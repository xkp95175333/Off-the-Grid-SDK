#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: G01

#include "Basic.hpp"

#include "Engine_structs.hpp"
#include "G01_structs.hpp"
#include "AIModule_structs.hpp"
#include "AnimGraphRuntime_structs.hpp"
#include "CoreUObject_structs.hpp"
#include "GameplayAbilities_structs.hpp"
#include "GameplayTags_structs.hpp"
#include "CommonInput_structs.hpp"
#include "XsollaStore_structs.hpp"
#include "AkAudio_structs.hpp"
#include "SlateCore_structs.hpp"
#include "EnhancedInput_structs.hpp"
#include "UnityMatchmaking_structs.hpp"
#include "InputCore_structs.hpp"
#include "PhysicsCore_structs.hpp"
#include "UMG_structs.hpp"
#include "MissionGraphRuntime_structs.hpp"
#include "NetCore_structs.hpp"


namespace SDK::Params
{

// Function G01.GzMoviePlayerModel.OnAkPostEventCallback
// 0x0010 (0x0010 - 0x0000)
struct GzMoviePlayerModel_OnAkPostEventCallback final
{
public:
	EAkCallbackType                               CallbackType;                                      // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C63[0x7];                                     // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UAkCallbackInfo*                        CallbackInfo;                                      // 0x0008(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzMoviePlayerModel_OnAkPostEventCallback) == 0x000008, "Wrong alignment on GzMoviePlayerModel_OnAkPostEventCallback");
static_assert(sizeof(GzMoviePlayerModel_OnAkPostEventCallback) == 0x000010, "Wrong size on GzMoviePlayerModel_OnAkPostEventCallback");
static_assert(offsetof(GzMoviePlayerModel_OnAkPostEventCallback, CallbackType) == 0x000000, "Member 'GzMoviePlayerModel_OnAkPostEventCallback::CallbackType' has a wrong offset!");
static_assert(offsetof(GzMoviePlayerModel_OnAkPostEventCallback, CallbackInfo) == 0x000008, "Member 'GzMoviePlayerModel_OnAkPostEventCallback::CallbackInfo' has a wrong offset!");

// Function G01.BlueprintLobbyHelpers.GetCVarsThatStartWith
// 0x0020 (0x0020 - 0x0000)
struct BlueprintLobbyHelpers_GetCVarsThatStartWith final
{
public:
	class FString                                 StartsWith;                                        // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class FString>                         CVars;                                             // 0x0010(0x0010)(Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(BlueprintLobbyHelpers_GetCVarsThatStartWith) == 0x000008, "Wrong alignment on BlueprintLobbyHelpers_GetCVarsThatStartWith");
static_assert(sizeof(BlueprintLobbyHelpers_GetCVarsThatStartWith) == 0x000020, "Wrong size on BlueprintLobbyHelpers_GetCVarsThatStartWith");
static_assert(offsetof(BlueprintLobbyHelpers_GetCVarsThatStartWith, StartsWith) == 0x000000, "Member 'BlueprintLobbyHelpers_GetCVarsThatStartWith::StartsWith' has a wrong offset!");
static_assert(offsetof(BlueprintLobbyHelpers_GetCVarsThatStartWith, CVars) == 0x000010, "Member 'BlueprintLobbyHelpers_GetCVarsThatStartWith::CVars' has a wrong offset!");

// Function G01.BlueprintLobbyHelpers.GetInputActions
// 0x0018 (0x0018 - 0x0000)
struct BlueprintLobbyHelpers_GetInputActions final
{
public:
	class APlayerController*                      PlayerController;                                  // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FInputActionKeyMapping>         ReturnValue;                                       // 0x0008(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(BlueprintLobbyHelpers_GetInputActions) == 0x000008, "Wrong alignment on BlueprintLobbyHelpers_GetInputActions");
static_assert(sizeof(BlueprintLobbyHelpers_GetInputActions) == 0x000018, "Wrong size on BlueprintLobbyHelpers_GetInputActions");
static_assert(offsetof(BlueprintLobbyHelpers_GetInputActions, PlayerController) == 0x000000, "Member 'BlueprintLobbyHelpers_GetInputActions::PlayerController' has a wrong offset!");
static_assert(offsetof(BlueprintLobbyHelpers_GetInputActions, ReturnValue) == 0x000008, "Member 'BlueprintLobbyHelpers_GetInputActions::ReturnValue' has a wrong offset!");

// Function G01.BlueprintLobbyHelpers.GetLocalIpAddress
// 0x0010 (0x0010 - 0x0000)
struct BlueprintLobbyHelpers_GetLocalIpAddress final
{
public:
	class FString                                 ReturnValue;                                       // 0x0000(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(BlueprintLobbyHelpers_GetLocalIpAddress) == 0x000008, "Wrong alignment on BlueprintLobbyHelpers_GetLocalIpAddress");
static_assert(sizeof(BlueprintLobbyHelpers_GetLocalIpAddress) == 0x000010, "Wrong size on BlueprintLobbyHelpers_GetLocalIpAddress");
static_assert(offsetof(BlueprintLobbyHelpers_GetLocalIpAddress, ReturnValue) == 0x000000, "Member 'BlueprintLobbyHelpers_GetLocalIpAddress::ReturnValue' has a wrong offset!");

// Function G01.BlueprintLobbyHelpers.ParseFloat
// 0x0018 (0x0018 - 0x0000)
struct BlueprintLobbyHelpers_ParseFloat final
{
public:
	class FString                                 String;                                            // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         OutValue;                                          // 0x0010(0x0004)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0014(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C6C[0x3];                                     // 0x0015(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(BlueprintLobbyHelpers_ParseFloat) == 0x000008, "Wrong alignment on BlueprintLobbyHelpers_ParseFloat");
static_assert(sizeof(BlueprintLobbyHelpers_ParseFloat) == 0x000018, "Wrong size on BlueprintLobbyHelpers_ParseFloat");
static_assert(offsetof(BlueprintLobbyHelpers_ParseFloat, String) == 0x000000, "Member 'BlueprintLobbyHelpers_ParseFloat::String' has a wrong offset!");
static_assert(offsetof(BlueprintLobbyHelpers_ParseFloat, OutValue) == 0x000010, "Member 'BlueprintLobbyHelpers_ParseFloat::OutValue' has a wrong offset!");
static_assert(offsetof(BlueprintLobbyHelpers_ParseFloat, ReturnValue) == 0x000014, "Member 'BlueprintLobbyHelpers_ParseFloat::ReturnValue' has a wrong offset!");

// Function G01.BlueprintLobbyHelpers.ParseInt
// 0x0018 (0x0018 - 0x0000)
struct BlueprintLobbyHelpers_ParseInt final
{
public:
	class FString                                 String;                                            // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         OutValue;                                          // 0x0010(0x0004)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0014(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C6D[0x3];                                     // 0x0015(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(BlueprintLobbyHelpers_ParseInt) == 0x000008, "Wrong alignment on BlueprintLobbyHelpers_ParseInt");
static_assert(sizeof(BlueprintLobbyHelpers_ParseInt) == 0x000018, "Wrong size on BlueprintLobbyHelpers_ParseInt");
static_assert(offsetof(BlueprintLobbyHelpers_ParseInt, String) == 0x000000, "Member 'BlueprintLobbyHelpers_ParseInt::String' has a wrong offset!");
static_assert(offsetof(BlueprintLobbyHelpers_ParseInt, OutValue) == 0x000010, "Member 'BlueprintLobbyHelpers_ParseInt::OutValue' has a wrong offset!");
static_assert(offsetof(BlueprintLobbyHelpers_ParseInt, ReturnValue) == 0x000014, "Member 'BlueprintLobbyHelpers_ParseInt::ReturnValue' has a wrong offset!");

// Function G01.BlueprintLobbyHelpers.ParseIpV4
// 0x0018 (0x0018 - 0x0000)
struct BlueprintLobbyHelpers_ParseIpV4 final
{
public:
	class FString                                 String;                                            // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         A;                                                 // 0x0010(0x0001)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         B;                                                 // 0x0011(0x0001)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         C;                                                 // 0x0012(0x0001)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         D;                                                 // 0x0013(0x0001)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0014(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C6E[0x3];                                     // 0x0015(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(BlueprintLobbyHelpers_ParseIpV4) == 0x000008, "Wrong alignment on BlueprintLobbyHelpers_ParseIpV4");
static_assert(sizeof(BlueprintLobbyHelpers_ParseIpV4) == 0x000018, "Wrong size on BlueprintLobbyHelpers_ParseIpV4");
static_assert(offsetof(BlueprintLobbyHelpers_ParseIpV4, String) == 0x000000, "Member 'BlueprintLobbyHelpers_ParseIpV4::String' has a wrong offset!");
static_assert(offsetof(BlueprintLobbyHelpers_ParseIpV4, A) == 0x000010, "Member 'BlueprintLobbyHelpers_ParseIpV4::A' has a wrong offset!");
static_assert(offsetof(BlueprintLobbyHelpers_ParseIpV4, B) == 0x000011, "Member 'BlueprintLobbyHelpers_ParseIpV4::B' has a wrong offset!");
static_assert(offsetof(BlueprintLobbyHelpers_ParseIpV4, C) == 0x000012, "Member 'BlueprintLobbyHelpers_ParseIpV4::C' has a wrong offset!");
static_assert(offsetof(BlueprintLobbyHelpers_ParseIpV4, D) == 0x000013, "Member 'BlueprintLobbyHelpers_ParseIpV4::D' has a wrong offset!");
static_assert(offsetof(BlueprintLobbyHelpers_ParseIpV4, ReturnValue) == 0x000014, "Member 'BlueprintLobbyHelpers_ParseIpV4::ReturnValue' has a wrong offset!");

// Function G01.GzWaterMesh.OnBeginOverlap
// 0x0118 (0x0118 - 0x0000)
struct GzWaterMesh_OnBeginOverlap final
{
public:
	class UPrimitiveComponent*                    OverlappedComponent;                               // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 OtherActor;                                        // 0x0008(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UPrimitiveComponent*                    OtherComp;                                         // 0x0010(0x0008)(Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         OtherBodyIndex;                                    // 0x0018(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bFromSweep;                                        // 0x001C(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C6F[0x3];                                     // 0x001D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FHitResult                             SweepResult;                                       // 0x0020(0x00F8)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzWaterMesh_OnBeginOverlap) == 0x000008, "Wrong alignment on GzWaterMesh_OnBeginOverlap");
static_assert(sizeof(GzWaterMesh_OnBeginOverlap) == 0x000118, "Wrong size on GzWaterMesh_OnBeginOverlap");
static_assert(offsetof(GzWaterMesh_OnBeginOverlap, OverlappedComponent) == 0x000000, "Member 'GzWaterMesh_OnBeginOverlap::OverlappedComponent' has a wrong offset!");
static_assert(offsetof(GzWaterMesh_OnBeginOverlap, OtherActor) == 0x000008, "Member 'GzWaterMesh_OnBeginOverlap::OtherActor' has a wrong offset!");
static_assert(offsetof(GzWaterMesh_OnBeginOverlap, OtherComp) == 0x000010, "Member 'GzWaterMesh_OnBeginOverlap::OtherComp' has a wrong offset!");
static_assert(offsetof(GzWaterMesh_OnBeginOverlap, OtherBodyIndex) == 0x000018, "Member 'GzWaterMesh_OnBeginOverlap::OtherBodyIndex' has a wrong offset!");
static_assert(offsetof(GzWaterMesh_OnBeginOverlap, bFromSweep) == 0x00001C, "Member 'GzWaterMesh_OnBeginOverlap::bFromSweep' has a wrong offset!");
static_assert(offsetof(GzWaterMesh_OnBeginOverlap, SweepResult) == 0x000020, "Member 'GzWaterMesh_OnBeginOverlap::SweepResult' has a wrong offset!");

// Function G01.GzWaterMesh.OnEndOverlap
// 0x0020 (0x0020 - 0x0000)
struct GzWaterMesh_OnEndOverlap final
{
public:
	class UPrimitiveComponent*                    OverlappedComponent;                               // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 OtherActor;                                        // 0x0008(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UPrimitiveComponent*                    OtherComp;                                         // 0x0010(0x0008)(Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         OtherBodyIndex;                                    // 0x0018(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C70[0x4];                                     // 0x001C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GzWaterMesh_OnEndOverlap) == 0x000008, "Wrong alignment on GzWaterMesh_OnEndOverlap");
static_assert(sizeof(GzWaterMesh_OnEndOverlap) == 0x000020, "Wrong size on GzWaterMesh_OnEndOverlap");
static_assert(offsetof(GzWaterMesh_OnEndOverlap, OverlappedComponent) == 0x000000, "Member 'GzWaterMesh_OnEndOverlap::OverlappedComponent' has a wrong offset!");
static_assert(offsetof(GzWaterMesh_OnEndOverlap, OtherActor) == 0x000008, "Member 'GzWaterMesh_OnEndOverlap::OtherActor' has a wrong offset!");
static_assert(offsetof(GzWaterMesh_OnEndOverlap, OtherComp) == 0x000010, "Member 'GzWaterMesh_OnEndOverlap::OtherComp' has a wrong offset!");
static_assert(offsetof(GzWaterMesh_OnEndOverlap, OtherBodyIndex) == 0x000018, "Member 'GzWaterMesh_OnEndOverlap::OtherBodyIndex' has a wrong offset!");

// Function G01.GzGameplayAbility.ApplyAbilityCameraMode
// 0x000C (0x000C - 0x0000)
struct GzGameplayAbility_ApplyAbilityCameraMode final
{
public:
	struct FGameplayTag                           CameraModeTag;                                     // 0x0000(0x0008)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDeactivatePreviousAbilityCameraMode;              // 0x0008(0x0001)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C78[0x3];                                     // 0x0009(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GzGameplayAbility_ApplyAbilityCameraMode) == 0x000004, "Wrong alignment on GzGameplayAbility_ApplyAbilityCameraMode");
static_assert(sizeof(GzGameplayAbility_ApplyAbilityCameraMode) == 0x00000C, "Wrong size on GzGameplayAbility_ApplyAbilityCameraMode");
static_assert(offsetof(GzGameplayAbility_ApplyAbilityCameraMode, CameraModeTag) == 0x000000, "Member 'GzGameplayAbility_ApplyAbilityCameraMode::CameraModeTag' has a wrong offset!");
static_assert(offsetof(GzGameplayAbility_ApplyAbilityCameraMode, bDeactivatePreviousAbilityCameraMode) == 0x000008, "Member 'GzGameplayAbility_ApplyAbilityCameraMode::bDeactivatePreviousAbilityCameraMode' has a wrong offset!");

// Function G01.GzGameplayAbility.ApplyEffectContainerSpec
// 0x0048 (0x0048 - 0x0000)
struct GzGameplayAbility_ApplyEffectContainerSpec final
{
public:
	struct FGzGameplayEffectContainerSpec         ContainerSpec;                                     // 0x0000(0x0038)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	TArray<struct FActiveGameplayEffectHandle>    ReturnValue;                                       // 0x0038(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzGameplayAbility_ApplyEffectContainerSpec) == 0x000008, "Wrong alignment on GzGameplayAbility_ApplyEffectContainerSpec");
static_assert(sizeof(GzGameplayAbility_ApplyEffectContainerSpec) == 0x000048, "Wrong size on GzGameplayAbility_ApplyEffectContainerSpec");
static_assert(offsetof(GzGameplayAbility_ApplyEffectContainerSpec, ContainerSpec) == 0x000000, "Member 'GzGameplayAbility_ApplyEffectContainerSpec::ContainerSpec' has a wrong offset!");
static_assert(offsetof(GzGameplayAbility_ApplyEffectContainerSpec, ReturnValue) == 0x000038, "Member 'GzGameplayAbility_ApplyEffectContainerSpec::ReturnValue' has a wrong offset!");

// Function G01.GzGameplayAbility.BP_CanActivateAbility
// 0x0010 (0x0010 - 0x0000)
struct GzGameplayAbility_BP_CanActivateAbility final
{
public:
	const class AGzCharacter*                     Instigator;                                        // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C79[0x7];                                     // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GzGameplayAbility_BP_CanActivateAbility) == 0x000008, "Wrong alignment on GzGameplayAbility_BP_CanActivateAbility");
static_assert(sizeof(GzGameplayAbility_BP_CanActivateAbility) == 0x000010, "Wrong size on GzGameplayAbility_BP_CanActivateAbility");
static_assert(offsetof(GzGameplayAbility_BP_CanActivateAbility, Instigator) == 0x000000, "Member 'GzGameplayAbility_BP_CanActivateAbility::Instigator' has a wrong offset!");
static_assert(offsetof(GzGameplayAbility_BP_CanActivateAbility, ReturnValue) == 0x000008, "Member 'GzGameplayAbility_BP_CanActivateAbility::ReturnValue' has a wrong offset!");

// Function G01.GzGameplayAbility.DoesSatisfyTagRequirements_BP
// 0x0001 (0x0001 - 0x0000)
struct GzGameplayAbility_DoesSatisfyTagRequirements_BP final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzGameplayAbility_DoesSatisfyTagRequirements_BP) == 0x000001, "Wrong alignment on GzGameplayAbility_DoesSatisfyTagRequirements_BP");
static_assert(sizeof(GzGameplayAbility_DoesSatisfyTagRequirements_BP) == 0x000001, "Wrong size on GzGameplayAbility_DoesSatisfyTagRequirements_BP");
static_assert(offsetof(GzGameplayAbility_DoesSatisfyTagRequirements_BP, ReturnValue) == 0x000000, "Member 'GzGameplayAbility_DoesSatisfyTagRequirements_BP::ReturnValue' has a wrong offset!");

// Function G01.GzGameplayAbility.MakeEffectContainerSpecFromContainer
// 0x0108 (0x0108 - 0x0000)
struct GzGameplayAbility_MakeEffectContainerSpecFromContainer final
{
public:
	struct FGzGameplayEffectContainer             Container;                                         // 0x0000(0x0018)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	struct FGameplayEventData                     EventData;                                         // 0x0018(0x00B0)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	int32                                         OverrideGameplayLevel;                             // 0x00C8(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C7A[0x4];                                     // 0x00CC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGzGameplayEffectContainerSpec         ReturnValue;                                       // 0x00D0(0x0038)(Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzGameplayAbility_MakeEffectContainerSpecFromContainer) == 0x000008, "Wrong alignment on GzGameplayAbility_MakeEffectContainerSpecFromContainer");
static_assert(sizeof(GzGameplayAbility_MakeEffectContainerSpecFromContainer) == 0x000108, "Wrong size on GzGameplayAbility_MakeEffectContainerSpecFromContainer");
static_assert(offsetof(GzGameplayAbility_MakeEffectContainerSpecFromContainer, Container) == 0x000000, "Member 'GzGameplayAbility_MakeEffectContainerSpecFromContainer::Container' has a wrong offset!");
static_assert(offsetof(GzGameplayAbility_MakeEffectContainerSpecFromContainer, EventData) == 0x000018, "Member 'GzGameplayAbility_MakeEffectContainerSpecFromContainer::EventData' has a wrong offset!");
static_assert(offsetof(GzGameplayAbility_MakeEffectContainerSpecFromContainer, OverrideGameplayLevel) == 0x0000C8, "Member 'GzGameplayAbility_MakeEffectContainerSpecFromContainer::OverrideGameplayLevel' has a wrong offset!");
static_assert(offsetof(GzGameplayAbility_MakeEffectContainerSpecFromContainer, ReturnValue) == 0x0000D0, "Member 'GzGameplayAbility_MakeEffectContainerSpecFromContainer::ReturnValue' has a wrong offset!");

// Function G01.GzGameplayAbility.MakeGameplayAbilityTargetDataHandleFromActorArray
// 0x0038 (0x0038 - 0x0000)
struct GzGameplayAbility_MakeGameplayAbilityTargetDataHandleFromActorArray final
{
public:
	TArray<class AActor*>                         TargetActors;                                      // 0x0000(0x0010)(ConstParm, Parm, ZeroConstructor, NativeAccessSpecifierPublic)
	struct FGameplayAbilityTargetDataHandle       ReturnValue;                                       // 0x0010(0x0028)(Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzGameplayAbility_MakeGameplayAbilityTargetDataHandleFromActorArray) == 0x000008, "Wrong alignment on GzGameplayAbility_MakeGameplayAbilityTargetDataHandleFromActorArray");
static_assert(sizeof(GzGameplayAbility_MakeGameplayAbilityTargetDataHandleFromActorArray) == 0x000038, "Wrong size on GzGameplayAbility_MakeGameplayAbilityTargetDataHandleFromActorArray");
static_assert(offsetof(GzGameplayAbility_MakeGameplayAbilityTargetDataHandleFromActorArray, TargetActors) == 0x000000, "Member 'GzGameplayAbility_MakeGameplayAbilityTargetDataHandleFromActorArray::TargetActors' has a wrong offset!");
static_assert(offsetof(GzGameplayAbility_MakeGameplayAbilityTargetDataHandleFromActorArray, ReturnValue) == 0x000010, "Member 'GzGameplayAbility_MakeGameplayAbilityTargetDataHandleFromActorArray::ReturnValue' has a wrong offset!");

// Function G01.GzGameplayAbility.MakeGameplayAbilityTargetDataHandleFromHitResults
// 0x0038 (0x0038 - 0x0000)
struct GzGameplayAbility_MakeGameplayAbilityTargetDataHandleFromHitResults final
{
public:
	TArray<struct FHitResult>                     HitResults;                                        // 0x0000(0x0010)(ConstParm, Parm, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FGameplayAbilityTargetDataHandle       ReturnValue;                                       // 0x0010(0x0028)(Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzGameplayAbility_MakeGameplayAbilityTargetDataHandleFromHitResults) == 0x000008, "Wrong alignment on GzGameplayAbility_MakeGameplayAbilityTargetDataHandleFromHitResults");
static_assert(sizeof(GzGameplayAbility_MakeGameplayAbilityTargetDataHandleFromHitResults) == 0x000038, "Wrong size on GzGameplayAbility_MakeGameplayAbilityTargetDataHandleFromHitResults");
static_assert(offsetof(GzGameplayAbility_MakeGameplayAbilityTargetDataHandleFromHitResults, HitResults) == 0x000000, "Member 'GzGameplayAbility_MakeGameplayAbilityTargetDataHandleFromHitResults::HitResults' has a wrong offset!");
static_assert(offsetof(GzGameplayAbility_MakeGameplayAbilityTargetDataHandleFromHitResults, ReturnValue) == 0x000010, "Member 'GzGameplayAbility_MakeGameplayAbilityTargetDataHandleFromHitResults::ReturnValue' has a wrong offset!");

// Function G01.GzGameplayAbility.ProcessPostEndAbilityTasks
// 0x0001 (0x0001 - 0x0000)
struct GzGameplayAbility_ProcessPostEndAbilityTasks final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzGameplayAbility_ProcessPostEndAbilityTasks) == 0x000001, "Wrong alignment on GzGameplayAbility_ProcessPostEndAbilityTasks");
static_assert(sizeof(GzGameplayAbility_ProcessPostEndAbilityTasks) == 0x000001, "Wrong size on GzGameplayAbility_ProcessPostEndAbilityTasks");
static_assert(offsetof(GzGameplayAbility_ProcessPostEndAbilityTasks, ReturnValue) == 0x000000, "Member 'GzGameplayAbility_ProcessPostEndAbilityTasks::ReturnValue' has a wrong offset!");

// Function G01.GzGameplayAbility.RemoveAbilityCameraMode
// 0x0008 (0x0008 - 0x0000)
struct GzGameplayAbility_RemoveAbilityCameraMode final
{
public:
	struct FGameplayTag                           CameraModeTag;                                     // 0x0000(0x0008)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzGameplayAbility_RemoveAbilityCameraMode) == 0x000004, "Wrong alignment on GzGameplayAbility_RemoveAbilityCameraMode");
static_assert(sizeof(GzGameplayAbility_RemoveAbilityCameraMode) == 0x000008, "Wrong size on GzGameplayAbility_RemoveAbilityCameraMode");
static_assert(offsetof(GzGameplayAbility_RemoveAbilityCameraMode, CameraModeTag) == 0x000000, "Member 'GzGameplayAbility_RemoveAbilityCameraMode::CameraModeTag' has a wrong offset!");

// Function G01.GzGameplayAbility.SendTargetDataToServer
// 0x0028 (0x0028 - 0x0000)
struct GzGameplayAbility_SendTargetDataToServer final
{
public:
	struct FGameplayAbilityTargetDataHandle       TargetData;                                        // 0x0000(0x0028)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzGameplayAbility_SendTargetDataToServer) == 0x000008, "Wrong alignment on GzGameplayAbility_SendTargetDataToServer");
static_assert(sizeof(GzGameplayAbility_SendTargetDataToServer) == 0x000028, "Wrong size on GzGameplayAbility_SendTargetDataToServer");
static_assert(offsetof(GzGameplayAbility_SendTargetDataToServer, TargetData) == 0x000000, "Member 'GzGameplayAbility_SendTargetDataToServer::TargetData' has a wrong offset!");

// Function G01.GzGameplayAbility.BP_IsActive
// 0x0001 (0x0001 - 0x0000)
struct GzGameplayAbility_BP_IsActive final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzGameplayAbility_BP_IsActive) == 0x000001, "Wrong alignment on GzGameplayAbility_BP_IsActive");
static_assert(sizeof(GzGameplayAbility_BP_IsActive) == 0x000001, "Wrong size on GzGameplayAbility_BP_IsActive");
static_assert(offsetof(GzGameplayAbility_BP_IsActive, ReturnValue) == 0x000000, "Member 'GzGameplayAbility_BP_IsActive::ReturnValue' has a wrong offset!");

// Function G01.GzGameplayAbility.CanBindToInputEvents
// 0x0001 (0x0001 - 0x0000)
struct GzGameplayAbility_CanBindToInputEvents final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzGameplayAbility_CanBindToInputEvents) == 0x000001, "Wrong alignment on GzGameplayAbility_CanBindToInputEvents");
static_assert(sizeof(GzGameplayAbility_CanBindToInputEvents) == 0x000001, "Wrong size on GzGameplayAbility_CanBindToInputEvents");
static_assert(offsetof(GzGameplayAbility_CanBindToInputEvents, ReturnValue) == 0x000000, "Member 'GzGameplayAbility_CanBindToInputEvents::ReturnValue' has a wrong offset!");

// Function G01.GzGameplayAbility.GetAbilityWidgetClass
// 0x0008 (0x0008 - 0x0000)
struct GzGameplayAbility_GetAbilityWidgetClass final
{
public:
	TSubclassOf<class UUserWidget>                ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzGameplayAbility_GetAbilityWidgetClass) == 0x000008, "Wrong alignment on GzGameplayAbility_GetAbilityWidgetClass");
static_assert(sizeof(GzGameplayAbility_GetAbilityWidgetClass) == 0x000008, "Wrong size on GzGameplayAbility_GetAbilityWidgetClass");
static_assert(offsetof(GzGameplayAbility_GetAbilityWidgetClass, ReturnValue) == 0x000000, "Member 'GzGameplayAbility_GetAbilityWidgetClass::ReturnValue' has a wrong offset!");

// Function G01.GzGameplayAbility.GetActivationOwnedTags
// 0x0020 (0x0020 - 0x0000)
struct GzGameplayAbility_GetActivationOwnedTags final
{
public:
	struct FGameplayTagContainer                  ReturnValue;                                       // 0x0000(0x0020)(ConstParm, Parm, OutParm, ReturnParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzGameplayAbility_GetActivationOwnedTags) == 0x000008, "Wrong alignment on GzGameplayAbility_GetActivationOwnedTags");
static_assert(sizeof(GzGameplayAbility_GetActivationOwnedTags) == 0x000020, "Wrong size on GzGameplayAbility_GetActivationOwnedTags");
static_assert(offsetof(GzGameplayAbility_GetActivationOwnedTags, ReturnValue) == 0x000000, "Member 'GzGameplayAbility_GetActivationOwnedTags::ReturnValue' has a wrong offset!");

// Function G01.GzGameplayAbility.GetCurrentPredictionKeyStatus
// 0x0010 (0x0010 - 0x0000)
struct GzGameplayAbility_GetCurrentPredictionKeyStatus final
{
public:
	class FString                                 ReturnValue;                                       // 0x0000(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzGameplayAbility_GetCurrentPredictionKeyStatus) == 0x000008, "Wrong alignment on GzGameplayAbility_GetCurrentPredictionKeyStatus");
static_assert(sizeof(GzGameplayAbility_GetCurrentPredictionKeyStatus) == 0x000010, "Wrong size on GzGameplayAbility_GetCurrentPredictionKeyStatus");
static_assert(offsetof(GzGameplayAbility_GetCurrentPredictionKeyStatus, ReturnValue) == 0x000000, "Member 'GzGameplayAbility_GetCurrentPredictionKeyStatus::ReturnValue' has a wrong offset!");

// Function G01.GzGameplayAbility.GetGzAbilitySystemComponentFromActorInfo
// 0x0008 (0x0008 - 0x0000)
struct GzGameplayAbility_GetGzAbilitySystemComponentFromActorInfo final
{
public:
	class UGzAbilitySystemComponent*              ReturnValue;                                       // 0x0000(0x0008)(ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzGameplayAbility_GetGzAbilitySystemComponentFromActorInfo) == 0x000008, "Wrong alignment on GzGameplayAbility_GetGzAbilitySystemComponentFromActorInfo");
static_assert(sizeof(GzGameplayAbility_GetGzAbilitySystemComponentFromActorInfo) == 0x000008, "Wrong size on GzGameplayAbility_GetGzAbilitySystemComponentFromActorInfo");
static_assert(offsetof(GzGameplayAbility_GetGzAbilitySystemComponentFromActorInfo, ReturnValue) == 0x000000, "Member 'GzGameplayAbility_GetGzAbilitySystemComponentFromActorInfo::ReturnValue' has a wrong offset!");

// Function G01.GzGameplayAbility.GetOwningCharacter
// 0x0008 (0x0008 - 0x0000)
struct GzGameplayAbility_GetOwningCharacter final
{
public:
	class AGzCharacter*                           ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzGameplayAbility_GetOwningCharacter) == 0x000008, "Wrong alignment on GzGameplayAbility_GetOwningCharacter");
static_assert(sizeof(GzGameplayAbility_GetOwningCharacter) == 0x000008, "Wrong size on GzGameplayAbility_GetOwningCharacter");
static_assert(offsetof(GzGameplayAbility_GetOwningCharacter, ReturnValue) == 0x000000, "Member 'GzGameplayAbility_GetOwningCharacter::ReturnValue' has a wrong offset!");

// Function G01.GzGameplayAbility.GzApplyCost
// 0x0068 (0x0068 - 0x0000)
struct GzGameplayAbility_GzApplyCost final
{
public:
	struct FGameplayAbilitySpecHandle             Handle;                                            // 0x0000(0x0004)(ConstParm, Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C7B[0x4];                                     // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayAbilityActorInfo              ActorInfo;                                         // 0x0008(0x0048)(ConstParm, Parm, OutParm, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FGameplayAbilityActivationInfo         ActivationInfo;                                    // 0x0050(0x0018)(ConstParm, Parm, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzGameplayAbility_GzApplyCost) == 0x000008, "Wrong alignment on GzGameplayAbility_GzApplyCost");
static_assert(sizeof(GzGameplayAbility_GzApplyCost) == 0x000068, "Wrong size on GzGameplayAbility_GzApplyCost");
static_assert(offsetof(GzGameplayAbility_GzApplyCost, Handle) == 0x000000, "Member 'GzGameplayAbility_GzApplyCost::Handle' has a wrong offset!");
static_assert(offsetof(GzGameplayAbility_GzApplyCost, ActorInfo) == 0x000008, "Member 'GzGameplayAbility_GzApplyCost::ActorInfo' has a wrong offset!");
static_assert(offsetof(GzGameplayAbility_GzApplyCost, ActivationInfo) == 0x000050, "Member 'GzGameplayAbility_GzApplyCost::ActivationInfo' has a wrong offset!");

// Function G01.GzGameplayAbility.GzCheckCost
// 0x0058 (0x0058 - 0x0000)
struct GzGameplayAbility_GzCheckCost final
{
public:
	struct FGameplayAbilitySpecHandle             Handle;                                            // 0x0000(0x0004)(ConstParm, Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C7C[0x4];                                     // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayAbilityActorInfo              ActorInfo;                                         // 0x0008(0x0048)(ConstParm, Parm, OutParm, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0050(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C7D[0x7];                                     // 0x0051(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GzGameplayAbility_GzCheckCost) == 0x000008, "Wrong alignment on GzGameplayAbility_GzCheckCost");
static_assert(sizeof(GzGameplayAbility_GzCheckCost) == 0x000058, "Wrong size on GzGameplayAbility_GzCheckCost");
static_assert(offsetof(GzGameplayAbility_GzCheckCost, Handle) == 0x000000, "Member 'GzGameplayAbility_GzCheckCost::Handle' has a wrong offset!");
static_assert(offsetof(GzGameplayAbility_GzCheckCost, ActorInfo) == 0x000008, "Member 'GzGameplayAbility_GzCheckCost::ActorInfo' has a wrong offset!");
static_assert(offsetof(GzGameplayAbility_GzCheckCost, ReturnValue) == 0x000050, "Member 'GzGameplayAbility_GzCheckCost::ReturnValue' has a wrong offset!");

// Function G01.GzGameplayAbility.HasAbilityCameraMode
// 0x000C (0x000C - 0x0000)
struct GzGameplayAbility_HasAbilityCameraMode final
{
public:
	struct FGameplayTag                           CameraModeTag;                                     // 0x0000(0x0008)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C7E[0x3];                                     // 0x0009(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GzGameplayAbility_HasAbilityCameraMode) == 0x000004, "Wrong alignment on GzGameplayAbility_HasAbilityCameraMode");
static_assert(sizeof(GzGameplayAbility_HasAbilityCameraMode) == 0x00000C, "Wrong size on GzGameplayAbility_HasAbilityCameraMode");
static_assert(offsetof(GzGameplayAbility_HasAbilityCameraMode, CameraModeTag) == 0x000000, "Member 'GzGameplayAbility_HasAbilityCameraMode::CameraModeTag' has a wrong offset!");
static_assert(offsetof(GzGameplayAbility_HasAbilityCameraMode, ReturnValue) == 0x000008, "Member 'GzGameplayAbility_HasAbilityCameraMode::ReturnValue' has a wrong offset!");

// Function G01.GzGameplayAbility.IsNotAuthorityOrStandalone
// 0x0001 (0x0001 - 0x0000)
struct GzGameplayAbility_IsNotAuthorityOrStandalone final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzGameplayAbility_IsNotAuthorityOrStandalone) == 0x000001, "Wrong alignment on GzGameplayAbility_IsNotAuthorityOrStandalone");
static_assert(sizeof(GzGameplayAbility_IsNotAuthorityOrStandalone) == 0x000001, "Wrong size on GzGameplayAbility_IsNotAuthorityOrStandalone");
static_assert(offsetof(GzGameplayAbility_IsNotAuthorityOrStandalone, ReturnValue) == 0x000000, "Member 'GzGameplayAbility_IsNotAuthorityOrStandalone::ReturnValue' has a wrong offset!");

// Function G01.GzGameplayAbility.IsPredictionKeyValidForMorePrediction
// 0x0001 (0x0001 - 0x0000)
struct GzGameplayAbility_IsPredictionKeyValidForMorePrediction final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzGameplayAbility_IsPredictionKeyValidForMorePrediction) == 0x000001, "Wrong alignment on GzGameplayAbility_IsPredictionKeyValidForMorePrediction");
static_assert(sizeof(GzGameplayAbility_IsPredictionKeyValidForMorePrediction) == 0x000001, "Wrong size on GzGameplayAbility_IsPredictionKeyValidForMorePrediction");
static_assert(offsetof(GzGameplayAbility_IsPredictionKeyValidForMorePrediction, ReturnValue) == 0x000000, "Member 'GzGameplayAbility_IsPredictionKeyValidForMorePrediction::ReturnValue' has a wrong offset!");

// Function G01.GzGameplayAbility.K2_GetSourceObject
// 0x0058 (0x0058 - 0x0000)
struct GzGameplayAbility_K2_GetSourceObject final
{
public:
	struct FGameplayAbilitySpecHandle             Handle;                                            // 0x0000(0x0004)(Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C7F[0x4];                                     // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayAbilityActorInfo              ActorInfo;                                         // 0x0008(0x0048)(ConstParm, Parm, OutParm, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
	class UObject*                                ReturnValue;                                       // 0x0050(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzGameplayAbility_K2_GetSourceObject) == 0x000008, "Wrong alignment on GzGameplayAbility_K2_GetSourceObject");
static_assert(sizeof(GzGameplayAbility_K2_GetSourceObject) == 0x000058, "Wrong size on GzGameplayAbility_K2_GetSourceObject");
static_assert(offsetof(GzGameplayAbility_K2_GetSourceObject, Handle) == 0x000000, "Member 'GzGameplayAbility_K2_GetSourceObject::Handle' has a wrong offset!");
static_assert(offsetof(GzGameplayAbility_K2_GetSourceObject, ActorInfo) == 0x000008, "Member 'GzGameplayAbility_K2_GetSourceObject::ActorInfo' has a wrong offset!");
static_assert(offsetof(GzGameplayAbility_K2_GetSourceObject, ReturnValue) == 0x000050, "Member 'GzGameplayAbility_K2_GetSourceObject::ReturnValue' has a wrong offset!");

// Function G01.GzGA_CharacterState.OnMovementModeChange
// 0x0010 (0x0010 - 0x0000)
struct GzGA_CharacterState_OnMovementModeChange final
{
public:
	class ACharacter*                             Character;                                         // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EMovementMode                                 PrevMovementMode;                                  // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         PreviousCustomMode;                                // 0x0009(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C81[0x6];                                     // 0x000A(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GzGA_CharacterState_OnMovementModeChange) == 0x000008, "Wrong alignment on GzGA_CharacterState_OnMovementModeChange");
static_assert(sizeof(GzGA_CharacterState_OnMovementModeChange) == 0x000010, "Wrong size on GzGA_CharacterState_OnMovementModeChange");
static_assert(offsetof(GzGA_CharacterState_OnMovementModeChange, Character) == 0x000000, "Member 'GzGA_CharacterState_OnMovementModeChange::Character' has a wrong offset!");
static_assert(offsetof(GzGA_CharacterState_OnMovementModeChange, PrevMovementMode) == 0x000008, "Member 'GzGA_CharacterState_OnMovementModeChange::PrevMovementMode' has a wrong offset!");
static_assert(offsetof(GzGA_CharacterState_OnMovementModeChange, PreviousCustomMode) == 0x000009, "Member 'GzGA_CharacterState_OnMovementModeChange::PreviousCustomMode' has a wrong offset!");

// Function G01.GzGA_BaseLimbAbility.AddAbilityStateTag
// 0x000C (0x000C - 0x0000)
struct GzGA_BaseLimbAbility_AddAbilityStateTag final
{
public:
	struct FGameplayTag                           Tag;                                               // 0x0000(0x0008)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bReplicate;                                        // 0x0008(0x0001)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C8A[0x3];                                     // 0x0009(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GzGA_BaseLimbAbility_AddAbilityStateTag) == 0x000004, "Wrong alignment on GzGA_BaseLimbAbility_AddAbilityStateTag");
static_assert(sizeof(GzGA_BaseLimbAbility_AddAbilityStateTag) == 0x00000C, "Wrong size on GzGA_BaseLimbAbility_AddAbilityStateTag");
static_assert(offsetof(GzGA_BaseLimbAbility_AddAbilityStateTag, Tag) == 0x000000, "Member 'GzGA_BaseLimbAbility_AddAbilityStateTag::Tag' has a wrong offset!");
static_assert(offsetof(GzGA_BaseLimbAbility_AddAbilityStateTag, bReplicate) == 0x000008, "Member 'GzGA_BaseLimbAbility_AddAbilityStateTag::bReplicate' has a wrong offset!");

// Function G01.GzGA_BaseLimbAbility.CancelAbilityAfterInput
// 0x0004 (0x0004 - 0x0000)
struct GzGA_BaseLimbAbility_CancelAbilityAfterInput final
{
public:
	float                                         TimeWaited;                                        // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzGA_BaseLimbAbility_CancelAbilityAfterInput) == 0x000004, "Wrong alignment on GzGA_BaseLimbAbility_CancelAbilityAfterInput");
static_assert(sizeof(GzGA_BaseLimbAbility_CancelAbilityAfterInput) == 0x000004, "Wrong size on GzGA_BaseLimbAbility_CancelAbilityAfterInput");
static_assert(offsetof(GzGA_BaseLimbAbility_CancelAbilityAfterInput, TimeWaited) == 0x000000, "Member 'GzGA_BaseLimbAbility_CancelAbilityAfterInput::TimeWaited' has a wrong offset!");

// Function G01.GzGA_BaseLimbAbility.OnChargesAttributeChanged
// 0x0040 (0x0040 - 0x0000)
struct GzGA_BaseLimbAbility_OnChargesAttributeChanged final
{
public:
	struct FGameplayAttribute                     Attribute;                                         // 0x0000(0x0038)(Parm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         NewValue;                                          // 0x0038(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         OldValue;                                          // 0x003C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzGA_BaseLimbAbility_OnChargesAttributeChanged) == 0x000008, "Wrong alignment on GzGA_BaseLimbAbility_OnChargesAttributeChanged");
static_assert(sizeof(GzGA_BaseLimbAbility_OnChargesAttributeChanged) == 0x000040, "Wrong size on GzGA_BaseLimbAbility_OnChargesAttributeChanged");
static_assert(offsetof(GzGA_BaseLimbAbility_OnChargesAttributeChanged, Attribute) == 0x000000, "Member 'GzGA_BaseLimbAbility_OnChargesAttributeChanged::Attribute' has a wrong offset!");
static_assert(offsetof(GzGA_BaseLimbAbility_OnChargesAttributeChanged, NewValue) == 0x000038, "Member 'GzGA_BaseLimbAbility_OnChargesAttributeChanged::NewValue' has a wrong offset!");
static_assert(offsetof(GzGA_BaseLimbAbility_OnChargesAttributeChanged, OldValue) == 0x00003C, "Member 'GzGA_BaseLimbAbility_OnChargesAttributeChanged::OldValue' has a wrong offset!");

// Function G01.GzGA_BaseLimbAbility.PlayAnimEffect
// 0x0008 (0x0008 - 0x0000)
struct GzGA_BaseLimbAbility_PlayAnimEffect final
{
public:
	class UAnimMontage*                           Effect;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzGA_BaseLimbAbility_PlayAnimEffect) == 0x000008, "Wrong alignment on GzGA_BaseLimbAbility_PlayAnimEffect");
static_assert(sizeof(GzGA_BaseLimbAbility_PlayAnimEffect) == 0x000008, "Wrong size on GzGA_BaseLimbAbility_PlayAnimEffect");
static_assert(offsetof(GzGA_BaseLimbAbility_PlayAnimEffect, Effect) == 0x000000, "Member 'GzGA_BaseLimbAbility_PlayAnimEffect::Effect' has a wrong offset!");

// Function G01.GzGA_BaseLimbAbility.RemoveAbilityStateTag
// 0x000C (0x000C - 0x0000)
struct GzGA_BaseLimbAbility_RemoveAbilityStateTag final
{
public:
	struct FGameplayTag                           Tag;                                               // 0x0000(0x0008)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bReplicate;                                        // 0x0008(0x0001)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C8B[0x3];                                     // 0x0009(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GzGA_BaseLimbAbility_RemoveAbilityStateTag) == 0x000004, "Wrong alignment on GzGA_BaseLimbAbility_RemoveAbilityStateTag");
static_assert(sizeof(GzGA_BaseLimbAbility_RemoveAbilityStateTag) == 0x00000C, "Wrong size on GzGA_BaseLimbAbility_RemoveAbilityStateTag");
static_assert(offsetof(GzGA_BaseLimbAbility_RemoveAbilityStateTag, Tag) == 0x000000, "Member 'GzGA_BaseLimbAbility_RemoveAbilityStateTag::Tag' has a wrong offset!");
static_assert(offsetof(GzGA_BaseLimbAbility_RemoveAbilityStateTag, bReplicate) == 0x000008, "Member 'GzGA_BaseLimbAbility_RemoveAbilityStateTag::bReplicate' has a wrong offset!");

// Function G01.GzGA_BaseLimbAbility.SetAimingState
// 0x0001 (0x0001 - 0x0000)
struct GzGA_BaseLimbAbility_SetAimingState final
{
public:
	bool                                          bIsAiming;                                         // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzGA_BaseLimbAbility_SetAimingState) == 0x000001, "Wrong alignment on GzGA_BaseLimbAbility_SetAimingState");
static_assert(sizeof(GzGA_BaseLimbAbility_SetAimingState) == 0x000001, "Wrong size on GzGA_BaseLimbAbility_SetAimingState");
static_assert(offsetof(GzGA_BaseLimbAbility_SetAimingState, bIsAiming) == 0x000000, "Member 'GzGA_BaseLimbAbility_SetAimingState::bIsAiming' has a wrong offset!");

// Function G01.GzGA_BaseLimbAbility.SetCancelViaAbilityInputEnabled
// 0x0001 (0x0001 - 0x0000)
struct GzGA_BaseLimbAbility_SetCancelViaAbilityInputEnabled final
{
public:
	bool                                          bSetEnabled;                                       // 0x0000(0x0001)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzGA_BaseLimbAbility_SetCancelViaAbilityInputEnabled) == 0x000001, "Wrong alignment on GzGA_BaseLimbAbility_SetCancelViaAbilityInputEnabled");
static_assert(sizeof(GzGA_BaseLimbAbility_SetCancelViaAbilityInputEnabled) == 0x000001, "Wrong size on GzGA_BaseLimbAbility_SetCancelViaAbilityInputEnabled");
static_assert(offsetof(GzGA_BaseLimbAbility_SetCancelViaAbilityInputEnabled, bSetEnabled) == 0x000000, "Member 'GzGA_BaseLimbAbility_SetCancelViaAbilityInputEnabled::bSetEnabled' has a wrong offset!");

// Function G01.GzGA_BaseLimbAbility.SetLimbHandOffset
// 0x0018 (0x0018 - 0x0000)
struct GzGA_BaseLimbAbility_SetLimbHandOffset final
{
public:
	struct FVector                                HandOffset;                                        // 0x0000(0x0018)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzGA_BaseLimbAbility_SetLimbHandOffset) == 0x000008, "Wrong alignment on GzGA_BaseLimbAbility_SetLimbHandOffset");
static_assert(sizeof(GzGA_BaseLimbAbility_SetLimbHandOffset) == 0x000018, "Wrong size on GzGA_BaseLimbAbility_SetLimbHandOffset");
static_assert(offsetof(GzGA_BaseLimbAbility_SetLimbHandOffset, HandOffset) == 0x000000, "Member 'GzGA_BaseLimbAbility_SetLimbHandOffset::HandOffset' has a wrong offset!");

// Function G01.GzGA_BaseLimbAbility.SetLimbHandShoulderDistance
// 0x0004 (0x0004 - 0x0000)
struct GzGA_BaseLimbAbility_SetLimbHandShoulderDistance final
{
public:
	float                                         Distance;                                          // 0x0000(0x0004)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzGA_BaseLimbAbility_SetLimbHandShoulderDistance) == 0x000004, "Wrong alignment on GzGA_BaseLimbAbility_SetLimbHandShoulderDistance");
static_assert(sizeof(GzGA_BaseLimbAbility_SetLimbHandShoulderDistance) == 0x000004, "Wrong size on GzGA_BaseLimbAbility_SetLimbHandShoulderDistance");
static_assert(offsetof(GzGA_BaseLimbAbility_SetLimbHandShoulderDistance, Distance) == 0x000000, "Member 'GzGA_BaseLimbAbility_SetLimbHandShoulderDistance::Distance' has a wrong offset!");

// Function G01.GzGA_BaseLimbAbility.SetLimbTargetLocation
// 0x0018 (0x0018 - 0x0000)
struct GzGA_BaseLimbAbility_SetLimbTargetLocation final
{
public:
	struct FVector                                TargetLocation;                                    // 0x0000(0x0018)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzGA_BaseLimbAbility_SetLimbTargetLocation) == 0x000008, "Wrong alignment on GzGA_BaseLimbAbility_SetLimbTargetLocation");
static_assert(sizeof(GzGA_BaseLimbAbility_SetLimbTargetLocation) == 0x000018, "Wrong size on GzGA_BaseLimbAbility_SetLimbTargetLocation");
static_assert(offsetof(GzGA_BaseLimbAbility_SetLimbTargetLocation, TargetLocation) == 0x000000, "Member 'GzGA_BaseLimbAbility_SetLimbTargetLocation::TargetLocation' has a wrong offset!");

// Function G01.GzGA_BaseLimbAbility.BP_GetAbilityComponent
// 0x0008 (0x0008 - 0x0000)
struct GzGA_BaseLimbAbility_BP_GetAbilityComponent final
{
public:
	class UActorComponent*                        ReturnValue;                                       // 0x0000(0x0008)(ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzGA_BaseLimbAbility_BP_GetAbilityComponent) == 0x000008, "Wrong alignment on GzGA_BaseLimbAbility_BP_GetAbilityComponent");
static_assert(sizeof(GzGA_BaseLimbAbility_BP_GetAbilityComponent) == 0x000008, "Wrong size on GzGA_BaseLimbAbility_BP_GetAbilityComponent");
static_assert(offsetof(GzGA_BaseLimbAbility_BP_GetAbilityComponent, ReturnValue) == 0x000000, "Member 'GzGA_BaseLimbAbility_BP_GetAbilityComponent::ReturnValue' has a wrong offset!");

// Function G01.GzGA_BaseLimbAbility.BP_GetAbilityData
// 0x0008 (0x0008 - 0x0000)
struct GzGA_BaseLimbAbility_BP_GetAbilityData final
{
public:
	class UGzBodyPartAbilityData*                 ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzGA_BaseLimbAbility_BP_GetAbilityData) == 0x000008, "Wrong alignment on GzGA_BaseLimbAbility_BP_GetAbilityData");
static_assert(sizeof(GzGA_BaseLimbAbility_BP_GetAbilityData) == 0x000008, "Wrong size on GzGA_BaseLimbAbility_BP_GetAbilityData");
static_assert(offsetof(GzGA_BaseLimbAbility_BP_GetAbilityData, ReturnValue) == 0x000000, "Member 'GzGA_BaseLimbAbility_BP_GetAbilityData::ReturnValue' has a wrong offset!");

// Function G01.GzGA_BaseLimbAbility.BP_GetCurrentRemainingRechargeTimeAndDuration
// 0x0008 (0x0008 - 0x0000)
struct GzGA_BaseLimbAbility_BP_GetCurrentRemainingRechargeTimeAndDuration final
{
public:
	float                                         TimeRemaining;                                     // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RechargeDuration;                                  // 0x0004(0x0004)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzGA_BaseLimbAbility_BP_GetCurrentRemainingRechargeTimeAndDuration) == 0x000004, "Wrong alignment on GzGA_BaseLimbAbility_BP_GetCurrentRemainingRechargeTimeAndDuration");
static_assert(sizeof(GzGA_BaseLimbAbility_BP_GetCurrentRemainingRechargeTimeAndDuration) == 0x000008, "Wrong size on GzGA_BaseLimbAbility_BP_GetCurrentRemainingRechargeTimeAndDuration");
static_assert(offsetof(GzGA_BaseLimbAbility_BP_GetCurrentRemainingRechargeTimeAndDuration, TimeRemaining) == 0x000000, "Member 'GzGA_BaseLimbAbility_BP_GetCurrentRemainingRechargeTimeAndDuration::TimeRemaining' has a wrong offset!");
static_assert(offsetof(GzGA_BaseLimbAbility_BP_GetCurrentRemainingRechargeTimeAndDuration, RechargeDuration) == 0x000004, "Member 'GzGA_BaseLimbAbility_BP_GetCurrentRemainingRechargeTimeAndDuration::RechargeDuration' has a wrong offset!");

// Function G01.GzGA_BaseLimbAbility.BP_GetTotalRemainingRechargeTimeAndDuration
// 0x0008 (0x0008 - 0x0000)
struct GzGA_BaseLimbAbility_BP_GetTotalRemainingRechargeTimeAndDuration final
{
public:
	float                                         TotalTimeRemaining;                                // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TotalRechargeDuration;                             // 0x0004(0x0004)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzGA_BaseLimbAbility_BP_GetTotalRemainingRechargeTimeAndDuration) == 0x000004, "Wrong alignment on GzGA_BaseLimbAbility_BP_GetTotalRemainingRechargeTimeAndDuration");
static_assert(sizeof(GzGA_BaseLimbAbility_BP_GetTotalRemainingRechargeTimeAndDuration) == 0x000008, "Wrong size on GzGA_BaseLimbAbility_BP_GetTotalRemainingRechargeTimeAndDuration");
static_assert(offsetof(GzGA_BaseLimbAbility_BP_GetTotalRemainingRechargeTimeAndDuration, TotalTimeRemaining) == 0x000000, "Member 'GzGA_BaseLimbAbility_BP_GetTotalRemainingRechargeTimeAndDuration::TotalTimeRemaining' has a wrong offset!");
static_assert(offsetof(GzGA_BaseLimbAbility_BP_GetTotalRemainingRechargeTimeAndDuration, TotalRechargeDuration) == 0x000004, "Member 'GzGA_BaseLimbAbility_BP_GetTotalRemainingRechargeTimeAndDuration::TotalRechargeDuration' has a wrong offset!");

// Function G01.GzGA_BaseLimbAbility.GetAbilityChargePercentage
// 0x0004 (0x0004 - 0x0000)
struct GzGA_BaseLimbAbility_GetAbilityChargePercentage final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzGA_BaseLimbAbility_GetAbilityChargePercentage) == 0x000004, "Wrong alignment on GzGA_BaseLimbAbility_GetAbilityChargePercentage");
static_assert(sizeof(GzGA_BaseLimbAbility_GetAbilityChargePercentage) == 0x000004, "Wrong size on GzGA_BaseLimbAbility_GetAbilityChargePercentage");
static_assert(offsetof(GzGA_BaseLimbAbility_GetAbilityChargePercentage, ReturnValue) == 0x000000, "Member 'GzGA_BaseLimbAbility_GetAbilityChargePercentage::ReturnValue' has a wrong offset!");

// Function G01.GzGA_BaseLimbAbility.GetAbilityChargesAttribute
// 0x0038 (0x0038 - 0x0000)
struct GzGA_BaseLimbAbility_GetAbilityChargesAttribute final
{
public:
	struct FGameplayAttribute                     ReturnValue;                                       // 0x0000(0x0038)(Parm, OutParm, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzGA_BaseLimbAbility_GetAbilityChargesAttribute) == 0x000008, "Wrong alignment on GzGA_BaseLimbAbility_GetAbilityChargesAttribute");
static_assert(sizeof(GzGA_BaseLimbAbility_GetAbilityChargesAttribute) == 0x000038, "Wrong size on GzGA_BaseLimbAbility_GetAbilityChargesAttribute");
static_assert(offsetof(GzGA_BaseLimbAbility_GetAbilityChargesAttribute, ReturnValue) == 0x000000, "Member 'GzGA_BaseLimbAbility_GetAbilityChargesAttribute::ReturnValue' has a wrong offset!");

// Function G01.GzGA_BaseLimbAbility.GetActivationCost
// 0x0004 (0x0004 - 0x0000)
struct GzGA_BaseLimbAbility_GetActivationCost final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzGA_BaseLimbAbility_GetActivationCost) == 0x000004, "Wrong alignment on GzGA_BaseLimbAbility_GetActivationCost");
static_assert(sizeof(GzGA_BaseLimbAbility_GetActivationCost) == 0x000004, "Wrong size on GzGA_BaseLimbAbility_GetActivationCost");
static_assert(offsetof(GzGA_BaseLimbAbility_GetActivationCost, ReturnValue) == 0x000000, "Member 'GzGA_BaseLimbAbility_GetActivationCost::ReturnValue' has a wrong offset!");

// Function G01.GzGA_BaseLimbAbility.GetCurrentCharges
// 0x0004 (0x0004 - 0x0000)
struct GzGA_BaseLimbAbility_GetCurrentCharges final
{
public:
	int32                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzGA_BaseLimbAbility_GetCurrentCharges) == 0x000004, "Wrong alignment on GzGA_BaseLimbAbility_GetCurrentCharges");
static_assert(sizeof(GzGA_BaseLimbAbility_GetCurrentCharges) == 0x000004, "Wrong size on GzGA_BaseLimbAbility_GetCurrentCharges");
static_assert(offsetof(GzGA_BaseLimbAbility_GetCurrentCharges, ReturnValue) == 0x000000, "Member 'GzGA_BaseLimbAbility_GetCurrentCharges::ReturnValue' has a wrong offset!");

// Function G01.GzGA_BaseLimbAbility.GetItemData
// 0x0008 (0x0008 - 0x0000)
struct GzGA_BaseLimbAbility_GetItemData final
{
public:
	class UGzBodyPartItemData*                    ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzGA_BaseLimbAbility_GetItemData) == 0x000008, "Wrong alignment on GzGA_BaseLimbAbility_GetItemData");
static_assert(sizeof(GzGA_BaseLimbAbility_GetItemData) == 0x000008, "Wrong size on GzGA_BaseLimbAbility_GetItemData");
static_assert(offsetof(GzGA_BaseLimbAbility_GetItemData, ReturnValue) == 0x000000, "Member 'GzGA_BaseLimbAbility_GetItemData::ReturnValue' has a wrong offset!");

// Function G01.GzGA_BaseLimbAbility.GetLimbComponent
// 0x0008 (0x0008 - 0x0000)
struct GzGA_BaseLimbAbility_GetLimbComponent final
{
public:
	class UGzLimbComponent*                       ReturnValue;                                       // 0x0000(0x0008)(ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzGA_BaseLimbAbility_GetLimbComponent) == 0x000008, "Wrong alignment on GzGA_BaseLimbAbility_GetLimbComponent");
static_assert(sizeof(GzGA_BaseLimbAbility_GetLimbComponent) == 0x000008, "Wrong size on GzGA_BaseLimbAbility_GetLimbComponent");
static_assert(offsetof(GzGA_BaseLimbAbility_GetLimbComponent, ReturnValue) == 0x000000, "Member 'GzGA_BaseLimbAbility_GetLimbComponent::ReturnValue' has a wrong offset!");

// Function G01.GzGA_BaseLimbAbility.GetLimbHandOffset
// 0x0018 (0x0018 - 0x0000)
struct GzGA_BaseLimbAbility_GetLimbHandOffset final
{
public:
	struct FVector                                ReturnValue;                                       // 0x0000(0x0018)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzGA_BaseLimbAbility_GetLimbHandOffset) == 0x000008, "Wrong alignment on GzGA_BaseLimbAbility_GetLimbHandOffset");
static_assert(sizeof(GzGA_BaseLimbAbility_GetLimbHandOffset) == 0x000018, "Wrong size on GzGA_BaseLimbAbility_GetLimbHandOffset");
static_assert(offsetof(GzGA_BaseLimbAbility_GetLimbHandOffset, ReturnValue) == 0x000000, "Member 'GzGA_BaseLimbAbility_GetLimbHandOffset::ReturnValue' has a wrong offset!");

// Function G01.GzGA_BaseLimbAbility.GetLimbSocketWorldLocation
// 0x0020 (0x0020 - 0x0000)
struct GzGA_BaseLimbAbility_GetLimbSocketWorldLocation final
{
public:
	class FName                                   SocketName;                                        // 0x0000(0x0008)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                ReturnValue;                                       // 0x0008(0x0018)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzGA_BaseLimbAbility_GetLimbSocketWorldLocation) == 0x000008, "Wrong alignment on GzGA_BaseLimbAbility_GetLimbSocketWorldLocation");
static_assert(sizeof(GzGA_BaseLimbAbility_GetLimbSocketWorldLocation) == 0x000020, "Wrong size on GzGA_BaseLimbAbility_GetLimbSocketWorldLocation");
static_assert(offsetof(GzGA_BaseLimbAbility_GetLimbSocketWorldLocation, SocketName) == 0x000000, "Member 'GzGA_BaseLimbAbility_GetLimbSocketWorldLocation::SocketName' has a wrong offset!");
static_assert(offsetof(GzGA_BaseLimbAbility_GetLimbSocketWorldLocation, ReturnValue) == 0x000008, "Member 'GzGA_BaseLimbAbility_GetLimbSocketWorldLocation::ReturnValue' has a wrong offset!");

// Function G01.GzGA_BaseLimbAbility.GetLimbTargetLocation
// 0x0018 (0x0018 - 0x0000)
struct GzGA_BaseLimbAbility_GetLimbTargetLocation final
{
public:
	struct FVector                                ReturnValue;                                       // 0x0000(0x0018)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzGA_BaseLimbAbility_GetLimbTargetLocation) == 0x000008, "Wrong alignment on GzGA_BaseLimbAbility_GetLimbTargetLocation");
static_assert(sizeof(GzGA_BaseLimbAbility_GetLimbTargetLocation) == 0x000018, "Wrong size on GzGA_BaseLimbAbility_GetLimbTargetLocation");
static_assert(offsetof(GzGA_BaseLimbAbility_GetLimbTargetLocation, ReturnValue) == 0x000000, "Member 'GzGA_BaseLimbAbility_GetLimbTargetLocation::ReturnValue' has a wrong offset!");

// Function G01.GzGA_BaseLimbAbility.GetMaxCharges
// 0x0004 (0x0004 - 0x0000)
struct GzGA_BaseLimbAbility_GetMaxCharges final
{
public:
	int32                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzGA_BaseLimbAbility_GetMaxCharges) == 0x000004, "Wrong alignment on GzGA_BaseLimbAbility_GetMaxCharges");
static_assert(sizeof(GzGA_BaseLimbAbility_GetMaxCharges) == 0x000004, "Wrong size on GzGA_BaseLimbAbility_GetMaxCharges");
static_assert(offsetof(GzGA_BaseLimbAbility_GetMaxCharges, ReturnValue) == 0x000000, "Member 'GzGA_BaseLimbAbility_GetMaxCharges::ReturnValue' has a wrong offset!");

// Function G01.GzGA_BaseLimbAbility.GetRechargeDuration
// 0x0004 (0x0004 - 0x0000)
struct GzGA_BaseLimbAbility_GetRechargeDuration final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzGA_BaseLimbAbility_GetRechargeDuration) == 0x000004, "Wrong alignment on GzGA_BaseLimbAbility_GetRechargeDuration");
static_assert(sizeof(GzGA_BaseLimbAbility_GetRechargeDuration) == 0x000004, "Wrong size on GzGA_BaseLimbAbility_GetRechargeDuration");
static_assert(offsetof(GzGA_BaseLimbAbility_GetRechargeDuration, ReturnValue) == 0x000000, "Member 'GzGA_BaseLimbAbility_GetRechargeDuration::ReturnValue' has a wrong offset!");

// Function G01.GzGA_BaseLimbAbility.GetRechargeTypeTag
// 0x0008 (0x0008 - 0x0000)
struct GzGA_BaseLimbAbility_GetRechargeTypeTag final
{
public:
	struct FGameplayTag                           ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzGA_BaseLimbAbility_GetRechargeTypeTag) == 0x000004, "Wrong alignment on GzGA_BaseLimbAbility_GetRechargeTypeTag");
static_assert(sizeof(GzGA_BaseLimbAbility_GetRechargeTypeTag) == 0x000008, "Wrong size on GzGA_BaseLimbAbility_GetRechargeTypeTag");
static_assert(offsetof(GzGA_BaseLimbAbility_GetRechargeTypeTag, ReturnValue) == 0x000000, "Member 'GzGA_BaseLimbAbility_GetRechargeTypeTag::ReturnValue' has a wrong offset!");

// Function G01.GzGA_BaseLimbAbility.IsInAimingState
// 0x0001 (0x0001 - 0x0000)
struct GzGA_BaseLimbAbility_IsInAimingState final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzGA_BaseLimbAbility_IsInAimingState) == 0x000001, "Wrong alignment on GzGA_BaseLimbAbility_IsInAimingState");
static_assert(sizeof(GzGA_BaseLimbAbility_IsInAimingState) == 0x000001, "Wrong size on GzGA_BaseLimbAbility_IsInAimingState");
static_assert(offsetof(GzGA_BaseLimbAbility_IsInAimingState, ReturnValue) == 0x000000, "Member 'GzGA_BaseLimbAbility_IsInAimingState::ReturnValue' has a wrong offset!");

// Function G01.GzGA_BaseLimbAbility.IsRecharging
// 0x0001 (0x0001 - 0x0000)
struct GzGA_BaseLimbAbility_IsRecharging final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzGA_BaseLimbAbility_IsRecharging) == 0x000001, "Wrong alignment on GzGA_BaseLimbAbility_IsRecharging");
static_assert(sizeof(GzGA_BaseLimbAbility_IsRecharging) == 0x000001, "Wrong size on GzGA_BaseLimbAbility_IsRecharging");
static_assert(offsetof(GzGA_BaseLimbAbility_IsRecharging, ReturnValue) == 0x000000, "Member 'GzGA_BaseLimbAbility_IsRecharging::ReturnValue' has a wrong offset!");

// Function G01.GzGA_Charge_LimbAbility.TriggerAbility
// 0x0001 (0x0001 - 0x0000)
struct GzGA_Charge_LimbAbility_TriggerAbility final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzGA_Charge_LimbAbility_TriggerAbility) == 0x000001, "Wrong alignment on GzGA_Charge_LimbAbility_TriggerAbility");
static_assert(sizeof(GzGA_Charge_LimbAbility_TriggerAbility) == 0x000001, "Wrong size on GzGA_Charge_LimbAbility_TriggerAbility");
static_assert(offsetof(GzGA_Charge_LimbAbility_TriggerAbility, ReturnValue) == 0x000000, "Member 'GzGA_Charge_LimbAbility_TriggerAbility::ReturnValue' has a wrong offset!");

// Function G01.GzGA_ChargeProjectile.Server_ReceiveClientTargetData
// 0x0028 (0x0028 - 0x0000)
struct GzGA_ChargeProjectile_Server_ReceiveClientTargetData final
{
public:
	struct FGameplayAbilityTargetDataHandle       Data;                                              // 0x0000(0x0028)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzGA_ChargeProjectile_Server_ReceiveClientTargetData) == 0x000008, "Wrong alignment on GzGA_ChargeProjectile_Server_ReceiveClientTargetData");
static_assert(sizeof(GzGA_ChargeProjectile_Server_ReceiveClientTargetData) == 0x000028, "Wrong size on GzGA_ChargeProjectile_Server_ReceiveClientTargetData");
static_assert(offsetof(GzGA_ChargeProjectile_Server_ReceiveClientTargetData, Data) == 0x000000, "Member 'GzGA_ChargeProjectile_Server_ReceiveClientTargetData::Data' has a wrong offset!");

// Function G01.GzWE_DamageAware.OnDamageRecieved
// 0x0018 (0x0018 - 0x0000)
struct GzWE_DamageAware_OnDamageRecieved final
{
public:
	struct FGzServerDamageInfo                    DamageInfo;                                        // 0x0000(0x0018)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzWE_DamageAware_OnDamageRecieved) == 0x000008, "Wrong alignment on GzWE_DamageAware_OnDamageRecieved");
static_assert(sizeof(GzWE_DamageAware_OnDamageRecieved) == 0x000018, "Wrong size on GzWE_DamageAware_OnDamageRecieved");
static_assert(offsetof(GzWE_DamageAware_OnDamageRecieved, DamageInfo) == 0x000000, "Member 'GzWE_DamageAware_OnDamageRecieved::DamageInfo' has a wrong offset!");

// Function G01.GzPawnControlsComponent.OnPawnRestarted
// 0x0008 (0x0008 - 0x0000)
struct GzPawnControlsComponent_OnPawnRestarted final
{
public:
	class APawn*                                  Pawn;                                              // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzPawnControlsComponent_OnPawnRestarted) == 0x000008, "Wrong alignment on GzPawnControlsComponent_OnPawnRestarted");
static_assert(sizeof(GzPawnControlsComponent_OnPawnRestarted) == 0x000008, "Wrong size on GzPawnControlsComponent_OnPawnRestarted");
static_assert(offsetof(GzPawnControlsComponent_OnPawnRestarted, Pawn) == 0x000000, "Member 'GzPawnControlsComponent_OnPawnRestarted::Pawn' has a wrong offset!");

// Function G01.GzPawnControlsComponent.PopInputMapping
// 0x0010 (0x0010 - 0x0000)
struct GzPawnControlsComponent_PopInputMapping final
{
public:
	struct FGzInputConfigBindingHandle            InHandle;                                          // 0x0000(0x000C)(Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FModifyContextOptions                  OPTIONS;                                           // 0x000C(0x0001)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C95[0x3];                                     // 0x000D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GzPawnControlsComponent_PopInputMapping) == 0x000004, "Wrong alignment on GzPawnControlsComponent_PopInputMapping");
static_assert(sizeof(GzPawnControlsComponent_PopInputMapping) == 0x000010, "Wrong size on GzPawnControlsComponent_PopInputMapping");
static_assert(offsetof(GzPawnControlsComponent_PopInputMapping, InHandle) == 0x000000, "Member 'GzPawnControlsComponent_PopInputMapping::InHandle' has a wrong offset!");
static_assert(offsetof(GzPawnControlsComponent_PopInputMapping, OPTIONS) == 0x00000C, "Member 'GzPawnControlsComponent_PopInputMapping::OPTIONS' has a wrong offset!");

// Function G01.GzPawnControlsComponent.PushInputMapping
// 0x0018 (0x0018 - 0x0000)
struct GzPawnControlsComponent_PushInputMapping final
{
public:
	class UGzPawnInputMappingConfig*              InMappingConfig;                                   // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FModifyContextOptions                  OPTIONS;                                           // 0x0008(0x0001)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C96[0x3];                                     // 0x0009(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGzInputConfigBindingHandle            ReturnValue;                                       // 0x000C(0x000C)(Parm, OutParm, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzPawnControlsComponent_PushInputMapping) == 0x000008, "Wrong alignment on GzPawnControlsComponent_PushInputMapping");
static_assert(sizeof(GzPawnControlsComponent_PushInputMapping) == 0x000018, "Wrong size on GzPawnControlsComponent_PushInputMapping");
static_assert(offsetof(GzPawnControlsComponent_PushInputMapping, InMappingConfig) == 0x000000, "Member 'GzPawnControlsComponent_PushInputMapping::InMappingConfig' has a wrong offset!");
static_assert(offsetof(GzPawnControlsComponent_PushInputMapping, OPTIONS) == 0x000008, "Member 'GzPawnControlsComponent_PushInputMapping::OPTIONS' has a wrong offset!");
static_assert(offsetof(GzPawnControlsComponent_PushInputMapping, ReturnValue) == 0x00000C, "Member 'GzPawnControlsComponent_PushInputMapping::ReturnValue' has a wrong offset!");

// Function G01.GzPawnControlsComponent.SetupPlayerControls
// 0x0008 (0x0008 - 0x0000)
struct GzPawnControlsComponent_SetupPlayerControls final
{
public:
	class UEnhancedInputComponent*                PlayerInputComponent;                              // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzPawnControlsComponent_SetupPlayerControls) == 0x000008, "Wrong alignment on GzPawnControlsComponent_SetupPlayerControls");
static_assert(sizeof(GzPawnControlsComponent_SetupPlayerControls) == 0x000008, "Wrong size on GzPawnControlsComponent_SetupPlayerControls");
static_assert(offsetof(GzPawnControlsComponent_SetupPlayerControls, PlayerInputComponent) == 0x000000, "Member 'GzPawnControlsComponent_SetupPlayerControls::PlayerInputComponent' has a wrong offset!");

// Function G01.GzPawnControlsComponent.TeardownPlayerControls
// 0x0008 (0x0008 - 0x0000)
struct GzPawnControlsComponent_TeardownPlayerControls final
{
public:
	class UEnhancedInputComponent*                PlayerInputComponent;                              // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzPawnControlsComponent_TeardownPlayerControls) == 0x000008, "Wrong alignment on GzPawnControlsComponent_TeardownPlayerControls");
static_assert(sizeof(GzPawnControlsComponent_TeardownPlayerControls) == 0x000008, "Wrong size on GzPawnControlsComponent_TeardownPlayerControls");
static_assert(offsetof(GzPawnControlsComponent_TeardownPlayerControls, PlayerInputComponent) == 0x000000, "Member 'GzPawnControlsComponent_TeardownPlayerControls::PlayerInputComponent' has a wrong offset!");

// Function G01.Gz3DDamageIndicationSubsystem.OnPawnChanged
// 0x0008 (0x0008 - 0x0000)
struct Gz3DDamageIndicationSubsystem_OnPawnChanged final
{
public:
	class APawn*                                  Pawn;                                              // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(Gz3DDamageIndicationSubsystem_OnPawnChanged) == 0x000008, "Wrong alignment on Gz3DDamageIndicationSubsystem_OnPawnChanged");
static_assert(sizeof(Gz3DDamageIndicationSubsystem_OnPawnChanged) == 0x000008, "Wrong size on Gz3DDamageIndicationSubsystem_OnPawnChanged");
static_assert(offsetof(Gz3DDamageIndicationSubsystem_OnPawnChanged, Pawn) == 0x000000, "Member 'Gz3DDamageIndicationSubsystem_OnPawnChanged::Pawn' has a wrong offset!");

// Function G01.Gz3DDamageIndicator.OnInit
// 0x0030 (0x0030 - 0x0000)
struct Gz3DDamageIndicator_OnInit final
{
public:
	struct FGzDamageDirectionData                 InDamageData;                                      // 0x0000(0x0030)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(Gz3DDamageIndicator_OnInit) == 0x000008, "Wrong alignment on Gz3DDamageIndicator_OnInit");
static_assert(sizeof(Gz3DDamageIndicator_OnInit) == 0x000030, "Wrong size on Gz3DDamageIndicator_OnInit");
static_assert(offsetof(Gz3DDamageIndicator_OnInit, InDamageData) == 0x000000, "Member 'Gz3DDamageIndicator_OnInit::InDamageData' has a wrong offset!");

// Function G01.GzGA_SmashLanding.BP_OnSmashLanding
// 0x00F8 (0x00F8 - 0x0000)
struct GzGA_SmashLanding_BP_OnSmashLanding final
{
public:
	struct FHitResult                             HitResult;                                         // 0x0000(0x00F8)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzGA_SmashLanding_BP_OnSmashLanding) == 0x000008, "Wrong alignment on GzGA_SmashLanding_BP_OnSmashLanding");
static_assert(sizeof(GzGA_SmashLanding_BP_OnSmashLanding) == 0x0000F8, "Wrong size on GzGA_SmashLanding_BP_OnSmashLanding");
static_assert(offsetof(GzGA_SmashLanding_BP_OnSmashLanding, HitResult) == 0x000000, "Member 'GzGA_SmashLanding_BP_OnSmashLanding::HitResult' has a wrong offset!");

// Function G01.GzGA_SmashLanding.BP_OnTargetChanged
// 0x0001 (0x0001 - 0x0000)
struct GzGA_SmashLanding_BP_OnTargetChanged final
{
public:
	bool                                          bIsOutOfRange;                                     // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzGA_SmashLanding_BP_OnTargetChanged) == 0x000001, "Wrong alignment on GzGA_SmashLanding_BP_OnTargetChanged");
static_assert(sizeof(GzGA_SmashLanding_BP_OnTargetChanged) == 0x000001, "Wrong size on GzGA_SmashLanding_BP_OnTargetChanged");
static_assert(offsetof(GzGA_SmashLanding_BP_OnTargetChanged, bIsOutOfRange) == 0x000000, "Member 'GzGA_SmashLanding_BP_OnTargetChanged::bIsOutOfRange' has a wrong offset!");

// Function G01.GzGA_SmashLanding.OnAttackInputPressed
// 0x0004 (0x0004 - 0x0000)
struct GzGA_SmashLanding_OnAttackInputPressed final
{
public:
	float                                         TimeHeld;                                          // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzGA_SmashLanding_OnAttackInputPressed) == 0x000004, "Wrong alignment on GzGA_SmashLanding_OnAttackInputPressed");
static_assert(sizeof(GzGA_SmashLanding_OnAttackInputPressed) == 0x000004, "Wrong size on GzGA_SmashLanding_OnAttackInputPressed");
static_assert(offsetof(GzGA_SmashLanding_OnAttackInputPressed, TimeHeld) == 0x000000, "Member 'GzGA_SmashLanding_OnAttackInputPressed::TimeHeld' has a wrong offset!");

// Function G01.GzGA_SmashLanding.OnCharacterLanded
// 0x00F8 (0x00F8 - 0x0000)
struct GzGA_SmashLanding_OnCharacterLanded final
{
public:
	struct FHitResult                             Hit;                                               // 0x0000(0x00F8)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzGA_SmashLanding_OnCharacterLanded) == 0x000008, "Wrong alignment on GzGA_SmashLanding_OnCharacterLanded");
static_assert(sizeof(GzGA_SmashLanding_OnCharacterLanded) == 0x0000F8, "Wrong size on GzGA_SmashLanding_OnCharacterLanded");
static_assert(offsetof(GzGA_SmashLanding_OnCharacterLanded, Hit) == 0x000000, "Member 'GzGA_SmashLanding_OnCharacterLanded::Hit' has a wrong offset!");

// Function G01.GzGA_SmashLanding.OnDashStopped
// 0x00F8 (0x00F8 - 0x0000)
struct GzGA_SmashLanding_OnDashStopped final
{
public:
	struct FHitResult                             HitResult;                                         // 0x0000(0x00F8)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzGA_SmashLanding_OnDashStopped) == 0x000008, "Wrong alignment on GzGA_SmashLanding_OnDashStopped");
static_assert(sizeof(GzGA_SmashLanding_OnDashStopped) == 0x0000F8, "Wrong size on GzGA_SmashLanding_OnDashStopped");
static_assert(offsetof(GzGA_SmashLanding_OnDashStopped, HitResult) == 0x000000, "Member 'GzGA_SmashLanding_OnDashStopped::HitResult' has a wrong offset!");

// Function G01.GzGA_SmashLanding.OnTargetingTaskEnded
// 0x0001 (0x0001 - 0x0000)
struct GzGA_SmashLanding_OnTargetingTaskEnded final
{
public:
	bool                                          bWasCompleted;                                     // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzGA_SmashLanding_OnTargetingTaskEnded) == 0x000001, "Wrong alignment on GzGA_SmashLanding_OnTargetingTaskEnded");
static_assert(sizeof(GzGA_SmashLanding_OnTargetingTaskEnded) == 0x000001, "Wrong size on GzGA_SmashLanding_OnTargetingTaskEnded");
static_assert(offsetof(GzGA_SmashLanding_OnTargetingTaskEnded, bWasCompleted) == 0x000000, "Member 'GzGA_SmashLanding_OnTargetingTaskEnded::bWasCompleted' has a wrong offset!");

// Function G01.GzGA_SmashLanding.OnTargetingTick
// 0x0004 (0x0004 - 0x0000)
struct GzGA_SmashLanding_OnTargetingTick final
{
public:
	float                                         DeltaTime;                                         // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzGA_SmashLanding_OnTargetingTick) == 0x000004, "Wrong alignment on GzGA_SmashLanding_OnTargetingTick");
static_assert(sizeof(GzGA_SmashLanding_OnTargetingTick) == 0x000004, "Wrong size on GzGA_SmashLanding_OnTargetingTick");
static_assert(offsetof(GzGA_SmashLanding_OnTargetingTick, DeltaTime) == 0x000000, "Member 'GzGA_SmashLanding_OnTargetingTick::DeltaTime' has a wrong offset!");

// Function G01.GzGA_SmashLanding.ServerHandleClientDashHitData
// 0x0028 (0x0028 - 0x0000)
struct GzGA_SmashLanding_ServerHandleClientDashHitData final
{
public:
	struct FGameplayAbilityTargetDataHandle       TargetData;                                        // 0x0000(0x0028)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzGA_SmashLanding_ServerHandleClientDashHitData) == 0x000008, "Wrong alignment on GzGA_SmashLanding_ServerHandleClientDashHitData");
static_assert(sizeof(GzGA_SmashLanding_ServerHandleClientDashHitData) == 0x000028, "Wrong size on GzGA_SmashLanding_ServerHandleClientDashHitData");
static_assert(offsetof(GzGA_SmashLanding_ServerHandleClientDashHitData, TargetData) == 0x000000, "Member 'GzGA_SmashLanding_ServerHandleClientDashHitData::TargetData' has a wrong offset!");

// Function G01.GzMission.DispatchUIMessage
// 0x0020 (0x0020 - 0x0000)
struct GzMission_DispatchUIMessage final
{
public:
	struct FGameplayTag                           Tag;                                               // 0x0000(0x0008)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   Text;                                              // 0x0008(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	float                                         Duration;                                          // 0x0018(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C9D[0x4];                                     // 0x001C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GzMission_DispatchUIMessage) == 0x000008, "Wrong alignment on GzMission_DispatchUIMessage");
static_assert(sizeof(GzMission_DispatchUIMessage) == 0x000020, "Wrong size on GzMission_DispatchUIMessage");
static_assert(offsetof(GzMission_DispatchUIMessage, Tag) == 0x000000, "Member 'GzMission_DispatchUIMessage::Tag' has a wrong offset!");
static_assert(offsetof(GzMission_DispatchUIMessage, Text) == 0x000008, "Member 'GzMission_DispatchUIMessage::Text' has a wrong offset!");
static_assert(offsetof(GzMission_DispatchUIMessage, Duration) == 0x000018, "Member 'GzMission_DispatchUIMessage::Duration' has a wrong offset!");

// Function G01.GzMission.HandleParticipantConnectionChanged
// 0x0008 (0x0008 - 0x0000)
struct GzMission_HandleParticipantConnectionChanged final
{
public:
	class AGzPlayerState*                         PlayerState;                                       // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzMission_HandleParticipantConnectionChanged) == 0x000008, "Wrong alignment on GzMission_HandleParticipantConnectionChanged");
static_assert(sizeof(GzMission_HandleParticipantConnectionChanged) == 0x000008, "Wrong size on GzMission_HandleParticipantConnectionChanged");
static_assert(offsetof(GzMission_HandleParticipantConnectionChanged, PlayerState) == 0x000000, "Member 'GzMission_HandleParticipantConnectionChanged::PlayerState' has a wrong offset!");

// Function G01.GzMission.OnRep_MissionState
// 0x000C (0x000C - 0x0000)
struct GzMission_OnRep_MissionState final
{
public:
	struct FGzMissionState                        OldState;                                          // 0x0000(0x000C)(Parm, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzMission_OnRep_MissionState) == 0x000004, "Wrong alignment on GzMission_OnRep_MissionState");
static_assert(sizeof(GzMission_OnRep_MissionState) == 0x00000C, "Wrong size on GzMission_OnRep_MissionState");
static_assert(offsetof(GzMission_OnRep_MissionState, OldState) == 0x000000, "Member 'GzMission_OnRep_MissionState::OldState' has a wrong offset!");

// Function G01.GzMission.GetMissionData
// 0x0008 (0x0008 - 0x0000)
struct GzMission_GetMissionData final
{
public:
	class UGzMissionData*                         ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzMission_GetMissionData) == 0x000008, "Wrong alignment on GzMission_GetMissionData");
static_assert(sizeof(GzMission_GetMissionData) == 0x000008, "Wrong size on GzMission_GetMissionData");
static_assert(offsetof(GzMission_GetMissionData, ReturnValue) == 0x000000, "Member 'GzMission_GetMissionData::ReturnValue' has a wrong offset!");

// Function G01.GzMission.GetMissionInstigator
// 0x0008 (0x0008 - 0x0000)
struct GzMission_GetMissionInstigator final
{
public:
	class AGzPlayerState*                         ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzMission_GetMissionInstigator) == 0x000008, "Wrong alignment on GzMission_GetMissionInstigator");
static_assert(sizeof(GzMission_GetMissionInstigator) == 0x000008, "Wrong size on GzMission_GetMissionInstigator");
static_assert(offsetof(GzMission_GetMissionInstigator, ReturnValue) == 0x000000, "Member 'GzMission_GetMissionInstigator::ReturnValue' has a wrong offset!");

// Function G01.GzMission.GetMissionName
// 0x0010 (0x0010 - 0x0000)
struct GzMission_GetMissionName final
{
public:
	class FText                                   ReturnValue;                                       // 0x0000(0x0010)(ConstParm, Parm, OutParm, ReturnParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzMission_GetMissionName) == 0x000008, "Wrong alignment on GzMission_GetMissionName");
static_assert(sizeof(GzMission_GetMissionName) == 0x000010, "Wrong size on GzMission_GetMissionName");
static_assert(offsetof(GzMission_GetMissionName, ReturnValue) == 0x000000, "Member 'GzMission_GetMissionName::ReturnValue' has a wrong offset!");

// Function G01.GzMission.GetMissionState
// 0x000C (0x000C - 0x0000)
struct GzMission_GetMissionState final
{
public:
	struct FGzMissionState                        ReturnValue;                                       // 0x0000(0x000C)(Parm, OutParm, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzMission_GetMissionState) == 0x000004, "Wrong alignment on GzMission_GetMissionState");
static_assert(sizeof(GzMission_GetMissionState) == 0x00000C, "Wrong size on GzMission_GetMissionState");
static_assert(offsetof(GzMission_GetMissionState, ReturnValue) == 0x000000, "Member 'GzMission_GetMissionState::ReturnValue' has a wrong offset!");

// Function G01.GzMission.GetRuntimeId
// 0x0004 (0x0004 - 0x0000)
struct GzMission_GetRuntimeId final
{
public:
	int32                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzMission_GetRuntimeId) == 0x000004, "Wrong alignment on GzMission_GetRuntimeId");
static_assert(sizeof(GzMission_GetRuntimeId) == 0x000004, "Wrong size on GzMission_GetRuntimeId");
static_assert(offsetof(GzMission_GetRuntimeId, ReturnValue) == 0x000000, "Member 'GzMission_GetRuntimeId::ReturnValue' has a wrong offset!");

// Function G01.GzLayerCharacterAnimInstance.AdvanceTimeByDistanceMatching
// 0x0050 (0x0050 - 0x0000)
struct GzLayerCharacterAnimInstance_AdvanceTimeByDistanceMatching final
{
public:
	struct FAnimUpdateContext                     UpdateContext;                                     // 0x0000(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	struct FSequenceEvaluatorReference            SequenceEvaluator;                                 // 0x0010(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	float                                         DistanceTraveled;                                  // 0x0020(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   DistanceCurveName;                                 // 0x0024(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2CA1[0x4];                                     // 0x002C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector2D                              PlayRateClamp;                                     // 0x0030(0x0010)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSequenceEvaluatorReference            ReturnValue;                                       // 0x0040(0x0010)(Parm, OutParm, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzLayerCharacterAnimInstance_AdvanceTimeByDistanceMatching) == 0x000008, "Wrong alignment on GzLayerCharacterAnimInstance_AdvanceTimeByDistanceMatching");
static_assert(sizeof(GzLayerCharacterAnimInstance_AdvanceTimeByDistanceMatching) == 0x000050, "Wrong size on GzLayerCharacterAnimInstance_AdvanceTimeByDistanceMatching");
static_assert(offsetof(GzLayerCharacterAnimInstance_AdvanceTimeByDistanceMatching, UpdateContext) == 0x000000, "Member 'GzLayerCharacterAnimInstance_AdvanceTimeByDistanceMatching::UpdateContext' has a wrong offset!");
static_assert(offsetof(GzLayerCharacterAnimInstance_AdvanceTimeByDistanceMatching, SequenceEvaluator) == 0x000010, "Member 'GzLayerCharacterAnimInstance_AdvanceTimeByDistanceMatching::SequenceEvaluator' has a wrong offset!");
static_assert(offsetof(GzLayerCharacterAnimInstance_AdvanceTimeByDistanceMatching, DistanceTraveled) == 0x000020, "Member 'GzLayerCharacterAnimInstance_AdvanceTimeByDistanceMatching::DistanceTraveled' has a wrong offset!");
static_assert(offsetof(GzLayerCharacterAnimInstance_AdvanceTimeByDistanceMatching, DistanceCurveName) == 0x000024, "Member 'GzLayerCharacterAnimInstance_AdvanceTimeByDistanceMatching::DistanceCurveName' has a wrong offset!");
static_assert(offsetof(GzLayerCharacterAnimInstance_AdvanceTimeByDistanceMatching, PlayRateClamp) == 0x000030, "Member 'GzLayerCharacterAnimInstance_AdvanceTimeByDistanceMatching::PlayRateClamp' has a wrong offset!");
static_assert(offsetof(GzLayerCharacterAnimInstance_AdvanceTimeByDistanceMatching, ReturnValue) == 0x000040, "Member 'GzLayerCharacterAnimInstance_AdvanceTimeByDistanceMatching::ReturnValue' has a wrong offset!");

// Function G01.GzLayerCharacterAnimInstance.DistanceMatchToTarget
// 0x0030 (0x0030 - 0x0000)
struct GzLayerCharacterAnimInstance_DistanceMatchToTarget final
{
public:
	struct FSequenceEvaluatorReference            SequenceEvaluator;                                 // 0x0000(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	float                                         DistanceToTarget;                                  // 0x0010(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   DistanceCurveName;                                 // 0x0014(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2CA2[0x4];                                     // 0x001C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FSequenceEvaluatorReference            ReturnValue;                                       // 0x0020(0x0010)(Parm, OutParm, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzLayerCharacterAnimInstance_DistanceMatchToTarget) == 0x000008, "Wrong alignment on GzLayerCharacterAnimInstance_DistanceMatchToTarget");
static_assert(sizeof(GzLayerCharacterAnimInstance_DistanceMatchToTarget) == 0x000030, "Wrong size on GzLayerCharacterAnimInstance_DistanceMatchToTarget");
static_assert(offsetof(GzLayerCharacterAnimInstance_DistanceMatchToTarget, SequenceEvaluator) == 0x000000, "Member 'GzLayerCharacterAnimInstance_DistanceMatchToTarget::SequenceEvaluator' has a wrong offset!");
static_assert(offsetof(GzLayerCharacterAnimInstance_DistanceMatchToTarget, DistanceToTarget) == 0x000010, "Member 'GzLayerCharacterAnimInstance_DistanceMatchToTarget::DistanceToTarget' has a wrong offset!");
static_assert(offsetof(GzLayerCharacterAnimInstance_DistanceMatchToTarget, DistanceCurveName) == 0x000014, "Member 'GzLayerCharacterAnimInstance_DistanceMatchToTarget::DistanceCurveName' has a wrong offset!");
static_assert(offsetof(GzLayerCharacterAnimInstance_DistanceMatchToTarget, ReturnValue) == 0x000020, "Member 'GzLayerCharacterAnimInstance_DistanceMatchToTarget::ReturnValue' has a wrong offset!");

// Function G01.GzLayerCharacterAnimInstance.SetDefaultAnimInstance
// 0x0008 (0x0008 - 0x0000)
struct GzLayerCharacterAnimInstance_SetDefaultAnimInstance final
{
public:
	class UAnimInstance*                          NewAnimInstance;                                   // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzLayerCharacterAnimInstance_SetDefaultAnimInstance) == 0x000008, "Wrong alignment on GzLayerCharacterAnimInstance_SetDefaultAnimInstance");
static_assert(sizeof(GzLayerCharacterAnimInstance_SetDefaultAnimInstance) == 0x000008, "Wrong size on GzLayerCharacterAnimInstance_SetDefaultAnimInstance");
static_assert(offsetof(GzLayerCharacterAnimInstance_SetDefaultAnimInstance, NewAnimInstance) == 0x000000, "Member 'GzLayerCharacterAnimInstance_SetDefaultAnimInstance::NewAnimInstance' has a wrong offset!");

// Function G01.GzLayerCharacterAnimInstance.SetPlayrateToMatchSpeed
// 0x0038 (0x0038 - 0x0000)
struct GzLayerCharacterAnimInstance_SetPlayrateToMatchSpeed final
{
public:
	struct FSequencePlayerReference               SequencePlayer;                                    // 0x0000(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	float                                         SpeedToMatch;                                      // 0x0010(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2CA3[0x4];                                     // 0x0014(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector2D                              PlayRateClamp;                                     // 0x0018(0x0010)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSequencePlayerReference               ReturnValue;                                       // 0x0028(0x0010)(Parm, OutParm, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzLayerCharacterAnimInstance_SetPlayrateToMatchSpeed) == 0x000008, "Wrong alignment on GzLayerCharacterAnimInstance_SetPlayrateToMatchSpeed");
static_assert(sizeof(GzLayerCharacterAnimInstance_SetPlayrateToMatchSpeed) == 0x000038, "Wrong size on GzLayerCharacterAnimInstance_SetPlayrateToMatchSpeed");
static_assert(offsetof(GzLayerCharacterAnimInstance_SetPlayrateToMatchSpeed, SequencePlayer) == 0x000000, "Member 'GzLayerCharacterAnimInstance_SetPlayrateToMatchSpeed::SequencePlayer' has a wrong offset!");
static_assert(offsetof(GzLayerCharacterAnimInstance_SetPlayrateToMatchSpeed, SpeedToMatch) == 0x000010, "Member 'GzLayerCharacterAnimInstance_SetPlayrateToMatchSpeed::SpeedToMatch' has a wrong offset!");
static_assert(offsetof(GzLayerCharacterAnimInstance_SetPlayrateToMatchSpeed, PlayRateClamp) == 0x000018, "Member 'GzLayerCharacterAnimInstance_SetPlayrateToMatchSpeed::PlayRateClamp' has a wrong offset!");
static_assert(offsetof(GzLayerCharacterAnimInstance_SetPlayrateToMatchSpeed, ReturnValue) == 0x000028, "Member 'GzLayerCharacterAnimInstance_SetPlayrateToMatchSpeed::ReturnValue' has a wrong offset!");

// Function G01.GzLayerCharacterAnimInstance.GetDefaultAnimInstance
// 0x0008 (0x0008 - 0x0000)
struct GzLayerCharacterAnimInstance_GetDefaultAnimInstance final
{
public:
	class UAnimInstance*                          ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzLayerCharacterAnimInstance_GetDefaultAnimInstance) == 0x000008, "Wrong alignment on GzLayerCharacterAnimInstance_GetDefaultAnimInstance");
static_assert(sizeof(GzLayerCharacterAnimInstance_GetDefaultAnimInstance) == 0x000008, "Wrong size on GzLayerCharacterAnimInstance_GetDefaultAnimInstance");
static_assert(offsetof(GzLayerCharacterAnimInstance_GetDefaultAnimInstance, ReturnValue) == 0x000000, "Member 'GzLayerCharacterAnimInstance_GetDefaultAnimInstance::ReturnValue' has a wrong offset!");

// Function G01.GzLayerCharacterAnimInstance.GetLayerType
// 0x0001 (0x0001 - 0x0000)
struct GzLayerCharacterAnimInstance_GetLayerType final
{
public:
	EGzLayerItemType                              ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzLayerCharacterAnimInstance_GetLayerType) == 0x000001, "Wrong alignment on GzLayerCharacterAnimInstance_GetLayerType");
static_assert(sizeof(GzLayerCharacterAnimInstance_GetLayerType) == 0x000001, "Wrong size on GzLayerCharacterAnimInstance_GetLayerType");
static_assert(offsetof(GzLayerCharacterAnimInstance_GetLayerType, ReturnValue) == 0x000000, "Member 'GzLayerCharacterAnimInstance_GetLayerType::ReturnValue' has a wrong offset!");

// Function G01.GzLayerCharacterAnimInstance.PredictGroundMovementPivotLocation
// 0x0050 (0x0050 - 0x0000)
struct GzLayerCharacterAnimInstance_PredictGroundMovementPivotLocation final
{
public:
	struct FVector                                Acceleration;                                      // 0x0000(0x0018)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Velocity;                                          // 0x0018(0x0018)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         GroundFriction;                                    // 0x0030(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2CA4[0x4];                                     // 0x0034(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                ReturnValue;                                       // 0x0038(0x0018)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzLayerCharacterAnimInstance_PredictGroundMovementPivotLocation) == 0x000008, "Wrong alignment on GzLayerCharacterAnimInstance_PredictGroundMovementPivotLocation");
static_assert(sizeof(GzLayerCharacterAnimInstance_PredictGroundMovementPivotLocation) == 0x000050, "Wrong size on GzLayerCharacterAnimInstance_PredictGroundMovementPivotLocation");
static_assert(offsetof(GzLayerCharacterAnimInstance_PredictGroundMovementPivotLocation, Acceleration) == 0x000000, "Member 'GzLayerCharacterAnimInstance_PredictGroundMovementPivotLocation::Acceleration' has a wrong offset!");
static_assert(offsetof(GzLayerCharacterAnimInstance_PredictGroundMovementPivotLocation, Velocity) == 0x000018, "Member 'GzLayerCharacterAnimInstance_PredictGroundMovementPivotLocation::Velocity' has a wrong offset!");
static_assert(offsetof(GzLayerCharacterAnimInstance_PredictGroundMovementPivotLocation, GroundFriction) == 0x000030, "Member 'GzLayerCharacterAnimInstance_PredictGroundMovementPivotLocation::GroundFriction' has a wrong offset!");
static_assert(offsetof(GzLayerCharacterAnimInstance_PredictGroundMovementPivotLocation, ReturnValue) == 0x000038, "Member 'GzLayerCharacterAnimInstance_PredictGroundMovementPivotLocation::ReturnValue' has a wrong offset!");

// Function G01.GzLayerCharacterAnimInstance.PredictGroundMovementStopLocation
// 0x0048 (0x0048 - 0x0000)
struct GzLayerCharacterAnimInstance_PredictGroundMovementStopLocation final
{
public:
	struct FVector                                Velocity;                                          // 0x0000(0x0018)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseSeparateBrakingFriction;                       // 0x0018(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2CA5[0x3];                                     // 0x0019(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         BrakingFriction;                                   // 0x001C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         GroundFriction;                                    // 0x0020(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BrakingFrictionFactor;                             // 0x0024(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BrakingDecelerationWalking;                        // 0x0028(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2CA6[0x4];                                     // 0x002C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                ReturnValue;                                       // 0x0030(0x0018)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzLayerCharacterAnimInstance_PredictGroundMovementStopLocation) == 0x000008, "Wrong alignment on GzLayerCharacterAnimInstance_PredictGroundMovementStopLocation");
static_assert(sizeof(GzLayerCharacterAnimInstance_PredictGroundMovementStopLocation) == 0x000048, "Wrong size on GzLayerCharacterAnimInstance_PredictGroundMovementStopLocation");
static_assert(offsetof(GzLayerCharacterAnimInstance_PredictGroundMovementStopLocation, Velocity) == 0x000000, "Member 'GzLayerCharacterAnimInstance_PredictGroundMovementStopLocation::Velocity' has a wrong offset!");
static_assert(offsetof(GzLayerCharacterAnimInstance_PredictGroundMovementStopLocation, bUseSeparateBrakingFriction) == 0x000018, "Member 'GzLayerCharacterAnimInstance_PredictGroundMovementStopLocation::bUseSeparateBrakingFriction' has a wrong offset!");
static_assert(offsetof(GzLayerCharacterAnimInstance_PredictGroundMovementStopLocation, BrakingFriction) == 0x00001C, "Member 'GzLayerCharacterAnimInstance_PredictGroundMovementStopLocation::BrakingFriction' has a wrong offset!");
static_assert(offsetof(GzLayerCharacterAnimInstance_PredictGroundMovementStopLocation, GroundFriction) == 0x000020, "Member 'GzLayerCharacterAnimInstance_PredictGroundMovementStopLocation::GroundFriction' has a wrong offset!");
static_assert(offsetof(GzLayerCharacterAnimInstance_PredictGroundMovementStopLocation, BrakingFrictionFactor) == 0x000024, "Member 'GzLayerCharacterAnimInstance_PredictGroundMovementStopLocation::BrakingFrictionFactor' has a wrong offset!");
static_assert(offsetof(GzLayerCharacterAnimInstance_PredictGroundMovementStopLocation, BrakingDecelerationWalking) == 0x000028, "Member 'GzLayerCharacterAnimInstance_PredictGroundMovementStopLocation::BrakingDecelerationWalking' has a wrong offset!");
static_assert(offsetof(GzLayerCharacterAnimInstance_PredictGroundMovementStopLocation, ReturnValue) == 0x000030, "Member 'GzLayerCharacterAnimInstance_PredictGroundMovementStopLocation::ReturnValue' has a wrong offset!");

// Function G01.GzCharacterCustomizationCheatExtension.SetJetpackVisibility
// 0x0001 (0x0001 - 0x0000)
struct GzCharacterCustomizationCheatExtension_SetJetpackVisibility final
{
public:
	bool                                          bNewVisibility;                                    // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzCharacterCustomizationCheatExtension_SetJetpackVisibility) == 0x000001, "Wrong alignment on GzCharacterCustomizationCheatExtension_SetJetpackVisibility");
static_assert(sizeof(GzCharacterCustomizationCheatExtension_SetJetpackVisibility) == 0x000001, "Wrong size on GzCharacterCustomizationCheatExtension_SetJetpackVisibility");
static_assert(offsetof(GzCharacterCustomizationCheatExtension_SetJetpackVisibility, bNewVisibility) == 0x000000, "Member 'GzCharacterCustomizationCheatExtension_SetJetpackVisibility::bNewVisibility' has a wrong offset!");

// Function G01.GzAbilityHelper.GetAvatar
// 0x0010 (0x0010 - 0x0000)
struct GzAbilityHelper_GetAvatar final
{
public:
	class UAbilitySystemComponent*                Target;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 ReturnValue;                                       // 0x0008(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzAbilityHelper_GetAvatar) == 0x000008, "Wrong alignment on GzAbilityHelper_GetAvatar");
static_assert(sizeof(GzAbilityHelper_GetAvatar) == 0x000010, "Wrong size on GzAbilityHelper_GetAvatar");
static_assert(offsetof(GzAbilityHelper_GetAvatar, Target) == 0x000000, "Member 'GzAbilityHelper_GetAvatar::Target' has a wrong offset!");
static_assert(offsetof(GzAbilityHelper_GetAvatar, ReturnValue) == 0x000008, "Member 'GzAbilityHelper_GetAvatar::ReturnValue' has a wrong offset!");

// Function G01.GzAbilityHelper.GetGameplayEffectDefinition
// 0x02B0 (0x02B0 - 0x0000)
struct GzAbilityHelper_GetGameplayEffectDefinition final
{
public:
	class UAbilitySystemComponent*                Target;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayEffectSpec                    Spec;                                              // 0x0008(0x02A0)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	TSubclassOf<class UGameplayEffect>            ReturnValue;                                       // 0x02A8(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzAbilityHelper_GetGameplayEffectDefinition) == 0x000008, "Wrong alignment on GzAbilityHelper_GetGameplayEffectDefinition");
static_assert(sizeof(GzAbilityHelper_GetGameplayEffectDefinition) == 0x0002B0, "Wrong size on GzAbilityHelper_GetGameplayEffectDefinition");
static_assert(offsetof(GzAbilityHelper_GetGameplayEffectDefinition, Target) == 0x000000, "Member 'GzAbilityHelper_GetGameplayEffectDefinition::Target' has a wrong offset!");
static_assert(offsetof(GzAbilityHelper_GetGameplayEffectDefinition, Spec) == 0x000008, "Member 'GzAbilityHelper_GetGameplayEffectDefinition::Spec' has a wrong offset!");
static_assert(offsetof(GzAbilityHelper_GetGameplayEffectDefinition, ReturnValue) == 0x0002A8, "Member 'GzAbilityHelper_GetGameplayEffectDefinition::ReturnValue' has a wrong offset!");

// Function G01.GzAbilityHelper.GetInstigatorOfEffect
// 0x02A8 (0x02A8 - 0x0000)
struct GzAbilityHelper_GetInstigatorOfEffect final
{
public:
	struct FGameplayEffectSpec                    Spec;                                              // 0x0000(0x02A0)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	class UAbilitySystemComponent*                ReturnValue;                                       // 0x02A0(0x0008)(ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzAbilityHelper_GetInstigatorOfEffect) == 0x000008, "Wrong alignment on GzAbilityHelper_GetInstigatorOfEffect");
static_assert(sizeof(GzAbilityHelper_GetInstigatorOfEffect) == 0x0002A8, "Wrong size on GzAbilityHelper_GetInstigatorOfEffect");
static_assert(offsetof(GzAbilityHelper_GetInstigatorOfEffect, Spec) == 0x000000, "Member 'GzAbilityHelper_GetInstigatorOfEffect::Spec' has a wrong offset!");
static_assert(offsetof(GzAbilityHelper_GetInstigatorOfEffect, ReturnValue) == 0x0002A0, "Member 'GzAbilityHelper_GetInstigatorOfEffect::ReturnValue' has a wrong offset!");

// Function G01.GzAbilityHelper.GetOwner
// 0x0010 (0x0010 - 0x0000)
struct GzAbilityHelper_GetOwner final
{
public:
	class UAbilitySystemComponent*                Target;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 ReturnValue;                                       // 0x0008(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzAbilityHelper_GetOwner) == 0x000008, "Wrong alignment on GzAbilityHelper_GetOwner");
static_assert(sizeof(GzAbilityHelper_GetOwner) == 0x000010, "Wrong size on GzAbilityHelper_GetOwner");
static_assert(offsetof(GzAbilityHelper_GetOwner, Target) == 0x000000, "Member 'GzAbilityHelper_GetOwner::Target' has a wrong offset!");
static_assert(offsetof(GzAbilityHelper_GetOwner, ReturnValue) == 0x000008, "Member 'GzAbilityHelper_GetOwner::ReturnValue' has a wrong offset!");

// Function G01.GzAbilityHelper.GetPlayerIdFromASC
// 0x0010 (0x0010 - 0x0000)
struct GzAbilityHelper_GetPlayerIdFromASC final
{
public:
	const class UAbilitySystemComponent*          ASC;                                               // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ReturnValue;                                       // 0x0008(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2CA9[0x4];                                     // 0x000C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GzAbilityHelper_GetPlayerIdFromASC) == 0x000008, "Wrong alignment on GzAbilityHelper_GetPlayerIdFromASC");
static_assert(sizeof(GzAbilityHelper_GetPlayerIdFromASC) == 0x000010, "Wrong size on GzAbilityHelper_GetPlayerIdFromASC");
static_assert(offsetof(GzAbilityHelper_GetPlayerIdFromASC, ASC) == 0x000000, "Member 'GzAbilityHelper_GetPlayerIdFromASC::ASC' has a wrong offset!");
static_assert(offsetof(GzAbilityHelper_GetPlayerIdFromASC, ReturnValue) == 0x000008, "Member 'GzAbilityHelper_GetPlayerIdFromASC::ReturnValue' has a wrong offset!");

// Function G01.GzAbilityHelper.GetTeammatesOfASCOwner
// 0x0018 (0x0018 - 0x0000)
struct GzAbilityHelper_GetTeammatesOfASCOwner final
{
public:
	class UAbilitySystemComponent*                Target;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class AGzCharacter*>                   ReturnValue;                                       // 0x0008(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzAbilityHelper_GetTeammatesOfASCOwner) == 0x000008, "Wrong alignment on GzAbilityHelper_GetTeammatesOfASCOwner");
static_assert(sizeof(GzAbilityHelper_GetTeammatesOfASCOwner) == 0x000018, "Wrong size on GzAbilityHelper_GetTeammatesOfASCOwner");
static_assert(offsetof(GzAbilityHelper_GetTeammatesOfASCOwner, Target) == 0x000000, "Member 'GzAbilityHelper_GetTeammatesOfASCOwner::Target' has a wrong offset!");
static_assert(offsetof(GzAbilityHelper_GetTeammatesOfASCOwner, ReturnValue) == 0x000008, "Member 'GzAbilityHelper_GetTeammatesOfASCOwner::ReturnValue' has a wrong offset!");

// Function G01.GzAbilitySystemComponent.SendGameplayEventToActor
// 0x00C8 (0x00C8 - 0x0000)
struct GzAbilitySystemComponent_SendGameplayEventToActor final
{
public:
	class AActor*                                 Actor;                                             // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           EventTag;                                          // 0x0008(0x0008)(Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayEventData                     Payload;                                           // 0x0010(0x00B0)(Parm, NativeAccessSpecifierPublic)
	int32                                         ReturnValue;                                       // 0x00C0(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2CAB[0x4];                                     // 0x00C4(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GzAbilitySystemComponent_SendGameplayEventToActor) == 0x000008, "Wrong alignment on GzAbilitySystemComponent_SendGameplayEventToActor");
static_assert(sizeof(GzAbilitySystemComponent_SendGameplayEventToActor) == 0x0000C8, "Wrong size on GzAbilitySystemComponent_SendGameplayEventToActor");
static_assert(offsetof(GzAbilitySystemComponent_SendGameplayEventToActor, Actor) == 0x000000, "Member 'GzAbilitySystemComponent_SendGameplayEventToActor::Actor' has a wrong offset!");
static_assert(offsetof(GzAbilitySystemComponent_SendGameplayEventToActor, EventTag) == 0x000008, "Member 'GzAbilitySystemComponent_SendGameplayEventToActor::EventTag' has a wrong offset!");
static_assert(offsetof(GzAbilitySystemComponent_SendGameplayEventToActor, Payload) == 0x000010, "Member 'GzAbilitySystemComponent_SendGameplayEventToActor::Payload' has a wrong offset!");
static_assert(offsetof(GzAbilitySystemComponent_SendGameplayEventToActor, ReturnValue) == 0x0000C0, "Member 'GzAbilitySystemComponent_SendGameplayEventToActor::ReturnValue' has a wrong offset!");

// Function G01.GzAbilitySystemComponent.AddGameplayCueLocal
// 0x00E0 (0x00E0 - 0x0000)
struct GzAbilitySystemComponent_AddGameplayCueLocal final
{
public:
	struct FGameplayTag                           GameplayCueTag;                                    // 0x0000(0x0008)(ConstParm, Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayCueParameters                 GameplayCueParameters;                             // 0x0008(0x00D8)(ConstParm, Parm, OutParm, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzAbilitySystemComponent_AddGameplayCueLocal) == 0x000008, "Wrong alignment on GzAbilitySystemComponent_AddGameplayCueLocal");
static_assert(sizeof(GzAbilitySystemComponent_AddGameplayCueLocal) == 0x0000E0, "Wrong size on GzAbilitySystemComponent_AddGameplayCueLocal");
static_assert(offsetof(GzAbilitySystemComponent_AddGameplayCueLocal, GameplayCueTag) == 0x000000, "Member 'GzAbilitySystemComponent_AddGameplayCueLocal::GameplayCueTag' has a wrong offset!");
static_assert(offsetof(GzAbilitySystemComponent_AddGameplayCueLocal, GameplayCueParameters) == 0x000008, "Member 'GzAbilitySystemComponent_AddGameplayCueLocal::GameplayCueParameters' has a wrong offset!");

// Function G01.GzAbilitySystemComponent.BP_ApplyGameplayEffectFromActor
// 0x0030 (0x0030 - 0x0000)
struct GzAbilitySystemComponent_BP_ApplyGameplayEffectFromActor final
{
public:
	TSubclassOf<class UGameplayEffect>            GameplayEffectClass;                               // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 EffectCauser;                                      // 0x0008(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                EffectOrigin;                                      // 0x0010(0x0018)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FActiveGameplayEffectHandle            ReturnValue;                                       // 0x0028(0x0008)(Parm, OutParm, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzAbilitySystemComponent_BP_ApplyGameplayEffectFromActor) == 0x000008, "Wrong alignment on GzAbilitySystemComponent_BP_ApplyGameplayEffectFromActor");
static_assert(sizeof(GzAbilitySystemComponent_BP_ApplyGameplayEffectFromActor) == 0x000030, "Wrong size on GzAbilitySystemComponent_BP_ApplyGameplayEffectFromActor");
static_assert(offsetof(GzAbilitySystemComponent_BP_ApplyGameplayEffectFromActor, GameplayEffectClass) == 0x000000, "Member 'GzAbilitySystemComponent_BP_ApplyGameplayEffectFromActor::GameplayEffectClass' has a wrong offset!");
static_assert(offsetof(GzAbilitySystemComponent_BP_ApplyGameplayEffectFromActor, EffectCauser) == 0x000008, "Member 'GzAbilitySystemComponent_BP_ApplyGameplayEffectFromActor::EffectCauser' has a wrong offset!");
static_assert(offsetof(GzAbilitySystemComponent_BP_ApplyGameplayEffectFromActor, EffectOrigin) == 0x000010, "Member 'GzAbilitySystemComponent_BP_ApplyGameplayEffectFromActor::EffectOrigin' has a wrong offset!");
static_assert(offsetof(GzAbilitySystemComponent_BP_ApplyGameplayEffectFromActor, ReturnValue) == 0x000028, "Member 'GzAbilitySystemComponent_BP_ApplyGameplayEffectFromActor::ReturnValue' has a wrong offset!");

// Function G01.GzAbilitySystemComponent.BP_ApplyGameplayEffectFromActorWithCustomMagnitudes
// 0x0080 (0x0080 - 0x0000)
struct GzAbilitySystemComponent_BP_ApplyGameplayEffectFromActorWithCustomMagnitudes final
{
public:
	TSubclassOf<class UGameplayEffect>            GameplayEffectClass;                               // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 EffectCauser;                                      // 0x0008(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMap<struct FGameplayTag, float>              SetSetByCallerMagnitudes;                          // 0x0010(0x0050)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	struct FVector                                EffectOrigin;                                      // 0x0060(0x0018)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FActiveGameplayEffectHandle            ReturnValue;                                       // 0x0078(0x0008)(Parm, OutParm, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzAbilitySystemComponent_BP_ApplyGameplayEffectFromActorWithCustomMagnitudes) == 0x000008, "Wrong alignment on GzAbilitySystemComponent_BP_ApplyGameplayEffectFromActorWithCustomMagnitudes");
static_assert(sizeof(GzAbilitySystemComponent_BP_ApplyGameplayEffectFromActorWithCustomMagnitudes) == 0x000080, "Wrong size on GzAbilitySystemComponent_BP_ApplyGameplayEffectFromActorWithCustomMagnitudes");
static_assert(offsetof(GzAbilitySystemComponent_BP_ApplyGameplayEffectFromActorWithCustomMagnitudes, GameplayEffectClass) == 0x000000, "Member 'GzAbilitySystemComponent_BP_ApplyGameplayEffectFromActorWithCustomMagnitudes::GameplayEffectClass' has a wrong offset!");
static_assert(offsetof(GzAbilitySystemComponent_BP_ApplyGameplayEffectFromActorWithCustomMagnitudes, EffectCauser) == 0x000008, "Member 'GzAbilitySystemComponent_BP_ApplyGameplayEffectFromActorWithCustomMagnitudes::EffectCauser' has a wrong offset!");
static_assert(offsetof(GzAbilitySystemComponent_BP_ApplyGameplayEffectFromActorWithCustomMagnitudes, SetSetByCallerMagnitudes) == 0x000010, "Member 'GzAbilitySystemComponent_BP_ApplyGameplayEffectFromActorWithCustomMagnitudes::SetSetByCallerMagnitudes' has a wrong offset!");
static_assert(offsetof(GzAbilitySystemComponent_BP_ApplyGameplayEffectFromActorWithCustomMagnitudes, EffectOrigin) == 0x000060, "Member 'GzAbilitySystemComponent_BP_ApplyGameplayEffectFromActorWithCustomMagnitudes::EffectOrigin' has a wrong offset!");
static_assert(offsetof(GzAbilitySystemComponent_BP_ApplyGameplayEffectFromActorWithCustomMagnitudes, ReturnValue) == 0x000078, "Member 'GzAbilitySystemComponent_BP_ApplyGameplayEffectFromActorWithCustomMagnitudes::ReturnValue' has a wrong offset!");

// Function G01.GzAbilitySystemComponent.BP_ApplyGameplayEffectToSelfWithPrediction
// 0x0030 (0x0030 - 0x0000)
struct GzAbilitySystemComponent_BP_ApplyGameplayEffectToSelfWithPrediction final
{
public:
	TSubclassOf<class UGameplayEffect>            GameplayEffectClass;                               // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Level;                                             // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2CAC[0x4];                                     // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayEffectContextHandle           EffectContext;                                     // 0x0010(0x0018)(Parm, NativeAccessSpecifierPublic)
	struct FActiveGameplayEffectHandle            ReturnValue;                                       // 0x0028(0x0008)(Parm, OutParm, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzAbilitySystemComponent_BP_ApplyGameplayEffectToSelfWithPrediction) == 0x000008, "Wrong alignment on GzAbilitySystemComponent_BP_ApplyGameplayEffectToSelfWithPrediction");
static_assert(sizeof(GzAbilitySystemComponent_BP_ApplyGameplayEffectToSelfWithPrediction) == 0x000030, "Wrong size on GzAbilitySystemComponent_BP_ApplyGameplayEffectToSelfWithPrediction");
static_assert(offsetof(GzAbilitySystemComponent_BP_ApplyGameplayEffectToSelfWithPrediction, GameplayEffectClass) == 0x000000, "Member 'GzAbilitySystemComponent_BP_ApplyGameplayEffectToSelfWithPrediction::GameplayEffectClass' has a wrong offset!");
static_assert(offsetof(GzAbilitySystemComponent_BP_ApplyGameplayEffectToSelfWithPrediction, Level) == 0x000008, "Member 'GzAbilitySystemComponent_BP_ApplyGameplayEffectToSelfWithPrediction::Level' has a wrong offset!");
static_assert(offsetof(GzAbilitySystemComponent_BP_ApplyGameplayEffectToSelfWithPrediction, EffectContext) == 0x000010, "Member 'GzAbilitySystemComponent_BP_ApplyGameplayEffectToSelfWithPrediction::EffectContext' has a wrong offset!");
static_assert(offsetof(GzAbilitySystemComponent_BP_ApplyGameplayEffectToSelfWithPrediction, ReturnValue) == 0x000028, "Member 'GzAbilitySystemComponent_BP_ApplyGameplayEffectToSelfWithPrediction::ReturnValue' has a wrong offset!");

// Function G01.GzAbilitySystemComponent.BP_ApplyGameplayEffectToTargetWithPrediction
// 0x0038 (0x0038 - 0x0000)
struct GzAbilitySystemComponent_BP_ApplyGameplayEffectToTargetWithPrediction final
{
public:
	TSubclassOf<class UGameplayEffect>            GameplayEffectClass;                               // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAbilitySystemComponent*                Target;                                            // 0x0008(0x0008)(Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Level;                                             // 0x0010(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2CAD[0x4];                                     // 0x0014(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayEffectContextHandle           Context;                                           // 0x0018(0x0018)(Parm, NativeAccessSpecifierPublic)
	struct FActiveGameplayEffectHandle            ReturnValue;                                       // 0x0030(0x0008)(Parm, OutParm, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzAbilitySystemComponent_BP_ApplyGameplayEffectToTargetWithPrediction) == 0x000008, "Wrong alignment on GzAbilitySystemComponent_BP_ApplyGameplayEffectToTargetWithPrediction");
static_assert(sizeof(GzAbilitySystemComponent_BP_ApplyGameplayEffectToTargetWithPrediction) == 0x000038, "Wrong size on GzAbilitySystemComponent_BP_ApplyGameplayEffectToTargetWithPrediction");
static_assert(offsetof(GzAbilitySystemComponent_BP_ApplyGameplayEffectToTargetWithPrediction, GameplayEffectClass) == 0x000000, "Member 'GzAbilitySystemComponent_BP_ApplyGameplayEffectToTargetWithPrediction::GameplayEffectClass' has a wrong offset!");
static_assert(offsetof(GzAbilitySystemComponent_BP_ApplyGameplayEffectToTargetWithPrediction, Target) == 0x000008, "Member 'GzAbilitySystemComponent_BP_ApplyGameplayEffectToTargetWithPrediction::Target' has a wrong offset!");
static_assert(offsetof(GzAbilitySystemComponent_BP_ApplyGameplayEffectToTargetWithPrediction, Level) == 0x000010, "Member 'GzAbilitySystemComponent_BP_ApplyGameplayEffectToTargetWithPrediction::Level' has a wrong offset!");
static_assert(offsetof(GzAbilitySystemComponent_BP_ApplyGameplayEffectToTargetWithPrediction, Context) == 0x000018, "Member 'GzAbilitySystemComponent_BP_ApplyGameplayEffectToTargetWithPrediction::Context' has a wrong offset!");
static_assert(offsetof(GzAbilitySystemComponent_BP_ApplyGameplayEffectToTargetWithPrediction, ReturnValue) == 0x000030, "Member 'GzAbilitySystemComponent_BP_ApplyGameplayEffectToTargetWithPrediction::ReturnValue' has a wrong offset!");

// Function G01.GzAbilitySystemComponent.CancelAbilityByClass
// 0x0008 (0x0008 - 0x0000)
struct GzAbilitySystemComponent_CancelAbilityByClass final
{
public:
	TSubclassOf<class UGameplayAbility>           InAbilityToCancel;                                 // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzAbilitySystemComponent_CancelAbilityByClass) == 0x000008, "Wrong alignment on GzAbilitySystemComponent_CancelAbilityByClass");
static_assert(sizeof(GzAbilitySystemComponent_CancelAbilityByClass) == 0x000008, "Wrong size on GzAbilitySystemComponent_CancelAbilityByClass");
static_assert(offsetof(GzAbilitySystemComponent_CancelAbilityByClass, InAbilityToCancel) == 0x000000, "Member 'GzAbilitySystemComponent_CancelAbilityByClass::InAbilityToCancel' has a wrong offset!");

// Function G01.GzAbilitySystemComponent.CancelAbilityByTag
// 0x0008 (0x0008 - 0x0000)
struct GzAbilitySystemComponent_CancelAbilityByTag final
{
public:
	struct FGameplayTag                           AbilityTag;                                        // 0x0000(0x0008)(Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzAbilitySystemComponent_CancelAbilityByTag) == 0x000004, "Wrong alignment on GzAbilitySystemComponent_CancelAbilityByTag");
static_assert(sizeof(GzAbilitySystemComponent_CancelAbilityByTag) == 0x000008, "Wrong size on GzAbilitySystemComponent_CancelAbilityByTag");
static_assert(offsetof(GzAbilitySystemComponent_CancelAbilityByTag, AbilityTag) == 0x000000, "Member 'GzAbilitySystemComponent_CancelAbilityByTag::AbilityTag' has a wrong offset!");

// Function G01.GzAbilitySystemComponent.ClientPreEndAbility
// 0x0028 (0x0028 - 0x0000)
struct GzAbilitySystemComponent_ClientPreEndAbility final
{
public:
	struct FGameplayAbilitySpecHandle             AbilityToPreEnd;                                   // 0x0000(0x0004)(Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2CAE[0x4];                                     // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayAbilityActivationInfo         ActivationInfo;                                    // 0x0008(0x0018)(Parm, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          bWasCancelled;                                     // 0x0020(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2CAF[0x7];                                     // 0x0021(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GzAbilitySystemComponent_ClientPreEndAbility) == 0x000008, "Wrong alignment on GzAbilitySystemComponent_ClientPreEndAbility");
static_assert(sizeof(GzAbilitySystemComponent_ClientPreEndAbility) == 0x000028, "Wrong size on GzAbilitySystemComponent_ClientPreEndAbility");
static_assert(offsetof(GzAbilitySystemComponent_ClientPreEndAbility, AbilityToPreEnd) == 0x000000, "Member 'GzAbilitySystemComponent_ClientPreEndAbility::AbilityToPreEnd' has a wrong offset!");
static_assert(offsetof(GzAbilitySystemComponent_ClientPreEndAbility, ActivationInfo) == 0x000008, "Member 'GzAbilitySystemComponent_ClientPreEndAbility::ActivationInfo' has a wrong offset!");
static_assert(offsetof(GzAbilitySystemComponent_ClientPreEndAbility, bWasCancelled) == 0x000020, "Member 'GzAbilitySystemComponent_ClientPreEndAbility::bWasCancelled' has a wrong offset!");

// Function G01.GzAbilitySystemComponent.ExecuteGameplayCueLocal
// 0x00E0 (0x00E0 - 0x0000)
struct GzAbilitySystemComponent_ExecuteGameplayCueLocal final
{
public:
	struct FGameplayTag                           GameplayCueTag;                                    // 0x0000(0x0008)(ConstParm, Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayCueParameters                 GameplayCueParameters;                             // 0x0008(0x00D8)(ConstParm, Parm, OutParm, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzAbilitySystemComponent_ExecuteGameplayCueLocal) == 0x000008, "Wrong alignment on GzAbilitySystemComponent_ExecuteGameplayCueLocal");
static_assert(sizeof(GzAbilitySystemComponent_ExecuteGameplayCueLocal) == 0x0000E0, "Wrong size on GzAbilitySystemComponent_ExecuteGameplayCueLocal");
static_assert(offsetof(GzAbilitySystemComponent_ExecuteGameplayCueLocal, GameplayCueTag) == 0x000000, "Member 'GzAbilitySystemComponent_ExecuteGameplayCueLocal::GameplayCueTag' has a wrong offset!");
static_assert(offsetof(GzAbilitySystemComponent_ExecuteGameplayCueLocal, GameplayCueParameters) == 0x000008, "Member 'GzAbilitySystemComponent_ExecuteGameplayCueLocal::GameplayCueParameters' has a wrong offset!");

// Function G01.GzAbilitySystemComponent.FindAbilitiesFromAbilityTag
// 0x0018 (0x0018 - 0x0000)
struct GzAbilitySystemComponent_FindAbilitiesFromAbilityTag final
{
public:
	struct FGameplayTag                           AbilityTag;                                        // 0x0000(0x0008)(ConstParm, Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class UGameplayAbility*>               OutAbilities;                                      // 0x0008(0x0010)(Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzAbilitySystemComponent_FindAbilitiesFromAbilityTag) == 0x000008, "Wrong alignment on GzAbilitySystemComponent_FindAbilitiesFromAbilityTag");
static_assert(sizeof(GzAbilitySystemComponent_FindAbilitiesFromAbilityTag) == 0x000018, "Wrong size on GzAbilitySystemComponent_FindAbilitiesFromAbilityTag");
static_assert(offsetof(GzAbilitySystemComponent_FindAbilitiesFromAbilityTag, AbilityTag) == 0x000000, "Member 'GzAbilitySystemComponent_FindAbilitiesFromAbilityTag::AbilityTag' has a wrong offset!");
static_assert(offsetof(GzAbilitySystemComponent_FindAbilitiesFromAbilityTag, OutAbilities) == 0x000008, "Member 'GzAbilitySystemComponent_FindAbilitiesFromAbilityTag::OutAbilities' has a wrong offset!");

// Function G01.GzAbilitySystemComponent.FindAbilitySpecHandleForClass
// 0x0018 (0x0018 - 0x0000)
struct GzAbilitySystemComponent_FindAbilitySpecHandleForClass final
{
public:
	TSubclassOf<class UGameplayAbility>           AbilityClass;                                      // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UObject*                                OptionalSourceObject;                              // 0x0008(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayAbilitySpecHandle             ReturnValue;                                       // 0x0010(0x0004)(Parm, OutParm, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2CB0[0x4];                                     // 0x0014(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GzAbilitySystemComponent_FindAbilitySpecHandleForClass) == 0x000008, "Wrong alignment on GzAbilitySystemComponent_FindAbilitySpecHandleForClass");
static_assert(sizeof(GzAbilitySystemComponent_FindAbilitySpecHandleForClass) == 0x000018, "Wrong size on GzAbilitySystemComponent_FindAbilitySpecHandleForClass");
static_assert(offsetof(GzAbilitySystemComponent_FindAbilitySpecHandleForClass, AbilityClass) == 0x000000, "Member 'GzAbilitySystemComponent_FindAbilitySpecHandleForClass::AbilityClass' has a wrong offset!");
static_assert(offsetof(GzAbilitySystemComponent_FindAbilitySpecHandleForClass, OptionalSourceObject) == 0x000008, "Member 'GzAbilitySystemComponent_FindAbilitySpecHandleForClass::OptionalSourceObject' has a wrong offset!");
static_assert(offsetof(GzAbilitySystemComponent_FindAbilitySpecHandleForClass, ReturnValue) == 0x000010, "Member 'GzAbilitySystemComponent_FindAbilitySpecHandleForClass::ReturnValue' has a wrong offset!");

// Function G01.GzAbilitySystemComponent.LinkAbilityAnimLayer
// 0x0030 (0x0030 - 0x0000)
struct GzAbilitySystemComponent_LinkAbilityAnimLayer final
{
public:
	class UGzGameplayAbility*                     ActivatingAbility;                                 // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftClassPtr<class UClass>                   AnimLayer;                                         // 0x0008(0x0028)(ConstParm, Parm, OutParm, ReferenceParm, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzAbilitySystemComponent_LinkAbilityAnimLayer) == 0x000008, "Wrong alignment on GzAbilitySystemComponent_LinkAbilityAnimLayer");
static_assert(sizeof(GzAbilitySystemComponent_LinkAbilityAnimLayer) == 0x000030, "Wrong size on GzAbilitySystemComponent_LinkAbilityAnimLayer");
static_assert(offsetof(GzAbilitySystemComponent_LinkAbilityAnimLayer, ActivatingAbility) == 0x000000, "Member 'GzAbilitySystemComponent_LinkAbilityAnimLayer::ActivatingAbility' has a wrong offset!");
static_assert(offsetof(GzAbilitySystemComponent_LinkAbilityAnimLayer, AnimLayer) == 0x000008, "Member 'GzAbilitySystemComponent_LinkAbilityAnimLayer::AnimLayer' has a wrong offset!");

// Function G01.GzAbilitySystemComponent.RemoveGameplayCueLocal
// 0x00E0 (0x00E0 - 0x0000)
struct GzAbilitySystemComponent_RemoveGameplayCueLocal final
{
public:
	struct FGameplayTag                           GameplayCueTag;                                    // 0x0000(0x0008)(ConstParm, Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayCueParameters                 GameplayCueParameters;                             // 0x0008(0x00D8)(ConstParm, Parm, OutParm, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzAbilitySystemComponent_RemoveGameplayCueLocal) == 0x000008, "Wrong alignment on GzAbilitySystemComponent_RemoveGameplayCueLocal");
static_assert(sizeof(GzAbilitySystemComponent_RemoveGameplayCueLocal) == 0x0000E0, "Wrong size on GzAbilitySystemComponent_RemoveGameplayCueLocal");
static_assert(offsetof(GzAbilitySystemComponent_RemoveGameplayCueLocal, GameplayCueTag) == 0x000000, "Member 'GzAbilitySystemComponent_RemoveGameplayCueLocal::GameplayCueTag' has a wrong offset!");
static_assert(offsetof(GzAbilitySystemComponent_RemoveGameplayCueLocal, GameplayCueParameters) == 0x000008, "Member 'GzAbilitySystemComponent_RemoveGameplayCueLocal::GameplayCueParameters' has a wrong offset!");

// Function G01.GzAbilitySystemComponent.ServerPreEndAbility
// 0x0038 (0x0038 - 0x0000)
struct GzAbilitySystemComponent_ServerPreEndAbility final
{
public:
	struct FGameplayAbilitySpecHandle             AbilityToPreEnd;                                   // 0x0000(0x0004)(Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2CB1[0x4];                                     // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayAbilityActivationInfo         ActivationInfo;                                    // 0x0008(0x0018)(Parm, NoDestructor, NativeAccessSpecifierPublic)
	struct FPredictionKey                         PredictionKey;                                     // 0x0020(0x0010)(Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bWasCancelled;                                     // 0x0030(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2CB2[0x7];                                     // 0x0031(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GzAbilitySystemComponent_ServerPreEndAbility) == 0x000008, "Wrong alignment on GzAbilitySystemComponent_ServerPreEndAbility");
static_assert(sizeof(GzAbilitySystemComponent_ServerPreEndAbility) == 0x000038, "Wrong size on GzAbilitySystemComponent_ServerPreEndAbility");
static_assert(offsetof(GzAbilitySystemComponent_ServerPreEndAbility, AbilityToPreEnd) == 0x000000, "Member 'GzAbilitySystemComponent_ServerPreEndAbility::AbilityToPreEnd' has a wrong offset!");
static_assert(offsetof(GzAbilitySystemComponent_ServerPreEndAbility, ActivationInfo) == 0x000008, "Member 'GzAbilitySystemComponent_ServerPreEndAbility::ActivationInfo' has a wrong offset!");
static_assert(offsetof(GzAbilitySystemComponent_ServerPreEndAbility, PredictionKey) == 0x000020, "Member 'GzAbilitySystemComponent_ServerPreEndAbility::PredictionKey' has a wrong offset!");
static_assert(offsetof(GzAbilitySystemComponent_ServerPreEndAbility, bWasCancelled) == 0x000030, "Member 'GzAbilitySystemComponent_ServerPreEndAbility::bWasCancelled' has a wrong offset!");

// Function G01.GzAbilitySystemComponent.TryPressAbilityInputByTag
// 0x000C (0x000C - 0x0000)
struct GzAbilitySystemComponent_TryPressAbilityInputByTag final
{
public:
	struct FGameplayTag                           AbilityTag;                                        // 0x0000(0x0008)(Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2CB3[0x3];                                     // 0x0009(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GzAbilitySystemComponent_TryPressAbilityInputByTag) == 0x000004, "Wrong alignment on GzAbilitySystemComponent_TryPressAbilityInputByTag");
static_assert(sizeof(GzAbilitySystemComponent_TryPressAbilityInputByTag) == 0x00000C, "Wrong size on GzAbilitySystemComponent_TryPressAbilityInputByTag");
static_assert(offsetof(GzAbilitySystemComponent_TryPressAbilityInputByTag, AbilityTag) == 0x000000, "Member 'GzAbilitySystemComponent_TryPressAbilityInputByTag::AbilityTag' has a wrong offset!");
static_assert(offsetof(GzAbilitySystemComponent_TryPressAbilityInputByTag, ReturnValue) == 0x000008, "Member 'GzAbilitySystemComponent_TryPressAbilityInputByTag::ReturnValue' has a wrong offset!");

// Function G01.GzAbilitySystemComponent.TryReleaseAbilityInputByTag
// 0x000C (0x000C - 0x0000)
struct GzAbilitySystemComponent_TryReleaseAbilityInputByTag final
{
public:
	struct FGameplayTag                           AbilityTag;                                        // 0x0000(0x0008)(Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2CB4[0x3];                                     // 0x0009(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GzAbilitySystemComponent_TryReleaseAbilityInputByTag) == 0x000004, "Wrong alignment on GzAbilitySystemComponent_TryReleaseAbilityInputByTag");
static_assert(sizeof(GzAbilitySystemComponent_TryReleaseAbilityInputByTag) == 0x00000C, "Wrong size on GzAbilitySystemComponent_TryReleaseAbilityInputByTag");
static_assert(offsetof(GzAbilitySystemComponent_TryReleaseAbilityInputByTag, AbilityTag) == 0x000000, "Member 'GzAbilitySystemComponent_TryReleaseAbilityInputByTag::AbilityTag' has a wrong offset!");
static_assert(offsetof(GzAbilitySystemComponent_TryReleaseAbilityInputByTag, ReturnValue) == 0x000008, "Member 'GzAbilitySystemComponent_TryReleaseAbilityInputByTag::ReturnValue' has a wrong offset!");

// Function G01.GzAbilitySystemComponent.UnlinkAbilityAnimLayer
// 0x0030 (0x0030 - 0x0000)
struct GzAbilitySystemComponent_UnlinkAbilityAnimLayer final
{
public:
	class UGzGameplayAbility*                     ActivatingAbility;                                 // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftClassPtr<class UClass>                   AnimLayer;                                         // 0x0008(0x0028)(ConstParm, Parm, OutParm, ReferenceParm, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzAbilitySystemComponent_UnlinkAbilityAnimLayer) == 0x000008, "Wrong alignment on GzAbilitySystemComponent_UnlinkAbilityAnimLayer");
static_assert(sizeof(GzAbilitySystemComponent_UnlinkAbilityAnimLayer) == 0x000030, "Wrong size on GzAbilitySystemComponent_UnlinkAbilityAnimLayer");
static_assert(offsetof(GzAbilitySystemComponent_UnlinkAbilityAnimLayer, ActivatingAbility) == 0x000000, "Member 'GzAbilitySystemComponent_UnlinkAbilityAnimLayer::ActivatingAbility' has a wrong offset!");
static_assert(offsetof(GzAbilitySystemComponent_UnlinkAbilityAnimLayer, AnimLayer) == 0x000008, "Member 'GzAbilitySystemComponent_UnlinkAbilityAnimLayer::AnimLayer' has a wrong offset!");

// Function G01.GzAbilitySystemComponent.ApplyAdditionalDamageMultipliers
// 0x0060 (0x0060 - 0x0000)
struct GzAbilitySystemComponent_ApplyAdditionalDamageMultipliers final
{
public:
	struct FGameplayEffectSpecHandle              SpecHandle;                                        // 0x0000(0x0010)(Parm, OutParm, NativeAccessSpecifierPublic)
	TMap<struct FGameplayTag, float>              AdditionalMultipliers;                             // 0x0010(0x0050)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzAbilitySystemComponent_ApplyAdditionalDamageMultipliers) == 0x000008, "Wrong alignment on GzAbilitySystemComponent_ApplyAdditionalDamageMultipliers");
static_assert(sizeof(GzAbilitySystemComponent_ApplyAdditionalDamageMultipliers) == 0x000060, "Wrong size on GzAbilitySystemComponent_ApplyAdditionalDamageMultipliers");
static_assert(offsetof(GzAbilitySystemComponent_ApplyAdditionalDamageMultipliers, SpecHandle) == 0x000000, "Member 'GzAbilitySystemComponent_ApplyAdditionalDamageMultipliers::SpecHandle' has a wrong offset!");
static_assert(offsetof(GzAbilitySystemComponent_ApplyAdditionalDamageMultipliers, AdditionalMultipliers) == 0x000010, "Member 'GzAbilitySystemComponent_ApplyAdditionalDamageMultipliers::AdditionalMultipliers' has a wrong offset!");

// Function G01.GzAbilitySystemComponent.CanActivateAbility
// 0x000C (0x000C - 0x0000)
struct GzAbilitySystemComponent_CanActivateAbility final
{
public:
	struct FGameplayTag                           AbilityTag;                                        // 0x0000(0x0008)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2CB5[0x3];                                     // 0x0009(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GzAbilitySystemComponent_CanActivateAbility) == 0x000004, "Wrong alignment on GzAbilitySystemComponent_CanActivateAbility");
static_assert(sizeof(GzAbilitySystemComponent_CanActivateAbility) == 0x00000C, "Wrong size on GzAbilitySystemComponent_CanActivateAbility");
static_assert(offsetof(GzAbilitySystemComponent_CanActivateAbility, AbilityTag) == 0x000000, "Member 'GzAbilitySystemComponent_CanActivateAbility::AbilityTag' has a wrong offset!");
static_assert(offsetof(GzAbilitySystemComponent_CanActivateAbility, ReturnValue) == 0x000008, "Member 'GzAbilitySystemComponent_CanActivateAbility::ReturnValue' has a wrong offset!");

// Function G01.GzAbilitySystemComponent.GetDistanceInMetersToImpact
// 0x0020 (0x0020 - 0x0000)
struct GzAbilitySystemComponent_GetDistanceInMetersToImpact final
{
public:
	struct FVector                                ImpactPoint;                                       // 0x0000(0x0018)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ReturnValue;                                       // 0x0018(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2CB6[0x4];                                     // 0x001C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GzAbilitySystemComponent_GetDistanceInMetersToImpact) == 0x000008, "Wrong alignment on GzAbilitySystemComponent_GetDistanceInMetersToImpact");
static_assert(sizeof(GzAbilitySystemComponent_GetDistanceInMetersToImpact) == 0x000020, "Wrong size on GzAbilitySystemComponent_GetDistanceInMetersToImpact");
static_assert(offsetof(GzAbilitySystemComponent_GetDistanceInMetersToImpact, ImpactPoint) == 0x000000, "Member 'GzAbilitySystemComponent_GetDistanceInMetersToImpact::ImpactPoint' has a wrong offset!");
static_assert(offsetof(GzAbilitySystemComponent_GetDistanceInMetersToImpact, ReturnValue) == 0x000018, "Member 'GzAbilitySystemComponent_GetDistanceInMetersToImpact::ReturnValue' has a wrong offset!");

// Function G01.GzAbilitySystemComponent.GetOngoingEffectDuration
// 0x0010 (0x0010 - 0x0000)
struct GzAbilitySystemComponent_GetOngoingEffectDuration final
{
public:
	TSubclassOf<class UGameplayEffect>            EffectClass;                                       // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ReturnValue;                                       // 0x0008(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2CB7[0x4];                                     // 0x000C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GzAbilitySystemComponent_GetOngoingEffectDuration) == 0x000008, "Wrong alignment on GzAbilitySystemComponent_GetOngoingEffectDuration");
static_assert(sizeof(GzAbilitySystemComponent_GetOngoingEffectDuration) == 0x000010, "Wrong size on GzAbilitySystemComponent_GetOngoingEffectDuration");
static_assert(offsetof(GzAbilitySystemComponent_GetOngoingEffectDuration, EffectClass) == 0x000000, "Member 'GzAbilitySystemComponent_GetOngoingEffectDuration::EffectClass' has a wrong offset!");
static_assert(offsetof(GzAbilitySystemComponent_GetOngoingEffectDuration, ReturnValue) == 0x000008, "Member 'GzAbilitySystemComponent_GetOngoingEffectDuration::ReturnValue' has a wrong offset!");

// Function G01.GzAbilitySystemComponent.IsAbilityActive
// 0x000C (0x000C - 0x0000)
struct GzAbilitySystemComponent_IsAbilityActive final
{
public:
	struct FGameplayTag                           AbilityTag;                                        // 0x0000(0x0008)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2CB8[0x3];                                     // 0x0009(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GzAbilitySystemComponent_IsAbilityActive) == 0x000004, "Wrong alignment on GzAbilitySystemComponent_IsAbilityActive");
static_assert(sizeof(GzAbilitySystemComponent_IsAbilityActive) == 0x00000C, "Wrong size on GzAbilitySystemComponent_IsAbilityActive");
static_assert(offsetof(GzAbilitySystemComponent_IsAbilityActive, AbilityTag) == 0x000000, "Member 'GzAbilitySystemComponent_IsAbilityActive::AbilityTag' has a wrong offset!");
static_assert(offsetof(GzAbilitySystemComponent_IsAbilityActive, ReturnValue) == 0x000008, "Member 'GzAbilitySystemComponent_IsAbilityActive::ReturnValue' has a wrong offset!");

// Function G01.GzAbilitySystemComponent.IsTagBlocked
// 0x000C (0x000C - 0x0000)
struct GzAbilitySystemComponent_IsTagBlocked final
{
public:
	struct FGameplayTag                           Tag;                                               // 0x0000(0x0008)(ConstParm, Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2CB9[0x3];                                     // 0x0009(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GzAbilitySystemComponent_IsTagBlocked) == 0x000004, "Wrong alignment on GzAbilitySystemComponent_IsTagBlocked");
static_assert(sizeof(GzAbilitySystemComponent_IsTagBlocked) == 0x00000C, "Wrong size on GzAbilitySystemComponent_IsTagBlocked");
static_assert(offsetof(GzAbilitySystemComponent_IsTagBlocked, Tag) == 0x000000, "Member 'GzAbilitySystemComponent_IsTagBlocked::Tag' has a wrong offset!");
static_assert(offsetof(GzAbilitySystemComponent_IsTagBlocked, ReturnValue) == 0x000008, "Member 'GzAbilitySystemComponent_IsTagBlocked::ReturnValue' has a wrong offset!");

// Function G01.GzAbilitySystemComponent.K2_GetTagCount
// 0x000C (0x000C - 0x0000)
struct GzAbilitySystemComponent_K2_GetTagCount final
{
public:
	struct FGameplayTag                           TagToCheck;                                        // 0x0000(0x0008)(Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ReturnValue;                                       // 0x0008(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzAbilitySystemComponent_K2_GetTagCount) == 0x000004, "Wrong alignment on GzAbilitySystemComponent_K2_GetTagCount");
static_assert(sizeof(GzAbilitySystemComponent_K2_GetTagCount) == 0x00000C, "Wrong size on GzAbilitySystemComponent_K2_GetTagCount");
static_assert(offsetof(GzAbilitySystemComponent_K2_GetTagCount, TagToCheck) == 0x000000, "Member 'GzAbilitySystemComponent_K2_GetTagCount::TagToCheck' has a wrong offset!");
static_assert(offsetof(GzAbilitySystemComponent_K2_GetTagCount, ReturnValue) == 0x000008, "Member 'GzAbilitySystemComponent_K2_GetTagCount::ReturnValue' has a wrong offset!");

// Function G01.GzAbilitySystemComponent.MakeEffectContextWithInstigator
// 0x0028 (0x0028 - 0x0000)
struct GzAbilitySystemComponent_MakeEffectContextWithInstigator final
{
public:
	class AActor*                                 Instigator;                                        // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 EffectCauser;                                      // 0x0008(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayEffectContextHandle           ReturnValue;                                       // 0x0010(0x0018)(Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzAbilitySystemComponent_MakeEffectContextWithInstigator) == 0x000008, "Wrong alignment on GzAbilitySystemComponent_MakeEffectContextWithInstigator");
static_assert(sizeof(GzAbilitySystemComponent_MakeEffectContextWithInstigator) == 0x000028, "Wrong size on GzAbilitySystemComponent_MakeEffectContextWithInstigator");
static_assert(offsetof(GzAbilitySystemComponent_MakeEffectContextWithInstigator, Instigator) == 0x000000, "Member 'GzAbilitySystemComponent_MakeEffectContextWithInstigator::Instigator' has a wrong offset!");
static_assert(offsetof(GzAbilitySystemComponent_MakeEffectContextWithInstigator, EffectCauser) == 0x000008, "Member 'GzAbilitySystemComponent_MakeEffectContextWithInstigator::EffectCauser' has a wrong offset!");
static_assert(offsetof(GzAbilitySystemComponent_MakeEffectContextWithInstigator, ReturnValue) == 0x000010, "Member 'GzAbilitySystemComponent_MakeEffectContextWithInstigator::ReturnValue' has a wrong offset!");

// Function G01.GzAbilitySystemComponent.MakeOutgoingDamageSpec
// 0x0048 (0x0048 - 0x0000)
struct GzAbilitySystemComponent_MakeOutgoingDamageSpec final
{
public:
	TSubclassOf<class UGzGE_BaseDamage>           GameplayDamageEffectClass;                         // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Level;                                             // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2CBA[0x4];                                     // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayEffectContextHandle           Context;                                           // 0x0010(0x0018)(Parm, NativeAccessSpecifierPublic)
	float                                         Distance;                                          // 0x0028(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RangeCoefficient;                                  // 0x002C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FalloffStrengthCoefficient;                        // 0x0030(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2CBB[0x4];                                     // 0x0034(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayEffectSpecHandle              ReturnValue;                                       // 0x0038(0x0010)(Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzAbilitySystemComponent_MakeOutgoingDamageSpec) == 0x000008, "Wrong alignment on GzAbilitySystemComponent_MakeOutgoingDamageSpec");
static_assert(sizeof(GzAbilitySystemComponent_MakeOutgoingDamageSpec) == 0x000048, "Wrong size on GzAbilitySystemComponent_MakeOutgoingDamageSpec");
static_assert(offsetof(GzAbilitySystemComponent_MakeOutgoingDamageSpec, GameplayDamageEffectClass) == 0x000000, "Member 'GzAbilitySystemComponent_MakeOutgoingDamageSpec::GameplayDamageEffectClass' has a wrong offset!");
static_assert(offsetof(GzAbilitySystemComponent_MakeOutgoingDamageSpec, Level) == 0x000008, "Member 'GzAbilitySystemComponent_MakeOutgoingDamageSpec::Level' has a wrong offset!");
static_assert(offsetof(GzAbilitySystemComponent_MakeOutgoingDamageSpec, Context) == 0x000010, "Member 'GzAbilitySystemComponent_MakeOutgoingDamageSpec::Context' has a wrong offset!");
static_assert(offsetof(GzAbilitySystemComponent_MakeOutgoingDamageSpec, Distance) == 0x000028, "Member 'GzAbilitySystemComponent_MakeOutgoingDamageSpec::Distance' has a wrong offset!");
static_assert(offsetof(GzAbilitySystemComponent_MakeOutgoingDamageSpec, RangeCoefficient) == 0x00002C, "Member 'GzAbilitySystemComponent_MakeOutgoingDamageSpec::RangeCoefficient' has a wrong offset!");
static_assert(offsetof(GzAbilitySystemComponent_MakeOutgoingDamageSpec, FalloffStrengthCoefficient) == 0x000030, "Member 'GzAbilitySystemComponent_MakeOutgoingDamageSpec::FalloffStrengthCoefficient' has a wrong offset!");
static_assert(offsetof(GzAbilitySystemComponent_MakeOutgoingDamageSpec, ReturnValue) == 0x000038, "Member 'GzAbilitySystemComponent_MakeOutgoingDamageSpec::ReturnValue' has a wrong offset!");

// Function G01.GzLoadoutSlot.OnLoadoutSlotReady_BP
// 0x0020 (0x0020 - 0x0000)
struct GzLoadoutSlot_OnLoadoutSlotReady_BP final
{
public:
	struct FGzLoadoutSelectionInitializeData      LoadoutInitializeData;                             // 0x0000(0x0020)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzLoadoutSlot_OnLoadoutSlotReady_BP) == 0x000008, "Wrong alignment on GzLoadoutSlot_OnLoadoutSlotReady_BP");
static_assert(sizeof(GzLoadoutSlot_OnLoadoutSlotReady_BP) == 0x000020, "Wrong size on GzLoadoutSlot_OnLoadoutSlotReady_BP");
static_assert(offsetof(GzLoadoutSlot_OnLoadoutSlotReady_BP, LoadoutInitializeData) == 0x000000, "Member 'GzLoadoutSlot_OnLoadoutSlotReady_BP::LoadoutInitializeData' has a wrong offset!");

// Function G01.GzLoadoutListBase.OnButtonCreated
// 0x0008 (0x0008 - 0x0000)
struct GzLoadoutListBase_OnButtonCreated final
{
public:
	class UGzLoadoutSelectionButton*              NewButton;                                         // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzLoadoutListBase_OnButtonCreated) == 0x000008, "Wrong alignment on GzLoadoutListBase_OnButtonCreated");
static_assert(sizeof(GzLoadoutListBase_OnButtonCreated) == 0x000008, "Wrong size on GzLoadoutListBase_OnButtonCreated");
static_assert(offsetof(GzLoadoutListBase_OnButtonCreated, NewButton) == 0x000000, "Member 'GzLoadoutListBase_OnButtonCreated::NewButton' has a wrong offset!");

// Function G01.GzViewpointClusterBase.GetViewpointNames
// 0x0010 (0x0010 - 0x0000)
struct GzViewpointClusterBase_GetViewpointNames final
{
public:
	TArray<class FString>                         ReturnValue;                                       // 0x0000(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzViewpointClusterBase_GetViewpointNames) == 0x000008, "Wrong alignment on GzViewpointClusterBase_GetViewpointNames");
static_assert(sizeof(GzViewpointClusterBase_GetViewpointNames) == 0x000010, "Wrong size on GzViewpointClusterBase_GetViewpointNames");
static_assert(offsetof(GzViewpointClusterBase_GetViewpointNames, ReturnValue) == 0x000000, "Member 'GzViewpointClusterBase_GetViewpointNames::ReturnValue' has a wrong offset!");

// Function G01.GzAbilityTaskConfig.CheckActivationRequirements
// 0x0100 (0x0100 - 0x0000)
struct GzAbilityTaskConfig_CheckActivationRequirements final
{
public:
	struct FGameplayAbilityActorInfo              ActorInfo;                                         // 0x0000(0x0048)(ConstParm, Parm, OutParm, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FGameplayEventData                     TriggerEventData;                                  // 0x0048(0x00B0)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x00F8(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2CC5[0x7];                                     // 0x00F9(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GzAbilityTaskConfig_CheckActivationRequirements) == 0x000008, "Wrong alignment on GzAbilityTaskConfig_CheckActivationRequirements");
static_assert(sizeof(GzAbilityTaskConfig_CheckActivationRequirements) == 0x000100, "Wrong size on GzAbilityTaskConfig_CheckActivationRequirements");
static_assert(offsetof(GzAbilityTaskConfig_CheckActivationRequirements, ActorInfo) == 0x000000, "Member 'GzAbilityTaskConfig_CheckActivationRequirements::ActorInfo' has a wrong offset!");
static_assert(offsetof(GzAbilityTaskConfig_CheckActivationRequirements, TriggerEventData) == 0x000048, "Member 'GzAbilityTaskConfig_CheckActivationRequirements::TriggerEventData' has a wrong offset!");
static_assert(offsetof(GzAbilityTaskConfig_CheckActivationRequirements, ReturnValue) == 0x0000F8, "Member 'GzAbilityTaskConfig_CheckActivationRequirements::ReturnValue' has a wrong offset!");

// Function G01.GzAbilityTaskConfig.CheckNetExecutionMode
// 0x0050 (0x0050 - 0x0000)
struct GzAbilityTaskConfig_CheckNetExecutionMode final
{
public:
	struct FGameplayAbilityActorInfo              ActorInfo;                                         // 0x0000(0x0048)(ConstParm, Parm, OutParm, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0048(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2CC6[0x7];                                     // 0x0049(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GzAbilityTaskConfig_CheckNetExecutionMode) == 0x000008, "Wrong alignment on GzAbilityTaskConfig_CheckNetExecutionMode");
static_assert(sizeof(GzAbilityTaskConfig_CheckNetExecutionMode) == 0x000050, "Wrong size on GzAbilityTaskConfig_CheckNetExecutionMode");
static_assert(offsetof(GzAbilityTaskConfig_CheckNetExecutionMode, ActorInfo) == 0x000000, "Member 'GzAbilityTaskConfig_CheckNetExecutionMode::ActorInfo' has a wrong offset!");
static_assert(offsetof(GzAbilityTaskConfig_CheckNetExecutionMode, ReturnValue) == 0x000048, "Member 'GzAbilityTaskConfig_CheckNetExecutionMode::ReturnValue' has a wrong offset!");

// Function G01.GzCommonButton.SetText
// 0x0010 (0x0010 - 0x0000)
struct GzCommonButton_SetText final
{
public:
	class FText                                   InText;                                            // 0x0000(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzCommonButton_SetText) == 0x000008, "Wrong alignment on GzCommonButton_SetText");
static_assert(sizeof(GzCommonButton_SetText) == 0x000010, "Wrong size on GzCommonButton_SetText");
static_assert(offsetof(GzCommonButton_SetText, InText) == 0x000000, "Member 'GzCommonButton_SetText::InText' has a wrong offset!");

// Function G01.GzAbilityTaskBase.OnStateEvent
// 0x0008 (0x0008 - 0x0000)
struct GzAbilityTaskBase_OnStateEvent final
{
public:
	class FName                                   NotifyName;                                        // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzAbilityTaskBase_OnStateEvent) == 0x000004, "Wrong alignment on GzAbilityTaskBase_OnStateEvent");
static_assert(sizeof(GzAbilityTaskBase_OnStateEvent) == 0x000008, "Wrong size on GzAbilityTaskBase_OnStateEvent");
static_assert(offsetof(GzAbilityTaskBase_OnStateEvent, NotifyName) == 0x000000, "Member 'GzAbilityTaskBase_OnStateEvent::NotifyName' has a wrong offset!");

// Function G01.GzInvComponent.AddItem
// 0x0018 (0x0018 - 0x0000)
struct GzInvComponent_AddItem final
{
public:
	struct FGzInvItem                             Item;                                              // 0x0000(0x0010)(Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0010(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2CCC[0x7];                                     // 0x0011(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GzInvComponent_AddItem) == 0x000008, "Wrong alignment on GzInvComponent_AddItem");
static_assert(sizeof(GzInvComponent_AddItem) == 0x000018, "Wrong size on GzInvComponent_AddItem");
static_assert(offsetof(GzInvComponent_AddItem, Item) == 0x000000, "Member 'GzInvComponent_AddItem::Item' has a wrong offset!");
static_assert(offsetof(GzInvComponent_AddItem, ReturnValue) == 0x000010, "Member 'GzInvComponent_AddItem::ReturnValue' has a wrong offset!");

// Function G01.GzInvComponent.DecreasePocketPriority
// 0x0008 (0x0008 - 0x0000)
struct GzInvComponent_DecreasePocketPriority final
{
public:
	struct FGzInvPocketId                         PocketId;                                          // 0x0000(0x0008)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzInvComponent_DecreasePocketPriority) == 0x000004, "Wrong alignment on GzInvComponent_DecreasePocketPriority");
static_assert(sizeof(GzInvComponent_DecreasePocketPriority) == 0x000008, "Wrong size on GzInvComponent_DecreasePocketPriority");
static_assert(offsetof(GzInvComponent_DecreasePocketPriority, PocketId) == 0x000000, "Member 'GzInvComponent_DecreasePocketPriority::PocketId' has a wrong offset!");

// Function G01.GzInvComponent.GetAllSlotsFromPocketDef
// 0x0020 (0x0020 - 0x0000)
struct GzInvComponent_GetAllSlotsFromPocketDef final
{
public:
	EGzInvPocketType                              PocketType;                                        // 0x0000(0x0001)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2CCD[0x3];                                     // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTag                           AllowedTag;                                        // 0x0004(0x0008)(ConstParm, Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2CCE[0x4];                                     // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FGameplayTag>                   ReturnValue;                                       // 0x0010(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzInvComponent_GetAllSlotsFromPocketDef) == 0x000008, "Wrong alignment on GzInvComponent_GetAllSlotsFromPocketDef");
static_assert(sizeof(GzInvComponent_GetAllSlotsFromPocketDef) == 0x000020, "Wrong size on GzInvComponent_GetAllSlotsFromPocketDef");
static_assert(offsetof(GzInvComponent_GetAllSlotsFromPocketDef, PocketType) == 0x000000, "Member 'GzInvComponent_GetAllSlotsFromPocketDef::PocketType' has a wrong offset!");
static_assert(offsetof(GzInvComponent_GetAllSlotsFromPocketDef, AllowedTag) == 0x000004, "Member 'GzInvComponent_GetAllSlotsFromPocketDef::AllowedTag' has a wrong offset!");
static_assert(offsetof(GzInvComponent_GetAllSlotsFromPocketDef, ReturnValue) == 0x000010, "Member 'GzInvComponent_GetAllSlotsFromPocketDef::ReturnValue' has a wrong offset!");

// Function G01.GzInvComponent.IncreasePocketPriority
// 0x0008 (0x0008 - 0x0000)
struct GzInvComponent_IncreasePocketPriority final
{
public:
	struct FGzInvPocketId                         PocketId;                                          // 0x0000(0x0008)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzInvComponent_IncreasePocketPriority) == 0x000004, "Wrong alignment on GzInvComponent_IncreasePocketPriority");
static_assert(sizeof(GzInvComponent_IncreasePocketPriority) == 0x000008, "Wrong size on GzInvComponent_IncreasePocketPriority");
static_assert(offsetof(GzInvComponent_IncreasePocketPriority, PocketId) == 0x000000, "Member 'GzInvComponent_IncreasePocketPriority::PocketId' has a wrong offset!");

// Function G01.GzInvComponent.RemoveAllItemFromPocket
// 0x0018 (0x0018 - 0x0000)
struct GzInvComponent_RemoveAllItemFromPocket final
{
public:
	struct FGzInvPocketId                         PocketId;                                          // 0x0000(0x0008)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGzInvItem                             ReturnValue;                                       // 0x0008(0x0010)(Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzInvComponent_RemoveAllItemFromPocket) == 0x000008, "Wrong alignment on GzInvComponent_RemoveAllItemFromPocket");
static_assert(sizeof(GzInvComponent_RemoveAllItemFromPocket) == 0x000018, "Wrong size on GzInvComponent_RemoveAllItemFromPocket");
static_assert(offsetof(GzInvComponent_RemoveAllItemFromPocket, PocketId) == 0x000000, "Member 'GzInvComponent_RemoveAllItemFromPocket::PocketId' has a wrong offset!");
static_assert(offsetof(GzInvComponent_RemoveAllItemFromPocket, ReturnValue) == 0x000008, "Member 'GzInvComponent_RemoveAllItemFromPocket::ReturnValue' has a wrong offset!");

// Function G01.GzInvComponent.RemoveAllItems
// 0x0010 (0x0010 - 0x0000)
struct GzInvComponent_RemoveAllItems final
{
public:
	TArray<struct FGzInvItem>                     ReturnValue;                                       // 0x0000(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzInvComponent_RemoveAllItems) == 0x000008, "Wrong alignment on GzInvComponent_RemoveAllItems");
static_assert(sizeof(GzInvComponent_RemoveAllItems) == 0x000010, "Wrong size on GzInvComponent_RemoveAllItems");
static_assert(offsetof(GzInvComponent_RemoveAllItems, ReturnValue) == 0x000000, "Member 'GzInvComponent_RemoveAllItems::ReturnValue' has a wrong offset!");

// Function G01.GzInvComponent.RemoveItem
// 0x0020 (0x0020 - 0x0000)
struct GzInvComponent_RemoveItem final
{
public:
	struct FGzInvItem                             Item;                                              // 0x0000(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	struct FGzInvItem                             ReturnValue;                                       // 0x0010(0x0010)(Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzInvComponent_RemoveItem) == 0x000008, "Wrong alignment on GzInvComponent_RemoveItem");
static_assert(sizeof(GzInvComponent_RemoveItem) == 0x000020, "Wrong size on GzInvComponent_RemoveItem");
static_assert(offsetof(GzInvComponent_RemoveItem, Item) == 0x000000, "Member 'GzInvComponent_RemoveItem::Item' has a wrong offset!");
static_assert(offsetof(GzInvComponent_RemoveItem, ReturnValue) == 0x000010, "Member 'GzInvComponent_RemoveItem::ReturnValue' has a wrong offset!");

// Function G01.GzInvComponent.RemoveItemFromPocket
// 0x0020 (0x0020 - 0x0000)
struct GzInvComponent_RemoveItemFromPocket final
{
public:
	struct FGzInvPocketId                         PocketId;                                          // 0x0000(0x0008)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Quantity;                                          // 0x0008(0x0004)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2CCF[0x4];                                     // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGzInvItem                             ReturnValue;                                       // 0x0010(0x0010)(Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzInvComponent_RemoveItemFromPocket) == 0x000008, "Wrong alignment on GzInvComponent_RemoveItemFromPocket");
static_assert(sizeof(GzInvComponent_RemoveItemFromPocket) == 0x000020, "Wrong size on GzInvComponent_RemoveItemFromPocket");
static_assert(offsetof(GzInvComponent_RemoveItemFromPocket, PocketId) == 0x000000, "Member 'GzInvComponent_RemoveItemFromPocket::PocketId' has a wrong offset!");
static_assert(offsetof(GzInvComponent_RemoveItemFromPocket, Quantity) == 0x000008, "Member 'GzInvComponent_RemoveItemFromPocket::Quantity' has a wrong offset!");
static_assert(offsetof(GzInvComponent_RemoveItemFromPocket, ReturnValue) == 0x000010, "Member 'GzInvComponent_RemoveItemFromPocket::ReturnValue' has a wrong offset!");

// Function G01.GzInvComponent.SetVirtualItem
// 0x0010 (0x0010 - 0x0000)
struct GzInvComponent_SetVirtualItem final
{
public:
	struct FGzInvPocketId                         PocketId;                                          // 0x0000(0x0008)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UGzItemData*                            ItemData;                                          // 0x0008(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzInvComponent_SetVirtualItem) == 0x000008, "Wrong alignment on GzInvComponent_SetVirtualItem");
static_assert(sizeof(GzInvComponent_SetVirtualItem) == 0x000010, "Wrong size on GzInvComponent_SetVirtualItem");
static_assert(offsetof(GzInvComponent_SetVirtualItem, PocketId) == 0x000000, "Member 'GzInvComponent_SetVirtualItem::PocketId' has a wrong offset!");
static_assert(offsetof(GzInvComponent_SetVirtualItem, ItemData) == 0x000008, "Member 'GzInvComponent_SetVirtualItem::ItemData' has a wrong offset!");

// Function G01.GzInvComponent.TrySwapPockets
// 0x0014 (0x0014 - 0x0000)
struct GzInvComponent_TrySwapPockets final
{
public:
	struct FGzInvPocketId                         LeftPocketId;                                      // 0x0000(0x0008)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGzInvPocketId                         RightPocketId;                                     // 0x0008(0x0008)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0010(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2CD0[0x3];                                     // 0x0011(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GzInvComponent_TrySwapPockets) == 0x000004, "Wrong alignment on GzInvComponent_TrySwapPockets");
static_assert(sizeof(GzInvComponent_TrySwapPockets) == 0x000014, "Wrong size on GzInvComponent_TrySwapPockets");
static_assert(offsetof(GzInvComponent_TrySwapPockets, LeftPocketId) == 0x000000, "Member 'GzInvComponent_TrySwapPockets::LeftPocketId' has a wrong offset!");
static_assert(offsetof(GzInvComponent_TrySwapPockets, RightPocketId) == 0x000008, "Member 'GzInvComponent_TrySwapPockets::RightPocketId' has a wrong offset!");
static_assert(offsetof(GzInvComponent_TrySwapPockets, ReturnValue) == 0x000010, "Member 'GzInvComponent_TrySwapPockets::ReturnValue' has a wrong offset!");

// Function G01.GzInvComponent.GetPocketById
// 0x0030 (0x0030 - 0x0000)
struct GzInvComponent_GetPocketById final
{
public:
	struct FGzInvPocketId                         PocketId;                                          // 0x0000(0x0008)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGzInvPocket                           ReturnValue;                                       // 0x0008(0x0028)(ConstParm, Parm, OutParm, ReturnParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzInvComponent_GetPocketById) == 0x000008, "Wrong alignment on GzInvComponent_GetPocketById");
static_assert(sizeof(GzInvComponent_GetPocketById) == 0x000030, "Wrong size on GzInvComponent_GetPocketById");
static_assert(offsetof(GzInvComponent_GetPocketById, PocketId) == 0x000000, "Member 'GzInvComponent_GetPocketById::PocketId' has a wrong offset!");
static_assert(offsetof(GzInvComponent_GetPocketById, ReturnValue) == 0x000008, "Member 'GzInvComponent_GetPocketById::ReturnValue' has a wrong offset!");

// Function G01.GzInvComponent.GetPocketDefById
// 0x0068 (0x0068 - 0x0000)
struct GzInvComponent_GetPocketDefById final
{
public:
	struct FGzInvPocketId                         PocketId;                                          // 0x0000(0x0008)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGzInvPocketDef                        ReturnValue;                                       // 0x0008(0x0060)(ConstParm, Parm, OutParm, ReturnParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzInvComponent_GetPocketDefById) == 0x000008, "Wrong alignment on GzInvComponent_GetPocketDefById");
static_assert(sizeof(GzInvComponent_GetPocketDefById) == 0x000068, "Wrong size on GzInvComponent_GetPocketDefById");
static_assert(offsetof(GzInvComponent_GetPocketDefById, PocketId) == 0x000000, "Member 'GzInvComponent_GetPocketDefById::PocketId' has a wrong offset!");
static_assert(offsetof(GzInvComponent_GetPocketDefById, ReturnValue) == 0x000008, "Member 'GzInvComponent_GetPocketDefById::ReturnValue' has a wrong offset!");

// Function G01.GzInvComponent.IsValidPocket
// 0x000C (0x000C - 0x0000)
struct GzInvComponent_IsValidPocket final
{
public:
	struct FGzInvPocketId                         PocketId;                                          // 0x0000(0x0008)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2CD1[0x3];                                     // 0x0009(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GzInvComponent_IsValidPocket) == 0x000004, "Wrong alignment on GzInvComponent_IsValidPocket");
static_assert(sizeof(GzInvComponent_IsValidPocket) == 0x00000C, "Wrong size on GzInvComponent_IsValidPocket");
static_assert(offsetof(GzInvComponent_IsValidPocket, PocketId) == 0x000000, "Member 'GzInvComponent_IsValidPocket::PocketId' has a wrong offset!");
static_assert(offsetof(GzInvComponent_IsValidPocket, ReturnValue) == 0x000008, "Member 'GzInvComponent_IsValidPocket::ReturnValue' has a wrong offset!");

// Function G01.GzLimbAbilityComponent.OnLimbAimingStart
// 0x0008 (0x0008 - 0x0000)
struct GzLimbAbilityComponent_OnLimbAimingStart final
{
public:
	struct FGameplayTag                           AimingTag;                                         // 0x0000(0x0008)(Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzLimbAbilityComponent_OnLimbAimingStart) == 0x000004, "Wrong alignment on GzLimbAbilityComponent_OnLimbAimingStart");
static_assert(sizeof(GzLimbAbilityComponent_OnLimbAimingStart) == 0x000008, "Wrong size on GzLimbAbilityComponent_OnLimbAimingStart");
static_assert(offsetof(GzLimbAbilityComponent_OnLimbAimingStart, AimingTag) == 0x000000, "Member 'GzLimbAbilityComponent_OnLimbAimingStart::AimingTag' has a wrong offset!");

// Function G01.GzLimbAbilityComponent.OnLimbAimingStop
// 0x0008 (0x0008 - 0x0000)
struct GzLimbAbilityComponent_OnLimbAimingStop final
{
public:
	struct FGameplayTag                           AimingTag;                                         // 0x0000(0x0008)(Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzLimbAbilityComponent_OnLimbAimingStop) == 0x000004, "Wrong alignment on GzLimbAbilityComponent_OnLimbAimingStop");
static_assert(sizeof(GzLimbAbilityComponent_OnLimbAimingStop) == 0x000008, "Wrong size on GzLimbAbilityComponent_OnLimbAimingStop");
static_assert(offsetof(GzLimbAbilityComponent_OnLimbAimingStop, AimingTag) == 0x000000, "Member 'GzLimbAbilityComponent_OnLimbAimingStop::AimingTag' has a wrong offset!");

// Function G01.GzLimbAbilityComponent.OnRep_IsRecharging
// 0x0001 (0x0001 - 0x0000)
struct GzLimbAbilityComponent_OnRep_IsRecharging final
{
public:
	bool                                          bOldIsRecharging;                                  // 0x0000(0x0001)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzLimbAbilityComponent_OnRep_IsRecharging) == 0x000001, "Wrong alignment on GzLimbAbilityComponent_OnRep_IsRecharging");
static_assert(sizeof(GzLimbAbilityComponent_OnRep_IsRecharging) == 0x000001, "Wrong size on GzLimbAbilityComponent_OnRep_IsRecharging");
static_assert(offsetof(GzLimbAbilityComponent_OnRep_IsRecharging, bOldIsRecharging) == 0x000000, "Member 'GzLimbAbilityComponent_OnRep_IsRecharging::bOldIsRecharging' has a wrong offset!");

// Function G01.GzLimbAbilityComponent.SetLimbUIEnabled
// 0x0001 (0x0001 - 0x0000)
struct GzLimbAbilityComponent_SetLimbUIEnabled final
{
public:
	bool                                          bIsEnabled;                                        // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzLimbAbilityComponent_SetLimbUIEnabled) == 0x000001, "Wrong alignment on GzLimbAbilityComponent_SetLimbUIEnabled");
static_assert(sizeof(GzLimbAbilityComponent_SetLimbUIEnabled) == 0x000001, "Wrong size on GzLimbAbilityComponent_SetLimbUIEnabled");
static_assert(offsetof(GzLimbAbilityComponent_SetLimbUIEnabled, bIsEnabled) == 0x000000, "Member 'GzLimbAbilityComponent_SetLimbUIEnabled::bIsEnabled' has a wrong offset!");

// Function G01.GzLimbAbilityComponent.BP_GetAbilityData
// 0x0008 (0x0008 - 0x0000)
struct GzLimbAbilityComponent_BP_GetAbilityData final
{
public:
	class UGzBodyPartAbilityData*                 ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzLimbAbilityComponent_BP_GetAbilityData) == 0x000008, "Wrong alignment on GzLimbAbilityComponent_BP_GetAbilityData");
static_assert(sizeof(GzLimbAbilityComponent_BP_GetAbilityData) == 0x000008, "Wrong size on GzLimbAbilityComponent_BP_GetAbilityData");
static_assert(offsetof(GzLimbAbilityComponent_BP_GetAbilityData, ReturnValue) == 0x000000, "Member 'GzLimbAbilityComponent_BP_GetAbilityData::ReturnValue' has a wrong offset!");

// Function G01.GzLimbAbilityComponent.GetAbilityChargePercentage
// 0x0004 (0x0004 - 0x0000)
struct GzLimbAbilityComponent_GetAbilityChargePercentage final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzLimbAbilityComponent_GetAbilityChargePercentage) == 0x000004, "Wrong alignment on GzLimbAbilityComponent_GetAbilityChargePercentage");
static_assert(sizeof(GzLimbAbilityComponent_GetAbilityChargePercentage) == 0x000004, "Wrong size on GzLimbAbilityComponent_GetAbilityChargePercentage");
static_assert(offsetof(GzLimbAbilityComponent_GetAbilityChargePercentage, ReturnValue) == 0x000000, "Member 'GzLimbAbilityComponent_GetAbilityChargePercentage::ReturnValue' has a wrong offset!");

// Function G01.GzLimbAbilityComponent.GetAbilityInputData
// 0x0008 (0x0008 - 0x0000)
struct GzLimbAbilityComponent_GetAbilityInputData final
{
public:
	class UGzBodyPartAbilityInputData*            ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzLimbAbilityComponent_GetAbilityInputData) == 0x000008, "Wrong alignment on GzLimbAbilityComponent_GetAbilityInputData");
static_assert(sizeof(GzLimbAbilityComponent_GetAbilityInputData) == 0x000008, "Wrong size on GzLimbAbilityComponent_GetAbilityInputData");
static_assert(offsetof(GzLimbAbilityComponent_GetAbilityInputData, ReturnValue) == 0x000000, "Member 'GzLimbAbilityComponent_GetAbilityInputData::ReturnValue' has a wrong offset!");

// Function G01.GzLimbAbilityComponent.GetLimbAbility
// 0x0008 (0x0008 - 0x0000)
struct GzLimbAbilityComponent_GetLimbAbility final
{
public:
	const class UGzGA_BaseLimbAbility*            ReturnValue;                                       // 0x0000(0x0008)(ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzLimbAbilityComponent_GetLimbAbility) == 0x000008, "Wrong alignment on GzLimbAbilityComponent_GetLimbAbility");
static_assert(sizeof(GzLimbAbilityComponent_GetLimbAbility) == 0x000008, "Wrong size on GzLimbAbilityComponent_GetLimbAbility");
static_assert(offsetof(GzLimbAbilityComponent_GetLimbAbility, ReturnValue) == 0x000000, "Member 'GzLimbAbilityComponent_GetLimbAbility::ReturnValue' has a wrong offset!");

// Function G01.GzLimbAbilityComponent.GetLimbComponent
// 0x0008 (0x0008 - 0x0000)
struct GzLimbAbilityComponent_GetLimbComponent final
{
public:
	class UGzLimbComponent*                       ReturnValue;                                       // 0x0000(0x0008)(ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzLimbAbilityComponent_GetLimbComponent) == 0x000008, "Wrong alignment on GzLimbAbilityComponent_GetLimbComponent");
static_assert(sizeof(GzLimbAbilityComponent_GetLimbComponent) == 0x000008, "Wrong size on GzLimbAbilityComponent_GetLimbComponent");
static_assert(offsetof(GzLimbAbilityComponent_GetLimbComponent, ReturnValue) == 0x000000, "Member 'GzLimbAbilityComponent_GetLimbComponent::ReturnValue' has a wrong offset!");

// Function G01.GzLimbAbilityComponent.GetLimbSocketWorldLocation
// 0x0020 (0x0020 - 0x0000)
struct GzLimbAbilityComponent_GetLimbSocketWorldLocation final
{
public:
	class FName                                   SocketName;                                        // 0x0000(0x0008)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                ReturnValue;                                       // 0x0008(0x0018)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzLimbAbilityComponent_GetLimbSocketWorldLocation) == 0x000008, "Wrong alignment on GzLimbAbilityComponent_GetLimbSocketWorldLocation");
static_assert(sizeof(GzLimbAbilityComponent_GetLimbSocketWorldLocation) == 0x000020, "Wrong size on GzLimbAbilityComponent_GetLimbSocketWorldLocation");
static_assert(offsetof(GzLimbAbilityComponent_GetLimbSocketWorldLocation, SocketName) == 0x000000, "Member 'GzLimbAbilityComponent_GetLimbSocketWorldLocation::SocketName' has a wrong offset!");
static_assert(offsetof(GzLimbAbilityComponent_GetLimbSocketWorldLocation, ReturnValue) == 0x000008, "Member 'GzLimbAbilityComponent_GetLimbSocketWorldLocation::ReturnValue' has a wrong offset!");

// Function G01.GzLimbAbilityComponent.GetLimbType
// 0x0001 (0x0001 - 0x0000)
struct GzLimbAbilityComponent_GetLimbType final
{
public:
	EGzLimbType                                   ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzLimbAbilityComponent_GetLimbType) == 0x000001, "Wrong alignment on GzLimbAbilityComponent_GetLimbType");
static_assert(sizeof(GzLimbAbilityComponent_GetLimbType) == 0x000001, "Wrong size on GzLimbAbilityComponent_GetLimbType");
static_assert(offsetof(GzLimbAbilityComponent_GetLimbType, ReturnValue) == 0x000000, "Member 'GzLimbAbilityComponent_GetLimbType::ReturnValue' has a wrong offset!");

// Function G01.GzLimbAbilityComponent.GetLimbUISystem
// 0x0008 (0x0008 - 0x0000)
struct GzLimbAbilityComponent_GetLimbUISystem final
{
public:
	class UGzLimbUIActivationSubsystem*           ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzLimbAbilityComponent_GetLimbUISystem) == 0x000008, "Wrong alignment on GzLimbAbilityComponent_GetLimbUISystem");
static_assert(sizeof(GzLimbAbilityComponent_GetLimbUISystem) == 0x000008, "Wrong size on GzLimbAbilityComponent_GetLimbUISystem");
static_assert(offsetof(GzLimbAbilityComponent_GetLimbUISystem, ReturnValue) == 0x000000, "Member 'GzLimbAbilityComponent_GetLimbUISystem::ReturnValue' has a wrong offset!");

// Function G01.GzLimbAbilityComponent.GetOwnerASC
// 0x0008 (0x0008 - 0x0000)
struct GzLimbAbilityComponent_GetOwnerASC final
{
public:
	class UGzAbilitySystemComponent*              ReturnValue;                                       // 0x0000(0x0008)(ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzLimbAbilityComponent_GetOwnerASC) == 0x000008, "Wrong alignment on GzLimbAbilityComponent_GetOwnerASC");
static_assert(sizeof(GzLimbAbilityComponent_GetOwnerASC) == 0x000008, "Wrong size on GzLimbAbilityComponent_GetOwnerASC");
static_assert(offsetof(GzLimbAbilityComponent_GetOwnerASC, ReturnValue) == 0x000000, "Member 'GzLimbAbilityComponent_GetOwnerASC::ReturnValue' has a wrong offset!");

// Function G01.GzLimbAbilityComponent.GetOwnerCharacter
// 0x0008 (0x0008 - 0x0000)
struct GzLimbAbilityComponent_GetOwnerCharacter final
{
public:
	class AGzMultiPartCharacter*                  ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzLimbAbilityComponent_GetOwnerCharacter) == 0x000008, "Wrong alignment on GzLimbAbilityComponent_GetOwnerCharacter");
static_assert(sizeof(GzLimbAbilityComponent_GetOwnerCharacter) == 0x000008, "Wrong size on GzLimbAbilityComponent_GetOwnerCharacter");
static_assert(offsetof(GzLimbAbilityComponent_GetOwnerCharacter, ReturnValue) == 0x000000, "Member 'GzLimbAbilityComponent_GetOwnerCharacter::ReturnValue' has a wrong offset!");

// Function G01.GzLimbAbilityComponent.HasOwnerAuthority
// 0x0001 (0x0001 - 0x0000)
struct GzLimbAbilityComponent_HasOwnerAuthority final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzLimbAbilityComponent_HasOwnerAuthority) == 0x000001, "Wrong alignment on GzLimbAbilityComponent_HasOwnerAuthority");
static_assert(sizeof(GzLimbAbilityComponent_HasOwnerAuthority) == 0x000001, "Wrong size on GzLimbAbilityComponent_HasOwnerAuthority");
static_assert(offsetof(GzLimbAbilityComponent_HasOwnerAuthority, ReturnValue) == 0x000000, "Member 'GzLimbAbilityComponent_HasOwnerAuthority::ReturnValue' has a wrong offset!");

// Function G01.GzLimbAbilityComponent.IsOwnerLocallyControlled
// 0x0001 (0x0001 - 0x0000)
struct GzLimbAbilityComponent_IsOwnerLocallyControlled final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzLimbAbilityComponent_IsOwnerLocallyControlled) == 0x000001, "Wrong alignment on GzLimbAbilityComponent_IsOwnerLocallyControlled");
static_assert(sizeof(GzLimbAbilityComponent_IsOwnerLocallyControlled) == 0x000001, "Wrong size on GzLimbAbilityComponent_IsOwnerLocallyControlled");
static_assert(offsetof(GzLimbAbilityComponent_IsOwnerLocallyControlled, ReturnValue) == 0x000000, "Member 'GzLimbAbilityComponent_IsOwnerLocallyControlled::ReturnValue' has a wrong offset!");

// Function G01.GzGrappleHookComponent.MulticastDistributeHookLaunch
// 0x00F8 (0x00F8 - 0x0000)
struct GzGrappleHookComponent_MulticastDistributeHookLaunch final
{
public:
	struct FHitResult                             HitResult;                                         // 0x0000(0x00F8)(ConstParm, Parm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzGrappleHookComponent_MulticastDistributeHookLaunch) == 0x000008, "Wrong alignment on GzGrappleHookComponent_MulticastDistributeHookLaunch");
static_assert(sizeof(GzGrappleHookComponent_MulticastDistributeHookLaunch) == 0x0000F8, "Wrong size on GzGrappleHookComponent_MulticastDistributeHookLaunch");
static_assert(offsetof(GzGrappleHookComponent_MulticastDistributeHookLaunch, HitResult) == 0x000000, "Member 'GzGrappleHookComponent_MulticastDistributeHookLaunch::HitResult' has a wrong offset!");

// Function G01.GzGrappleHookComponent.OnGrappleHookProjectileDestroyed
// 0x0008 (0x0008 - 0x0000)
struct GzGrappleHookComponent_OnGrappleHookProjectileDestroyed final
{
public:
	class AActor*                                 DestroyedActor;                                    // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzGrappleHookComponent_OnGrappleHookProjectileDestroyed) == 0x000008, "Wrong alignment on GzGrappleHookComponent_OnGrappleHookProjectileDestroyed");
static_assert(sizeof(GzGrappleHookComponent_OnGrappleHookProjectileDestroyed) == 0x000008, "Wrong size on GzGrappleHookComponent_OnGrappleHookProjectileDestroyed");
static_assert(offsetof(GzGrappleHookComponent_OnGrappleHookProjectileDestroyed, DestroyedActor) == 0x000000, "Member 'GzGrappleHookComponent_OnGrappleHookProjectileDestroyed::DestroyedActor' has a wrong offset!");

// Function G01.GzGrappleHookComponent.OnRep_GrappleHookState
// 0x0001 (0x0001 - 0x0000)
struct GzGrappleHookComponent_OnRep_GrappleHookState final
{
public:
	EGzGrappleHookState                           OldGrappleHookState;                               // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzGrappleHookComponent_OnRep_GrappleHookState) == 0x000001, "Wrong alignment on GzGrappleHookComponent_OnRep_GrappleHookState");
static_assert(sizeof(GzGrappleHookComponent_OnRep_GrappleHookState) == 0x000001, "Wrong size on GzGrappleHookComponent_OnRep_GrappleHookState");
static_assert(offsetof(GzGrappleHookComponent_OnRep_GrappleHookState, OldGrappleHookState) == 0x000000, "Member 'GzGrappleHookComponent_OnRep_GrappleHookState::OldGrappleHookState' has a wrong offset!");

// Function G01.GzGrappleHookComponent.ServerPullCharacterRequest
// 0x00F8 (0x00F8 - 0x0000)
struct GzGrappleHookComponent_ServerPullCharacterRequest final
{
public:
	struct FHitResult                             HitResult;                                         // 0x0000(0x00F8)(ConstParm, Parm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzGrappleHookComponent_ServerPullCharacterRequest) == 0x000008, "Wrong alignment on GzGrappleHookComponent_ServerPullCharacterRequest");
static_assert(sizeof(GzGrappleHookComponent_ServerPullCharacterRequest) == 0x0000F8, "Wrong size on GzGrappleHookComponent_ServerPullCharacterRequest");
static_assert(offsetof(GzGrappleHookComponent_ServerPullCharacterRequest, HitResult) == 0x000000, "Member 'GzGrappleHookComponent_ServerPullCharacterRequest::HitResult' has a wrong offset!");

// Function G01.GzGrappleHookComponent.ServerRequestHookLaunch
// 0x00F8 (0x00F8 - 0x0000)
struct GzGrappleHookComponent_ServerRequestHookLaunch final
{
public:
	struct FHitResult                             HitResult;                                         // 0x0000(0x00F8)(ConstParm, Parm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzGrappleHookComponent_ServerRequestHookLaunch) == 0x000008, "Wrong alignment on GzGrappleHookComponent_ServerRequestHookLaunch");
static_assert(sizeof(GzGrappleHookComponent_ServerRequestHookLaunch) == 0x0000F8, "Wrong size on GzGrappleHookComponent_ServerRequestHookLaunch");
static_assert(offsetof(GzGrappleHookComponent_ServerRequestHookLaunch, HitResult) == 0x000000, "Member 'GzGrappleHookComponent_ServerRequestHookLaunch::HitResult' has a wrong offset!");

// Function G01.GzGrappleHookComponent.ServerStopGrapple
// 0x0110 (0x0110 - 0x0000)
struct GzGrappleHookComponent_ServerStopGrapple final
{
public:
	struct FHitResult                             HitResult;                                         // 0x0000(0x00F8)(ConstParm, Parm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FVector                                Offset;                                            // 0x00F8(0x0018)(ConstParm, Parm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzGrappleHookComponent_ServerStopGrapple) == 0x000008, "Wrong alignment on GzGrappleHookComponent_ServerStopGrapple");
static_assert(sizeof(GzGrappleHookComponent_ServerStopGrapple) == 0x000110, "Wrong size on GzGrappleHookComponent_ServerStopGrapple");
static_assert(offsetof(GzGrappleHookComponent_ServerStopGrapple, HitResult) == 0x000000, "Member 'GzGrappleHookComponent_ServerStopGrapple::HitResult' has a wrong offset!");
static_assert(offsetof(GzGrappleHookComponent_ServerStopGrapple, Offset) == 0x0000F8, "Member 'GzGrappleHookComponent_ServerStopGrapple::Offset' has a wrong offset!");

// Function G01.GzGrappleHookComponent.GetState
// 0x0001 (0x0001 - 0x0000)
struct GzGrappleHookComponent_GetState final
{
public:
	EGzGrappleHookState                           ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzGrappleHookComponent_GetState) == 0x000001, "Wrong alignment on GzGrappleHookComponent_GetState");
static_assert(sizeof(GzGrappleHookComponent_GetState) == 0x000001, "Wrong size on GzGrappleHookComponent_GetState");
static_assert(offsetof(GzGrappleHookComponent_GetState, ReturnValue) == 0x000000, "Member 'GzGrappleHookComponent_GetState::ReturnValue' has a wrong offset!");

// Function G01.GzPlayerToPlayerInteractionMessage.AreFromSameTeam
// 0x0010 (0x0010 - 0x0000)
struct GzPlayerToPlayerInteractionMessage_AreFromSameTeam final
{
public:
	const class UObject*                          WorldContext;                                      // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2CDD[0x7];                                     // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GzPlayerToPlayerInteractionMessage_AreFromSameTeam) == 0x000008, "Wrong alignment on GzPlayerToPlayerInteractionMessage_AreFromSameTeam");
static_assert(sizeof(GzPlayerToPlayerInteractionMessage_AreFromSameTeam) == 0x000010, "Wrong size on GzPlayerToPlayerInteractionMessage_AreFromSameTeam");
static_assert(offsetof(GzPlayerToPlayerInteractionMessage_AreFromSameTeam, WorldContext) == 0x000000, "Member 'GzPlayerToPlayerInteractionMessage_AreFromSameTeam::WorldContext' has a wrong offset!");
static_assert(offsetof(GzPlayerToPlayerInteractionMessage_AreFromSameTeam, ReturnValue) == 0x000008, "Member 'GzPlayerToPlayerInteractionMessage_AreFromSameTeam::ReturnValue' has a wrong offset!");

// Function G01.GzPlayerToPlayerInteractionMessage.GetInstigatorName
// 0x0018 (0x0018 - 0x0000)
struct GzPlayerToPlayerInteractionMessage_GetInstigatorName final
{
public:
	const class UObject*                          WorldContextObject;                                // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 ReturnValue;                                       // 0x0008(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzPlayerToPlayerInteractionMessage_GetInstigatorName) == 0x000008, "Wrong alignment on GzPlayerToPlayerInteractionMessage_GetInstigatorName");
static_assert(sizeof(GzPlayerToPlayerInteractionMessage_GetInstigatorName) == 0x000018, "Wrong size on GzPlayerToPlayerInteractionMessage_GetInstigatorName");
static_assert(offsetof(GzPlayerToPlayerInteractionMessage_GetInstigatorName, WorldContextObject) == 0x000000, "Member 'GzPlayerToPlayerInteractionMessage_GetInstigatorName::WorldContextObject' has a wrong offset!");
static_assert(offsetof(GzPlayerToPlayerInteractionMessage_GetInstigatorName, ReturnValue) == 0x000008, "Member 'GzPlayerToPlayerInteractionMessage_GetInstigatorName::ReturnValue' has a wrong offset!");

// Function G01.GzPlayerToPlayerInteractionMessage.GetInstigatorPlayerState
// 0x0010 (0x0010 - 0x0000)
struct GzPlayerToPlayerInteractionMessage_GetInstigatorPlayerState final
{
public:
	const class UObject*                          WorldContextObject;                                // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AGzPlayerState*                         ReturnValue;                                       // 0x0008(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzPlayerToPlayerInteractionMessage_GetInstigatorPlayerState) == 0x000008, "Wrong alignment on GzPlayerToPlayerInteractionMessage_GetInstigatorPlayerState");
static_assert(sizeof(GzPlayerToPlayerInteractionMessage_GetInstigatorPlayerState) == 0x000010, "Wrong size on GzPlayerToPlayerInteractionMessage_GetInstigatorPlayerState");
static_assert(offsetof(GzPlayerToPlayerInteractionMessage_GetInstigatorPlayerState, WorldContextObject) == 0x000000, "Member 'GzPlayerToPlayerInteractionMessage_GetInstigatorPlayerState::WorldContextObject' has a wrong offset!");
static_assert(offsetof(GzPlayerToPlayerInteractionMessage_GetInstigatorPlayerState, ReturnValue) == 0x000008, "Member 'GzPlayerToPlayerInteractionMessage_GetInstigatorPlayerState::ReturnValue' has a wrong offset!");

// Function G01.GzPlayerToPlayerInteractionMessage.GetUIAssetIcon
// 0x0028 (0x0028 - 0x0000)
struct GzPlayerToPlayerInteractionMessage_GetUIAssetIcon final
{
public:
	TSoftObjectPtr<class UTexture2D>              ReturnValue;                                       // 0x0000(0x0028)(Parm, OutParm, ReturnParm, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzPlayerToPlayerInteractionMessage_GetUIAssetIcon) == 0x000008, "Wrong alignment on GzPlayerToPlayerInteractionMessage_GetUIAssetIcon");
static_assert(sizeof(GzPlayerToPlayerInteractionMessage_GetUIAssetIcon) == 0x000028, "Wrong size on GzPlayerToPlayerInteractionMessage_GetUIAssetIcon");
static_assert(offsetof(GzPlayerToPlayerInteractionMessage_GetUIAssetIcon, ReturnValue) == 0x000000, "Member 'GzPlayerToPlayerInteractionMessage_GetUIAssetIcon::ReturnValue' has a wrong offset!");

// Function G01.GzPlayerToPlayerInteractionMessage.GetUIAssetId
// 0x0010 (0x0010 - 0x0000)
struct GzPlayerToPlayerInteractionMessage_GetUIAssetId final
{
public:
	class FString                                 ReturnValue;                                       // 0x0000(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzPlayerToPlayerInteractionMessage_GetUIAssetId) == 0x000008, "Wrong alignment on GzPlayerToPlayerInteractionMessage_GetUIAssetId");
static_assert(sizeof(GzPlayerToPlayerInteractionMessage_GetUIAssetId) == 0x000010, "Wrong size on GzPlayerToPlayerInteractionMessage_GetUIAssetId");
static_assert(offsetof(GzPlayerToPlayerInteractionMessage_GetUIAssetId, ReturnValue) == 0x000000, "Member 'GzPlayerToPlayerInteractionMessage_GetUIAssetId::ReturnValue' has a wrong offset!");

// Function G01.GzPlayerToPlayerInteractionMessage.GetVictimName
// 0x0018 (0x0018 - 0x0000)
struct GzPlayerToPlayerInteractionMessage_GetVictimName final
{
public:
	const class UObject*                          WorldContextObject;                                // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 ReturnValue;                                       // 0x0008(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzPlayerToPlayerInteractionMessage_GetVictimName) == 0x000008, "Wrong alignment on GzPlayerToPlayerInteractionMessage_GetVictimName");
static_assert(sizeof(GzPlayerToPlayerInteractionMessage_GetVictimName) == 0x000018, "Wrong size on GzPlayerToPlayerInteractionMessage_GetVictimName");
static_assert(offsetof(GzPlayerToPlayerInteractionMessage_GetVictimName, WorldContextObject) == 0x000000, "Member 'GzPlayerToPlayerInteractionMessage_GetVictimName::WorldContextObject' has a wrong offset!");
static_assert(offsetof(GzPlayerToPlayerInteractionMessage_GetVictimName, ReturnValue) == 0x000008, "Member 'GzPlayerToPlayerInteractionMessage_GetVictimName::ReturnValue' has a wrong offset!");

// Function G01.GzPlayerToPlayerInteractionMessage.GetVictimPlayerState
// 0x0010 (0x0010 - 0x0000)
struct GzPlayerToPlayerInteractionMessage_GetVictimPlayerState final
{
public:
	const class UObject*                          WorldContextObject;                                // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AGzPlayerState*                         ReturnValue;                                       // 0x0008(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzPlayerToPlayerInteractionMessage_GetVictimPlayerState) == 0x000008, "Wrong alignment on GzPlayerToPlayerInteractionMessage_GetVictimPlayerState");
static_assert(sizeof(GzPlayerToPlayerInteractionMessage_GetVictimPlayerState) == 0x000010, "Wrong size on GzPlayerToPlayerInteractionMessage_GetVictimPlayerState");
static_assert(offsetof(GzPlayerToPlayerInteractionMessage_GetVictimPlayerState, WorldContextObject) == 0x000000, "Member 'GzPlayerToPlayerInteractionMessage_GetVictimPlayerState::WorldContextObject' has a wrong offset!");
static_assert(offsetof(GzPlayerToPlayerInteractionMessage_GetVictimPlayerState, ReturnValue) == 0x000008, "Member 'GzPlayerToPlayerInteractionMessage_GetVictimPlayerState::ReturnValue' has a wrong offset!");

// Function G01.GzAchievementServiceCheatExtension.ClientCompleteAchievementStage
// 0x000C (0x000C - 0x0000)
struct GzAchievementServiceCheatExtension_ClientCompleteAchievementStage final
{
public:
	class FName                                   AchievementId;                                     // 0x0000(0x0008)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int8                                          AchievementStageToComplete;                        // 0x0008(0x0001)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2CDF[0x3];                                     // 0x0009(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GzAchievementServiceCheatExtension_ClientCompleteAchievementStage) == 0x000004, "Wrong alignment on GzAchievementServiceCheatExtension_ClientCompleteAchievementStage");
static_assert(sizeof(GzAchievementServiceCheatExtension_ClientCompleteAchievementStage) == 0x00000C, "Wrong size on GzAchievementServiceCheatExtension_ClientCompleteAchievementStage");
static_assert(offsetof(GzAchievementServiceCheatExtension_ClientCompleteAchievementStage, AchievementId) == 0x000000, "Member 'GzAchievementServiceCheatExtension_ClientCompleteAchievementStage::AchievementId' has a wrong offset!");
static_assert(offsetof(GzAchievementServiceCheatExtension_ClientCompleteAchievementStage, AchievementStageToComplete) == 0x000008, "Member 'GzAchievementServiceCheatExtension_ClientCompleteAchievementStage::AchievementStageToComplete' has a wrong offset!");

// Function G01.GzAchievementServiceCheatExtension.ClientResetAchievementProgress
// 0x0008 (0x0008 - 0x0000)
struct GzAchievementServiceCheatExtension_ClientResetAchievementProgress final
{
public:
	class FName                                   AchievementId;                                     // 0x0000(0x0008)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzAchievementServiceCheatExtension_ClientResetAchievementProgress) == 0x000004, "Wrong alignment on GzAchievementServiceCheatExtension_ClientResetAchievementProgress");
static_assert(sizeof(GzAchievementServiceCheatExtension_ClientResetAchievementProgress) == 0x000008, "Wrong size on GzAchievementServiceCheatExtension_ClientResetAchievementProgress");
static_assert(offsetof(GzAchievementServiceCheatExtension_ClientResetAchievementProgress, AchievementId) == 0x000000, "Member 'GzAchievementServiceCheatExtension_ClientResetAchievementProgress::AchievementId' has a wrong offset!");

// Function G01.GzAchievementServiceCheatExtension.ClientUpdateAchievementsProgress
// 0x000C (0x000C - 0x0000)
struct GzAchievementServiceCheatExtension_ClientUpdateAchievementsProgress final
{
public:
	class FName                                   AchievementId;                                     // 0x0000(0x0008)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ProgressToAdd;                                     // 0x0008(0x0004)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzAchievementServiceCheatExtension_ClientUpdateAchievementsProgress) == 0x000004, "Wrong alignment on GzAchievementServiceCheatExtension_ClientUpdateAchievementsProgress");
static_assert(sizeof(GzAchievementServiceCheatExtension_ClientUpdateAchievementsProgress) == 0x00000C, "Wrong size on GzAchievementServiceCheatExtension_ClientUpdateAchievementsProgress");
static_assert(offsetof(GzAchievementServiceCheatExtension_ClientUpdateAchievementsProgress, AchievementId) == 0x000000, "Member 'GzAchievementServiceCheatExtension_ClientUpdateAchievementsProgress::AchievementId' has a wrong offset!");
static_assert(offsetof(GzAchievementServiceCheatExtension_ClientUpdateAchievementsProgress, ProgressToAdd) == 0x000008, "Member 'GzAchievementServiceCheatExtension_ClientUpdateAchievementsProgress::ProgressToAdd' has a wrong offset!");

// Function G01.GzLoadoutStatics.GetAuthorityLoadoutCost
// 0x0030 (0x0030 - 0x0000)
struct GzLoadoutStatics_GetAuthorityLoadoutCost final
{
public:
	const class UObject*                          WorldContext;                                      // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 PlayFabId;                                         // 0x0008(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGuid                                  Guid;                                              // 0x0018(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ReturnValue;                                       // 0x0028(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2CE0[0x4];                                     // 0x002C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GzLoadoutStatics_GetAuthorityLoadoutCost) == 0x000008, "Wrong alignment on GzLoadoutStatics_GetAuthorityLoadoutCost");
static_assert(sizeof(GzLoadoutStatics_GetAuthorityLoadoutCost) == 0x000030, "Wrong size on GzLoadoutStatics_GetAuthorityLoadoutCost");
static_assert(offsetof(GzLoadoutStatics_GetAuthorityLoadoutCost, WorldContext) == 0x000000, "Member 'GzLoadoutStatics_GetAuthorityLoadoutCost::WorldContext' has a wrong offset!");
static_assert(offsetof(GzLoadoutStatics_GetAuthorityLoadoutCost, PlayFabId) == 0x000008, "Member 'GzLoadoutStatics_GetAuthorityLoadoutCost::PlayFabId' has a wrong offset!");
static_assert(offsetof(GzLoadoutStatics_GetAuthorityLoadoutCost, Guid) == 0x000018, "Member 'GzLoadoutStatics_GetAuthorityLoadoutCost::Guid' has a wrong offset!");
static_assert(offsetof(GzLoadoutStatics_GetAuthorityLoadoutCost, ReturnValue) == 0x000028, "Member 'GzLoadoutStatics_GetAuthorityLoadoutCost::ReturnValue' has a wrong offset!");

// Function G01.GzLoadoutStatics.GetItemFromLocalLoadoutSlot
// 0x0030 (0x0030 - 0x0000)
struct GzLoadoutStatics_GetItemFromLocalLoadoutSlot final
{
public:
	const class UObject*                          WorldContext;                                      // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGuid                                  Guid;                                              // 0x0008(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EGzLoadoutSlots                               SlotType;                                          // 0x0018(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2CE1[0x7];                                     // 0x0019(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGzInvItem                             ReturnValue;                                       // 0x0020(0x0010)(Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzLoadoutStatics_GetItemFromLocalLoadoutSlot) == 0x000008, "Wrong alignment on GzLoadoutStatics_GetItemFromLocalLoadoutSlot");
static_assert(sizeof(GzLoadoutStatics_GetItemFromLocalLoadoutSlot) == 0x000030, "Wrong size on GzLoadoutStatics_GetItemFromLocalLoadoutSlot");
static_assert(offsetof(GzLoadoutStatics_GetItemFromLocalLoadoutSlot, WorldContext) == 0x000000, "Member 'GzLoadoutStatics_GetItemFromLocalLoadoutSlot::WorldContext' has a wrong offset!");
static_assert(offsetof(GzLoadoutStatics_GetItemFromLocalLoadoutSlot, Guid) == 0x000008, "Member 'GzLoadoutStatics_GetItemFromLocalLoadoutSlot::Guid' has a wrong offset!");
static_assert(offsetof(GzLoadoutStatics_GetItemFromLocalLoadoutSlot, SlotType) == 0x000018, "Member 'GzLoadoutStatics_GetItemFromLocalLoadoutSlot::SlotType' has a wrong offset!");
static_assert(offsetof(GzLoadoutStatics_GetItemFromLocalLoadoutSlot, ReturnValue) == 0x000020, "Member 'GzLoadoutStatics_GetItemFromLocalLoadoutSlot::ReturnValue' has a wrong offset!");

// Function G01.GzLoadoutStatics.GetItemsFromAuthorityLoadout
// 0x0038 (0x0038 - 0x0000)
struct GzLoadoutStatics_GetItemsFromAuthorityLoadout final
{
public:
	const class UObject*                          WorldContext;                                      // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 PlayFabId;                                         // 0x0008(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGuid                                  Guid;                                              // 0x0018(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FGzInvItem>                     ReturnValue;                                       // 0x0028(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzLoadoutStatics_GetItemsFromAuthorityLoadout) == 0x000008, "Wrong alignment on GzLoadoutStatics_GetItemsFromAuthorityLoadout");
static_assert(sizeof(GzLoadoutStatics_GetItemsFromAuthorityLoadout) == 0x000038, "Wrong size on GzLoadoutStatics_GetItemsFromAuthorityLoadout");
static_assert(offsetof(GzLoadoutStatics_GetItemsFromAuthorityLoadout, WorldContext) == 0x000000, "Member 'GzLoadoutStatics_GetItemsFromAuthorityLoadout::WorldContext' has a wrong offset!");
static_assert(offsetof(GzLoadoutStatics_GetItemsFromAuthorityLoadout, PlayFabId) == 0x000008, "Member 'GzLoadoutStatics_GetItemsFromAuthorityLoadout::PlayFabId' has a wrong offset!");
static_assert(offsetof(GzLoadoutStatics_GetItemsFromAuthorityLoadout, Guid) == 0x000018, "Member 'GzLoadoutStatics_GetItemsFromAuthorityLoadout::Guid' has a wrong offset!");
static_assert(offsetof(GzLoadoutStatics_GetItemsFromAuthorityLoadout, ReturnValue) == 0x000028, "Member 'GzLoadoutStatics_GetItemsFromAuthorityLoadout::ReturnValue' has a wrong offset!");

// Function G01.GzLoadoutStatics.GetItemsFromAuthorityLoadoutConfig
// 0x0098 (0x0098 - 0x0000)
struct GzLoadoutStatics_GetItemsFromAuthorityLoadoutConfig final
{
public:
	const class UObject*                          WorldContext;                                      // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGzLoadoutDataConfig                   Config;                                            // 0x0008(0x0070)(ConstParm, Parm, OutParm, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
	class FString                                 PlayFabId;                                         // 0x0078(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FGzInvItem>                     ReturnValue;                                       // 0x0088(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzLoadoutStatics_GetItemsFromAuthorityLoadoutConfig) == 0x000008, "Wrong alignment on GzLoadoutStatics_GetItemsFromAuthorityLoadoutConfig");
static_assert(sizeof(GzLoadoutStatics_GetItemsFromAuthorityLoadoutConfig) == 0x000098, "Wrong size on GzLoadoutStatics_GetItemsFromAuthorityLoadoutConfig");
static_assert(offsetof(GzLoadoutStatics_GetItemsFromAuthorityLoadoutConfig, WorldContext) == 0x000000, "Member 'GzLoadoutStatics_GetItemsFromAuthorityLoadoutConfig::WorldContext' has a wrong offset!");
static_assert(offsetof(GzLoadoutStatics_GetItemsFromAuthorityLoadoutConfig, Config) == 0x000008, "Member 'GzLoadoutStatics_GetItemsFromAuthorityLoadoutConfig::Config' has a wrong offset!");
static_assert(offsetof(GzLoadoutStatics_GetItemsFromAuthorityLoadoutConfig, PlayFabId) == 0x000078, "Member 'GzLoadoutStatics_GetItemsFromAuthorityLoadoutConfig::PlayFabId' has a wrong offset!");
static_assert(offsetof(GzLoadoutStatics_GetItemsFromAuthorityLoadoutConfig, ReturnValue) == 0x000088, "Member 'GzLoadoutStatics_GetItemsFromAuthorityLoadoutConfig::ReturnValue' has a wrong offset!");

// Function G01.GzLoadoutStatics.GetItemsFromLocalLoadout
// 0x0028 (0x0028 - 0x0000)
struct GzLoadoutStatics_GetItemsFromLocalLoadout final
{
public:
	const class UObject*                          WorldContext;                                      // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGuid                                  Guid;                                              // 0x0008(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FGzInvItem>                     ReturnValue;                                       // 0x0018(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzLoadoutStatics_GetItemsFromLocalLoadout) == 0x000008, "Wrong alignment on GzLoadoutStatics_GetItemsFromLocalLoadout");
static_assert(sizeof(GzLoadoutStatics_GetItemsFromLocalLoadout) == 0x000028, "Wrong size on GzLoadoutStatics_GetItemsFromLocalLoadout");
static_assert(offsetof(GzLoadoutStatics_GetItemsFromLocalLoadout, WorldContext) == 0x000000, "Member 'GzLoadoutStatics_GetItemsFromLocalLoadout::WorldContext' has a wrong offset!");
static_assert(offsetof(GzLoadoutStatics_GetItemsFromLocalLoadout, Guid) == 0x000008, "Member 'GzLoadoutStatics_GetItemsFromLocalLoadout::Guid' has a wrong offset!");
static_assert(offsetof(GzLoadoutStatics_GetItemsFromLocalLoadout, ReturnValue) == 0x000018, "Member 'GzLoadoutStatics_GetItemsFromLocalLoadout::ReturnValue' has a wrong offset!");

// Function G01.GzLoadoutStatics.GetItemsFromLocalLoadoutConfig
// 0x0088 (0x0088 - 0x0000)
struct GzLoadoutStatics_GetItemsFromLocalLoadoutConfig final
{
public:
	const class UObject*                          WorldContext;                                      // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGzLoadoutDataConfig                   Config;                                            // 0x0008(0x0070)(ConstParm, Parm, OutParm, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
	TArray<struct FGzInvItem>                     ReturnValue;                                       // 0x0078(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzLoadoutStatics_GetItemsFromLocalLoadoutConfig) == 0x000008, "Wrong alignment on GzLoadoutStatics_GetItemsFromLocalLoadoutConfig");
static_assert(sizeof(GzLoadoutStatics_GetItemsFromLocalLoadoutConfig) == 0x000088, "Wrong size on GzLoadoutStatics_GetItemsFromLocalLoadoutConfig");
static_assert(offsetof(GzLoadoutStatics_GetItemsFromLocalLoadoutConfig, WorldContext) == 0x000000, "Member 'GzLoadoutStatics_GetItemsFromLocalLoadoutConfig::WorldContext' has a wrong offset!");
static_assert(offsetof(GzLoadoutStatics_GetItemsFromLocalLoadoutConfig, Config) == 0x000008, "Member 'GzLoadoutStatics_GetItemsFromLocalLoadoutConfig::Config' has a wrong offset!");
static_assert(offsetof(GzLoadoutStatics_GetItemsFromLocalLoadoutConfig, ReturnValue) == 0x000078, "Member 'GzLoadoutStatics_GetItemsFromLocalLoadoutConfig::ReturnValue' has a wrong offset!");

// Function G01.GzLoadoutStatics.GetLoadoutItemsForSlotsFromConfig
// 0x00C8 (0x00C8 - 0x0000)
struct GzLoadoutStatics_GetLoadoutItemsForSlotsFromConfig final
{
public:
	const class UObject*                          WorldContext;                                      // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGzLoadoutDataConfig                   Config;                                            // 0x0008(0x0070)(ConstParm, Parm, OutParm, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
	TMap<EGzLoadoutSlots, struct FGzInvItem>      ReturnValue;                                       // 0x0078(0x0050)(Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzLoadoutStatics_GetLoadoutItemsForSlotsFromConfig) == 0x000008, "Wrong alignment on GzLoadoutStatics_GetLoadoutItemsForSlotsFromConfig");
static_assert(sizeof(GzLoadoutStatics_GetLoadoutItemsForSlotsFromConfig) == 0x0000C8, "Wrong size on GzLoadoutStatics_GetLoadoutItemsForSlotsFromConfig");
static_assert(offsetof(GzLoadoutStatics_GetLoadoutItemsForSlotsFromConfig, WorldContext) == 0x000000, "Member 'GzLoadoutStatics_GetLoadoutItemsForSlotsFromConfig::WorldContext' has a wrong offset!");
static_assert(offsetof(GzLoadoutStatics_GetLoadoutItemsForSlotsFromConfig, Config) == 0x000008, "Member 'GzLoadoutStatics_GetLoadoutItemsForSlotsFromConfig::Config' has a wrong offset!");
static_assert(offsetof(GzLoadoutStatics_GetLoadoutItemsForSlotsFromConfig, ReturnValue) == 0x000078, "Member 'GzLoadoutStatics_GetLoadoutItemsForSlotsFromConfig::ReturnValue' has a wrong offset!");

// Function G01.GzLoadoutStatics.GetLoadoutItemsForSlotsFromGuid
// 0x0068 (0x0068 - 0x0000)
struct GzLoadoutStatics_GetLoadoutItemsForSlotsFromGuid final
{
public:
	const class UObject*                          WorldContext;                                      // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGuid                                  Guid;                                              // 0x0008(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMap<EGzLoadoutSlots, struct FGzInvItem>      ReturnValue;                                       // 0x0018(0x0050)(Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzLoadoutStatics_GetLoadoutItemsForSlotsFromGuid) == 0x000008, "Wrong alignment on GzLoadoutStatics_GetLoadoutItemsForSlotsFromGuid");
static_assert(sizeof(GzLoadoutStatics_GetLoadoutItemsForSlotsFromGuid) == 0x000068, "Wrong size on GzLoadoutStatics_GetLoadoutItemsForSlotsFromGuid");
static_assert(offsetof(GzLoadoutStatics_GetLoadoutItemsForSlotsFromGuid, WorldContext) == 0x000000, "Member 'GzLoadoutStatics_GetLoadoutItemsForSlotsFromGuid::WorldContext' has a wrong offset!");
static_assert(offsetof(GzLoadoutStatics_GetLoadoutItemsForSlotsFromGuid, Guid) == 0x000008, "Member 'GzLoadoutStatics_GetLoadoutItemsForSlotsFromGuid::Guid' has a wrong offset!");
static_assert(offsetof(GzLoadoutStatics_GetLoadoutItemsForSlotsFromGuid, ReturnValue) == 0x000018, "Member 'GzLoadoutStatics_GetLoadoutItemsForSlotsFromGuid::ReturnValue' has a wrong offset!");

// Function G01.GzLoadoutStatics.GetLoadoutPriceMultiplier
// 0x0010 (0x0010 - 0x0000)
struct GzLoadoutStatics_GetLoadoutPriceMultiplier final
{
public:
	const class UObject*                          WorldContext;                                      // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ReturnValue;                                       // 0x0008(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2CE2[0x4];                                     // 0x000C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GzLoadoutStatics_GetLoadoutPriceMultiplier) == 0x000008, "Wrong alignment on GzLoadoutStatics_GetLoadoutPriceMultiplier");
static_assert(sizeof(GzLoadoutStatics_GetLoadoutPriceMultiplier) == 0x000010, "Wrong size on GzLoadoutStatics_GetLoadoutPriceMultiplier");
static_assert(offsetof(GzLoadoutStatics_GetLoadoutPriceMultiplier, WorldContext) == 0x000000, "Member 'GzLoadoutStatics_GetLoadoutPriceMultiplier::WorldContext' has a wrong offset!");
static_assert(offsetof(GzLoadoutStatics_GetLoadoutPriceMultiplier, ReturnValue) == 0x000008, "Member 'GzLoadoutStatics_GetLoadoutPriceMultiplier::ReturnValue' has a wrong offset!");

// Function G01.GzLoadoutStatics.GetLocalLoadoutCost
// 0x0020 (0x0020 - 0x0000)
struct GzLoadoutStatics_GetLocalLoadoutCost final
{
public:
	const class UObject*                          WorldContext;                                      // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGuid                                  Guid;                                              // 0x0008(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ReturnValue;                                       // 0x0018(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2CE3[0x4];                                     // 0x001C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GzLoadoutStatics_GetLocalLoadoutCost) == 0x000008, "Wrong alignment on GzLoadoutStatics_GetLocalLoadoutCost");
static_assert(sizeof(GzLoadoutStatics_GetLocalLoadoutCost) == 0x000020, "Wrong size on GzLoadoutStatics_GetLocalLoadoutCost");
static_assert(offsetof(GzLoadoutStatics_GetLocalLoadoutCost, WorldContext) == 0x000000, "Member 'GzLoadoutStatics_GetLocalLoadoutCost::WorldContext' has a wrong offset!");
static_assert(offsetof(GzLoadoutStatics_GetLocalLoadoutCost, Guid) == 0x000008, "Member 'GzLoadoutStatics_GetLocalLoadoutCost::Guid' has a wrong offset!");
static_assert(offsetof(GzLoadoutStatics_GetLocalLoadoutCost, ReturnValue) == 0x000018, "Member 'GzLoadoutStatics_GetLocalLoadoutCost::ReturnValue' has a wrong offset!");

// Function G01.GzLoadoutStatics.GetLocalLoadoutName
// 0x0028 (0x0028 - 0x0000)
struct GzLoadoutStatics_GetLocalLoadoutName final
{
public:
	const class UObject*                          WorldContext;                                      // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGuid                                  Guid;                                              // 0x0008(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 ReturnValue;                                       // 0x0018(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzLoadoutStatics_GetLocalLoadoutName) == 0x000008, "Wrong alignment on GzLoadoutStatics_GetLocalLoadoutName");
static_assert(sizeof(GzLoadoutStatics_GetLocalLoadoutName) == 0x000028, "Wrong size on GzLoadoutStatics_GetLocalLoadoutName");
static_assert(offsetof(GzLoadoutStatics_GetLocalLoadoutName, WorldContext) == 0x000000, "Member 'GzLoadoutStatics_GetLocalLoadoutName::WorldContext' has a wrong offset!");
static_assert(offsetof(GzLoadoutStatics_GetLocalLoadoutName, Guid) == 0x000008, "Member 'GzLoadoutStatics_GetLocalLoadoutName::Guid' has a wrong offset!");
static_assert(offsetof(GzLoadoutStatics_GetLocalLoadoutName, ReturnValue) == 0x000018, "Member 'GzLoadoutStatics_GetLocalLoadoutName::ReturnValue' has a wrong offset!");

// Function G01.GzLoadoutStatics.GetPlayerLocalLoadoutGuids
// 0x0018 (0x0018 - 0x0000)
struct GzLoadoutStatics_GetPlayerLocalLoadoutGuids final
{
public:
	const class UObject*                          WorldContext;                                      // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FGuid>                          ReturnValue;                                       // 0x0008(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzLoadoutStatics_GetPlayerLocalLoadoutGuids) == 0x000008, "Wrong alignment on GzLoadoutStatics_GetPlayerLocalLoadoutGuids");
static_assert(sizeof(GzLoadoutStatics_GetPlayerLocalLoadoutGuids) == 0x000018, "Wrong size on GzLoadoutStatics_GetPlayerLocalLoadoutGuids");
static_assert(offsetof(GzLoadoutStatics_GetPlayerLocalLoadoutGuids, WorldContext) == 0x000000, "Member 'GzLoadoutStatics_GetPlayerLocalLoadoutGuids::WorldContext' has a wrong offset!");
static_assert(offsetof(GzLoadoutStatics_GetPlayerLocalLoadoutGuids, ReturnValue) == 0x000008, "Member 'GzLoadoutStatics_GetPlayerLocalLoadoutGuids::ReturnValue' has a wrong offset!");

// Function G01.GzLoadoutStatics.GetSharedLocalLoadoutGuids
// 0x0018 (0x0018 - 0x0000)
struct GzLoadoutStatics_GetSharedLocalLoadoutGuids final
{
public:
	const class UObject*                          WorldContext;                                      // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FGuid>                          ReturnValue;                                       // 0x0008(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzLoadoutStatics_GetSharedLocalLoadoutGuids) == 0x000008, "Wrong alignment on GzLoadoutStatics_GetSharedLocalLoadoutGuids");
static_assert(sizeof(GzLoadoutStatics_GetSharedLocalLoadoutGuids) == 0x000018, "Wrong size on GzLoadoutStatics_GetSharedLocalLoadoutGuids");
static_assert(offsetof(GzLoadoutStatics_GetSharedLocalLoadoutGuids, WorldContext) == 0x000000, "Member 'GzLoadoutStatics_GetSharedLocalLoadoutGuids::WorldContext' has a wrong offset!");
static_assert(offsetof(GzLoadoutStatics_GetSharedLocalLoadoutGuids, ReturnValue) == 0x000008, "Member 'GzLoadoutStatics_GetSharedLocalLoadoutGuids::ReturnValue' has a wrong offset!");

// Function G01.GzLoadoutStatics.HasPlayerLocalLoadouts
// 0x0010 (0x0010 - 0x0000)
struct GzLoadoutStatics_HasPlayerLocalLoadouts final
{
public:
	const class UObject*                          WorldContext;                                      // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2CE4[0x7];                                     // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GzLoadoutStatics_HasPlayerLocalLoadouts) == 0x000008, "Wrong alignment on GzLoadoutStatics_HasPlayerLocalLoadouts");
static_assert(sizeof(GzLoadoutStatics_HasPlayerLocalLoadouts) == 0x000010, "Wrong size on GzLoadoutStatics_HasPlayerLocalLoadouts");
static_assert(offsetof(GzLoadoutStatics_HasPlayerLocalLoadouts, WorldContext) == 0x000000, "Member 'GzLoadoutStatics_HasPlayerLocalLoadouts::WorldContext' has a wrong offset!");
static_assert(offsetof(GzLoadoutStatics_HasPlayerLocalLoadouts, ReturnValue) == 0x000008, "Member 'GzLoadoutStatics_HasPlayerLocalLoadouts::ReturnValue' has a wrong offset!");

// Function G01.GzLoadoutStatics.HasSharedLocalLoadouts
// 0x0010 (0x0010 - 0x0000)
struct GzLoadoutStatics_HasSharedLocalLoadouts final
{
public:
	const class UObject*                          WorldContext;                                      // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2CE5[0x7];                                     // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GzLoadoutStatics_HasSharedLocalLoadouts) == 0x000008, "Wrong alignment on GzLoadoutStatics_HasSharedLocalLoadouts");
static_assert(sizeof(GzLoadoutStatics_HasSharedLocalLoadouts) == 0x000010, "Wrong size on GzLoadoutStatics_HasSharedLocalLoadouts");
static_assert(offsetof(GzLoadoutStatics_HasSharedLocalLoadouts, WorldContext) == 0x000000, "Member 'GzLoadoutStatics_HasSharedLocalLoadouts::WorldContext' has a wrong offset!");
static_assert(offsetof(GzLoadoutStatics_HasSharedLocalLoadouts, ReturnValue) == 0x000008, "Member 'GzLoadoutStatics_HasSharedLocalLoadouts::ReturnValue' has a wrong offset!");

// Function G01.GzLoadoutStatics.IsValidLoadoutConfig
// 0x0078 (0x0078 - 0x0000)
struct GzLoadoutStatics_IsValidLoadoutConfig final
{
public:
	struct FGzLoadoutDataConfig                   Config;                                            // 0x0000(0x0070)(ConstParm, Parm, OutParm, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0070(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2CE6[0x7];                                     // 0x0071(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GzLoadoutStatics_IsValidLoadoutConfig) == 0x000008, "Wrong alignment on GzLoadoutStatics_IsValidLoadoutConfig");
static_assert(sizeof(GzLoadoutStatics_IsValidLoadoutConfig) == 0x000078, "Wrong size on GzLoadoutStatics_IsValidLoadoutConfig");
static_assert(offsetof(GzLoadoutStatics_IsValidLoadoutConfig, Config) == 0x000000, "Member 'GzLoadoutStatics_IsValidLoadoutConfig::Config' has a wrong offset!");
static_assert(offsetof(GzLoadoutStatics_IsValidLoadoutConfig, ReturnValue) == 0x000070, "Member 'GzLoadoutStatics_IsValidLoadoutConfig::ReturnValue' has a wrong offset!");

// Function G01.GzNavigationWidget.GetInitialMousePosition
// 0x0010 (0x0010 - 0x0000)
struct GzNavigationWidget_GetInitialMousePosition final
{
public:
	struct FVector2D                              ReturnValue;                                       // 0x0000(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzNavigationWidget_GetInitialMousePosition) == 0x000008, "Wrong alignment on GzNavigationWidget_GetInitialMousePosition");
static_assert(sizeof(GzNavigationWidget_GetInitialMousePosition) == 0x000010, "Wrong size on GzNavigationWidget_GetInitialMousePosition");
static_assert(offsetof(GzNavigationWidget_GetInitialMousePosition, ReturnValue) == 0x000000, "Member 'GzNavigationWidget_GetInitialMousePosition::ReturnValue' has a wrong offset!");

// Function G01.GzNavigationWidget.OnPawnChanged
// 0x0008 (0x0008 - 0x0000)
struct GzNavigationWidget_OnPawnChanged final
{
public:
	class APawn*                                  Pawn;                                              // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzNavigationWidget_OnPawnChanged) == 0x000008, "Wrong alignment on GzNavigationWidget_OnPawnChanged");
static_assert(sizeof(GzNavigationWidget_OnPawnChanged) == 0x000008, "Wrong size on GzNavigationWidget_OnPawnChanged");
static_assert(offsetof(GzNavigationWidget_OnPawnChanged, Pawn) == 0x000000, "Member 'GzNavigationWidget_OnPawnChanged::Pawn' has a wrong offset!");

// Function G01.GzNavigationWidget.RegisterBinding
// 0x0020 (0x0020 - 0x0000)
struct GzNavigationWidget_RegisterBinding final
{
public:
	class UInputAction*                           InputAction;                                       // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TDelegate<void()>                             Callback;                                          // 0x0008(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGzInputActionBindingHandle            BindingHandle;                                     // 0x0018(0x0004)(Parm, OutParm, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          bDisplayInBar;                                     // 0x001C(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bConsumeInput;                                     // 0x001D(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EInputEvent                                   InputEvent;                                        // 0x001E(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2CEC[0x1];                                     // 0x001F(0x0001)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GzNavigationWidget_RegisterBinding) == 0x000008, "Wrong alignment on GzNavigationWidget_RegisterBinding");
static_assert(sizeof(GzNavigationWidget_RegisterBinding) == 0x000020, "Wrong size on GzNavigationWidget_RegisterBinding");
static_assert(offsetof(GzNavigationWidget_RegisterBinding, InputAction) == 0x000000, "Member 'GzNavigationWidget_RegisterBinding::InputAction' has a wrong offset!");
static_assert(offsetof(GzNavigationWidget_RegisterBinding, Callback) == 0x000008, "Member 'GzNavigationWidget_RegisterBinding::Callback' has a wrong offset!");
static_assert(offsetof(GzNavigationWidget_RegisterBinding, BindingHandle) == 0x000018, "Member 'GzNavigationWidget_RegisterBinding::BindingHandle' has a wrong offset!");
static_assert(offsetof(GzNavigationWidget_RegisterBinding, bDisplayInBar) == 0x00001C, "Member 'GzNavigationWidget_RegisterBinding::bDisplayInBar' has a wrong offset!");
static_assert(offsetof(GzNavigationWidget_RegisterBinding, bConsumeInput) == 0x00001D, "Member 'GzNavigationWidget_RegisterBinding::bConsumeInput' has a wrong offset!");
static_assert(offsetof(GzNavigationWidget_RegisterBinding, InputEvent) == 0x00001E, "Member 'GzNavigationWidget_RegisterBinding::InputEvent' has a wrong offset!");

// Function G01.GzNavigationWidget.ShouldFlushInputOnOpening
// 0x0001 (0x0001 - 0x0000)
struct GzNavigationWidget_ShouldFlushInputOnOpening final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzNavigationWidget_ShouldFlushInputOnOpening) == 0x000001, "Wrong alignment on GzNavigationWidget_ShouldFlushInputOnOpening");
static_assert(sizeof(GzNavigationWidget_ShouldFlushInputOnOpening) == 0x000001, "Wrong size on GzNavigationWidget_ShouldFlushInputOnOpening");
static_assert(offsetof(GzNavigationWidget_ShouldFlushInputOnOpening, ReturnValue) == 0x000000, "Member 'GzNavigationWidget_ShouldFlushInputOnOpening::ReturnValue' has a wrong offset!");

// Function G01.GzNavigationWidget.UnregisterBinding
// 0x0004 (0x0004 - 0x0000)
struct GzNavigationWidget_UnregisterBinding final
{
public:
	struct FGzInputActionBindingHandle            BindingHandle;                                     // 0x0000(0x0004)(Parm, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzNavigationWidget_UnregisterBinding) == 0x000004, "Wrong alignment on GzNavigationWidget_UnregisterBinding");
static_assert(sizeof(GzNavigationWidget_UnregisterBinding) == 0x000004, "Wrong size on GzNavigationWidget_UnregisterBinding");
static_assert(offsetof(GzNavigationWidget_UnregisterBinding, BindingHandle) == 0x000000, "Member 'GzNavigationWidget_UnregisterBinding::BindingHandle' has a wrong offset!");

// Function G01.GzNavigationWidget.UpdateAcceptButton
// 0x0001 (0x0001 - 0x0000)
struct GzNavigationWidget_UpdateAcceptButton final
{
public:
	ECommonInputType                              NewInputType;                                      // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzNavigationWidget_UpdateAcceptButton) == 0x000001, "Wrong alignment on GzNavigationWidget_UpdateAcceptButton");
static_assert(sizeof(GzNavigationWidget_UpdateAcceptButton) == 0x000001, "Wrong size on GzNavigationWidget_UpdateAcceptButton");
static_assert(offsetof(GzNavigationWidget_UpdateAcceptButton, NewInputType) == 0x000000, "Member 'GzNavigationWidget_UpdateAcceptButton::NewInputType' has a wrong offset!");

// Function G01.GzNavigationWidget.CanBeAddedToLayer
// 0x0010 (0x0010 - 0x0000)
struct GzNavigationWidget_CanBeAddedToLayer final
{
public:
	class UObject*                                WorldContext;                                      // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2CED[0x7];                                     // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GzNavigationWidget_CanBeAddedToLayer) == 0x000008, "Wrong alignment on GzNavigationWidget_CanBeAddedToLayer");
static_assert(sizeof(GzNavigationWidget_CanBeAddedToLayer) == 0x000010, "Wrong size on GzNavigationWidget_CanBeAddedToLayer");
static_assert(offsetof(GzNavigationWidget_CanBeAddedToLayer, WorldContext) == 0x000000, "Member 'GzNavigationWidget_CanBeAddedToLayer::WorldContext' has a wrong offset!");
static_assert(offsetof(GzNavigationWidget_CanBeAddedToLayer, ReturnValue) == 0x000008, "Member 'GzNavigationWidget_CanBeAddedToLayer::ReturnValue' has a wrong offset!");

// Function G01.GzNavigationWidget.DoesAllowDuplicates
// 0x0001 (0x0001 - 0x0000)
struct GzNavigationWidget_DoesAllowDuplicates final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzNavigationWidget_DoesAllowDuplicates) == 0x000001, "Wrong alignment on GzNavigationWidget_DoesAllowDuplicates");
static_assert(sizeof(GzNavigationWidget_DoesAllowDuplicates) == 0x000001, "Wrong size on GzNavigationWidget_DoesAllowDuplicates");
static_assert(offsetof(GzNavigationWidget_DoesAllowDuplicates, ReturnValue) == 0x000000, "Member 'GzNavigationWidget_DoesAllowDuplicates::ReturnValue' has a wrong offset!");

// Function G01.GzNavigationWidget.GetLayerKey
// 0x0008 (0x0008 - 0x0000)
struct GzNavigationWidget_GetLayerKey final
{
public:
	class FName                                   ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzNavigationWidget_GetLayerKey) == 0x000004, "Wrong alignment on GzNavigationWidget_GetLayerKey");
static_assert(sizeof(GzNavigationWidget_GetLayerKey) == 0x000008, "Wrong size on GzNavigationWidget_GetLayerKey");
static_assert(offsetof(GzNavigationWidget_GetLayerKey, ReturnValue) == 0x000000, "Member 'GzNavigationWidget_GetLayerKey::ReturnValue' has a wrong offset!");

// Function G01.GzInteractionCondition.IsAutoInteractionConditionPassed
// 0x0018 (0x0018 - 0x0000)
struct GzInteractionCondition_IsAutoInteractionConditionPassed final
{
public:
	const class AGzCharacter*                     InteractedBy;                                      // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	const class AActor*                           InteractableOwner;                                 // 0x0008(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0010(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2CF9[0x7];                                     // 0x0011(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GzInteractionCondition_IsAutoInteractionConditionPassed) == 0x000008, "Wrong alignment on GzInteractionCondition_IsAutoInteractionConditionPassed");
static_assert(sizeof(GzInteractionCondition_IsAutoInteractionConditionPassed) == 0x000018, "Wrong size on GzInteractionCondition_IsAutoInteractionConditionPassed");
static_assert(offsetof(GzInteractionCondition_IsAutoInteractionConditionPassed, InteractedBy) == 0x000000, "Member 'GzInteractionCondition_IsAutoInteractionConditionPassed::InteractedBy' has a wrong offset!");
static_assert(offsetof(GzInteractionCondition_IsAutoInteractionConditionPassed, InteractableOwner) == 0x000008, "Member 'GzInteractionCondition_IsAutoInteractionConditionPassed::InteractableOwner' has a wrong offset!");
static_assert(offsetof(GzInteractionCondition_IsAutoInteractionConditionPassed, ReturnValue) == 0x000010, "Member 'GzInteractionCondition_IsAutoInteractionConditionPassed::ReturnValue' has a wrong offset!");

// Function G01.GzInteractionCondition.IsInteractionConditionPassed
// 0x0018 (0x0018 - 0x0000)
struct GzInteractionCondition_IsInteractionConditionPassed final
{
public:
	const class AGzCharacter*                     InteractedBy;                                      // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	const class AActor*                           InteractableOwner;                                 // 0x0008(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0010(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2CFA[0x7];                                     // 0x0011(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GzInteractionCondition_IsInteractionConditionPassed) == 0x000008, "Wrong alignment on GzInteractionCondition_IsInteractionConditionPassed");
static_assert(sizeof(GzInteractionCondition_IsInteractionConditionPassed) == 0x000018, "Wrong size on GzInteractionCondition_IsInteractionConditionPassed");
static_assert(offsetof(GzInteractionCondition_IsInteractionConditionPassed, InteractedBy) == 0x000000, "Member 'GzInteractionCondition_IsInteractionConditionPassed::InteractedBy' has a wrong offset!");
static_assert(offsetof(GzInteractionCondition_IsInteractionConditionPassed, InteractableOwner) == 0x000008, "Member 'GzInteractionCondition_IsInteractionConditionPassed::InteractableOwner' has a wrong offset!");
static_assert(offsetof(GzInteractionCondition_IsInteractionConditionPassed, ReturnValue) == 0x000010, "Member 'GzInteractionCondition_IsInteractionConditionPassed::ReturnValue' has a wrong offset!");

// Function G01.GzInteractionCondition.GetOwnerActor
// 0x0008 (0x0008 - 0x0000)
struct GzInteractionCondition_GetOwnerActor final
{
public:
	class AActor*                                 ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzInteractionCondition_GetOwnerActor) == 0x000008, "Wrong alignment on GzInteractionCondition_GetOwnerActor");
static_assert(sizeof(GzInteractionCondition_GetOwnerActor) == 0x000008, "Wrong size on GzInteractionCondition_GetOwnerActor");
static_assert(offsetof(GzInteractionCondition_GetOwnerActor, ReturnValue) == 0x000000, "Member 'GzInteractionCondition_GetOwnerActor::ReturnValue' has a wrong offset!");

// Function G01.GzInteractionCondition.GetOwnerASC
// 0x0008 (0x0008 - 0x0000)
struct GzInteractionCondition_GetOwnerASC final
{
public:
	class UAbilitySystemComponent*                ReturnValue;                                       // 0x0000(0x0008)(ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzInteractionCondition_GetOwnerASC) == 0x000008, "Wrong alignment on GzInteractionCondition_GetOwnerASC");
static_assert(sizeof(GzInteractionCondition_GetOwnerASC) == 0x000008, "Wrong size on GzInteractionCondition_GetOwnerASC");
static_assert(offsetof(GzInteractionCondition_GetOwnerASC, ReturnValue) == 0x000000, "Member 'GzInteractionCondition_GetOwnerASC::ReturnValue' has a wrong offset!");

// Function G01.GzStateAction.CheckNetExecutionMode
// 0x0050 (0x0050 - 0x0000)
struct GzStateAction_CheckNetExecutionMode final
{
public:
	struct FGameplayAbilityActorInfo              ActorInfo;                                         // 0x0000(0x0048)(Parm, ContainsInstancedReference, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0048(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2CFE[0x7];                                     // 0x0049(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GzStateAction_CheckNetExecutionMode) == 0x000008, "Wrong alignment on GzStateAction_CheckNetExecutionMode");
static_assert(sizeof(GzStateAction_CheckNetExecutionMode) == 0x000050, "Wrong size on GzStateAction_CheckNetExecutionMode");
static_assert(offsetof(GzStateAction_CheckNetExecutionMode, ActorInfo) == 0x000000, "Member 'GzStateAction_CheckNetExecutionMode::ActorInfo' has a wrong offset!");
static_assert(offsetof(GzStateAction_CheckNetExecutionMode, ReturnValue) == 0x000048, "Member 'GzStateAction_CheckNetExecutionMode::ReturnValue' has a wrong offset!");

// Function G01.GzStateAction.K2_CanActivate
// 0x0058 (0x0058 - 0x0000)
struct GzStateAction_K2_CanActivate final
{
public:
	const class UGzGameplayAbility*               GameplayAbility;                                   // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayAbilityActorInfo              ActorInfo;                                         // 0x0008(0x0048)(Parm, ContainsInstancedReference, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0050(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2CFF[0x7];                                     // 0x0051(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GzStateAction_K2_CanActivate) == 0x000008, "Wrong alignment on GzStateAction_K2_CanActivate");
static_assert(sizeof(GzStateAction_K2_CanActivate) == 0x000058, "Wrong size on GzStateAction_K2_CanActivate");
static_assert(offsetof(GzStateAction_K2_CanActivate, GameplayAbility) == 0x000000, "Member 'GzStateAction_K2_CanActivate::GameplayAbility' has a wrong offset!");
static_assert(offsetof(GzStateAction_K2_CanActivate, ActorInfo) == 0x000008, "Member 'GzStateAction_K2_CanActivate::ActorInfo' has a wrong offset!");
static_assert(offsetof(GzStateAction_K2_CanActivate, ReturnValue) == 0x000050, "Member 'GzStateAction_K2_CanActivate::ReturnValue' has a wrong offset!");

// Function G01.GzStateAction.K2_OnActivate
// 0x0058 (0x0058 - 0x0000)
struct GzStateAction_K2_OnActivate final
{
public:
	class UGzGameplayAbility*                     GameplayAbility;                                   // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayAbilityActorInfo              ActorInfo;                                         // 0x0008(0x0048)(Parm, ContainsInstancedReference, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0050(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2D00[0x7];                                     // 0x0051(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GzStateAction_K2_OnActivate) == 0x000008, "Wrong alignment on GzStateAction_K2_OnActivate");
static_assert(sizeof(GzStateAction_K2_OnActivate) == 0x000058, "Wrong size on GzStateAction_K2_OnActivate");
static_assert(offsetof(GzStateAction_K2_OnActivate, GameplayAbility) == 0x000000, "Member 'GzStateAction_K2_OnActivate::GameplayAbility' has a wrong offset!");
static_assert(offsetof(GzStateAction_K2_OnActivate, ActorInfo) == 0x000008, "Member 'GzStateAction_K2_OnActivate::ActorInfo' has a wrong offset!");
static_assert(offsetof(GzStateAction_K2_OnActivate, ReturnValue) == 0x000050, "Member 'GzStateAction_K2_OnActivate::ReturnValue' has a wrong offset!");

// Function G01.GzStateAction.K2_OnDeactivate
// 0x0058 (0x0058 - 0x0000)
struct GzStateAction_K2_OnDeactivate final
{
public:
	class UGzGameplayAbility*                     GameplayAbility;                                   // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayAbilityActorInfo              ActorInfo;                                         // 0x0008(0x0048)(Parm, ContainsInstancedReference, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0050(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2D01[0x7];                                     // 0x0051(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GzStateAction_K2_OnDeactivate) == 0x000008, "Wrong alignment on GzStateAction_K2_OnDeactivate");
static_assert(sizeof(GzStateAction_K2_OnDeactivate) == 0x000058, "Wrong size on GzStateAction_K2_OnDeactivate");
static_assert(offsetof(GzStateAction_K2_OnDeactivate, GameplayAbility) == 0x000000, "Member 'GzStateAction_K2_OnDeactivate::GameplayAbility' has a wrong offset!");
static_assert(offsetof(GzStateAction_K2_OnDeactivate, ActorInfo) == 0x000008, "Member 'GzStateAction_K2_OnDeactivate::ActorInfo' has a wrong offset!");
static_assert(offsetof(GzStateAction_K2_OnDeactivate, ReturnValue) == 0x000050, "Member 'GzStateAction_K2_OnDeactivate::ReturnValue' has a wrong offset!");

// Function G01.GzSA_ActionOnTimer.OnEvent
// 0x00B0 (0x00B0 - 0x0000)
struct GzSA_ActionOnTimer_OnEvent final
{
public:
	struct FGameplayEventData                     TriggerEventData;                                  // 0x0000(0x00B0)(Parm, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzSA_ActionOnTimer_OnEvent) == 0x000008, "Wrong alignment on GzSA_ActionOnTimer_OnEvent");
static_assert(sizeof(GzSA_ActionOnTimer_OnEvent) == 0x0000B0, "Wrong size on GzSA_ActionOnTimer_OnEvent");
static_assert(offsetof(GzSA_ActionOnTimer_OnEvent, TriggerEventData) == 0x000000, "Member 'GzSA_ActionOnTimer_OnEvent::TriggerEventData' has a wrong offset!");

// Function G01.GzActionWidget.SetActionProgress
// 0x0004 (0x0004 - 0x0000)
struct GzActionWidget_SetActionProgress final
{
public:
	float                                         ProgressValue;                                     // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzActionWidget_SetActionProgress) == 0x000004, "Wrong alignment on GzActionWidget_SetActionProgress");
static_assert(sizeof(GzActionWidget_SetActionProgress) == 0x000004, "Wrong size on GzActionWidget_SetActionProgress");
static_assert(offsetof(GzActionWidget_SetActionProgress, ProgressValue) == 0x000000, "Member 'GzActionWidget_SetActionProgress::ProgressValue' has a wrong offset!");

// Function G01.GzActionWidget.SetAlwaysHide
// 0x0001 (0x0001 - 0x0000)
struct GzActionWidget_SetAlwaysHide final
{
public:
	bool                                          bHide;                                             // 0x0000(0x0001)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzActionWidget_SetAlwaysHide) == 0x000001, "Wrong alignment on GzActionWidget_SetAlwaysHide");
static_assert(sizeof(GzActionWidget_SetAlwaysHide) == 0x000001, "Wrong size on GzActionWidget_SetAlwaysHide");
static_assert(offsetof(GzActionWidget_SetAlwaysHide, bHide) == 0x000000, "Member 'GzActionWidget_SetAlwaysHide::bHide' has a wrong offset!");

// Function G01.GzActionWidget.SetAsHoldAction
// 0x0001 (0x0001 - 0x0000)
struct GzActionWidget_SetAsHoldAction final
{
public:
	bool                                          bInAsHoldAction;                                   // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzActionWidget_SetAsHoldAction) == 0x000001, "Wrong alignment on GzActionWidget_SetAsHoldAction");
static_assert(sizeof(GzActionWidget_SetAsHoldAction) == 0x000001, "Wrong size on GzActionWidget_SetAsHoldAction");
static_assert(offsetof(GzActionWidget_SetAsHoldAction, bInAsHoldAction) == 0x000000, "Member 'GzActionWidget_SetAsHoldAction::bInAsHoldAction' has a wrong offset!");

// Function G01.GzActionWidget.SetAssociatedInputAction
// 0x0008 (0x0008 - 0x0000)
struct GzActionWidget_SetAssociatedInputAction final
{
public:
	class UInputAction*                           NewInputAction;                                    // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzActionWidget_SetAssociatedInputAction) == 0x000008, "Wrong alignment on GzActionWidget_SetAssociatedInputAction");
static_assert(sizeof(GzActionWidget_SetAssociatedInputAction) == 0x000008, "Wrong size on GzActionWidget_SetAssociatedInputAction");
static_assert(offsetof(GzActionWidget_SetAssociatedInputAction, NewInputAction) == 0x000000, "Member 'GzActionWidget_SetAssociatedInputAction::NewInputAction' has a wrong offset!");

// Function G01.GzActionWidget.SetState
// 0x0008 (0x0008 - 0x0000)
struct GzActionWidget_SetState final
{
public:
	struct FGameplayTag                           InState;                                           // 0x0000(0x0008)(Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzActionWidget_SetState) == 0x000004, "Wrong alignment on GzActionWidget_SetState");
static_assert(sizeof(GzActionWidget_SetState) == 0x000008, "Wrong size on GzActionWidget_SetState");
static_assert(offsetof(GzActionWidget_SetState, InState) == 0x000000, "Member 'GzActionWidget_SetState::InState' has a wrong offset!");

// Function G01.GzActionWidget.SetTheme
// 0x0008 (0x0008 - 0x0000)
struct GzActionWidget_SetTheme final
{
public:
	struct FGameplayTag                           ThemeTag;                                          // 0x0000(0x0008)(Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzActionWidget_SetTheme) == 0x000004, "Wrong alignment on GzActionWidget_SetTheme");
static_assert(sizeof(GzActionWidget_SetTheme) == 0x000008, "Wrong size on GzActionWidget_SetTheme");
static_assert(offsetof(GzActionWidget_SetTheme, ThemeTag) == 0x000000, "Member 'GzActionWidget_SetTheme::ThemeTag' has a wrong offset!");

// Function G01.GzCohtmlUserWidget.NotifyPawnChange
// 0x0008 (0x0008 - 0x0000)
struct GzCohtmlUserWidget_NotifyPawnChange final
{
public:
	class APawn*                                  Pawn;                                              // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzCohtmlUserWidget_NotifyPawnChange) == 0x000008, "Wrong alignment on GzCohtmlUserWidget_NotifyPawnChange");
static_assert(sizeof(GzCohtmlUserWidget_NotifyPawnChange) == 0x000008, "Wrong size on GzCohtmlUserWidget_NotifyPawnChange");
static_assert(offsetof(GzCohtmlUserWidget_NotifyPawnChange, Pawn) == 0x000000, "Member 'GzCohtmlUserWidget_NotifyPawnChange::Pawn' has a wrong offset!");

// Function G01.GzWeaponBehaviorAttachment.GetHiden
// 0x0001 (0x0001 - 0x0000)
struct GzWeaponBehaviorAttachment_GetHiden final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzWeaponBehaviorAttachment_GetHiden) == 0x000001, "Wrong alignment on GzWeaponBehaviorAttachment_GetHiden");
static_assert(sizeof(GzWeaponBehaviorAttachment_GetHiden) == 0x000001, "Wrong size on GzWeaponBehaviorAttachment_GetHiden");
static_assert(offsetof(GzWeaponBehaviorAttachment_GetHiden, ReturnValue) == 0x000000, "Member 'GzWeaponBehaviorAttachment_GetHiden::ReturnValue' has a wrong offset!");

// Function G01.GzWeaponBehaviorAttachment.Hide
// 0x0001 (0x0001 - 0x0000)
struct GzWeaponBehaviorAttachment_Hide final
{
public:
	bool                                          bHide;                                             // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzWeaponBehaviorAttachment_Hide) == 0x000001, "Wrong alignment on GzWeaponBehaviorAttachment_Hide");
static_assert(sizeof(GzWeaponBehaviorAttachment_Hide) == 0x000001, "Wrong size on GzWeaponBehaviorAttachment_Hide");
static_assert(offsetof(GzWeaponBehaviorAttachment_Hide, bHide) == 0x000000, "Member 'GzWeaponBehaviorAttachment_Hide::bHide' has a wrong offset!");

// Function G01.GzWeaponBehaviorAttachment.OnHide
// 0x0001 (0x0001 - 0x0000)
struct GzWeaponBehaviorAttachment_OnHide final
{
public:
	bool                                          bHide;                                             // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzWeaponBehaviorAttachment_OnHide) == 0x000001, "Wrong alignment on GzWeaponBehaviorAttachment_OnHide");
static_assert(sizeof(GzWeaponBehaviorAttachment_OnHide) == 0x000001, "Wrong size on GzWeaponBehaviorAttachment_OnHide");
static_assert(offsetof(GzWeaponBehaviorAttachment_OnHide, bHide) == 0x000000, "Member 'GzWeaponBehaviorAttachment_OnHide::bHide' has a wrong offset!");

// Function G01.GzAdvancedCameraParamsComponent.ResetOverlayCameraMode
// 0x0001 (0x0001 - 0x0000)
struct GzAdvancedCameraParamsComponent_ResetOverlayCameraMode final
{
public:
	bool                                          bWithInterpolation;                                // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzAdvancedCameraParamsComponent_ResetOverlayCameraMode) == 0x000001, "Wrong alignment on GzAdvancedCameraParamsComponent_ResetOverlayCameraMode");
static_assert(sizeof(GzAdvancedCameraParamsComponent_ResetOverlayCameraMode) == 0x000001, "Wrong size on GzAdvancedCameraParamsComponent_ResetOverlayCameraMode");
static_assert(offsetof(GzAdvancedCameraParamsComponent_ResetOverlayCameraMode, bWithInterpolation) == 0x000000, "Member 'GzAdvancedCameraParamsComponent_ResetOverlayCameraMode::bWithInterpolation' has a wrong offset!");

// Function G01.GzAdvancedCameraParamsComponent.SetOverlayCameraDistance
// 0x0008 (0x0008 - 0x0000)
struct GzAdvancedCameraParamsComponent_SetOverlayCameraDistance final
{
public:
	float                                         Distance;                                          // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bWithInterpolation;                                // 0x0004(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2D0B[0x3];                                     // 0x0005(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GzAdvancedCameraParamsComponent_SetOverlayCameraDistance) == 0x000004, "Wrong alignment on GzAdvancedCameraParamsComponent_SetOverlayCameraDistance");
static_assert(sizeof(GzAdvancedCameraParamsComponent_SetOverlayCameraDistance) == 0x000008, "Wrong size on GzAdvancedCameraParamsComponent_SetOverlayCameraDistance");
static_assert(offsetof(GzAdvancedCameraParamsComponent_SetOverlayCameraDistance, Distance) == 0x000000, "Member 'GzAdvancedCameraParamsComponent_SetOverlayCameraDistance::Distance' has a wrong offset!");
static_assert(offsetof(GzAdvancedCameraParamsComponent_SetOverlayCameraDistance, bWithInterpolation) == 0x000004, "Member 'GzAdvancedCameraParamsComponent_SetOverlayCameraDistance::bWithInterpolation' has a wrong offset!");

// Function G01.GzAdvancedCameraParamsComponent.SetOverlayCameraMode
// 0x000C (0x000C - 0x0000)
struct GzAdvancedCameraParamsComponent_SetOverlayCameraMode final
{
public:
	struct FGameplayTag                           CameraModeTag;                                     // 0x0000(0x0008)(Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bWithInterpolation;                                // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2D0C[0x3];                                     // 0x0009(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GzAdvancedCameraParamsComponent_SetOverlayCameraMode) == 0x000004, "Wrong alignment on GzAdvancedCameraParamsComponent_SetOverlayCameraMode");
static_assert(sizeof(GzAdvancedCameraParamsComponent_SetOverlayCameraMode) == 0x00000C, "Wrong size on GzAdvancedCameraParamsComponent_SetOverlayCameraMode");
static_assert(offsetof(GzAdvancedCameraParamsComponent_SetOverlayCameraMode, CameraModeTag) == 0x000000, "Member 'GzAdvancedCameraParamsComponent_SetOverlayCameraMode::CameraModeTag' has a wrong offset!");
static_assert(offsetof(GzAdvancedCameraParamsComponent_SetOverlayCameraMode, bWithInterpolation) == 0x000008, "Member 'GzAdvancedCameraParamsComponent_SetOverlayCameraMode::bWithInterpolation' has a wrong offset!");

// Function G01.GzAdvancedCameraParamsComponent.SetOverlayCameraModeManually
// 0x0010 (0x0010 - 0x0000)
struct GzAdvancedCameraParamsComponent_SetOverlayCameraModeManually final
{
public:
	class UGzCameraOverlayModeDataAsset*          OverlayCameraMode;                                 // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bWithInterpolation;                                // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2D0D[0x7];                                     // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GzAdvancedCameraParamsComponent_SetOverlayCameraModeManually) == 0x000008, "Wrong alignment on GzAdvancedCameraParamsComponent_SetOverlayCameraModeManually");
static_assert(sizeof(GzAdvancedCameraParamsComponent_SetOverlayCameraModeManually) == 0x000010, "Wrong size on GzAdvancedCameraParamsComponent_SetOverlayCameraModeManually");
static_assert(offsetof(GzAdvancedCameraParamsComponent_SetOverlayCameraModeManually, OverlayCameraMode) == 0x000000, "Member 'GzAdvancedCameraParamsComponent_SetOverlayCameraModeManually::OverlayCameraMode' has a wrong offset!");
static_assert(offsetof(GzAdvancedCameraParamsComponent_SetOverlayCameraModeManually, bWithInterpolation) == 0x000008, "Member 'GzAdvancedCameraParamsComponent_SetOverlayCameraModeManually::bWithInterpolation' has a wrong offset!");

// Function G01.GzAdvancedCameraParamsComponent.GetOverlayCameraModeFromTag
// 0x0010 (0x0010 - 0x0000)
struct GzAdvancedCameraParamsComponent_GetOverlayCameraModeFromTag final
{
public:
	struct FGameplayTag                           CameraModeTag;                                     // 0x0000(0x0008)(Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UGzCameraOverlayModeDataAsset*          ReturnValue;                                       // 0x0008(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzAdvancedCameraParamsComponent_GetOverlayCameraModeFromTag) == 0x000008, "Wrong alignment on GzAdvancedCameraParamsComponent_GetOverlayCameraModeFromTag");
static_assert(sizeof(GzAdvancedCameraParamsComponent_GetOverlayCameraModeFromTag) == 0x000010, "Wrong size on GzAdvancedCameraParamsComponent_GetOverlayCameraModeFromTag");
static_assert(offsetof(GzAdvancedCameraParamsComponent_GetOverlayCameraModeFromTag, CameraModeTag) == 0x000000, "Member 'GzAdvancedCameraParamsComponent_GetOverlayCameraModeFromTag::CameraModeTag' has a wrong offset!");
static_assert(offsetof(GzAdvancedCameraParamsComponent_GetOverlayCameraModeFromTag, ReturnValue) == 0x000008, "Member 'GzAdvancedCameraParamsComponent_GetOverlayCameraModeFromTag::ReturnValue' has a wrong offset!");

// Function G01.GzAdvancedCameraParamsComponent.GetOverlayLocationObject
// 0x0008 (0x0008 - 0x0000)
struct GzAdvancedCameraParamsComponent_GetOverlayLocationObject final
{
public:
	class UGzCameraOverlayLocationObject*         ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzAdvancedCameraParamsComponent_GetOverlayLocationObject) == 0x000008, "Wrong alignment on GzAdvancedCameraParamsComponent_GetOverlayLocationObject");
static_assert(sizeof(GzAdvancedCameraParamsComponent_GetOverlayLocationObject) == 0x000008, "Wrong size on GzAdvancedCameraParamsComponent_GetOverlayLocationObject");
static_assert(offsetof(GzAdvancedCameraParamsComponent_GetOverlayLocationObject, ReturnValue) == 0x000000, "Member 'GzAdvancedCameraParamsComponent_GetOverlayLocationObject::ReturnValue' has a wrong offset!");

// Function G01.GzAdvancedMission.BuildObjectiveGraph
// 0x0008 (0x0008 - 0x0000)
struct GzAdvancedMission_BuildObjectiveGraph final
{
public:
	class UGzObjective*                           ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzAdvancedMission_BuildObjectiveGraph) == 0x000008, "Wrong alignment on GzAdvancedMission_BuildObjectiveGraph");
static_assert(sizeof(GzAdvancedMission_BuildObjectiveGraph) == 0x000008, "Wrong size on GzAdvancedMission_BuildObjectiveGraph");
static_assert(offsetof(GzAdvancedMission_BuildObjectiveGraph, ReturnValue) == 0x000000, "Member 'GzAdvancedMission_BuildObjectiveGraph::ReturnValue' has a wrong offset!");

// Function G01.GzAdvancedMission.CreateOrSyncTask
// 0x0010 (0x0010 - 0x0000)
struct GzAdvancedMission_CreateOrSyncTask final
{
public:
	const class UClass*                           TaskClass;                                         // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UGzMissionTask*                         ReturnValue;                                       // 0x0008(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzAdvancedMission_CreateOrSyncTask) == 0x000008, "Wrong alignment on GzAdvancedMission_CreateOrSyncTask");
static_assert(sizeof(GzAdvancedMission_CreateOrSyncTask) == 0x000010, "Wrong size on GzAdvancedMission_CreateOrSyncTask");
static_assert(offsetof(GzAdvancedMission_CreateOrSyncTask, TaskClass) == 0x000000, "Member 'GzAdvancedMission_CreateOrSyncTask::TaskClass' has a wrong offset!");
static_assert(offsetof(GzAdvancedMission_CreateOrSyncTask, ReturnValue) == 0x000008, "Member 'GzAdvancedMission_CreateOrSyncTask::ReturnValue' has a wrong offset!");

// Function G01.GzAdvancedMission.GetMissionName
// 0x0010 (0x0010 - 0x0000)
struct GzAdvancedMission_GetMissionName final
{
public:
	class FText                                   ReturnValue;                                       // 0x0000(0x0010)(ConstParm, Parm, OutParm, ReturnParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzAdvancedMission_GetMissionName) == 0x000008, "Wrong alignment on GzAdvancedMission_GetMissionName");
static_assert(sizeof(GzAdvancedMission_GetMissionName) == 0x000010, "Wrong size on GzAdvancedMission_GetMissionName");
static_assert(offsetof(GzAdvancedMission_GetMissionName, ReturnValue) == 0x000000, "Member 'GzAdvancedMission_GetMissionName::ReturnValue' has a wrong offset!");

// Function G01.GzAdvancedMission.GetMissionState
// 0x0001 (0x0001 - 0x0000)
struct GzAdvancedMission_GetMissionState final
{
public:
	EGzMissionState                               ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzAdvancedMission_GetMissionState) == 0x000001, "Wrong alignment on GzAdvancedMission_GetMissionState");
static_assert(sizeof(GzAdvancedMission_GetMissionState) == 0x000001, "Wrong size on GzAdvancedMission_GetMissionState");
static_assert(offsetof(GzAdvancedMission_GetMissionState, ReturnValue) == 0x000000, "Member 'GzAdvancedMission_GetMissionState::ReturnValue' has a wrong offset!");

// Function G01.GzAdvancedMission.IsTracked
// 0x0001 (0x0001 - 0x0000)
struct GzAdvancedMission_IsTracked final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzAdvancedMission_IsTracked) == 0x000001, "Wrong alignment on GzAdvancedMission_IsTracked");
static_assert(sizeof(GzAdvancedMission_IsTracked) == 0x000001, "Wrong size on GzAdvancedMission_IsTracked");
static_assert(offsetof(GzAdvancedMission_IsTracked, ReturnValue) == 0x000000, "Member 'GzAdvancedMission_IsTracked::ReturnValue' has a wrong offset!");

// Function G01.GzWeaponModifier.ApplyModifier
// 0x0010 (0x0010 - 0x0000)
struct GzWeaponModifier_ApplyModifier final
{
public:
	class UGzWeaponComponent*                     WeaponComponent;                                   // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2D12[0x7];                                     // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GzWeaponModifier_ApplyModifier) == 0x000008, "Wrong alignment on GzWeaponModifier_ApplyModifier");
static_assert(sizeof(GzWeaponModifier_ApplyModifier) == 0x000010, "Wrong size on GzWeaponModifier_ApplyModifier");
static_assert(offsetof(GzWeaponModifier_ApplyModifier, WeaponComponent) == 0x000000, "Member 'GzWeaponModifier_ApplyModifier::WeaponComponent' has a wrong offset!");
static_assert(offsetof(GzWeaponModifier_ApplyModifier, ReturnValue) == 0x000008, "Member 'GzWeaponModifier_ApplyModifier::ReturnValue' has a wrong offset!");

// Function G01.GzWeaponModifier.IsEquipModifier
// 0x0001 (0x0001 - 0x0000)
struct GzWeaponModifier_IsEquipModifier final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzWeaponModifier_IsEquipModifier) == 0x000001, "Wrong alignment on GzWeaponModifier_IsEquipModifier");
static_assert(sizeof(GzWeaponModifier_IsEquipModifier) == 0x000001, "Wrong size on GzWeaponModifier_IsEquipModifier");
static_assert(offsetof(GzWeaponModifier_IsEquipModifier, ReturnValue) == 0x000000, "Member 'GzWeaponModifier_IsEquipModifier::ReturnValue' has a wrong offset!");

// Function G01.GzWeaponModifier.IsServerOnlyModifier
// 0x0001 (0x0001 - 0x0000)
struct GzWeaponModifier_IsServerOnlyModifier final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzWeaponModifier_IsServerOnlyModifier) == 0x000001, "Wrong alignment on GzWeaponModifier_IsServerOnlyModifier");
static_assert(sizeof(GzWeaponModifier_IsServerOnlyModifier) == 0x000001, "Wrong size on GzWeaponModifier_IsServerOnlyModifier");
static_assert(offsetof(GzWeaponModifier_IsServerOnlyModifier, ReturnValue) == 0x000000, "Member 'GzWeaponModifier_IsServerOnlyModifier::ReturnValue' has a wrong offset!");

// Function G01.GzWeaponModifier.RemoveModifier
// 0x0010 (0x0010 - 0x0000)
struct GzWeaponModifier_RemoveModifier final
{
public:
	class UGzWeaponComponent*                     WeaponComponent;                                   // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2D13[0x7];                                     // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GzWeaponModifier_RemoveModifier) == 0x000008, "Wrong alignment on GzWeaponModifier_RemoveModifier");
static_assert(sizeof(GzWeaponModifier_RemoveModifier) == 0x000010, "Wrong size on GzWeaponModifier_RemoveModifier");
static_assert(offsetof(GzWeaponModifier_RemoveModifier, WeaponComponent) == 0x000000, "Member 'GzWeaponModifier_RemoveModifier::WeaponComponent' has a wrong offset!");
static_assert(offsetof(GzWeaponModifier_RemoveModifier, ReturnValue) == 0x000008, "Member 'GzWeaponModifier_RemoveModifier::ReturnValue' has a wrong offset!");

// Function G01.GzAIActivateAbilityAsyncTaskBlueprintProxy.CreateActivateAbilityMontageProxyObject
// 0x0028 (0x0028 - 0x0000)
struct GzAIActivateAbilityAsyncTaskBlueprintProxy_CreateActivateAbilityMontageProxyObject final
{
public:
	class APawn*                                  InPawn;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UGameplayAbility>           InAbilityToActivate;                               // 0x0008(0x0008)(Parm, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimMontage*                           AnimMontage;                                       // 0x0010(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   StartSection;                                      // 0x0018(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UGzAIActivateAbilityAsyncTaskBlueprintProxy* ReturnValue;                                       // 0x0020(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzAIActivateAbilityAsyncTaskBlueprintProxy_CreateActivateAbilityMontageProxyObject) == 0x000008, "Wrong alignment on GzAIActivateAbilityAsyncTaskBlueprintProxy_CreateActivateAbilityMontageProxyObject");
static_assert(sizeof(GzAIActivateAbilityAsyncTaskBlueprintProxy_CreateActivateAbilityMontageProxyObject) == 0x000028, "Wrong size on GzAIActivateAbilityAsyncTaskBlueprintProxy_CreateActivateAbilityMontageProxyObject");
static_assert(offsetof(GzAIActivateAbilityAsyncTaskBlueprintProxy_CreateActivateAbilityMontageProxyObject, InPawn) == 0x000000, "Member 'GzAIActivateAbilityAsyncTaskBlueprintProxy_CreateActivateAbilityMontageProxyObject::InPawn' has a wrong offset!");
static_assert(offsetof(GzAIActivateAbilityAsyncTaskBlueprintProxy_CreateActivateAbilityMontageProxyObject, InAbilityToActivate) == 0x000008, "Member 'GzAIActivateAbilityAsyncTaskBlueprintProxy_CreateActivateAbilityMontageProxyObject::InAbilityToActivate' has a wrong offset!");
static_assert(offsetof(GzAIActivateAbilityAsyncTaskBlueprintProxy_CreateActivateAbilityMontageProxyObject, AnimMontage) == 0x000010, "Member 'GzAIActivateAbilityAsyncTaskBlueprintProxy_CreateActivateAbilityMontageProxyObject::AnimMontage' has a wrong offset!");
static_assert(offsetof(GzAIActivateAbilityAsyncTaskBlueprintProxy_CreateActivateAbilityMontageProxyObject, StartSection) == 0x000018, "Member 'GzAIActivateAbilityAsyncTaskBlueprintProxy_CreateActivateAbilityMontageProxyObject::StartSection' has a wrong offset!");
static_assert(offsetof(GzAIActivateAbilityAsyncTaskBlueprintProxy_CreateActivateAbilityMontageProxyObject, ReturnValue) == 0x000020, "Member 'GzAIActivateAbilityAsyncTaskBlueprintProxy_CreateActivateAbilityMontageProxyObject::ReturnValue' has a wrong offset!");

// Function G01.GzAIActivateAbilityAsyncTaskBlueprintProxy.CreateActivateAbilityProxyObject
// 0x0018 (0x0018 - 0x0000)
struct GzAIActivateAbilityAsyncTaskBlueprintProxy_CreateActivateAbilityProxyObject final
{
public:
	class APawn*                                  InPawn;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UGameplayAbility>           InAbilityToActivate;                               // 0x0008(0x0008)(Parm, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UGzAIActivateAbilityAsyncTaskBlueprintProxy* ReturnValue;                                       // 0x0010(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzAIActivateAbilityAsyncTaskBlueprintProxy_CreateActivateAbilityProxyObject) == 0x000008, "Wrong alignment on GzAIActivateAbilityAsyncTaskBlueprintProxy_CreateActivateAbilityProxyObject");
static_assert(sizeof(GzAIActivateAbilityAsyncTaskBlueprintProxy_CreateActivateAbilityProxyObject) == 0x000018, "Wrong size on GzAIActivateAbilityAsyncTaskBlueprintProxy_CreateActivateAbilityProxyObject");
static_assert(offsetof(GzAIActivateAbilityAsyncTaskBlueprintProxy_CreateActivateAbilityProxyObject, InPawn) == 0x000000, "Member 'GzAIActivateAbilityAsyncTaskBlueprintProxy_CreateActivateAbilityProxyObject::InPawn' has a wrong offset!");
static_assert(offsetof(GzAIActivateAbilityAsyncTaskBlueprintProxy_CreateActivateAbilityProxyObject, InAbilityToActivate) == 0x000008, "Member 'GzAIActivateAbilityAsyncTaskBlueprintProxy_CreateActivateAbilityProxyObject::InAbilityToActivate' has a wrong offset!");
static_assert(offsetof(GzAIActivateAbilityAsyncTaskBlueprintProxy_CreateActivateAbilityProxyObject, ReturnValue) == 0x000010, "Member 'GzAIActivateAbilityAsyncTaskBlueprintProxy_CreateActivateAbilityProxyObject::ReturnValue' has a wrong offset!");

// Function G01.GzAIActivateAbilityAsyncTaskBlueprintProxy.CreateActivateAbilityProxyObjectFull
// 0x0030 (0x0030 - 0x0000)
struct GzAIActivateAbilityAsyncTaskBlueprintProxy_CreateActivateAbilityProxyObjectFull final
{
public:
	class APawn*                                  InPawn;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UGameplayAbility>           InAbilityToActivate;                               // 0x0008(0x0008)(Parm, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 Target;                                            // 0x0010(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UObject*                                OptionalObject;                                    // 0x0018(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UObject*                                OptionalObject2;                                   // 0x0020(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UGzAIActivateAbilityAsyncTaskBlueprintProxy* ReturnValue;                                       // 0x0028(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzAIActivateAbilityAsyncTaskBlueprintProxy_CreateActivateAbilityProxyObjectFull) == 0x000008, "Wrong alignment on GzAIActivateAbilityAsyncTaskBlueprintProxy_CreateActivateAbilityProxyObjectFull");
static_assert(sizeof(GzAIActivateAbilityAsyncTaskBlueprintProxy_CreateActivateAbilityProxyObjectFull) == 0x000030, "Wrong size on GzAIActivateAbilityAsyncTaskBlueprintProxy_CreateActivateAbilityProxyObjectFull");
static_assert(offsetof(GzAIActivateAbilityAsyncTaskBlueprintProxy_CreateActivateAbilityProxyObjectFull, InPawn) == 0x000000, "Member 'GzAIActivateAbilityAsyncTaskBlueprintProxy_CreateActivateAbilityProxyObjectFull::InPawn' has a wrong offset!");
static_assert(offsetof(GzAIActivateAbilityAsyncTaskBlueprintProxy_CreateActivateAbilityProxyObjectFull, InAbilityToActivate) == 0x000008, "Member 'GzAIActivateAbilityAsyncTaskBlueprintProxy_CreateActivateAbilityProxyObjectFull::InAbilityToActivate' has a wrong offset!");
static_assert(offsetof(GzAIActivateAbilityAsyncTaskBlueprintProxy_CreateActivateAbilityProxyObjectFull, Target) == 0x000010, "Member 'GzAIActivateAbilityAsyncTaskBlueprintProxy_CreateActivateAbilityProxyObjectFull::Target' has a wrong offset!");
static_assert(offsetof(GzAIActivateAbilityAsyncTaskBlueprintProxy_CreateActivateAbilityProxyObjectFull, OptionalObject) == 0x000018, "Member 'GzAIActivateAbilityAsyncTaskBlueprintProxy_CreateActivateAbilityProxyObjectFull::OptionalObject' has a wrong offset!");
static_assert(offsetof(GzAIActivateAbilityAsyncTaskBlueprintProxy_CreateActivateAbilityProxyObjectFull, OptionalObject2) == 0x000020, "Member 'GzAIActivateAbilityAsyncTaskBlueprintProxy_CreateActivateAbilityProxyObjectFull::OptionalObject2' has a wrong offset!");
static_assert(offsetof(GzAIActivateAbilityAsyncTaskBlueprintProxy_CreateActivateAbilityProxyObjectFull, ReturnValue) == 0x000028, "Member 'GzAIActivateAbilityAsyncTaskBlueprintProxy_CreateActivateAbilityProxyObjectFull::ReturnValue' has a wrong offset!");

// Function G01.GzAIActivateAbilityAsyncTaskBlueprintProxy.CreateActivateAbilityProxyObjectWithTarget
// 0x0020 (0x0020 - 0x0000)
struct GzAIActivateAbilityAsyncTaskBlueprintProxy_CreateActivateAbilityProxyObjectWithTarget final
{
public:
	class APawn*                                  InPawn;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UGameplayAbility>           InAbilityToActivate;                               // 0x0008(0x0008)(Parm, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 Target;                                            // 0x0010(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UGzAIActivateAbilityAsyncTaskBlueprintProxy* ReturnValue;                                       // 0x0018(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzAIActivateAbilityAsyncTaskBlueprintProxy_CreateActivateAbilityProxyObjectWithTarget) == 0x000008, "Wrong alignment on GzAIActivateAbilityAsyncTaskBlueprintProxy_CreateActivateAbilityProxyObjectWithTarget");
static_assert(sizeof(GzAIActivateAbilityAsyncTaskBlueprintProxy_CreateActivateAbilityProxyObjectWithTarget) == 0x000020, "Wrong size on GzAIActivateAbilityAsyncTaskBlueprintProxy_CreateActivateAbilityProxyObjectWithTarget");
static_assert(offsetof(GzAIActivateAbilityAsyncTaskBlueprintProxy_CreateActivateAbilityProxyObjectWithTarget, InPawn) == 0x000000, "Member 'GzAIActivateAbilityAsyncTaskBlueprintProxy_CreateActivateAbilityProxyObjectWithTarget::InPawn' has a wrong offset!");
static_assert(offsetof(GzAIActivateAbilityAsyncTaskBlueprintProxy_CreateActivateAbilityProxyObjectWithTarget, InAbilityToActivate) == 0x000008, "Member 'GzAIActivateAbilityAsyncTaskBlueprintProxy_CreateActivateAbilityProxyObjectWithTarget::InAbilityToActivate' has a wrong offset!");
static_assert(offsetof(GzAIActivateAbilityAsyncTaskBlueprintProxy_CreateActivateAbilityProxyObjectWithTarget, Target) == 0x000010, "Member 'GzAIActivateAbilityAsyncTaskBlueprintProxy_CreateActivateAbilityProxyObjectWithTarget::Target' has a wrong offset!");
static_assert(offsetof(GzAIActivateAbilityAsyncTaskBlueprintProxy_CreateActivateAbilityProxyObjectWithTarget, ReturnValue) == 0x000018, "Member 'GzAIActivateAbilityAsyncTaskBlueprintProxy_CreateActivateAbilityProxyObjectWithTarget::ReturnValue' has a wrong offset!");

// Function G01.GzAIActivateAbilityAsyncTaskBlueprintProxy.OnGameAbilityEnded
// 0x0010 (0x0010 - 0x0000)
struct GzAIActivateAbilityAsyncTaskBlueprintProxy_OnGameAbilityEnded final
{
public:
	struct FAbilityEndedData                      AbilityEndedData;                                  // 0x0000(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzAIActivateAbilityAsyncTaskBlueprintProxy_OnGameAbilityEnded) == 0x000008, "Wrong alignment on GzAIActivateAbilityAsyncTaskBlueprintProxy_OnGameAbilityEnded");
static_assert(sizeof(GzAIActivateAbilityAsyncTaskBlueprintProxy_OnGameAbilityEnded) == 0x000010, "Wrong size on GzAIActivateAbilityAsyncTaskBlueprintProxy_OnGameAbilityEnded");
static_assert(offsetof(GzAIActivateAbilityAsyncTaskBlueprintProxy_OnGameAbilityEnded, AbilityEndedData) == 0x000000, "Member 'GzAIActivateAbilityAsyncTaskBlueprintProxy_OnGameAbilityEnded::AbilityEndedData' has a wrong offset!");

// Function G01.GzMissionTask.RegisterMarker
// 0x0008 (0x0008 - 0x0000)
struct GzMissionTask_RegisterMarker final
{
public:
	class AGzMissionMarker*                       Marker;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzMissionTask_RegisterMarker) == 0x000008, "Wrong alignment on GzMissionTask_RegisterMarker");
static_assert(sizeof(GzMissionTask_RegisterMarker) == 0x000008, "Wrong size on GzMissionTask_RegisterMarker");
static_assert(offsetof(GzMissionTask_RegisterMarker, Marker) == 0x000000, "Member 'GzMissionTask_RegisterMarker::Marker' has a wrong offset!");

// Function G01.GzMissionTask.UnregisterMarker
// 0x0004 (0x0004 - 0x0000)
struct GzMissionTask_UnregisterMarker final
{
public:
	int32                                         Param_Index;                                       // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzMissionTask_UnregisterMarker) == 0x000004, "Wrong alignment on GzMissionTask_UnregisterMarker");
static_assert(sizeof(GzMissionTask_UnregisterMarker) == 0x000004, "Wrong size on GzMissionTask_UnregisterMarker");
static_assert(offsetof(GzMissionTask_UnregisterMarker, Param_Index) == 0x000000, "Member 'GzMissionTask_UnregisterMarker::Param_Index' has a wrong offset!");

// Function G01.GzMissionTask.GetGroupChecked
// 0x0020 (0x0020 - 0x0000)
struct GzMissionTask_GetGroupChecked final
{
public:
	struct FGzMissionGroup                        ReturnValue;                                       // 0x0000(0x0020)(ConstParm, Parm, OutParm, ReturnParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzMissionTask_GetGroupChecked) == 0x000008, "Wrong alignment on GzMissionTask_GetGroupChecked");
static_assert(sizeof(GzMissionTask_GetGroupChecked) == 0x000020, "Wrong size on GzMissionTask_GetGroupChecked");
static_assert(offsetof(GzMissionTask_GetGroupChecked, ReturnValue) == 0x000000, "Member 'GzMissionTask_GetGroupChecked::ReturnValue' has a wrong offset!");

// Function G01.GzMissionTask.GetGroupId
// 0x0004 (0x0004 - 0x0000)
struct GzMissionTask_GetGroupId final
{
public:
	int32                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzMissionTask_GetGroupId) == 0x000004, "Wrong alignment on GzMissionTask_GetGroupId");
static_assert(sizeof(GzMissionTask_GetGroupId) == 0x000004, "Wrong size on GzMissionTask_GetGroupId");
static_assert(offsetof(GzMissionTask_GetGroupId, ReturnValue) == 0x000000, "Member 'GzMissionTask_GetGroupId::ReturnValue' has a wrong offset!");

// Function G01.GzMissionTask.GetMissionChecked
// 0x0008 (0x0008 - 0x0000)
struct GzMissionTask_GetMissionChecked final
{
public:
	class AGzAdvancedMission*                     ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzMissionTask_GetMissionChecked) == 0x000008, "Wrong alignment on GzMissionTask_GetMissionChecked");
static_assert(sizeof(GzMissionTask_GetMissionChecked) == 0x000008, "Wrong size on GzMissionTask_GetMissionChecked");
static_assert(offsetof(GzMissionTask_GetMissionChecked, ReturnValue) == 0x000000, "Member 'GzMissionTask_GetMissionChecked::ReturnValue' has a wrong offset!");

// Function G01.GzMissionTask.HasAuthority
// 0x0001 (0x0001 - 0x0000)
struct GzMissionTask_HasAuthority final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzMissionTask_HasAuthority) == 0x000001, "Wrong alignment on GzMissionTask_HasAuthority");
static_assert(sizeof(GzMissionTask_HasAuthority) == 0x000001, "Wrong size on GzMissionTask_HasAuthority");
static_assert(offsetof(GzMissionTask_HasAuthority, ReturnValue) == 0x000000, "Member 'GzMissionTask_HasAuthority::ReturnValue' has a wrong offset!");

// Function G01.GzMissionTask.HasGroupMember
// 0x0008 (0x0008 - 0x0000)
struct GzMissionTask_HasGroupMember final
{
public:
	int32                                         PlayerId;                                          // 0x0000(0x0004)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0004(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2D16[0x3];                                     // 0x0005(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GzMissionTask_HasGroupMember) == 0x000004, "Wrong alignment on GzMissionTask_HasGroupMember");
static_assert(sizeof(GzMissionTask_HasGroupMember) == 0x000008, "Wrong size on GzMissionTask_HasGroupMember");
static_assert(offsetof(GzMissionTask_HasGroupMember, PlayerId) == 0x000000, "Member 'GzMissionTask_HasGroupMember::PlayerId' has a wrong offset!");
static_assert(offsetof(GzMissionTask_HasGroupMember, ReturnValue) == 0x000004, "Member 'GzMissionTask_HasGroupMember::ReturnValue' has a wrong offset!");

// Function G01.GzMissionTask.IsRunningOnClient
// 0x0001 (0x0001 - 0x0000)
struct GzMissionTask_IsRunningOnClient final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzMissionTask_IsRunningOnClient) == 0x000001, "Wrong alignment on GzMissionTask_IsRunningOnClient");
static_assert(sizeof(GzMissionTask_IsRunningOnClient) == 0x000001, "Wrong size on GzMissionTask_IsRunningOnClient");
static_assert(offsetof(GzMissionTask_IsRunningOnClient, ReturnValue) == 0x000000, "Member 'GzMissionTask_IsRunningOnClient::ReturnValue' has a wrong offset!");

// Function G01.GzCompletedObjective.MakeCompletedObjective
// 0x0010 (0x0010 - 0x0000)
struct GzCompletedObjective_MakeCompletedObjective final
{
public:
	class AGzAdvancedMission*                     Mission;                                           // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UGzObjective*                           ReturnValue;                                       // 0x0008(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzCompletedObjective_MakeCompletedObjective) == 0x000008, "Wrong alignment on GzCompletedObjective_MakeCompletedObjective");
static_assert(sizeof(GzCompletedObjective_MakeCompletedObjective) == 0x000010, "Wrong size on GzCompletedObjective_MakeCompletedObjective");
static_assert(offsetof(GzCompletedObjective_MakeCompletedObjective, Mission) == 0x000000, "Member 'GzCompletedObjective_MakeCompletedObjective::Mission' has a wrong offset!");
static_assert(offsetof(GzCompletedObjective_MakeCompletedObjective, ReturnValue) == 0x000008, "Member 'GzCompletedObjective_MakeCompletedObjective::ReturnValue' has a wrong offset!");

// Function G01.GzAutotestComponent.AppendBlueprintCommandDetailedLog
// 0x0010 (0x0010 - 0x0000)
struct GzAutotestComponent_AppendBlueprintCommandDetailedLog final
{
public:
	class FString                                 DetailedLog;                                       // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzAutotestComponent_AppendBlueprintCommandDetailedLog) == 0x000008, "Wrong alignment on GzAutotestComponent_AppendBlueprintCommandDetailedLog");
static_assert(sizeof(GzAutotestComponent_AppendBlueprintCommandDetailedLog) == 0x000010, "Wrong size on GzAutotestComponent_AppendBlueprintCommandDetailedLog");
static_assert(offsetof(GzAutotestComponent_AppendBlueprintCommandDetailedLog, DetailedLog) == 0x000000, "Member 'GzAutotestComponent_AppendBlueprintCommandDetailedLog::DetailedLog' has a wrong offset!");

// Function G01.GzAutotestComponent.InitializeTriggers
// 0x0008 (0x0008 - 0x0000)
struct GzAutotestComponent_InitializeTriggers final
{
public:
	const class AActor*                           Owner;                                             // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzAutotestComponent_InitializeTriggers) == 0x000008, "Wrong alignment on GzAutotestComponent_InitializeTriggers");
static_assert(sizeof(GzAutotestComponent_InitializeTriggers) == 0x000008, "Wrong size on GzAutotestComponent_InitializeTriggers");
static_assert(offsetof(GzAutotestComponent_InitializeTriggers, Owner) == 0x000000, "Member 'GzAutotestComponent_InitializeTriggers::Owner' has a wrong offset!");

// Function G01.GzAutotestComponent.OnCharacterBeginOverlap
// 0x0118 (0x0118 - 0x0000)
struct GzAutotestComponent_OnCharacterBeginOverlap final
{
public:
	class UPrimitiveComponent*                    OverlappedComponent;                               // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 OtherActor;                                        // 0x0008(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UPrimitiveComponent*                    OtherComp;                                         // 0x0010(0x0008)(Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         OtherBodyIndex;                                    // 0x0018(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bFromSweep;                                        // 0x001C(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2D1F[0x3];                                     // 0x001D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FHitResult                             SweepResult;                                       // 0x0020(0x00F8)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzAutotestComponent_OnCharacterBeginOverlap) == 0x000008, "Wrong alignment on GzAutotestComponent_OnCharacterBeginOverlap");
static_assert(sizeof(GzAutotestComponent_OnCharacterBeginOverlap) == 0x000118, "Wrong size on GzAutotestComponent_OnCharacterBeginOverlap");
static_assert(offsetof(GzAutotestComponent_OnCharacterBeginOverlap, OverlappedComponent) == 0x000000, "Member 'GzAutotestComponent_OnCharacterBeginOverlap::OverlappedComponent' has a wrong offset!");
static_assert(offsetof(GzAutotestComponent_OnCharacterBeginOverlap, OtherActor) == 0x000008, "Member 'GzAutotestComponent_OnCharacterBeginOverlap::OtherActor' has a wrong offset!");
static_assert(offsetof(GzAutotestComponent_OnCharacterBeginOverlap, OtherComp) == 0x000010, "Member 'GzAutotestComponent_OnCharacterBeginOverlap::OtherComp' has a wrong offset!");
static_assert(offsetof(GzAutotestComponent_OnCharacterBeginOverlap, OtherBodyIndex) == 0x000018, "Member 'GzAutotestComponent_OnCharacterBeginOverlap::OtherBodyIndex' has a wrong offset!");
static_assert(offsetof(GzAutotestComponent_OnCharacterBeginOverlap, bFromSweep) == 0x00001C, "Member 'GzAutotestComponent_OnCharacterBeginOverlap::bFromSweep' has a wrong offset!");
static_assert(offsetof(GzAutotestComponent_OnCharacterBeginOverlap, SweepResult) == 0x000020, "Member 'GzAutotestComponent_OnCharacterBeginOverlap::SweepResult' has a wrong offset!");

// Function G01.GzAutotestComponent.OnStateChanged
// 0x0001 (0x0001 - 0x0000)
struct GzAutotestComponent_OnStateChanged final
{
public:
	EGzAutotestComponentState                     CommandComponentState;                             // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzAutotestComponent_OnStateChanged) == 0x000001, "Wrong alignment on GzAutotestComponent_OnStateChanged");
static_assert(sizeof(GzAutotestComponent_OnStateChanged) == 0x000001, "Wrong size on GzAutotestComponent_OnStateChanged");
static_assert(offsetof(GzAutotestComponent_OnStateChanged, CommandComponentState) == 0x000000, "Member 'GzAutotestComponent_OnStateChanged::CommandComponentState' has a wrong offset!");

// Function G01.GzAutotestComponent.PrepareCommand
// 0x0001 (0x0001 - 0x0000)
struct GzAutotestComponent_PrepareCommand final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzAutotestComponent_PrepareCommand) == 0x000001, "Wrong alignment on GzAutotestComponent_PrepareCommand");
static_assert(sizeof(GzAutotestComponent_PrepareCommand) == 0x000001, "Wrong size on GzAutotestComponent_PrepareCommand");
static_assert(offsetof(GzAutotestComponent_PrepareCommand, ReturnValue) == 0x000000, "Member 'GzAutotestComponent_PrepareCommand::ReturnValue' has a wrong offset!");

// Function G01.GzAutotestComponent.StartCommand
// 0x0001 (0x0001 - 0x0000)
struct GzAutotestComponent_StartCommand final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzAutotestComponent_StartCommand) == 0x000001, "Wrong alignment on GzAutotestComponent_StartCommand");
static_assert(sizeof(GzAutotestComponent_StartCommand) == 0x000001, "Wrong size on GzAutotestComponent_StartCommand");
static_assert(offsetof(GzAutotestComponent_StartCommand, ReturnValue) == 0x000000, "Member 'GzAutotestComponent_StartCommand::ReturnValue' has a wrong offset!");

// Function G01.GzAutotestComponent.UpdateTimer
// 0x0004 (0x0004 - 0x0000)
struct GzAutotestComponent_UpdateTimer final
{
public:
	float                                         DeltaTime;                                         // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzAutotestComponent_UpdateTimer) == 0x000004, "Wrong alignment on GzAutotestComponent_UpdateTimer");
static_assert(sizeof(GzAutotestComponent_UpdateTimer) == 0x000004, "Wrong size on GzAutotestComponent_UpdateTimer");
static_assert(offsetof(GzAutotestComponent_UpdateTimer, DeltaTime) == 0x000000, "Member 'GzAutotestComponent_UpdateTimer::DeltaTime' has a wrong offset!");

// Function G01.GzAutotestComponent.GetCheatManager
// 0x0008 (0x0008 - 0x0000)
struct GzAutotestComponent_GetCheatManager final
{
public:
	class UGzCheatManager*                        ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzAutotestComponent_GetCheatManager) == 0x000008, "Wrong alignment on GzAutotestComponent_GetCheatManager");
static_assert(sizeof(GzAutotestComponent_GetCheatManager) == 0x000008, "Wrong size on GzAutotestComponent_GetCheatManager");
static_assert(offsetof(GzAutotestComponent_GetCheatManager, ReturnValue) == 0x000000, "Member 'GzAutotestComponent_GetCheatManager::ReturnValue' has a wrong offset!");

// Function G01.GzAutotestComponent.GetCommandState
// 0x0001 (0x0001 - 0x0000)
struct GzAutotestComponent_GetCommandState final
{
public:
	EGzAutotestComponentState                     ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzAutotestComponent_GetCommandState) == 0x000001, "Wrong alignment on GzAutotestComponent_GetCommandState");
static_assert(sizeof(GzAutotestComponent_GetCommandState) == 0x000001, "Wrong size on GzAutotestComponent_GetCommandState");
static_assert(offsetof(GzAutotestComponent_GetCommandState, ReturnValue) == 0x000000, "Member 'GzAutotestComponent_GetCommandState::ReturnValue' has a wrong offset!");

// Function G01.GzAutotestComponent.GetDetailedLog
// 0x0010 (0x0010 - 0x0000)
struct GzAutotestComponent_GetDetailedLog final
{
public:
	class FString                                 ReturnValue;                                       // 0x0000(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzAutotestComponent_GetDetailedLog) == 0x000008, "Wrong alignment on GzAutotestComponent_GetDetailedLog");
static_assert(sizeof(GzAutotestComponent_GetDetailedLog) == 0x000010, "Wrong size on GzAutotestComponent_GetDetailedLog");
static_assert(offsetof(GzAutotestComponent_GetDetailedLog, ReturnValue) == 0x000000, "Member 'GzAutotestComponent_GetDetailedLog::ReturnValue' has a wrong offset!");

// Function G01.GzAIAutotestCommandMoveTo.OnAIReachedPatrolPoint
// 0x0010 (0x0010 - 0x0000)
struct GzAIAutotestCommandMoveTo_OnAIReachedPatrolPoint final
{
public:
	class AActor*                                 OverlappedActor;                                   // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 OtherActor;                                        // 0x0008(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzAIAutotestCommandMoveTo_OnAIReachedPatrolPoint) == 0x000008, "Wrong alignment on GzAIAutotestCommandMoveTo_OnAIReachedPatrolPoint");
static_assert(sizeof(GzAIAutotestCommandMoveTo_OnAIReachedPatrolPoint) == 0x000010, "Wrong size on GzAIAutotestCommandMoveTo_OnAIReachedPatrolPoint");
static_assert(offsetof(GzAIAutotestCommandMoveTo_OnAIReachedPatrolPoint, OverlappedActor) == 0x000000, "Member 'GzAIAutotestCommandMoveTo_OnAIReachedPatrolPoint::OverlappedActor' has a wrong offset!");
static_assert(offsetof(GzAIAutotestCommandMoveTo_OnAIReachedPatrolPoint, OtherActor) == 0x000008, "Member 'GzAIAutotestCommandMoveTo_OnAIReachedPatrolPoint::OtherActor' has a wrong offset!");

// Function G01.GzHUDComponent.OnViewTargetChanged
// 0x0008 (0x0008 - 0x0000)
struct GzHUDComponent_OnViewTargetChanged final
{
public:
	class APawn*                                  ViewTarget;                                        // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzHUDComponent_OnViewTargetChanged) == 0x000008, "Wrong alignment on GzHUDComponent_OnViewTargetChanged");
static_assert(sizeof(GzHUDComponent_OnViewTargetChanged) == 0x000008, "Wrong size on GzHUDComponent_OnViewTargetChanged");
static_assert(offsetof(GzHUDComponent_OnViewTargetChanged, ViewTarget) == 0x000000, "Member 'GzHUDComponent_OnViewTargetChanged::ViewTarget' has a wrong offset!");

// Function G01.GzHUDComponent.ReceiveBindEvents
// 0x0008 (0x0008 - 0x0000)
struct GzHUDComponent_ReceiveBindEvents final
{
public:
	class APawn*                                  NewViewTarget;                                     // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzHUDComponent_ReceiveBindEvents) == 0x000008, "Wrong alignment on GzHUDComponent_ReceiveBindEvents");
static_assert(sizeof(GzHUDComponent_ReceiveBindEvents) == 0x000008, "Wrong size on GzHUDComponent_ReceiveBindEvents");
static_assert(offsetof(GzHUDComponent_ReceiveBindEvents, NewViewTarget) == 0x000000, "Member 'GzHUDComponent_ReceiveBindEvents::NewViewTarget' has a wrong offset!");

// Function G01.GzHUDComponent.ReceiveUnbindEvents
// 0x0008 (0x0008 - 0x0000)
struct GzHUDComponent_ReceiveUnbindEvents final
{
public:
	class APawn*                                  OldViewTarget;                                     // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzHUDComponent_ReceiveUnbindEvents) == 0x000008, "Wrong alignment on GzHUDComponent_ReceiveUnbindEvents");
static_assert(sizeof(GzHUDComponent_ReceiveUnbindEvents) == 0x000008, "Wrong size on GzHUDComponent_ReceiveUnbindEvents");
static_assert(offsetof(GzHUDComponent_ReceiveUnbindEvents, OldViewTarget) == 0x000000, "Member 'GzHUDComponent_ReceiveUnbindEvents::OldViewTarget' has a wrong offset!");

// Function G01.GzHUDComponent.SubscribeToAttributeChange
// 0x0048 (0x0048 - 0x0000)
struct GzHUDComponent_SubscribeToAttributeChange final
{
public:
	struct FGameplayAttribute                     Attribute;                                         // 0x0000(0x0038)(ConstParm, Parm, OutParm, ReferenceParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TDelegate<void(float NewValue, float OldValue)> OnAttributeChanged;                                // 0x0038(0x0010)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzHUDComponent_SubscribeToAttributeChange) == 0x000008, "Wrong alignment on GzHUDComponent_SubscribeToAttributeChange");
static_assert(sizeof(GzHUDComponent_SubscribeToAttributeChange) == 0x000048, "Wrong size on GzHUDComponent_SubscribeToAttributeChange");
static_assert(offsetof(GzHUDComponent_SubscribeToAttributeChange, Attribute) == 0x000000, "Member 'GzHUDComponent_SubscribeToAttributeChange::Attribute' has a wrong offset!");
static_assert(offsetof(GzHUDComponent_SubscribeToAttributeChange, OnAttributeChanged) == 0x000038, "Member 'GzHUDComponent_SubscribeToAttributeChange::OnAttributeChanged' has a wrong offset!");

// Function G01.GzHUDComponent.SubscribeToTagChange
// 0x0018 (0x0018 - 0x0000)
struct GzHUDComponent_SubscribeToTagChange final
{
public:
	struct FGameplayTag                           Tag;                                               // 0x0000(0x0008)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TDelegate<void(bool bWasAdded)>               OnTagChanged;                                      // 0x0008(0x0010)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzHUDComponent_SubscribeToTagChange) == 0x000004, "Wrong alignment on GzHUDComponent_SubscribeToTagChange");
static_assert(sizeof(GzHUDComponent_SubscribeToTagChange) == 0x000018, "Wrong size on GzHUDComponent_SubscribeToTagChange");
static_assert(offsetof(GzHUDComponent_SubscribeToTagChange, Tag) == 0x000000, "Member 'GzHUDComponent_SubscribeToTagChange::Tag' has a wrong offset!");
static_assert(offsetof(GzHUDComponent_SubscribeToTagChange, OnTagChanged) == 0x000008, "Member 'GzHUDComponent_SubscribeToTagChange::OnTagChanged' has a wrong offset!");

// Function G01.GzHUDComponent.GetViewTarget
// 0x0008 (0x0008 - 0x0000)
struct GzHUDComponent_GetViewTarget final
{
public:
	class APawn*                                  ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzHUDComponent_GetViewTarget) == 0x000008, "Wrong alignment on GzHUDComponent_GetViewTarget");
static_assert(sizeof(GzHUDComponent_GetViewTarget) == 0x000008, "Wrong size on GzHUDComponent_GetViewTarget");
static_assert(offsetof(GzHUDComponent_GetViewTarget, ReturnValue) == 0x000000, "Member 'GzHUDComponent_GetViewTarget::ReturnValue' has a wrong offset!");

// Function G01.GzBaseLogWidget.OnNewEntryEnqueued
// 0x0008 (0x0008 - 0x0000)
struct GzBaseLogWidget_OnNewEntryEnqueued final
{
public:
	class UGzBaseLogEntryWidget*                  Entry;                                             // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzBaseLogWidget_OnNewEntryEnqueued) == 0x000008, "Wrong alignment on GzBaseLogWidget_OnNewEntryEnqueued");
static_assert(sizeof(GzBaseLogWidget_OnNewEntryEnqueued) == 0x000008, "Wrong size on GzBaseLogWidget_OnNewEntryEnqueued");
static_assert(offsetof(GzBaseLogWidget_OnNewEntryEnqueued, Entry) == 0x000000, "Member 'GzBaseLogWidget_OnNewEntryEnqueued::Entry' has a wrong offset!");

// Function G01.GzBaseLogWidget.OnNewEntryShowed
// 0x0008 (0x0008 - 0x0000)
struct GzBaseLogWidget_OnNewEntryShowed final
{
public:
	class UGzBaseLogEntryWidget*                  Entry;                                             // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzBaseLogWidget_OnNewEntryShowed) == 0x000008, "Wrong alignment on GzBaseLogWidget_OnNewEntryShowed");
static_assert(sizeof(GzBaseLogWidget_OnNewEntryShowed) == 0x000008, "Wrong size on GzBaseLogWidget_OnNewEntryShowed");
static_assert(offsetof(GzBaseLogWidget_OnNewEntryShowed, Entry) == 0x000000, "Member 'GzBaseLogWidget_OnNewEntryShowed::Entry' has a wrong offset!");

// Function G01.GzXPLogWidget.UpdateLog
// 0x0018 (0x0018 - 0x0000)
struct GzXPLogWidget_UpdateLog final
{
public:
	int32                                         PlayerId;                                          // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2D29[0x4];                                     // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGzGameStat                            Stat;                                              // 0x0008(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzXPLogWidget_UpdateLog) == 0x000008, "Wrong alignment on GzXPLogWidget_UpdateLog");
static_assert(sizeof(GzXPLogWidget_UpdateLog) == 0x000018, "Wrong size on GzXPLogWidget_UpdateLog");
static_assert(offsetof(GzXPLogWidget_UpdateLog, PlayerId) == 0x000000, "Member 'GzXPLogWidget_UpdateLog::PlayerId' has a wrong offset!");
static_assert(offsetof(GzXPLogWidget_UpdateLog, Stat) == 0x000008, "Member 'GzXPLogWidget_UpdateLog::Stat' has a wrong offset!");

// Function G01.GzBaseCharacter.GetBPComponent
// 0x0018 (0x0018 - 0x0000)
struct GzBaseCharacter_GetBPComponent final
{
public:
	TSubclassOf<class USceneComponent>            ComponentClass;                                    // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   CompName;                                          // 0x0008(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USceneComponent*                        ReturnValue;                                       // 0x0010(0x0008)(ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzBaseCharacter_GetBPComponent) == 0x000008, "Wrong alignment on GzBaseCharacter_GetBPComponent");
static_assert(sizeof(GzBaseCharacter_GetBPComponent) == 0x000018, "Wrong size on GzBaseCharacter_GetBPComponent");
static_assert(offsetof(GzBaseCharacter_GetBPComponent, ComponentClass) == 0x000000, "Member 'GzBaseCharacter_GetBPComponent::ComponentClass' has a wrong offset!");
static_assert(offsetof(GzBaseCharacter_GetBPComponent, CompName) == 0x000008, "Member 'GzBaseCharacter_GetBPComponent::CompName' has a wrong offset!");
static_assert(offsetof(GzBaseCharacter_GetBPComponent, ReturnValue) == 0x000010, "Member 'GzBaseCharacter_GetBPComponent::ReturnValue' has a wrong offset!");

// Function G01.GzBaseCharacter.GetAliveObjectAttributeSet
// 0x0008 (0x0008 - 0x0000)
struct GzBaseCharacter_GetAliveObjectAttributeSet final
{
public:
	const class UGzAliveObjectAttributeSet*       ReturnValue;                                       // 0x0000(0x0008)(ConstParm, ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzBaseCharacter_GetAliveObjectAttributeSet) == 0x000008, "Wrong alignment on GzBaseCharacter_GetAliveObjectAttributeSet");
static_assert(sizeof(GzBaseCharacter_GetAliveObjectAttributeSet) == 0x000008, "Wrong size on GzBaseCharacter_GetAliveObjectAttributeSet");
static_assert(offsetof(GzBaseCharacter_GetAliveObjectAttributeSet, ReturnValue) == 0x000000, "Member 'GzBaseCharacter_GetAliveObjectAttributeSet::ReturnValue' has a wrong offset!");

// Function G01.GzBaseCharacter.GetAttributeSet
// 0x0008 (0x0008 - 0x0000)
struct GzBaseCharacter_GetAttributeSet final
{
public:
	const class UGzAttributeSet*                  ReturnValue;                                       // 0x0000(0x0008)(ConstParm, ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzBaseCharacter_GetAttributeSet) == 0x000008, "Wrong alignment on GzBaseCharacter_GetAttributeSet");
static_assert(sizeof(GzBaseCharacter_GetAttributeSet) == 0x000008, "Wrong size on GzBaseCharacter_GetAttributeSet");
static_assert(offsetof(GzBaseCharacter_GetAttributeSet, ReturnValue) == 0x000000, "Member 'GzBaseCharacter_GetAttributeSet::ReturnValue' has a wrong offset!");

// Function G01.GzBaseCharacter.GetCombatComponent
// 0x0008 (0x0008 - 0x0000)
struct GzBaseCharacter_GetCombatComponent final
{
public:
	class UGzCombatComponent*                     ReturnValue;                                       // 0x0000(0x0008)(ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzBaseCharacter_GetCombatComponent) == 0x000008, "Wrong alignment on GzBaseCharacter_GetCombatComponent");
static_assert(sizeof(GzBaseCharacter_GetCombatComponent) == 0x000008, "Wrong size on GzBaseCharacter_GetCombatComponent");
static_assert(offsetof(GzBaseCharacter_GetCombatComponent, ReturnValue) == 0x000000, "Member 'GzBaseCharacter_GetCombatComponent::ReturnValue' has a wrong offset!");

// Function G01.GzBaseCharacter.GetGzAbilitySystemComponent
// 0x0008 (0x0008 - 0x0000)
struct GzBaseCharacter_GetGzAbilitySystemComponent final
{
public:
	class UGzAbilitySystemComponent*              ReturnValue;                                       // 0x0000(0x0008)(ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzBaseCharacter_GetGzAbilitySystemComponent) == 0x000008, "Wrong alignment on GzBaseCharacter_GetGzAbilitySystemComponent");
static_assert(sizeof(GzBaseCharacter_GetGzAbilitySystemComponent) == 0x000008, "Wrong size on GzBaseCharacter_GetGzAbilitySystemComponent");
static_assert(offsetof(GzBaseCharacter_GetGzAbilitySystemComponent, ReturnValue) == 0x000000, "Member 'GzBaseCharacter_GetGzAbilitySystemComponent::ReturnValue' has a wrong offset!");

// Function G01.GzBaseCharacter.GetInventoryComponent
// 0x0008 (0x0008 - 0x0000)
struct GzBaseCharacter_GetInventoryComponent final
{
public:
	class UGzInvComponent*                        ReturnValue;                                       // 0x0000(0x0008)(ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzBaseCharacter_GetInventoryComponent) == 0x000008, "Wrong alignment on GzBaseCharacter_GetInventoryComponent");
static_assert(sizeof(GzBaseCharacter_GetInventoryComponent) == 0x000008, "Wrong size on GzBaseCharacter_GetInventoryComponent");
static_assert(offsetof(GzBaseCharacter_GetInventoryComponent, ReturnValue) == 0x000000, "Member 'GzBaseCharacter_GetInventoryComponent::ReturnValue' has a wrong offset!");

// Function G01.GzBaseCharacter.HasCombatComponent
// 0x0001 (0x0001 - 0x0000)
struct GzBaseCharacter_HasCombatComponent final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzBaseCharacter_HasCombatComponent) == 0x000001, "Wrong alignment on GzBaseCharacter_HasCombatComponent");
static_assert(sizeof(GzBaseCharacter_HasCombatComponent) == 0x000001, "Wrong size on GzBaseCharacter_HasCombatComponent");
static_assert(offsetof(GzBaseCharacter_HasCombatComponent, ReturnValue) == 0x000000, "Member 'GzBaseCharacter_HasCombatComponent::ReturnValue' has a wrong offset!");

// Function G01.GzGameModeObject.GetGameMode
// 0x0010 (0x0010 - 0x0000)
struct GzGameModeObject_GetGameMode final
{
public:
	TSubclassOf<class AGameModeBase>              GameModeClass;                                     // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AGameModeBase*                          ReturnValue;                                       // 0x0008(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzGameModeObject_GetGameMode) == 0x000008, "Wrong alignment on GzGameModeObject_GetGameMode");
static_assert(sizeof(GzGameModeObject_GetGameMode) == 0x000010, "Wrong size on GzGameModeObject_GetGameMode");
static_assert(offsetof(GzGameModeObject_GetGameMode, GameModeClass) == 0x000000, "Member 'GzGameModeObject_GetGameMode::GameModeClass' has a wrong offset!");
static_assert(offsetof(GzGameModeObject_GetGameMode, ReturnValue) == 0x000008, "Member 'GzGameModeObject_GetGameMode::ReturnValue' has a wrong offset!");

// Function G01.GzGameModeObject.GetGameModeSettings
// 0x0010 (0x0010 - 0x0000)
struct GzGameModeObject_GetGameModeSettings final
{
public:
	TSubclassOf<class UGzGameModeSettings>        SettingsClass;                                     // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UGzGameModeSettings*                    ReturnValue;                                       // 0x0008(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzGameModeObject_GetGameModeSettings) == 0x000008, "Wrong alignment on GzGameModeObject_GetGameModeSettings");
static_assert(sizeof(GzGameModeObject_GetGameModeSettings) == 0x000010, "Wrong size on GzGameModeObject_GetGameModeSettings");
static_assert(offsetof(GzGameModeObject_GetGameModeSettings, SettingsClass) == 0x000000, "Member 'GzGameModeObject_GetGameModeSettings::SettingsClass' has a wrong offset!");
static_assert(offsetof(GzGameModeObject_GetGameModeSettings, ReturnValue) == 0x000008, "Member 'GzGameModeObject_GetGameModeSettings::ReturnValue' has a wrong offset!");

// Function G01.GzGameStageBase.Transition
// 0x0008 (0x0008 - 0x0000)
struct GzGameStageBase_Transition final
{
public:
	class FName                                   Key;                                               // 0x0000(0x0008)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzGameStageBase_Transition) == 0x000004, "Wrong alignment on GzGameStageBase_Transition");
static_assert(sizeof(GzGameStageBase_Transition) == 0x000008, "Wrong size on GzGameStageBase_Transition");
static_assert(offsetof(GzGameStageBase_Transition, Key) == 0x000000, "Member 'GzGameStageBase_Transition::Key' has a wrong offset!");

// Function G01.GzGameStageBase.GetDisplayName
// 0x0010 (0x0010 - 0x0000)
struct GzGameStageBase_GetDisplayName final
{
public:
	class FString                                 ReturnValue;                                       // 0x0000(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzGameStageBase_GetDisplayName) == 0x000008, "Wrong alignment on GzGameStageBase_GetDisplayName");
static_assert(sizeof(GzGameStageBase_GetDisplayName) == 0x000010, "Wrong size on GzGameStageBase_GetDisplayName");
static_assert(offsetof(GzGameStageBase_GetDisplayName, ReturnValue) == 0x000000, "Member 'GzGameStageBase_GetDisplayName::ReturnValue' has a wrong offset!");

// Function G01.GzGameStageBase.GetStageTag
// 0x0008 (0x0008 - 0x0000)
struct GzGameStageBase_GetStageTag final
{
public:
	struct FGameplayTag                           ReturnValue;                                       // 0x0000(0x0008)(ConstParm, Parm, OutParm, ReturnParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzGameStageBase_GetStageTag) == 0x000004, "Wrong alignment on GzGameStageBase_GetStageTag");
static_assert(sizeof(GzGameStageBase_GetStageTag) == 0x000008, "Wrong size on GzGameStageBase_GetStageTag");
static_assert(offsetof(GzGameStageBase_GetStageTag, ReturnValue) == 0x000000, "Member 'GzGameStageBase_GetStageTag::ReturnValue' has a wrong offset!");

// Function G01.GzMarkerComponent.AddMarkerState
// 0x0008 (0x0008 - 0x0000)
struct GzMarkerComponent_AddMarkerState final
{
public:
	struct FGameplayTag                           State;                                             // 0x0000(0x0008)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzMarkerComponent_AddMarkerState) == 0x000004, "Wrong alignment on GzMarkerComponent_AddMarkerState");
static_assert(sizeof(GzMarkerComponent_AddMarkerState) == 0x000008, "Wrong size on GzMarkerComponent_AddMarkerState");
static_assert(offsetof(GzMarkerComponent_AddMarkerState, State) == 0x000000, "Member 'GzMarkerComponent_AddMarkerState::State' has a wrong offset!");

// Function G01.GzMarkerComponent.HandleLocalPlayerControllerChanged
// 0x0008 (0x0008 - 0x0000)
struct GzMarkerComponent_HandleLocalPlayerControllerChanged final
{
public:
	class APlayerController*                      InPlayerController;                                // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzMarkerComponent_HandleLocalPlayerControllerChanged) == 0x000008, "Wrong alignment on GzMarkerComponent_HandleLocalPlayerControllerChanged");
static_assert(sizeof(GzMarkerComponent_HandleLocalPlayerControllerChanged) == 0x000008, "Wrong size on GzMarkerComponent_HandleLocalPlayerControllerChanged");
static_assert(offsetof(GzMarkerComponent_HandleLocalPlayerControllerChanged, InPlayerController) == 0x000000, "Member 'GzMarkerComponent_HandleLocalPlayerControllerChanged::InPlayerController' has a wrong offset!");

// Function G01.GzMarkerComponent.RemoveMarkerState
// 0x0008 (0x0008 - 0x0000)
struct GzMarkerComponent_RemoveMarkerState final
{
public:
	struct FGameplayTag                           State;                                             // 0x0000(0x0008)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzMarkerComponent_RemoveMarkerState) == 0x000004, "Wrong alignment on GzMarkerComponent_RemoveMarkerState");
static_assert(sizeof(GzMarkerComponent_RemoveMarkerState) == 0x000008, "Wrong size on GzMarkerComponent_RemoveMarkerState");
static_assert(offsetof(GzMarkerComponent_RemoveMarkerState, State) == 0x000000, "Member 'GzMarkerComponent_RemoveMarkerState::State' has a wrong offset!");

// Function G01.GzMarkerComponent.SetMarkerType
// 0x0008 (0x0008 - 0x0000)
struct GzMarkerComponent_SetMarkerType final
{
public:
	struct FGameplayTag                           InMarkerType;                                      // 0x0000(0x0008)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzMarkerComponent_SetMarkerType) == 0x000004, "Wrong alignment on GzMarkerComponent_SetMarkerType");
static_assert(sizeof(GzMarkerComponent_SetMarkerType) == 0x000008, "Wrong size on GzMarkerComponent_SetMarkerType");
static_assert(offsetof(GzMarkerComponent_SetMarkerType, InMarkerType) == 0x000000, "Member 'GzMarkerComponent_SetMarkerType::InMarkerType' has a wrong offset!");

// Function G01.GzMarkerComponent.SetPriority
// 0x0004 (0x0004 - 0x0000)
struct GzMarkerComponent_SetPriority final
{
public:
	int32                                         InPriority;                                        // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzMarkerComponent_SetPriority) == 0x000004, "Wrong alignment on GzMarkerComponent_SetPriority");
static_assert(sizeof(GzMarkerComponent_SetPriority) == 0x000004, "Wrong size on GzMarkerComponent_SetPriority");
static_assert(offsetof(GzMarkerComponent_SetPriority, InPriority) == 0x000000, "Member 'GzMarkerComponent_SetPriority::InPriority' has a wrong offset!");

// Function G01.GzMarkerComponent.SetWorldInstanceId
// 0x0004 (0x0004 - 0x0000)
struct GzMarkerComponent_SetWorldInstanceId final
{
public:
	int32                                         InInstanceId;                                      // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzMarkerComponent_SetWorldInstanceId) == 0x000004, "Wrong alignment on GzMarkerComponent_SetWorldInstanceId");
static_assert(sizeof(GzMarkerComponent_SetWorldInstanceId) == 0x000004, "Wrong size on GzMarkerComponent_SetWorldInstanceId");
static_assert(offsetof(GzMarkerComponent_SetWorldInstanceId, InInstanceId) == 0x000000, "Member 'GzMarkerComponent_SetWorldInstanceId::InInstanceId' has a wrong offset!");

// Function G01.GzMarkerComponent.GetMarkerLocation
// 0x0010 (0x0010 - 0x0000)
struct GzMarkerComponent_GetMarkerLocation final
{
public:
	struct FVector2D                              ReturnValue;                                       // 0x0000(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzMarkerComponent_GetMarkerLocation) == 0x000008, "Wrong alignment on GzMarkerComponent_GetMarkerLocation");
static_assert(sizeof(GzMarkerComponent_GetMarkerLocation) == 0x000010, "Wrong size on GzMarkerComponent_GetMarkerLocation");
static_assert(offsetof(GzMarkerComponent_GetMarkerLocation, ReturnValue) == 0x000000, "Member 'GzMarkerComponent_GetMarkerLocation::ReturnValue' has a wrong offset!");

// Function G01.GzMarkerComponent.GetMarkerLocation3D
// 0x0018 (0x0018 - 0x0000)
struct GzMarkerComponent_GetMarkerLocation3D final
{
public:
	struct FVector                                ReturnValue;                                       // 0x0000(0x0018)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzMarkerComponent_GetMarkerLocation3D) == 0x000008, "Wrong alignment on GzMarkerComponent_GetMarkerLocation3D");
static_assert(sizeof(GzMarkerComponent_GetMarkerLocation3D) == 0x000018, "Wrong size on GzMarkerComponent_GetMarkerLocation3D");
static_assert(offsetof(GzMarkerComponent_GetMarkerLocation3D, ReturnValue) == 0x000000, "Member 'GzMarkerComponent_GetMarkerLocation3D::ReturnValue' has a wrong offset!");

// Function G01.GzMarkerComponent.GetMarkerRotation
// 0x0004 (0x0004 - 0x0000)
struct GzMarkerComponent_GetMarkerRotation final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzMarkerComponent_GetMarkerRotation) == 0x000004, "Wrong alignment on GzMarkerComponent_GetMarkerRotation");
static_assert(sizeof(GzMarkerComponent_GetMarkerRotation) == 0x000004, "Wrong size on GzMarkerComponent_GetMarkerRotation");
static_assert(offsetof(GzMarkerComponent_GetMarkerRotation, ReturnValue) == 0x000000, "Member 'GzMarkerComponent_GetMarkerRotation::ReturnValue' has a wrong offset!");

// Function G01.GzMarkerComponent.GetMarkerStates
// 0x0020 (0x0020 - 0x0000)
struct GzMarkerComponent_GetMarkerStates final
{
public:
	struct FGameplayTagContainer                  ReturnValue;                                       // 0x0000(0x0020)(ConstParm, Parm, OutParm, ReturnParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzMarkerComponent_GetMarkerStates) == 0x000008, "Wrong alignment on GzMarkerComponent_GetMarkerStates");
static_assert(sizeof(GzMarkerComponent_GetMarkerStates) == 0x000020, "Wrong size on GzMarkerComponent_GetMarkerStates");
static_assert(offsetof(GzMarkerComponent_GetMarkerStates, ReturnValue) == 0x000000, "Member 'GzMarkerComponent_GetMarkerStates::ReturnValue' has a wrong offset!");

// Function G01.GzMarkerComponent.GetMarkerType
// 0x0008 (0x0008 - 0x0000)
struct GzMarkerComponent_GetMarkerType final
{
public:
	struct FGameplayTag                           ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzMarkerComponent_GetMarkerType) == 0x000004, "Wrong alignment on GzMarkerComponent_GetMarkerType");
static_assert(sizeof(GzMarkerComponent_GetMarkerType) == 0x000008, "Wrong size on GzMarkerComponent_GetMarkerType");
static_assert(offsetof(GzMarkerComponent_GetMarkerType, ReturnValue) == 0x000000, "Member 'GzMarkerComponent_GetMarkerType::ReturnValue' has a wrong offset!");

// Function G01.GzMarkerComponent.GetPingData
// 0x0060 (0x0060 - 0x0000)
struct GzMarkerComponent_GetPingData final
{
public:
	struct FGzPingData                            ReturnValue;                                       // 0x0000(0x0060)(Parm, OutParm, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzMarkerComponent_GetPingData) == 0x000008, "Wrong alignment on GzMarkerComponent_GetPingData");
static_assert(sizeof(GzMarkerComponent_GetPingData) == 0x000060, "Wrong size on GzMarkerComponent_GetPingData");
static_assert(offsetof(GzMarkerComponent_GetPingData, ReturnValue) == 0x000000, "Member 'GzMarkerComponent_GetPingData::ReturnValue' has a wrong offset!");

// Function G01.GzMarkerComponent.GetPriority
// 0x0004 (0x0004 - 0x0000)
struct GzMarkerComponent_GetPriority final
{
public:
	int32                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzMarkerComponent_GetPriority) == 0x000004, "Wrong alignment on GzMarkerComponent_GetPriority");
static_assert(sizeof(GzMarkerComponent_GetPriority) == 0x000004, "Wrong size on GzMarkerComponent_GetPriority");
static_assert(offsetof(GzMarkerComponent_GetPriority, ReturnValue) == 0x000000, "Member 'GzMarkerComponent_GetPriority::ReturnValue' has a wrong offset!");

// Function G01.GzMarkerComponent.GetServerData
// 0x0050 (0x0050 - 0x0000)
struct GzMarkerComponent_GetServerData final
{
public:
	struct FGzMarkerServerData                    ReturnValue;                                       // 0x0000(0x0050)(ConstParm, Parm, OutParm, ReturnParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzMarkerComponent_GetServerData) == 0x000008, "Wrong alignment on GzMarkerComponent_GetServerData");
static_assert(sizeof(GzMarkerComponent_GetServerData) == 0x000050, "Wrong size on GzMarkerComponent_GetServerData");
static_assert(offsetof(GzMarkerComponent_GetServerData, ReturnValue) == 0x000000, "Member 'GzMarkerComponent_GetServerData::ReturnValue' has a wrong offset!");

// Function G01.GzMarkerComponent.GetShape
// 0x0008 (0x0008 - 0x0000)
struct GzMarkerComponent_GetShape final
{
public:
	class UGzMarkerShape*                         ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzMarkerComponent_GetShape) == 0x000008, "Wrong alignment on GzMarkerComponent_GetShape");
static_assert(sizeof(GzMarkerComponent_GetShape) == 0x000008, "Wrong size on GzMarkerComponent_GetShape");
static_assert(offsetof(GzMarkerComponent_GetShape, ReturnValue) == 0x000000, "Member 'GzMarkerComponent_GetShape::ReturnValue' has a wrong offset!");

// Function G01.GzMarkerComponent.IsCompassMarkerStickingToEdges
// 0x0001 (0x0001 - 0x0000)
struct GzMarkerComponent_IsCompassMarkerStickingToEdges final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzMarkerComponent_IsCompassMarkerStickingToEdges) == 0x000001, "Wrong alignment on GzMarkerComponent_IsCompassMarkerStickingToEdges");
static_assert(sizeof(GzMarkerComponent_IsCompassMarkerStickingToEdges) == 0x000001, "Wrong size on GzMarkerComponent_IsCompassMarkerStickingToEdges");
static_assert(offsetof(GzMarkerComponent_IsCompassMarkerStickingToEdges, ReturnValue) == 0x000000, "Member 'GzMarkerComponent_IsCompassMarkerStickingToEdges::ReturnValue' has a wrong offset!");

// Function G01.GzMarkerComponent.IsHighlighted
// 0x0001 (0x0001 - 0x0000)
struct GzMarkerComponent_IsHighlighted final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzMarkerComponent_IsHighlighted) == 0x000001, "Wrong alignment on GzMarkerComponent_IsHighlighted");
static_assert(sizeof(GzMarkerComponent_IsHighlighted) == 0x000001, "Wrong size on GzMarkerComponent_IsHighlighted");
static_assert(offsetof(GzMarkerComponent_IsHighlighted, ReturnValue) == 0x000000, "Member 'GzMarkerComponent_IsHighlighted::ReturnValue' has a wrong offset!");

// Function G01.GzMarkerComponent.IsNavigatable
// 0x0001 (0x0001 - 0x0000)
struct GzMarkerComponent_IsNavigatable final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzMarkerComponent_IsNavigatable) == 0x000001, "Wrong alignment on GzMarkerComponent_IsNavigatable");
static_assert(sizeof(GzMarkerComponent_IsNavigatable) == 0x000001, "Wrong size on GzMarkerComponent_IsNavigatable");
static_assert(offsetof(GzMarkerComponent_IsNavigatable, ReturnValue) == 0x000000, "Member 'GzMarkerComponent_IsNavigatable::ReturnValue' has a wrong offset!");

// Function G01.GzMarkerComponent.IsPingable
// 0x0002 (0x0002 - 0x0000)
struct GzMarkerComponent_IsPingable final
{
public:
	EGzPingChannels                               InChannel;                                         // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0001(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzMarkerComponent_IsPingable) == 0x000001, "Wrong alignment on GzMarkerComponent_IsPingable");
static_assert(sizeof(GzMarkerComponent_IsPingable) == 0x000002, "Wrong size on GzMarkerComponent_IsPingable");
static_assert(offsetof(GzMarkerComponent_IsPingable, InChannel) == 0x000000, "Member 'GzMarkerComponent_IsPingable::InChannel' has a wrong offset!");
static_assert(offsetof(GzMarkerComponent_IsPingable, ReturnValue) == 0x000001, "Member 'GzMarkerComponent_IsPingable::ReturnValue' has a wrong offset!");

// Function G01.GzMarkerComponent.IsSupportingRotation
// 0x0001 (0x0001 - 0x0000)
struct GzMarkerComponent_IsSupportingRotation final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzMarkerComponent_IsSupportingRotation) == 0x000001, "Wrong alignment on GzMarkerComponent_IsSupportingRotation");
static_assert(sizeof(GzMarkerComponent_IsSupportingRotation) == 0x000001, "Wrong size on GzMarkerComponent_IsSupportingRotation");
static_assert(offsetof(GzMarkerComponent_IsSupportingRotation, ReturnValue) == 0x000000, "Member 'GzMarkerComponent_IsSupportingRotation::ReturnValue' has a wrong offset!");

// Function G01.GzMarkerComponent.RequiresDelayedDestroy
// 0x0001 (0x0001 - 0x0000)
struct GzMarkerComponent_RequiresDelayedDestroy final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzMarkerComponent_RequiresDelayedDestroy) == 0x000001, "Wrong alignment on GzMarkerComponent_RequiresDelayedDestroy");
static_assert(sizeof(GzMarkerComponent_RequiresDelayedDestroy) == 0x000001, "Wrong size on GzMarkerComponent_RequiresDelayedDestroy");
static_assert(offsetof(GzMarkerComponent_RequiresDelayedDestroy, ReturnValue) == 0x000000, "Member 'GzMarkerComponent_RequiresDelayedDestroy::ReturnValue' has a wrong offset!");

// Function G01.GzMissionMarkerComponent.SetMission
// 0x0008 (0x0008 - 0x0000)
struct GzMissionMarkerComponent_SetMission final
{
public:
	class AGzAdvancedMission*                     InMission;                                         // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzMissionMarkerComponent_SetMission) == 0x000008, "Wrong alignment on GzMissionMarkerComponent_SetMission");
static_assert(sizeof(GzMissionMarkerComponent_SetMission) == 0x000008, "Wrong size on GzMissionMarkerComponent_SetMission");
static_assert(offsetof(GzMissionMarkerComponent_SetMission, InMission) == 0x000000, "Member 'GzMissionMarkerComponent_SetMission::InMission' has a wrong offset!");

// Function G01.GzMissionMarkerComponent.GetMission
// 0x0008 (0x0008 - 0x0000)
struct GzMissionMarkerComponent_GetMission final
{
public:
	const class AGzAdvancedMission*               ReturnValue;                                       // 0x0000(0x0008)(ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzMissionMarkerComponent_GetMission) == 0x000008, "Wrong alignment on GzMissionMarkerComponent_GetMission");
static_assert(sizeof(GzMissionMarkerComponent_GetMission) == 0x000008, "Wrong size on GzMissionMarkerComponent_GetMission");
static_assert(offsetof(GzMissionMarkerComponent_GetMission, ReturnValue) == 0x000000, "Member 'GzMissionMarkerComponent_GetMission::ReturnValue' has a wrong offset!");

// Function G01.GzConsoleSessionCheatExtension.UpdateConsoleSessionJoinDisable
// 0x0001 (0x0001 - 0x0000)
struct GzConsoleSessionCheatExtension_UpdateConsoleSessionJoinDisable final
{
public:
	bool                                          bJoinable;                                         // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzConsoleSessionCheatExtension_UpdateConsoleSessionJoinDisable) == 0x000001, "Wrong alignment on GzConsoleSessionCheatExtension_UpdateConsoleSessionJoinDisable");
static_assert(sizeof(GzConsoleSessionCheatExtension_UpdateConsoleSessionJoinDisable) == 0x000001, "Wrong size on GzConsoleSessionCheatExtension_UpdateConsoleSessionJoinDisable");
static_assert(offsetof(GzConsoleSessionCheatExtension_UpdateConsoleSessionJoinDisable, bJoinable) == 0x000000, "Member 'GzConsoleSessionCheatExtension_UpdateConsoleSessionJoinDisable::bJoinable' has a wrong offset!");

// Function G01.LocomotionCharacter.K2_OnEndGrapplingPull
// 0x0001 (0x0001 - 0x0000)
struct LocomotionCharacter_K2_OnEndGrapplingPull final
{
public:
	bool                                          bClientSimulation;                                 // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LocomotionCharacter_K2_OnEndGrapplingPull) == 0x000001, "Wrong alignment on LocomotionCharacter_K2_OnEndGrapplingPull");
static_assert(sizeof(LocomotionCharacter_K2_OnEndGrapplingPull) == 0x000001, "Wrong size on LocomotionCharacter_K2_OnEndGrapplingPull");
static_assert(offsetof(LocomotionCharacter_K2_OnEndGrapplingPull, bClientSimulation) == 0x000000, "Member 'LocomotionCharacter_K2_OnEndGrapplingPull::bClientSimulation' has a wrong offset!");

// Function G01.LocomotionCharacter.K2_OnMovementActionChanged
// 0x0002 (0x0002 - 0x0000)
struct LocomotionCharacter_K2_OnMovementActionChanged final
{
public:
	ELocomotionMovementAction                     NewAction;                                         // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ELocomotionMovementAction                     PreviousAction;                                    // 0x0001(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LocomotionCharacter_K2_OnMovementActionChanged) == 0x000001, "Wrong alignment on LocomotionCharacter_K2_OnMovementActionChanged");
static_assert(sizeof(LocomotionCharacter_K2_OnMovementActionChanged) == 0x000002, "Wrong size on LocomotionCharacter_K2_OnMovementActionChanged");
static_assert(offsetof(LocomotionCharacter_K2_OnMovementActionChanged, NewAction) == 0x000000, "Member 'LocomotionCharacter_K2_OnMovementActionChanged::NewAction' has a wrong offset!");
static_assert(offsetof(LocomotionCharacter_K2_OnMovementActionChanged, PreviousAction) == 0x000001, "Member 'LocomotionCharacter_K2_OnMovementActionChanged::PreviousAction' has a wrong offset!");

// Function G01.LocomotionCharacter.K2_OnStartGrapplingPull
// 0x0001 (0x0001 - 0x0000)
struct LocomotionCharacter_K2_OnStartGrapplingPull final
{
public:
	bool                                          bClientSimulation;                                 // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LocomotionCharacter_K2_OnStartGrapplingPull) == 0x000001, "Wrong alignment on LocomotionCharacter_K2_OnStartGrapplingPull");
static_assert(sizeof(LocomotionCharacter_K2_OnStartGrapplingPull) == 0x000001, "Wrong size on LocomotionCharacter_K2_OnStartGrapplingPull");
static_assert(offsetof(LocomotionCharacter_K2_OnStartGrapplingPull, bClientSimulation) == 0x000000, "Member 'LocomotionCharacter_K2_OnStartGrapplingPull::bClientSimulation' has a wrong offset!");

// DelegateFunction G01.LocomotionCharacter.OnMovementActionChanged__DelegateSignature
// 0x0001 (0x0001 - 0x0000)
struct LocomotionCharacter_OnMovementActionChanged__DelegateSignature final
{
public:
	ELocomotionMovementAction                     PreviousAction;                                    // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LocomotionCharacter_OnMovementActionChanged__DelegateSignature) == 0x000001, "Wrong alignment on LocomotionCharacter_OnMovementActionChanged__DelegateSignature");
static_assert(sizeof(LocomotionCharacter_OnMovementActionChanged__DelegateSignature) == 0x000001, "Wrong size on LocomotionCharacter_OnMovementActionChanged__DelegateSignature");
static_assert(offsetof(LocomotionCharacter_OnMovementActionChanged__DelegateSignature, PreviousAction) == 0x000000, "Member 'LocomotionCharacter_OnMovementActionChanged__DelegateSignature::PreviousAction' has a wrong offset!");

// Function G01.LocomotionCharacter.OnRep_LocomotionFlags
// 0x0004 (0x0004 - 0x0000)
struct LocomotionCharacter_OnRep_LocomotionFlags final
{
public:
	uint32                                        OldFlags;                                          // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LocomotionCharacter_OnRep_LocomotionFlags) == 0x000004, "Wrong alignment on LocomotionCharacter_OnRep_LocomotionFlags");
static_assert(sizeof(LocomotionCharacter_OnRep_LocomotionFlags) == 0x000004, "Wrong size on LocomotionCharacter_OnRep_LocomotionFlags");
static_assert(offsetof(LocomotionCharacter_OnRep_LocomotionFlags, OldFlags) == 0x000000, "Member 'LocomotionCharacter_OnRep_LocomotionFlags::OldFlags' has a wrong offset!");

// Function G01.LocomotionCharacter.SetSprintEnabled
// 0x0001 (0x0001 - 0x0000)
struct LocomotionCharacter_SetSprintEnabled final
{
public:
	bool                                          bEnabled;                                          // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LocomotionCharacter_SetSprintEnabled) == 0x000001, "Wrong alignment on LocomotionCharacter_SetSprintEnabled");
static_assert(sizeof(LocomotionCharacter_SetSprintEnabled) == 0x000001, "Wrong size on LocomotionCharacter_SetSprintEnabled");
static_assert(offsetof(LocomotionCharacter_SetSprintEnabled, bEnabled) == 0x000000, "Member 'LocomotionCharacter_SetSprintEnabled::bEnabled' has a wrong offset!");

// Function G01.LocomotionCharacter.SetWalkEnabled
// 0x0001 (0x0001 - 0x0000)
struct LocomotionCharacter_SetWalkEnabled final
{
public:
	bool                                          bIsEnabled;                                        // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LocomotionCharacter_SetWalkEnabled) == 0x000001, "Wrong alignment on LocomotionCharacter_SetWalkEnabled");
static_assert(sizeof(LocomotionCharacter_SetWalkEnabled) == 0x000001, "Wrong size on LocomotionCharacter_SetWalkEnabled");
static_assert(offsetof(LocomotionCharacter_SetWalkEnabled, bIsEnabled) == 0x000000, "Member 'LocomotionCharacter_SetWalkEnabled::bIsEnabled' has a wrong offset!");

// Function G01.LocomotionCharacter.CanUncrouch
// 0x0001 (0x0001 - 0x0000)
struct LocomotionCharacter_CanUncrouch final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LocomotionCharacter_CanUncrouch) == 0x000001, "Wrong alignment on LocomotionCharacter_CanUncrouch");
static_assert(sizeof(LocomotionCharacter_CanUncrouch) == 0x000001, "Wrong size on LocomotionCharacter_CanUncrouch");
static_assert(offsetof(LocomotionCharacter_CanUncrouch, ReturnValue) == 0x000000, "Member 'LocomotionCharacter_CanUncrouch::ReturnValue' has a wrong offset!");

// Function G01.LocomotionCharacter.CanWingsuit
// 0x0001 (0x0001 - 0x0000)
struct LocomotionCharacter_CanWingsuit final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LocomotionCharacter_CanWingsuit) == 0x000001, "Wrong alignment on LocomotionCharacter_CanWingsuit");
static_assert(sizeof(LocomotionCharacter_CanWingsuit) == 0x000001, "Wrong size on LocomotionCharacter_CanWingsuit");
static_assert(offsetof(LocomotionCharacter_CanWingsuit, ReturnValue) == 0x000000, "Member 'LocomotionCharacter_CanWingsuit::ReturnValue' has a wrong offset!");

// Function G01.LocomotionCharacter.GetTraceDebugType
// 0x0002 (0x0002 - 0x0000)
struct LocomotionCharacter_GetTraceDebugType final
{
public:
	EDrawDebugTrace                               ShowTraceType;                                     // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EDrawDebugTrace                               ReturnValue;                                       // 0x0001(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LocomotionCharacter_GetTraceDebugType) == 0x000001, "Wrong alignment on LocomotionCharacter_GetTraceDebugType");
static_assert(sizeof(LocomotionCharacter_GetTraceDebugType) == 0x000002, "Wrong size on LocomotionCharacter_GetTraceDebugType");
static_assert(offsetof(LocomotionCharacter_GetTraceDebugType, ShowTraceType) == 0x000000, "Member 'LocomotionCharacter_GetTraceDebugType::ShowTraceType' has a wrong offset!");
static_assert(offsetof(LocomotionCharacter_GetTraceDebugType, ReturnValue) == 0x000001, "Member 'LocomotionCharacter_GetTraceDebugType::ReturnValue' has a wrong offset!");

// Function G01.LocomotionCharacter.IsJetpackBoosterActive
// 0x0001 (0x0001 - 0x0000)
struct LocomotionCharacter_IsJetpackBoosterActive final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LocomotionCharacter_IsJetpackBoosterActive) == 0x000001, "Wrong alignment on LocomotionCharacter_IsJetpackBoosterActive");
static_assert(sizeof(LocomotionCharacter_IsJetpackBoosterActive) == 0x000001, "Wrong size on LocomotionCharacter_IsJetpackBoosterActive");
static_assert(offsetof(LocomotionCharacter_IsJetpackBoosterActive, ReturnValue) == 0x000000, "Member 'LocomotionCharacter_IsJetpackBoosterActive::ReturnValue' has a wrong offset!");

// Function G01.LocomotionCharacter.IsJetpackDamaged
// 0x0001 (0x0001 - 0x0000)
struct LocomotionCharacter_IsJetpackDamaged final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LocomotionCharacter_IsJetpackDamaged) == 0x000001, "Wrong alignment on LocomotionCharacter_IsJetpackDamaged");
static_assert(sizeof(LocomotionCharacter_IsJetpackDamaged) == 0x000001, "Wrong size on LocomotionCharacter_IsJetpackDamaged");
static_assert(offsetof(LocomotionCharacter_IsJetpackDamaged, ReturnValue) == 0x000000, "Member 'LocomotionCharacter_IsJetpackDamaged::ReturnValue' has a wrong offset!");

// Function G01.LocomotionCharacter.IsJetpackDelayed
// 0x0001 (0x0001 - 0x0000)
struct LocomotionCharacter_IsJetpackDelayed final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LocomotionCharacter_IsJetpackDelayed) == 0x000001, "Wrong alignment on LocomotionCharacter_IsJetpackDelayed");
static_assert(sizeof(LocomotionCharacter_IsJetpackDelayed) == 0x000001, "Wrong size on LocomotionCharacter_IsJetpackDelayed");
static_assert(offsetof(LocomotionCharacter_IsJetpackDelayed, ReturnValue) == 0x000000, "Member 'LocomotionCharacter_IsJetpackDelayed::ReturnValue' has a wrong offset!");

// Function G01.LocomotionCharacter.IsWingsuitActive
// 0x0001 (0x0001 - 0x0000)
struct LocomotionCharacter_IsWingsuitActive final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LocomotionCharacter_IsWingsuitActive) == 0x000001, "Wrong alignment on LocomotionCharacter_IsWingsuitActive");
static_assert(sizeof(LocomotionCharacter_IsWingsuitActive) == 0x000001, "Wrong size on LocomotionCharacter_IsWingsuitActive");
static_assert(offsetof(LocomotionCharacter_IsWingsuitActive, ReturnValue) == 0x000000, "Member 'LocomotionCharacter_IsWingsuitActive::ReturnValue' has a wrong offset!");

// Function G01.GzCharacter.AddAnimLayerToPool
// 0x0028 (0x0028 - 0x0000)
struct GzCharacter_AddAnimLayerToPool final
{
public:
	TSoftClassPtr<class UClass>                   NewLayer;                                          // 0x0000(0x0028)(ConstParm, Parm, OutParm, ReferenceParm, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzCharacter_AddAnimLayerToPool) == 0x000008, "Wrong alignment on GzCharacter_AddAnimLayerToPool");
static_assert(sizeof(GzCharacter_AddAnimLayerToPool) == 0x000028, "Wrong size on GzCharacter_AddAnimLayerToPool");
static_assert(offsetof(GzCharacter_AddAnimLayerToPool, NewLayer) == 0x000000, "Member 'GzCharacter_AddAnimLayerToPool::NewLayer' has a wrong offset!");

// Function G01.GzCharacter.ApplyFallDamage
// 0x0010 (0x0010 - 0x0000)
struct GzCharacter_ApplyFallDamage final
{
public:
	TSubclassOf<class UGzGE_FallDamage>           EffectClass;                                       // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FallHeight;                                        // 0x0008(0x0004)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2D4E[0x4];                                     // 0x000C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GzCharacter_ApplyFallDamage) == 0x000008, "Wrong alignment on GzCharacter_ApplyFallDamage");
static_assert(sizeof(GzCharacter_ApplyFallDamage) == 0x000010, "Wrong size on GzCharacter_ApplyFallDamage");
static_assert(offsetof(GzCharacter_ApplyFallDamage, EffectClass) == 0x000000, "Member 'GzCharacter_ApplyFallDamage::EffectClass' has a wrong offset!");
static_assert(offsetof(GzCharacter_ApplyFallDamage, FallHeight) == 0x000008, "Member 'GzCharacter_ApplyFallDamage::FallHeight' has a wrong offset!");

// Function G01.GzCharacter.Client_PlayFatalHitEffects
// 0x0108 (0x0108 - 0x0000)
struct GzCharacter_Client_PlayFatalHitEffects final
{
public:
	class AActor*                                 Attacker;                                          // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EGzWeaponResourceType                         Resource;                                          // 0x0008(0x0001)(ConstParm, Parm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2D4F[0x7];                                     // 0x0009(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FHitResult                             Hit;                                               // 0x0010(0x00F8)(ConstParm, Parm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzCharacter_Client_PlayFatalHitEffects) == 0x000008, "Wrong alignment on GzCharacter_Client_PlayFatalHitEffects");
static_assert(sizeof(GzCharacter_Client_PlayFatalHitEffects) == 0x000108, "Wrong size on GzCharacter_Client_PlayFatalHitEffects");
static_assert(offsetof(GzCharacter_Client_PlayFatalHitEffects, Attacker) == 0x000000, "Member 'GzCharacter_Client_PlayFatalHitEffects::Attacker' has a wrong offset!");
static_assert(offsetof(GzCharacter_Client_PlayFatalHitEffects, Resource) == 0x000008, "Member 'GzCharacter_Client_PlayFatalHitEffects::Resource' has a wrong offset!");
static_assert(offsetof(GzCharacter_Client_PlayFatalHitEffects, Hit) == 0x000010, "Member 'GzCharacter_Client_PlayFatalHitEffects::Hit' has a wrong offset!");

// Function G01.GzCharacter.DropExcessItems
// 0x0010 (0x0010 - 0x0000)
struct GzCharacter_DropExcessItems final
{
public:
	TArray<struct FGzInvItem>                     ExcessItems;                                       // 0x0000(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzCharacter_DropExcessItems) == 0x000008, "Wrong alignment on GzCharacter_DropExcessItems");
static_assert(sizeof(GzCharacter_DropExcessItems) == 0x000010, "Wrong size on GzCharacter_DropExcessItems");
static_assert(offsetof(GzCharacter_DropExcessItems, ExcessItems) == 0x000000, "Member 'GzCharacter_DropExcessItems::ExcessItems' has a wrong offset!");

// DelegateFunction G01.GzCharacter.GzCharacterKilled__DelegateSignature
// 0x0004 (0x0004 - 0x0000)
struct GzCharacter_GzCharacterKilled__DelegateSignature final
{
public:
	int32                                         KillerId;                                          // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzCharacter_GzCharacterKilled__DelegateSignature) == 0x000004, "Wrong alignment on GzCharacter_GzCharacterKilled__DelegateSignature");
static_assert(sizeof(GzCharacter_GzCharacterKilled__DelegateSignature) == 0x000004, "Wrong size on GzCharacter_GzCharacterKilled__DelegateSignature");
static_assert(offsetof(GzCharacter_GzCharacterKilled__DelegateSignature, KillerId) == 0x000000, "Member 'GzCharacter_GzCharacterKilled__DelegateSignature::KillerId' has a wrong offset!");

// DelegateFunction G01.GzCharacter.GzOperableObjectChanged__DelegateSignature
// 0x0008 (0x0008 - 0x0000)
struct GzCharacter_GzOperableObjectChanged__DelegateSignature final
{
public:
	class UGzOperableObjectComponent*             OperableObjectComponent;                           // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzCharacter_GzOperableObjectChanged__DelegateSignature) == 0x000008, "Wrong alignment on GzCharacter_GzOperableObjectChanged__DelegateSignature");
static_assert(sizeof(GzCharacter_GzOperableObjectChanged__DelegateSignature) == 0x000008, "Wrong size on GzCharacter_GzOperableObjectChanged__DelegateSignature");
static_assert(offsetof(GzCharacter_GzOperableObjectChanged__DelegateSignature, OperableObjectComponent) == 0x000000, "Member 'GzCharacter_GzOperableObjectChanged__DelegateSignature::OperableObjectComponent' has a wrong offset!");

// Function G01.GzCharacter.HandleFinishedMovingAlongZipline
// 0x0001 (0x0001 - 0x0000)
struct GzCharacter_HandleFinishedMovingAlongZipline final
{
public:
	bool                                          bCanceled;                                         // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzCharacter_HandleFinishedMovingAlongZipline) == 0x000001, "Wrong alignment on GzCharacter_HandleFinishedMovingAlongZipline");
static_assert(sizeof(GzCharacter_HandleFinishedMovingAlongZipline) == 0x000001, "Wrong size on GzCharacter_HandleFinishedMovingAlongZipline");
static_assert(offsetof(GzCharacter_HandleFinishedMovingAlongZipline, bCanceled) == 0x000000, "Member 'GzCharacter_HandleFinishedMovingAlongZipline::bCanceled' has a wrong offset!");

// Function G01.GzCharacter.LinkActiveAnimLayer
// 0x0028 (0x0028 - 0x0000)
struct GzCharacter_LinkActiveAnimLayer final
{
public:
	TSoftClassPtr<class UClass>                   NewLayer;                                          // 0x0000(0x0028)(ConstParm, Parm, OutParm, ReferenceParm, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzCharacter_LinkActiveAnimLayer) == 0x000008, "Wrong alignment on GzCharacter_LinkActiveAnimLayer");
static_assert(sizeof(GzCharacter_LinkActiveAnimLayer) == 0x000028, "Wrong size on GzCharacter_LinkActiveAnimLayer");
static_assert(offsetof(GzCharacter_LinkActiveAnimLayer, NewLayer) == 0x000000, "Member 'GzCharacter_LinkActiveAnimLayer::NewLayer' has a wrong offset!");

// Function G01.GzCharacter.MulticastOnJumpActivationFailed
// 0x0008 (0x0008 - 0x0000)
struct GzCharacter_MulticastOnJumpActivationFailed final
{
public:
	struct FGameplayTag                           FailedAbilityTag;                                  // 0x0000(0x0008)(ConstParm, Parm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzCharacter_MulticastOnJumpActivationFailed) == 0x000004, "Wrong alignment on GzCharacter_MulticastOnJumpActivationFailed");
static_assert(sizeof(GzCharacter_MulticastOnJumpActivationFailed) == 0x000008, "Wrong size on GzCharacter_MulticastOnJumpActivationFailed");
static_assert(offsetof(GzCharacter_MulticastOnJumpActivationFailed, FailedAbilityTag) == 0x000000, "Member 'GzCharacter_MulticastOnJumpActivationFailed::FailedAbilityTag' has a wrong offset!");

// Function G01.GzCharacter.MulticastStartRagDoll
// 0x02A0 (0x02A0 - 0x0000)
struct GzCharacter_MulticastStartRagDoll final
{
public:
	struct FGameplayEffectSpec                    DeathEffect;                                       // 0x0000(0x02A0)(ConstParm, Parm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzCharacter_MulticastStartRagDoll) == 0x000008, "Wrong alignment on GzCharacter_MulticastStartRagDoll");
static_assert(sizeof(GzCharacter_MulticastStartRagDoll) == 0x0002A0, "Wrong size on GzCharacter_MulticastStartRagDoll");
static_assert(offsetof(GzCharacter_MulticastStartRagDoll, DeathEffect) == 0x000000, "Member 'GzCharacter_MulticastStartRagDoll::DeathEffect' has a wrong offset!");

// Function G01.GzCharacter.OnCharacterCustomizationApplied
// 0x0150 (0x0150 - 0x0000)
struct GzCharacter_OnCharacterCustomizationApplied final
{
public:
	struct FGzCharacterCustomizationProfile       Profile;                                           // 0x0000(0x0150)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzCharacter_OnCharacterCustomizationApplied) == 0x000008, "Wrong alignment on GzCharacter_OnCharacterCustomizationApplied");
static_assert(sizeof(GzCharacter_OnCharacterCustomizationApplied) == 0x000150, "Wrong size on GzCharacter_OnCharacterCustomizationApplied");
static_assert(offsetof(GzCharacter_OnCharacterCustomizationApplied, Profile) == 0x000000, "Member 'GzCharacter_OnCharacterCustomizationApplied::Profile' has a wrong offset!");

// SparseDelegateFunction G01.GzCharacter.OnCharacterDied_BP__DelegateSignature
// 0x0008 (0x0008 - 0x0000)
struct GzCharacter_OnCharacterDied_BP__DelegateSignature final
{
public:
	class AGzCharacter*                           Character;                                         // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzCharacter_OnCharacterDied_BP__DelegateSignature) == 0x000008, "Wrong alignment on GzCharacter_OnCharacterDied_BP__DelegateSignature");
static_assert(sizeof(GzCharacter_OnCharacterDied_BP__DelegateSignature) == 0x000008, "Wrong size on GzCharacter_OnCharacterDied_BP__DelegateSignature");
static_assert(offsetof(GzCharacter_OnCharacterDied_BP__DelegateSignature, Character) == 0x000000, "Member 'GzCharacter_OnCharacterDied_BP__DelegateSignature::Character' has a wrong offset!");

// SparseDelegateFunction G01.GzCharacter.OnCharacterKnockedDown_BP__DelegateSignature
// 0x0008 (0x0008 - 0x0000)
struct GzCharacter_OnCharacterKnockedDown_BP__DelegateSignature final
{
public:
	class AGzCharacter*                           Character;                                         // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzCharacter_OnCharacterKnockedDown_BP__DelegateSignature) == 0x000008, "Wrong alignment on GzCharacter_OnCharacterKnockedDown_BP__DelegateSignature");
static_assert(sizeof(GzCharacter_OnCharacterKnockedDown_BP__DelegateSignature) == 0x000008, "Wrong size on GzCharacter_OnCharacterKnockedDown_BP__DelegateSignature");
static_assert(offsetof(GzCharacter_OnCharacterKnockedDown_BP__DelegateSignature, Character) == 0x000000, "Member 'GzCharacter_OnCharacterKnockedDown_BP__DelegateSignature::Character' has a wrong offset!");

// SparseDelegateFunction G01.GzCharacter.OnCharacterKnockedDownStateChanged_BP__DelegateSignature
// 0x0010 (0x0010 - 0x0000)
struct GzCharacter_OnCharacterKnockedDownStateChanged_BP__DelegateSignature final
{
public:
	class AGzCharacter*                           Character;                                         // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          KnockedDownState;                                  // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2D50[0x7];                                     // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GzCharacter_OnCharacterKnockedDownStateChanged_BP__DelegateSignature) == 0x000008, "Wrong alignment on GzCharacter_OnCharacterKnockedDownStateChanged_BP__DelegateSignature");
static_assert(sizeof(GzCharacter_OnCharacterKnockedDownStateChanged_BP__DelegateSignature) == 0x000010, "Wrong size on GzCharacter_OnCharacterKnockedDownStateChanged_BP__DelegateSignature");
static_assert(offsetof(GzCharacter_OnCharacterKnockedDownStateChanged_BP__DelegateSignature, Character) == 0x000000, "Member 'GzCharacter_OnCharacterKnockedDownStateChanged_BP__DelegateSignature::Character' has a wrong offset!");
static_assert(offsetof(GzCharacter_OnCharacterKnockedDownStateChanged_BP__DelegateSignature, KnockedDownState) == 0x000008, "Member 'GzCharacter_OnCharacterKnockedDownStateChanged_BP__DelegateSignature::KnockedDownState' has a wrong offset!");

// SparseDelegateFunction G01.GzCharacter.OnCharacterStartDied_BP__DelegateSignature
// 0x0008 (0x0008 - 0x0000)
struct GzCharacter_OnCharacterStartDied_BP__DelegateSignature final
{
public:
	class AGzCharacter*                           Character;                                         // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzCharacter_OnCharacterStartDied_BP__DelegateSignature) == 0x000008, "Wrong alignment on GzCharacter_OnCharacterStartDied_BP__DelegateSignature");
static_assert(sizeof(GzCharacter_OnCharacterStartDied_BP__DelegateSignature) == 0x000008, "Wrong size on GzCharacter_OnCharacterStartDied_BP__DelegateSignature");
static_assert(offsetof(GzCharacter_OnCharacterStartDied_BP__DelegateSignature, Character) == 0x000000, "Member 'GzCharacter_OnCharacterStartDied_BP__DelegateSignature::Character' has a wrong offset!");

// Function G01.GzCharacter.OnComebackArenaStateChanged
// 0x0008 (0x0008 - 0x0000)
struct GzCharacter_OnComebackArenaStateChanged final
{
public:
	class AGzPlayerState*                         PS;                                                // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzCharacter_OnComebackArenaStateChanged) == 0x000008, "Wrong alignment on GzCharacter_OnComebackArenaStateChanged");
static_assert(sizeof(GzCharacter_OnComebackArenaStateChanged) == 0x000008, "Wrong size on GzCharacter_OnComebackArenaStateChanged");
static_assert(offsetof(GzCharacter_OnComebackArenaStateChanged, PS) == 0x000000, "Member 'GzCharacter_OnComebackArenaStateChanged::PS' has a wrong offset!");

// Function G01.GzCharacter.OnHitReaction
// 0x0100 (0x0100 - 0x0000)
struct GzCharacter_OnHitReaction final
{
public:
	const class AActor*                           Who;                                               // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FHitResult                             HitResult;                                         // 0x0008(0x00F8)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzCharacter_OnHitReaction) == 0x000008, "Wrong alignment on GzCharacter_OnHitReaction");
static_assert(sizeof(GzCharacter_OnHitReaction) == 0x000100, "Wrong size on GzCharacter_OnHitReaction");
static_assert(offsetof(GzCharacter_OnHitReaction, Who) == 0x000000, "Member 'GzCharacter_OnHitReaction::Who' has a wrong offset!");
static_assert(offsetof(GzCharacter_OnHitReaction, HitResult) == 0x000008, "Member 'GzCharacter_OnHitReaction::HitResult' has a wrong offset!");

// Function G01.GzCharacter.OnJumpActivationFailed
// 0x0008 (0x0008 - 0x0000)
struct GzCharacter_OnJumpActivationFailed final
{
public:
	struct FGameplayTag                           FailedAbilityTag;                                  // 0x0000(0x0008)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzCharacter_OnJumpActivationFailed) == 0x000004, "Wrong alignment on GzCharacter_OnJumpActivationFailed");
static_assert(sizeof(GzCharacter_OnJumpActivationFailed) == 0x000008, "Wrong size on GzCharacter_OnJumpActivationFailed");
static_assert(offsetof(GzCharacter_OnJumpActivationFailed, FailedAbilityTag) == 0x000000, "Member 'GzCharacter_OnJumpActivationFailed::FailedAbilityTag' has a wrong offset!");

// Function G01.GzCharacter.OnMontageEnded
// 0x0010 (0x0010 - 0x0000)
struct GzCharacter_OnMontageEnded final
{
public:
	class UAnimMontage*                           Montage;                                           // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bInterrupted;                                      // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2D51[0x7];                                     // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GzCharacter_OnMontageEnded) == 0x000008, "Wrong alignment on GzCharacter_OnMontageEnded");
static_assert(sizeof(GzCharacter_OnMontageEnded) == 0x000010, "Wrong size on GzCharacter_OnMontageEnded");
static_assert(offsetof(GzCharacter_OnMontageEnded, Montage) == 0x000000, "Member 'GzCharacter_OnMontageEnded::Montage' has a wrong offset!");
static_assert(offsetof(GzCharacter_OnMontageEnded, bInterrupted) == 0x000008, "Member 'GzCharacter_OnMontageEnded::bInterrupted' has a wrong offset!");

// Function G01.GzCharacter.OnMontageStarted
// 0x0008 (0x0008 - 0x0000)
struct GzCharacter_OnMontageStarted final
{
public:
	class UAnimMontage*                           Montage;                                           // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzCharacter_OnMontageStarted) == 0x000008, "Wrong alignment on GzCharacter_OnMontageStarted");
static_assert(sizeof(GzCharacter_OnMontageStarted) == 0x000008, "Wrong size on GzCharacter_OnMontageStarted");
static_assert(offsetof(GzCharacter_OnMontageStarted, Montage) == 0x000000, "Member 'GzCharacter_OnMontageStarted::Montage' has a wrong offset!");

// Function G01.GzCharacter.OnPlayerTeamChangedInternal
// 0x0008 (0x0008 - 0x0000)
struct GzCharacter_OnPlayerTeamChangedInternal final
{
public:
	class AGzPlayerState*                         PS;                                                // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzCharacter_OnPlayerTeamChangedInternal) == 0x000008, "Wrong alignment on GzCharacter_OnPlayerTeamChangedInternal");
static_assert(sizeof(GzCharacter_OnPlayerTeamChangedInternal) == 0x000008, "Wrong size on GzCharacter_OnPlayerTeamChangedInternal");
static_assert(offsetof(GzCharacter_OnPlayerTeamChangedInternal, PS) == 0x000000, "Member 'GzCharacter_OnPlayerTeamChangedInternal::PS' has a wrong offset!");

// Function G01.GzCharacter.OnRagDollEnded
// 0x02A0 (0x02A0 - 0x0000)
struct GzCharacter_OnRagDollEnded final
{
public:
	struct FGameplayEffectSpec                    DeathEffect;                                       // 0x0000(0x02A0)(ConstParm, Parm, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzCharacter_OnRagDollEnded) == 0x000008, "Wrong alignment on GzCharacter_OnRagDollEnded");
static_assert(sizeof(GzCharacter_OnRagDollEnded) == 0x0002A0, "Wrong size on GzCharacter_OnRagDollEnded");
static_assert(offsetof(GzCharacter_OnRagDollEnded, DeathEffect) == 0x000000, "Member 'GzCharacter_OnRagDollEnded::DeathEffect' has a wrong offset!");

// Function G01.GzCharacter.OnSingleHitDamageReceived
// 0x01F8 (0x01F8 - 0x0000)
struct GzCharacter_OnSingleHitDamageReceived final
{
public:
	class UGzDamageableComponent*                 Receiver;                                          // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGzSingleHitDamage                     SingleHit;                                         // 0x0008(0x01F0)(ConstParm, Parm, OutParm, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzCharacter_OnSingleHitDamageReceived) == 0x000008, "Wrong alignment on GzCharacter_OnSingleHitDamageReceived");
static_assert(sizeof(GzCharacter_OnSingleHitDamageReceived) == 0x0001F8, "Wrong size on GzCharacter_OnSingleHitDamageReceived");
static_assert(offsetof(GzCharacter_OnSingleHitDamageReceived, Receiver) == 0x000000, "Member 'GzCharacter_OnSingleHitDamageReceived::Receiver' has a wrong offset!");
static_assert(offsetof(GzCharacter_OnSingleHitDamageReceived, SingleHit) == 0x000008, "Member 'GzCharacter_OnSingleHitDamageReceived::SingleHit' has a wrong offset!");

// Function G01.GzCharacter.OnWorldInstanceIdChanged
// 0x0008 (0x0008 - 0x0000)
struct GzCharacter_OnWorldInstanceIdChanged final
{
public:
	class AGzPlayerState*                         InPlayerState;                                     // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzCharacter_OnWorldInstanceIdChanged) == 0x000008, "Wrong alignment on GzCharacter_OnWorldInstanceIdChanged");
static_assert(sizeof(GzCharacter_OnWorldInstanceIdChanged) == 0x000008, "Wrong size on GzCharacter_OnWorldInstanceIdChanged");
static_assert(offsetof(GzCharacter_OnWorldInstanceIdChanged, InPlayerState) == 0x000000, "Member 'GzCharacter_OnWorldInstanceIdChanged::InPlayerState' has a wrong offset!");

// Function G01.GzCharacter.RevealActor
// 0x0008 (0x0008 - 0x0000)
struct GzCharacter_RevealActor final
{
public:
	class AActor*                                 Actor;                                             // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzCharacter_RevealActor) == 0x000008, "Wrong alignment on GzCharacter_RevealActor");
static_assert(sizeof(GzCharacter_RevealActor) == 0x000008, "Wrong size on GzCharacter_RevealActor");
static_assert(offsetof(GzCharacter_RevealActor, Actor) == 0x000000, "Member 'GzCharacter_RevealActor::Actor' has a wrong offset!");

// Function G01.GzCharacter.ServerOnJumpActivationFailed
// 0x0008 (0x0008 - 0x0000)
struct GzCharacter_ServerOnJumpActivationFailed final
{
public:
	struct FGameplayTag                           FailedAbilityTag;                                  // 0x0000(0x0008)(ConstParm, Parm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzCharacter_ServerOnJumpActivationFailed) == 0x000004, "Wrong alignment on GzCharacter_ServerOnJumpActivationFailed");
static_assert(sizeof(GzCharacter_ServerOnJumpActivationFailed) == 0x000008, "Wrong size on GzCharacter_ServerOnJumpActivationFailed");
static_assert(offsetof(GzCharacter_ServerOnJumpActivationFailed, FailedAbilityTag) == 0x000000, "Member 'GzCharacter_ServerOnJumpActivationFailed::FailedAbilityTag' has a wrong offset!");

// Function G01.GzCharacter.SetCanDie
// 0x0001 (0x0001 - 0x0000)
struct GzCharacter_SetCanDie final
{
public:
	bool                                          bInCanDie;                                         // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzCharacter_SetCanDie) == 0x000001, "Wrong alignment on GzCharacter_SetCanDie");
static_assert(sizeof(GzCharacter_SetCanDie) == 0x000001, "Wrong size on GzCharacter_SetCanDie");
static_assert(offsetof(GzCharacter_SetCanDie, bInCanDie) == 0x000000, "Member 'GzCharacter_SetCanDie::bInCanDie' has a wrong offset!");

// Function G01.GzCharacter.SetCurrentZipline
// 0x0008 (0x0008 - 0x0000)
struct GzCharacter_SetCurrentZipline final
{
public:
	const class AGzZipline*                       NewZipline;                                        // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzCharacter_SetCurrentZipline) == 0x000008, "Wrong alignment on GzCharacter_SetCurrentZipline");
static_assert(sizeof(GzCharacter_SetCurrentZipline) == 0x000008, "Wrong size on GzCharacter_SetCurrentZipline");
static_assert(offsetof(GzCharacter_SetCurrentZipline, NewZipline) == 0x000000, "Member 'GzCharacter_SetCurrentZipline::NewZipline' has a wrong offset!");

// Function G01.GzCharacter.Shoot
// 0x0001 (0x0001 - 0x0000)
struct GzCharacter_Shoot final
{
public:
	bool                                          bStart;                                            // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzCharacter_Shoot) == 0x000001, "Wrong alignment on GzCharacter_Shoot");
static_assert(sizeof(GzCharacter_Shoot) == 0x000001, "Wrong size on GzCharacter_Shoot");
static_assert(offsetof(GzCharacter_Shoot, bStart) == 0x000000, "Member 'GzCharacter_Shoot::bStart' has a wrong offset!");

// Function G01.GzCharacter.UnRevealActor
// 0x0008 (0x0008 - 0x0000)
struct GzCharacter_UnRevealActor final
{
public:
	class AActor*                                 Actor;                                             // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzCharacter_UnRevealActor) == 0x000008, "Wrong alignment on GzCharacter_UnRevealActor");
static_assert(sizeof(GzCharacter_UnRevealActor) == 0x000008, "Wrong size on GzCharacter_UnRevealActor");
static_assert(offsetof(GzCharacter_UnRevealActor, Actor) == 0x000000, "Member 'GzCharacter_UnRevealActor::Actor' has a wrong offset!");

// Function G01.GzCharacter.BP_IsNewCharacter
// 0x0001 (0x0001 - 0x0000)
struct GzCharacter_BP_IsNewCharacter final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzCharacter_BP_IsNewCharacter) == 0x000001, "Wrong alignment on GzCharacter_BP_IsNewCharacter");
static_assert(sizeof(GzCharacter_BP_IsNewCharacter) == 0x000001, "Wrong size on GzCharacter_BP_IsNewCharacter");
static_assert(offsetof(GzCharacter_BP_IsNewCharacter, ReturnValue) == 0x000000, "Member 'GzCharacter_BP_IsNewCharacter::ReturnValue' has a wrong offset!");

// Function G01.GzCharacter.CanDie
// 0x0001 (0x0001 - 0x0000)
struct GzCharacter_CanDie final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzCharacter_CanDie) == 0x000001, "Wrong alignment on GzCharacter_CanDie");
static_assert(sizeof(GzCharacter_CanDie) == 0x000001, "Wrong size on GzCharacter_CanDie");
static_assert(offsetof(GzCharacter_CanDie, ReturnValue) == 0x000000, "Member 'GzCharacter_CanDie::ReturnValue' has a wrong offset!");

// Function G01.GzCharacter.GetAbilitiesForInventorySlots
// 0x0030 (0x0030 - 0x0000)
struct GzCharacter_GetAbilitiesForInventorySlots final
{
public:
	struct FGameplayTagContainer                  ItemTypes;                                         // 0x0000(0x0020)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	TArray<class UGzGameplayAbility*>             OutAbilities;                                      // 0x0020(0x0010)(Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzCharacter_GetAbilitiesForInventorySlots) == 0x000008, "Wrong alignment on GzCharacter_GetAbilitiesForInventorySlots");
static_assert(sizeof(GzCharacter_GetAbilitiesForInventorySlots) == 0x000030, "Wrong size on GzCharacter_GetAbilitiesForInventorySlots");
static_assert(offsetof(GzCharacter_GetAbilitiesForInventorySlots, ItemTypes) == 0x000000, "Member 'GzCharacter_GetAbilitiesForInventorySlots::ItemTypes' has a wrong offset!");
static_assert(offsetof(GzCharacter_GetAbilitiesForInventorySlots, OutAbilities) == 0x000020, "Member 'GzCharacter_GetAbilitiesForInventorySlots::OutAbilities' has a wrong offset!");

// Function G01.GzCharacter.GetActiveWeapon
// 0x0008 (0x0008 - 0x0000)
struct GzCharacter_GetActiveWeapon final
{
public:
	class AGzWeaponActor*                         ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzCharacter_GetActiveWeapon) == 0x000008, "Wrong alignment on GzCharacter_GetActiveWeapon");
static_assert(sizeof(GzCharacter_GetActiveWeapon) == 0x000008, "Wrong size on GzCharacter_GetActiveWeapon");
static_assert(offsetof(GzCharacter_GetActiveWeapon, ReturnValue) == 0x000000, "Member 'GzCharacter_GetActiveWeapon::ReturnValue' has a wrong offset!");

// Function G01.GzCharacter.GetActiveWeaponComponent
// 0x0008 (0x0008 - 0x0000)
struct GzCharacter_GetActiveWeaponComponent final
{
public:
	class UGzWeaponComponent*                     ReturnValue;                                       // 0x0000(0x0008)(ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzCharacter_GetActiveWeaponComponent) == 0x000008, "Wrong alignment on GzCharacter_GetActiveWeaponComponent");
static_assert(sizeof(GzCharacter_GetActiveWeaponComponent) == 0x000008, "Wrong size on GzCharacter_GetActiveWeaponComponent");
static_assert(offsetof(GzCharacter_GetActiveWeaponComponent, ReturnValue) == 0x000000, "Member 'GzCharacter_GetActiveWeaponComponent::ReturnValue' has a wrong offset!");

// Function G01.GzCharacter.GetAirFrictionCoef
// 0x0004 (0x0004 - 0x0000)
struct GzCharacter_GetAirFrictionCoef final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzCharacter_GetAirFrictionCoef) == 0x000004, "Wrong alignment on GzCharacter_GetAirFrictionCoef");
static_assert(sizeof(GzCharacter_GetAirFrictionCoef) == 0x000004, "Wrong size on GzCharacter_GetAirFrictionCoef");
static_assert(offsetof(GzCharacter_GetAirFrictionCoef, ReturnValue) == 0x000000, "Member 'GzCharacter_GetAirFrictionCoef::ReturnValue' has a wrong offset!");

// Function G01.GzCharacter.GetArmor
// 0x0004 (0x0004 - 0x0000)
struct GzCharacter_GetArmor final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzCharacter_GetArmor) == 0x000004, "Wrong alignment on GzCharacter_GetArmor");
static_assert(sizeof(GzCharacter_GetArmor) == 0x000004, "Wrong size on GzCharacter_GetArmor");
static_assert(offsetof(GzCharacter_GetArmor, ReturnValue) == 0x000000, "Member 'GzCharacter_GetArmor::ReturnValue' has a wrong offset!");

// Function G01.GzCharacter.GetCharacterLevel
// 0x0004 (0x0004 - 0x0000)
struct GzCharacter_GetCharacterLevel final
{
public:
	int32                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzCharacter_GetCharacterLevel) == 0x000004, "Wrong alignment on GzCharacter_GetCharacterLevel");
static_assert(sizeof(GzCharacter_GetCharacterLevel) == 0x000004, "Wrong size on GzCharacter_GetCharacterLevel");
static_assert(offsetof(GzCharacter_GetCharacterLevel, ReturnValue) == 0x000000, "Member 'GzCharacter_GetCharacterLevel::ReturnValue' has a wrong offset!");

// Function G01.GzCharacter.GetCrouchCoef
// 0x0004 (0x0004 - 0x0000)
struct GzCharacter_GetCrouchCoef final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzCharacter_GetCrouchCoef) == 0x000004, "Wrong alignment on GzCharacter_GetCrouchCoef");
static_assert(sizeof(GzCharacter_GetCrouchCoef) == 0x000004, "Wrong size on GzCharacter_GetCrouchCoef");
static_assert(offsetof(GzCharacter_GetCrouchCoef, ReturnValue) == 0x000000, "Member 'GzCharacter_GetCrouchCoef::ReturnValue' has a wrong offset!");

// Function G01.GzCharacter.GetCurrentEquippedPocketID
// 0x0008 (0x0008 - 0x0000)
struct GzCharacter_GetCurrentEquippedPocketID final
{
public:
	struct FGzInvPocketId                         ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzCharacter_GetCurrentEquippedPocketID) == 0x000004, "Wrong alignment on GzCharacter_GetCurrentEquippedPocketID");
static_assert(sizeof(GzCharacter_GetCurrentEquippedPocketID) == 0x000008, "Wrong size on GzCharacter_GetCurrentEquippedPocketID");
static_assert(offsetof(GzCharacter_GetCurrentEquippedPocketID, ReturnValue) == 0x000000, "Member 'GzCharacter_GetCurrentEquippedPocketID::ReturnValue' has a wrong offset!");

// Function G01.GzCharacter.GetCurrentOperableObjectComponent
// 0x0008 (0x0008 - 0x0000)
struct GzCharacter_GetCurrentOperableObjectComponent final
{
public:
	class UGzOperableObjectComponent*             ReturnValue;                                       // 0x0000(0x0008)(ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzCharacter_GetCurrentOperableObjectComponent) == 0x000008, "Wrong alignment on GzCharacter_GetCurrentOperableObjectComponent");
static_assert(sizeof(GzCharacter_GetCurrentOperableObjectComponent) == 0x000008, "Wrong size on GzCharacter_GetCurrentOperableObjectComponent");
static_assert(offsetof(GzCharacter_GetCurrentOperableObjectComponent, ReturnValue) == 0x000000, "Member 'GzCharacter_GetCurrentOperableObjectComponent::ReturnValue' has a wrong offset!");

// Function G01.GzCharacter.GetCurrentVehicle
// 0x0008 (0x0008 - 0x0000)
struct GzCharacter_GetCurrentVehicle final
{
public:
	class AGzVehicle*                             ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzCharacter_GetCurrentVehicle) == 0x000008, "Wrong alignment on GzCharacter_GetCurrentVehicle");
static_assert(sizeof(GzCharacter_GetCurrentVehicle) == 0x000008, "Wrong size on GzCharacter_GetCurrentVehicle");
static_assert(offsetof(GzCharacter_GetCurrentVehicle, ReturnValue) == 0x000000, "Member 'GzCharacter_GetCurrentVehicle::ReturnValue' has a wrong offset!");

// Function G01.GzCharacter.GetCurrentZipline
// 0x0008 (0x0008 - 0x0000)
struct GzCharacter_GetCurrentZipline final
{
public:
	const class AGzZipline*                       ReturnValue;                                       // 0x0000(0x0008)(ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzCharacter_GetCurrentZipline) == 0x000008, "Wrong alignment on GzCharacter_GetCurrentZipline");
static_assert(sizeof(GzCharacter_GetCurrentZipline) == 0x000008, "Wrong size on GzCharacter_GetCurrentZipline");
static_assert(offsetof(GzCharacter_GetCurrentZipline, ReturnValue) == 0x000000, "Member 'GzCharacter_GetCurrentZipline::ReturnValue' has a wrong offset!");

// Function G01.GzCharacter.GetCustomizationComponent
// 0x0008 (0x0008 - 0x0000)
struct GzCharacter_GetCustomizationComponent final
{
public:
	class UGzCharacterCustomizationComponent*     ReturnValue;                                       // 0x0000(0x0008)(ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzCharacter_GetCustomizationComponent) == 0x000008, "Wrong alignment on GzCharacter_GetCustomizationComponent");
static_assert(sizeof(GzCharacter_GetCustomizationComponent) == 0x000008, "Wrong size on GzCharacter_GetCustomizationComponent");
static_assert(offsetof(GzCharacter_GetCustomizationComponent, ReturnValue) == 0x000000, "Member 'GzCharacter_GetCustomizationComponent::ReturnValue' has a wrong offset!");

// Function G01.GzCharacter.GetGenericTeamId
// 0x0001 (0x0001 - 0x0000)
struct GzCharacter_GetGenericTeamId final
{
public:
	struct FGenericTeamId                         ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzCharacter_GetGenericTeamId) == 0x000001, "Wrong alignment on GzCharacter_GetGenericTeamId");
static_assert(sizeof(GzCharacter_GetGenericTeamId) == 0x000001, "Wrong size on GzCharacter_GetGenericTeamId");
static_assert(offsetof(GzCharacter_GetGenericTeamId, ReturnValue) == 0x000000, "Member 'GzCharacter_GetGenericTeamId::ReturnValue' has a wrong offset!");

// Function G01.GzCharacter.GetInteractableComponent
// 0x0008 (0x0008 - 0x0000)
struct GzCharacter_GetInteractableComponent final
{
public:
	class UGzInteractableComponent*               ReturnValue;                                       // 0x0000(0x0008)(ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzCharacter_GetInteractableComponent) == 0x000008, "Wrong alignment on GzCharacter_GetInteractableComponent");
static_assert(sizeof(GzCharacter_GetInteractableComponent) == 0x000008, "Wrong size on GzCharacter_GetInteractableComponent");
static_assert(offsetof(GzCharacter_GetInteractableComponent, ReturnValue) == 0x000000, "Member 'GzCharacter_GetInteractableComponent::ReturnValue' has a wrong offset!");

// Function G01.GzCharacter.GetJumpVelocityBaseValue
// 0x0004 (0x0004 - 0x0000)
struct GzCharacter_GetJumpVelocityBaseValue final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzCharacter_GetJumpVelocityBaseValue) == 0x000004, "Wrong alignment on GzCharacter_GetJumpVelocityBaseValue");
static_assert(sizeof(GzCharacter_GetJumpVelocityBaseValue) == 0x000004, "Wrong size on GzCharacter_GetJumpVelocityBaseValue");
static_assert(offsetof(GzCharacter_GetJumpVelocityBaseValue, ReturnValue) == 0x000000, "Member 'GzCharacter_GetJumpVelocityBaseValue::ReturnValue' has a wrong offset!");

// Function G01.GzCharacter.GetKnockedTimeToLive
// 0x0004 (0x0004 - 0x0000)
struct GzCharacter_GetKnockedTimeToLive final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzCharacter_GetKnockedTimeToLive) == 0x000004, "Wrong alignment on GzCharacter_GetKnockedTimeToLive");
static_assert(sizeof(GzCharacter_GetKnockedTimeToLive) == 0x000004, "Wrong size on GzCharacter_GetKnockedTimeToLive");
static_assert(offsetof(GzCharacter_GetKnockedTimeToLive, ReturnValue) == 0x000000, "Member 'GzCharacter_GetKnockedTimeToLive::ReturnValue' has a wrong offset!");

// Function G01.GzCharacter.GetLeftHandIKOffsetXValue
// 0x0004 (0x0004 - 0x0000)
struct GzCharacter_GetLeftHandIKOffsetXValue final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzCharacter_GetLeftHandIKOffsetXValue) == 0x000004, "Wrong alignment on GzCharacter_GetLeftHandIKOffsetXValue");
static_assert(sizeof(GzCharacter_GetLeftHandIKOffsetXValue) == 0x000004, "Wrong size on GzCharacter_GetLeftHandIKOffsetXValue");
static_assert(offsetof(GzCharacter_GetLeftHandIKOffsetXValue, ReturnValue) == 0x000000, "Member 'GzCharacter_GetLeftHandIKOffsetXValue::ReturnValue' has a wrong offset!");

// Function G01.GzCharacter.GetLeftHandIKOffsetYValue
// 0x0004 (0x0004 - 0x0000)
struct GzCharacter_GetLeftHandIKOffsetYValue final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzCharacter_GetLeftHandIKOffsetYValue) == 0x000004, "Wrong alignment on GzCharacter_GetLeftHandIKOffsetYValue");
static_assert(sizeof(GzCharacter_GetLeftHandIKOffsetYValue) == 0x000004, "Wrong size on GzCharacter_GetLeftHandIKOffsetYValue");
static_assert(offsetof(GzCharacter_GetLeftHandIKOffsetYValue, ReturnValue) == 0x000000, "Member 'GzCharacter_GetLeftHandIKOffsetYValue::ReturnValue' has a wrong offset!");

// Function G01.GzCharacter.GetLeftHandIKOffsetZValue
// 0x0004 (0x0004 - 0x0000)
struct GzCharacter_GetLeftHandIKOffsetZValue final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzCharacter_GetLeftHandIKOffsetZValue) == 0x000004, "Wrong alignment on GzCharacter_GetLeftHandIKOffsetZValue");
static_assert(sizeof(GzCharacter_GetLeftHandIKOffsetZValue) == 0x000004, "Wrong size on GzCharacter_GetLeftHandIKOffsetZValue");
static_assert(offsetof(GzCharacter_GetLeftHandIKOffsetZValue, ReturnValue) == 0x000000, "Member 'GzCharacter_GetLeftHandIKOffsetZValue::ReturnValue' has a wrong offset!");

// Function G01.GzCharacter.GetLeftHandIKValue
// 0x0004 (0x0004 - 0x0000)
struct GzCharacter_GetLeftHandIKValue final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzCharacter_GetLeftHandIKValue) == 0x000004, "Wrong alignment on GzCharacter_GetLeftHandIKValue");
static_assert(sizeof(GzCharacter_GetLeftHandIKValue) == 0x000004, "Wrong size on GzCharacter_GetLeftHandIKValue");
static_assert(offsetof(GzCharacter_GetLeftHandIKValue, ReturnValue) == 0x000000, "Member 'GzCharacter_GetLeftHandIKValue::ReturnValue' has a wrong offset!");

// Function G01.GzCharacter.GetMaxArmor
// 0x0004 (0x0004 - 0x0000)
struct GzCharacter_GetMaxArmor final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzCharacter_GetMaxArmor) == 0x000004, "Wrong alignment on GzCharacter_GetMaxArmor");
static_assert(sizeof(GzCharacter_GetMaxArmor) == 0x000004, "Wrong size on GzCharacter_GetMaxArmor");
static_assert(offsetof(GzCharacter_GetMaxArmor, ReturnValue) == 0x000000, "Member 'GzCharacter_GetMaxArmor::ReturnValue' has a wrong offset!");

// Function G01.GzCharacter.GetMovementSpeed
// 0x0004 (0x0004 - 0x0000)
struct GzCharacter_GetMovementSpeed final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzCharacter_GetMovementSpeed) == 0x000004, "Wrong alignment on GzCharacter_GetMovementSpeed");
static_assert(sizeof(GzCharacter_GetMovementSpeed) == 0x000004, "Wrong size on GzCharacter_GetMovementSpeed");
static_assert(offsetof(GzCharacter_GetMovementSpeed, ReturnValue) == 0x000000, "Member 'GzCharacter_GetMovementSpeed::ReturnValue' has a wrong offset!");

// Function G01.GzCharacter.GetMovementSpeedBaseValue
// 0x0004 (0x0004 - 0x0000)
struct GzCharacter_GetMovementSpeedBaseValue final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzCharacter_GetMovementSpeedBaseValue) == 0x000004, "Wrong alignment on GzCharacter_GetMovementSpeedBaseValue");
static_assert(sizeof(GzCharacter_GetMovementSpeedBaseValue) == 0x000004, "Wrong size on GzCharacter_GetMovementSpeedBaseValue");
static_assert(offsetof(GzCharacter_GetMovementSpeedBaseValue, ReturnValue) == 0x000000, "Member 'GzCharacter_GetMovementSpeedBaseValue::ReturnValue' has a wrong offset!");

// Function G01.GzCharacter.GetRunCoef
// 0x0004 (0x0004 - 0x0000)
struct GzCharacter_GetRunCoef final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzCharacter_GetRunCoef) == 0x000004, "Wrong alignment on GzCharacter_GetRunCoef");
static_assert(sizeof(GzCharacter_GetRunCoef) == 0x000004, "Wrong size on GzCharacter_GetRunCoef");
static_assert(offsetof(GzCharacter_GetRunCoef, ReturnValue) == 0x000000, "Member 'GzCharacter_GetRunCoef::ReturnValue' has a wrong offset!");

// Function G01.GzCharacter.GetSprintCoef
// 0x0004 (0x0004 - 0x0000)
struct GzCharacter_GetSprintCoef final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzCharacter_GetSprintCoef) == 0x000004, "Wrong alignment on GzCharacter_GetSprintCoef");
static_assert(sizeof(GzCharacter_GetSprintCoef) == 0x000004, "Wrong size on GzCharacter_GetSprintCoef");
static_assert(offsetof(GzCharacter_GetSprintCoef, ReturnValue) == 0x000000, "Member 'GzCharacter_GetSprintCoef::ReturnValue' has a wrong offset!");

// Function G01.GzCharacter.GetTeamId
// 0x0004 (0x0004 - 0x0000)
struct GzCharacter_GetTeamId final
{
public:
	int32                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzCharacter_GetTeamId) == 0x000004, "Wrong alignment on GzCharacter_GetTeamId");
static_assert(sizeof(GzCharacter_GetTeamId) == 0x000004, "Wrong size on GzCharacter_GetTeamId");
static_assert(offsetof(GzCharacter_GetTeamId, ReturnValue) == 0x000000, "Member 'GzCharacter_GetTeamId::ReturnValue' has a wrong offset!");

// Function G01.GzCharacter.GetUnarmedAnimLayer
// 0x0028 (0x0028 - 0x0000)
struct GzCharacter_GetUnarmedAnimLayer final
{
public:
	TSoftClassPtr<class UClass>                   ReturnValue;                                       // 0x0000(0x0028)(ConstParm, Parm, OutParm, ReturnParm, ReferenceParm, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzCharacter_GetUnarmedAnimLayer) == 0x000008, "Wrong alignment on GzCharacter_GetUnarmedAnimLayer");
static_assert(sizeof(GzCharacter_GetUnarmedAnimLayer) == 0x000028, "Wrong size on GzCharacter_GetUnarmedAnimLayer");
static_assert(offsetof(GzCharacter_GetUnarmedAnimLayer, ReturnValue) == 0x000000, "Member 'GzCharacter_GetUnarmedAnimLayer::ReturnValue' has a wrong offset!");

// Function G01.GzCharacter.GetWalkCoef
// 0x0004 (0x0004 - 0x0000)
struct GzCharacter_GetWalkCoef final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzCharacter_GetWalkCoef) == 0x000004, "Wrong alignment on GzCharacter_GetWalkCoef");
static_assert(sizeof(GzCharacter_GetWalkCoef) == 0x000004, "Wrong size on GzCharacter_GetWalkCoef");
static_assert(offsetof(GzCharacter_GetWalkCoef, ReturnValue) == 0x000000, "Member 'GzCharacter_GetWalkCoef::ReturnValue' has a wrong offset!");

// Function G01.GzCharacter.GetWeaponAtSlot
// 0x0010 (0x0010 - 0x0000)
struct GzCharacter_GetWeaponAtSlot final
{
public:
	struct FGzInvPocketId                         SlotID;                                            // 0x0000(0x0008)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AGzWeaponActor*                         ReturnValue;                                       // 0x0008(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzCharacter_GetWeaponAtSlot) == 0x000008, "Wrong alignment on GzCharacter_GetWeaponAtSlot");
static_assert(sizeof(GzCharacter_GetWeaponAtSlot) == 0x000010, "Wrong size on GzCharacter_GetWeaponAtSlot");
static_assert(offsetof(GzCharacter_GetWeaponAtSlot, SlotID) == 0x000000, "Member 'GzCharacter_GetWeaponAtSlot::SlotID' has a wrong offset!");
static_assert(offsetof(GzCharacter_GetWeaponAtSlot, ReturnValue) == 0x000008, "Member 'GzCharacter_GetWeaponAtSlot::ReturnValue' has a wrong offset!");

// Function G01.GzCharacter.IsAfterShootTimerFinished
// 0x0001 (0x0001 - 0x0000)
struct GzCharacter_IsAfterShootTimerFinished final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzCharacter_IsAfterShootTimerFinished) == 0x000001, "Wrong alignment on GzCharacter_IsAfterShootTimerFinished");
static_assert(sizeof(GzCharacter_IsAfterShootTimerFinished) == 0x000001, "Wrong size on GzCharacter_IsAfterShootTimerFinished");
static_assert(offsetof(GzCharacter_IsAfterShootTimerFinished, ReturnValue) == 0x000000, "Member 'GzCharacter_IsAfterShootTimerFinished::ReturnValue' has a wrong offset!");

// Function G01.GzCharacter.IsKnockedDown
// 0x0001 (0x0001 - 0x0000)
struct GzCharacter_IsKnockedDown final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzCharacter_IsKnockedDown) == 0x000001, "Wrong alignment on GzCharacter_IsKnockedDown");
static_assert(sizeof(GzCharacter_IsKnockedDown) == 0x000001, "Wrong size on GzCharacter_IsKnockedDown");
static_assert(offsetof(GzCharacter_IsKnockedDown, ReturnValue) == 0x000000, "Member 'GzCharacter_IsKnockedDown::ReturnValue' has a wrong offset!");

// Function G01.GzMultiPartCharacter.BP_OnBackpackChanged
// 0x0080 (0x0080 - 0x0000)
struct GzMultiPartCharacter_BP_OnBackpackChanged final
{
public:
	struct FGzInvPocketChangeData                 Data;                                              // 0x0000(0x0080)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzMultiPartCharacter_BP_OnBackpackChanged) == 0x000008, "Wrong alignment on GzMultiPartCharacter_BP_OnBackpackChanged");
static_assert(sizeof(GzMultiPartCharacter_BP_OnBackpackChanged) == 0x000080, "Wrong size on GzMultiPartCharacter_BP_OnBackpackChanged");
static_assert(offsetof(GzMultiPartCharacter_BP_OnBackpackChanged, Data) == 0x000000, "Member 'GzMultiPartCharacter_BP_OnBackpackChanged::Data' has a wrong offset!");

// Function G01.GzMultiPartCharacter.Multicast_PlayHitReaction
// 0x0100 (0x0100 - 0x0000)
struct GzMultiPartCharacter_Multicast_PlayHitReaction final
{
public:
	const class AActor*                           Who;                                               // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FHitResult                             HitResult;                                         // 0x0008(0x00F8)(ConstParm, Parm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzMultiPartCharacter_Multicast_PlayHitReaction) == 0x000008, "Wrong alignment on GzMultiPartCharacter_Multicast_PlayHitReaction");
static_assert(sizeof(GzMultiPartCharacter_Multicast_PlayHitReaction) == 0x000100, "Wrong size on GzMultiPartCharacter_Multicast_PlayHitReaction");
static_assert(offsetof(GzMultiPartCharacter_Multicast_PlayHitReaction, Who) == 0x000000, "Member 'GzMultiPartCharacter_Multicast_PlayHitReaction::Who' has a wrong offset!");
static_assert(offsetof(GzMultiPartCharacter_Multicast_PlayHitReaction, HitResult) == 0x000008, "Member 'GzMultiPartCharacter_Multicast_PlayHitReaction::HitResult' has a wrong offset!");

// Function G01.GzMultiPartCharacter.OnActiveLimbTagChanged
// 0x0008 (0x0008 - 0x0000)
struct GzMultiPartCharacter_OnActiveLimbTagChanged final
{
public:
	struct FGameplayTag                           LimbActiveTag;                                     // 0x0000(0x0008)(Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzMultiPartCharacter_OnActiveLimbTagChanged) == 0x000004, "Wrong alignment on GzMultiPartCharacter_OnActiveLimbTagChanged");
static_assert(sizeof(GzMultiPartCharacter_OnActiveLimbTagChanged) == 0x000008, "Wrong size on GzMultiPartCharacter_OnActiveLimbTagChanged");
static_assert(offsetof(GzMultiPartCharacter_OnActiveLimbTagChanged, LimbActiveTag) == 0x000000, "Member 'GzMultiPartCharacter_OnActiveLimbTagChanged::LimbActiveTag' has a wrong offset!");

// Function G01.GzMultiPartCharacter.OnDamageableAreaDamaged
// 0x0008 (0x0008 - 0x0000)
struct GzMultiPartCharacter_OnDamageableAreaDamaged final
{
public:
	EGzCharacterDamageAreaType                    DamageableArea;                                    // 0x0000(0x0001)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2D60[0x3];                                     // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Damage;                                            // 0x0004(0x0004)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzMultiPartCharacter_OnDamageableAreaDamaged) == 0x000004, "Wrong alignment on GzMultiPartCharacter_OnDamageableAreaDamaged");
static_assert(sizeof(GzMultiPartCharacter_OnDamageableAreaDamaged) == 0x000008, "Wrong size on GzMultiPartCharacter_OnDamageableAreaDamaged");
static_assert(offsetof(GzMultiPartCharacter_OnDamageableAreaDamaged, DamageableArea) == 0x000000, "Member 'GzMultiPartCharacter_OnDamageableAreaDamaged::DamageableArea' has a wrong offset!");
static_assert(offsetof(GzMultiPartCharacter_OnDamageableAreaDamaged, Damage) == 0x000004, "Member 'GzMultiPartCharacter_OnDamageableAreaDamaged::Damage' has a wrong offset!");

// Function G01.GzMultiPartCharacter.OnLimbAttachCancel
// 0x0120 (0x0120 - 0x0000)
struct GzMultiPartCharacter_OnLimbAttachCancel final
{
public:
	struct FVector_NetQuantize                    Location;                                          // 0x0000(0x0018)(ConstParm, Parm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2D61[0x8];                                     // 0x0018(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FQuat                                  Rotation;                                          // 0x0020(0x0020)(ConstParm, Parm, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGzPickableSpawnInfo                   LimbInfo;                                          // 0x0040(0x00D0)(ConstParm, Parm, ReferenceParm, NativeAccessSpecifierPublic)
	struct FGzInvItem                             InvItem;                                           // 0x0110(0x0010)(ConstParm, Parm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzMultiPartCharacter_OnLimbAttachCancel) == 0x000010, "Wrong alignment on GzMultiPartCharacter_OnLimbAttachCancel");
static_assert(sizeof(GzMultiPartCharacter_OnLimbAttachCancel) == 0x000120, "Wrong size on GzMultiPartCharacter_OnLimbAttachCancel");
static_assert(offsetof(GzMultiPartCharacter_OnLimbAttachCancel, Location) == 0x000000, "Member 'GzMultiPartCharacter_OnLimbAttachCancel::Location' has a wrong offset!");
static_assert(offsetof(GzMultiPartCharacter_OnLimbAttachCancel, Rotation) == 0x000020, "Member 'GzMultiPartCharacter_OnLimbAttachCancel::Rotation' has a wrong offset!");
static_assert(offsetof(GzMultiPartCharacter_OnLimbAttachCancel, LimbInfo) == 0x000040, "Member 'GzMultiPartCharacter_OnLimbAttachCancel::LimbInfo' has a wrong offset!");
static_assert(offsetof(GzMultiPartCharacter_OnLimbAttachCancel, InvItem) == 0x000110, "Member 'GzMultiPartCharacter_OnLimbAttachCancel::InvItem' has a wrong offset!");

// Function G01.GzMultiPartCharacter.OnLimbTypeHealthChange
// 0x0008 (0x0008 - 0x0000)
struct GzMultiPartCharacter_OnLimbTypeHealthChange final
{
public:
	EGzLimbType                                   LimbType;                                          // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2D62[0x3];                                     // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Health;                                            // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzMultiPartCharacter_OnLimbTypeHealthChange) == 0x000004, "Wrong alignment on GzMultiPartCharacter_OnLimbTypeHealthChange");
static_assert(sizeof(GzMultiPartCharacter_OnLimbTypeHealthChange) == 0x000008, "Wrong size on GzMultiPartCharacter_OnLimbTypeHealthChange");
static_assert(offsetof(GzMultiPartCharacter_OnLimbTypeHealthChange, LimbType) == 0x000000, "Member 'GzMultiPartCharacter_OnLimbTypeHealthChange::LimbType' has a wrong offset!");
static_assert(offsetof(GzMultiPartCharacter_OnLimbTypeHealthChange, Health) == 0x000004, "Member 'GzMultiPartCharacter_OnLimbTypeHealthChange::Health' has a wrong offset!");

// Function G01.GzMultiPartCharacter.TearOffLimbByType
// 0x0002 (0x0002 - 0x0000)
struct GzMultiPartCharacter_TearOffLimbByType final
{
public:
	EGzLimbType                                   LimbType;                                          // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bForced;                                           // 0x0001(0x0001)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzMultiPartCharacter_TearOffLimbByType) == 0x000001, "Wrong alignment on GzMultiPartCharacter_TearOffLimbByType");
static_assert(sizeof(GzMultiPartCharacter_TearOffLimbByType) == 0x000002, "Wrong size on GzMultiPartCharacter_TearOffLimbByType");
static_assert(offsetof(GzMultiPartCharacter_TearOffLimbByType, LimbType) == 0x000000, "Member 'GzMultiPartCharacter_TearOffLimbByType::LimbType' has a wrong offset!");
static_assert(offsetof(GzMultiPartCharacter_TearOffLimbByType, bForced) == 0x000001, "Member 'GzMultiPartCharacter_TearOffLimbByType::bForced' has a wrong offset!");

// Function G01.GzMultiPartCharacter.TearOffLimbByTypeWithTag
// 0x000C (0x000C - 0x0000)
struct GzMultiPartCharacter_TearOffLimbByTypeWithTag final
{
public:
	EGzLimbType                                   LimbType;                                          // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2D63[0x3];                                     // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTag                           Tag;                                               // 0x0004(0x0008)(ConstParm, Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzMultiPartCharacter_TearOffLimbByTypeWithTag) == 0x000004, "Wrong alignment on GzMultiPartCharacter_TearOffLimbByTypeWithTag");
static_assert(sizeof(GzMultiPartCharacter_TearOffLimbByTypeWithTag) == 0x00000C, "Wrong size on GzMultiPartCharacter_TearOffLimbByTypeWithTag");
static_assert(offsetof(GzMultiPartCharacter_TearOffLimbByTypeWithTag, LimbType) == 0x000000, "Member 'GzMultiPartCharacter_TearOffLimbByTypeWithTag::LimbType' has a wrong offset!");
static_assert(offsetof(GzMultiPartCharacter_TearOffLimbByTypeWithTag, Tag) == 0x000004, "Member 'GzMultiPartCharacter_TearOffLimbByTypeWithTag::Tag' has a wrong offset!");

// Function G01.GzMultiPartCharacter.GetActiveLimbAbility
// 0x0008 (0x0008 - 0x0000)
struct GzMultiPartCharacter_GetActiveLimbAbility final
{
public:
	class UGzGA_BaseLimbAbility*                  ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzMultiPartCharacter_GetActiveLimbAbility) == 0x000008, "Wrong alignment on GzMultiPartCharacter_GetActiveLimbAbility");
static_assert(sizeof(GzMultiPartCharacter_GetActiveLimbAbility) == 0x000008, "Wrong size on GzMultiPartCharacter_GetActiveLimbAbility");
static_assert(offsetof(GzMultiPartCharacter_GetActiveLimbAbility, ReturnValue) == 0x000000, "Member 'GzMultiPartCharacter_GetActiveLimbAbility::ReturnValue' has a wrong offset!");

// Function G01.GzMultiPartCharacter.GetActiveLimbAbilityTag
// 0x0008 (0x0008 - 0x0000)
struct GzMultiPartCharacter_GetActiveLimbAbilityTag final
{
public:
	struct FGameplayTag                           ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzMultiPartCharacter_GetActiveLimbAbilityTag) == 0x000004, "Wrong alignment on GzMultiPartCharacter_GetActiveLimbAbilityTag");
static_assert(sizeof(GzMultiPartCharacter_GetActiveLimbAbilityTag) == 0x000008, "Wrong size on GzMultiPartCharacter_GetActiveLimbAbilityTag");
static_assert(offsetof(GzMultiPartCharacter_GetActiveLimbAbilityTag, ReturnValue) == 0x000000, "Member 'GzMultiPartCharacter_GetActiveLimbAbilityTag::ReturnValue' has a wrong offset!");

// Function G01.GzMultiPartCharacter.GetBackpackMeshComponent
// 0x0008 (0x0008 - 0x0000)
struct GzMultiPartCharacter_GetBackpackMeshComponent final
{
public:
	class UStaticMeshComponent*                   ReturnValue;                                       // 0x0000(0x0008)(ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzMultiPartCharacter_GetBackpackMeshComponent) == 0x000008, "Wrong alignment on GzMultiPartCharacter_GetBackpackMeshComponent");
static_assert(sizeof(GzMultiPartCharacter_GetBackpackMeshComponent) == 0x000008, "Wrong size on GzMultiPartCharacter_GetBackpackMeshComponent");
static_assert(offsetof(GzMultiPartCharacter_GetBackpackMeshComponent, ReturnValue) == 0x000000, "Member 'GzMultiPartCharacter_GetBackpackMeshComponent::ReturnValue' has a wrong offset!");

// Function G01.GzMultiPartCharacter.GetBoneNameByDamageArea
// 0x000C (0x000C - 0x0000)
struct GzMultiPartCharacter_GetBoneNameByDamageArea final
{
public:
	EGzCharacterDamageAreaType                    DamageArea;                                        // 0x0000(0x0001)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2D64[0x3];                                     // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   ReturnValue;                                       // 0x0004(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzMultiPartCharacter_GetBoneNameByDamageArea) == 0x000004, "Wrong alignment on GzMultiPartCharacter_GetBoneNameByDamageArea");
static_assert(sizeof(GzMultiPartCharacter_GetBoneNameByDamageArea) == 0x00000C, "Wrong size on GzMultiPartCharacter_GetBoneNameByDamageArea");
static_assert(offsetof(GzMultiPartCharacter_GetBoneNameByDamageArea, DamageArea) == 0x000000, "Member 'GzMultiPartCharacter_GetBoneNameByDamageArea::DamageArea' has a wrong offset!");
static_assert(offsetof(GzMultiPartCharacter_GetBoneNameByDamageArea, ReturnValue) == 0x000004, "Member 'GzMultiPartCharacter_GetBoneNameByDamageArea::ReturnValue' has a wrong offset!");

// Function G01.GzMultiPartCharacter.GetDamageAreaTypeByBone
// 0x000C (0x000C - 0x0000)
struct GzMultiPartCharacter_GetDamageAreaTypeByBone final
{
public:
	class FName                                   bone;                                              // 0x0000(0x0008)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EGzCharacterDamageAreaType                    ReturnValue;                                       // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2D65[0x3];                                     // 0x0009(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GzMultiPartCharacter_GetDamageAreaTypeByBone) == 0x000004, "Wrong alignment on GzMultiPartCharacter_GetDamageAreaTypeByBone");
static_assert(sizeof(GzMultiPartCharacter_GetDamageAreaTypeByBone) == 0x00000C, "Wrong size on GzMultiPartCharacter_GetDamageAreaTypeByBone");
static_assert(offsetof(GzMultiPartCharacter_GetDamageAreaTypeByBone, bone) == 0x000000, "Member 'GzMultiPartCharacter_GetDamageAreaTypeByBone::bone' has a wrong offset!");
static_assert(offsetof(GzMultiPartCharacter_GetDamageAreaTypeByBone, ReturnValue) == 0x000008, "Member 'GzMultiPartCharacter_GetDamageAreaTypeByBone::ReturnValue' has a wrong offset!");

// Function G01.GzMultiPartCharacter.GetDamageAreaTypeByHit
// 0x0100 (0x0100 - 0x0000)
struct GzMultiPartCharacter_GetDamageAreaTypeByHit final
{
public:
	struct FHitResult                             Hit;                                               // 0x0000(0x00F8)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	EGzCharacterDamageAreaType                    ReturnValue;                                       // 0x00F8(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2D66[0x7];                                     // 0x00F9(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GzMultiPartCharacter_GetDamageAreaTypeByHit) == 0x000008, "Wrong alignment on GzMultiPartCharacter_GetDamageAreaTypeByHit");
static_assert(sizeof(GzMultiPartCharacter_GetDamageAreaTypeByHit) == 0x000100, "Wrong size on GzMultiPartCharacter_GetDamageAreaTypeByHit");
static_assert(offsetof(GzMultiPartCharacter_GetDamageAreaTypeByHit, Hit) == 0x000000, "Member 'GzMultiPartCharacter_GetDamageAreaTypeByHit::Hit' has a wrong offset!");
static_assert(offsetof(GzMultiPartCharacter_GetDamageAreaTypeByHit, ReturnValue) == 0x0000F8, "Member 'GzMultiPartCharacter_GetDamageAreaTypeByHit::ReturnValue' has a wrong offset!");

// Function G01.GzMultiPartCharacter.GetEquippedLimbComponent
// 0x0010 (0x0010 - 0x0000)
struct GzMultiPartCharacter_GetEquippedLimbComponent final
{
public:
	EGzLimbType                                   Type;                                              // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2D67[0x7];                                     // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UGzLimbComponent*                       ReturnValue;                                       // 0x0008(0x0008)(ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzMultiPartCharacter_GetEquippedLimbComponent) == 0x000008, "Wrong alignment on GzMultiPartCharacter_GetEquippedLimbComponent");
static_assert(sizeof(GzMultiPartCharacter_GetEquippedLimbComponent) == 0x000010, "Wrong size on GzMultiPartCharacter_GetEquippedLimbComponent");
static_assert(offsetof(GzMultiPartCharacter_GetEquippedLimbComponent, Type) == 0x000000, "Member 'GzMultiPartCharacter_GetEquippedLimbComponent::Type' has a wrong offset!");
static_assert(offsetof(GzMultiPartCharacter_GetEquippedLimbComponent, ReturnValue) == 0x000008, "Member 'GzMultiPartCharacter_GetEquippedLimbComponent::ReturnValue' has a wrong offset!");

// Function G01.GzMultiPartCharacter.GetLimbAbilityComponent
// 0x0010 (0x0010 - 0x0000)
struct GzMultiPartCharacter_GetLimbAbilityComponent final
{
public:
	EGzLimbType                                   LimbType;                                          // 0x0000(0x0001)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2D68[0x7];                                     // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UGzLimbAbilityComponent*                ReturnValue;                                       // 0x0008(0x0008)(ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzMultiPartCharacter_GetLimbAbilityComponent) == 0x000008, "Wrong alignment on GzMultiPartCharacter_GetLimbAbilityComponent");
static_assert(sizeof(GzMultiPartCharacter_GetLimbAbilityComponent) == 0x000010, "Wrong size on GzMultiPartCharacter_GetLimbAbilityComponent");
static_assert(offsetof(GzMultiPartCharacter_GetLimbAbilityComponent, LimbType) == 0x000000, "Member 'GzMultiPartCharacter_GetLimbAbilityComponent::LimbType' has a wrong offset!");
static_assert(offsetof(GzMultiPartCharacter_GetLimbAbilityComponent, ReturnValue) == 0x000008, "Member 'GzMultiPartCharacter_GetLimbAbilityComponent::ReturnValue' has a wrong offset!");

// Function G01.GzMultiPartCharacter.GetLimbComponent
// 0x0010 (0x0010 - 0x0000)
struct GzMultiPartCharacter_GetLimbComponent final
{
public:
	EGzLimbType                                   Type;                                              // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2D69[0x7];                                     // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UGzLimbComponent*                       ReturnValue;                                       // 0x0008(0x0008)(ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzMultiPartCharacter_GetLimbComponent) == 0x000008, "Wrong alignment on GzMultiPartCharacter_GetLimbComponent");
static_assert(sizeof(GzMultiPartCharacter_GetLimbComponent) == 0x000010, "Wrong size on GzMultiPartCharacter_GetLimbComponent");
static_assert(offsetof(GzMultiPartCharacter_GetLimbComponent, Type) == 0x000000, "Member 'GzMultiPartCharacter_GetLimbComponent::Type' has a wrong offset!");
static_assert(offsetof(GzMultiPartCharacter_GetLimbComponent, ReturnValue) == 0x000008, "Member 'GzMultiPartCharacter_GetLimbComponent::ReturnValue' has a wrong offset!");

// Function G01.GzMultiPartCharacter.GetLimbComponentByBone
// 0x0010 (0x0010 - 0x0000)
struct GzMultiPartCharacter_GetLimbComponentByBone final
{
public:
	class FName                                   bone;                                              // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UGzLimbComponent*                       ReturnValue;                                       // 0x0008(0x0008)(ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzMultiPartCharacter_GetLimbComponentByBone) == 0x000008, "Wrong alignment on GzMultiPartCharacter_GetLimbComponentByBone");
static_assert(sizeof(GzMultiPartCharacter_GetLimbComponentByBone) == 0x000010, "Wrong size on GzMultiPartCharacter_GetLimbComponentByBone");
static_assert(offsetof(GzMultiPartCharacter_GetLimbComponentByBone, bone) == 0x000000, "Member 'GzMultiPartCharacter_GetLimbComponentByBone::bone' has a wrong offset!");
static_assert(offsetof(GzMultiPartCharacter_GetLimbComponentByBone, ReturnValue) == 0x000008, "Member 'GzMultiPartCharacter_GetLimbComponentByBone::ReturnValue' has a wrong offset!");

// Function G01.GzMultiPartCharacter.GetLimbComponentByPocketId
// 0x0010 (0x0010 - 0x0000)
struct GzMultiPartCharacter_GetLimbComponentByPocketId final
{
public:
	struct FGzInvPocketId                         PocketId;                                          // 0x0000(0x0008)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UGzLimbAbilityComponent*                ReturnValue;                                       // 0x0008(0x0008)(ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzMultiPartCharacter_GetLimbComponentByPocketId) == 0x000008, "Wrong alignment on GzMultiPartCharacter_GetLimbComponentByPocketId");
static_assert(sizeof(GzMultiPartCharacter_GetLimbComponentByPocketId) == 0x000010, "Wrong size on GzMultiPartCharacter_GetLimbComponentByPocketId");
static_assert(offsetof(GzMultiPartCharacter_GetLimbComponentByPocketId, PocketId) == 0x000000, "Member 'GzMultiPartCharacter_GetLimbComponentByPocketId::PocketId' has a wrong offset!");
static_assert(offsetof(GzMultiPartCharacter_GetLimbComponentByPocketId, ReturnValue) == 0x000008, "Member 'GzMultiPartCharacter_GetLimbComponentByPocketId::ReturnValue' has a wrong offset!");

// Function G01.GzMultiPartCharacter.GetLimbHealth
// 0x0008 (0x0008 - 0x0000)
struct GzMultiPartCharacter_GetLimbHealth final
{
public:
	EGzLimbType                                   LimbType;                                          // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2D6A[0x3];                                     // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ReturnValue;                                       // 0x0004(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzMultiPartCharacter_GetLimbHealth) == 0x000004, "Wrong alignment on GzMultiPartCharacter_GetLimbHealth");
static_assert(sizeof(GzMultiPartCharacter_GetLimbHealth) == 0x000008, "Wrong size on GzMultiPartCharacter_GetLimbHealth");
static_assert(offsetof(GzMultiPartCharacter_GetLimbHealth, LimbType) == 0x000000, "Member 'GzMultiPartCharacter_GetLimbHealth::LimbType' has a wrong offset!");
static_assert(offsetof(GzMultiPartCharacter_GetLimbHealth, ReturnValue) == 0x000004, "Member 'GzMultiPartCharacter_GetLimbHealth::ReturnValue' has a wrong offset!");

// Function G01.GzMultiPartCharacter.GetLimbTypeByBone
// 0x000C (0x000C - 0x0000)
struct GzMultiPartCharacter_GetLimbTypeByBone final
{
public:
	class FName                                   bone;                                              // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EGzLimbType                                   ReturnValue;                                       // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2D6B[0x3];                                     // 0x0009(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GzMultiPartCharacter_GetLimbTypeByBone) == 0x000004, "Wrong alignment on GzMultiPartCharacter_GetLimbTypeByBone");
static_assert(sizeof(GzMultiPartCharacter_GetLimbTypeByBone) == 0x00000C, "Wrong size on GzMultiPartCharacter_GetLimbTypeByBone");
static_assert(offsetof(GzMultiPartCharacter_GetLimbTypeByBone, bone) == 0x000000, "Member 'GzMultiPartCharacter_GetLimbTypeByBone::bone' has a wrong offset!");
static_assert(offsetof(GzMultiPartCharacter_GetLimbTypeByBone, ReturnValue) == 0x000008, "Member 'GzMultiPartCharacter_GetLimbTypeByBone::ReturnValue' has a wrong offset!");

// Function G01.GzMultiPartCharacter.GetLoadedLimbComponent
// 0x0010 (0x0010 - 0x0000)
struct GzMultiPartCharacter_GetLoadedLimbComponent final
{
public:
	EGzLimbType                                   Type;                                              // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2D6C[0x7];                                     // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UGzLimbComponent*                       ReturnValue;                                       // 0x0008(0x0008)(ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzMultiPartCharacter_GetLoadedLimbComponent) == 0x000008, "Wrong alignment on GzMultiPartCharacter_GetLoadedLimbComponent");
static_assert(sizeof(GzMultiPartCharacter_GetLoadedLimbComponent) == 0x000010, "Wrong size on GzMultiPartCharacter_GetLoadedLimbComponent");
static_assert(offsetof(GzMultiPartCharacter_GetLoadedLimbComponent, Type) == 0x000000, "Member 'GzMultiPartCharacter_GetLoadedLimbComponent::Type' has a wrong offset!");
static_assert(offsetof(GzMultiPartCharacter_GetLoadedLimbComponent, ReturnValue) == 0x000008, "Member 'GzMultiPartCharacter_GetLoadedLimbComponent::ReturnValue' has a wrong offset!");

// Function G01.GzMultiPartCharacter.GetMultiPartAttributeSet
// 0x0008 (0x0008 - 0x0000)
struct GzMultiPartCharacter_GetMultiPartAttributeSet final
{
public:
	const class UGzMultiPartAttributeSet*         ReturnValue;                                       // 0x0000(0x0008)(ConstParm, ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzMultiPartCharacter_GetMultiPartAttributeSet) == 0x000008, "Wrong alignment on GzMultiPartCharacter_GetMultiPartAttributeSet");
static_assert(sizeof(GzMultiPartCharacter_GetMultiPartAttributeSet) == 0x000008, "Wrong size on GzMultiPartCharacter_GetMultiPartAttributeSet");
static_assert(offsetof(GzMultiPartCharacter_GetMultiPartAttributeSet, ReturnValue) == 0x000000, "Member 'GzMultiPartCharacter_GetMultiPartAttributeSet::ReturnValue' has a wrong offset!");

// Function G01.GzMultiPartCharacter.GetPhysMaterialByDamageArea
// 0x0010 (0x0010 - 0x0000)
struct GzMultiPartCharacter_GetPhysMaterialByDamageArea final
{
public:
	EGzCharacterDamageAreaType                    DamageAreaType;                                    // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2D6D[0x7];                                     // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UPhysicalMaterial*                      ReturnValue;                                       // 0x0008(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzMultiPartCharacter_GetPhysMaterialByDamageArea) == 0x000008, "Wrong alignment on GzMultiPartCharacter_GetPhysMaterialByDamageArea");
static_assert(sizeof(GzMultiPartCharacter_GetPhysMaterialByDamageArea) == 0x000010, "Wrong size on GzMultiPartCharacter_GetPhysMaterialByDamageArea");
static_assert(offsetof(GzMultiPartCharacter_GetPhysMaterialByDamageArea, DamageAreaType) == 0x000000, "Member 'GzMultiPartCharacter_GetPhysMaterialByDamageArea::DamageAreaType' has a wrong offset!");
static_assert(offsetof(GzMultiPartCharacter_GetPhysMaterialByDamageArea, ReturnValue) == 0x000008, "Member 'GzMultiPartCharacter_GetPhysMaterialByDamageArea::ReturnValue' has a wrong offset!");

// Function G01.GzMultiPartCharacter.GetTotalArmorDamageReductionFromLimbs
// 0x0004 (0x0004 - 0x0000)
struct GzMultiPartCharacter_GetTotalArmorDamageReductionFromLimbs final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzMultiPartCharacter_GetTotalArmorDamageReductionFromLimbs) == 0x000004, "Wrong alignment on GzMultiPartCharacter_GetTotalArmorDamageReductionFromLimbs");
static_assert(sizeof(GzMultiPartCharacter_GetTotalArmorDamageReductionFromLimbs) == 0x000004, "Wrong size on GzMultiPartCharacter_GetTotalArmorDamageReductionFromLimbs");
static_assert(offsetof(GzMultiPartCharacter_GetTotalArmorDamageReductionFromLimbs, ReturnValue) == 0x000000, "Member 'GzMultiPartCharacter_GetTotalArmorDamageReductionFromLimbs::ReturnValue' has a wrong offset!");

// Function G01.GzMultiPartCharacter.HasDamageAreaOfType
// 0x0002 (0x0002 - 0x0000)
struct GzMultiPartCharacter_HasDamageAreaOfType final
{
public:
	EGzCharacterDamageAreaType                    Type;                                              // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0001(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzMultiPartCharacter_HasDamageAreaOfType) == 0x000001, "Wrong alignment on GzMultiPartCharacter_HasDamageAreaOfType");
static_assert(sizeof(GzMultiPartCharacter_HasDamageAreaOfType) == 0x000002, "Wrong size on GzMultiPartCharacter_HasDamageAreaOfType");
static_assert(offsetof(GzMultiPartCharacter_HasDamageAreaOfType, Type) == 0x000000, "Member 'GzMultiPartCharacter_HasDamageAreaOfType::Type' has a wrong offset!");
static_assert(offsetof(GzMultiPartCharacter_HasDamageAreaOfType, ReturnValue) == 0x000001, "Member 'GzMultiPartCharacter_HasDamageAreaOfType::ReturnValue' has a wrong offset!");

// Function G01.GzMultiPartCharacter.HasLimbEquipped
// 0x0002 (0x0002 - 0x0000)
struct GzMultiPartCharacter_HasLimbEquipped final
{
public:
	EGzLimbType                                   Type;                                              // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0001(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzMultiPartCharacter_HasLimbEquipped) == 0x000001, "Wrong alignment on GzMultiPartCharacter_HasLimbEquipped");
static_assert(sizeof(GzMultiPartCharacter_HasLimbEquipped) == 0x000002, "Wrong size on GzMultiPartCharacter_HasLimbEquipped");
static_assert(offsetof(GzMultiPartCharacter_HasLimbEquipped, Type) == 0x000000, "Member 'GzMultiPartCharacter_HasLimbEquipped::Type' has a wrong offset!");
static_assert(offsetof(GzMultiPartCharacter_HasLimbEquipped, ReturnValue) == 0x000001, "Member 'GzMultiPartCharacter_HasLimbEquipped::ReturnValue' has a wrong offset!");

// Function G01.GzMultiPartCharacter.HasLimbLoaded
// 0x0002 (0x0002 - 0x0000)
struct GzMultiPartCharacter_HasLimbLoaded final
{
public:
	EGzLimbType                                   Type;                                              // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0001(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzMultiPartCharacter_HasLimbLoaded) == 0x000001, "Wrong alignment on GzMultiPartCharacter_HasLimbLoaded");
static_assert(sizeof(GzMultiPartCharacter_HasLimbLoaded) == 0x000002, "Wrong size on GzMultiPartCharacter_HasLimbLoaded");
static_assert(offsetof(GzMultiPartCharacter_HasLimbLoaded, Type) == 0x000000, "Member 'GzMultiPartCharacter_HasLimbLoaded::Type' has a wrong offset!");
static_assert(offsetof(GzMultiPartCharacter_HasLimbLoaded, ReturnValue) == 0x000001, "Member 'GzMultiPartCharacter_HasLimbLoaded::ReturnValue' has a wrong offset!");

// Function G01.GzMultiPartCharacter.IsSwitchingLimb
// 0x0001 (0x0001 - 0x0000)
struct GzMultiPartCharacter_IsSwitchingLimb final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzMultiPartCharacter_IsSwitchingLimb) == 0x000001, "Wrong alignment on GzMultiPartCharacter_IsSwitchingLimb");
static_assert(sizeof(GzMultiPartCharacter_IsSwitchingLimb) == 0x000001, "Wrong size on GzMultiPartCharacter_IsSwitchingLimb");
static_assert(offsetof(GzMultiPartCharacter_IsSwitchingLimb, ReturnValue) == 0x000000, "Member 'GzMultiPartCharacter_IsSwitchingLimb::ReturnValue' has a wrong offset!");

// Function G01.GzAICharacter.SetReplicatedCollision
// 0x0001 (0x0001 - 0x0000)
struct GzAICharacter_SetReplicatedCollision final
{
public:
	bool                                          bEnabled;                                          // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzAICharacter_SetReplicatedCollision) == 0x000001, "Wrong alignment on GzAICharacter_SetReplicatedCollision");
static_assert(sizeof(GzAICharacter_SetReplicatedCollision) == 0x000001, "Wrong size on GzAICharacter_SetReplicatedCollision");
static_assert(offsetof(GzAICharacter_SetReplicatedCollision, bEnabled) == 0x000000, "Member 'GzAICharacter_SetReplicatedCollision::bEnabled' has a wrong offset!");

// Function G01.GzAICharacter.LaunchTo
// 0x0018 (0x0018 - 0x0000)
struct GzAICharacter_LaunchTo final
{
public:
	struct FVector                                NavDestination;                                    // 0x0000(0x0018)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzAICharacter_LaunchTo) == 0x000008, "Wrong alignment on GzAICharacter_LaunchTo");
static_assert(sizeof(GzAICharacter_LaunchTo) == 0x000018, "Wrong size on GzAICharacter_LaunchTo");
static_assert(offsetof(GzAICharacter_LaunchTo, NavDestination) == 0x000000, "Member 'GzAICharacter_LaunchTo::NavDestination' has a wrong offset!");

// Function G01.GzAIController.InitializeBehavior
// 0x0008 (0x0008 - 0x0000)
struct GzAIController_InitializeBehavior final
{
public:
	class UBehaviorTree*                          BTree;                                             // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzAIController_InitializeBehavior) == 0x000008, "Wrong alignment on GzAIController_InitializeBehavior");
static_assert(sizeof(GzAIController_InitializeBehavior) == 0x000008, "Wrong size on GzAIController_InitializeBehavior");
static_assert(offsetof(GzAIController_InitializeBehavior, BTree) == 0x000000, "Member 'GzAIController_InitializeBehavior::BTree' has a wrong offset!");

// Function G01.GzAIController.LaunchOverObstacle
// 0x0048 (0x0048 - 0x0000)
struct GzAIController_LaunchOverObstacle final
{
public:
	struct FVector                                NavDestination;                                    // 0x0000(0x0018)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                StartEdgeLocation;                                 // 0x0018(0x0018)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                EndEdgeLocation;                                   // 0x0030(0x0018)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzAIController_LaunchOverObstacle) == 0x000008, "Wrong alignment on GzAIController_LaunchOverObstacle");
static_assert(sizeof(GzAIController_LaunchOverObstacle) == 0x000048, "Wrong size on GzAIController_LaunchOverObstacle");
static_assert(offsetof(GzAIController_LaunchOverObstacle, NavDestination) == 0x000000, "Member 'GzAIController_LaunchOverObstacle::NavDestination' has a wrong offset!");
static_assert(offsetof(GzAIController_LaunchOverObstacle, StartEdgeLocation) == 0x000018, "Member 'GzAIController_LaunchOverObstacle::StartEdgeLocation' has a wrong offset!");
static_assert(offsetof(GzAIController_LaunchOverObstacle, EndEdgeLocation) == 0x000030, "Member 'GzAIController_LaunchOverObstacle::EndEdgeLocation' has a wrong offset!");

// Function G01.GzAIController.LaunchTo
// 0x0018 (0x0018 - 0x0000)
struct GzAIController_LaunchTo final
{
public:
	struct FVector                                NavDestination;                                    // 0x0000(0x0018)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzAIController_LaunchTo) == 0x000008, "Wrong alignment on GzAIController_LaunchTo");
static_assert(sizeof(GzAIController_LaunchTo) == 0x000018, "Wrong size on GzAIController_LaunchTo");
static_assert(offsetof(GzAIController_LaunchTo, NavDestination) == 0x000000, "Member 'GzAIController_LaunchTo::NavDestination' has a wrong offset!");

// SparseDelegateFunction G01.GzAIController.OnAIChangeLODEvent_BP__DelegateSignature
// 0x0040 (0x0040 - 0x0000)
struct GzAIController_OnAIChangeLODEvent_BP__DelegateSignature final
{
public:
	struct FGzAILOD                               AILOD;                                             // 0x0000(0x0040)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzAIController_OnAIChangeLODEvent_BP__DelegateSignature) == 0x000008, "Wrong alignment on GzAIController_OnAIChangeLODEvent_BP__DelegateSignature");
static_assert(sizeof(GzAIController_OnAIChangeLODEvent_BP__DelegateSignature) == 0x000040, "Wrong size on GzAIController_OnAIChangeLODEvent_BP__DelegateSignature");
static_assert(offsetof(GzAIController_OnAIChangeLODEvent_BP__DelegateSignature, AILOD) == 0x000000, "Member 'GzAIController_OnAIChangeLODEvent_BP__DelegateSignature::AILOD' has a wrong offset!");

// Function G01.GzAIController.OnCapsuleHitCallback
// 0x0128 (0x0128 - 0x0000)
struct GzAIController_OnCapsuleHitCallback final
{
public:
	class UPrimitiveComponent*                    HitComponent;                                      // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 OtherActor;                                        // 0x0008(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UPrimitiveComponent*                    OtherComp;                                         // 0x0010(0x0008)(Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                NormalImpulse;                                     // 0x0018(0x0018)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FHitResult                             Hit;                                               // 0x0030(0x00F8)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzAIController_OnCapsuleHitCallback) == 0x000008, "Wrong alignment on GzAIController_OnCapsuleHitCallback");
static_assert(sizeof(GzAIController_OnCapsuleHitCallback) == 0x000128, "Wrong size on GzAIController_OnCapsuleHitCallback");
static_assert(offsetof(GzAIController_OnCapsuleHitCallback, HitComponent) == 0x000000, "Member 'GzAIController_OnCapsuleHitCallback::HitComponent' has a wrong offset!");
static_assert(offsetof(GzAIController_OnCapsuleHitCallback, OtherActor) == 0x000008, "Member 'GzAIController_OnCapsuleHitCallback::OtherActor' has a wrong offset!");
static_assert(offsetof(GzAIController_OnCapsuleHitCallback, OtherComp) == 0x000010, "Member 'GzAIController_OnCapsuleHitCallback::OtherComp' has a wrong offset!");
static_assert(offsetof(GzAIController_OnCapsuleHitCallback, NormalImpulse) == 0x000018, "Member 'GzAIController_OnCapsuleHitCallback::NormalImpulse' has a wrong offset!");
static_assert(offsetof(GzAIController_OnCapsuleHitCallback, Hit) == 0x000030, "Member 'GzAIController_OnCapsuleHitCallback::Hit' has a wrong offset!");

// Function G01.GzAIController.RefillAmmoStock
// 0x0001 (0x0001 - 0x0000)
struct GzAIController_RefillAmmoStock final
{
public:
	bool                                          RefillOneClip;                                     // 0x0000(0x0001)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzAIController_RefillAmmoStock) == 0x000001, "Wrong alignment on GzAIController_RefillAmmoStock");
static_assert(sizeof(GzAIController_RefillAmmoStock) == 0x000001, "Wrong size on GzAIController_RefillAmmoStock");
static_assert(offsetof(GzAIController_RefillAmmoStock, RefillOneClip) == 0x000000, "Member 'GzAIController_RefillAmmoStock::RefillOneClip' has a wrong offset!");

// Function G01.GzAIController.RequestControllerSenseTeamEvent
// 0x0030 (0x0030 - 0x0000)
struct GzAIController_RequestControllerSenseTeamEvent final
{
public:
	class AActor*                                 Target;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                LastLocation;                                      // 0x0008(0x0018)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         EventRange;                                        // 0x0020(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PassedInfoAge;                                     // 0x0024(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InStrength;                                        // 0x0028(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2D75[0x4];                                     // 0x002C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GzAIController_RequestControllerSenseTeamEvent) == 0x000008, "Wrong alignment on GzAIController_RequestControllerSenseTeamEvent");
static_assert(sizeof(GzAIController_RequestControllerSenseTeamEvent) == 0x000030, "Wrong size on GzAIController_RequestControllerSenseTeamEvent");
static_assert(offsetof(GzAIController_RequestControllerSenseTeamEvent, Target) == 0x000000, "Member 'GzAIController_RequestControllerSenseTeamEvent::Target' has a wrong offset!");
static_assert(offsetof(GzAIController_RequestControllerSenseTeamEvent, LastLocation) == 0x000008, "Member 'GzAIController_RequestControllerSenseTeamEvent::LastLocation' has a wrong offset!");
static_assert(offsetof(GzAIController_RequestControllerSenseTeamEvent, EventRange) == 0x000020, "Member 'GzAIController_RequestControllerSenseTeamEvent::EventRange' has a wrong offset!");
static_assert(offsetof(GzAIController_RequestControllerSenseTeamEvent, PassedInfoAge) == 0x000024, "Member 'GzAIController_RequestControllerSenseTeamEvent::PassedInfoAge' has a wrong offset!");
static_assert(offsetof(GzAIController_RequestControllerSenseTeamEvent, InStrength) == 0x000028, "Member 'GzAIController_RequestControllerSenseTeamEvent::InStrength' has a wrong offset!");

// Function G01.GzAIController.SetCurrentActionState
// 0x0001 (0x0001 - 0x0000)
struct GzAIController_SetCurrentActionState final
{
public:
	EGzNpcActionStates                            ActionStateRef;                                    // 0x0000(0x0001)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzAIController_SetCurrentActionState) == 0x000001, "Wrong alignment on GzAIController_SetCurrentActionState");
static_assert(sizeof(GzAIController_SetCurrentActionState) == 0x000001, "Wrong size on GzAIController_SetCurrentActionState");
static_assert(offsetof(GzAIController_SetCurrentActionState, ActionStateRef) == 0x000000, "Member 'GzAIController_SetCurrentActionState::ActionStateRef' has a wrong offset!");

// Function G01.GzAIController.SetCurrentMentalState
// 0x0001 (0x0001 - 0x0000)
struct GzAIController_SetCurrentMentalState final
{
public:
	EGzMentalState                                MentalStateRef;                                    // 0x0000(0x0001)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzAIController_SetCurrentMentalState) == 0x000001, "Wrong alignment on GzAIController_SetCurrentMentalState");
static_assert(sizeof(GzAIController_SetCurrentMentalState) == 0x000001, "Wrong size on GzAIController_SetCurrentMentalState");
static_assert(offsetof(GzAIController_SetCurrentMentalState, MentalStateRef) == 0x000000, "Member 'GzAIController_SetCurrentMentalState::MentalStateRef' has a wrong offset!");

// Function G01.GzAIController.SetCurrentMentalStateTime
// 0x0004 (0x0004 - 0x0000)
struct GzAIController_SetCurrentMentalStateTime final
{
public:
	float                                         MentalStateTimeRef;                                // 0x0000(0x0004)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzAIController_SetCurrentMentalStateTime) == 0x000004, "Wrong alignment on GzAIController_SetCurrentMentalStateTime");
static_assert(sizeof(GzAIController_SetCurrentMentalStateTime) == 0x000004, "Wrong size on GzAIController_SetCurrentMentalStateTime");
static_assert(offsetof(GzAIController_SetCurrentMentalStateTime, MentalStateTimeRef) == 0x000000, "Member 'GzAIController_SetCurrentMentalStateTime::MentalStateTimeRef' has a wrong offset!");

// Function G01.GzAIController.SetFocusTargetBodyPartsOffset
// 0x0028 (0x0028 - 0x0000)
struct GzAIController_SetFocusTargetBodyPartsOffset final
{
public:
	class AActor*                                 FocusActor;                                        // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EGzCharacterDamageAreaType                    DamageAreaType;                                    // 0x0008(0x0001)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2D76[0x7];                                     // 0x0009(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                Offset;                                            // 0x0010(0x0018)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzAIController_SetFocusTargetBodyPartsOffset) == 0x000008, "Wrong alignment on GzAIController_SetFocusTargetBodyPartsOffset");
static_assert(sizeof(GzAIController_SetFocusTargetBodyPartsOffset) == 0x000028, "Wrong size on GzAIController_SetFocusTargetBodyPartsOffset");
static_assert(offsetof(GzAIController_SetFocusTargetBodyPartsOffset, FocusActor) == 0x000000, "Member 'GzAIController_SetFocusTargetBodyPartsOffset::FocusActor' has a wrong offset!");
static_assert(offsetof(GzAIController_SetFocusTargetBodyPartsOffset, DamageAreaType) == 0x000008, "Member 'GzAIController_SetFocusTargetBodyPartsOffset::DamageAreaType' has a wrong offset!");
static_assert(offsetof(GzAIController_SetFocusTargetBodyPartsOffset, Offset) == 0x000010, "Member 'GzAIController_SetFocusTargetBodyPartsOffset::Offset' has a wrong offset!");

// Function G01.GzAIController.SetTargetNonVisibleBodyParts
// 0x0010 (0x0010 - 0x0000)
struct GzAIController_SetTargetNonVisibleBodyParts final
{
public:
	TArray<EGzCharacterDamageAreaType>            InNonVisibleParts;                                 // 0x0000(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzAIController_SetTargetNonVisibleBodyParts) == 0x000008, "Wrong alignment on GzAIController_SetTargetNonVisibleBodyParts");
static_assert(sizeof(GzAIController_SetTargetNonVisibleBodyParts) == 0x000010, "Wrong size on GzAIController_SetTargetNonVisibleBodyParts");
static_assert(offsetof(GzAIController_SetTargetNonVisibleBodyParts, InNonVisibleParts) == 0x000000, "Member 'GzAIController_SetTargetNonVisibleBodyParts::InNonVisibleParts' has a wrong offset!");

// Function G01.GzAIController.SetTargetVisibleBodyPart
// 0x0001 (0x0001 - 0x0000)
struct GzAIController_SetTargetVisibleBodyPart final
{
public:
	EGzCharacterDamageAreaType                    InVisibleParts;                                    // 0x0000(0x0001)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzAIController_SetTargetVisibleBodyPart) == 0x000001, "Wrong alignment on GzAIController_SetTargetVisibleBodyPart");
static_assert(sizeof(GzAIController_SetTargetVisibleBodyPart) == 0x000001, "Wrong size on GzAIController_SetTargetVisibleBodyPart");
static_assert(offsetof(GzAIController_SetTargetVisibleBodyPart, InVisibleParts) == 0x000000, "Member 'GzAIController_SetTargetVisibleBodyPart::InVisibleParts' has a wrong offset!");

// Function G01.GzAIController.SetZoneControl
// 0x0038 (0x0038 - 0x0000)
struct GzAIController_SetZoneControl final
{
public:
	struct FBox                                   InValue;                                           // 0x0000(0x0038)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzAIController_SetZoneControl) == 0x000008, "Wrong alignment on GzAIController_SetZoneControl");
static_assert(sizeof(GzAIController_SetZoneControl) == 0x000038, "Wrong size on GzAIController_SetZoneControl");
static_assert(offsetof(GzAIController_SetZoneControl, InValue) == 0x000000, "Member 'GzAIController_SetZoneControl::InValue' has a wrong offset!");

// Function G01.GzAIController.GetActorLastStimulusLocation
// 0x0028 (0x0028 - 0x0000)
struct GzAIController_GetActorLastStimulusLocation final
{
public:
	const class AActor*                           Actor;                                             // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                OutLoc;                                            // 0x0008(0x0018)(Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0020(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2D77[0x7];                                     // 0x0021(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GzAIController_GetActorLastStimulusLocation) == 0x000008, "Wrong alignment on GzAIController_GetActorLastStimulusLocation");
static_assert(sizeof(GzAIController_GetActorLastStimulusLocation) == 0x000028, "Wrong size on GzAIController_GetActorLastStimulusLocation");
static_assert(offsetof(GzAIController_GetActorLastStimulusLocation, Actor) == 0x000000, "Member 'GzAIController_GetActorLastStimulusLocation::Actor' has a wrong offset!");
static_assert(offsetof(GzAIController_GetActorLastStimulusLocation, OutLoc) == 0x000008, "Member 'GzAIController_GetActorLastStimulusLocation::OutLoc' has a wrong offset!");
static_assert(offsetof(GzAIController_GetActorLastStimulusLocation, ReturnValue) == 0x000020, "Member 'GzAIController_GetActorLastStimulusLocation::ReturnValue' has a wrong offset!");

// Function G01.GzAIController.GetAIProcessTargetComponent
// 0x0008 (0x0008 - 0x0000)
struct GzAIController_GetAIProcessTargetComponent final
{
public:
	class UGzAIProcessTargetComponent*            ReturnValue;                                       // 0x0000(0x0008)(ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzAIController_GetAIProcessTargetComponent) == 0x000008, "Wrong alignment on GzAIController_GetAIProcessTargetComponent");
static_assert(sizeof(GzAIController_GetAIProcessTargetComponent) == 0x000008, "Wrong size on GzAIController_GetAIProcessTargetComponent");
static_assert(offsetof(GzAIController_GetAIProcessTargetComponent, ReturnValue) == 0x000000, "Member 'GzAIController_GetAIProcessTargetComponent::ReturnValue' has a wrong offset!");

// Function G01.GzAIController.GetAIVoiceComponent
// 0x0008 (0x0008 - 0x0000)
struct GzAIController_GetAIVoiceComponent final
{
public:
	class UGzAIVoiceComponent*                    ReturnValue;                                       // 0x0000(0x0008)(ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzAIController_GetAIVoiceComponent) == 0x000008, "Wrong alignment on GzAIController_GetAIVoiceComponent");
static_assert(sizeof(GzAIController_GetAIVoiceComponent) == 0x000008, "Wrong size on GzAIController_GetAIVoiceComponent");
static_assert(offsetof(GzAIController_GetAIVoiceComponent, ReturnValue) == 0x000000, "Member 'GzAIController_GetAIVoiceComponent::ReturnValue' has a wrong offset!");

// Function G01.GzAIController.GetBlockSightSenseTags
// 0x0020 (0x0020 - 0x0000)
struct GzAIController_GetBlockSightSenseTags final
{
public:
	struct FGameplayTagContainer                  ReturnValue;                                       // 0x0000(0x0020)(ConstParm, Parm, OutParm, ReturnParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzAIController_GetBlockSightSenseTags) == 0x000008, "Wrong alignment on GzAIController_GetBlockSightSenseTags");
static_assert(sizeof(GzAIController_GetBlockSightSenseTags) == 0x000020, "Wrong size on GzAIController_GetBlockSightSenseTags");
static_assert(offsetof(GzAIController_GetBlockSightSenseTags, ReturnValue) == 0x000000, "Member 'GzAIController_GetBlockSightSenseTags::ReturnValue' has a wrong offset!");

// Function G01.GzAIController.GetCurrentActionState
// 0x0001 (0x0001 - 0x0000)
struct GzAIController_GetCurrentActionState final
{
public:
	EGzNpcActionStates                            ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzAIController_GetCurrentActionState) == 0x000001, "Wrong alignment on GzAIController_GetCurrentActionState");
static_assert(sizeof(GzAIController_GetCurrentActionState) == 0x000001, "Wrong size on GzAIController_GetCurrentActionState");
static_assert(offsetof(GzAIController_GetCurrentActionState, ReturnValue) == 0x000000, "Member 'GzAIController_GetCurrentActionState::ReturnValue' has a wrong offset!");

// Function G01.GzAIController.GetCurrentMentalState
// 0x0001 (0x0001 - 0x0000)
struct GzAIController_GetCurrentMentalState final
{
public:
	EGzMentalState                                ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzAIController_GetCurrentMentalState) == 0x000001, "Wrong alignment on GzAIController_GetCurrentMentalState");
static_assert(sizeof(GzAIController_GetCurrentMentalState) == 0x000001, "Wrong size on GzAIController_GetCurrentMentalState");
static_assert(offsetof(GzAIController_GetCurrentMentalState, ReturnValue) == 0x000000, "Member 'GzAIController_GetCurrentMentalState::ReturnValue' has a wrong offset!");

// Function G01.GzAIController.GetCurrentMentalStateTime
// 0x0004 (0x0004 - 0x0000)
struct GzAIController_GetCurrentMentalStateTime final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzAIController_GetCurrentMentalStateTime) == 0x000004, "Wrong alignment on GzAIController_GetCurrentMentalStateTime");
static_assert(sizeof(GzAIController_GetCurrentMentalStateTime) == 0x000004, "Wrong size on GzAIController_GetCurrentMentalStateTime");
static_assert(offsetof(GzAIController_GetCurrentMentalStateTime, ReturnValue) == 0x000000, "Member 'GzAIController_GetCurrentMentalStateTime::ReturnValue' has a wrong offset!");

// Function G01.GzAIController.GetOwningGameplayAITag
// 0x0008 (0x0008 - 0x0000)
struct GzAIController_GetOwningGameplayAITag final
{
public:
	struct FGameplayTag                           ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzAIController_GetOwningGameplayAITag) == 0x000004, "Wrong alignment on GzAIController_GetOwningGameplayAITag");
static_assert(sizeof(GzAIController_GetOwningGameplayAITag) == 0x000008, "Wrong size on GzAIController_GetOwningGameplayAITag");
static_assert(offsetof(GzAIController_GetOwningGameplayAITag, ReturnValue) == 0x000000, "Member 'GzAIController_GetOwningGameplayAITag::ReturnValue' has a wrong offset!");

// Function G01.GzAIController.GetSenseConfigDamage
// 0x0008 (0x0008 - 0x0000)
struct GzAIController_GetSenseConfigDamage final
{
public:
	class UAISenseConfig_Damage*                  ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzAIController_GetSenseConfigDamage) == 0x000008, "Wrong alignment on GzAIController_GetSenseConfigDamage");
static_assert(sizeof(GzAIController_GetSenseConfigDamage) == 0x000008, "Wrong size on GzAIController_GetSenseConfigDamage");
static_assert(offsetof(GzAIController_GetSenseConfigDamage, ReturnValue) == 0x000000, "Member 'GzAIController_GetSenseConfigDamage::ReturnValue' has a wrong offset!");

// Function G01.GzAIController.GetSenseConfigHearing
// 0x0008 (0x0008 - 0x0000)
struct GzAIController_GetSenseConfigHearing final
{
public:
	class UAISenseConfig_Hearing*                 ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzAIController_GetSenseConfigHearing) == 0x000008, "Wrong alignment on GzAIController_GetSenseConfigHearing");
static_assert(sizeof(GzAIController_GetSenseConfigHearing) == 0x000008, "Wrong size on GzAIController_GetSenseConfigHearing");
static_assert(offsetof(GzAIController_GetSenseConfigHearing, ReturnValue) == 0x000000, "Member 'GzAIController_GetSenseConfigHearing::ReturnValue' has a wrong offset!");

// Function G01.GzAIController.GetSenseConfigPrediction
// 0x0008 (0x0008 - 0x0000)
struct GzAIController_GetSenseConfigPrediction final
{
public:
	class UAISenseConfig_Prediction*              ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzAIController_GetSenseConfigPrediction) == 0x000008, "Wrong alignment on GzAIController_GetSenseConfigPrediction");
static_assert(sizeof(GzAIController_GetSenseConfigPrediction) == 0x000008, "Wrong size on GzAIController_GetSenseConfigPrediction");
static_assert(offsetof(GzAIController_GetSenseConfigPrediction, ReturnValue) == 0x000000, "Member 'GzAIController_GetSenseConfigPrediction::ReturnValue' has a wrong offset!");

// Function G01.GzAIController.GetSenseConfigSight
// 0x0008 (0x0008 - 0x0000)
struct GzAIController_GetSenseConfigSight final
{
public:
	class UAISenseConfig_Sight*                   ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzAIController_GetSenseConfigSight) == 0x000008, "Wrong alignment on GzAIController_GetSenseConfigSight");
static_assert(sizeof(GzAIController_GetSenseConfigSight) == 0x000008, "Wrong size on GzAIController_GetSenseConfigSight");
static_assert(offsetof(GzAIController_GetSenseConfigSight, ReturnValue) == 0x000000, "Member 'GzAIController_GetSenseConfigSight::ReturnValue' has a wrong offset!");

// Function G01.GzAIController.GetSenseConfigTeam
// 0x0008 (0x0008 - 0x0000)
struct GzAIController_GetSenseConfigTeam final
{
public:
	class UAISenseConfig_Team*                    ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzAIController_GetSenseConfigTeam) == 0x000008, "Wrong alignment on GzAIController_GetSenseConfigTeam");
static_assert(sizeof(GzAIController_GetSenseConfigTeam) == 0x000008, "Wrong size on GzAIController_GetSenseConfigTeam");
static_assert(offsetof(GzAIController_GetSenseConfigTeam, ReturnValue) == 0x000000, "Member 'GzAIController_GetSenseConfigTeam::ReturnValue' has a wrong offset!");

// Function G01.GzAIController.GetSenseConfigTouch
// 0x0008 (0x0008 - 0x0000)
struct GzAIController_GetSenseConfigTouch final
{
public:
	class UAISenseConfig_Touch*                   ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzAIController_GetSenseConfigTouch) == 0x000008, "Wrong alignment on GzAIController_GetSenseConfigTouch");
static_assert(sizeof(GzAIController_GetSenseConfigTouch) == 0x000008, "Wrong size on GzAIController_GetSenseConfigTouch");
static_assert(offsetof(GzAIController_GetSenseConfigTouch, ReturnValue) == 0x000000, "Member 'GzAIController_GetSenseConfigTouch::ReturnValue' has a wrong offset!");

// Function G01.GzAIController.GetTargetNonVisibleBodyParts
// 0x0010 (0x0010 - 0x0000)
struct GzAIController_GetTargetNonVisibleBodyParts final
{
public:
	TArray<EGzCharacterDamageAreaType>            ReturnValue;                                       // 0x0000(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzAIController_GetTargetNonVisibleBodyParts) == 0x000008, "Wrong alignment on GzAIController_GetTargetNonVisibleBodyParts");
static_assert(sizeof(GzAIController_GetTargetNonVisibleBodyParts) == 0x000010, "Wrong size on GzAIController_GetTargetNonVisibleBodyParts");
static_assert(offsetof(GzAIController_GetTargetNonVisibleBodyParts, ReturnValue) == 0x000000, "Member 'GzAIController_GetTargetNonVisibleBodyParts::ReturnValue' has a wrong offset!");

// Function G01.GzAIController.GetTargetVisibleBodyPart
// 0x0001 (0x0001 - 0x0000)
struct GzAIController_GetTargetVisibleBodyPart final
{
public:
	EGzCharacterDamageAreaType                    ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzAIController_GetTargetVisibleBodyPart) == 0x000001, "Wrong alignment on GzAIController_GetTargetVisibleBodyPart");
static_assert(sizeof(GzAIController_GetTargetVisibleBodyPart) == 0x000001, "Wrong size on GzAIController_GetTargetVisibleBodyPart");
static_assert(offsetof(GzAIController_GetTargetVisibleBodyPart, ReturnValue) == 0x000000, "Member 'GzAIController_GetTargetVisibleBodyPart::ReturnValue' has a wrong offset!");

// Function G01.GzAIController.GetZoneControl
// 0x0038 (0x0038 - 0x0000)
struct GzAIController_GetZoneControl final
{
public:
	struct FBox                                   ReturnValue;                                       // 0x0000(0x0038)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzAIController_GetZoneControl) == 0x000008, "Wrong alignment on GzAIController_GetZoneControl");
static_assert(sizeof(GzAIController_GetZoneControl) == 0x000038, "Wrong size on GzAIController_GetZoneControl");
static_assert(offsetof(GzAIController_GetZoneControl, ReturnValue) == 0x000000, "Member 'GzAIController_GetZoneControl::ReturnValue' has a wrong offset!");

// Function G01.GzAIController.HasActiveDamageStimulus
// 0x0010 (0x0010 - 0x0000)
struct GzAIController_HasActiveDamageStimulus final
{
public:
	class AActor*                                 ActorPtr;                                          // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2D78[0x7];                                     // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GzAIController_HasActiveDamageStimulus) == 0x000008, "Wrong alignment on GzAIController_HasActiveDamageStimulus");
static_assert(sizeof(GzAIController_HasActiveDamageStimulus) == 0x000010, "Wrong size on GzAIController_HasActiveDamageStimulus");
static_assert(offsetof(GzAIController_HasActiveDamageStimulus, ActorPtr) == 0x000000, "Member 'GzAIController_HasActiveDamageStimulus::ActorPtr' has a wrong offset!");
static_assert(offsetof(GzAIController_HasActiveDamageStimulus, ReturnValue) == 0x000008, "Member 'GzAIController_HasActiveDamageStimulus::ReturnValue' has a wrong offset!");

// Function G01.GzAIController.HasActiveSightSenseStimulus
// 0x0010 (0x0010 - 0x0000)
struct GzAIController_HasActiveSightSenseStimulus final
{
public:
	class AActor*                                 ActorPtr;                                          // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2D79[0x7];                                     // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GzAIController_HasActiveSightSenseStimulus) == 0x000008, "Wrong alignment on GzAIController_HasActiveSightSenseStimulus");
static_assert(sizeof(GzAIController_HasActiveSightSenseStimulus) == 0x000010, "Wrong size on GzAIController_HasActiveSightSenseStimulus");
static_assert(offsetof(GzAIController_HasActiveSightSenseStimulus, ActorPtr) == 0x000000, "Member 'GzAIController_HasActiveSightSenseStimulus::ActorPtr' has a wrong offset!");
static_assert(offsetof(GzAIController_HasActiveSightSenseStimulus, ReturnValue) == 0x000008, "Member 'GzAIController_HasActiveSightSenseStimulus::ReturnValue' has a wrong offset!");

// Function G01.GzAIController.HasAnyCurrentStimulus
// 0x0010 (0x0010 - 0x0000)
struct GzAIController_HasAnyCurrentStimulus final
{
public:
	class AActor*                                 ActorPtr;                                          // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2D7A[0x7];                                     // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GzAIController_HasAnyCurrentStimulus) == 0x000008, "Wrong alignment on GzAIController_HasAnyCurrentStimulus");
static_assert(sizeof(GzAIController_HasAnyCurrentStimulus) == 0x000010, "Wrong size on GzAIController_HasAnyCurrentStimulus");
static_assert(offsetof(GzAIController_HasAnyCurrentStimulus, ActorPtr) == 0x000000, "Member 'GzAIController_HasAnyCurrentStimulus::ActorPtr' has a wrong offset!");
static_assert(offsetof(GzAIController_HasAnyCurrentStimulus, ReturnValue) == 0x000008, "Member 'GzAIController_HasAnyCurrentStimulus::ReturnValue' has a wrong offset!");

// Function G01.GzAIController.HasZoneControl
// 0x0001 (0x0001 - 0x0000)
struct GzAIController_HasZoneControl final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzAIController_HasZoneControl) == 0x000001, "Wrong alignment on GzAIController_HasZoneControl");
static_assert(sizeof(GzAIController_HasZoneControl) == 0x000001, "Wrong size on GzAIController_HasZoneControl");
static_assert(offsetof(GzAIController_HasZoneControl, ReturnValue) == 0x000000, "Member 'GzAIController_HasZoneControl::ReturnValue' has a wrong offset!");

// Function G01.GzAIController.IsLocationReachable
// 0x0030 (0x0030 - 0x0000)
struct GzAIController_IsLocationReachable final
{
public:
	struct FVector                                Loc;                                               // 0x0000(0x0018)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AcceptanceRadius;                                  // 0x0018(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2D7B[0x4];                                     // 0x001C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UNavigationQueryFilter>     FilterClass;                                       // 0x0020(0x0008)(Parm, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0028(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2D7C[0x7];                                     // 0x0029(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GzAIController_IsLocationReachable) == 0x000008, "Wrong alignment on GzAIController_IsLocationReachable");
static_assert(sizeof(GzAIController_IsLocationReachable) == 0x000030, "Wrong size on GzAIController_IsLocationReachable");
static_assert(offsetof(GzAIController_IsLocationReachable, Loc) == 0x000000, "Member 'GzAIController_IsLocationReachable::Loc' has a wrong offset!");
static_assert(offsetof(GzAIController_IsLocationReachable, AcceptanceRadius) == 0x000018, "Member 'GzAIController_IsLocationReachable::AcceptanceRadius' has a wrong offset!");
static_assert(offsetof(GzAIController_IsLocationReachable, FilterClass) == 0x000020, "Member 'GzAIController_IsLocationReachable::FilterClass' has a wrong offset!");
static_assert(offsetof(GzAIController_IsLocationReachable, ReturnValue) == 0x000028, "Member 'GzAIController_IsLocationReachable::ReturnValue' has a wrong offset!");

// Function G01.GzAIController.IsPointInZoneControl
// 0x0020 (0x0020 - 0x0000)
struct GzAIController_IsPointInZoneControl final
{
public:
	struct FVector                                InValue;                                           // 0x0000(0x0018)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0018(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2D7D[0x7];                                     // 0x0019(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GzAIController_IsPointInZoneControl) == 0x000008, "Wrong alignment on GzAIController_IsPointInZoneControl");
static_assert(sizeof(GzAIController_IsPointInZoneControl) == 0x000020, "Wrong size on GzAIController_IsPointInZoneControl");
static_assert(offsetof(GzAIController_IsPointInZoneControl, InValue) == 0x000000, "Member 'GzAIController_IsPointInZoneControl::InValue' has a wrong offset!");
static_assert(offsetof(GzAIController_IsPointInZoneControl, ReturnValue) == 0x000018, "Member 'GzAIController_IsPointInZoneControl::ReturnValue' has a wrong offset!");

// Function G01.GzAIInfo.OnPawnInactive
// 0x0010 (0x0010 - 0x0000)
struct GzAIInfo_OnPawnInactive final
{
public:
	class AActor*                                 Actor;                                             // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EEndPlayReason                                EndPlayReason;                                     // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2D80[0x7];                                     // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GzAIInfo_OnPawnInactive) == 0x000008, "Wrong alignment on GzAIInfo_OnPawnInactive");
static_assert(sizeof(GzAIInfo_OnPawnInactive) == 0x000010, "Wrong size on GzAIInfo_OnPawnInactive");
static_assert(offsetof(GzAIInfo_OnPawnInactive, Actor) == 0x000000, "Member 'GzAIInfo_OnPawnInactive::Actor' has a wrong offset!");
static_assert(offsetof(GzAIInfo_OnPawnInactive, EndPlayReason) == 0x000008, "Member 'GzAIInfo_OnPawnInactive::EndPlayReason' has a wrong offset!");

// Function G01.GzAIInfo.SetInactive
// 0x0001 (0x0001 - 0x0000)
struct GzAIInfo_SetInactive final
{
public:
	bool                                          Value;                                             // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzAIInfo_SetInactive) == 0x000001, "Wrong alignment on GzAIInfo_SetInactive");
static_assert(sizeof(GzAIInfo_SetInactive) == 0x000001, "Wrong size on GzAIInfo_SetInactive");
static_assert(offsetof(GzAIInfo_SetInactive, Value) == 0x000000, "Member 'GzAIInfo_SetInactive::Value' has a wrong offset!");

// Function G01.GzAIInfo.SetName
// 0x0010 (0x0010 - 0x0000)
struct GzAIInfo_SetName final
{
public:
	class FString                                 InName;                                            // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzAIInfo_SetName) == 0x000008, "Wrong alignment on GzAIInfo_SetName");
static_assert(sizeof(GzAIInfo_SetName) == 0x000010, "Wrong size on GzAIInfo_SetName");
static_assert(offsetof(GzAIInfo_SetName, InName) == 0x000000, "Member 'GzAIInfo_SetName::InName' has a wrong offset!");

// Function G01.GzAIInfo.GetAILODId
// 0x0001 (0x0001 - 0x0000)
struct GzAIInfo_GetAILODId final
{
public:
	uint8                                         ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzAIInfo_GetAILODId) == 0x000001, "Wrong alignment on GzAIInfo_GetAILODId");
static_assert(sizeof(GzAIInfo_GetAILODId) == 0x000001, "Wrong size on GzAIInfo_GetAILODId");
static_assert(offsetof(GzAIInfo_GetAILODId, ReturnValue) == 0x000000, "Member 'GzAIInfo_GetAILODId::ReturnValue' has a wrong offset!");

// Function G01.GzAIInfo.GetId
// 0x0004 (0x0004 - 0x0000)
struct GzAIInfo_GetId final
{
public:
	int32                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzAIInfo_GetId) == 0x000004, "Wrong alignment on GzAIInfo_GetId");
static_assert(sizeof(GzAIInfo_GetId) == 0x000004, "Wrong size on GzAIInfo_GetId");
static_assert(offsetof(GzAIInfo_GetId, ReturnValue) == 0x000000, "Member 'GzAIInfo_GetId::ReturnValue' has a wrong offset!");

// Function G01.GzAIInfo.GetNPCName
// 0x0010 (0x0010 - 0x0000)
struct GzAIInfo_GetNPCName final
{
public:
	class FString                                 ReturnValue;                                       // 0x0000(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzAIInfo_GetNPCName) == 0x000008, "Wrong alignment on GzAIInfo_GetNPCName");
static_assert(sizeof(GzAIInfo_GetNPCName) == 0x000010, "Wrong size on GzAIInfo_GetNPCName");
static_assert(offsetof(GzAIInfo_GetNPCName, ReturnValue) == 0x000000, "Member 'GzAIInfo_GetNPCName::ReturnValue' has a wrong offset!");

// Function G01.GzAIInfo.GetNPCType
// 0x0001 (0x0001 - 0x0000)
struct GzAIInfo_GetNPCType final
{
public:
	ENPCType                                      ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzAIInfo_GetNPCType) == 0x000001, "Wrong alignment on GzAIInfo_GetNPCType");
static_assert(sizeof(GzAIInfo_GetNPCType) == 0x000001, "Wrong size on GzAIInfo_GetNPCType");
static_assert(offsetof(GzAIInfo_GetNPCType, ReturnValue) == 0x000000, "Member 'GzAIInfo_GetNPCType::ReturnValue' has a wrong offset!");

// Function G01.GzAIInfo.GetPawn
// 0x0008 (0x0008 - 0x0000)
struct GzAIInfo_GetPawn final
{
public:
	class APawn*                                  ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzAIInfo_GetPawn) == 0x000008, "Wrong alignment on GzAIInfo_GetPawn");
static_assert(sizeof(GzAIInfo_GetPawn) == 0x000008, "Wrong size on GzAIInfo_GetPawn");
static_assert(offsetof(GzAIInfo_GetPawn, ReturnValue) == 0x000000, "Member 'GzAIInfo_GetPawn::ReturnValue' has a wrong offset!");

// Function G01.GzAIInfo.GetSpawner
// 0x0008 (0x0008 - 0x0000)
struct GzAIInfo_GetSpawner final
{
public:
	class AGzNPCSpawner*                          ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzAIInfo_GetSpawner) == 0x000008, "Wrong alignment on GzAIInfo_GetSpawner");
static_assert(sizeof(GzAIInfo_GetSpawner) == 0x000008, "Wrong size on GzAIInfo_GetSpawner");
static_assert(offsetof(GzAIInfo_GetSpawner, ReturnValue) == 0x000000, "Member 'GzAIInfo_GetSpawner::ReturnValue' has a wrong offset!");

// Function G01.GzAIInfo.GetTeamId
// 0x0004 (0x0004 - 0x0000)
struct GzAIInfo_GetTeamId final
{
public:
	int32                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzAIInfo_GetTeamId) == 0x000004, "Wrong alignment on GzAIInfo_GetTeamId");
static_assert(sizeof(GzAIInfo_GetTeamId) == 0x000004, "Wrong size on GzAIInfo_GetTeamId");
static_assert(offsetof(GzAIInfo_GetTeamId, ReturnValue) == 0x000000, "Member 'GzAIInfo_GetTeamId::ReturnValue' has a wrong offset!");

// Function G01.GzAIInfo.IsAlive
// 0x0001 (0x0001 - 0x0000)
struct GzAIInfo_IsAlive final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzAIInfo_IsAlive) == 0x000001, "Wrong alignment on GzAIInfo_IsAlive");
static_assert(sizeof(GzAIInfo_IsAlive) == 0x000001, "Wrong size on GzAIInfo_IsAlive");
static_assert(offsetof(GzAIInfo_IsAlive, ReturnValue) == 0x000000, "Member 'GzAIInfo_IsAlive::ReturnValue' has a wrong offset!");

// Function G01.GzAIInfo.IsInactive
// 0x0001 (0x0001 - 0x0000)
struct GzAIInfo_IsInactive final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzAIInfo_IsInactive) == 0x000001, "Wrong alignment on GzAIInfo_IsInactive");
static_assert(sizeof(GzAIInfo_IsInactive) == 0x000001, "Wrong size on GzAIInfo_IsInactive");
static_assert(offsetof(GzAIInfo_IsInactive, ReturnValue) == 0x000000, "Member 'GzAIInfo_IsInactive::ReturnValue' has a wrong offset!");

// Function G01.GzXPLogEntryWidget.SetStatName
// 0x0010 (0x0010 - 0x0000)
struct GzXPLogEntryWidget_SetStatName final
{
public:
	class FText                                   Param_Name;                                        // 0x0000(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzXPLogEntryWidget_SetStatName) == 0x000008, "Wrong alignment on GzXPLogEntryWidget_SetStatName");
static_assert(sizeof(GzXPLogEntryWidget_SetStatName) == 0x000010, "Wrong size on GzXPLogEntryWidget_SetStatName");
static_assert(offsetof(GzXPLogEntryWidget_SetStatName, Param_Name) == 0x000000, "Member 'GzXPLogEntryWidget_SetStatName::Param_Name' has a wrong offset!");

// Function G01.GzLootSpawner.GetLocalSocketTransforms
// 0x0010 (0x0010 - 0x0000)
struct GzLootSpawner_GetLocalSocketTransforms final
{
public:
	TArray<struct FTransform>                     ReturnValue;                                       // 0x0000(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzLootSpawner_GetLocalSocketTransforms) == 0x000008, "Wrong alignment on GzLootSpawner_GetLocalSocketTransforms");
static_assert(sizeof(GzLootSpawner_GetLocalSocketTransforms) == 0x000010, "Wrong size on GzLootSpawner_GetLocalSocketTransforms");
static_assert(offsetof(GzLootSpawner_GetLocalSocketTransforms, ReturnValue) == 0x000000, "Member 'GzLootSpawner_GetLocalSocketTransforms::ReturnValue' has a wrong offset!");

// Function G01.GzContainerLootSpawner.OnInteract
// 0x0010 (0x0010 - 0x0000)
struct GzContainerLootSpawner_OnInteract final
{
public:
	class AActor*                                 InteractedBy;                                      // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	const class UGzInteractableComponent*         Interactable;                                      // 0x0008(0x0008)(ConstParm, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzContainerLootSpawner_OnInteract) == 0x000008, "Wrong alignment on GzContainerLootSpawner_OnInteract");
static_assert(sizeof(GzContainerLootSpawner_OnInteract) == 0x000010, "Wrong size on GzContainerLootSpawner_OnInteract");
static_assert(offsetof(GzContainerLootSpawner_OnInteract, InteractedBy) == 0x000000, "Member 'GzContainerLootSpawner_OnInteract::InteractedBy' has a wrong offset!");
static_assert(offsetof(GzContainerLootSpawner_OnInteract, Interactable) == 0x000008, "Member 'GzContainerLootSpawner_OnInteract::Interactable' has a wrong offset!");

// Function G01.GzBaseMarkerContainer.AddMarker
// 0x0008 (0x0008 - 0x0000)
struct GzBaseMarkerContainer_AddMarker final
{
public:
	class UGzMarkerComponent*                     MarkerComponent;                                   // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzBaseMarkerContainer_AddMarker) == 0x000008, "Wrong alignment on GzBaseMarkerContainer_AddMarker");
static_assert(sizeof(GzBaseMarkerContainer_AddMarker) == 0x000008, "Wrong size on GzBaseMarkerContainer_AddMarker");
static_assert(offsetof(GzBaseMarkerContainer_AddMarker, MarkerComponent) == 0x000000, "Member 'GzBaseMarkerContainer_AddMarker::MarkerComponent' has a wrong offset!");

// Function G01.GzBaseMarkerContainer.OnMarkerAdded
// 0x0010 (0x0010 - 0x0000)
struct GzBaseMarkerContainer_OnMarkerAdded final
{
public:
	class UGzMarkerWidget*                        MarkerWidget;                                      // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UGzMarkerComponent*                     MarkerComponent;                                   // 0x0008(0x0008)(Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzBaseMarkerContainer_OnMarkerAdded) == 0x000008, "Wrong alignment on GzBaseMarkerContainer_OnMarkerAdded");
static_assert(sizeof(GzBaseMarkerContainer_OnMarkerAdded) == 0x000010, "Wrong size on GzBaseMarkerContainer_OnMarkerAdded");
static_assert(offsetof(GzBaseMarkerContainer_OnMarkerAdded, MarkerWidget) == 0x000000, "Member 'GzBaseMarkerContainer_OnMarkerAdded::MarkerWidget' has a wrong offset!");
static_assert(offsetof(GzBaseMarkerContainer_OnMarkerAdded, MarkerComponent) == 0x000008, "Member 'GzBaseMarkerContainer_OnMarkerAdded::MarkerComponent' has a wrong offset!");

// Function G01.GzBaseMarkerContainer.OnMarkerRemoved
// 0x0010 (0x0010 - 0x0000)
struct GzBaseMarkerContainer_OnMarkerRemoved final
{
public:
	class UGzMarkerWidget*                        MarkerWidget;                                      // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UGzMarkerComponent*                     MarkerComponent;                                   // 0x0008(0x0008)(Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzBaseMarkerContainer_OnMarkerRemoved) == 0x000008, "Wrong alignment on GzBaseMarkerContainer_OnMarkerRemoved");
static_assert(sizeof(GzBaseMarkerContainer_OnMarkerRemoved) == 0x000010, "Wrong size on GzBaseMarkerContainer_OnMarkerRemoved");
static_assert(offsetof(GzBaseMarkerContainer_OnMarkerRemoved, MarkerWidget) == 0x000000, "Member 'GzBaseMarkerContainer_OnMarkerRemoved::MarkerWidget' has a wrong offset!");
static_assert(offsetof(GzBaseMarkerContainer_OnMarkerRemoved, MarkerComponent) == 0x000008, "Member 'GzBaseMarkerContainer_OnMarkerRemoved::MarkerComponent' has a wrong offset!");

// Function G01.GzBaseMarkerContainer.OnMarkerStateChanged
// 0x0028 (0x0028 - 0x0000)
struct GzBaseMarkerContainer_OnMarkerStateChanged final
{
public:
	class UGzMarkerComponent*                     MarkerComponent;                                   // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTagContainer                  States;                                            // 0x0008(0x0020)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzBaseMarkerContainer_OnMarkerStateChanged) == 0x000008, "Wrong alignment on GzBaseMarkerContainer_OnMarkerStateChanged");
static_assert(sizeof(GzBaseMarkerContainer_OnMarkerStateChanged) == 0x000028, "Wrong size on GzBaseMarkerContainer_OnMarkerStateChanged");
static_assert(offsetof(GzBaseMarkerContainer_OnMarkerStateChanged, MarkerComponent) == 0x000000, "Member 'GzBaseMarkerContainer_OnMarkerStateChanged::MarkerComponent' has a wrong offset!");
static_assert(offsetof(GzBaseMarkerContainer_OnMarkerStateChanged, States) == 0x000008, "Member 'GzBaseMarkerContainer_OnMarkerStateChanged::States' has a wrong offset!");

// Function G01.GzBaseMarkerContainer.OnMarkerWidgetRemove
// 0x0008 (0x0008 - 0x0000)
struct GzBaseMarkerContainer_OnMarkerWidgetRemove final
{
public:
	class UGzMarkerComponent*                     InMarkerComponent;                                 // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzBaseMarkerContainer_OnMarkerWidgetRemove) == 0x000008, "Wrong alignment on GzBaseMarkerContainer_OnMarkerWidgetRemove");
static_assert(sizeof(GzBaseMarkerContainer_OnMarkerWidgetRemove) == 0x000008, "Wrong size on GzBaseMarkerContainer_OnMarkerWidgetRemove");
static_assert(offsetof(GzBaseMarkerContainer_OnMarkerWidgetRemove, InMarkerComponent) == 0x000000, "Member 'GzBaseMarkerContainer_OnMarkerWidgetRemove::InMarkerComponent' has a wrong offset!");

// Function G01.GzBaseMarkerContainer.OnPawnChanged
// 0x0008 (0x0008 - 0x0000)
struct GzBaseMarkerContainer_OnPawnChanged final
{
public:
	class APawn*                                  Pawn;                                              // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzBaseMarkerContainer_OnPawnChanged) == 0x000008, "Wrong alignment on GzBaseMarkerContainer_OnPawnChanged");
static_assert(sizeof(GzBaseMarkerContainer_OnPawnChanged) == 0x000008, "Wrong size on GzBaseMarkerContainer_OnPawnChanged");
static_assert(offsetof(GzBaseMarkerContainer_OnPawnChanged, Pawn) == 0x000000, "Member 'GzBaseMarkerContainer_OnPawnChanged::Pawn' has a wrong offset!");

// Function G01.GzBaseMarkerContainer.RefreshMarker
// 0x0008 (0x0008 - 0x0000)
struct GzBaseMarkerContainer_RefreshMarker final
{
public:
	class UGzMarkerComponent*                     MarkerComponent;                                   // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzBaseMarkerContainer_RefreshMarker) == 0x000008, "Wrong alignment on GzBaseMarkerContainer_RefreshMarker");
static_assert(sizeof(GzBaseMarkerContainer_RefreshMarker) == 0x000008, "Wrong size on GzBaseMarkerContainer_RefreshMarker");
static_assert(offsetof(GzBaseMarkerContainer_RefreshMarker, MarkerComponent) == 0x000000, "Member 'GzBaseMarkerContainer_RefreshMarker::MarkerComponent' has a wrong offset!");

// Function G01.GzBaseMarkerContainer.RemoveMarker
// 0x0008 (0x0008 - 0x0000)
struct GzBaseMarkerContainer_RemoveMarker final
{
public:
	class UGzMarkerComponent*                     MarkerComponent;                                   // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzBaseMarkerContainer_RemoveMarker) == 0x000008, "Wrong alignment on GzBaseMarkerContainer_RemoveMarker");
static_assert(sizeof(GzBaseMarkerContainer_RemoveMarker) == 0x000008, "Wrong size on GzBaseMarkerContainer_RemoveMarker");
static_assert(offsetof(GzBaseMarkerContainer_RemoveMarker, MarkerComponent) == 0x000000, "Member 'GzBaseMarkerContainer_RemoveMarker::MarkerComponent' has a wrong offset!");

// Function G01.GzMapMarkerContainer.RequestPing
// 0x0008 (0x0008 - 0x0000)
struct GzMapMarkerContainer_RequestPing final
{
public:
	struct FGameplayTag                           PingType;                                          // 0x0000(0x0008)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzMapMarkerContainer_RequestPing) == 0x000004, "Wrong alignment on GzMapMarkerContainer_RequestPing");
static_assert(sizeof(GzMapMarkerContainer_RequestPing) == 0x000008, "Wrong size on GzMapMarkerContainer_RequestPing");
static_assert(offsetof(GzMapMarkerContainer_RequestPing, PingType) == 0x000000, "Member 'GzMapMarkerContainer_RequestPing::PingType' has a wrong offset!");

// Function G01.GzAIManager.AddAllAttitudeTeam
// 0x0008 (0x0008 - 0x0000)
struct GzAIManager_AddAllAttitudeTeam final
{
public:
	ENPCTeamAttitude                              NPCTeamAttitude;                                   // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2D95[0x3];                                     // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         TeamID;                                            // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzAIManager_AddAllAttitudeTeam) == 0x000004, "Wrong alignment on GzAIManager_AddAllAttitudeTeam");
static_assert(sizeof(GzAIManager_AddAllAttitudeTeam) == 0x000008, "Wrong size on GzAIManager_AddAllAttitudeTeam");
static_assert(offsetof(GzAIManager_AddAllAttitudeTeam, NPCTeamAttitude) == 0x000000, "Member 'GzAIManager_AddAllAttitudeTeam::NPCTeamAttitude' has a wrong offset!");
static_assert(offsetof(GzAIManager_AddAllAttitudeTeam, TeamID) == 0x000004, "Member 'GzAIManager_AddAllAttitudeTeam::TeamID' has a wrong offset!");

// Function G01.GzAIManager.AddAttitudeTeam
// 0x0010 (0x0010 - 0x0000)
struct GzAIManager_AddAttitudeTeam final
{
public:
	ENPCTeamAttitude                              AttitudeType;                                      // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2D96[0x3];                                     // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         TeamIdA;                                           // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         TeamIdB;                                           // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x000C(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2D97[0x3];                                     // 0x000D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GzAIManager_AddAttitudeTeam) == 0x000004, "Wrong alignment on GzAIManager_AddAttitudeTeam");
static_assert(sizeof(GzAIManager_AddAttitudeTeam) == 0x000010, "Wrong size on GzAIManager_AddAttitudeTeam");
static_assert(offsetof(GzAIManager_AddAttitudeTeam, AttitudeType) == 0x000000, "Member 'GzAIManager_AddAttitudeTeam::AttitudeType' has a wrong offset!");
static_assert(offsetof(GzAIManager_AddAttitudeTeam, TeamIdA) == 0x000004, "Member 'GzAIManager_AddAttitudeTeam::TeamIdA' has a wrong offset!");
static_assert(offsetof(GzAIManager_AddAttitudeTeam, TeamIdB) == 0x000008, "Member 'GzAIManager_AddAttitudeTeam::TeamIdB' has a wrong offset!");
static_assert(offsetof(GzAIManager_AddAttitudeTeam, ReturnValue) == 0x00000C, "Member 'GzAIManager_AddAttitudeTeam::ReturnValue' has a wrong offset!");

// Function G01.GzAIManager.AddFriendTeam
// 0x000C (0x000C - 0x0000)
struct GzAIManager_AddFriendTeam final
{
public:
	int32                                         TeamIdA;                                           // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         TeamIdB;                                           // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2D98[0x3];                                     // 0x0009(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GzAIManager_AddFriendTeam) == 0x000004, "Wrong alignment on GzAIManager_AddFriendTeam");
static_assert(sizeof(GzAIManager_AddFriendTeam) == 0x00000C, "Wrong size on GzAIManager_AddFriendTeam");
static_assert(offsetof(GzAIManager_AddFriendTeam, TeamIdA) == 0x000000, "Member 'GzAIManager_AddFriendTeam::TeamIdA' has a wrong offset!");
static_assert(offsetof(GzAIManager_AddFriendTeam, TeamIdB) == 0x000004, "Member 'GzAIManager_AddFriendTeam::TeamIdB' has a wrong offset!");
static_assert(offsetof(GzAIManager_AddFriendTeam, ReturnValue) == 0x000008, "Member 'GzAIManager_AddFriendTeam::ReturnValue' has a wrong offset!");

// Function G01.GzAIManager.AddHostileTeam
// 0x000C (0x000C - 0x0000)
struct GzAIManager_AddHostileTeam final
{
public:
	int32                                         TeamIdA;                                           // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         TeamIdB;                                           // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2D99[0x3];                                     // 0x0009(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GzAIManager_AddHostileTeam) == 0x000004, "Wrong alignment on GzAIManager_AddHostileTeam");
static_assert(sizeof(GzAIManager_AddHostileTeam) == 0x00000C, "Wrong size on GzAIManager_AddHostileTeam");
static_assert(offsetof(GzAIManager_AddHostileTeam, TeamIdA) == 0x000000, "Member 'GzAIManager_AddHostileTeam::TeamIdA' has a wrong offset!");
static_assert(offsetof(GzAIManager_AddHostileTeam, TeamIdB) == 0x000004, "Member 'GzAIManager_AddHostileTeam::TeamIdB' has a wrong offset!");
static_assert(offsetof(GzAIManager_AddHostileTeam, ReturnValue) == 0x000008, "Member 'GzAIManager_AddHostileTeam::ReturnValue' has a wrong offset!");

// Function G01.GzAIManager.AddNeutralTeam
// 0x000C (0x000C - 0x0000)
struct GzAIManager_AddNeutralTeam final
{
public:
	int32                                         TeamIdA;                                           // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         TeamIdB;                                           // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2D9A[0x3];                                     // 0x0009(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GzAIManager_AddNeutralTeam) == 0x000004, "Wrong alignment on GzAIManager_AddNeutralTeam");
static_assert(sizeof(GzAIManager_AddNeutralTeam) == 0x00000C, "Wrong size on GzAIManager_AddNeutralTeam");
static_assert(offsetof(GzAIManager_AddNeutralTeam, TeamIdA) == 0x000000, "Member 'GzAIManager_AddNeutralTeam::TeamIdA' has a wrong offset!");
static_assert(offsetof(GzAIManager_AddNeutralTeam, TeamIdB) == 0x000004, "Member 'GzAIManager_AddNeutralTeam::TeamIdB' has a wrong offset!");
static_assert(offsetof(GzAIManager_AddNeutralTeam, ReturnValue) == 0x000008, "Member 'GzAIManager_AddNeutralTeam::ReturnValue' has a wrong offset!");

// Function G01.GzAIManager.MakeNPCTeamFriendlyToPlayers
// 0x0004 (0x0004 - 0x0000)
struct GzAIManager_MakeNPCTeamFriendlyToPlayers final
{
public:
	int32                                         NPCTeamId;                                         // 0x0000(0x0004)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzAIManager_MakeNPCTeamFriendlyToPlayers) == 0x000004, "Wrong alignment on GzAIManager_MakeNPCTeamFriendlyToPlayers");
static_assert(sizeof(GzAIManager_MakeNPCTeamFriendlyToPlayers) == 0x000004, "Wrong size on GzAIManager_MakeNPCTeamFriendlyToPlayers");
static_assert(offsetof(GzAIManager_MakeNPCTeamFriendlyToPlayers, NPCTeamId) == 0x000000, "Member 'GzAIManager_MakeNPCTeamFriendlyToPlayers::NPCTeamId' has a wrong offset!");

// Function G01.GzAIManager.RemoveAllAttitudeTeam
// 0x0004 (0x0004 - 0x0000)
struct GzAIManager_RemoveAllAttitudeTeam final
{
public:
	int32                                         TeamID;                                            // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzAIManager_RemoveAllAttitudeTeam) == 0x000004, "Wrong alignment on GzAIManager_RemoveAllAttitudeTeam");
static_assert(sizeof(GzAIManager_RemoveAllAttitudeTeam) == 0x000004, "Wrong size on GzAIManager_RemoveAllAttitudeTeam");
static_assert(offsetof(GzAIManager_RemoveAllAttitudeTeam, TeamID) == 0x000000, "Member 'GzAIManager_RemoveAllAttitudeTeam::TeamID' has a wrong offset!");

// Function G01.GzAIManager.RemoveAttitudeTeam
// 0x000C (0x000C - 0x0000)
struct GzAIManager_RemoveAttitudeTeam final
{
public:
	int32                                         TeamIdA;                                           // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         TeamIdB;                                           // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2D9B[0x3];                                     // 0x0009(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GzAIManager_RemoveAttitudeTeam) == 0x000004, "Wrong alignment on GzAIManager_RemoveAttitudeTeam");
static_assert(sizeof(GzAIManager_RemoveAttitudeTeam) == 0x00000C, "Wrong size on GzAIManager_RemoveAttitudeTeam");
static_assert(offsetof(GzAIManager_RemoveAttitudeTeam, TeamIdA) == 0x000000, "Member 'GzAIManager_RemoveAttitudeTeam::TeamIdA' has a wrong offset!");
static_assert(offsetof(GzAIManager_RemoveAttitudeTeam, TeamIdB) == 0x000004, "Member 'GzAIManager_RemoveAttitudeTeam::TeamIdB' has a wrong offset!");
static_assert(offsetof(GzAIManager_RemoveAttitudeTeam, ReturnValue) == 0x000008, "Member 'GzAIManager_RemoveAttitudeTeam::ReturnValue' has a wrong offset!");

// Function G01.GzAIManager.SetAILODsEnabled
// 0x0001 (0x0001 - 0x0000)
struct GzAIManager_SetAILODsEnabled final
{
public:
	bool                                          bEnabled;                                          // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzAIManager_SetAILODsEnabled) == 0x000001, "Wrong alignment on GzAIManager_SetAILODsEnabled");
static_assert(sizeof(GzAIManager_SetAILODsEnabled) == 0x000001, "Wrong size on GzAIManager_SetAILODsEnabled");
static_assert(offsetof(GzAIManager_SetAILODsEnabled, bEnabled) == 0x000000, "Member 'GzAIManager_SetAILODsEnabled::bEnabled' has a wrong offset!");

// Function G01.GzAIManager.SetSuppressNPCSpawn
// 0x0001 (0x0001 - 0x0000)
struct GzAIManager_SetSuppressNPCSpawn final
{
public:
	bool                                          InValue;                                           // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzAIManager_SetSuppressNPCSpawn) == 0x000001, "Wrong alignment on GzAIManager_SetSuppressNPCSpawn");
static_assert(sizeof(GzAIManager_SetSuppressNPCSpawn) == 0x000001, "Wrong size on GzAIManager_SetSuppressNPCSpawn");
static_assert(offsetof(GzAIManager_SetSuppressNPCSpawn, InValue) == 0x000000, "Member 'GzAIManager_SetSuppressNPCSpawn::InValue' has a wrong offset!");

// Function G01.GzAIManager.GetAIInfoByIndex
// 0x0010 (0x0010 - 0x0000)
struct GzAIManager_GetAIInfoByIndex final
{
public:
	int32                                         Param_Index;                                       // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2D9C[0x4];                                     // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	const class AGzAIInfo*                        ReturnValue;                                       // 0x0008(0x0008)(ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzAIManager_GetAIInfoByIndex) == 0x000008, "Wrong alignment on GzAIManager_GetAIInfoByIndex");
static_assert(sizeof(GzAIManager_GetAIInfoByIndex) == 0x000010, "Wrong size on GzAIManager_GetAIInfoByIndex");
static_assert(offsetof(GzAIManager_GetAIInfoByIndex, Param_Index) == 0x000000, "Member 'GzAIManager_GetAIInfoByIndex::Param_Index' has a wrong offset!");
static_assert(offsetof(GzAIManager_GetAIInfoByIndex, ReturnValue) == 0x000008, "Member 'GzAIManager_GetAIInfoByIndex::ReturnValue' has a wrong offset!");

// Function G01.GzAIManager.GetAudioEvent
// 0x0010 (0x0010 - 0x0000)
struct GzAIManager_GetAudioEvent final
{
public:
	struct FGameplayTag                           AudioTag;                                          // 0x0000(0x0008)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAkAudioEvent*                          ReturnValue;                                       // 0x0008(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzAIManager_GetAudioEvent) == 0x000008, "Wrong alignment on GzAIManager_GetAudioEvent");
static_assert(sizeof(GzAIManager_GetAudioEvent) == 0x000010, "Wrong size on GzAIManager_GetAudioEvent");
static_assert(offsetof(GzAIManager_GetAudioEvent, AudioTag) == 0x000000, "Member 'GzAIManager_GetAudioEvent::AudioTag' has a wrong offset!");
static_assert(offsetof(GzAIManager_GetAudioEvent, ReturnValue) == 0x000008, "Member 'GzAIManager_GetAudioEvent::ReturnValue' has a wrong offset!");

// Function G01.GzAIManager.GetDangerousZones
// 0x0010 (0x0010 - 0x0000)
struct GzAIManager_GetDangerousZones final
{
public:
	TArray<class AGzBattleRoyaleZone*>            ReturnValue;                                       // 0x0000(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzAIManager_GetDangerousZones) == 0x000008, "Wrong alignment on GzAIManager_GetDangerousZones");
static_assert(sizeof(GzAIManager_GetDangerousZones) == 0x000010, "Wrong size on GzAIManager_GetDangerousZones");
static_assert(offsetof(GzAIManager_GetDangerousZones, ReturnValue) == 0x000000, "Member 'GzAIManager_GetDangerousZones::ReturnValue' has a wrong offset!");

// Function G01.GzAIManager.GetFriendlyMembers
// 0x0018 (0x0018 - 0x0000)
struct GzAIManager_GetFriendlyMembers final
{
public:
	int32                                         TeamID;                                            // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2D9D[0x4];                                     // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class APawn*>                          ReturnValue;                                       // 0x0008(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzAIManager_GetFriendlyMembers) == 0x000008, "Wrong alignment on GzAIManager_GetFriendlyMembers");
static_assert(sizeof(GzAIManager_GetFriendlyMembers) == 0x000018, "Wrong size on GzAIManager_GetFriendlyMembers");
static_assert(offsetof(GzAIManager_GetFriendlyMembers, TeamID) == 0x000000, "Member 'GzAIManager_GetFriendlyMembers::TeamID' has a wrong offset!");
static_assert(offsetof(GzAIManager_GetFriendlyMembers, ReturnValue) == 0x000008, "Member 'GzAIManager_GetFriendlyMembers::ReturnValue' has a wrong offset!");

// Function G01.GzAIManager.GetNPCData
// 0x0010 (0x0010 - 0x0000)
struct GzAIManager_GetNPCData final
{
public:
	struct FGameplayTag                           NPCType;                                           // 0x0000(0x0008)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UGzNPCData*                             ReturnValue;                                       // 0x0008(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzAIManager_GetNPCData) == 0x000008, "Wrong alignment on GzAIManager_GetNPCData");
static_assert(sizeof(GzAIManager_GetNPCData) == 0x000010, "Wrong size on GzAIManager_GetNPCData");
static_assert(offsetof(GzAIManager_GetNPCData, NPCType) == 0x000000, "Member 'GzAIManager_GetNPCData::NPCType' has a wrong offset!");
static_assert(offsetof(GzAIManager_GetNPCData, ReturnValue) == 0x000008, "Member 'GzAIManager_GetNPCData::ReturnValue' has a wrong offset!");

// Function G01.GzAIManager.GetNPCTeam
// 0x0010 (0x0010 - 0x0000)
struct GzAIManager_GetNPCTeam final
{
public:
	int32                                         TeamID;                                            // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2D9E[0x4];                                     // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class AGzNPCTeam*                             ReturnValue;                                       // 0x0008(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzAIManager_GetNPCTeam) == 0x000008, "Wrong alignment on GzAIManager_GetNPCTeam");
static_assert(sizeof(GzAIManager_GetNPCTeam) == 0x000010, "Wrong size on GzAIManager_GetNPCTeam");
static_assert(offsetof(GzAIManager_GetNPCTeam, TeamID) == 0x000000, "Member 'GzAIManager_GetNPCTeam::TeamID' has a wrong offset!");
static_assert(offsetof(GzAIManager_GetNPCTeam, ReturnValue) == 0x000008, "Member 'GzAIManager_GetNPCTeam::ReturnValue' has a wrong offset!");

// Function G01.GzAIManager.GetNPCTeamMembers
// 0x0018 (0x0018 - 0x0000)
struct GzAIManager_GetNPCTeamMembers final
{
public:
	int32                                         TeamID;                                            // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2D9F[0x4];                                     // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class APawn*>                          ReturnValue;                                       // 0x0008(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzAIManager_GetNPCTeamMembers) == 0x000008, "Wrong alignment on GzAIManager_GetNPCTeamMembers");
static_assert(sizeof(GzAIManager_GetNPCTeamMembers) == 0x000018, "Wrong size on GzAIManager_GetNPCTeamMembers");
static_assert(offsetof(GzAIManager_GetNPCTeamMembers, TeamID) == 0x000000, "Member 'GzAIManager_GetNPCTeamMembers::TeamID' has a wrong offset!");
static_assert(offsetof(GzAIManager_GetNPCTeamMembers, ReturnValue) == 0x000008, "Member 'GzAIManager_GetNPCTeamMembers::ReturnValue' has a wrong offset!");

// Function G01.GzAIManager.GetNumActiveNPCs
// 0x0004 (0x0004 - 0x0000)
struct GzAIManager_GetNumActiveNPCs final
{
public:
	int32                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzAIManager_GetNumActiveNPCs) == 0x000004, "Wrong alignment on GzAIManager_GetNumActiveNPCs");
static_assert(sizeof(GzAIManager_GetNumActiveNPCs) == 0x000004, "Wrong size on GzAIManager_GetNumActiveNPCs");
static_assert(offsetof(GzAIManager_GetNumActiveNPCs, ReturnValue) == 0x000000, "Member 'GzAIManager_GetNumActiveNPCs::ReturnValue' has a wrong offset!");

// Function G01.GzAIManager.GetNumNPCLOD
// 0x0008 (0x0008 - 0x0000)
struct GzAIManager_GetNumNPCLOD final
{
public:
	uint8                                         LodId;                                             // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2DA0[0x3];                                     // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         ReturnValue;                                       // 0x0004(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzAIManager_GetNumNPCLOD) == 0x000004, "Wrong alignment on GzAIManager_GetNumNPCLOD");
static_assert(sizeof(GzAIManager_GetNumNPCLOD) == 0x000008, "Wrong size on GzAIManager_GetNumNPCLOD");
static_assert(offsetof(GzAIManager_GetNumNPCLOD, LodId) == 0x000000, "Member 'GzAIManager_GetNumNPCLOD::LodId' has a wrong offset!");
static_assert(offsetof(GzAIManager_GetNumNPCLOD, ReturnValue) == 0x000004, "Member 'GzAIManager_GetNumNPCLOD::ReturnValue' has a wrong offset!");

// Function G01.GzAIManager.GetNumNPCs
// 0x0004 (0x0004 - 0x0000)
struct GzAIManager_GetNumNPCs final
{
public:
	int32                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzAIManager_GetNumNPCs) == 0x000004, "Wrong alignment on GzAIManager_GetNumNPCs");
static_assert(sizeof(GzAIManager_GetNumNPCs) == 0x000004, "Wrong size on GzAIManager_GetNumNPCs");
static_assert(offsetof(GzAIManager_GetNumNPCs, ReturnValue) == 0x000000, "Member 'GzAIManager_GetNumNPCs::ReturnValue' has a wrong offset!");

// Function G01.GzAIManager.GetNumNPCTeams
// 0x0004 (0x0004 - 0x0000)
struct GzAIManager_GetNumNPCTeams final
{
public:
	int32                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzAIManager_GetNumNPCTeams) == 0x000004, "Wrong alignment on GzAIManager_GetNumNPCTeams");
static_assert(sizeof(GzAIManager_GetNumNPCTeams) == 0x000004, "Wrong size on GzAIManager_GetNumNPCTeams");
static_assert(offsetof(GzAIManager_GetNumNPCTeams, ReturnValue) == 0x000000, "Member 'GzAIManager_GetNumNPCTeams::ReturnValue' has a wrong offset!");

// Function G01.GzAIManager.GetPredefinedCustomization
// 0x0010 (0x0010 - 0x0000)
struct GzAIManager_GetPredefinedCustomization final
{
public:
	struct FGameplayTag                           CustomizationTag;                                  // 0x0000(0x0008)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UGzCustomizationProfileData*            ReturnValue;                                       // 0x0008(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzAIManager_GetPredefinedCustomization) == 0x000008, "Wrong alignment on GzAIManager_GetPredefinedCustomization");
static_assert(sizeof(GzAIManager_GetPredefinedCustomization) == 0x000010, "Wrong size on GzAIManager_GetPredefinedCustomization");
static_assert(offsetof(GzAIManager_GetPredefinedCustomization, CustomizationTag) == 0x000000, "Member 'GzAIManager_GetPredefinedCustomization::CustomizationTag' has a wrong offset!");
static_assert(offsetof(GzAIManager_GetPredefinedCustomization, ReturnValue) == 0x000008, "Member 'GzAIManager_GetPredefinedCustomization::ReturnValue' has a wrong offset!");

// Function G01.GzAIManager.GetSafeZones
// 0x0010 (0x0010 - 0x0000)
struct GzAIManager_GetSafeZones final
{
public:
	TArray<class AGzBattleRoyaleZone*>            ReturnValue;                                       // 0x0000(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzAIManager_GetSafeZones) == 0x000008, "Wrong alignment on GzAIManager_GetSafeZones");
static_assert(sizeof(GzAIManager_GetSafeZones) == 0x000010, "Wrong size on GzAIManager_GetSafeZones");
static_assert(offsetof(GzAIManager_GetSafeZones, ReturnValue) == 0x000000, "Member 'GzAIManager_GetSafeZones::ReturnValue' has a wrong offset!");

// Function G01.GzAIManager.IsSuppressNPCSpawn
// 0x0001 (0x0001 - 0x0000)
struct GzAIManager_IsSuppressNPCSpawn final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzAIManager_IsSuppressNPCSpawn) == 0x000001, "Wrong alignment on GzAIManager_IsSuppressNPCSpawn");
static_assert(sizeof(GzAIManager_IsSuppressNPCSpawn) == 0x000001, "Wrong size on GzAIManager_IsSuppressNPCSpawn");
static_assert(offsetof(GzAIManager_IsSuppressNPCSpawn, ReturnValue) == 0x000000, "Member 'GzAIManager_IsSuppressNPCSpawn::ReturnValue' has a wrong offset!");

// Function G01.GzAIManager.IsTeamFriends
// 0x000C (0x000C - 0x0000)
struct GzAIManager_IsTeamFriends final
{
public:
	int32                                         NPCTeamId;                                         // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         TeamID;                                            // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2DA1[0x3];                                     // 0x0009(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GzAIManager_IsTeamFriends) == 0x000004, "Wrong alignment on GzAIManager_IsTeamFriends");
static_assert(sizeof(GzAIManager_IsTeamFriends) == 0x00000C, "Wrong size on GzAIManager_IsTeamFriends");
static_assert(offsetof(GzAIManager_IsTeamFriends, NPCTeamId) == 0x000000, "Member 'GzAIManager_IsTeamFriends::NPCTeamId' has a wrong offset!");
static_assert(offsetof(GzAIManager_IsTeamFriends, TeamID) == 0x000004, "Member 'GzAIManager_IsTeamFriends::TeamID' has a wrong offset!");
static_assert(offsetof(GzAIManager_IsTeamFriends, ReturnValue) == 0x000008, "Member 'GzAIManager_IsTeamFriends::ReturnValue' has a wrong offset!");

// Function G01.GzAIManager.IsTeamNeutrals
// 0x000C (0x000C - 0x0000)
struct GzAIManager_IsTeamNeutrals final
{
public:
	int32                                         NPCTeamId;                                         // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         TeamID;                                            // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2DA2[0x3];                                     // 0x0009(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GzAIManager_IsTeamNeutrals) == 0x000004, "Wrong alignment on GzAIManager_IsTeamNeutrals");
static_assert(sizeof(GzAIManager_IsTeamNeutrals) == 0x00000C, "Wrong size on GzAIManager_IsTeamNeutrals");
static_assert(offsetof(GzAIManager_IsTeamNeutrals, NPCTeamId) == 0x000000, "Member 'GzAIManager_IsTeamNeutrals::NPCTeamId' has a wrong offset!");
static_assert(offsetof(GzAIManager_IsTeamNeutrals, TeamID) == 0x000004, "Member 'GzAIManager_IsTeamNeutrals::TeamID' has a wrong offset!");
static_assert(offsetof(GzAIManager_IsTeamNeutrals, ReturnValue) == 0x000008, "Member 'GzAIManager_IsTeamNeutrals::ReturnValue' has a wrong offset!");

// Function G01.GzAimAssistComponent.OnInputMethodChanged
// 0x0001 (0x0001 - 0x0000)
struct GzAimAssistComponent_OnInputMethodChanged final
{
public:
	ECommonInputType                              bNewInputType;                                     // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzAimAssistComponent_OnInputMethodChanged) == 0x000001, "Wrong alignment on GzAimAssistComponent_OnInputMethodChanged");
static_assert(sizeof(GzAimAssistComponent_OnInputMethodChanged) == 0x000001, "Wrong size on GzAimAssistComponent_OnInputMethodChanged");
static_assert(offsetof(GzAimAssistComponent_OnInputMethodChanged, bNewInputType) == 0x000000, "Member 'GzAimAssistComponent_OnInputMethodChanged::bNewInputType' has a wrong offset!");

// Function G01.GzAimAssistComponent.OnOwnerControllerChanged
// 0x0018 (0x0018 - 0x0000)
struct GzAimAssistComponent_OnOwnerControllerChanged final
{
public:
	class APawn*                                  Pawn;                                              // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AController*                            OldController;                                     // 0x0008(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AController*                            NewController;                                     // 0x0010(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzAimAssistComponent_OnOwnerControllerChanged) == 0x000008, "Wrong alignment on GzAimAssistComponent_OnOwnerControllerChanged");
static_assert(sizeof(GzAimAssistComponent_OnOwnerControllerChanged) == 0x000018, "Wrong size on GzAimAssistComponent_OnOwnerControllerChanged");
static_assert(offsetof(GzAimAssistComponent_OnOwnerControllerChanged, Pawn) == 0x000000, "Member 'GzAimAssistComponent_OnOwnerControllerChanged::Pawn' has a wrong offset!");
static_assert(offsetof(GzAimAssistComponent_OnOwnerControllerChanged, OldController) == 0x000008, "Member 'GzAimAssistComponent_OnOwnerControllerChanged::OldController' has a wrong offset!");
static_assert(offsetof(GzAimAssistComponent_OnOwnerControllerChanged, NewController) == 0x000010, "Member 'GzAimAssistComponent_OnOwnerControllerChanged::NewController' has a wrong offset!");

// Function G01.GzAimAssistComponent.OnOwnerTagAdded
// 0x0008 (0x0008 - 0x0000)
struct GzAimAssistComponent_OnOwnerTagAdded final
{
public:
	struct FGameplayTag                           ChangedTag;                                        // 0x0000(0x0008)(Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzAimAssistComponent_OnOwnerTagAdded) == 0x000004, "Wrong alignment on GzAimAssistComponent_OnOwnerTagAdded");
static_assert(sizeof(GzAimAssistComponent_OnOwnerTagAdded) == 0x000008, "Wrong size on GzAimAssistComponent_OnOwnerTagAdded");
static_assert(offsetof(GzAimAssistComponent_OnOwnerTagAdded, ChangedTag) == 0x000000, "Member 'GzAimAssistComponent_OnOwnerTagAdded::ChangedTag' has a wrong offset!");

// Function G01.GzAimAssistComponent.OnOwnerTagRemoved
// 0x0008 (0x0008 - 0x0000)
struct GzAimAssistComponent_OnOwnerTagRemoved final
{
public:
	struct FGameplayTag                           ChangedTag;                                        // 0x0000(0x0008)(Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzAimAssistComponent_OnOwnerTagRemoved) == 0x000004, "Wrong alignment on GzAimAssistComponent_OnOwnerTagRemoved");
static_assert(sizeof(GzAimAssistComponent_OnOwnerTagRemoved) == 0x000008, "Wrong size on GzAimAssistComponent_OnOwnerTagRemoved");
static_assert(offsetof(GzAimAssistComponent_OnOwnerTagRemoved, ChangedTag) == 0x000000, "Member 'GzAimAssistComponent_OnOwnerTagRemoved::ChangedTag' has a wrong offset!");

// Function G01.GzAimAssistComponent.OnWeaponEquipChanged
// 0x0008 (0x0008 - 0x0000)
struct GzAimAssistComponent_OnWeaponEquipChanged final
{
public:
	struct FGzInvPocketId                         PocketId;                                          // 0x0000(0x0008)(Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzAimAssistComponent_OnWeaponEquipChanged) == 0x000004, "Wrong alignment on GzAimAssistComponent_OnWeaponEquipChanged");
static_assert(sizeof(GzAimAssistComponent_OnWeaponEquipChanged) == 0x000008, "Wrong size on GzAimAssistComponent_OnWeaponEquipChanged");
static_assert(offsetof(GzAimAssistComponent_OnWeaponEquipChanged, PocketId) == 0x000000, "Member 'GzAimAssistComponent_OnWeaponEquipChanged::PocketId' has a wrong offset!");

// Function G01.GzHUDBase.OnPawnChanged
// 0x0008 (0x0008 - 0x0000)
struct GzHUDBase_OnPawnChanged final
{
public:
	class APawn*                                  Pawn;                                              // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzHUDBase_OnPawnChanged) == 0x000008, "Wrong alignment on GzHUDBase_OnPawnChanged");
static_assert(sizeof(GzHUDBase_OnPawnChanged) == 0x000008, "Wrong size on GzHUDBase_OnPawnChanged");
static_assert(offsetof(GzHUDBase_OnPawnChanged, Pawn) == 0x000000, "Member 'GzHUDBase_OnPawnChanged::Pawn' has a wrong offset!");

// Function G01.GzHUDBase.OnPlayerControllerInitialized
// 0x0010 (0x0010 - 0x0000)
struct GzHUDBase_OnPlayerControllerInitialized final
{
public:
	class AGzPlayerController*                    PlayerController;                                  // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AGzPlayerState*                         PlayerState;                                       // 0x0008(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzHUDBase_OnPlayerControllerInitialized) == 0x000008, "Wrong alignment on GzHUDBase_OnPlayerControllerInitialized");
static_assert(sizeof(GzHUDBase_OnPlayerControllerInitialized) == 0x000010, "Wrong size on GzHUDBase_OnPlayerControllerInitialized");
static_assert(offsetof(GzHUDBase_OnPlayerControllerInitialized, PlayerController) == 0x000000, "Member 'GzHUDBase_OnPlayerControllerInitialized::PlayerController' has a wrong offset!");
static_assert(offsetof(GzHUDBase_OnPlayerControllerInitialized, PlayerState) == 0x000008, "Member 'GzHUDBase_OnPlayerControllerInitialized::PlayerState' has a wrong offset!");

// Function G01.GzHUDBase.OnPlayerControllerInitialized_BP
// 0x0010 (0x0010 - 0x0000)
struct GzHUDBase_OnPlayerControllerInitialized_BP final
{
public:
	class AGzPlayerController*                    PlayerController;                                  // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AGzPlayerState*                         PlayerState;                                       // 0x0008(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzHUDBase_OnPlayerControllerInitialized_BP) == 0x000008, "Wrong alignment on GzHUDBase_OnPlayerControllerInitialized_BP");
static_assert(sizeof(GzHUDBase_OnPlayerControllerInitialized_BP) == 0x000010, "Wrong size on GzHUDBase_OnPlayerControllerInitialized_BP");
static_assert(offsetof(GzHUDBase_OnPlayerControllerInitialized_BP, PlayerController) == 0x000000, "Member 'GzHUDBase_OnPlayerControllerInitialized_BP::PlayerController' has a wrong offset!");
static_assert(offsetof(GzHUDBase_OnPlayerControllerInitialized_BP, PlayerState) == 0x000008, "Member 'GzHUDBase_OnPlayerControllerInitialized_BP::PlayerState' has a wrong offset!");

// Function G01.GzHUDBase.OnViewTargetPlayerStateRep
// 0x0008 (0x0008 - 0x0000)
struct GzHUDBase_OnViewTargetPlayerStateRep final
{
public:
	class AGzPlayerState*                         PlayerState;                                       // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzHUDBase_OnViewTargetPlayerStateRep) == 0x000008, "Wrong alignment on GzHUDBase_OnViewTargetPlayerStateRep");
static_assert(sizeof(GzHUDBase_OnViewTargetPlayerStateRep) == 0x000008, "Wrong size on GzHUDBase_OnViewTargetPlayerStateRep");
static_assert(offsetof(GzHUDBase_OnViewTargetPlayerStateRep, PlayerState) == 0x000000, "Member 'GzHUDBase_OnViewTargetPlayerStateRep::PlayerState' has a wrong offset!");

// Function G01.GzHUDBase.ReceiveOnPawnChanged
// 0x0008 (0x0008 - 0x0000)
struct GzHUDBase_ReceiveOnPawnChanged final
{
public:
	class APawn*                                  Pawn;                                              // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzHUDBase_ReceiveOnPawnChanged) == 0x000008, "Wrong alignment on GzHUDBase_ReceiveOnPawnChanged");
static_assert(sizeof(GzHUDBase_ReceiveOnPawnChanged) == 0x000008, "Wrong size on GzHUDBase_ReceiveOnPawnChanged");
static_assert(offsetof(GzHUDBase_ReceiveOnPawnChanged, Pawn) == 0x000000, "Member 'GzHUDBase_ReceiveOnPawnChanged::Pawn' has a wrong offset!");

// Function G01.GzHUDBase.GetActiveStageUITags
// 0x0040 (0x0040 - 0x0000)
struct GzHUDBase_GetActiveStageUITags final
{
public:
	struct FGameplayTagContainer                  ActiveStageTags;                                   // 0x0000(0x0020)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	struct FGameplayTagContainer                  ReturnValue;                                       // 0x0020(0x0020)(Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzHUDBase_GetActiveStageUITags) == 0x000008, "Wrong alignment on GzHUDBase_GetActiveStageUITags");
static_assert(sizeof(GzHUDBase_GetActiveStageUITags) == 0x000040, "Wrong size on GzHUDBase_GetActiveStageUITags");
static_assert(offsetof(GzHUDBase_GetActiveStageUITags, ActiveStageTags) == 0x000000, "Member 'GzHUDBase_GetActiveStageUITags::ActiveStageTags' has a wrong offset!");
static_assert(offsetof(GzHUDBase_GetActiveStageUITags, ReturnValue) == 0x000020, "Member 'GzHUDBase_GetActiveStageUITags::ReturnValue' has a wrong offset!");

// Function G01.GzHUDBase.GetView
// 0x0008 (0x0008 - 0x0000)
struct GzHUDBase_GetView final
{
public:
	class UGzHUDView*                             ReturnValue;                                       // 0x0000(0x0008)(ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzHUDBase_GetView) == 0x000008, "Wrong alignment on GzHUDBase_GetView");
static_assert(sizeof(GzHUDBase_GetView) == 0x000008, "Wrong size on GzHUDBase_GetView");
static_assert(offsetof(GzHUDBase_GetView, ReturnValue) == 0x000000, "Member 'GzHUDBase_GetView::ReturnValue' has a wrong offset!");

// Function G01.GzHUDBase.ShouldWaitKillerSpectateEnd
// 0x0001 (0x0001 - 0x0000)
struct GzHUDBase_ShouldWaitKillerSpectateEnd final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzHUDBase_ShouldWaitKillerSpectateEnd) == 0x000001, "Wrong alignment on GzHUDBase_ShouldWaitKillerSpectateEnd");
static_assert(sizeof(GzHUDBase_ShouldWaitKillerSpectateEnd) == 0x000001, "Wrong size on GzHUDBase_ShouldWaitKillerSpectateEnd");
static_assert(offsetof(GzHUDBase_ShouldWaitKillerSpectateEnd, ReturnValue) == 0x000000, "Member 'GzHUDBase_ShouldWaitKillerSpectateEnd::ReturnValue' has a wrong offset!");

// Function G01.GzTeamBlueprintLibrary.FindDefeatedTeammates
// 0x0020 (0x0020 - 0x0000)
struct GzTeamBlueprintLibrary_FindDefeatedTeammates final
{
public:
	class APlayerState*                           PlayerState;                                       // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IncludePlayer;                                     // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2DAA[0x7];                                     // 0x0009(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class AGzPlayerState*>                 ReturnValue;                                       // 0x0010(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzTeamBlueprintLibrary_FindDefeatedTeammates) == 0x000008, "Wrong alignment on GzTeamBlueprintLibrary_FindDefeatedTeammates");
static_assert(sizeof(GzTeamBlueprintLibrary_FindDefeatedTeammates) == 0x000020, "Wrong size on GzTeamBlueprintLibrary_FindDefeatedTeammates");
static_assert(offsetof(GzTeamBlueprintLibrary_FindDefeatedTeammates, PlayerState) == 0x000000, "Member 'GzTeamBlueprintLibrary_FindDefeatedTeammates::PlayerState' has a wrong offset!");
static_assert(offsetof(GzTeamBlueprintLibrary_FindDefeatedTeammates, IncludePlayer) == 0x000008, "Member 'GzTeamBlueprintLibrary_FindDefeatedTeammates::IncludePlayer' has a wrong offset!");
static_assert(offsetof(GzTeamBlueprintLibrary_FindDefeatedTeammates, ReturnValue) == 0x000010, "Member 'GzTeamBlueprintLibrary_FindDefeatedTeammates::ReturnValue' has a wrong offset!");

// Function G01.GzTeamBlueprintLibrary.FindTeammates
// 0x0020 (0x0020 - 0x0000)
struct GzTeamBlueprintLibrary_FindTeammates final
{
public:
	class APlayerState*                           PlayerState;                                       // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IncludePlayer;                                     // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2DAB[0x7];                                     // 0x0009(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class AGzPlayerState*>                 ReturnValue;                                       // 0x0010(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzTeamBlueprintLibrary_FindTeammates) == 0x000008, "Wrong alignment on GzTeamBlueprintLibrary_FindTeammates");
static_assert(sizeof(GzTeamBlueprintLibrary_FindTeammates) == 0x000020, "Wrong size on GzTeamBlueprintLibrary_FindTeammates");
static_assert(offsetof(GzTeamBlueprintLibrary_FindTeammates, PlayerState) == 0x000000, "Member 'GzTeamBlueprintLibrary_FindTeammates::PlayerState' has a wrong offset!");
static_assert(offsetof(GzTeamBlueprintLibrary_FindTeammates, IncludePlayer) == 0x000008, "Member 'GzTeamBlueprintLibrary_FindTeammates::IncludePlayer' has a wrong offset!");
static_assert(offsetof(GzTeamBlueprintLibrary_FindTeammates, ReturnValue) == 0x000010, "Member 'GzTeamBlueprintLibrary_FindTeammates::ReturnValue' has a wrong offset!");

// Function G01.GzTeamBlueprintLibrary.FindTeammatesInMatch
// 0x0020 (0x0020 - 0x0000)
struct GzTeamBlueprintLibrary_FindTeammatesInMatch final
{
public:
	class APlayerState*                           PlayerState;                                       // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IncludePlayer;                                     // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2DAC[0x7];                                     // 0x0009(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class AGzPlayerState*>                 ReturnValue;                                       // 0x0010(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzTeamBlueprintLibrary_FindTeammatesInMatch) == 0x000008, "Wrong alignment on GzTeamBlueprintLibrary_FindTeammatesInMatch");
static_assert(sizeof(GzTeamBlueprintLibrary_FindTeammatesInMatch) == 0x000020, "Wrong size on GzTeamBlueprintLibrary_FindTeammatesInMatch");
static_assert(offsetof(GzTeamBlueprintLibrary_FindTeammatesInMatch, PlayerState) == 0x000000, "Member 'GzTeamBlueprintLibrary_FindTeammatesInMatch::PlayerState' has a wrong offset!");
static_assert(offsetof(GzTeamBlueprintLibrary_FindTeammatesInMatch, IncludePlayer) == 0x000008, "Member 'GzTeamBlueprintLibrary_FindTeammatesInMatch::IncludePlayer' has a wrong offset!");
static_assert(offsetof(GzTeamBlueprintLibrary_FindTeammatesInMatch, ReturnValue) == 0x000010, "Member 'GzTeamBlueprintLibrary_FindTeammatesInMatch::ReturnValue' has a wrong offset!");

// Function G01.GzTeamBlueprintLibrary.GetAliveTeams
// 0x0018 (0x0018 - 0x0000)
struct GzTeamBlueprintLibrary_GetAliveTeams final
{
public:
	class UObject*                                WorldContextObject;                                // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<int32>                                 ReturnValue;                                       // 0x0008(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzTeamBlueprintLibrary_GetAliveTeams) == 0x000008, "Wrong alignment on GzTeamBlueprintLibrary_GetAliveTeams");
static_assert(sizeof(GzTeamBlueprintLibrary_GetAliveTeams) == 0x000018, "Wrong size on GzTeamBlueprintLibrary_GetAliveTeams");
static_assert(offsetof(GzTeamBlueprintLibrary_GetAliveTeams, WorldContextObject) == 0x000000, "Member 'GzTeamBlueprintLibrary_GetAliveTeams::WorldContextObject' has a wrong offset!");
static_assert(offsetof(GzTeamBlueprintLibrary_GetAliveTeams, ReturnValue) == 0x000008, "Member 'GzTeamBlueprintLibrary_GetAliveTeams::ReturnValue' has a wrong offset!");

// Function G01.GzTeamBlueprintLibrary.GetNumAliveTeams
// 0x0010 (0x0010 - 0x0000)
struct GzTeamBlueprintLibrary_GetNumAliveTeams final
{
public:
	class UObject*                                WorldContextObject;                                // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ReturnValue;                                       // 0x0008(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2DAD[0x4];                                     // 0x000C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GzTeamBlueprintLibrary_GetNumAliveTeams) == 0x000008, "Wrong alignment on GzTeamBlueprintLibrary_GetNumAliveTeams");
static_assert(sizeof(GzTeamBlueprintLibrary_GetNumAliveTeams) == 0x000010, "Wrong size on GzTeamBlueprintLibrary_GetNumAliveTeams");
static_assert(offsetof(GzTeamBlueprintLibrary_GetNumAliveTeams, WorldContextObject) == 0x000000, "Member 'GzTeamBlueprintLibrary_GetNumAliveTeams::WorldContextObject' has a wrong offset!");
static_assert(offsetof(GzTeamBlueprintLibrary_GetNumAliveTeams, ReturnValue) == 0x000008, "Member 'GzTeamBlueprintLibrary_GetNumAliveTeams::ReturnValue' has a wrong offset!");

// Function G01.GzTeamBlueprintLibrary.GetNumNotDefeatedTeams
// 0x0010 (0x0010 - 0x0000)
struct GzTeamBlueprintLibrary_GetNumNotDefeatedTeams final
{
public:
	class UObject*                                WorldContextObject;                                // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ReturnValue;                                       // 0x0008(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2DAE[0x4];                                     // 0x000C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GzTeamBlueprintLibrary_GetNumNotDefeatedTeams) == 0x000008, "Wrong alignment on GzTeamBlueprintLibrary_GetNumNotDefeatedTeams");
static_assert(sizeof(GzTeamBlueprintLibrary_GetNumNotDefeatedTeams) == 0x000010, "Wrong size on GzTeamBlueprintLibrary_GetNumNotDefeatedTeams");
static_assert(offsetof(GzTeamBlueprintLibrary_GetNumNotDefeatedTeams, WorldContextObject) == 0x000000, "Member 'GzTeamBlueprintLibrary_GetNumNotDefeatedTeams::WorldContextObject' has a wrong offset!");
static_assert(offsetof(GzTeamBlueprintLibrary_GetNumNotDefeatedTeams, ReturnValue) == 0x000008, "Member 'GzTeamBlueprintLibrary_GetNumNotDefeatedTeams::ReturnValue' has a wrong offset!");

// Function G01.GzTeamBlueprintLibrary.GetPlayerCharacterFromPlayerId
// 0x0018 (0x0018 - 0x0000)
struct GzTeamBlueprintLibrary_GetPlayerCharacterFromPlayerId final
{
public:
	const class UObject*                          WorldContextObject;                                // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         PlayerId;                                          // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2DAF[0x4];                                     // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class AGzPlayerCharacter*                     ReturnValue;                                       // 0x0010(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzTeamBlueprintLibrary_GetPlayerCharacterFromPlayerId) == 0x000008, "Wrong alignment on GzTeamBlueprintLibrary_GetPlayerCharacterFromPlayerId");
static_assert(sizeof(GzTeamBlueprintLibrary_GetPlayerCharacterFromPlayerId) == 0x000018, "Wrong size on GzTeamBlueprintLibrary_GetPlayerCharacterFromPlayerId");
static_assert(offsetof(GzTeamBlueprintLibrary_GetPlayerCharacterFromPlayerId, WorldContextObject) == 0x000000, "Member 'GzTeamBlueprintLibrary_GetPlayerCharacterFromPlayerId::WorldContextObject' has a wrong offset!");
static_assert(offsetof(GzTeamBlueprintLibrary_GetPlayerCharacterFromPlayerId, PlayerId) == 0x000008, "Member 'GzTeamBlueprintLibrary_GetPlayerCharacterFromPlayerId::PlayerId' has a wrong offset!");
static_assert(offsetof(GzTeamBlueprintLibrary_GetPlayerCharacterFromPlayerId, ReturnValue) == 0x000010, "Member 'GzTeamBlueprintLibrary_GetPlayerCharacterFromPlayerId::ReturnValue' has a wrong offset!");

// Function G01.GzTeamBlueprintLibrary.GetPlayerState
// 0x0018 (0x0018 - 0x0000)
struct GzTeamBlueprintLibrary_GetPlayerState final
{
public:
	const class UObject*                          WorldContextObject;                                // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         PlayerId;                                          // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2DB0[0x4];                                     // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class AGzPlayerState*                         ReturnValue;                                       // 0x0010(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzTeamBlueprintLibrary_GetPlayerState) == 0x000008, "Wrong alignment on GzTeamBlueprintLibrary_GetPlayerState");
static_assert(sizeof(GzTeamBlueprintLibrary_GetPlayerState) == 0x000018, "Wrong size on GzTeamBlueprintLibrary_GetPlayerState");
static_assert(offsetof(GzTeamBlueprintLibrary_GetPlayerState, WorldContextObject) == 0x000000, "Member 'GzTeamBlueprintLibrary_GetPlayerState::WorldContextObject' has a wrong offset!");
static_assert(offsetof(GzTeamBlueprintLibrary_GetPlayerState, PlayerId) == 0x000008, "Member 'GzTeamBlueprintLibrary_GetPlayerState::PlayerId' has a wrong offset!");
static_assert(offsetof(GzTeamBlueprintLibrary_GetPlayerState, ReturnValue) == 0x000010, "Member 'GzTeamBlueprintLibrary_GetPlayerState::ReturnValue' has a wrong offset!");

// Function G01.GzTeamBlueprintLibrary.GetTeamAttitude
// 0x0018 (0x0018 - 0x0000)
struct GzTeamBlueprintLibrary_GetTeamAttitude final
{
public:
	class AActor*                                 A;                                                 // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 B;                                                 // 0x0008(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETeamAttitude                                 ReturnValue;                                       // 0x0010(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2DB1[0x7];                                     // 0x0011(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GzTeamBlueprintLibrary_GetTeamAttitude) == 0x000008, "Wrong alignment on GzTeamBlueprintLibrary_GetTeamAttitude");
static_assert(sizeof(GzTeamBlueprintLibrary_GetTeamAttitude) == 0x000018, "Wrong size on GzTeamBlueprintLibrary_GetTeamAttitude");
static_assert(offsetof(GzTeamBlueprintLibrary_GetTeamAttitude, A) == 0x000000, "Member 'GzTeamBlueprintLibrary_GetTeamAttitude::A' has a wrong offset!");
static_assert(offsetof(GzTeamBlueprintLibrary_GetTeamAttitude, B) == 0x000008, "Member 'GzTeamBlueprintLibrary_GetTeamAttitude::B' has a wrong offset!");
static_assert(offsetof(GzTeamBlueprintLibrary_GetTeamAttitude, ReturnValue) == 0x000010, "Member 'GzTeamBlueprintLibrary_GetTeamAttitude::ReturnValue' has a wrong offset!");

// Function G01.GzTeamBlueprintLibrary.GetTeamAttitudeByPlayerIds
// 0x0018 (0x0018 - 0x0000)
struct GzTeamBlueprintLibrary_GetTeamAttitudeByPlayerIds final
{
public:
	const class UObject*                          WorldContextObject;                                // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         PlayerIdA;                                         // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         PlayerIdB;                                         // 0x000C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETeamAttitude                                 ReturnValue;                                       // 0x0010(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2DB2[0x7];                                     // 0x0011(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GzTeamBlueprintLibrary_GetTeamAttitudeByPlayerIds) == 0x000008, "Wrong alignment on GzTeamBlueprintLibrary_GetTeamAttitudeByPlayerIds");
static_assert(sizeof(GzTeamBlueprintLibrary_GetTeamAttitudeByPlayerIds) == 0x000018, "Wrong size on GzTeamBlueprintLibrary_GetTeamAttitudeByPlayerIds");
static_assert(offsetof(GzTeamBlueprintLibrary_GetTeamAttitudeByPlayerIds, WorldContextObject) == 0x000000, "Member 'GzTeamBlueprintLibrary_GetTeamAttitudeByPlayerIds::WorldContextObject' has a wrong offset!");
static_assert(offsetof(GzTeamBlueprintLibrary_GetTeamAttitudeByPlayerIds, PlayerIdA) == 0x000008, "Member 'GzTeamBlueprintLibrary_GetTeamAttitudeByPlayerIds::PlayerIdA' has a wrong offset!");
static_assert(offsetof(GzTeamBlueprintLibrary_GetTeamAttitudeByPlayerIds, PlayerIdB) == 0x00000C, "Member 'GzTeamBlueprintLibrary_GetTeamAttitudeByPlayerIds::PlayerIdB' has a wrong offset!");
static_assert(offsetof(GzTeamBlueprintLibrary_GetTeamAttitudeByPlayerIds, ReturnValue) == 0x000010, "Member 'GzTeamBlueprintLibrary_GetTeamAttitudeByPlayerIds::ReturnValue' has a wrong offset!");

// Function G01.GzTeamBlueprintLibrary.GetTeamFromPlayer
// 0x0010 (0x0010 - 0x0000)
struct GzTeamBlueprintLibrary_GetTeamFromPlayer final
{
public:
	const class AActor*                           Player;                                            // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AGzTeam*                                ReturnValue;                                       // 0x0008(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzTeamBlueprintLibrary_GetTeamFromPlayer) == 0x000008, "Wrong alignment on GzTeamBlueprintLibrary_GetTeamFromPlayer");
static_assert(sizeof(GzTeamBlueprintLibrary_GetTeamFromPlayer) == 0x000010, "Wrong size on GzTeamBlueprintLibrary_GetTeamFromPlayer");
static_assert(offsetof(GzTeamBlueprintLibrary_GetTeamFromPlayer, Player) == 0x000000, "Member 'GzTeamBlueprintLibrary_GetTeamFromPlayer::Player' has a wrong offset!");
static_assert(offsetof(GzTeamBlueprintLibrary_GetTeamFromPlayer, ReturnValue) == 0x000008, "Member 'GzTeamBlueprintLibrary_GetTeamFromPlayer::ReturnValue' has a wrong offset!");

// Function G01.GzTeamBlueprintLibrary.GetTeamFromPlayerId
// 0x0018 (0x0018 - 0x0000)
struct GzTeamBlueprintLibrary_GetTeamFromPlayerId final
{
public:
	const class UObject*                          WorldContextObject;                                // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         PlayerId;                                          // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2DB3[0x4];                                     // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class AGzTeam*                                ReturnValue;                                       // 0x0010(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzTeamBlueprintLibrary_GetTeamFromPlayerId) == 0x000008, "Wrong alignment on GzTeamBlueprintLibrary_GetTeamFromPlayerId");
static_assert(sizeof(GzTeamBlueprintLibrary_GetTeamFromPlayerId) == 0x000018, "Wrong size on GzTeamBlueprintLibrary_GetTeamFromPlayerId");
static_assert(offsetof(GzTeamBlueprintLibrary_GetTeamFromPlayerId, WorldContextObject) == 0x000000, "Member 'GzTeamBlueprintLibrary_GetTeamFromPlayerId::WorldContextObject' has a wrong offset!");
static_assert(offsetof(GzTeamBlueprintLibrary_GetTeamFromPlayerId, PlayerId) == 0x000008, "Member 'GzTeamBlueprintLibrary_GetTeamFromPlayerId::PlayerId' has a wrong offset!");
static_assert(offsetof(GzTeamBlueprintLibrary_GetTeamFromPlayerId, ReturnValue) == 0x000010, "Member 'GzTeamBlueprintLibrary_GetTeamFromPlayerId::ReturnValue' has a wrong offset!");

// Function G01.GzTeamBlueprintLibrary.GetTeamMembers
// 0x0020 (0x0020 - 0x0000)
struct GzTeamBlueprintLibrary_GetTeamMembers final
{
public:
	class UObject*                                WorldContextObject;                                // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Team;                                              // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2DB4[0x4];                                     // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<int32>                                 ReturnValue;                                       // 0x0010(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzTeamBlueprintLibrary_GetTeamMembers) == 0x000008, "Wrong alignment on GzTeamBlueprintLibrary_GetTeamMembers");
static_assert(sizeof(GzTeamBlueprintLibrary_GetTeamMembers) == 0x000020, "Wrong size on GzTeamBlueprintLibrary_GetTeamMembers");
static_assert(offsetof(GzTeamBlueprintLibrary_GetTeamMembers, WorldContextObject) == 0x000000, "Member 'GzTeamBlueprintLibrary_GetTeamMembers::WorldContextObject' has a wrong offset!");
static_assert(offsetof(GzTeamBlueprintLibrary_GetTeamMembers, Team) == 0x000008, "Member 'GzTeamBlueprintLibrary_GetTeamMembers::Team' has a wrong offset!");
static_assert(offsetof(GzTeamBlueprintLibrary_GetTeamMembers, ReturnValue) == 0x000010, "Member 'GzTeamBlueprintLibrary_GetTeamMembers::ReturnValue' has a wrong offset!");

// Function G01.GzTeamBlueprintLibrary.GetTeamsCount
// 0x0010 (0x0010 - 0x0000)
struct GzTeamBlueprintLibrary_GetTeamsCount final
{
public:
	class UObject*                                WorldContextObject;                                // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ReturnValue;                                       // 0x0008(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2DB5[0x4];                                     // 0x000C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GzTeamBlueprintLibrary_GetTeamsCount) == 0x000008, "Wrong alignment on GzTeamBlueprintLibrary_GetTeamsCount");
static_assert(sizeof(GzTeamBlueprintLibrary_GetTeamsCount) == 0x000010, "Wrong size on GzTeamBlueprintLibrary_GetTeamsCount");
static_assert(offsetof(GzTeamBlueprintLibrary_GetTeamsCount, WorldContextObject) == 0x000000, "Member 'GzTeamBlueprintLibrary_GetTeamsCount::WorldContextObject' has a wrong offset!");
static_assert(offsetof(GzTeamBlueprintLibrary_GetTeamsCount, ReturnValue) == 0x000008, "Member 'GzTeamBlueprintLibrary_GetTeamsCount::ReturnValue' has a wrong offset!");

// Function G01.GzGlobalStatsCollector.IncrementStat
// 0x0004 (0x0004 - 0x0000)
struct GzGlobalStatsCollector_IncrementStat final
{
public:
	int32                                         PlayerId;                                          // 0x0000(0x0004)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzGlobalStatsCollector_IncrementStat) == 0x000004, "Wrong alignment on GzGlobalStatsCollector_IncrementStat");
static_assert(sizeof(GzGlobalStatsCollector_IncrementStat) == 0x000004, "Wrong size on GzGlobalStatsCollector_IncrementStat");
static_assert(offsetof(GzGlobalStatsCollector_IncrementStat, PlayerId) == 0x000000, "Member 'GzGlobalStatsCollector_IncrementStat::PlayerId' has a wrong offset!");

// Function G01.GzGlobalStatsCollector.IncrementSubStat
// 0x000C (0x000C - 0x0000)
struct GzGlobalStatsCollector_IncrementSubStat final
{
public:
	class FName                                   SubKey;                                            // 0x0000(0x0008)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         PlayerId;                                          // 0x0008(0x0004)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzGlobalStatsCollector_IncrementSubStat) == 0x000004, "Wrong alignment on GzGlobalStatsCollector_IncrementSubStat");
static_assert(sizeof(GzGlobalStatsCollector_IncrementSubStat) == 0x00000C, "Wrong size on GzGlobalStatsCollector_IncrementSubStat");
static_assert(offsetof(GzGlobalStatsCollector_IncrementSubStat, SubKey) == 0x000000, "Member 'GzGlobalStatsCollector_IncrementSubStat::SubKey' has a wrong offset!");
static_assert(offsetof(GzGlobalStatsCollector_IncrementSubStat, PlayerId) == 0x000008, "Member 'GzGlobalStatsCollector_IncrementSubStat::PlayerId' has a wrong offset!");

// Function G01.GzGlobalStatsCollector.SetStat
// 0x0008 (0x0008 - 0x0000)
struct GzGlobalStatsCollector_SetStat final
{
public:
	int32                                         PlayerId;                                          // 0x0000(0x0004)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Value;                                             // 0x0004(0x0004)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzGlobalStatsCollector_SetStat) == 0x000004, "Wrong alignment on GzGlobalStatsCollector_SetStat");
static_assert(sizeof(GzGlobalStatsCollector_SetStat) == 0x000008, "Wrong size on GzGlobalStatsCollector_SetStat");
static_assert(offsetof(GzGlobalStatsCollector_SetStat, PlayerId) == 0x000000, "Member 'GzGlobalStatsCollector_SetStat::PlayerId' has a wrong offset!");
static_assert(offsetof(GzGlobalStatsCollector_SetStat, Value) == 0x000004, "Member 'GzGlobalStatsCollector_SetStat::Value' has a wrong offset!");

// Function G01.GzGlobalStatsCollector.SetSubStat
// 0x0010 (0x0010 - 0x0000)
struct GzGlobalStatsCollector_SetSubStat final
{
public:
	class FName                                   SubKey;                                            // 0x0000(0x0008)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         PlayerId;                                          // 0x0008(0x0004)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Value;                                             // 0x000C(0x0004)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzGlobalStatsCollector_SetSubStat) == 0x000004, "Wrong alignment on GzGlobalStatsCollector_SetSubStat");
static_assert(sizeof(GzGlobalStatsCollector_SetSubStat) == 0x000010, "Wrong size on GzGlobalStatsCollector_SetSubStat");
static_assert(offsetof(GzGlobalStatsCollector_SetSubStat, SubKey) == 0x000000, "Member 'GzGlobalStatsCollector_SetSubStat::SubKey' has a wrong offset!");
static_assert(offsetof(GzGlobalStatsCollector_SetSubStat, PlayerId) == 0x000008, "Member 'GzGlobalStatsCollector_SetSubStat::PlayerId' has a wrong offset!");
static_assert(offsetof(GzGlobalStatsCollector_SetSubStat, Value) == 0x00000C, "Member 'GzGlobalStatsCollector_SetSubStat::Value' has a wrong offset!");

// Function G01.GzGlobalStatsCollector.AddStat
// 0x0008 (0x0008 - 0x0000)
struct GzGlobalStatsCollector_AddStat final
{
public:
	int32                                         PlayerId;                                          // 0x0000(0x0004)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Value;                                             // 0x0004(0x0004)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzGlobalStatsCollector_AddStat) == 0x000004, "Wrong alignment on GzGlobalStatsCollector_AddStat");
static_assert(sizeof(GzGlobalStatsCollector_AddStat) == 0x000008, "Wrong size on GzGlobalStatsCollector_AddStat");
static_assert(offsetof(GzGlobalStatsCollector_AddStat, PlayerId) == 0x000000, "Member 'GzGlobalStatsCollector_AddStat::PlayerId' has a wrong offset!");
static_assert(offsetof(GzGlobalStatsCollector_AddStat, Value) == 0x000004, "Member 'GzGlobalStatsCollector_AddStat::Value' has a wrong offset!");

// Function G01.GzGlobalStatsCollector.AddSubStat
// 0x0010 (0x0010 - 0x0000)
struct GzGlobalStatsCollector_AddSubStat final
{
public:
	class FName                                   SubKey;                                            // 0x0000(0x0008)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         PlayerId;                                          // 0x0008(0x0004)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Value;                                             // 0x000C(0x0004)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzGlobalStatsCollector_AddSubStat) == 0x000004, "Wrong alignment on GzGlobalStatsCollector_AddSubStat");
static_assert(sizeof(GzGlobalStatsCollector_AddSubStat) == 0x000010, "Wrong size on GzGlobalStatsCollector_AddSubStat");
static_assert(offsetof(GzGlobalStatsCollector_AddSubStat, SubKey) == 0x000000, "Member 'GzGlobalStatsCollector_AddSubStat::SubKey' has a wrong offset!");
static_assert(offsetof(GzGlobalStatsCollector_AddSubStat, PlayerId) == 0x000008, "Member 'GzGlobalStatsCollector_AddSubStat::PlayerId' has a wrong offset!");
static_assert(offsetof(GzGlobalStatsCollector_AddSubStat, Value) == 0x00000C, "Member 'GzGlobalStatsCollector_AddSubStat::Value' has a wrong offset!");

// Function G01.GzAIPawn.OnHealthChange
// 0x0004 (0x0004 - 0x0000)
struct GzAIPawn_OnHealthChange final
{
public:
	float                                         Health;                                            // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzAIPawn_OnHealthChange) == 0x000004, "Wrong alignment on GzAIPawn_OnHealthChange");
static_assert(sizeof(GzAIPawn_OnHealthChange) == 0x000004, "Wrong size on GzAIPawn_OnHealthChange");
static_assert(offsetof(GzAIPawn_OnHealthChange, Health) == 0x000000, "Member 'GzAIPawn_OnHealthChange::Health' has a wrong offset!");

// Function G01.GzAIPawn.Shoot
// 0x0001 (0x0001 - 0x0000)
struct GzAIPawn_Shoot final
{
public:
	bool                                          bStart;                                            // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzAIPawn_Shoot) == 0x000001, "Wrong alignment on GzAIPawn_Shoot");
static_assert(sizeof(GzAIPawn_Shoot) == 0x000001, "Wrong size on GzAIPawn_Shoot");
static_assert(offsetof(GzAIPawn_Shoot, bStart) == 0x000000, "Member 'GzAIPawn_Shoot::bStart' has a wrong offset!");

// Function G01.GzAIPawn.GetCombatComponent
// 0x0008 (0x0008 - 0x0000)
struct GzAIPawn_GetCombatComponent final
{
public:
	class UGzCombatComponent*                     ReturnValue;                                       // 0x0000(0x0008)(ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzAIPawn_GetCombatComponent) == 0x000008, "Wrong alignment on GzAIPawn_GetCombatComponent");
static_assert(sizeof(GzAIPawn_GetCombatComponent) == 0x000008, "Wrong size on GzAIPawn_GetCombatComponent");
static_assert(offsetof(GzAIPawn_GetCombatComponent, ReturnValue) == 0x000000, "Member 'GzAIPawn_GetCombatComponent::ReturnValue' has a wrong offset!");

// Function G01.GzAIPawn.GetGzAbilitySystemComponent
// 0x0008 (0x0008 - 0x0000)
struct GzAIPawn_GetGzAbilitySystemComponent final
{
public:
	class UGzAbilitySystemComponent*              ReturnValue;                                       // 0x0000(0x0008)(ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzAIPawn_GetGzAbilitySystemComponent) == 0x000008, "Wrong alignment on GzAIPawn_GetGzAbilitySystemComponent");
static_assert(sizeof(GzAIPawn_GetGzAbilitySystemComponent) == 0x000008, "Wrong size on GzAIPawn_GetGzAbilitySystemComponent");
static_assert(offsetof(GzAIPawn_GetGzAbilitySystemComponent, ReturnValue) == 0x000000, "Member 'GzAIPawn_GetGzAbilitySystemComponent::ReturnValue' has a wrong offset!");

// Function G01.GzAIPawn.GetInventoryComponent
// 0x0008 (0x0008 - 0x0000)
struct GzAIPawn_GetInventoryComponent final
{
public:
	class UGzInvComponent*                        ReturnValue;                                       // 0x0000(0x0008)(ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzAIPawn_GetInventoryComponent) == 0x000008, "Wrong alignment on GzAIPawn_GetInventoryComponent");
static_assert(sizeof(GzAIPawn_GetInventoryComponent) == 0x000008, "Wrong size on GzAIPawn_GetInventoryComponent");
static_assert(offsetof(GzAIPawn_GetInventoryComponent, ReturnValue) == 0x000000, "Member 'GzAIPawn_GetInventoryComponent::ReturnValue' has a wrong offset!");

// Function G01.GzAIPawn.HasCombatComponent
// 0x0001 (0x0001 - 0x0000)
struct GzAIPawn_HasCombatComponent final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzAIPawn_HasCombatComponent) == 0x000001, "Wrong alignment on GzAIPawn_HasCombatComponent");
static_assert(sizeof(GzAIPawn_HasCombatComponent) == 0x000001, "Wrong size on GzAIPawn_HasCombatComponent");
static_assert(offsetof(GzAIPawn_HasCombatComponent, ReturnValue) == 0x000000, "Member 'GzAIPawn_HasCombatComponent::ReturnValue' has a wrong offset!");

// Function G01.GzAIPawn.HasInventoryComponent
// 0x0001 (0x0001 - 0x0000)
struct GzAIPawn_HasInventoryComponent final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzAIPawn_HasInventoryComponent) == 0x000001, "Wrong alignment on GzAIPawn_HasInventoryComponent");
static_assert(sizeof(GzAIPawn_HasInventoryComponent) == 0x000001, "Wrong size on GzAIPawn_HasInventoryComponent");
static_assert(offsetof(GzAIPawn_HasInventoryComponent, ReturnValue) == 0x000000, "Member 'GzAIPawn_HasInventoryComponent::ReturnValue' has a wrong offset!");

// Function G01.GzUserWidgetExtension.EventTick
// 0x003C (0x003C - 0x0000)
struct GzUserWidgetExtension_EventTick final
{
public:
	struct FGeometry                              MyGeometry;                                        // 0x0000(0x0038)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	float                                         InDeltaTime;                                       // 0x0038(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzUserWidgetExtension_EventTick) == 0x000004, "Wrong alignment on GzUserWidgetExtension_EventTick");
static_assert(sizeof(GzUserWidgetExtension_EventTick) == 0x00003C, "Wrong size on GzUserWidgetExtension_EventTick");
static_assert(offsetof(GzUserWidgetExtension_EventTick, MyGeometry) == 0x000000, "Member 'GzUserWidgetExtension_EventTick::MyGeometry' has a wrong offset!");
static_assert(offsetof(GzUserWidgetExtension_EventTick, InDeltaTime) == 0x000038, "Member 'GzUserWidgetExtension_EventTick::InDeltaTime' has a wrong offset!");

// Function G01.GzUserWidgetExtension.DoesRequiresTick
// 0x0001 (0x0001 - 0x0000)
struct GzUserWidgetExtension_DoesRequiresTick final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzUserWidgetExtension_DoesRequiresTick) == 0x000001, "Wrong alignment on GzUserWidgetExtension_DoesRequiresTick");
static_assert(sizeof(GzUserWidgetExtension_DoesRequiresTick) == 0x000001, "Wrong size on GzUserWidgetExtension_DoesRequiresTick");
static_assert(offsetof(GzUserWidgetExtension_DoesRequiresTick, ReturnValue) == 0x000000, "Member 'GzUserWidgetExtension_DoesRequiresTick::ReturnValue' has a wrong offset!");

// Function G01.GzUserWidgetExtension.GetWidget
// 0x0008 (0x0008 - 0x0000)
struct GzUserWidgetExtension_GetWidget final
{
public:
	class UUserWidget*                            ReturnValue;                                       // 0x0000(0x0008)(ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzUserWidgetExtension_GetWidget) == 0x000008, "Wrong alignment on GzUserWidgetExtension_GetWidget");
static_assert(sizeof(GzUserWidgetExtension_GetWidget) == 0x000008, "Wrong size on GzUserWidgetExtension_GetWidget");
static_assert(offsetof(GzUserWidgetExtension_GetWidget, ReturnValue) == 0x000000, "Member 'GzUserWidgetExtension_GetWidget::ReturnValue' has a wrong offset!");

// Function G01.GzAIPawnInterface.GetAiId
// 0x0004 (0x0004 - 0x0000)
struct GzAIPawnInterface_GetAiId final
{
public:
	int32                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzAIPawnInterface_GetAiId) == 0x000004, "Wrong alignment on GzAIPawnInterface_GetAiId");
static_assert(sizeof(GzAIPawnInterface_GetAiId) == 0x000004, "Wrong size on GzAIPawnInterface_GetAiId");
static_assert(offsetof(GzAIPawnInterface_GetAiId, ReturnValue) == 0x000000, "Member 'GzAIPawnInterface_GetAiId::ReturnValue' has a wrong offset!");

// Function G01.GzLimbComponent.GetArmorDamageReductionValue
// 0x0004 (0x0004 - 0x0000)
struct GzLimbComponent_GetArmorDamageReductionValue final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzLimbComponent_GetArmorDamageReductionValue) == 0x000004, "Wrong alignment on GzLimbComponent_GetArmorDamageReductionValue");
static_assert(sizeof(GzLimbComponent_GetArmorDamageReductionValue) == 0x000004, "Wrong size on GzLimbComponent_GetArmorDamageReductionValue");
static_assert(offsetof(GzLimbComponent_GetArmorDamageReductionValue, ReturnValue) == 0x000000, "Member 'GzLimbComponent_GetArmorDamageReductionValue::ReturnValue' has a wrong offset!");

// Function G01.GzLimbComponent.GetBodyPartItemData
// 0x0008 (0x0008 - 0x0000)
struct GzLimbComponent_GetBodyPartItemData final
{
public:
	class UGzBodyPartItemData*                    ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzLimbComponent_GetBodyPartItemData) == 0x000008, "Wrong alignment on GzLimbComponent_GetBodyPartItemData");
static_assert(sizeof(GzLimbComponent_GetBodyPartItemData) == 0x000008, "Wrong size on GzLimbComponent_GetBodyPartItemData");
static_assert(offsetof(GzLimbComponent_GetBodyPartItemData, ReturnValue) == 0x000000, "Member 'GzLimbComponent_GetBodyPartItemData::ReturnValue' has a wrong offset!");

// Function G01.GzLimbComponent.GetLimbDamageMultiplier
// 0x0004 (0x0004 - 0x0000)
struct GzLimbComponent_GetLimbDamageMultiplier final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzLimbComponent_GetLimbDamageMultiplier) == 0x000004, "Wrong alignment on GzLimbComponent_GetLimbDamageMultiplier");
static_assert(sizeof(GzLimbComponent_GetLimbDamageMultiplier) == 0x000004, "Wrong size on GzLimbComponent_GetLimbDamageMultiplier");
static_assert(offsetof(GzLimbComponent_GetLimbDamageMultiplier, ReturnValue) == 0x000000, "Member 'GzLimbComponent_GetLimbDamageMultiplier::ReturnValue' has a wrong offset!");

// Function G01.GzLimbComponent.GetType
// 0x0001 (0x0001 - 0x0000)
struct GzLimbComponent_GetType final
{
public:
	EGzLimbType                                   ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzLimbComponent_GetType) == 0x000001, "Wrong alignment on GzLimbComponent_GetType");
static_assert(sizeof(GzLimbComponent_GetType) == 0x000001, "Wrong size on GzLimbComponent_GetType");
static_assert(offsetof(GzLimbComponent_GetType, ReturnValue) == 0x000000, "Member 'GzLimbComponent_GetType::ReturnValue' has a wrong offset!");

// Function G01.GzLimbComponent.HasLoadedMesh
// 0x0001 (0x0001 - 0x0000)
struct GzLimbComponent_HasLoadedMesh final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzLimbComponent_HasLoadedMesh) == 0x000001, "Wrong alignment on GzLimbComponent_HasLoadedMesh");
static_assert(sizeof(GzLimbComponent_HasLoadedMesh) == 0x000001, "Wrong size on GzLimbComponent_HasLoadedMesh");
static_assert(offsetof(GzLimbComponent_HasLoadedMesh, ReturnValue) == 0x000000, "Member 'GzLimbComponent_HasLoadedMesh::ReturnValue' has a wrong offset!");

// Function G01.GzLimbComponent.IsDetachable
// 0x0001 (0x0001 - 0x0000)
struct GzLimbComponent_IsDetachable final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzLimbComponent_IsDetachable) == 0x000001, "Wrong alignment on GzLimbComponent_IsDetachable");
static_assert(sizeof(GzLimbComponent_IsDetachable) == 0x000001, "Wrong size on GzLimbComponent_IsDetachable");
static_assert(offsetof(GzLimbComponent_IsDetachable, ReturnValue) == 0x000000, "Member 'GzLimbComponent_IsDetachable::ReturnValue' has a wrong offset!");

// Function G01.GzDamageableActor.BP_OnDeath
// 0x0020 (0x0020 - 0x0000)
struct GzDamageableActor_BP_OnDeath final
{
public:
	bool                                          HasDeathHitPoint;                                  // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2DC4[0x7];                                     // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                DeathHitPoint;                                     // 0x0008(0x0018)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzDamageableActor_BP_OnDeath) == 0x000008, "Wrong alignment on GzDamageableActor_BP_OnDeath");
static_assert(sizeof(GzDamageableActor_BP_OnDeath) == 0x000020, "Wrong size on GzDamageableActor_BP_OnDeath");
static_assert(offsetof(GzDamageableActor_BP_OnDeath, HasDeathHitPoint) == 0x000000, "Member 'GzDamageableActor_BP_OnDeath::HasDeathHitPoint' has a wrong offset!");
static_assert(offsetof(GzDamageableActor_BP_OnDeath, DeathHitPoint) == 0x000008, "Member 'GzDamageableActor_BP_OnDeath::DeathHitPoint' has a wrong offset!");

// Function G01.GzDamageableActor.BP_OnHealthChange
// 0x0004 (0x0004 - 0x0000)
struct GzDamageableActor_BP_OnHealthChange final
{
public:
	float                                         Health;                                            // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzDamageableActor_BP_OnHealthChange) == 0x000004, "Wrong alignment on GzDamageableActor_BP_OnHealthChange");
static_assert(sizeof(GzDamageableActor_BP_OnHealthChange) == 0x000004, "Wrong size on GzDamageableActor_BP_OnHealthChange");
static_assert(offsetof(GzDamageableActor_BP_OnHealthChange, Health) == 0x000000, "Member 'GzDamageableActor_BP_OnHealthChange::Health' has a wrong offset!");

// Function G01.GzDamageableActor.GetCurrentHealth
// 0x0004 (0x0004 - 0x0000)
struct GzDamageableActor_GetCurrentHealth final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzDamageableActor_GetCurrentHealth) == 0x000004, "Wrong alignment on GzDamageableActor_GetCurrentHealth");
static_assert(sizeof(GzDamageableActor_GetCurrentHealth) == 0x000004, "Wrong size on GzDamageableActor_GetCurrentHealth");
static_assert(offsetof(GzDamageableActor_GetCurrentHealth, ReturnValue) == 0x000000, "Member 'GzDamageableActor_GetCurrentHealth::ReturnValue' has a wrong offset!");

// Function G01.GzHitReactableActor.BP_ClientOnDiedPlayFx
// 0x0018 (0x0018 - 0x0000)
struct GzHitReactableActor_BP_ClientOnDiedPlayFx final
{
public:
	struct FVector                                LastHitLocation;                                   // 0x0000(0x0018)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzHitReactableActor_BP_ClientOnDiedPlayFx) == 0x000008, "Wrong alignment on GzHitReactableActor_BP_ClientOnDiedPlayFx");
static_assert(sizeof(GzHitReactableActor_BP_ClientOnDiedPlayFx) == 0x000018, "Wrong size on GzHitReactableActor_BP_ClientOnDiedPlayFx");
static_assert(offsetof(GzHitReactableActor_BP_ClientOnDiedPlayFx, LastHitLocation) == 0x000000, "Member 'GzHitReactableActor_BP_ClientOnDiedPlayFx::LastHitLocation' has a wrong offset!");

// Function G01.GzHitReactableActor.BP_OnHitApplied
// 0x00F8 (0x00F8 - 0x0000)
struct GzHitReactableActor_BP_OnHitApplied final
{
public:
	struct FHitResult                             HitResult;                                         // 0x0000(0x00F8)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzHitReactableActor_BP_OnHitApplied) == 0x000008, "Wrong alignment on GzHitReactableActor_BP_OnHitApplied");
static_assert(sizeof(GzHitReactableActor_BP_OnHitApplied) == 0x0000F8, "Wrong size on GzHitReactableActor_BP_OnHitApplied");
static_assert(offsetof(GzHitReactableActor_BP_OnHitApplied, HitResult) == 0x000000, "Member 'GzHitReactableActor_BP_OnHitApplied::HitResult' has a wrong offset!");

// Function G01.GzHitReactableActor.GetLastHitResult
// 0x0100 (0x0100 - 0x0000)
struct GzHitReactableActor_GetLastHitResult final
{
public:
	struct FHitResult                             OutHitResult;                                      // 0x0000(0x00F8)(Parm, OutParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x00F8(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2DC5[0x7];                                     // 0x00F9(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GzHitReactableActor_GetLastHitResult) == 0x000008, "Wrong alignment on GzHitReactableActor_GetLastHitResult");
static_assert(sizeof(GzHitReactableActor_GetLastHitResult) == 0x000100, "Wrong size on GzHitReactableActor_GetLastHitResult");
static_assert(offsetof(GzHitReactableActor_GetLastHitResult, OutHitResult) == 0x000000, "Member 'GzHitReactableActor_GetLastHitResult::OutHitResult' has a wrong offset!");
static_assert(offsetof(GzHitReactableActor_GetLastHitResult, ReturnValue) == 0x0000F8, "Member 'GzHitReactableActor_GetLastHitResult::ReturnValue' has a wrong offset!");

// Function G01.GzHitReactableActor.Multicast_OnDied
// 0x0018 (0x0018 - 0x0000)
struct GzHitReactableActor_Multicast_OnDied final
{
public:
	struct FVector_NetQuantize                    LastHitLocation;                                   // 0x0000(0x0018)(ConstParm, Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzHitReactableActor_Multicast_OnDied) == 0x000008, "Wrong alignment on GzHitReactableActor_Multicast_OnDied");
static_assert(sizeof(GzHitReactableActor_Multicast_OnDied) == 0x000018, "Wrong size on GzHitReactableActor_Multicast_OnDied");
static_assert(offsetof(GzHitReactableActor_Multicast_OnDied, LastHitLocation) == 0x000000, "Member 'GzHitReactableActor_Multicast_OnDied::LastHitLocation' has a wrong offset!");

// Function G01.GzHitReactableActor.OnRep_Hits
// 0x0010 (0x0010 - 0x0000)
struct GzHitReactableActor_OnRep_Hits final
{
public:
	TArray<struct FHitResult>                     OldHits;                                           // 0x0000(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzHitReactableActor_OnRep_Hits) == 0x000008, "Wrong alignment on GzHitReactableActor_OnRep_Hits");
static_assert(sizeof(GzHitReactableActor_OnRep_Hits) == 0x000010, "Wrong size on GzHitReactableActor_OnRep_Hits");
static_assert(offsetof(GzHitReactableActor_OnRep_Hits, OldHits) == 0x000000, "Member 'GzHitReactableActor_OnRep_Hits::OldHits' has a wrong offset!");

// Function G01.GzConfirmLoadoutSelectionButton.SetCooldown
// 0x0004 (0x0004 - 0x0000)
struct GzConfirmLoadoutSelectionButton_SetCooldown final
{
public:
	float                                         Cooldown;                                          // 0x0000(0x0004)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzConfirmLoadoutSelectionButton_SetCooldown) == 0x000004, "Wrong alignment on GzConfirmLoadoutSelectionButton_SetCooldown");
static_assert(sizeof(GzConfirmLoadoutSelectionButton_SetCooldown) == 0x000004, "Wrong size on GzConfirmLoadoutSelectionButton_SetCooldown");
static_assert(offsetof(GzConfirmLoadoutSelectionButton_SetCooldown, Cooldown) == 0x000000, "Member 'GzConfirmLoadoutSelectionButton_SetCooldown::Cooldown' has a wrong offset!");

// Function G01.GzAIProcessTargetComponent.AddAlertLocation
// 0x0020 (0x0020 - 0x0000)
struct GzAIProcessTargetComponent_AddAlertLocation final
{
public:
	int32                                         TargetId;                                          // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2DC7[0x4];                                     // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                Location;                                          // 0x0008(0x0018)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzAIProcessTargetComponent_AddAlertLocation) == 0x000008, "Wrong alignment on GzAIProcessTargetComponent_AddAlertLocation");
static_assert(sizeof(GzAIProcessTargetComponent_AddAlertLocation) == 0x000020, "Wrong size on GzAIProcessTargetComponent_AddAlertLocation");
static_assert(offsetof(GzAIProcessTargetComponent_AddAlertLocation, TargetId) == 0x000000, "Member 'GzAIProcessTargetComponent_AddAlertLocation::TargetId' has a wrong offset!");
static_assert(offsetof(GzAIProcessTargetComponent_AddAlertLocation, Location) == 0x000008, "Member 'GzAIProcessTargetComponent_AddAlertLocation::Location' has a wrong offset!");

// Function G01.GzAIProcessTargetComponent.TryAddUniqueTarget
// 0x0010 (0x0010 - 0x0000)
struct GzAIProcessTargetComponent_TryAddUniqueTarget final
{
public:
	class AActor*                                 Target;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         TargetId;                                          // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x000C(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2DC8[0x3];                                     // 0x000D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GzAIProcessTargetComponent_TryAddUniqueTarget) == 0x000008, "Wrong alignment on GzAIProcessTargetComponent_TryAddUniqueTarget");
static_assert(sizeof(GzAIProcessTargetComponent_TryAddUniqueTarget) == 0x000010, "Wrong size on GzAIProcessTargetComponent_TryAddUniqueTarget");
static_assert(offsetof(GzAIProcessTargetComponent_TryAddUniqueTarget, Target) == 0x000000, "Member 'GzAIProcessTargetComponent_TryAddUniqueTarget::Target' has a wrong offset!");
static_assert(offsetof(GzAIProcessTargetComponent_TryAddUniqueTarget, TargetId) == 0x000008, "Member 'GzAIProcessTargetComponent_TryAddUniqueTarget::TargetId' has a wrong offset!");
static_assert(offsetof(GzAIProcessTargetComponent_TryAddUniqueTarget, ReturnValue) == 0x00000C, "Member 'GzAIProcessTargetComponent_TryAddUniqueTarget::ReturnValue' has a wrong offset!");

// Function G01.GzAIProcessTargetComponent.TryRemoveNonActiveTarget
// 0x0008 (0x0008 - 0x0000)
struct GzAIProcessTargetComponent_TryRemoveNonActiveTarget final
{
public:
	int32                                         TargetId;                                          // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0004(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2DC9[0x3];                                     // 0x0005(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GzAIProcessTargetComponent_TryRemoveNonActiveTarget) == 0x000004, "Wrong alignment on GzAIProcessTargetComponent_TryRemoveNonActiveTarget");
static_assert(sizeof(GzAIProcessTargetComponent_TryRemoveNonActiveTarget) == 0x000008, "Wrong size on GzAIProcessTargetComponent_TryRemoveNonActiveTarget");
static_assert(offsetof(GzAIProcessTargetComponent_TryRemoveNonActiveTarget, TargetId) == 0x000000, "Member 'GzAIProcessTargetComponent_TryRemoveNonActiveTarget::TargetId' has a wrong offset!");
static_assert(offsetof(GzAIProcessTargetComponent_TryRemoveNonActiveTarget, ReturnValue) == 0x000004, "Member 'GzAIProcessTargetComponent_TryRemoveNonActiveTarget::ReturnValue' has a wrong offset!");

// Function G01.GzAIProcessTargetComponent.TryRemoveTarget
// 0x0008 (0x0008 - 0x0000)
struct GzAIProcessTargetComponent_TryRemoveTarget final
{
public:
	int32                                         TargetId;                                          // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0004(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2DCA[0x3];                                     // 0x0005(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GzAIProcessTargetComponent_TryRemoveTarget) == 0x000004, "Wrong alignment on GzAIProcessTargetComponent_TryRemoveTarget");
static_assert(sizeof(GzAIProcessTargetComponent_TryRemoveTarget) == 0x000008, "Wrong size on GzAIProcessTargetComponent_TryRemoveTarget");
static_assert(offsetof(GzAIProcessTargetComponent_TryRemoveTarget, TargetId) == 0x000000, "Member 'GzAIProcessTargetComponent_TryRemoveTarget::TargetId' has a wrong offset!");
static_assert(offsetof(GzAIProcessTargetComponent_TryRemoveTarget, ReturnValue) == 0x000004, "Member 'GzAIProcessTargetComponent_TryRemoveTarget::ReturnValue' has a wrong offset!");

// Function G01.GzAIProcessTargetComponent.UpdateTargets
// 0x0004 (0x0004 - 0x0000)
struct GzAIProcessTargetComponent_UpdateTargets final
{
public:
	float                                         DeltaTime;                                         // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzAIProcessTargetComponent_UpdateTargets) == 0x000004, "Wrong alignment on GzAIProcessTargetComponent_UpdateTargets");
static_assert(sizeof(GzAIProcessTargetComponent_UpdateTargets) == 0x000004, "Wrong size on GzAIProcessTargetComponent_UpdateTargets");
static_assert(offsetof(GzAIProcessTargetComponent_UpdateTargets, DeltaTime) == 0x000000, "Member 'GzAIProcessTargetComponent_UpdateTargets::DeltaTime' has a wrong offset!");

// Function G01.GzAIProcessTargetComponent.GetAIController
// 0x0008 (0x0008 - 0x0000)
struct GzAIProcessTargetComponent_GetAIController final
{
public:
	class AGzAIController*                        ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzAIProcessTargetComponent_GetAIController) == 0x000008, "Wrong alignment on GzAIProcessTargetComponent_GetAIController");
static_assert(sizeof(GzAIProcessTargetComponent_GetAIController) == 0x000008, "Wrong size on GzAIProcessTargetComponent_GetAIController");
static_assert(offsetof(GzAIProcessTargetComponent_GetAIController, ReturnValue) == 0x000000, "Member 'GzAIProcessTargetComponent_GetAIController::ReturnValue' has a wrong offset!");

// Function G01.GzAIProcessTargetComponent.GetCurrentTarget
// 0x0008 (0x0008 - 0x0000)
struct GzAIProcessTargetComponent_GetCurrentTarget final
{
public:
	class AActor*                                 ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzAIProcessTargetComponent_GetCurrentTarget) == 0x000008, "Wrong alignment on GzAIProcessTargetComponent_GetCurrentTarget");
static_assert(sizeof(GzAIProcessTargetComponent_GetCurrentTarget) == 0x000008, "Wrong size on GzAIProcessTargetComponent_GetCurrentTarget");
static_assert(offsetof(GzAIProcessTargetComponent_GetCurrentTarget, ReturnValue) == 0x000000, "Member 'GzAIProcessTargetComponent_GetCurrentTarget::ReturnValue' has a wrong offset!");

// Function G01.GzAIProcessTargetComponent.GetNearestAlertLocation
// 0x0020 (0x0020 - 0x0000)
struct GzAIProcessTargetComponent_GetNearestAlertLocation final
{
public:
	struct FVector                                OutLocation;                                       // 0x0000(0x0018)(Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0018(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2DCB[0x7];                                     // 0x0019(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GzAIProcessTargetComponent_GetNearestAlertLocation) == 0x000008, "Wrong alignment on GzAIProcessTargetComponent_GetNearestAlertLocation");
static_assert(sizeof(GzAIProcessTargetComponent_GetNearestAlertLocation) == 0x000020, "Wrong size on GzAIProcessTargetComponent_GetNearestAlertLocation");
static_assert(offsetof(GzAIProcessTargetComponent_GetNearestAlertLocation, OutLocation) == 0x000000, "Member 'GzAIProcessTargetComponent_GetNearestAlertLocation::OutLocation' has a wrong offset!");
static_assert(offsetof(GzAIProcessTargetComponent_GetNearestAlertLocation, ReturnValue) == 0x000018, "Member 'GzAIProcessTargetComponent_GetNearestAlertLocation::ReturnValue' has a wrong offset!");

// Function G01.GzAIProcessTargetComponent.GetPawnOwner
// 0x0008 (0x0008 - 0x0000)
struct GzAIProcessTargetComponent_GetPawnOwner final
{
public:
	class APawn*                                  ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzAIProcessTargetComponent_GetPawnOwner) == 0x000008, "Wrong alignment on GzAIProcessTargetComponent_GetPawnOwner");
static_assert(sizeof(GzAIProcessTargetComponent_GetPawnOwner) == 0x000008, "Wrong size on GzAIProcessTargetComponent_GetPawnOwner");
static_assert(offsetof(GzAIProcessTargetComponent_GetPawnOwner, ReturnValue) == 0x000000, "Member 'GzAIProcessTargetComponent_GetPawnOwner::ReturnValue' has a wrong offset!");

// Function G01.GzAIProcessTargetComponent.HasAlertLocations
// 0x0001 (0x0001 - 0x0000)
struct GzAIProcessTargetComponent_HasAlertLocations final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzAIProcessTargetComponent_HasAlertLocations) == 0x000001, "Wrong alignment on GzAIProcessTargetComponent_HasAlertLocations");
static_assert(sizeof(GzAIProcessTargetComponent_HasAlertLocations) == 0x000001, "Wrong size on GzAIProcessTargetComponent_HasAlertLocations");
static_assert(offsetof(GzAIProcessTargetComponent_HasAlertLocations, ReturnValue) == 0x000000, "Member 'GzAIProcessTargetComponent_HasAlertLocations::ReturnValue' has a wrong offset!");

// Function G01.GzAIProcessTargetComponent.HasTargets
// 0x0001 (0x0001 - 0x0000)
struct GzAIProcessTargetComponent_HasTargets final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzAIProcessTargetComponent_HasTargets) == 0x000001, "Wrong alignment on GzAIProcessTargetComponent_HasTargets");
static_assert(sizeof(GzAIProcessTargetComponent_HasTargets) == 0x000001, "Wrong size on GzAIProcessTargetComponent_HasTargets");
static_assert(offsetof(GzAIProcessTargetComponent_HasTargets, ReturnValue) == 0x000000, "Member 'GzAIProcessTargetComponent_HasTargets::ReturnValue' has a wrong offset!");

// Function G01.GzAITokenComponent.AddAttacker
// 0x0010 (0x0010 - 0x0000)
struct GzAITokenComponent_AddAttacker final
{
public:
	class APawn*                                  InPawn;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2DCD[0x7];                                     // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GzAITokenComponent_AddAttacker) == 0x000008, "Wrong alignment on GzAITokenComponent_AddAttacker");
static_assert(sizeof(GzAITokenComponent_AddAttacker) == 0x000010, "Wrong size on GzAITokenComponent_AddAttacker");
static_assert(offsetof(GzAITokenComponent_AddAttacker, InPawn) == 0x000000, "Member 'GzAITokenComponent_AddAttacker::InPawn' has a wrong offset!");
static_assert(offsetof(GzAITokenComponent_AddAttacker, ReturnValue) == 0x000008, "Member 'GzAITokenComponent_AddAttacker::ReturnValue' has a wrong offset!");

// Function G01.GzAITokenComponent.RemoveAttacker
// 0x0008 (0x0008 - 0x0000)
struct GzAITokenComponent_RemoveAttacker final
{
public:
	class APawn*                                  InPawn;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzAITokenComponent_RemoveAttacker) == 0x000008, "Wrong alignment on GzAITokenComponent_RemoveAttacker");
static_assert(sizeof(GzAITokenComponent_RemoveAttacker) == 0x000008, "Wrong size on GzAITokenComponent_RemoveAttacker");
static_assert(offsetof(GzAITokenComponent_RemoveAttacker, InPawn) == 0x000000, "Member 'GzAITokenComponent_RemoveAttacker::InPawn' has a wrong offset!");

// Function G01.GzAITokenComponent.CanBeAttackedBy
// 0x0010 (0x0010 - 0x0000)
struct GzAITokenComponent_CanBeAttackedBy final
{
public:
	class APawn*                                  InPawn;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2DCE[0x7];                                     // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GzAITokenComponent_CanBeAttackedBy) == 0x000008, "Wrong alignment on GzAITokenComponent_CanBeAttackedBy");
static_assert(sizeof(GzAITokenComponent_CanBeAttackedBy) == 0x000010, "Wrong size on GzAITokenComponent_CanBeAttackedBy");
static_assert(offsetof(GzAITokenComponent_CanBeAttackedBy, InPawn) == 0x000000, "Member 'GzAITokenComponent_CanBeAttackedBy::InPawn' has a wrong offset!");
static_assert(offsetof(GzAITokenComponent_CanBeAttackedBy, ReturnValue) == 0x000008, "Member 'GzAITokenComponent_CanBeAttackedBy::ReturnValue' has a wrong offset!");

// Function G01.GzAITokenComponent.GetNumAttackers
// 0x0004 (0x0004 - 0x0000)
struct GzAITokenComponent_GetNumAttackers final
{
public:
	int32                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzAITokenComponent_GetNumAttackers) == 0x000004, "Wrong alignment on GzAITokenComponent_GetNumAttackers");
static_assert(sizeof(GzAITokenComponent_GetNumAttackers) == 0x000004, "Wrong size on GzAITokenComponent_GetNumAttackers");
static_assert(offsetof(GzAITokenComponent_GetNumAttackers, ReturnValue) == 0x000000, "Member 'GzAITokenComponent_GetNumAttackers::ReturnValue' has a wrong offset!");

// Function G01.GzAITokenComponent.HasAttacker
// 0x0010 (0x0010 - 0x0000)
struct GzAITokenComponent_HasAttacker final
{
public:
	const class APawn*                            InPawn;                                            // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2DCF[0x7];                                     // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GzAITokenComponent_HasAttacker) == 0x000008, "Wrong alignment on GzAITokenComponent_HasAttacker");
static_assert(sizeof(GzAITokenComponent_HasAttacker) == 0x000010, "Wrong size on GzAITokenComponent_HasAttacker");
static_assert(offsetof(GzAITokenComponent_HasAttacker, InPawn) == 0x000000, "Member 'GzAITokenComponent_HasAttacker::InPawn' has a wrong offset!");
static_assert(offsetof(GzAITokenComponent_HasAttacker, ReturnValue) == 0x000008, "Member 'GzAITokenComponent_HasAttacker::ReturnValue' has a wrong offset!");

// Function G01.GzAITokenComponent.HasFreeToken
// 0x0001 (0x0001 - 0x0000)
struct GzAITokenComponent_HasFreeToken final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzAITokenComponent_HasFreeToken) == 0x000001, "Wrong alignment on GzAITokenComponent_HasFreeToken");
static_assert(sizeof(GzAITokenComponent_HasFreeToken) == 0x000001, "Wrong size on GzAITokenComponent_HasFreeToken");
static_assert(offsetof(GzAITokenComponent_HasFreeToken, ReturnValue) == 0x000000, "Member 'GzAITokenComponent_HasFreeToken::ReturnValue' has a wrong offset!");

// Function G01.GzAITokenComponent.IsValidAttacker
// 0x0010 (0x0010 - 0x0000)
struct GzAITokenComponent_IsValidAttacker final
{
public:
	class APawn*                                  InPawn;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2DD0[0x7];                                     // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GzAITokenComponent_IsValidAttacker) == 0x000008, "Wrong alignment on GzAITokenComponent_IsValidAttacker");
static_assert(sizeof(GzAITokenComponent_IsValidAttacker) == 0x000010, "Wrong size on GzAITokenComponent_IsValidAttacker");
static_assert(offsetof(GzAITokenComponent_IsValidAttacker, InPawn) == 0x000000, "Member 'GzAITokenComponent_IsValidAttacker::InPawn' has a wrong offset!");
static_assert(offsetof(GzAITokenComponent_IsValidAttacker, ReturnValue) == 0x000008, "Member 'GzAITokenComponent_IsValidAttacker::ReturnValue' has a wrong offset!");

// Function G01.GzAIVoiceComponent.OnStartSoundAccepted
// 0x000C (0x000C - 0x0000)
struct GzAIVoiceComponent_OnStartSoundAccepted final
{
public:
	struct FGameplayTag                           AudioEventTag;                                     // 0x0000(0x0008)(ConstParm, Parm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          StopActive;                                        // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2DD2[0x3];                                     // 0x0009(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GzAIVoiceComponent_OnStartSoundAccepted) == 0x000004, "Wrong alignment on GzAIVoiceComponent_OnStartSoundAccepted");
static_assert(sizeof(GzAIVoiceComponent_OnStartSoundAccepted) == 0x00000C, "Wrong size on GzAIVoiceComponent_OnStartSoundAccepted");
static_assert(offsetof(GzAIVoiceComponent_OnStartSoundAccepted, AudioEventTag) == 0x000000, "Member 'GzAIVoiceComponent_OnStartSoundAccepted::AudioEventTag' has a wrong offset!");
static_assert(offsetof(GzAIVoiceComponent_OnStartSoundAccepted, StopActive) == 0x000008, "Member 'GzAIVoiceComponent_OnStartSoundAccepted::StopActive' has a wrong offset!");

// Function G01.GzAIVoiceComponent.StartSound
// 0x000C (0x000C - 0x0000)
struct GzAIVoiceComponent_StartSound final
{
public:
	struct FGameplayTag                           AIBarkTag;                                         // 0x0000(0x0008)(ConstParm, Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          StopActiveCooldownAndSound;                        // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0009(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2DD3[0x2];                                     // 0x000A(0x0002)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GzAIVoiceComponent_StartSound) == 0x000004, "Wrong alignment on GzAIVoiceComponent_StartSound");
static_assert(sizeof(GzAIVoiceComponent_StartSound) == 0x00000C, "Wrong size on GzAIVoiceComponent_StartSound");
static_assert(offsetof(GzAIVoiceComponent_StartSound, AIBarkTag) == 0x000000, "Member 'GzAIVoiceComponent_StartSound::AIBarkTag' has a wrong offset!");
static_assert(offsetof(GzAIVoiceComponent_StartSound, StopActiveCooldownAndSound) == 0x000008, "Member 'GzAIVoiceComponent_StartSound::StopActiveCooldownAndSound' has a wrong offset!");
static_assert(offsetof(GzAIVoiceComponent_StartSound, ReturnValue) == 0x000009, "Member 'GzAIVoiceComponent_StartSound::ReturnValue' has a wrong offset!");

// Function G01.GzAIVoiceComponent.HasActiveSound
// 0x0001 (0x0001 - 0x0000)
struct GzAIVoiceComponent_HasActiveSound final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzAIVoiceComponent_HasActiveSound) == 0x000001, "Wrong alignment on GzAIVoiceComponent_HasActiveSound");
static_assert(sizeof(GzAIVoiceComponent_HasActiveSound) == 0x000001, "Wrong size on GzAIVoiceComponent_HasActiveSound");
static_assert(offsetof(GzAIVoiceComponent_HasActiveSound, ReturnValue) == 0x000000, "Member 'GzAIVoiceComponent_HasActiveSound::ReturnValue' has a wrong offset!");

// Function G01.GzAIVoiceComponent.IsSoundActive
// 0x000C (0x000C - 0x0000)
struct GzAIVoiceComponent_IsSoundActive final
{
public:
	struct FGameplayTag                           AIBarkTag;                                         // 0x0000(0x0008)(ConstParm, Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2DD4[0x3];                                     // 0x0009(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GzAIVoiceComponent_IsSoundActive) == 0x000004, "Wrong alignment on GzAIVoiceComponent_IsSoundActive");
static_assert(sizeof(GzAIVoiceComponent_IsSoundActive) == 0x00000C, "Wrong size on GzAIVoiceComponent_IsSoundActive");
static_assert(offsetof(GzAIVoiceComponent_IsSoundActive, AIBarkTag) == 0x000000, "Member 'GzAIVoiceComponent_IsSoundActive::AIBarkTag' has a wrong offset!");
static_assert(offsetof(GzAIVoiceComponent_IsSoundActive, ReturnValue) == 0x000008, "Member 'GzAIVoiceComponent_IsSoundActive::ReturnValue' has a wrong offset!");

// Function G01.GzAIVoiceComponent.IsSoundCooldown
// 0x000C (0x000C - 0x0000)
struct GzAIVoiceComponent_IsSoundCooldown final
{
public:
	struct FGameplayTag                           AIBarkTag;                                         // 0x0000(0x0008)(ConstParm, Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2DD5[0x3];                                     // 0x0009(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GzAIVoiceComponent_IsSoundCooldown) == 0x000004, "Wrong alignment on GzAIVoiceComponent_IsSoundCooldown");
static_assert(sizeof(GzAIVoiceComponent_IsSoundCooldown) == 0x00000C, "Wrong size on GzAIVoiceComponent_IsSoundCooldown");
static_assert(offsetof(GzAIVoiceComponent_IsSoundCooldown, AIBarkTag) == 0x000000, "Member 'GzAIVoiceComponent_IsSoundCooldown::AIBarkTag' has a wrong offset!");
static_assert(offsetof(GzAIVoiceComponent_IsSoundCooldown, ReturnValue) == 0x000008, "Member 'GzAIVoiceComponent_IsSoundCooldown::ReturnValue' has a wrong offset!");

// Function G01.GzMarkerWidget.OnShow
// 0x0001 (0x0001 - 0x0000)
struct GzMarkerWidget_OnShow final
{
public:
	bool                                          bInVisible;                                        // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzMarkerWidget_OnShow) == 0x000001, "Wrong alignment on GzMarkerWidget_OnShow");
static_assert(sizeof(GzMarkerWidget_OnShow) == 0x000001, "Wrong size on GzMarkerWidget_OnShow");
static_assert(offsetof(GzMarkerWidget_OnShow, bInVisible) == 0x000000, "Member 'GzMarkerWidget_OnShow::bInVisible' has a wrong offset!");

// Function G01.GzMarkerWidget.GetHideVisibility
// 0x0001 (0x0001 - 0x0000)
struct GzMarkerWidget_GetHideVisibility final
{
public:
	ESlateVisibility                              ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzMarkerWidget_GetHideVisibility) == 0x000001, "Wrong alignment on GzMarkerWidget_GetHideVisibility");
static_assert(sizeof(GzMarkerWidget_GetHideVisibility) == 0x000001, "Wrong size on GzMarkerWidget_GetHideVisibility");
static_assert(offsetof(GzMarkerWidget_GetHideVisibility, ReturnValue) == 0x000000, "Member 'GzMarkerWidget_GetHideVisibility::ReturnValue' has a wrong offset!");

// Function G01.GzMarkerWidget.GetShowVisibility
// 0x0001 (0x0001 - 0x0000)
struct GzMarkerWidget_GetShowVisibility final
{
public:
	ESlateVisibility                              ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzMarkerWidget_GetShowVisibility) == 0x000001, "Wrong alignment on GzMarkerWidget_GetShowVisibility");
static_assert(sizeof(GzMarkerWidget_GetShowVisibility) == 0x000001, "Wrong size on GzMarkerWidget_GetShowVisibility");
static_assert(offsetof(GzMarkerWidget_GetShowVisibility, ReturnValue) == 0x000000, "Member 'GzMarkerWidget_GetShowVisibility::ReturnValue' has a wrong offset!");

// Function G01.GzMapMarkerWidget.SetShouldClamp
// 0x0001 (0x0001 - 0x0000)
struct GzMapMarkerWidget_SetShouldClamp final
{
public:
	bool                                          bInShouldClamp;                                    // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzMapMarkerWidget_SetShouldClamp) == 0x000001, "Wrong alignment on GzMapMarkerWidget_SetShouldClamp");
static_assert(sizeof(GzMapMarkerWidget_SetShouldClamp) == 0x000001, "Wrong size on GzMapMarkerWidget_SetShouldClamp");
static_assert(offsetof(GzMapMarkerWidget_SetShouldClamp, bInShouldClamp) == 0x000000, "Member 'GzMapMarkerWidget_SetShouldClamp::bInShouldClamp' has a wrong offset!");

// Function G01.GzMapMarkerWidget.SetZoomCurveScaleFactor
// 0x0004 (0x0004 - 0x0000)
struct GzMapMarkerWidget_SetZoomCurveScaleFactor final
{
public:
	float                                         ScaleMultiplier;                                   // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzMapMarkerWidget_SetZoomCurveScaleFactor) == 0x000004, "Wrong alignment on GzMapMarkerWidget_SetZoomCurveScaleFactor");
static_assert(sizeof(GzMapMarkerWidget_SetZoomCurveScaleFactor) == 0x000004, "Wrong size on GzMapMarkerWidget_SetZoomCurveScaleFactor");
static_assert(offsetof(GzMapMarkerWidget_SetZoomCurveScaleFactor, ScaleMultiplier) == 0x000000, "Member 'GzMapMarkerWidget_SetZoomCurveScaleFactor::ScaleMultiplier' has a wrong offset!");

// Function G01.GzMapMarkerWidget.GetScaleByZoomCurve
// 0x0004 (0x0004 - 0x0000)
struct GzMapMarkerWidget_GetScaleByZoomCurve final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzMapMarkerWidget_GetScaleByZoomCurve) == 0x000004, "Wrong alignment on GzMapMarkerWidget_GetScaleByZoomCurve");
static_assert(sizeof(GzMapMarkerWidget_GetScaleByZoomCurve) == 0x000004, "Wrong size on GzMapMarkerWidget_GetScaleByZoomCurve");
static_assert(offsetof(GzMapMarkerWidget_GetScaleByZoomCurve, ReturnValue) == 0x000000, "Member 'GzMapMarkerWidget_GetScaleByZoomCurve::ReturnValue' has a wrong offset!");

// Function G01.GzMapMarkerWidget.GetZoomCurveScaleFactor
// 0x0004 (0x0004 - 0x0000)
struct GzMapMarkerWidget_GetZoomCurveScaleFactor final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzMapMarkerWidget_GetZoomCurveScaleFactor) == 0x000004, "Wrong alignment on GzMapMarkerWidget_GetZoomCurveScaleFactor");
static_assert(sizeof(GzMapMarkerWidget_GetZoomCurveScaleFactor) == 0x000004, "Wrong size on GzMapMarkerWidget_GetZoomCurveScaleFactor");
static_assert(offsetof(GzMapMarkerWidget_GetZoomCurveScaleFactor, ReturnValue) == 0x000000, "Member 'GzMapMarkerWidget_GetZoomCurveScaleFactor::ReturnValue' has a wrong offset!");

// Function G01.GzMapMarkerWidget.K2_ShouldShow
// 0x0001 (0x0001 - 0x0000)
struct GzMapMarkerWidget_K2_ShouldShow final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzMapMarkerWidget_K2_ShouldShow) == 0x000001, "Wrong alignment on GzMapMarkerWidget_K2_ShouldShow");
static_assert(sizeof(GzMapMarkerWidget_K2_ShouldShow) == 0x000001, "Wrong size on GzMapMarkerWidget_K2_ShouldShow");
static_assert(offsetof(GzMapMarkerWidget_K2_ShouldShow, ReturnValue) == 0x000000, "Member 'GzMapMarkerWidget_K2_ShouldShow::ReturnValue' has a wrong offset!");

// Function G01.GzMapMarkerWidget.ShouldBeClamped
// 0x0001 (0x0001 - 0x0000)
struct GzMapMarkerWidget_ShouldBeClamped final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzMapMarkerWidget_ShouldBeClamped) == 0x000001, "Wrong alignment on GzMapMarkerWidget_ShouldBeClamped");
static_assert(sizeof(GzMapMarkerWidget_ShouldBeClamped) == 0x000001, "Wrong size on GzMapMarkerWidget_ShouldBeClamped");
static_assert(offsetof(GzMapMarkerWidget_ShouldBeClamped, ReturnValue) == 0x000000, "Member 'GzMapMarkerWidget_ShouldBeClamped::ReturnValue' has a wrong offset!");

// Function G01.GzAliveObjectAttributeSet.OnRep_Damage
// 0x0010 (0x0010 - 0x0000)
struct GzAliveObjectAttributeSet_OnRep_Damage final
{
public:
	struct FGameplayAttributeData                 OldDamage;                                         // 0x0000(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzAliveObjectAttributeSet_OnRep_Damage) == 0x000008, "Wrong alignment on GzAliveObjectAttributeSet_OnRep_Damage");
static_assert(sizeof(GzAliveObjectAttributeSet_OnRep_Damage) == 0x000010, "Wrong size on GzAliveObjectAttributeSet_OnRep_Damage");
static_assert(offsetof(GzAliveObjectAttributeSet_OnRep_Damage, OldDamage) == 0x000000, "Member 'GzAliveObjectAttributeSet_OnRep_Damage::OldDamage' has a wrong offset!");

// Function G01.GzAliveObjectAttributeSet.OnRep_Health
// 0x0010 (0x0010 - 0x0000)
struct GzAliveObjectAttributeSet_OnRep_Health final
{
public:
	struct FGameplayAttributeData                 OldHealth;                                         // 0x0000(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzAliveObjectAttributeSet_OnRep_Health) == 0x000008, "Wrong alignment on GzAliveObjectAttributeSet_OnRep_Health");
static_assert(sizeof(GzAliveObjectAttributeSet_OnRep_Health) == 0x000010, "Wrong size on GzAliveObjectAttributeSet_OnRep_Health");
static_assert(offsetof(GzAliveObjectAttributeSet_OnRep_Health, OldHealth) == 0x000000, "Member 'GzAliveObjectAttributeSet_OnRep_Health::OldHealth' has a wrong offset!");

// Function G01.GzAliveObjectAttributeSet.OnRep_MaxHealth
// 0x0010 (0x0010 - 0x0000)
struct GzAliveObjectAttributeSet_OnRep_MaxHealth final
{
public:
	struct FGameplayAttributeData                 OldMaxHealth;                                      // 0x0000(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzAliveObjectAttributeSet_OnRep_MaxHealth) == 0x000008, "Wrong alignment on GzAliveObjectAttributeSet_OnRep_MaxHealth");
static_assert(sizeof(GzAliveObjectAttributeSet_OnRep_MaxHealth) == 0x000010, "Wrong size on GzAliveObjectAttributeSet_OnRep_MaxHealth");
static_assert(offsetof(GzAliveObjectAttributeSet_OnRep_MaxHealth, OldMaxHealth) == 0x000000, "Member 'GzAliveObjectAttributeSet_OnRep_MaxHealth::OldMaxHealth' has a wrong offset!");

// Function G01.GzGA_ReloadHolsteredWeapons.OnAmmoAdded
// 0x0018 (0x0018 - 0x0000)
struct GzGA_ReloadHolsteredWeapons_OnAmmoAdded final
{
public:
	struct FGzInvItem                             Item;                                              // 0x0000(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	EGzInvChangeEvent                             Event;                                             // 0x0010(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2DE5[0x7];                                     // 0x0011(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GzGA_ReloadHolsteredWeapons_OnAmmoAdded) == 0x000008, "Wrong alignment on GzGA_ReloadHolsteredWeapons_OnAmmoAdded");
static_assert(sizeof(GzGA_ReloadHolsteredWeapons_OnAmmoAdded) == 0x000018, "Wrong size on GzGA_ReloadHolsteredWeapons_OnAmmoAdded");
static_assert(offsetof(GzGA_ReloadHolsteredWeapons_OnAmmoAdded, Item) == 0x000000, "Member 'GzGA_ReloadHolsteredWeapons_OnAmmoAdded::Item' has a wrong offset!");
static_assert(offsetof(GzGA_ReloadHolsteredWeapons_OnAmmoAdded, Event) == 0x000010, "Member 'GzGA_ReloadHolsteredWeapons_OnAmmoAdded::Event' has a wrong offset!");

// Function G01.GzGA_ReloadHolsteredWeapons.OnWeaponPocketChanged
// 0x0008 (0x0008 - 0x0000)
struct GzGA_ReloadHolsteredWeapons_OnWeaponPocketChanged final
{
public:
	struct FGzInvPocketId                         PocketId;                                          // 0x0000(0x0008)(Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzGA_ReloadHolsteredWeapons_OnWeaponPocketChanged) == 0x000004, "Wrong alignment on GzGA_ReloadHolsteredWeapons_OnWeaponPocketChanged");
static_assert(sizeof(GzGA_ReloadHolsteredWeapons_OnWeaponPocketChanged) == 0x000008, "Wrong size on GzGA_ReloadHolsteredWeapons_OnWeaponPocketChanged");
static_assert(offsetof(GzGA_ReloadHolsteredWeapons_OnWeaponPocketChanged, PocketId) == 0x000000, "Member 'GzGA_ReloadHolsteredWeapons_OnWeaponPocketChanged::PocketId' has a wrong offset!");

// Function G01.GzItemData.CanBeAccessBy
// 0x0002 (0x0002 - 0x0000)
struct GzItemData_CanBeAccessBy final
{
public:
	EGzItemAccessPermission                       PermissionMask;                                    // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0001(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzItemData_CanBeAccessBy) == 0x000001, "Wrong alignment on GzItemData_CanBeAccessBy");
static_assert(sizeof(GzItemData_CanBeAccessBy) == 0x000002, "Wrong size on GzItemData_CanBeAccessBy");
static_assert(offsetof(GzItemData_CanBeAccessBy, PermissionMask) == 0x000000, "Member 'GzItemData_CanBeAccessBy::PermissionMask' has a wrong offset!");
static_assert(offsetof(GzItemData_CanBeAccessBy, ReturnValue) == 0x000001, "Member 'GzItemData_CanBeAccessBy::ReturnValue' has a wrong offset!");

// Function G01.GzItemData.GetHUDIconByTag
// 0x0038 (0x0038 - 0x0000)
struct GzItemData_GetHUDIconByTag final
{
public:
	struct FGameplayTag                           IconTag;                                           // 0x0000(0x0008)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bWarnOnMissingTag;                                 // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2DEF[0x7];                                     // 0x0009(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftObjectPtr<class UTexture2D>              ReturnValue;                                       // 0x0010(0x0028)(Parm, OutParm, ReturnParm, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzItemData_GetHUDIconByTag) == 0x000008, "Wrong alignment on GzItemData_GetHUDIconByTag");
static_assert(sizeof(GzItemData_GetHUDIconByTag) == 0x000038, "Wrong size on GzItemData_GetHUDIconByTag");
static_assert(offsetof(GzItemData_GetHUDIconByTag, IconTag) == 0x000000, "Member 'GzItemData_GetHUDIconByTag::IconTag' has a wrong offset!");
static_assert(offsetof(GzItemData_GetHUDIconByTag, bWarnOnMissingTag) == 0x000008, "Member 'GzItemData_GetHUDIconByTag::bWarnOnMissingTag' has a wrong offset!");
static_assert(offsetof(GzItemData_GetHUDIconByTag, ReturnValue) == 0x000010, "Member 'GzItemData_GetHUDIconByTag::ReturnValue' has a wrong offset!");

// Function G01.GzItemData.GetIdentifierString
// 0x0010 (0x0010 - 0x0000)
struct GzItemData_GetIdentifierString final
{
public:
	class FString                                 ReturnValue;                                       // 0x0000(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzItemData_GetIdentifierString) == 0x000008, "Wrong alignment on GzItemData_GetIdentifierString");
static_assert(sizeof(GzItemData_GetIdentifierString) == 0x000010, "Wrong size on GzItemData_GetIdentifierString");
static_assert(offsetof(GzItemData_GetIdentifierString, ReturnValue) == 0x000000, "Member 'GzItemData_GetIdentifierString::ReturnValue' has a wrong offset!");

// Function G01.GzItemData.GetRarity
// 0x0001 (0x0001 - 0x0000)
struct GzItemData_GetRarity final
{
public:
	EGzItemRarity                                 ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzItemData_GetRarity) == 0x000001, "Wrong alignment on GzItemData_GetRarity");
static_assert(sizeof(GzItemData_GetRarity) == 0x000001, "Wrong size on GzItemData_GetRarity");
static_assert(offsetof(GzItemData_GetRarity, ReturnValue) == 0x000000, "Member 'GzItemData_GetRarity::ReturnValue' has a wrong offset!");

// Function G01.GzItemData.GetShortDescription
// 0x0010 (0x0010 - 0x0000)
struct GzItemData_GetShortDescription final
{
public:
	class FText                                   ReturnValue;                                       // 0x0000(0x0010)(ConstParm, Parm, OutParm, ReturnParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzItemData_GetShortDescription) == 0x000008, "Wrong alignment on GzItemData_GetShortDescription");
static_assert(sizeof(GzItemData_GetShortDescription) == 0x000010, "Wrong size on GzItemData_GetShortDescription");
static_assert(offsetof(GzItemData_GetShortDescription, ReturnValue) == 0x000000, "Member 'GzItemData_GetShortDescription::ReturnValue' has a wrong offset!");

// Function G01.GzAnimatedAi.GetMentalState
// 0x0001 (0x0001 - 0x0000)
struct GzAnimatedAi_GetMentalState final
{
public:
	EGzNPCMentalState                             ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzAnimatedAi_GetMentalState) == 0x000001, "Wrong alignment on GzAnimatedAi_GetMentalState");
static_assert(sizeof(GzAnimatedAi_GetMentalState) == 0x000001, "Wrong size on GzAnimatedAi_GetMentalState");
static_assert(offsetof(GzAnimatedAi_GetMentalState, ReturnValue) == 0x000000, "Member 'GzAnimatedAi_GetMentalState::ReturnValue' has a wrong offset!");

// Function G01.GzAnimatedAi.GetTrackingTargetPosition
// 0x0018 (0x0018 - 0x0000)
struct GzAnimatedAi_GetTrackingTargetPosition final
{
public:
	struct FVector                                ReturnValue;                                       // 0x0000(0x0018)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzAnimatedAi_GetTrackingTargetPosition) == 0x000008, "Wrong alignment on GzAnimatedAi_GetTrackingTargetPosition");
static_assert(sizeof(GzAnimatedAi_GetTrackingTargetPosition) == 0x000018, "Wrong size on GzAnimatedAi_GetTrackingTargetPosition");
static_assert(offsetof(GzAnimatedAi_GetTrackingTargetPosition, ReturnValue) == 0x000000, "Member 'GzAnimatedAi_GetTrackingTargetPosition::ReturnValue' has a wrong offset!");

// Function G01.GzInteractionComponent.GetFailedInteractionText
// 0x0010 (0x0010 - 0x0000)
struct GzInteractionComponent_GetFailedInteractionText final
{
public:
	class FText                                   ReturnValue;                                       // 0x0000(0x0010)(ConstParm, Parm, OutParm, ReturnParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzInteractionComponent_GetFailedInteractionText) == 0x000008, "Wrong alignment on GzInteractionComponent_GetFailedInteractionText");
static_assert(sizeof(GzInteractionComponent_GetFailedInteractionText) == 0x000010, "Wrong size on GzInteractionComponent_GetFailedInteractionText");
static_assert(offsetof(GzInteractionComponent_GetFailedInteractionText, ReturnValue) == 0x000000, "Member 'GzInteractionComponent_GetFailedInteractionText::ReturnValue' has a wrong offset!");

// Function G01.GzInteractionComponent.GetInteractionConditionsPassed
// 0x0001 (0x0001 - 0x0000)
struct GzInteractionComponent_GetInteractionConditionsPassed final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzInteractionComponent_GetInteractionConditionsPassed) == 0x000001, "Wrong alignment on GzInteractionComponent_GetInteractionConditionsPassed");
static_assert(sizeof(GzInteractionComponent_GetInteractionConditionsPassed) == 0x000001, "Wrong size on GzInteractionComponent_GetInteractionConditionsPassed");
static_assert(offsetof(GzInteractionComponent_GetInteractionConditionsPassed, ReturnValue) == 0x000000, "Member 'GzInteractionComponent_GetInteractionConditionsPassed::ReturnValue' has a wrong offset!");

// Function G01.GzPreMatchStage.CheckAllReady
// 0x0008 (0x0008 - 0x0000)
struct GzPreMatchStage_CheckAllReady final
{
public:
	class AGzPlayerState*                         NewPlayerState;                                    // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzPreMatchStage_CheckAllReady) == 0x000008, "Wrong alignment on GzPreMatchStage_CheckAllReady");
static_assert(sizeof(GzPreMatchStage_CheckAllReady) == 0x000008, "Wrong size on GzPreMatchStage_CheckAllReady");
static_assert(offsetof(GzPreMatchStage_CheckAllReady, NewPlayerState) == 0x000000, "Member 'GzPreMatchStage_CheckAllReady::NewPlayerState' has a wrong offset!");

// Function G01.GzWeaponUdimSkinData.ApplyParametersForMesh
// 0x0008 (0x0008 - 0x0000)
struct GzWeaponUdimSkinData_ApplyParametersForMesh final
{
public:
	class UMeshComponent*                         Mesh;                                              // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzWeaponUdimSkinData_ApplyParametersForMesh) == 0x000008, "Wrong alignment on GzWeaponUdimSkinData_ApplyParametersForMesh");
static_assert(sizeof(GzWeaponUdimSkinData_ApplyParametersForMesh) == 0x000008, "Wrong size on GzWeaponUdimSkinData_ApplyParametersForMesh");
static_assert(offsetof(GzWeaponUdimSkinData_ApplyParametersForMesh, Mesh) == 0x000000, "Member 'GzWeaponUdimSkinData_ApplyParametersForMesh::Mesh' has a wrong offset!");

// Function G01.GzWeaponUdimSkinData.ApplyParametersForMeshArray
// 0x0010 (0x0010 - 0x0000)
struct GzWeaponUdimSkinData_ApplyParametersForMeshArray final
{
public:
	TArray<class UMeshComponent*>                 Meshes;                                            // 0x0000(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzWeaponUdimSkinData_ApplyParametersForMeshArray) == 0x000008, "Wrong alignment on GzWeaponUdimSkinData_ApplyParametersForMeshArray");
static_assert(sizeof(GzWeaponUdimSkinData_ApplyParametersForMeshArray) == 0x000010, "Wrong size on GzWeaponUdimSkinData_ApplyParametersForMeshArray");
static_assert(offsetof(GzWeaponUdimSkinData_ApplyParametersForMeshArray, Meshes) == 0x000000, "Member 'GzWeaponUdimSkinData_ApplyParametersForMeshArray::Meshes' has a wrong offset!");

// Function G01.GzWeaponUdimSkinData.GetIndexNumbersArray
// 0x0010 (0x0010 - 0x0000)
struct GzWeaponUdimSkinData_GetIndexNumbersArray final
{
public:
	TArray<float>                                 Values;                                            // 0x0000(0x0010)(Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzWeaponUdimSkinData_GetIndexNumbersArray) == 0x000008, "Wrong alignment on GzWeaponUdimSkinData_GetIndexNumbersArray");
static_assert(sizeof(GzWeaponUdimSkinData_GetIndexNumbersArray) == 0x000010, "Wrong size on GzWeaponUdimSkinData_GetIndexNumbersArray");
static_assert(offsetof(GzWeaponUdimSkinData_GetIndexNumbersArray, Values) == 0x000000, "Member 'GzWeaponUdimSkinData_GetIndexNumbersArray::Values' has a wrong offset!");

// Function G01.GzSearchZone.OnShrinkingZoneAvailable
// 0x0008 (0x0008 - 0x0000)
struct GzSearchZone_OnShrinkingZoneAvailable final
{
public:
	class AGzShrinkingZone*                       Zone;                                              // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzSearchZone_OnShrinkingZoneAvailable) == 0x000008, "Wrong alignment on GzSearchZone_OnShrinkingZoneAvailable");
static_assert(sizeof(GzSearchZone_OnShrinkingZoneAvailable) == 0x000008, "Wrong size on GzSearchZone_OnShrinkingZoneAvailable");
static_assert(offsetof(GzSearchZone_OnShrinkingZoneAvailable, Zone) == 0x000000, "Member 'GzSearchZone_OnShrinkingZoneAvailable::Zone' has a wrong offset!");

// Function G01.GzCrosshairContainer.OnAdsUpdated
// 0x0001 (0x0001 - 0x0000)
struct GzCrosshairContainer_OnAdsUpdated final
{
public:
	bool                                          bIsInAds;                                          // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzCrosshairContainer_OnAdsUpdated) == 0x000001, "Wrong alignment on GzCrosshairContainer_OnAdsUpdated");
static_assert(sizeof(GzCrosshairContainer_OnAdsUpdated) == 0x000001, "Wrong size on GzCrosshairContainer_OnAdsUpdated");
static_assert(offsetof(GzCrosshairContainer_OnAdsUpdated, bIsInAds) == 0x000000, "Member 'GzCrosshairContainer_OnAdsUpdated::bIsInAds' has a wrong offset!");

// Function G01.GzCrosshairContainer.OnLimbChanged
// 0x0001 (0x0001 - 0x0000)
struct GzCrosshairContainer_OnLimbChanged final
{
public:
	EGzLimbType                                   LimbType;                                          // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzCrosshairContainer_OnLimbChanged) == 0x000001, "Wrong alignment on GzCrosshairContainer_OnLimbChanged");
static_assert(sizeof(GzCrosshairContainer_OnLimbChanged) == 0x000001, "Wrong size on GzCrosshairContainer_OnLimbChanged");
static_assert(offsetof(GzCrosshairContainer_OnLimbChanged, LimbType) == 0x000000, "Member 'GzCrosshairContainer_OnLimbChanged::LimbType' has a wrong offset!");

// Function G01.GzCrosshairContainer.OnOperableObjectChanged
// 0x0008 (0x0008 - 0x0000)
struct GzCrosshairContainer_OnOperableObjectChanged final
{
public:
	class UGzOperableObjectComponent*             OperableObjectComponent;                           // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzCrosshairContainer_OnOperableObjectChanged) == 0x000008, "Wrong alignment on GzCrosshairContainer_OnOperableObjectChanged");
static_assert(sizeof(GzCrosshairContainer_OnOperableObjectChanged) == 0x000008, "Wrong size on GzCrosshairContainer_OnOperableObjectChanged");
static_assert(offsetof(GzCrosshairContainer_OnOperableObjectChanged, OperableObjectComponent) == 0x000000, "Member 'GzCrosshairContainer_OnOperableObjectChanged::OperableObjectComponent' has a wrong offset!");

// Function G01.GzCrosshairContainer.OnTriggerUpdateTagsUpdated
// 0x0001 (0x0001 - 0x0000)
struct GzCrosshairContainer_OnTriggerUpdateTagsUpdated final
{
public:
	bool                                          bWasAdded;                                         // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzCrosshairContainer_OnTriggerUpdateTagsUpdated) == 0x000001, "Wrong alignment on GzCrosshairContainer_OnTriggerUpdateTagsUpdated");
static_assert(sizeof(GzCrosshairContainer_OnTriggerUpdateTagsUpdated) == 0x000001, "Wrong size on GzCrosshairContainer_OnTriggerUpdateTagsUpdated");
static_assert(offsetof(GzCrosshairContainer_OnTriggerUpdateTagsUpdated, bWasAdded) == 0x000000, "Member 'GzCrosshairContainer_OnTriggerUpdateTagsUpdated::bWasAdded' has a wrong offset!");

// Function G01.GzCrosshairContainer.OnVehicleSeatChanged
// 0x0010 (0x0010 - 0x0000)
struct GzCrosshairContainer_OnVehicleSeatChanged final
{
public:
	class AGzCharacter*                           Character;                                         // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EGzVehicleSeatType                            NewSeat;                                           // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EGzVehicleSeatType                            OldSeat;                                           // 0x0009(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2E0F[0x6];                                     // 0x000A(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GzCrosshairContainer_OnVehicleSeatChanged) == 0x000008, "Wrong alignment on GzCrosshairContainer_OnVehicleSeatChanged");
static_assert(sizeof(GzCrosshairContainer_OnVehicleSeatChanged) == 0x000010, "Wrong size on GzCrosshairContainer_OnVehicleSeatChanged");
static_assert(offsetof(GzCrosshairContainer_OnVehicleSeatChanged, Character) == 0x000000, "Member 'GzCrosshairContainer_OnVehicleSeatChanged::Character' has a wrong offset!");
static_assert(offsetof(GzCrosshairContainer_OnVehicleSeatChanged, NewSeat) == 0x000008, "Member 'GzCrosshairContainer_OnVehicleSeatChanged::NewSeat' has a wrong offset!");
static_assert(offsetof(GzCrosshairContainer_OnVehicleSeatChanged, OldSeat) == 0x000009, "Member 'GzCrosshairContainer_OnVehicleSeatChanged::OldSeat' has a wrong offset!");

// Function G01.GzCrosshairContainer.OnWeaponUpdated
// 0x0010 (0x0010 - 0x0000)
struct GzCrosshairContainer_OnWeaponUpdated final
{
public:
	struct FGzInvPocketId                         PocketId;                                          // 0x0000(0x0008)(Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AGzWeaponActor*                         WeaponActor;                                       // 0x0008(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzCrosshairContainer_OnWeaponUpdated) == 0x000008, "Wrong alignment on GzCrosshairContainer_OnWeaponUpdated");
static_assert(sizeof(GzCrosshairContainer_OnWeaponUpdated) == 0x000010, "Wrong size on GzCrosshairContainer_OnWeaponUpdated");
static_assert(offsetof(GzCrosshairContainer_OnWeaponUpdated, PocketId) == 0x000000, "Member 'GzCrosshairContainer_OnWeaponUpdated::PocketId' has a wrong offset!");
static_assert(offsetof(GzCrosshairContainer_OnWeaponUpdated, WeaponActor) == 0x000008, "Member 'GzCrosshairContainer_OnWeaponUpdated::WeaponActor' has a wrong offset!");

// Function G01.GzCrosshairContainer.GetCurrentCrosshair
// 0x0008 (0x0008 - 0x0000)
struct GzCrosshairContainer_GetCurrentCrosshair final
{
public:
	class UGzCrosshair*                           ReturnValue;                                       // 0x0000(0x0008)(ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzCrosshairContainer_GetCurrentCrosshair) == 0x000008, "Wrong alignment on GzCrosshairContainer_GetCurrentCrosshair");
static_assert(sizeof(GzCrosshairContainer_GetCurrentCrosshair) == 0x000008, "Wrong size on GzCrosshairContainer_GetCurrentCrosshair");
static_assert(offsetof(GzCrosshairContainer_GetCurrentCrosshair, ReturnValue) == 0x000000, "Member 'GzCrosshairContainer_GetCurrentCrosshair::ReturnValue' has a wrong offset!");

// Function G01.GzCrosshairContainer.OnAimUpdatedBP
// 0x0020 (0x0020 - 0x0000)
struct GzCrosshairContainer_OnAimUpdatedBP final
{
public:
	struct FVector                                blockedLocation;                                   // 0x0000(0x0018)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsBlocked;                                        // 0x0018(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2E10[0x7];                                     // 0x0019(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GzCrosshairContainer_OnAimUpdatedBP) == 0x000008, "Wrong alignment on GzCrosshairContainer_OnAimUpdatedBP");
static_assert(sizeof(GzCrosshairContainer_OnAimUpdatedBP) == 0x000020, "Wrong size on GzCrosshairContainer_OnAimUpdatedBP");
static_assert(offsetof(GzCrosshairContainer_OnAimUpdatedBP, blockedLocation) == 0x000000, "Member 'GzCrosshairContainer_OnAimUpdatedBP::blockedLocation' has a wrong offset!");
static_assert(offsetof(GzCrosshairContainer_OnAimUpdatedBP, bIsBlocked) == 0x000018, "Member 'GzCrosshairContainer_OnAimUpdatedBP::bIsBlocked' has a wrong offset!");

// Function G01.GzGameModeBase.GetSubsystemByClass
// 0x0010 (0x0010 - 0x0000)
struct GzGameModeBase_GetSubsystemByClass final
{
public:
	TSubclassOf<class AGzGameModeSubsystem>       InClass;                                           // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AGzGameModeSubsystem*                   ReturnValue;                                       // 0x0008(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzGameModeBase_GetSubsystemByClass) == 0x000008, "Wrong alignment on GzGameModeBase_GetSubsystemByClass");
static_assert(sizeof(GzGameModeBase_GetSubsystemByClass) == 0x000010, "Wrong size on GzGameModeBase_GetSubsystemByClass");
static_assert(offsetof(GzGameModeBase_GetSubsystemByClass, InClass) == 0x000000, "Member 'GzGameModeBase_GetSubsystemByClass::InClass' has a wrong offset!");
static_assert(offsetof(GzGameModeBase_GetSubsystemByClass, ReturnValue) == 0x000008, "Member 'GzGameModeBase_GetSubsystemByClass::ReturnValue' has a wrong offset!");

// Function G01.GzGameModeBase.RestartPlayerInMatch
// 0x0008 (0x0008 - 0x0000)
struct GzGameModeBase_RestartPlayerInMatch final
{
public:
	class AController*                            PlayerController;                                  // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzGameModeBase_RestartPlayerInMatch) == 0x000008, "Wrong alignment on GzGameModeBase_RestartPlayerInMatch");
static_assert(sizeof(GzGameModeBase_RestartPlayerInMatch) == 0x000008, "Wrong size on GzGameModeBase_RestartPlayerInMatch");
static_assert(offsetof(GzGameModeBase_RestartPlayerInMatch, PlayerController) == 0x000000, "Member 'GzGameModeBase_RestartPlayerInMatch::PlayerController' has a wrong offset!");

// Function G01.GzGameModeBase.RestartPlayerInMatchAtTransform
// 0x0070 (0x0070 - 0x0000)
struct GzGameModeBase_RestartPlayerInMatchAtTransform final
{
public:
	class AController*                            PlayerController;                                  // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2E12[0x8];                                     // 0x0008(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             Transform;                                         // 0x0010(0x0060)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzGameModeBase_RestartPlayerInMatchAtTransform) == 0x000010, "Wrong alignment on GzGameModeBase_RestartPlayerInMatchAtTransform");
static_assert(sizeof(GzGameModeBase_RestartPlayerInMatchAtTransform) == 0x000070, "Wrong size on GzGameModeBase_RestartPlayerInMatchAtTransform");
static_assert(offsetof(GzGameModeBase_RestartPlayerInMatchAtTransform, PlayerController) == 0x000000, "Member 'GzGameModeBase_RestartPlayerInMatchAtTransform::PlayerController' has a wrong offset!");
static_assert(offsetof(GzGameModeBase_RestartPlayerInMatchAtTransform, Transform) == 0x000010, "Member 'GzGameModeBase_RestartPlayerInMatchAtTransform::Transform' has a wrong offset!");

// Function G01.GzGameModeBase.GetDisplayName
// 0x0010 (0x0010 - 0x0000)
struct GzGameModeBase_GetDisplayName final
{
public:
	class FString                                 ReturnValue;                                       // 0x0000(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzGameModeBase_GetDisplayName) == 0x000008, "Wrong alignment on GzGameModeBase_GetDisplayName");
static_assert(sizeof(GzGameModeBase_GetDisplayName) == 0x000010, "Wrong size on GzGameModeBase_GetDisplayName");
static_assert(offsetof(GzGameModeBase_GetDisplayName, ReturnValue) == 0x000000, "Member 'GzGameModeBase_GetDisplayName::ReturnValue' has a wrong offset!");

// Function G01.GzSessionGameModeBase.OnAIDied
// 0x0008 (0x0008 - 0x0000)
struct GzSessionGameModeBase_OnAIDied final
{
public:
	class AGzAIController*                        Controller;                                        // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzSessionGameModeBase_OnAIDied) == 0x000008, "Wrong alignment on GzSessionGameModeBase_OnAIDied");
static_assert(sizeof(GzSessionGameModeBase_OnAIDied) == 0x000008, "Wrong size on GzSessionGameModeBase_OnAIDied");
static_assert(offsetof(GzSessionGameModeBase_OnAIDied, Controller) == 0x000000, "Member 'GzSessionGameModeBase_OnAIDied::Controller' has a wrong offset!");

// Function G01.GzSessionGameModeBase.OnAISpawned
// 0x0008 (0x0008 - 0x0000)
struct GzSessionGameModeBase_OnAISpawned final
{
public:
	class AGzAIController*                        Controller;                                        // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzSessionGameModeBase_OnAISpawned) == 0x000008, "Wrong alignment on GzSessionGameModeBase_OnAISpawned");
static_assert(sizeof(GzSessionGameModeBase_OnAISpawned) == 0x000008, "Wrong size on GzSessionGameModeBase_OnAISpawned");
static_assert(offsetof(GzSessionGameModeBase_OnAISpawned, Controller) == 0x000000, "Member 'GzSessionGameModeBase_OnAISpawned::Controller' has a wrong offset!");

// Function G01.GzSessionGameModeBase.OnPlayerDied
// 0x0008 (0x0008 - 0x0000)
struct GzSessionGameModeBase_OnPlayerDied final
{
public:
	class AGzCharacter*                           Character;                                         // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzSessionGameModeBase_OnPlayerDied) == 0x000008, "Wrong alignment on GzSessionGameModeBase_OnPlayerDied");
static_assert(sizeof(GzSessionGameModeBase_OnPlayerDied) == 0x000008, "Wrong size on GzSessionGameModeBase_OnPlayerDied");
static_assert(offsetof(GzSessionGameModeBase_OnPlayerDied, Character) == 0x000000, "Member 'GzSessionGameModeBase_OnPlayerDied::Character' has a wrong offset!");

// Function G01.GzSessionGameModeBase.OnPlayerLoggedOut
// 0x0010 (0x0010 - 0x0000)
struct GzSessionGameModeBase_OnPlayerLoggedOut final
{
public:
	class AGzPlayerController*                    Player;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EGzPlayerLogoutReason                         LogoutReason;                                      // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2E16[0x7];                                     // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GzSessionGameModeBase_OnPlayerLoggedOut) == 0x000008, "Wrong alignment on GzSessionGameModeBase_OnPlayerLoggedOut");
static_assert(sizeof(GzSessionGameModeBase_OnPlayerLoggedOut) == 0x000010, "Wrong size on GzSessionGameModeBase_OnPlayerLoggedOut");
static_assert(offsetof(GzSessionGameModeBase_OnPlayerLoggedOut, Player) == 0x000000, "Member 'GzSessionGameModeBase_OnPlayerLoggedOut::Player' has a wrong offset!");
static_assert(offsetof(GzSessionGameModeBase_OnPlayerLoggedOut, LogoutReason) == 0x000008, "Member 'GzSessionGameModeBase_OnPlayerLoggedOut::LogoutReason' has a wrong offset!");

// Function G01.GzSessionGameModeBase.SpawnPlayer
// 0x0070 (0x0070 - 0x0000)
struct GzSessionGameModeBase_SpawnPlayer final
{
public:
	class AGzPlayerState*                         InPlayerState;                                     // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2E17[0x8];                                     // 0x0008(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             SpawnTransform;                                    // 0x0010(0x0060)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzSessionGameModeBase_SpawnPlayer) == 0x000010, "Wrong alignment on GzSessionGameModeBase_SpawnPlayer");
static_assert(sizeof(GzSessionGameModeBase_SpawnPlayer) == 0x000070, "Wrong size on GzSessionGameModeBase_SpawnPlayer");
static_assert(offsetof(GzSessionGameModeBase_SpawnPlayer, InPlayerState) == 0x000000, "Member 'GzSessionGameModeBase_SpawnPlayer::InPlayerState' has a wrong offset!");
static_assert(offsetof(GzSessionGameModeBase_SpawnPlayer, SpawnTransform) == 0x000010, "Member 'GzSessionGameModeBase_SpawnPlayer::SpawnTransform' has a wrong offset!");

// Function G01.GzSessionGameModeBase.CanSpawnAtPlayerStart
// 0x0018 (0x0018 - 0x0000)
struct GzSessionGameModeBase_CanSpawnAtPlayerStart final
{
public:
	const class AGzPlayerState*                   PlayerState;                                       // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	const class AGzTeamStart*                     PlayerStart;                                       // 0x0008(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0010(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2E18[0x7];                                     // 0x0011(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GzSessionGameModeBase_CanSpawnAtPlayerStart) == 0x000008, "Wrong alignment on GzSessionGameModeBase_CanSpawnAtPlayerStart");
static_assert(sizeof(GzSessionGameModeBase_CanSpawnAtPlayerStart) == 0x000018, "Wrong size on GzSessionGameModeBase_CanSpawnAtPlayerStart");
static_assert(offsetof(GzSessionGameModeBase_CanSpawnAtPlayerStart, PlayerState) == 0x000000, "Member 'GzSessionGameModeBase_CanSpawnAtPlayerStart::PlayerState' has a wrong offset!");
static_assert(offsetof(GzSessionGameModeBase_CanSpawnAtPlayerStart, PlayerStart) == 0x000008, "Member 'GzSessionGameModeBase_CanSpawnAtPlayerStart::PlayerStart' has a wrong offset!");
static_assert(offsetof(GzSessionGameModeBase_CanSpawnAtPlayerStart, ReturnValue) == 0x000010, "Member 'GzSessionGameModeBase_CanSpawnAtPlayerStart::ReturnValue' has a wrong offset!");

// Function G01.GzSessionGameModeBase.GetTotalTeamCount
// 0x0004 (0x0004 - 0x0000)
struct GzSessionGameModeBase_GetTotalTeamCount final
{
public:
	int32                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzSessionGameModeBase_GetTotalTeamCount) == 0x000004, "Wrong alignment on GzSessionGameModeBase_GetTotalTeamCount");
static_assert(sizeof(GzSessionGameModeBase_GetTotalTeamCount) == 0x000004, "Wrong size on GzSessionGameModeBase_GetTotalTeamCount");
static_assert(offsetof(GzSessionGameModeBase_GetTotalTeamCount, ReturnValue) == 0x000000, "Member 'GzSessionGameModeBase_GetTotalTeamCount::ReturnValue' has a wrong offset!");

// Function G01.GzSessionGameModeBase.GetWinnerTeam
// 0x0008 (0x0008 - 0x0000)
struct GzSessionGameModeBase_GetWinnerTeam final
{
public:
	class AGzTeam*                                ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzSessionGameModeBase_GetWinnerTeam) == 0x000008, "Wrong alignment on GzSessionGameModeBase_GetWinnerTeam");
static_assert(sizeof(GzSessionGameModeBase_GetWinnerTeam) == 0x000008, "Wrong size on GzSessionGameModeBase_GetWinnerTeam");
static_assert(offsetof(GzSessionGameModeBase_GetWinnerTeam, ReturnValue) == 0x000000, "Member 'GzSessionGameModeBase_GetWinnerTeam::ReturnValue' has a wrong offset!");

// Function G01.GzMarkerSceneContainer.GetMarkerID
// 0x0004 (0x0004 - 0x0000)
struct GzMarkerSceneContainer_GetMarkerID final
{
public:
	int32                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzMarkerSceneContainer_GetMarkerID) == 0x000004, "Wrong alignment on GzMarkerSceneContainer_GetMarkerID");
static_assert(sizeof(GzMarkerSceneContainer_GetMarkerID) == 0x000004, "Wrong size on GzMarkerSceneContainer_GetMarkerID");
static_assert(offsetof(GzMarkerSceneContainer_GetMarkerID, ReturnValue) == 0x000000, "Member 'GzMarkerSceneContainer_GetMarkerID::ReturnValue' has a wrong offset!");

// Function G01.GzArrivalMarker.GetArrivalTime
// 0x0004 (0x0004 - 0x0000)
struct GzArrivalMarker_GetArrivalTime final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzArrivalMarker_GetArrivalTime) == 0x000004, "Wrong alignment on GzArrivalMarker_GetArrivalTime");
static_assert(sizeof(GzArrivalMarker_GetArrivalTime) == 0x000004, "Wrong size on GzArrivalMarker_GetArrivalTime");
static_assert(offsetof(GzArrivalMarker_GetArrivalTime, ReturnValue) == 0x000000, "Member 'GzArrivalMarker_GetArrivalTime::ReturnValue' has a wrong offset!");

// Function G01.GzMicroMissileCarrier.SpawnMicroMissile
// 0x0004 (0x0004 - 0x0000)
struct GzMicroMissileCarrier_SpawnMicroMissile final
{
public:
	int32                                         MissileIndex;                                      // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzMicroMissileCarrier_SpawnMicroMissile) == 0x000004, "Wrong alignment on GzMicroMissileCarrier_SpawnMicroMissile");
static_assert(sizeof(GzMicroMissileCarrier_SpawnMicroMissile) == 0x000004, "Wrong size on GzMicroMissileCarrier_SpawnMicroMissile");
static_assert(offsetof(GzMicroMissileCarrier_SpawnMicroMissile, MissileIndex) == 0x000000, "Member 'GzMicroMissileCarrier_SpawnMicroMissile::MissileIndex' has a wrong offset!");

// Function G01.GzASCBlueprintFunctionLibrary.AddGameplayCue_NonReplicated
// 0x00E8 (0x00E8 - 0x0000)
struct GzASCBlueprintFunctionLibrary_AddGameplayCue_NonReplicated final
{
public:
	class AActor*                                 Target;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           GameplayCueTag;                                    // 0x0008(0x0008)(ConstParm, Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayCueParameters                 Parameters;                                        // 0x0010(0x00D8)(ConstParm, Parm, OutParm, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzASCBlueprintFunctionLibrary_AddGameplayCue_NonReplicated) == 0x000008, "Wrong alignment on GzASCBlueprintFunctionLibrary_AddGameplayCue_NonReplicated");
static_assert(sizeof(GzASCBlueprintFunctionLibrary_AddGameplayCue_NonReplicated) == 0x0000E8, "Wrong size on GzASCBlueprintFunctionLibrary_AddGameplayCue_NonReplicated");
static_assert(offsetof(GzASCBlueprintFunctionLibrary_AddGameplayCue_NonReplicated, Target) == 0x000000, "Member 'GzASCBlueprintFunctionLibrary_AddGameplayCue_NonReplicated::Target' has a wrong offset!");
static_assert(offsetof(GzASCBlueprintFunctionLibrary_AddGameplayCue_NonReplicated, GameplayCueTag) == 0x000008, "Member 'GzASCBlueprintFunctionLibrary_AddGameplayCue_NonReplicated::GameplayCueTag' has a wrong offset!");
static_assert(offsetof(GzASCBlueprintFunctionLibrary_AddGameplayCue_NonReplicated, Parameters) == 0x000010, "Member 'GzASCBlueprintFunctionLibrary_AddGameplayCue_NonReplicated::Parameters' has a wrong offset!");

// Function G01.GzASCBlueprintFunctionLibrary.EffectContextAddSourceObject
// 0x0020 (0x0020 - 0x0000)
struct GzASCBlueprintFunctionLibrary_EffectContextAddSourceObject final
{
public:
	struct FGameplayEffectContextHandle           EffectContext;                                     // 0x0000(0x0018)(Parm, NativeAccessSpecifierPublic)
	class UObject*                                SourceObject;                                      // 0x0018(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzASCBlueprintFunctionLibrary_EffectContextAddSourceObject) == 0x000008, "Wrong alignment on GzASCBlueprintFunctionLibrary_EffectContextAddSourceObject");
static_assert(sizeof(GzASCBlueprintFunctionLibrary_EffectContextAddSourceObject) == 0x000020, "Wrong size on GzASCBlueprintFunctionLibrary_EffectContextAddSourceObject");
static_assert(offsetof(GzASCBlueprintFunctionLibrary_EffectContextAddSourceObject, EffectContext) == 0x000000, "Member 'GzASCBlueprintFunctionLibrary_EffectContextAddSourceObject::EffectContext' has a wrong offset!");
static_assert(offsetof(GzASCBlueprintFunctionLibrary_EffectContextAddSourceObject, SourceObject) == 0x000018, "Member 'GzASCBlueprintFunctionLibrary_EffectContextAddSourceObject::SourceObject' has a wrong offset!");

// Function G01.GzASCBlueprintFunctionLibrary.ExecuteGameplayCue_NonReplicated
// 0x00E8 (0x00E8 - 0x0000)
struct GzASCBlueprintFunctionLibrary_ExecuteGameplayCue_NonReplicated final
{
public:
	class AActor*                                 Target;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           GameplayCueTag;                                    // 0x0008(0x0008)(ConstParm, Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayCueParameters                 Parameters;                                        // 0x0010(0x00D8)(ConstParm, Parm, OutParm, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzASCBlueprintFunctionLibrary_ExecuteGameplayCue_NonReplicated) == 0x000008, "Wrong alignment on GzASCBlueprintFunctionLibrary_ExecuteGameplayCue_NonReplicated");
static_assert(sizeof(GzASCBlueprintFunctionLibrary_ExecuteGameplayCue_NonReplicated) == 0x0000E8, "Wrong size on GzASCBlueprintFunctionLibrary_ExecuteGameplayCue_NonReplicated");
static_assert(offsetof(GzASCBlueprintFunctionLibrary_ExecuteGameplayCue_NonReplicated, Target) == 0x000000, "Member 'GzASCBlueprintFunctionLibrary_ExecuteGameplayCue_NonReplicated::Target' has a wrong offset!");
static_assert(offsetof(GzASCBlueprintFunctionLibrary_ExecuteGameplayCue_NonReplicated, GameplayCueTag) == 0x000008, "Member 'GzASCBlueprintFunctionLibrary_ExecuteGameplayCue_NonReplicated::GameplayCueTag' has a wrong offset!");
static_assert(offsetof(GzASCBlueprintFunctionLibrary_ExecuteGameplayCue_NonReplicated, Parameters) == 0x000010, "Member 'GzASCBlueprintFunctionLibrary_ExecuteGameplayCue_NonReplicated::Parameters' has a wrong offset!");

// Function G01.GzASCBlueprintFunctionLibrary.RemoveGameplayCue_NonReplicated
// 0x00E8 (0x00E8 - 0x0000)
struct GzASCBlueprintFunctionLibrary_RemoveGameplayCue_NonReplicated final
{
public:
	class AActor*                                 Target;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           GameplayCueTag;                                    // 0x0008(0x0008)(ConstParm, Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayCueParameters                 Parameters;                                        // 0x0010(0x00D8)(ConstParm, Parm, OutParm, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzASCBlueprintFunctionLibrary_RemoveGameplayCue_NonReplicated) == 0x000008, "Wrong alignment on GzASCBlueprintFunctionLibrary_RemoveGameplayCue_NonReplicated");
static_assert(sizeof(GzASCBlueprintFunctionLibrary_RemoveGameplayCue_NonReplicated) == 0x0000E8, "Wrong size on GzASCBlueprintFunctionLibrary_RemoveGameplayCue_NonReplicated");
static_assert(offsetof(GzASCBlueprintFunctionLibrary_RemoveGameplayCue_NonReplicated, Target) == 0x000000, "Member 'GzASCBlueprintFunctionLibrary_RemoveGameplayCue_NonReplicated::Target' has a wrong offset!");
static_assert(offsetof(GzASCBlueprintFunctionLibrary_RemoveGameplayCue_NonReplicated, GameplayCueTag) == 0x000008, "Member 'GzASCBlueprintFunctionLibrary_RemoveGameplayCue_NonReplicated::GameplayCueTag' has a wrong offset!");
static_assert(offsetof(GzASCBlueprintFunctionLibrary_RemoveGameplayCue_NonReplicated, Parameters) == 0x000010, "Member 'GzASCBlueprintFunctionLibrary_RemoveGameplayCue_NonReplicated::Parameters' has a wrong offset!");

// Function G01.GzDamageableComponent.OnReceiveMultiHitDamage
// 0x0048 (0x0048 - 0x0000)
struct GzDamageableComponent_OnReceiveMultiHitDamage final
{
public:
	struct FGzMultiHitDamage                      Damage;                                            // 0x0000(0x0048)(ConstParm, Parm, OutParm, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzDamageableComponent_OnReceiveMultiHitDamage) == 0x000008, "Wrong alignment on GzDamageableComponent_OnReceiveMultiHitDamage");
static_assert(sizeof(GzDamageableComponent_OnReceiveMultiHitDamage) == 0x000048, "Wrong size on GzDamageableComponent_OnReceiveMultiHitDamage");
static_assert(offsetof(GzDamageableComponent_OnReceiveMultiHitDamage, Damage) == 0x000000, "Member 'GzDamageableComponent_OnReceiveMultiHitDamage::Damage' has a wrong offset!");

// Function G01.GzDamageableComponent.OnReceiveSingleHitDamage
// 0x01F0 (0x01F0 - 0x0000)
struct GzDamageableComponent_OnReceiveSingleHitDamage final
{
public:
	struct FGzSingleHitDamage                     Damage;                                            // 0x0000(0x01F0)(ConstParm, Parm, OutParm, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzDamageableComponent_OnReceiveSingleHitDamage) == 0x000008, "Wrong alignment on GzDamageableComponent_OnReceiveSingleHitDamage");
static_assert(sizeof(GzDamageableComponent_OnReceiveSingleHitDamage) == 0x0001F0, "Wrong size on GzDamageableComponent_OnReceiveSingleHitDamage");
static_assert(offsetof(GzDamageableComponent_OnReceiveSingleHitDamage, Damage) == 0x000000, "Member 'GzDamageableComponent_OnReceiveSingleHitDamage::Damage' has a wrong offset!");

// Function G01.GzDamageableComponent.ReceiveMultiHitDamage
// 0x0048 (0x0048 - 0x0000)
struct GzDamageableComponent_ReceiveMultiHitDamage final
{
public:
	struct FGzMultiHitDamage                      Damage;                                            // 0x0000(0x0048)(ConstParm, Parm, OutParm, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzDamageableComponent_ReceiveMultiHitDamage) == 0x000008, "Wrong alignment on GzDamageableComponent_ReceiveMultiHitDamage");
static_assert(sizeof(GzDamageableComponent_ReceiveMultiHitDamage) == 0x000048, "Wrong size on GzDamageableComponent_ReceiveMultiHitDamage");
static_assert(offsetof(GzDamageableComponent_ReceiveMultiHitDamage, Damage) == 0x000000, "Member 'GzDamageableComponent_ReceiveMultiHitDamage::Damage' has a wrong offset!");

// Function G01.GzDamageableComponent.ReceiveSingleHitDamage
// 0x01F0 (0x01F0 - 0x0000)
struct GzDamageableComponent_ReceiveSingleHitDamage final
{
public:
	struct FGzSingleHitDamage                     Damage;                                            // 0x0000(0x01F0)(ConstParm, Parm, OutParm, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzDamageableComponent_ReceiveSingleHitDamage) == 0x000008, "Wrong alignment on GzDamageableComponent_ReceiveSingleHitDamage");
static_assert(sizeof(GzDamageableComponent_ReceiveSingleHitDamage) == 0x0001F0, "Wrong size on GzDamageableComponent_ReceiveSingleHitDamage");
static_assert(offsetof(GzDamageableComponent_ReceiveSingleHitDamage, Damage) == 0x000000, "Member 'GzDamageableComponent_ReceiveSingleHitDamage::Damage' has a wrong offset!");

// Function G01.GzDamageableComponent.SetTeamOverride
// 0x0001 (0x0001 - 0x0000)
struct GzDamageableComponent_SetTeamOverride final
{
public:
	struct FGenericTeamId                         TeamID;                                            // 0x0000(0x0001)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzDamageableComponent_SetTeamOverride) == 0x000001, "Wrong alignment on GzDamageableComponent_SetTeamOverride");
static_assert(sizeof(GzDamageableComponent_SetTeamOverride) == 0x000001, "Wrong size on GzDamageableComponent_SetTeamOverride");
static_assert(offsetof(GzDamageableComponent_SetTeamOverride, TeamID) == 0x000000, "Member 'GzDamageableComponent_SetTeamOverride::TeamID' has a wrong offset!");

// Function G01.GzDamageableComponent.GetTeamOverride
// 0x0001 (0x0001 - 0x0000)
struct GzDamageableComponent_GetTeamOverride final
{
public:
	struct FGenericTeamId                         ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzDamageableComponent_GetTeamOverride) == 0x000001, "Wrong alignment on GzDamageableComponent_GetTeamOverride");
static_assert(sizeof(GzDamageableComponent_GetTeamOverride) == 0x000001, "Wrong size on GzDamageableComponent_GetTeamOverride");
static_assert(offsetof(GzDamageableComponent_GetTeamOverride, ReturnValue) == 0x000000, "Member 'GzDamageableComponent_GetTeamOverride::ReturnValue' has a wrong offset!");

// Function G01.GzGA_MeleeAttack.CalculateSnapDirection
// 0x0030 (0x0030 - 0x0000)
struct GzGA_MeleeAttack_CalculateSnapDirection final
{
public:
	class AActor*                                 CharacterActor;                                    // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DetectionRadius;                                   // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2E20[0x4];                                     // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                OutDirectionToEnemy;                               // 0x0010(0x0018)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         OutDistanceToEnemy;                                // 0x0028(0x0004)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x002C(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2E21[0x3];                                     // 0x002D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GzGA_MeleeAttack_CalculateSnapDirection) == 0x000008, "Wrong alignment on GzGA_MeleeAttack_CalculateSnapDirection");
static_assert(sizeof(GzGA_MeleeAttack_CalculateSnapDirection) == 0x000030, "Wrong size on GzGA_MeleeAttack_CalculateSnapDirection");
static_assert(offsetof(GzGA_MeleeAttack_CalculateSnapDirection, CharacterActor) == 0x000000, "Member 'GzGA_MeleeAttack_CalculateSnapDirection::CharacterActor' has a wrong offset!");
static_assert(offsetof(GzGA_MeleeAttack_CalculateSnapDirection, DetectionRadius) == 0x000008, "Member 'GzGA_MeleeAttack_CalculateSnapDirection::DetectionRadius' has a wrong offset!");
static_assert(offsetof(GzGA_MeleeAttack_CalculateSnapDirection, OutDirectionToEnemy) == 0x000010, "Member 'GzGA_MeleeAttack_CalculateSnapDirection::OutDirectionToEnemy' has a wrong offset!");
static_assert(offsetof(GzGA_MeleeAttack_CalculateSnapDirection, OutDistanceToEnemy) == 0x000028, "Member 'GzGA_MeleeAttack_CalculateSnapDirection::OutDistanceToEnemy' has a wrong offset!");
static_assert(offsetof(GzGA_MeleeAttack_CalculateSnapDirection, ReturnValue) == 0x00002C, "Member 'GzGA_MeleeAttack_CalculateSnapDirection::ReturnValue' has a wrong offset!");

// Function G01.GzGA_MeleeAttack.ClientPredictTargetData
// 0x0028 (0x0028 - 0x0000)
struct GzGA_MeleeAttack_ClientPredictTargetData final
{
public:
	struct FGameplayAbilityTargetDataHandle       TargetData;                                        // 0x0000(0x0028)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzGA_MeleeAttack_ClientPredictTargetData) == 0x000008, "Wrong alignment on GzGA_MeleeAttack_ClientPredictTargetData");
static_assert(sizeof(GzGA_MeleeAttack_ClientPredictTargetData) == 0x000028, "Wrong size on GzGA_MeleeAttack_ClientPredictTargetData");
static_assert(offsetof(GzGA_MeleeAttack_ClientPredictTargetData, TargetData) == 0x000000, "Member 'GzGA_MeleeAttack_ClientPredictTargetData::TargetData' has a wrong offset!");

// Function G01.GzGA_MeleeAttack.OnTagetDataAccepted
// 0x0028 (0x0028 - 0x0000)
struct GzGA_MeleeAttack_OnTagetDataAccepted final
{
public:
	struct FGameplayAbilityTargetDataHandle       TargetData;                                        // 0x0000(0x0028)(Parm, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzGA_MeleeAttack_OnTagetDataAccepted) == 0x000008, "Wrong alignment on GzGA_MeleeAttack_OnTagetDataAccepted");
static_assert(sizeof(GzGA_MeleeAttack_OnTagetDataAccepted) == 0x000028, "Wrong size on GzGA_MeleeAttack_OnTagetDataAccepted");
static_assert(offsetof(GzGA_MeleeAttack_OnTagetDataAccepted, TargetData) == 0x000000, "Member 'GzGA_MeleeAttack_OnTagetDataAccepted::TargetData' has a wrong offset!");

// Function G01.GzGA_MeleeAttack.ServerHandleClientTargetData
// 0x0028 (0x0028 - 0x0000)
struct GzGA_MeleeAttack_ServerHandleClientTargetData final
{
public:
	struct FGameplayAbilityTargetDataHandle       TargetData;                                        // 0x0000(0x0028)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzGA_MeleeAttack_ServerHandleClientTargetData) == 0x000008, "Wrong alignment on GzGA_MeleeAttack_ServerHandleClientTargetData");
static_assert(sizeof(GzGA_MeleeAttack_ServerHandleClientTargetData) == 0x000028, "Wrong size on GzGA_MeleeAttack_ServerHandleClientTargetData");
static_assert(offsetof(GzGA_MeleeAttack_ServerHandleClientTargetData, TargetData) == 0x000000, "Member 'GzGA_MeleeAttack_ServerHandleClientTargetData::TargetData' has a wrong offset!");

// Function G01.GzAssaultDrone.AddImpulse
// 0x0018 (0x0018 - 0x0000)
struct GzAssaultDrone_AddImpulse final
{
public:
	struct FVector                                Impulse;                                           // 0x0000(0x0018)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzAssaultDrone_AddImpulse) == 0x000008, "Wrong alignment on GzAssaultDrone_AddImpulse");
static_assert(sizeof(GzAssaultDrone_AddImpulse) == 0x000018, "Wrong size on GzAssaultDrone_AddImpulse");
static_assert(offsetof(GzAssaultDrone_AddImpulse, Impulse) == 0x000000, "Member 'GzAssaultDrone_AddImpulse::Impulse' has a wrong offset!");

// Function G01.GzAssaultDrone.AssignOnOwnerEvents
// 0x0008 (0x0008 - 0x0000)
struct GzAssaultDrone_AssignOnOwnerEvents final
{
public:
	class AActor*                                 NewOwner;                                          // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzAssaultDrone_AssignOnOwnerEvents) == 0x000008, "Wrong alignment on GzAssaultDrone_AssignOnOwnerEvents");
static_assert(sizeof(GzAssaultDrone_AssignOnOwnerEvents) == 0x000008, "Wrong size on GzAssaultDrone_AssignOnOwnerEvents");
static_assert(offsetof(GzAssaultDrone_AssignOnOwnerEvents, NewOwner) == 0x000000, "Member 'GzAssaultDrone_AssignOnOwnerEvents::NewOwner' has a wrong offset!");

// Function G01.GzAssaultDrone.CalculateAnimationValue
// 0x0004 (0x0004 - 0x0000)
struct GzAssaultDrone_CalculateAnimationValue final
{
public:
	float                                         DeltaSeconds;                                      // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzAssaultDrone_CalculateAnimationValue) == 0x000004, "Wrong alignment on GzAssaultDrone_CalculateAnimationValue");
static_assert(sizeof(GzAssaultDrone_CalculateAnimationValue) == 0x000004, "Wrong size on GzAssaultDrone_CalculateAnimationValue");
static_assert(offsetof(GzAssaultDrone_CalculateAnimationValue, DeltaSeconds) == 0x000000, "Member 'GzAssaultDrone_CalculateAnimationValue::DeltaSeconds' has a wrong offset!");

// Function G01.GzAssaultDrone.CalculateLifeTime
// 0x0004 (0x0004 - 0x0000)
struct GzAssaultDrone_CalculateLifeTime final
{
public:
	float                                         DeltaSeconds;                                      // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzAssaultDrone_CalculateLifeTime) == 0x000004, "Wrong alignment on GzAssaultDrone_CalculateLifeTime");
static_assert(sizeof(GzAssaultDrone_CalculateLifeTime) == 0x000004, "Wrong size on GzAssaultDrone_CalculateLifeTime");
static_assert(offsetof(GzAssaultDrone_CalculateLifeTime, DeltaSeconds) == 0x000000, "Member 'GzAssaultDrone_CalculateLifeTime::DeltaSeconds' has a wrong offset!");

// Function G01.GzAssaultDrone.GeneratePatrolVolume
// 0x0048 (0x0048 - 0x0000)
struct GzAssaultDrone_GeneratePatrolVolume final
{
public:
	struct FVector                                StartPointRef;                                     // 0x0000(0x0018)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                TargetPointRef;                                    // 0x0018(0x0018)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                ReturnValue;                                       // 0x0030(0x0018)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzAssaultDrone_GeneratePatrolVolume) == 0x000008, "Wrong alignment on GzAssaultDrone_GeneratePatrolVolume");
static_assert(sizeof(GzAssaultDrone_GeneratePatrolVolume) == 0x000048, "Wrong size on GzAssaultDrone_GeneratePatrolVolume");
static_assert(offsetof(GzAssaultDrone_GeneratePatrolVolume, StartPointRef) == 0x000000, "Member 'GzAssaultDrone_GeneratePatrolVolume::StartPointRef' has a wrong offset!");
static_assert(offsetof(GzAssaultDrone_GeneratePatrolVolume, TargetPointRef) == 0x000018, "Member 'GzAssaultDrone_GeneratePatrolVolume::TargetPointRef' has a wrong offset!");
static_assert(offsetof(GzAssaultDrone_GeneratePatrolVolume, ReturnValue) == 0x000030, "Member 'GzAssaultDrone_GeneratePatrolVolume::ReturnValue' has a wrong offset!");

// Function G01.GzAssaultDrone.OnCollisionHit
// 0x00F8 (0x00F8 - 0x0000)
struct GzAssaultDrone_OnCollisionHit final
{
public:
	struct FHitResult                             HitResult;                                         // 0x0000(0x00F8)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzAssaultDrone_OnCollisionHit) == 0x000008, "Wrong alignment on GzAssaultDrone_OnCollisionHit");
static_assert(sizeof(GzAssaultDrone_OnCollisionHit) == 0x0000F8, "Wrong size on GzAssaultDrone_OnCollisionHit");
static_assert(offsetof(GzAssaultDrone_OnCollisionHit, HitResult) == 0x000000, "Member 'GzAssaultDrone_OnCollisionHit::HitResult' has a wrong offset!");

// Function G01.GzAssaultDrone.OnOwnerDestroyed
// 0x0008 (0x0008 - 0x0000)
struct GzAssaultDrone_OnOwnerDestroyed final
{
public:
	class AActor*                                 Actor;                                             // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzAssaultDrone_OnOwnerDestroyed) == 0x000008, "Wrong alignment on GzAssaultDrone_OnOwnerDestroyed");
static_assert(sizeof(GzAssaultDrone_OnOwnerDestroyed) == 0x000008, "Wrong size on GzAssaultDrone_OnOwnerDestroyed");
static_assert(offsetof(GzAssaultDrone_OnOwnerDestroyed, Actor) == 0x000000, "Member 'GzAssaultDrone_OnOwnerDestroyed::Actor' has a wrong offset!");

// Function G01.GzAssaultDrone.OnOwnerKilled
// 0x0004 (0x0004 - 0x0000)
struct GzAssaultDrone_OnOwnerKilled final
{
public:
	int32                                         KillerId;                                          // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzAssaultDrone_OnOwnerKilled) == 0x000004, "Wrong alignment on GzAssaultDrone_OnOwnerKilled");
static_assert(sizeof(GzAssaultDrone_OnOwnerKilled) == 0x000004, "Wrong size on GzAssaultDrone_OnOwnerKilled");
static_assert(offsetof(GzAssaultDrone_OnOwnerKilled, KillerId) == 0x000000, "Member 'GzAssaultDrone_OnOwnerKilled::KillerId' has a wrong offset!");

// Function G01.GzAssaultDrone.SetFlyPoint
// 0x0018 (0x0018 - 0x0000)
struct GzAssaultDrone_SetFlyPoint final
{
public:
	struct FVector                                TargetPointRef;                                    // 0x0000(0x0018)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzAssaultDrone_SetFlyPoint) == 0x000008, "Wrong alignment on GzAssaultDrone_SetFlyPoint");
static_assert(sizeof(GzAssaultDrone_SetFlyPoint) == 0x000018, "Wrong size on GzAssaultDrone_SetFlyPoint");
static_assert(offsetof(GzAssaultDrone_SetFlyPoint, TargetPointRef) == 0x000000, "Member 'GzAssaultDrone_SetFlyPoint::TargetPointRef' has a wrong offset!");

// Function G01.GzAssaultDrone.TryFlyToPoint
// 0x0004 (0x0004 - 0x0000)
struct GzAssaultDrone_TryFlyToPoint final
{
public:
	float                                         DeltaSeconds;                                      // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzAssaultDrone_TryFlyToPoint) == 0x000004, "Wrong alignment on GzAssaultDrone_TryFlyToPoint");
static_assert(sizeof(GzAssaultDrone_TryFlyToPoint) == 0x000004, "Wrong size on GzAssaultDrone_TryFlyToPoint");
static_assert(offsetof(GzAssaultDrone_TryFlyToPoint, DeltaSeconds) == 0x000000, "Member 'GzAssaultDrone_TryFlyToPoint::DeltaSeconds' has a wrong offset!");

// Function G01.GzLoadingScreenController.StartLoadingScreen
// 0x0010 (0x0010 - 0x0000)
struct GzLoadingScreenController_StartLoadingScreen final
{
public:
	class UGzLoadingScreenContext*                Context;                                           // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsStartup;                                        // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2E31[0x7];                                     // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GzLoadingScreenController_StartLoadingScreen) == 0x000008, "Wrong alignment on GzLoadingScreenController_StartLoadingScreen");
static_assert(sizeof(GzLoadingScreenController_StartLoadingScreen) == 0x000010, "Wrong size on GzLoadingScreenController_StartLoadingScreen");
static_assert(offsetof(GzLoadingScreenController_StartLoadingScreen, Context) == 0x000000, "Member 'GzLoadingScreenController_StartLoadingScreen::Context' has a wrong offset!");
static_assert(offsetof(GzLoadingScreenController_StartLoadingScreen, bIsStartup) == 0x000008, "Member 'GzLoadingScreenController_StartLoadingScreen::bIsStartup' has a wrong offset!");

// Function G01.GzMarkerActiveStateFilter.EvaluateState
// 0x0010 (0x0010 - 0x0000)
struct GzMarkerActiveStateFilter_EvaluateState final
{
public:
	class UGzMarkerWidget*                        InMarker;                                          // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EGzMarkerActiveState                          ReturnValue;                                       // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2E32[0x7];                                     // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GzMarkerActiveStateFilter_EvaluateState) == 0x000008, "Wrong alignment on GzMarkerActiveStateFilter_EvaluateState");
static_assert(sizeof(GzMarkerActiveStateFilter_EvaluateState) == 0x000010, "Wrong size on GzMarkerActiveStateFilter_EvaluateState");
static_assert(offsetof(GzMarkerActiveStateFilter_EvaluateState, InMarker) == 0x000000, "Member 'GzMarkerActiveStateFilter_EvaluateState::InMarker' has a wrong offset!");
static_assert(offsetof(GzMarkerActiveStateFilter_EvaluateState, ReturnValue) == 0x000008, "Member 'GzMarkerActiveStateFilter_EvaluateState::ReturnValue' has a wrong offset!");

// Function G01.GzSoundAnimNotifyBase.SetActionType
// 0x0008 (0x0008 - 0x0000)
struct GzSoundAnimNotifyBase_SetActionType final
{
public:
	class FName                                   InActionType;                                      // 0x0000(0x0008)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzSoundAnimNotifyBase_SetActionType) == 0x000004, "Wrong alignment on GzSoundAnimNotifyBase_SetActionType");
static_assert(sizeof(GzSoundAnimNotifyBase_SetActionType) == 0x000008, "Wrong size on GzSoundAnimNotifyBase_SetActionType");
static_assert(offsetof(GzSoundAnimNotifyBase_SetActionType, InActionType) == 0x000000, "Member 'GzSoundAnimNotifyBase_SetActionType::InActionType' has a wrong offset!");

// Function G01.GzSoundAnimNotifyBase.SetSoundSourceBodyPart
// 0x0001 (0x0001 - 0x0000)
struct GzSoundAnimNotifyBase_SetSoundSourceBodyPart final
{
public:
	EGzSoundSourceBodyPart                        InSoundSourceBodyPart;                             // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzSoundAnimNotifyBase_SetSoundSourceBodyPart) == 0x000001, "Wrong alignment on GzSoundAnimNotifyBase_SetSoundSourceBodyPart");
static_assert(sizeof(GzSoundAnimNotifyBase_SetSoundSourceBodyPart) == 0x000001, "Wrong size on GzSoundAnimNotifyBase_SetSoundSourceBodyPart");
static_assert(offsetof(GzSoundAnimNotifyBase_SetSoundSourceBodyPart, InSoundSourceBodyPart) == 0x000000, "Member 'GzSoundAnimNotifyBase_SetSoundSourceBodyPart::InSoundSourceBodyPart' has a wrong offset!");

// Function G01.GzCustomizationSoundNotify.SetSlot
// 0x0008 (0x0008 - 0x0000)
struct GzCustomizationSoundNotify_SetSlot final
{
public:
	struct FGameplayTag                           InSlot;                                            // 0x0000(0x0008)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzCustomizationSoundNotify_SetSlot) == 0x000004, "Wrong alignment on GzCustomizationSoundNotify_SetSlot");
static_assert(sizeof(GzCustomizationSoundNotify_SetSlot) == 0x000008, "Wrong size on GzCustomizationSoundNotify_SetSlot");
static_assert(offsetof(GzCustomizationSoundNotify_SetSlot, InSlot) == 0x000000, "Member 'GzCustomizationSoundNotify_SetSlot::InSlot' has a wrong offset!");

// Function G01.GzInputControlsComponent.AddInputMappingDecorator
// 0x0018 (0x0018 - 0x0000)
struct GzInputControlsComponent_AddInputMappingDecorator final
{
public:
	struct FGzInputMappingContextInfo             MappingContextInfo;                                // 0x0000(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	struct FModifyContextOptions                  OPTIONS;                                           // 0x0010(0x0001)(Parm, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_2E37[0x3];                                     // 0x0011(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGzInputMappingDecoratorHandle         ReturnValue;                                       // 0x0014(0x0004)(Parm, OutParm, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzInputControlsComponent_AddInputMappingDecorator) == 0x000008, "Wrong alignment on GzInputControlsComponent_AddInputMappingDecorator");
static_assert(sizeof(GzInputControlsComponent_AddInputMappingDecorator) == 0x000018, "Wrong size on GzInputControlsComponent_AddInputMappingDecorator");
static_assert(offsetof(GzInputControlsComponent_AddInputMappingDecorator, MappingContextInfo) == 0x000000, "Member 'GzInputControlsComponent_AddInputMappingDecorator::MappingContextInfo' has a wrong offset!");
static_assert(offsetof(GzInputControlsComponent_AddInputMappingDecorator, OPTIONS) == 0x000010, "Member 'GzInputControlsComponent_AddInputMappingDecorator::OPTIONS' has a wrong offset!");
static_assert(offsetof(GzInputControlsComponent_AddInputMappingDecorator, ReturnValue) == 0x000014, "Member 'GzInputControlsComponent_AddInputMappingDecorator::ReturnValue' has a wrong offset!");

// Function G01.GzInputControlsComponent.PopInputMapping
// 0x0010 (0x0010 - 0x0000)
struct GzInputControlsComponent_PopInputMapping final
{
public:
	struct FGzInputConfigBindingHandle            InHandle;                                          // 0x0000(0x000C)(Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FModifyContextOptions                  OPTIONS;                                           // 0x000C(0x0001)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_2E38[0x3];                                     // 0x000D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GzInputControlsComponent_PopInputMapping) == 0x000004, "Wrong alignment on GzInputControlsComponent_PopInputMapping");
static_assert(sizeof(GzInputControlsComponent_PopInputMapping) == 0x000010, "Wrong size on GzInputControlsComponent_PopInputMapping");
static_assert(offsetof(GzInputControlsComponent_PopInputMapping, InHandle) == 0x000000, "Member 'GzInputControlsComponent_PopInputMapping::InHandle' has a wrong offset!");
static_assert(offsetof(GzInputControlsComponent_PopInputMapping, OPTIONS) == 0x00000C, "Member 'GzInputControlsComponent_PopInputMapping::OPTIONS' has a wrong offset!");

// Function G01.GzInputControlsComponent.PushInputMapping
// 0x0018 (0x0018 - 0x0000)
struct GzInputControlsComponent_PushInputMapping final
{
public:
	class UGzInputMappingConfig*                  InMappingConfig;                                   // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FModifyContextOptions                  OPTIONS;                                           // 0x0008(0x0001)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_2E39[0x3];                                     // 0x0009(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGzInputConfigBindingHandle            ReturnValue;                                       // 0x000C(0x000C)(Parm, OutParm, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzInputControlsComponent_PushInputMapping) == 0x000008, "Wrong alignment on GzInputControlsComponent_PushInputMapping");
static_assert(sizeof(GzInputControlsComponent_PushInputMapping) == 0x000018, "Wrong size on GzInputControlsComponent_PushInputMapping");
static_assert(offsetof(GzInputControlsComponent_PushInputMapping, InMappingConfig) == 0x000000, "Member 'GzInputControlsComponent_PushInputMapping::InMappingConfig' has a wrong offset!");
static_assert(offsetof(GzInputControlsComponent_PushInputMapping, OPTIONS) == 0x000008, "Member 'GzInputControlsComponent_PushInputMapping::OPTIONS' has a wrong offset!");
static_assert(offsetof(GzInputControlsComponent_PushInputMapping, ReturnValue) == 0x00000C, "Member 'GzInputControlsComponent_PushInputMapping::ReturnValue' has a wrong offset!");

// Function G01.GzInputControlsComponent.RemoveInputMappingDecorator
// 0x0004 (0x0004 - 0x0000)
struct GzInputControlsComponent_RemoveInputMappingDecorator final
{
public:
	struct FGzInputMappingDecoratorHandle         InHandle;                                          // 0x0000(0x0004)(Parm, OutParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzInputControlsComponent_RemoveInputMappingDecorator) == 0x000004, "Wrong alignment on GzInputControlsComponent_RemoveInputMappingDecorator");
static_assert(sizeof(GzInputControlsComponent_RemoveInputMappingDecorator) == 0x000004, "Wrong size on GzInputControlsComponent_RemoveInputMappingDecorator");
static_assert(offsetof(GzInputControlsComponent_RemoveInputMappingDecorator, InHandle) == 0x000000, "Member 'GzInputControlsComponent_RemoveInputMappingDecorator::InHandle' has a wrong offset!");

// Function G01.GzWeaponComponent.AddShootingBarrel
// 0x0008 (0x0008 - 0x0000)
struct GzWeaponComponent_AddShootingBarrel final
{
public:
	class FName                                   ShootingBarrelSuffix;                              // 0x0000(0x0008)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzWeaponComponent_AddShootingBarrel) == 0x000004, "Wrong alignment on GzWeaponComponent_AddShootingBarrel");
static_assert(sizeof(GzWeaponComponent_AddShootingBarrel) == 0x000008, "Wrong size on GzWeaponComponent_AddShootingBarrel");
static_assert(offsetof(GzWeaponComponent_AddShootingBarrel, ShootingBarrelSuffix) == 0x000000, "Member 'GzWeaponComponent_AddShootingBarrel::ShootingBarrelSuffix' has a wrong offset!");

// Function G01.GzWeaponComponent.CanAim
// 0x0001 (0x0001 - 0x0000)
struct GzWeaponComponent_CanAim final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzWeaponComponent_CanAim) == 0x000001, "Wrong alignment on GzWeaponComponent_CanAim");
static_assert(sizeof(GzWeaponComponent_CanAim) == 0x000001, "Wrong size on GzWeaponComponent_CanAim");
static_assert(offsetof(GzWeaponComponent_CanAim, ReturnValue) == 0x000000, "Member 'GzWeaponComponent_CanAim::ReturnValue' has a wrong offset!");

// Function G01.GzWeaponComponent.CanAttack
// 0x0001 (0x0001 - 0x0000)
struct GzWeaponComponent_CanAttack final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzWeaponComponent_CanAttack) == 0x000001, "Wrong alignment on GzWeaponComponent_CanAttack");
static_assert(sizeof(GzWeaponComponent_CanAttack) == 0x000001, "Wrong size on GzWeaponComponent_CanAttack");
static_assert(offsetof(GzWeaponComponent_CanAttack, ReturnValue) == 0x000000, "Member 'GzWeaponComponent_CanAttack::ReturnValue' has a wrong offset!");

// Function G01.GzWeaponComponent.CanReload
// 0x0001 (0x0001 - 0x0000)
struct GzWeaponComponent_CanReload final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzWeaponComponent_CanReload) == 0x000001, "Wrong alignment on GzWeaponComponent_CanReload");
static_assert(sizeof(GzWeaponComponent_CanReload) == 0x000001, "Wrong size on GzWeaponComponent_CanReload");
static_assert(offsetof(GzWeaponComponent_CanReload, ReturnValue) == 0x000000, "Member 'GzWeaponComponent_CanReload::ReturnValue' has a wrong offset!");

// Function G01.GzWeaponComponent.CanSimulateShooting
// 0x0001 (0x0001 - 0x0000)
struct GzWeaponComponent_CanSimulateShooting final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzWeaponComponent_CanSimulateShooting) == 0x000001, "Wrong alignment on GzWeaponComponent_CanSimulateShooting");
static_assert(sizeof(GzWeaponComponent_CanSimulateShooting) == 0x000001, "Wrong size on GzWeaponComponent_CanSimulateShooting");
static_assert(offsetof(GzWeaponComponent_CanSimulateShooting, ReturnValue) == 0x000000, "Member 'GzWeaponComponent_CanSimulateShooting::ReturnValue' has a wrong offset!");

// Function G01.GzWeaponComponent.CanStopAttack
// 0x0001 (0x0001 - 0x0000)
struct GzWeaponComponent_CanStopAttack final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzWeaponComponent_CanStopAttack) == 0x000001, "Wrong alignment on GzWeaponComponent_CanStopAttack");
static_assert(sizeof(GzWeaponComponent_CanStopAttack) == 0x000001, "Wrong size on GzWeaponComponent_CanStopAttack");
static_assert(offsetof(GzWeaponComponent_CanStopAttack, ReturnValue) == 0x000000, "Member 'GzWeaponComponent_CanStopAttack::ReturnValue' has a wrong offset!");

// Function G01.GzWeaponComponent.GetActiveShootingBarrel
// 0x0008 (0x0008 - 0x0000)
struct GzWeaponComponent_GetActiveShootingBarrel final
{
public:
	class FName                                   ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzWeaponComponent_GetActiveShootingBarrel) == 0x000004, "Wrong alignment on GzWeaponComponent_GetActiveShootingBarrel");
static_assert(sizeof(GzWeaponComponent_GetActiveShootingBarrel) == 0x000008, "Wrong size on GzWeaponComponent_GetActiveShootingBarrel");
static_assert(offsetof(GzWeaponComponent_GetActiveShootingBarrel, ReturnValue) == 0x000000, "Member 'GzWeaponComponent_GetActiveShootingBarrel::ReturnValue' has a wrong offset!");

// Function G01.GzWeaponComponent.GetAimingProgress
// 0x0004 (0x0004 - 0x0000)
struct GzWeaponComponent_GetAimingProgress final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzWeaponComponent_GetAimingProgress) == 0x000004, "Wrong alignment on GzWeaponComponent_GetAimingProgress");
static_assert(sizeof(GzWeaponComponent_GetAimingProgress) == 0x000004, "Wrong size on GzWeaponComponent_GetAimingProgress");
static_assert(offsetof(GzWeaponComponent_GetAimingProgress, ReturnValue) == 0x000000, "Member 'GzWeaponComponent_GetAimingProgress::ReturnValue' has a wrong offset!");

// Function G01.GzWeaponComponent.GetAllScopeMagnifications
// 0x0010 (0x0010 - 0x0000)
struct GzWeaponComponent_GetAllScopeMagnifications final
{
public:
	TArray<int32>                                 ReturnValue;                                       // 0x0000(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzWeaponComponent_GetAllScopeMagnifications) == 0x000008, "Wrong alignment on GzWeaponComponent_GetAllScopeMagnifications");
static_assert(sizeof(GzWeaponComponent_GetAllScopeMagnifications) == 0x000010, "Wrong size on GzWeaponComponent_GetAllScopeMagnifications");
static_assert(offsetof(GzWeaponComponent_GetAllScopeMagnifications, ReturnValue) == 0x000000, "Member 'GzWeaponComponent_GetAllScopeMagnifications::ReturnValue' has a wrong offset!");

// Function G01.GzWeaponComponent.GetAnimationLayer
// 0x0038 (0x0038 - 0x0000)
struct GzWeaponComponent_GetAnimationLayer final
{
public:
	class AActor*                                 Character;                                         // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGzWeaponAnimationLayerData            ReturnValue;                                       // 0x0008(0x0030)(Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzWeaponComponent_GetAnimationLayer) == 0x000008, "Wrong alignment on GzWeaponComponent_GetAnimationLayer");
static_assert(sizeof(GzWeaponComponent_GetAnimationLayer) == 0x000038, "Wrong size on GzWeaponComponent_GetAnimationLayer");
static_assert(offsetof(GzWeaponComponent_GetAnimationLayer, Character) == 0x000000, "Member 'GzWeaponComponent_GetAnimationLayer::Character' has a wrong offset!");
static_assert(offsetof(GzWeaponComponent_GetAnimationLayer, ReturnValue) == 0x000008, "Member 'GzWeaponComponent_GetAnimationLayer::ReturnValue' has a wrong offset!");

// Function G01.GzWeaponComponent.GetAttackDamageEffect
// 0x0008 (0x0008 - 0x0000)
struct GzWeaponComponent_GetAttackDamageEffect final
{
public:
	TSubclassOf<class UGzGE_BaseDamage>           ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzWeaponComponent_GetAttackDamageEffect) == 0x000008, "Wrong alignment on GzWeaponComponent_GetAttackDamageEffect");
static_assert(sizeof(GzWeaponComponent_GetAttackDamageEffect) == 0x000008, "Wrong size on GzWeaponComponent_GetAttackDamageEffect");
static_assert(offsetof(GzWeaponComponent_GetAttackDamageEffect, ReturnValue) == 0x000000, "Member 'GzWeaponComponent_GetAttackDamageEffect::ReturnValue' has a wrong offset!");

// Function G01.GzWeaponComponent.GetAvailableScopeModes
// 0x0010 (0x0010 - 0x0000)
struct GzWeaponComponent_GetAvailableScopeModes final
{
public:
	TArray<struct FGzScopeMode>                   ReturnValue;                                       // 0x0000(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzWeaponComponent_GetAvailableScopeModes) == 0x000008, "Wrong alignment on GzWeaponComponent_GetAvailableScopeModes");
static_assert(sizeof(GzWeaponComponent_GetAvailableScopeModes) == 0x000010, "Wrong size on GzWeaponComponent_GetAvailableScopeModes");
static_assert(offsetof(GzWeaponComponent_GetAvailableScopeModes, ReturnValue) == 0x000000, "Member 'GzWeaponComponent_GetAvailableScopeModes::ReturnValue' has a wrong offset!");

// Function G01.GzWeaponComponent.GetAvailibleFireModes
// 0x0010 (0x0010 - 0x0000)
struct GzWeaponComponent_GetAvailibleFireModes final
{
public:
	TArray<EGzWeaponMode>                         ReturnValue;                                       // 0x0000(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzWeaponComponent_GetAvailibleFireModes) == 0x000008, "Wrong alignment on GzWeaponComponent_GetAvailibleFireModes");
static_assert(sizeof(GzWeaponComponent_GetAvailibleFireModes) == 0x000010, "Wrong size on GzWeaponComponent_GetAvailibleFireModes");
static_assert(offsetof(GzWeaponComponent_GetAvailibleFireModes, ReturnValue) == 0x000000, "Member 'GzWeaponComponent_GetAvailibleFireModes::ReturnValue' has a wrong offset!");

// Function G01.GzWeaponComponent.GetClipAmmoAmount
// 0x0004 (0x0004 - 0x0000)
struct GzWeaponComponent_GetClipAmmoAmount final
{
public:
	int32                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzWeaponComponent_GetClipAmmoAmount) == 0x000004, "Wrong alignment on GzWeaponComponent_GetClipAmmoAmount");
static_assert(sizeof(GzWeaponComponent_GetClipAmmoAmount) == 0x000004, "Wrong size on GzWeaponComponent_GetClipAmmoAmount");
static_assert(offsetof(GzWeaponComponent_GetClipAmmoAmount, ReturnValue) == 0x000000, "Member 'GzWeaponComponent_GetClipAmmoAmount::ReturnValue' has a wrong offset!");

// Function G01.GzWeaponComponent.GetCurrentFireMode
// 0x0020 (0x0020 - 0x0000)
struct GzWeaponComponent_GetCurrentFireMode final
{
public:
	struct FGzWeaponFireMode                      ReturnValue;                                       // 0x0000(0x0020)(ConstParm, Parm, OutParm, ReturnParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzWeaponComponent_GetCurrentFireMode) == 0x000008, "Wrong alignment on GzWeaponComponent_GetCurrentFireMode");
static_assert(sizeof(GzWeaponComponent_GetCurrentFireMode) == 0x000020, "Wrong size on GzWeaponComponent_GetCurrentFireMode");
static_assert(offsetof(GzWeaponComponent_GetCurrentFireMode, ReturnValue) == 0x000000, "Member 'GzWeaponComponent_GetCurrentFireMode::ReturnValue' has a wrong offset!");

// Function G01.GzWeaponComponent.GetCurrentScopeMagnification
// 0x0004 (0x0004 - 0x0000)
struct GzWeaponComponent_GetCurrentScopeMagnification final
{
public:
	int32                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzWeaponComponent_GetCurrentScopeMagnification) == 0x000004, "Wrong alignment on GzWeaponComponent_GetCurrentScopeMagnification");
static_assert(sizeof(GzWeaponComponent_GetCurrentScopeMagnification) == 0x000004, "Wrong size on GzWeaponComponent_GetCurrentScopeMagnification");
static_assert(offsetof(GzWeaponComponent_GetCurrentScopeMagnification, ReturnValue) == 0x000000, "Member 'GzWeaponComponent_GetCurrentScopeMagnification::ReturnValue' has a wrong offset!");

// Function G01.GzWeaponComponent.GetCurrentScopeMode
// 0x0080 (0x0080 - 0x0000)
struct GzWeaponComponent_GetCurrentScopeMode final
{
public:
	struct FGzScopeMode                           ReturnValue;                                       // 0x0000(0x0080)(ConstParm, Parm, OutParm, ReturnParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzWeaponComponent_GetCurrentScopeMode) == 0x000008, "Wrong alignment on GzWeaponComponent_GetCurrentScopeMode");
static_assert(sizeof(GzWeaponComponent_GetCurrentScopeMode) == 0x000080, "Wrong size on GzWeaponComponent_GetCurrentScopeMode");
static_assert(offsetof(GzWeaponComponent_GetCurrentScopeMode, ReturnValue) == 0x000000, "Member 'GzWeaponComponent_GetCurrentScopeMode::ReturnValue' has a wrong offset!");

// Function G01.GzWeaponComponent.GetFireModeIndexByType
// 0x0008 (0x0008 - 0x0000)
struct GzWeaponComponent_GetFireModeIndexByType final
{
public:
	EGzWeaponMode                                 WeaponMode;                                        // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2E40[0x3];                                     // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         ReturnValue;                                       // 0x0004(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzWeaponComponent_GetFireModeIndexByType) == 0x000004, "Wrong alignment on GzWeaponComponent_GetFireModeIndexByType");
static_assert(sizeof(GzWeaponComponent_GetFireModeIndexByType) == 0x000008, "Wrong size on GzWeaponComponent_GetFireModeIndexByType");
static_assert(offsetof(GzWeaponComponent_GetFireModeIndexByType, WeaponMode) == 0x000000, "Member 'GzWeaponComponent_GetFireModeIndexByType::WeaponMode' has a wrong offset!");
static_assert(offsetof(GzWeaponComponent_GetFireModeIndexByType, ReturnValue) == 0x000004, "Member 'GzWeaponComponent_GetFireModeIndexByType::ReturnValue' has a wrong offset!");

// Function G01.GzWeaponComponent.GetFireStartLocationAndRotation
// 0x0040 (0x0040 - 0x0000)
struct GzWeaponComponent_GetFireStartLocationAndRotation final
{
public:
	struct FVector                                OutLocation;                                       // 0x0000(0x0018)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               OutRotation;                                       // 0x0018(0x0018)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	class FName                                   MuzzleSocketName;                                  // 0x0030(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0038(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2E41[0x7];                                     // 0x0039(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GzWeaponComponent_GetFireStartLocationAndRotation) == 0x000008, "Wrong alignment on GzWeaponComponent_GetFireStartLocationAndRotation");
static_assert(sizeof(GzWeaponComponent_GetFireStartLocationAndRotation) == 0x000040, "Wrong size on GzWeaponComponent_GetFireStartLocationAndRotation");
static_assert(offsetof(GzWeaponComponent_GetFireStartLocationAndRotation, OutLocation) == 0x000000, "Member 'GzWeaponComponent_GetFireStartLocationAndRotation::OutLocation' has a wrong offset!");
static_assert(offsetof(GzWeaponComponent_GetFireStartLocationAndRotation, OutRotation) == 0x000018, "Member 'GzWeaponComponent_GetFireStartLocationAndRotation::OutRotation' has a wrong offset!");
static_assert(offsetof(GzWeaponComponent_GetFireStartLocationAndRotation, MuzzleSocketName) == 0x000030, "Member 'GzWeaponComponent_GetFireStartLocationAndRotation::MuzzleSocketName' has a wrong offset!");
static_assert(offsetof(GzWeaponComponent_GetFireStartLocationAndRotation, ReturnValue) == 0x000038, "Member 'GzWeaponComponent_GetFireStartLocationAndRotation::ReturnValue' has a wrong offset!");

// Function G01.GzWeaponComponent.GetJointTargetLocation
// 0x0018 (0x0018 - 0x0000)
struct GzWeaponComponent_GetJointTargetLocation final
{
public:
	struct FVector                                ReturnValue;                                       // 0x0000(0x0018)(ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzWeaponComponent_GetJointTargetLocation) == 0x000008, "Wrong alignment on GzWeaponComponent_GetJointTargetLocation");
static_assert(sizeof(GzWeaponComponent_GetJointTargetLocation) == 0x000018, "Wrong size on GzWeaponComponent_GetJointTargetLocation");
static_assert(offsetof(GzWeaponComponent_GetJointTargetLocation, ReturnValue) == 0x000000, "Member 'GzWeaponComponent_GetJointTargetLocation::ReturnValue' has a wrong offset!");

// Function G01.GzWeaponComponent.GetMaxClipAmmoAmount
// 0x0004 (0x0004 - 0x0000)
struct GzWeaponComponent_GetMaxClipAmmoAmount final
{
public:
	int32                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzWeaponComponent_GetMaxClipAmmoAmount) == 0x000004, "Wrong alignment on GzWeaponComponent_GetMaxClipAmmoAmount");
static_assert(sizeof(GzWeaponComponent_GetMaxClipAmmoAmount) == 0x000004, "Wrong size on GzWeaponComponent_GetMaxClipAmmoAmount");
static_assert(offsetof(GzWeaponComponent_GetMaxClipAmmoAmount, ReturnValue) == 0x000000, "Member 'GzWeaponComponent_GetMaxClipAmmoAmount::ReturnValue' has a wrong offset!");

// Function G01.GzWeaponComponent.GetOverheatData
// 0x0008 (0x0008 - 0x0000)
struct GzWeaponComponent_GetOverheatData final
{
public:
	const class UGzWeaponOverheatData*            ReturnValue;                                       // 0x0000(0x0008)(ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzWeaponComponent_GetOverheatData) == 0x000008, "Wrong alignment on GzWeaponComponent_GetOverheatData");
static_assert(sizeof(GzWeaponComponent_GetOverheatData) == 0x000008, "Wrong size on GzWeaponComponent_GetOverheatData");
static_assert(offsetof(GzWeaponComponent_GetOverheatData, ReturnValue) == 0x000000, "Member 'GzWeaponComponent_GetOverheatData::ReturnValue' has a wrong offset!");

// Function G01.GzWeaponComponent.GetOverheatPercentage
// 0x0004 (0x0004 - 0x0000)
struct GzWeaponComponent_GetOverheatPercentage final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzWeaponComponent_GetOverheatPercentage) == 0x000004, "Wrong alignment on GzWeaponComponent_GetOverheatPercentage");
static_assert(sizeof(GzWeaponComponent_GetOverheatPercentage) == 0x000004, "Wrong size on GzWeaponComponent_GetOverheatPercentage");
static_assert(offsetof(GzWeaponComponent_GetOverheatPercentage, ReturnValue) == 0x000000, "Member 'GzWeaponComponent_GetOverheatPercentage::ReturnValue' has a wrong offset!");

// Function G01.GzWeaponComponent.GetOwnerCombatComponent
// 0x0008 (0x0008 - 0x0000)
struct GzWeaponComponent_GetOwnerCombatComponent final
{
public:
	class UGzCombatComponent*                     ReturnValue;                                       // 0x0000(0x0008)(ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzWeaponComponent_GetOwnerCombatComponent) == 0x000008, "Wrong alignment on GzWeaponComponent_GetOwnerCombatComponent");
static_assert(sizeof(GzWeaponComponent_GetOwnerCombatComponent) == 0x000008, "Wrong size on GzWeaponComponent_GetOwnerCombatComponent");
static_assert(offsetof(GzWeaponComponent_GetOwnerCombatComponent, ReturnValue) == 0x000000, "Member 'GzWeaponComponent_GetOwnerCombatComponent::ReturnValue' has a wrong offset!");

// Function G01.GzWeaponComponent.GetRecoilData
// 0x0008 (0x0008 - 0x0000)
struct GzWeaponComponent_GetRecoilData final
{
public:
	const class UGzWeaponRecoilData*              ReturnValue;                                       // 0x0000(0x0008)(ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzWeaponComponent_GetRecoilData) == 0x000008, "Wrong alignment on GzWeaponComponent_GetRecoilData");
static_assert(sizeof(GzWeaponComponent_GetRecoilData) == 0x000008, "Wrong size on GzWeaponComponent_GetRecoilData");
static_assert(offsetof(GzWeaponComponent_GetRecoilData, ReturnValue) == 0x000000, "Member 'GzWeaponComponent_GetRecoilData::ReturnValue' has a wrong offset!");

// Function G01.GzWeaponComponent.GetReloadTimeSeconds
// 0x0010 (0x0010 - 0x0000)
struct GzWeaponComponent_GetReloadTimeSeconds final
{
public:
	class APawn*                                  Pawn;                                              // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ReturnValue;                                       // 0x0008(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2E42[0x4];                                     // 0x000C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GzWeaponComponent_GetReloadTimeSeconds) == 0x000008, "Wrong alignment on GzWeaponComponent_GetReloadTimeSeconds");
static_assert(sizeof(GzWeaponComponent_GetReloadTimeSeconds) == 0x000010, "Wrong size on GzWeaponComponent_GetReloadTimeSeconds");
static_assert(offsetof(GzWeaponComponent_GetReloadTimeSeconds, Pawn) == 0x000000, "Member 'GzWeaponComponent_GetReloadTimeSeconds::Pawn' has a wrong offset!");
static_assert(offsetof(GzWeaponComponent_GetReloadTimeSeconds, ReturnValue) == 0x000008, "Member 'GzWeaponComponent_GetReloadTimeSeconds::ReturnValue' has a wrong offset!");

// Function G01.GzWeaponComponent.GetSpreadData
// 0x0008 (0x0008 - 0x0000)
struct GzWeaponComponent_GetSpreadData final
{
public:
	const class UGzWeaponSpreadData*              ReturnValue;                                       // 0x0000(0x0008)(ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzWeaponComponent_GetSpreadData) == 0x000008, "Wrong alignment on GzWeaponComponent_GetSpreadData");
static_assert(sizeof(GzWeaponComponent_GetSpreadData) == 0x000008, "Wrong size on GzWeaponComponent_GetSpreadData");
static_assert(offsetof(GzWeaponComponent_GetSpreadData, ReturnValue) == 0x000000, "Member 'GzWeaponComponent_GetSpreadData::ReturnValue' has a wrong offset!");

// Function G01.GzWeaponComponent.GetStockAmmoAmount
// 0x0004 (0x0004 - 0x0000)
struct GzWeaponComponent_GetStockAmmoAmount final
{
public:
	int32                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzWeaponComponent_GetStockAmmoAmount) == 0x000004, "Wrong alignment on GzWeaponComponent_GetStockAmmoAmount");
static_assert(sizeof(GzWeaponComponent_GetStockAmmoAmount) == 0x000004, "Wrong size on GzWeaponComponent_GetStockAmmoAmount");
static_assert(offsetof(GzWeaponComponent_GetStockAmmoAmount, ReturnValue) == 0x000000, "Member 'GzWeaponComponent_GetStockAmmoAmount::ReturnValue' has a wrong offset!");

// Function G01.GzWeaponComponent.GetSwayData
// 0x0008 (0x0008 - 0x0000)
struct GzWeaponComponent_GetSwayData final
{
public:
	const class UGzWeaponSwayData*                ReturnValue;                                       // 0x0000(0x0008)(ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzWeaponComponent_GetSwayData) == 0x000008, "Wrong alignment on GzWeaponComponent_GetSwayData");
static_assert(sizeof(GzWeaponComponent_GetSwayData) == 0x000008, "Wrong size on GzWeaponComponent_GetSwayData");
static_assert(offsetof(GzWeaponComponent_GetSwayData, ReturnValue) == 0x000000, "Member 'GzWeaponComponent_GetSwayData::ReturnValue' has a wrong offset!");

// Function G01.GzWeaponComponent.GetWeaponActor
// 0x0008 (0x0008 - 0x0000)
struct GzWeaponComponent_GetWeaponActor final
{
public:
	class AGzWeaponActor*                         ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzWeaponComponent_GetWeaponActor) == 0x000008, "Wrong alignment on GzWeaponComponent_GetWeaponActor");
static_assert(sizeof(GzWeaponComponent_GetWeaponActor) == 0x000008, "Wrong size on GzWeaponComponent_GetWeaponActor");
static_assert(offsetof(GzWeaponComponent_GetWeaponActor, ReturnValue) == 0x000000, "Member 'GzWeaponComponent_GetWeaponActor::ReturnValue' has a wrong offset!");

// Function G01.GzWeaponComponent.GetWeaponAIData
// 0x0008 (0x0008 - 0x0000)
struct GzWeaponComponent_GetWeaponAIData final
{
public:
	const class UGzWeaponAIData*                  ReturnValue;                                       // 0x0000(0x0008)(ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzWeaponComponent_GetWeaponAIData) == 0x000008, "Wrong alignment on GzWeaponComponent_GetWeaponAIData");
static_assert(sizeof(GzWeaponComponent_GetWeaponAIData) == 0x000008, "Wrong size on GzWeaponComponent_GetWeaponAIData");
static_assert(offsetof(GzWeaponComponent_GetWeaponAIData, ReturnValue) == 0x000000, "Member 'GzWeaponComponent_GetWeaponAIData::ReturnValue' has a wrong offset!");

// Function G01.GzWeaponComponent.GetWeaponAnimationData
// 0x0008 (0x0008 - 0x0000)
struct GzWeaponComponent_GetWeaponAnimationData final
{
public:
	const class UGzWeaponAnimationData*           ReturnValue;                                       // 0x0000(0x0008)(ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzWeaponComponent_GetWeaponAnimationData) == 0x000008, "Wrong alignment on GzWeaponComponent_GetWeaponAnimationData");
static_assert(sizeof(GzWeaponComponent_GetWeaponAnimationData) == 0x000008, "Wrong size on GzWeaponComponent_GetWeaponAnimationData");
static_assert(offsetof(GzWeaponComponent_GetWeaponAnimationData, ReturnValue) == 0x000000, "Member 'GzWeaponComponent_GetWeaponAnimationData::ReturnValue' has a wrong offset!");

// Function G01.GzWeaponComponent.GetWeaponData
// 0x0008 (0x0008 - 0x0000)
struct GzWeaponComponent_GetWeaponData final
{
public:
	const class UGzWeaponData*                    ReturnValue;                                       // 0x0000(0x0008)(ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzWeaponComponent_GetWeaponData) == 0x000008, "Wrong alignment on GzWeaponComponent_GetWeaponData");
static_assert(sizeof(GzWeaponComponent_GetWeaponData) == 0x000008, "Wrong size on GzWeaponComponent_GetWeaponData");
static_assert(offsetof(GzWeaponComponent_GetWeaponData, ReturnValue) == 0x000000, "Member 'GzWeaponComponent_GetWeaponData::ReturnValue' has a wrong offset!");

// Function G01.GzWeaponComponent.GetWeaponFXData
// 0x0008 (0x0008 - 0x0000)
struct GzWeaponComponent_GetWeaponFXData final
{
public:
	const class UGzWeaponFXData*                  ReturnValue;                                       // 0x0000(0x0008)(ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzWeaponComponent_GetWeaponFXData) == 0x000008, "Wrong alignment on GzWeaponComponent_GetWeaponFXData");
static_assert(sizeof(GzWeaponComponent_GetWeaponFXData) == 0x000008, "Wrong size on GzWeaponComponent_GetWeaponFXData");
static_assert(offsetof(GzWeaponComponent_GetWeaponFXData, ReturnValue) == 0x000000, "Member 'GzWeaponComponent_GetWeaponFXData::ReturnValue' has a wrong offset!");

// Function G01.GzWeaponComponent.GetWeaponSoundData
// 0x0008 (0x0008 - 0x0000)
struct GzWeaponComponent_GetWeaponSoundData final
{
public:
	const class UGzWeaponSoundData*               ReturnValue;                                       // 0x0000(0x0008)(ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzWeaponComponent_GetWeaponSoundData) == 0x000008, "Wrong alignment on GzWeaponComponent_GetWeaponSoundData");
static_assert(sizeof(GzWeaponComponent_GetWeaponSoundData) == 0x000008, "Wrong size on GzWeaponComponent_GetWeaponSoundData");
static_assert(offsetof(GzWeaponComponent_GetWeaponSoundData, ReturnValue) == 0x000000, "Member 'GzWeaponComponent_GetWeaponSoundData::ReturnValue' has a wrong offset!");

// Function G01.GzWeaponComponent.HasScope
// 0x0001 (0x0001 - 0x0000)
struct GzWeaponComponent_HasScope final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzWeaponComponent_HasScope) == 0x000001, "Wrong alignment on GzWeaponComponent_HasScope");
static_assert(sizeof(GzWeaponComponent_HasScope) == 0x000001, "Wrong size on GzWeaponComponent_HasScope");
static_assert(offsetof(GzWeaponComponent_HasScope, ReturnValue) == 0x000000, "Member 'GzWeaponComponent_HasScope::ReturnValue' has a wrong offset!");

// Function G01.GzWeaponComponent.IsClipEmpty
// 0x0001 (0x0001 - 0x0000)
struct GzWeaponComponent_IsClipEmpty final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzWeaponComponent_IsClipEmpty) == 0x000001, "Wrong alignment on GzWeaponComponent_IsClipEmpty");
static_assert(sizeof(GzWeaponComponent_IsClipEmpty) == 0x000001, "Wrong size on GzWeaponComponent_IsClipEmpty");
static_assert(offsetof(GzWeaponComponent_IsClipEmpty, ReturnValue) == 0x000000, "Member 'GzWeaponComponent_IsClipEmpty::ReturnValue' has a wrong offset!");

// Function G01.GzWeaponComponent.IsClipFull
// 0x0001 (0x0001 - 0x0000)
struct GzWeaponComponent_IsClipFull final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzWeaponComponent_IsClipFull) == 0x000001, "Wrong alignment on GzWeaponComponent_IsClipFull");
static_assert(sizeof(GzWeaponComponent_IsClipFull) == 0x000001, "Wrong size on GzWeaponComponent_IsClipFull");
static_assert(offsetof(GzWeaponComponent_IsClipFull, ReturnValue) == 0x000000, "Member 'GzWeaponComponent_IsClipFull::ReturnValue' has a wrong offset!");

// Function G01.GzWeaponComponent.IsCurrentlyEquipped
// 0x0001 (0x0001 - 0x0000)
struct GzWeaponComponent_IsCurrentlyEquipped final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzWeaponComponent_IsCurrentlyEquipped) == 0x000001, "Wrong alignment on GzWeaponComponent_IsCurrentlyEquipped");
static_assert(sizeof(GzWeaponComponent_IsCurrentlyEquipped) == 0x000001, "Wrong size on GzWeaponComponent_IsCurrentlyEquipped");
static_assert(offsetof(GzWeaponComponent_IsCurrentlyEquipped, ReturnValue) == 0x000000, "Member 'GzWeaponComponent_IsCurrentlyEquipped::ReturnValue' has a wrong offset!");

// Function G01.GzWeaponComponent.IsLimbWeapon
// 0x0001 (0x0001 - 0x0000)
struct GzWeaponComponent_IsLimbWeapon final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzWeaponComponent_IsLimbWeapon) == 0x000001, "Wrong alignment on GzWeaponComponent_IsLimbWeapon");
static_assert(sizeof(GzWeaponComponent_IsLimbWeapon) == 0x000001, "Wrong size on GzWeaponComponent_IsLimbWeapon");
static_assert(offsetof(GzWeaponComponent_IsLimbWeapon, ReturnValue) == 0x000000, "Member 'GzWeaponComponent_IsLimbWeapon::ReturnValue' has a wrong offset!");

// Function G01.GzWeaponComponent.IsOverheated
// 0x0001 (0x0001 - 0x0000)
struct GzWeaponComponent_IsOverheated final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzWeaponComponent_IsOverheated) == 0x000001, "Wrong alignment on GzWeaponComponent_IsOverheated");
static_assert(sizeof(GzWeaponComponent_IsOverheated) == 0x000001, "Wrong size on GzWeaponComponent_IsOverheated");
static_assert(offsetof(GzWeaponComponent_IsOverheated, ReturnValue) == 0x000000, "Member 'GzWeaponComponent_IsOverheated::ReturnValue' has a wrong offset!");

// Function G01.GzWeaponComponent.IsOwnerAiming
// 0x0001 (0x0001 - 0x0000)
struct GzWeaponComponent_IsOwnerAiming final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzWeaponComponent_IsOwnerAiming) == 0x000001, "Wrong alignment on GzWeaponComponent_IsOwnerAiming");
static_assert(sizeof(GzWeaponComponent_IsOwnerAiming) == 0x000001, "Wrong size on GzWeaponComponent_IsOwnerAiming");
static_assert(offsetof(GzWeaponComponent_IsOwnerAiming, ReturnValue) == 0x000000, "Member 'GzWeaponComponent_IsOwnerAiming::ReturnValue' has a wrong offset!");

// Function G01.GzWeaponComponent.IsPendingAttack
// 0x0001 (0x0001 - 0x0000)
struct GzWeaponComponent_IsPendingAttack final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzWeaponComponent_IsPendingAttack) == 0x000001, "Wrong alignment on GzWeaponComponent_IsPendingAttack");
static_assert(sizeof(GzWeaponComponent_IsPendingAttack) == 0x000001, "Wrong size on GzWeaponComponent_IsPendingAttack");
static_assert(offsetof(GzWeaponComponent_IsPendingAttack, ReturnValue) == 0x000000, "Member 'GzWeaponComponent_IsPendingAttack::ReturnValue' has a wrong offset!");

// Function G01.GzWeaponComponent.IsWeaponSilenced
// 0x0001 (0x0001 - 0x0000)
struct GzWeaponComponent_IsWeaponSilenced final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzWeaponComponent_IsWeaponSilenced) == 0x000001, "Wrong alignment on GzWeaponComponent_IsWeaponSilenced");
static_assert(sizeof(GzWeaponComponent_IsWeaponSilenced) == 0x000001, "Wrong size on GzWeaponComponent_IsWeaponSilenced");
static_assert(offsetof(GzWeaponComponent_IsWeaponSilenced, ReturnValue) == 0x000000, "Member 'GzWeaponComponent_IsWeaponSilenced::ReturnValue' has a wrong offset!");

// Function G01.GzWeaponComponent.NeedsRechambering
// 0x0001 (0x0001 - 0x0000)
struct GzWeaponComponent_NeedsRechambering final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzWeaponComponent_NeedsRechambering) == 0x000001, "Wrong alignment on GzWeaponComponent_NeedsRechambering");
static_assert(sizeof(GzWeaponComponent_NeedsRechambering) == 0x000001, "Wrong size on GzWeaponComponent_NeedsRechambering");
static_assert(offsetof(GzWeaponComponent_NeedsRechambering, ReturnValue) == 0x000000, "Member 'GzWeaponComponent_NeedsRechambering::ReturnValue' has a wrong offset!");

// Function G01.GzWeaponComponent.OnWeaponAttackMontageEnded
// 0x0010 (0x0010 - 0x0000)
struct GzWeaponComponent_OnWeaponAttackMontageEnded final
{
public:
	class UAnimMontage*                           Montage;                                           // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bInterrupted;                                      // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2E43[0x7];                                     // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GzWeaponComponent_OnWeaponAttackMontageEnded) == 0x000008, "Wrong alignment on GzWeaponComponent_OnWeaponAttackMontageEnded");
static_assert(sizeof(GzWeaponComponent_OnWeaponAttackMontageEnded) == 0x000010, "Wrong size on GzWeaponComponent_OnWeaponAttackMontageEnded");
static_assert(offsetof(GzWeaponComponent_OnWeaponAttackMontageEnded, Montage) == 0x000000, "Member 'GzWeaponComponent_OnWeaponAttackMontageEnded::Montage' has a wrong offset!");
static_assert(offsetof(GzWeaponComponent_OnWeaponAttackMontageEnded, bInterrupted) == 0x000008, "Member 'GzWeaponComponent_OnWeaponAttackMontageEnded::bInterrupted' has a wrong offset!");

// Function G01.GzWeaponComponent.OnWeaponReloadMontageEnded
// 0x0010 (0x0010 - 0x0000)
struct GzWeaponComponent_OnWeaponReloadMontageEnded final
{
public:
	class UAnimMontage*                           Montage;                                           // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bInterrupted;                                      // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2E44[0x7];                                     // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GzWeaponComponent_OnWeaponReloadMontageEnded) == 0x000008, "Wrong alignment on GzWeaponComponent_OnWeaponReloadMontageEnded");
static_assert(sizeof(GzWeaponComponent_OnWeaponReloadMontageEnded) == 0x000010, "Wrong size on GzWeaponComponent_OnWeaponReloadMontageEnded");
static_assert(offsetof(GzWeaponComponent_OnWeaponReloadMontageEnded, Montage) == 0x000000, "Member 'GzWeaponComponent_OnWeaponReloadMontageEnded::Montage' has a wrong offset!");
static_assert(offsetof(GzWeaponComponent_OnWeaponReloadMontageEnded, bInterrupted) == 0x000008, "Member 'GzWeaponComponent_OnWeaponReloadMontageEnded::bInterrupted' has a wrong offset!");

// Function G01.GzWeaponComponent.TryFindSocketLocation
// 0x0028 (0x0028 - 0x0000)
struct GzWeaponComponent_TryFindSocketLocation final
{
public:
	class FName                                   MuzzleSocketName;                                  // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                OutLocation;                                       // 0x0008(0x0018)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0020(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2E45[0x7];                                     // 0x0021(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GzWeaponComponent_TryFindSocketLocation) == 0x000008, "Wrong alignment on GzWeaponComponent_TryFindSocketLocation");
static_assert(sizeof(GzWeaponComponent_TryFindSocketLocation) == 0x000028, "Wrong size on GzWeaponComponent_TryFindSocketLocation");
static_assert(offsetof(GzWeaponComponent_TryFindSocketLocation, MuzzleSocketName) == 0x000000, "Member 'GzWeaponComponent_TryFindSocketLocation::MuzzleSocketName' has a wrong offset!");
static_assert(offsetof(GzWeaponComponent_TryFindSocketLocation, OutLocation) == 0x000008, "Member 'GzWeaponComponent_TryFindSocketLocation::OutLocation' has a wrong offset!");
static_assert(offsetof(GzWeaponComponent_TryFindSocketLocation, ReturnValue) == 0x000020, "Member 'GzWeaponComponent_TryFindSocketLocation::ReturnValue' has a wrong offset!");

// Function G01.GzAsyncTaskAttributeChanged.ListenForAttributeChange
// 0x0048 (0x0048 - 0x0000)
struct GzAsyncTaskAttributeChanged_ListenForAttributeChange final
{
public:
	class UAbilitySystemComponent*                AbilitySystemComponent;                            // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayAttribute                     Attribute;                                         // 0x0008(0x0038)(Parm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UGzAsyncTaskAttributeChanged*           ReturnValue;                                       // 0x0040(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzAsyncTaskAttributeChanged_ListenForAttributeChange) == 0x000008, "Wrong alignment on GzAsyncTaskAttributeChanged_ListenForAttributeChange");
static_assert(sizeof(GzAsyncTaskAttributeChanged_ListenForAttributeChange) == 0x000048, "Wrong size on GzAsyncTaskAttributeChanged_ListenForAttributeChange");
static_assert(offsetof(GzAsyncTaskAttributeChanged_ListenForAttributeChange, AbilitySystemComponent) == 0x000000, "Member 'GzAsyncTaskAttributeChanged_ListenForAttributeChange::AbilitySystemComponent' has a wrong offset!");
static_assert(offsetof(GzAsyncTaskAttributeChanged_ListenForAttributeChange, Attribute) == 0x000008, "Member 'GzAsyncTaskAttributeChanged_ListenForAttributeChange::Attribute' has a wrong offset!");
static_assert(offsetof(GzAsyncTaskAttributeChanged_ListenForAttributeChange, ReturnValue) == 0x000040, "Member 'GzAsyncTaskAttributeChanged_ListenForAttributeChange::ReturnValue' has a wrong offset!");

// Function G01.GzAsyncTaskAttributeChanged.ListenForAttributesChange
// 0x0020 (0x0020 - 0x0000)
struct GzAsyncTaskAttributeChanged_ListenForAttributesChange final
{
public:
	class UAbilitySystemComponent*                AbilitySystemComponent;                            // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FGameplayAttribute>             Attributes;                                        // 0x0008(0x0010)(Parm, ZeroConstructor, NativeAccessSpecifierPublic)
	class UGzAsyncTaskAttributeChanged*           ReturnValue;                                       // 0x0018(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzAsyncTaskAttributeChanged_ListenForAttributesChange) == 0x000008, "Wrong alignment on GzAsyncTaskAttributeChanged_ListenForAttributesChange");
static_assert(sizeof(GzAsyncTaskAttributeChanged_ListenForAttributesChange) == 0x000020, "Wrong size on GzAsyncTaskAttributeChanged_ListenForAttributesChange");
static_assert(offsetof(GzAsyncTaskAttributeChanged_ListenForAttributesChange, AbilitySystemComponent) == 0x000000, "Member 'GzAsyncTaskAttributeChanged_ListenForAttributesChange::AbilitySystemComponent' has a wrong offset!");
static_assert(offsetof(GzAsyncTaskAttributeChanged_ListenForAttributesChange, Attributes) == 0x000008, "Member 'GzAsyncTaskAttributeChanged_ListenForAttributesChange::Attributes' has a wrong offset!");
static_assert(offsetof(GzAsyncTaskAttributeChanged_ListenForAttributesChange, ReturnValue) == 0x000018, "Member 'GzAsyncTaskAttributeChanged_ListenForAttributesChange::ReturnValue' has a wrong offset!");

// Function G01.GzAsyncTaskGameplayTagAddedRemoved.ListenForGameplayTagAddedOrRemoved
// 0x0030 (0x0030 - 0x0000)
struct GzAsyncTaskGameplayTagAddedRemoved_ListenForGameplayTagAddedOrRemoved final
{
public:
	class UAbilitySystemComponent*                AbilitySystemComponent;                            // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTagContainer                  Tags;                                              // 0x0008(0x0020)(Parm, NativeAccessSpecifierPublic)
	class UGzAsyncTaskGameplayTagAddedRemoved*    ReturnValue;                                       // 0x0028(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzAsyncTaskGameplayTagAddedRemoved_ListenForGameplayTagAddedOrRemoved) == 0x000008, "Wrong alignment on GzAsyncTaskGameplayTagAddedRemoved_ListenForGameplayTagAddedOrRemoved");
static_assert(sizeof(GzAsyncTaskGameplayTagAddedRemoved_ListenForGameplayTagAddedOrRemoved) == 0x000030, "Wrong size on GzAsyncTaskGameplayTagAddedRemoved_ListenForGameplayTagAddedOrRemoved");
static_assert(offsetof(GzAsyncTaskGameplayTagAddedRemoved_ListenForGameplayTagAddedOrRemoved, AbilitySystemComponent) == 0x000000, "Member 'GzAsyncTaskGameplayTagAddedRemoved_ListenForGameplayTagAddedOrRemoved::AbilitySystemComponent' has a wrong offset!");
static_assert(offsetof(GzAsyncTaskGameplayTagAddedRemoved_ListenForGameplayTagAddedOrRemoved, Tags) == 0x000008, "Member 'GzAsyncTaskGameplayTagAddedRemoved_ListenForGameplayTagAddedOrRemoved::Tags' has a wrong offset!");
static_assert(offsetof(GzAsyncTaskGameplayTagAddedRemoved_ListenForGameplayTagAddedOrRemoved, ReturnValue) == 0x000028, "Member 'GzAsyncTaskGameplayTagAddedRemoved_ListenForGameplayTagAddedOrRemoved::ReturnValue' has a wrong offset!");

// Function G01.GzProjectileBase.InitializeWithData
// 0x0008 (0x0008 - 0x0000)
struct GzProjectileBase_InitializeWithData final
{
public:
	const class UGzProjectileData*                Data;                                              // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzProjectileBase_InitializeWithData) == 0x000008, "Wrong alignment on GzProjectileBase_InitializeWithData");
static_assert(sizeof(GzProjectileBase_InitializeWithData) == 0x000008, "Wrong size on GzProjectileBase_InitializeWithData");
static_assert(offsetof(GzProjectileBase_InitializeWithData, Data) == 0x000000, "Member 'GzProjectileBase_InitializeWithData::Data' has a wrong offset!");

// Function G01.GzProjectileBase.LaunchProjectile
// 0x0030 (0x0030 - 0x0000)
struct GzProjectileBase_LaunchProjectile final
{
public:
	struct FVector                                LaunchPosition;                                    // 0x0000(0x0018)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Direction;                                         // 0x0018(0x0018)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzProjectileBase_LaunchProjectile) == 0x000008, "Wrong alignment on GzProjectileBase_LaunchProjectile");
static_assert(sizeof(GzProjectileBase_LaunchProjectile) == 0x000030, "Wrong size on GzProjectileBase_LaunchProjectile");
static_assert(offsetof(GzProjectileBase_LaunchProjectile, LaunchPosition) == 0x000000, "Member 'GzProjectileBase_LaunchProjectile::LaunchPosition' has a wrong offset!");
static_assert(offsetof(GzProjectileBase_LaunchProjectile, Direction) == 0x000018, "Member 'GzProjectileBase_LaunchProjectile::Direction' has a wrong offset!");

// Function G01.GzProjectileBase.LaunchProjectileWithSpeed
// 0x0038 (0x0038 - 0x0000)
struct GzProjectileBase_LaunchProjectileWithSpeed final
{
public:
	struct FVector                                LaunchPosition;                                    // 0x0000(0x0018)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Direction;                                         // 0x0018(0x0018)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Speed;                                             // 0x0030(0x0004)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2E54[0x4];                                     // 0x0034(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GzProjectileBase_LaunchProjectileWithSpeed) == 0x000008, "Wrong alignment on GzProjectileBase_LaunchProjectileWithSpeed");
static_assert(sizeof(GzProjectileBase_LaunchProjectileWithSpeed) == 0x000038, "Wrong size on GzProjectileBase_LaunchProjectileWithSpeed");
static_assert(offsetof(GzProjectileBase_LaunchProjectileWithSpeed, LaunchPosition) == 0x000000, "Member 'GzProjectileBase_LaunchProjectileWithSpeed::LaunchPosition' has a wrong offset!");
static_assert(offsetof(GzProjectileBase_LaunchProjectileWithSpeed, Direction) == 0x000018, "Member 'GzProjectileBase_LaunchProjectileWithSpeed::Direction' has a wrong offset!");
static_assert(offsetof(GzProjectileBase_LaunchProjectileWithSpeed, Speed) == 0x000030, "Member 'GzProjectileBase_LaunchProjectileWithSpeed::Speed' has a wrong offset!");

// Function G01.GzProjectileBase.OnMultiHitDamageReceived
// 0x0050 (0x0050 - 0x0000)
struct GzProjectileBase_OnMultiHitDamageReceived final
{
public:
	class UGzDamageableComponent*                 Receiver;                                          // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGzMultiHitDamage                      Hit;                                               // 0x0008(0x0048)(ConstParm, Parm, OutParm, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzProjectileBase_OnMultiHitDamageReceived) == 0x000008, "Wrong alignment on GzProjectileBase_OnMultiHitDamageReceived");
static_assert(sizeof(GzProjectileBase_OnMultiHitDamageReceived) == 0x000050, "Wrong size on GzProjectileBase_OnMultiHitDamageReceived");
static_assert(offsetof(GzProjectileBase_OnMultiHitDamageReceived, Receiver) == 0x000000, "Member 'GzProjectileBase_OnMultiHitDamageReceived::Receiver' has a wrong offset!");
static_assert(offsetof(GzProjectileBase_OnMultiHitDamageReceived, Hit) == 0x000008, "Member 'GzProjectileBase_OnMultiHitDamageReceived::Hit' has a wrong offset!");

// Function G01.GzProjectileBase.OnSingleHitDamageReceived
// 0x01F8 (0x01F8 - 0x0000)
struct GzProjectileBase_OnSingleHitDamageReceived final
{
public:
	class UGzDamageableComponent*                 Receiver;                                          // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGzSingleHitDamage                     Hit;                                               // 0x0008(0x01F0)(ConstParm, Parm, OutParm, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzProjectileBase_OnSingleHitDamageReceived) == 0x000008, "Wrong alignment on GzProjectileBase_OnSingleHitDamageReceived");
static_assert(sizeof(GzProjectileBase_OnSingleHitDamageReceived) == 0x0001F8, "Wrong size on GzProjectileBase_OnSingleHitDamageReceived");
static_assert(offsetof(GzProjectileBase_OnSingleHitDamageReceived, Receiver) == 0x000000, "Member 'GzProjectileBase_OnSingleHitDamageReceived::Receiver' has a wrong offset!");
static_assert(offsetof(GzProjectileBase_OnSingleHitDamageReceived, Hit) == 0x000008, "Member 'GzProjectileBase_OnSingleHitDamageReceived::Hit' has a wrong offset!");

// Function G01.GzProjectileBase.SetItemData
// 0x0008 (0x0008 - 0x0000)
struct GzProjectileBase_SetItemData final
{
public:
	class UGzItemData*                            Param_ItemData;                                    // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzProjectileBase_SetItemData) == 0x000008, "Wrong alignment on GzProjectileBase_SetItemData");
static_assert(sizeof(GzProjectileBase_SetItemData) == 0x000008, "Wrong size on GzProjectileBase_SetItemData");
static_assert(offsetof(GzProjectileBase_SetItemData, Param_ItemData) == 0x000000, "Member 'GzProjectileBase_SetItemData::Param_ItemData' has a wrong offset!");

// Function G01.GzProjectileBase.WasLaunched
// 0x0001 (0x0001 - 0x0000)
struct GzProjectileBase_WasLaunched final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzProjectileBase_WasLaunched) == 0x000001, "Wrong alignment on GzProjectileBase_WasLaunched");
static_assert(sizeof(GzProjectileBase_WasLaunched) == 0x000001, "Wrong size on GzProjectileBase_WasLaunched");
static_assert(offsetof(GzProjectileBase_WasLaunched, ReturnValue) == 0x000000, "Member 'GzProjectileBase_WasLaunched::ReturnValue' has a wrong offset!");

// Function G01.GzGrappleHookProjectile.OnFlyingStop
// 0x00F8 (0x00F8 - 0x0000)
struct GzGrappleHookProjectile_OnFlyingStop final
{
public:
	struct FHitResult                             ImpactResult;                                      // 0x0000(0x00F8)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzGrappleHookProjectile_OnFlyingStop) == 0x000008, "Wrong alignment on GzGrappleHookProjectile_OnFlyingStop");
static_assert(sizeof(GzGrappleHookProjectile_OnFlyingStop) == 0x0000F8, "Wrong size on GzGrappleHookProjectile_OnFlyingStop");
static_assert(offsetof(GzGrappleHookProjectile_OnFlyingStop, ImpactResult) == 0x000000, "Member 'GzGrappleHookProjectile_OnFlyingStop::ImpactResult' has a wrong offset!");

// Function G01.GzLoadoutSelectionScreen.OnConfirmed_BP
// 0x0078 (0x0078 - 0x0000)
struct GzLoadoutSelectionScreen_OnConfirmed_BP final
{
public:
	class AGzPlayerController*                    ConfirmedBy;                                       // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGzLoadoutDataConfig                   LoadoutConfig;                                     // 0x0008(0x0070)(ConstParm, Parm, OutParm, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzLoadoutSelectionScreen_OnConfirmed_BP) == 0x000008, "Wrong alignment on GzLoadoutSelectionScreen_OnConfirmed_BP");
static_assert(sizeof(GzLoadoutSelectionScreen_OnConfirmed_BP) == 0x000078, "Wrong size on GzLoadoutSelectionScreen_OnConfirmed_BP");
static_assert(offsetof(GzLoadoutSelectionScreen_OnConfirmed_BP, ConfirmedBy) == 0x000000, "Member 'GzLoadoutSelectionScreen_OnConfirmed_BP::ConfirmedBy' has a wrong offset!");
static_assert(offsetof(GzLoadoutSelectionScreen_OnConfirmed_BP, LoadoutConfig) == 0x000008, "Member 'GzLoadoutSelectionScreen_OnConfirmed_BP::LoadoutConfig' has a wrong offset!");

// Function G01.GzLoadoutSelectionScreen.OnLoadoutButtonClicked_BP
// 0x0070 (0x0070 - 0x0000)
struct GzLoadoutSelectionScreen_OnLoadoutButtonClicked_BP final
{
public:
	struct FGzLoadoutDataConfig                   LoadoutConfig;                                     // 0x0000(0x0070)(ConstParm, Parm, OutParm, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzLoadoutSelectionScreen_OnLoadoutButtonClicked_BP) == 0x000008, "Wrong alignment on GzLoadoutSelectionScreen_OnLoadoutButtonClicked_BP");
static_assert(sizeof(GzLoadoutSelectionScreen_OnLoadoutButtonClicked_BP) == 0x000070, "Wrong size on GzLoadoutSelectionScreen_OnLoadoutButtonClicked_BP");
static_assert(offsetof(GzLoadoutSelectionScreen_OnLoadoutButtonClicked_BP, LoadoutConfig) == 0x000000, "Member 'GzLoadoutSelectionScreen_OnLoadoutButtonClicked_BP::LoadoutConfig' has a wrong offset!");

// Function G01.GzLoadoutSelectionScreen.OnLoadoutButtonDoubleClicked_BP
// 0x0070 (0x0070 - 0x0000)
struct GzLoadoutSelectionScreen_OnLoadoutButtonDoubleClicked_BP final
{
public:
	struct FGzLoadoutDataConfig                   LoadoutConfig;                                     // 0x0000(0x0070)(ConstParm, Parm, OutParm, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzLoadoutSelectionScreen_OnLoadoutButtonDoubleClicked_BP) == 0x000008, "Wrong alignment on GzLoadoutSelectionScreen_OnLoadoutButtonDoubleClicked_BP");
static_assert(sizeof(GzLoadoutSelectionScreen_OnLoadoutButtonDoubleClicked_BP) == 0x000070, "Wrong size on GzLoadoutSelectionScreen_OnLoadoutButtonDoubleClicked_BP");
static_assert(offsetof(GzLoadoutSelectionScreen_OnLoadoutButtonDoubleClicked_BP, LoadoutConfig) == 0x000000, "Member 'GzLoadoutSelectionScreen_OnLoadoutButtonDoubleClicked_BP::LoadoutConfig' has a wrong offset!");

// Function G01.GzLoadoutSelectionScreen.OnLoadoutButtonHovered_BP
// 0x0070 (0x0070 - 0x0000)
struct GzLoadoutSelectionScreen_OnLoadoutButtonHovered_BP final
{
public:
	struct FGzLoadoutDataConfig                   LoadoutConfig;                                     // 0x0000(0x0070)(ConstParm, Parm, OutParm, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzLoadoutSelectionScreen_OnLoadoutButtonHovered_BP) == 0x000008, "Wrong alignment on GzLoadoutSelectionScreen_OnLoadoutButtonHovered_BP");
static_assert(sizeof(GzLoadoutSelectionScreen_OnLoadoutButtonHovered_BP) == 0x000070, "Wrong size on GzLoadoutSelectionScreen_OnLoadoutButtonHovered_BP");
static_assert(offsetof(GzLoadoutSelectionScreen_OnLoadoutButtonHovered_BP, LoadoutConfig) == 0x000000, "Member 'GzLoadoutSelectionScreen_OnLoadoutButtonHovered_BP::LoadoutConfig' has a wrong offset!");

// Function G01.GzLoadoutSelectionScreen.OnLoadoutButtonUnHovered_BP
// 0x0070 (0x0070 - 0x0000)
struct GzLoadoutSelectionScreen_OnLoadoutButtonUnHovered_BP final
{
public:
	struct FGzLoadoutDataConfig                   LoadoutConfig;                                     // 0x0000(0x0070)(ConstParm, Parm, OutParm, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzLoadoutSelectionScreen_OnLoadoutButtonUnHovered_BP) == 0x000008, "Wrong alignment on GzLoadoutSelectionScreen_OnLoadoutButtonUnHovered_BP");
static_assert(sizeof(GzLoadoutSelectionScreen_OnLoadoutButtonUnHovered_BP) == 0x000070, "Wrong size on GzLoadoutSelectionScreen_OnLoadoutButtonUnHovered_BP");
static_assert(offsetof(GzLoadoutSelectionScreen_OnLoadoutButtonUnHovered_BP, LoadoutConfig) == 0x000000, "Member 'GzLoadoutSelectionScreen_OnLoadoutButtonUnHovered_BP::LoadoutConfig' has a wrong offset!");

// Function G01.GzLoadoutSelectionScreen.ValidateCompleteSelection
// 0x0001 (0x0001 - 0x0000)
struct GzLoadoutSelectionScreen_ValidateCompleteSelection final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzLoadoutSelectionScreen_ValidateCompleteSelection) == 0x000001, "Wrong alignment on GzLoadoutSelectionScreen_ValidateCompleteSelection");
static_assert(sizeof(GzLoadoutSelectionScreen_ValidateCompleteSelection) == 0x000001, "Wrong size on GzLoadoutSelectionScreen_ValidateCompleteSelection");
static_assert(offsetof(GzLoadoutSelectionScreen_ValidateCompleteSelection, ReturnValue) == 0x000000, "Member 'GzLoadoutSelectionScreen_ValidateCompleteSelection::ReturnValue' has a wrong offset!");

// Function G01.GzMultiPartAttributeSet.OnRep_AbilityRechargeMultiplier
// 0x0010 (0x0010 - 0x0000)
struct GzMultiPartAttributeSet_OnRep_AbilityRechargeMultiplier final
{
public:
	struct FGameplayAttributeData                 OldAbilityRechargeMultiplier;                      // 0x0000(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzMultiPartAttributeSet_OnRep_AbilityRechargeMultiplier) == 0x000008, "Wrong alignment on GzMultiPartAttributeSet_OnRep_AbilityRechargeMultiplier");
static_assert(sizeof(GzMultiPartAttributeSet_OnRep_AbilityRechargeMultiplier) == 0x000010, "Wrong size on GzMultiPartAttributeSet_OnRep_AbilityRechargeMultiplier");
static_assert(offsetof(GzMultiPartAttributeSet_OnRep_AbilityRechargeMultiplier, OldAbilityRechargeMultiplier) == 0x000000, "Member 'GzMultiPartAttributeSet_OnRep_AbilityRechargeMultiplier::OldAbilityRechargeMultiplier' has a wrong offset!");

// Function G01.GzMultiPartAttributeSet.OnRep_JetpackHealth
// 0x0010 (0x0010 - 0x0000)
struct GzMultiPartAttributeSet_OnRep_JetpackHealth final
{
public:
	struct FGameplayAttributeData                 OldValue;                                          // 0x0000(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzMultiPartAttributeSet_OnRep_JetpackHealth) == 0x000008, "Wrong alignment on GzMultiPartAttributeSet_OnRep_JetpackHealth");
static_assert(sizeof(GzMultiPartAttributeSet_OnRep_JetpackHealth) == 0x000010, "Wrong size on GzMultiPartAttributeSet_OnRep_JetpackHealth");
static_assert(offsetof(GzMultiPartAttributeSet_OnRep_JetpackHealth, OldValue) == 0x000000, "Member 'GzMultiPartAttributeSet_OnRep_JetpackHealth::OldValue' has a wrong offset!");

// Function G01.GzMultiPartAttributeSet.OnRep_JetpackMaxHealth
// 0x0010 (0x0010 - 0x0000)
struct GzMultiPartAttributeSet_OnRep_JetpackMaxHealth final
{
public:
	struct FGameplayAttributeData                 OldValue;                                          // 0x0000(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzMultiPartAttributeSet_OnRep_JetpackMaxHealth) == 0x000008, "Wrong alignment on GzMultiPartAttributeSet_OnRep_JetpackMaxHealth");
static_assert(sizeof(GzMultiPartAttributeSet_OnRep_JetpackMaxHealth) == 0x000010, "Wrong size on GzMultiPartAttributeSet_OnRep_JetpackMaxHealth");
static_assert(offsetof(GzMultiPartAttributeSet_OnRep_JetpackMaxHealth, OldValue) == 0x000000, "Member 'GzMultiPartAttributeSet_OnRep_JetpackMaxHealth::OldValue' has a wrong offset!");

// Function G01.GzMultiPartAttributeSet.OnRep_LeftArmAbilityCharges
// 0x0010 (0x0010 - 0x0000)
struct GzMultiPartAttributeSet_OnRep_LeftArmAbilityCharges final
{
public:
	struct FGameplayAttributeData                 OldLeftArmAbilityCharges;                          // 0x0000(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzMultiPartAttributeSet_OnRep_LeftArmAbilityCharges) == 0x000008, "Wrong alignment on GzMultiPartAttributeSet_OnRep_LeftArmAbilityCharges");
static_assert(sizeof(GzMultiPartAttributeSet_OnRep_LeftArmAbilityCharges) == 0x000010, "Wrong size on GzMultiPartAttributeSet_OnRep_LeftArmAbilityCharges");
static_assert(offsetof(GzMultiPartAttributeSet_OnRep_LeftArmAbilityCharges, OldLeftArmAbilityCharges) == 0x000000, "Member 'GzMultiPartAttributeSet_OnRep_LeftArmAbilityCharges::OldLeftArmAbilityCharges' has a wrong offset!");

// Function G01.GzMultiPartAttributeSet.OnRep_LeftArmHealth
// 0x0010 (0x0010 - 0x0000)
struct GzMultiPartAttributeSet_OnRep_LeftArmHealth final
{
public:
	struct FGameplayAttributeData                 OldValue;                                          // 0x0000(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzMultiPartAttributeSet_OnRep_LeftArmHealth) == 0x000008, "Wrong alignment on GzMultiPartAttributeSet_OnRep_LeftArmHealth");
static_assert(sizeof(GzMultiPartAttributeSet_OnRep_LeftArmHealth) == 0x000010, "Wrong size on GzMultiPartAttributeSet_OnRep_LeftArmHealth");
static_assert(offsetof(GzMultiPartAttributeSet_OnRep_LeftArmHealth, OldValue) == 0x000000, "Member 'GzMultiPartAttributeSet_OnRep_LeftArmHealth::OldValue' has a wrong offset!");

// Function G01.GzMultiPartAttributeSet.OnRep_LeftArmMaxAbilityCharges
// 0x0010 (0x0010 - 0x0000)
struct GzMultiPartAttributeSet_OnRep_LeftArmMaxAbilityCharges final
{
public:
	struct FGameplayAttributeData                 OldLeftArmMaxAbilityCharges;                       // 0x0000(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzMultiPartAttributeSet_OnRep_LeftArmMaxAbilityCharges) == 0x000008, "Wrong alignment on GzMultiPartAttributeSet_OnRep_LeftArmMaxAbilityCharges");
static_assert(sizeof(GzMultiPartAttributeSet_OnRep_LeftArmMaxAbilityCharges) == 0x000010, "Wrong size on GzMultiPartAttributeSet_OnRep_LeftArmMaxAbilityCharges");
static_assert(offsetof(GzMultiPartAttributeSet_OnRep_LeftArmMaxAbilityCharges, OldLeftArmMaxAbilityCharges) == 0x000000, "Member 'GzMultiPartAttributeSet_OnRep_LeftArmMaxAbilityCharges::OldLeftArmMaxAbilityCharges' has a wrong offset!");

// Function G01.GzMultiPartAttributeSet.OnRep_LeftArmMaxHealth
// 0x0010 (0x0010 - 0x0000)
struct GzMultiPartAttributeSet_OnRep_LeftArmMaxHealth final
{
public:
	struct FGameplayAttributeData                 OldValue;                                          // 0x0000(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzMultiPartAttributeSet_OnRep_LeftArmMaxHealth) == 0x000008, "Wrong alignment on GzMultiPartAttributeSet_OnRep_LeftArmMaxHealth");
static_assert(sizeof(GzMultiPartAttributeSet_OnRep_LeftArmMaxHealth) == 0x000010, "Wrong size on GzMultiPartAttributeSet_OnRep_LeftArmMaxHealth");
static_assert(offsetof(GzMultiPartAttributeSet_OnRep_LeftArmMaxHealth, OldValue) == 0x000000, "Member 'GzMultiPartAttributeSet_OnRep_LeftArmMaxHealth::OldValue' has a wrong offset!");

// Function G01.GzMultiPartAttributeSet.OnRep_LegsAbilityCharges
// 0x0010 (0x0010 - 0x0000)
struct GzMultiPartAttributeSet_OnRep_LegsAbilityCharges final
{
public:
	struct FGameplayAttributeData                 OldLegsAbilityCharges;                             // 0x0000(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzMultiPartAttributeSet_OnRep_LegsAbilityCharges) == 0x000008, "Wrong alignment on GzMultiPartAttributeSet_OnRep_LegsAbilityCharges");
static_assert(sizeof(GzMultiPartAttributeSet_OnRep_LegsAbilityCharges) == 0x000010, "Wrong size on GzMultiPartAttributeSet_OnRep_LegsAbilityCharges");
static_assert(offsetof(GzMultiPartAttributeSet_OnRep_LegsAbilityCharges, OldLegsAbilityCharges) == 0x000000, "Member 'GzMultiPartAttributeSet_OnRep_LegsAbilityCharges::OldLegsAbilityCharges' has a wrong offset!");

// Function G01.GzMultiPartAttributeSet.OnRep_LegsHealth
// 0x0010 (0x0010 - 0x0000)
struct GzMultiPartAttributeSet_OnRep_LegsHealth final
{
public:
	struct FGameplayAttributeData                 OldValue;                                          // 0x0000(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzMultiPartAttributeSet_OnRep_LegsHealth) == 0x000008, "Wrong alignment on GzMultiPartAttributeSet_OnRep_LegsHealth");
static_assert(sizeof(GzMultiPartAttributeSet_OnRep_LegsHealth) == 0x000010, "Wrong size on GzMultiPartAttributeSet_OnRep_LegsHealth");
static_assert(offsetof(GzMultiPartAttributeSet_OnRep_LegsHealth, OldValue) == 0x000000, "Member 'GzMultiPartAttributeSet_OnRep_LegsHealth::OldValue' has a wrong offset!");

// Function G01.GzMultiPartAttributeSet.OnRep_LegsMaxAbilityCharges
// 0x0010 (0x0010 - 0x0000)
struct GzMultiPartAttributeSet_OnRep_LegsMaxAbilityCharges final
{
public:
	struct FGameplayAttributeData                 OldLegsMaxAbilityCharges;                          // 0x0000(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzMultiPartAttributeSet_OnRep_LegsMaxAbilityCharges) == 0x000008, "Wrong alignment on GzMultiPartAttributeSet_OnRep_LegsMaxAbilityCharges");
static_assert(sizeof(GzMultiPartAttributeSet_OnRep_LegsMaxAbilityCharges) == 0x000010, "Wrong size on GzMultiPartAttributeSet_OnRep_LegsMaxAbilityCharges");
static_assert(offsetof(GzMultiPartAttributeSet_OnRep_LegsMaxAbilityCharges, OldLegsMaxAbilityCharges) == 0x000000, "Member 'GzMultiPartAttributeSet_OnRep_LegsMaxAbilityCharges::OldLegsMaxAbilityCharges' has a wrong offset!");

// Function G01.GzMultiPartAttributeSet.OnRep_LegsMaxHealth
// 0x0010 (0x0010 - 0x0000)
struct GzMultiPartAttributeSet_OnRep_LegsMaxHealth final
{
public:
	struct FGameplayAttributeData                 OldValue;                                          // 0x0000(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzMultiPartAttributeSet_OnRep_LegsMaxHealth) == 0x000008, "Wrong alignment on GzMultiPartAttributeSet_OnRep_LegsMaxHealth");
static_assert(sizeof(GzMultiPartAttributeSet_OnRep_LegsMaxHealth) == 0x000010, "Wrong size on GzMultiPartAttributeSet_OnRep_LegsMaxHealth");
static_assert(offsetof(GzMultiPartAttributeSet_OnRep_LegsMaxHealth, OldValue) == 0x000000, "Member 'GzMultiPartAttributeSet_OnRep_LegsMaxHealth::OldValue' has a wrong offset!");

// Function G01.GzMultiPartAttributeSet.OnRep_RightArmAbilityCharges
// 0x0010 (0x0010 - 0x0000)
struct GzMultiPartAttributeSet_OnRep_RightArmAbilityCharges final
{
public:
	struct FGameplayAttributeData                 OldRightArmAbilityCharges;                         // 0x0000(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzMultiPartAttributeSet_OnRep_RightArmAbilityCharges) == 0x000008, "Wrong alignment on GzMultiPartAttributeSet_OnRep_RightArmAbilityCharges");
static_assert(sizeof(GzMultiPartAttributeSet_OnRep_RightArmAbilityCharges) == 0x000010, "Wrong size on GzMultiPartAttributeSet_OnRep_RightArmAbilityCharges");
static_assert(offsetof(GzMultiPartAttributeSet_OnRep_RightArmAbilityCharges, OldRightArmAbilityCharges) == 0x000000, "Member 'GzMultiPartAttributeSet_OnRep_RightArmAbilityCharges::OldRightArmAbilityCharges' has a wrong offset!");

// Function G01.GzMultiPartAttributeSet.OnRep_RightArmHealth
// 0x0010 (0x0010 - 0x0000)
struct GzMultiPartAttributeSet_OnRep_RightArmHealth final
{
public:
	struct FGameplayAttributeData                 OldValue;                                          // 0x0000(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzMultiPartAttributeSet_OnRep_RightArmHealth) == 0x000008, "Wrong alignment on GzMultiPartAttributeSet_OnRep_RightArmHealth");
static_assert(sizeof(GzMultiPartAttributeSet_OnRep_RightArmHealth) == 0x000010, "Wrong size on GzMultiPartAttributeSet_OnRep_RightArmHealth");
static_assert(offsetof(GzMultiPartAttributeSet_OnRep_RightArmHealth, OldValue) == 0x000000, "Member 'GzMultiPartAttributeSet_OnRep_RightArmHealth::OldValue' has a wrong offset!");

// Function G01.GzMultiPartAttributeSet.OnRep_RightArmMaxAbilityCharges
// 0x0010 (0x0010 - 0x0000)
struct GzMultiPartAttributeSet_OnRep_RightArmMaxAbilityCharges final
{
public:
	struct FGameplayAttributeData                 OldRightArmMaxAbilityCharges;                      // 0x0000(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzMultiPartAttributeSet_OnRep_RightArmMaxAbilityCharges) == 0x000008, "Wrong alignment on GzMultiPartAttributeSet_OnRep_RightArmMaxAbilityCharges");
static_assert(sizeof(GzMultiPartAttributeSet_OnRep_RightArmMaxAbilityCharges) == 0x000010, "Wrong size on GzMultiPartAttributeSet_OnRep_RightArmMaxAbilityCharges");
static_assert(offsetof(GzMultiPartAttributeSet_OnRep_RightArmMaxAbilityCharges, OldRightArmMaxAbilityCharges) == 0x000000, "Member 'GzMultiPartAttributeSet_OnRep_RightArmMaxAbilityCharges::OldRightArmMaxAbilityCharges' has a wrong offset!");

// Function G01.GzMultiPartAttributeSet.OnRep_RightArmMaxHealth
// 0x0010 (0x0010 - 0x0000)
struct GzMultiPartAttributeSet_OnRep_RightArmMaxHealth final
{
public:
	struct FGameplayAttributeData                 OldValue;                                          // 0x0000(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzMultiPartAttributeSet_OnRep_RightArmMaxHealth) == 0x000008, "Wrong alignment on GzMultiPartAttributeSet_OnRep_RightArmMaxHealth");
static_assert(sizeof(GzMultiPartAttributeSet_OnRep_RightArmMaxHealth) == 0x000010, "Wrong size on GzMultiPartAttributeSet_OnRep_RightArmMaxHealth");
static_assert(offsetof(GzMultiPartAttributeSet_OnRep_RightArmMaxHealth, OldValue) == 0x000000, "Member 'GzMultiPartAttributeSet_OnRep_RightArmMaxHealth::OldValue' has a wrong offset!");

// Function G01.GzGA_Throw.BP_BindEventOnGrenadeLaunched
// 0x0010 (0x0010 - 0x0000)
struct GzGA_Throw_BP_BindEventOnGrenadeLaunched final
{
public:
	TDelegate<void()>                             Event;                                             // 0x0000(0x0010)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzGA_Throw_BP_BindEventOnGrenadeLaunched) == 0x000004, "Wrong alignment on GzGA_Throw_BP_BindEventOnGrenadeLaunched");
static_assert(sizeof(GzGA_Throw_BP_BindEventOnGrenadeLaunched) == 0x000010, "Wrong size on GzGA_Throw_BP_BindEventOnGrenadeLaunched");
static_assert(offsetof(GzGA_Throw_BP_BindEventOnGrenadeLaunched, Event) == 0x000000, "Member 'GzGA_Throw_BP_BindEventOnGrenadeLaunched::Event' has a wrong offset!");

// Function G01.GzGA_Throw.BP_BindEventOnStartCookingGrenade
// 0x0010 (0x0010 - 0x0000)
struct GzGA_Throw_BP_BindEventOnStartCookingGrenade final
{
public:
	TDelegate<void(float GrenadeTime)>            Event;                                             // 0x0000(0x0010)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzGA_Throw_BP_BindEventOnStartCookingGrenade) == 0x000004, "Wrong alignment on GzGA_Throw_BP_BindEventOnStartCookingGrenade");
static_assert(sizeof(GzGA_Throw_BP_BindEventOnStartCookingGrenade) == 0x000010, "Wrong size on GzGA_Throw_BP_BindEventOnStartCookingGrenade");
static_assert(offsetof(GzGA_Throw_BP_BindEventOnStartCookingGrenade, Event) == 0x000000, "Member 'GzGA_Throw_BP_BindEventOnStartCookingGrenade::Event' has a wrong offset!");

// Function G01.GzGA_Throw.BP_RemoveEventOnGrenadeLaunched
// 0x0010 (0x0010 - 0x0000)
struct GzGA_Throw_BP_RemoveEventOnGrenadeLaunched final
{
public:
	TDelegate<void()>                             Event;                                             // 0x0000(0x0010)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzGA_Throw_BP_RemoveEventOnGrenadeLaunched) == 0x000004, "Wrong alignment on GzGA_Throw_BP_RemoveEventOnGrenadeLaunched");
static_assert(sizeof(GzGA_Throw_BP_RemoveEventOnGrenadeLaunched) == 0x000010, "Wrong size on GzGA_Throw_BP_RemoveEventOnGrenadeLaunched");
static_assert(offsetof(GzGA_Throw_BP_RemoveEventOnGrenadeLaunched, Event) == 0x000000, "Member 'GzGA_Throw_BP_RemoveEventOnGrenadeLaunched::Event' has a wrong offset!");

// Function G01.GzGA_Throw.BP_RemoveEventOnStartCookingGrenade
// 0x0010 (0x0010 - 0x0000)
struct GzGA_Throw_BP_RemoveEventOnStartCookingGrenade final
{
public:
	TDelegate<void(float GrenadeTime)>            Event;                                             // 0x0000(0x0010)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzGA_Throw_BP_RemoveEventOnStartCookingGrenade) == 0x000004, "Wrong alignment on GzGA_Throw_BP_RemoveEventOnStartCookingGrenade");
static_assert(sizeof(GzGA_Throw_BP_RemoveEventOnStartCookingGrenade) == 0x000010, "Wrong size on GzGA_Throw_BP_RemoveEventOnStartCookingGrenade");
static_assert(offsetof(GzGA_Throw_BP_RemoveEventOnStartCookingGrenade, Event) == 0x000000, "Member 'GzGA_Throw_BP_RemoveEventOnStartCookingGrenade::Event' has a wrong offset!");

// Function G01.GzGA_Throw.CancelThrow
// 0x0008 (0x0008 - 0x0000)
struct GzGA_Throw_CancelThrow final
{
public:
	class AActor*                                 Actor;                                             // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzGA_Throw_CancelThrow) == 0x000008, "Wrong alignment on GzGA_Throw_CancelThrow");
static_assert(sizeof(GzGA_Throw_CancelThrow) == 0x000008, "Wrong size on GzGA_Throw_CancelThrow");
static_assert(offsetof(GzGA_Throw_CancelThrow, Actor) == 0x000000, "Member 'GzGA_Throw_CancelThrow::Actor' has a wrong offset!");

// Function G01.GzGA_Throw.OnAbilityInputPressedAgain
// 0x0004 (0x0004 - 0x0000)
struct GzGA_Throw_OnAbilityInputPressedAgain final
{
public:
	float                                         TimeHeld;                                          // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzGA_Throw_OnAbilityInputPressedAgain) == 0x000004, "Wrong alignment on GzGA_Throw_OnAbilityInputPressedAgain");
static_assert(sizeof(GzGA_Throw_OnAbilityInputPressedAgain) == 0x000004, "Wrong size on GzGA_Throw_OnAbilityInputPressedAgain");
static_assert(offsetof(GzGA_Throw_OnAbilityInputPressedAgain, TimeHeld) == 0x000000, "Member 'GzGA_Throw_OnAbilityInputPressedAgain::TimeHeld' has a wrong offset!");

// Function G01.GzGA_Throw.OnAttackInputPressed
// 0x0004 (0x0004 - 0x0000)
struct GzGA_Throw_OnAttackInputPressed final
{
public:
	float                                         TimeHeld;                                          // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzGA_Throw_OnAttackInputPressed) == 0x000004, "Wrong alignment on GzGA_Throw_OnAttackInputPressed");
static_assert(sizeof(GzGA_Throw_OnAttackInputPressed) == 0x000004, "Wrong size on GzGA_Throw_OnAttackInputPressed");
static_assert(offsetof(GzGA_Throw_OnAttackInputPressed, TimeHeld) == 0x000000, "Member 'GzGA_Throw_OnAttackInputPressed::TimeHeld' has a wrong offset!");

// Function G01.GzGA_Throw.OnStartThrow
// 0x0004 (0x0004 - 0x0000)
struct GzGA_Throw_OnStartThrow final
{
public:
	float                                         TimeHeld;                                          // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzGA_Throw_OnStartThrow) == 0x000004, "Wrong alignment on GzGA_Throw_OnStartThrow");
static_assert(sizeof(GzGA_Throw_OnStartThrow) == 0x000004, "Wrong size on GzGA_Throw_OnStartThrow");
static_assert(offsetof(GzGA_Throw_OnStartThrow, TimeHeld) == 0x000000, "Member 'GzGA_Throw_OnStartThrow::TimeHeld' has a wrong offset!");

// Function G01.GzGA_Throw.OnThrowAnimationNotification
// 0x0008 (0x0008 - 0x0000)
struct GzGA_Throw_OnThrowAnimationNotification final
{
public:
	class FName                                   NotifyName;                                        // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzGA_Throw_OnThrowAnimationNotification) == 0x000004, "Wrong alignment on GzGA_Throw_OnThrowAnimationNotification");
static_assert(sizeof(GzGA_Throw_OnThrowAnimationNotification) == 0x000008, "Wrong size on GzGA_Throw_OnThrowAnimationNotification");
static_assert(offsetof(GzGA_Throw_OnThrowAnimationNotification, NotifyName) == 0x000000, "Member 'GzGA_Throw_OnThrowAnimationNotification::NotifyName' has a wrong offset!");

// Function G01.GzGA_Throw.ServerHandleClientTargetData
// 0x0028 (0x0028 - 0x0000)
struct GzGA_Throw_ServerHandleClientTargetData final
{
public:
	struct FGameplayAbilityTargetDataHandle       TargetData;                                        // 0x0000(0x0028)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzGA_Throw_ServerHandleClientTargetData) == 0x000008, "Wrong alignment on GzGA_Throw_ServerHandleClientTargetData");
static_assert(sizeof(GzGA_Throw_ServerHandleClientTargetData) == 0x000028, "Wrong size on GzGA_Throw_ServerHandleClientTargetData");
static_assert(offsetof(GzGA_Throw_ServerHandleClientTargetData, TargetData) == 0x000000, "Member 'GzGA_Throw_ServerHandleClientTargetData::TargetData' has a wrong offset!");

// Function G01.GzGA_Throw.GetThrowableItemData
// 0x0008 (0x0008 - 0x0000)
struct GzGA_Throw_GetThrowableItemData final
{
public:
	const class UGzThrowableItemData*             ReturnValue;                                       // 0x0000(0x0008)(ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzGA_Throw_GetThrowableItemData) == 0x000008, "Wrong alignment on GzGA_Throw_GetThrowableItemData");
static_assert(sizeof(GzGA_Throw_GetThrowableItemData) == 0x000008, "Wrong size on GzGA_Throw_GetThrowableItemData");
static_assert(offsetof(GzGA_Throw_GetThrowableItemData, ReturnValue) == 0x000000, "Member 'GzGA_Throw_GetThrowableItemData::ReturnValue' has a wrong offset!");

// Function G01.GzGA_Throw.GetThrowableProjectile
// 0x0008 (0x0008 - 0x0000)
struct GzGA_Throw_GetThrowableProjectile final
{
public:
	const class AGzProjectileBase*                ReturnValue;                                       // 0x0000(0x0008)(ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzGA_Throw_GetThrowableProjectile) == 0x000008, "Wrong alignment on GzGA_Throw_GetThrowableProjectile");
static_assert(sizeof(GzGA_Throw_GetThrowableProjectile) == 0x000008, "Wrong size on GzGA_Throw_GetThrowableProjectile");
static_assert(offsetof(GzGA_Throw_GetThrowableProjectile, ReturnValue) == 0x000000, "Member 'GzGA_Throw_GetThrowableProjectile::ReturnValue' has a wrong offset!");

// Function G01.GzAttributeSet.OnRep_AirFrictionCoef
// 0x0010 (0x0010 - 0x0000)
struct GzAttributeSet_OnRep_AirFrictionCoef final
{
public:
	struct FGameplayAttributeData                 OldAirFrictionCoef;                                // 0x0000(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzAttributeSet_OnRep_AirFrictionCoef) == 0x000008, "Wrong alignment on GzAttributeSet_OnRep_AirFrictionCoef");
static_assert(sizeof(GzAttributeSet_OnRep_AirFrictionCoef) == 0x000010, "Wrong size on GzAttributeSet_OnRep_AirFrictionCoef");
static_assert(offsetof(GzAttributeSet_OnRep_AirFrictionCoef, OldAirFrictionCoef) == 0x000000, "Member 'GzAttributeSet_OnRep_AirFrictionCoef::OldAirFrictionCoef' has a wrong offset!");

// Function G01.GzAttributeSet.OnRep_Armor
// 0x0010 (0x0010 - 0x0000)
struct GzAttributeSet_OnRep_Armor final
{
public:
	struct FGameplayAttributeData                 OldArmor;                                          // 0x0000(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzAttributeSet_OnRep_Armor) == 0x000008, "Wrong alignment on GzAttributeSet_OnRep_Armor");
static_assert(sizeof(GzAttributeSet_OnRep_Armor) == 0x000010, "Wrong size on GzAttributeSet_OnRep_Armor");
static_assert(offsetof(GzAttributeSet_OnRep_Armor, OldArmor) == 0x000000, "Member 'GzAttributeSet_OnRep_Armor::OldArmor' has a wrong offset!");

// Function G01.GzAttributeSet.OnRep_ClimbSpeed
// 0x0010 (0x0010 - 0x0000)
struct GzAttributeSet_OnRep_ClimbSpeed final
{
public:
	struct FGameplayAttributeData                 OldClimbSpeed;                                     // 0x0000(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzAttributeSet_OnRep_ClimbSpeed) == 0x000008, "Wrong alignment on GzAttributeSet_OnRep_ClimbSpeed");
static_assert(sizeof(GzAttributeSet_OnRep_ClimbSpeed) == 0x000010, "Wrong size on GzAttributeSet_OnRep_ClimbSpeed");
static_assert(offsetof(GzAttributeSet_OnRep_ClimbSpeed, OldClimbSpeed) == 0x000000, "Member 'GzAttributeSet_OnRep_ClimbSpeed::OldClimbSpeed' has a wrong offset!");

// Function G01.GzAttributeSet.OnRep_CrouchCoef
// 0x0010 (0x0010 - 0x0000)
struct GzAttributeSet_OnRep_CrouchCoef final
{
public:
	struct FGameplayAttributeData                 OldCrouchCoef;                                     // 0x0000(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzAttributeSet_OnRep_CrouchCoef) == 0x000008, "Wrong alignment on GzAttributeSet_OnRep_CrouchCoef");
static_assert(sizeof(GzAttributeSet_OnRep_CrouchCoef) == 0x000010, "Wrong size on GzAttributeSet_OnRep_CrouchCoef");
static_assert(offsetof(GzAttributeSet_OnRep_CrouchCoef, OldCrouchCoef) == 0x000000, "Member 'GzAttributeSet_OnRep_CrouchCoef::OldCrouchCoef' has a wrong offset!");

// Function G01.GzAttributeSet.OnRep_GridArmor
// 0x0010 (0x0010 - 0x0000)
struct GzAttributeSet_OnRep_GridArmor final
{
public:
	struct FGameplayAttributeData                 OldGridArmor;                                      // 0x0000(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzAttributeSet_OnRep_GridArmor) == 0x000008, "Wrong alignment on GzAttributeSet_OnRep_GridArmor");
static_assert(sizeof(GzAttributeSet_OnRep_GridArmor) == 0x000010, "Wrong size on GzAttributeSet_OnRep_GridArmor");
static_assert(offsetof(GzAttributeSet_OnRep_GridArmor, OldGridArmor) == 0x000000, "Member 'GzAttributeSet_OnRep_GridArmor::OldGridArmor' has a wrong offset!");

// Function G01.GzAttributeSet.OnRep_JumpVelocity
// 0x0010 (0x0010 - 0x0000)
struct GzAttributeSet_OnRep_JumpVelocity final
{
public:
	struct FGameplayAttributeData                 OldJumpVelocity;                                   // 0x0000(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzAttributeSet_OnRep_JumpVelocity) == 0x000008, "Wrong alignment on GzAttributeSet_OnRep_JumpVelocity");
static_assert(sizeof(GzAttributeSet_OnRep_JumpVelocity) == 0x000010, "Wrong size on GzAttributeSet_OnRep_JumpVelocity");
static_assert(offsetof(GzAttributeSet_OnRep_JumpVelocity, OldJumpVelocity) == 0x000000, "Member 'GzAttributeSet_OnRep_JumpVelocity::OldJumpVelocity' has a wrong offset!");

// Function G01.GzAttributeSet.OnRep_MantleAndClimbHeight
// 0x0010 (0x0010 - 0x0000)
struct GzAttributeSet_OnRep_MantleAndClimbHeight final
{
public:
	struct FGameplayAttributeData                 OldMantleAndClimbHeight;                           // 0x0000(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzAttributeSet_OnRep_MantleAndClimbHeight) == 0x000008, "Wrong alignment on GzAttributeSet_OnRep_MantleAndClimbHeight");
static_assert(sizeof(GzAttributeSet_OnRep_MantleAndClimbHeight) == 0x000010, "Wrong size on GzAttributeSet_OnRep_MantleAndClimbHeight");
static_assert(offsetof(GzAttributeSet_OnRep_MantleAndClimbHeight, OldMantleAndClimbHeight) == 0x000000, "Member 'GzAttributeSet_OnRep_MantleAndClimbHeight::OldMantleAndClimbHeight' has a wrong offset!");

// Function G01.GzAttributeSet.OnRep_MantleSpeed
// 0x0010 (0x0010 - 0x0000)
struct GzAttributeSet_OnRep_MantleSpeed final
{
public:
	struct FGameplayAttributeData                 OldMantleSpeed;                                    // 0x0000(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzAttributeSet_OnRep_MantleSpeed) == 0x000008, "Wrong alignment on GzAttributeSet_OnRep_MantleSpeed");
static_assert(sizeof(GzAttributeSet_OnRep_MantleSpeed) == 0x000010, "Wrong size on GzAttributeSet_OnRep_MantleSpeed");
static_assert(offsetof(GzAttributeSet_OnRep_MantleSpeed, OldMantleSpeed) == 0x000000, "Member 'GzAttributeSet_OnRep_MantleSpeed::OldMantleSpeed' has a wrong offset!");

// Function G01.GzAttributeSet.OnRep_MaxArmor
// 0x0010 (0x0010 - 0x0000)
struct GzAttributeSet_OnRep_MaxArmor final
{
public:
	struct FGameplayAttributeData                 OldMaxArmor;                                       // 0x0000(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzAttributeSet_OnRep_MaxArmor) == 0x000008, "Wrong alignment on GzAttributeSet_OnRep_MaxArmor");
static_assert(sizeof(GzAttributeSet_OnRep_MaxArmor) == 0x000010, "Wrong size on GzAttributeSet_OnRep_MaxArmor");
static_assert(offsetof(GzAttributeSet_OnRep_MaxArmor, OldMaxArmor) == 0x000000, "Member 'GzAttributeSet_OnRep_MaxArmor::OldMaxArmor' has a wrong offset!");

// Function G01.GzAttributeSet.OnRep_MovementSpeed
// 0x0010 (0x0010 - 0x0000)
struct GzAttributeSet_OnRep_MovementSpeed final
{
public:
	struct FGameplayAttributeData                 OldMovementSpeed;                                  // 0x0000(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzAttributeSet_OnRep_MovementSpeed) == 0x000008, "Wrong alignment on GzAttributeSet_OnRep_MovementSpeed");
static_assert(sizeof(GzAttributeSet_OnRep_MovementSpeed) == 0x000010, "Wrong size on GzAttributeSet_OnRep_MovementSpeed");
static_assert(offsetof(GzAttributeSet_OnRep_MovementSpeed, OldMovementSpeed) == 0x000000, "Member 'GzAttributeSet_OnRep_MovementSpeed::OldMovementSpeed' has a wrong offset!");

// Function G01.GzAttributeSet.OnRep_RunCoef
// 0x0010 (0x0010 - 0x0000)
struct GzAttributeSet_OnRep_RunCoef final
{
public:
	struct FGameplayAttributeData                 OldRunCoef;                                        // 0x0000(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzAttributeSet_OnRep_RunCoef) == 0x000008, "Wrong alignment on GzAttributeSet_OnRep_RunCoef");
static_assert(sizeof(GzAttributeSet_OnRep_RunCoef) == 0x000010, "Wrong size on GzAttributeSet_OnRep_RunCoef");
static_assert(offsetof(GzAttributeSet_OnRep_RunCoef, OldRunCoef) == 0x000000, "Member 'GzAttributeSet_OnRep_RunCoef::OldRunCoef' has a wrong offset!");

// Function G01.GzAttributeSet.OnRep_SprintCoef
// 0x0010 (0x0010 - 0x0000)
struct GzAttributeSet_OnRep_SprintCoef final
{
public:
	struct FGameplayAttributeData                 OldSprintCoef;                                     // 0x0000(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzAttributeSet_OnRep_SprintCoef) == 0x000008, "Wrong alignment on GzAttributeSet_OnRep_SprintCoef");
static_assert(sizeof(GzAttributeSet_OnRep_SprintCoef) == 0x000010, "Wrong size on GzAttributeSet_OnRep_SprintCoef");
static_assert(offsetof(GzAttributeSet_OnRep_SprintCoef, OldSprintCoef) == 0x000000, "Member 'GzAttributeSet_OnRep_SprintCoef::OldSprintCoef' has a wrong offset!");

// Function G01.GzAttributeSet.OnRep_WalkCoef
// 0x0010 (0x0010 - 0x0000)
struct GzAttributeSet_OnRep_WalkCoef final
{
public:
	struct FGameplayAttributeData                 OldWalkCoef;                                       // 0x0000(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzAttributeSet_OnRep_WalkCoef) == 0x000008, "Wrong alignment on GzAttributeSet_OnRep_WalkCoef");
static_assert(sizeof(GzAttributeSet_OnRep_WalkCoef) == 0x000010, "Wrong size on GzAttributeSet_OnRep_WalkCoef");
static_assert(offsetof(GzAttributeSet_OnRep_WalkCoef, OldWalkCoef) == 0x000000, "Member 'GzAttributeSet_OnRep_WalkCoef::OldWalkCoef' has a wrong offset!");

// Function G01.GzAT_AbilityTick.AbilityTick
// 0x0018 (0x0018 - 0x0000)
struct GzAT_AbilityTick_AbilityTick final
{
public:
	class UGameplayAbility*                       OwningAbility;                                     // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Param_Duration;                                    // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2E5C[0x4];                                     // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UGzAT_AbilityTick*                      ReturnValue;                                       // 0x0010(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzAT_AbilityTick_AbilityTick) == 0x000008, "Wrong alignment on GzAT_AbilityTick_AbilityTick");
static_assert(sizeof(GzAT_AbilityTick_AbilityTick) == 0x000018, "Wrong size on GzAT_AbilityTick_AbilityTick");
static_assert(offsetof(GzAT_AbilityTick_AbilityTick, OwningAbility) == 0x000000, "Member 'GzAT_AbilityTick_AbilityTick::OwningAbility' has a wrong offset!");
static_assert(offsetof(GzAT_AbilityTick_AbilityTick, Param_Duration) == 0x000008, "Member 'GzAT_AbilityTick_AbilityTick::Param_Duration' has a wrong offset!");
static_assert(offsetof(GzAT_AbilityTick_AbilityTick, ReturnValue) == 0x000010, "Member 'GzAT_AbilityTick_AbilityTick::ReturnValue' has a wrong offset!");

// Function G01.GzAT_ApplyRootMotionDash.ApplyRootMotionDash
// 0x0050 (0x0050 - 0x0000)
struct GzAT_ApplyRootMotionDash_ApplyRootMotionDash final
{
public:
	class UGameplayAbility*                       OwningAbility;                                     // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   TaskInstanceName;                                  // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	const class AActor*                           Param_TargetActor;                                 // 0x0010(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	const class UGzDashParamsData*                Param_DashParams;                                  // 0x0018(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Param_InitialTargetLocation;                       // 0x0020(0x0018)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Param_DistanceTriggerDistance;                     // 0x0038(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bResetVelocityAtEnd;                               // 0x003C(0x0001)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2E61[0x3];                                     // 0x003D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Param_ReachedDestinationDistance;                  // 0x0040(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2E62[0x4];                                     // 0x0044(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UGzAT_ApplyRootMotionDash*              ReturnValue;                                       // 0x0048(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzAT_ApplyRootMotionDash_ApplyRootMotionDash) == 0x000008, "Wrong alignment on GzAT_ApplyRootMotionDash_ApplyRootMotionDash");
static_assert(sizeof(GzAT_ApplyRootMotionDash_ApplyRootMotionDash) == 0x000050, "Wrong size on GzAT_ApplyRootMotionDash_ApplyRootMotionDash");
static_assert(offsetof(GzAT_ApplyRootMotionDash_ApplyRootMotionDash, OwningAbility) == 0x000000, "Member 'GzAT_ApplyRootMotionDash_ApplyRootMotionDash::OwningAbility' has a wrong offset!");
static_assert(offsetof(GzAT_ApplyRootMotionDash_ApplyRootMotionDash, TaskInstanceName) == 0x000008, "Member 'GzAT_ApplyRootMotionDash_ApplyRootMotionDash::TaskInstanceName' has a wrong offset!");
static_assert(offsetof(GzAT_ApplyRootMotionDash_ApplyRootMotionDash, Param_TargetActor) == 0x000010, "Member 'GzAT_ApplyRootMotionDash_ApplyRootMotionDash::Param_TargetActor' has a wrong offset!");
static_assert(offsetof(GzAT_ApplyRootMotionDash_ApplyRootMotionDash, Param_DashParams) == 0x000018, "Member 'GzAT_ApplyRootMotionDash_ApplyRootMotionDash::Param_DashParams' has a wrong offset!");
static_assert(offsetof(GzAT_ApplyRootMotionDash_ApplyRootMotionDash, Param_InitialTargetLocation) == 0x000020, "Member 'GzAT_ApplyRootMotionDash_ApplyRootMotionDash::Param_InitialTargetLocation' has a wrong offset!");
static_assert(offsetof(GzAT_ApplyRootMotionDash_ApplyRootMotionDash, Param_DistanceTriggerDistance) == 0x000038, "Member 'GzAT_ApplyRootMotionDash_ApplyRootMotionDash::Param_DistanceTriggerDistance' has a wrong offset!");
static_assert(offsetof(GzAT_ApplyRootMotionDash_ApplyRootMotionDash, bResetVelocityAtEnd) == 0x00003C, "Member 'GzAT_ApplyRootMotionDash_ApplyRootMotionDash::bResetVelocityAtEnd' has a wrong offset!");
static_assert(offsetof(GzAT_ApplyRootMotionDash_ApplyRootMotionDash, Param_ReachedDestinationDistance) == 0x000040, "Member 'GzAT_ApplyRootMotionDash_ApplyRootMotionDash::Param_ReachedDestinationDistance' has a wrong offset!");
static_assert(offsetof(GzAT_ApplyRootMotionDash_ApplyRootMotionDash, ReturnValue) == 0x000048, "Member 'GzAT_ApplyRootMotionDash_ApplyRootMotionDash::ReturnValue' has a wrong offset!");

// Function G01.GzAT_ApplyRootMotionDash.OnAvatarActorHitEvent
// 0x0120 (0x0120 - 0x0000)
struct GzAT_ApplyRootMotionDash_OnAvatarActorHitEvent final
{
public:
	class AActor*                                 SelfActor;                                         // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 OtherActor;                                        // 0x0008(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                NormalImpulse;                                     // 0x0010(0x0018)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FHitResult                             Hit;                                               // 0x0028(0x00F8)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzAT_ApplyRootMotionDash_OnAvatarActorHitEvent) == 0x000008, "Wrong alignment on GzAT_ApplyRootMotionDash_OnAvatarActorHitEvent");
static_assert(sizeof(GzAT_ApplyRootMotionDash_OnAvatarActorHitEvent) == 0x000120, "Wrong size on GzAT_ApplyRootMotionDash_OnAvatarActorHitEvent");
static_assert(offsetof(GzAT_ApplyRootMotionDash_OnAvatarActorHitEvent, SelfActor) == 0x000000, "Member 'GzAT_ApplyRootMotionDash_OnAvatarActorHitEvent::SelfActor' has a wrong offset!");
static_assert(offsetof(GzAT_ApplyRootMotionDash_OnAvatarActorHitEvent, OtherActor) == 0x000008, "Member 'GzAT_ApplyRootMotionDash_OnAvatarActorHitEvent::OtherActor' has a wrong offset!");
static_assert(offsetof(GzAT_ApplyRootMotionDash_OnAvatarActorHitEvent, NormalImpulse) == 0x000010, "Member 'GzAT_ApplyRootMotionDash_OnAvatarActorHitEvent::NormalImpulse' has a wrong offset!");
static_assert(offsetof(GzAT_ApplyRootMotionDash_OnAvatarActorHitEvent, Hit) == 0x000028, "Member 'GzAT_ApplyRootMotionDash_OnAvatarActorHitEvent::Hit' has a wrong offset!");

// Function G01.GzSquadPanel.Init
// 0x0008 (0x0008 - 0x0000)
struct GzSquadPanel_Init final
{
public:
	class AGzPlayerState*                         InViewTargetPlayerState;                           // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzSquadPanel_Init) == 0x000008, "Wrong alignment on GzSquadPanel_Init");
static_assert(sizeof(GzSquadPanel_Init) == 0x000008, "Wrong size on GzSquadPanel_Init");
static_assert(offsetof(GzSquadPanel_Init, InViewTargetPlayerState) == 0x000000, "Member 'GzSquadPanel_Init::InViewTargetPlayerState' has a wrong offset!");

// Function G01.GzSquadPanel.OnPlayerChangeTeam
// 0x0008 (0x0008 - 0x0000)
struct GzSquadPanel_OnPlayerChangeTeam final
{
public:
	class AGzPlayerState*                         PlayerState;                                       // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzSquadPanel_OnPlayerChangeTeam) == 0x000008, "Wrong alignment on GzSquadPanel_OnPlayerChangeTeam");
static_assert(sizeof(GzSquadPanel_OnPlayerChangeTeam) == 0x000008, "Wrong size on GzSquadPanel_OnPlayerChangeTeam");
static_assert(offsetof(GzSquadPanel_OnPlayerChangeTeam, PlayerState) == 0x000000, "Member 'GzSquadPanel_OnPlayerChangeTeam::PlayerState' has a wrong offset!");

// Function G01.GzSquadPanel.OnTeammatesUpdated
// 0x0010 (0x0010 - 0x0000)
struct GzSquadPanel_OnTeammatesUpdated final
{
public:
	TArray<struct FGzTeamMember>                  TeamMembers;                                       // 0x0000(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzSquadPanel_OnTeammatesUpdated) == 0x000008, "Wrong alignment on GzSquadPanel_OnTeammatesUpdated");
static_assert(sizeof(GzSquadPanel_OnTeammatesUpdated) == 0x000010, "Wrong size on GzSquadPanel_OnTeammatesUpdated");
static_assert(offsetof(GzSquadPanel_OnTeammatesUpdated, TeamMembers) == 0x000000, "Member 'GzSquadPanel_OnTeammatesUpdated::TeamMembers' has a wrong offset!");

// Function G01.GzSquadPanel.GetViewTargetTeamMembers
// 0x0010 (0x0010 - 0x0000)
struct GzSquadPanel_GetViewTargetTeamMembers final
{
public:
	TArray<struct FGzTeamMember>                  ReturnValue;                                       // 0x0000(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzSquadPanel_GetViewTargetTeamMembers) == 0x000008, "Wrong alignment on GzSquadPanel_GetViewTargetTeamMembers");
static_assert(sizeof(GzSquadPanel_GetViewTargetTeamMembers) == 0x000010, "Wrong size on GzSquadPanel_GetViewTargetTeamMembers");
static_assert(offsetof(GzSquadPanel_GetViewTargetTeamMembers, ReturnValue) == 0x000000, "Member 'GzSquadPanel_GetViewTargetTeamMembers::ReturnValue' has a wrong offset!");

// Function G01.GzAT_ApplyRootMotionInteractable.ApplyRootMotionInteractable
// 0x0118 (0x0118 - 0x0000)
struct GzAT_ApplyRootMotionInteractable_ApplyRootMotionInteractable final
{
public:
	class UGameplayAbility*                       OwningAbility;                                     // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	const class UGzInteractableComponent*         Param_InteractableComponent;                       // 0x0008(0x0008)(ConstParm, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	const class UGzInteractableTransitionSettings* Param_InteractableTransitionSettings;              // 0x0010(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGzInteractionData                     InInteractionData;                                 // 0x0018(0x00F8)(ConstParm, Parm, OutParm, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
	class UGzAT_ApplyRootMotionInteractable*      ReturnValue;                                       // 0x0110(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzAT_ApplyRootMotionInteractable_ApplyRootMotionInteractable) == 0x000008, "Wrong alignment on GzAT_ApplyRootMotionInteractable_ApplyRootMotionInteractable");
static_assert(sizeof(GzAT_ApplyRootMotionInteractable_ApplyRootMotionInteractable) == 0x000118, "Wrong size on GzAT_ApplyRootMotionInteractable_ApplyRootMotionInteractable");
static_assert(offsetof(GzAT_ApplyRootMotionInteractable_ApplyRootMotionInteractable, OwningAbility) == 0x000000, "Member 'GzAT_ApplyRootMotionInteractable_ApplyRootMotionInteractable::OwningAbility' has a wrong offset!");
static_assert(offsetof(GzAT_ApplyRootMotionInteractable_ApplyRootMotionInteractable, Param_InteractableComponent) == 0x000008, "Member 'GzAT_ApplyRootMotionInteractable_ApplyRootMotionInteractable::Param_InteractableComponent' has a wrong offset!");
static_assert(offsetof(GzAT_ApplyRootMotionInteractable_ApplyRootMotionInteractable, Param_InteractableTransitionSettings) == 0x000010, "Member 'GzAT_ApplyRootMotionInteractable_ApplyRootMotionInteractable::Param_InteractableTransitionSettings' has a wrong offset!");
static_assert(offsetof(GzAT_ApplyRootMotionInteractable_ApplyRootMotionInteractable, InInteractionData) == 0x000018, "Member 'GzAT_ApplyRootMotionInteractable_ApplyRootMotionInteractable::InInteractionData' has a wrong offset!");
static_assert(offsetof(GzAT_ApplyRootMotionInteractable_ApplyRootMotionInteractable, ReturnValue) == 0x000110, "Member 'GzAT_ApplyRootMotionInteractable_ApplyRootMotionInteractable::ReturnValue' has a wrong offset!");

// Function G01.GzBodyPartAbilityData.GetRechargeTypeTag
// 0x0008 (0x0008 - 0x0000)
struct GzBodyPartAbilityData_GetRechargeTypeTag final
{
public:
	struct FGameplayTag                           ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzBodyPartAbilityData_GetRechargeTypeTag) == 0x000004, "Wrong alignment on GzBodyPartAbilityData_GetRechargeTypeTag");
static_assert(sizeof(GzBodyPartAbilityData_GetRechargeTypeTag) == 0x000008, "Wrong size on GzBodyPartAbilityData_GetRechargeTypeTag");
static_assert(offsetof(GzBodyPartAbilityData_GetRechargeTypeTag, ReturnValue) == 0x000000, "Member 'GzBodyPartAbilityData_GetRechargeTypeTag::ReturnValue' has a wrong offset!");

// Function G01.GzAT_ApplyRootMotionZipline.ApplyRootMotionZipline
// 0x0020 (0x0020 - 0x0000)
struct GzAT_ApplyRootMotionZipline_ApplyRootMotionZipline final
{
public:
	class UGameplayAbility*                       OwningAbility;                                     // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AGzZipline*                             Param_Zipline;                                     // 0x0008(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UGzZiplineMovementSettings*             ZiplineMovementSettings;                           // 0x0010(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UGzAT_ApplyRootMotionZipline*           ReturnValue;                                       // 0x0018(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzAT_ApplyRootMotionZipline_ApplyRootMotionZipline) == 0x000008, "Wrong alignment on GzAT_ApplyRootMotionZipline_ApplyRootMotionZipline");
static_assert(sizeof(GzAT_ApplyRootMotionZipline_ApplyRootMotionZipline) == 0x000020, "Wrong size on GzAT_ApplyRootMotionZipline_ApplyRootMotionZipline");
static_assert(offsetof(GzAT_ApplyRootMotionZipline_ApplyRootMotionZipline, OwningAbility) == 0x000000, "Member 'GzAT_ApplyRootMotionZipline_ApplyRootMotionZipline::OwningAbility' has a wrong offset!");
static_assert(offsetof(GzAT_ApplyRootMotionZipline_ApplyRootMotionZipline, Param_Zipline) == 0x000008, "Member 'GzAT_ApplyRootMotionZipline_ApplyRootMotionZipline::Param_Zipline' has a wrong offset!");
static_assert(offsetof(GzAT_ApplyRootMotionZipline_ApplyRootMotionZipline, ZiplineMovementSettings) == 0x000010, "Member 'GzAT_ApplyRootMotionZipline_ApplyRootMotionZipline::ZiplineMovementSettings' has a wrong offset!");
static_assert(offsetof(GzAT_ApplyRootMotionZipline_ApplyRootMotionZipline, ReturnValue) == 0x000018, "Member 'GzAT_ApplyRootMotionZipline_ApplyRootMotionZipline::ReturnValue' has a wrong offset!");

// Function G01.GzAT_ApplyRootMotionZiplineJumpOff.ApplyRootMotionZiplineJumpOff
// 0x0070 (0x0070 - 0x0000)
struct GzAT_ApplyRootMotionZiplineJumpOff_ApplyRootMotionZiplineJumpOff final
{
public:
	class UGameplayAbility*                       OwningAbility;                                     // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGzZiplineMovementRuntimeData          ZiplineData;                                       // 0x0008(0x0058)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	const class UGzZiplineMovementSettings*       ZiplineMovementSettings;                           // 0x0060(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UGzAT_ApplyRootMotionZiplineJumpOff*    ReturnValue;                                       // 0x0068(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzAT_ApplyRootMotionZiplineJumpOff_ApplyRootMotionZiplineJumpOff) == 0x000008, "Wrong alignment on GzAT_ApplyRootMotionZiplineJumpOff_ApplyRootMotionZiplineJumpOff");
static_assert(sizeof(GzAT_ApplyRootMotionZiplineJumpOff_ApplyRootMotionZiplineJumpOff) == 0x000070, "Wrong size on GzAT_ApplyRootMotionZiplineJumpOff_ApplyRootMotionZiplineJumpOff");
static_assert(offsetof(GzAT_ApplyRootMotionZiplineJumpOff_ApplyRootMotionZiplineJumpOff, OwningAbility) == 0x000000, "Member 'GzAT_ApplyRootMotionZiplineJumpOff_ApplyRootMotionZiplineJumpOff::OwningAbility' has a wrong offset!");
static_assert(offsetof(GzAT_ApplyRootMotionZiplineJumpOff_ApplyRootMotionZiplineJumpOff, ZiplineData) == 0x000008, "Member 'GzAT_ApplyRootMotionZiplineJumpOff_ApplyRootMotionZiplineJumpOff::ZiplineData' has a wrong offset!");
static_assert(offsetof(GzAT_ApplyRootMotionZiplineJumpOff_ApplyRootMotionZiplineJumpOff, ZiplineMovementSettings) == 0x000060, "Member 'GzAT_ApplyRootMotionZiplineJumpOff_ApplyRootMotionZiplineJumpOff::ZiplineMovementSettings' has a wrong offset!");
static_assert(offsetof(GzAT_ApplyRootMotionZiplineJumpOff_ApplyRootMotionZiplineJumpOff, ReturnValue) == 0x000068, "Member 'GzAT_ApplyRootMotionZiplineJumpOff_ApplyRootMotionZiplineJumpOff::ReturnValue' has a wrong offset!");

// Function G01.GzAT_ApplySmoothRotation.ApplySmoothRotation
// 0x0040 (0x0040 - 0x0000)
struct GzAT_ApplySmoothRotation_ApplySmoothRotation final
{
public:
	class UGameplayAbility*                       OwningAbility;                                     // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   TaskInstanceName;                                  // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Duration;                                          // 0x0010(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2E71[0x4];                                     // 0x0014(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UCurveFloat*                            Param_RotationOverTime;                            // 0x0018(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               TargetRotation;                                    // 0x0020(0x0018)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	class UGzAT_ApplySmoothRotation*              ReturnValue;                                       // 0x0038(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzAT_ApplySmoothRotation_ApplySmoothRotation) == 0x000008, "Wrong alignment on GzAT_ApplySmoothRotation_ApplySmoothRotation");
static_assert(sizeof(GzAT_ApplySmoothRotation_ApplySmoothRotation) == 0x000040, "Wrong size on GzAT_ApplySmoothRotation_ApplySmoothRotation");
static_assert(offsetof(GzAT_ApplySmoothRotation_ApplySmoothRotation, OwningAbility) == 0x000000, "Member 'GzAT_ApplySmoothRotation_ApplySmoothRotation::OwningAbility' has a wrong offset!");
static_assert(offsetof(GzAT_ApplySmoothRotation_ApplySmoothRotation, TaskInstanceName) == 0x000008, "Member 'GzAT_ApplySmoothRotation_ApplySmoothRotation::TaskInstanceName' has a wrong offset!");
static_assert(offsetof(GzAT_ApplySmoothRotation_ApplySmoothRotation, Duration) == 0x000010, "Member 'GzAT_ApplySmoothRotation_ApplySmoothRotation::Duration' has a wrong offset!");
static_assert(offsetof(GzAT_ApplySmoothRotation_ApplySmoothRotation, Param_RotationOverTime) == 0x000018, "Member 'GzAT_ApplySmoothRotation_ApplySmoothRotation::Param_RotationOverTime' has a wrong offset!");
static_assert(offsetof(GzAT_ApplySmoothRotation_ApplySmoothRotation, TargetRotation) == 0x000020, "Member 'GzAT_ApplySmoothRotation_ApplySmoothRotation::TargetRotation' has a wrong offset!");
static_assert(offsetof(GzAT_ApplySmoothRotation_ApplySmoothRotation, ReturnValue) == 0x000038, "Member 'GzAT_ApplySmoothRotation_ApplySmoothRotation::ReturnValue' has a wrong offset!");

// Function G01.GzAT_AsyncSweep.AsyncSweepByBox
// 0x00C0 (0x00C0 - 0x0000)
struct GzAT_AsyncSweep_AsyncSweepByBox final
{
public:
	class UGameplayAbility*                       OwningAbility;                                     // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   TaskInstanceName;                                  // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EGzAsyncTraceType                             TraceType;                                         // 0x0010(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2E73[0x7];                                     // 0x0011(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                StartPoint;                                        // 0x0018(0x0018)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Endpoint;                                          // 0x0030(0x0018)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2E74[0x8];                                     // 0x0048(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FQuat                                  Rotation;                                          // 0x0050(0x0020)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECollisionChannel                             Channel;                                           // 0x0070(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2E75[0x7];                                     // 0x0071(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                BoxHalfExtend;                                     // 0x0078(0x0018)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bTraceComplex;                                     // 0x0090(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2E76[0x7];                                     // 0x0091(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class AActor*>                         ActorsToIgnore;                                    // 0x0098(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	bool                                          bIgnoreSelf;                                       // 0x00A8(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2E77[0x7];                                     // 0x00A9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UGzAT_AsyncSweep*                       ReturnValue;                                       // 0x00B0(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2E78[0x8];                                     // 0x00B8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GzAT_AsyncSweep_AsyncSweepByBox) == 0x000010, "Wrong alignment on GzAT_AsyncSweep_AsyncSweepByBox");
static_assert(sizeof(GzAT_AsyncSweep_AsyncSweepByBox) == 0x0000C0, "Wrong size on GzAT_AsyncSweep_AsyncSweepByBox");
static_assert(offsetof(GzAT_AsyncSweep_AsyncSweepByBox, OwningAbility) == 0x000000, "Member 'GzAT_AsyncSweep_AsyncSweepByBox::OwningAbility' has a wrong offset!");
static_assert(offsetof(GzAT_AsyncSweep_AsyncSweepByBox, TaskInstanceName) == 0x000008, "Member 'GzAT_AsyncSweep_AsyncSweepByBox::TaskInstanceName' has a wrong offset!");
static_assert(offsetof(GzAT_AsyncSweep_AsyncSweepByBox, TraceType) == 0x000010, "Member 'GzAT_AsyncSweep_AsyncSweepByBox::TraceType' has a wrong offset!");
static_assert(offsetof(GzAT_AsyncSweep_AsyncSweepByBox, StartPoint) == 0x000018, "Member 'GzAT_AsyncSweep_AsyncSweepByBox::StartPoint' has a wrong offset!");
static_assert(offsetof(GzAT_AsyncSweep_AsyncSweepByBox, Endpoint) == 0x000030, "Member 'GzAT_AsyncSweep_AsyncSweepByBox::Endpoint' has a wrong offset!");
static_assert(offsetof(GzAT_AsyncSweep_AsyncSweepByBox, Rotation) == 0x000050, "Member 'GzAT_AsyncSweep_AsyncSweepByBox::Rotation' has a wrong offset!");
static_assert(offsetof(GzAT_AsyncSweep_AsyncSweepByBox, Channel) == 0x000070, "Member 'GzAT_AsyncSweep_AsyncSweepByBox::Channel' has a wrong offset!");
static_assert(offsetof(GzAT_AsyncSweep_AsyncSweepByBox, BoxHalfExtend) == 0x000078, "Member 'GzAT_AsyncSweep_AsyncSweepByBox::BoxHalfExtend' has a wrong offset!");
static_assert(offsetof(GzAT_AsyncSweep_AsyncSweepByBox, bTraceComplex) == 0x000090, "Member 'GzAT_AsyncSweep_AsyncSweepByBox::bTraceComplex' has a wrong offset!");
static_assert(offsetof(GzAT_AsyncSweep_AsyncSweepByBox, ActorsToIgnore) == 0x000098, "Member 'GzAT_AsyncSweep_AsyncSweepByBox::ActorsToIgnore' has a wrong offset!");
static_assert(offsetof(GzAT_AsyncSweep_AsyncSweepByBox, bIgnoreSelf) == 0x0000A8, "Member 'GzAT_AsyncSweep_AsyncSweepByBox::bIgnoreSelf' has a wrong offset!");
static_assert(offsetof(GzAT_AsyncSweep_AsyncSweepByBox, ReturnValue) == 0x0000B0, "Member 'GzAT_AsyncSweep_AsyncSweepByBox::ReturnValue' has a wrong offset!");

// Function G01.GzAT_AsyncSweep.AsyncSweepBySphere
// 0x00A0 (0x00A0 - 0x0000)
struct GzAT_AsyncSweep_AsyncSweepBySphere final
{
public:
	class UGameplayAbility*                       OwningAbility;                                     // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   TaskInstanceName;                                  // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EGzAsyncTraceType                             TraceType;                                         // 0x0010(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2E79[0x7];                                     // 0x0011(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                StartPoint;                                        // 0x0018(0x0018)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Endpoint;                                          // 0x0030(0x0018)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2E7A[0x8];                                     // 0x0048(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FQuat                                  Rotation;                                          // 0x0050(0x0020)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECollisionChannel                             Channel;                                           // 0x0070(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2E7B[0x3];                                     // 0x0071(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         SphereRadius;                                      // 0x0074(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bTraceComplex;                                     // 0x0078(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2E7C[0x7];                                     // 0x0079(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class AActor*>                         ActorsToIgnore;                                    // 0x0080(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	bool                                          bIgnoreSelf;                                       // 0x0090(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2E7D[0x7];                                     // 0x0091(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UGzAT_AsyncSweep*                       ReturnValue;                                       // 0x0098(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzAT_AsyncSweep_AsyncSweepBySphere) == 0x000010, "Wrong alignment on GzAT_AsyncSweep_AsyncSweepBySphere");
static_assert(sizeof(GzAT_AsyncSweep_AsyncSweepBySphere) == 0x0000A0, "Wrong size on GzAT_AsyncSweep_AsyncSweepBySphere");
static_assert(offsetof(GzAT_AsyncSweep_AsyncSweepBySphere, OwningAbility) == 0x000000, "Member 'GzAT_AsyncSweep_AsyncSweepBySphere::OwningAbility' has a wrong offset!");
static_assert(offsetof(GzAT_AsyncSweep_AsyncSweepBySphere, TaskInstanceName) == 0x000008, "Member 'GzAT_AsyncSweep_AsyncSweepBySphere::TaskInstanceName' has a wrong offset!");
static_assert(offsetof(GzAT_AsyncSweep_AsyncSweepBySphere, TraceType) == 0x000010, "Member 'GzAT_AsyncSweep_AsyncSweepBySphere::TraceType' has a wrong offset!");
static_assert(offsetof(GzAT_AsyncSweep_AsyncSweepBySphere, StartPoint) == 0x000018, "Member 'GzAT_AsyncSweep_AsyncSweepBySphere::StartPoint' has a wrong offset!");
static_assert(offsetof(GzAT_AsyncSweep_AsyncSweepBySphere, Endpoint) == 0x000030, "Member 'GzAT_AsyncSweep_AsyncSweepBySphere::Endpoint' has a wrong offset!");
static_assert(offsetof(GzAT_AsyncSweep_AsyncSweepBySphere, Rotation) == 0x000050, "Member 'GzAT_AsyncSweep_AsyncSweepBySphere::Rotation' has a wrong offset!");
static_assert(offsetof(GzAT_AsyncSweep_AsyncSweepBySphere, Channel) == 0x000070, "Member 'GzAT_AsyncSweep_AsyncSweepBySphere::Channel' has a wrong offset!");
static_assert(offsetof(GzAT_AsyncSweep_AsyncSweepBySphere, SphereRadius) == 0x000074, "Member 'GzAT_AsyncSweep_AsyncSweepBySphere::SphereRadius' has a wrong offset!");
static_assert(offsetof(GzAT_AsyncSweep_AsyncSweepBySphere, bTraceComplex) == 0x000078, "Member 'GzAT_AsyncSweep_AsyncSweepBySphere::bTraceComplex' has a wrong offset!");
static_assert(offsetof(GzAT_AsyncSweep_AsyncSweepBySphere, ActorsToIgnore) == 0x000080, "Member 'GzAT_AsyncSweep_AsyncSweepBySphere::ActorsToIgnore' has a wrong offset!");
static_assert(offsetof(GzAT_AsyncSweep_AsyncSweepBySphere, bIgnoreSelf) == 0x000090, "Member 'GzAT_AsyncSweep_AsyncSweepBySphere::bIgnoreSelf' has a wrong offset!");
static_assert(offsetof(GzAT_AsyncSweep_AsyncSweepBySphere, ReturnValue) == 0x000098, "Member 'GzAT_AsyncSweep_AsyncSweepBySphere::ReturnValue' has a wrong offset!");

// Function G01.GzBodyPartArchetype.GetSuitableSkinNames
// 0x0010 (0x0010 - 0x0000)
struct GzBodyPartArchetype_GetSuitableSkinNames final
{
public:
	TArray<class FName>                           ReturnValue;                                       // 0x0000(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzBodyPartArchetype_GetSuitableSkinNames) == 0x000008, "Wrong alignment on GzBodyPartArchetype_GetSuitableSkinNames");
static_assert(sizeof(GzBodyPartArchetype_GetSuitableSkinNames) == 0x000010, "Wrong size on GzBodyPartArchetype_GetSuitableSkinNames");
static_assert(offsetof(GzBodyPartArchetype_GetSuitableSkinNames, ReturnValue) == 0x000000, "Member 'GzBodyPartArchetype_GetSuitableSkinNames::ReturnValue' has a wrong offset!");

// Function G01.GzAT_AsyncTrace.AsyncTrace
// 0x0070 (0x0070 - 0x0000)
struct GzAT_AsyncTrace_AsyncTrace final
{
public:
	class UGameplayAbility*                       OwningAbility;                                     // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   TaskInstanceName;                                  // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EGzAsyncTraceType                             TraceType;                                         // 0x0010(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2E80[0x7];                                     // 0x0011(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                StartPoint;                                        // 0x0018(0x0018)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Endpoint;                                          // 0x0030(0x0018)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECollisionChannel                             Channel;                                           // 0x0048(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bTraceComplex;                                     // 0x0049(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2E81[0x6];                                     // 0x004A(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class AActor*>                         ActorsToIgnore;                                    // 0x0050(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	bool                                          bIgnoreSelf;                                       // 0x0060(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2E82[0x7];                                     // 0x0061(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UGzAT_AsyncTrace*                       ReturnValue;                                       // 0x0068(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzAT_AsyncTrace_AsyncTrace) == 0x000008, "Wrong alignment on GzAT_AsyncTrace_AsyncTrace");
static_assert(sizeof(GzAT_AsyncTrace_AsyncTrace) == 0x000070, "Wrong size on GzAT_AsyncTrace_AsyncTrace");
static_assert(offsetof(GzAT_AsyncTrace_AsyncTrace, OwningAbility) == 0x000000, "Member 'GzAT_AsyncTrace_AsyncTrace::OwningAbility' has a wrong offset!");
static_assert(offsetof(GzAT_AsyncTrace_AsyncTrace, TaskInstanceName) == 0x000008, "Member 'GzAT_AsyncTrace_AsyncTrace::TaskInstanceName' has a wrong offset!");
static_assert(offsetof(GzAT_AsyncTrace_AsyncTrace, TraceType) == 0x000010, "Member 'GzAT_AsyncTrace_AsyncTrace::TraceType' has a wrong offset!");
static_assert(offsetof(GzAT_AsyncTrace_AsyncTrace, StartPoint) == 0x000018, "Member 'GzAT_AsyncTrace_AsyncTrace::StartPoint' has a wrong offset!");
static_assert(offsetof(GzAT_AsyncTrace_AsyncTrace, Endpoint) == 0x000030, "Member 'GzAT_AsyncTrace_AsyncTrace::Endpoint' has a wrong offset!");
static_assert(offsetof(GzAT_AsyncTrace_AsyncTrace, Channel) == 0x000048, "Member 'GzAT_AsyncTrace_AsyncTrace::Channel' has a wrong offset!");
static_assert(offsetof(GzAT_AsyncTrace_AsyncTrace, bTraceComplex) == 0x000049, "Member 'GzAT_AsyncTrace_AsyncTrace::bTraceComplex' has a wrong offset!");
static_assert(offsetof(GzAT_AsyncTrace_AsyncTrace, ActorsToIgnore) == 0x000050, "Member 'GzAT_AsyncTrace_AsyncTrace::ActorsToIgnore' has a wrong offset!");
static_assert(offsetof(GzAT_AsyncTrace_AsyncTrace, bIgnoreSelf) == 0x000060, "Member 'GzAT_AsyncTrace_AsyncTrace::bIgnoreSelf' has a wrong offset!");
static_assert(offsetof(GzAT_AsyncTrace_AsyncTrace, ReturnValue) == 0x000068, "Member 'GzAT_AsyncTrace_AsyncTrace::ReturnValue' has a wrong offset!");

// Function G01.GzAT_JetpackDelayedActivation.JetpackDelayActivation
// 0x0020 (0x0020 - 0x0000)
struct GzAT_JetpackDelayedActivation_JetpackDelayActivation final
{
public:
	class UGameplayAbility*                       OwningAbility;                                     // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   TaskInstanceName;                                  // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InActivationDelay;                                 // 0x0010(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          InbInterruptDelayedJetpackIfWeCantExecuteAbility;  // 0x0014(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2E87[0x3];                                     // 0x0015(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class UGzAT_JetpackDelayedActivation*         ReturnValue;                                       // 0x0018(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzAT_JetpackDelayedActivation_JetpackDelayActivation) == 0x000008, "Wrong alignment on GzAT_JetpackDelayedActivation_JetpackDelayActivation");
static_assert(sizeof(GzAT_JetpackDelayedActivation_JetpackDelayActivation) == 0x000020, "Wrong size on GzAT_JetpackDelayedActivation_JetpackDelayActivation");
static_assert(offsetof(GzAT_JetpackDelayedActivation_JetpackDelayActivation, OwningAbility) == 0x000000, "Member 'GzAT_JetpackDelayedActivation_JetpackDelayActivation::OwningAbility' has a wrong offset!");
static_assert(offsetof(GzAT_JetpackDelayedActivation_JetpackDelayActivation, TaskInstanceName) == 0x000008, "Member 'GzAT_JetpackDelayedActivation_JetpackDelayActivation::TaskInstanceName' has a wrong offset!");
static_assert(offsetof(GzAT_JetpackDelayedActivation_JetpackDelayActivation, InActivationDelay) == 0x000010, "Member 'GzAT_JetpackDelayedActivation_JetpackDelayActivation::InActivationDelay' has a wrong offset!");
static_assert(offsetof(GzAT_JetpackDelayedActivation_JetpackDelayActivation, InbInterruptDelayedJetpackIfWeCantExecuteAbility) == 0x000014, "Member 'GzAT_JetpackDelayedActivation_JetpackDelayActivation::InbInterruptDelayedJetpackIfWeCantExecuteAbility' has a wrong offset!");
static_assert(offsetof(GzAT_JetpackDelayedActivation_JetpackDelayActivation, ReturnValue) == 0x000018, "Member 'GzAT_JetpackDelayedActivation_JetpackDelayActivation::ReturnValue' has a wrong offset!");

// Function G01.GzSpawnArea.GetZoneTag
// 0x0008 (0x0008 - 0x0000)
struct GzSpawnArea_GetZoneTag final
{
public:
	struct FGameplayTag                           ReturnValue;                                       // 0x0000(0x0008)(ConstParm, Parm, OutParm, ReturnParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzSpawnArea_GetZoneTag) == 0x000004, "Wrong alignment on GzSpawnArea_GetZoneTag");
static_assert(sizeof(GzSpawnArea_GetZoneTag) == 0x000008, "Wrong size on GzSpawnArea_GetZoneTag");
static_assert(offsetof(GzSpawnArea_GetZoneTag, ReturnValue) == 0x000000, "Member 'GzSpawnArea_GetZoneTag::ReturnValue' has a wrong offset!");

// Function G01.GzAT_LimbAbilityMonitor.MonitorLimbAbility
// 0x0020 (0x0020 - 0x0000)
struct GzAT_LimbAbilityMonitor_MonitorLimbAbility final
{
public:
	class UGameplayAbility*                       OwningAbility;                                     // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEnableImpulseTreshold;                            // 0x0008(0x0001)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2E89[0x3];                                     // 0x0009(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ImpulseThreshold;                                  // 0x000C(0x0004)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bListenForLimbLoss;                                // 0x0010(0x0001)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2E8A[0x7];                                     // 0x0011(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UGzAT_LimbAbilityMonitor*               ReturnValue;                                       // 0x0018(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzAT_LimbAbilityMonitor_MonitorLimbAbility) == 0x000008, "Wrong alignment on GzAT_LimbAbilityMonitor_MonitorLimbAbility");
static_assert(sizeof(GzAT_LimbAbilityMonitor_MonitorLimbAbility) == 0x000020, "Wrong size on GzAT_LimbAbilityMonitor_MonitorLimbAbility");
static_assert(offsetof(GzAT_LimbAbilityMonitor_MonitorLimbAbility, OwningAbility) == 0x000000, "Member 'GzAT_LimbAbilityMonitor_MonitorLimbAbility::OwningAbility' has a wrong offset!");
static_assert(offsetof(GzAT_LimbAbilityMonitor_MonitorLimbAbility, bEnableImpulseTreshold) == 0x000008, "Member 'GzAT_LimbAbilityMonitor_MonitorLimbAbility::bEnableImpulseTreshold' has a wrong offset!");
static_assert(offsetof(GzAT_LimbAbilityMonitor_MonitorLimbAbility, ImpulseThreshold) == 0x00000C, "Member 'GzAT_LimbAbilityMonitor_MonitorLimbAbility::ImpulseThreshold' has a wrong offset!");
static_assert(offsetof(GzAT_LimbAbilityMonitor_MonitorLimbAbility, bListenForLimbLoss) == 0x000010, "Member 'GzAT_LimbAbilityMonitor_MonitorLimbAbility::bListenForLimbLoss' has a wrong offset!");
static_assert(offsetof(GzAT_LimbAbilityMonitor_MonitorLimbAbility, ReturnValue) == 0x000018, "Member 'GzAT_LimbAbilityMonitor_MonitorLimbAbility::ReturnValue' has a wrong offset!");

// Function G01.GzAT_MortarLegs_Scanner.MortarLegs_Scanner
// 0x0068 (0x0068 - 0x0000)
struct GzAT_MortarLegs_Scanner_MortarLegs_Scanner final
{
public:
	class UGameplayAbility*                       OwningAbility;                                     // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AGzPlayerCharacter*                     Param_OwnerPlayer;                                 // 0x0008(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                OwnerForwardVector;                                // 0x0010(0x0018)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftClassPtr<class UClass>                   Param_ScannedTargetMarkerActorClass;               // 0x0028(0x0028)(Parm, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UGzBodyPartAbilityData_MortarLegs*      Param_AbilityData;                                 // 0x0050(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RoofCheckDistance;                                 // 0x0058(0x0004)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2E8D[0x4];                                     // 0x005C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UGzAT_MortarLegs_Scanner*               ReturnValue;                                       // 0x0060(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzAT_MortarLegs_Scanner_MortarLegs_Scanner) == 0x000008, "Wrong alignment on GzAT_MortarLegs_Scanner_MortarLegs_Scanner");
static_assert(sizeof(GzAT_MortarLegs_Scanner_MortarLegs_Scanner) == 0x000068, "Wrong size on GzAT_MortarLegs_Scanner_MortarLegs_Scanner");
static_assert(offsetof(GzAT_MortarLegs_Scanner_MortarLegs_Scanner, OwningAbility) == 0x000000, "Member 'GzAT_MortarLegs_Scanner_MortarLegs_Scanner::OwningAbility' has a wrong offset!");
static_assert(offsetof(GzAT_MortarLegs_Scanner_MortarLegs_Scanner, Param_OwnerPlayer) == 0x000008, "Member 'GzAT_MortarLegs_Scanner_MortarLegs_Scanner::Param_OwnerPlayer' has a wrong offset!");
static_assert(offsetof(GzAT_MortarLegs_Scanner_MortarLegs_Scanner, OwnerForwardVector) == 0x000010, "Member 'GzAT_MortarLegs_Scanner_MortarLegs_Scanner::OwnerForwardVector' has a wrong offset!");
static_assert(offsetof(GzAT_MortarLegs_Scanner_MortarLegs_Scanner, Param_ScannedTargetMarkerActorClass) == 0x000028, "Member 'GzAT_MortarLegs_Scanner_MortarLegs_Scanner::Param_ScannedTargetMarkerActorClass' has a wrong offset!");
static_assert(offsetof(GzAT_MortarLegs_Scanner_MortarLegs_Scanner, Param_AbilityData) == 0x000050, "Member 'GzAT_MortarLegs_Scanner_MortarLegs_Scanner::Param_AbilityData' has a wrong offset!");
static_assert(offsetof(GzAT_MortarLegs_Scanner_MortarLegs_Scanner, RoofCheckDistance) == 0x000058, "Member 'GzAT_MortarLegs_Scanner_MortarLegs_Scanner::RoofCheckDistance' has a wrong offset!");
static_assert(offsetof(GzAT_MortarLegs_Scanner_MortarLegs_Scanner, ReturnValue) == 0x000060, "Member 'GzAT_MortarLegs_Scanner_MortarLegs_Scanner::ReturnValue' has a wrong offset!");

// Function G01.GzAT_MovementMonitor.MonitorMovement
// 0x0028 (0x0028 - 0x0000)
struct GzAT_MovementMonitor_MonitorMovement final
{
public:
	class UGameplayAbility*                       OwningAbility;                                     // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEnableSpeedTreshold;                              // 0x0008(0x0001)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2E8F[0x3];                                     // 0x0009(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         SpeedThreshold;                                    // 0x000C(0x0004)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bListenForMovementInput;                           // 0x0010(0x0001)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2E90[0x3];                                     // 0x0011(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MovementInputThreshold;                            // 0x0014(0x0004)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bOnlyTriggerOnce;                                  // 0x0018(0x0001)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2E91[0x7];                                     // 0x0019(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UGzAT_MovementMonitor*                  ReturnValue;                                       // 0x0020(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzAT_MovementMonitor_MonitorMovement) == 0x000008, "Wrong alignment on GzAT_MovementMonitor_MonitorMovement");
static_assert(sizeof(GzAT_MovementMonitor_MonitorMovement) == 0x000028, "Wrong size on GzAT_MovementMonitor_MonitorMovement");
static_assert(offsetof(GzAT_MovementMonitor_MonitorMovement, OwningAbility) == 0x000000, "Member 'GzAT_MovementMonitor_MonitorMovement::OwningAbility' has a wrong offset!");
static_assert(offsetof(GzAT_MovementMonitor_MonitorMovement, bEnableSpeedTreshold) == 0x000008, "Member 'GzAT_MovementMonitor_MonitorMovement::bEnableSpeedTreshold' has a wrong offset!");
static_assert(offsetof(GzAT_MovementMonitor_MonitorMovement, SpeedThreshold) == 0x00000C, "Member 'GzAT_MovementMonitor_MonitorMovement::SpeedThreshold' has a wrong offset!");
static_assert(offsetof(GzAT_MovementMonitor_MonitorMovement, bListenForMovementInput) == 0x000010, "Member 'GzAT_MovementMonitor_MonitorMovement::bListenForMovementInput' has a wrong offset!");
static_assert(offsetof(GzAT_MovementMonitor_MonitorMovement, MovementInputThreshold) == 0x000014, "Member 'GzAT_MovementMonitor_MonitorMovement::MovementInputThreshold' has a wrong offset!");
static_assert(offsetof(GzAT_MovementMonitor_MonitorMovement, bOnlyTriggerOnce) == 0x000018, "Member 'GzAT_MovementMonitor_MonitorMovement::bOnlyTriggerOnce' has a wrong offset!");
static_assert(offsetof(GzAT_MovementMonitor_MonitorMovement, ReturnValue) == 0x000020, "Member 'GzAT_MovementMonitor_MonitorMovement::ReturnValue' has a wrong offset!");

// Function G01.GzAT_PlayMontageAndWaitForEvent.PlayMontageAndWaitForEvent
// 0x0058 (0x0058 - 0x0000)
struct GzAT_PlayMontageAndWaitForEvent_PlayMontageAndWaitForEvent final
{
public:
	class UGameplayAbility*                       OwningAbility;                                     // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   TaskInstanceName;                                  // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimMontage*                           Param_MontageToPlay;                               // 0x0010(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTagContainer                  Param_EventTags;                                   // 0x0018(0x0020)(Parm, NativeAccessSpecifierPublic)
	float                                         Param_Rate;                                        // 0x0038(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Param_StartSection;                                // 0x003C(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Param_bStopWhenAbilityEnds;                        // 0x0044(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2E93[0x3];                                     // 0x0045(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Param_AnimRootMotionTranslationScale;              // 0x0048(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2E94[0x4];                                     // 0x004C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UGzAT_PlayMontageAndWaitForEvent*       ReturnValue;                                       // 0x0050(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzAT_PlayMontageAndWaitForEvent_PlayMontageAndWaitForEvent) == 0x000008, "Wrong alignment on GzAT_PlayMontageAndWaitForEvent_PlayMontageAndWaitForEvent");
static_assert(sizeof(GzAT_PlayMontageAndWaitForEvent_PlayMontageAndWaitForEvent) == 0x000058, "Wrong size on GzAT_PlayMontageAndWaitForEvent_PlayMontageAndWaitForEvent");
static_assert(offsetof(GzAT_PlayMontageAndWaitForEvent_PlayMontageAndWaitForEvent, OwningAbility) == 0x000000, "Member 'GzAT_PlayMontageAndWaitForEvent_PlayMontageAndWaitForEvent::OwningAbility' has a wrong offset!");
static_assert(offsetof(GzAT_PlayMontageAndWaitForEvent_PlayMontageAndWaitForEvent, TaskInstanceName) == 0x000008, "Member 'GzAT_PlayMontageAndWaitForEvent_PlayMontageAndWaitForEvent::TaskInstanceName' has a wrong offset!");
static_assert(offsetof(GzAT_PlayMontageAndWaitForEvent_PlayMontageAndWaitForEvent, Param_MontageToPlay) == 0x000010, "Member 'GzAT_PlayMontageAndWaitForEvent_PlayMontageAndWaitForEvent::Param_MontageToPlay' has a wrong offset!");
static_assert(offsetof(GzAT_PlayMontageAndWaitForEvent_PlayMontageAndWaitForEvent, Param_EventTags) == 0x000018, "Member 'GzAT_PlayMontageAndWaitForEvent_PlayMontageAndWaitForEvent::Param_EventTags' has a wrong offset!");
static_assert(offsetof(GzAT_PlayMontageAndWaitForEvent_PlayMontageAndWaitForEvent, Param_Rate) == 0x000038, "Member 'GzAT_PlayMontageAndWaitForEvent_PlayMontageAndWaitForEvent::Param_Rate' has a wrong offset!");
static_assert(offsetof(GzAT_PlayMontageAndWaitForEvent_PlayMontageAndWaitForEvent, Param_StartSection) == 0x00003C, "Member 'GzAT_PlayMontageAndWaitForEvent_PlayMontageAndWaitForEvent::Param_StartSection' has a wrong offset!");
static_assert(offsetof(GzAT_PlayMontageAndWaitForEvent_PlayMontageAndWaitForEvent, Param_bStopWhenAbilityEnds) == 0x000044, "Member 'GzAT_PlayMontageAndWaitForEvent_PlayMontageAndWaitForEvent::Param_bStopWhenAbilityEnds' has a wrong offset!");
static_assert(offsetof(GzAT_PlayMontageAndWaitForEvent_PlayMontageAndWaitForEvent, Param_AnimRootMotionTranslationScale) == 0x000048, "Member 'GzAT_PlayMontageAndWaitForEvent_PlayMontageAndWaitForEvent::Param_AnimRootMotionTranslationScale' has a wrong offset!");
static_assert(offsetof(GzAT_PlayMontageAndWaitForEvent_PlayMontageAndWaitForEvent, ReturnValue) == 0x000050, "Member 'GzAT_PlayMontageAndWaitForEvent_PlayMontageAndWaitForEvent::ReturnValue' has a wrong offset!");

// Function G01.GzAT_PlayMontageAndWaitForEvent.OnNotifyBeginReceived
// 0x0028 (0x0028 - 0x0000)
struct GzAT_PlayMontageAndWaitForEvent_OnNotifyBeginReceived final
{
public:
	class FName                                   NotifyName;                                        // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FBranchingPointNotifyPayload           BranchingPointNotifyPayload;                       // 0x0008(0x0020)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzAT_PlayMontageAndWaitForEvent_OnNotifyBeginReceived) == 0x000008, "Wrong alignment on GzAT_PlayMontageAndWaitForEvent_OnNotifyBeginReceived");
static_assert(sizeof(GzAT_PlayMontageAndWaitForEvent_OnNotifyBeginReceived) == 0x000028, "Wrong size on GzAT_PlayMontageAndWaitForEvent_OnNotifyBeginReceived");
static_assert(offsetof(GzAT_PlayMontageAndWaitForEvent_OnNotifyBeginReceived, NotifyName) == 0x000000, "Member 'GzAT_PlayMontageAndWaitForEvent_OnNotifyBeginReceived::NotifyName' has a wrong offset!");
static_assert(offsetof(GzAT_PlayMontageAndWaitForEvent_OnNotifyBeginReceived, BranchingPointNotifyPayload) == 0x000008, "Member 'GzAT_PlayMontageAndWaitForEvent_OnNotifyBeginReceived::BranchingPointNotifyPayload' has a wrong offset!");

// Function G01.GzAT_PlayMontageAndWaitForEvent.OnNotifyEndReceived
// 0x0028 (0x0028 - 0x0000)
struct GzAT_PlayMontageAndWaitForEvent_OnNotifyEndReceived final
{
public:
	class FName                                   NotifyName;                                        // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FBranchingPointNotifyPayload           BranchingPointNotifyPayload;                       // 0x0008(0x0020)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzAT_PlayMontageAndWaitForEvent_OnNotifyEndReceived) == 0x000008, "Wrong alignment on GzAT_PlayMontageAndWaitForEvent_OnNotifyEndReceived");
static_assert(sizeof(GzAT_PlayMontageAndWaitForEvent_OnNotifyEndReceived) == 0x000028, "Wrong size on GzAT_PlayMontageAndWaitForEvent_OnNotifyEndReceived");
static_assert(offsetof(GzAT_PlayMontageAndWaitForEvent_OnNotifyEndReceived, NotifyName) == 0x000000, "Member 'GzAT_PlayMontageAndWaitForEvent_OnNotifyEndReceived::NotifyName' has a wrong offset!");
static_assert(offsetof(GzAT_PlayMontageAndWaitForEvent_OnNotifyEndReceived, BranchingPointNotifyPayload) == 0x000008, "Member 'GzAT_PlayMontageAndWaitForEvent_OnNotifyEndReceived::BranchingPointNotifyPayload' has a wrong offset!");

// Function G01.GzAT_ServerWaitForTargetData.ServerWaitForClientTargetData
// 0x0020 (0x0020 - 0x0000)
struct GzAT_ServerWaitForTargetData_ServerWaitForClientTargetData final
{
public:
	class UGameplayAbility*                       OwningAbility;                                     // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   TaskInstanceName;                                  // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          TriggerOnce;                                       // 0x0010(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2E96[0x7];                                     // 0x0011(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UGzAT_ServerWaitForTargetData*          ReturnValue;                                       // 0x0018(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzAT_ServerWaitForTargetData_ServerWaitForClientTargetData) == 0x000008, "Wrong alignment on GzAT_ServerWaitForTargetData_ServerWaitForClientTargetData");
static_assert(sizeof(GzAT_ServerWaitForTargetData_ServerWaitForClientTargetData) == 0x000020, "Wrong size on GzAT_ServerWaitForTargetData_ServerWaitForClientTargetData");
static_assert(offsetof(GzAT_ServerWaitForTargetData_ServerWaitForClientTargetData, OwningAbility) == 0x000000, "Member 'GzAT_ServerWaitForTargetData_ServerWaitForClientTargetData::OwningAbility' has a wrong offset!");
static_assert(offsetof(GzAT_ServerWaitForTargetData_ServerWaitForClientTargetData, TaskInstanceName) == 0x000008, "Member 'GzAT_ServerWaitForTargetData_ServerWaitForClientTargetData::TaskInstanceName' has a wrong offset!");
static_assert(offsetof(GzAT_ServerWaitForTargetData_ServerWaitForClientTargetData, TriggerOnce) == 0x000010, "Member 'GzAT_ServerWaitForTargetData_ServerWaitForClientTargetData::TriggerOnce' has a wrong offset!");
static_assert(offsetof(GzAT_ServerWaitForTargetData_ServerWaitForClientTargetData, ReturnValue) == 0x000018, "Member 'GzAT_ServerWaitForTargetData_ServerWaitForClientTargetData::ReturnValue' has a wrong offset!");

// Function G01.GzAT_ServerWaitForTargetData.OnTargetDataReplicatedCallback
// 0x0030 (0x0030 - 0x0000)
struct GzAT_ServerWaitForTargetData_OnTargetDataReplicatedCallback final
{
public:
	struct FGameplayAbilityTargetDataHandle       Data;                                              // 0x0000(0x0028)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	struct FGameplayTag                           ActivationTag;                                     // 0x0028(0x0008)(Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzAT_ServerWaitForTargetData_OnTargetDataReplicatedCallback) == 0x000008, "Wrong alignment on GzAT_ServerWaitForTargetData_OnTargetDataReplicatedCallback");
static_assert(sizeof(GzAT_ServerWaitForTargetData_OnTargetDataReplicatedCallback) == 0x000030, "Wrong size on GzAT_ServerWaitForTargetData_OnTargetDataReplicatedCallback");
static_assert(offsetof(GzAT_ServerWaitForTargetData_OnTargetDataReplicatedCallback, Data) == 0x000000, "Member 'GzAT_ServerWaitForTargetData_OnTargetDataReplicatedCallback::Data' has a wrong offset!");
static_assert(offsetof(GzAT_ServerWaitForTargetData_OnTargetDataReplicatedCallback, ActivationTag) == 0x000028, "Member 'GzAT_ServerWaitForTargetData_OnTargetDataReplicatedCallback::ActivationTag' has a wrong offset!");

// Function G01.DefaultInteractionBehavior.OnInteractionEnds
// 0x0010 (0x0010 - 0x0000)
struct DefaultInteractionBehavior_OnInteractionEnds final
{
public:
	class AActor*                                 InteractedBy;                                      // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bHasAuthority;                                     // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2E99[0x7];                                     // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(DefaultInteractionBehavior_OnInteractionEnds) == 0x000008, "Wrong alignment on DefaultInteractionBehavior_OnInteractionEnds");
static_assert(sizeof(DefaultInteractionBehavior_OnInteractionEnds) == 0x000010, "Wrong size on DefaultInteractionBehavior_OnInteractionEnds");
static_assert(offsetof(DefaultInteractionBehavior_OnInteractionEnds, InteractedBy) == 0x000000, "Member 'DefaultInteractionBehavior_OnInteractionEnds::InteractedBy' has a wrong offset!");
static_assert(offsetof(DefaultInteractionBehavior_OnInteractionEnds, bHasAuthority) == 0x000008, "Member 'DefaultInteractionBehavior_OnInteractionEnds::bHasAuthority' has a wrong offset!");

// Function G01.DefaultInteractionBehavior.CanBeInteractedBy
// 0x0010 (0x0010 - 0x0000)
struct DefaultInteractionBehavior_CanBeInteractedBy final
{
public:
	class UGzInteractionComponent*                InteractedBy;                                      // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2E9A[0x7];                                     // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(DefaultInteractionBehavior_CanBeInteractedBy) == 0x000008, "Wrong alignment on DefaultInteractionBehavior_CanBeInteractedBy");
static_assert(sizeof(DefaultInteractionBehavior_CanBeInteractedBy) == 0x000010, "Wrong size on DefaultInteractionBehavior_CanBeInteractedBy");
static_assert(offsetof(DefaultInteractionBehavior_CanBeInteractedBy, InteractedBy) == 0x000000, "Member 'DefaultInteractionBehavior_CanBeInteractedBy::InteractedBy' has a wrong offset!");
static_assert(offsetof(DefaultInteractionBehavior_CanBeInteractedBy, ReturnValue) == 0x000008, "Member 'DefaultInteractionBehavior_CanBeInteractedBy::ReturnValue' has a wrong offset!");

// Function G01.DefaultInteractionBehavior.GetOwnerActor
// 0x0008 (0x0008 - 0x0000)
struct DefaultInteractionBehavior_GetOwnerActor final
{
public:
	class AActor*                                 ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DefaultInteractionBehavior_GetOwnerActor) == 0x000008, "Wrong alignment on DefaultInteractionBehavior_GetOwnerActor");
static_assert(sizeof(DefaultInteractionBehavior_GetOwnerActor) == 0x000008, "Wrong size on DefaultInteractionBehavior_GetOwnerActor");
static_assert(offsetof(DefaultInteractionBehavior_GetOwnerActor, ReturnValue) == 0x000000, "Member 'DefaultInteractionBehavior_GetOwnerActor::ReturnValue' has a wrong offset!");

// Function G01.DefaultInteractionBehavior.GetOwnerASC
// 0x0008 (0x0008 - 0x0000)
struct DefaultInteractionBehavior_GetOwnerASC final
{
public:
	class UAbilitySystemComponent*                ReturnValue;                                       // 0x0000(0x0008)(ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DefaultInteractionBehavior_GetOwnerASC) == 0x000008, "Wrong alignment on DefaultInteractionBehavior_GetOwnerASC");
static_assert(sizeof(DefaultInteractionBehavior_GetOwnerASC) == 0x000008, "Wrong size on DefaultInteractionBehavior_GetOwnerASC");
static_assert(offsetof(DefaultInteractionBehavior_GetOwnerASC, ReturnValue) == 0x000000, "Member 'DefaultInteractionBehavior_GetOwnerASC::ReturnValue' has a wrong offset!");

// Function G01.DefaultInteractionBehavior.GetOwnerInteractable
// 0x0008 (0x0008 - 0x0000)
struct DefaultInteractionBehavior_GetOwnerInteractable final
{
public:
	class UGzInteractableComponent*               ReturnValue;                                       // 0x0000(0x0008)(ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DefaultInteractionBehavior_GetOwnerInteractable) == 0x000008, "Wrong alignment on DefaultInteractionBehavior_GetOwnerInteractable");
static_assert(sizeof(DefaultInteractionBehavior_GetOwnerInteractable) == 0x000008, "Wrong size on DefaultInteractionBehavior_GetOwnerInteractable");
static_assert(offsetof(DefaultInteractionBehavior_GetOwnerInteractable, ReturnValue) == 0x000000, "Member 'DefaultInteractionBehavior_GetOwnerInteractable::ReturnValue' has a wrong offset!");

// Function G01.MontageInteractionBehavior.OnMontageNotify
// 0x0008 (0x0008 - 0x0000)
struct MontageInteractionBehavior_OnMontageNotify final
{
public:
	class FName                                   NotifyName;                                        // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MontageInteractionBehavior_OnMontageNotify) == 0x000004, "Wrong alignment on MontageInteractionBehavior_OnMontageNotify");
static_assert(sizeof(MontageInteractionBehavior_OnMontageNotify) == 0x000008, "Wrong size on MontageInteractionBehavior_OnMontageNotify");
static_assert(offsetof(MontageInteractionBehavior_OnMontageNotify, NotifyName) == 0x000000, "Member 'MontageInteractionBehavior_OnMontageNotify::NotifyName' has a wrong offset!");

// Function G01.GzAT_W8AttributeChangeThreshold.WaitForAttributeChangeThreshold
// 0x0060 (0x0060 - 0x0000)
struct GzAT_W8AttributeChangeThreshold_WaitForAttributeChangeThreshold final
{
public:
	class UGameplayAbility*                       OwningAbility;                                     // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayAttribute                     Attribute;                                         // 0x0008(0x0038)(Parm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EWaitAttributeChangeComparison                ComparisonType;                                    // 0x0040(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2E9F[0x3];                                     // 0x0041(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ComparisonValue;                                   // 0x0044(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bTriggerOnce;                                      // 0x0048(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2EA0[0x7];                                     // 0x0049(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class AActor*                                 OptionalExternalOwner;                             // 0x0050(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UGzAT_W8AttributeChangeThreshold*       ReturnValue;                                       // 0x0058(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzAT_W8AttributeChangeThreshold_WaitForAttributeChangeThreshold) == 0x000008, "Wrong alignment on GzAT_W8AttributeChangeThreshold_WaitForAttributeChangeThreshold");
static_assert(sizeof(GzAT_W8AttributeChangeThreshold_WaitForAttributeChangeThreshold) == 0x000060, "Wrong size on GzAT_W8AttributeChangeThreshold_WaitForAttributeChangeThreshold");
static_assert(offsetof(GzAT_W8AttributeChangeThreshold_WaitForAttributeChangeThreshold, OwningAbility) == 0x000000, "Member 'GzAT_W8AttributeChangeThreshold_WaitForAttributeChangeThreshold::OwningAbility' has a wrong offset!");
static_assert(offsetof(GzAT_W8AttributeChangeThreshold_WaitForAttributeChangeThreshold, Attribute) == 0x000008, "Member 'GzAT_W8AttributeChangeThreshold_WaitForAttributeChangeThreshold::Attribute' has a wrong offset!");
static_assert(offsetof(GzAT_W8AttributeChangeThreshold_WaitForAttributeChangeThreshold, ComparisonType) == 0x000040, "Member 'GzAT_W8AttributeChangeThreshold_WaitForAttributeChangeThreshold::ComparisonType' has a wrong offset!");
static_assert(offsetof(GzAT_W8AttributeChangeThreshold_WaitForAttributeChangeThreshold, ComparisonValue) == 0x000044, "Member 'GzAT_W8AttributeChangeThreshold_WaitForAttributeChangeThreshold::ComparisonValue' has a wrong offset!");
static_assert(offsetof(GzAT_W8AttributeChangeThreshold_WaitForAttributeChangeThreshold, bTriggerOnce) == 0x000048, "Member 'GzAT_W8AttributeChangeThreshold_WaitForAttributeChangeThreshold::bTriggerOnce' has a wrong offset!");
static_assert(offsetof(GzAT_W8AttributeChangeThreshold_WaitForAttributeChangeThreshold, OptionalExternalOwner) == 0x000050, "Member 'GzAT_W8AttributeChangeThreshold_WaitForAttributeChangeThreshold::OptionalExternalOwner' has a wrong offset!");
static_assert(offsetof(GzAT_W8AttributeChangeThreshold_WaitForAttributeChangeThreshold, ReturnValue) == 0x000058, "Member 'GzAT_W8AttributeChangeThreshold_WaitForAttributeChangeThreshold::ReturnValue' has a wrong offset!");

// Function G01.GzAT_WaitComponentOverlap.WaitForOverlap
// 0x0020 (0x0020 - 0x0000)
struct GzAT_WaitComponentOverlap_WaitForOverlap final
{
public:
	class UGameplayAbility*                       OwningAbility;                                     // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UPrimitiveComponent*                    OverlapWithComponent;                              // 0x0008(0x0008)(Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEndTaskAfterFirstOverlap;                         // 0x0010(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bReceiveHit;                                       // 0x0011(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bReceiveBeginOverlap;                              // 0x0012(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2EA5[0x5];                                     // 0x0013(0x0005)(Fixing Size After Last Property [ Dumper-7 ])
	class UGzAT_WaitComponentOverlap*             ReturnValue;                                       // 0x0018(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzAT_WaitComponentOverlap_WaitForOverlap) == 0x000008, "Wrong alignment on GzAT_WaitComponentOverlap_WaitForOverlap");
static_assert(sizeof(GzAT_WaitComponentOverlap_WaitForOverlap) == 0x000020, "Wrong size on GzAT_WaitComponentOverlap_WaitForOverlap");
static_assert(offsetof(GzAT_WaitComponentOverlap_WaitForOverlap, OwningAbility) == 0x000000, "Member 'GzAT_WaitComponentOverlap_WaitForOverlap::OwningAbility' has a wrong offset!");
static_assert(offsetof(GzAT_WaitComponentOverlap_WaitForOverlap, OverlapWithComponent) == 0x000008, "Member 'GzAT_WaitComponentOverlap_WaitForOverlap::OverlapWithComponent' has a wrong offset!");
static_assert(offsetof(GzAT_WaitComponentOverlap_WaitForOverlap, bEndTaskAfterFirstOverlap) == 0x000010, "Member 'GzAT_WaitComponentOverlap_WaitForOverlap::bEndTaskAfterFirstOverlap' has a wrong offset!");
static_assert(offsetof(GzAT_WaitComponentOverlap_WaitForOverlap, bReceiveHit) == 0x000011, "Member 'GzAT_WaitComponentOverlap_WaitForOverlap::bReceiveHit' has a wrong offset!");
static_assert(offsetof(GzAT_WaitComponentOverlap_WaitForOverlap, bReceiveBeginOverlap) == 0x000012, "Member 'GzAT_WaitComponentOverlap_WaitForOverlap::bReceiveBeginOverlap' has a wrong offset!");
static_assert(offsetof(GzAT_WaitComponentOverlap_WaitForOverlap, ReturnValue) == 0x000018, "Member 'GzAT_WaitComponentOverlap_WaitForOverlap::ReturnValue' has a wrong offset!");

// Function G01.GzAT_WaitComponentOverlap.OnBeginOverlapCallback
// 0x0118 (0x0118 - 0x0000)
struct GzAT_WaitComponentOverlap_OnBeginOverlapCallback final
{
public:
	class UPrimitiveComponent*                    OverlappedComponent;                               // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 OtherActor;                                        // 0x0008(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UPrimitiveComponent*                    OtherComp;                                         // 0x0010(0x0008)(Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         OtherBodyIndex;                                    // 0x0018(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bFromSweep;                                        // 0x001C(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2EA6[0x3];                                     // 0x001D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FHitResult                             SweepResult;                                       // 0x0020(0x00F8)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzAT_WaitComponentOverlap_OnBeginOverlapCallback) == 0x000008, "Wrong alignment on GzAT_WaitComponentOverlap_OnBeginOverlapCallback");
static_assert(sizeof(GzAT_WaitComponentOverlap_OnBeginOverlapCallback) == 0x000118, "Wrong size on GzAT_WaitComponentOverlap_OnBeginOverlapCallback");
static_assert(offsetof(GzAT_WaitComponentOverlap_OnBeginOverlapCallback, OverlappedComponent) == 0x000000, "Member 'GzAT_WaitComponentOverlap_OnBeginOverlapCallback::OverlappedComponent' has a wrong offset!");
static_assert(offsetof(GzAT_WaitComponentOverlap_OnBeginOverlapCallback, OtherActor) == 0x000008, "Member 'GzAT_WaitComponentOverlap_OnBeginOverlapCallback::OtherActor' has a wrong offset!");
static_assert(offsetof(GzAT_WaitComponentOverlap_OnBeginOverlapCallback, OtherComp) == 0x000010, "Member 'GzAT_WaitComponentOverlap_OnBeginOverlapCallback::OtherComp' has a wrong offset!");
static_assert(offsetof(GzAT_WaitComponentOverlap_OnBeginOverlapCallback, OtherBodyIndex) == 0x000018, "Member 'GzAT_WaitComponentOverlap_OnBeginOverlapCallback::OtherBodyIndex' has a wrong offset!");
static_assert(offsetof(GzAT_WaitComponentOverlap_OnBeginOverlapCallback, bFromSweep) == 0x00001C, "Member 'GzAT_WaitComponentOverlap_OnBeginOverlapCallback::bFromSweep' has a wrong offset!");
static_assert(offsetof(GzAT_WaitComponentOverlap_OnBeginOverlapCallback, SweepResult) == 0x000020, "Member 'GzAT_WaitComponentOverlap_OnBeginOverlapCallback::SweepResult' has a wrong offset!");

// Function G01.GzAT_WaitComponentOverlap.OnHitCallback
// 0x0128 (0x0128 - 0x0000)
struct GzAT_WaitComponentOverlap_OnHitCallback final
{
public:
	class UPrimitiveComponent*                    HitComp;                                           // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 OtherActor;                                        // 0x0008(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UPrimitiveComponent*                    OtherComp;                                         // 0x0010(0x0008)(Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                NormalImpulse;                                     // 0x0018(0x0018)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FHitResult                             Hit;                                               // 0x0030(0x00F8)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzAT_WaitComponentOverlap_OnHitCallback) == 0x000008, "Wrong alignment on GzAT_WaitComponentOverlap_OnHitCallback");
static_assert(sizeof(GzAT_WaitComponentOverlap_OnHitCallback) == 0x000128, "Wrong size on GzAT_WaitComponentOverlap_OnHitCallback");
static_assert(offsetof(GzAT_WaitComponentOverlap_OnHitCallback, HitComp) == 0x000000, "Member 'GzAT_WaitComponentOverlap_OnHitCallback::HitComp' has a wrong offset!");
static_assert(offsetof(GzAT_WaitComponentOverlap_OnHitCallback, OtherActor) == 0x000008, "Member 'GzAT_WaitComponentOverlap_OnHitCallback::OtherActor' has a wrong offset!");
static_assert(offsetof(GzAT_WaitComponentOverlap_OnHitCallback, OtherComp) == 0x000010, "Member 'GzAT_WaitComponentOverlap_OnHitCallback::OtherComp' has a wrong offset!");
static_assert(offsetof(GzAT_WaitComponentOverlap_OnHitCallback, NormalImpulse) == 0x000018, "Member 'GzAT_WaitComponentOverlap_OnHitCallback::NormalImpulse' has a wrong offset!");
static_assert(offsetof(GzAT_WaitComponentOverlap_OnHitCallback, Hit) == 0x000030, "Member 'GzAT_WaitComponentOverlap_OnHitCallback::Hit' has a wrong offset!");

// Function G01.GzInWorldHitmarkSubsystem.OnHitResponse
// 0x0038 (0x0038 - 0x0000)
struct GzInWorldHitmarkSubsystem_OnHitResponse final
{
public:
	struct FGzHitResponseData                     HitResponseData;                                   // 0x0000(0x0038)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzInWorldHitmarkSubsystem_OnHitResponse) == 0x000008, "Wrong alignment on GzInWorldHitmarkSubsystem_OnHitResponse");
static_assert(sizeof(GzInWorldHitmarkSubsystem_OnHitResponse) == 0x000038, "Wrong size on GzInWorldHitmarkSubsystem_OnHitResponse");
static_assert(offsetof(GzInWorldHitmarkSubsystem_OnHitResponse, HitResponseData) == 0x000000, "Member 'GzInWorldHitmarkSubsystem_OnHitResponse::HitResponseData' has a wrong offset!");

// Function G01.GzAT_WaitCustomInputPress.WaitCustomAnyInputPress
// 0x0028 (0x0028 - 0x0000)
struct GzAT_WaitCustomInputPress_WaitCustomAnyInputPress final
{
public:
	class UGameplayAbility*                       OwningAbility;                                     // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class UInputAction*>                   InputActions;                                      // 0x0008(0x0010)(Parm, ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          bTestAlreadyPressed;                               // 0x0018(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EGzCustomInputEvent                           EventId;                                           // 0x0019(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2EAA[0x6];                                     // 0x001A(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class UGzAT_WaitCustomInputPress*             ReturnValue;                                       // 0x0020(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzAT_WaitCustomInputPress_WaitCustomAnyInputPress) == 0x000008, "Wrong alignment on GzAT_WaitCustomInputPress_WaitCustomAnyInputPress");
static_assert(sizeof(GzAT_WaitCustomInputPress_WaitCustomAnyInputPress) == 0x000028, "Wrong size on GzAT_WaitCustomInputPress_WaitCustomAnyInputPress");
static_assert(offsetof(GzAT_WaitCustomInputPress_WaitCustomAnyInputPress, OwningAbility) == 0x000000, "Member 'GzAT_WaitCustomInputPress_WaitCustomAnyInputPress::OwningAbility' has a wrong offset!");
static_assert(offsetof(GzAT_WaitCustomInputPress_WaitCustomAnyInputPress, InputActions) == 0x000008, "Member 'GzAT_WaitCustomInputPress_WaitCustomAnyInputPress::InputActions' has a wrong offset!");
static_assert(offsetof(GzAT_WaitCustomInputPress_WaitCustomAnyInputPress, bTestAlreadyPressed) == 0x000018, "Member 'GzAT_WaitCustomInputPress_WaitCustomAnyInputPress::bTestAlreadyPressed' has a wrong offset!");
static_assert(offsetof(GzAT_WaitCustomInputPress_WaitCustomAnyInputPress, EventId) == 0x000019, "Member 'GzAT_WaitCustomInputPress_WaitCustomAnyInputPress::EventId' has a wrong offset!");
static_assert(offsetof(GzAT_WaitCustomInputPress_WaitCustomAnyInputPress, ReturnValue) == 0x000020, "Member 'GzAT_WaitCustomInputPress_WaitCustomAnyInputPress::ReturnValue' has a wrong offset!");

// Function G01.GzAT_WaitCustomInputPress.WaitCustomInputPress
// 0x0020 (0x0020 - 0x0000)
struct GzAT_WaitCustomInputPress_WaitCustomInputPress final
{
public:
	class UGameplayAbility*                       OwningAbility;                                     // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UInputAction*                           InputAction;                                       // 0x0008(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bTestAlreadyPressed;                               // 0x0010(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EGzCustomInputEvent                           EventId;                                           // 0x0011(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2EAB[0x6];                                     // 0x0012(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class UGzAT_WaitCustomInputPress*             ReturnValue;                                       // 0x0018(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzAT_WaitCustomInputPress_WaitCustomInputPress) == 0x000008, "Wrong alignment on GzAT_WaitCustomInputPress_WaitCustomInputPress");
static_assert(sizeof(GzAT_WaitCustomInputPress_WaitCustomInputPress) == 0x000020, "Wrong size on GzAT_WaitCustomInputPress_WaitCustomInputPress");
static_assert(offsetof(GzAT_WaitCustomInputPress_WaitCustomInputPress, OwningAbility) == 0x000000, "Member 'GzAT_WaitCustomInputPress_WaitCustomInputPress::OwningAbility' has a wrong offset!");
static_assert(offsetof(GzAT_WaitCustomInputPress_WaitCustomInputPress, InputAction) == 0x000008, "Member 'GzAT_WaitCustomInputPress_WaitCustomInputPress::InputAction' has a wrong offset!");
static_assert(offsetof(GzAT_WaitCustomInputPress_WaitCustomInputPress, bTestAlreadyPressed) == 0x000010, "Member 'GzAT_WaitCustomInputPress_WaitCustomInputPress::bTestAlreadyPressed' has a wrong offset!");
static_assert(offsetof(GzAT_WaitCustomInputPress_WaitCustomInputPress, EventId) == 0x000011, "Member 'GzAT_WaitCustomInputPress_WaitCustomInputPress::EventId' has a wrong offset!");
static_assert(offsetof(GzAT_WaitCustomInputPress_WaitCustomInputPress, ReturnValue) == 0x000018, "Member 'GzAT_WaitCustomInputPress_WaitCustomInputPress::ReturnValue' has a wrong offset!");

// Function G01.GzAT_WaitCustomInputRelease.WaitCustomAnyInputRelease
// 0x0028 (0x0028 - 0x0000)
struct GzAT_WaitCustomInputRelease_WaitCustomAnyInputRelease final
{
public:
	class UGameplayAbility*                       OwningAbility;                                     // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class UInputAction*>                   InputActions;                                      // 0x0008(0x0010)(Parm, ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          bTestAlreadyReleased_NotImplemented;               // 0x0018(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EGzCustomInputEvent                           EventId;                                           // 0x0019(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2EAC[0x6];                                     // 0x001A(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class UGzAT_WaitCustomInputRelease*           ReturnValue;                                       // 0x0020(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzAT_WaitCustomInputRelease_WaitCustomAnyInputRelease) == 0x000008, "Wrong alignment on GzAT_WaitCustomInputRelease_WaitCustomAnyInputRelease");
static_assert(sizeof(GzAT_WaitCustomInputRelease_WaitCustomAnyInputRelease) == 0x000028, "Wrong size on GzAT_WaitCustomInputRelease_WaitCustomAnyInputRelease");
static_assert(offsetof(GzAT_WaitCustomInputRelease_WaitCustomAnyInputRelease, OwningAbility) == 0x000000, "Member 'GzAT_WaitCustomInputRelease_WaitCustomAnyInputRelease::OwningAbility' has a wrong offset!");
static_assert(offsetof(GzAT_WaitCustomInputRelease_WaitCustomAnyInputRelease, InputActions) == 0x000008, "Member 'GzAT_WaitCustomInputRelease_WaitCustomAnyInputRelease::InputActions' has a wrong offset!");
static_assert(offsetof(GzAT_WaitCustomInputRelease_WaitCustomAnyInputRelease, bTestAlreadyReleased_NotImplemented) == 0x000018, "Member 'GzAT_WaitCustomInputRelease_WaitCustomAnyInputRelease::bTestAlreadyReleased_NotImplemented' has a wrong offset!");
static_assert(offsetof(GzAT_WaitCustomInputRelease_WaitCustomAnyInputRelease, EventId) == 0x000019, "Member 'GzAT_WaitCustomInputRelease_WaitCustomAnyInputRelease::EventId' has a wrong offset!");
static_assert(offsetof(GzAT_WaitCustomInputRelease_WaitCustomAnyInputRelease, ReturnValue) == 0x000020, "Member 'GzAT_WaitCustomInputRelease_WaitCustomAnyInputRelease::ReturnValue' has a wrong offset!");

// Function G01.GzAT_WaitCustomInputRelease.WaitCustomInputRelease
// 0x0020 (0x0020 - 0x0000)
struct GzAT_WaitCustomInputRelease_WaitCustomInputRelease final
{
public:
	class UGameplayAbility*                       OwningAbility;                                     // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UInputAction*                           InputAction;                                       // 0x0008(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bTestAlreadyReleased_NotImplemented;               // 0x0010(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EGzCustomInputEvent                           EventId;                                           // 0x0011(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2EAD[0x6];                                     // 0x0012(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class UGzAT_WaitCustomInputRelease*           ReturnValue;                                       // 0x0018(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzAT_WaitCustomInputRelease_WaitCustomInputRelease) == 0x000008, "Wrong alignment on GzAT_WaitCustomInputRelease_WaitCustomInputRelease");
static_assert(sizeof(GzAT_WaitCustomInputRelease_WaitCustomInputRelease) == 0x000020, "Wrong size on GzAT_WaitCustomInputRelease_WaitCustomInputRelease");
static_assert(offsetof(GzAT_WaitCustomInputRelease_WaitCustomInputRelease, OwningAbility) == 0x000000, "Member 'GzAT_WaitCustomInputRelease_WaitCustomInputRelease::OwningAbility' has a wrong offset!");
static_assert(offsetof(GzAT_WaitCustomInputRelease_WaitCustomInputRelease, InputAction) == 0x000008, "Member 'GzAT_WaitCustomInputRelease_WaitCustomInputRelease::InputAction' has a wrong offset!");
static_assert(offsetof(GzAT_WaitCustomInputRelease_WaitCustomInputRelease, bTestAlreadyReleased_NotImplemented) == 0x000010, "Member 'GzAT_WaitCustomInputRelease_WaitCustomInputRelease::bTestAlreadyReleased_NotImplemented' has a wrong offset!");
static_assert(offsetof(GzAT_WaitCustomInputRelease_WaitCustomInputRelease, EventId) == 0x000011, "Member 'GzAT_WaitCustomInputRelease_WaitCustomInputRelease::EventId' has a wrong offset!");
static_assert(offsetof(GzAT_WaitCustomInputRelease_WaitCustomInputRelease, ReturnValue) == 0x000018, "Member 'GzAT_WaitCustomInputRelease_WaitCustomInputRelease::ReturnValue' has a wrong offset!");

// Function G01.GzAT_WaitDelayRepeated.WaitDelayRepeated
// 0x0020 (0x0020 - 0x0000)
struct GzAT_WaitDelayRepeated_WaitDelayRepeated final
{
public:
	class UGameplayAbility*                       OwningAbility;                                     // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Time;                                              // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         RepetionAmount;                                    // 0x000C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bTriggerOnStart;                                   // 0x0010(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Priority;                                          // 0x0011(0x0001)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2EB0[0x6];                                     // 0x0012(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class UGzAT_WaitDelayRepeated*                ReturnValue;                                       // 0x0018(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzAT_WaitDelayRepeated_WaitDelayRepeated) == 0x000008, "Wrong alignment on GzAT_WaitDelayRepeated_WaitDelayRepeated");
static_assert(sizeof(GzAT_WaitDelayRepeated_WaitDelayRepeated) == 0x000020, "Wrong size on GzAT_WaitDelayRepeated_WaitDelayRepeated");
static_assert(offsetof(GzAT_WaitDelayRepeated_WaitDelayRepeated, OwningAbility) == 0x000000, "Member 'GzAT_WaitDelayRepeated_WaitDelayRepeated::OwningAbility' has a wrong offset!");
static_assert(offsetof(GzAT_WaitDelayRepeated_WaitDelayRepeated, Time) == 0x000008, "Member 'GzAT_WaitDelayRepeated_WaitDelayRepeated::Time' has a wrong offset!");
static_assert(offsetof(GzAT_WaitDelayRepeated_WaitDelayRepeated, RepetionAmount) == 0x00000C, "Member 'GzAT_WaitDelayRepeated_WaitDelayRepeated::RepetionAmount' has a wrong offset!");
static_assert(offsetof(GzAT_WaitDelayRepeated_WaitDelayRepeated, bTriggerOnStart) == 0x000010, "Member 'GzAT_WaitDelayRepeated_WaitDelayRepeated::bTriggerOnStart' has a wrong offset!");
static_assert(offsetof(GzAT_WaitDelayRepeated_WaitDelayRepeated, Priority) == 0x000011, "Member 'GzAT_WaitDelayRepeated_WaitDelayRepeated::Priority' has a wrong offset!");
static_assert(offsetof(GzAT_WaitDelayRepeated_WaitDelayRepeated, ReturnValue) == 0x000018, "Member 'GzAT_WaitDelayRepeated_WaitDelayRepeated::ReturnValue' has a wrong offset!");

// Function G01.GzAT_WaitEquip.WaitEquipAbilityTask
// 0x00C8 (0x00C8 - 0x0000)
struct GzAT_WaitEquip_WaitEquipAbilityTask final
{
public:
	class UGameplayAbility*                       OwningAbility;                                     // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayEventData                     Payload;                                           // 0x0008(0x00B0)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	class UGzAbilityTaskConfig*                   AbilityTaskConfig;                                 // 0x00B8(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UGzAT_WaitEquip*                        ReturnValue;                                       // 0x00C0(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzAT_WaitEquip_WaitEquipAbilityTask) == 0x000008, "Wrong alignment on GzAT_WaitEquip_WaitEquipAbilityTask");
static_assert(sizeof(GzAT_WaitEquip_WaitEquipAbilityTask) == 0x0000C8, "Wrong size on GzAT_WaitEquip_WaitEquipAbilityTask");
static_assert(offsetof(GzAT_WaitEquip_WaitEquipAbilityTask, OwningAbility) == 0x000000, "Member 'GzAT_WaitEquip_WaitEquipAbilityTask::OwningAbility' has a wrong offset!");
static_assert(offsetof(GzAT_WaitEquip_WaitEquipAbilityTask, Payload) == 0x000008, "Member 'GzAT_WaitEquip_WaitEquipAbilityTask::Payload' has a wrong offset!");
static_assert(offsetof(GzAT_WaitEquip_WaitEquipAbilityTask, AbilityTaskConfig) == 0x0000B8, "Member 'GzAT_WaitEquip_WaitEquipAbilityTask::AbilityTaskConfig' has a wrong offset!");
static_assert(offsetof(GzAT_WaitEquip_WaitEquipAbilityTask, ReturnValue) == 0x0000C0, "Member 'GzAT_WaitEquip_WaitEquipAbilityTask::ReturnValue' has a wrong offset!");

// Function G01.GzAT_WaitEquip.OnWeaponEquiped
// 0x0018 (0x0018 - 0x0000)
struct GzAT_WaitEquip_OnWeaponEquiped final
{
public:
	struct FGzInvPocketId                         InvPocketId;                                       // 0x0000(0x0008)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	const class AGzWeaponActor*                   WeaponActor;                                       // 0x0008(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEquipped;                                         // 0x0010(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2EB4[0x7];                                     // 0x0011(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GzAT_WaitEquip_OnWeaponEquiped) == 0x000008, "Wrong alignment on GzAT_WaitEquip_OnWeaponEquiped");
static_assert(sizeof(GzAT_WaitEquip_OnWeaponEquiped) == 0x000018, "Wrong size on GzAT_WaitEquip_OnWeaponEquiped");
static_assert(offsetof(GzAT_WaitEquip_OnWeaponEquiped, InvPocketId) == 0x000000, "Member 'GzAT_WaitEquip_OnWeaponEquiped::InvPocketId' has a wrong offset!");
static_assert(offsetof(GzAT_WaitEquip_OnWeaponEquiped, WeaponActor) == 0x000008, "Member 'GzAT_WaitEquip_OnWeaponEquiped::WeaponActor' has a wrong offset!");
static_assert(offsetof(GzAT_WaitEquip_OnWeaponEquiped, bEquipped) == 0x000010, "Member 'GzAT_WaitEquip_OnWeaponEquiped::bEquipped' has a wrong offset!");

// Function G01.GzAT_WaitGameplayEventAny.WaitGameplayEventAny
// 0x0040 (0x0040 - 0x0000)
struct GzAT_WaitGameplayEventAny_WaitGameplayEventAny final
{
public:
	class UGameplayAbility*                       OwningAbility;                                     // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTagContainer                  EventTags;                                         // 0x0008(0x0020)(Parm, NativeAccessSpecifierPublic)
	class AActor*                                 Param_OptionalExternalTarget;                      // 0x0028(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          OnlyTriggerOnce;                                   // 0x0030(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2EB7[0x7];                                     // 0x0031(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UGzAT_WaitGameplayEventAny*             ReturnValue;                                       // 0x0038(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzAT_WaitGameplayEventAny_WaitGameplayEventAny) == 0x000008, "Wrong alignment on GzAT_WaitGameplayEventAny_WaitGameplayEventAny");
static_assert(sizeof(GzAT_WaitGameplayEventAny_WaitGameplayEventAny) == 0x000040, "Wrong size on GzAT_WaitGameplayEventAny_WaitGameplayEventAny");
static_assert(offsetof(GzAT_WaitGameplayEventAny_WaitGameplayEventAny, OwningAbility) == 0x000000, "Member 'GzAT_WaitGameplayEventAny_WaitGameplayEventAny::OwningAbility' has a wrong offset!");
static_assert(offsetof(GzAT_WaitGameplayEventAny_WaitGameplayEventAny, EventTags) == 0x000008, "Member 'GzAT_WaitGameplayEventAny_WaitGameplayEventAny::EventTags' has a wrong offset!");
static_assert(offsetof(GzAT_WaitGameplayEventAny_WaitGameplayEventAny, Param_OptionalExternalTarget) == 0x000028, "Member 'GzAT_WaitGameplayEventAny_WaitGameplayEventAny::Param_OptionalExternalTarget' has a wrong offset!");
static_assert(offsetof(GzAT_WaitGameplayEventAny_WaitGameplayEventAny, OnlyTriggerOnce) == 0x000030, "Member 'GzAT_WaitGameplayEventAny_WaitGameplayEventAny::OnlyTriggerOnce' has a wrong offset!");
static_assert(offsetof(GzAT_WaitGameplayEventAny_WaitGameplayEventAny, ReturnValue) == 0x000038, "Member 'GzAT_WaitGameplayEventAny_WaitGameplayEventAny::ReturnValue' has a wrong offset!");

// Function G01.GzHexExtractorMenu.Init
// 0x0008 (0x0008 - 0x0000)
struct GzHexExtractorMenu_Init final
{
public:
	class AGzItemExtractor*                       InHexExtractor;                                    // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzHexExtractorMenu_Init) == 0x000008, "Wrong alignment on GzHexExtractorMenu_Init");
static_assert(sizeof(GzHexExtractorMenu_Init) == 0x000008, "Wrong size on GzHexExtractorMenu_Init");
static_assert(offsetof(GzHexExtractorMenu_Init, InHexExtractor) == 0x000000, "Member 'GzHexExtractorMenu_Init::InHexExtractor' has a wrong offset!");

// Function G01.GzHexExtractorMenu.GetPlayerCurrency
// 0x0004 (0x0004 - 0x0000)
struct GzHexExtractorMenu_GetPlayerCurrency final
{
public:
	int32                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzHexExtractorMenu_GetPlayerCurrency) == 0x000004, "Wrong alignment on GzHexExtractorMenu_GetPlayerCurrency");
static_assert(sizeof(GzHexExtractorMenu_GetPlayerCurrency) == 0x000004, "Wrong size on GzHexExtractorMenu_GetPlayerCurrency");
static_assert(offsetof(GzHexExtractorMenu_GetPlayerCurrency, ReturnValue) == 0x000000, "Member 'GzHexExtractorMenu_GetPlayerCurrency::ReturnValue' has a wrong offset!");

// Function G01.GzPreviewPathActor.SetPathData
// 0x0140 (0x0140 - 0x0000)
struct GzPreviewPathActor_SetPathData final
{
public:
	struct FPredictProjectilePathResult           NewPathData;                                       // 0x0000(0x0140)(ConstParm, Parm, OutParm, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzPreviewPathActor_SetPathData) == 0x000008, "Wrong alignment on GzPreviewPathActor_SetPathData");
static_assert(sizeof(GzPreviewPathActor_SetPathData) == 0x000140, "Wrong size on GzPreviewPathActor_SetPathData");
static_assert(offsetof(GzPreviewPathActor_SetPathData, NewPathData) == 0x000000, "Member 'GzPreviewPathActor_SetPathData::NewPathData' has a wrong offset!");

// Function G01.GzPreviewPathActor.SetVisible
// 0x0001 (0x0001 - 0x0000)
struct GzPreviewPathActor_SetVisible final
{
public:
	bool                                          bIsVisible;                                        // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzPreviewPathActor_SetVisible) == 0x000001, "Wrong alignment on GzPreviewPathActor_SetVisible");
static_assert(sizeof(GzPreviewPathActor_SetVisible) == 0x000001, "Wrong size on GzPreviewPathActor_SetVisible");
static_assert(offsetof(GzPreviewPathActor_SetVisible, bIsVisible) == 0x000000, "Member 'GzPreviewPathActor_SetVisible::bIsVisible' has a wrong offset!");

// Function G01.GzPreviewPathActor.GetNiagaraComponents
// 0x0010 (0x0010 - 0x0000)
struct GzPreviewPathActor_GetNiagaraComponents final
{
public:
	TArray<class UNiagaraComponent*>              ReturnValue;                                       // 0x0000(0x0010)(ConstParm, ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzPreviewPathActor_GetNiagaraComponents) == 0x000008, "Wrong alignment on GzPreviewPathActor_GetNiagaraComponents");
static_assert(sizeof(GzPreviewPathActor_GetNiagaraComponents) == 0x000010, "Wrong size on GzPreviewPathActor_GetNiagaraComponents");
static_assert(offsetof(GzPreviewPathActor_GetNiagaraComponents, ReturnValue) == 0x000000, "Member 'GzPreviewPathActor_GetNiagaraComponents::ReturnValue' has a wrong offset!");

// Function G01.GzPreviewPathActor.GetPathEndLocation
// 0x0018 (0x0018 - 0x0000)
struct GzPreviewPathActor_GetPathEndLocation final
{
public:
	struct FVector                                ReturnValue;                                       // 0x0000(0x0018)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzPreviewPathActor_GetPathEndLocation) == 0x000008, "Wrong alignment on GzPreviewPathActor_GetPathEndLocation");
static_assert(sizeof(GzPreviewPathActor_GetPathEndLocation) == 0x000018, "Wrong size on GzPreviewPathActor_GetPathEndLocation");
static_assert(offsetof(GzPreviewPathActor_GetPathEndLocation, ReturnValue) == 0x000000, "Member 'GzPreviewPathActor_GetPathEndLocation::ReturnValue' has a wrong offset!");

// Function G01.GzPreviewPathActor.GetSplineMeshComponents
// 0x0010 (0x0010 - 0x0000)
struct GzPreviewPathActor_GetSplineMeshComponents final
{
public:
	TArray<class USplineMeshComponent*>           ReturnValue;                                       // 0x0000(0x0010)(ConstParm, ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzPreviewPathActor_GetSplineMeshComponents) == 0x000008, "Wrong alignment on GzPreviewPathActor_GetSplineMeshComponents");
static_assert(sizeof(GzPreviewPathActor_GetSplineMeshComponents) == 0x000010, "Wrong size on GzPreviewPathActor_GetSplineMeshComponents");
static_assert(offsetof(GzPreviewPathActor_GetSplineMeshComponents, ReturnValue) == 0x000000, "Member 'GzPreviewPathActor_GetSplineMeshComponents::ReturnValue' has a wrong offset!");

// Function G01.GzGameState.Multicast_SetMatchEndResult
// 0x0018 (0x0018 - 0x0000)
struct GzGameState_Multicast_SetMatchEndResult final
{
public:
	struct FGzMatchEndResult                      Result;                                            // 0x0000(0x0018)(ConstParm, Parm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzGameState_Multicast_SetMatchEndResult) == 0x000008, "Wrong alignment on GzGameState_Multicast_SetMatchEndResult");
static_assert(sizeof(GzGameState_Multicast_SetMatchEndResult) == 0x000018, "Wrong size on GzGameState_Multicast_SetMatchEndResult");
static_assert(offsetof(GzGameState_Multicast_SetMatchEndResult, Result) == 0x000000, "Member 'GzGameState_Multicast_SetMatchEndResult::Result' has a wrong offset!");

// Function G01.GzGameState.FindLocalSubsystem
// 0x0010 (0x0010 - 0x0000)
struct GzGameState_FindLocalSubsystem final
{
public:
	TSubclassOf<class AGzGameModeSubsystem>       SubsystemClass;                                    // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AGzGameModeSubsystem*                   ReturnValue;                                       // 0x0008(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzGameState_FindLocalSubsystem) == 0x000008, "Wrong alignment on GzGameState_FindLocalSubsystem");
static_assert(sizeof(GzGameState_FindLocalSubsystem) == 0x000010, "Wrong size on GzGameState_FindLocalSubsystem");
static_assert(offsetof(GzGameState_FindLocalSubsystem, SubsystemClass) == 0x000000, "Member 'GzGameState_FindLocalSubsystem::SubsystemClass' has a wrong offset!");
static_assert(offsetof(GzGameState_FindLocalSubsystem, ReturnValue) == 0x000008, "Member 'GzGameState_FindLocalSubsystem::ReturnValue' has a wrong offset!");

// Function G01.GzGameState.FindPlayerState
// 0x0010 (0x0010 - 0x0000)
struct GzGameState_FindPlayerState final
{
public:
	int32                                         PlayerId;                                          // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2EC9[0x4];                                     // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class AGzPlayerState*                         ReturnValue;                                       // 0x0008(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzGameState_FindPlayerState) == 0x000008, "Wrong alignment on GzGameState_FindPlayerState");
static_assert(sizeof(GzGameState_FindPlayerState) == 0x000010, "Wrong size on GzGameState_FindPlayerState");
static_assert(offsetof(GzGameState_FindPlayerState, PlayerId) == 0x000000, "Member 'GzGameState_FindPlayerState::PlayerId' has a wrong offset!");
static_assert(offsetof(GzGameState_FindPlayerState, ReturnValue) == 0x000008, "Member 'GzGameState_FindPlayerState::ReturnValue' has a wrong offset!");

// Function G01.GzGameState.GetMatchEndResult
// 0x0018 (0x0018 - 0x0000)
struct GzGameState_GetMatchEndResult final
{
public:
	struct FGzMatchEndResult                      ReturnValue;                                       // 0x0000(0x0018)(ConstParm, Parm, OutParm, ReturnParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzGameState_GetMatchEndResult) == 0x000008, "Wrong alignment on GzGameState_GetMatchEndResult");
static_assert(sizeof(GzGameState_GetMatchEndResult) == 0x000018, "Wrong size on GzGameState_GetMatchEndResult");
static_assert(offsetof(GzGameState_GetMatchEndResult, ReturnValue) == 0x000000, "Member 'GzGameState_GetMatchEndResult::ReturnValue' has a wrong offset!");

// Function G01.GzGameState.GetMatchId
// 0x0010 (0x0010 - 0x0000)
struct GzGameState_GetMatchId final
{
public:
	class FString                                 ReturnValue;                                       // 0x0000(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzGameState_GetMatchId) == 0x000008, "Wrong alignment on GzGameState_GetMatchId");
static_assert(sizeof(GzGameState_GetMatchId) == 0x000010, "Wrong size on GzGameState_GetMatchId");
static_assert(offsetof(GzGameState_GetMatchId, ReturnValue) == 0x000000, "Member 'GzGameState_GetMatchId::ReturnValue' has a wrong offset!");

// Function G01.GzGameState.GetPlayerStates
// 0x0010 (0x0010 - 0x0000)
struct GzGameState_GetPlayerStates final
{
public:
	TArray<class AGzPlayerState*>                 PlayerStates;                                      // 0x0000(0x0010)(Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzGameState_GetPlayerStates) == 0x000008, "Wrong alignment on GzGameState_GetPlayerStates");
static_assert(sizeof(GzGameState_GetPlayerStates) == 0x000010, "Wrong size on GzGameState_GetPlayerStates");
static_assert(offsetof(GzGameState_GetPlayerStates, PlayerStates) == 0x000000, "Member 'GzGameState_GetPlayerStates::PlayerStates' has a wrong offset!");

// Function G01.GzGameState.HasMatchEndResult
// 0x0001 (0x0001 - 0x0000)
struct GzGameState_HasMatchEndResult final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzGameState_HasMatchEndResult) == 0x000001, "Wrong alignment on GzGameState_HasMatchEndResult");
static_assert(sizeof(GzGameState_HasMatchEndResult) == 0x000001, "Wrong size on GzGameState_HasMatchEndResult");
static_assert(offsetof(GzGameState_HasMatchEndResult, ReturnValue) == 0x000000, "Member 'GzGameState_HasMatchEndResult::ReturnValue' has a wrong offset!");

// Function G01.GzGameState.IsGameRuleEnabled
// 0x000C (0x000C - 0x0000)
struct GzGameState_IsGameRuleEnabled final
{
public:
	struct FGameplayTag                           Rule;                                              // 0x0000(0x0008)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2ECA[0x3];                                     // 0x0009(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GzGameState_IsGameRuleEnabled) == 0x000004, "Wrong alignment on GzGameState_IsGameRuleEnabled");
static_assert(sizeof(GzGameState_IsGameRuleEnabled) == 0x00000C, "Wrong size on GzGameState_IsGameRuleEnabled");
static_assert(offsetof(GzGameState_IsGameRuleEnabled, Rule) == 0x000000, "Member 'GzGameState_IsGameRuleEnabled::Rule' has a wrong offset!");
static_assert(offsetof(GzGameState_IsGameRuleEnabled, ReturnValue) == 0x000008, "Member 'GzGameState_IsGameRuleEnabled::ReturnValue' has a wrong offset!");

// Function G01.GzMTW_Base.InjectTimer
// 0x0008 (0x0008 - 0x0000)
struct GzMTW_Base_InjectTimer final
{
public:
	class UGzMTW_Timer*                           CurrentTimer;                                      // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzMTW_Base_InjectTimer) == 0x000008, "Wrong alignment on GzMTW_Base_InjectTimer");
static_assert(sizeof(GzMTW_Base_InjectTimer) == 0x000008, "Wrong size on GzMTW_Base_InjectTimer");
static_assert(offsetof(GzMTW_Base_InjectTimer, CurrentTimer) == 0x000000, "Member 'GzMTW_Base_InjectTimer::CurrentTimer' has a wrong offset!");

// Function G01.GzMTW_Timer.OnStateChanged_BP
// 0x0001 (0x0001 - 0x0000)
struct GzMTW_Timer_OnStateChanged_BP final
{
public:
	EGzConditionState                             NewState;                                          // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzMTW_Timer_OnStateChanged_BP) == 0x000001, "Wrong alignment on GzMTW_Timer_OnStateChanged_BP");
static_assert(sizeof(GzMTW_Timer_OnStateChanged_BP) == 0x000001, "Wrong size on GzMTW_Timer_OnStateChanged_BP");
static_assert(offsetof(GzMTW_Timer_OnStateChanged_BP, NewState) == 0x000000, "Member 'GzMTW_Timer_OnStateChanged_BP::NewState' has a wrong offset!");

// Function G01.GzMTW_Timer.OnTimerStateChanged
// 0x0001 (0x0001 - 0x0000)
struct GzMTW_Timer_OnTimerStateChanged final
{
public:
	EGzConditionState                             NewState;                                          // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzMTW_Timer_OnTimerStateChanged) == 0x000001, "Wrong alignment on GzMTW_Timer_OnTimerStateChanged");
static_assert(sizeof(GzMTW_Timer_OnTimerStateChanged) == 0x000001, "Wrong size on GzMTW_Timer_OnTimerStateChanged");
static_assert(offsetof(GzMTW_Timer_OnTimerStateChanged, NewState) == 0x000000, "Member 'GzMTW_Timer_OnTimerStateChanged::NewState' has a wrong offset!");

// Function G01.GzMTW_Timer.GetRemainingTime
// 0x0004 (0x0004 - 0x0000)
struct GzMTW_Timer_GetRemainingTime final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzMTW_Timer_GetRemainingTime) == 0x000004, "Wrong alignment on GzMTW_Timer_GetRemainingTime");
static_assert(sizeof(GzMTW_Timer_GetRemainingTime) == 0x000004, "Wrong size on GzMTW_Timer_GetRemainingTime");
static_assert(offsetof(GzMTW_Timer_GetRemainingTime, ReturnValue) == 0x000000, "Member 'GzMTW_Timer_GetRemainingTime::ReturnValue' has a wrong offset!");

// Function G01.GzMTW_Timer.IsInActiveState
// 0x0002 (0x0002 - 0x0000)
struct GzMTW_Timer_IsInActiveState final
{
public:
	EGzConditionState                             State;                                             // 0x0000(0x0001)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0001(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzMTW_Timer_IsInActiveState) == 0x000001, "Wrong alignment on GzMTW_Timer_IsInActiveState");
static_assert(sizeof(GzMTW_Timer_IsInActiveState) == 0x000002, "Wrong size on GzMTW_Timer_IsInActiveState");
static_assert(offsetof(GzMTW_Timer_IsInActiveState, State) == 0x000000, "Member 'GzMTW_Timer_IsInActiveState::State' has a wrong offset!");
static_assert(offsetof(GzMTW_Timer_IsInActiveState, ReturnValue) == 0x000001, "Member 'GzMTW_Timer_IsInActiveState::ReturnValue' has a wrong offset!");

// Function G01.GzAudioAnnouncer.OnAnnouncementEnded
// 0x0018 (0x0018 - 0x0000)
struct GzAudioAnnouncer_OnAnnouncementEnded final
{
public:
	const class AActor*                           Actor;                                             // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAkAudioEvent*                          Event;                                             // 0x0008(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           VoiceLineTag;                                      // 0x0010(0x0008)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzAudioAnnouncer_OnAnnouncementEnded) == 0x000008, "Wrong alignment on GzAudioAnnouncer_OnAnnouncementEnded");
static_assert(sizeof(GzAudioAnnouncer_OnAnnouncementEnded) == 0x000018, "Wrong size on GzAudioAnnouncer_OnAnnouncementEnded");
static_assert(offsetof(GzAudioAnnouncer_OnAnnouncementEnded, Actor) == 0x000000, "Member 'GzAudioAnnouncer_OnAnnouncementEnded::Actor' has a wrong offset!");
static_assert(offsetof(GzAudioAnnouncer_OnAnnouncementEnded, Event) == 0x000008, "Member 'GzAudioAnnouncer_OnAnnouncementEnded::Event' has a wrong offset!");
static_assert(offsetof(GzAudioAnnouncer_OnAnnouncementEnded, VoiceLineTag) == 0x000010, "Member 'GzAudioAnnouncer_OnAnnouncementEnded::VoiceLineTag' has a wrong offset!");

// Function G01.GzAudioAnnouncer.PostAnnouncement
// 0x0020 (0x0020 - 0x0000)
struct GzAudioAnnouncer_PostAnnouncement final
{
public:
	struct FGameplayTag                           VoiceLineTag;                                      // 0x0000(0x0008)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bStarted;                                          // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2ED3[0x3];                                     // 0x0009(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TDelegate<void()>                             AnnouncementEndDelegate;                           // 0x000C(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x001C(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2ED4[0x3];                                     // 0x001D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GzAudioAnnouncer_PostAnnouncement) == 0x000004, "Wrong alignment on GzAudioAnnouncer_PostAnnouncement");
static_assert(sizeof(GzAudioAnnouncer_PostAnnouncement) == 0x000020, "Wrong size on GzAudioAnnouncer_PostAnnouncement");
static_assert(offsetof(GzAudioAnnouncer_PostAnnouncement, VoiceLineTag) == 0x000000, "Member 'GzAudioAnnouncer_PostAnnouncement::VoiceLineTag' has a wrong offset!");
static_assert(offsetof(GzAudioAnnouncer_PostAnnouncement, bStarted) == 0x000008, "Member 'GzAudioAnnouncer_PostAnnouncement::bStarted' has a wrong offset!");
static_assert(offsetof(GzAudioAnnouncer_PostAnnouncement, AnnouncementEndDelegate) == 0x00000C, "Member 'GzAudioAnnouncer_PostAnnouncement::AnnouncementEndDelegate' has a wrong offset!");
static_assert(offsetof(GzAudioAnnouncer_PostAnnouncement, ReturnValue) == 0x00001C, "Member 'GzAudioAnnouncer_PostAnnouncement::ReturnValue' has a wrong offset!");

// Function G01.GzCheatManager.AddConsumable
// 0x0010 (0x0010 - 0x0000)
struct GzCheatManager_AddConsumable final
{
public:
	class FString                                 ItemName;                                          // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzCheatManager_AddConsumable) == 0x000008, "Wrong alignment on GzCheatManager_AddConsumable");
static_assert(sizeof(GzCheatManager_AddConsumable) == 0x000010, "Wrong size on GzCheatManager_AddConsumable");
static_assert(offsetof(GzCheatManager_AddConsumable, ItemName) == 0x000000, "Member 'GzCheatManager_AddConsumable::ItemName' has a wrong offset!");

// Function G01.GzCheatManager.AddCyberLimb
// 0x0010 (0x0010 - 0x0000)
struct GzCheatManager_AddCyberLimb final
{
public:
	class FString                                 CyberLimbName;                                     // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzCheatManager_AddCyberLimb) == 0x000008, "Wrong alignment on GzCheatManager_AddCyberLimb");
static_assert(sizeof(GzCheatManager_AddCyberLimb) == 0x000010, "Wrong size on GzCheatManager_AddCyberLimb");
static_assert(offsetof(GzCheatManager_AddCyberLimb, CyberLimbName) == 0x000000, "Member 'GzCheatManager_AddCyberLimb::CyberLimbName' has a wrong offset!");

// Function G01.GzCheatManager.AddMeNPCTeamFriend
// 0x0004 (0x0004 - 0x0000)
struct GzCheatManager_AddMeNPCTeamFriend final
{
public:
	int32                                         TeamID;                                            // 0x0000(0x0004)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzCheatManager_AddMeNPCTeamFriend) == 0x000004, "Wrong alignment on GzCheatManager_AddMeNPCTeamFriend");
static_assert(sizeof(GzCheatManager_AddMeNPCTeamFriend) == 0x000004, "Wrong size on GzCheatManager_AddMeNPCTeamFriend");
static_assert(offsetof(GzCheatManager_AddMeNPCTeamFriend, TeamID) == 0x000000, "Member 'GzCheatManager_AddMeNPCTeamFriend::TeamID' has a wrong offset!");

// Function G01.GzCheatManager.AddPlayerXp
// 0x0004 (0x0004 - 0x0000)
struct GzCheatManager_AddPlayerXp final
{
public:
	int32                                         Xp;                                                // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzCheatManager_AddPlayerXp) == 0x000004, "Wrong alignment on GzCheatManager_AddPlayerXp");
static_assert(sizeof(GzCheatManager_AddPlayerXp) == 0x000004, "Wrong size on GzCheatManager_AddPlayerXp");
static_assert(offsetof(GzCheatManager_AddPlayerXp, Xp) == 0x000000, "Member 'GzCheatManager_AddPlayerXp::Xp' has a wrong offset!");

// Function G01.GzCheatManager.AddWeapon
// 0x0010 (0x0010 - 0x0000)
struct GzCheatManager_AddWeapon final
{
public:
	class FString                                 WeaponName;                                        // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzCheatManager_AddWeapon) == 0x000008, "Wrong alignment on GzCheatManager_AddWeapon");
static_assert(sizeof(GzCheatManager_AddWeapon) == 0x000010, "Wrong size on GzCheatManager_AddWeapon");
static_assert(offsetof(GzCheatManager_AddWeapon, WeaponName) == 0x000000, "Member 'GzCheatManager_AddWeapon::WeaponName' has a wrong offset!");

// Function G01.GzCheatManager.AddWidget
// 0x0010 (0x0010 - 0x0000)
struct GzCheatManager_AddWidget final
{
public:
	class FString                                 WidgetClassName;                                   // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzCheatManager_AddWidget) == 0x000008, "Wrong alignment on GzCheatManager_AddWidget");
static_assert(sizeof(GzCheatManager_AddWidget) == 0x000010, "Wrong size on GzCheatManager_AddWidget");
static_assert(offsetof(GzCheatManager_AddWidget, WidgetClassName) == 0x000000, "Member 'GzCheatManager_AddWidget::WidgetClassName' has a wrong offset!");

// Function G01.GzCheatManager.ChangeTeam
// 0x0004 (0x0004 - 0x0000)
struct GzCheatManager_ChangeTeam final
{
public:
	int32                                         NewTeamIndex;                                      // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzCheatManager_ChangeTeam) == 0x000004, "Wrong alignment on GzCheatManager_ChangeTeam");
static_assert(sizeof(GzCheatManager_ChangeTeam) == 0x000004, "Wrong size on GzCheatManager_ChangeTeam");
static_assert(offsetof(GzCheatManager_ChangeTeam, NewTeamIndex) == 0x000000, "Member 'GzCheatManager_ChangeTeam::NewTeamIndex' has a wrong offset!");

// Function G01.GzCheatManager.DebugGetHit
// 0x0040 (0x0040 - 0x0000)
struct GzCheatManager_DebugGetHit final
{
public:
	float                                         DamageAmount;                                      // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2ED7[0x4];                                     // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                TraceStartOffset;                                  // 0x0008(0x0018)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                TraceEndOffset;                                    // 0x0020(0x0018)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bVisualizeTrace;                                   // 0x0038(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2ED8[0x7];                                     // 0x0039(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GzCheatManager_DebugGetHit) == 0x000008, "Wrong alignment on GzCheatManager_DebugGetHit");
static_assert(sizeof(GzCheatManager_DebugGetHit) == 0x000040, "Wrong size on GzCheatManager_DebugGetHit");
static_assert(offsetof(GzCheatManager_DebugGetHit, DamageAmount) == 0x000000, "Member 'GzCheatManager_DebugGetHit::DamageAmount' has a wrong offset!");
static_assert(offsetof(GzCheatManager_DebugGetHit, TraceStartOffset) == 0x000008, "Member 'GzCheatManager_DebugGetHit::TraceStartOffset' has a wrong offset!");
static_assert(offsetof(GzCheatManager_DebugGetHit, TraceEndOffset) == 0x000020, "Member 'GzCheatManager_DebugGetHit::TraceEndOffset' has a wrong offset!");
static_assert(offsetof(GzCheatManager_DebugGetHit, bVisualizeTrace) == 0x000038, "Member 'GzCheatManager_DebugGetHit::bVisualizeTrace' has a wrong offset!");

// Function G01.GzCheatManager.DebugGetHitFromTop
// 0x0008 (0x0008 - 0x0000)
struct GzCheatManager_DebugGetHitFromTop final
{
public:
	float                                         DamageAmount;                                      // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bVisualizeTrace;                                   // 0x0004(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2ED9[0x3];                                     // 0x0005(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GzCheatManager_DebugGetHitFromTop) == 0x000004, "Wrong alignment on GzCheatManager_DebugGetHitFromTop");
static_assert(sizeof(GzCheatManager_DebugGetHitFromTop) == 0x000008, "Wrong size on GzCheatManager_DebugGetHitFromTop");
static_assert(offsetof(GzCheatManager_DebugGetHitFromTop, DamageAmount) == 0x000000, "Member 'GzCheatManager_DebugGetHitFromTop::DamageAmount' has a wrong offset!");
static_assert(offsetof(GzCheatManager_DebugGetHitFromTop, bVisualizeTrace) == 0x000004, "Member 'GzCheatManager_DebugGetHitFromTop::bVisualizeTrace' has a wrong offset!");

// Function G01.GzCheatManager.DrawCoversInOrigin
// 0x0004 (0x0004 - 0x0000)
struct GzCheatManager_DrawCoversInOrigin final
{
public:
	float                                         Extent;                                            // 0x0000(0x0004)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzCheatManager_DrawCoversInOrigin) == 0x000004, "Wrong alignment on GzCheatManager_DrawCoversInOrigin");
static_assert(sizeof(GzCheatManager_DrawCoversInOrigin) == 0x000004, "Wrong size on GzCheatManager_DrawCoversInOrigin");
static_assert(offsetof(GzCheatManager_DrawCoversInOrigin, Extent) == 0x000000, "Member 'GzCheatManager_DrawCoversInOrigin::Extent' has a wrong offset!");

// Function G01.GzCheatManager.EnableStall
// 0x0010 (0x0010 - 0x0000)
struct GzCheatManager_EnableStall final
{
public:
	float                                         MinInterval;                                       // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxInterval;                                       // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinStallTime;                                      // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxStallTime;                                      // 0x000C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzCheatManager_EnableStall) == 0x000004, "Wrong alignment on GzCheatManager_EnableStall");
static_assert(sizeof(GzCheatManager_EnableStall) == 0x000010, "Wrong size on GzCheatManager_EnableStall");
static_assert(offsetof(GzCheatManager_EnableStall, MinInterval) == 0x000000, "Member 'GzCheatManager_EnableStall::MinInterval' has a wrong offset!");
static_assert(offsetof(GzCheatManager_EnableStall, MaxInterval) == 0x000004, "Member 'GzCheatManager_EnableStall::MaxInterval' has a wrong offset!");
static_assert(offsetof(GzCheatManager_EnableStall, MinStallTime) == 0x000008, "Member 'GzCheatManager_EnableStall::MinStallTime' has a wrong offset!");
static_assert(offsetof(GzCheatManager_EnableStall, MaxStallTime) == 0x00000C, "Member 'GzCheatManager_EnableStall::MaxStallTime' has a wrong offset!");

// Function G01.GzCheatManager.JoinOnlineMatch
// 0x0010 (0x0010 - 0x0000)
struct GzCheatManager_JoinOnlineMatch final
{
public:
	class FString                                 NetworkAddress;                                    // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzCheatManager_JoinOnlineMatch) == 0x000008, "Wrong alignment on GzCheatManager_JoinOnlineMatch");
static_assert(sizeof(GzCheatManager_JoinOnlineMatch) == 0x000010, "Wrong size on GzCheatManager_JoinOnlineMatch");
static_assert(offsetof(GzCheatManager_JoinOnlineMatch, NetworkAddress) == 0x000000, "Member 'GzCheatManager_JoinOnlineMatch::NetworkAddress' has a wrong offset!");

// Function G01.GzCheatManager.KillNpc
// 0x0010 (0x0010 - 0x0000)
struct GzCheatManager_KillNpc final
{
public:
	class FString                                 Param_Name;                                        // 0x0000(0x0010)(ConstParm, Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzCheatManager_KillNpc) == 0x000008, "Wrong alignment on GzCheatManager_KillNpc");
static_assert(sizeof(GzCheatManager_KillNpc) == 0x000010, "Wrong size on GzCheatManager_KillNpc");
static_assert(offsetof(GzCheatManager_KillNpc, Param_Name) == 0x000000, "Member 'GzCheatManager_KillNpc::Param_Name' has a wrong offset!");

// Function G01.GzCheatManager.RemoveMeNPCTeamFriend
// 0x0004 (0x0004 - 0x0000)
struct GzCheatManager_RemoveMeNPCTeamFriend final
{
public:
	int32                                         TeamID;                                            // 0x0000(0x0004)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzCheatManager_RemoveMeNPCTeamFriend) == 0x000004, "Wrong alignment on GzCheatManager_RemoveMeNPCTeamFriend");
static_assert(sizeof(GzCheatManager_RemoveMeNPCTeamFriend) == 0x000004, "Wrong size on GzCheatManager_RemoveMeNPCTeamFriend");
static_assert(offsetof(GzCheatManager_RemoveMeNPCTeamFriend, TeamID) == 0x000000, "Member 'GzCheatManager_RemoveMeNPCTeamFriend::TeamID' has a wrong offset!");

// Function G01.GzCheatManager.RepeatInteract
// 0x0004 (0x0004 - 0x0000)
struct GzCheatManager_RepeatInteract final
{
public:
	int32                                         RepeatCount;                                       // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzCheatManager_RepeatInteract) == 0x000004, "Wrong alignment on GzCheatManager_RepeatInteract");
static_assert(sizeof(GzCheatManager_RepeatInteract) == 0x000004, "Wrong size on GzCheatManager_RepeatInteract");
static_assert(offsetof(GzCheatManager_RepeatInteract, RepeatCount) == 0x000000, "Member 'GzCheatManager_RepeatInteract::RepeatCount' has a wrong offset!");

// Function G01.GzCheatManager.SetAICoversDebug
// 0x0008 (0x0008 - 0x0000)
struct GzCheatManager_SetAICoversDebug final
{
public:
	bool                                          bEnabled;                                          // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2EDA[0x3];                                     // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Radius;                                            // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzCheatManager_SetAICoversDebug) == 0x000004, "Wrong alignment on GzCheatManager_SetAICoversDebug");
static_assert(sizeof(GzCheatManager_SetAICoversDebug) == 0x000008, "Wrong size on GzCheatManager_SetAICoversDebug");
static_assert(offsetof(GzCheatManager_SetAICoversDebug, bEnabled) == 0x000000, "Member 'GzCheatManager_SetAICoversDebug::bEnabled' has a wrong offset!");
static_assert(offsetof(GzCheatManager_SetAICoversDebug, Radius) == 0x000004, "Member 'GzCheatManager_SetAICoversDebug::Radius' has a wrong offset!");

// Function G01.GzCheatManager.SetAILODsEnabled
// 0x0001 (0x0001 - 0x0000)
struct GzCheatManager_SetAILODsEnabled final
{
public:
	bool                                          bEnabled;                                          // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzCheatManager_SetAILODsEnabled) == 0x000001, "Wrong alignment on GzCheatManager_SetAILODsEnabled");
static_assert(sizeof(GzCheatManager_SetAILODsEnabled) == 0x000001, "Wrong size on GzCheatManager_SetAILODsEnabled");
static_assert(offsetof(GzCheatManager_SetAILODsEnabled, bEnabled) == 0x000000, "Member 'GzCheatManager_SetAILODsEnabled::bEnabled' has a wrong offset!");

// Function G01.GzCheatManager.SetBotFarmMode
// 0x0001 (0x0001 - 0x0000)
struct GzCheatManager_SetBotFarmMode final
{
public:
	bool                                          bEnable;                                           // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzCheatManager_SetBotFarmMode) == 0x000001, "Wrong alignment on GzCheatManager_SetBotFarmMode");
static_assert(sizeof(GzCheatManager_SetBotFarmMode) == 0x000001, "Wrong size on GzCheatManager_SetBotFarmMode");
static_assert(offsetof(GzCheatManager_SetBotFarmMode, bEnable) == 0x000000, "Member 'GzCheatManager_SetBotFarmMode::bEnable' has a wrong offset!");

// Function G01.GzCheatManager.SetDataLayerPreset
// 0x0008 (0x0008 - 0x0000)
struct GzCheatManager_SetDataLayerPreset final
{
public:
	class FName                                   PresetName;                                        // 0x0000(0x0008)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzCheatManager_SetDataLayerPreset) == 0x000004, "Wrong alignment on GzCheatManager_SetDataLayerPreset");
static_assert(sizeof(GzCheatManager_SetDataLayerPreset) == 0x000008, "Wrong size on GzCheatManager_SetDataLayerPreset");
static_assert(offsetof(GzCheatManager_SetDataLayerPreset, PresetName) == 0x000000, "Member 'GzCheatManager_SetDataLayerPreset::PresetName' has a wrong offset!");

// Function G01.GzCheatManager.SetDebugFreeCam
// 0x0001 (0x0001 - 0x0000)
struct GzCheatManager_SetDebugFreeCam final
{
public:
	bool                                          bEnable;                                           // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzCheatManager_SetDebugFreeCam) == 0x000001, "Wrong alignment on GzCheatManager_SetDebugFreeCam");
static_assert(sizeof(GzCheatManager_SetDebugFreeCam) == 0x000001, "Wrong size on GzCheatManager_SetDebugFreeCam");
static_assert(offsetof(GzCheatManager_SetDebugFreeCam, bEnable) == 0x000000, "Member 'GzCheatManager_SetDebugFreeCam::bEnable' has a wrong offset!");

// Function G01.GzCheatManager.SetGzCheatsEnabled
// 0x0001 (0x0001 - 0x0000)
struct GzCheatManager_SetGzCheatsEnabled final
{
public:
	bool                                          bEnabled;                                          // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzCheatManager_SetGzCheatsEnabled) == 0x000001, "Wrong alignment on GzCheatManager_SetGzCheatsEnabled");
static_assert(sizeof(GzCheatManager_SetGzCheatsEnabled) == 0x000001, "Wrong size on GzCheatManager_SetGzCheatsEnabled");
static_assert(offsetof(GzCheatManager_SetGzCheatsEnabled, bEnabled) == 0x000000, "Member 'GzCheatManager_SetGzCheatsEnabled::bEnabled' has a wrong offset!");

// Function G01.GzCheatManager.SetJetpackHealth
// 0x0004 (0x0004 - 0x0000)
struct GzCheatManager_SetJetpackHealth final
{
public:
	float                                         Health;                                            // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzCheatManager_SetJetpackHealth) == 0x000004, "Wrong alignment on GzCheatManager_SetJetpackHealth");
static_assert(sizeof(GzCheatManager_SetJetpackHealth) == 0x000004, "Wrong size on GzCheatManager_SetJetpackHealth");
static_assert(offsetof(GzCheatManager_SetJetpackHealth, Health) == 0x000000, "Member 'GzCheatManager_SetJetpackHealth::Health' has a wrong offset!");

// Function G01.GzCheatManager.SetMaxNPCDeathMatchMode
// 0x0004 (0x0004 - 0x0000)
struct GzCheatManager_SetMaxNPCDeathMatchMode final
{
public:
	int32                                         Count;                                             // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzCheatManager_SetMaxNPCDeathMatchMode) == 0x000004, "Wrong alignment on GzCheatManager_SetMaxNPCDeathMatchMode");
static_assert(sizeof(GzCheatManager_SetMaxNPCDeathMatchMode) == 0x000004, "Wrong size on GzCheatManager_SetMaxNPCDeathMatchMode");
static_assert(offsetof(GzCheatManager_SetMaxNPCDeathMatchMode, Count) == 0x000000, "Member 'GzCheatManager_SetMaxNPCDeathMatchMode::Count' has a wrong offset!");

// Function G01.GzCheatManager.SetMovementSpeed
// 0x0004 (0x0004 - 0x0000)
struct GzCheatManager_SetMovementSpeed final
{
public:
	float                                         Value;                                             // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzCheatManager_SetMovementSpeed) == 0x000004, "Wrong alignment on GzCheatManager_SetMovementSpeed");
static_assert(sizeof(GzCheatManager_SetMovementSpeed) == 0x000004, "Wrong size on GzCheatManager_SetMovementSpeed");
static_assert(offsetof(GzCheatManager_SetMovementSpeed, Value) == 0x000000, "Member 'GzCheatManager_SetMovementSpeed::Value' has a wrong offset!");

// Function G01.GzCheatManager.SetQuitGameTime
// 0x0004 (0x0004 - 0x0000)
struct GzCheatManager_SetQuitGameTime final
{
public:
	float                                         Value;                                             // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzCheatManager_SetQuitGameTime) == 0x000004, "Wrong alignment on GzCheatManager_SetQuitGameTime");
static_assert(sizeof(GzCheatManager_SetQuitGameTime) == 0x000004, "Wrong size on GzCheatManager_SetQuitGameTime");
static_assert(offsetof(GzCheatManager_SetQuitGameTime, Value) == 0x000000, "Member 'GzCheatManager_SetQuitGameTime::Value' has a wrong offset!");

// Function G01.GzCheatManager.SetReadyToStart
// 0x0001 (0x0001 - 0x0000)
struct GzCheatManager_SetReadyToStart final
{
public:
	bool                                          bReadyToStart;                                     // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzCheatManager_SetReadyToStart) == 0x000001, "Wrong alignment on GzCheatManager_SetReadyToStart");
static_assert(sizeof(GzCheatManager_SetReadyToStart) == 0x000001, "Wrong size on GzCheatManager_SetReadyToStart");
static_assert(offsetof(GzCheatManager_SetReadyToStart, bReadyToStart) == 0x000000, "Member 'GzCheatManager_SetReadyToStart::bReadyToStart' has a wrong offset!");

// Function G01.GzCheatManager.SetRespawnInMatch
// 0x0002 (0x0002 - 0x0000)
struct GzCheatManager_SetRespawnInMatch final
{
public:
	bool                                          bRespawnPlayers;                                   // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bRespawnAfterZoneActivation;                       // 0x0001(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzCheatManager_SetRespawnInMatch) == 0x000001, "Wrong alignment on GzCheatManager_SetRespawnInMatch");
static_assert(sizeof(GzCheatManager_SetRespawnInMatch) == 0x000002, "Wrong size on GzCheatManager_SetRespawnInMatch");
static_assert(offsetof(GzCheatManager_SetRespawnInMatch, bRespawnPlayers) == 0x000000, "Member 'GzCheatManager_SetRespawnInMatch::bRespawnPlayers' has a wrong offset!");
static_assert(offsetof(GzCheatManager_SetRespawnInMatch, bRespawnAfterZoneActivation) == 0x000001, "Member 'GzCheatManager_SetRespawnInMatch::bRespawnAfterZoneActivation' has a wrong offset!");

// Function G01.GzCheatManager.SetRTPCValue
// 0x0018 (0x0018 - 0x0000)
struct GzCheatManager_SetRTPCValue final
{
public:
	class FString                                 RTPC;                                              // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         NewValue;                                          // 0x0010(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2EDB[0x4];                                     // 0x0014(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GzCheatManager_SetRTPCValue) == 0x000008, "Wrong alignment on GzCheatManager_SetRTPCValue");
static_assert(sizeof(GzCheatManager_SetRTPCValue) == 0x000018, "Wrong size on GzCheatManager_SetRTPCValue");
static_assert(offsetof(GzCheatManager_SetRTPCValue, RTPC) == 0x000000, "Member 'GzCheatManager_SetRTPCValue::RTPC' has a wrong offset!");
static_assert(offsetof(GzCheatManager_SetRTPCValue, NewValue) == 0x000010, "Member 'GzCheatManager_SetRTPCValue::NewValue' has a wrong offset!");

// Function G01.GzCheatManager.SetServerFPSAccTime
// 0x0004 (0x0004 - 0x0000)
struct GzCheatManager_SetServerFPSAccTime final
{
public:
	float                                         FPSAccTime;                                        // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzCheatManager_SetServerFPSAccTime) == 0x000004, "Wrong alignment on GzCheatManager_SetServerFPSAccTime");
static_assert(sizeof(GzCheatManager_SetServerFPSAccTime) == 0x000004, "Wrong size on GzCheatManager_SetServerFPSAccTime");
static_assert(offsetof(GzCheatManager_SetServerFPSAccTime, FPSAccTime) == 0x000000, "Member 'GzCheatManager_SetServerFPSAccTime::FPSAccTime' has a wrong offset!");

// Function G01.GzCheatManager.SetTargetFpsClient
// 0x0004 (0x0004 - 0x0000)
struct GzCheatManager_SetTargetFpsClient final
{
public:
	float                                         TargetFps;                                         // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzCheatManager_SetTargetFpsClient) == 0x000004, "Wrong alignment on GzCheatManager_SetTargetFpsClient");
static_assert(sizeof(GzCheatManager_SetTargetFpsClient) == 0x000004, "Wrong size on GzCheatManager_SetTargetFpsClient");
static_assert(offsetof(GzCheatManager_SetTargetFpsClient, TargetFps) == 0x000000, "Member 'GzCheatManager_SetTargetFpsClient::TargetFps' has a wrong offset!");

// Function G01.GzCheatManager.SetTargetFpsServer
// 0x0004 (0x0004 - 0x0000)
struct GzCheatManager_SetTargetFpsServer final
{
public:
	float                                         TargetFps;                                         // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzCheatManager_SetTargetFpsServer) == 0x000004, "Wrong alignment on GzCheatManager_SetTargetFpsServer");
static_assert(sizeof(GzCheatManager_SetTargetFpsServer) == 0x000004, "Wrong size on GzCheatManager_SetTargetFpsServer");
static_assert(offsetof(GzCheatManager_SetTargetFpsServer, TargetFps) == 0x000000, "Member 'GzCheatManager_SetTargetFpsServer::TargetFps' has a wrong offset!");

// Function G01.GzCheatManager.SetTeamChangeUnlocked
// 0x0001 (0x0001 - 0x0000)
struct GzCheatManager_SetTeamChangeUnlocked final
{
public:
	bool                                          bUnlocked;                                         // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzCheatManager_SetTeamChangeUnlocked) == 0x000001, "Wrong alignment on GzCheatManager_SetTeamChangeUnlocked");
static_assert(sizeof(GzCheatManager_SetTeamChangeUnlocked) == 0x000001, "Wrong size on GzCheatManager_SetTeamChangeUnlocked");
static_assert(offsetof(GzCheatManager_SetTeamChangeUnlocked, bUnlocked) == 0x000000, "Member 'GzCheatManager_SetTeamChangeUnlocked::bUnlocked' has a wrong offset!");

// Function G01.GzCheatManager.SetVoiceState
// 0x0001 (0x0001 - 0x0000)
struct GzCheatManager_SetVoiceState final
{
public:
	bool                                          Value;                                             // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzCheatManager_SetVoiceState) == 0x000001, "Wrong alignment on GzCheatManager_SetVoiceState");
static_assert(sizeof(GzCheatManager_SetVoiceState) == 0x000001, "Wrong size on GzCheatManager_SetVoiceState");
static_assert(offsetof(GzCheatManager_SetVoiceState, Value) == 0x000000, "Member 'GzCheatManager_SetVoiceState::Value' has a wrong offset!");

// Function G01.GzCheatManager.ShowAICharacterOutline
// 0x0001 (0x0001 - 0x0000)
struct GzCheatManager_ShowAICharacterOutline final
{
public:
	uint8                                         InValue;                                           // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzCheatManager_ShowAICharacterOutline) == 0x000001, "Wrong alignment on GzCheatManager_ShowAICharacterOutline");
static_assert(sizeof(GzCheatManager_ShowAICharacterOutline) == 0x000001, "Wrong size on GzCheatManager_ShowAICharacterOutline");
static_assert(offsetof(GzCheatManager_ShowAICharacterOutline, InValue) == 0x000000, "Member 'GzCheatManager_ShowAICharacterOutline::InValue' has a wrong offset!");

// Function G01.GzCheatManager.ShowGameNotification
// 0x0008 (0x0008 - 0x0000)
struct GzCheatManager_ShowGameNotification final
{
public:
	class FName                                   TestNotificationID;                                // 0x0000(0x0008)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzCheatManager_ShowGameNotification) == 0x000004, "Wrong alignment on GzCheatManager_ShowGameNotification");
static_assert(sizeof(GzCheatManager_ShowGameNotification) == 0x000008, "Wrong size on GzCheatManager_ShowGameNotification");
static_assert(offsetof(GzCheatManager_ShowGameNotification, TestNotificationID) == 0x000000, "Member 'GzCheatManager_ShowGameNotification::TestNotificationID' has a wrong offset!");

// Function G01.GzCheatManager.ShowPlayerNames
// 0x0001 (0x0001 - 0x0000)
struct GzCheatManager_ShowPlayerNames final
{
public:
	bool                                          bShow;                                             // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzCheatManager_ShowPlayerNames) == 0x000001, "Wrong alignment on GzCheatManager_ShowPlayerNames");
static_assert(sizeof(GzCheatManager_ShowPlayerNames) == 0x000001, "Wrong size on GzCheatManager_ShowPlayerNames");
static_assert(offsetof(GzCheatManager_ShowPlayerNames, bShow) == 0x000000, "Member 'GzCheatManager_ShowPlayerNames::bShow' has a wrong offset!");

// Function G01.GzCheatManager.SimulateKeyAxis
// 0x0020 (0x0020 - 0x0000)
struct GzCheatManager_SimulateKeyAxis final
{
public:
	struct FKey                                   Key;                                               // 0x0000(0x0018)(Parm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Delta;                                             // 0x0018(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2EDC[0x4];                                     // 0x001C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GzCheatManager_SimulateKeyAxis) == 0x000008, "Wrong alignment on GzCheatManager_SimulateKeyAxis");
static_assert(sizeof(GzCheatManager_SimulateKeyAxis) == 0x000020, "Wrong size on GzCheatManager_SimulateKeyAxis");
static_assert(offsetof(GzCheatManager_SimulateKeyAxis, Key) == 0x000000, "Member 'GzCheatManager_SimulateKeyAxis::Key' has a wrong offset!");
static_assert(offsetof(GzCheatManager_SimulateKeyAxis, Delta) == 0x000018, "Member 'GzCheatManager_SimulateKeyAxis::Delta' has a wrong offset!");

// Function G01.GzCheatManager.SimulateKeyPressed
// 0x0018 (0x0018 - 0x0000)
struct GzCheatManager_SimulateKeyPressed final
{
public:
	struct FKey                                   Key;                                               // 0x0000(0x0018)(Parm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzCheatManager_SimulateKeyPressed) == 0x000008, "Wrong alignment on GzCheatManager_SimulateKeyPressed");
static_assert(sizeof(GzCheatManager_SimulateKeyPressed) == 0x000018, "Wrong size on GzCheatManager_SimulateKeyPressed");
static_assert(offsetof(GzCheatManager_SimulateKeyPressed, Key) == 0x000000, "Member 'GzCheatManager_SimulateKeyPressed::Key' has a wrong offset!");

// Function G01.GzCheatManager.SimulateKeyPressedAndReleased
// 0x0020 (0x0020 - 0x0000)
struct GzCheatManager_SimulateKeyPressedAndReleased final
{
public:
	struct FKey                                   Key;                                               // 0x0000(0x0018)(Parm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Delay;                                             // 0x0018(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2EDD[0x4];                                     // 0x001C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GzCheatManager_SimulateKeyPressedAndReleased) == 0x000008, "Wrong alignment on GzCheatManager_SimulateKeyPressedAndReleased");
static_assert(sizeof(GzCheatManager_SimulateKeyPressedAndReleased) == 0x000020, "Wrong size on GzCheatManager_SimulateKeyPressedAndReleased");
static_assert(offsetof(GzCheatManager_SimulateKeyPressedAndReleased, Key) == 0x000000, "Member 'GzCheatManager_SimulateKeyPressedAndReleased::Key' has a wrong offset!");
static_assert(offsetof(GzCheatManager_SimulateKeyPressedAndReleased, Delay) == 0x000018, "Member 'GzCheatManager_SimulateKeyPressedAndReleased::Delay' has a wrong offset!");

// Function G01.GzCheatManager.SimulateKeyReleased
// 0x0018 (0x0018 - 0x0000)
struct GzCheatManager_SimulateKeyReleased final
{
public:
	struct FKey                                   Key;                                               // 0x0000(0x0018)(Parm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzCheatManager_SimulateKeyReleased) == 0x000008, "Wrong alignment on GzCheatManager_SimulateKeyReleased");
static_assert(sizeof(GzCheatManager_SimulateKeyReleased) == 0x000018, "Wrong size on GzCheatManager_SimulateKeyReleased");
static_assert(offsetof(GzCheatManager_SimulateKeyReleased, Key) == 0x000000, "Member 'GzCheatManager_SimulateKeyReleased::Key' has a wrong offset!");

// Function G01.GzCheatManager.SpawnAI
// 0x0018 (0x0018 - 0x0000)
struct GzCheatManager_SpawnAI final
{
public:
	class FString                                 Param_Name;                                        // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         TeamID;                                            // 0x0010(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Count;                                             // 0x0014(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzCheatManager_SpawnAI) == 0x000008, "Wrong alignment on GzCheatManager_SpawnAI");
static_assert(sizeof(GzCheatManager_SpawnAI) == 0x000018, "Wrong size on GzCheatManager_SpawnAI");
static_assert(offsetof(GzCheatManager_SpawnAI, Param_Name) == 0x000000, "Member 'GzCheatManager_SpawnAI::Param_Name' has a wrong offset!");
static_assert(offsetof(GzCheatManager_SpawnAI, TeamID) == 0x000010, "Member 'GzCheatManager_SpawnAI::TeamID' has a wrong offset!");
static_assert(offsetof(GzCheatManager_SpawnAI, Count) == 0x000014, "Member 'GzCheatManager_SpawnAI::Count' has a wrong offset!");

// Function G01.GzCheatManager.SpawnNPC
// 0x0010 (0x0010 - 0x0000)
struct GzCheatManager_SpawnNPC final
{
public:
	int32                                         Count;                                             // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Radius;                                            // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         TeamID;                                            // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaxTeamSize;                                       // 0x000C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzCheatManager_SpawnNPC) == 0x000004, "Wrong alignment on GzCheatManager_SpawnNPC");
static_assert(sizeof(GzCheatManager_SpawnNPC) == 0x000010, "Wrong size on GzCheatManager_SpawnNPC");
static_assert(offsetof(GzCheatManager_SpawnNPC, Count) == 0x000000, "Member 'GzCheatManager_SpawnNPC::Count' has a wrong offset!");
static_assert(offsetof(GzCheatManager_SpawnNPC, Radius) == 0x000004, "Member 'GzCheatManager_SpawnNPC::Radius' has a wrong offset!");
static_assert(offsetof(GzCheatManager_SpawnNPC, TeamID) == 0x000008, "Member 'GzCheatManager_SpawnNPC::TeamID' has a wrong offset!");
static_assert(offsetof(GzCheatManager_SpawnNPC, MaxTeamSize) == 0x00000C, "Member 'GzCheatManager_SpawnNPC::MaxTeamSize' has a wrong offset!");

// Function G01.GzCheatManager.SweepShape
// 0x0028 (0x0028 - 0x0000)
struct GzCheatManager_SweepShape final
{
public:
	uint8                                         ShapeType;                                         // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2EDE[0x3];                                     // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ShapeRadius;                                       // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ShapeHeight;                                       // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIgnoreCharacter;                                  // 0x000C(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2EDF[0x3];                                     // 0x000D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         StartX;                                            // 0x0010(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         StartY;                                            // 0x0014(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         StartZ;                                            // 0x0018(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         EndX;                                              // 0x001C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         EndY;                                              // 0x0020(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         EndZ;                                              // 0x0024(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzCheatManager_SweepShape) == 0x000004, "Wrong alignment on GzCheatManager_SweepShape");
static_assert(sizeof(GzCheatManager_SweepShape) == 0x000028, "Wrong size on GzCheatManager_SweepShape");
static_assert(offsetof(GzCheatManager_SweepShape, ShapeType) == 0x000000, "Member 'GzCheatManager_SweepShape::ShapeType' has a wrong offset!");
static_assert(offsetof(GzCheatManager_SweepShape, ShapeRadius) == 0x000004, "Member 'GzCheatManager_SweepShape::ShapeRadius' has a wrong offset!");
static_assert(offsetof(GzCheatManager_SweepShape, ShapeHeight) == 0x000008, "Member 'GzCheatManager_SweepShape::ShapeHeight' has a wrong offset!");
static_assert(offsetof(GzCheatManager_SweepShape, bIgnoreCharacter) == 0x00000C, "Member 'GzCheatManager_SweepShape::bIgnoreCharacter' has a wrong offset!");
static_assert(offsetof(GzCheatManager_SweepShape, StartX) == 0x000010, "Member 'GzCheatManager_SweepShape::StartX' has a wrong offset!");
static_assert(offsetof(GzCheatManager_SweepShape, StartY) == 0x000014, "Member 'GzCheatManager_SweepShape::StartY' has a wrong offset!");
static_assert(offsetof(GzCheatManager_SweepShape, StartZ) == 0x000018, "Member 'GzCheatManager_SweepShape::StartZ' has a wrong offset!");
static_assert(offsetof(GzCheatManager_SweepShape, EndX) == 0x00001C, "Member 'GzCheatManager_SweepShape::EndX' has a wrong offset!");
static_assert(offsetof(GzCheatManager_SweepShape, EndY) == 0x000020, "Member 'GzCheatManager_SweepShape::EndY' has a wrong offset!");
static_assert(offsetof(GzCheatManager_SweepShape, EndZ) == 0x000024, "Member 'GzCheatManager_SweepShape::EndZ' has a wrong offset!");

// Function G01.GzCheatManager.SweepShapeByDelta
// 0x0028 (0x0028 - 0x0000)
struct GzCheatManager_SweepShapeByDelta final
{
public:
	uint8                                         ShapeType;                                         // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2EE0[0x3];                                     // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ShapeRadius;                                       // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ShapeHeight;                                       // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIgnoreCharacter;                                  // 0x000C(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2EE1[0x3];                                     // 0x000D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         StartX;                                            // 0x0010(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         StartY;                                            // 0x0014(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         StartZ;                                            // 0x0018(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DeltaX;                                            // 0x001C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DeltaY;                                            // 0x0020(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DeltaZ;                                            // 0x0024(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzCheatManager_SweepShapeByDelta) == 0x000004, "Wrong alignment on GzCheatManager_SweepShapeByDelta");
static_assert(sizeof(GzCheatManager_SweepShapeByDelta) == 0x000028, "Wrong size on GzCheatManager_SweepShapeByDelta");
static_assert(offsetof(GzCheatManager_SweepShapeByDelta, ShapeType) == 0x000000, "Member 'GzCheatManager_SweepShapeByDelta::ShapeType' has a wrong offset!");
static_assert(offsetof(GzCheatManager_SweepShapeByDelta, ShapeRadius) == 0x000004, "Member 'GzCheatManager_SweepShapeByDelta::ShapeRadius' has a wrong offset!");
static_assert(offsetof(GzCheatManager_SweepShapeByDelta, ShapeHeight) == 0x000008, "Member 'GzCheatManager_SweepShapeByDelta::ShapeHeight' has a wrong offset!");
static_assert(offsetof(GzCheatManager_SweepShapeByDelta, bIgnoreCharacter) == 0x00000C, "Member 'GzCheatManager_SweepShapeByDelta::bIgnoreCharacter' has a wrong offset!");
static_assert(offsetof(GzCheatManager_SweepShapeByDelta, StartX) == 0x000010, "Member 'GzCheatManager_SweepShapeByDelta::StartX' has a wrong offset!");
static_assert(offsetof(GzCheatManager_SweepShapeByDelta, StartY) == 0x000014, "Member 'GzCheatManager_SweepShapeByDelta::StartY' has a wrong offset!");
static_assert(offsetof(GzCheatManager_SweepShapeByDelta, StartZ) == 0x000018, "Member 'GzCheatManager_SweepShapeByDelta::StartZ' has a wrong offset!");
static_assert(offsetof(GzCheatManager_SweepShapeByDelta, DeltaX) == 0x00001C, "Member 'GzCheatManager_SweepShapeByDelta::DeltaX' has a wrong offset!");
static_assert(offsetof(GzCheatManager_SweepShapeByDelta, DeltaY) == 0x000020, "Member 'GzCheatManager_SweepShapeByDelta::DeltaY' has a wrong offset!");
static_assert(offsetof(GzCheatManager_SweepShapeByDelta, DeltaZ) == 0x000024, "Member 'GzCheatManager_SweepShapeByDelta::DeltaZ' has a wrong offset!");

// Function G01.GzCheatManager.TearOffLimb
// 0x0018 (0x0018 - 0x0000)
struct GzCheatManager_TearOffLimb final
{
public:
	class FString                                 Param_Name;                                        // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bForced;                                           // 0x0010(0x0001)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2EE2[0x7];                                     // 0x0011(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GzCheatManager_TearOffLimb) == 0x000008, "Wrong alignment on GzCheatManager_TearOffLimb");
static_assert(sizeof(GzCheatManager_TearOffLimb) == 0x000018, "Wrong size on GzCheatManager_TearOffLimb");
static_assert(offsetof(GzCheatManager_TearOffLimb, Param_Name) == 0x000000, "Member 'GzCheatManager_TearOffLimb::Param_Name' has a wrong offset!");
static_assert(offsetof(GzCheatManager_TearOffLimb, bForced) == 0x000010, "Member 'GzCheatManager_TearOffLimb::bForced' has a wrong offset!");

// Function G01.GzCheatManager.TeleportToCoordinates
// 0x000C (0x000C - 0x0000)
struct GzCheatManager_TeleportToCoordinates final
{
public:
	float                                         X;                                                 // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Y;                                                 // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Z;                                                 // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzCheatManager_TeleportToCoordinates) == 0x000004, "Wrong alignment on GzCheatManager_TeleportToCoordinates");
static_assert(sizeof(GzCheatManager_TeleportToCoordinates) == 0x00000C, "Wrong size on GzCheatManager_TeleportToCoordinates");
static_assert(offsetof(GzCheatManager_TeleportToCoordinates, X) == 0x000000, "Member 'GzCheatManager_TeleportToCoordinates::X' has a wrong offset!");
static_assert(offsetof(GzCheatManager_TeleportToCoordinates, Y) == 0x000004, "Member 'GzCheatManager_TeleportToCoordinates::Y' has a wrong offset!");
static_assert(offsetof(GzCheatManager_TeleportToCoordinates, Z) == 0x000008, "Member 'GzCheatManager_TeleportToCoordinates::Z' has a wrong offset!");

// Function G01.GzCheatManager.ZoomDebugFreeCamAction
// 0x0020 (0x0020 - 0x0000)
struct GzCheatManager_ZoomDebugFreeCamAction final
{
public:
	struct FInputActionValue                      Instance;                                          // 0x0000(0x0020)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzCheatManager_ZoomDebugFreeCamAction) == 0x000008, "Wrong alignment on GzCheatManager_ZoomDebugFreeCamAction");
static_assert(sizeof(GzCheatManager_ZoomDebugFreeCamAction) == 0x000020, "Wrong size on GzCheatManager_ZoomDebugFreeCamAction");
static_assert(offsetof(GzCheatManager_ZoomDebugFreeCamAction, Instance) == 0x000000, "Member 'GzCheatManager_ZoomDebugFreeCamAction::Instance' has a wrong offset!");

// Function G01.GzCheatManager.AddBlockchainCoins
// 0x0008 (0x0008 - 0x0000)
struct GzCheatManager_AddBlockchainCoins final
{
public:
	double                                        CurrencyAmount;                                    // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzCheatManager_AddBlockchainCoins) == 0x000008, "Wrong alignment on GzCheatManager_AddBlockchainCoins");
static_assert(sizeof(GzCheatManager_AddBlockchainCoins) == 0x000008, "Wrong size on GzCheatManager_AddBlockchainCoins");
static_assert(offsetof(GzCheatManager_AddBlockchainCoins, CurrencyAmount) == 0x000000, "Member 'GzCheatManager_AddBlockchainCoins::CurrencyAmount' has a wrong offset!");

// Function G01.GzCheatManager.EnterOfflineSession
// 0x0010 (0x0010 - 0x0000)
struct GzCheatManager_EnterOfflineSession final
{
public:
	class FString                                 LevelName;                                         // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzCheatManager_EnterOfflineSession) == 0x000008, "Wrong alignment on GzCheatManager_EnterOfflineSession");
static_assert(sizeof(GzCheatManager_EnterOfflineSession) == 0x000010, "Wrong size on GzCheatManager_EnterOfflineSession");
static_assert(offsetof(GzCheatManager_EnterOfflineSession, LevelName) == 0x000000, "Member 'GzCheatManager_EnterOfflineSession::LevelName' has a wrong offset!");

// Function G01.GzCheatManager.PostVoiceLine
// 0x0010 (0x0010 - 0x0000)
struct GzCheatManager_PostVoiceLine final
{
public:
	class FString                                 EventName;                                         // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzCheatManager_PostVoiceLine) == 0x000008, "Wrong alignment on GzCheatManager_PostVoiceLine");
static_assert(sizeof(GzCheatManager_PostVoiceLine) == 0x000010, "Wrong size on GzCheatManager_PostVoiceLine");
static_assert(offsetof(GzCheatManager_PostVoiceLine, EventName) == 0x000000, "Member 'GzCheatManager_PostVoiceLine::EventName' has a wrong offset!");

// Function G01.GzCheatManager.SetLeglessState
// 0x0001 (0x0001 - 0x0000)
struct GzCheatManager_SetLeglessState final
{
public:
	bool                                          bEnable;                                           // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzCheatManager_SetLeglessState) == 0x000001, "Wrong alignment on GzCheatManager_SetLeglessState");
static_assert(sizeof(GzCheatManager_SetLeglessState) == 0x000001, "Wrong size on GzCheatManager_SetLeglessState");
static_assert(offsetof(GzCheatManager_SetLeglessState, bEnable) == 0x000000, "Member 'GzCheatManager_SetLeglessState::bEnable' has a wrong offset!");

// Function G01.GzCheatManager.SetQuickOrderCooldown
// 0x0004 (0x0004 - 0x0000)
struct GzCheatManager_SetQuickOrderCooldown final
{
public:
	float                                         Time;                                              // 0x0000(0x0004)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzCheatManager_SetQuickOrderCooldown) == 0x000004, "Wrong alignment on GzCheatManager_SetQuickOrderCooldown");
static_assert(sizeof(GzCheatManager_SetQuickOrderCooldown) == 0x000004, "Wrong size on GzCheatManager_SetQuickOrderCooldown");
static_assert(offsetof(GzCheatManager_SetQuickOrderCooldown, Time) == 0x000000, "Member 'GzCheatManager_SetQuickOrderCooldown::Time' has a wrong offset!");

// Function G01.GzCheatManager.SetRespawnCheatUnlocked
// 0x0001 (0x0001 - 0x0000)
struct GzCheatManager_SetRespawnCheatUnlocked final
{
public:
	bool                                          bUnlocked;                                         // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzCheatManager_SetRespawnCheatUnlocked) == 0x000001, "Wrong alignment on GzCheatManager_SetRespawnCheatUnlocked");
static_assert(sizeof(GzCheatManager_SetRespawnCheatUnlocked) == 0x000001, "Wrong size on GzCheatManager_SetRespawnCheatUnlocked");
static_assert(offsetof(GzCheatManager_SetRespawnCheatUnlocked, bUnlocked) == 0x000000, "Member 'GzCheatManager_SetRespawnCheatUnlocked::bUnlocked' has a wrong offset!");

// Function G01.GzCheatManager.SetVirtualCurrency
// 0x0008 (0x0008 - 0x0000)
struct GzCheatManager_SetVirtualCurrency final
{
public:
	uint8                                         CurrencyType;                                      // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2EE3[0x3];                                     // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         CurrencyAmount;                                    // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzCheatManager_SetVirtualCurrency) == 0x000004, "Wrong alignment on GzCheatManager_SetVirtualCurrency");
static_assert(sizeof(GzCheatManager_SetVirtualCurrency) == 0x000008, "Wrong size on GzCheatManager_SetVirtualCurrency");
static_assert(offsetof(GzCheatManager_SetVirtualCurrency, CurrencyType) == 0x000000, "Member 'GzCheatManager_SetVirtualCurrency::CurrencyType' has a wrong offset!");
static_assert(offsetof(GzCheatManager_SetVirtualCurrency, CurrencyAmount) == 0x000004, "Member 'GzCheatManager_SetVirtualCurrency::CurrencyAmount' has a wrong offset!");

// Function G01.GzCheatManager.SubtractBlockchainCoins
// 0x0008 (0x0008 - 0x0000)
struct GzCheatManager_SubtractBlockchainCoins final
{
public:
	double                                        CurrencyAmount;                                    // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzCheatManager_SubtractBlockchainCoins) == 0x000008, "Wrong alignment on GzCheatManager_SubtractBlockchainCoins");
static_assert(sizeof(GzCheatManager_SubtractBlockchainCoins) == 0x000008, "Wrong size on GzCheatManager_SubtractBlockchainCoins");
static_assert(offsetof(GzCheatManager_SubtractBlockchainCoins, CurrencyAmount) == 0x000000, "Member 'GzCheatManager_SubtractBlockchainCoins::CurrencyAmount' has a wrong offset!");

// Function G01.GzAudioControllerComponent.GetMissionVoiceLineTag
// 0x0018 (0x0018 - 0x0000)
struct GzAudioControllerComponent_GetMissionVoiceLineTag final
{
public:
	class AGzMission*                             InMission;                                         // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EMissionState                                 MissionState;                                      // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2EE6[0x3];                                     // 0x0009(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTag                           ReturnValue;                                       // 0x000C(0x0008)(Parm, OutParm, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2EE7[0x4];                                     // 0x0014(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GzAudioControllerComponent_GetMissionVoiceLineTag) == 0x000008, "Wrong alignment on GzAudioControllerComponent_GetMissionVoiceLineTag");
static_assert(sizeof(GzAudioControllerComponent_GetMissionVoiceLineTag) == 0x000018, "Wrong size on GzAudioControllerComponent_GetMissionVoiceLineTag");
static_assert(offsetof(GzAudioControllerComponent_GetMissionVoiceLineTag, InMission) == 0x000000, "Member 'GzAudioControllerComponent_GetMissionVoiceLineTag::InMission' has a wrong offset!");
static_assert(offsetof(GzAudioControllerComponent_GetMissionVoiceLineTag, MissionState) == 0x000008, "Member 'GzAudioControllerComponent_GetMissionVoiceLineTag::MissionState' has a wrong offset!");
static_assert(offsetof(GzAudioControllerComponent_GetMissionVoiceLineTag, ReturnValue) == 0x00000C, "Member 'GzAudioControllerComponent_GetMissionVoiceLineTag::ReturnValue' has a wrong offset!");

// Function G01.GzAudioControllerComponent.OnMessageReceived
// 0x0008 (0x0008 - 0x0000)
struct GzAudioControllerComponent_OnMessageReceived final
{
public:
	const class UGzGameMessage*                   Message;                                           // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzAudioControllerComponent_OnMessageReceived) == 0x000008, "Wrong alignment on GzAudioControllerComponent_OnMessageReceived");
static_assert(sizeof(GzAudioControllerComponent_OnMessageReceived) == 0x000008, "Wrong size on GzAudioControllerComponent_OnMessageReceived");
static_assert(offsetof(GzAudioControllerComponent_OnMessageReceived, Message) == 0x000000, "Member 'GzAudioControllerComponent_OnMessageReceived::Message' has a wrong offset!");

// Function G01.GzAudioControllerComponent.OnMissionStateChanged
// 0x0020 (0x0020 - 0x0000)
struct GzAudioControllerComponent_OnMissionStateChanged final
{
public:
	class AGzMission*                             Mission;                                           // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGzMissionState                        OldState;                                          // 0x0008(0x000C)(Parm, NoDestructor, NativeAccessSpecifierPublic)
	struct FGzMissionState                        MissionState;                                      // 0x0014(0x000C)(Parm, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzAudioControllerComponent_OnMissionStateChanged) == 0x000008, "Wrong alignment on GzAudioControllerComponent_OnMissionStateChanged");
static_assert(sizeof(GzAudioControllerComponent_OnMissionStateChanged) == 0x000020, "Wrong size on GzAudioControllerComponent_OnMissionStateChanged");
static_assert(offsetof(GzAudioControllerComponent_OnMissionStateChanged, Mission) == 0x000000, "Member 'GzAudioControllerComponent_OnMissionStateChanged::Mission' has a wrong offset!");
static_assert(offsetof(GzAudioControllerComponent_OnMissionStateChanged, OldState) == 0x000008, "Member 'GzAudioControllerComponent_OnMissionStateChanged::OldState' has a wrong offset!");
static_assert(offsetof(GzAudioControllerComponent_OnMissionStateChanged, MissionState) == 0x000014, "Member 'GzAudioControllerComponent_OnMissionStateChanged::MissionState' has a wrong offset!");

// Function G01.GzAudioControllerComponent.OnPingAdded
// 0x0060 (0x0060 - 0x0000)
struct GzAudioControllerComponent_OnPingAdded final
{
public:
	struct FGzPingData                            PingData;                                          // 0x0000(0x0060)(ConstParm, Parm, OutParm, ReferenceParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzAudioControllerComponent_OnPingAdded) == 0x000008, "Wrong alignment on GzAudioControllerComponent_OnPingAdded");
static_assert(sizeof(GzAudioControllerComponent_OnPingAdded) == 0x000060, "Wrong size on GzAudioControllerComponent_OnPingAdded");
static_assert(offsetof(GzAudioControllerComponent_OnPingAdded, PingData) == 0x000000, "Member 'GzAudioControllerComponent_OnPingAdded::PingData' has a wrong offset!");

// Function G01.GzAudioControllerComponent.OnPingAgreementChanged
// 0x0070 (0x0070 - 0x0000)
struct GzAudioControllerComponent_OnPingAgreementChanged final
{
public:
	class AGzPlayerState*                         PlayerState;                                       // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGzPingData                            PingData;                                          // 0x0008(0x0060)(ConstParm, Parm, OutParm, ReferenceParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAgree;                                            // 0x0068(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2EE8[0x7];                                     // 0x0069(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GzAudioControllerComponent_OnPingAgreementChanged) == 0x000008, "Wrong alignment on GzAudioControllerComponent_OnPingAgreementChanged");
static_assert(sizeof(GzAudioControllerComponent_OnPingAgreementChanged) == 0x000070, "Wrong size on GzAudioControllerComponent_OnPingAgreementChanged");
static_assert(offsetof(GzAudioControllerComponent_OnPingAgreementChanged, PlayerState) == 0x000000, "Member 'GzAudioControllerComponent_OnPingAgreementChanged::PlayerState' has a wrong offset!");
static_assert(offsetof(GzAudioControllerComponent_OnPingAgreementChanged, PingData) == 0x000008, "Member 'GzAudioControllerComponent_OnPingAgreementChanged::PingData' has a wrong offset!");
static_assert(offsetof(GzAudioControllerComponent_OnPingAgreementChanged, bAgree) == 0x000068, "Member 'GzAudioControllerComponent_OnPingAgreementChanged::bAgree' has a wrong offset!");

// Function G01.GzAudioControllerComponent.OnPingCanceled
// 0x0060 (0x0060 - 0x0000)
struct GzAudioControllerComponent_OnPingCanceled final
{
public:
	struct FGzPingData                            PingData;                                          // 0x0000(0x0060)(ConstParm, Parm, OutParm, ReferenceParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzAudioControllerComponent_OnPingCanceled) == 0x000008, "Wrong alignment on GzAudioControllerComponent_OnPingCanceled");
static_assert(sizeof(GzAudioControllerComponent_OnPingCanceled) == 0x000060, "Wrong size on GzAudioControllerComponent_OnPingCanceled");
static_assert(offsetof(GzAudioControllerComponent_OnPingCanceled, PingData) == 0x000000, "Member 'GzAudioControllerComponent_OnPingCanceled::PingData' has a wrong offset!");

// Function G01.GzAudioControllerComponent.OnTeamDied
// 0x0008 (0x0008 - 0x0000)
struct GzAudioControllerComponent_OnTeamDied final
{
public:
	class AGzTeam*                                DefeatedTeam;                                      // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzAudioControllerComponent_OnTeamDied) == 0x000008, "Wrong alignment on GzAudioControllerComponent_OnTeamDied");
static_assert(sizeof(GzAudioControllerComponent_OnTeamDied) == 0x000008, "Wrong size on GzAudioControllerComponent_OnTeamDied");
static_assert(offsetof(GzAudioControllerComponent_OnTeamDied, DefeatedTeam) == 0x000000, "Member 'GzAudioControllerComponent_OnTeamDied::DefeatedTeam' has a wrong offset!");

// Function G01.GzAudioControllerComponent.OnViewTargetChanged
// 0x0008 (0x0008 - 0x0000)
struct GzAudioControllerComponent_OnViewTargetChanged final
{
public:
	class APawn*                                  NewViewTarget;                                     // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzAudioControllerComponent_OnViewTargetChanged) == 0x000008, "Wrong alignment on GzAudioControllerComponent_OnViewTargetChanged");
static_assert(sizeof(GzAudioControllerComponent_OnViewTargetChanged) == 0x000008, "Wrong size on GzAudioControllerComponent_OnViewTargetChanged");
static_assert(offsetof(GzAudioControllerComponent_OnViewTargetChanged, NewViewTarget) == 0x000000, "Member 'GzAudioControllerComponent_OnViewTargetChanged::NewViewTarget' has a wrong offset!");

// Function G01.GzAudioControllerComponent.OnVoiceLineEventHit
// 0x0010 (0x0010 - 0x0000)
struct GzAudioControllerComponent_OnVoiceLineEventHit final
{
public:
	EAkCallbackType                               CallbackType;                                      // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2EE9[0x7];                                     // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UAkCallbackInfo*                        CallbackInfo;                                      // 0x0008(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzAudioControllerComponent_OnVoiceLineEventHit) == 0x000008, "Wrong alignment on GzAudioControllerComponent_OnVoiceLineEventHit");
static_assert(sizeof(GzAudioControllerComponent_OnVoiceLineEventHit) == 0x000010, "Wrong size on GzAudioControllerComponent_OnVoiceLineEventHit");
static_assert(offsetof(GzAudioControllerComponent_OnVoiceLineEventHit, CallbackType) == 0x000000, "Member 'GzAudioControllerComponent_OnVoiceLineEventHit::CallbackType' has a wrong offset!");
static_assert(offsetof(GzAudioControllerComponent_OnVoiceLineEventHit, CallbackInfo) == 0x000008, "Member 'GzAudioControllerComponent_OnVoiceLineEventHit::CallbackInfo' has a wrong offset!");

// Function G01.GzAudioControllerComponent.PostCharacterActionVoiceLine
// 0x0020 (0x0020 - 0x0000)
struct GzAudioControllerComponent_PostCharacterActionVoiceLine final
{
public:
	class AActor*                                 Actor;                                             // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAkAudioEvent*                          Event;                                             // 0x0008(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           VoiceLineTag;                                      // 0x0010(0x0008)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EGzVoiceLinePriority                          Priority;                                          // 0x0018(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0019(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2EEA[0x6];                                     // 0x001A(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GzAudioControllerComponent_PostCharacterActionVoiceLine) == 0x000008, "Wrong alignment on GzAudioControllerComponent_PostCharacterActionVoiceLine");
static_assert(sizeof(GzAudioControllerComponent_PostCharacterActionVoiceLine) == 0x000020, "Wrong size on GzAudioControllerComponent_PostCharacterActionVoiceLine");
static_assert(offsetof(GzAudioControllerComponent_PostCharacterActionVoiceLine, Actor) == 0x000000, "Member 'GzAudioControllerComponent_PostCharacterActionVoiceLine::Actor' has a wrong offset!");
static_assert(offsetof(GzAudioControllerComponent_PostCharacterActionVoiceLine, Event) == 0x000008, "Member 'GzAudioControllerComponent_PostCharacterActionVoiceLine::Event' has a wrong offset!");
static_assert(offsetof(GzAudioControllerComponent_PostCharacterActionVoiceLine, VoiceLineTag) == 0x000010, "Member 'GzAudioControllerComponent_PostCharacterActionVoiceLine::VoiceLineTag' has a wrong offset!");
static_assert(offsetof(GzAudioControllerComponent_PostCharacterActionVoiceLine, Priority) == 0x000018, "Member 'GzAudioControllerComponent_PostCharacterActionVoiceLine::Priority' has a wrong offset!");
static_assert(offsetof(GzAudioControllerComponent_PostCharacterActionVoiceLine, ReturnValue) == 0x000019, "Member 'GzAudioControllerComponent_PostCharacterActionVoiceLine::ReturnValue' has a wrong offset!");

// Function G01.GzAudioControllerComponent.PostLocalAkEvent
// 0x0010 (0x0010 - 0x0000)
struct GzAudioControllerComponent_PostLocalAkEvent final
{
public:
	class UAkAudioEvent*                          Event;                                             // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ReturnValue;                                       // 0x0008(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2EEB[0x4];                                     // 0x000C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GzAudioControllerComponent_PostLocalAkEvent) == 0x000008, "Wrong alignment on GzAudioControllerComponent_PostLocalAkEvent");
static_assert(sizeof(GzAudioControllerComponent_PostLocalAkEvent) == 0x000010, "Wrong size on GzAudioControllerComponent_PostLocalAkEvent");
static_assert(offsetof(GzAudioControllerComponent_PostLocalAkEvent, Event) == 0x000000, "Member 'GzAudioControllerComponent_PostLocalAkEvent::Event' has a wrong offset!");
static_assert(offsetof(GzAudioControllerComponent_PostLocalAkEvent, ReturnValue) == 0x000008, "Member 'GzAudioControllerComponent_PostLocalAkEvent::ReturnValue' has a wrong offset!");

// Function G01.GzAudioControllerComponent.PostVoiceLine
// 0x0020 (0x0020 - 0x0000)
struct GzAudioControllerComponent_PostVoiceLine final
{
public:
	class AActor*                                 Actor;                                             // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAkAudioEvent*                          Event;                                             // 0x0008(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           VoiceLineTag;                                      // 0x0010(0x0008)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EGzVoiceLinePriority                          Priority;                                          // 0x0018(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0019(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2EEC[0x6];                                     // 0x001A(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GzAudioControllerComponent_PostVoiceLine) == 0x000008, "Wrong alignment on GzAudioControllerComponent_PostVoiceLine");
static_assert(sizeof(GzAudioControllerComponent_PostVoiceLine) == 0x000020, "Wrong size on GzAudioControllerComponent_PostVoiceLine");
static_assert(offsetof(GzAudioControllerComponent_PostVoiceLine, Actor) == 0x000000, "Member 'GzAudioControllerComponent_PostVoiceLine::Actor' has a wrong offset!");
static_assert(offsetof(GzAudioControllerComponent_PostVoiceLine, Event) == 0x000008, "Member 'GzAudioControllerComponent_PostVoiceLine::Event' has a wrong offset!");
static_assert(offsetof(GzAudioControllerComponent_PostVoiceLine, VoiceLineTag) == 0x000010, "Member 'GzAudioControllerComponent_PostVoiceLine::VoiceLineTag' has a wrong offset!");
static_assert(offsetof(GzAudioControllerComponent_PostVoiceLine, Priority) == 0x000018, "Member 'GzAudioControllerComponent_PostVoiceLine::Priority' has a wrong offset!");
static_assert(offsetof(GzAudioControllerComponent_PostVoiceLine, ReturnValue) == 0x000019, "Member 'GzAudioControllerComponent_PostVoiceLine::ReturnValue' has a wrong offset!");

// Function G01.GzAudioEngineSubsystem.OnInputMethodChanged
// 0x0008 (0x0008 - 0x0000)
struct GzAudioEngineSubsystem_OnInputMethodChanged final
{
public:
	struct FPlatformUserId                        UserId;                                            // 0x0000(0x0004)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FInputDeviceId                         InputDeviceId;                                     // 0x0004(0x0004)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzAudioEngineSubsystem_OnInputMethodChanged) == 0x000004, "Wrong alignment on GzAudioEngineSubsystem_OnInputMethodChanged");
static_assert(sizeof(GzAudioEngineSubsystem_OnInputMethodChanged) == 0x000008, "Wrong size on GzAudioEngineSubsystem_OnInputMethodChanged");
static_assert(offsetof(GzAudioEngineSubsystem_OnInputMethodChanged, UserId) == 0x000000, "Member 'GzAudioEngineSubsystem_OnInputMethodChanged::UserId' has a wrong offset!");
static_assert(offsetof(GzAudioEngineSubsystem_OnInputMethodChanged, InputDeviceId) == 0x000004, "Member 'GzAudioEngineSubsystem_OnInputMethodChanged::InputDeviceId' has a wrong offset!");

// Function G01.GzLootUtility.GetLootModifiableNames
// 0x0010 (0x0010 - 0x0000)
struct GzLootUtility_GetLootModifiableNames final
{
public:
	TArray<class FName>                           ReturnValue;                                       // 0x0000(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzLootUtility_GetLootModifiableNames) == 0x000008, "Wrong alignment on GzLootUtility_GetLootModifiableNames");
static_assert(sizeof(GzLootUtility_GetLootModifiableNames) == 0x000010, "Wrong size on GzLootUtility_GetLootModifiableNames");
static_assert(offsetof(GzLootUtility_GetLootModifiableNames, ReturnValue) == 0x000000, "Member 'GzLootUtility_GetLootModifiableNames::ReturnValue' has a wrong offset!");

// Function G01.GzLootUtility.MergeLootModifiers
// 0x0020 (0x0020 - 0x0000)
struct GzLootUtility_MergeLootModifiers final
{
public:
	TArray<class UGzLootModifierTableData*>       ModifierTables;                                    // 0x0000(0x0010)(ConstParm, Parm, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FGzLootModifier>                ReturnValue;                                       // 0x0010(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzLootUtility_MergeLootModifiers) == 0x000008, "Wrong alignment on GzLootUtility_MergeLootModifiers");
static_assert(sizeof(GzLootUtility_MergeLootModifiers) == 0x000020, "Wrong size on GzLootUtility_MergeLootModifiers");
static_assert(offsetof(GzLootUtility_MergeLootModifiers, ModifierTables) == 0x000000, "Member 'GzLootUtility_MergeLootModifiers::ModifierTables' has a wrong offset!");
static_assert(offsetof(GzLootUtility_MergeLootModifiers, ReturnValue) == 0x000010, "Member 'GzLootUtility_MergeLootModifiers::ReturnValue' has a wrong offset!");

// Function G01.GzInventoryTooltip.InitFromItem_BP
// 0x0018 (0x0018 - 0x0000)
struct GzInventoryTooltip_InitFromItem_BP final
{
public:
	struct FGzInvItem                             InItem;                                            // 0x0000(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	struct FGzInvPocketId                         PocketId;                                          // 0x0010(0x0008)(ConstParm, Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzInventoryTooltip_InitFromItem_BP) == 0x000008, "Wrong alignment on GzInventoryTooltip_InitFromItem_BP");
static_assert(sizeof(GzInventoryTooltip_InitFromItem_BP) == 0x000018, "Wrong size on GzInventoryTooltip_InitFromItem_BP");
static_assert(offsetof(GzInventoryTooltip_InitFromItem_BP, InItem) == 0x000000, "Member 'GzInventoryTooltip_InitFromItem_BP::InItem' has a wrong offset!");
static_assert(offsetof(GzInventoryTooltip_InitFromItem_BP, PocketId) == 0x000010, "Member 'GzInventoryTooltip_InitFromItem_BP::PocketId' has a wrong offset!");

// Function G01.GzGA_Minigun.HandleAbilityInputPressed
// 0x0004 (0x0004 - 0x0000)
struct GzGA_Minigun_HandleAbilityInputPressed final
{
public:
	float                                         TimeHeld;                                          // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzGA_Minigun_HandleAbilityInputPressed) == 0x000004, "Wrong alignment on GzGA_Minigun_HandleAbilityInputPressed");
static_assert(sizeof(GzGA_Minigun_HandleAbilityInputPressed) == 0x000004, "Wrong size on GzGA_Minigun_HandleAbilityInputPressed");
static_assert(offsetof(GzGA_Minigun_HandleAbilityInputPressed, TimeHeld) == 0x000000, "Member 'GzGA_Minigun_HandleAbilityInputPressed::TimeHeld' has a wrong offset!");

// Function G01.GzGA_Minigun.HandleShootingInputPressed
// 0x0004 (0x0004 - 0x0000)
struct GzGA_Minigun_HandleShootingInputPressed final
{
public:
	float                                         Time;                                              // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzGA_Minigun_HandleShootingInputPressed) == 0x000004, "Wrong alignment on GzGA_Minigun_HandleShootingInputPressed");
static_assert(sizeof(GzGA_Minigun_HandleShootingInputPressed) == 0x000004, "Wrong size on GzGA_Minigun_HandleShootingInputPressed");
static_assert(offsetof(GzGA_Minigun_HandleShootingInputPressed, Time) == 0x000000, "Member 'GzGA_Minigun_HandleShootingInputPressed::Time' has a wrong offset!");

// Function G01.GzGA_Minigun.HandleShootingInputReleased
// 0x0004 (0x0004 - 0x0000)
struct GzGA_Minigun_HandleShootingInputReleased final
{
public:
	float                                         Time;                                              // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzGA_Minigun_HandleShootingInputReleased) == 0x000004, "Wrong alignment on GzGA_Minigun_HandleShootingInputReleased");
static_assert(sizeof(GzGA_Minigun_HandleShootingInputReleased) == 0x000004, "Wrong size on GzGA_Minigun_HandleShootingInputReleased");
static_assert(offsetof(GzGA_Minigun_HandleShootingInputReleased, Time) == 0x000000, "Member 'GzGA_Minigun_HandleShootingInputReleased::Time' has a wrong offset!");

// Function G01.GzAudioManagerSubsystem.GetAudioAnnouncer
// 0x0018 (0x0018 - 0x0000)
struct GzAudioManagerSubsystem_GetAudioAnnouncer final
{
public:
	const class UObject*                          WorldContext;                                      // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           AnnouncerTag;                                      // 0x0008(0x0008)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AGzAudioAnnouncer*                      ReturnValue;                                       // 0x0010(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzAudioManagerSubsystem_GetAudioAnnouncer) == 0x000008, "Wrong alignment on GzAudioManagerSubsystem_GetAudioAnnouncer");
static_assert(sizeof(GzAudioManagerSubsystem_GetAudioAnnouncer) == 0x000018, "Wrong size on GzAudioManagerSubsystem_GetAudioAnnouncer");
static_assert(offsetof(GzAudioManagerSubsystem_GetAudioAnnouncer, WorldContext) == 0x000000, "Member 'GzAudioManagerSubsystem_GetAudioAnnouncer::WorldContext' has a wrong offset!");
static_assert(offsetof(GzAudioManagerSubsystem_GetAudioAnnouncer, AnnouncerTag) == 0x000008, "Member 'GzAudioManagerSubsystem_GetAudioAnnouncer::AnnouncerTag' has a wrong offset!");
static_assert(offsetof(GzAudioManagerSubsystem_GetAudioAnnouncer, ReturnValue) == 0x000010, "Member 'GzAudioManagerSubsystem_GetAudioAnnouncer::ReturnValue' has a wrong offset!");

// Function G01.GzAudioManagerSubsystem.ResetLoadedStateEvent
// 0x0010 (0x0010 - 0x0000)
struct GzAudioManagerSubsystem_ResetLoadedStateEvent final
{
public:
	EAkCallbackType                               CallbackType;                                      // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2EF3[0x7];                                     // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UAkCallbackInfo*                        CallbackInfo;                                      // 0x0008(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzAudioManagerSubsystem_ResetLoadedStateEvent) == 0x000008, "Wrong alignment on GzAudioManagerSubsystem_ResetLoadedStateEvent");
static_assert(sizeof(GzAudioManagerSubsystem_ResetLoadedStateEvent) == 0x000010, "Wrong size on GzAudioManagerSubsystem_ResetLoadedStateEvent");
static_assert(offsetof(GzAudioManagerSubsystem_ResetLoadedStateEvent, CallbackType) == 0x000000, "Member 'GzAudioManagerSubsystem_ResetLoadedStateEvent::CallbackType' has a wrong offset!");
static_assert(offsetof(GzAudioManagerSubsystem_ResetLoadedStateEvent, CallbackInfo) == 0x000008, "Member 'GzAudioManagerSubsystem_ResetLoadedStateEvent::CallbackInfo' has a wrong offset!");

// Function G01.GzBTBaseService.GetBlackboardComponent
// 0x0008 (0x0008 - 0x0000)
struct GzBTBaseService_GetBlackboardComponent final
{
public:
	class UBlackboardComponent*                   ReturnValue;                                       // 0x0000(0x0008)(ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzBTBaseService_GetBlackboardComponent) == 0x000008, "Wrong alignment on GzBTBaseService_GetBlackboardComponent");
static_assert(sizeof(GzBTBaseService_GetBlackboardComponent) == 0x000008, "Wrong size on GzBTBaseService_GetBlackboardComponent");
static_assert(offsetof(GzBTBaseService_GetBlackboardComponent, ReturnValue) == 0x000000, "Member 'GzBTBaseService_GetBlackboardComponent::ReturnValue' has a wrong offset!");

// Function G01.GzBTBaseService.GetGzAIController
// 0x0008 (0x0008 - 0x0000)
struct GzBTBaseService_GetGzAIController final
{
public:
	class AGzAIController*                        ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzBTBaseService_GetGzAIController) == 0x000008, "Wrong alignment on GzBTBaseService_GetGzAIController");
static_assert(sizeof(GzBTBaseService_GetGzAIController) == 0x000008, "Wrong size on GzBTBaseService_GetGzAIController");
static_assert(offsetof(GzBTBaseService_GetGzAIController, ReturnValue) == 0x000000, "Member 'GzBTBaseService_GetGzAIController::ReturnValue' has a wrong offset!");

// Function G01.GzBTServiceAttack.OnTakeDamage
// 0x0028 (0x0028 - 0x0000)
struct GzBTServiceAttack_OnTakeDamage final
{
public:
	class AActor*                                 DamagedActor;                                      // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Damage;                                            // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2EF6[0x4];                                     // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	const class UDamageType*                      DamageType;                                        // 0x0010(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AController*                            InstigatedBy;                                      // 0x0018(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 DamageCauser;                                      // 0x0020(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzBTServiceAttack_OnTakeDamage) == 0x000008, "Wrong alignment on GzBTServiceAttack_OnTakeDamage");
static_assert(sizeof(GzBTServiceAttack_OnTakeDamage) == 0x000028, "Wrong size on GzBTServiceAttack_OnTakeDamage");
static_assert(offsetof(GzBTServiceAttack_OnTakeDamage, DamagedActor) == 0x000000, "Member 'GzBTServiceAttack_OnTakeDamage::DamagedActor' has a wrong offset!");
static_assert(offsetof(GzBTServiceAttack_OnTakeDamage, Damage) == 0x000008, "Member 'GzBTServiceAttack_OnTakeDamage::Damage' has a wrong offset!");
static_assert(offsetof(GzBTServiceAttack_OnTakeDamage, DamageType) == 0x000010, "Member 'GzBTServiceAttack_OnTakeDamage::DamageType' has a wrong offset!");
static_assert(offsetof(GzBTServiceAttack_OnTakeDamage, InstigatedBy) == 0x000018, "Member 'GzBTServiceAttack_OnTakeDamage::InstigatedBy' has a wrong offset!");
static_assert(offsetof(GzBTServiceAttack_OnTakeDamage, DamageCauser) == 0x000020, "Member 'GzBTServiceAttack_OnTakeDamage::DamageCauser' has a wrong offset!");

// Function G01.GzGlobalSettings.GetGlobalSettings
// 0x0008 (0x0008 - 0x0000)
struct GzGlobalSettings_GetGlobalSettings final
{
public:
	class UGzGlobalSettings*                      ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzGlobalSettings_GetGlobalSettings) == 0x000008, "Wrong alignment on GzGlobalSettings_GetGlobalSettings");
static_assert(sizeof(GzGlobalSettings_GetGlobalSettings) == 0x000008, "Wrong size on GzGlobalSettings_GetGlobalSettings");
static_assert(offsetof(GzGlobalSettings_GetGlobalSettings, ReturnValue) == 0x000000, "Member 'GzGlobalSettings_GetGlobalSettings::ReturnValue' has a wrong offset!");

// Function G01.GzBTServiceSwitchFireMode.GetCurrentFireMode
// 0x0001 (0x0001 - 0x0000)
struct GzBTServiceSwitchFireMode_GetCurrentFireMode final
{
public:
	EGzWeaponMode                                 ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzBTServiceSwitchFireMode_GetCurrentFireMode) == 0x000001, "Wrong alignment on GzBTServiceSwitchFireMode_GetCurrentFireMode");
static_assert(sizeof(GzBTServiceSwitchFireMode_GetCurrentFireMode) == 0x000001, "Wrong size on GzBTServiceSwitchFireMode_GetCurrentFireMode");
static_assert(offsetof(GzBTServiceSwitchFireMode_GetCurrentFireMode, ReturnValue) == 0x000000, "Member 'GzBTServiceSwitchFireMode_GetCurrentFireMode::ReturnValue' has a wrong offset!");

// Function G01.GzQuickOrderComponent.Server_SpawnDeliveryDrone
// 0x0028 (0x0028 - 0x0000)
struct GzQuickOrderComponent_Server_SpawnDeliveryDrone final
{
public:
	struct FGuid                                  LoadoutGuid;                                       // 0x0000(0x0010)(ConstParm, Parm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                InDeliveryLocation;                                // 0x0010(0x0018)(ConstParm, Parm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzQuickOrderComponent_Server_SpawnDeliveryDrone) == 0x000008, "Wrong alignment on GzQuickOrderComponent_Server_SpawnDeliveryDrone");
static_assert(sizeof(GzQuickOrderComponent_Server_SpawnDeliveryDrone) == 0x000028, "Wrong size on GzQuickOrderComponent_Server_SpawnDeliveryDrone");
static_assert(offsetof(GzQuickOrderComponent_Server_SpawnDeliveryDrone, LoadoutGuid) == 0x000000, "Member 'GzQuickOrderComponent_Server_SpawnDeliveryDrone::LoadoutGuid' has a wrong offset!");
static_assert(offsetof(GzQuickOrderComponent_Server_SpawnDeliveryDrone, InDeliveryLocation) == 0x000010, "Member 'GzQuickOrderComponent_Server_SpawnDeliveryDrone::InDeliveryLocation' has a wrong offset!");

// Function G01.GzQuickOrderComponent.StartSelectingDeliveryLocation
// 0x0010 (0x0010 - 0x0000)
struct GzQuickOrderComponent_StartSelectingDeliveryLocation final
{
public:
	struct FGuid                                  LoadoutGuid;                                       // 0x0000(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzQuickOrderComponent_StartSelectingDeliveryLocation) == 0x000004, "Wrong alignment on GzQuickOrderComponent_StartSelectingDeliveryLocation");
static_assert(sizeof(GzQuickOrderComponent_StartSelectingDeliveryLocation) == 0x000010, "Wrong size on GzQuickOrderComponent_StartSelectingDeliveryLocation");
static_assert(offsetof(GzQuickOrderComponent_StartSelectingDeliveryLocation, LoadoutGuid) == 0x000000, "Member 'GzQuickOrderComponent_StartSelectingDeliveryLocation::LoadoutGuid' has a wrong offset!");

// Function G01.GzQuickOrderComponent.TryCallDrone
// 0x0001 (0x0001 - 0x0000)
struct GzQuickOrderComponent_TryCallDrone final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzQuickOrderComponent_TryCallDrone) == 0x000001, "Wrong alignment on GzQuickOrderComponent_TryCallDrone");
static_assert(sizeof(GzQuickOrderComponent_TryCallDrone) == 0x000001, "Wrong size on GzQuickOrderComponent_TryCallDrone");
static_assert(offsetof(GzQuickOrderComponent_TryCallDrone, ReturnValue) == 0x000000, "Member 'GzQuickOrderComponent_TryCallDrone::ReturnValue' has a wrong offset!");

// Function G01.GzQuickOrderComponent.CanCallDeliveryDrone
// 0x0001 (0x0001 - 0x0000)
struct GzQuickOrderComponent_CanCallDeliveryDrone final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzQuickOrderComponent_CanCallDeliveryDrone) == 0x000001, "Wrong alignment on GzQuickOrderComponent_CanCallDeliveryDrone");
static_assert(sizeof(GzQuickOrderComponent_CanCallDeliveryDrone) == 0x000001, "Wrong size on GzQuickOrderComponent_CanCallDeliveryDrone");
static_assert(offsetof(GzQuickOrderComponent_CanCallDeliveryDrone, ReturnValue) == 0x000000, "Member 'GzQuickOrderComponent_CanCallDeliveryDrone::ReturnValue' has a wrong offset!");

// Function G01.GzQuickOrderComponent.GetCallDroneAvailableTime
// 0x0004 (0x0004 - 0x0000)
struct GzQuickOrderComponent_GetCallDroneAvailableTime final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzQuickOrderComponent_GetCallDroneAvailableTime) == 0x000004, "Wrong alignment on GzQuickOrderComponent_GetCallDroneAvailableTime");
static_assert(sizeof(GzQuickOrderComponent_GetCallDroneAvailableTime) == 0x000004, "Wrong size on GzQuickOrderComponent_GetCallDroneAvailableTime");
static_assert(offsetof(GzQuickOrderComponent_GetCallDroneAvailableTime, ReturnValue) == 0x000000, "Member 'GzQuickOrderComponent_GetCallDroneAvailableTime::ReturnValue' has a wrong offset!");

// Function G01.GzQuickOrderComponent.GetDroneRemainingCooldown
// 0x0004 (0x0004 - 0x0000)
struct GzQuickOrderComponent_GetDroneRemainingCooldown final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzQuickOrderComponent_GetDroneRemainingCooldown) == 0x000004, "Wrong alignment on GzQuickOrderComponent_GetDroneRemainingCooldown");
static_assert(sizeof(GzQuickOrderComponent_GetDroneRemainingCooldown) == 0x000004, "Wrong size on GzQuickOrderComponent_GetDroneRemainingCooldown");
static_assert(offsetof(GzQuickOrderComponent_GetDroneRemainingCooldown, ReturnValue) == 0x000000, "Member 'GzQuickOrderComponent_GetDroneRemainingCooldown::ReturnValue' has a wrong offset!");

// Function G01.GzQuickOrderComponent.IsSelectingLocation
// 0x0001 (0x0001 - 0x0000)
struct GzQuickOrderComponent_IsSelectingLocation final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzQuickOrderComponent_IsSelectingLocation) == 0x000001, "Wrong alignment on GzQuickOrderComponent_IsSelectingLocation");
static_assert(sizeof(GzQuickOrderComponent_IsSelectingLocation) == 0x000001, "Wrong size on GzQuickOrderComponent_IsSelectingLocation");
static_assert(offsetof(GzQuickOrderComponent_IsSelectingLocation, ReturnValue) == 0x000000, "Member 'GzQuickOrderComponent_IsSelectingLocation::ReturnValue' has a wrong offset!");

// Function G01.GzAutoReplaySubsystem.OnReplayPlaybackComplete
// 0x0008 (0x0008 - 0x0000)
struct GzAutoReplaySubsystem_OnReplayPlaybackComplete final
{
public:
	class UWorld*                                 World;                                             // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzAutoReplaySubsystem_OnReplayPlaybackComplete) == 0x000008, "Wrong alignment on GzAutoReplaySubsystem_OnReplayPlaybackComplete");
static_assert(sizeof(GzAutoReplaySubsystem_OnReplayPlaybackComplete) == 0x000008, "Wrong size on GzAutoReplaySubsystem_OnReplayPlaybackComplete");
static_assert(offsetof(GzAutoReplaySubsystem_OnReplayPlaybackComplete, World) == 0x000000, "Member 'GzAutoReplaySubsystem_OnReplayPlaybackComplete::World' has a wrong offset!");

// Function G01.GzAutoRespawnAvailabilityMessage.GetAutoRespawnChangeTime
// 0x0004 (0x0004 - 0x0000)
struct GzAutoRespawnAvailabilityMessage_GetAutoRespawnChangeTime final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzAutoRespawnAvailabilityMessage_GetAutoRespawnChangeTime) == 0x000004, "Wrong alignment on GzAutoRespawnAvailabilityMessage_GetAutoRespawnChangeTime");
static_assert(sizeof(GzAutoRespawnAvailabilityMessage_GetAutoRespawnChangeTime) == 0x000004, "Wrong size on GzAutoRespawnAvailabilityMessage_GetAutoRespawnChangeTime");
static_assert(offsetof(GzAutoRespawnAvailabilityMessage_GetAutoRespawnChangeTime, ReturnValue) == 0x000000, "Member 'GzAutoRespawnAvailabilityMessage_GetAutoRespawnChangeTime::ReturnValue' has a wrong offset!");

// Function G01.GzAutoRespawnAvailabilityMessage.GetNewAvailabilityStatus
// 0x0004 (0x0004 - 0x0000)
struct GzAutoRespawnAvailabilityMessage_GetNewAvailabilityStatus final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzAutoRespawnAvailabilityMessage_GetNewAvailabilityStatus) == 0x000004, "Wrong alignment on GzAutoRespawnAvailabilityMessage_GetNewAvailabilityStatus");
static_assert(sizeof(GzAutoRespawnAvailabilityMessage_GetNewAvailabilityStatus) == 0x000004, "Wrong size on GzAutoRespawnAvailabilityMessage_GetNewAvailabilityStatus");
static_assert(offsetof(GzAutoRespawnAvailabilityMessage_GetNewAvailabilityStatus, ReturnValue) == 0x000000, "Member 'GzAutoRespawnAvailabilityMessage_GetNewAvailabilityStatus::ReturnValue' has a wrong offset!");

// Function G01.GzCoreBlueprintFunctionLibrary.LogStreamingGridInfo
// 0x0008 (0x0008 - 0x0000)
struct GzCoreBlueprintFunctionLibrary_LogStreamingGridInfo final
{
public:
	const class UObject*                          WorldContextObject;                                // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzCoreBlueprintFunctionLibrary_LogStreamingGridInfo) == 0x000008, "Wrong alignment on GzCoreBlueprintFunctionLibrary_LogStreamingGridInfo");
static_assert(sizeof(GzCoreBlueprintFunctionLibrary_LogStreamingGridInfo) == 0x000008, "Wrong size on GzCoreBlueprintFunctionLibrary_LogStreamingGridInfo");
static_assert(offsetof(GzCoreBlueprintFunctionLibrary_LogStreamingGridInfo, WorldContextObject) == 0x000000, "Member 'GzCoreBlueprintFunctionLibrary_LogStreamingGridInfo::WorldContextObject' has a wrong offset!");

// Function G01.GzAutotestCommandInteract.OnInteract
// 0x0010 (0x0010 - 0x0000)
struct GzAutotestCommandInteract_OnInteract final
{
public:
	class AActor*                                 InteractedBy;                                      // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	const class UGzInteractableComponent*         Interaction;                                       // 0x0008(0x0008)(ConstParm, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzAutotestCommandInteract_OnInteract) == 0x000008, "Wrong alignment on GzAutotestCommandInteract_OnInteract");
static_assert(sizeof(GzAutotestCommandInteract_OnInteract) == 0x000010, "Wrong size on GzAutotestCommandInteract_OnInteract");
static_assert(offsetof(GzAutotestCommandInteract_OnInteract, InteractedBy) == 0x000000, "Member 'GzAutotestCommandInteract_OnInteract::InteractedBy' has a wrong offset!");
static_assert(offsetof(GzAutotestCommandInteract_OnInteract, Interaction) == 0x000008, "Member 'GzAutotestCommandInteract_OnInteract::Interaction' has a wrong offset!");

// Function G01.GzHealthInterface.GetHealth
// 0x0004 (0x0004 - 0x0000)
struct GzHealthInterface_GetHealth final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzHealthInterface_GetHealth) == 0x000004, "Wrong alignment on GzHealthInterface_GetHealth");
static_assert(sizeof(GzHealthInterface_GetHealth) == 0x000004, "Wrong size on GzHealthInterface_GetHealth");
static_assert(offsetof(GzHealthInterface_GetHealth, ReturnValue) == 0x000000, "Member 'GzHealthInterface_GetHealth::ReturnValue' has a wrong offset!");

// Function G01.GzHealthInterface.GetMaxHealth
// 0x0004 (0x0004 - 0x0000)
struct GzHealthInterface_GetMaxHealth final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzHealthInterface_GetMaxHealth) == 0x000004, "Wrong alignment on GzHealthInterface_GetMaxHealth");
static_assert(sizeof(GzHealthInterface_GetMaxHealth) == 0x000004, "Wrong size on GzHealthInterface_GetMaxHealth");
static_assert(offsetof(GzHealthInterface_GetMaxHealth, ReturnValue) == 0x000000, "Member 'GzHealthInterface_GetMaxHealth::ReturnValue' has a wrong offset!");

// Function G01.GzHealthInterface.IsAlive
// 0x0001 (0x0001 - 0x0000)
struct GzHealthInterface_IsAlive final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzHealthInterface_IsAlive) == 0x000001, "Wrong alignment on GzHealthInterface_IsAlive");
static_assert(sizeof(GzHealthInterface_IsAlive) == 0x000001, "Wrong size on GzHealthInterface_IsAlive");
static_assert(offsetof(GzHealthInterface_IsAlive, ReturnValue) == 0x000000, "Member 'GzHealthInterface_IsAlive::ReturnValue' has a wrong offset!");

// Function G01.GzPropagationActor.OnPropagationPointActivated
// 0x0040 (0x0040 - 0x0000)
struct GzPropagationActor_OnPropagationPointActivated final
{
public:
	int32                                         PropagationPointID;                                // 0x0000(0x0004)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2F22[0x4];                                     // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                Location;                                          // 0x0008(0x0018)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Normal;                                            // 0x0020(0x0018)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PointLifespan;                                     // 0x0038(0x0004)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2F23[0x4];                                     // 0x003C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GzPropagationActor_OnPropagationPointActivated) == 0x000008, "Wrong alignment on GzPropagationActor_OnPropagationPointActivated");
static_assert(sizeof(GzPropagationActor_OnPropagationPointActivated) == 0x000040, "Wrong size on GzPropagationActor_OnPropagationPointActivated");
static_assert(offsetof(GzPropagationActor_OnPropagationPointActivated, PropagationPointID) == 0x000000, "Member 'GzPropagationActor_OnPropagationPointActivated::PropagationPointID' has a wrong offset!");
static_assert(offsetof(GzPropagationActor_OnPropagationPointActivated, Location) == 0x000008, "Member 'GzPropagationActor_OnPropagationPointActivated::Location' has a wrong offset!");
static_assert(offsetof(GzPropagationActor_OnPropagationPointActivated, Normal) == 0x000020, "Member 'GzPropagationActor_OnPropagationPointActivated::Normal' has a wrong offset!");
static_assert(offsetof(GzPropagationActor_OnPropagationPointActivated, PointLifespan) == 0x000038, "Member 'GzPropagationActor_OnPropagationPointActivated::PointLifespan' has a wrong offset!");

// Function G01.GzPropagationActor.OnPropagationPointDeactivated
// 0x0038 (0x0038 - 0x0000)
struct GzPropagationActor_OnPropagationPointDeactivated final
{
public:
	int32                                         PropagationPointID;                                // 0x0000(0x0004)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2F24[0x4];                                     // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                Location;                                          // 0x0008(0x0018)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Normal;                                            // 0x0020(0x0018)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzPropagationActor_OnPropagationPointDeactivated) == 0x000008, "Wrong alignment on GzPropagationActor_OnPropagationPointDeactivated");
static_assert(sizeof(GzPropagationActor_OnPropagationPointDeactivated) == 0x000038, "Wrong size on GzPropagationActor_OnPropagationPointDeactivated");
static_assert(offsetof(GzPropagationActor_OnPropagationPointDeactivated, PropagationPointID) == 0x000000, "Member 'GzPropagationActor_OnPropagationPointDeactivated::PropagationPointID' has a wrong offset!");
static_assert(offsetof(GzPropagationActor_OnPropagationPointDeactivated, Location) == 0x000008, "Member 'GzPropagationActor_OnPropagationPointDeactivated::Location' has a wrong offset!");
static_assert(offsetof(GzPropagationActor_OnPropagationPointDeactivated, Normal) == 0x000020, "Member 'GzPropagationActor_OnPropagationPointDeactivated::Normal' has a wrong offset!");

// Function G01.GzPropagationActor.RegisterCollisionComponentWithPoint
// 0x0010 (0x0010 - 0x0000)
struct GzPropagationActor_RegisterCollisionComponentWithPoint final
{
public:
	int32                                         PropagationPointID;                                // 0x0000(0x0004)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2F25[0x4];                                     // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UPrimitiveComponent*                    CollisionComponent;                                // 0x0008(0x0008)(Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzPropagationActor_RegisterCollisionComponentWithPoint) == 0x000008, "Wrong alignment on GzPropagationActor_RegisterCollisionComponentWithPoint");
static_assert(sizeof(GzPropagationActor_RegisterCollisionComponentWithPoint) == 0x000010, "Wrong size on GzPropagationActor_RegisterCollisionComponentWithPoint");
static_assert(offsetof(GzPropagationActor_RegisterCollisionComponentWithPoint, PropagationPointID) == 0x000000, "Member 'GzPropagationActor_RegisterCollisionComponentWithPoint::PropagationPointID' has a wrong offset!");
static_assert(offsetof(GzPropagationActor_RegisterCollisionComponentWithPoint, CollisionComponent) == 0x000008, "Member 'GzPropagationActor_RegisterCollisionComponentWithPoint::CollisionComponent' has a wrong offset!");

// Function G01.GzPropagationActor.RegisterVisualComponentWithPoint
// 0x0010 (0x0010 - 0x0000)
struct GzPropagationActor_RegisterVisualComponentWithPoint final
{
public:
	int32                                         PropagationPointID;                                // 0x0000(0x0004)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2F26[0x4];                                     // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class USceneComponent*                        VisualComponent;                                   // 0x0008(0x0008)(Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzPropagationActor_RegisterVisualComponentWithPoint) == 0x000008, "Wrong alignment on GzPropagationActor_RegisterVisualComponentWithPoint");
static_assert(sizeof(GzPropagationActor_RegisterVisualComponentWithPoint) == 0x000010, "Wrong size on GzPropagationActor_RegisterVisualComponentWithPoint");
static_assert(offsetof(GzPropagationActor_RegisterVisualComponentWithPoint, PropagationPointID) == 0x000000, "Member 'GzPropagationActor_RegisterVisualComponentWithPoint::PropagationPointID' has a wrong offset!");
static_assert(offsetof(GzPropagationActor_RegisterVisualComponentWithPoint, VisualComponent) == 0x000008, "Member 'GzPropagationActor_RegisterVisualComponentWithPoint::VisualComponent' has a wrong offset!");

// Function G01.GzPropagationActor.GetAdjustedLifespan
// 0x0008 (0x0008 - 0x0000)
struct GzPropagationActor_GetAdjustedLifespan final
{
public:
	float                                         TotalLifespan;                                     // 0x0000(0x0004)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ReturnValue;                                       // 0x0004(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzPropagationActor_GetAdjustedLifespan) == 0x000004, "Wrong alignment on GzPropagationActor_GetAdjustedLifespan");
static_assert(sizeof(GzPropagationActor_GetAdjustedLifespan) == 0x000008, "Wrong size on GzPropagationActor_GetAdjustedLifespan");
static_assert(offsetof(GzPropagationActor_GetAdjustedLifespan, TotalLifespan) == 0x000000, "Member 'GzPropagationActor_GetAdjustedLifespan::TotalLifespan' has a wrong offset!");
static_assert(offsetof(GzPropagationActor_GetAdjustedLifespan, ReturnValue) == 0x000004, "Member 'GzPropagationActor_GetAdjustedLifespan::ReturnValue' has a wrong offset!");

// Function G01.GzPropagationActor.MakeEffectContext
// 0x0018 (0x0018 - 0x0000)
struct GzPropagationActor_MakeEffectContext final
{
public:
	struct FGameplayEffectContextHandle           ReturnValue;                                       // 0x0000(0x0018)(Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzPropagationActor_MakeEffectContext) == 0x000008, "Wrong alignment on GzPropagationActor_MakeEffectContext");
static_assert(sizeof(GzPropagationActor_MakeEffectContext) == 0x000018, "Wrong size on GzPropagationActor_MakeEffectContext");
static_assert(offsetof(GzPropagationActor_MakeEffectContext, ReturnValue) == 0x000000, "Member 'GzPropagationActor_MakeEffectContext::ReturnValue' has a wrong offset!");

// Function G01.GzStickyGooPropagationActor.OnPawnBeginOverlap
// 0x0010 (0x0010 - 0x0000)
struct GzStickyGooPropagationActor_OnPawnBeginOverlap final
{
public:
	class AActor*                                 OverlappedActor;                                   // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 OtherActor;                                        // 0x0008(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzStickyGooPropagationActor_OnPawnBeginOverlap) == 0x000008, "Wrong alignment on GzStickyGooPropagationActor_OnPawnBeginOverlap");
static_assert(sizeof(GzStickyGooPropagationActor_OnPawnBeginOverlap) == 0x000010, "Wrong size on GzStickyGooPropagationActor_OnPawnBeginOverlap");
static_assert(offsetof(GzStickyGooPropagationActor_OnPawnBeginOverlap, OverlappedActor) == 0x000000, "Member 'GzStickyGooPropagationActor_OnPawnBeginOverlap::OverlappedActor' has a wrong offset!");
static_assert(offsetof(GzStickyGooPropagationActor_OnPawnBeginOverlap, OtherActor) == 0x000008, "Member 'GzStickyGooPropagationActor_OnPawnBeginOverlap::OtherActor' has a wrong offset!");

// Function G01.GzStickyGooPropagationActor.OnPawnEndOverlap
// 0x0010 (0x0010 - 0x0000)
struct GzStickyGooPropagationActor_OnPawnEndOverlap final
{
public:
	class AActor*                                 OverlappedActor;                                   // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 OtherActor;                                        // 0x0008(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzStickyGooPropagationActor_OnPawnEndOverlap) == 0x000008, "Wrong alignment on GzStickyGooPropagationActor_OnPawnEndOverlap");
static_assert(sizeof(GzStickyGooPropagationActor_OnPawnEndOverlap) == 0x000010, "Wrong size on GzStickyGooPropagationActor_OnPawnEndOverlap");
static_assert(offsetof(GzStickyGooPropagationActor_OnPawnEndOverlap, OverlappedActor) == 0x000000, "Member 'GzStickyGooPropagationActor_OnPawnEndOverlap::OverlappedActor' has a wrong offset!");
static_assert(offsetof(GzStickyGooPropagationActor_OnPawnEndOverlap, OtherActor) == 0x000008, "Member 'GzStickyGooPropagationActor_OnPawnEndOverlap::OtherActor' has a wrong offset!");

// Function G01.GzStickyGooPropagationActor.SpawnDecalNiagaraComponent
// 0x0038 (0x0038 - 0x0000)
struct GzStickyGooPropagationActor_SpawnDecalNiagaraComponent final
{
public:
	struct FVector                                WorldLocation;                                     // 0x0000(0x0018)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               Rotation;                                          // 0x0018(0x0018)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	class UNiagaraComponent*                      ReturnValue;                                       // 0x0030(0x0008)(ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzStickyGooPropagationActor_SpawnDecalNiagaraComponent) == 0x000008, "Wrong alignment on GzStickyGooPropagationActor_SpawnDecalNiagaraComponent");
static_assert(sizeof(GzStickyGooPropagationActor_SpawnDecalNiagaraComponent) == 0x000038, "Wrong size on GzStickyGooPropagationActor_SpawnDecalNiagaraComponent");
static_assert(offsetof(GzStickyGooPropagationActor_SpawnDecalNiagaraComponent, WorldLocation) == 0x000000, "Member 'GzStickyGooPropagationActor_SpawnDecalNiagaraComponent::WorldLocation' has a wrong offset!");
static_assert(offsetof(GzStickyGooPropagationActor_SpawnDecalNiagaraComponent, Rotation) == 0x000018, "Member 'GzStickyGooPropagationActor_SpawnDecalNiagaraComponent::Rotation' has a wrong offset!");
static_assert(offsetof(GzStickyGooPropagationActor_SpawnDecalNiagaraComponent, ReturnValue) == 0x000030, "Member 'GzStickyGooPropagationActor_SpawnDecalNiagaraComponent::ReturnValue' has a wrong offset!");

// Function G01.GzStickyGooPropagationActor.SpawnPrimaryNiagaraComponent
// 0x0038 (0x0038 - 0x0000)
struct GzStickyGooPropagationActor_SpawnPrimaryNiagaraComponent final
{
public:
	struct FVector                                WorldLocation;                                     // 0x0000(0x0018)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Normal;                                            // 0x0018(0x0018)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UNiagaraComponent*                      ReturnValue;                                       // 0x0030(0x0008)(ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzStickyGooPropagationActor_SpawnPrimaryNiagaraComponent) == 0x000008, "Wrong alignment on GzStickyGooPropagationActor_SpawnPrimaryNiagaraComponent");
static_assert(sizeof(GzStickyGooPropagationActor_SpawnPrimaryNiagaraComponent) == 0x000038, "Wrong size on GzStickyGooPropagationActor_SpawnPrimaryNiagaraComponent");
static_assert(offsetof(GzStickyGooPropagationActor_SpawnPrimaryNiagaraComponent, WorldLocation) == 0x000000, "Member 'GzStickyGooPropagationActor_SpawnPrimaryNiagaraComponent::WorldLocation' has a wrong offset!");
static_assert(offsetof(GzStickyGooPropagationActor_SpawnPrimaryNiagaraComponent, Normal) == 0x000018, "Member 'GzStickyGooPropagationActor_SpawnPrimaryNiagaraComponent::Normal' has a wrong offset!");
static_assert(offsetof(GzStickyGooPropagationActor_SpawnPrimaryNiagaraComponent, ReturnValue) == 0x000030, "Member 'GzStickyGooPropagationActor_SpawnPrimaryNiagaraComponent::ReturnValue' has a wrong offset!");

// Function G01.GzStickyGooPropagationActor.SpawnSecondaryNiagaraComponent
// 0x0038 (0x0038 - 0x0000)
struct GzStickyGooPropagationActor_SpawnSecondaryNiagaraComponent final
{
public:
	struct FVector                                WorldLocation;                                     // 0x0000(0x0018)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Normal;                                            // 0x0018(0x0018)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UNiagaraComponent*                      ReturnValue;                                       // 0x0030(0x0008)(ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzStickyGooPropagationActor_SpawnSecondaryNiagaraComponent) == 0x000008, "Wrong alignment on GzStickyGooPropagationActor_SpawnSecondaryNiagaraComponent");
static_assert(sizeof(GzStickyGooPropagationActor_SpawnSecondaryNiagaraComponent) == 0x000038, "Wrong size on GzStickyGooPropagationActor_SpawnSecondaryNiagaraComponent");
static_assert(offsetof(GzStickyGooPropagationActor_SpawnSecondaryNiagaraComponent, WorldLocation) == 0x000000, "Member 'GzStickyGooPropagationActor_SpawnSecondaryNiagaraComponent::WorldLocation' has a wrong offset!");
static_assert(offsetof(GzStickyGooPropagationActor_SpawnSecondaryNiagaraComponent, Normal) == 0x000018, "Member 'GzStickyGooPropagationActor_SpawnSecondaryNiagaraComponent::Normal' has a wrong offset!");
static_assert(offsetof(GzStickyGooPropagationActor_SpawnSecondaryNiagaraComponent, ReturnValue) == 0x000030, "Member 'GzStickyGooPropagationActor_SpawnSecondaryNiagaraComponent::ReturnValue' has a wrong offset!");

// Function G01.GzStickyGooPropagationActor.UpdateVFX
// 0x0018 (0x0018 - 0x0000)
struct GzStickyGooPropagationActor_UpdateVFX final
{
public:
	float                                         DeltaSeconds;                                      // 0x0000(0x0004)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2F2D[0x4];                                     // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UNiagaraComponent*                      Instance;                                          // 0x0008(0x0008)(Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ScaleProgress;                                     // 0x0010(0x0004)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxRadius;                                         // 0x0014(0x0004)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzStickyGooPropagationActor_UpdateVFX) == 0x000008, "Wrong alignment on GzStickyGooPropagationActor_UpdateVFX");
static_assert(sizeof(GzStickyGooPropagationActor_UpdateVFX) == 0x000018, "Wrong size on GzStickyGooPropagationActor_UpdateVFX");
static_assert(offsetof(GzStickyGooPropagationActor_UpdateVFX, DeltaSeconds) == 0x000000, "Member 'GzStickyGooPropagationActor_UpdateVFX::DeltaSeconds' has a wrong offset!");
static_assert(offsetof(GzStickyGooPropagationActor_UpdateVFX, Instance) == 0x000008, "Member 'GzStickyGooPropagationActor_UpdateVFX::Instance' has a wrong offset!");
static_assert(offsetof(GzStickyGooPropagationActor_UpdateVFX, ScaleProgress) == 0x000010, "Member 'GzStickyGooPropagationActor_UpdateVFX::ScaleProgress' has a wrong offset!");
static_assert(offsetof(GzStickyGooPropagationActor_UpdateVFX, MaxRadius) == 0x000014, "Member 'GzStickyGooPropagationActor_UpdateVFX::MaxRadius' has a wrong offset!");

// Function G01.GzBTService_MirrorLimbMove.CheckIsFalling
// 0x0001 (0x0001 - 0x0000)
struct GzBTService_MirrorLimbMove_CheckIsFalling final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzBTService_MirrorLimbMove_CheckIsFalling) == 0x000001, "Wrong alignment on GzBTService_MirrorLimbMove_CheckIsFalling");
static_assert(sizeof(GzBTService_MirrorLimbMove_CheckIsFalling) == 0x000001, "Wrong size on GzBTService_MirrorLimbMove_CheckIsFalling");
static_assert(offsetof(GzBTService_MirrorLimbMove_CheckIsFalling, ReturnValue) == 0x000000, "Member 'GzBTService_MirrorLimbMove_CheckIsFalling::ReturnValue' has a wrong offset!");

// Function G01.GzBTService_MirrorLimbMove.CheckIsNeedStop
// 0x0001 (0x0001 - 0x0000)
struct GzBTService_MirrorLimbMove_CheckIsNeedStop final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzBTService_MirrorLimbMove_CheckIsNeedStop) == 0x000001, "Wrong alignment on GzBTService_MirrorLimbMove_CheckIsNeedStop");
static_assert(sizeof(GzBTService_MirrorLimbMove_CheckIsNeedStop) == 0x000001, "Wrong size on GzBTService_MirrorLimbMove_CheckIsNeedStop");
static_assert(offsetof(GzBTService_MirrorLimbMove_CheckIsNeedStop, ReturnValue) == 0x000000, "Member 'GzBTService_MirrorLimbMove_CheckIsNeedStop::ReturnValue' has a wrong offset!");

// Function G01.GzLootSpawnerComponent.SpawnLoot
// 0x0030 (0x0030 - 0x0000)
struct GzLootSpawnerComponent_SpawnLoot final
{
public:
	struct FGzSpawnContentsParameters             SpawnContentParameters;                            // 0x0000(0x0030)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzLootSpawnerComponent_SpawnLoot) == 0x000008, "Wrong alignment on GzLootSpawnerComponent_SpawnLoot");
static_assert(sizeof(GzLootSpawnerComponent_SpawnLoot) == 0x000030, "Wrong size on GzLootSpawnerComponent_SpawnLoot");
static_assert(offsetof(GzLootSpawnerComponent_SpawnLoot, SpawnContentParameters) == 0x000000, "Member 'GzLootSpawnerComponent_SpawnLoot::SpawnContentParameters' has a wrong offset!");

// Function G01.GzInitialShrinkingZoneSetup.GetCircle
// 0x0018 (0x0018 - 0x0000)
struct GzInitialShrinkingZoneSetup_GetCircle final
{
public:
	struct FGzCircle2D                            ReturnValue;                                       // 0x0000(0x0018)(Parm, OutParm, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzInitialShrinkingZoneSetup_GetCircle) == 0x000008, "Wrong alignment on GzInitialShrinkingZoneSetup_GetCircle");
static_assert(sizeof(GzInitialShrinkingZoneSetup_GetCircle) == 0x000018, "Wrong size on GzInitialShrinkingZoneSetup_GetCircle");
static_assert(offsetof(GzInitialShrinkingZoneSetup_GetCircle, ReturnValue) == 0x000000, "Member 'GzInitialShrinkingZoneSetup_GetCircle::ReturnValue' has a wrong offset!");

// Function G01.GzInitialShrinkingZoneSetup.GetRadius
// 0x0004 (0x0004 - 0x0000)
struct GzInitialShrinkingZoneSetup_GetRadius final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzInitialShrinkingZoneSetup_GetRadius) == 0x000004, "Wrong alignment on GzInitialShrinkingZoneSetup_GetRadius");
static_assert(sizeof(GzInitialShrinkingZoneSetup_GetRadius) == 0x000004, "Wrong size on GzInitialShrinkingZoneSetup_GetRadius");
static_assert(offsetof(GzInitialShrinkingZoneSetup_GetRadius, ReturnValue) == 0x000000, "Member 'GzInitialShrinkingZoneSetup_GetRadius::ReturnValue' has a wrong offset!");

// Function G01.GzInitialShrinkingZoneSetup.GetSpawnHeight
// 0x0004 (0x0004 - 0x0000)
struct GzInitialShrinkingZoneSetup_GetSpawnHeight final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzInitialShrinkingZoneSetup_GetSpawnHeight) == 0x000004, "Wrong alignment on GzInitialShrinkingZoneSetup_GetSpawnHeight");
static_assert(sizeof(GzInitialShrinkingZoneSetup_GetSpawnHeight) == 0x000004, "Wrong size on GzInitialShrinkingZoneSetup_GetSpawnHeight");
static_assert(offsetof(GzInitialShrinkingZoneSetup_GetSpawnHeight, ReturnValue) == 0x000000, "Member 'GzInitialShrinkingZoneSetup_GetSpawnHeight::ReturnValue' has a wrong offset!");

// Function G01.GzInitialShrinkingZoneSetup.GetZoneTag
// 0x0008 (0x0008 - 0x0000)
struct GzInitialShrinkingZoneSetup_GetZoneTag final
{
public:
	struct FGameplayTag                           ReturnValue;                                       // 0x0000(0x0008)(ConstParm, Parm, OutParm, ReturnParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzInitialShrinkingZoneSetup_GetZoneTag) == 0x000004, "Wrong alignment on GzInitialShrinkingZoneSetup_GetZoneTag");
static_assert(sizeof(GzInitialShrinkingZoneSetup_GetZoneTag) == 0x000008, "Wrong size on GzInitialShrinkingZoneSetup_GetZoneTag");
static_assert(offsetof(GzInitialShrinkingZoneSetup_GetZoneTag, ReturnValue) == 0x000000, "Member 'GzInitialShrinkingZoneSetup_GetZoneTag::ReturnValue' has a wrong offset!");

// Function G01.GzAutotestStateCheckerAbilitySystem.RetargetCharacter
// 0x0008 (0x0008 - 0x0000)
struct GzAutotestStateCheckerAbilitySystem_RetargetCharacter final
{
public:
	class AGzCharacter*                           NewTargetCharacter;                                // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzAutotestStateCheckerAbilitySystem_RetargetCharacter) == 0x000008, "Wrong alignment on GzAutotestStateCheckerAbilitySystem_RetargetCharacter");
static_assert(sizeof(GzAutotestStateCheckerAbilitySystem_RetargetCharacter) == 0x000008, "Wrong size on GzAutotestStateCheckerAbilitySystem_RetargetCharacter");
static_assert(offsetof(GzAutotestStateCheckerAbilitySystem_RetargetCharacter, NewTargetCharacter) == 0x000000, "Member 'GzAutotestStateCheckerAbilitySystem_RetargetCharacter::NewTargetCharacter' has a wrong offset!");

// Function G01.GzInteractableComponent.AddInteractableHighlightState
// 0x0002 (0x0002 - 0x0000)
struct GzInteractableComponent_AddInteractableHighlightState final
{
public:
	EGzInteractableHighlightState                 State;                                             // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EDepthStencilValue                            InHighlightStateStencilValue;                      // 0x0001(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzInteractableComponent_AddInteractableHighlightState) == 0x000001, "Wrong alignment on GzInteractableComponent_AddInteractableHighlightState");
static_assert(sizeof(GzInteractableComponent_AddInteractableHighlightState) == 0x000002, "Wrong size on GzInteractableComponent_AddInteractableHighlightState");
static_assert(offsetof(GzInteractableComponent_AddInteractableHighlightState, State) == 0x000000, "Member 'GzInteractableComponent_AddInteractableHighlightState::State' has a wrong offset!");
static_assert(offsetof(GzInteractableComponent_AddInteractableHighlightState, InHighlightStateStencilValue) == 0x000001, "Member 'GzInteractableComponent_AddInteractableHighlightState::InHighlightStateStencilValue' has a wrong offset!");

// Function G01.GzInteractableComponent.AddInteraction
// 0x0008 (0x0008 - 0x0000)
struct GzInteractableComponent_AddInteraction final
{
public:
	class UDefaultInteractionBehavior*            Interaction;                                       // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzInteractableComponent_AddInteraction) == 0x000008, "Wrong alignment on GzInteractableComponent_AddInteraction");
static_assert(sizeof(GzInteractableComponent_AddInteraction) == 0x000008, "Wrong size on GzInteractableComponent_AddInteraction");
static_assert(offsetof(GzInteractableComponent_AddInteraction, Interaction) == 0x000000, "Member 'GzInteractableComponent_AddInteraction::Interaction' has a wrong offset!");

// Function G01.GzInteractableComponent.RemoveInteractableHighlightState
// 0x0001 (0x0001 - 0x0000)
struct GzInteractableComponent_RemoveInteractableHighlightState final
{
public:
	EGzInteractableHighlightState                 State;                                             // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzInteractableComponent_RemoveInteractableHighlightState) == 0x000001, "Wrong alignment on GzInteractableComponent_RemoveInteractableHighlightState");
static_assert(sizeof(GzInteractableComponent_RemoveInteractableHighlightState) == 0x000001, "Wrong size on GzInteractableComponent_RemoveInteractableHighlightState");
static_assert(offsetof(GzInteractableComponent_RemoveInteractableHighlightState, State) == 0x000000, "Member 'GzInteractableComponent_RemoveInteractableHighlightState::State' has a wrong offset!");

// Function G01.GzInteractableComponent.SetInteractionAllowed
// 0x0001 (0x0001 - 0x0000)
struct GzInteractableComponent_SetInteractionAllowed final
{
public:
	bool                                          bNewInteractionAllowed;                            // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzInteractableComponent_SetInteractionAllowed) == 0x000001, "Wrong alignment on GzInteractableComponent_SetInteractionAllowed");
static_assert(sizeof(GzInteractableComponent_SetInteractionAllowed) == 0x000001, "Wrong size on GzInteractableComponent_SetInteractionAllowed");
static_assert(offsetof(GzInteractableComponent_SetInteractionAllowed, bNewInteractionAllowed) == 0x000000, "Member 'GzInteractableComponent_SetInteractionAllowed::bNewInteractionAllowed' has a wrong offset!");

// Function G01.GzInteractableComponent.ShiftToNextInteractionInterval
// 0x0008 (0x0008 - 0x0000)
struct GzInteractableComponent_ShiftToNextInteractionInterval final
{
public:
	class AGzCharacter*                           InteractedBy;                                      // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzInteractableComponent_ShiftToNextInteractionInterval) == 0x000008, "Wrong alignment on GzInteractableComponent_ShiftToNextInteractionInterval");
static_assert(sizeof(GzInteractableComponent_ShiftToNextInteractionInterval) == 0x000008, "Wrong size on GzInteractableComponent_ShiftToNextInteractionInterval");
static_assert(offsetof(GzInteractableComponent_ShiftToNextInteractionInterval, InteractedBy) == 0x000000, "Member 'GzInteractableComponent_ShiftToNextInteractionInterval::InteractedBy' has a wrong offset!");

// Function G01.GzInteractableComponent.FindInteractionDataByTag
// 0x0108 (0x0108 - 0x0000)
struct GzInteractableComponent_FindInteractionDataByTag final
{
public:
	struct FGameplayTag                           Tag;                                               // 0x0000(0x0008)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGzInteractionData                     OutInteractionData;                                // 0x0008(0x00F8)(Parm, OutParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0100(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2F49[0x7];                                     // 0x0101(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GzInteractableComponent_FindInteractionDataByTag) == 0x000008, "Wrong alignment on GzInteractableComponent_FindInteractionDataByTag");
static_assert(sizeof(GzInteractableComponent_FindInteractionDataByTag) == 0x000108, "Wrong size on GzInteractableComponent_FindInteractionDataByTag");
static_assert(offsetof(GzInteractableComponent_FindInteractionDataByTag, Tag) == 0x000000, "Member 'GzInteractableComponent_FindInteractionDataByTag::Tag' has a wrong offset!");
static_assert(offsetof(GzInteractableComponent_FindInteractionDataByTag, OutInteractionData) == 0x000008, "Member 'GzInteractableComponent_FindInteractionDataByTag::OutInteractionData' has a wrong offset!");
static_assert(offsetof(GzInteractableComponent_FindInteractionDataByTag, ReturnValue) == 0x000100, "Member 'GzInteractableComponent_FindInteractionDataByTag::ReturnValue' has a wrong offset!");

// Function G01.GzInteractableComponent.GetCurrentMontagePlayLength
// 0x0004 (0x0004 - 0x0000)
struct GzInteractableComponent_GetCurrentMontagePlayLength final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzInteractableComponent_GetCurrentMontagePlayLength) == 0x000004, "Wrong alignment on GzInteractableComponent_GetCurrentMontagePlayLength");
static_assert(sizeof(GzInteractableComponent_GetCurrentMontagePlayLength) == 0x000004, "Wrong size on GzInteractableComponent_GetCurrentMontagePlayLength");
static_assert(offsetof(GzInteractableComponent_GetCurrentMontagePlayLength, ReturnValue) == 0x000000, "Member 'GzInteractableComponent_GetCurrentMontagePlayLength::ReturnValue' has a wrong offset!");

// Function G01.GzInteractableComponent.GetInteractionDuration
// 0x0004 (0x0004 - 0x0000)
struct GzInteractableComponent_GetInteractionDuration final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzInteractableComponent_GetInteractionDuration) == 0x000004, "Wrong alignment on GzInteractableComponent_GetInteractionDuration");
static_assert(sizeof(GzInteractableComponent_GetInteractionDuration) == 0x000004, "Wrong size on GzInteractableComponent_GetInteractionDuration");
static_assert(offsetof(GzInteractableComponent_GetInteractionDuration, ReturnValue) == 0x000000, "Member 'GzInteractableComponent_GetInteractionDuration::ReturnValue' has a wrong offset!");

// Function G01.GzInteractableComponent.GetLastSavedInteractionProgress
// 0x0004 (0x0004 - 0x0000)
struct GzInteractableComponent_GetLastSavedInteractionProgress final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzInteractableComponent_GetLastSavedInteractionProgress) == 0x000004, "Wrong alignment on GzInteractableComponent_GetLastSavedInteractionProgress");
static_assert(sizeof(GzInteractableComponent_GetLastSavedInteractionProgress) == 0x000004, "Wrong size on GzInteractableComponent_GetLastSavedInteractionProgress");
static_assert(offsetof(GzInteractableComponent_GetLastSavedInteractionProgress, ReturnValue) == 0x000000, "Member 'GzInteractableComponent_GetLastSavedInteractionProgress::ReturnValue' has a wrong offset!");

// Function G01.GzInteractableComponent.GetResetProgressBarOnRelease
// 0x0001 (0x0001 - 0x0000)
struct GzInteractableComponent_GetResetProgressBarOnRelease final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzInteractableComponent_GetResetProgressBarOnRelease) == 0x000001, "Wrong alignment on GzInteractableComponent_GetResetProgressBarOnRelease");
static_assert(sizeof(GzInteractableComponent_GetResetProgressBarOnRelease) == 0x000001, "Wrong size on GzInteractableComponent_GetResetProgressBarOnRelease");
static_assert(offsetof(GzInteractableComponent_GetResetProgressBarOnRelease, ReturnValue) == 0x000000, "Member 'GzInteractableComponent_GetResetProgressBarOnRelease::ReturnValue' has a wrong offset!");

// Function G01.GzInteractableComponent.HasDefaultInteractionSetup
// 0x0001 (0x0001 - 0x0000)
struct GzInteractableComponent_HasDefaultInteractionSetup final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzInteractableComponent_HasDefaultInteractionSetup) == 0x000001, "Wrong alignment on GzInteractableComponent_HasDefaultInteractionSetup");
static_assert(sizeof(GzInteractableComponent_HasDefaultInteractionSetup) == 0x000001, "Wrong size on GzInteractableComponent_HasDefaultInteractionSetup");
static_assert(offsetof(GzInteractableComponent_HasDefaultInteractionSetup, ReturnValue) == 0x000000, "Member 'GzInteractableComponent_HasDefaultInteractionSetup::ReturnValue' has a wrong offset!");

// Function G01.GzInteractableComponent.IsInteractionCapturedBy
// 0x0010 (0x0010 - 0x0000)
struct GzInteractableComponent_IsInteractionCapturedBy final
{
public:
	const class AActor*                           InteractedBy;                                      // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2F4A[0x7];                                     // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GzInteractableComponent_IsInteractionCapturedBy) == 0x000008, "Wrong alignment on GzInteractableComponent_IsInteractionCapturedBy");
static_assert(sizeof(GzInteractableComponent_IsInteractionCapturedBy) == 0x000010, "Wrong size on GzInteractableComponent_IsInteractionCapturedBy");
static_assert(offsetof(GzInteractableComponent_IsInteractionCapturedBy, InteractedBy) == 0x000000, "Member 'GzInteractableComponent_IsInteractionCapturedBy::InteractedBy' has a wrong offset!");
static_assert(offsetof(GzInteractableComponent_IsInteractionCapturedBy, ReturnValue) == 0x000008, "Member 'GzInteractableComponent_IsInteractionCapturedBy::ReturnValue' has a wrong offset!");

// Function G01.GzInteractableComponent.OnRep_InteractionOwners
// 0x0010 (0x0010 - 0x0000)
struct GzInteractableComponent_OnRep_InteractionOwners final
{
public:
	TArray<class AActor*>                         OldInteractionOwners;                              // 0x0000(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzInteractableComponent_OnRep_InteractionOwners) == 0x000008, "Wrong alignment on GzInteractableComponent_OnRep_InteractionOwners");
static_assert(sizeof(GzInteractableComponent_OnRep_InteractionOwners) == 0x000010, "Wrong size on GzInteractableComponent_OnRep_InteractionOwners");
static_assert(offsetof(GzInteractableComponent_OnRep_InteractionOwners, OldInteractionOwners) == 0x000000, "Member 'GzInteractableComponent_OnRep_InteractionOwners::OldInteractionOwners' has a wrong offset!");

// Function G01.GzInteractableComponent.TryGetCurrentInteractionData
// 0x0100 (0x0100 - 0x0000)
struct GzInteractableComponent_TryGetCurrentInteractionData final
{
public:
	struct FGzInteractionData                     OutInteractionData;                                // 0x0000(0x00F8)(Parm, OutParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x00F8(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2F4B[0x7];                                     // 0x00F9(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GzInteractableComponent_TryGetCurrentInteractionData) == 0x000008, "Wrong alignment on GzInteractableComponent_TryGetCurrentInteractionData");
static_assert(sizeof(GzInteractableComponent_TryGetCurrentInteractionData) == 0x000100, "Wrong size on GzInteractableComponent_TryGetCurrentInteractionData");
static_assert(offsetof(GzInteractableComponent_TryGetCurrentInteractionData, OutInteractionData) == 0x000000, "Member 'GzInteractableComponent_TryGetCurrentInteractionData::OutInteractionData' has a wrong offset!");
static_assert(offsetof(GzInteractableComponent_TryGetCurrentInteractionData, ReturnValue) == 0x0000F8, "Member 'GzInteractableComponent_TryGetCurrentInteractionData::ReturnValue' has a wrong offset!");

// Function G01.GzNPCTeam.AddAttitudeTeam
// 0x0008 (0x0008 - 0x0000)
struct GzNPCTeam_AddAttitudeTeam final
{
public:
	ENPCTeamAttitude                              TeamAttitude;                                      // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2F51[0x3];                                     // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         TeamID;                                            // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzNPCTeam_AddAttitudeTeam) == 0x000004, "Wrong alignment on GzNPCTeam_AddAttitudeTeam");
static_assert(sizeof(GzNPCTeam_AddAttitudeTeam) == 0x000008, "Wrong size on GzNPCTeam_AddAttitudeTeam");
static_assert(offsetof(GzNPCTeam_AddAttitudeTeam, TeamAttitude) == 0x000000, "Member 'GzNPCTeam_AddAttitudeTeam::TeamAttitude' has a wrong offset!");
static_assert(offsetof(GzNPCTeam_AddAttitudeTeam, TeamID) == 0x000004, "Member 'GzNPCTeam_AddAttitudeTeam::TeamID' has a wrong offset!");

// Function G01.GzNPCTeam.AddFriendlyTeam
// 0x0004 (0x0004 - 0x0000)
struct GzNPCTeam_AddFriendlyTeam final
{
public:
	int32                                         TeamID;                                            // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzNPCTeam_AddFriendlyTeam) == 0x000004, "Wrong alignment on GzNPCTeam_AddFriendlyTeam");
static_assert(sizeof(GzNPCTeam_AddFriendlyTeam) == 0x000004, "Wrong size on GzNPCTeam_AddFriendlyTeam");
static_assert(offsetof(GzNPCTeam_AddFriendlyTeam, TeamID) == 0x000000, "Member 'GzNPCTeam_AddFriendlyTeam::TeamID' has a wrong offset!");

// Function G01.GzNPCTeam.AddHostileTeam
// 0x0004 (0x0004 - 0x0000)
struct GzNPCTeam_AddHostileTeam final
{
public:
	int32                                         TeamID;                                            // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzNPCTeam_AddHostileTeam) == 0x000004, "Wrong alignment on GzNPCTeam_AddHostileTeam");
static_assert(sizeof(GzNPCTeam_AddHostileTeam) == 0x000004, "Wrong size on GzNPCTeam_AddHostileTeam");
static_assert(offsetof(GzNPCTeam_AddHostileTeam, TeamID) == 0x000000, "Member 'GzNPCTeam_AddHostileTeam::TeamID' has a wrong offset!");

// Function G01.GzNPCTeam.AddNeutralTeam
// 0x0004 (0x0004 - 0x0000)
struct GzNPCTeam_AddNeutralTeam final
{
public:
	int32                                         TeamID;                                            // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzNPCTeam_AddNeutralTeam) == 0x000004, "Wrong alignment on GzNPCTeam_AddNeutralTeam");
static_assert(sizeof(GzNPCTeam_AddNeutralTeam) == 0x000004, "Wrong size on GzNPCTeam_AddNeutralTeam");
static_assert(offsetof(GzNPCTeam_AddNeutralTeam, TeamID) == 0x000000, "Member 'GzNPCTeam_AddNeutralTeam::TeamID' has a wrong offset!");

// Function G01.GzNPCTeam.AddNPC
// 0x0008 (0x0008 - 0x0000)
struct GzNPCTeam_AddNPC final
{
public:
	class AGzAIInfo*                              NPCAIInfo;                                         // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzNPCTeam_AddNPC) == 0x000008, "Wrong alignment on GzNPCTeam_AddNPC");
static_assert(sizeof(GzNPCTeam_AddNPC) == 0x000008, "Wrong size on GzNPCTeam_AddNPC");
static_assert(offsetof(GzNPCTeam_AddNPC, NPCAIInfo) == 0x000000, "Member 'GzNPCTeam_AddNPC::NPCAIInfo' has a wrong offset!");

// Function G01.GzNPCTeam.RemoveAttitudeTeam
// 0x0004 (0x0004 - 0x0000)
struct GzNPCTeam_RemoveAttitudeTeam final
{
public:
	int32                                         TeamID;                                            // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzNPCTeam_RemoveAttitudeTeam) == 0x000004, "Wrong alignment on GzNPCTeam_RemoveAttitudeTeam");
static_assert(sizeof(GzNPCTeam_RemoveAttitudeTeam) == 0x000004, "Wrong size on GzNPCTeam_RemoveAttitudeTeam");
static_assert(offsetof(GzNPCTeam_RemoveAttitudeTeam, TeamID) == 0x000000, "Member 'GzNPCTeam_RemoveAttitudeTeam::TeamID' has a wrong offset!");

// Function G01.GzNPCTeam.RemoveNPC
// 0x0008 (0x0008 - 0x0000)
struct GzNPCTeam_RemoveNPC final
{
public:
	class AGzAIInfo*                              NPCAIInfo;                                         // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzNPCTeam_RemoveNPC) == 0x000008, "Wrong alignment on GzNPCTeam_RemoveNPC");
static_assert(sizeof(GzNPCTeam_RemoveNPC) == 0x000008, "Wrong size on GzNPCTeam_RemoveNPC");
static_assert(offsetof(GzNPCTeam_RemoveNPC, NPCAIInfo) == 0x000000, "Member 'GzNPCTeam_RemoveNPC::NPCAIInfo' has a wrong offset!");

// Function G01.GzNPCTeam.SetDefaultTeamAttitude
// 0x0001 (0x0001 - 0x0000)
struct GzNPCTeam_SetDefaultTeamAttitude final
{
public:
	ENPCTeamAttitude                              InValue;                                           // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzNPCTeam_SetDefaultTeamAttitude) == 0x000001, "Wrong alignment on GzNPCTeam_SetDefaultTeamAttitude");
static_assert(sizeof(GzNPCTeam_SetDefaultTeamAttitude) == 0x000001, "Wrong size on GzNPCTeam_SetDefaultTeamAttitude");
static_assert(offsetof(GzNPCTeam_SetDefaultTeamAttitude, InValue) == 0x000000, "Member 'GzNPCTeam_SetDefaultTeamAttitude::InValue' has a wrong offset!");

// Function G01.GzNPCTeam.SetTeamName
// 0x0010 (0x0010 - 0x0000)
struct GzNPCTeam_SetTeamName final
{
public:
	class FString                                 InTeamName;                                        // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzNPCTeam_SetTeamName) == 0x000008, "Wrong alignment on GzNPCTeam_SetTeamName");
static_assert(sizeof(GzNPCTeam_SetTeamName) == 0x000010, "Wrong size on GzNPCTeam_SetTeamName");
static_assert(offsetof(GzNPCTeam_SetTeamName, InTeamName) == 0x000000, "Member 'GzNPCTeam_SetTeamName::InTeamName' has a wrong offset!");

// Function G01.GzNPCTeam.GetDefaultTeamAttitude
// 0x0001 (0x0001 - 0x0000)
struct GzNPCTeam_GetDefaultTeamAttitude final
{
public:
	ENPCTeamAttitude                              ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzNPCTeam_GetDefaultTeamAttitude) == 0x000001, "Wrong alignment on GzNPCTeam_GetDefaultTeamAttitude");
static_assert(sizeof(GzNPCTeam_GetDefaultTeamAttitude) == 0x000001, "Wrong size on GzNPCTeam_GetDefaultTeamAttitude");
static_assert(offsetof(GzNPCTeam_GetDefaultTeamAttitude, ReturnValue) == 0x000000, "Member 'GzNPCTeam_GetDefaultTeamAttitude::ReturnValue' has a wrong offset!");

// Function G01.GzNPCTeam.GetFriendsTeamsIds
// 0x0010 (0x0010 - 0x0000)
struct GzNPCTeam_GetFriendsTeamsIds final
{
public:
	TArray<int32>                                 TeamsIdsRef;                                       // 0x0000(0x0010)(Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzNPCTeam_GetFriendsTeamsIds) == 0x000008, "Wrong alignment on GzNPCTeam_GetFriendsTeamsIds");
static_assert(sizeof(GzNPCTeam_GetFriendsTeamsIds) == 0x000010, "Wrong size on GzNPCTeam_GetFriendsTeamsIds");
static_assert(offsetof(GzNPCTeam_GetFriendsTeamsIds, TeamsIdsRef) == 0x000000, "Member 'GzNPCTeam_GetFriendsTeamsIds::TeamsIdsRef' has a wrong offset!");

// Function G01.GzNPCTeam.GetNPCTeamAttitude
// 0x0008 (0x0008 - 0x0000)
struct GzNPCTeam_GetNPCTeamAttitude final
{
public:
	int32                                         TeamID;                                            // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ENPCTeamAttitude                              ReturnValue;                                       // 0x0004(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2F52[0x3];                                     // 0x0005(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GzNPCTeam_GetNPCTeamAttitude) == 0x000004, "Wrong alignment on GzNPCTeam_GetNPCTeamAttitude");
static_assert(sizeof(GzNPCTeam_GetNPCTeamAttitude) == 0x000008, "Wrong size on GzNPCTeam_GetNPCTeamAttitude");
static_assert(offsetof(GzNPCTeam_GetNPCTeamAttitude, TeamID) == 0x000000, "Member 'GzNPCTeam_GetNPCTeamAttitude::TeamID' has a wrong offset!");
static_assert(offsetof(GzNPCTeam_GetNPCTeamAttitude, ReturnValue) == 0x000004, "Member 'GzNPCTeam_GetNPCTeamAttitude::ReturnValue' has a wrong offset!");

// Function G01.GzNPCTeam.GetTeamAttitude
// 0x0008 (0x0008 - 0x0000)
struct GzNPCTeam_GetTeamAttitude final
{
public:
	int32                                         TeamID;                                            // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETeamAttitude                                 ReturnValue;                                       // 0x0004(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2F53[0x3];                                     // 0x0005(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GzNPCTeam_GetTeamAttitude) == 0x000004, "Wrong alignment on GzNPCTeam_GetTeamAttitude");
static_assert(sizeof(GzNPCTeam_GetTeamAttitude) == 0x000008, "Wrong size on GzNPCTeam_GetTeamAttitude");
static_assert(offsetof(GzNPCTeam_GetTeamAttitude, TeamID) == 0x000000, "Member 'GzNPCTeam_GetTeamAttitude::TeamID' has a wrong offset!");
static_assert(offsetof(GzNPCTeam_GetTeamAttitude, ReturnValue) == 0x000004, "Member 'GzNPCTeam_GetTeamAttitude::ReturnValue' has a wrong offset!");

// Function G01.GzNPCTeam.GetTeamId
// 0x0004 (0x0004 - 0x0000)
struct GzNPCTeam_GetTeamId final
{
public:
	int32                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzNPCTeam_GetTeamId) == 0x000004, "Wrong alignment on GzNPCTeam_GetTeamId");
static_assert(sizeof(GzNPCTeam_GetTeamId) == 0x000004, "Wrong size on GzNPCTeam_GetTeamId");
static_assert(offsetof(GzNPCTeam_GetTeamId, ReturnValue) == 0x000000, "Member 'GzNPCTeam_GetTeamId::ReturnValue' has a wrong offset!");

// Function G01.GzNPCTeam.GetTeamName
// 0x0010 (0x0010 - 0x0000)
struct GzNPCTeam_GetTeamName final
{
public:
	class FString                                 ReturnValue;                                       // 0x0000(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzNPCTeam_GetTeamName) == 0x000008, "Wrong alignment on GzNPCTeam_GetTeamName");
static_assert(sizeof(GzNPCTeam_GetTeamName) == 0x000010, "Wrong size on GzNPCTeam_GetTeamName");
static_assert(offsetof(GzNPCTeam_GetTeamName, ReturnValue) == 0x000000, "Member 'GzNPCTeam_GetTeamName::ReturnValue' has a wrong offset!");

// Function G01.GzNPCTeam.IsEmpty
// 0x0001 (0x0001 - 0x0000)
struct GzNPCTeam_IsEmpty final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzNPCTeam_IsEmpty) == 0x000001, "Wrong alignment on GzNPCTeam_IsEmpty");
static_assert(sizeof(GzNPCTeam_IsEmpty) == 0x000001, "Wrong size on GzNPCTeam_IsEmpty");
static_assert(offsetof(GzNPCTeam_IsEmpty, ReturnValue) == 0x000000, "Member 'GzNPCTeam_IsEmpty::ReturnValue' has a wrong offset!");

// Function G01.GzNPCTeam.IsFriendlyTeam
// 0x0008 (0x0008 - 0x0000)
struct GzNPCTeam_IsFriendlyTeam final
{
public:
	int32                                         TeamID;                                            // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0004(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2F54[0x3];                                     // 0x0005(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GzNPCTeam_IsFriendlyTeam) == 0x000004, "Wrong alignment on GzNPCTeam_IsFriendlyTeam");
static_assert(sizeof(GzNPCTeam_IsFriendlyTeam) == 0x000008, "Wrong size on GzNPCTeam_IsFriendlyTeam");
static_assert(offsetof(GzNPCTeam_IsFriendlyTeam, TeamID) == 0x000000, "Member 'GzNPCTeam_IsFriendlyTeam::TeamID' has a wrong offset!");
static_assert(offsetof(GzNPCTeam_IsFriendlyTeam, ReturnValue) == 0x000004, "Member 'GzNPCTeam_IsFriendlyTeam::ReturnValue' has a wrong offset!");

// Function G01.GzNPCTeam.IsHostileTeam
// 0x0008 (0x0008 - 0x0000)
struct GzNPCTeam_IsHostileTeam final
{
public:
	int32                                         TeamID;                                            // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0004(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2F55[0x3];                                     // 0x0005(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GzNPCTeam_IsHostileTeam) == 0x000004, "Wrong alignment on GzNPCTeam_IsHostileTeam");
static_assert(sizeof(GzNPCTeam_IsHostileTeam) == 0x000008, "Wrong size on GzNPCTeam_IsHostileTeam");
static_assert(offsetof(GzNPCTeam_IsHostileTeam, TeamID) == 0x000000, "Member 'GzNPCTeam_IsHostileTeam::TeamID' has a wrong offset!");
static_assert(offsetof(GzNPCTeam_IsHostileTeam, ReturnValue) == 0x000004, "Member 'GzNPCTeam_IsHostileTeam::ReturnValue' has a wrong offset!");

// Function G01.GzNPCTeam.IsNeutralTeam
// 0x0008 (0x0008 - 0x0000)
struct GzNPCTeam_IsNeutralTeam final
{
public:
	int32                                         TeamID;                                            // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0004(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2F56[0x3];                                     // 0x0005(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GzNPCTeam_IsNeutralTeam) == 0x000004, "Wrong alignment on GzNPCTeam_IsNeutralTeam");
static_assert(sizeof(GzNPCTeam_IsNeutralTeam) == 0x000008, "Wrong size on GzNPCTeam_IsNeutralTeam");
static_assert(offsetof(GzNPCTeam_IsNeutralTeam, TeamID) == 0x000000, "Member 'GzNPCTeam_IsNeutralTeam::TeamID' has a wrong offset!");
static_assert(offsetof(GzNPCTeam_IsNeutralTeam, ReturnValue) == 0x000004, "Member 'GzNPCTeam_IsNeutralTeam::ReturnValue' has a wrong offset!");

// Function G01.GzAutotestStateCheckerCustom.SetCondtionState
// 0x0001 (0x0001 - 0x0000)
struct GzAutotestStateCheckerCustom_SetCondtionState final
{
public:
	EGzCustomCheckingState                        CheckingState;                                     // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzAutotestStateCheckerCustom_SetCondtionState) == 0x000001, "Wrong alignment on GzAutotestStateCheckerCustom_SetCondtionState");
static_assert(sizeof(GzAutotestStateCheckerCustom_SetCondtionState) == 0x000001, "Wrong size on GzAutotestStateCheckerCustom_SetCondtionState");
static_assert(offsetof(GzAutotestStateCheckerCustom_SetCondtionState, CheckingState) == 0x000000, "Member 'GzAutotestStateCheckerCustom_SetCondtionState::CheckingState' has a wrong offset!");

// Function G01.GzTeamSubsystem.CanChangeTeam
// 0x0010 (0x0010 - 0x0000)
struct GzTeamSubsystem_CanChangeTeam final
{
public:
	const class AGzPlayerState*                   Player;                                            // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         NewTeamId;                                         // 0x0008(0x0004)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x000C(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2F59[0x3];                                     // 0x000D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GzTeamSubsystem_CanChangeTeam) == 0x000008, "Wrong alignment on GzTeamSubsystem_CanChangeTeam");
static_assert(sizeof(GzTeamSubsystem_CanChangeTeam) == 0x000010, "Wrong size on GzTeamSubsystem_CanChangeTeam");
static_assert(offsetof(GzTeamSubsystem_CanChangeTeam, Player) == 0x000000, "Member 'GzTeamSubsystem_CanChangeTeam::Player' has a wrong offset!");
static_assert(offsetof(GzTeamSubsystem_CanChangeTeam, NewTeamId) == 0x000008, "Member 'GzTeamSubsystem_CanChangeTeam::NewTeamId' has a wrong offset!");
static_assert(offsetof(GzTeamSubsystem_CanChangeTeam, ReturnValue) == 0x00000C, "Member 'GzTeamSubsystem_CanChangeTeam::ReturnValue' has a wrong offset!");

// Function G01.GzTeamSubsystem.GetMaxTeamCapacity
// 0x0004 (0x0004 - 0x0000)
struct GzTeamSubsystem_GetMaxTeamCapacity final
{
public:
	int32                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzTeamSubsystem_GetMaxTeamCapacity) == 0x000004, "Wrong alignment on GzTeamSubsystem_GetMaxTeamCapacity");
static_assert(sizeof(GzTeamSubsystem_GetMaxTeamCapacity) == 0x000004, "Wrong size on GzTeamSubsystem_GetMaxTeamCapacity");
static_assert(offsetof(GzTeamSubsystem_GetMaxTeamCapacity, ReturnValue) == 0x000000, "Member 'GzTeamSubsystem_GetMaxTeamCapacity::ReturnValue' has a wrong offset!");

// Function G01.GzTeamSubsystem.GetMaxTeamCount
// 0x0004 (0x0004 - 0x0000)
struct GzTeamSubsystem_GetMaxTeamCount final
{
public:
	int32                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzTeamSubsystem_GetMaxTeamCount) == 0x000004, "Wrong alignment on GzTeamSubsystem_GetMaxTeamCount");
static_assert(sizeof(GzTeamSubsystem_GetMaxTeamCount) == 0x000004, "Wrong size on GzTeamSubsystem_GetMaxTeamCount");
static_assert(offsetof(GzTeamSubsystem_GetMaxTeamCount, ReturnValue) == 0x000000, "Member 'GzTeamSubsystem_GetMaxTeamCount::ReturnValue' has a wrong offset!");

// Function G01.GzTeamSubsystem.GetTeam
// 0x0010 (0x0010 - 0x0000)
struct GzTeamSubsystem_GetTeam final
{
public:
	int32                                         TeamID;                                            // 0x0000(0x0004)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2F5A[0x4];                                     // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class AGzTeam*                                ReturnValue;                                       // 0x0008(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzTeamSubsystem_GetTeam) == 0x000008, "Wrong alignment on GzTeamSubsystem_GetTeam");
static_assert(sizeof(GzTeamSubsystem_GetTeam) == 0x000010, "Wrong size on GzTeamSubsystem_GetTeam");
static_assert(offsetof(GzTeamSubsystem_GetTeam, TeamID) == 0x000000, "Member 'GzTeamSubsystem_GetTeam::TeamID' has a wrong offset!");
static_assert(offsetof(GzTeamSubsystem_GetTeam, ReturnValue) == 0x000008, "Member 'GzTeamSubsystem_GetTeam::ReturnValue' has a wrong offset!");

// Function G01.GzTeamSubsystem.GetTeams
// 0x0010 (0x0010 - 0x0000)
struct GzTeamSubsystem_GetTeams final
{
public:
	TArray<class AGzTeam*>                        ReturnValue;                                       // 0x0000(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzTeamSubsystem_GetTeams) == 0x000008, "Wrong alignment on GzTeamSubsystem_GetTeams");
static_assert(sizeof(GzTeamSubsystem_GetTeams) == 0x000010, "Wrong size on GzTeamSubsystem_GetTeams");
static_assert(offsetof(GzTeamSubsystem_GetTeams, ReturnValue) == 0x000000, "Member 'GzTeamSubsystem_GetTeams::ReturnValue' has a wrong offset!");

// Function G01.GzTeamSubsystem.GetTeamsCount
// 0x0004 (0x0004 - 0x0000)
struct GzTeamSubsystem_GetTeamsCount final
{
public:
	int32                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzTeamSubsystem_GetTeamsCount) == 0x000004, "Wrong alignment on GzTeamSubsystem_GetTeamsCount");
static_assert(sizeof(GzTeamSubsystem_GetTeamsCount) == 0x000004, "Wrong size on GzTeamSubsystem_GetTeamsCount");
static_assert(offsetof(GzTeamSubsystem_GetTeamsCount, ReturnValue) == 0x000000, "Member 'GzTeamSubsystem_GetTeamsCount::ReturnValue' has a wrong offset!");

// Function G01.GzTeamSubsystem.IsTeamExist
// 0x0008 (0x0008 - 0x0000)
struct GzTeamSubsystem_IsTeamExist final
{
public:
	int32                                         TeamID;                                            // 0x0000(0x0004)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0004(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2F5B[0x3];                                     // 0x0005(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GzTeamSubsystem_IsTeamExist) == 0x000004, "Wrong alignment on GzTeamSubsystem_IsTeamExist");
static_assert(sizeof(GzTeamSubsystem_IsTeamExist) == 0x000008, "Wrong size on GzTeamSubsystem_IsTeamExist");
static_assert(offsetof(GzTeamSubsystem_IsTeamExist, TeamID) == 0x000000, "Member 'GzTeamSubsystem_IsTeamExist::TeamID' has a wrong offset!");
static_assert(offsetof(GzTeamSubsystem_IsTeamExist, ReturnValue) == 0x000004, "Member 'GzTeamSubsystem_IsTeamExist::ReturnValue' has a wrong offset!");

// Function G01.GzTargetType.GetTargets
// 0x00F0 (0x00F0 - 0x0000)
struct GzTargetType_GetTargets final
{
public:
	class AGzCharacter*                           TargetingCharacter;                                // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 TargetingActor;                                    // 0x0008(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayEventData                     EventData;                                         // 0x0010(0x00B0)(Parm, NativeAccessSpecifierPublic)
	TArray<struct FGameplayAbilityTargetDataHandle> OutTargetData;                                     // 0x00C0(0x0010)(Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FHitResult>                     OutHitResults;                                     // 0x00D0(0x0010)(Parm, OutParm, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	TArray<class AActor*>                         OutActors;                                         // 0x00E0(0x0010)(Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzTargetType_GetTargets) == 0x000008, "Wrong alignment on GzTargetType_GetTargets");
static_assert(sizeof(GzTargetType_GetTargets) == 0x0000F0, "Wrong size on GzTargetType_GetTargets");
static_assert(offsetof(GzTargetType_GetTargets, TargetingCharacter) == 0x000000, "Member 'GzTargetType_GetTargets::TargetingCharacter' has a wrong offset!");
static_assert(offsetof(GzTargetType_GetTargets, TargetingActor) == 0x000008, "Member 'GzTargetType_GetTargets::TargetingActor' has a wrong offset!");
static_assert(offsetof(GzTargetType_GetTargets, EventData) == 0x000010, "Member 'GzTargetType_GetTargets::EventData' has a wrong offset!");
static_assert(offsetof(GzTargetType_GetTargets, OutTargetData) == 0x0000C0, "Member 'GzTargetType_GetTargets::OutTargetData' has a wrong offset!");
static_assert(offsetof(GzTargetType_GetTargets, OutHitResults) == 0x0000D0, "Member 'GzTargetType_GetTargets::OutHitResults' has a wrong offset!");
static_assert(offsetof(GzTargetType_GetTargets, OutActors) == 0x0000E0, "Member 'GzTargetType_GetTargets::OutActors' has a wrong offset!");

// Function G01.GzTrackTransport.EnableSplineAlignment
// 0x0001 (0x0001 - 0x0000)
struct GzTrackTransport_EnableSplineAlignment final
{
public:
	bool                                          bEnable;                                           // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzTrackTransport_EnableSplineAlignment) == 0x000001, "Wrong alignment on GzTrackTransport_EnableSplineAlignment");
static_assert(sizeof(GzTrackTransport_EnableSplineAlignment) == 0x000001, "Wrong size on GzTrackTransport_EnableSplineAlignment");
static_assert(offsetof(GzTrackTransport_EnableSplineAlignment, bEnable) == 0x000000, "Member 'GzTrackTransport_EnableSplineAlignment::bEnable' has a wrong offset!");

// Function G01.GzTrackTransport.OnRep_CurrentDistance
// 0x0010 (0x0010 - 0x0000)
struct GzTrackTransport_OnRep_CurrentDistance final
{
public:
	struct FGzTrackDistance                       OldDistance;                                       // 0x0000(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzTrackTransport_OnRep_CurrentDistance) == 0x000008, "Wrong alignment on GzTrackTransport_OnRep_CurrentDistance");
static_assert(sizeof(GzTrackTransport_OnRep_CurrentDistance) == 0x000010, "Wrong size on GzTrackTransport_OnRep_CurrentDistance");
static_assert(offsetof(GzTrackTransport_OnRep_CurrentDistance, OldDistance) == 0x000000, "Member 'GzTrackTransport_OnRep_CurrentDistance::OldDistance' has a wrong offset!");

// Function G01.GzTrackTransport.OnRep_Track
// 0x0008 (0x0008 - 0x0000)
struct GzTrackTransport_OnRep_Track final
{
public:
	class AGzTrack*                               OldTrack;                                          // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzTrackTransport_OnRep_Track) == 0x000008, "Wrong alignment on GzTrackTransport_OnRep_Track");
static_assert(sizeof(GzTrackTransport_OnRep_Track) == 0x000008, "Wrong size on GzTrackTransport_OnRep_Track");
static_assert(offsetof(GzTrackTransport_OnRep_Track, OldTrack) == 0x000000, "Member 'GzTrackTransport_OnRep_Track::OldTrack' has a wrong offset!");

// Function G01.GzTrackTransport.SetMaxSpeed
// 0x0004 (0x0004 - 0x0000)
struct GzTrackTransport_SetMaxSpeed final
{
public:
	float                                         InMaxSpeed;                                        // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzTrackTransport_SetMaxSpeed) == 0x000004, "Wrong alignment on GzTrackTransport_SetMaxSpeed");
static_assert(sizeof(GzTrackTransport_SetMaxSpeed) == 0x000004, "Wrong size on GzTrackTransport_SetMaxSpeed");
static_assert(offsetof(GzTrackTransport_SetMaxSpeed, InMaxSpeed) == 0x000000, "Member 'GzTrackTransport_SetMaxSpeed::InMaxSpeed' has a wrong offset!");

// Function G01.GzTrackTransport.StopMoving
// 0x0004 (0x0004 - 0x0000)
struct GzTrackTransport_StopMoving final
{
public:
	float                                         StopDistance;                                      // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzTrackTransport_StopMoving) == 0x000004, "Wrong alignment on GzTrackTransport_StopMoving");
static_assert(sizeof(GzTrackTransport_StopMoving) == 0x000004, "Wrong size on GzTrackTransport_StopMoving");
static_assert(offsetof(GzTrackTransport_StopMoving, StopDistance) == 0x000000, "Member 'GzTrackTransport_StopMoving::StopDistance' has a wrong offset!");

// Function G01.GzTrackTransport.GetCurrentSpeed
// 0x0004 (0x0004 - 0x0000)
struct GzTrackTransport_GetCurrentSpeed final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzTrackTransport_GetCurrentSpeed) == 0x000004, "Wrong alignment on GzTrackTransport_GetCurrentSpeed");
static_assert(sizeof(GzTrackTransport_GetCurrentSpeed) == 0x000004, "Wrong size on GzTrackTransport_GetCurrentSpeed");
static_assert(offsetof(GzTrackTransport_GetCurrentSpeed, ReturnValue) == 0x000000, "Member 'GzTrackTransport_GetCurrentSpeed::ReturnValue' has a wrong offset!");

// Function G01.GzTrackTransport.GetDistanceAlongSpline
// 0x0008 (0x0008 - 0x0000)
struct GzTrackTransport_GetDistanceAlongSpline final
{
public:
	double                                        ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzTrackTransport_GetDistanceAlongSpline) == 0x000008, "Wrong alignment on GzTrackTransport_GetDistanceAlongSpline");
static_assert(sizeof(GzTrackTransport_GetDistanceAlongSpline) == 0x000008, "Wrong size on GzTrackTransport_GetDistanceAlongSpline");
static_assert(offsetof(GzTrackTransport_GetDistanceAlongSpline, ReturnValue) == 0x000000, "Member 'GzTrackTransport_GetDistanceAlongSpline::ReturnValue' has a wrong offset!");

// Function G01.GzTrackTransport.GetDistanceAlongTrack
// 0x0008 (0x0008 - 0x0000)
struct GzTrackTransport_GetDistanceAlongTrack final
{
public:
	double                                        ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzTrackTransport_GetDistanceAlongTrack) == 0x000008, "Wrong alignment on GzTrackTransport_GetDistanceAlongTrack");
static_assert(sizeof(GzTrackTransport_GetDistanceAlongTrack) == 0x000008, "Wrong size on GzTrackTransport_GetDistanceAlongTrack");
static_assert(offsetof(GzTrackTransport_GetDistanceAlongTrack, ReturnValue) == 0x000000, "Member 'GzTrackTransport_GetDistanceAlongTrack::ReturnValue' has a wrong offset!");

// Function G01.GzTrackTransport.GetTargetSpeed
// 0x0004 (0x0004 - 0x0000)
struct GzTrackTransport_GetTargetSpeed final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzTrackTransport_GetTargetSpeed) == 0x000004, "Wrong alignment on GzTrackTransport_GetTargetSpeed");
static_assert(sizeof(GzTrackTransport_GetTargetSpeed) == 0x000004, "Wrong size on GzTrackTransport_GetTargetSpeed");
static_assert(offsetof(GzTrackTransport_GetTargetSpeed, ReturnValue) == 0x000000, "Member 'GzTrackTransport_GetTargetSpeed::ReturnValue' has a wrong offset!");

// Function G01.GzTrackTransport.GetTurnInclineRoll
// 0x0004 (0x0004 - 0x0000)
struct GzTrackTransport_GetTurnInclineRoll final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzTrackTransport_GetTurnInclineRoll) == 0x000004, "Wrong alignment on GzTrackTransport_GetTurnInclineRoll");
static_assert(sizeof(GzTrackTransport_GetTurnInclineRoll) == 0x000004, "Wrong size on GzTrackTransport_GetTurnInclineRoll");
static_assert(offsetof(GzTrackTransport_GetTurnInclineRoll, ReturnValue) == 0x000000, "Member 'GzTrackTransport_GetTurnInclineRoll::ReturnValue' has a wrong offset!");

// Function G01.GzTrackTransport.HasReachedTarget
// 0x0001 (0x0001 - 0x0000)
struct GzTrackTransport_HasReachedTarget final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzTrackTransport_HasReachedTarget) == 0x000001, "Wrong alignment on GzTrackTransport_HasReachedTarget");
static_assert(sizeof(GzTrackTransport_HasReachedTarget) == 0x000001, "Wrong size on GzTrackTransport_HasReachedTarget");
static_assert(offsetof(GzTrackTransport_HasReachedTarget, ReturnValue) == 0x000000, "Member 'GzTrackTransport_HasReachedTarget::ReturnValue' has a wrong offset!");

// Function G01.GzAutoTrackTransport.ReceiveWaitOnStop
// 0x0004 (0x0004 - 0x0000)
struct GzAutoTrackTransport_ReceiveWaitOnStop final
{
public:
	int32                                         Stop;                                              // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzAutoTrackTransport_ReceiveWaitOnStop) == 0x000004, "Wrong alignment on GzAutoTrackTransport_ReceiveWaitOnStop");
static_assert(sizeof(GzAutoTrackTransport_ReceiveWaitOnStop) == 0x000004, "Wrong size on GzAutoTrackTransport_ReceiveWaitOnStop");
static_assert(offsetof(GzAutoTrackTransport_ReceiveWaitOnStop, Stop) == 0x000000, "Member 'GzAutoTrackTransport_ReceiveWaitOnStop::Stop' has a wrong offset!");

// Function G01.GzAutoTrackTransport.GetArrivalTimeToNextStop
// 0x0004 (0x0004 - 0x0000)
struct GzAutoTrackTransport_GetArrivalTimeToNextStop final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzAutoTrackTransport_GetArrivalTimeToNextStop) == 0x000004, "Wrong alignment on GzAutoTrackTransport_GetArrivalTimeToNextStop");
static_assert(sizeof(GzAutoTrackTransport_GetArrivalTimeToNextStop) == 0x000004, "Wrong size on GzAutoTrackTransport_GetArrivalTimeToNextStop");
static_assert(offsetof(GzAutoTrackTransport_GetArrivalTimeToNextStop, ReturnValue) == 0x000000, "Member 'GzAutoTrackTransport_GetArrivalTimeToNextStop::ReturnValue' has a wrong offset!");

// Function G01.GzAutoTrackTransport.GetArrivalTimeToStop
// 0x0008 (0x0008 - 0x0000)
struct GzAutoTrackTransport_GetArrivalTimeToStop final
{
public:
	int32                                         InStopIndex;                                       // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ReturnValue;                                       // 0x0004(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzAutoTrackTransport_GetArrivalTimeToStop) == 0x000004, "Wrong alignment on GzAutoTrackTransport_GetArrivalTimeToStop");
static_assert(sizeof(GzAutoTrackTransport_GetArrivalTimeToStop) == 0x000008, "Wrong size on GzAutoTrackTransport_GetArrivalTimeToStop");
static_assert(offsetof(GzAutoTrackTransport_GetArrivalTimeToStop, InStopIndex) == 0x000000, "Member 'GzAutoTrackTransport_GetArrivalTimeToStop::InStopIndex' has a wrong offset!");
static_assert(offsetof(GzAutoTrackTransport_GetArrivalTimeToStop, ReturnValue) == 0x000004, "Member 'GzAutoTrackTransport_GetArrivalTimeToStop::ReturnValue' has a wrong offset!");

// Function G01.GzAutoTrackTransport.GetDistanceToNextStop
// 0x0008 (0x0008 - 0x0000)
struct GzAutoTrackTransport_GetDistanceToNextStop final
{
public:
	double                                        ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzAutoTrackTransport_GetDistanceToNextStop) == 0x000008, "Wrong alignment on GzAutoTrackTransport_GetDistanceToNextStop");
static_assert(sizeof(GzAutoTrackTransport_GetDistanceToNextStop) == 0x000008, "Wrong size on GzAutoTrackTransport_GetDistanceToNextStop");
static_assert(offsetof(GzAutoTrackTransport_GetDistanceToNextStop, ReturnValue) == 0x000000, "Member 'GzAutoTrackTransport_GetDistanceToNextStop::ReturnValue' has a wrong offset!");

// Function G01.Gz_BTService_MentalStateSelection.ChooseAndSetTarget
// 0x0004 (0x0004 - 0x0000)
struct Gz_BTService_MentalStateSelection_ChooseAndSetTarget final
{
public:
	float                                         DeltaTime;                                         // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(Gz_BTService_MentalStateSelection_ChooseAndSetTarget) == 0x000004, "Wrong alignment on Gz_BTService_MentalStateSelection_ChooseAndSetTarget");
static_assert(sizeof(Gz_BTService_MentalStateSelection_ChooseAndSetTarget) == 0x000004, "Wrong size on Gz_BTService_MentalStateSelection_ChooseAndSetTarget");
static_assert(offsetof(Gz_BTService_MentalStateSelection_ChooseAndSetTarget, DeltaTime) == 0x000000, "Member 'Gz_BTService_MentalStateSelection_ChooseAndSetTarget::DeltaTime' has a wrong offset!");

// Function G01.Gz_BTService_MentalStateSelection.GetBlackboardComponent
// 0x0008 (0x0008 - 0x0000)
struct Gz_BTService_MentalStateSelection_GetBlackboardComponent final
{
public:
	class UBlackboardComponent*                   ReturnValue;                                       // 0x0000(0x0008)(ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(Gz_BTService_MentalStateSelection_GetBlackboardComponent) == 0x000008, "Wrong alignment on Gz_BTService_MentalStateSelection_GetBlackboardComponent");
static_assert(sizeof(Gz_BTService_MentalStateSelection_GetBlackboardComponent) == 0x000008, "Wrong size on Gz_BTService_MentalStateSelection_GetBlackboardComponent");
static_assert(offsetof(Gz_BTService_MentalStateSelection_GetBlackboardComponent, ReturnValue) == 0x000000, "Member 'Gz_BTService_MentalStateSelection_GetBlackboardComponent::ReturnValue' has a wrong offset!");

// Function G01.Gz_BTService_MentalStateSelection.GetGzAIController
// 0x0008 (0x0008 - 0x0000)
struct Gz_BTService_MentalStateSelection_GetGzAIController final
{
public:
	class AGzAIController*                        ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(Gz_BTService_MentalStateSelection_GetGzAIController) == 0x000008, "Wrong alignment on Gz_BTService_MentalStateSelection_GetGzAIController");
static_assert(sizeof(Gz_BTService_MentalStateSelection_GetGzAIController) == 0x000008, "Wrong size on Gz_BTService_MentalStateSelection_GetGzAIController");
static_assert(offsetof(Gz_BTService_MentalStateSelection_GetGzAIController, ReturnValue) == 0x000000, "Member 'Gz_BTService_MentalStateSelection_GetGzAIController::ReturnValue' has a wrong offset!");

// Function G01.Gz_BTService_MentalStateSelection.SetMentalState
// 0x0001 (0x0001 - 0x0000)
struct Gz_BTService_MentalStateSelection_SetMentalState final
{
public:
	EGzMentalState                                GzMentalState;                                     // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(Gz_BTService_MentalStateSelection_SetMentalState) == 0x000001, "Wrong alignment on Gz_BTService_MentalStateSelection_SetMentalState");
static_assert(sizeof(Gz_BTService_MentalStateSelection_SetMentalState) == 0x000001, "Wrong size on Gz_BTService_MentalStateSelection_SetMentalState");
static_assert(offsetof(Gz_BTService_MentalStateSelection_SetMentalState, GzMentalState) == 0x000000, "Member 'Gz_BTService_MentalStateSelection_SetMentalState::GzMentalState' has a wrong offset!");

// Function G01.Gz_BTService_MentalStateSelection.SetStimulusLocation
// 0x0018 (0x0018 - 0x0000)
struct Gz_BTService_MentalStateSelection_SetStimulusLocation final
{
public:
	struct FVector                                StimulusLocationRef;                               // 0x0000(0x0018)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(Gz_BTService_MentalStateSelection_SetStimulusLocation) == 0x000008, "Wrong alignment on Gz_BTService_MentalStateSelection_SetStimulusLocation");
static_assert(sizeof(Gz_BTService_MentalStateSelection_SetStimulusLocation) == 0x000018, "Wrong size on Gz_BTService_MentalStateSelection_SetStimulusLocation");
static_assert(offsetof(Gz_BTService_MentalStateSelection_SetStimulusLocation, StimulusLocationRef) == 0x000000, "Member 'Gz_BTService_MentalStateSelection_SetStimulusLocation::StimulusLocationRef' has a wrong offset!");

// Function G01.Gz_BTService_MentalStateSelection.SetTargetEnemy
// 0x0008 (0x0008 - 0x0000)
struct Gz_BTService_MentalStateSelection_SetTargetEnemy final
{
public:
	class AActor*                                 TargetEnemyPtr;                                    // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(Gz_BTService_MentalStateSelection_SetTargetEnemy) == 0x000008, "Wrong alignment on Gz_BTService_MentalStateSelection_SetTargetEnemy");
static_assert(sizeof(Gz_BTService_MentalStateSelection_SetTargetEnemy) == 0x000008, "Wrong size on Gz_BTService_MentalStateSelection_SetTargetEnemy");
static_assert(offsetof(Gz_BTService_MentalStateSelection_SetTargetEnemy, TargetEnemyPtr) == 0x000000, "Member 'Gz_BTService_MentalStateSelection_SetTargetEnemy::TargetEnemyPtr' has a wrong offset!");

// Function G01.Gz_BTService_MentalStateSelection.SetTargetVisible
// 0x0001 (0x0001 - 0x0000)
struct Gz_BTService_MentalStateSelection_SetTargetVisible final
{
public:
	bool                                          bVisible;                                          // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(Gz_BTService_MentalStateSelection_SetTargetVisible) == 0x000001, "Wrong alignment on Gz_BTService_MentalStateSelection_SetTargetVisible");
static_assert(sizeof(Gz_BTService_MentalStateSelection_SetTargetVisible) == 0x000001, "Wrong size on Gz_BTService_MentalStateSelection_SetTargetVisible");
static_assert(offsetof(Gz_BTService_MentalStateSelection_SetTargetVisible, bVisible) == 0x000000, "Member 'Gz_BTService_MentalStateSelection_SetTargetVisible::bVisible' has a wrong offset!");

// Function G01.GzKillLogEntryWidget.SetActionInfo
// 0x0018 (0x0018 - 0x0000)
struct GzKillLogEntryWidget_SetActionInfo final
{
public:
	class FText                                   ActionText;                                        // 0x0000(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	struct FGzAdvancedIdType                      InVictimId;                                        // 0x0010(0x0008)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzKillLogEntryWidget_SetActionInfo) == 0x000008, "Wrong alignment on GzKillLogEntryWidget_SetActionInfo");
static_assert(sizeof(GzKillLogEntryWidget_SetActionInfo) == 0x000018, "Wrong size on GzKillLogEntryWidget_SetActionInfo");
static_assert(offsetof(GzKillLogEntryWidget_SetActionInfo, ActionText) == 0x000000, "Member 'GzKillLogEntryWidget_SetActionInfo::ActionText' has a wrong offset!");
static_assert(offsetof(GzKillLogEntryWidget_SetActionInfo, InVictimId) == 0x000010, "Member 'GzKillLogEntryWidget_SetActionInfo::InVictimId' has a wrong offset!");

// Function G01.GzKillLogEntryWidget.GetVictimId
// 0x0008 (0x0008 - 0x0000)
struct GzKillLogEntryWidget_GetVictimId final
{
public:
	struct FGzAdvancedIdType                      ReturnValue;                                       // 0x0000(0x0008)(ConstParm, Parm, OutParm, ReturnParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzKillLogEntryWidget_GetVictimId) == 0x000004, "Wrong alignment on GzKillLogEntryWidget_GetVictimId");
static_assert(sizeof(GzKillLogEntryWidget_GetVictimId) == 0x000008, "Wrong size on GzKillLogEntryWidget_GetVictimId");
static_assert(offsetof(GzKillLogEntryWidget_GetVictimId, ReturnValue) == 0x000000, "Member 'GzKillLogEntryWidget_GetVictimId::ReturnValue' has a wrong offset!");

// Function G01.GzGA_WeaponReload.OnReloadEvent
// 0x0008 (0x0008 - 0x0000)
struct GzGA_WeaponReload_OnReloadEvent final
{
public:
	class FName                                   NotifyName;                                        // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzGA_WeaponReload_OnReloadEvent) == 0x000004, "Wrong alignment on GzGA_WeaponReload_OnReloadEvent");
static_assert(sizeof(GzGA_WeaponReload_OnReloadEvent) == 0x000008, "Wrong size on GzGA_WeaponReload_OnReloadEvent");
static_assert(offsetof(GzGA_WeaponReload_OnReloadEvent, NotifyName) == 0x000000, "Member 'GzGA_WeaponReload_OnReloadEvent::NotifyName' has a wrong offset!");

// Function G01.GzCharacterControlsComponent.HandleLookUp
// 0x0004 (0x0004 - 0x0000)
struct GzCharacterControlsComponent_HandleLookUp final
{
public:
	float                                         Value;                                             // 0x0000(0x0004)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzCharacterControlsComponent_HandleLookUp) == 0x000004, "Wrong alignment on GzCharacterControlsComponent_HandleLookUp");
static_assert(sizeof(GzCharacterControlsComponent_HandleLookUp) == 0x000004, "Wrong size on GzCharacterControlsComponent_HandleLookUp");
static_assert(offsetof(GzCharacterControlsComponent_HandleLookUp, Value) == 0x000000, "Member 'GzCharacterControlsComponent_HandleLookUp::Value' has a wrong offset!");

// Function G01.GzCharacterControlsComponent.HandleMoveForward
// 0x0004 (0x0004 - 0x0000)
struct GzCharacterControlsComponent_HandleMoveForward final
{
public:
	float                                         Value;                                             // 0x0000(0x0004)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzCharacterControlsComponent_HandleMoveForward) == 0x000004, "Wrong alignment on GzCharacterControlsComponent_HandleMoveForward");
static_assert(sizeof(GzCharacterControlsComponent_HandleMoveForward) == 0x000004, "Wrong size on GzCharacterControlsComponent_HandleMoveForward");
static_assert(offsetof(GzCharacterControlsComponent_HandleMoveForward, Value) == 0x000000, "Member 'GzCharacterControlsComponent_HandleMoveForward::Value' has a wrong offset!");

// Function G01.GzCharacterControlsComponent.HandleMoveRight
// 0x0004 (0x0004 - 0x0000)
struct GzCharacterControlsComponent_HandleMoveRight final
{
public:
	float                                         Value;                                             // 0x0000(0x0004)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzCharacterControlsComponent_HandleMoveRight) == 0x000004, "Wrong alignment on GzCharacterControlsComponent_HandleMoveRight");
static_assert(sizeof(GzCharacterControlsComponent_HandleMoveRight) == 0x000004, "Wrong size on GzCharacterControlsComponent_HandleMoveRight");
static_assert(offsetof(GzCharacterControlsComponent_HandleMoveRight, Value) == 0x000000, "Member 'GzCharacterControlsComponent_HandleMoveRight::Value' has a wrong offset!");

// Function G01.GzCharacterControlsComponent.HandleTurn
// 0x0004 (0x0004 - 0x0000)
struct GzCharacterControlsComponent_HandleTurn final
{
public:
	float                                         Value;                                             // 0x0000(0x0004)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzCharacterControlsComponent_HandleTurn) == 0x000004, "Wrong alignment on GzCharacterControlsComponent_HandleTurn");
static_assert(sizeof(GzCharacterControlsComponent_HandleTurn) == 0x000004, "Wrong size on GzCharacterControlsComponent_HandleTurn");
static_assert(offsetof(GzCharacterControlsComponent_HandleTurn, Value) == 0x000000, "Member 'GzCharacterControlsComponent_HandleTurn::Value' has a wrong offset!");

// Function G01.GzCharacterControlsComponent.HandleWingsuitMovementPitch
// 0x0008 (0x0008 - 0x0000)
struct GzCharacterControlsComponent_HandleWingsuitMovementPitch final
{
public:
	float                                         ForwardAxisValue;                                  // 0x0000(0x0004)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RightAxisValue;                                    // 0x0004(0x0004)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzCharacterControlsComponent_HandleWingsuitMovementPitch) == 0x000004, "Wrong alignment on GzCharacterControlsComponent_HandleWingsuitMovementPitch");
static_assert(sizeof(GzCharacterControlsComponent_HandleWingsuitMovementPitch) == 0x000008, "Wrong size on GzCharacterControlsComponent_HandleWingsuitMovementPitch");
static_assert(offsetof(GzCharacterControlsComponent_HandleWingsuitMovementPitch, ForwardAxisValue) == 0x000000, "Member 'GzCharacterControlsComponent_HandleWingsuitMovementPitch::ForwardAxisValue' has a wrong offset!");
static_assert(offsetof(GzCharacterControlsComponent_HandleWingsuitMovementPitch, RightAxisValue) == 0x000004, "Member 'GzCharacterControlsComponent_HandleWingsuitMovementPitch::RightAxisValue' has a wrong offset!");

// Function G01.GzCharacterControlsComponent.HandleWingsuitMovementYaw
// 0x0008 (0x0008 - 0x0000)
struct GzCharacterControlsComponent_HandleWingsuitMovementYaw final
{
public:
	float                                         ForwardAxisValue;                                  // 0x0000(0x0004)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RightAxisValue;                                    // 0x0004(0x0004)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzCharacterControlsComponent_HandleWingsuitMovementYaw) == 0x000004, "Wrong alignment on GzCharacterControlsComponent_HandleWingsuitMovementYaw");
static_assert(sizeof(GzCharacterControlsComponent_HandleWingsuitMovementYaw) == 0x000008, "Wrong size on GzCharacterControlsComponent_HandleWingsuitMovementYaw");
static_assert(offsetof(GzCharacterControlsComponent_HandleWingsuitMovementYaw, ForwardAxisValue) == 0x000000, "Member 'GzCharacterControlsComponent_HandleWingsuitMovementYaw::ForwardAxisValue' has a wrong offset!");
static_assert(offsetof(GzCharacterControlsComponent_HandleWingsuitMovementYaw, RightAxisValue) == 0x000004, "Member 'GzCharacterControlsComponent_HandleWingsuitMovementYaw::RightAxisValue' has a wrong offset!");

// Function G01.GzCharacterControlsComponent.SetMovementEnabled
// 0x0001 (0x0001 - 0x0000)
struct GzCharacterControlsComponent_SetMovementEnabled final
{
public:
	bool                                          bEnabled;                                          // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzCharacterControlsComponent_SetMovementEnabled) == 0x000001, "Wrong alignment on GzCharacterControlsComponent_SetMovementEnabled");
static_assert(sizeof(GzCharacterControlsComponent_SetMovementEnabled) == 0x000001, "Wrong size on GzCharacterControlsComponent_SetMovementEnabled");
static_assert(offsetof(GzCharacterControlsComponent_SetMovementEnabled, bEnabled) == 0x000000, "Member 'GzCharacterControlsComponent_SetMovementEnabled::bEnabled' has a wrong offset!");

// Function G01.GzNotificationsCheatExtension.SimulateLotSoldNotification
// 0x0010 (0x0010 - 0x0000)
struct GzNotificationsCheatExtension_SimulateLotSoldNotification final
{
public:
	class FString                                 ItemGuid;                                          // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzNotificationsCheatExtension_SimulateLotSoldNotification) == 0x000008, "Wrong alignment on GzNotificationsCheatExtension_SimulateLotSoldNotification");
static_assert(sizeof(GzNotificationsCheatExtension_SimulateLotSoldNotification) == 0x000010, "Wrong size on GzNotificationsCheatExtension_SimulateLotSoldNotification");
static_assert(offsetof(GzNotificationsCheatExtension_SimulateLotSoldNotification, ItemGuid) == 0x000000, "Member 'GzNotificationsCheatExtension_SimulateLotSoldNotification::ItemGuid' has a wrong offset!");

// Function G01.GzGameplayTagHandler.OnTagCountChanged
// 0x0018 (0x0018 - 0x0000)
struct GzGameplayTagHandler_OnTagCountChanged final
{
public:
	class UGzAbilitySystemComponent*              Target;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           Tag;                                               // 0x0008(0x0008)(Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Count;                                             // 0x0010(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2F6D[0x4];                                     // 0x0014(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GzGameplayTagHandler_OnTagCountChanged) == 0x000008, "Wrong alignment on GzGameplayTagHandler_OnTagCountChanged");
static_assert(sizeof(GzGameplayTagHandler_OnTagCountChanged) == 0x000018, "Wrong size on GzGameplayTagHandler_OnTagCountChanged");
static_assert(offsetof(GzGameplayTagHandler_OnTagCountChanged, Target) == 0x000000, "Member 'GzGameplayTagHandler_OnTagCountChanged::Target' has a wrong offset!");
static_assert(offsetof(GzGameplayTagHandler_OnTagCountChanged, Tag) == 0x000008, "Member 'GzGameplayTagHandler_OnTagCountChanged::Tag' has a wrong offset!");
static_assert(offsetof(GzGameplayTagHandler_OnTagCountChanged, Count) == 0x000010, "Member 'GzGameplayTagHandler_OnTagCountChanged::Count' has a wrong offset!");

// Function G01.GzCharacterCustomizationComponent.ApplyCustomizationItem
// 0x0020 (0x0020 - 0x0000)
struct GzCharacterCustomizationComponent_ApplyCustomizationItem final
{
public:
	struct FGzCharacterCustomizationItem          CustomizationItem;                                 // 0x0000(0x0018)(Parm, NativeAccessSpecifierPublic)
	bool                                          bDefaultProfile;                                   // 0x0018(0x0001)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2F75[0x7];                                     // 0x0019(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GzCharacterCustomizationComponent_ApplyCustomizationItem) == 0x000008, "Wrong alignment on GzCharacterCustomizationComponent_ApplyCustomizationItem");
static_assert(sizeof(GzCharacterCustomizationComponent_ApplyCustomizationItem) == 0x000020, "Wrong size on GzCharacterCustomizationComponent_ApplyCustomizationItem");
static_assert(offsetof(GzCharacterCustomizationComponent_ApplyCustomizationItem, CustomizationItem) == 0x000000, "Member 'GzCharacterCustomizationComponent_ApplyCustomizationItem::CustomizationItem' has a wrong offset!");
static_assert(offsetof(GzCharacterCustomizationComponent_ApplyCustomizationItem, bDefaultProfile) == 0x000018, "Member 'GzCharacterCustomizationComponent_ApplyCustomizationItem::bDefaultProfile' has a wrong offset!");

// Function G01.GzCharacterCustomizationComponent.OnCharacterLimbChanged
// 0x0001 (0x0001 - 0x0000)
struct GzCharacterCustomizationComponent_OnCharacterLimbChanged final
{
public:
	EGzLimbType                                   LimbType;                                          // 0x0000(0x0001)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzCharacterCustomizationComponent_OnCharacterLimbChanged) == 0x000001, "Wrong alignment on GzCharacterCustomizationComponent_OnCharacterLimbChanged");
static_assert(sizeof(GzCharacterCustomizationComponent_OnCharacterLimbChanged) == 0x000001, "Wrong size on GzCharacterCustomizationComponent_OnCharacterLimbChanged");
static_assert(offsetof(GzCharacterCustomizationComponent_OnCharacterLimbChanged, LimbType) == 0x000000, "Member 'GzCharacterCustomizationComponent_OnCharacterLimbChanged::LimbType' has a wrong offset!");

// Function G01.GzCharacterCustomizationComponent.OnHasDefaultLegsTagChanged
// 0x000C (0x000C - 0x0000)
struct GzCharacterCustomizationComponent_OnHasDefaultLegsTagChanged final
{
public:
	struct FGameplayTag                           DefaultLegsPresentTag;                             // 0x0000(0x0008)(ConstParm, Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Count;                                             // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzCharacterCustomizationComponent_OnHasDefaultLegsTagChanged) == 0x000004, "Wrong alignment on GzCharacterCustomizationComponent_OnHasDefaultLegsTagChanged");
static_assert(sizeof(GzCharacterCustomizationComponent_OnHasDefaultLegsTagChanged) == 0x00000C, "Wrong size on GzCharacterCustomizationComponent_OnHasDefaultLegsTagChanged");
static_assert(offsetof(GzCharacterCustomizationComponent_OnHasDefaultLegsTagChanged, DefaultLegsPresentTag) == 0x000000, "Member 'GzCharacterCustomizationComponent_OnHasDefaultLegsTagChanged::DefaultLegsPresentTag' has a wrong offset!");
static_assert(offsetof(GzCharacterCustomizationComponent_OnHasDefaultLegsTagChanged, Count) == 0x000008, "Member 'GzCharacterCustomizationComponent_OnHasDefaultLegsTagChanged::Count' has a wrong offset!");

// Function G01.GzCharacterCustomizationComponent.OnHasInitialLegsTagChanged
// 0x000C (0x000C - 0x0000)
struct GzCharacterCustomizationComponent_OnHasInitialLegsTagChanged final
{
public:
	struct FGameplayTag                           InitialLegsPresentTag;                             // 0x0000(0x0008)(ConstParm, Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Count;                                             // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzCharacterCustomizationComponent_OnHasInitialLegsTagChanged) == 0x000004, "Wrong alignment on GzCharacterCustomizationComponent_OnHasInitialLegsTagChanged");
static_assert(sizeof(GzCharacterCustomizationComponent_OnHasInitialLegsTagChanged) == 0x00000C, "Wrong size on GzCharacterCustomizationComponent_OnHasInitialLegsTagChanged");
static_assert(offsetof(GzCharacterCustomizationComponent_OnHasInitialLegsTagChanged, InitialLegsPresentTag) == 0x000000, "Member 'GzCharacterCustomizationComponent_OnHasInitialLegsTagChanged::InitialLegsPresentTag' has a wrong offset!");
static_assert(offsetof(GzCharacterCustomizationComponent_OnHasInitialLegsTagChanged, Count) == 0x000008, "Member 'GzCharacterCustomizationComponent_OnHasInitialLegsTagChanged::Count' has a wrong offset!");

// Function G01.GzCharacterCustomizationComponent.SetNewCustomizationProfile
// 0x0150 (0x0150 - 0x0000)
struct GzCharacterCustomizationComponent_SetNewCustomizationProfile final
{
public:
	struct FGzCharacterCustomizationProfile       NewProfile;                                        // 0x0000(0x0150)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzCharacterCustomizationComponent_SetNewCustomizationProfile) == 0x000008, "Wrong alignment on GzCharacterCustomizationComponent_SetNewCustomizationProfile");
static_assert(sizeof(GzCharacterCustomizationComponent_SetNewCustomizationProfile) == 0x000150, "Wrong size on GzCharacterCustomizationComponent_SetNewCustomizationProfile");
static_assert(offsetof(GzCharacterCustomizationComponent_SetNewCustomizationProfile, NewProfile) == 0x000000, "Member 'GzCharacterCustomizationComponent_SetNewCustomizationProfile::NewProfile' has a wrong offset!");

// Function G01.GzCharacterCustomizationComponent.GetCurrentCharacterCustomizationProfile
// 0x0150 (0x0150 - 0x0000)
struct GzCharacterCustomizationComponent_GetCurrentCharacterCustomizationProfile final
{
public:
	struct FGzCharacterCustomizationProfile       ReturnValue;                                       // 0x0000(0x0150)(ConstParm, Parm, OutParm, ReturnParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzCharacterCustomizationComponent_GetCurrentCharacterCustomizationProfile) == 0x000008, "Wrong alignment on GzCharacterCustomizationComponent_GetCurrentCharacterCustomizationProfile");
static_assert(sizeof(GzCharacterCustomizationComponent_GetCurrentCharacterCustomizationProfile) == 0x000150, "Wrong size on GzCharacterCustomizationComponent_GetCurrentCharacterCustomizationProfile");
static_assert(offsetof(GzCharacterCustomizationComponent_GetCurrentCharacterCustomizationProfile, ReturnValue) == 0x000000, "Member 'GzCharacterCustomizationComponent_GetCurrentCharacterCustomizationProfile::ReturnValue' has a wrong offset!");

// Function G01.GzCIT_Emote.GetEmoteId
// 0x0004 (0x0004 - 0x0000)
struct GzCIT_Emote_GetEmoteId final
{
public:
	int32                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzCIT_Emote_GetEmoteId) == 0x000004, "Wrong alignment on GzCIT_Emote_GetEmoteId");
static_assert(sizeof(GzCIT_Emote_GetEmoteId) == 0x000004, "Wrong size on GzCIT_Emote_GetEmoteId");
static_assert(offsetof(GzCIT_Emote_GetEmoteId, ReturnValue) == 0x000000, "Member 'GzCIT_Emote_GetEmoteId::ReturnValue' has a wrong offset!");

// Function G01.GzCIT_Emote.GetEmoteMontage
// 0x0008 (0x0008 - 0x0000)
struct GzCIT_Emote_GetEmoteMontage final
{
public:
	class UAnimMontage*                           ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzCIT_Emote_GetEmoteMontage) == 0x000008, "Wrong alignment on GzCIT_Emote_GetEmoteMontage");
static_assert(sizeof(GzCIT_Emote_GetEmoteMontage) == 0x000008, "Wrong size on GzCIT_Emote_GetEmoteMontage");
static_assert(offsetof(GzCIT_Emote_GetEmoteMontage, ReturnValue) == 0x000000, "Member 'GzCIT_Emote_GetEmoteMontage::ReturnValue' has a wrong offset!");

// Function G01.GzCIT_Emote.GetEmoteName
// 0x0008 (0x0008 - 0x0000)
struct GzCIT_Emote_GetEmoteName final
{
public:
	class FName                                   ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzCIT_Emote_GetEmoteName) == 0x000004, "Wrong alignment on GzCIT_Emote_GetEmoteName");
static_assert(sizeof(GzCIT_Emote_GetEmoteName) == 0x000008, "Wrong size on GzCIT_Emote_GetEmoteName");
static_assert(offsetof(GzCIT_Emote_GetEmoteName, ReturnValue) == 0x000000, "Member 'GzCIT_Emote_GetEmoteName::ReturnValue' has a wrong offset!");

// Function G01.GzCIT_Emote.GetEmoteTexture
// 0x0008 (0x0008 - 0x0000)
struct GzCIT_Emote_GetEmoteTexture final
{
public:
	class UTexture2D*                             ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzCIT_Emote_GetEmoteTexture) == 0x000008, "Wrong alignment on GzCIT_Emote_GetEmoteTexture");
static_assert(sizeof(GzCIT_Emote_GetEmoteTexture) == 0x000008, "Wrong size on GzCIT_Emote_GetEmoteTexture");
static_assert(offsetof(GzCIT_Emote_GetEmoteTexture, ReturnValue) == 0x000000, "Member 'GzCIT_Emote_GetEmoteTexture::ReturnValue' has a wrong offset!");

// Function G01.GzSpawnZone.OnEndOverlap
// 0x0020 (0x0020 - 0x0000)
struct GzSpawnZone_OnEndOverlap final
{
public:
	class UPrimitiveComponent*                    Component;                                         // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 Actor;                                             // 0x0008(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UPrimitiveComponent*                    OtherComp;                                         // 0x0010(0x0008)(Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         OtherBodyIndex;                                    // 0x0018(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2F7C[0x4];                                     // 0x001C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GzSpawnZone_OnEndOverlap) == 0x000008, "Wrong alignment on GzSpawnZone_OnEndOverlap");
static_assert(sizeof(GzSpawnZone_OnEndOverlap) == 0x000020, "Wrong size on GzSpawnZone_OnEndOverlap");
static_assert(offsetof(GzSpawnZone_OnEndOverlap, Component) == 0x000000, "Member 'GzSpawnZone_OnEndOverlap::Component' has a wrong offset!");
static_assert(offsetof(GzSpawnZone_OnEndOverlap, Actor) == 0x000008, "Member 'GzSpawnZone_OnEndOverlap::Actor' has a wrong offset!");
static_assert(offsetof(GzSpawnZone_OnEndOverlap, OtherComp) == 0x000010, "Member 'GzSpawnZone_OnEndOverlap::OtherComp' has a wrong offset!");
static_assert(offsetof(GzSpawnZone_OnEndOverlap, OtherBodyIndex) == 0x000018, "Member 'GzSpawnZone_OnEndOverlap::OtherBodyIndex' has a wrong offset!");

// Function G01.GzSpawnZone.GetSpawnHeight
// 0x0004 (0x0004 - 0x0000)
struct GzSpawnZone_GetSpawnHeight final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzSpawnZone_GetSpawnHeight) == 0x000004, "Wrong alignment on GzSpawnZone_GetSpawnHeight");
static_assert(sizeof(GzSpawnZone_GetSpawnHeight) == 0x000004, "Wrong size on GzSpawnZone_GetSpawnHeight");
static_assert(offsetof(GzSpawnZone_GetSpawnHeight, ReturnValue) == 0x000000, "Member 'GzSpawnZone_GetSpawnHeight::ReturnValue' has a wrong offset!");

// Function G01.GzSpawnZone.GetSpawnRadius
// 0x0004 (0x0004 - 0x0000)
struct GzSpawnZone_GetSpawnRadius final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzSpawnZone_GetSpawnRadius) == 0x000004, "Wrong alignment on GzSpawnZone_GetSpawnRadius");
static_assert(sizeof(GzSpawnZone_GetSpawnRadius) == 0x000004, "Wrong size on GzSpawnZone_GetSpawnRadius");
static_assert(offsetof(GzSpawnZone_GetSpawnRadius, ReturnValue) == 0x000000, "Member 'GzSpawnZone_GetSpawnRadius::ReturnValue' has a wrong offset!");

// Function G01.GzBackendPlayerDataHelper.GetPlayerAvatar
// 0x0010 (0x0010 - 0x0000)
struct GzBackendPlayerDataHelper_GetPlayerAvatar final
{
public:
	const class UObject*                          WorldContextObject;                                // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	const class UTexture2D*                       ReturnValue;                                       // 0x0008(0x0008)(ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzBackendPlayerDataHelper_GetPlayerAvatar) == 0x000008, "Wrong alignment on GzBackendPlayerDataHelper_GetPlayerAvatar");
static_assert(sizeof(GzBackendPlayerDataHelper_GetPlayerAvatar) == 0x000010, "Wrong size on GzBackendPlayerDataHelper_GetPlayerAvatar");
static_assert(offsetof(GzBackendPlayerDataHelper_GetPlayerAvatar, WorldContextObject) == 0x000000, "Member 'GzBackendPlayerDataHelper_GetPlayerAvatar::WorldContextObject' has a wrong offset!");
static_assert(offsetof(GzBackendPlayerDataHelper_GetPlayerAvatar, ReturnValue) == 0x000008, "Member 'GzBackendPlayerDataHelper_GetPlayerAvatar::ReturnValue' has a wrong offset!");

// Function G01.GzBackendPlayerDataHelper.GetPlayerClanTag
// 0x0018 (0x0018 - 0x0000)
struct GzBackendPlayerDataHelper_GetPlayerClanTag final
{
public:
	const class UObject*                          WorldContextObject;                                // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 ReturnValue;                                       // 0x0008(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzBackendPlayerDataHelper_GetPlayerClanTag) == 0x000008, "Wrong alignment on GzBackendPlayerDataHelper_GetPlayerClanTag");
static_assert(sizeof(GzBackendPlayerDataHelper_GetPlayerClanTag) == 0x000018, "Wrong size on GzBackendPlayerDataHelper_GetPlayerClanTag");
static_assert(offsetof(GzBackendPlayerDataHelper_GetPlayerClanTag, WorldContextObject) == 0x000000, "Member 'GzBackendPlayerDataHelper_GetPlayerClanTag::WorldContextObject' has a wrong offset!");
static_assert(offsetof(GzBackendPlayerDataHelper_GetPlayerClanTag, ReturnValue) == 0x000008, "Member 'GzBackendPlayerDataHelper_GetPlayerClanTag::ReturnValue' has a wrong offset!");

// Function G01.GzBackendPlayerDataHelper.GetPlayerProgression
// 0x0010 (0x0010 - 0x0000)
struct GzBackendPlayerDataHelper_GetPlayerProgression final
{
public:
	const class UObject*                          WorldContextObject;                                // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGzLevelProgression                    ReturnValue;                                       // 0x0008(0x0008)(ConstParm, Parm, OutParm, ReturnParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzBackendPlayerDataHelper_GetPlayerProgression) == 0x000008, "Wrong alignment on GzBackendPlayerDataHelper_GetPlayerProgression");
static_assert(sizeof(GzBackendPlayerDataHelper_GetPlayerProgression) == 0x000010, "Wrong size on GzBackendPlayerDataHelper_GetPlayerProgression");
static_assert(offsetof(GzBackendPlayerDataHelper_GetPlayerProgression, WorldContextObject) == 0x000000, "Member 'GzBackendPlayerDataHelper_GetPlayerProgression::WorldContextObject' has a wrong offset!");
static_assert(offsetof(GzBackendPlayerDataHelper_GetPlayerProgression, ReturnValue) == 0x000008, "Member 'GzBackendPlayerDataHelper_GetPlayerProgression::ReturnValue' has a wrong offset!");

// Function G01.GzBackendPlayerDataHelper.HasPlayerValidSubscription
// 0x0010 (0x0010 - 0x0000)
struct GzBackendPlayerDataHelper_HasPlayerValidSubscription final
{
public:
	const class UObject*                          WorldContextObject;                                // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2F7D[0x7];                                     // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GzBackendPlayerDataHelper_HasPlayerValidSubscription) == 0x000008, "Wrong alignment on GzBackendPlayerDataHelper_HasPlayerValidSubscription");
static_assert(sizeof(GzBackendPlayerDataHelper_HasPlayerValidSubscription) == 0x000010, "Wrong size on GzBackendPlayerDataHelper_HasPlayerValidSubscription");
static_assert(offsetof(GzBackendPlayerDataHelper_HasPlayerValidSubscription, WorldContextObject) == 0x000000, "Member 'GzBackendPlayerDataHelper_HasPlayerValidSubscription::WorldContextObject' has a wrong offset!");
static_assert(offsetof(GzBackendPlayerDataHelper_HasPlayerValidSubscription, ReturnValue) == 0x000008, "Member 'GzBackendPlayerDataHelper_HasPlayerValidSubscription::ReturnValue' has a wrong offset!");

// DelegateFunction G01.GzBackendSubsystem.OnCallLoadout__DelegateSignature
// 0x0028 (0x0028 - 0x0000)
struct GzBackendSubsystem_OnCallLoadout__DelegateSignature final
{
public:
	class AActor*                                 InitiatorObject;                                   // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 PlayFabId;                                         // 0x0008(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 CharacterId;                                       // 0x0018(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzBackendSubsystem_OnCallLoadout__DelegateSignature) == 0x000008, "Wrong alignment on GzBackendSubsystem_OnCallLoadout__DelegateSignature");
static_assert(sizeof(GzBackendSubsystem_OnCallLoadout__DelegateSignature) == 0x000028, "Wrong size on GzBackendSubsystem_OnCallLoadout__DelegateSignature");
static_assert(offsetof(GzBackendSubsystem_OnCallLoadout__DelegateSignature, InitiatorObject) == 0x000000, "Member 'GzBackendSubsystem_OnCallLoadout__DelegateSignature::InitiatorObject' has a wrong offset!");
static_assert(offsetof(GzBackendSubsystem_OnCallLoadout__DelegateSignature, PlayFabId) == 0x000008, "Member 'GzBackendSubsystem_OnCallLoadout__DelegateSignature::PlayFabId' has a wrong offset!");
static_assert(offsetof(GzBackendSubsystem_OnCallLoadout__DelegateSignature, CharacterId) == 0x000018, "Member 'GzBackendSubsystem_OnCallLoadout__DelegateSignature::CharacterId' has a wrong offset!");

// DelegateFunction G01.GzBackendSubsystem.OnCallSaveLoadout__DelegateSignature
// 0x0020 (0x0020 - 0x0000)
struct GzBackendSubsystem_OnCallSaveLoadout__DelegateSignature final
{
public:
	class FString                                 PlayFabId;                                         // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 CharacterId;                                       // 0x0010(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzBackendSubsystem_OnCallSaveLoadout__DelegateSignature) == 0x000008, "Wrong alignment on GzBackendSubsystem_OnCallSaveLoadout__DelegateSignature");
static_assert(sizeof(GzBackendSubsystem_OnCallSaveLoadout__DelegateSignature) == 0x000020, "Wrong size on GzBackendSubsystem_OnCallSaveLoadout__DelegateSignature");
static_assert(offsetof(GzBackendSubsystem_OnCallSaveLoadout__DelegateSignature, PlayFabId) == 0x000000, "Member 'GzBackendSubsystem_OnCallSaveLoadout__DelegateSignature::PlayFabId' has a wrong offset!");
static_assert(offsetof(GzBackendSubsystem_OnCallSaveLoadout__DelegateSignature, CharacterId) == 0x000010, "Member 'GzBackendSubsystem_OnCallSaveLoadout__DelegateSignature::CharacterId' has a wrong offset!");

// Function G01.GzBackendSubsystem.SpawnLootChest
// 0x0018 (0x0018 - 0x0000)
struct GzBackendSubsystem_SpawnLootChest final
{
public:
	class AActor*                                 InitiatorObject;                                   // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FGzInventoryItemContent>        LootList;                                          // 0x0008(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzBackendSubsystem_SpawnLootChest) == 0x000008, "Wrong alignment on GzBackendSubsystem_SpawnLootChest");
static_assert(sizeof(GzBackendSubsystem_SpawnLootChest) == 0x000018, "Wrong size on GzBackendSubsystem_SpawnLootChest");
static_assert(offsetof(GzBackendSubsystem_SpawnLootChest, InitiatorObject) == 0x000000, "Member 'GzBackendSubsystem_SpawnLootChest::InitiatorObject' has a wrong offset!");
static_assert(offsetof(GzBackendSubsystem_SpawnLootChest, LootList) == 0x000008, "Member 'GzBackendSubsystem_SpawnLootChest::LootList' has a wrong offset!");

// Function G01.GzBackpackItemData.GetBackpackPocketDefsCount
// 0x0004 (0x0004 - 0x0000)
struct GzBackpackItemData_GetBackpackPocketDefsCount final
{
public:
	int32                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzBackpackItemData_GetBackpackPocketDefsCount) == 0x000004, "Wrong alignment on GzBackpackItemData_GetBackpackPocketDefsCount");
static_assert(sizeof(GzBackpackItemData_GetBackpackPocketDefsCount) == 0x000004, "Wrong size on GzBackpackItemData_GetBackpackPocketDefsCount");
static_assert(offsetof(GzBackpackItemData_GetBackpackPocketDefsCount, ReturnValue) == 0x000000, "Member 'GzBackpackItemData_GetBackpackPocketDefsCount::ReturnValue' has a wrong offset!");

// Function G01.GzBackpackItemData.GetPocketCount
// 0x0004 (0x0004 - 0x0000)
struct GzBackpackItemData_GetPocketCount final
{
public:
	int32                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzBackpackItemData_GetPocketCount) == 0x000004, "Wrong alignment on GzBackpackItemData_GetPocketCount");
static_assert(sizeof(GzBackpackItemData_GetPocketCount) == 0x000004, "Wrong size on GzBackpackItemData_GetPocketCount");
static_assert(offsetof(GzBackpackItemData_GetPocketCount, ReturnValue) == 0x000000, "Member 'GzBackpackItemData_GetPocketCount::ReturnValue' has a wrong offset!");

// Function G01.GzGA_Wingsuit.CanActivateJetpack
// 0x0010 (0x0010 - 0x0000)
struct GzGA_Wingsuit_CanActivateJetpack final
{
public:
	class AGzCharacter*                           Character;                                         // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2F82[0x7];                                     // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GzGA_Wingsuit_CanActivateJetpack) == 0x000008, "Wrong alignment on GzGA_Wingsuit_CanActivateJetpack");
static_assert(sizeof(GzGA_Wingsuit_CanActivateJetpack) == 0x000010, "Wrong size on GzGA_Wingsuit_CanActivateJetpack");
static_assert(offsetof(GzGA_Wingsuit_CanActivateJetpack, Character) == 0x000000, "Member 'GzGA_Wingsuit_CanActivateJetpack::Character' has a wrong offset!");
static_assert(offsetof(GzGA_Wingsuit_CanActivateJetpack, ReturnValue) == 0x000008, "Member 'GzGA_Wingsuit_CanActivateJetpack::ReturnValue' has a wrong offset!");

// Function G01.GzGA_Wingsuit.IsJetpackActive
// 0x0010 (0x0010 - 0x0000)
struct GzGA_Wingsuit_IsJetpackActive final
{
public:
	class AGzCharacter*                           Character;                                         // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2F83[0x7];                                     // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GzGA_Wingsuit_IsJetpackActive) == 0x000008, "Wrong alignment on GzGA_Wingsuit_IsJetpackActive");
static_assert(sizeof(GzGA_Wingsuit_IsJetpackActive) == 0x000010, "Wrong size on GzGA_Wingsuit_IsJetpackActive");
static_assert(offsetof(GzGA_Wingsuit_IsJetpackActive, Character) == 0x000000, "Member 'GzGA_Wingsuit_IsJetpackActive::Character' has a wrong offset!");
static_assert(offsetof(GzGA_Wingsuit_IsJetpackActive, ReturnValue) == 0x000008, "Member 'GzGA_Wingsuit_IsJetpackActive::ReturnValue' has a wrong offset!");

// Function G01.GzGA_Wingsuit.BP_DeactivateJetpack
// 0x0001 (0x0001 - 0x0000)
struct GzGA_Wingsuit_BP_DeactivateJetpack final
{
public:
	bool                                          bWasCancelled;                                     // 0x0000(0x0001)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzGA_Wingsuit_BP_DeactivateJetpack) == 0x000001, "Wrong alignment on GzGA_Wingsuit_BP_DeactivateJetpack");
static_assert(sizeof(GzGA_Wingsuit_BP_DeactivateJetpack) == 0x000001, "Wrong size on GzGA_Wingsuit_BP_DeactivateJetpack");
static_assert(offsetof(GzGA_Wingsuit_BP_DeactivateJetpack, bWasCancelled) == 0x000000, "Member 'GzGA_Wingsuit_BP_DeactivateJetpack::bWasCancelled' has a wrong offset!");

// Function G01.GzGA_Wingsuit.OnHitReactionInJetpackTagChanged
// 0x000C (0x000C - 0x0000)
struct GzGA_Wingsuit_OnHitReactionInJetpackTagChanged final
{
public:
	struct FGameplayTag                           HitReactionInJetpackTag;                           // 0x0000(0x0008)(ConstParm, Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Count;                                             // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzGA_Wingsuit_OnHitReactionInJetpackTagChanged) == 0x000004, "Wrong alignment on GzGA_Wingsuit_OnHitReactionInJetpackTagChanged");
static_assert(sizeof(GzGA_Wingsuit_OnHitReactionInJetpackTagChanged) == 0x00000C, "Wrong size on GzGA_Wingsuit_OnHitReactionInJetpackTagChanged");
static_assert(offsetof(GzGA_Wingsuit_OnHitReactionInJetpackTagChanged, HitReactionInJetpackTag) == 0x000000, "Member 'GzGA_Wingsuit_OnHitReactionInJetpackTagChanged::HitReactionInJetpackTag' has a wrong offset!");
static_assert(offsetof(GzGA_Wingsuit_OnHitReactionInJetpackTagChanged, Count) == 0x000008, "Member 'GzGA_Wingsuit_OnHitReactionInJetpackTagChanged::Count' has a wrong offset!");

// Function G01.GzGA_Wingsuit.OnMontageNotify
// 0x0008 (0x0008 - 0x0000)
struct GzGA_Wingsuit_OnMontageNotify final
{
public:
	class FName                                   NotifyName;                                        // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzGA_Wingsuit_OnMontageNotify) == 0x000004, "Wrong alignment on GzGA_Wingsuit_OnMontageNotify");
static_assert(sizeof(GzGA_Wingsuit_OnMontageNotify) == 0x000008, "Wrong size on GzGA_Wingsuit_OnMontageNotify");
static_assert(offsetof(GzGA_Wingsuit_OnMontageNotify, NotifyName) == 0x000000, "Member 'GzGA_Wingsuit_OnMontageNotify::NotifyName' has a wrong offset!");

// Function G01.GzGA_Wingsuit.OnMovementModeChangeWingsuit
// 0x0010 (0x0010 - 0x0000)
struct GzGA_Wingsuit_OnMovementModeChangeWingsuit final
{
public:
	class ACharacter*                             Character;                                         // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EMovementMode                                 PrevMovementMode;                                  // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         PreviousCustomMode;                                // 0x0009(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2F84[0x6];                                     // 0x000A(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GzGA_Wingsuit_OnMovementModeChangeWingsuit) == 0x000008, "Wrong alignment on GzGA_Wingsuit_OnMovementModeChangeWingsuit");
static_assert(sizeof(GzGA_Wingsuit_OnMovementModeChangeWingsuit) == 0x000010, "Wrong size on GzGA_Wingsuit_OnMovementModeChangeWingsuit");
static_assert(offsetof(GzGA_Wingsuit_OnMovementModeChangeWingsuit, Character) == 0x000000, "Member 'GzGA_Wingsuit_OnMovementModeChangeWingsuit::Character' has a wrong offset!");
static_assert(offsetof(GzGA_Wingsuit_OnMovementModeChangeWingsuit, PrevMovementMode) == 0x000008, "Member 'GzGA_Wingsuit_OnMovementModeChangeWingsuit::PrevMovementMode' has a wrong offset!");
static_assert(offsetof(GzGA_Wingsuit_OnMovementModeChangeWingsuit, PreviousCustomMode) == 0x000009, "Member 'GzGA_Wingsuit_OnMovementModeChangeWingsuit::PreviousCustomMode' has a wrong offset!");

// Function G01.GzGA_Wingsuit.IsDamaged
// 0x0001 (0x0001 - 0x0000)
struct GzGA_Wingsuit_IsDamaged final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzGA_Wingsuit_IsDamaged) == 0x000001, "Wrong alignment on GzGA_Wingsuit_IsDamaged");
static_assert(sizeof(GzGA_Wingsuit_IsDamaged) == 0x000001, "Wrong size on GzGA_Wingsuit_IsDamaged");
static_assert(offsetof(GzGA_Wingsuit_IsDamaged, ReturnValue) == 0x000000, "Member 'GzGA_Wingsuit_IsDamaged::ReturnValue' has a wrong offset!");

// Function G01.GzGA_Wingsuit.IsStarted
// 0x0001 (0x0001 - 0x0000)
struct GzGA_Wingsuit_IsStarted final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzGA_Wingsuit_IsStarted) == 0x000001, "Wrong alignment on GzGA_Wingsuit_IsStarted");
static_assert(sizeof(GzGA_Wingsuit_IsStarted) == 0x000001, "Wrong size on GzGA_Wingsuit_IsStarted");
static_assert(offsetof(GzGA_Wingsuit_IsStarted, ReturnValue) == 0x000000, "Member 'GzGA_Wingsuit_IsStarted::ReturnValue' has a wrong offset!");

// Function G01.GzCharacterAkComponent.OnLocalPlayerInitialized
// 0x0010 (0x0010 - 0x0000)
struct GzCharacterAkComponent_OnLocalPlayerInitialized final
{
public:
	class AGzPlayerController*                    Controller;                                        // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AGzPlayerState*                         PlayerState;                                       // 0x0008(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzCharacterAkComponent_OnLocalPlayerInitialized) == 0x000008, "Wrong alignment on GzCharacterAkComponent_OnLocalPlayerInitialized");
static_assert(sizeof(GzCharacterAkComponent_OnLocalPlayerInitialized) == 0x000010, "Wrong size on GzCharacterAkComponent_OnLocalPlayerInitialized");
static_assert(offsetof(GzCharacterAkComponent_OnLocalPlayerInitialized, Controller) == 0x000000, "Member 'GzCharacterAkComponent_OnLocalPlayerInitialized::Controller' has a wrong offset!");
static_assert(offsetof(GzCharacterAkComponent_OnLocalPlayerInitialized, PlayerState) == 0x000008, "Member 'GzCharacterAkComponent_OnLocalPlayerInitialized::PlayerState' has a wrong offset!");

// Function G01.GzCharacterAkComponent.OnPlayerStateReplicated
// 0x0008 (0x0008 - 0x0000)
struct GzCharacterAkComponent_OnPlayerStateReplicated final
{
public:
	class AGzPlayerState*                         PlayerState;                                       // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzCharacterAkComponent_OnPlayerStateReplicated) == 0x000008, "Wrong alignment on GzCharacterAkComponent_OnPlayerStateReplicated");
static_assert(sizeof(GzCharacterAkComponent_OnPlayerStateReplicated) == 0x000008, "Wrong size on GzCharacterAkComponent_OnPlayerStateReplicated");
static_assert(offsetof(GzCharacterAkComponent_OnPlayerStateReplicated, PlayerState) == 0x000000, "Member 'GzCharacterAkComponent_OnPlayerStateReplicated::PlayerState' has a wrong offset!");

// Function G01.GzCharacterAkComponent.OnTeamChanged
// 0x0008 (0x0008 - 0x0000)
struct GzCharacterAkComponent_OnTeamChanged final
{
public:
	class AGzPlayerState*                         PlayerState;                                       // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzCharacterAkComponent_OnTeamChanged) == 0x000008, "Wrong alignment on GzCharacterAkComponent_OnTeamChanged");
static_assert(sizeof(GzCharacterAkComponent_OnTeamChanged) == 0x000008, "Wrong size on GzCharacterAkComponent_OnTeamChanged");
static_assert(offsetof(GzCharacterAkComponent_OnTeamChanged, PlayerState) == 0x000000, "Member 'GzCharacterAkComponent_OnTeamChanged::PlayerState' has a wrong offset!");

// Function G01.GzCharacterMetaSubsystem.DestroyMetaCharacter
// 0x0008 (0x0008 - 0x0000)
struct GzCharacterMetaSubsystem_DestroyMetaCharacter final
{
public:
	class AActor*                                 Actor;                                             // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzCharacterMetaSubsystem_DestroyMetaCharacter) == 0x000008, "Wrong alignment on GzCharacterMetaSubsystem_DestroyMetaCharacter");
static_assert(sizeof(GzCharacterMetaSubsystem_DestroyMetaCharacter) == 0x000008, "Wrong size on GzCharacterMetaSubsystem_DestroyMetaCharacter");
static_assert(offsetof(GzCharacterMetaSubsystem_DestroyMetaCharacter, Actor) == 0x000000, "Member 'GzCharacterMetaSubsystem_DestroyMetaCharacter::Actor' has a wrong offset!");

// Function G01.GzCameraLocationObject.HidePlayer
// 0x0008 (0x0008 - 0x0000)
struct GzCameraLocationObject_HidePlayer final
{
public:
	class AGzPlayerCharacter*                     Character;                                         // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzCameraLocationObject_HidePlayer) == 0x000008, "Wrong alignment on GzCameraLocationObject_HidePlayer");
static_assert(sizeof(GzCameraLocationObject_HidePlayer) == 0x000008, "Wrong size on GzCameraLocationObject_HidePlayer");
static_assert(offsetof(GzCameraLocationObject_HidePlayer, Character) == 0x000000, "Member 'GzCameraLocationObject_HidePlayer::Character' has a wrong offset!");

// Function G01.GzCameraLocationObject.ShowPlayer
// 0x0008 (0x0008 - 0x0000)
struct GzCameraLocationObject_ShowPlayer final
{
public:
	class AGzPlayerCharacter*                     Character;                                         // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzCameraLocationObject_ShowPlayer) == 0x000008, "Wrong alignment on GzCameraLocationObject_ShowPlayer");
static_assert(sizeof(GzCameraLocationObject_ShowPlayer) == 0x000008, "Wrong size on GzCameraLocationObject_ShowPlayer");
static_assert(offsetof(GzCameraLocationObject_ShowPlayer, Character) == 0x000000, "Member 'GzCameraLocationObject_ShowPlayer::Character' has a wrong offset!");

// Function G01.GzBaseInventoryWidget.GetInventoryComponent
// 0x0008 (0x0008 - 0x0000)
struct GzBaseInventoryWidget_GetInventoryComponent final
{
public:
	class UGzInvComponent*                        ReturnValue;                                       // 0x0000(0x0008)(ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzBaseInventoryWidget_GetInventoryComponent) == 0x000008, "Wrong alignment on GzBaseInventoryWidget_GetInventoryComponent");
static_assert(sizeof(GzBaseInventoryWidget_GetInventoryComponent) == 0x000008, "Wrong size on GzBaseInventoryWidget_GetInventoryComponent");
static_assert(offsetof(GzBaseInventoryWidget_GetInventoryComponent, ReturnValue) == 0x000000, "Member 'GzBaseInventoryWidget_GetInventoryComponent::ReturnValue' has a wrong offset!");

// Function G01.GzCloakComponent.OnBackpackChanged
// 0x0080 (0x0080 - 0x0000)
struct GzCloakComponent_OnBackpackChanged final
{
public:
	struct FGzInvPocketChangeData                 Data;                                              // 0x0000(0x0080)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzCloakComponent_OnBackpackChanged) == 0x000008, "Wrong alignment on GzCloakComponent_OnBackpackChanged");
static_assert(sizeof(GzCloakComponent_OnBackpackChanged) == 0x000080, "Wrong size on GzCloakComponent_OnBackpackChanged");
static_assert(offsetof(GzCloakComponent_OnBackpackChanged, Data) == 0x000000, "Member 'GzCloakComponent_OnBackpackChanged::Data' has a wrong offset!");

// Function G01.GzCloakComponent.OnBlockingTagsAddedRemoved
// 0x0008 (0x0008 - 0x0000)
struct GzCloakComponent_OnBlockingTagsAddedRemoved final
{
public:
	struct FGameplayTag                           Tag;                                               // 0x0000(0x0008)(Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzCloakComponent_OnBlockingTagsAddedRemoved) == 0x000004, "Wrong alignment on GzCloakComponent_OnBlockingTagsAddedRemoved");
static_assert(sizeof(GzCloakComponent_OnBlockingTagsAddedRemoved) == 0x000008, "Wrong size on GzCloakComponent_OnBlockingTagsAddedRemoved");
static_assert(offsetof(GzCloakComponent_OnBlockingTagsAddedRemoved, Tag) == 0x000000, "Member 'GzCloakComponent_OnBlockingTagsAddedRemoved::Tag' has a wrong offset!");

// Function G01.GzCloakComponent.OnCharacterReceivedDamage
// 0x0040 (0x0040 - 0x0000)
struct GzCloakComponent_OnCharacterReceivedDamage final
{
public:
	struct FGameplayAttribute                     Attribute;                                         // 0x0000(0x0038)(Parm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         NewValue;                                          // 0x0038(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         OldValue;                                          // 0x003C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzCloakComponent_OnCharacterReceivedDamage) == 0x000008, "Wrong alignment on GzCloakComponent_OnCharacterReceivedDamage");
static_assert(sizeof(GzCloakComponent_OnCharacterReceivedDamage) == 0x000040, "Wrong size on GzCloakComponent_OnCharacterReceivedDamage");
static_assert(offsetof(GzCloakComponent_OnCharacterReceivedDamage, Attribute) == 0x000000, "Member 'GzCloakComponent_OnCharacterReceivedDamage::Attribute' has a wrong offset!");
static_assert(offsetof(GzCloakComponent_OnCharacterReceivedDamage, NewValue) == 0x000038, "Member 'GzCloakComponent_OnCharacterReceivedDamage::NewValue' has a wrong offset!");
static_assert(offsetof(GzCloakComponent_OnCharacterReceivedDamage, OldValue) == 0x00003C, "Member 'GzCloakComponent_OnCharacterReceivedDamage::OldValue' has a wrong offset!");

// Function G01.GzCloakComponent.OnLimbChanged
// 0x0001 (0x0001 - 0x0000)
struct GzCloakComponent_OnLimbChanged final
{
public:
	EGzLimbType                                   ChangedLimbType;                                   // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzCloakComponent_OnLimbChanged) == 0x000001, "Wrong alignment on GzCloakComponent_OnLimbChanged");
static_assert(sizeof(GzCloakComponent_OnLimbChanged) == 0x000001, "Wrong size on GzCloakComponent_OnLimbChanged");
static_assert(offsetof(GzCloakComponent_OnLimbChanged, ChangedLimbType) == 0x000000, "Member 'GzCloakComponent_OnLimbChanged::ChangedLimbType' has a wrong offset!");

// Function G01.GzCloakComponent.OnPartiallyBlockingTagsAddedRemoved
// 0x0008 (0x0008 - 0x0000)
struct GzCloakComponent_OnPartiallyBlockingTagsAddedRemoved final
{
public:
	struct FGameplayTag                           Tag;                                               // 0x0000(0x0008)(Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzCloakComponent_OnPartiallyBlockingTagsAddedRemoved) == 0x000004, "Wrong alignment on GzCloakComponent_OnPartiallyBlockingTagsAddedRemoved");
static_assert(sizeof(GzCloakComponent_OnPartiallyBlockingTagsAddedRemoved) == 0x000008, "Wrong size on GzCloakComponent_OnPartiallyBlockingTagsAddedRemoved");
static_assert(offsetof(GzCloakComponent_OnPartiallyBlockingTagsAddedRemoved, Tag) == 0x000000, "Member 'GzCloakComponent_OnPartiallyBlockingTagsAddedRemoved::Tag' has a wrong offset!");

// Function G01.GzCloakComponent.OnWeaponeEquiped
// 0x0018 (0x0018 - 0x0000)
struct GzCloakComponent_OnWeaponeEquiped final
{
public:
	struct FGzInvPocketId                         InvPocketId;                                       // 0x0000(0x0008)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	const class AGzWeaponActor*                   WeaponActor;                                       // 0x0008(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEquipped;                                         // 0x0010(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2F9D[0x7];                                     // 0x0011(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GzCloakComponent_OnWeaponeEquiped) == 0x000008, "Wrong alignment on GzCloakComponent_OnWeaponeEquiped");
static_assert(sizeof(GzCloakComponent_OnWeaponeEquiped) == 0x000018, "Wrong size on GzCloakComponent_OnWeaponeEquiped");
static_assert(offsetof(GzCloakComponent_OnWeaponeEquiped, InvPocketId) == 0x000000, "Member 'GzCloakComponent_OnWeaponeEquiped::InvPocketId' has a wrong offset!");
static_assert(offsetof(GzCloakComponent_OnWeaponeEquiped, WeaponActor) == 0x000008, "Member 'GzCloakComponent_OnWeaponeEquiped::WeaponActor' has a wrong offset!");
static_assert(offsetof(GzCloakComponent_OnWeaponeEquiped, bEquipped) == 0x000010, "Member 'GzCloakComponent_OnWeaponeEquiped::bEquipped' has a wrong offset!");

// Function G01.GzHideoutStatics.CurrentMapIsHideout
// 0x0010 (0x0010 - 0x0000)
struct GzHideoutStatics_CurrentMapIsHideout final
{
public:
	const class UObject*                          WorldContext;                                      // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2F9E[0x7];                                     // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GzHideoutStatics_CurrentMapIsHideout) == 0x000008, "Wrong alignment on GzHideoutStatics_CurrentMapIsHideout");
static_assert(sizeof(GzHideoutStatics_CurrentMapIsHideout) == 0x000010, "Wrong size on GzHideoutStatics_CurrentMapIsHideout");
static_assert(offsetof(GzHideoutStatics_CurrentMapIsHideout, WorldContext) == 0x000000, "Member 'GzHideoutStatics_CurrentMapIsHideout::WorldContext' has a wrong offset!");
static_assert(offsetof(GzHideoutStatics_CurrentMapIsHideout, ReturnValue) == 0x000008, "Member 'GzHideoutStatics_CurrentMapIsHideout::ReturnValue' has a wrong offset!");

// Function G01.GzHideoutStatics.GetLoadoutServiceChecked
// 0x0010 (0x0010 - 0x0000)
struct GzHideoutStatics_GetLoadoutServiceChecked final
{
public:
	const class UObject*                          WorldContext;                                      // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UGzClientLoadoutService*                ReturnValue;                                       // 0x0008(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzHideoutStatics_GetLoadoutServiceChecked) == 0x000008, "Wrong alignment on GzHideoutStatics_GetLoadoutServiceChecked");
static_assert(sizeof(GzHideoutStatics_GetLoadoutServiceChecked) == 0x000010, "Wrong size on GzHideoutStatics_GetLoadoutServiceChecked");
static_assert(offsetof(GzHideoutStatics_GetLoadoutServiceChecked, WorldContext) == 0x000000, "Member 'GzHideoutStatics_GetLoadoutServiceChecked::WorldContext' has a wrong offset!");
static_assert(offsetof(GzHideoutStatics_GetLoadoutServiceChecked, ReturnValue) == 0x000008, "Member 'GzHideoutStatics_GetLoadoutServiceChecked::ReturnValue' has a wrong offset!");

// Function G01.GzHideoutStatics.GetSceneManager
// 0x0010 (0x0010 - 0x0000)
struct GzHideoutStatics_GetSceneManager final
{
public:
	const class UObject*                          WorldContext;                                      // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AGzSceneManager*                        ReturnValue;                                       // 0x0008(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzHideoutStatics_GetSceneManager) == 0x000008, "Wrong alignment on GzHideoutStatics_GetSceneManager");
static_assert(sizeof(GzHideoutStatics_GetSceneManager) == 0x000010, "Wrong size on GzHideoutStatics_GetSceneManager");
static_assert(offsetof(GzHideoutStatics_GetSceneManager, WorldContext) == 0x000000, "Member 'GzHideoutStatics_GetSceneManager::WorldContext' has a wrong offset!");
static_assert(offsetof(GzHideoutStatics_GetSceneManager, ReturnValue) == 0x000008, "Member 'GzHideoutStatics_GetSceneManager::ReturnValue' has a wrong offset!");

// Function G01.GzHideoutStatics.GetSceneManagerChecked
// 0x0010 (0x0010 - 0x0000)
struct GzHideoutStatics_GetSceneManagerChecked final
{
public:
	const class UObject*                          WorldContext;                                      // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AGzSceneManager*                        ReturnValue;                                       // 0x0008(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzHideoutStatics_GetSceneManagerChecked) == 0x000008, "Wrong alignment on GzHideoutStatics_GetSceneManagerChecked");
static_assert(sizeof(GzHideoutStatics_GetSceneManagerChecked) == 0x000010, "Wrong size on GzHideoutStatics_GetSceneManagerChecked");
static_assert(offsetof(GzHideoutStatics_GetSceneManagerChecked, WorldContext) == 0x000000, "Member 'GzHideoutStatics_GetSceneManagerChecked::WorldContext' has a wrong offset!");
static_assert(offsetof(GzHideoutStatics_GetSceneManagerChecked, ReturnValue) == 0x000008, "Member 'GzHideoutStatics_GetSceneManagerChecked::ReturnValue' has a wrong offset!");

// Function G01.GzHideoutStatics.GetScenePuppeteerChecked
// 0x0010 (0x0010 - 0x0000)
struct GzHideoutStatics_GetScenePuppeteerChecked final
{
public:
	const class UObject*                          WorldContext;                                      // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UGzScenePuppeteer*                      ReturnValue;                                       // 0x0008(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzHideoutStatics_GetScenePuppeteerChecked) == 0x000008, "Wrong alignment on GzHideoutStatics_GetScenePuppeteerChecked");
static_assert(sizeof(GzHideoutStatics_GetScenePuppeteerChecked) == 0x000010, "Wrong size on GzHideoutStatics_GetScenePuppeteerChecked");
static_assert(offsetof(GzHideoutStatics_GetScenePuppeteerChecked, WorldContext) == 0x000000, "Member 'GzHideoutStatics_GetScenePuppeteerChecked::WorldContext' has a wrong offset!");
static_assert(offsetof(GzHideoutStatics_GetScenePuppeteerChecked, ReturnValue) == 0x000008, "Member 'GzHideoutStatics_GetScenePuppeteerChecked::ReturnValue' has a wrong offset!");

// Function G01.GzHideoutStatics.ResetCharacterRotation
// 0x0008 (0x0008 - 0x0000)
struct GzHideoutStatics_ResetCharacterRotation final
{
public:
	const class UObject*                          WorldContext;                                      // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzHideoutStatics_ResetCharacterRotation) == 0x000008, "Wrong alignment on GzHideoutStatics_ResetCharacterRotation");
static_assert(sizeof(GzHideoutStatics_ResetCharacterRotation) == 0x000008, "Wrong size on GzHideoutStatics_ResetCharacterRotation");
static_assert(offsetof(GzHideoutStatics_ResetCharacterRotation, WorldContext) == 0x000000, "Member 'GzHideoutStatics_ResetCharacterRotation::WorldContext' has a wrong offset!");

// Function G01.GzHideoutStatics.RotateCharacter
// 0x0028 (0x0028 - 0x0000)
struct GzHideoutStatics_RotateCharacter final
{
public:
	const class UObject*                          WorldContext;                                      // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	double                                        Pitch;                                             // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	double                                        Yaw;                                               // 0x0010(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	double                                        Roll;                                              // 0x0018(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	double                                        Delta;                                             // 0x0020(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzHideoutStatics_RotateCharacter) == 0x000008, "Wrong alignment on GzHideoutStatics_RotateCharacter");
static_assert(sizeof(GzHideoutStatics_RotateCharacter) == 0x000028, "Wrong size on GzHideoutStatics_RotateCharacter");
static_assert(offsetof(GzHideoutStatics_RotateCharacter, WorldContext) == 0x000000, "Member 'GzHideoutStatics_RotateCharacter::WorldContext' has a wrong offset!");
static_assert(offsetof(GzHideoutStatics_RotateCharacter, Pitch) == 0x000008, "Member 'GzHideoutStatics_RotateCharacter::Pitch' has a wrong offset!");
static_assert(offsetof(GzHideoutStatics_RotateCharacter, Yaw) == 0x000010, "Member 'GzHideoutStatics_RotateCharacter::Yaw' has a wrong offset!");
static_assert(offsetof(GzHideoutStatics_RotateCharacter, Roll) == 0x000018, "Member 'GzHideoutStatics_RotateCharacter::Roll' has a wrong offset!");
static_assert(offsetof(GzHideoutStatics_RotateCharacter, Delta) == 0x000020, "Member 'GzHideoutStatics_RotateCharacter::Delta' has a wrong offset!");

// Function G01.GzHideoutStatics.RotateSpawnedWeapon
// 0x0028 (0x0028 - 0x0000)
struct GzHideoutStatics_RotateSpawnedWeapon final
{
public:
	const class UObject*                          WorldContext;                                      // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	double                                        Pitch;                                             // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	double                                        Yaw;                                               // 0x0010(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	double                                        Roll;                                              // 0x0018(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	double                                        Delta;                                             // 0x0020(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzHideoutStatics_RotateSpawnedWeapon) == 0x000008, "Wrong alignment on GzHideoutStatics_RotateSpawnedWeapon");
static_assert(sizeof(GzHideoutStatics_RotateSpawnedWeapon) == 0x000028, "Wrong size on GzHideoutStatics_RotateSpawnedWeapon");
static_assert(offsetof(GzHideoutStatics_RotateSpawnedWeapon, WorldContext) == 0x000000, "Member 'GzHideoutStatics_RotateSpawnedWeapon::WorldContext' has a wrong offset!");
static_assert(offsetof(GzHideoutStatics_RotateSpawnedWeapon, Pitch) == 0x000008, "Member 'GzHideoutStatics_RotateSpawnedWeapon::Pitch' has a wrong offset!");
static_assert(offsetof(GzHideoutStatics_RotateSpawnedWeapon, Yaw) == 0x000010, "Member 'GzHideoutStatics_RotateSpawnedWeapon::Yaw' has a wrong offset!");
static_assert(offsetof(GzHideoutStatics_RotateSpawnedWeapon, Roll) == 0x000018, "Member 'GzHideoutStatics_RotateSpawnedWeapon::Roll' has a wrong offset!");
static_assert(offsetof(GzHideoutStatics_RotateSpawnedWeapon, Delta) == 0x000020, "Member 'GzHideoutStatics_RotateSpawnedWeapon::Delta' has a wrong offset!");

// Function G01.GzHideoutStatics.ToggleCohtmlInput
// 0x0010 (0x0010 - 0x0000)
struct GzHideoutStatics_ToggleCohtmlInput final
{
public:
	bool                                          bEnable;                                           // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2F9F[0x7];                                     // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	const class UObject*                          WorldContext;                                      // 0x0008(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzHideoutStatics_ToggleCohtmlInput) == 0x000008, "Wrong alignment on GzHideoutStatics_ToggleCohtmlInput");
static_assert(sizeof(GzHideoutStatics_ToggleCohtmlInput) == 0x000010, "Wrong size on GzHideoutStatics_ToggleCohtmlInput");
static_assert(offsetof(GzHideoutStatics_ToggleCohtmlInput, bEnable) == 0x000000, "Member 'GzHideoutStatics_ToggleCohtmlInput::bEnable' has a wrong offset!");
static_assert(offsetof(GzHideoutStatics_ToggleCohtmlInput, WorldContext) == 0x000008, "Member 'GzHideoutStatics_ToggleCohtmlInput::WorldContext' has a wrong offset!");

// Function G01.GzBaseTerminal.OnZoneSideSwitched
// 0x0001 (0x0001 - 0x0000)
struct GzBaseTerminal_OnZoneSideSwitched final
{
public:
	bool                                          bInOverloadZone;                                   // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzBaseTerminal_OnZoneSideSwitched) == 0x000001, "Wrong alignment on GzBaseTerminal_OnZoneSideSwitched");
static_assert(sizeof(GzBaseTerminal_OnZoneSideSwitched) == 0x000001, "Wrong size on GzBaseTerminal_OnZoneSideSwitched");
static_assert(offsetof(GzBaseTerminal_OnZoneSideSwitched, bInOverloadZone) == 0x000000, "Member 'GzBaseTerminal_OnZoneSideSwitched::bInOverloadZone' has a wrong offset!");

// Function G01.GzBaseTerminal.ReceiveActiveStateChanged
// 0x0001 (0x0001 - 0x0000)
struct GzBaseTerminal_ReceiveActiveStateChanged final
{
public:
	bool                                          bNewActive;                                        // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzBaseTerminal_ReceiveActiveStateChanged) == 0x000001, "Wrong alignment on GzBaseTerminal_ReceiveActiveStateChanged");
static_assert(sizeof(GzBaseTerminal_ReceiveActiveStateChanged) == 0x000001, "Wrong size on GzBaseTerminal_ReceiveActiveStateChanged");
static_assert(offsetof(GzBaseTerminal_ReceiveActiveStateChanged, bNewActive) == 0x000000, "Member 'GzBaseTerminal_ReceiveActiveStateChanged::bNewActive' has a wrong offset!");

// Function G01.GzBaseTerminal.ReceiveZoneOverloadSwitched
// 0x0001 (0x0001 - 0x0000)
struct GzBaseTerminal_ReceiveZoneOverloadSwitched final
{
public:
	bool                                          bInOverloadZone;                                   // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzBaseTerminal_ReceiveZoneOverloadSwitched) == 0x000001, "Wrong alignment on GzBaseTerminal_ReceiveZoneOverloadSwitched");
static_assert(sizeof(GzBaseTerminal_ReceiveZoneOverloadSwitched) == 0x000001, "Wrong size on GzBaseTerminal_ReceiveZoneOverloadSwitched");
static_assert(offsetof(GzBaseTerminal_ReceiveZoneOverloadSwitched, bInOverloadZone) == 0x000000, "Member 'GzBaseTerminal_ReceiveZoneOverloadSwitched::bInOverloadZone' has a wrong offset!");

// Function G01.GzBaseTerminal.SetIsActive
// 0x0001 (0x0001 - 0x0000)
struct GzBaseTerminal_SetIsActive final
{
public:
	bool                                          bNewActive;                                        // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzBaseTerminal_SetIsActive) == 0x000001, "Wrong alignment on GzBaseTerminal_SetIsActive");
static_assert(sizeof(GzBaseTerminal_SetIsActive) == 0x000001, "Wrong size on GzBaseTerminal_SetIsActive");
static_assert(offsetof(GzBaseTerminal_SetIsActive, bNewActive) == 0x000000, "Member 'GzBaseTerminal_SetIsActive::bNewActive' has a wrong offset!");

// Function G01.GzBaseTerminal.IsActive
// 0x0001 (0x0001 - 0x0000)
struct GzBaseTerminal_IsActive final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzBaseTerminal_IsActive) == 0x000001, "Wrong alignment on GzBaseTerminal_IsActive");
static_assert(sizeof(GzBaseTerminal_IsActive) == 0x000001, "Wrong size on GzBaseTerminal_IsActive");
static_assert(offsetof(GzBaseTerminal_IsActive, ReturnValue) == 0x000000, "Member 'GzBaseTerminal_IsActive::ReturnValue' has a wrong offset!");

// Function G01.GzBaseTerminal.IsInsideOverloadZone
// 0x0001 (0x0001 - 0x0000)
struct GzBaseTerminal_IsInsideOverloadZone final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzBaseTerminal_IsInsideOverloadZone) == 0x000001, "Wrong alignment on GzBaseTerminal_IsInsideOverloadZone");
static_assert(sizeof(GzBaseTerminal_IsInsideOverloadZone) == 0x000001, "Wrong size on GzBaseTerminal_IsInsideOverloadZone");
static_assert(offsetof(GzBaseTerminal_IsInsideOverloadZone, ReturnValue) == 0x000000, "Member 'GzBaseTerminal_IsInsideOverloadZone::ReturnValue' has a wrong offset!");

// Function G01.GzTagSwitcherHorizontal.InitializedTag
// 0x0060 (0x0060 - 0x0000)
struct GzTagSwitcherHorizontal_InitializedTag final
{
public:
	class UUserWidget*                            InParentWidget;                                    // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bResetTagSettings;                                 // 0x0008(0x0001)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2FA4[0x7];                                     // 0x0009(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGzTagVisibilitySettings               InTagSettings;                                     // 0x0010(0x0050)(ConstParm, Parm, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzTagSwitcherHorizontal_InitializedTag) == 0x000008, "Wrong alignment on GzTagSwitcherHorizontal_InitializedTag");
static_assert(sizeof(GzTagSwitcherHorizontal_InitializedTag) == 0x000060, "Wrong size on GzTagSwitcherHorizontal_InitializedTag");
static_assert(offsetof(GzTagSwitcherHorizontal_InitializedTag, InParentWidget) == 0x000000, "Member 'GzTagSwitcherHorizontal_InitializedTag::InParentWidget' has a wrong offset!");
static_assert(offsetof(GzTagSwitcherHorizontal_InitializedTag, bResetTagSettings) == 0x000008, "Member 'GzTagSwitcherHorizontal_InitializedTag::bResetTagSettings' has a wrong offset!");
static_assert(offsetof(GzTagSwitcherHorizontal_InitializedTag, InTagSettings) == 0x000010, "Member 'GzTagSwitcherHorizontal_InitializedTag::InTagSettings' has a wrong offset!");

// Function G01.GzTagSwitcherHorizontal.SetTagVisibility
// 0x0001 (0x0001 - 0x0000)
struct GzTagSwitcherHorizontal_SetTagVisibility final
{
public:
	EGzTargetUITagsState                          TagsState;                                         // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzTagSwitcherHorizontal_SetTagVisibility) == 0x000001, "Wrong alignment on GzTagSwitcherHorizontal_SetTagVisibility");
static_assert(sizeof(GzTagSwitcherHorizontal_SetTagVisibility) == 0x000001, "Wrong size on GzTagSwitcherHorizontal_SetTagVisibility");
static_assert(offsetof(GzTagSwitcherHorizontal_SetTagVisibility, TagsState) == 0x000000, "Member 'GzTagSwitcherHorizontal_SetTagVisibility::TagsState' has a wrong offset!");

// Function G01.GzPartyHelper.IsInParty
// 0x0010 (0x0010 - 0x0000)
struct GzPartyHelper_IsInParty final
{
public:
	const class UObject*                          WorldContextObject;                                // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2FA9[0x7];                                     // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GzPartyHelper_IsInParty) == 0x000008, "Wrong alignment on GzPartyHelper_IsInParty");
static_assert(sizeof(GzPartyHelper_IsInParty) == 0x000010, "Wrong size on GzPartyHelper_IsInParty");
static_assert(offsetof(GzPartyHelper_IsInParty, WorldContextObject) == 0x000000, "Member 'GzPartyHelper_IsInParty::WorldContextObject' has a wrong offset!");
static_assert(offsetof(GzPartyHelper_IsInParty, ReturnValue) == 0x000008, "Member 'GzPartyHelper_IsInParty::ReturnValue' has a wrong offset!");

// Function G01.GzCharacterMovementComponent.GetGroundInfo
// 0x0108 (0x0108 - 0x0000)
struct GzCharacterMovementComponent_GetGroundInfo final
{
public:
	struct FLyraCharacterGroundInfo               ReturnValue;                                       // 0x0000(0x0108)(ConstParm, Parm, OutParm, ReturnParm, ReferenceParm, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzCharacterMovementComponent_GetGroundInfo) == 0x000008, "Wrong alignment on GzCharacterMovementComponent_GetGroundInfo");
static_assert(sizeof(GzCharacterMovementComponent_GetGroundInfo) == 0x000108, "Wrong size on GzCharacterMovementComponent_GetGroundInfo");
static_assert(offsetof(GzCharacterMovementComponent_GetGroundInfo, ReturnValue) == 0x000000, "Member 'GzCharacterMovementComponent_GetGroundInfo::ReturnValue' has a wrong offset!");

// Function G01.GzCharacterMovementComponent.SetCurrentDashParams
// 0x0008 (0x0008 - 0x0000)
struct GzCharacterMovementComponent_SetCurrentDashParams final
{
public:
	const class UGzDashParamsData*                NewDashParamsData;                                 // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzCharacterMovementComponent_SetCurrentDashParams) == 0x000008, "Wrong alignment on GzCharacterMovementComponent_SetCurrentDashParams");
static_assert(sizeof(GzCharacterMovementComponent_SetCurrentDashParams) == 0x000008, "Wrong size on GzCharacterMovementComponent_SetCurrentDashParams");
static_assert(offsetof(GzCharacterMovementComponent_SetCurrentDashParams, NewDashParamsData) == 0x000000, "Member 'GzCharacterMovementComponent_SetCurrentDashParams::NewDashParamsData' has a wrong offset!");

// Function G01.GzCharacterMovementComponent.SetCurrentHoverParams
// 0x001C (0x001C - 0x0000)
struct GzCharacterMovementComponent_SetCurrentHoverParams final
{
public:
	struct FGzHoverParams                         HoverParams;                                       // 0x0000(0x001C)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzCharacterMovementComponent_SetCurrentHoverParams) == 0x000004, "Wrong alignment on GzCharacterMovementComponent_SetCurrentHoverParams");
static_assert(sizeof(GzCharacterMovementComponent_SetCurrentHoverParams) == 0x00001C, "Wrong size on GzCharacterMovementComponent_SetCurrentHoverParams");
static_assert(offsetof(GzCharacterMovementComponent_SetCurrentHoverParams, HoverParams) == 0x000000, "Member 'GzCharacterMovementComponent_SetCurrentHoverParams::HoverParams' has a wrong offset!");

// Function G01.GzCharacterMovementComponent.StartDashing
// 0x0020 (0x0020 - 0x0000)
struct GzCharacterMovementComponent_StartDashing final
{
public:
	bool                                          bClientSimulation;                                 // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2FBC[0x7];                                     // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                Direction;                                         // 0x0008(0x0018)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzCharacterMovementComponent_StartDashing) == 0x000008, "Wrong alignment on GzCharacterMovementComponent_StartDashing");
static_assert(sizeof(GzCharacterMovementComponent_StartDashing) == 0x000020, "Wrong size on GzCharacterMovementComponent_StartDashing");
static_assert(offsetof(GzCharacterMovementComponent_StartDashing, bClientSimulation) == 0x000000, "Member 'GzCharacterMovementComponent_StartDashing::bClientSimulation' has a wrong offset!");
static_assert(offsetof(GzCharacterMovementComponent_StartDashing, Direction) == 0x000008, "Member 'GzCharacterMovementComponent_StartDashing::Direction' has a wrong offset!");

// Function G01.GzCharacterMovementComponent.StartHover
// 0x0001 (0x0001 - 0x0000)
struct GzCharacterMovementComponent_StartHover final
{
public:
	bool                                          bClientSimulation;                                 // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzCharacterMovementComponent_StartHover) == 0x000001, "Wrong alignment on GzCharacterMovementComponent_StartHover");
static_assert(sizeof(GzCharacterMovementComponent_StartHover) == 0x000001, "Wrong size on GzCharacterMovementComponent_StartHover");
static_assert(offsetof(GzCharacterMovementComponent_StartHover, bClientSimulation) == 0x000000, "Member 'GzCharacterMovementComponent_StartHover::bClientSimulation' has a wrong offset!");

// Function G01.GzCharacterMovementComponent.StopDashing
// 0x0001 (0x0001 - 0x0000)
struct GzCharacterMovementComponent_StopDashing final
{
public:
	bool                                          bClientSimulation;                                 // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzCharacterMovementComponent_StopDashing) == 0x000001, "Wrong alignment on GzCharacterMovementComponent_StopDashing");
static_assert(sizeof(GzCharacterMovementComponent_StopDashing) == 0x000001, "Wrong size on GzCharacterMovementComponent_StopDashing");
static_assert(offsetof(GzCharacterMovementComponent_StopDashing, bClientSimulation) == 0x000000, "Member 'GzCharacterMovementComponent_StopDashing::bClientSimulation' has a wrong offset!");

// Function G01.GzCharacterMovementComponent.StopHover
// 0x0001 (0x0001 - 0x0000)
struct GzCharacterMovementComponent_StopHover final
{
public:
	bool                                          bClientSimulation;                                 // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzCharacterMovementComponent_StopHover) == 0x000001, "Wrong alignment on GzCharacterMovementComponent_StopHover");
static_assert(sizeof(GzCharacterMovementComponent_StopHover) == 0x000001, "Wrong size on GzCharacterMovementComponent_StopHover");
static_assert(offsetof(GzCharacterMovementComponent_StopHover, bClientSimulation) == 0x000000, "Member 'GzCharacterMovementComponent_StopHover::bClientSimulation' has a wrong offset!");

// Function G01.GzCharacterMovementComponent.GetDashingDirection
// 0x0018 (0x0018 - 0x0000)
struct GzCharacterMovementComponent_GetDashingDirection final
{
public:
	struct FVector                                ReturnValue;                                       // 0x0000(0x0018)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzCharacterMovementComponent_GetDashingDirection) == 0x000008, "Wrong alignment on GzCharacterMovementComponent_GetDashingDirection");
static_assert(sizeof(GzCharacterMovementComponent_GetDashingDirection) == 0x000018, "Wrong size on GzCharacterMovementComponent_GetDashingDirection");
static_assert(offsetof(GzCharacterMovementComponent_GetDashingDirection, ReturnValue) == 0x000000, "Member 'GzCharacterMovementComponent_GetDashingDirection::ReturnValue' has a wrong offset!");

// Function G01.GzCharacterMovementComponent.GetJumpZVelocity
// 0x0008 (0x0008 - 0x0000)
struct GzCharacterMovementComponent_GetJumpZVelocity final
{
public:
	float                                         Height;                                            // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ReturnValue;                                       // 0x0004(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzCharacterMovementComponent_GetJumpZVelocity) == 0x000004, "Wrong alignment on GzCharacterMovementComponent_GetJumpZVelocity");
static_assert(sizeof(GzCharacterMovementComponent_GetJumpZVelocity) == 0x000008, "Wrong size on GzCharacterMovementComponent_GetJumpZVelocity");
static_assert(offsetof(GzCharacterMovementComponent_GetJumpZVelocity, Height) == 0x000000, "Member 'GzCharacterMovementComponent_GetJumpZVelocity::Height' has a wrong offset!");
static_assert(offsetof(GzCharacterMovementComponent_GetJumpZVelocity, ReturnValue) == 0x000004, "Member 'GzCharacterMovementComponent_GetJumpZVelocity::ReturnValue' has a wrong offset!");

// Function G01.GzCharacterMovementComponent.GetMaxJumpTime
// 0x000C (0x000C - 0x0000)
struct GzCharacterMovementComponent_GetMaxJumpTime final
{
public:
	float                                         Height;                                            // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ZVelocity;                                         // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ReturnValue;                                       // 0x0008(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzCharacterMovementComponent_GetMaxJumpTime) == 0x000004, "Wrong alignment on GzCharacterMovementComponent_GetMaxJumpTime");
static_assert(sizeof(GzCharacterMovementComponent_GetMaxJumpTime) == 0x00000C, "Wrong size on GzCharacterMovementComponent_GetMaxJumpTime");
static_assert(offsetof(GzCharacterMovementComponent_GetMaxJumpTime, Height) == 0x000000, "Member 'GzCharacterMovementComponent_GetMaxJumpTime::Height' has a wrong offset!");
static_assert(offsetof(GzCharacterMovementComponent_GetMaxJumpTime, ZVelocity) == 0x000004, "Member 'GzCharacterMovementComponent_GetMaxJumpTime::ZVelocity' has a wrong offset!");
static_assert(offsetof(GzCharacterMovementComponent_GetMaxJumpTime, ReturnValue) == 0x000008, "Member 'GzCharacterMovementComponent_GetMaxJumpTime::ReturnValue' has a wrong offset!");

// Function G01.GzCharacterMovementComponent.HasAppliedRootMotion
// 0x0002 (0x0002 - 0x0000)
struct GzCharacterMovementComponent_HasAppliedRootMotion final
{
public:
	EGzRootMotionSourceType                       RMSType;                                           // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0001(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzCharacterMovementComponent_HasAppliedRootMotion) == 0x000001, "Wrong alignment on GzCharacterMovementComponent_HasAppliedRootMotion");
static_assert(sizeof(GzCharacterMovementComponent_HasAppliedRootMotion) == 0x000002, "Wrong size on GzCharacterMovementComponent_HasAppliedRootMotion");
static_assert(offsetof(GzCharacterMovementComponent_HasAppliedRootMotion, RMSType) == 0x000000, "Member 'GzCharacterMovementComponent_HasAppliedRootMotion::RMSType' has a wrong offset!");
static_assert(offsetof(GzCharacterMovementComponent_HasAppliedRootMotion, ReturnValue) == 0x000001, "Member 'GzCharacterMovementComponent_HasAppliedRootMotion::ReturnValue' has a wrong offset!");

// Function G01.GzCharacterMovementComponent.HasQueuedRootMotion
// 0x0002 (0x0002 - 0x0000)
struct GzCharacterMovementComponent_HasQueuedRootMotion final
{
public:
	EGzRootMotionSourceType                       RMSType;                                           // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0001(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzCharacterMovementComponent_HasQueuedRootMotion) == 0x000001, "Wrong alignment on GzCharacterMovementComponent_HasQueuedRootMotion");
static_assert(sizeof(GzCharacterMovementComponent_HasQueuedRootMotion) == 0x000002, "Wrong size on GzCharacterMovementComponent_HasQueuedRootMotion");
static_assert(offsetof(GzCharacterMovementComponent_HasQueuedRootMotion, RMSType) == 0x000000, "Member 'GzCharacterMovementComponent_HasQueuedRootMotion::RMSType' has a wrong offset!");
static_assert(offsetof(GzCharacterMovementComponent_HasQueuedRootMotion, ReturnValue) == 0x000001, "Member 'GzCharacterMovementComponent_HasQueuedRootMotion::ReturnValue' has a wrong offset!");

// Function G01.GzCharacterMovementComponent.IsDashing
// 0x0001 (0x0001 - 0x0000)
struct GzCharacterMovementComponent_IsDashing final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzCharacterMovementComponent_IsDashing) == 0x000001, "Wrong alignment on GzCharacterMovementComponent_IsDashing");
static_assert(sizeof(GzCharacterMovementComponent_IsDashing) == 0x000001, "Wrong size on GzCharacterMovementComponent_IsDashing");
static_assert(offsetof(GzCharacterMovementComponent_IsDashing, ReturnValue) == 0x000000, "Member 'GzCharacterMovementComponent_IsDashing::ReturnValue' has a wrong offset!");

// Function G01.GzCharacterMovementComponent.IsHovering
// 0x0001 (0x0001 - 0x0000)
struct GzCharacterMovementComponent_IsHovering final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzCharacterMovementComponent_IsHovering) == 0x000001, "Wrong alignment on GzCharacterMovementComponent_IsHovering");
static_assert(sizeof(GzCharacterMovementComponent_IsHovering) == 0x000001, "Wrong size on GzCharacterMovementComponent_IsHovering");
static_assert(offsetof(GzCharacterMovementComponent_IsHovering, ReturnValue) == 0x000000, "Member 'GzCharacterMovementComponent_IsHovering::ReturnValue' has a wrong offset!");

// Function G01.GzCharacterMovementComponent.IsInWingsuitLandingRoll
// 0x0001 (0x0001 - 0x0000)
struct GzCharacterMovementComponent_IsInWingsuitLandingRoll final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzCharacterMovementComponent_IsInWingsuitLandingRoll) == 0x000001, "Wrong alignment on GzCharacterMovementComponent_IsInWingsuitLandingRoll");
static_assert(sizeof(GzCharacterMovementComponent_IsInWingsuitLandingRoll) == 0x000001, "Wrong size on GzCharacterMovementComponent_IsInWingsuitLandingRoll");
static_assert(offsetof(GzCharacterMovementComponent_IsInWingsuitLandingRoll, ReturnValue) == 0x000000, "Member 'GzCharacterMovementComponent_IsInWingsuitLandingRoll::ReturnValue' has a wrong offset!");

// Function G01.GzCharacterMovementComponent.IsWingsuit
// 0x0001 (0x0001 - 0x0000)
struct GzCharacterMovementComponent_IsWingsuit final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzCharacterMovementComponent_IsWingsuit) == 0x000001, "Wrong alignment on GzCharacterMovementComponent_IsWingsuit");
static_assert(sizeof(GzCharacterMovementComponent_IsWingsuit) == 0x000001, "Wrong size on GzCharacterMovementComponent_IsWingsuit");
static_assert(offsetof(GzCharacterMovementComponent_IsWingsuit, ReturnValue) == 0x000000, "Member 'GzCharacterMovementComponent_IsWingsuit::ReturnValue' has a wrong offset!");

// Function G01.GzCombatComponent.ClientSetHostOverheatChanged
// 0x000C (0x000C - 0x0000)
struct GzCombatComponent_ClientSetHostOverheatChanged final
{
public:
	bool                                          bOverheated;                                       // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2FC9[0x3];                                     // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGzInvPocketId                         PocketId;                                          // 0x0004(0x0008)(ConstParm, Parm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzCombatComponent_ClientSetHostOverheatChanged) == 0x000004, "Wrong alignment on GzCombatComponent_ClientSetHostOverheatChanged");
static_assert(sizeof(GzCombatComponent_ClientSetHostOverheatChanged) == 0x00000C, "Wrong size on GzCombatComponent_ClientSetHostOverheatChanged");
static_assert(offsetof(GzCombatComponent_ClientSetHostOverheatChanged, bOverheated) == 0x000000, "Member 'GzCombatComponent_ClientSetHostOverheatChanged::bOverheated' has a wrong offset!");
static_assert(offsetof(GzCombatComponent_ClientSetHostOverheatChanged, PocketId) == 0x000004, "Member 'GzCombatComponent_ClientSetHostOverheatChanged::PocketId' has a wrong offset!");

// Function G01.GzCombatComponent.ClientSyncResourceInClip
// 0x0060 (0x0060 - 0x0000)
struct GzCombatComponent_ClientSyncResourceInClip final
{
public:
	struct FGzWeaponInvItem                       Item;                                              // 0x0000(0x0050)(ConstParm, Parm, ReferenceParm, NativeAccessSpecifierPublic)
	struct FGzInvPocketId                         PocketId;                                          // 0x0050(0x0008)(ConstParm, Parm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         AmountResourceInClip;                              // 0x0058(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         LastProcessedShotId;                               // 0x005C(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2FCA[0x3];                                     // 0x005D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GzCombatComponent_ClientSyncResourceInClip) == 0x000008, "Wrong alignment on GzCombatComponent_ClientSyncResourceInClip");
static_assert(sizeof(GzCombatComponent_ClientSyncResourceInClip) == 0x000060, "Wrong size on GzCombatComponent_ClientSyncResourceInClip");
static_assert(offsetof(GzCombatComponent_ClientSyncResourceInClip, Item) == 0x000000, "Member 'GzCombatComponent_ClientSyncResourceInClip::Item' has a wrong offset!");
static_assert(offsetof(GzCombatComponent_ClientSyncResourceInClip, PocketId) == 0x000050, "Member 'GzCombatComponent_ClientSyncResourceInClip::PocketId' has a wrong offset!");
static_assert(offsetof(GzCombatComponent_ClientSyncResourceInClip, AmountResourceInClip) == 0x000058, "Member 'GzCombatComponent_ClientSyncResourceInClip::AmountResourceInClip' has a wrong offset!");
static_assert(offsetof(GzCombatComponent_ClientSyncResourceInClip, LastProcessedShotId) == 0x00005C, "Member 'GzCombatComponent_ClientSyncResourceInClip::LastProcessedShotId' has a wrong offset!");

// Function G01.GzCombatComponent.DistributeBullets
// 0x0018 (0x0018 - 0x0000)
struct GzCombatComponent_DistributeBullets final
{
public:
	TArray<struct FGzBulletNetData>               BulletsData;                                       // 0x0000(0x0010)(ConstParm, Parm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	struct FGzShotData                            ShotData;                                          // 0x0010(0x0002)(Parm, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          bBulletFromWeapon;                                 // 0x0012(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2FCB[0x5];                                     // 0x0013(0x0005)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GzCombatComponent_DistributeBullets) == 0x000008, "Wrong alignment on GzCombatComponent_DistributeBullets");
static_assert(sizeof(GzCombatComponent_DistributeBullets) == 0x000018, "Wrong size on GzCombatComponent_DistributeBullets");
static_assert(offsetof(GzCombatComponent_DistributeBullets, BulletsData) == 0x000000, "Member 'GzCombatComponent_DistributeBullets::BulletsData' has a wrong offset!");
static_assert(offsetof(GzCombatComponent_DistributeBullets, ShotData) == 0x000010, "Member 'GzCombatComponent_DistributeBullets::ShotData' has a wrong offset!");
static_assert(offsetof(GzCombatComponent_DistributeBullets, bBulletFromWeapon) == 0x000012, "Member 'GzCombatComponent_DistributeBullets::bBulletFromWeapon' has a wrong offset!");

// Function G01.GzCombatComponent.Initialize
// 0x0008 (0x0008 - 0x0000)
struct GzCombatComponent_Initialize final
{
public:
	class USkeletalMeshComponent*                 Mesh;                                              // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzCombatComponent_Initialize) == 0x000008, "Wrong alignment on GzCombatComponent_Initialize");
static_assert(sizeof(GzCombatComponent_Initialize) == 0x000008, "Wrong size on GzCombatComponent_Initialize");
static_assert(offsetof(GzCombatComponent_Initialize, Mesh) == 0x000000, "Member 'GzCombatComponent_Initialize::Mesh' has a wrong offset!");

// Function G01.GzCombatComponent.InitializeWithSockets
// 0x0008 (0x0008 - 0x0000)
struct GzCombatComponent_InitializeWithSockets final
{
public:
	class USkeletalMeshComponent*                 Mesh;                                              // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzCombatComponent_InitializeWithSockets) == 0x000008, "Wrong alignment on GzCombatComponent_InitializeWithSockets");
static_assert(sizeof(GzCombatComponent_InitializeWithSockets) == 0x000008, "Wrong size on GzCombatComponent_InitializeWithSockets");
static_assert(offsetof(GzCombatComponent_InitializeWithSockets, Mesh) == 0x000000, "Member 'GzCombatComponent_InitializeWithSockets::Mesh' has a wrong offset!");

// Function G01.GzCombatComponent.OnAbilityActivationFailed
// 0x0028 (0x0028 - 0x0000)
struct GzCombatComponent_OnAbilityActivationFailed final
{
public:
	const class UGameplayAbility*                 FailedAbility;                                     // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTagContainer                  FailureReasonTags;                                 // 0x0008(0x0020)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzCombatComponent_OnAbilityActivationFailed) == 0x000008, "Wrong alignment on GzCombatComponent_OnAbilityActivationFailed");
static_assert(sizeof(GzCombatComponent_OnAbilityActivationFailed) == 0x000028, "Wrong size on GzCombatComponent_OnAbilityActivationFailed");
static_assert(offsetof(GzCombatComponent_OnAbilityActivationFailed, FailedAbility) == 0x000000, "Member 'GzCombatComponent_OnAbilityActivationFailed::FailedAbility' has a wrong offset!");
static_assert(offsetof(GzCombatComponent_OnAbilityActivationFailed, FailureReasonTags) == 0x000008, "Member 'GzCombatComponent_OnAbilityActivationFailed::FailureReasonTags' has a wrong offset!");

// Function G01.GzCombatComponent.OnRep_EquippedPocket
// 0x0008 (0x0008 - 0x0000)
struct GzCombatComponent_OnRep_EquippedPocket final
{
public:
	struct FGzInvPocketId                         OldPocketID;                                       // 0x0000(0x0008)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzCombatComponent_OnRep_EquippedPocket) == 0x000004, "Wrong alignment on GzCombatComponent_OnRep_EquippedPocket");
static_assert(sizeof(GzCombatComponent_OnRep_EquippedPocket) == 0x000008, "Wrong size on GzCombatComponent_OnRep_EquippedPocket");
static_assert(offsetof(GzCombatComponent_OnRep_EquippedPocket, OldPocketID) == 0x000000, "Member 'GzCombatComponent_OnRep_EquippedPocket::OldPocketID' has a wrong offset!");

// Function G01.GzCombatComponent.ServerDistributeBullets
// 0x0018 (0x0018 - 0x0000)
struct GzCombatComponent_ServerDistributeBullets final
{
public:
	TArray<struct FGzBulletNetData>               BulletsData;                                       // 0x0000(0x0010)(ConstParm, Parm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	struct FGzShotData                            ShotData;                                          // 0x0010(0x0002)(Parm, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          bBulletFromWeapon;                                 // 0x0012(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2FCC[0x5];                                     // 0x0013(0x0005)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GzCombatComponent_ServerDistributeBullets) == 0x000008, "Wrong alignment on GzCombatComponent_ServerDistributeBullets");
static_assert(sizeof(GzCombatComponent_ServerDistributeBullets) == 0x000018, "Wrong size on GzCombatComponent_ServerDistributeBullets");
static_assert(offsetof(GzCombatComponent_ServerDistributeBullets, BulletsData) == 0x000000, "Member 'GzCombatComponent_ServerDistributeBullets::BulletsData' has a wrong offset!");
static_assert(offsetof(GzCombatComponent_ServerDistributeBullets, ShotData) == 0x000010, "Member 'GzCombatComponent_ServerDistributeBullets::ShotData' has a wrong offset!");
static_assert(offsetof(GzCombatComponent_ServerDistributeBullets, bBulletFromWeapon) == 0x000012, "Member 'GzCombatComponent_ServerDistributeBullets::bBulletFromWeapon' has a wrong offset!");

// Function G01.GzCombatComponent.ServerProcessBulletHit
// 0x0110 (0x0110 - 0x0000)
struct GzCombatComponent_ServerProcessBulletHit final
{
public:
	struct FGzBulletID                            BulletID;                                          // 0x0000(0x000C)(ConstParm, Parm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2FCD[0x4];                                     // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FHitResult                             Hit;                                               // 0x0010(0x00F8)(ConstParm, Parm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	float                                         SyncedWorldTime;                                   // 0x0108(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2FCE[0x4];                                     // 0x010C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GzCombatComponent_ServerProcessBulletHit) == 0x000008, "Wrong alignment on GzCombatComponent_ServerProcessBulletHit");
static_assert(sizeof(GzCombatComponent_ServerProcessBulletHit) == 0x000110, "Wrong size on GzCombatComponent_ServerProcessBulletHit");
static_assert(offsetof(GzCombatComponent_ServerProcessBulletHit, BulletID) == 0x000000, "Member 'GzCombatComponent_ServerProcessBulletHit::BulletID' has a wrong offset!");
static_assert(offsetof(GzCombatComponent_ServerProcessBulletHit, Hit) == 0x000010, "Member 'GzCombatComponent_ServerProcessBulletHit::Hit' has a wrong offset!");
static_assert(offsetof(GzCombatComponent_ServerProcessBulletHit, SyncedWorldTime) == 0x000108, "Member 'GzCombatComponent_ServerProcessBulletHit::SyncedWorldTime' has a wrong offset!");

// Function G01.GzCombatComponent.SetAllWeaponsHidden
// 0x0001 (0x0001 - 0x0000)
struct GzCombatComponent_SetAllWeaponsHidden final
{
public:
	bool                                          bHideWeapons;                                      // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzCombatComponent_SetAllWeaponsHidden) == 0x000001, "Wrong alignment on GzCombatComponent_SetAllWeaponsHidden");
static_assert(sizeof(GzCombatComponent_SetAllWeaponsHidden) == 0x000001, "Wrong size on GzCombatComponent_SetAllWeaponsHidden");
static_assert(offsetof(GzCombatComponent_SetAllWeaponsHidden, bHideWeapons) == 0x000000, "Member 'GzCombatComponent_SetAllWeaponsHidden::bHideWeapons' has a wrong offset!");

// Function G01.GzCombatComponent.SwitchEquippedWeaponSocket
// 0x0001 (0x0001 - 0x0000)
struct GzCombatComponent_SwitchEquippedWeaponSocket final
{
public:
	bool                                          bUseUnholserAnim;                                  // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzCombatComponent_SwitchEquippedWeaponSocket) == 0x000001, "Wrong alignment on GzCombatComponent_SwitchEquippedWeaponSocket");
static_assert(sizeof(GzCombatComponent_SwitchEquippedWeaponSocket) == 0x000001, "Wrong size on GzCombatComponent_SwitchEquippedWeaponSocket");
static_assert(offsetof(GzCombatComponent_SwitchEquippedWeaponSocket, bUseUnholserAnim) == 0x000000, "Member 'GzCombatComponent_SwitchEquippedWeaponSocket::bUseUnholserAnim' has a wrong offset!");

// Function G01.GzCombatComponent.ActivateEquipPreviousWeaponAbility
// 0x0008 (0x0008 - 0x0000)
struct GzCombatComponent_ActivateEquipPreviousWeaponAbility final
{
public:
	class FName                                   SocketName;                                        // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzCombatComponent_ActivateEquipPreviousWeaponAbility) == 0x000004, "Wrong alignment on GzCombatComponent_ActivateEquipPreviousWeaponAbility");
static_assert(sizeof(GzCombatComponent_ActivateEquipPreviousWeaponAbility) == 0x000008, "Wrong size on GzCombatComponent_ActivateEquipPreviousWeaponAbility");
static_assert(offsetof(GzCombatComponent_ActivateEquipPreviousWeaponAbility, SocketName) == 0x000000, "Member 'GzCombatComponent_ActivateEquipPreviousWeaponAbility::SocketName' has a wrong offset!");

// Function G01.GzCombatComponent.CanEquip
// 0x000C (0x000C - 0x0000)
struct GzCombatComponent_CanEquip final
{
public:
	struct FGzInvPocketId                         WeaponPocket;                                      // 0x0000(0x0008)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2FCF[0x3];                                     // 0x0009(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GzCombatComponent_CanEquip) == 0x000004, "Wrong alignment on GzCombatComponent_CanEquip");
static_assert(sizeof(GzCombatComponent_CanEquip) == 0x00000C, "Wrong size on GzCombatComponent_CanEquip");
static_assert(offsetof(GzCombatComponent_CanEquip, WeaponPocket) == 0x000000, "Member 'GzCombatComponent_CanEquip::WeaponPocket' has a wrong offset!");
static_assert(offsetof(GzCombatComponent_CanEquip, ReturnValue) == 0x000008, "Member 'GzCombatComponent_CanEquip::ReturnValue' has a wrong offset!");

// Function G01.GzCombatComponent.EquippedWeaponCanAttack
// 0x0001 (0x0001 - 0x0000)
struct GzCombatComponent_EquippedWeaponCanAttack final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzCombatComponent_EquippedWeaponCanAttack) == 0x000001, "Wrong alignment on GzCombatComponent_EquippedWeaponCanAttack");
static_assert(sizeof(GzCombatComponent_EquippedWeaponCanAttack) == 0x000001, "Wrong size on GzCombatComponent_EquippedWeaponCanAttack");
static_assert(offsetof(GzCombatComponent_EquippedWeaponCanAttack, ReturnValue) == 0x000000, "Member 'GzCombatComponent_EquippedWeaponCanAttack::ReturnValue' has a wrong offset!");

// Function G01.GzCombatComponent.EquipWeaponAtPocket
// 0x0010 (0x0010 - 0x0000)
struct GzCombatComponent_EquipWeaponAtPocket final
{
public:
	struct FGzInvPocketId                         PocketId;                                          // 0x0000(0x0008)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   SocketName;                                        // 0x0008(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzCombatComponent_EquipWeaponAtPocket) == 0x000004, "Wrong alignment on GzCombatComponent_EquipWeaponAtPocket");
static_assert(sizeof(GzCombatComponent_EquipWeaponAtPocket) == 0x000010, "Wrong size on GzCombatComponent_EquipWeaponAtPocket");
static_assert(offsetof(GzCombatComponent_EquipWeaponAtPocket, PocketId) == 0x000000, "Member 'GzCombatComponent_EquipWeaponAtPocket::PocketId' has a wrong offset!");
static_assert(offsetof(GzCombatComponent_EquipWeaponAtPocket, SocketName) == 0x000008, "Member 'GzCombatComponent_EquipWeaponAtPocket::SocketName' has a wrong offset!");

// Function G01.GzCombatComponent.GetAbilitySystemComponent
// 0x0008 (0x0008 - 0x0000)
struct GzCombatComponent_GetAbilitySystemComponent final
{
public:
	class UGzAbilitySystemComponent*              ReturnValue;                                       // 0x0000(0x0008)(ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzCombatComponent_GetAbilitySystemComponent) == 0x000008, "Wrong alignment on GzCombatComponent_GetAbilitySystemComponent");
static_assert(sizeof(GzCombatComponent_GetAbilitySystemComponent) == 0x000008, "Wrong size on GzCombatComponent_GetAbilitySystemComponent");
static_assert(offsetof(GzCombatComponent_GetAbilitySystemComponent, ReturnValue) == 0x000000, "Member 'GzCombatComponent_GetAbilitySystemComponent::ReturnValue' has a wrong offset!");

// Function G01.GzCombatComponent.GetAdvancedCameraComponent
// 0x0008 (0x0008 - 0x0000)
struct GzCombatComponent_GetAdvancedCameraComponent final
{
public:
	class UATPCCameraComponent*                   ReturnValue;                                       // 0x0000(0x0008)(ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzCombatComponent_GetAdvancedCameraComponent) == 0x000008, "Wrong alignment on GzCombatComponent_GetAdvancedCameraComponent");
static_assert(sizeof(GzCombatComponent_GetAdvancedCameraComponent) == 0x000008, "Wrong size on GzCombatComponent_GetAdvancedCameraComponent");
static_assert(offsetof(GzCombatComponent_GetAdvancedCameraComponent, ReturnValue) == 0x000000, "Member 'GzCombatComponent_GetAdvancedCameraComponent::ReturnValue' has a wrong offset!");

// Function G01.GzCombatComponent.GetAllWeaponComponents
// 0x0010 (0x0010 - 0x0000)
struct GzCombatComponent_GetAllWeaponComponents final
{
public:
	TArray<class UGzWeaponComponent*>             OutWeapons;                                        // 0x0000(0x0010)(Parm, OutParm, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzCombatComponent_GetAllWeaponComponents) == 0x000008, "Wrong alignment on GzCombatComponent_GetAllWeaponComponents");
static_assert(sizeof(GzCombatComponent_GetAllWeaponComponents) == 0x000010, "Wrong size on GzCombatComponent_GetAllWeaponComponents");
static_assert(offsetof(GzCombatComponent_GetAllWeaponComponents, OutWeapons) == 0x000000, "Member 'GzCombatComponent_GetAllWeaponComponents::OutWeapons' has a wrong offset!");

// Function G01.GzCombatComponent.GetAllWeapons
// 0x0010 (0x0010 - 0x0000)
struct GzCombatComponent_GetAllWeapons final
{
public:
	TArray<class AGzWeaponActor*>                 OutWeapons;                                        // 0x0000(0x0010)(Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzCombatComponent_GetAllWeapons) == 0x000008, "Wrong alignment on GzCombatComponent_GetAllWeapons");
static_assert(sizeof(GzCombatComponent_GetAllWeapons) == 0x000010, "Wrong size on GzCombatComponent_GetAllWeapons");
static_assert(offsetof(GzCombatComponent_GetAllWeapons, OutWeapons) == 0x000000, "Member 'GzCombatComponent_GetAllWeapons::OutWeapons' has a wrong offset!");

// Function G01.GzCombatComponent.GetDesiredPocket
// 0x0008 (0x0008 - 0x0000)
struct GzCombatComponent_GetDesiredPocket final
{
public:
	struct FGzInvPocketId                         ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzCombatComponent_GetDesiredPocket) == 0x000004, "Wrong alignment on GzCombatComponent_GetDesiredPocket");
static_assert(sizeof(GzCombatComponent_GetDesiredPocket) == 0x000008, "Wrong size on GzCombatComponent_GetDesiredPocket");
static_assert(offsetof(GzCombatComponent_GetDesiredPocket, ReturnValue) == 0x000000, "Member 'GzCombatComponent_GetDesiredPocket::ReturnValue' has a wrong offset!");

// Function G01.GzCombatComponent.GetEquippedPocketID
// 0x0008 (0x0008 - 0x0000)
struct GzCombatComponent_GetEquippedPocketID final
{
public:
	struct FGzInvPocketId                         ReturnValue;                                       // 0x0000(0x0008)(ConstParm, Parm, OutParm, ReturnParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzCombatComponent_GetEquippedPocketID) == 0x000004, "Wrong alignment on GzCombatComponent_GetEquippedPocketID");
static_assert(sizeof(GzCombatComponent_GetEquippedPocketID) == 0x000008, "Wrong size on GzCombatComponent_GetEquippedPocketID");
static_assert(offsetof(GzCombatComponent_GetEquippedPocketID, ReturnValue) == 0x000000, "Member 'GzCombatComponent_GetEquippedPocketID::ReturnValue' has a wrong offset!");

// Function G01.GzCombatComponent.GetEquippedWeapon
// 0x0008 (0x0008 - 0x0000)
struct GzCombatComponent_GetEquippedWeapon final
{
public:
	class AGzWeaponActor*                         ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzCombatComponent_GetEquippedWeapon) == 0x000008, "Wrong alignment on GzCombatComponent_GetEquippedWeapon");
static_assert(sizeof(GzCombatComponent_GetEquippedWeapon) == 0x000008, "Wrong size on GzCombatComponent_GetEquippedWeapon");
static_assert(offsetof(GzCombatComponent_GetEquippedWeapon, ReturnValue) == 0x000000, "Member 'GzCombatComponent_GetEquippedWeapon::ReturnValue' has a wrong offset!");

// Function G01.GzCombatComponent.GetEquippedWeaponComponent
// 0x0008 (0x0008 - 0x0000)
struct GzCombatComponent_GetEquippedWeaponComponent final
{
public:
	class UGzWeaponComponent*                     ReturnValue;                                       // 0x0000(0x0008)(ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzCombatComponent_GetEquippedWeaponComponent) == 0x000008, "Wrong alignment on GzCombatComponent_GetEquippedWeaponComponent");
static_assert(sizeof(GzCombatComponent_GetEquippedWeaponComponent) == 0x000008, "Wrong size on GzCombatComponent_GetEquippedWeaponComponent");
static_assert(offsetof(GzCombatComponent_GetEquippedWeaponComponent, ReturnValue) == 0x000000, "Member 'GzCombatComponent_GetEquippedWeaponComponent::ReturnValue' has a wrong offset!");

// Function G01.GzCombatComponent.GetInventoryComponent
// 0x0008 (0x0008 - 0x0000)
struct GzCombatComponent_GetInventoryComponent final
{
public:
	class UGzInvComponent*                        ReturnValue;                                       // 0x0000(0x0008)(ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzCombatComponent_GetInventoryComponent) == 0x000008, "Wrong alignment on GzCombatComponent_GetInventoryComponent");
static_assert(sizeof(GzCombatComponent_GetInventoryComponent) == 0x000008, "Wrong size on GzCombatComponent_GetInventoryComponent");
static_assert(offsetof(GzCombatComponent_GetInventoryComponent, ReturnValue) == 0x000000, "Member 'GzCombatComponent_GetInventoryComponent::ReturnValue' has a wrong offset!");

// Function G01.GzCombatComponent.GetIsAiming
// 0x0001 (0x0001 - 0x0000)
struct GzCombatComponent_GetIsAiming final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzCombatComponent_GetIsAiming) == 0x000001, "Wrong alignment on GzCombatComponent_GetIsAiming");
static_assert(sizeof(GzCombatComponent_GetIsAiming) == 0x000001, "Wrong size on GzCombatComponent_GetIsAiming");
static_assert(offsetof(GzCombatComponent_GetIsAiming, ReturnValue) == 0x000000, "Member 'GzCombatComponent_GetIsAiming::ReturnValue' has a wrong offset!");

// Function G01.GzCombatComponent.GetMesh
// 0x0008 (0x0008 - 0x0000)
struct GzCombatComponent_GetMesh final
{
public:
	class USkeletalMeshComponent*                 ReturnValue;                                       // 0x0000(0x0008)(ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzCombatComponent_GetMesh) == 0x000008, "Wrong alignment on GzCombatComponent_GetMesh");
static_assert(sizeof(GzCombatComponent_GetMesh) == 0x000008, "Wrong size on GzCombatComponent_GetMesh");
static_assert(offsetof(GzCombatComponent_GetMesh, ReturnValue) == 0x000000, "Member 'GzCombatComponent_GetMesh::ReturnValue' has a wrong offset!");

// Function G01.GzCombatComponent.GetOwnerPawn
// 0x0008 (0x0008 - 0x0000)
struct GzCombatComponent_GetOwnerPawn final
{
public:
	class APawn*                                  ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzCombatComponent_GetOwnerPawn) == 0x000008, "Wrong alignment on GzCombatComponent_GetOwnerPawn");
static_assert(sizeof(GzCombatComponent_GetOwnerPawn) == 0x000008, "Wrong size on GzCombatComponent_GetOwnerPawn");
static_assert(offsetof(GzCombatComponent_GetOwnerPawn, ReturnValue) == 0x000000, "Member 'GzCombatComponent_GetOwnerPawn::ReturnValue' has a wrong offset!");

// Function G01.GzCombatComponent.GetPocketByWeaponComponent
// 0x0010 (0x0010 - 0x0000)
struct GzCombatComponent_GetPocketByWeaponComponent final
{
public:
	const class UGzWeaponComponent*               WeaponComponent;                                   // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGzInvPocketId                         ReturnValue;                                       // 0x0008(0x0008)(Parm, OutParm, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzCombatComponent_GetPocketByWeaponComponent) == 0x000008, "Wrong alignment on GzCombatComponent_GetPocketByWeaponComponent");
static_assert(sizeof(GzCombatComponent_GetPocketByWeaponComponent) == 0x000010, "Wrong size on GzCombatComponent_GetPocketByWeaponComponent");
static_assert(offsetof(GzCombatComponent_GetPocketByWeaponComponent, WeaponComponent) == 0x000000, "Member 'GzCombatComponent_GetPocketByWeaponComponent::WeaponComponent' has a wrong offset!");
static_assert(offsetof(GzCombatComponent_GetPocketByWeaponComponent, ReturnValue) == 0x000008, "Member 'GzCombatComponent_GetPocketByWeaponComponent::ReturnValue' has a wrong offset!");

// Function G01.GzCombatComponent.GetPreviousEquippedPocketID
// 0x0008 (0x0008 - 0x0000)
struct GzCombatComponent_GetPreviousEquippedPocketID final
{
public:
	struct FGzInvPocketId                         ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzCombatComponent_GetPreviousEquippedPocketID) == 0x000004, "Wrong alignment on GzCombatComponent_GetPreviousEquippedPocketID");
static_assert(sizeof(GzCombatComponent_GetPreviousEquippedPocketID) == 0x000008, "Wrong size on GzCombatComponent_GetPreviousEquippedPocketID");
static_assert(offsetof(GzCombatComponent_GetPreviousEquippedPocketID, ReturnValue) == 0x000000, "Member 'GzCombatComponent_GetPreviousEquippedPocketID::ReturnValue' has a wrong offset!");

// Function G01.GzCombatComponent.GetViewHitResult
// 0x00F8 (0x00F8 - 0x0000)
struct GzCombatComponent_GetViewHitResult final
{
public:
	struct FHitResult                             ReturnValue;                                       // 0x0000(0x00F8)(ConstParm, Parm, OutParm, ReturnParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzCombatComponent_GetViewHitResult) == 0x000008, "Wrong alignment on GzCombatComponent_GetViewHitResult");
static_assert(sizeof(GzCombatComponent_GetViewHitResult) == 0x0000F8, "Wrong size on GzCombatComponent_GetViewHitResult");
static_assert(offsetof(GzCombatComponent_GetViewHitResult, ReturnValue) == 0x000000, "Member 'GzCombatComponent_GetViewHitResult::ReturnValue' has a wrong offset!");

// Function G01.GzCombatComponent.GetWeaponAtPocket
// 0x0010 (0x0010 - 0x0000)
struct GzCombatComponent_GetWeaponAtPocket final
{
public:
	struct FGzInvPocketId                         PocketId;                                          // 0x0000(0x0008)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AGzWeaponActor*                         ReturnValue;                                       // 0x0008(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzCombatComponent_GetWeaponAtPocket) == 0x000008, "Wrong alignment on GzCombatComponent_GetWeaponAtPocket");
static_assert(sizeof(GzCombatComponent_GetWeaponAtPocket) == 0x000010, "Wrong size on GzCombatComponent_GetWeaponAtPocket");
static_assert(offsetof(GzCombatComponent_GetWeaponAtPocket, PocketId) == 0x000000, "Member 'GzCombatComponent_GetWeaponAtPocket::PocketId' has a wrong offset!");
static_assert(offsetof(GzCombatComponent_GetWeaponAtPocket, ReturnValue) == 0x000008, "Member 'GzCombatComponent_GetWeaponAtPocket::ReturnValue' has a wrong offset!");

// Function G01.GzCombatComponent.GetWeaponComponentAtPocket
// 0x0010 (0x0010 - 0x0000)
struct GzCombatComponent_GetWeaponComponentAtPocket final
{
public:
	struct FGzInvPocketId                         PocketId;                                          // 0x0000(0x0008)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UGzWeaponComponent*                     ReturnValue;                                       // 0x0008(0x0008)(ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzCombatComponent_GetWeaponComponentAtPocket) == 0x000008, "Wrong alignment on GzCombatComponent_GetWeaponComponentAtPocket");
static_assert(sizeof(GzCombatComponent_GetWeaponComponentAtPocket) == 0x000010, "Wrong size on GzCombatComponent_GetWeaponComponentAtPocket");
static_assert(offsetof(GzCombatComponent_GetWeaponComponentAtPocket, PocketId) == 0x000000, "Member 'GzCombatComponent_GetWeaponComponentAtPocket::PocketId' has a wrong offset!");
static_assert(offsetof(GzCombatComponent_GetWeaponComponentAtPocket, ReturnValue) == 0x000008, "Member 'GzCombatComponent_GetWeaponComponentAtPocket::ReturnValue' has a wrong offset!");

// Function G01.GzCombatComponent.HasEquippedWeapon
// 0x0001 (0x0001 - 0x0000)
struct GzCombatComponent_HasEquippedWeapon final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzCombatComponent_HasEquippedWeapon) == 0x000001, "Wrong alignment on GzCombatComponent_HasEquippedWeapon");
static_assert(sizeof(GzCombatComponent_HasEquippedWeapon) == 0x000001, "Wrong size on GzCombatComponent_HasEquippedWeapon");
static_assert(offsetof(GzCombatComponent_HasEquippedWeapon, ReturnValue) == 0x000000, "Member 'GzCombatComponent_HasEquippedWeapon::ReturnValue' has a wrong offset!");

// Function G01.GzCombatComponent.HasSingleSocket
// 0x0001 (0x0001 - 0x0000)
struct GzCombatComponent_HasSingleSocket final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzCombatComponent_HasSingleSocket) == 0x000001, "Wrong alignment on GzCombatComponent_HasSingleSocket");
static_assert(sizeof(GzCombatComponent_HasSingleSocket) == 0x000001, "Wrong size on GzCombatComponent_HasSingleSocket");
static_assert(offsetof(GzCombatComponent_HasSingleSocket, ReturnValue) == 0x000000, "Member 'GzCombatComponent_HasSingleSocket::ReturnValue' has a wrong offset!");

// Function G01.GzCombatComponent.HolsterWeaponAtPocket
// 0x0008 (0x0008 - 0x0000)
struct GzCombatComponent_HolsterWeaponAtPocket final
{
public:
	struct FGzInvPocketId                         PocketId;                                          // 0x0000(0x0008)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzCombatComponent_HolsterWeaponAtPocket) == 0x000004, "Wrong alignment on GzCombatComponent_HolsterWeaponAtPocket");
static_assert(sizeof(GzCombatComponent_HolsterWeaponAtPocket) == 0x000008, "Wrong size on GzCombatComponent_HolsterWeaponAtPocket");
static_assert(offsetof(GzCombatComponent_HolsterWeaponAtPocket, PocketId) == 0x000000, "Member 'GzCombatComponent_HolsterWeaponAtPocket::PocketId' has a wrong offset!");

// Function G01.GzCombatComponent.IsDesiredWeaponPocket
// 0x000C (0x000C - 0x0000)
struct GzCombatComponent_IsDesiredWeaponPocket final
{
public:
	struct FGzInvPocketId                         WeaponPocket;                                      // 0x0000(0x0008)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2FD0[0x3];                                     // 0x0009(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GzCombatComponent_IsDesiredWeaponPocket) == 0x000004, "Wrong alignment on GzCombatComponent_IsDesiredWeaponPocket");
static_assert(sizeof(GzCombatComponent_IsDesiredWeaponPocket) == 0x00000C, "Wrong size on GzCombatComponent_IsDesiredWeaponPocket");
static_assert(offsetof(GzCombatComponent_IsDesiredWeaponPocket, WeaponPocket) == 0x000000, "Member 'GzCombatComponent_IsDesiredWeaponPocket::WeaponPocket' has a wrong offset!");
static_assert(offsetof(GzCombatComponent_IsDesiredWeaponPocket, ReturnValue) == 0x000008, "Member 'GzCombatComponent_IsDesiredWeaponPocket::ReturnValue' has a wrong offset!");

// Function G01.GzCombatComponent.IsEquippedWeapon
// 0x0010 (0x0010 - 0x0000)
struct GzCombatComponent_IsEquippedWeapon final
{
public:
	const class UGzWeaponComponent*               GzWeaponComponent;                                 // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2FD1[0x7];                                     // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GzCombatComponent_IsEquippedWeapon) == 0x000008, "Wrong alignment on GzCombatComponent_IsEquippedWeapon");
static_assert(sizeof(GzCombatComponent_IsEquippedWeapon) == 0x000010, "Wrong size on GzCombatComponent_IsEquippedWeapon");
static_assert(offsetof(GzCombatComponent_IsEquippedWeapon, GzWeaponComponent) == 0x000000, "Member 'GzCombatComponent_IsEquippedWeapon::GzWeaponComponent' has a wrong offset!");
static_assert(offsetof(GzCombatComponent_IsEquippedWeapon, ReturnValue) == 0x000008, "Member 'GzCombatComponent_IsEquippedWeapon::ReturnValue' has a wrong offset!");

// Function G01.GzCombatComponent.IsEquippedWeaponPocket
// 0x000C (0x000C - 0x0000)
struct GzCombatComponent_IsEquippedWeaponPocket final
{
public:
	struct FGzInvPocketId                         WeaponPocket;                                      // 0x0000(0x0008)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2FD2[0x3];                                     // 0x0009(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GzCombatComponent_IsEquippedWeaponPocket) == 0x000004, "Wrong alignment on GzCombatComponent_IsEquippedWeaponPocket");
static_assert(sizeof(GzCombatComponent_IsEquippedWeaponPocket) == 0x00000C, "Wrong size on GzCombatComponent_IsEquippedWeaponPocket");
static_assert(offsetof(GzCombatComponent_IsEquippedWeaponPocket, WeaponPocket) == 0x000000, "Member 'GzCombatComponent_IsEquippedWeaponPocket::WeaponPocket' has a wrong offset!");
static_assert(offsetof(GzCombatComponent_IsEquippedWeaponPocket, ReturnValue) == 0x000008, "Member 'GzCombatComponent_IsEquippedWeaponPocket::ReturnValue' has a wrong offset!");

// Function G01.GzCombatComponent.IsInitialized
// 0x0001 (0x0001 - 0x0000)
struct GzCombatComponent_IsInitialized final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzCombatComponent_IsInitialized) == 0x000001, "Wrong alignment on GzCombatComponent_IsInitialized");
static_assert(sizeof(GzCombatComponent_IsInitialized) == 0x000001, "Wrong size on GzCombatComponent_IsInitialized");
static_assert(offsetof(GzCombatComponent_IsInitialized, ReturnValue) == 0x000000, "Member 'GzCombatComponent_IsInitialized::ReturnValue' has a wrong offset!");

// Function G01.GzCombatComponent.ServerProcessAttackRequest
// 0x0070 (0x0070 - 0x0000)
struct GzCombatComponent_ServerProcessAttackRequest final
{
public:
	struct FGzWeaponInvItem                       Item;                                              // 0x0000(0x0050)(ConstParm, Parm, ReferenceParm, NativeAccessSpecifierPublic)
	struct FGzInvPocketId                         PocketId;                                          // 0x0050(0x0008)(ConstParm, Parm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FGzBulletNetData>               BulletsData;                                       // 0x0058(0x0010)(ConstParm, Parm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	int32                                         AmountResourceInClip;                              // 0x0068(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         InNumberOfSequencedShots;                          // 0x006C(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2FD3[0x3];                                     // 0x006D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GzCombatComponent_ServerProcessAttackRequest) == 0x000008, "Wrong alignment on GzCombatComponent_ServerProcessAttackRequest");
static_assert(sizeof(GzCombatComponent_ServerProcessAttackRequest) == 0x000070, "Wrong size on GzCombatComponent_ServerProcessAttackRequest");
static_assert(offsetof(GzCombatComponent_ServerProcessAttackRequest, Item) == 0x000000, "Member 'GzCombatComponent_ServerProcessAttackRequest::Item' has a wrong offset!");
static_assert(offsetof(GzCombatComponent_ServerProcessAttackRequest, PocketId) == 0x000050, "Member 'GzCombatComponent_ServerProcessAttackRequest::PocketId' has a wrong offset!");
static_assert(offsetof(GzCombatComponent_ServerProcessAttackRequest, BulletsData) == 0x000058, "Member 'GzCombatComponent_ServerProcessAttackRequest::BulletsData' has a wrong offset!");
static_assert(offsetof(GzCombatComponent_ServerProcessAttackRequest, AmountResourceInClip) == 0x000068, "Member 'GzCombatComponent_ServerProcessAttackRequest::AmountResourceInClip' has a wrong offset!");
static_assert(offsetof(GzCombatComponent_ServerProcessAttackRequest, InNumberOfSequencedShots) == 0x00006C, "Member 'GzCombatComponent_ServerProcessAttackRequest::InNumberOfSequencedShots' has a wrong offset!");

// Function G01.GzCombatComponent.TryActivateEquipWeaponAbility
// 0x0010 (0x0010 - 0x0000)
struct GzCombatComponent_TryActivateEquipWeaponAbility final
{
public:
	struct FGzInvPocketId                         PocketId;                                          // 0x0000(0x0008)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   SocketName;                                        // 0x0008(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzCombatComponent_TryActivateEquipWeaponAbility) == 0x000004, "Wrong alignment on GzCombatComponent_TryActivateEquipWeaponAbility");
static_assert(sizeof(GzCombatComponent_TryActivateEquipWeaponAbility) == 0x000010, "Wrong size on GzCombatComponent_TryActivateEquipWeaponAbility");
static_assert(offsetof(GzCombatComponent_TryActivateEquipWeaponAbility, PocketId) == 0x000000, "Member 'GzCombatComponent_TryActivateEquipWeaponAbility::PocketId' has a wrong offset!");
static_assert(offsetof(GzCombatComponent_TryActivateEquipWeaponAbility, SocketName) == 0x000008, "Member 'GzCombatComponent_TryActivateEquipWeaponAbility::SocketName' has a wrong offset!");

// Function G01.GzHexExtractionMessageBase.IsExtractionTeam
// 0x0010 (0x0010 - 0x0000)
struct GzHexExtractionMessageBase_IsExtractionTeam final
{
public:
	const class AGzPlayerState*                   PlayerState;                                       // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2FD6[0x7];                                     // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GzHexExtractionMessageBase_IsExtractionTeam) == 0x000008, "Wrong alignment on GzHexExtractionMessageBase_IsExtractionTeam");
static_assert(sizeof(GzHexExtractionMessageBase_IsExtractionTeam) == 0x000010, "Wrong size on GzHexExtractionMessageBase_IsExtractionTeam");
static_assert(offsetof(GzHexExtractionMessageBase_IsExtractionTeam, PlayerState) == 0x000000, "Member 'GzHexExtractionMessageBase_IsExtractionTeam::PlayerState' has a wrong offset!");
static_assert(offsetof(GzHexExtractionMessageBase_IsExtractionTeam, ReturnValue) == 0x000008, "Member 'GzHexExtractionMessageBase_IsExtractionTeam::ReturnValue' has a wrong offset!");

// Function G01.GzHexExtractionMessageBase.SetAssetID
// 0x0010 (0x0010 - 0x0000)
struct GzHexExtractionMessageBase_SetAssetID final
{
public:
	struct FPrimaryAssetId                        InAssetID;                                         // 0x0000(0x0010)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzHexExtractionMessageBase_SetAssetID) == 0x000004, "Wrong alignment on GzHexExtractionMessageBase_SetAssetID");
static_assert(sizeof(GzHexExtractionMessageBase_SetAssetID) == 0x000010, "Wrong size on GzHexExtractionMessageBase_SetAssetID");
static_assert(offsetof(GzHexExtractionMessageBase_SetAssetID, InAssetID) == 0x000000, "Member 'GzHexExtractionMessageBase_SetAssetID::InAssetID' has a wrong offset!");

// Function G01.GzHexExtractionMessageBase.SetExtractingPlayerId
// 0x0004 (0x0004 - 0x0000)
struct GzHexExtractionMessageBase_SetExtractingPlayerId final
{
public:
	int32                                         InPlayerId;                                        // 0x0000(0x0004)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzHexExtractionMessageBase_SetExtractingPlayerId) == 0x000004, "Wrong alignment on GzHexExtractionMessageBase_SetExtractingPlayerId");
static_assert(sizeof(GzHexExtractionMessageBase_SetExtractingPlayerId) == 0x000004, "Wrong size on GzHexExtractionMessageBase_SetExtractingPlayerId");
static_assert(offsetof(GzHexExtractionMessageBase_SetExtractingPlayerId, InPlayerId) == 0x000000, "Member 'GzHexExtractionMessageBase_SetExtractingPlayerId::InPlayerId' has a wrong offset!");

// Function G01.GzHexExtractionMessageBase.SetExtractionTeamID
// 0x0004 (0x0004 - 0x0000)
struct GzHexExtractionMessageBase_SetExtractionTeamID final
{
public:
	int32                                         TeamID;                                            // 0x0000(0x0004)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzHexExtractionMessageBase_SetExtractionTeamID) == 0x000004, "Wrong alignment on GzHexExtractionMessageBase_SetExtractionTeamID");
static_assert(sizeof(GzHexExtractionMessageBase_SetExtractionTeamID) == 0x000004, "Wrong size on GzHexExtractionMessageBase_SetExtractionTeamID");
static_assert(offsetof(GzHexExtractionMessageBase_SetExtractionTeamID, TeamID) == 0x000000, "Member 'GzHexExtractionMessageBase_SetExtractionTeamID::TeamID' has a wrong offset!");

// Function G01.GzHexExtractionMessageBase.GetExtractingPlayerId
// 0x0004 (0x0004 - 0x0000)
struct GzHexExtractionMessageBase_GetExtractingPlayerId final
{
public:
	int32                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzHexExtractionMessageBase_GetExtractingPlayerId) == 0x000004, "Wrong alignment on GzHexExtractionMessageBase_GetExtractingPlayerId");
static_assert(sizeof(GzHexExtractionMessageBase_GetExtractingPlayerId) == 0x000004, "Wrong size on GzHexExtractionMessageBase_GetExtractingPlayerId");
static_assert(offsetof(GzHexExtractionMessageBase_GetExtractingPlayerId, ReturnValue) == 0x000000, "Member 'GzHexExtractionMessageBase_GetExtractingPlayerId::ReturnValue' has a wrong offset!");

// Function G01.GzHexExtractionMessageBase.GetExtractionTeamID
// 0x0004 (0x0004 - 0x0000)
struct GzHexExtractionMessageBase_GetExtractionTeamID final
{
public:
	int32                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzHexExtractionMessageBase_GetExtractionTeamID) == 0x000004, "Wrong alignment on GzHexExtractionMessageBase_GetExtractionTeamID");
static_assert(sizeof(GzHexExtractionMessageBase_GetExtractionTeamID) == 0x000004, "Wrong size on GzHexExtractionMessageBase_GetExtractionTeamID");
static_assert(offsetof(GzHexExtractionMessageBase_GetExtractionTeamID, ReturnValue) == 0x000000, "Member 'GzHexExtractionMessageBase_GetExtractionTeamID::ReturnValue' has a wrong offset!");

// Function G01.GzHexExtractionMessageBase.GetItemData
// 0x0008 (0x0008 - 0x0000)
struct GzHexExtractionMessageBase_GetItemData final
{
public:
	class UGzItemData*                            ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzHexExtractionMessageBase_GetItemData) == 0x000008, "Wrong alignment on GzHexExtractionMessageBase_GetItemData");
static_assert(sizeof(GzHexExtractionMessageBase_GetItemData) == 0x000008, "Wrong size on GzHexExtractionMessageBase_GetItemData");
static_assert(offsetof(GzHexExtractionMessageBase_GetItemData, ReturnValue) == 0x000000, "Member 'GzHexExtractionMessageBase_GetItemData::ReturnValue' has a wrong offset!");

// Function G01.GzHexExtractionHackBaseMessage.SetHackedTeamID
// 0x0004 (0x0004 - 0x0000)
struct GzHexExtractionHackBaseMessage_SetHackedTeamID final
{
public:
	int32                                         TeamID;                                            // 0x0000(0x0004)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzHexExtractionHackBaseMessage_SetHackedTeamID) == 0x000004, "Wrong alignment on GzHexExtractionHackBaseMessage_SetHackedTeamID");
static_assert(sizeof(GzHexExtractionHackBaseMessage_SetHackedTeamID) == 0x000004, "Wrong size on GzHexExtractionHackBaseMessage_SetHackedTeamID");
static_assert(offsetof(GzHexExtractionHackBaseMessage_SetHackedTeamID, TeamID) == 0x000000, "Member 'GzHexExtractionHackBaseMessage_SetHackedTeamID::TeamID' has a wrong offset!");

// Function G01.GzHexExtractionHackBaseMessage.GetHackedPlayerId
// 0x0004 (0x0004 - 0x0000)
struct GzHexExtractionHackBaseMessage_GetHackedPlayerId final
{
public:
	int32                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzHexExtractionHackBaseMessage_GetHackedPlayerId) == 0x000004, "Wrong alignment on GzHexExtractionHackBaseMessage_GetHackedPlayerId");
static_assert(sizeof(GzHexExtractionHackBaseMessage_GetHackedPlayerId) == 0x000004, "Wrong size on GzHexExtractionHackBaseMessage_GetHackedPlayerId");
static_assert(offsetof(GzHexExtractionHackBaseMessage_GetHackedPlayerId, ReturnValue) == 0x000000, "Member 'GzHexExtractionHackBaseMessage_GetHackedPlayerId::ReturnValue' has a wrong offset!");

// Function G01.GzHexExtractionHackBaseMessage.GetHackedTeamID
// 0x0004 (0x0004 - 0x0000)
struct GzHexExtractionHackBaseMessage_GetHackedTeamID final
{
public:
	int32                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzHexExtractionHackBaseMessage_GetHackedTeamID) == 0x000004, "Wrong alignment on GzHexExtractionHackBaseMessage_GetHackedTeamID");
static_assert(sizeof(GzHexExtractionHackBaseMessage_GetHackedTeamID) == 0x000004, "Wrong size on GzHexExtractionHackBaseMessage_GetHackedTeamID");
static_assert(offsetof(GzHexExtractionHackBaseMessage_GetHackedTeamID, ReturnValue) == 0x000000, "Member 'GzHexExtractionHackBaseMessage_GetHackedTeamID::ReturnValue' has a wrong offset!");

// Function G01.GzHexExtractionHackBaseMessage.IsHackedTeamMessage
// 0x0001 (0x0001 - 0x0000)
struct GzHexExtractionHackBaseMessage_IsHackedTeamMessage final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzHexExtractionHackBaseMessage_IsHackedTeamMessage) == 0x000001, "Wrong alignment on GzHexExtractionHackBaseMessage_IsHackedTeamMessage");
static_assert(sizeof(GzHexExtractionHackBaseMessage_IsHackedTeamMessage) == 0x000001, "Wrong size on GzHexExtractionHackBaseMessage_IsHackedTeamMessage");
static_assert(offsetof(GzHexExtractionHackBaseMessage_IsHackedTeamMessage, ReturnValue) == 0x000000, "Member 'GzHexExtractionHackBaseMessage_IsHackedTeamMessage::ReturnValue' has a wrong offset!");

// Function G01.GzGA_SmokeWall.OnAttackInputPressed
// 0x0004 (0x0004 - 0x0000)
struct GzGA_SmokeWall_OnAttackInputPressed final
{
public:
	float                                         TimeHeld;                                          // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzGA_SmokeWall_OnAttackInputPressed) == 0x000004, "Wrong alignment on GzGA_SmokeWall_OnAttackInputPressed");
static_assert(sizeof(GzGA_SmokeWall_OnAttackInputPressed) == 0x000004, "Wrong size on GzGA_SmokeWall_OnAttackInputPressed");
static_assert(offsetof(GzGA_SmokeWall_OnAttackInputPressed, TimeHeld) == 0x000000, "Member 'GzGA_SmokeWall_OnAttackInputPressed::TimeHeld' has a wrong offset!");

// Function G01.GzGA_SmokeWall.TargetDataReceived
// 0x0028 (0x0028 - 0x0000)
struct GzGA_SmokeWall_TargetDataReceived final
{
public:
	struct FGameplayAbilityTargetDataHandle       Data;                                              // 0x0000(0x0028)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzGA_SmokeWall_TargetDataReceived) == 0x000008, "Wrong alignment on GzGA_SmokeWall_TargetDataReceived");
static_assert(sizeof(GzGA_SmokeWall_TargetDataReceived) == 0x000028, "Wrong size on GzGA_SmokeWall_TargetDataReceived");
static_assert(offsetof(GzGA_SmokeWall_TargetDataReceived, Data) == 0x000000, "Member 'GzGA_SmokeWall_TargetDataReceived::Data' has a wrong offset!");

// Function G01.GzGA_SmokeWall.GetLaunchSocketLocation
// 0x0018 (0x0018 - 0x0000)
struct GzGA_SmokeWall_GetLaunchSocketLocation final
{
public:
	struct FVector                                ReturnValue;                                       // 0x0000(0x0018)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzGA_SmokeWall_GetLaunchSocketLocation) == 0x000008, "Wrong alignment on GzGA_SmokeWall_GetLaunchSocketLocation");
static_assert(sizeof(GzGA_SmokeWall_GetLaunchSocketLocation) == 0x000018, "Wrong size on GzGA_SmokeWall_GetLaunchSocketLocation");
static_assert(offsetof(GzGA_SmokeWall_GetLaunchSocketLocation, ReturnValue) == 0x000000, "Member 'GzGA_SmokeWall_GetLaunchSocketLocation::ReturnValue' has a wrong offset!");

// Function G01.GzMultiStageGameState.SetMatchStartTime
// 0x0004 (0x0004 - 0x0000)
struct GzMultiStageGameState_SetMatchStartTime final
{
public:
	float                                         NewMatchStartTime;                                 // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzMultiStageGameState_SetMatchStartTime) == 0x000004, "Wrong alignment on GzMultiStageGameState_SetMatchStartTime");
static_assert(sizeof(GzMultiStageGameState_SetMatchStartTime) == 0x000004, "Wrong size on GzMultiStageGameState_SetMatchStartTime");
static_assert(offsetof(GzMultiStageGameState_SetMatchStartTime, NewMatchStartTime) == 0x000000, "Member 'GzMultiStageGameState_SetMatchStartTime::NewMatchStartTime' has a wrong offset!");

// Function G01.GzMultiStageGameState.SetStageEndTime
// 0x0004 (0x0004 - 0x0000)
struct GzMultiStageGameState_SetStageEndTime final
{
public:
	float                                         NewStageEndTime;                                   // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzMultiStageGameState_SetStageEndTime) == 0x000004, "Wrong alignment on GzMultiStageGameState_SetStageEndTime");
static_assert(sizeof(GzMultiStageGameState_SetStageEndTime) == 0x000004, "Wrong size on GzMultiStageGameState_SetStageEndTime");
static_assert(offsetof(GzMultiStageGameState_SetStageEndTime, NewStageEndTime) == 0x000000, "Member 'GzMultiStageGameState_SetStageEndTime::NewStageEndTime' has a wrong offset!");

// Function G01.GzMultiStageGameState.SetStageStartTime
// 0x0004 (0x0004 - 0x0000)
struct GzMultiStageGameState_SetStageStartTime final
{
public:
	float                                         NewStageStartTime;                                 // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzMultiStageGameState_SetStageStartTime) == 0x000004, "Wrong alignment on GzMultiStageGameState_SetStageStartTime");
static_assert(sizeof(GzMultiStageGameState_SetStageStartTime) == 0x000004, "Wrong size on GzMultiStageGameState_SetStageStartTime");
static_assert(offsetof(GzMultiStageGameState_SetStageStartTime, NewStageStartTime) == 0x000000, "Member 'GzMultiStageGameState_SetStageStartTime::NewStageStartTime' has a wrong offset!");

// Function G01.GzMultiStageGameState.GetActiveStageTags
// 0x0020 (0x0020 - 0x0000)
struct GzMultiStageGameState_GetActiveStageTags final
{
public:
	struct FGameplayTagContainer                  ReturnValue;                                       // 0x0000(0x0020)(ConstParm, Parm, OutParm, ReturnParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzMultiStageGameState_GetActiveStageTags) == 0x000008, "Wrong alignment on GzMultiStageGameState_GetActiveStageTags");
static_assert(sizeof(GzMultiStageGameState_GetActiveStageTags) == 0x000020, "Wrong size on GzMultiStageGameState_GetActiveStageTags");
static_assert(offsetof(GzMultiStageGameState_GetActiveStageTags, ReturnValue) == 0x000000, "Member 'GzMultiStageGameState_GetActiveStageTags::ReturnValue' has a wrong offset!");

// Function G01.GzMultiStageGameState.GetDeploymentPawnCount
// 0x0004 (0x0004 - 0x0000)
struct GzMultiStageGameState_GetDeploymentPawnCount final
{
public:
	int32                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzMultiStageGameState_GetDeploymentPawnCount) == 0x000004, "Wrong alignment on GzMultiStageGameState_GetDeploymentPawnCount");
static_assert(sizeof(GzMultiStageGameState_GetDeploymentPawnCount) == 0x000004, "Wrong size on GzMultiStageGameState_GetDeploymentPawnCount");
static_assert(offsetof(GzMultiStageGameState_GetDeploymentPawnCount, ReturnValue) == 0x000000, "Member 'GzMultiStageGameState_GetDeploymentPawnCount::ReturnValue' has a wrong offset!");

// Function G01.GzMultiStageGameState.GetStageRemainingTime
// 0x0004 (0x0004 - 0x0000)
struct GzMultiStageGameState_GetStageRemainingTime final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzMultiStageGameState_GetStageRemainingTime) == 0x000004, "Wrong alignment on GzMultiStageGameState_GetStageRemainingTime");
static_assert(sizeof(GzMultiStageGameState_GetStageRemainingTime) == 0x000004, "Wrong size on GzMultiStageGameState_GetStageRemainingTime");
static_assert(offsetof(GzMultiStageGameState_GetStageRemainingTime, ReturnValue) == 0x000000, "Member 'GzMultiStageGameState_GetStageRemainingTime::ReturnValue' has a wrong offset!");

// Function G01.GzMultiStageGameState.GetTimeFromMatchStart
// 0x0004 (0x0004 - 0x0000)
struct GzMultiStageGameState_GetTimeFromMatchStart final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzMultiStageGameState_GetTimeFromMatchStart) == 0x000004, "Wrong alignment on GzMultiStageGameState_GetTimeFromMatchStart");
static_assert(sizeof(GzMultiStageGameState_GetTimeFromMatchStart) == 0x000004, "Wrong size on GzMultiStageGameState_GetTimeFromMatchStart");
static_assert(offsetof(GzMultiStageGameState_GetTimeFromMatchStart, ReturnValue) == 0x000000, "Member 'GzMultiStageGameState_GetTimeFromMatchStart::ReturnValue' has a wrong offset!");

// Function G01.GzMultiStageGameState.GetTimeFromStageStart
// 0x0004 (0x0004 - 0x0000)
struct GzMultiStageGameState_GetTimeFromStageStart final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzMultiStageGameState_GetTimeFromStageStart) == 0x000004, "Wrong alignment on GzMultiStageGameState_GetTimeFromStageStart");
static_assert(sizeof(GzMultiStageGameState_GetTimeFromStageStart) == 0x000004, "Wrong size on GzMultiStageGameState_GetTimeFromStageStart");
static_assert(offsetof(GzMultiStageGameState_GetTimeFromStageStart, ReturnValue) == 0x000000, "Member 'GzMultiStageGameState_GetTimeFromStageStart::ReturnValue' has a wrong offset!");

// Function G01.GzPocketWidget.OnHoldCompleted
// 0x0020 (0x0020 - 0x0000)
struct GzPocketWidget_OnHoldCompleted final
{
public:
	class UCommonButtonBase*                      Button;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FKey                                   HoldingKey;                                        // 0x0008(0x0018)(ConstParm, Parm, OutParm, ReferenceParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzPocketWidget_OnHoldCompleted) == 0x000008, "Wrong alignment on GzPocketWidget_OnHoldCompleted");
static_assert(sizeof(GzPocketWidget_OnHoldCompleted) == 0x000020, "Wrong size on GzPocketWidget_OnHoldCompleted");
static_assert(offsetof(GzPocketWidget_OnHoldCompleted, Button) == 0x000000, "Member 'GzPocketWidget_OnHoldCompleted::Button' has a wrong offset!");
static_assert(offsetof(GzPocketWidget_OnHoldCompleted, HoldingKey) == 0x000008, "Member 'GzPocketWidget_OnHoldCompleted::HoldingKey' has a wrong offset!");

// Function G01.GzPocketWidget.OnPocketChanged_BP
// 0x0010 (0x0010 - 0x0000)
struct GzPocketWidget_OnPocketChanged_BP final
{
public:
	struct FGzInvItem                             NewItem;                                           // 0x0000(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzPocketWidget_OnPocketChanged_BP) == 0x000008, "Wrong alignment on GzPocketWidget_OnPocketChanged_BP");
static_assert(sizeof(GzPocketWidget_OnPocketChanged_BP) == 0x000010, "Wrong size on GzPocketWidget_OnPocketChanged_BP");
static_assert(offsetof(GzPocketWidget_OnPocketChanged_BP, NewItem) == 0x000000, "Member 'GzPocketWidget_OnPocketChanged_BP::NewItem' has a wrong offset!");

// Function G01.GzPocketWidget.OnRightClick
// 0x0008 (0x0008 - 0x0000)
struct GzPocketWidget_OnRightClick final
{
public:
	class UCommonButtonBase*                      Button;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzPocketWidget_OnRightClick) == 0x000008, "Wrong alignment on GzPocketWidget_OnRightClick");
static_assert(sizeof(GzPocketWidget_OnRightClick) == 0x000008, "Wrong size on GzPocketWidget_OnRightClick");
static_assert(offsetof(GzPocketWidget_OnRightClick, Button) == 0x000000, "Member 'GzPocketWidget_OnRightClick::Button' has a wrong offset!");

// Function G01.GzPocketWidget.GetPocket
// 0x0028 (0x0028 - 0x0000)
struct GzPocketWidget_GetPocket final
{
public:
	struct FGzInvPocket                           ReturnValue;                                       // 0x0000(0x0028)(ConstParm, Parm, OutParm, ReturnParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzPocketWidget_GetPocket) == 0x000008, "Wrong alignment on GzPocketWidget_GetPocket");
static_assert(sizeof(GzPocketWidget_GetPocket) == 0x000028, "Wrong size on GzPocketWidget_GetPocket");
static_assert(offsetof(GzPocketWidget_GetPocket, ReturnValue) == 0x000000, "Member 'GzPocketWidget_GetPocket::ReturnValue' has a wrong offset!");

// Function G01.GzLimbPocketWidget.OnLimbHealthChanged_BP
// 0x0008 (0x0008 - 0x0000)
struct GzLimbPocketWidget_OnLimbHealthChanged_BP final
{
public:
	float                                         OldHealth;                                         // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         NewHealth;                                         // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzLimbPocketWidget_OnLimbHealthChanged_BP) == 0x000004, "Wrong alignment on GzLimbPocketWidget_OnLimbHealthChanged_BP");
static_assert(sizeof(GzLimbPocketWidget_OnLimbHealthChanged_BP) == 0x000008, "Wrong size on GzLimbPocketWidget_OnLimbHealthChanged_BP");
static_assert(offsetof(GzLimbPocketWidget_OnLimbHealthChanged_BP, OldHealth) == 0x000000, "Member 'GzLimbPocketWidget_OnLimbHealthChanged_BP::OldHealth' has a wrong offset!");
static_assert(offsetof(GzLimbPocketWidget_OnLimbHealthChanged_BP, NewHealth) == 0x000004, "Member 'GzLimbPocketWidget_OnLimbHealthChanged_BP::NewHealth' has a wrong offset!");

// Function G01.GzLimbPocketWidget.GetAbilitySystemComponent
// 0x0008 (0x0008 - 0x0000)
struct GzLimbPocketWidget_GetAbilitySystemComponent final
{
public:
	class UAbilitySystemComponent*                ReturnValue;                                       // 0x0000(0x0008)(ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzLimbPocketWidget_GetAbilitySystemComponent) == 0x000008, "Wrong alignment on GzLimbPocketWidget_GetAbilitySystemComponent");
static_assert(sizeof(GzLimbPocketWidget_GetAbilitySystemComponent) == 0x000008, "Wrong size on GzLimbPocketWidget_GetAbilitySystemComponent");
static_assert(offsetof(GzLimbPocketWidget_GetAbilitySystemComponent, ReturnValue) == 0x000000, "Member 'GzLimbPocketWidget_GetAbilitySystemComponent::ReturnValue' has a wrong offset!");

// Function G01.GzLimbPocketWidget.GetHealthAttribute
// 0x0038 (0x0038 - 0x0000)
struct GzLimbPocketWidget_GetHealthAttribute final
{
public:
	struct FGameplayAttribute                     ReturnValue;                                       // 0x0000(0x0038)(Parm, OutParm, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzLimbPocketWidget_GetHealthAttribute) == 0x000008, "Wrong alignment on GzLimbPocketWidget_GetHealthAttribute");
static_assert(sizeof(GzLimbPocketWidget_GetHealthAttribute) == 0x000038, "Wrong size on GzLimbPocketWidget_GetHealthAttribute");
static_assert(offsetof(GzLimbPocketWidget_GetHealthAttribute, ReturnValue) == 0x000000, "Member 'GzLimbPocketWidget_GetHealthAttribute::ReturnValue' has a wrong offset!");

// Function G01.GzPlayerController.AntiCheatSendToClient
// 0x0010 (0x0010 - 0x0000)
struct GzPlayerController_AntiCheatSendToClient final
{
public:
	TArray<uint8>                                 Data;                                              // 0x0000(0x0010)(ConstParm, Parm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzPlayerController_AntiCheatSendToClient) == 0x000008, "Wrong alignment on GzPlayerController_AntiCheatSendToClient");
static_assert(sizeof(GzPlayerController_AntiCheatSendToClient) == 0x000010, "Wrong size on GzPlayerController_AntiCheatSendToClient");
static_assert(offsetof(GzPlayerController_AntiCheatSendToClient, Data) == 0x000000, "Member 'GzPlayerController_AntiCheatSendToClient::Data' has a wrong offset!");

// Function G01.GzPlayerController.AntiCheatSendToServer
// 0x0010 (0x0010 - 0x0000)
struct GzPlayerController_AntiCheatSendToServer final
{
public:
	TArray<uint8>                                 Data;                                              // 0x0000(0x0010)(ConstParm, Parm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzPlayerController_AntiCheatSendToServer) == 0x000008, "Wrong alignment on GzPlayerController_AntiCheatSendToServer");
static_assert(sizeof(GzPlayerController_AntiCheatSendToServer) == 0x000010, "Wrong size on GzPlayerController_AntiCheatSendToServer");
static_assert(offsetof(GzPlayerController_AntiCheatSendToServer, Data) == 0x000000, "Member 'GzPlayerController_AntiCheatSendToServer::Data' has a wrong offset!");

// Function G01.GzPlayerController.Client_NotifyReceivedHitResponse
// 0x0038 (0x0038 - 0x0000)
struct GzPlayerController_Client_NotifyReceivedHitResponse final
{
public:
	struct FGzHitResponseData                     HitResponseData;                                   // 0x0000(0x0038)(Parm, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzPlayerController_Client_NotifyReceivedHitResponse) == 0x000008, "Wrong alignment on GzPlayerController_Client_NotifyReceivedHitResponse");
static_assert(sizeof(GzPlayerController_Client_NotifyReceivedHitResponse) == 0x000038, "Wrong size on GzPlayerController_Client_NotifyReceivedHitResponse");
static_assert(offsetof(GzPlayerController_Client_NotifyReceivedHitResponse, HitResponseData) == 0x000000, "Member 'GzPlayerController_Client_NotifyReceivedHitResponse::HitResponseData' has a wrong offset!");

// Function G01.GzPlayerController.Client_NotifyRespawnTime
// 0x0004 (0x0004 - 0x0000)
struct GzPlayerController_Client_NotifyRespawnTime final
{
public:
	float                                         RespawnTime;                                       // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzPlayerController_Client_NotifyRespawnTime) == 0x000004, "Wrong alignment on GzPlayerController_Client_NotifyRespawnTime");
static_assert(sizeof(GzPlayerController_Client_NotifyRespawnTime) == 0x000004, "Wrong size on GzPlayerController_Client_NotifyRespawnTime");
static_assert(offsetof(GzPlayerController_Client_NotifyRespawnTime, RespawnTime) == 0x000000, "Member 'GzPlayerController_Client_NotifyRespawnTime::RespawnTime' has a wrong offset!");

// Function G01.GzPlayerController.Client_NotifyTeamRespawnTimeReduced
// 0x0004 (0x0004 - 0x0000)
struct GzPlayerController_Client_NotifyTeamRespawnTimeReduced final
{
public:
	float                                         TimeBonus;                                         // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzPlayerController_Client_NotifyTeamRespawnTimeReduced) == 0x000004, "Wrong alignment on GzPlayerController_Client_NotifyTeamRespawnTimeReduced");
static_assert(sizeof(GzPlayerController_Client_NotifyTeamRespawnTimeReduced) == 0x000004, "Wrong size on GzPlayerController_Client_NotifyTeamRespawnTimeReduced");
static_assert(offsetof(GzPlayerController_Client_NotifyTeamRespawnTimeReduced, TimeBonus) == 0x000000, "Member 'GzPlayerController_Client_NotifyTeamRespawnTimeReduced::TimeBonus' has a wrong offset!");

// Function G01.GzPlayerController.Client_NotifyUpdateRecentPlayers
// 0x0010 (0x0010 - 0x0000)
struct GzPlayerController_Client_NotifyUpdateRecentPlayers final
{
public:
	TArray<class FString>                         PlatformUserIds;                                   // 0x0000(0x0010)(ConstParm, Parm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzPlayerController_Client_NotifyUpdateRecentPlayers) == 0x000008, "Wrong alignment on GzPlayerController_Client_NotifyUpdateRecentPlayers");
static_assert(sizeof(GzPlayerController_Client_NotifyUpdateRecentPlayers) == 0x000010, "Wrong size on GzPlayerController_Client_NotifyUpdateRecentPlayers");
static_assert(offsetof(GzPlayerController_Client_NotifyUpdateRecentPlayers, PlatformUserIds) == 0x000000, "Member 'GzPlayerController_Client_NotifyUpdateRecentPlayers::PlatformUserIds' has a wrong offset!");

// Function G01.GzPlayerController.Client_NotifyViewTargetReceivedDamage
// 0x0018 (0x0018 - 0x0000)
struct GzPlayerController_Client_NotifyViewTargetReceivedDamage final
{
public:
	struct FGzServerDamageInfo                    ServerDamageInfo;                                  // 0x0000(0x0018)(Parm, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzPlayerController_Client_NotifyViewTargetReceivedDamage) == 0x000008, "Wrong alignment on GzPlayerController_Client_NotifyViewTargetReceivedDamage");
static_assert(sizeof(GzPlayerController_Client_NotifyViewTargetReceivedDamage) == 0x000018, "Wrong size on GzPlayerController_Client_NotifyViewTargetReceivedDamage");
static_assert(offsetof(GzPlayerController_Client_NotifyViewTargetReceivedDamage, ServerDamageInfo) == 0x000000, "Member 'GzPlayerController_Client_NotifyViewTargetReceivedDamage::ServerDamageInfo' has a wrong offset!");

// Function G01.GzPlayerController.Client_ResetSpectatorCameraMode
// 0x0008 (0x0008 - 0x0000)
struct GzPlayerController_Client_ResetSpectatorCameraMode final
{
public:
	struct FGameplayTag                           CameraModeTag;                                     // 0x0000(0x0008)(Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzPlayerController_Client_ResetSpectatorCameraMode) == 0x000004, "Wrong alignment on GzPlayerController_Client_ResetSpectatorCameraMode");
static_assert(sizeof(GzPlayerController_Client_ResetSpectatorCameraMode) == 0x000008, "Wrong size on GzPlayerController_Client_ResetSpectatorCameraMode");
static_assert(offsetof(GzPlayerController_Client_ResetSpectatorCameraMode, CameraModeTag) == 0x000000, "Member 'GzPlayerController_Client_ResetSpectatorCameraMode::CameraModeTag' has a wrong offset!");

// Function G01.GzPlayerController.Client_ResetSpectatorOverlayCameraMode
// 0x0001 (0x0001 - 0x0000)
struct GzPlayerController_Client_ResetSpectatorOverlayCameraMode final
{
public:
	bool                                          bWithInterpolation;                                // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzPlayerController_Client_ResetSpectatorOverlayCameraMode) == 0x000001, "Wrong alignment on GzPlayerController_Client_ResetSpectatorOverlayCameraMode");
static_assert(sizeof(GzPlayerController_Client_ResetSpectatorOverlayCameraMode) == 0x000001, "Wrong size on GzPlayerController_Client_ResetSpectatorOverlayCameraMode");
static_assert(offsetof(GzPlayerController_Client_ResetSpectatorOverlayCameraMode, bWithInterpolation) == 0x000000, "Member 'GzPlayerController_Client_ResetSpectatorOverlayCameraMode::bWithInterpolation' has a wrong offset!");

// Function G01.GzPlayerController.Client_SendAudioAnnouncement
// 0x0014 (0x0014 - 0x0000)
struct GzPlayerController_Client_SendAudioAnnouncement final
{
public:
	struct FGameplayTag                           AnnouncerTag;                                      // 0x0000(0x0008)(ConstParm, Parm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           VoiceLineTag;                                      // 0x0008(0x0008)(ConstParm, Parm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bStarted;                                          // 0x0010(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2FEC[0x3];                                     // 0x0011(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GzPlayerController_Client_SendAudioAnnouncement) == 0x000004, "Wrong alignment on GzPlayerController_Client_SendAudioAnnouncement");
static_assert(sizeof(GzPlayerController_Client_SendAudioAnnouncement) == 0x000014, "Wrong size on GzPlayerController_Client_SendAudioAnnouncement");
static_assert(offsetof(GzPlayerController_Client_SendAudioAnnouncement, AnnouncerTag) == 0x000000, "Member 'GzPlayerController_Client_SendAudioAnnouncement::AnnouncerTag' has a wrong offset!");
static_assert(offsetof(GzPlayerController_Client_SendAudioAnnouncement, VoiceLineTag) == 0x000008, "Member 'GzPlayerController_Client_SendAudioAnnouncement::VoiceLineTag' has a wrong offset!");
static_assert(offsetof(GzPlayerController_Client_SendAudioAnnouncement, bStarted) == 0x000010, "Member 'GzPlayerController_Client_SendAudioAnnouncement::bStarted' has a wrong offset!");

// Function G01.GzPlayerController.Client_SendGameMessage
// 0x0018 (0x0018 - 0x0000)
struct GzPlayerController_Client_SendGameMessage final
{
public:
	struct FGzMessageNetData                      MessageData;                                       // 0x0000(0x0018)(Parm, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzPlayerController_Client_SendGameMessage) == 0x000008, "Wrong alignment on GzPlayerController_Client_SendGameMessage");
static_assert(sizeof(GzPlayerController_Client_SendGameMessage) == 0x000018, "Wrong size on GzPlayerController_Client_SendGameMessage");
static_assert(offsetof(GzPlayerController_Client_SendGameMessage, MessageData) == 0x000000, "Member 'GzPlayerController_Client_SendGameMessage::MessageData' has a wrong offset!");

// Function G01.GzPlayerController.Client_SendVoiceableActionEvent
// 0x0018 (0x0018 - 0x0000)
struct GzPlayerController_Client_SendVoiceableActionEvent final
{
public:
	class AActor*                                 ActionInstigator;                                  // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           Tag;                                               // 0x0008(0x0008)(ConstParm, Parm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bStarted;                                          // 0x0010(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2FED[0x7];                                     // 0x0011(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GzPlayerController_Client_SendVoiceableActionEvent) == 0x000008, "Wrong alignment on GzPlayerController_Client_SendVoiceableActionEvent");
static_assert(sizeof(GzPlayerController_Client_SendVoiceableActionEvent) == 0x000018, "Wrong size on GzPlayerController_Client_SendVoiceableActionEvent");
static_assert(offsetof(GzPlayerController_Client_SendVoiceableActionEvent, ActionInstigator) == 0x000000, "Member 'GzPlayerController_Client_SendVoiceableActionEvent::ActionInstigator' has a wrong offset!");
static_assert(offsetof(GzPlayerController_Client_SendVoiceableActionEvent, Tag) == 0x000008, "Member 'GzPlayerController_Client_SendVoiceableActionEvent::Tag' has a wrong offset!");
static_assert(offsetof(GzPlayerController_Client_SendVoiceableActionEvent, bStarted) == 0x000010, "Member 'GzPlayerController_Client_SendVoiceableActionEvent::bStarted' has a wrong offset!");

// Function G01.GzPlayerController.Client_SetSpectatorCameraMode
// 0x0008 (0x0008 - 0x0000)
struct GzPlayerController_Client_SetSpectatorCameraMode final
{
public:
	struct FGameplayTag                           CameraModeTag;                                     // 0x0000(0x0008)(Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzPlayerController_Client_SetSpectatorCameraMode) == 0x000004, "Wrong alignment on GzPlayerController_Client_SetSpectatorCameraMode");
static_assert(sizeof(GzPlayerController_Client_SetSpectatorCameraMode) == 0x000008, "Wrong size on GzPlayerController_Client_SetSpectatorCameraMode");
static_assert(offsetof(GzPlayerController_Client_SetSpectatorCameraMode, CameraModeTag) == 0x000000, "Member 'GzPlayerController_Client_SetSpectatorCameraMode::CameraModeTag' has a wrong offset!");

// Function G01.GzPlayerController.Client_SetSpectatorOverlayCameraMode
// 0x000C (0x000C - 0x0000)
struct GzPlayerController_Client_SetSpectatorOverlayCameraMode final
{
public:
	struct FGameplayTag                           CameraModeTag;                                     // 0x0000(0x0008)(Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bWithInterpolation;                                // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2FEE[0x3];                                     // 0x0009(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GzPlayerController_Client_SetSpectatorOverlayCameraMode) == 0x000004, "Wrong alignment on GzPlayerController_Client_SetSpectatorOverlayCameraMode");
static_assert(sizeof(GzPlayerController_Client_SetSpectatorOverlayCameraMode) == 0x00000C, "Wrong size on GzPlayerController_Client_SetSpectatorOverlayCameraMode");
static_assert(offsetof(GzPlayerController_Client_SetSpectatorOverlayCameraMode, CameraModeTag) == 0x000000, "Member 'GzPlayerController_Client_SetSpectatorOverlayCameraMode::CameraModeTag' has a wrong offset!");
static_assert(offsetof(GzPlayerController_Client_SetSpectatorOverlayCameraMode, bWithInterpolation) == 0x000008, "Member 'GzPlayerController_Client_SetSpectatorOverlayCameraMode::bWithInterpolation' has a wrong offset!");

// Function G01.GzPlayerController.ClientSetMatchResult
// 0x0090 (0x0090 - 0x0000)
struct GzPlayerController_ClientSetMatchResult final
{
public:
	struct FGzMatchResult                         InMatchResult;                                     // 0x0000(0x0090)(ConstParm, Parm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzPlayerController_ClientSetMatchResult) == 0x000008, "Wrong alignment on GzPlayerController_ClientSetMatchResult");
static_assert(sizeof(GzPlayerController_ClientSetMatchResult) == 0x000090, "Wrong size on GzPlayerController_ClientSetMatchResult");
static_assert(offsetof(GzPlayerController_ClientSetMatchResult, InMatchResult) == 0x000000, "Member 'GzPlayerController_ClientSetMatchResult::InMatchResult' has a wrong offset!");

// Function G01.GzPlayerController.ClientSetSoundState
// 0x0008 (0x0008 - 0x0000)
struct GzPlayerController_ClientSetSoundState final
{
public:
	struct FGzSoundStateKey                       State;                                             // 0x0000(0x0008)(Parm, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzPlayerController_ClientSetSoundState) == 0x000004, "Wrong alignment on GzPlayerController_ClientSetSoundState");
static_assert(sizeof(GzPlayerController_ClientSetSoundState) == 0x000008, "Wrong size on GzPlayerController_ClientSetSoundState");
static_assert(offsetof(GzPlayerController_ClientSetSoundState, State) == 0x000000, "Member 'GzPlayerController_ClientSetSoundState::State' has a wrong offset!");

// Function G01.GzPlayerController.ClientUpdateWorldTime
// 0x0008 (0x0008 - 0x0000)
struct GzPlayerController_ClientUpdateWorldTime final
{
public:
	float                                         ClientTimestamp;                                   // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ServerTimestamp;                                   // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzPlayerController_ClientUpdateWorldTime) == 0x000004, "Wrong alignment on GzPlayerController_ClientUpdateWorldTime");
static_assert(sizeof(GzPlayerController_ClientUpdateWorldTime) == 0x000008, "Wrong size on GzPlayerController_ClientUpdateWorldTime");
static_assert(offsetof(GzPlayerController_ClientUpdateWorldTime, ClientTimestamp) == 0x000000, "Member 'GzPlayerController_ClientUpdateWorldTime::ClientTimestamp' has a wrong offset!");
static_assert(offsetof(GzPlayerController_ClientUpdateWorldTime, ServerTimestamp) == 0x000004, "Member 'GzPlayerController_ClientUpdateWorldTime::ServerTimestamp' has a wrong offset!");

// Function G01.GzPlayerController.ConnectToVoiceChatRoom
// 0x0030 (0x0030 - 0x0000)
struct GzPlayerController_ConnectToVoiceChatRoom final
{
public:
	struct FGuid                                  RoomGuid;                                          // 0x0000(0x0010)(ConstParm, Parm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 JoinUrl;                                           // 0x0010(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 JoinToken;                                         // 0x0020(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzPlayerController_ConnectToVoiceChatRoom) == 0x000008, "Wrong alignment on GzPlayerController_ConnectToVoiceChatRoom");
static_assert(sizeof(GzPlayerController_ConnectToVoiceChatRoom) == 0x000030, "Wrong size on GzPlayerController_ConnectToVoiceChatRoom");
static_assert(offsetof(GzPlayerController_ConnectToVoiceChatRoom, RoomGuid) == 0x000000, "Member 'GzPlayerController_ConnectToVoiceChatRoom::RoomGuid' has a wrong offset!");
static_assert(offsetof(GzPlayerController_ConnectToVoiceChatRoom, JoinUrl) == 0x000010, "Member 'GzPlayerController_ConnectToVoiceChatRoom::JoinUrl' has a wrong offset!");
static_assert(offsetof(GzPlayerController_ConnectToVoiceChatRoom, JoinToken) == 0x000020, "Member 'GzPlayerController_ConnectToVoiceChatRoom::JoinToken' has a wrong offset!");

// Function G01.GzPlayerController.DisplayDamage
// 0x0048 (0x0048 - 0x0000)
struct GzPlayerController_DisplayDamage final
{
public:
	struct FDamageDisplayData                     DamageData;                                        // 0x0000(0x0030)(Parm, NoDestructor, NativeAccessSpecifierPublic)
	struct FVector                                ImpactNormal;                                      // 0x0030(0x0018)(ConstParm, Parm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzPlayerController_DisplayDamage) == 0x000008, "Wrong alignment on GzPlayerController_DisplayDamage");
static_assert(sizeof(GzPlayerController_DisplayDamage) == 0x000048, "Wrong size on GzPlayerController_DisplayDamage");
static_assert(offsetof(GzPlayerController_DisplayDamage, DamageData) == 0x000000, "Member 'GzPlayerController_DisplayDamage::DamageData' has a wrong offset!");
static_assert(offsetof(GzPlayerController_DisplayDamage, ImpactNormal) == 0x000030, "Member 'GzPlayerController_DisplayDamage::ImpactNormal' has a wrong offset!");

// Function G01.GzPlayerController.DrawDebugCovers
// 0x0010 (0x0010 - 0x0000)
struct GzPlayerController_DrawDebugCovers final
{
public:
	TArray<struct FDrawCovers>                    TakeCovers;                                        // 0x0000(0x0010)(ConstParm, Parm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzPlayerController_DrawDebugCovers) == 0x000008, "Wrong alignment on GzPlayerController_DrawDebugCovers");
static_assert(sizeof(GzPlayerController_DrawDebugCovers) == 0x000010, "Wrong size on GzPlayerController_DrawDebugCovers");
static_assert(offsetof(GzPlayerController_DrawDebugCovers, TakeCovers) == 0x000000, "Member 'GzPlayerController_DrawDebugCovers::TakeCovers' has a wrong offset!");

// Function G01.GzPlayerController.K2_DisplayDamage
// 0x0030 (0x0030 - 0x0000)
struct GzPlayerController_K2_DisplayDamage final
{
public:
	struct FDamageDisplayData                     DamageData;                                        // 0x0000(0x0030)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzPlayerController_K2_DisplayDamage) == 0x000008, "Wrong alignment on GzPlayerController_K2_DisplayDamage");
static_assert(sizeof(GzPlayerController_K2_DisplayDamage) == 0x000030, "Wrong size on GzPlayerController_K2_DisplayDamage");
static_assert(offsetof(GzPlayerController_K2_DisplayDamage, DamageData) == 0x000000, "Member 'GzPlayerController_K2_DisplayDamage::DamageData' has a wrong offset!");

// Function G01.GzPlayerController.ListenLandedEvent
// 0x0001 (0x0001 - 0x0000)
struct GzPlayerController_ListenLandedEvent final
{
public:
	bool                                          bChangeSoundState;                                 // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzPlayerController_ListenLandedEvent) == 0x000001, "Wrong alignment on GzPlayerController_ListenLandedEvent");
static_assert(sizeof(GzPlayerController_ListenLandedEvent) == 0x000001, "Wrong size on GzPlayerController_ListenLandedEvent");
static_assert(offsetof(GzPlayerController_ListenLandedEvent, bChangeSoundState) == 0x000000, "Member 'GzPlayerController_ListenLandedEvent::bChangeSoundState' has a wrong offset!");

// Function G01.GzPlayerController.OnCinematicModeChanged
// 0x0001 (0x0001 - 0x0000)
struct GzPlayerController_OnCinematicModeChanged final
{
public:
	bool                                          bNewCinematicMode;                                 // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzPlayerController_OnCinematicModeChanged) == 0x000001, "Wrong alignment on GzPlayerController_OnCinematicModeChanged");
static_assert(sizeof(GzPlayerController_OnCinematicModeChanged) == 0x000001, "Wrong size on GzPlayerController_OnCinematicModeChanged");
static_assert(offsetof(GzPlayerController_OnCinematicModeChanged, bNewCinematicMode) == 0x000000, "Member 'GzPlayerController_OnCinematicModeChanged::bNewCinematicMode' has a wrong offset!");

// Function G01.GzPlayerController.OnConnectionStateChanged
// 0x0008 (0x0008 - 0x0000)
struct GzPlayerController_OnConnectionStateChanged final
{
public:
	class AGzPlayerState*                         PS;                                                // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzPlayerController_OnConnectionStateChanged) == 0x000008, "Wrong alignment on GzPlayerController_OnConnectionStateChanged");
static_assert(sizeof(GzPlayerController_OnConnectionStateChanged) == 0x000008, "Wrong size on GzPlayerController_OnConnectionStateChanged");
static_assert(offsetof(GzPlayerController_OnConnectionStateChanged, PS) == 0x000000, "Member 'GzPlayerController_OnConnectionStateChanged::PS' has a wrong offset!");

// Function G01.GzPlayerController.OnObservedPlayerConnectionChanged
// 0x0008 (0x0008 - 0x0000)
struct GzPlayerController_OnObservedPlayerConnectionChanged final
{
public:
	class AGzPlayerState*                         InPlayerState;                                     // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzPlayerController_OnObservedPlayerConnectionChanged) == 0x000008, "Wrong alignment on GzPlayerController_OnObservedPlayerConnectionChanged");
static_assert(sizeof(GzPlayerController_OnObservedPlayerConnectionChanged) == 0x000008, "Wrong size on GzPlayerController_OnObservedPlayerConnectionChanged");
static_assert(offsetof(GzPlayerController_OnObservedPlayerConnectionChanged, InPlayerState) == 0x000000, "Member 'GzPlayerController_OnObservedPlayerConnectionChanged::InPlayerState' has a wrong offset!");

// Function G01.GzPlayerController.OnRep_SpectateKiller
// 0x0001 (0x0001 - 0x0000)
struct GzPlayerController_OnRep_SpectateKiller final
{
public:
	bool                                          bPrevSpectateKiller;                               // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzPlayerController_OnRep_SpectateKiller) == 0x000001, "Wrong alignment on GzPlayerController_OnRep_SpectateKiller");
static_assert(sizeof(GzPlayerController_OnRep_SpectateKiller) == 0x000001, "Wrong size on GzPlayerController_OnRep_SpectateKiller");
static_assert(offsetof(GzPlayerController_OnRep_SpectateKiller, bPrevSpectateKiller) == 0x000000, "Member 'GzPlayerController_OnRep_SpectateKiller::bPrevSpectateKiller' has a wrong offset!");

// Function G01.GzPlayerController.OnTeamChanged
// 0x0008 (0x0008 - 0x0000)
struct GzPlayerController_OnTeamChanged final
{
public:
	class AGzPlayerState*                         PS;                                                // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzPlayerController_OnTeamChanged) == 0x000008, "Wrong alignment on GzPlayerController_OnTeamChanged");
static_assert(sizeof(GzPlayerController_OnTeamChanged) == 0x000008, "Wrong size on GzPlayerController_OnTeamChanged");
static_assert(offsetof(GzPlayerController_OnTeamChanged, PS) == 0x000000, "Member 'GzPlayerController_OnTeamChanged::PS' has a wrong offset!");

// Function G01.GzPlayerController.OnTeammateAliveStateChanged
// 0x0008 (0x0008 - 0x0000)
struct GzPlayerController_OnTeammateAliveStateChanged final
{
public:
	class AGzPlayerState*                         PS;                                                // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzPlayerController_OnTeammateAliveStateChanged) == 0x000008, "Wrong alignment on GzPlayerController_OnTeammateAliveStateChanged");
static_assert(sizeof(GzPlayerController_OnTeammateAliveStateChanged) == 0x000008, "Wrong size on GzPlayerController_OnTeammateAliveStateChanged");
static_assert(offsetof(GzPlayerController_OnTeammateAliveStateChanged, PS) == 0x000000, "Member 'GzPlayerController_OnTeammateAliveStateChanged::PS' has a wrong offset!");

// Function G01.GzPlayerController.RemoveActiveHexExtraction
// 0x0004 (0x0004 - 0x0000)
struct GzPlayerController_RemoveActiveHexExtraction final
{
public:
	int32                                         ExtractionId;                                      // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzPlayerController_RemoveActiveHexExtraction) == 0x000004, "Wrong alignment on GzPlayerController_RemoveActiveHexExtraction");
static_assert(sizeof(GzPlayerController_RemoveActiveHexExtraction) == 0x000004, "Wrong size on GzPlayerController_RemoveActiveHexExtraction");
static_assert(offsetof(GzPlayerController_RemoveActiveHexExtraction, ExtractionId) == 0x000000, "Member 'GzPlayerController_RemoveActiveHexExtraction::ExtractionId' has a wrong offset!");

// Function G01.GzPlayerController.SendServerFloorToClient
// 0x0108 (0x0108 - 0x0000)
struct GzPlayerController_SendServerFloorToClient final
{
public:
	struct FFindFloorResult                       FloorResult;                                       // 0x0000(0x0108)(ConstParm, Parm, ReferenceParm, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzPlayerController_SendServerFloorToClient) == 0x000008, "Wrong alignment on GzPlayerController_SendServerFloorToClient");
static_assert(sizeof(GzPlayerController_SendServerFloorToClient) == 0x000108, "Wrong size on GzPlayerController_SendServerFloorToClient");
static_assert(offsetof(GzPlayerController_SendServerFloorToClient, FloorResult) == 0x000000, "Member 'GzPlayerController_SendServerFloorToClient::FloorResult' has a wrong offset!");

// Function G01.GzPlayerController.Server_CallRedeployment
// 0x0018 (0x0018 - 0x0000)
struct GzPlayerController_Server_CallRedeployment final
{
public:
	class AGzRedeploymentTerminal*                RedeploymentTerminal;                              // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<int32>                                 TeammatesIds;                                      // 0x0008(0x0010)(ConstParm, Parm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzPlayerController_Server_CallRedeployment) == 0x000008, "Wrong alignment on GzPlayerController_Server_CallRedeployment");
static_assert(sizeof(GzPlayerController_Server_CallRedeployment) == 0x000018, "Wrong size on GzPlayerController_Server_CallRedeployment");
static_assert(offsetof(GzPlayerController_Server_CallRedeployment, RedeploymentTerminal) == 0x000000, "Member 'GzPlayerController_Server_CallRedeployment::RedeploymentTerminal' has a wrong offset!");
static_assert(offsetof(GzPlayerController_Server_CallRedeployment, TeammatesIds) == 0x000008, "Member 'GzPlayerController_Server_CallRedeployment::TeammatesIds' has a wrong offset!");

// Function G01.GzPlayerController.Server_SendMinigameBytes
// 0x0001 (0x0001 - 0x0000)
struct GzPlayerController_Server_SendMinigameBytes final
{
public:
	uint8                                         Bytes;                                             // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzPlayerController_Server_SendMinigameBytes) == 0x000001, "Wrong alignment on GzPlayerController_Server_SendMinigameBytes");
static_assert(sizeof(GzPlayerController_Server_SendMinigameBytes) == 0x000001, "Wrong size on GzPlayerController_Server_SendMinigameBytes");
static_assert(offsetof(GzPlayerController_Server_SendMinigameBytes, Bytes) == 0x000000, "Member 'GzPlayerController_Server_SendMinigameBytes::Bytes' has a wrong offset!");

// Function G01.GzPlayerController.Server_SendPlatformUserInfo
// 0x0020 (0x0020 - 0x0000)
struct GzPlayerController_Server_SendPlatformUserInfo final
{
public:
	class FString                                 PlayFabId;                                         // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 PlatformUserId;                                    // 0x0010(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzPlayerController_Server_SendPlatformUserInfo) == 0x000008, "Wrong alignment on GzPlayerController_Server_SendPlatformUserInfo");
static_assert(sizeof(GzPlayerController_Server_SendPlatformUserInfo) == 0x000020, "Wrong size on GzPlayerController_Server_SendPlatformUserInfo");
static_assert(offsetof(GzPlayerController_Server_SendPlatformUserInfo, PlayFabId) == 0x000000, "Member 'GzPlayerController_Server_SendPlatformUserInfo::PlayFabId' has a wrong offset!");
static_assert(offsetof(GzPlayerController_Server_SendPlatformUserInfo, PlatformUserId) == 0x000010, "Member 'GzPlayerController_Server_SendPlatformUserInfo::PlatformUserId' has a wrong offset!");

// Function G01.GzPlayerController.Server_SetVirtualItem
// 0x0010 (0x0010 - 0x0000)
struct GzPlayerController_Server_SetVirtualItem final
{
public:
	struct FGzInvPocketId                         PocketId;                                          // 0x0000(0x0008)(ConstParm, Parm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UGzItemData*                            ItemData;                                          // 0x0008(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzPlayerController_Server_SetVirtualItem) == 0x000008, "Wrong alignment on GzPlayerController_Server_SetVirtualItem");
static_assert(sizeof(GzPlayerController_Server_SetVirtualItem) == 0x000010, "Wrong size on GzPlayerController_Server_SetVirtualItem");
static_assert(offsetof(GzPlayerController_Server_SetVirtualItem, PocketId) == 0x000000, "Member 'GzPlayerController_Server_SetVirtualItem::PocketId' has a wrong offset!");
static_assert(offsetof(GzPlayerController_Server_SetVirtualItem, ItemData) == 0x000008, "Member 'GzPlayerController_Server_SetVirtualItem::ItemData' has a wrong offset!");

// Function G01.GzPlayerController.ServerRemoveItem
// 0x0010 (0x0010 - 0x0000)
struct GzPlayerController_ServerRemoveItem final
{
public:
	struct FGzInvItem                             Item;                                              // 0x0000(0x0010)(ConstParm, Parm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzPlayerController_ServerRemoveItem) == 0x000008, "Wrong alignment on GzPlayerController_ServerRemoveItem");
static_assert(sizeof(GzPlayerController_ServerRemoveItem) == 0x000010, "Wrong size on GzPlayerController_ServerRemoveItem");
static_assert(offsetof(GzPlayerController_ServerRemoveItem, Item) == 0x000000, "Member 'GzPlayerController_ServerRemoveItem::Item' has a wrong offset!");

// Function G01.GzPlayerController.ServerRemoveSlot
// 0x0008 (0x0008 - 0x0000)
struct GzPlayerController_ServerRemoveSlot final
{
public:
	struct FGameplayTag                           Slot;                                              // 0x0000(0x0008)(ConstParm, Parm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzPlayerController_ServerRemoveSlot) == 0x000004, "Wrong alignment on GzPlayerController_ServerRemoveSlot");
static_assert(sizeof(GzPlayerController_ServerRemoveSlot) == 0x000008, "Wrong size on GzPlayerController_ServerRemoveSlot");
static_assert(offsetof(GzPlayerController_ServerRemoveSlot, Slot) == 0x000000, "Member 'GzPlayerController_ServerRemoveSlot::Slot' has a wrong offset!");

// Function G01.GzPlayerController.ServerRename
// 0x0010 (0x0010 - 0x0000)
struct GzPlayerController_ServerRename final
{
public:
	class FString                                 BaseName;                                          // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzPlayerController_ServerRename) == 0x000008, "Wrong alignment on GzPlayerController_ServerRename");
static_assert(sizeof(GzPlayerController_ServerRename) == 0x000010, "Wrong size on GzPlayerController_ServerRename");
static_assert(offsetof(GzPlayerController_ServerRename, BaseName) == 0x000000, "Member 'GzPlayerController_ServerRename::BaseName' has a wrong offset!");

// Function G01.GzPlayerController.ServerRequestWorldTime
// 0x0004 (0x0004 - 0x0000)
struct GzPlayerController_ServerRequestWorldTime final
{
public:
	float                                         ClientTimestamp;                                   // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzPlayerController_ServerRequestWorldTime) == 0x000004, "Wrong alignment on GzPlayerController_ServerRequestWorldTime");
static_assert(sizeof(GzPlayerController_ServerRequestWorldTime) == 0x000004, "Wrong size on GzPlayerController_ServerRequestWorldTime");
static_assert(offsetof(GzPlayerController_ServerRequestWorldTime, ClientTimestamp) == 0x000000, "Member 'GzPlayerController_ServerRequestWorldTime::ClientTimestamp' has a wrong offset!");

// Function G01.GzPlayerController.ServerStartPostLoadoutSelectionTimer
// 0x0010 (0x0010 - 0x0000)
struct GzPlayerController_ServerStartPostLoadoutSelectionTimer final
{
public:
	struct FGuid                                  LoadoutGuid;                                       // 0x0000(0x0010)(ConstParm, Parm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzPlayerController_ServerStartPostLoadoutSelectionTimer) == 0x000004, "Wrong alignment on GzPlayerController_ServerStartPostLoadoutSelectionTimer");
static_assert(sizeof(GzPlayerController_ServerStartPostLoadoutSelectionTimer) == 0x000010, "Wrong size on GzPlayerController_ServerStartPostLoadoutSelectionTimer");
static_assert(offsetof(GzPlayerController_ServerStartPostLoadoutSelectionTimer, LoadoutGuid) == 0x000000, "Member 'GzPlayerController_ServerStartPostLoadoutSelectionTimer::LoadoutGuid' has a wrong offset!");

// Function G01.GzPlayerController.ServerSwapPockets
// 0x0010 (0x0010 - 0x0000)
struct GzPlayerController_ServerSwapPockets final
{
public:
	struct FGzInvPocketId                         LeftPocketId;                                      // 0x0000(0x0008)(ConstParm, Parm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGzInvPocketId                         RightPocketId;                                     // 0x0008(0x0008)(ConstParm, Parm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzPlayerController_ServerSwapPockets) == 0x000004, "Wrong alignment on GzPlayerController_ServerSwapPockets");
static_assert(sizeof(GzPlayerController_ServerSwapPockets) == 0x000010, "Wrong size on GzPlayerController_ServerSwapPockets");
static_assert(offsetof(GzPlayerController_ServerSwapPockets, LeftPocketId) == 0x000000, "Member 'GzPlayerController_ServerSwapPockets::LeftPocketId' has a wrong offset!");
static_assert(offsetof(GzPlayerController_ServerSwapPockets, RightPocketId) == 0x000008, "Member 'GzPlayerController_ServerSwapPockets::RightPocketId' has a wrong offset!");

// Function G01.GzPlayerController.SetActiveHexExtraction
// 0x0040 (0x0040 - 0x0000)
struct GzPlayerController_SetActiveHexExtraction final
{
public:
	struct FGzExtractionData                      InExtractionData;                                  // 0x0000(0x0040)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzPlayerController_SetActiveHexExtraction) == 0x000008, "Wrong alignment on GzPlayerController_SetActiveHexExtraction");
static_assert(sizeof(GzPlayerController_SetActiveHexExtraction) == 0x000040, "Wrong size on GzPlayerController_SetActiveHexExtraction");
static_assert(offsetof(GzPlayerController_SetActiveHexExtraction, InExtractionData) == 0x000000, "Member 'GzPlayerController_SetActiveHexExtraction::InExtractionData' has a wrong offset!");

// Function G01.GzPlayerController.SetAimingInputScale
// 0x0004 (0x0004 - 0x0000)
struct GzPlayerController_SetAimingInputScale final
{
public:
	float                                         Scale;                                             // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzPlayerController_SetAimingInputScale) == 0x000004, "Wrong alignment on GzPlayerController_SetAimingInputScale");
static_assert(sizeof(GzPlayerController_SetAimingInputScale) == 0x000004, "Wrong size on GzPlayerController_SetAimingInputScale");
static_assert(offsetof(GzPlayerController_SetAimingInputScale, Scale) == 0x000000, "Member 'GzPlayerController_SetAimingInputScale::Scale' has a wrong offset!");

// Function G01.GzPlayerController.SetFlushKeysOnViewportFocusChange
// 0x0001 (0x0001 - 0x0000)
struct GzPlayerController_SetFlushKeysOnViewportFocusChange final
{
public:
	bool                                          bInFlushKeysOnViewportFocusChange;                 // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzPlayerController_SetFlushKeysOnViewportFocusChange) == 0x000001, "Wrong alignment on GzPlayerController_SetFlushKeysOnViewportFocusChange");
static_assert(sizeof(GzPlayerController_SetFlushKeysOnViewportFocusChange) == 0x000001, "Wrong size on GzPlayerController_SetFlushKeysOnViewportFocusChange");
static_assert(offsetof(GzPlayerController_SetFlushKeysOnViewportFocusChange, bInFlushKeysOnViewportFocusChange) == 0x000000, "Member 'GzPlayerController_SetFlushKeysOnViewportFocusChange::bInFlushKeysOnViewportFocusChange' has a wrong offset!");

// Function G01.GzPlayerController.SetInputPitchYawScale
// 0x0008 (0x0008 - 0x0000)
struct GzPlayerController_SetInputPitchYawScale final
{
public:
	float                                         PitchScale;                                        // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         YawScale;                                          // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzPlayerController_SetInputPitchYawScale) == 0x000004, "Wrong alignment on GzPlayerController_SetInputPitchYawScale");
static_assert(sizeof(GzPlayerController_SetInputPitchYawScale) == 0x000008, "Wrong size on GzPlayerController_SetInputPitchYawScale");
static_assert(offsetof(GzPlayerController_SetInputPitchYawScale, PitchScale) == 0x000000, "Member 'GzPlayerController_SetInputPitchYawScale::PitchScale' has a wrong offset!");
static_assert(offsetof(GzPlayerController_SetInputPitchYawScale, YawScale) == 0x000004, "Member 'GzPlayerController_SetInputPitchYawScale::YawScale' has a wrong offset!");

// Function G01.GzPlayerController.SetPreciseControlRotation
// 0x0018 (0x0018 - 0x0000)
struct GzPlayerController_SetPreciseControlRotation final
{
public:
	struct FRotator                               NewRotation;                                       // 0x0000(0x0018)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzPlayerController_SetPreciseControlRotation) == 0x000008, "Wrong alignment on GzPlayerController_SetPreciseControlRotation");
static_assert(sizeof(GzPlayerController_SetPreciseControlRotation) == 0x000018, "Wrong size on GzPlayerController_SetPreciseControlRotation");
static_assert(offsetof(GzPlayerController_SetPreciseControlRotation, NewRotation) == 0x000000, "Member 'GzPlayerController_SetPreciseControlRotation::NewRotation' has a wrong offset!");

// Function G01.GzPlayerController.SetSniperScopeInputScale
// 0x0004 (0x0004 - 0x0000)
struct GzPlayerController_SetSniperScopeInputScale final
{
public:
	float                                         Scale;                                             // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzPlayerController_SetSniperScopeInputScale) == 0x000004, "Wrong alignment on GzPlayerController_SetSniperScopeInputScale");
static_assert(sizeof(GzPlayerController_SetSniperScopeInputScale) == 0x000004, "Wrong size on GzPlayerController_SetSniperScopeInputScale");
static_assert(offsetof(GzPlayerController_SetSniperScopeInputScale, Scale) == 0x000000, "Member 'GzPlayerController_SetSniperScopeInputScale::Scale' has a wrong offset!");

// Function G01.GzPlayerController.StartPostLoadoutSelectionTimer
// 0x0010 (0x0010 - 0x0000)
struct GzPlayerController_StartPostLoadoutSelectionTimer final
{
public:
	struct FGuid                                  LoadoutGuid;                                       // 0x0000(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzPlayerController_StartPostLoadoutSelectionTimer) == 0x000004, "Wrong alignment on GzPlayerController_StartPostLoadoutSelectionTimer");
static_assert(sizeof(GzPlayerController_StartPostLoadoutSelectionTimer) == 0x000010, "Wrong size on GzPlayerController_StartPostLoadoutSelectionTimer");
static_assert(offsetof(GzPlayerController_StartPostLoadoutSelectionTimer, LoadoutGuid) == 0x000000, "Member 'GzPlayerController_StartPostLoadoutSelectionTimer::LoadoutGuid' has a wrong offset!");

// Function G01.GzPlayerController.GetActiveHexExtractions
// 0x0010 (0x0010 - 0x0000)
struct GzPlayerController_GetActiveHexExtractions final
{
public:
	TArray<struct FGzExtractionData>              ReturnValue;                                       // 0x0000(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzPlayerController_GetActiveHexExtractions) == 0x000008, "Wrong alignment on GzPlayerController_GetActiveHexExtractions");
static_assert(sizeof(GzPlayerController_GetActiveHexExtractions) == 0x000010, "Wrong size on GzPlayerController_GetActiveHexExtractions");
static_assert(offsetof(GzPlayerController_GetActiveHexExtractions, ReturnValue) == 0x000000, "Member 'GzPlayerController_GetActiveHexExtractions::ReturnValue' has a wrong offset!");

// Function G01.GzPlayerController.GetInputControlsComponent
// 0x0008 (0x0008 - 0x0000)
struct GzPlayerController_GetInputControlsComponent final
{
public:
	class UGzInputControlsComponent*              ReturnValue;                                       // 0x0000(0x0008)(ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzPlayerController_GetInputControlsComponent) == 0x000008, "Wrong alignment on GzPlayerController_GetInputControlsComponent");
static_assert(sizeof(GzPlayerController_GetInputControlsComponent) == 0x000008, "Wrong size on GzPlayerController_GetInputControlsComponent");
static_assert(offsetof(GzPlayerController_GetInputControlsComponent, ReturnValue) == 0x000000, "Member 'GzPlayerController_GetInputControlsComponent::ReturnValue' has a wrong offset!");

// Function G01.GzPlayerController.GetKillerInfo
// 0x0030 (0x0030 - 0x0000)
struct GzPlayerController_GetKillerInfo final
{
public:
	struct FGzKillerInfo                          ReturnValue;                                       // 0x0000(0x0030)(ConstParm, Parm, OutParm, ReturnParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzPlayerController_GetKillerInfo) == 0x000008, "Wrong alignment on GzPlayerController_GetKillerInfo");
static_assert(sizeof(GzPlayerController_GetKillerInfo) == 0x000030, "Wrong size on GzPlayerController_GetKillerInfo");
static_assert(offsetof(GzPlayerController_GetKillerInfo, ReturnValue) == 0x000000, "Member 'GzPlayerController_GetKillerInfo::ReturnValue' has a wrong offset!");

// Function G01.GzPlayerController.GetMarkersHolderComponent
// 0x0008 (0x0008 - 0x0000)
struct GzPlayerController_GetMarkersHolderComponent final
{
public:
	class UGzPlayerMarkersHolderComponent*        ReturnValue;                                       // 0x0000(0x0008)(ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzPlayerController_GetMarkersHolderComponent) == 0x000008, "Wrong alignment on GzPlayerController_GetMarkersHolderComponent");
static_assert(sizeof(GzPlayerController_GetMarkersHolderComponent) == 0x000008, "Wrong size on GzPlayerController_GetMarkersHolderComponent");
static_assert(offsetof(GzPlayerController_GetMarkersHolderComponent, ReturnValue) == 0x000000, "Member 'GzPlayerController_GetMarkersHolderComponent::ReturnValue' has a wrong offset!");

// Function G01.GzPlayerController.GetMatchResult
// 0x0090 (0x0090 - 0x0000)
struct GzPlayerController_GetMatchResult final
{
public:
	struct FGzMatchResult                         ReturnValue;                                       // 0x0000(0x0090)(ConstParm, Parm, OutParm, ReturnParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzPlayerController_GetMatchResult) == 0x000008, "Wrong alignment on GzPlayerController_GetMatchResult");
static_assert(sizeof(GzPlayerController_GetMatchResult) == 0x000090, "Wrong size on GzPlayerController_GetMatchResult");
static_assert(offsetof(GzPlayerController_GetMatchResult, ReturnValue) == 0x000000, "Member 'GzPlayerController_GetMatchResult::ReturnValue' has a wrong offset!");

// Function G01.GzPlayerController.GetServerWorldTimeDelta
// 0x0004 (0x0004 - 0x0000)
struct GzPlayerController_GetServerWorldTimeDelta final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzPlayerController_GetServerWorldTimeDelta) == 0x000004, "Wrong alignment on GzPlayerController_GetServerWorldTimeDelta");
static_assert(sizeof(GzPlayerController_GetServerWorldTimeDelta) == 0x000004, "Wrong size on GzPlayerController_GetServerWorldTimeDelta");
static_assert(offsetof(GzPlayerController_GetServerWorldTimeDelta, ReturnValue) == 0x000000, "Member 'GzPlayerController_GetServerWorldTimeDelta::ReturnValue' has a wrong offset!");

// Function G01.GzPlayerController.GetSyncedServerWorldTime
// 0x0004 (0x0004 - 0x0000)
struct GzPlayerController_GetSyncedServerWorldTime final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzPlayerController_GetSyncedServerWorldTime) == 0x000004, "Wrong alignment on GzPlayerController_GetSyncedServerWorldTime");
static_assert(sizeof(GzPlayerController_GetSyncedServerWorldTime) == 0x000004, "Wrong size on GzPlayerController_GetSyncedServerWorldTime");
static_assert(offsetof(GzPlayerController_GetSyncedServerWorldTime, ReturnValue) == 0x000000, "Member 'GzPlayerController_GetSyncedServerWorldTime::ReturnValue' has a wrong offset!");

// Function G01.GzPlayerController.IsMatchResultSet
// 0x0001 (0x0001 - 0x0000)
struct GzPlayerController_IsMatchResultSet final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzPlayerController_IsMatchResultSet) == 0x000001, "Wrong alignment on GzPlayerController_IsMatchResultSet");
static_assert(sizeof(GzPlayerController_IsMatchResultSet) == 0x000001, "Wrong size on GzPlayerController_IsMatchResultSet");
static_assert(offsetof(GzPlayerController_IsMatchResultSet, ReturnValue) == 0x000000, "Member 'GzPlayerController_IsMatchResultSet::ReturnValue' has a wrong offset!");

// Function G01.GzPlayerController.IsPartyMember
// 0x0001 (0x0001 - 0x0000)
struct GzPlayerController_IsPartyMember final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzPlayerController_IsPartyMember) == 0x000001, "Wrong alignment on GzPlayerController_IsPartyMember");
static_assert(sizeof(GzPlayerController_IsPartyMember) == 0x000001, "Wrong size on GzPlayerController_IsPartyMember");
static_assert(offsetof(GzPlayerController_IsPartyMember, ReturnValue) == 0x000000, "Member 'GzPlayerController_IsPartyMember::ReturnValue' has a wrong offset!");

// Function G01.GzTimeSurvivedStatsCollector.UpdatePlayerTimeSurvived
// 0x0008 (0x0008 - 0x0000)
struct GzTimeSurvivedStatsCollector_UpdatePlayerTimeSurvived final
{
public:
	class AGzPlayerState*                         PlayerState;                                       // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzTimeSurvivedStatsCollector_UpdatePlayerTimeSurvived) == 0x000008, "Wrong alignment on GzTimeSurvivedStatsCollector_UpdatePlayerTimeSurvived");
static_assert(sizeof(GzTimeSurvivedStatsCollector_UpdatePlayerTimeSurvived) == 0x000008, "Wrong size on GzTimeSurvivedStatsCollector_UpdatePlayerTimeSurvived");
static_assert(offsetof(GzTimeSurvivedStatsCollector_UpdatePlayerTimeSurvived, PlayerState) == 0x000000, "Member 'GzTimeSurvivedStatsCollector_UpdatePlayerTimeSurvived::PlayerState' has a wrong offset!");

// Function G01.GzBattleRoyalePlayerController.OnRep_SelectedLastZoneData
// 0x0008 (0x0008 - 0x0000)
struct GzBattleRoyalePlayerController_OnRep_SelectedLastZoneData final
{
public:
	struct FGzSelectedZoneData                    OldZoneData;                                       // 0x0000(0x0008)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzBattleRoyalePlayerController_OnRep_SelectedLastZoneData) == 0x000004, "Wrong alignment on GzBattleRoyalePlayerController_OnRep_SelectedLastZoneData");
static_assert(sizeof(GzBattleRoyalePlayerController_OnRep_SelectedLastZoneData) == 0x000008, "Wrong size on GzBattleRoyalePlayerController_OnRep_SelectedLastZoneData");
static_assert(offsetof(GzBattleRoyalePlayerController_OnRep_SelectedLastZoneData, OldZoneData) == 0x000000, "Member 'GzBattleRoyalePlayerController_OnRep_SelectedLastZoneData::OldZoneData' has a wrong offset!");

// Function G01.GzBattleRoyalePlayerController.GetSelectedLastZoneIndex
// 0x0008 (0x0008 - 0x0000)
struct GzBattleRoyalePlayerController_GetSelectedLastZoneIndex final
{
public:
	struct FGzSelectedZoneData                    ReturnValue;                                       // 0x0000(0x0008)(ConstParm, Parm, OutParm, ReturnParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzBattleRoyalePlayerController_GetSelectedLastZoneIndex) == 0x000004, "Wrong alignment on GzBattleRoyalePlayerController_GetSelectedLastZoneIndex");
static_assert(sizeof(GzBattleRoyalePlayerController_GetSelectedLastZoneIndex) == 0x000008, "Wrong size on GzBattleRoyalePlayerController_GetSelectedLastZoneIndex");
static_assert(offsetof(GzBattleRoyalePlayerController_GetSelectedLastZoneIndex, ReturnValue) == 0x000000, "Member 'GzBattleRoyalePlayerController_GetSelectedLastZoneIndex::ReturnValue' has a wrong offset!");

// Function G01.GzBattleRoyalePlayerController.HasSelectedLastZoneData
// 0x0001 (0x0001 - 0x0000)
struct GzBattleRoyalePlayerController_HasSelectedLastZoneData final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzBattleRoyalePlayerController_HasSelectedLastZoneData) == 0x000001, "Wrong alignment on GzBattleRoyalePlayerController_HasSelectedLastZoneData");
static_assert(sizeof(GzBattleRoyalePlayerController_HasSelectedLastZoneData) == 0x000001, "Wrong size on GzBattleRoyalePlayerController_HasSelectedLastZoneData");
static_assert(offsetof(GzBattleRoyalePlayerController_HasSelectedLastZoneData, ReturnValue) == 0x000000, "Member 'GzBattleRoyalePlayerController_HasSelectedLastZoneData::ReturnValue' has a wrong offset!");

// Function G01.GzShootHitStatCollector.PlayerHit
// 0x0018 (0x0018 - 0x0000)
struct GzShootHitStatCollector_PlayerHit final
{
public:
	const class APawn*                            Instigator;                                        // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   WeaponName;                                        // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EGzCharacterDamageAreaType                    CharacterDamageAreaType;                           // 0x0010(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2FF0[0x7];                                     // 0x0011(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GzShootHitStatCollector_PlayerHit) == 0x000008, "Wrong alignment on GzShootHitStatCollector_PlayerHit");
static_assert(sizeof(GzShootHitStatCollector_PlayerHit) == 0x000018, "Wrong size on GzShootHitStatCollector_PlayerHit");
static_assert(offsetof(GzShootHitStatCollector_PlayerHit, Instigator) == 0x000000, "Member 'GzShootHitStatCollector_PlayerHit::Instigator' has a wrong offset!");
static_assert(offsetof(GzShootHitStatCollector_PlayerHit, WeaponName) == 0x000008, "Member 'GzShootHitStatCollector_PlayerHit::WeaponName' has a wrong offset!");
static_assert(offsetof(GzShootHitStatCollector_PlayerHit, CharacterDamageAreaType) == 0x000010, "Member 'GzShootHitStatCollector_PlayerHit::CharacterDamageAreaType' has a wrong offset!");

// Function G01.GzPlayerState.Client_NotifyConsoleUserInfos
// 0x0020 (0x0020 - 0x0000)
struct GzPlayerState_Client_NotifyConsoleUserInfos final
{
public:
	TArray<class FString>                         InConsoleUserIds;                                  // 0x0000(0x0010)(ConstParm, Parm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	TArray<class FString>                         InPlayFabIds;                                      // 0x0010(0x0010)(ConstParm, Parm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzPlayerState_Client_NotifyConsoleUserInfos) == 0x000008, "Wrong alignment on GzPlayerState_Client_NotifyConsoleUserInfos");
static_assert(sizeof(GzPlayerState_Client_NotifyConsoleUserInfos) == 0x000020, "Wrong size on GzPlayerState_Client_NotifyConsoleUserInfos");
static_assert(offsetof(GzPlayerState_Client_NotifyConsoleUserInfos, InConsoleUserIds) == 0x000000, "Member 'GzPlayerState_Client_NotifyConsoleUserInfos::InConsoleUserIds' has a wrong offset!");
static_assert(offsetof(GzPlayerState_Client_NotifyConsoleUserInfos, InPlayFabIds) == 0x000010, "Member 'GzPlayerState_Client_NotifyConsoleUserInfos::InPlayFabIds' has a wrong offset!");

// Function G01.GzPlayerState.OnPawnChanged
// 0x0018 (0x0018 - 0x0000)
struct GzPlayerState_OnPawnChanged final
{
public:
	class APlayerState*                           Player;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class APawn*                                  NewPawn;                                           // 0x0008(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class APawn*                                  OldPawn;                                           // 0x0010(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzPlayerState_OnPawnChanged) == 0x000008, "Wrong alignment on GzPlayerState_OnPawnChanged");
static_assert(sizeof(GzPlayerState_OnPawnChanged) == 0x000018, "Wrong size on GzPlayerState_OnPawnChanged");
static_assert(offsetof(GzPlayerState_OnPawnChanged, Player) == 0x000000, "Member 'GzPlayerState_OnPawnChanged::Player' has a wrong offset!");
static_assert(offsetof(GzPlayerState_OnPawnChanged, NewPawn) == 0x000008, "Member 'GzPlayerState_OnPawnChanged::NewPawn' has a wrong offset!");
static_assert(offsetof(GzPlayerState_OnPawnChanged, OldPawn) == 0x000010, "Member 'GzPlayerState_OnPawnChanged::OldPawn' has a wrong offset!");

// Function G01.GzPlayerState.Server_QueryConsoleUserIds
// 0x0010 (0x0010 - 0x0000)
struct GzPlayerState_Server_QueryConsoleUserIds final
{
public:
	TArray<class FString>                         InPlayFabIds;                                      // 0x0000(0x0010)(ConstParm, Parm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzPlayerState_Server_QueryConsoleUserIds) == 0x000008, "Wrong alignment on GzPlayerState_Server_QueryConsoleUserIds");
static_assert(sizeof(GzPlayerState_Server_QueryConsoleUserIds) == 0x000010, "Wrong size on GzPlayerState_Server_QueryConsoleUserIds");
static_assert(offsetof(GzPlayerState_Server_QueryConsoleUserIds, InPlayFabIds) == 0x000000, "Member 'GzPlayerState_Server_QueryConsoleUserIds::InPlayFabIds' has a wrong offset!");

// Function G01.GzPlayerState.Server_SaveConsoleUserId
// 0x0020 (0x0020 - 0x0000)
struct GzPlayerState_Server_SaveConsoleUserId final
{
public:
	class FString                                 InPlayfabId;                                       // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 InConsoleUserId;                                   // 0x0010(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzPlayerState_Server_SaveConsoleUserId) == 0x000008, "Wrong alignment on GzPlayerState_Server_SaveConsoleUserId");
static_assert(sizeof(GzPlayerState_Server_SaveConsoleUserId) == 0x000020, "Wrong size on GzPlayerState_Server_SaveConsoleUserId");
static_assert(offsetof(GzPlayerState_Server_SaveConsoleUserId, InPlayfabId) == 0x000000, "Member 'GzPlayerState_Server_SaveConsoleUserId::InPlayfabId' has a wrong offset!");
static_assert(offsetof(GzPlayerState_Server_SaveConsoleUserId, InConsoleUserId) == 0x000010, "Member 'GzPlayerState_Server_SaveConsoleUserId::InConsoleUserId' has a wrong offset!");

// Function G01.GzPlayerState.SetPreMatchStartTime
// 0x0004 (0x0004 - 0x0000)
struct GzPlayerState_SetPreMatchStartTime final
{
public:
	float                                         InTime;                                            // 0x0000(0x0004)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzPlayerState_SetPreMatchStartTime) == 0x000004, "Wrong alignment on GzPlayerState_SetPreMatchStartTime");
static_assert(sizeof(GzPlayerState_SetPreMatchStartTime) == 0x000004, "Wrong size on GzPlayerState_SetPreMatchStartTime");
static_assert(offsetof(GzPlayerState_SetPreMatchStartTime, InTime) == 0x000000, "Member 'GzPlayerState_SetPreMatchStartTime::InTime' has a wrong offset!");

// Function G01.GzPlayerState.GetBackendCharacterId
// 0x0008 (0x0008 - 0x0000)
struct GzPlayerState_GetBackendCharacterId final
{
public:
	class FName                                   ReturnValue;                                       // 0x0000(0x0008)(ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzPlayerState_GetBackendCharacterId) == 0x000004, "Wrong alignment on GzPlayerState_GetBackendCharacterId");
static_assert(sizeof(GzPlayerState_GetBackendCharacterId) == 0x000008, "Wrong size on GzPlayerState_GetBackendCharacterId");
static_assert(offsetof(GzPlayerState_GetBackendCharacterId, ReturnValue) == 0x000000, "Member 'GzPlayerState_GetBackendCharacterId::ReturnValue' has a wrong offset!");

// Function G01.GzPlayerState.GetComebackArenaState
// 0x0001 (0x0001 - 0x0000)
struct GzPlayerState_GetComebackArenaState final
{
public:
	EGzComebackArenaCandidateState                ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzPlayerState_GetComebackArenaState) == 0x000001, "Wrong alignment on GzPlayerState_GetComebackArenaState");
static_assert(sizeof(GzPlayerState_GetComebackArenaState) == 0x000001, "Wrong size on GzPlayerState_GetComebackArenaState");
static_assert(offsetof(GzPlayerState_GetComebackArenaState, ReturnValue) == 0x000000, "Member 'GzPlayerState_GetComebackArenaState::ReturnValue' has a wrong offset!");

// Function G01.GzPlayerState.GetConnectionState
// 0x0001 (0x0001 - 0x0000)
struct GzPlayerState_GetConnectionState final
{
public:
	EGzConnectionState                            ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzPlayerState_GetConnectionState) == 0x000001, "Wrong alignment on GzPlayerState_GetConnectionState");
static_assert(sizeof(GzPlayerState_GetConnectionState) == 0x000001, "Wrong size on GzPlayerState_GetConnectionState");
static_assert(offsetof(GzPlayerState_GetConnectionState, ReturnValue) == 0x000000, "Member 'GzPlayerState_GetConnectionState::ReturnValue' has a wrong offset!");

// Function G01.GzPlayerState.GetCustomizationProfile
// 0x0150 (0x0150 - 0x0000)
struct GzPlayerState_GetCustomizationProfile final
{
public:
	struct FGzCharacterCustomizationProfile       ReturnValue;                                       // 0x0000(0x0150)(ConstParm, Parm, OutParm, ReturnParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzPlayerState_GetCustomizationProfile) == 0x000008, "Wrong alignment on GzPlayerState_GetCustomizationProfile");
static_assert(sizeof(GzPlayerState_GetCustomizationProfile) == 0x000150, "Wrong size on GzPlayerState_GetCustomizationProfile");
static_assert(offsetof(GzPlayerState_GetCustomizationProfile, ReturnValue) == 0x000000, "Member 'GzPlayerState_GetCustomizationProfile::ReturnValue' has a wrong offset!");

// Function G01.GzPlayerState.GetEpicProductUserId
// 0x0010 (0x0010 - 0x0000)
struct GzPlayerState_GetEpicProductUserId final
{
public:
	class FString                                 ReturnValue;                                       // 0x0000(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzPlayerState_GetEpicProductUserId) == 0x000008, "Wrong alignment on GzPlayerState_GetEpicProductUserId");
static_assert(sizeof(GzPlayerState_GetEpicProductUserId) == 0x000010, "Wrong size on GzPlayerState_GetEpicProductUserId");
static_assert(offsetof(GzPlayerState_GetEpicProductUserId, ReturnValue) == 0x000000, "Member 'GzPlayerState_GetEpicProductUserId::ReturnValue' has a wrong offset!");

// Function G01.GzPlayerState.GetFaction
// 0x0048 (0x0048 - 0x0000)
struct GzPlayerState_GetFaction final
{
public:
	struct FGzFaction                             ReturnValue;                                       // 0x0000(0x0048)(ConstParm, Parm, OutParm, ReturnParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzPlayerState_GetFaction) == 0x000008, "Wrong alignment on GzPlayerState_GetFaction");
static_assert(sizeof(GzPlayerState_GetFaction) == 0x000048, "Wrong size on GzPlayerState_GetFaction");
static_assert(offsetof(GzPlayerState_GetFaction, ReturnValue) == 0x000000, "Member 'GzPlayerState_GetFaction::ReturnValue' has a wrong offset!");

// Function G01.GzPlayerState.GetFactionId
// 0x0004 (0x0004 - 0x0000)
struct GzPlayerState_GetFactionId final
{
public:
	int32                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzPlayerState_GetFactionId) == 0x000004, "Wrong alignment on GzPlayerState_GetFactionId");
static_assert(sizeof(GzPlayerState_GetFactionId) == 0x000004, "Wrong size on GzPlayerState_GetFactionId");
static_assert(offsetof(GzPlayerState_GetFactionId, ReturnValue) == 0x000000, "Member 'GzPlayerState_GetFactionId::ReturnValue' has a wrong offset!");

// Function G01.GzPlayerState.GetGenericTeamId
// 0x0001 (0x0001 - 0x0000)
struct GzPlayerState_GetGenericTeamId final
{
public:
	struct FGenericTeamId                         ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzPlayerState_GetGenericTeamId) == 0x000001, "Wrong alignment on GzPlayerState_GetGenericTeamId");
static_assert(sizeof(GzPlayerState_GetGenericTeamId) == 0x000001, "Wrong size on GzPlayerState_GetGenericTeamId");
static_assert(offsetof(GzPlayerState_GetGenericTeamId, ReturnValue) == 0x000000, "Member 'GzPlayerState_GetGenericTeamId::ReturnValue' has a wrong offset!");

// Function G01.GzPlayerState.GetInitialRespawnTime
// 0x0004 (0x0004 - 0x0000)
struct GzPlayerState_GetInitialRespawnTime final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzPlayerState_GetInitialRespawnTime) == 0x000004, "Wrong alignment on GzPlayerState_GetInitialRespawnTime");
static_assert(sizeof(GzPlayerState_GetInitialRespawnTime) == 0x000004, "Wrong size on GzPlayerState_GetInitialRespawnTime");
static_assert(offsetof(GzPlayerState_GetInitialRespawnTime, ReturnValue) == 0x000000, "Member 'GzPlayerState_GetInitialRespawnTime::ReturnValue' has a wrong offset!");

// Function G01.GzPlayerState.GetOldRespawnTime
// 0x0004 (0x0004 - 0x0000)
struct GzPlayerState_GetOldRespawnTime final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzPlayerState_GetOldRespawnTime) == 0x000004, "Wrong alignment on GzPlayerState_GetOldRespawnTime");
static_assert(sizeof(GzPlayerState_GetOldRespawnTime) == 0x000004, "Wrong size on GzPlayerState_GetOldRespawnTime");
static_assert(offsetof(GzPlayerState_GetOldRespawnTime, ReturnValue) == 0x000000, "Member 'GzPlayerState_GetOldRespawnTime::ReturnValue' has a wrong offset!");

// Function G01.GzPlayerState.GetPlayerAliveState
// 0x0001 (0x0001 - 0x0000)
struct GzPlayerState_GetPlayerAliveState final
{
public:
	EGzAliveState                                 ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzPlayerState_GetPlayerAliveState) == 0x000001, "Wrong alignment on GzPlayerState_GetPlayerAliveState");
static_assert(sizeof(GzPlayerState_GetPlayerAliveState) == 0x000001, "Wrong size on GzPlayerState_GetPlayerAliveState");
static_assert(offsetof(GzPlayerState_GetPlayerAliveState, ReturnValue) == 0x000000, "Member 'GzPlayerState_GetPlayerAliveState::ReturnValue' has a wrong offset!");

// Function G01.GzPlayerState.GetPlayerClanTag
// 0x0010 (0x0010 - 0x0000)
struct GzPlayerState_GetPlayerClanTag final
{
public:
	class FString                                 ReturnValue;                                       // 0x0000(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzPlayerState_GetPlayerClanTag) == 0x000008, "Wrong alignment on GzPlayerState_GetPlayerClanTag");
static_assert(sizeof(GzPlayerState_GetPlayerClanTag) == 0x000010, "Wrong size on GzPlayerState_GetPlayerClanTag");
static_assert(offsetof(GzPlayerState_GetPlayerClanTag, ReturnValue) == 0x000000, "Member 'GzPlayerState_GetPlayerClanTag::ReturnValue' has a wrong offset!");

// Function G01.GzPlayerState.GetPlayerSubscriptionIsValid
// 0x0001 (0x0001 - 0x0000)
struct GzPlayerState_GetPlayerSubscriptionIsValid final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzPlayerState_GetPlayerSubscriptionIsValid) == 0x000001, "Wrong alignment on GzPlayerState_GetPlayerSubscriptionIsValid");
static_assert(sizeof(GzPlayerState_GetPlayerSubscriptionIsValid) == 0x000001, "Wrong size on GzPlayerState_GetPlayerSubscriptionIsValid");
static_assert(offsetof(GzPlayerState_GetPlayerSubscriptionIsValid, ReturnValue) == 0x000000, "Member 'GzPlayerState_GetPlayerSubscriptionIsValid::ReturnValue' has a wrong offset!");

// Function G01.GzPlayerState.GetPlayFabId
// 0x0010 (0x0010 - 0x0000)
struct GzPlayerState_GetPlayFabId final
{
public:
	class FString                                 ReturnValue;                                       // 0x0000(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzPlayerState_GetPlayFabId) == 0x000008, "Wrong alignment on GzPlayerState_GetPlayFabId");
static_assert(sizeof(GzPlayerState_GetPlayFabId) == 0x000010, "Wrong size on GzPlayerState_GetPlayFabId");
static_assert(offsetof(GzPlayerState_GetPlayFabId, ReturnValue) == 0x000000, "Member 'GzPlayerState_GetPlayFabId::ReturnValue' has a wrong offset!");

// Function G01.GzPlayerState.GetQuickOrderDroneAvailableTime
// 0x0004 (0x0004 - 0x0000)
struct GzPlayerState_GetQuickOrderDroneAvailableTime final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzPlayerState_GetQuickOrderDroneAvailableTime) == 0x000004, "Wrong alignment on GzPlayerState_GetQuickOrderDroneAvailableTime");
static_assert(sizeof(GzPlayerState_GetQuickOrderDroneAvailableTime) == 0x000004, "Wrong size on GzPlayerState_GetQuickOrderDroneAvailableTime");
static_assert(offsetof(GzPlayerState_GetQuickOrderDroneAvailableTime, ReturnValue) == 0x000000, "Member 'GzPlayerState_GetQuickOrderDroneAvailableTime::ReturnValue' has a wrong offset!");

// Function G01.GzPlayerState.GetRedeploymentCost
// 0x0004 (0x0004 - 0x0000)
struct GzPlayerState_GetRedeploymentCost final
{
public:
	int32                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzPlayerState_GetRedeploymentCost) == 0x000004, "Wrong alignment on GzPlayerState_GetRedeploymentCost");
static_assert(sizeof(GzPlayerState_GetRedeploymentCost) == 0x000004, "Wrong size on GzPlayerState_GetRedeploymentCost");
static_assert(offsetof(GzPlayerState_GetRedeploymentCost, ReturnValue) == 0x000000, "Member 'GzPlayerState_GetRedeploymentCost::ReturnValue' has a wrong offset!");

// Function G01.GzPlayerState.GetRedeploymentCount
// 0x0004 (0x0004 - 0x0000)
struct GzPlayerState_GetRedeploymentCount final
{
public:
	int32                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzPlayerState_GetRedeploymentCount) == 0x000004, "Wrong alignment on GzPlayerState_GetRedeploymentCount");
static_assert(sizeof(GzPlayerState_GetRedeploymentCount) == 0x000004, "Wrong size on GzPlayerState_GetRedeploymentCount");
static_assert(offsetof(GzPlayerState_GetRedeploymentCount, ReturnValue) == 0x000000, "Member 'GzPlayerState_GetRedeploymentCount::ReturnValue' has a wrong offset!");

// Function G01.GzPlayerState.GetRespawnTime
// 0x0004 (0x0004 - 0x0000)
struct GzPlayerState_GetRespawnTime final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzPlayerState_GetRespawnTime) == 0x000004, "Wrong alignment on GzPlayerState_GetRespawnTime");
static_assert(sizeof(GzPlayerState_GetRespawnTime) == 0x000004, "Wrong size on GzPlayerState_GetRespawnTime");
static_assert(offsetof(GzPlayerState_GetRespawnTime, ReturnValue) == 0x000000, "Member 'GzPlayerState_GetRespawnTime::ReturnValue' has a wrong offset!");

// Function G01.GzPlayerState.GetSessionTeamId
// 0x0010 (0x0010 - 0x0000)
struct GzPlayerState_GetSessionTeamId final
{
public:
	class FString                                 ReturnValue;                                       // 0x0000(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzPlayerState_GetSessionTeamId) == 0x000008, "Wrong alignment on GzPlayerState_GetSessionTeamId");
static_assert(sizeof(GzPlayerState_GetSessionTeamId) == 0x000010, "Wrong size on GzPlayerState_GetSessionTeamId");
static_assert(offsetof(GzPlayerState_GetSessionTeamId, ReturnValue) == 0x000000, "Member 'GzPlayerState_GetSessionTeamId::ReturnValue' has a wrong offset!");

// Function G01.GzPlayerState.GetStoredInGameCurrencyQuantity
// 0x0004 (0x0004 - 0x0000)
struct GzPlayerState_GetStoredInGameCurrencyQuantity final
{
public:
	int32                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzPlayerState_GetStoredInGameCurrencyQuantity) == 0x000004, "Wrong alignment on GzPlayerState_GetStoredInGameCurrencyQuantity");
static_assert(sizeof(GzPlayerState_GetStoredInGameCurrencyQuantity) == 0x000004, "Wrong size on GzPlayerState_GetStoredInGameCurrencyQuantity");
static_assert(offsetof(GzPlayerState_GetStoredInGameCurrencyQuantity, ReturnValue) == 0x000000, "Member 'GzPlayerState_GetStoredInGameCurrencyQuantity::ReturnValue' has a wrong offset!");

// Function G01.GzPlayerState.GetTeam
// 0x0008 (0x0008 - 0x0000)
struct GzPlayerState_GetTeam final
{
public:
	class AGzTeam*                                ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzPlayerState_GetTeam) == 0x000008, "Wrong alignment on GzPlayerState_GetTeam");
static_assert(sizeof(GzPlayerState_GetTeam) == 0x000008, "Wrong size on GzPlayerState_GetTeam");
static_assert(offsetof(GzPlayerState_GetTeam, ReturnValue) == 0x000000, "Member 'GzPlayerState_GetTeam::ReturnValue' has a wrong offset!");

// Function G01.GzPlayerState.GetTeamId
// 0x0004 (0x0004 - 0x0000)
struct GzPlayerState_GetTeamId final
{
public:
	int32                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzPlayerState_GetTeamId) == 0x000004, "Wrong alignment on GzPlayerState_GetTeamId");
static_assert(sizeof(GzPlayerState_GetTeamId) == 0x000004, "Wrong size on GzPlayerState_GetTeamId");
static_assert(offsetof(GzPlayerState_GetTeamId, ReturnValue) == 0x000000, "Member 'GzPlayerState_GetTeamId::ReturnValue' has a wrong offset!");

// Function G01.GzPlayerState.GetTitleAccountId
// 0x0010 (0x0010 - 0x0000)
struct GzPlayerState_GetTitleAccountId final
{
public:
	class FString                                 ReturnValue;                                       // 0x0000(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzPlayerState_GetTitleAccountId) == 0x000008, "Wrong alignment on GzPlayerState_GetTitleAccountId");
static_assert(sizeof(GzPlayerState_GetTitleAccountId) == 0x000010, "Wrong size on GzPlayerState_GetTitleAccountId");
static_assert(offsetof(GzPlayerState_GetTitleAccountId, ReturnValue) == 0x000000, "Member 'GzPlayerState_GetTitleAccountId::ReturnValue' has a wrong offset!");

// Function G01.GzPlayerState.HasLeftMatch
// 0x0001 (0x0001 - 0x0000)
struct GzPlayerState_HasLeftMatch final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzPlayerState_HasLeftMatch) == 0x000001, "Wrong alignment on GzPlayerState_HasLeftMatch");
static_assert(sizeof(GzPlayerState_HasLeftMatch) == 0x000001, "Wrong size on GzPlayerState_HasLeftMatch");
static_assert(offsetof(GzPlayerState_HasLeftMatch, ReturnValue) == 0x000000, "Member 'GzPlayerState_HasLeftMatch::ReturnValue' has a wrong offset!");

// Function G01.GzPlayerState.IsConnected
// 0x0001 (0x0001 - 0x0000)
struct GzPlayerState_IsConnected final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzPlayerState_IsConnected) == 0x000001, "Wrong alignment on GzPlayerState_IsConnected");
static_assert(sizeof(GzPlayerState_IsConnected) == 0x000001, "Wrong size on GzPlayerState_IsConnected");
static_assert(offsetof(GzPlayerState_IsConnected, ReturnValue) == 0x000000, "Member 'GzPlayerState_IsConnected::ReturnValue' has a wrong offset!");

// Function G01.GzPlayerState.IsInComebackArena
// 0x0001 (0x0001 - 0x0000)
struct GzPlayerState_IsInComebackArena final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzPlayerState_IsInComebackArena) == 0x000001, "Wrong alignment on GzPlayerState_IsInComebackArena");
static_assert(sizeof(GzPlayerState_IsInComebackArena) == 0x000001, "Wrong size on GzPlayerState_IsInComebackArena");
static_assert(offsetof(GzPlayerState_IsInComebackArena, ReturnValue) == 0x000000, "Member 'GzPlayerState_IsInComebackArena::ReturnValue' has a wrong offset!");

// Function G01.GzPlayerState.IsInComebackArenaQueue
// 0x0001 (0x0001 - 0x0000)
struct GzPlayerState_IsInComebackArenaQueue final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzPlayerState_IsInComebackArenaQueue) == 0x000001, "Wrong alignment on GzPlayerState_IsInComebackArenaQueue");
static_assert(sizeof(GzPlayerState_IsInComebackArenaQueue) == 0x000001, "Wrong size on GzPlayerState_IsInComebackArenaQueue");
static_assert(offsetof(GzPlayerState_IsInComebackArenaQueue, ReturnValue) == 0x000000, "Member 'GzPlayerState_IsInComebackArenaQueue::ReturnValue' has a wrong offset!");

// Function G01.GzPlayerState.IsInMatch
// 0x0001 (0x0001 - 0x0000)
struct GzPlayerState_IsInMatch final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzPlayerState_IsInMatch) == 0x000001, "Wrong alignment on GzPlayerState_IsInMatch");
static_assert(sizeof(GzPlayerState_IsInMatch) == 0x000001, "Wrong size on GzPlayerState_IsInMatch");
static_assert(offsetof(GzPlayerState_IsInMatch, ReturnValue) == 0x000000, "Member 'GzPlayerState_IsInMatch::ReturnValue' has a wrong offset!");

// Function G01.GzPlayerState.IsReadyToStart
// 0x0001 (0x0001 - 0x0000)
struct GzPlayerState_IsReadyToStart final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzPlayerState_IsReadyToStart) == 0x000001, "Wrong alignment on GzPlayerState_IsReadyToStart");
static_assert(sizeof(GzPlayerState_IsReadyToStart) == 0x000001, "Wrong size on GzPlayerState_IsReadyToStart");
static_assert(offsetof(GzPlayerState_IsReadyToStart, ReturnValue) == 0x000000, "Member 'GzPlayerState_IsReadyToStart::ReturnValue' has a wrong offset!");

// Function G01.GzPlayerState.IsSecondChanceAvailable
// 0x0001 (0x0001 - 0x0000)
struct GzPlayerState_IsSecondChanceAvailable final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzPlayerState_IsSecondChanceAvailable) == 0x000001, "Wrong alignment on GzPlayerState_IsSecondChanceAvailable");
static_assert(sizeof(GzPlayerState_IsSecondChanceAvailable) == 0x000001, "Wrong size on GzPlayerState_IsSecondChanceAvailable");
static_assert(offsetof(GzPlayerState_IsSecondChanceAvailable, ReturnValue) == 0x000000, "Member 'GzPlayerState_IsSecondChanceAvailable::ReturnValue' has a wrong offset!");

// Function G01.GzSessionGameModeSettings.CanReconnect
// 0x0001 (0x0001 - 0x0000)
struct GzSessionGameModeSettings_CanReconnect final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzSessionGameModeSettings_CanReconnect) == 0x000001, "Wrong alignment on GzSessionGameModeSettings_CanReconnect");
static_assert(sizeof(GzSessionGameModeSettings_CanReconnect) == 0x000001, "Wrong size on GzSessionGameModeSettings_CanReconnect");
static_assert(offsetof(GzSessionGameModeSettings_CanReconnect, ReturnValue) == 0x000000, "Member 'GzSessionGameModeSettings_CanReconnect::ReturnValue' has a wrong offset!");

// Function G01.GzSessionGameModeSettings.GetHexExtractionSetting
// 0x000C (0x000C - 0x0000)
struct GzSessionGameModeSettings_GetHexExtractionSetting final
{
public:
	EGzItemRarity                                 ItemRarity;                                        // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2FFB[0x3];                                     // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGzHexExtractionSettings               ReturnValue;                                       // 0x0004(0x0008)(Parm, OutParm, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzSessionGameModeSettings_GetHexExtractionSetting) == 0x000004, "Wrong alignment on GzSessionGameModeSettings_GetHexExtractionSetting");
static_assert(sizeof(GzSessionGameModeSettings_GetHexExtractionSetting) == 0x00000C, "Wrong size on GzSessionGameModeSettings_GetHexExtractionSetting");
static_assert(offsetof(GzSessionGameModeSettings_GetHexExtractionSetting, ItemRarity) == 0x000000, "Member 'GzSessionGameModeSettings_GetHexExtractionSetting::ItemRarity' has a wrong offset!");
static_assert(offsetof(GzSessionGameModeSettings_GetHexExtractionSetting, ReturnValue) == 0x000004, "Member 'GzSessionGameModeSettings_GetHexExtractionSetting::ReturnValue' has a wrong offset!");

// Function G01.GzSessionGameModeSettings.GetRedeploymentCostAtLevel
// 0x0008 (0x0008 - 0x0000)
struct GzSessionGameModeSettings_GetRedeploymentCostAtLevel final
{
public:
	int32                                         Level;                                             // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ReturnValue;                                       // 0x0004(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzSessionGameModeSettings_GetRedeploymentCostAtLevel) == 0x000004, "Wrong alignment on GzSessionGameModeSettings_GetRedeploymentCostAtLevel");
static_assert(sizeof(GzSessionGameModeSettings_GetRedeploymentCostAtLevel) == 0x000008, "Wrong size on GzSessionGameModeSettings_GetRedeploymentCostAtLevel");
static_assert(offsetof(GzSessionGameModeSettings_GetRedeploymentCostAtLevel, Level) == 0x000000, "Member 'GzSessionGameModeSettings_GetRedeploymentCostAtLevel::Level' has a wrong offset!");
static_assert(offsetof(GzSessionGameModeSettings_GetRedeploymentCostAtLevel, ReturnValue) == 0x000004, "Member 'GzSessionGameModeSettings_GetRedeploymentCostAtLevel::ReturnValue' has a wrong offset!");

// Function G01.GzSessionGameModeSettings.ShouldKillPlayerOnLeave
// 0x0001 (0x0001 - 0x0000)
struct GzSessionGameModeSettings_ShouldKillPlayerOnLeave final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzSessionGameModeSettings_ShouldKillPlayerOnLeave) == 0x000001, "Wrong alignment on GzSessionGameModeSettings_ShouldKillPlayerOnLeave");
static_assert(sizeof(GzSessionGameModeSettings_ShouldKillPlayerOnLeave) == 0x000001, "Wrong size on GzSessionGameModeSettings_ShouldKillPlayerOnLeave");
static_assert(offsetof(GzSessionGameModeSettings_ShouldKillPlayerOnLeave, ReturnValue) == 0x000000, "Member 'GzSessionGameModeSettings_ShouldKillPlayerOnLeave::ReturnValue' has a wrong offset!");

// DelegateFunction G01.GzBattleRoyaleZone.GzOnRadiusUpdated__DelegateSignature
// 0x0004 (0x0004 - 0x0000)
struct GzBattleRoyaleZone_GzOnRadiusUpdated__DelegateSignature final
{
public:
	float                                         NewRadius;                                         // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzBattleRoyaleZone_GzOnRadiusUpdated__DelegateSignature) == 0x000004, "Wrong alignment on GzBattleRoyaleZone_GzOnRadiusUpdated__DelegateSignature");
static_assert(sizeof(GzBattleRoyaleZone_GzOnRadiusUpdated__DelegateSignature) == 0x000004, "Wrong size on GzBattleRoyaleZone_GzOnRadiusUpdated__DelegateSignature");
static_assert(offsetof(GzBattleRoyaleZone_GzOnRadiusUpdated__DelegateSignature, NewRadius) == 0x000000, "Member 'GzBattleRoyaleZone_GzOnRadiusUpdated__DelegateSignature::NewRadius' has a wrong offset!");

// Function G01.GzBattleRoyaleZone.SetOverloadPaused
// 0x0001 (0x0001 - 0x0000)
struct GzBattleRoyaleZone_SetOverloadPaused final
{
public:
	bool                                          bPaused;                                           // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzBattleRoyaleZone_SetOverloadPaused) == 0x000001, "Wrong alignment on GzBattleRoyaleZone_SetOverloadPaused");
static_assert(sizeof(GzBattleRoyaleZone_SetOverloadPaused) == 0x000001, "Wrong size on GzBattleRoyaleZone_SetOverloadPaused");
static_assert(offsetof(GzBattleRoyaleZone_SetOverloadPaused, bPaused) == 0x000000, "Member 'GzBattleRoyaleZone_SetOverloadPaused::bPaused' has a wrong offset!");

// Function G01.GzBattleRoyaleZone.GetCurrentRadius
// 0x0004 (0x0004 - 0x0000)
struct GzBattleRoyaleZone_GetCurrentRadius final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzBattleRoyaleZone_GetCurrentRadius) == 0x000004, "Wrong alignment on GzBattleRoyaleZone_GetCurrentRadius");
static_assert(sizeof(GzBattleRoyaleZone_GetCurrentRadius) == 0x000004, "Wrong size on GzBattleRoyaleZone_GetCurrentRadius");
static_assert(offsetof(GzBattleRoyaleZone_GetCurrentRadius, ReturnValue) == 0x000000, "Member 'GzBattleRoyaleZone_GetCurrentRadius::ReturnValue' has a wrong offset!");

// Function G01.GzBattleRoyaleZone.GetLandingZoneOrigin
// 0x0010 (0x0010 - 0x0000)
struct GzBattleRoyaleZone_GetLandingZoneOrigin final
{
public:
	struct FVector2D                              ReturnValue;                                       // 0x0000(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzBattleRoyaleZone_GetLandingZoneOrigin) == 0x000008, "Wrong alignment on GzBattleRoyaleZone_GetLandingZoneOrigin");
static_assert(sizeof(GzBattleRoyaleZone_GetLandingZoneOrigin) == 0x000010, "Wrong size on GzBattleRoyaleZone_GetLandingZoneOrigin");
static_assert(offsetof(GzBattleRoyaleZone_GetLandingZoneOrigin, ReturnValue) == 0x000000, "Member 'GzBattleRoyaleZone_GetLandingZoneOrigin::ReturnValue' has a wrong offset!");

// Function G01.GzBattleRoyaleZone.GetOverloadStartTime
// 0x0004 (0x0004 - 0x0000)
struct GzBattleRoyaleZone_GetOverloadStartTime final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzBattleRoyaleZone_GetOverloadStartTime) == 0x000004, "Wrong alignment on GzBattleRoyaleZone_GetOverloadStartTime");
static_assert(sizeof(GzBattleRoyaleZone_GetOverloadStartTime) == 0x000004, "Wrong size on GzBattleRoyaleZone_GetOverloadStartTime");
static_assert(offsetof(GzBattleRoyaleZone_GetOverloadStartTime, ReturnValue) == 0x000000, "Member 'GzBattleRoyaleZone_GetOverloadStartTime::ReturnValue' has a wrong offset!");

// Function G01.GzBattleRoyaleZone.GetOverloadState
// 0x0001 (0x0001 - 0x0000)
struct GzBattleRoyaleZone_GetOverloadState final
{
public:
	EGzZoneOverloadState                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzBattleRoyaleZone_GetOverloadState) == 0x000001, "Wrong alignment on GzBattleRoyaleZone_GetOverloadState");
static_assert(sizeof(GzBattleRoyaleZone_GetOverloadState) == 0x000001, "Wrong size on GzBattleRoyaleZone_GetOverloadState");
static_assert(offsetof(GzBattleRoyaleZone_GetOverloadState, ReturnValue) == 0x000000, "Member 'GzBattleRoyaleZone_GetOverloadState::ReturnValue' has a wrong offset!");

// Function G01.GzBattleRoyaleZone.GetZoneCenter
// 0x0010 (0x0010 - 0x0000)
struct GzBattleRoyaleZone_GetZoneCenter final
{
public:
	struct FVector2D                              ReturnValue;                                       // 0x0000(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzBattleRoyaleZone_GetZoneCenter) == 0x000008, "Wrong alignment on GzBattleRoyaleZone_GetZoneCenter");
static_assert(sizeof(GzBattleRoyaleZone_GetZoneCenter) == 0x000010, "Wrong size on GzBattleRoyaleZone_GetZoneCenter");
static_assert(offsetof(GzBattleRoyaleZone_GetZoneCenter, ReturnValue) == 0x000000, "Member 'GzBattleRoyaleZone_GetZoneCenter::ReturnValue' has a wrong offset!");

// Function G01.GzBattleRoyaleZone.GetZoneIndex
// 0x0004 (0x0004 - 0x0000)
struct GzBattleRoyaleZone_GetZoneIndex final
{
public:
	int32                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzBattleRoyaleZone_GetZoneIndex) == 0x000004, "Wrong alignment on GzBattleRoyaleZone_GetZoneIndex");
static_assert(sizeof(GzBattleRoyaleZone_GetZoneIndex) == 0x000004, "Wrong size on GzBattleRoyaleZone_GetZoneIndex");
static_assert(offsetof(GzBattleRoyaleZone_GetZoneIndex, ReturnValue) == 0x000000, "Member 'GzBattleRoyaleZone_GetZoneIndex::ReturnValue' has a wrong offset!");

// Function G01.GzBattleRoyaleZone.GetZoneName
// 0x0008 (0x0008 - 0x0000)
struct GzBattleRoyaleZone_GetZoneName final
{
public:
	class FName                                   ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzBattleRoyaleZone_GetZoneName) == 0x000004, "Wrong alignment on GzBattleRoyaleZone_GetZoneName");
static_assert(sizeof(GzBattleRoyaleZone_GetZoneName) == 0x000008, "Wrong size on GzBattleRoyaleZone_GetZoneName");
static_assert(offsetof(GzBattleRoyaleZone_GetZoneName, ReturnValue) == 0x000000, "Member 'GzBattleRoyaleZone_GetZoneName::ReturnValue' has a wrong offset!");

// Function G01.GzBattleRoyaleZone.GetZoneOrigin
// 0x0010 (0x0010 - 0x0000)
struct GzBattleRoyaleZone_GetZoneOrigin final
{
public:
	struct FVector2D                              ReturnValue;                                       // 0x0000(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzBattleRoyaleZone_GetZoneOrigin) == 0x000008, "Wrong alignment on GzBattleRoyaleZone_GetZoneOrigin");
static_assert(sizeof(GzBattleRoyaleZone_GetZoneOrigin) == 0x000010, "Wrong size on GzBattleRoyaleZone_GetZoneOrigin");
static_assert(offsetof(GzBattleRoyaleZone_GetZoneOrigin, ReturnValue) == 0x000000, "Member 'GzBattleRoyaleZone_GetZoneOrigin::ReturnValue' has a wrong offset!");

// Function G01.GzBattleRoyaleZone.GetZonePoints
// 0x0010 (0x0010 - 0x0000)
struct GzBattleRoyaleZone_GetZonePoints final
{
public:
	TArray<struct FVector2D>                      ZonePoints;                                        // 0x0000(0x0010)(Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzBattleRoyaleZone_GetZonePoints) == 0x000008, "Wrong alignment on GzBattleRoyaleZone_GetZonePoints");
static_assert(sizeof(GzBattleRoyaleZone_GetZonePoints) == 0x000010, "Wrong size on GzBattleRoyaleZone_GetZonePoints");
static_assert(offsetof(GzBattleRoyaleZone_GetZonePoints, ZonePoints) == 0x000000, "Member 'GzBattleRoyaleZone_GetZonePoints::ZonePoints' has a wrong offset!");

// Function G01.GzBattleRoyaleZone.GetZoneText
// 0x0010 (0x0010 - 0x0000)
struct GzBattleRoyaleZone_GetZoneText final
{
public:
	class FText                                   ReturnValue;                                       // 0x0000(0x0010)(Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzBattleRoyaleZone_GetZoneText) == 0x000008, "Wrong alignment on GzBattleRoyaleZone_GetZoneText");
static_assert(sizeof(GzBattleRoyaleZone_GetZoneText) == 0x000010, "Wrong size on GzBattleRoyaleZone_GetZoneText");
static_assert(offsetof(GzBattleRoyaleZone_GetZoneText, ReturnValue) == 0x000000, "Member 'GzBattleRoyaleZone_GetZoneText::ReturnValue' has a wrong offset!");

// Function G01.GzBattleRoyaleZone.IsFullyOverloaded
// 0x0001 (0x0001 - 0x0000)
struct GzBattleRoyaleZone_IsFullyOverloaded final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzBattleRoyaleZone_IsFullyOverloaded) == 0x000001, "Wrong alignment on GzBattleRoyaleZone_IsFullyOverloaded");
static_assert(sizeof(GzBattleRoyaleZone_IsFullyOverloaded) == 0x000001, "Wrong size on GzBattleRoyaleZone_IsFullyOverloaded");
static_assert(offsetof(GzBattleRoyaleZone_IsFullyOverloaded, ReturnValue) == 0x000000, "Member 'GzBattleRoyaleZone_IsFullyOverloaded::ReturnValue' has a wrong offset!");

// Function G01.GzBattleRoyaleZone.IsInOverloadedZone
// 0x0018 (0x0018 - 0x0000)
struct GzBattleRoyaleZone_IsInOverloadedZone final
{
public:
	struct FVector2D                              Position;                                          // 0x0000(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0010(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3005[0x7];                                     // 0x0011(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GzBattleRoyaleZone_IsInOverloadedZone) == 0x000008, "Wrong alignment on GzBattleRoyaleZone_IsInOverloadedZone");
static_assert(sizeof(GzBattleRoyaleZone_IsInOverloadedZone) == 0x000018, "Wrong size on GzBattleRoyaleZone_IsInOverloadedZone");
static_assert(offsetof(GzBattleRoyaleZone_IsInOverloadedZone, Position) == 0x000000, "Member 'GzBattleRoyaleZone_IsInOverloadedZone::Position' has a wrong offset!");
static_assert(offsetof(GzBattleRoyaleZone_IsInOverloadedZone, ReturnValue) == 0x000010, "Member 'GzBattleRoyaleZone_IsInOverloadedZone::ReturnValue' has a wrong offset!");

// Function G01.GzBattleRoyaleZone.IsInOverloadingZoneRadius
// 0x0018 (0x0018 - 0x0000)
struct GzBattleRoyaleZone_IsInOverloadingZoneRadius final
{
public:
	struct FVector2D                              Position;                                          // 0x0000(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0010(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3006[0x7];                                     // 0x0011(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GzBattleRoyaleZone_IsInOverloadingZoneRadius) == 0x000008, "Wrong alignment on GzBattleRoyaleZone_IsInOverloadingZoneRadius");
static_assert(sizeof(GzBattleRoyaleZone_IsInOverloadingZoneRadius) == 0x000018, "Wrong size on GzBattleRoyaleZone_IsInOverloadingZoneRadius");
static_assert(offsetof(GzBattleRoyaleZone_IsInOverloadingZoneRadius, Position) == 0x000000, "Member 'GzBattleRoyaleZone_IsInOverloadingZoneRadius::Position' has a wrong offset!");
static_assert(offsetof(GzBattleRoyaleZone_IsInOverloadingZoneRadius, ReturnValue) == 0x000010, "Member 'GzBattleRoyaleZone_IsInOverloadingZoneRadius::ReturnValue' has a wrong offset!");

// Function G01.GzBattleRoyaleZone.IsOverloading
// 0x0001 (0x0001 - 0x0000)
struct GzBattleRoyaleZone_IsOverloading final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzBattleRoyaleZone_IsOverloading) == 0x000001, "Wrong alignment on GzBattleRoyaleZone_IsOverloading");
static_assert(sizeof(GzBattleRoyaleZone_IsOverloading) == 0x000001, "Wrong size on GzBattleRoyaleZone_IsOverloading");
static_assert(offsetof(GzBattleRoyaleZone_IsOverloading, ReturnValue) == 0x000000, "Member 'GzBattleRoyaleZone_IsOverloading::ReturnValue' has a wrong offset!");

// Function G01.GzBattleRoyaleZone.IsOverloadStarted
// 0x0001 (0x0001 - 0x0000)
struct GzBattleRoyaleZone_IsOverloadStarted final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzBattleRoyaleZone_IsOverloadStarted) == 0x000001, "Wrong alignment on GzBattleRoyaleZone_IsOverloadStarted");
static_assert(sizeof(GzBattleRoyaleZone_IsOverloadStarted) == 0x000001, "Wrong size on GzBattleRoyaleZone_IsOverloadStarted");
static_assert(offsetof(GzBattleRoyaleZone_IsOverloadStarted, ReturnValue) == 0x000000, "Member 'GzBattleRoyaleZone_IsOverloadStarted::ReturnValue' has a wrong offset!");

// Function G01.GzBattleRoyaleZone.IsShrinking
// 0x0001 (0x0001 - 0x0000)
struct GzBattleRoyaleZone_IsShrinking final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzBattleRoyaleZone_IsShrinking) == 0x000001, "Wrong alignment on GzBattleRoyaleZone_IsShrinking");
static_assert(sizeof(GzBattleRoyaleZone_IsShrinking) == 0x000001, "Wrong size on GzBattleRoyaleZone_IsShrinking");
static_assert(offsetof(GzBattleRoyaleZone_IsShrinking, ReturnValue) == 0x000000, "Member 'GzBattleRoyaleZone_IsShrinking::ReturnValue' has a wrong offset!");

// Function G01.GzBattleRoyaleZoneCheatExtension.OverloadZone
// 0x0010 (0x0010 - 0x0000)
struct GzBattleRoyaleZoneCheatExtension_OverloadZone final
{
public:
	class FString                                 ZoneName;                                          // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzBattleRoyaleZoneCheatExtension_OverloadZone) == 0x000008, "Wrong alignment on GzBattleRoyaleZoneCheatExtension_OverloadZone");
static_assert(sizeof(GzBattleRoyaleZoneCheatExtension_OverloadZone) == 0x000010, "Wrong size on GzBattleRoyaleZoneCheatExtension_OverloadZone");
static_assert(offsetof(GzBattleRoyaleZoneCheatExtension_OverloadZone, ZoneName) == 0x000000, "Member 'GzBattleRoyaleZoneCheatExtension_OverloadZone::ZoneName' has a wrong offset!");

// Function G01.GzBattleRoyaleZoneCheatExtension.ResetZone
// 0x0010 (0x0010 - 0x0000)
struct GzBattleRoyaleZoneCheatExtension_ResetZone final
{
public:
	class FString                                 ZoneName;                                          // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzBattleRoyaleZoneCheatExtension_ResetZone) == 0x000008, "Wrong alignment on GzBattleRoyaleZoneCheatExtension_ResetZone");
static_assert(sizeof(GzBattleRoyaleZoneCheatExtension_ResetZone) == 0x000010, "Wrong size on GzBattleRoyaleZoneCheatExtension_ResetZone");
static_assert(offsetof(GzBattleRoyaleZoneCheatExtension_ResetZone, ZoneName) == 0x000000, "Member 'GzBattleRoyaleZoneCheatExtension_ResetZone::ZoneName' has a wrong offset!");

// Function G01.GzBattleRoyaleZoneCheatExtension.SelectLastZoneAndStartOverload
// 0x0018 (0x0018 - 0x0000)
struct GzBattleRoyaleZoneCheatExtension_SelectLastZoneAndStartOverload final
{
public:
	class FString                                 ZoneName;                                          // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         LandingZoneIndex;                                  // 0x0010(0x0004)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3007[0x4];                                     // 0x0014(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GzBattleRoyaleZoneCheatExtension_SelectLastZoneAndStartOverload) == 0x000008, "Wrong alignment on GzBattleRoyaleZoneCheatExtension_SelectLastZoneAndStartOverload");
static_assert(sizeof(GzBattleRoyaleZoneCheatExtension_SelectLastZoneAndStartOverload) == 0x000018, "Wrong size on GzBattleRoyaleZoneCheatExtension_SelectLastZoneAndStartOverload");
static_assert(offsetof(GzBattleRoyaleZoneCheatExtension_SelectLastZoneAndStartOverload, ZoneName) == 0x000000, "Member 'GzBattleRoyaleZoneCheatExtension_SelectLastZoneAndStartOverload::ZoneName' has a wrong offset!");
static_assert(offsetof(GzBattleRoyaleZoneCheatExtension_SelectLastZoneAndStartOverload, LandingZoneIndex) == 0x000010, "Member 'GzBattleRoyaleZoneCheatExtension_SelectLastZoneAndStartOverload::LandingZoneIndex' has a wrong offset!");

// Function G01.GzInventoryCheatExtension.AddAttachmentToActiveWeapon
// 0x0010 (0x0010 - 0x0000)
struct GzInventoryCheatExtension_AddAttachmentToActiveWeapon final
{
public:
	class FString                                 AttachmentItemName;                                // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzInventoryCheatExtension_AddAttachmentToActiveWeapon) == 0x000008, "Wrong alignment on GzInventoryCheatExtension_AddAttachmentToActiveWeapon");
static_assert(sizeof(GzInventoryCheatExtension_AddAttachmentToActiveWeapon) == 0x000010, "Wrong size on GzInventoryCheatExtension_AddAttachmentToActiveWeapon");
static_assert(offsetof(GzInventoryCheatExtension_AddAttachmentToActiveWeapon, AttachmentItemName) == 0x000000, "Member 'GzInventoryCheatExtension_AddAttachmentToActiveWeapon::AttachmentItemName' has a wrong offset!");

// Function G01.GzInventoryCheatExtension.AddBackpack
// 0x0010 (0x0010 - 0x0000)
struct GzInventoryCheatExtension_AddBackpack final
{
public:
	class FString                                 BackpackName;                                      // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzInventoryCheatExtension_AddBackpack) == 0x000008, "Wrong alignment on GzInventoryCheatExtension_AddBackpack");
static_assert(sizeof(GzInventoryCheatExtension_AddBackpack) == 0x000010, "Wrong size on GzInventoryCheatExtension_AddBackpack");
static_assert(offsetof(GzInventoryCheatExtension_AddBackpack, BackpackName) == 0x000000, "Member 'GzInventoryCheatExtension_AddBackpack::BackpackName' has a wrong offset!");

// Function G01.GzInventoryCheatExtension.AddConsumableWithQuantity
// 0x0018 (0x0018 - 0x0000)
struct GzInventoryCheatExtension_AddConsumableWithQuantity final
{
public:
	class FString                                 ItemName;                                          // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Quantity;                                          // 0x0010(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3008[0x4];                                     // 0x0014(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GzInventoryCheatExtension_AddConsumableWithQuantity) == 0x000008, "Wrong alignment on GzInventoryCheatExtension_AddConsumableWithQuantity");
static_assert(sizeof(GzInventoryCheatExtension_AddConsumableWithQuantity) == 0x000018, "Wrong size on GzInventoryCheatExtension_AddConsumableWithQuantity");
static_assert(offsetof(GzInventoryCheatExtension_AddConsumableWithQuantity, ItemName) == 0x000000, "Member 'GzInventoryCheatExtension_AddConsumableWithQuantity::ItemName' has a wrong offset!");
static_assert(offsetof(GzInventoryCheatExtension_AddConsumableWithQuantity, Quantity) == 0x000010, "Member 'GzInventoryCheatExtension_AddConsumableWithQuantity::Quantity' has a wrong offset!");

// Function G01.GzInventoryCheatExtension.AddContainerItem
// 0x0010 (0x0010 - 0x0000)
struct GzInventoryCheatExtension_AddContainerItem final
{
public:
	class FString                                 ItemName;                                          // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzInventoryCheatExtension_AddContainerItem) == 0x000008, "Wrong alignment on GzInventoryCheatExtension_AddContainerItem");
static_assert(sizeof(GzInventoryCheatExtension_AddContainerItem) == 0x000010, "Wrong size on GzInventoryCheatExtension_AddContainerItem");
static_assert(offsetof(GzInventoryCheatExtension_AddContainerItem, ItemName) == 0x000000, "Member 'GzInventoryCheatExtension_AddContainerItem::ItemName' has a wrong offset!");

// Function G01.GzInventoryCheatExtension.AddMiscItem
// 0x0010 (0x0010 - 0x0000)
struct GzInventoryCheatExtension_AddMiscItem final
{
public:
	class FString                                 ItemName;                                          // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzInventoryCheatExtension_AddMiscItem) == 0x000008, "Wrong alignment on GzInventoryCheatExtension_AddMiscItem");
static_assert(sizeof(GzInventoryCheatExtension_AddMiscItem) == 0x000010, "Wrong size on GzInventoryCheatExtension_AddMiscItem");
static_assert(offsetof(GzInventoryCheatExtension_AddMiscItem, ItemName) == 0x000000, "Member 'GzInventoryCheatExtension_AddMiscItem::ItemName' has a wrong offset!");

// Function G01.GzInventoryCheatExtension.AddMiscItemWithQuantity
// 0x0018 (0x0018 - 0x0000)
struct GzInventoryCheatExtension_AddMiscItemWithQuantity final
{
public:
	class FString                                 ItemName;                                          // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Quantity;                                          // 0x0010(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3009[0x4];                                     // 0x0014(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GzInventoryCheatExtension_AddMiscItemWithQuantity) == 0x000008, "Wrong alignment on GzInventoryCheatExtension_AddMiscItemWithQuantity");
static_assert(sizeof(GzInventoryCheatExtension_AddMiscItemWithQuantity) == 0x000018, "Wrong size on GzInventoryCheatExtension_AddMiscItemWithQuantity");
static_assert(offsetof(GzInventoryCheatExtension_AddMiscItemWithQuantity, ItemName) == 0x000000, "Member 'GzInventoryCheatExtension_AddMiscItemWithQuantity::ItemName' has a wrong offset!");
static_assert(offsetof(GzInventoryCheatExtension_AddMiscItemWithQuantity, Quantity) == 0x000010, "Member 'GzInventoryCheatExtension_AddMiscItemWithQuantity::Quantity' has a wrong offset!");

// Function G01.GzInventoryCheatExtension.ApplySkinForActiveWeapon
// 0x0010 (0x0010 - 0x0000)
struct GzInventoryCheatExtension_ApplySkinForActiveWeapon final
{
public:
	class FString                                 SkinItemName;                                      // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzInventoryCheatExtension_ApplySkinForActiveWeapon) == 0x000008, "Wrong alignment on GzInventoryCheatExtension_ApplySkinForActiveWeapon");
static_assert(sizeof(GzInventoryCheatExtension_ApplySkinForActiveWeapon) == 0x000010, "Wrong size on GzInventoryCheatExtension_ApplySkinForActiveWeapon");
static_assert(offsetof(GzInventoryCheatExtension_ApplySkinForActiveWeapon, SkinItemName) == 0x000000, "Member 'GzInventoryCheatExtension_ApplySkinForActiveWeapon::SkinItemName' has a wrong offset!");

// Function G01.GzInventoryCheatExtension.ApplySkinForLimb
// 0x0018 (0x0018 - 0x0000)
struct GzInventoryCheatExtension_ApplySkinForLimb final
{
public:
	int32                                         LimbType;                                          // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_300A[0x4];                                     // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 SkinItemName;                                      // 0x0008(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzInventoryCheatExtension_ApplySkinForLimb) == 0x000008, "Wrong alignment on GzInventoryCheatExtension_ApplySkinForLimb");
static_assert(sizeof(GzInventoryCheatExtension_ApplySkinForLimb) == 0x000018, "Wrong size on GzInventoryCheatExtension_ApplySkinForLimb");
static_assert(offsetof(GzInventoryCheatExtension_ApplySkinForLimb, LimbType) == 0x000000, "Member 'GzInventoryCheatExtension_ApplySkinForLimb::LimbType' has a wrong offset!");
static_assert(offsetof(GzInventoryCheatExtension_ApplySkinForLimb, SkinItemName) == 0x000008, "Member 'GzInventoryCheatExtension_ApplySkinForLimb::SkinItemName' has a wrong offset!");

// Function G01.GzInventoryCheatExtension.RemoveAttachmentFromActiveWeapon
// 0x0010 (0x0010 - 0x0000)
struct GzInventoryCheatExtension_RemoveAttachmentFromActiveWeapon final
{
public:
	class FString                                 AttachmentTypeStr;                                 // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzInventoryCheatExtension_RemoveAttachmentFromActiveWeapon) == 0x000008, "Wrong alignment on GzInventoryCheatExtension_RemoveAttachmentFromActiveWeapon");
static_assert(sizeof(GzInventoryCheatExtension_RemoveAttachmentFromActiveWeapon) == 0x000010, "Wrong size on GzInventoryCheatExtension_RemoveAttachmentFromActiveWeapon");
static_assert(offsetof(GzInventoryCheatExtension_RemoveAttachmentFromActiveWeapon, AttachmentTypeStr) == 0x000000, "Member 'GzInventoryCheatExtension_RemoveAttachmentFromActiveWeapon::AttachmentTypeStr' has a wrong offset!");

// Function G01.GzInventoryCheatExtension.RemoveSkinFromLimb
// 0x0004 (0x0004 - 0x0000)
struct GzInventoryCheatExtension_RemoveSkinFromLimb final
{
public:
	int32                                         LimbType;                                          // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzInventoryCheatExtension_RemoveSkinFromLimb) == 0x000004, "Wrong alignment on GzInventoryCheatExtension_RemoveSkinFromLimb");
static_assert(sizeof(GzInventoryCheatExtension_RemoveSkinFromLimb) == 0x000004, "Wrong size on GzInventoryCheatExtension_RemoveSkinFromLimb");
static_assert(offsetof(GzInventoryCheatExtension_RemoveSkinFromLimb, LimbType) == 0x000000, "Member 'GzInventoryCheatExtension_RemoveSkinFromLimb::LimbType' has a wrong offset!");

// Function G01.GzInventoryCheatExtension.ShowSuitableAttachmentsOfTypeForActiveWeapon
// 0x0010 (0x0010 - 0x0000)
struct GzInventoryCheatExtension_ShowSuitableAttachmentsOfTypeForActiveWeapon final
{
public:
	class FString                                 AttachmentTypeStr;                                 // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzInventoryCheatExtension_ShowSuitableAttachmentsOfTypeForActiveWeapon) == 0x000008, "Wrong alignment on GzInventoryCheatExtension_ShowSuitableAttachmentsOfTypeForActiveWeapon");
static_assert(sizeof(GzInventoryCheatExtension_ShowSuitableAttachmentsOfTypeForActiveWeapon) == 0x000010, "Wrong size on GzInventoryCheatExtension_ShowSuitableAttachmentsOfTypeForActiveWeapon");
static_assert(offsetof(GzInventoryCheatExtension_ShowSuitableAttachmentsOfTypeForActiveWeapon, AttachmentTypeStr) == 0x000000, "Member 'GzInventoryCheatExtension_ShowSuitableAttachmentsOfTypeForActiveWeapon::AttachmentTypeStr' has a wrong offset!");

// DelegateFunction G01.GzSceneManager.GzSceneChangedDynamic__DelegateSignature
// 0x0018 (0x0018 - 0x0000)
struct GzSceneManager_GzSceneChangedDynamic__DelegateSignature final
{
public:
	struct FGameplayTag                           SceneTag;                                          // 0x0000(0x0008)(Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGzSceneChangedEventData               EventData;                                         // 0x0008(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzSceneManager_GzSceneChangedDynamic__DelegateSignature) == 0x000004, "Wrong alignment on GzSceneManager_GzSceneChangedDynamic__DelegateSignature");
static_assert(sizeof(GzSceneManager_GzSceneChangedDynamic__DelegateSignature) == 0x000018, "Wrong size on GzSceneManager_GzSceneChangedDynamic__DelegateSignature");
static_assert(offsetof(GzSceneManager_GzSceneChangedDynamic__DelegateSignature, SceneTag) == 0x000000, "Member 'GzSceneManager_GzSceneChangedDynamic__DelegateSignature::SceneTag' has a wrong offset!");
static_assert(offsetof(GzSceneManager_GzSceneChangedDynamic__DelegateSignature, EventData) == 0x000008, "Member 'GzSceneManager_GzSceneChangedDynamic__DelegateSignature::EventData' has a wrong offset!");

// DelegateFunction G01.GzSceneManager.GzSceneUpdatedDynamic__DelegateSignature
// 0x0018 (0x0018 - 0x0000)
struct GzSceneManager_GzSceneUpdatedDynamic__DelegateSignature final
{
public:
	struct FGameplayTag                           SceneTag;                                          // 0x0000(0x0008)(Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGzSceneChangedEventData               EventData;                                         // 0x0008(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzSceneManager_GzSceneUpdatedDynamic__DelegateSignature) == 0x000004, "Wrong alignment on GzSceneManager_GzSceneUpdatedDynamic__DelegateSignature");
static_assert(sizeof(GzSceneManager_GzSceneUpdatedDynamic__DelegateSignature) == 0x000018, "Wrong size on GzSceneManager_GzSceneUpdatedDynamic__DelegateSignature");
static_assert(offsetof(GzSceneManager_GzSceneUpdatedDynamic__DelegateSignature, SceneTag) == 0x000000, "Member 'GzSceneManager_GzSceneUpdatedDynamic__DelegateSignature::SceneTag' has a wrong offset!");
static_assert(offsetof(GzSceneManager_GzSceneUpdatedDynamic__DelegateSignature, EventData) == 0x000008, "Member 'GzSceneManager_GzSceneUpdatedDynamic__DelegateSignature::EventData' has a wrong offset!");

// Function G01.GzSceneManager.GetTransitionParameters
// 0x001C (0x001C - 0x0000)
struct GzSceneManager_GetTransitionParameters final
{
public:
	struct FGameplayTag                           From;                                              // 0x0000(0x0008)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           To;                                                // 0x0008(0x0008)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGzSceneTransitionParameters           ReturnValue;                                       // 0x0010(0x000C)(ConstParm, Parm, OutParm, ReturnParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzSceneManager_GetTransitionParameters) == 0x000004, "Wrong alignment on GzSceneManager_GetTransitionParameters");
static_assert(sizeof(GzSceneManager_GetTransitionParameters) == 0x00001C, "Wrong size on GzSceneManager_GetTransitionParameters");
static_assert(offsetof(GzSceneManager_GetTransitionParameters, From) == 0x000000, "Member 'GzSceneManager_GetTransitionParameters::From' has a wrong offset!");
static_assert(offsetof(GzSceneManager_GetTransitionParameters, To) == 0x000008, "Member 'GzSceneManager_GetTransitionParameters::To' has a wrong offset!");
static_assert(offsetof(GzSceneManager_GetTransitionParameters, ReturnValue) == 0x000010, "Member 'GzSceneManager_GetTransitionParameters::ReturnValue' has a wrong offset!");

// Function G01.GzBattleRoyaleZoneManager.Instance
// 0x0010 (0x0010 - 0x0000)
struct GzBattleRoyaleZoneManager_Instance final
{
public:
	class UObject*                                WorldContextObject;                                // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AGzBattleRoyaleZoneManager*             ReturnValue;                                       // 0x0008(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzBattleRoyaleZoneManager_Instance) == 0x000008, "Wrong alignment on GzBattleRoyaleZoneManager_Instance");
static_assert(sizeof(GzBattleRoyaleZoneManager_Instance) == 0x000010, "Wrong size on GzBattleRoyaleZoneManager_Instance");
static_assert(offsetof(GzBattleRoyaleZoneManager_Instance, WorldContextObject) == 0x000000, "Member 'GzBattleRoyaleZoneManager_Instance::WorldContextObject' has a wrong offset!");
static_assert(offsetof(GzBattleRoyaleZoneManager_Instance, ReturnValue) == 0x000008, "Member 'GzBattleRoyaleZoneManager_Instance::ReturnValue' has a wrong offset!");

// Function G01.GzBattleRoyaleZoneManager.SelectLastOverloadedZoneByName
// 0x0010 (0x0010 - 0x0000)
struct GzBattleRoyaleZoneManager_SelectLastOverloadedZoneByName final
{
public:
	class FName                                   SelectedZoneName;                                  // 0x0000(0x0008)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SelectedLastZoneIndex;                             // 0x0008(0x0004)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SelectedZonePlayerID;                              // 0x000C(0x0004)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzBattleRoyaleZoneManager_SelectLastOverloadedZoneByName) == 0x000004, "Wrong alignment on GzBattleRoyaleZoneManager_SelectLastOverloadedZoneByName");
static_assert(sizeof(GzBattleRoyaleZoneManager_SelectLastOverloadedZoneByName) == 0x000010, "Wrong size on GzBattleRoyaleZoneManager_SelectLastOverloadedZoneByName");
static_assert(offsetof(GzBattleRoyaleZoneManager_SelectLastOverloadedZoneByName, SelectedZoneName) == 0x000000, "Member 'GzBattleRoyaleZoneManager_SelectLastOverloadedZoneByName::SelectedZoneName' has a wrong offset!");
static_assert(offsetof(GzBattleRoyaleZoneManager_SelectLastOverloadedZoneByName, SelectedLastZoneIndex) == 0x000008, "Member 'GzBattleRoyaleZoneManager_SelectLastOverloadedZoneByName::SelectedLastZoneIndex' has a wrong offset!");
static_assert(offsetof(GzBattleRoyaleZoneManager_SelectLastOverloadedZoneByName, SelectedZonePlayerID) == 0x00000C, "Member 'GzBattleRoyaleZoneManager_SelectLastOverloadedZoneByName::SelectedZonePlayerID' has a wrong offset!");

// Function G01.GzBattleRoyaleZoneManager.ExpandZone
// 0x0010 (0x0010 - 0x0000)
struct GzBattleRoyaleZoneManager_ExpandZone final
{
public:
	float                                         CurrentRadius;                                     // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxExpansionRadius;                                // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DeltaTime;                                         // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ReturnValue;                                       // 0x000C(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzBattleRoyaleZoneManager_ExpandZone) == 0x000004, "Wrong alignment on GzBattleRoyaleZoneManager_ExpandZone");
static_assert(sizeof(GzBattleRoyaleZoneManager_ExpandZone) == 0x000010, "Wrong size on GzBattleRoyaleZoneManager_ExpandZone");
static_assert(offsetof(GzBattleRoyaleZoneManager_ExpandZone, CurrentRadius) == 0x000000, "Member 'GzBattleRoyaleZoneManager_ExpandZone::CurrentRadius' has a wrong offset!");
static_assert(offsetof(GzBattleRoyaleZoneManager_ExpandZone, MaxExpansionRadius) == 0x000004, "Member 'GzBattleRoyaleZoneManager_ExpandZone::MaxExpansionRadius' has a wrong offset!");
static_assert(offsetof(GzBattleRoyaleZoneManager_ExpandZone, DeltaTime) == 0x000008, "Member 'GzBattleRoyaleZoneManager_ExpandZone::DeltaTime' has a wrong offset!");
static_assert(offsetof(GzBattleRoyaleZoneManager_ExpandZone, ReturnValue) == 0x00000C, "Member 'GzBattleRoyaleZoneManager_ExpandZone::ReturnValue' has a wrong offset!");

// Function G01.GzBattleRoyaleZoneManager.GetAvailableLastZoneData
// 0x0010 (0x0010 - 0x0000)
struct GzBattleRoyaleZoneManager_GetAvailableLastZoneData final
{
public:
	TArray<struct FGzZoneSelectionData>           ReturnValue;                                       // 0x0000(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzBattleRoyaleZoneManager_GetAvailableLastZoneData) == 0x000008, "Wrong alignment on GzBattleRoyaleZoneManager_GetAvailableLastZoneData");
static_assert(sizeof(GzBattleRoyaleZoneManager_GetAvailableLastZoneData) == 0x000010, "Wrong size on GzBattleRoyaleZoneManager_GetAvailableLastZoneData");
static_assert(offsetof(GzBattleRoyaleZoneManager_GetAvailableLastZoneData, ReturnValue) == 0x000000, "Member 'GzBattleRoyaleZoneManager_GetAvailableLastZoneData::ReturnValue' has a wrong offset!");

// Function G01.GzBattleRoyaleZoneManager.GetCurrentStageIndex
// 0x0004 (0x0004 - 0x0000)
struct GzBattleRoyaleZoneManager_GetCurrentStageIndex final
{
public:
	int32                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzBattleRoyaleZoneManager_GetCurrentStageIndex) == 0x000004, "Wrong alignment on GzBattleRoyaleZoneManager_GetCurrentStageIndex");
static_assert(sizeof(GzBattleRoyaleZoneManager_GetCurrentStageIndex) == 0x000004, "Wrong size on GzBattleRoyaleZoneManager_GetCurrentStageIndex");
static_assert(offsetof(GzBattleRoyaleZoneManager_GetCurrentStageIndex, ReturnValue) == 0x000000, "Member 'GzBattleRoyaleZoneManager_GetCurrentStageIndex::ReturnValue' has a wrong offset!");

// Function G01.GzBattleRoyaleZoneManager.GetLastOverloadedZone
// 0x0008 (0x0008 - 0x0000)
struct GzBattleRoyaleZoneManager_GetLastOverloadedZone final
{
public:
	class AGzBattleRoyaleZone*                    ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzBattleRoyaleZoneManager_GetLastOverloadedZone) == 0x000008, "Wrong alignment on GzBattleRoyaleZoneManager_GetLastOverloadedZone");
static_assert(sizeof(GzBattleRoyaleZoneManager_GetLastOverloadedZone) == 0x000008, "Wrong size on GzBattleRoyaleZoneManager_GetLastOverloadedZone");
static_assert(offsetof(GzBattleRoyaleZoneManager_GetLastOverloadedZone, ReturnValue) == 0x000000, "Member 'GzBattleRoyaleZoneManager_GetLastOverloadedZone::ReturnValue' has a wrong offset!");

// Function G01.GzBattleRoyaleZoneManager.GetOverloadTime
// 0x0004 (0x0004 - 0x0000)
struct GzBattleRoyaleZoneManager_GetOverloadTime final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzBattleRoyaleZoneManager_GetOverloadTime) == 0x000004, "Wrong alignment on GzBattleRoyaleZoneManager_GetOverloadTime");
static_assert(sizeof(GzBattleRoyaleZoneManager_GetOverloadTime) == 0x000004, "Wrong size on GzBattleRoyaleZoneManager_GetOverloadTime");
static_assert(offsetof(GzBattleRoyaleZoneManager_GetOverloadTime, ReturnValue) == 0x000000, "Member 'GzBattleRoyaleZoneManager_GetOverloadTime::ReturnValue' has a wrong offset!");

// Function G01.GzBattleRoyaleZoneManager.GetOverloadWaitPeriodTime
// 0x0004 (0x0004 - 0x0000)
struct GzBattleRoyaleZoneManager_GetOverloadWaitPeriodTime final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzBattleRoyaleZoneManager_GetOverloadWaitPeriodTime) == 0x000004, "Wrong alignment on GzBattleRoyaleZoneManager_GetOverloadWaitPeriodTime");
static_assert(sizeof(GzBattleRoyaleZoneManager_GetOverloadWaitPeriodTime) == 0x000004, "Wrong size on GzBattleRoyaleZoneManager_GetOverloadWaitPeriodTime");
static_assert(offsetof(GzBattleRoyaleZoneManager_GetOverloadWaitPeriodTime, ReturnValue) == 0x000000, "Member 'GzBattleRoyaleZoneManager_GetOverloadWaitPeriodTime::ReturnValue' has a wrong offset!");

// Function G01.GzBattleRoyaleZoneManager.GetPlayerActivatedOverload
// 0x0004 (0x0004 - 0x0000)
struct GzBattleRoyaleZoneManager_GetPlayerActivatedOverload final
{
public:
	int32                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzBattleRoyaleZoneManager_GetPlayerActivatedOverload) == 0x000004, "Wrong alignment on GzBattleRoyaleZoneManager_GetPlayerActivatedOverload");
static_assert(sizeof(GzBattleRoyaleZoneManager_GetPlayerActivatedOverload) == 0x000004, "Wrong size on GzBattleRoyaleZoneManager_GetPlayerActivatedOverload");
static_assert(offsetof(GzBattleRoyaleZoneManager_GetPlayerActivatedOverload, ReturnValue) == 0x000000, "Member 'GzBattleRoyaleZoneManager_GetPlayerActivatedOverload::ReturnValue' has a wrong offset!");

// Function G01.GzBattleRoyaleZoneManager.GetWaitPeriodEndTime
// 0x0004 (0x0004 - 0x0000)
struct GzBattleRoyaleZoneManager_GetWaitPeriodEndTime final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzBattleRoyaleZoneManager_GetWaitPeriodEndTime) == 0x000004, "Wrong alignment on GzBattleRoyaleZoneManager_GetWaitPeriodEndTime");
static_assert(sizeof(GzBattleRoyaleZoneManager_GetWaitPeriodEndTime) == 0x000004, "Wrong size on GzBattleRoyaleZoneManager_GetWaitPeriodEndTime");
static_assert(offsetof(GzBattleRoyaleZoneManager_GetWaitPeriodEndTime, ReturnValue) == 0x000000, "Member 'GzBattleRoyaleZoneManager_GetWaitPeriodEndTime::ReturnValue' has a wrong offset!");

// Function G01.GzBattleRoyaleZoneManager.GetZoneByPosition
// 0x0020 (0x0020 - 0x0000)
struct GzBattleRoyaleZoneManager_GetZoneByPosition final
{
public:
	struct FVector                                Position;                                          // 0x0000(0x0018)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AGzBattleRoyaleZone*                    ReturnValue;                                       // 0x0018(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzBattleRoyaleZoneManager_GetZoneByPosition) == 0x000008, "Wrong alignment on GzBattleRoyaleZoneManager_GetZoneByPosition");
static_assert(sizeof(GzBattleRoyaleZoneManager_GetZoneByPosition) == 0x000020, "Wrong size on GzBattleRoyaleZoneManager_GetZoneByPosition");
static_assert(offsetof(GzBattleRoyaleZoneManager_GetZoneByPosition, Position) == 0x000000, "Member 'GzBattleRoyaleZoneManager_GetZoneByPosition::Position' has a wrong offset!");
static_assert(offsetof(GzBattleRoyaleZoneManager_GetZoneByPosition, ReturnValue) == 0x000018, "Member 'GzBattleRoyaleZoneManager_GetZoneByPosition::ReturnValue' has a wrong offset!");

// Function G01.GzBattleRoyaleZoneManager.GetZoneCount
// 0x0004 (0x0004 - 0x0000)
struct GzBattleRoyaleZoneManager_GetZoneCount final
{
public:
	int32                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzBattleRoyaleZoneManager_GetZoneCount) == 0x000004, "Wrong alignment on GzBattleRoyaleZoneManager_GetZoneCount");
static_assert(sizeof(GzBattleRoyaleZoneManager_GetZoneCount) == 0x000004, "Wrong size on GzBattleRoyaleZoneManager_GetZoneCount");
static_assert(offsetof(GzBattleRoyaleZoneManager_GetZoneCount, ReturnValue) == 0x000000, "Member 'GzBattleRoyaleZoneManager_GetZoneCount::ReturnValue' has a wrong offset!");

// Function G01.GzBattleRoyaleZoneManager.IsInAnyOverloadedZone
// 0x0020 (0x0020 - 0x0000)
struct GzBattleRoyaleZoneManager_IsInAnyOverloadedZone final
{
public:
	struct FVector                                Position;                                          // 0x0000(0x0018)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0018(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3011[0x7];                                     // 0x0019(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GzBattleRoyaleZoneManager_IsInAnyOverloadedZone) == 0x000008, "Wrong alignment on GzBattleRoyaleZoneManager_IsInAnyOverloadedZone");
static_assert(sizeof(GzBattleRoyaleZoneManager_IsInAnyOverloadedZone) == 0x000020, "Wrong size on GzBattleRoyaleZoneManager_IsInAnyOverloadedZone");
static_assert(offsetof(GzBattleRoyaleZoneManager_IsInAnyOverloadedZone, Position) == 0x000000, "Member 'GzBattleRoyaleZoneManager_IsInAnyOverloadedZone::Position' has a wrong offset!");
static_assert(offsetof(GzBattleRoyaleZoneManager_IsInAnyOverloadedZone, ReturnValue) == 0x000018, "Member 'GzBattleRoyaleZoneManager_IsInAnyOverloadedZone::ReturnValue' has a wrong offset!");

// Function G01.GzBattleRoyaleZoneManager.IsInOverloadedZoneRadius
// 0x0028 (0x0028 - 0x0000)
struct GzBattleRoyaleZoneManager_IsInOverloadedZoneRadius final
{
public:
	class AGzBattleRoyaleZone*                    Zone;                                              // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Position;                                          // 0x0008(0x0018)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0020(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3012[0x7];                                     // 0x0021(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GzBattleRoyaleZoneManager_IsInOverloadedZoneRadius) == 0x000008, "Wrong alignment on GzBattleRoyaleZoneManager_IsInOverloadedZoneRadius");
static_assert(sizeof(GzBattleRoyaleZoneManager_IsInOverloadedZoneRadius) == 0x000028, "Wrong size on GzBattleRoyaleZoneManager_IsInOverloadedZoneRadius");
static_assert(offsetof(GzBattleRoyaleZoneManager_IsInOverloadedZoneRadius, Zone) == 0x000000, "Member 'GzBattleRoyaleZoneManager_IsInOverloadedZoneRadius::Zone' has a wrong offset!");
static_assert(offsetof(GzBattleRoyaleZoneManager_IsInOverloadedZoneRadius, Position) == 0x000008, "Member 'GzBattleRoyaleZoneManager_IsInOverloadedZoneRadius::Position' has a wrong offset!");
static_assert(offsetof(GzBattleRoyaleZoneManager_IsInOverloadedZoneRadius, ReturnValue) == 0x000020, "Member 'GzBattleRoyaleZoneManager_IsInOverloadedZoneRadius::ReturnValue' has a wrong offset!");

// Function G01.GzBattleRoyaleZoneManager.IsOverloadStarted
// 0x0001 (0x0001 - 0x0000)
struct GzBattleRoyaleZoneManager_IsOverloadStarted final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzBattleRoyaleZoneManager_IsOverloadStarted) == 0x000001, "Wrong alignment on GzBattleRoyaleZoneManager_IsOverloadStarted");
static_assert(sizeof(GzBattleRoyaleZoneManager_IsOverloadStarted) == 0x000001, "Wrong size on GzBattleRoyaleZoneManager_IsOverloadStarted");
static_assert(offsetof(GzBattleRoyaleZoneManager_IsOverloadStarted, ReturnValue) == 0x000000, "Member 'GzBattleRoyaleZoneManager_IsOverloadStarted::ReturnValue' has a wrong offset!");

// Function G01.GzBattleRoyaleZoneManager.ShrinkZone
// 0x0010 (0x0010 - 0x0000)
struct GzBattleRoyaleZoneManager_ShrinkZone final
{
public:
	float                                         CurrentRadius;                                     // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxExpansionRadius;                                // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DeltaTime;                                         // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ReturnValue;                                       // 0x000C(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzBattleRoyaleZoneManager_ShrinkZone) == 0x000004, "Wrong alignment on GzBattleRoyaleZoneManager_ShrinkZone");
static_assert(sizeof(GzBattleRoyaleZoneManager_ShrinkZone) == 0x000010, "Wrong size on GzBattleRoyaleZoneManager_ShrinkZone");
static_assert(offsetof(GzBattleRoyaleZoneManager_ShrinkZone, CurrentRadius) == 0x000000, "Member 'GzBattleRoyaleZoneManager_ShrinkZone::CurrentRadius' has a wrong offset!");
static_assert(offsetof(GzBattleRoyaleZoneManager_ShrinkZone, MaxExpansionRadius) == 0x000004, "Member 'GzBattleRoyaleZoneManager_ShrinkZone::MaxExpansionRadius' has a wrong offset!");
static_assert(offsetof(GzBattleRoyaleZoneManager_ShrinkZone, DeltaTime) == 0x000008, "Member 'GzBattleRoyaleZoneManager_ShrinkZone::DeltaTime' has a wrong offset!");
static_assert(offsetof(GzBattleRoyaleZoneManager_ShrinkZone, ReturnValue) == 0x00000C, "Member 'GzBattleRoyaleZoneManager_ShrinkZone::ReturnValue' has a wrong offset!");

// Function G01.GzLoadoutSelectionComponent.TryGiveLoadout
// 0x0018 (0x0018 - 0x0000)
struct GzLoadoutSelectionComponent_TryGiveLoadout final
{
public:
	class AGzCharacter*                           Player;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGuid                                  LoadoutGuid;                                       // 0x0008(0x0010)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzLoadoutSelectionComponent_TryGiveLoadout) == 0x000008, "Wrong alignment on GzLoadoutSelectionComponent_TryGiveLoadout");
static_assert(sizeof(GzLoadoutSelectionComponent_TryGiveLoadout) == 0x000018, "Wrong size on GzLoadoutSelectionComponent_TryGiveLoadout");
static_assert(offsetof(GzLoadoutSelectionComponent_TryGiveLoadout, Player) == 0x000000, "Member 'GzLoadoutSelectionComponent_TryGiveLoadout::Player' has a wrong offset!");
static_assert(offsetof(GzLoadoutSelectionComponent_TryGiveLoadout, LoadoutGuid) == 0x000008, "Member 'GzLoadoutSelectionComponent_TryGiveLoadout::LoadoutGuid' has a wrong offset!");

// Function G01.GzLoadoutSelectionComponent.CanGiveLoadout
// 0x0010 (0x0010 - 0x0000)
struct GzLoadoutSelectionComponent_CanGiveLoadout final
{
public:
	const class AGzCharacter*                     Player;                                            // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3016[0x7];                                     // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GzLoadoutSelectionComponent_CanGiveLoadout) == 0x000008, "Wrong alignment on GzLoadoutSelectionComponent_CanGiveLoadout");
static_assert(sizeof(GzLoadoutSelectionComponent_CanGiveLoadout) == 0x000010, "Wrong size on GzLoadoutSelectionComponent_CanGiveLoadout");
static_assert(offsetof(GzLoadoutSelectionComponent_CanGiveLoadout, Player) == 0x000000, "Member 'GzLoadoutSelectionComponent_CanGiveLoadout::Player' has a wrong offset!");
static_assert(offsetof(GzLoadoutSelectionComponent_CanGiveLoadout, ReturnValue) == 0x000008, "Member 'GzLoadoutSelectionComponent_CanGiveLoadout::ReturnValue' has a wrong offset!");

// Function G01.GzLoadoutSelectionComponent.OnRep_LoadoutGrantedPlayerIds
// 0x0010 (0x0010 - 0x0000)
struct GzLoadoutSelectionComponent_OnRep_LoadoutGrantedPlayerIds final
{
public:
	TArray<int32>                                 OldLoadoutGrantedPlayerIds;                        // 0x0000(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzLoadoutSelectionComponent_OnRep_LoadoutGrantedPlayerIds) == 0x000008, "Wrong alignment on GzLoadoutSelectionComponent_OnRep_LoadoutGrantedPlayerIds");
static_assert(sizeof(GzLoadoutSelectionComponent_OnRep_LoadoutGrantedPlayerIds) == 0x000010, "Wrong size on GzLoadoutSelectionComponent_OnRep_LoadoutGrantedPlayerIds");
static_assert(offsetof(GzLoadoutSelectionComponent_OnRep_LoadoutGrantedPlayerIds, OldLoadoutGrantedPlayerIds) == 0x000000, "Member 'GzLoadoutSelectionComponent_OnRep_LoadoutGrantedPlayerIds::OldLoadoutGrantedPlayerIds' has a wrong offset!");

// Function G01.GzBlackboardCoverData.HasData
// 0x0001 (0x0001 - 0x0000)
struct GzBlackboardCoverData_HasData final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzBlackboardCoverData_HasData) == 0x000001, "Wrong alignment on GzBlackboardCoverData_HasData");
static_assert(sizeof(GzBlackboardCoverData_HasData) == 0x000001, "Wrong size on GzBlackboardCoverData_HasData");
static_assert(offsetof(GzBlackboardCoverData_HasData, ReturnValue) == 0x000000, "Member 'GzBlackboardCoverData_HasData::ReturnValue' has a wrong offset!");

// Function G01.GzBlueprintCVarHelper.SetCVarName
// 0x0010 (0x0010 - 0x0000)
struct GzBlueprintCVarHelper_SetCVarName final
{
public:
	class FString                                 NewName;                                           // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzBlueprintCVarHelper_SetCVarName) == 0x000008, "Wrong alignment on GzBlueprintCVarHelper_SetCVarName");
static_assert(sizeof(GzBlueprintCVarHelper_SetCVarName) == 0x000010, "Wrong size on GzBlueprintCVarHelper_SetCVarName");
static_assert(offsetof(GzBlueprintCVarHelper_SetCVarName, NewName) == 0x000000, "Member 'GzBlueprintCVarHelper_SetCVarName::NewName' has a wrong offset!");

// Function G01.GzBlueprintCVarHelper.SetValue
// 0x0010 (0x0010 - 0x0000)
struct GzBlueprintCVarHelper_SetValue final
{
public:
	class FString                                 NewValue;                                          // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzBlueprintCVarHelper_SetValue) == 0x000008, "Wrong alignment on GzBlueprintCVarHelper_SetValue");
static_assert(sizeof(GzBlueprintCVarHelper_SetValue) == 0x000010, "Wrong size on GzBlueprintCVarHelper_SetValue");
static_assert(offsetof(GzBlueprintCVarHelper_SetValue, NewValue) == 0x000000, "Member 'GzBlueprintCVarHelper_SetValue::NewValue' has a wrong offset!");

// Function G01.GzBlueprintCVarHelper.GetCVarName
// 0x0010 (0x0010 - 0x0000)
struct GzBlueprintCVarHelper_GetCVarName final
{
public:
	class FString                                 ReturnValue;                                       // 0x0000(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzBlueprintCVarHelper_GetCVarName) == 0x000008, "Wrong alignment on GzBlueprintCVarHelper_GetCVarName");
static_assert(sizeof(GzBlueprintCVarHelper_GetCVarName) == 0x000010, "Wrong size on GzBlueprintCVarHelper_GetCVarName");
static_assert(offsetof(GzBlueprintCVarHelper_GetCVarName, ReturnValue) == 0x000000, "Member 'GzBlueprintCVarHelper_GetCVarName::ReturnValue' has a wrong offset!");

// Function G01.GzBlueprintCVarHelper.GetDesciptionMultiline
// 0x0010 (0x0010 - 0x0000)
struct GzBlueprintCVarHelper_GetDesciptionMultiline final
{
public:
	TArray<class FString>                         ReturnValue;                                       // 0x0000(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzBlueprintCVarHelper_GetDesciptionMultiline) == 0x000008, "Wrong alignment on GzBlueprintCVarHelper_GetDesciptionMultiline");
static_assert(sizeof(GzBlueprintCVarHelper_GetDesciptionMultiline) == 0x000010, "Wrong size on GzBlueprintCVarHelper_GetDesciptionMultiline");
static_assert(offsetof(GzBlueprintCVarHelper_GetDesciptionMultiline, ReturnValue) == 0x000000, "Member 'GzBlueprintCVarHelper_GetDesciptionMultiline::ReturnValue' has a wrong offset!");

// Function G01.GzBlueprintCVarHelper.GetDescription
// 0x0010 (0x0010 - 0x0000)
struct GzBlueprintCVarHelper_GetDescription final
{
public:
	class FString                                 ReturnValue;                                       // 0x0000(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzBlueprintCVarHelper_GetDescription) == 0x000008, "Wrong alignment on GzBlueprintCVarHelper_GetDescription");
static_assert(sizeof(GzBlueprintCVarHelper_GetDescription) == 0x000010, "Wrong size on GzBlueprintCVarHelper_GetDescription");
static_assert(offsetof(GzBlueprintCVarHelper_GetDescription, ReturnValue) == 0x000000, "Member 'GzBlueprintCVarHelper_GetDescription::ReturnValue' has a wrong offset!");

// Function G01.GzBlueprintCVarHelper.GetValue
// 0x0010 (0x0010 - 0x0000)
struct GzBlueprintCVarHelper_GetValue final
{
public:
	class FString                                 ReturnValue;                                       // 0x0000(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzBlueprintCVarHelper_GetValue) == 0x000008, "Wrong alignment on GzBlueprintCVarHelper_GetValue");
static_assert(sizeof(GzBlueprintCVarHelper_GetValue) == 0x000010, "Wrong size on GzBlueprintCVarHelper_GetValue");
static_assert(offsetof(GzBlueprintCVarHelper_GetValue, ReturnValue) == 0x000000, "Member 'GzBlueprintCVarHelper_GetValue::ReturnValue' has a wrong offset!");

// Function G01.GzBlueprintFunctionLibrary.BindObjectInputDelegates
// 0x0010 (0x0010 - 0x0000)
struct GzBlueprintFunctionLibrary_BindObjectInputDelegates final
{
public:
	class UObject*                                ObjectBindTo;                                      // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	const class APawn*                            Pawn;                                              // 0x0008(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzBlueprintFunctionLibrary_BindObjectInputDelegates) == 0x000008, "Wrong alignment on GzBlueprintFunctionLibrary_BindObjectInputDelegates");
static_assert(sizeof(GzBlueprintFunctionLibrary_BindObjectInputDelegates) == 0x000010, "Wrong size on GzBlueprintFunctionLibrary_BindObjectInputDelegates");
static_assert(offsetof(GzBlueprintFunctionLibrary_BindObjectInputDelegates, ObjectBindTo) == 0x000000, "Member 'GzBlueprintFunctionLibrary_BindObjectInputDelegates::ObjectBindTo' has a wrong offset!");
static_assert(offsetof(GzBlueprintFunctionLibrary_BindObjectInputDelegates, Pawn) == 0x000008, "Member 'GzBlueprintFunctionLibrary_BindObjectInputDelegates::Pawn' has a wrong offset!");

// Function G01.GzBlueprintFunctionLibrary.CanSpectateSomebodyElse
// 0x0010 (0x0010 - 0x0000)
struct GzBlueprintFunctionLibrary_CanSpectateSomebodyElse final
{
public:
	class AGzPlayerController*                    Viewer;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_301B[0x7];                                     // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GzBlueprintFunctionLibrary_CanSpectateSomebodyElse) == 0x000008, "Wrong alignment on GzBlueprintFunctionLibrary_CanSpectateSomebodyElse");
static_assert(sizeof(GzBlueprintFunctionLibrary_CanSpectateSomebodyElse) == 0x000010, "Wrong size on GzBlueprintFunctionLibrary_CanSpectateSomebodyElse");
static_assert(offsetof(GzBlueprintFunctionLibrary_CanSpectateSomebodyElse, Viewer) == 0x000000, "Member 'GzBlueprintFunctionLibrary_CanSpectateSomebodyElse::Viewer' has a wrong offset!");
static_assert(offsetof(GzBlueprintFunctionLibrary_CanSpectateSomebodyElse, ReturnValue) == 0x000008, "Member 'GzBlueprintFunctionLibrary_CanSpectateSomebodyElse::ReturnValue' has a wrong offset!");

// Function G01.GzBlueprintFunctionLibrary.CircleAsString
// 0x0028 (0x0028 - 0x0000)
struct GzBlueprintFunctionLibrary_CircleAsString final
{
public:
	struct FGzCircle2D                            Circle;                                            // 0x0000(0x0018)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	class FString                                 ReturnValue;                                       // 0x0018(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzBlueprintFunctionLibrary_CircleAsString) == 0x000008, "Wrong alignment on GzBlueprintFunctionLibrary_CircleAsString");
static_assert(sizeof(GzBlueprintFunctionLibrary_CircleAsString) == 0x000028, "Wrong size on GzBlueprintFunctionLibrary_CircleAsString");
static_assert(offsetof(GzBlueprintFunctionLibrary_CircleAsString, Circle) == 0x000000, "Member 'GzBlueprintFunctionLibrary_CircleAsString::Circle' has a wrong offset!");
static_assert(offsetof(GzBlueprintFunctionLibrary_CircleAsString, ReturnValue) == 0x000018, "Member 'GzBlueprintFunctionLibrary_CircleAsString::ReturnValue' has a wrong offset!");

// Function G01.GzBlueprintFunctionLibrary.ClearStencilValue
// 0x0008 (0x0008 - 0x0000)
struct GzBlueprintFunctionLibrary_ClearStencilValue final
{
public:
	const class AActor*                           Actor;                                             // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzBlueprintFunctionLibrary_ClearStencilValue) == 0x000008, "Wrong alignment on GzBlueprintFunctionLibrary_ClearStencilValue");
static_assert(sizeof(GzBlueprintFunctionLibrary_ClearStencilValue) == 0x000008, "Wrong size on GzBlueprintFunctionLibrary_ClearStencilValue");
static_assert(offsetof(GzBlueprintFunctionLibrary_ClearStencilValue, Actor) == 0x000000, "Member 'GzBlueprintFunctionLibrary_ClearStencilValue::Actor' has a wrong offset!");

// Function G01.GzBlueprintFunctionLibrary.ConvertWorldLocationToWidgetPositionWithScale
// 0x0048 (0x0048 - 0x0000)
struct GzBlueprintFunctionLibrary_ConvertWorldLocationToWidgetPositionWithScale final
{
public:
	struct FVector                                WorldLocation;                                     // 0x0000(0x0018)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                WorldOrigin;                                       // 0x0018(0x0018)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         GameplayArea;                                      // 0x0030(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ScaleFactor;                                       // 0x0034(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              WidgetPosition;                                    // 0x0038(0x0010)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzBlueprintFunctionLibrary_ConvertWorldLocationToWidgetPositionWithScale) == 0x000008, "Wrong alignment on GzBlueprintFunctionLibrary_ConvertWorldLocationToWidgetPositionWithScale");
static_assert(sizeof(GzBlueprintFunctionLibrary_ConvertWorldLocationToWidgetPositionWithScale) == 0x000048, "Wrong size on GzBlueprintFunctionLibrary_ConvertWorldLocationToWidgetPositionWithScale");
static_assert(offsetof(GzBlueprintFunctionLibrary_ConvertWorldLocationToWidgetPositionWithScale, WorldLocation) == 0x000000, "Member 'GzBlueprintFunctionLibrary_ConvertWorldLocationToWidgetPositionWithScale::WorldLocation' has a wrong offset!");
static_assert(offsetof(GzBlueprintFunctionLibrary_ConvertWorldLocationToWidgetPositionWithScale, WorldOrigin) == 0x000018, "Member 'GzBlueprintFunctionLibrary_ConvertWorldLocationToWidgetPositionWithScale::WorldOrigin' has a wrong offset!");
static_assert(offsetof(GzBlueprintFunctionLibrary_ConvertWorldLocationToWidgetPositionWithScale, GameplayArea) == 0x000030, "Member 'GzBlueprintFunctionLibrary_ConvertWorldLocationToWidgetPositionWithScale::GameplayArea' has a wrong offset!");
static_assert(offsetof(GzBlueprintFunctionLibrary_ConvertWorldLocationToWidgetPositionWithScale, ScaleFactor) == 0x000034, "Member 'GzBlueprintFunctionLibrary_ConvertWorldLocationToWidgetPositionWithScale::ScaleFactor' has a wrong offset!");
static_assert(offsetof(GzBlueprintFunctionLibrary_ConvertWorldLocationToWidgetPositionWithScale, WidgetPosition) == 0x000038, "Member 'GzBlueprintFunctionLibrary_ConvertWorldLocationToWidgetPositionWithScale::WidgetPosition' has a wrong offset!");

// Function G01.GzBlueprintFunctionLibrary.DoesSupportRayTracing
// 0x0001 (0x0001 - 0x0000)
struct GzBlueprintFunctionLibrary_DoesSupportRayTracing final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzBlueprintFunctionLibrary_DoesSupportRayTracing) == 0x000001, "Wrong alignment on GzBlueprintFunctionLibrary_DoesSupportRayTracing");
static_assert(sizeof(GzBlueprintFunctionLibrary_DoesSupportRayTracing) == 0x000001, "Wrong size on GzBlueprintFunctionLibrary_DoesSupportRayTracing");
static_assert(offsetof(GzBlueprintFunctionLibrary_DoesSupportRayTracing, ReturnValue) == 0x000000, "Member 'GzBlueprintFunctionLibrary_DoesSupportRayTracing::ReturnValue' has a wrong offset!");

// Function G01.GzBlueprintFunctionLibrary.FilterGameplayTagContainer
// 0x0068 (0x0068 - 0x0000)
struct GzBlueprintFunctionLibrary_FilterGameplayTagContainer final
{
public:
	struct FGameplayTagContainer                  Container;                                         // 0x0000(0x0020)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	struct FGameplayTagContainer                  OtherContainer;                                    // 0x0020(0x0020)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	bool                                          bFilterExact;                                      // 0x0040(0x0001)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_301C[0x7];                                     // 0x0041(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTagContainer                  ReturnValue;                                       // 0x0048(0x0020)(Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzBlueprintFunctionLibrary_FilterGameplayTagContainer) == 0x000008, "Wrong alignment on GzBlueprintFunctionLibrary_FilterGameplayTagContainer");
static_assert(sizeof(GzBlueprintFunctionLibrary_FilterGameplayTagContainer) == 0x000068, "Wrong size on GzBlueprintFunctionLibrary_FilterGameplayTagContainer");
static_assert(offsetof(GzBlueprintFunctionLibrary_FilterGameplayTagContainer, Container) == 0x000000, "Member 'GzBlueprintFunctionLibrary_FilterGameplayTagContainer::Container' has a wrong offset!");
static_assert(offsetof(GzBlueprintFunctionLibrary_FilterGameplayTagContainer, OtherContainer) == 0x000020, "Member 'GzBlueprintFunctionLibrary_FilterGameplayTagContainer::OtherContainer' has a wrong offset!");
static_assert(offsetof(GzBlueprintFunctionLibrary_FilterGameplayTagContainer, bFilterExact) == 0x000040, "Member 'GzBlueprintFunctionLibrary_FilterGameplayTagContainer::bFilterExact' has a wrong offset!");
static_assert(offsetof(GzBlueprintFunctionLibrary_FilterGameplayTagContainer, ReturnValue) == 0x000048, "Member 'GzBlueprintFunctionLibrary_FilterGameplayTagContainer::ReturnValue' has a wrong offset!");

// Function G01.GzBlueprintFunctionLibrary.FindClosestBone
// 0x0048 (0x0048 - 0x0000)
struct GzBlueprintFunctionLibrary_FindClosestBone final
{
public:
	class AActor*                                 ActorPtr;                                          // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                ImpactPoint;                                       // 0x0008(0x0018)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGzAttachmentPoint                     ReturnValue;                                       // 0x0020(0x0028)(Parm, OutParm, ReturnParm, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzBlueprintFunctionLibrary_FindClosestBone) == 0x000008, "Wrong alignment on GzBlueprintFunctionLibrary_FindClosestBone");
static_assert(sizeof(GzBlueprintFunctionLibrary_FindClosestBone) == 0x000048, "Wrong size on GzBlueprintFunctionLibrary_FindClosestBone");
static_assert(offsetof(GzBlueprintFunctionLibrary_FindClosestBone, ActorPtr) == 0x000000, "Member 'GzBlueprintFunctionLibrary_FindClosestBone::ActorPtr' has a wrong offset!");
static_assert(offsetof(GzBlueprintFunctionLibrary_FindClosestBone, ImpactPoint) == 0x000008, "Member 'GzBlueprintFunctionLibrary_FindClosestBone::ImpactPoint' has a wrong offset!");
static_assert(offsetof(GzBlueprintFunctionLibrary_FindClosestBone, ReturnValue) == 0x000020, "Member 'GzBlueprintFunctionLibrary_FindClosestBone::ReturnValue' has a wrong offset!");

// Function G01.GzBlueprintFunctionLibrary.GetAiInfo
// 0x0018 (0x0018 - 0x0000)
struct GzBlueprintFunctionLibrary_GetAiInfo final
{
public:
	const class UObject*                          WorldContextObject;                                // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         AiId;                                              // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_301D[0x4];                                     // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	const class AGzAIInfo*                        ReturnValue;                                       // 0x0010(0x0008)(ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzBlueprintFunctionLibrary_GetAiInfo) == 0x000008, "Wrong alignment on GzBlueprintFunctionLibrary_GetAiInfo");
static_assert(sizeof(GzBlueprintFunctionLibrary_GetAiInfo) == 0x000018, "Wrong size on GzBlueprintFunctionLibrary_GetAiInfo");
static_assert(offsetof(GzBlueprintFunctionLibrary_GetAiInfo, WorldContextObject) == 0x000000, "Member 'GzBlueprintFunctionLibrary_GetAiInfo::WorldContextObject' has a wrong offset!");
static_assert(offsetof(GzBlueprintFunctionLibrary_GetAiInfo, AiId) == 0x000008, "Member 'GzBlueprintFunctionLibrary_GetAiInfo::AiId' has a wrong offset!");
static_assert(offsetof(GzBlueprintFunctionLibrary_GetAiInfo, ReturnValue) == 0x000010, "Member 'GzBlueprintFunctionLibrary_GetAiInfo::ReturnValue' has a wrong offset!");

// Function G01.GzBlueprintFunctionLibrary.GetAiManager
// 0x0010 (0x0010 - 0x0000)
struct GzBlueprintFunctionLibrary_GetAiManager final
{
public:
	const class UObject*                          WorldContextObject;                                // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AGzAIManager*                           ReturnValue;                                       // 0x0008(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzBlueprintFunctionLibrary_GetAiManager) == 0x000008, "Wrong alignment on GzBlueprintFunctionLibrary_GetAiManager");
static_assert(sizeof(GzBlueprintFunctionLibrary_GetAiManager) == 0x000010, "Wrong size on GzBlueprintFunctionLibrary_GetAiManager");
static_assert(offsetof(GzBlueprintFunctionLibrary_GetAiManager, WorldContextObject) == 0x000000, "Member 'GzBlueprintFunctionLibrary_GetAiManager::WorldContextObject' has a wrong offset!");
static_assert(offsetof(GzBlueprintFunctionLibrary_GetAiManager, ReturnValue) == 0x000008, "Member 'GzBlueprintFunctionLibrary_GetAiManager::ReturnValue' has a wrong offset!");

// Function G01.GzBlueprintFunctionLibrary.GetChangelistBuiltFrom
// 0x0008 (0x0008 - 0x0000)
struct GzBlueprintFunctionLibrary_GetChangelistBuiltFrom final
{
public:
	int64                                         ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzBlueprintFunctionLibrary_GetChangelistBuiltFrom) == 0x000008, "Wrong alignment on GzBlueprintFunctionLibrary_GetChangelistBuiltFrom");
static_assert(sizeof(GzBlueprintFunctionLibrary_GetChangelistBuiltFrom) == 0x000008, "Wrong size on GzBlueprintFunctionLibrary_GetChangelistBuiltFrom");
static_assert(offsetof(GzBlueprintFunctionLibrary_GetChangelistBuiltFrom, ReturnValue) == 0x000000, "Member 'GzBlueprintFunctionLibrary_GetChangelistBuiltFrom::ReturnValue' has a wrong offset!");

// Function G01.GzBlueprintFunctionLibrary.GetConsoleAccountId
// 0x0010 (0x0010 - 0x0000)
struct GzBlueprintFunctionLibrary_GetConsoleAccountId final
{
public:
	class FString                                 ReturnValue;                                       // 0x0000(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzBlueprintFunctionLibrary_GetConsoleAccountId) == 0x000008, "Wrong alignment on GzBlueprintFunctionLibrary_GetConsoleAccountId");
static_assert(sizeof(GzBlueprintFunctionLibrary_GetConsoleAccountId) == 0x000010, "Wrong size on GzBlueprintFunctionLibrary_GetConsoleAccountId");
static_assert(offsetof(GzBlueprintFunctionLibrary_GetConsoleAccountId, ReturnValue) == 0x000000, "Member 'GzBlueprintFunctionLibrary_GetConsoleAccountId::ReturnValue' has a wrong offset!");

// Function G01.GzBlueprintFunctionLibrary.GetEnumMaxValue
// 0x0010 (0x0010 - 0x0000)
struct GzBlueprintFunctionLibrary_GetEnumMaxValue final
{
public:
	const class UEnum*                            Enum;                                              // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int64                                         ReturnValue;                                       // 0x0008(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzBlueprintFunctionLibrary_GetEnumMaxValue) == 0x000008, "Wrong alignment on GzBlueprintFunctionLibrary_GetEnumMaxValue");
static_assert(sizeof(GzBlueprintFunctionLibrary_GetEnumMaxValue) == 0x000010, "Wrong size on GzBlueprintFunctionLibrary_GetEnumMaxValue");
static_assert(offsetof(GzBlueprintFunctionLibrary_GetEnumMaxValue, Enum) == 0x000000, "Member 'GzBlueprintFunctionLibrary_GetEnumMaxValue::Enum' has a wrong offset!");
static_assert(offsetof(GzBlueprintFunctionLibrary_GetEnumMaxValue, ReturnValue) == 0x000008, "Member 'GzBlueprintFunctionLibrary_GetEnumMaxValue::ReturnValue' has a wrong offset!");

// Function G01.GzBlueprintFunctionLibrary.GetEnumValueByNameString
// 0x0020 (0x0020 - 0x0000)
struct GzBlueprintFunctionLibrary_GetEnumValueByNameString final
{
public:
	const class UEnum*                            Enum;                                              // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Param_Name;                                        // 0x0008(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int64                                         ReturnValue;                                       // 0x0018(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzBlueprintFunctionLibrary_GetEnumValueByNameString) == 0x000008, "Wrong alignment on GzBlueprintFunctionLibrary_GetEnumValueByNameString");
static_assert(sizeof(GzBlueprintFunctionLibrary_GetEnumValueByNameString) == 0x000020, "Wrong size on GzBlueprintFunctionLibrary_GetEnumValueByNameString");
static_assert(offsetof(GzBlueprintFunctionLibrary_GetEnumValueByNameString, Enum) == 0x000000, "Member 'GzBlueprintFunctionLibrary_GetEnumValueByNameString::Enum' has a wrong offset!");
static_assert(offsetof(GzBlueprintFunctionLibrary_GetEnumValueByNameString, Param_Name) == 0x000008, "Member 'GzBlueprintFunctionLibrary_GetEnumValueByNameString::Param_Name' has a wrong offset!");
static_assert(offsetof(GzBlueprintFunctionLibrary_GetEnumValueByNameString, ReturnValue) == 0x000018, "Member 'GzBlueprintFunctionLibrary_GetEnumValueByNameString::ReturnValue' has a wrong offset!");

// Function G01.GzBlueprintFunctionLibrary.GetFirstLocalPlayerController
// 0x0010 (0x0010 - 0x0000)
struct GzBlueprintFunctionLibrary_GetFirstLocalPlayerController final
{
public:
	const class UObject*                          WorldContextObject;                                // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AGzPlayerController*                    ReturnValue;                                       // 0x0008(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzBlueprintFunctionLibrary_GetFirstLocalPlayerController) == 0x000008, "Wrong alignment on GzBlueprintFunctionLibrary_GetFirstLocalPlayerController");
static_assert(sizeof(GzBlueprintFunctionLibrary_GetFirstLocalPlayerController) == 0x000010, "Wrong size on GzBlueprintFunctionLibrary_GetFirstLocalPlayerController");
static_assert(offsetof(GzBlueprintFunctionLibrary_GetFirstLocalPlayerController, WorldContextObject) == 0x000000, "Member 'GzBlueprintFunctionLibrary_GetFirstLocalPlayerController::WorldContextObject' has a wrong offset!");
static_assert(offsetof(GzBlueprintFunctionLibrary_GetFirstLocalPlayerController, ReturnValue) == 0x000008, "Member 'GzBlueprintFunctionLibrary_GetFirstLocalPlayerController::ReturnValue' has a wrong offset!");

// Function G01.GzBlueprintFunctionLibrary.GetGameUserSettings
// 0x0008 (0x0008 - 0x0000)
struct GzBlueprintFunctionLibrary_GetGameUserSettings final
{
public:
	class UGzGameUserSettings*                    ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzBlueprintFunctionLibrary_GetGameUserSettings) == 0x000008, "Wrong alignment on GzBlueprintFunctionLibrary_GetGameUserSettings");
static_assert(sizeof(GzBlueprintFunctionLibrary_GetGameUserSettings) == 0x000008, "Wrong size on GzBlueprintFunctionLibrary_GetGameUserSettings");
static_assert(offsetof(GzBlueprintFunctionLibrary_GetGameUserSettings, ReturnValue) == 0x000000, "Member 'GzBlueprintFunctionLibrary_GetGameUserSettings::ReturnValue' has a wrong offset!");

// Function G01.GzBlueprintFunctionLibrary.GetLimbUIActivationSubsystem
// 0x0010 (0x0010 - 0x0000)
struct GzBlueprintFunctionLibrary_GetLimbUIActivationSubsystem final
{
public:
	const class UObject*                          WorldContextObject;                                // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UGzLimbUIActivationSubsystem*           ReturnValue;                                       // 0x0008(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzBlueprintFunctionLibrary_GetLimbUIActivationSubsystem) == 0x000008, "Wrong alignment on GzBlueprintFunctionLibrary_GetLimbUIActivationSubsystem");
static_assert(sizeof(GzBlueprintFunctionLibrary_GetLimbUIActivationSubsystem) == 0x000010, "Wrong size on GzBlueprintFunctionLibrary_GetLimbUIActivationSubsystem");
static_assert(offsetof(GzBlueprintFunctionLibrary_GetLimbUIActivationSubsystem, WorldContextObject) == 0x000000, "Member 'GzBlueprintFunctionLibrary_GetLimbUIActivationSubsystem::WorldContextObject' has a wrong offset!");
static_assert(offsetof(GzBlueprintFunctionLibrary_GetLimbUIActivationSubsystem, ReturnValue) == 0x000008, "Member 'GzBlueprintFunctionLibrary_GetLimbUIActivationSubsystem::ReturnValue' has a wrong offset!");

// Function G01.GzBlueprintFunctionLibrary.GetNameStringByEnumValue
// 0x0020 (0x0020 - 0x0000)
struct GzBlueprintFunctionLibrary_GetNameStringByEnumValue final
{
public:
	const class UEnum*                            Enum;                                              // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int64                                         Value;                                             // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 ReturnValue;                                       // 0x0010(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzBlueprintFunctionLibrary_GetNameStringByEnumValue) == 0x000008, "Wrong alignment on GzBlueprintFunctionLibrary_GetNameStringByEnumValue");
static_assert(sizeof(GzBlueprintFunctionLibrary_GetNameStringByEnumValue) == 0x000020, "Wrong size on GzBlueprintFunctionLibrary_GetNameStringByEnumValue");
static_assert(offsetof(GzBlueprintFunctionLibrary_GetNameStringByEnumValue, Enum) == 0x000000, "Member 'GzBlueprintFunctionLibrary_GetNameStringByEnumValue::Enum' has a wrong offset!");
static_assert(offsetof(GzBlueprintFunctionLibrary_GetNameStringByEnumValue, Value) == 0x000008, "Member 'GzBlueprintFunctionLibrary_GetNameStringByEnumValue::Value' has a wrong offset!");
static_assert(offsetof(GzBlueprintFunctionLibrary_GetNameStringByEnumValue, ReturnValue) == 0x000010, "Member 'GzBlueprintFunctionLibrary_GetNameStringByEnumValue::ReturnValue' has a wrong offset!");

// Function G01.GzBlueprintFunctionLibrary.GetNetworkLag
// 0x0010 (0x0010 - 0x0000)
struct GzBlueprintFunctionLibrary_GetNetworkLag final
{
public:
	class UObject*                                WorldContextObject;                                // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ReturnValue;                                       // 0x0008(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_301E[0x4];                                     // 0x000C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GzBlueprintFunctionLibrary_GetNetworkLag) == 0x000008, "Wrong alignment on GzBlueprintFunctionLibrary_GetNetworkLag");
static_assert(sizeof(GzBlueprintFunctionLibrary_GetNetworkLag) == 0x000010, "Wrong size on GzBlueprintFunctionLibrary_GetNetworkLag");
static_assert(offsetof(GzBlueprintFunctionLibrary_GetNetworkLag, WorldContextObject) == 0x000000, "Member 'GzBlueprintFunctionLibrary_GetNetworkLag::WorldContextObject' has a wrong offset!");
static_assert(offsetof(GzBlueprintFunctionLibrary_GetNetworkLag, ReturnValue) == 0x000008, "Member 'GzBlueprintFunctionLibrary_GetNetworkLag::ReturnValue' has a wrong offset!");

// Function G01.GzBlueprintFunctionLibrary.GetPawnByCharacterId
// 0x0018 (0x0018 - 0x0000)
struct GzBlueprintFunctionLibrary_GetPawnByCharacterId final
{
public:
	const class UObject*                          WorldContextObject;                                // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 CharacterIdInterfaceActor;                         // 0x0008(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class APawn*                                  ReturnValue;                                       // 0x0010(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzBlueprintFunctionLibrary_GetPawnByCharacterId) == 0x000008, "Wrong alignment on GzBlueprintFunctionLibrary_GetPawnByCharacterId");
static_assert(sizeof(GzBlueprintFunctionLibrary_GetPawnByCharacterId) == 0x000018, "Wrong size on GzBlueprintFunctionLibrary_GetPawnByCharacterId");
static_assert(offsetof(GzBlueprintFunctionLibrary_GetPawnByCharacterId, WorldContextObject) == 0x000000, "Member 'GzBlueprintFunctionLibrary_GetPawnByCharacterId::WorldContextObject' has a wrong offset!");
static_assert(offsetof(GzBlueprintFunctionLibrary_GetPawnByCharacterId, CharacterIdInterfaceActor) == 0x000008, "Member 'GzBlueprintFunctionLibrary_GetPawnByCharacterId::CharacterIdInterfaceActor' has a wrong offset!");
static_assert(offsetof(GzBlueprintFunctionLibrary_GetPawnByCharacterId, ReturnValue) == 0x000010, "Member 'GzBlueprintFunctionLibrary_GetPawnByCharacterId::ReturnValue' has a wrong offset!");

// Function G01.GzBlueprintFunctionLibrary.GetPawnById
// 0x0018 (0x0018 - 0x0000)
struct GzBlueprintFunctionLibrary_GetPawnById final
{
public:
	const class UObject*                          WorldContextObject;                                // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGzAdvancedIdType                      ID;                                                // 0x0008(0x0008)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class APawn*                                  ReturnValue;                                       // 0x0010(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzBlueprintFunctionLibrary_GetPawnById) == 0x000008, "Wrong alignment on GzBlueprintFunctionLibrary_GetPawnById");
static_assert(sizeof(GzBlueprintFunctionLibrary_GetPawnById) == 0x000018, "Wrong size on GzBlueprintFunctionLibrary_GetPawnById");
static_assert(offsetof(GzBlueprintFunctionLibrary_GetPawnById, WorldContextObject) == 0x000000, "Member 'GzBlueprintFunctionLibrary_GetPawnById::WorldContextObject' has a wrong offset!");
static_assert(offsetof(GzBlueprintFunctionLibrary_GetPawnById, ID) == 0x000008, "Member 'GzBlueprintFunctionLibrary_GetPawnById::ID' has a wrong offset!");
static_assert(offsetof(GzBlueprintFunctionLibrary_GetPawnById, ReturnValue) == 0x000010, "Member 'GzBlueprintFunctionLibrary_GetPawnById::ReturnValue' has a wrong offset!");

// Function G01.GzBlueprintFunctionLibrary.GetPersistentPlayerState
// 0x0010 (0x0010 - 0x0000)
struct GzBlueprintFunctionLibrary_GetPersistentPlayerState final
{
public:
	const class APawn*                            Pawn;                                              // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AGzPlayerState*                         ReturnValue;                                       // 0x0008(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzBlueprintFunctionLibrary_GetPersistentPlayerState) == 0x000008, "Wrong alignment on GzBlueprintFunctionLibrary_GetPersistentPlayerState");
static_assert(sizeof(GzBlueprintFunctionLibrary_GetPersistentPlayerState) == 0x000010, "Wrong size on GzBlueprintFunctionLibrary_GetPersistentPlayerState");
static_assert(offsetof(GzBlueprintFunctionLibrary_GetPersistentPlayerState, Pawn) == 0x000000, "Member 'GzBlueprintFunctionLibrary_GetPersistentPlayerState::Pawn' has a wrong offset!");
static_assert(offsetof(GzBlueprintFunctionLibrary_GetPersistentPlayerState, ReturnValue) == 0x000008, "Member 'GzBlueprintFunctionLibrary_GetPersistentPlayerState::ReturnValue' has a wrong offset!");

// Function G01.GzBlueprintFunctionLibrary.GetPlatformMasks
// 0x0001 (0x0001 - 0x0000)
struct GzBlueprintFunctionLibrary_GetPlatformMasks final
{
public:
	EGzPlatformMasks                              ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzBlueprintFunctionLibrary_GetPlatformMasks) == 0x000001, "Wrong alignment on GzBlueprintFunctionLibrary_GetPlatformMasks");
static_assert(sizeof(GzBlueprintFunctionLibrary_GetPlatformMasks) == 0x000001, "Wrong size on GzBlueprintFunctionLibrary_GetPlatformMasks");
static_assert(offsetof(GzBlueprintFunctionLibrary_GetPlatformMasks, ReturnValue) == 0x000000, "Member 'GzBlueprintFunctionLibrary_GetPlatformMasks::ReturnValue' has a wrong offset!");

// Function G01.GzBlueprintFunctionLibrary.GetPlayerController
// 0x0018 (0x0018 - 0x0000)
struct GzBlueprintFunctionLibrary_GetPlayerController final
{
public:
	const class UObject*                          WorldContextObject;                                // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         PlayerId;                                          // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_301F[0x4];                                     // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class APlayerController*                      ReturnValue;                                       // 0x0010(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzBlueprintFunctionLibrary_GetPlayerController) == 0x000008, "Wrong alignment on GzBlueprintFunctionLibrary_GetPlayerController");
static_assert(sizeof(GzBlueprintFunctionLibrary_GetPlayerController) == 0x000018, "Wrong size on GzBlueprintFunctionLibrary_GetPlayerController");
static_assert(offsetof(GzBlueprintFunctionLibrary_GetPlayerController, WorldContextObject) == 0x000000, "Member 'GzBlueprintFunctionLibrary_GetPlayerController::WorldContextObject' has a wrong offset!");
static_assert(offsetof(GzBlueprintFunctionLibrary_GetPlayerController, PlayerId) == 0x000008, "Member 'GzBlueprintFunctionLibrary_GetPlayerController::PlayerId' has a wrong offset!");
static_assert(offsetof(GzBlueprintFunctionLibrary_GetPlayerController, ReturnValue) == 0x000010, "Member 'GzBlueprintFunctionLibrary_GetPlayerController::ReturnValue' has a wrong offset!");

// Function G01.GzBlueprintFunctionLibrary.GetPlayerPostProcessControllerComponent
// 0x0010 (0x0010 - 0x0000)
struct GzBlueprintFunctionLibrary_GetPlayerPostProcessControllerComponent final
{
public:
	const class UObject*                          WorldContextObject;                                // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UGzPostProcessControllerComponent*      ReturnValue;                                       // 0x0008(0x0008)(ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzBlueprintFunctionLibrary_GetPlayerPostProcessControllerComponent) == 0x000008, "Wrong alignment on GzBlueprintFunctionLibrary_GetPlayerPostProcessControllerComponent");
static_assert(sizeof(GzBlueprintFunctionLibrary_GetPlayerPostProcessControllerComponent) == 0x000010, "Wrong size on GzBlueprintFunctionLibrary_GetPlayerPostProcessControllerComponent");
static_assert(offsetof(GzBlueprintFunctionLibrary_GetPlayerPostProcessControllerComponent, WorldContextObject) == 0x000000, "Member 'GzBlueprintFunctionLibrary_GetPlayerPostProcessControllerComponent::WorldContextObject' has a wrong offset!");
static_assert(offsetof(GzBlueprintFunctionLibrary_GetPlayerPostProcessControllerComponent, ReturnValue) == 0x000008, "Member 'GzBlueprintFunctionLibrary_GetPlayerPostProcessControllerComponent::ReturnValue' has a wrong offset!");

// Function G01.GzBlueprintFunctionLibrary.GetPlayerState
// 0x0018 (0x0018 - 0x0000)
struct GzBlueprintFunctionLibrary_GetPlayerState final
{
public:
	const class UObject*                          WorldContextObject;                                // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         PlayerId;                                          // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3020[0x4];                                     // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class AGzPlayerState*                         ReturnValue;                                       // 0x0010(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzBlueprintFunctionLibrary_GetPlayerState) == 0x000008, "Wrong alignment on GzBlueprintFunctionLibrary_GetPlayerState");
static_assert(sizeof(GzBlueprintFunctionLibrary_GetPlayerState) == 0x000018, "Wrong size on GzBlueprintFunctionLibrary_GetPlayerState");
static_assert(offsetof(GzBlueprintFunctionLibrary_GetPlayerState, WorldContextObject) == 0x000000, "Member 'GzBlueprintFunctionLibrary_GetPlayerState::WorldContextObject' has a wrong offset!");
static_assert(offsetof(GzBlueprintFunctionLibrary_GetPlayerState, PlayerId) == 0x000008, "Member 'GzBlueprintFunctionLibrary_GetPlayerState::PlayerId' has a wrong offset!");
static_assert(offsetof(GzBlueprintFunctionLibrary_GetPlayerState, ReturnValue) == 0x000010, "Member 'GzBlueprintFunctionLibrary_GetPlayerState::ReturnValue' has a wrong offset!");

// Function G01.GzBlueprintFunctionLibrary.GetRandomDeviationFloat
// 0x000C (0x000C - 0x0000)
struct GzBlueprintFunctionLibrary_GetRandomDeviationFloat final
{
public:
	float                                         Value;                                             // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Deviation;                                         // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ReturnValue;                                       // 0x0008(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzBlueprintFunctionLibrary_GetRandomDeviationFloat) == 0x000004, "Wrong alignment on GzBlueprintFunctionLibrary_GetRandomDeviationFloat");
static_assert(sizeof(GzBlueprintFunctionLibrary_GetRandomDeviationFloat) == 0x00000C, "Wrong size on GzBlueprintFunctionLibrary_GetRandomDeviationFloat");
static_assert(offsetof(GzBlueprintFunctionLibrary_GetRandomDeviationFloat, Value) == 0x000000, "Member 'GzBlueprintFunctionLibrary_GetRandomDeviationFloat::Value' has a wrong offset!");
static_assert(offsetof(GzBlueprintFunctionLibrary_GetRandomDeviationFloat, Deviation) == 0x000004, "Member 'GzBlueprintFunctionLibrary_GetRandomDeviationFloat::Deviation' has a wrong offset!");
static_assert(offsetof(GzBlueprintFunctionLibrary_GetRandomDeviationFloat, ReturnValue) == 0x000008, "Member 'GzBlueprintFunctionLibrary_GetRandomDeviationFloat::ReturnValue' has a wrong offset!");

// Function G01.GzBlueprintFunctionLibrary.GetSignedAngle
// 0x0028 (0x0028 - 0x0000)
struct GzBlueprintFunctionLibrary_GetSignedAngle final
{
public:
	struct FVector2D                              A;                                                 // 0x0000(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              B;                                                 // 0x0010(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ReturnValue;                                       // 0x0020(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3021[0x4];                                     // 0x0024(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GzBlueprintFunctionLibrary_GetSignedAngle) == 0x000008, "Wrong alignment on GzBlueprintFunctionLibrary_GetSignedAngle");
static_assert(sizeof(GzBlueprintFunctionLibrary_GetSignedAngle) == 0x000028, "Wrong size on GzBlueprintFunctionLibrary_GetSignedAngle");
static_assert(offsetof(GzBlueprintFunctionLibrary_GetSignedAngle, A) == 0x000000, "Member 'GzBlueprintFunctionLibrary_GetSignedAngle::A' has a wrong offset!");
static_assert(offsetof(GzBlueprintFunctionLibrary_GetSignedAngle, B) == 0x000010, "Member 'GzBlueprintFunctionLibrary_GetSignedAngle::B' has a wrong offset!");
static_assert(offsetof(GzBlueprintFunctionLibrary_GetSignedAngle, ReturnValue) == 0x000020, "Member 'GzBlueprintFunctionLibrary_GetSignedAngle::ReturnValue' has a wrong offset!");

// Function G01.GzBlueprintFunctionLibrary.GetStencilValue
// 0x0010 (0x0010 - 0x0000)
struct GzBlueprintFunctionLibrary_GetStencilValue final
{
public:
	class UPrimitiveComponent*                    Component;                                         // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EDepthStencilValue                            ReturnValue;                                       // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3022[0x7];                                     // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GzBlueprintFunctionLibrary_GetStencilValue) == 0x000008, "Wrong alignment on GzBlueprintFunctionLibrary_GetStencilValue");
static_assert(sizeof(GzBlueprintFunctionLibrary_GetStencilValue) == 0x000010, "Wrong size on GzBlueprintFunctionLibrary_GetStencilValue");
static_assert(offsetof(GzBlueprintFunctionLibrary_GetStencilValue, Component) == 0x000000, "Member 'GzBlueprintFunctionLibrary_GetStencilValue::Component' has a wrong offset!");
static_assert(offsetof(GzBlueprintFunctionLibrary_GetStencilValue, ReturnValue) == 0x000008, "Member 'GzBlueprintFunctionLibrary_GetStencilValue::ReturnValue' has a wrong offset!");

// Function G01.GzBlueprintFunctionLibrary.GetTimeMinutesSeconds
// 0x000C (0x000C - 0x0000)
struct GzBlueprintFunctionLibrary_GetTimeMinutesSeconds final
{
public:
	float                                         InSeconds;                                         // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         OutMinutes;                                        // 0x0004(0x0004)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         OutSeconds;                                        // 0x0008(0x0004)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzBlueprintFunctionLibrary_GetTimeMinutesSeconds) == 0x000004, "Wrong alignment on GzBlueprintFunctionLibrary_GetTimeMinutesSeconds");
static_assert(sizeof(GzBlueprintFunctionLibrary_GetTimeMinutesSeconds) == 0x00000C, "Wrong size on GzBlueprintFunctionLibrary_GetTimeMinutesSeconds");
static_assert(offsetof(GzBlueprintFunctionLibrary_GetTimeMinutesSeconds, InSeconds) == 0x000000, "Member 'GzBlueprintFunctionLibrary_GetTimeMinutesSeconds::InSeconds' has a wrong offset!");
static_assert(offsetof(GzBlueprintFunctionLibrary_GetTimeMinutesSeconds, OutMinutes) == 0x000004, "Member 'GzBlueprintFunctionLibrary_GetTimeMinutesSeconds::OutMinutes' has a wrong offset!");
static_assert(offsetof(GzBlueprintFunctionLibrary_GetTimeMinutesSeconds, OutSeconds) == 0x000008, "Member 'GzBlueprintFunctionLibrary_GetTimeMinutesSeconds::OutSeconds' has a wrong offset!");

// Function G01.GzBlueprintFunctionLibrary.GetUIDeveloperSettings
// 0x0008 (0x0008 - 0x0000)
struct GzBlueprintFunctionLibrary_GetUIDeveloperSettings final
{
public:
	const class UGzUISettings*                    ReturnValue;                                       // 0x0000(0x0008)(ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzBlueprintFunctionLibrary_GetUIDeveloperSettings) == 0x000008, "Wrong alignment on GzBlueprintFunctionLibrary_GetUIDeveloperSettings");
static_assert(sizeof(GzBlueprintFunctionLibrary_GetUIDeveloperSettings) == 0x000008, "Wrong size on GzBlueprintFunctionLibrary_GetUIDeveloperSettings");
static_assert(offsetof(GzBlueprintFunctionLibrary_GetUIDeveloperSettings, ReturnValue) == 0x000000, "Member 'GzBlueprintFunctionLibrary_GetUIDeveloperSettings::ReturnValue' has a wrong offset!");

// Function G01.GzBlueprintFunctionLibrary.GetWorldSettings
// 0x0010 (0x0010 - 0x0000)
struct GzBlueprintFunctionLibrary_GetWorldSettings final
{
public:
	const class UObject*                          WorldContextObject;                                // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AGzWorldSettings*                       ReturnValue;                                       // 0x0008(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzBlueprintFunctionLibrary_GetWorldSettings) == 0x000008, "Wrong alignment on GzBlueprintFunctionLibrary_GetWorldSettings");
static_assert(sizeof(GzBlueprintFunctionLibrary_GetWorldSettings) == 0x000010, "Wrong size on GzBlueprintFunctionLibrary_GetWorldSettings");
static_assert(offsetof(GzBlueprintFunctionLibrary_GetWorldSettings, WorldContextObject) == 0x000000, "Member 'GzBlueprintFunctionLibrary_GetWorldSettings::WorldContextObject' has a wrong offset!");
static_assert(offsetof(GzBlueprintFunctionLibrary_GetWorldSettings, ReturnValue) == 0x000008, "Member 'GzBlueprintFunctionLibrary_GetWorldSettings::ReturnValue' has a wrong offset!");

// Function G01.GzBlueprintFunctionLibrary.IsAlive
// 0x0010 (0x0010 - 0x0000)
struct GzBlueprintFunctionLibrary_IsAlive final
{
public:
	const class AActor*                           TargetActor;                                       // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3023[0x7];                                     // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GzBlueprintFunctionLibrary_IsAlive) == 0x000008, "Wrong alignment on GzBlueprintFunctionLibrary_IsAlive");
static_assert(sizeof(GzBlueprintFunctionLibrary_IsAlive) == 0x000010, "Wrong size on GzBlueprintFunctionLibrary_IsAlive");
static_assert(offsetof(GzBlueprintFunctionLibrary_IsAlive, TargetActor) == 0x000000, "Member 'GzBlueprintFunctionLibrary_IsAlive::TargetActor' has a wrong offset!");
static_assert(offsetof(GzBlueprintFunctionLibrary_IsAlive, ReturnValue) == 0x000008, "Member 'GzBlueprintFunctionLibrary_IsAlive::ReturnValue' has a wrong offset!");

// Function G01.GzBlueprintFunctionLibrary.IsConsole
// 0x0001 (0x0001 - 0x0000)
struct GzBlueprintFunctionLibrary_IsConsole final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzBlueprintFunctionLibrary_IsConsole) == 0x000001, "Wrong alignment on GzBlueprintFunctionLibrary_IsConsole");
static_assert(sizeof(GzBlueprintFunctionLibrary_IsConsole) == 0x000001, "Wrong size on GzBlueprintFunctionLibrary_IsConsole");
static_assert(offsetof(GzBlueprintFunctionLibrary_IsConsole, ReturnValue) == 0x000000, "Member 'GzBlueprintFunctionLibrary_IsConsole::ReturnValue' has a wrong offset!");

// Function G01.GzBlueprintFunctionLibrary.IsCoverValid
// 0x0030 (0x0030 - 0x0000)
struct GzBlueprintFunctionLibrary_IsCoverValid final
{
public:
	class AActor*                                 ObserverActor;                                     // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 TargetActor;                                       // 0x0008(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                CoverLocation;                                     // 0x0010(0x0018)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0028(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3024[0x7];                                     // 0x0029(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GzBlueprintFunctionLibrary_IsCoverValid) == 0x000008, "Wrong alignment on GzBlueprintFunctionLibrary_IsCoverValid");
static_assert(sizeof(GzBlueprintFunctionLibrary_IsCoverValid) == 0x000030, "Wrong size on GzBlueprintFunctionLibrary_IsCoverValid");
static_assert(offsetof(GzBlueprintFunctionLibrary_IsCoverValid, ObserverActor) == 0x000000, "Member 'GzBlueprintFunctionLibrary_IsCoverValid::ObserverActor' has a wrong offset!");
static_assert(offsetof(GzBlueprintFunctionLibrary_IsCoverValid, TargetActor) == 0x000008, "Member 'GzBlueprintFunctionLibrary_IsCoverValid::TargetActor' has a wrong offset!");
static_assert(offsetof(GzBlueprintFunctionLibrary_IsCoverValid, CoverLocation) == 0x000010, "Member 'GzBlueprintFunctionLibrary_IsCoverValid::CoverLocation' has a wrong offset!");
static_assert(offsetof(GzBlueprintFunctionLibrary_IsCoverValid, ReturnValue) == 0x000028, "Member 'GzBlueprintFunctionLibrary_IsCoverValid::ReturnValue' has a wrong offset!");

// Function G01.GzBlueprintFunctionLibrary.IsLocalViewTarget
// 0x0010 (0x0010 - 0x0000)
struct GzBlueprintFunctionLibrary_IsLocalViewTarget final
{
public:
	const class APawn*                            InPawn;                                            // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3025[0x7];                                     // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GzBlueprintFunctionLibrary_IsLocalViewTarget) == 0x000008, "Wrong alignment on GzBlueprintFunctionLibrary_IsLocalViewTarget");
static_assert(sizeof(GzBlueprintFunctionLibrary_IsLocalViewTarget) == 0x000010, "Wrong size on GzBlueprintFunctionLibrary_IsLocalViewTarget");
static_assert(offsetof(GzBlueprintFunctionLibrary_IsLocalViewTarget, InPawn) == 0x000000, "Member 'GzBlueprintFunctionLibrary_IsLocalViewTarget::InPawn' has a wrong offset!");
static_assert(offsetof(GzBlueprintFunctionLibrary_IsLocalViewTarget, ReturnValue) == 0x000008, "Member 'GzBlueprintFunctionLibrary_IsLocalViewTarget::ReturnValue' has a wrong offset!");

// Function G01.GzBlueprintFunctionLibrary.IsPeerToPeer
// 0x0010 (0x0010 - 0x0000)
struct GzBlueprintFunctionLibrary_IsPeerToPeer final
{
public:
	class UObject*                                WorldContextObject;                                // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3026[0x7];                                     // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GzBlueprintFunctionLibrary_IsPeerToPeer) == 0x000008, "Wrong alignment on GzBlueprintFunctionLibrary_IsPeerToPeer");
static_assert(sizeof(GzBlueprintFunctionLibrary_IsPeerToPeer) == 0x000010, "Wrong size on GzBlueprintFunctionLibrary_IsPeerToPeer");
static_assert(offsetof(GzBlueprintFunctionLibrary_IsPeerToPeer, WorldContextObject) == 0x000000, "Member 'GzBlueprintFunctionLibrary_IsPeerToPeer::WorldContextObject' has a wrong offset!");
static_assert(offsetof(GzBlueprintFunctionLibrary_IsPeerToPeer, ReturnValue) == 0x000008, "Member 'GzBlueprintFunctionLibrary_IsPeerToPeer::ReturnValue' has a wrong offset!");

// Function G01.GzBlueprintFunctionLibrary.IsPointInCircle
// 0x0030 (0x0030 - 0x0000)
struct GzBlueprintFunctionLibrary_IsPointInCircle final
{
public:
	struct FVector2D                              Point;                                             // 0x0000(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGzCircle2D                            Circle;                                            // 0x0010(0x0018)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0028(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3027[0x7];                                     // 0x0029(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GzBlueprintFunctionLibrary_IsPointInCircle) == 0x000008, "Wrong alignment on GzBlueprintFunctionLibrary_IsPointInCircle");
static_assert(sizeof(GzBlueprintFunctionLibrary_IsPointInCircle) == 0x000030, "Wrong size on GzBlueprintFunctionLibrary_IsPointInCircle");
static_assert(offsetof(GzBlueprintFunctionLibrary_IsPointInCircle, Point) == 0x000000, "Member 'GzBlueprintFunctionLibrary_IsPointInCircle::Point' has a wrong offset!");
static_assert(offsetof(GzBlueprintFunctionLibrary_IsPointInCircle, Circle) == 0x000010, "Member 'GzBlueprintFunctionLibrary_IsPointInCircle::Circle' has a wrong offset!");
static_assert(offsetof(GzBlueprintFunctionLibrary_IsPointInCircle, ReturnValue) == 0x000028, "Member 'GzBlueprintFunctionLibrary_IsPointInCircle::ReturnValue' has a wrong offset!");

// Function G01.GzBlueprintFunctionLibrary.IsPointInPolygon
// 0x0028 (0x0028 - 0x0000)
struct GzBlueprintFunctionLibrary_IsPointInPolygon final
{
public:
	struct FVector2D                              Point;                                             // 0x0000(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FVector2D>                      PolygonBorder;                                     // 0x0010(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0020(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3028[0x7];                                     // 0x0021(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GzBlueprintFunctionLibrary_IsPointInPolygon) == 0x000008, "Wrong alignment on GzBlueprintFunctionLibrary_IsPointInPolygon");
static_assert(sizeof(GzBlueprintFunctionLibrary_IsPointInPolygon) == 0x000028, "Wrong size on GzBlueprintFunctionLibrary_IsPointInPolygon");
static_assert(offsetof(GzBlueprintFunctionLibrary_IsPointInPolygon, Point) == 0x000000, "Member 'GzBlueprintFunctionLibrary_IsPointInPolygon::Point' has a wrong offset!");
static_assert(offsetof(GzBlueprintFunctionLibrary_IsPointInPolygon, PolygonBorder) == 0x000010, "Member 'GzBlueprintFunctionLibrary_IsPointInPolygon::PolygonBorder' has a wrong offset!");
static_assert(offsetof(GzBlueprintFunctionLibrary_IsPointInPolygon, ReturnValue) == 0x000020, "Member 'GzBlueprintFunctionLibrary_IsPointInPolygon::ReturnValue' has a wrong offset!");

// Function G01.GzBlueprintFunctionLibrary.IsSameLocalPlayerTeamId
// 0x0010 (0x0010 - 0x0000)
struct GzBlueprintFunctionLibrary_IsSameLocalPlayerTeamId final
{
public:
	const class UObject*                          WorldContextObject;                                // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         CallerTeamId;                                      // 0x0008(0x0004)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x000C(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3029[0x3];                                     // 0x000D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GzBlueprintFunctionLibrary_IsSameLocalPlayerTeamId) == 0x000008, "Wrong alignment on GzBlueprintFunctionLibrary_IsSameLocalPlayerTeamId");
static_assert(sizeof(GzBlueprintFunctionLibrary_IsSameLocalPlayerTeamId) == 0x000010, "Wrong size on GzBlueprintFunctionLibrary_IsSameLocalPlayerTeamId");
static_assert(offsetof(GzBlueprintFunctionLibrary_IsSameLocalPlayerTeamId, WorldContextObject) == 0x000000, "Member 'GzBlueprintFunctionLibrary_IsSameLocalPlayerTeamId::WorldContextObject' has a wrong offset!");
static_assert(offsetof(GzBlueprintFunctionLibrary_IsSameLocalPlayerTeamId, CallerTeamId) == 0x000008, "Member 'GzBlueprintFunctionLibrary_IsSameLocalPlayerTeamId::CallerTeamId' has a wrong offset!");
static_assert(offsetof(GzBlueprintFunctionLibrary_IsSameLocalPlayerTeamId, ReturnValue) == 0x00000C, "Member 'GzBlueprintFunctionLibrary_IsSameLocalPlayerTeamId::ReturnValue' has a wrong offset!");

// Function G01.GzBlueprintFunctionLibrary.IsShipping
// 0x0001 (0x0001 - 0x0000)
struct GzBlueprintFunctionLibrary_IsShipping final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzBlueprintFunctionLibrary_IsShipping) == 0x000001, "Wrong alignment on GzBlueprintFunctionLibrary_IsShipping");
static_assert(sizeof(GzBlueprintFunctionLibrary_IsShipping) == 0x000001, "Wrong size on GzBlueprintFunctionLibrary_IsShipping");
static_assert(offsetof(GzBlueprintFunctionLibrary_IsShipping, ReturnValue) == 0x000000, "Member 'GzBlueprintFunctionLibrary_IsShipping::ReturnValue' has a wrong offset!");

// Function G01.GzBlueprintFunctionLibrary.IsSpectatedViewTarget
// 0x0010 (0x0010 - 0x0000)
struct GzBlueprintFunctionLibrary_IsSpectatedViewTarget final
{
public:
	const class APawn*                            InPawn;                                            // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_302A[0x7];                                     // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GzBlueprintFunctionLibrary_IsSpectatedViewTarget) == 0x000008, "Wrong alignment on GzBlueprintFunctionLibrary_IsSpectatedViewTarget");
static_assert(sizeof(GzBlueprintFunctionLibrary_IsSpectatedViewTarget) == 0x000010, "Wrong size on GzBlueprintFunctionLibrary_IsSpectatedViewTarget");
static_assert(offsetof(GzBlueprintFunctionLibrary_IsSpectatedViewTarget, InPawn) == 0x000000, "Member 'GzBlueprintFunctionLibrary_IsSpectatedViewTarget::InPawn' has a wrong offset!");
static_assert(offsetof(GzBlueprintFunctionLibrary_IsSpectatedViewTarget, ReturnValue) == 0x000008, "Member 'GzBlueprintFunctionLibrary_IsSpectatedViewTarget::ReturnValue' has a wrong offset!");

// Function G01.GzBlueprintFunctionLibrary.IsWatermarkEnabled
// 0x0001 (0x0001 - 0x0000)
struct GzBlueprintFunctionLibrary_IsWatermarkEnabled final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzBlueprintFunctionLibrary_IsWatermarkEnabled) == 0x000001, "Wrong alignment on GzBlueprintFunctionLibrary_IsWatermarkEnabled");
static_assert(sizeof(GzBlueprintFunctionLibrary_IsWatermarkEnabled) == 0x000001, "Wrong size on GzBlueprintFunctionLibrary_IsWatermarkEnabled");
static_assert(offsetof(GzBlueprintFunctionLibrary_IsWatermarkEnabled, ReturnValue) == 0x000000, "Member 'GzBlueprintFunctionLibrary_IsWatermarkEnabled::ReturnValue' has a wrong offset!");

// Function G01.GzBlueprintFunctionLibrary.RefreshCharactersVisibilityStates
// 0x0008 (0x0008 - 0x0000)
struct GzBlueprintFunctionLibrary_RefreshCharactersVisibilityStates final
{
public:
	class UObject*                                WorldContext;                                      // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzBlueprintFunctionLibrary_RefreshCharactersVisibilityStates) == 0x000008, "Wrong alignment on GzBlueprintFunctionLibrary_RefreshCharactersVisibilityStates");
static_assert(sizeof(GzBlueprintFunctionLibrary_RefreshCharactersVisibilityStates) == 0x000008, "Wrong size on GzBlueprintFunctionLibrary_RefreshCharactersVisibilityStates");
static_assert(offsetof(GzBlueprintFunctionLibrary_RefreshCharactersVisibilityStates, WorldContext) == 0x000000, "Member 'GzBlueprintFunctionLibrary_RefreshCharactersVisibilityStates::WorldContext' has a wrong offset!");

// Function G01.GzBlueprintFunctionLibrary.SetInputMode
// 0x0018 (0x0018 - 0x0000)
struct GzBlueprintFunctionLibrary_SetInputMode final
{
public:
	const class UObject*                          WorldContextObject;                                // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EGzInputMode                                  InputMode;                                         // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_302B[0x7];                                     // 0x0009(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UWidget*                                WidgetToFocus;                                     // 0x0010(0x0008)(Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzBlueprintFunctionLibrary_SetInputMode) == 0x000008, "Wrong alignment on GzBlueprintFunctionLibrary_SetInputMode");
static_assert(sizeof(GzBlueprintFunctionLibrary_SetInputMode) == 0x000018, "Wrong size on GzBlueprintFunctionLibrary_SetInputMode");
static_assert(offsetof(GzBlueprintFunctionLibrary_SetInputMode, WorldContextObject) == 0x000000, "Member 'GzBlueprintFunctionLibrary_SetInputMode::WorldContextObject' has a wrong offset!");
static_assert(offsetof(GzBlueprintFunctionLibrary_SetInputMode, InputMode) == 0x000008, "Member 'GzBlueprintFunctionLibrary_SetInputMode::InputMode' has a wrong offset!");
static_assert(offsetof(GzBlueprintFunctionLibrary_SetInputMode, WidgetToFocus) == 0x000010, "Member 'GzBlueprintFunctionLibrary_SetInputMode::WidgetToFocus' has a wrong offset!");

// Function G01.GzBlueprintFunctionLibrary.SetStencilValue
// 0x0010 (0x0010 - 0x0000)
struct GzBlueprintFunctionLibrary_SetStencilValue final
{
public:
	const class AActor*                           Actor;                                             // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EDepthStencilValue                            Value;                                             // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bWriteInCustomDepthOnZeroStencil;                  // 0x0009(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_302C[0x6];                                     // 0x000A(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GzBlueprintFunctionLibrary_SetStencilValue) == 0x000008, "Wrong alignment on GzBlueprintFunctionLibrary_SetStencilValue");
static_assert(sizeof(GzBlueprintFunctionLibrary_SetStencilValue) == 0x000010, "Wrong size on GzBlueprintFunctionLibrary_SetStencilValue");
static_assert(offsetof(GzBlueprintFunctionLibrary_SetStencilValue, Actor) == 0x000000, "Member 'GzBlueprintFunctionLibrary_SetStencilValue::Actor' has a wrong offset!");
static_assert(offsetof(GzBlueprintFunctionLibrary_SetStencilValue, Value) == 0x000008, "Member 'GzBlueprintFunctionLibrary_SetStencilValue::Value' has a wrong offset!");
static_assert(offsetof(GzBlueprintFunctionLibrary_SetStencilValue, bWriteInCustomDepthOnZeroStencil) == 0x000009, "Member 'GzBlueprintFunctionLibrary_SetStencilValue::bWriteInCustomDepthOnZeroStencil' has a wrong offset!");

// Function G01.GzBlueprintFunctionLibrary.ShouldShowComparisonTooltip
// 0x0001 (0x0001 - 0x0000)
struct GzBlueprintFunctionLibrary_ShouldShowComparisonTooltip final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzBlueprintFunctionLibrary_ShouldShowComparisonTooltip) == 0x000001, "Wrong alignment on GzBlueprintFunctionLibrary_ShouldShowComparisonTooltip");
static_assert(sizeof(GzBlueprintFunctionLibrary_ShouldShowComparisonTooltip) == 0x000001, "Wrong size on GzBlueprintFunctionLibrary_ShouldShowComparisonTooltip");
static_assert(offsetof(GzBlueprintFunctionLibrary_ShouldShowComparisonTooltip, ReturnValue) == 0x000000, "Member 'GzBlueprintFunctionLibrary_ShouldShowComparisonTooltip::ReturnValue' has a wrong offset!");

// Function G01.GzBlueprintFunctionLibrary.SpawnNSAtTransformsWithDelay
// 0x0090 (0x0090 - 0x0000)
struct GzBlueprintFunctionLibrary_SpawnNSAtTransformsWithDelay final
{
public:
	class UObject*                                WorldContextObject;                                // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_302D[0x8];                                     // 0x0008(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             WorldTransform;                                    // 0x0010(0x0060)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGzDelayedVFXSpawnData                 DelayedVFXSpawnData;                               // 0x0070(0x0018)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	uint8                                         Pad_302E[0x8];                                     // 0x0088(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GzBlueprintFunctionLibrary_SpawnNSAtTransformsWithDelay) == 0x000010, "Wrong alignment on GzBlueprintFunctionLibrary_SpawnNSAtTransformsWithDelay");
static_assert(sizeof(GzBlueprintFunctionLibrary_SpawnNSAtTransformsWithDelay) == 0x000090, "Wrong size on GzBlueprintFunctionLibrary_SpawnNSAtTransformsWithDelay");
static_assert(offsetof(GzBlueprintFunctionLibrary_SpawnNSAtTransformsWithDelay, WorldContextObject) == 0x000000, "Member 'GzBlueprintFunctionLibrary_SpawnNSAtTransformsWithDelay::WorldContextObject' has a wrong offset!");
static_assert(offsetof(GzBlueprintFunctionLibrary_SpawnNSAtTransformsWithDelay, WorldTransform) == 0x000010, "Member 'GzBlueprintFunctionLibrary_SpawnNSAtTransformsWithDelay::WorldTransform' has a wrong offset!");
static_assert(offsetof(GzBlueprintFunctionLibrary_SpawnNSAtTransformsWithDelay, DelayedVFXSpawnData) == 0x000070, "Member 'GzBlueprintFunctionLibrary_SpawnNSAtTransformsWithDelay::DelayedVFXSpawnData' has a wrong offset!");

// Function G01.GzBlueprintFunctionLibrary.StartListening
// 0x0010 (0x0010 - 0x0000)
struct GzBlueprintFunctionLibrary_StartListening final
{
public:
	class UObject*                                WorldContextObject;                                // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Port;                                              // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_302F[0x4];                                     // 0x000C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GzBlueprintFunctionLibrary_StartListening) == 0x000008, "Wrong alignment on GzBlueprintFunctionLibrary_StartListening");
static_assert(sizeof(GzBlueprintFunctionLibrary_StartListening) == 0x000010, "Wrong size on GzBlueprintFunctionLibrary_StartListening");
static_assert(offsetof(GzBlueprintFunctionLibrary_StartListening, WorldContextObject) == 0x000000, "Member 'GzBlueprintFunctionLibrary_StartListening::WorldContextObject' has a wrong offset!");
static_assert(offsetof(GzBlueprintFunctionLibrary_StartListening, Port) == 0x000008, "Member 'GzBlueprintFunctionLibrary_StartListening::Port' has a wrong offset!");

// Function G01.GzBlueprintFunctionLibrary.SupportsQualityMode
// 0x0001 (0x0001 - 0x0000)
struct GzBlueprintFunctionLibrary_SupportsQualityMode final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzBlueprintFunctionLibrary_SupportsQualityMode) == 0x000001, "Wrong alignment on GzBlueprintFunctionLibrary_SupportsQualityMode");
static_assert(sizeof(GzBlueprintFunctionLibrary_SupportsQualityMode) == 0x000001, "Wrong size on GzBlueprintFunctionLibrary_SupportsQualityMode");
static_assert(offsetof(GzBlueprintFunctionLibrary_SupportsQualityMode, ReturnValue) == 0x000000, "Member 'GzBlueprintFunctionLibrary_SupportsQualityMode::ReturnValue' has a wrong offset!");

// Function G01.GzBlueprintFunctionLibrary.TriggerEquipWeaponAtSlot
// 0x0018 (0x0018 - 0x0000)
struct GzBlueprintFunctionLibrary_TriggerEquipWeaponAtSlot final
{
public:
	class APawn*                                  Character;                                         // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           PocketSlot;                                        // 0x0008(0x0008)(Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0010(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3030[0x7];                                     // 0x0011(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GzBlueprintFunctionLibrary_TriggerEquipWeaponAtSlot) == 0x000008, "Wrong alignment on GzBlueprintFunctionLibrary_TriggerEquipWeaponAtSlot");
static_assert(sizeof(GzBlueprintFunctionLibrary_TriggerEquipWeaponAtSlot) == 0x000018, "Wrong size on GzBlueprintFunctionLibrary_TriggerEquipWeaponAtSlot");
static_assert(offsetof(GzBlueprintFunctionLibrary_TriggerEquipWeaponAtSlot, Character) == 0x000000, "Member 'GzBlueprintFunctionLibrary_TriggerEquipWeaponAtSlot::Character' has a wrong offset!");
static_assert(offsetof(GzBlueprintFunctionLibrary_TriggerEquipWeaponAtSlot, PocketSlot) == 0x000008, "Member 'GzBlueprintFunctionLibrary_TriggerEquipWeaponAtSlot::PocketSlot' has a wrong offset!");
static_assert(offsetof(GzBlueprintFunctionLibrary_TriggerEquipWeaponAtSlot, ReturnValue) == 0x000010, "Member 'GzBlueprintFunctionLibrary_TriggerEquipWeaponAtSlot::ReturnValue' has a wrong offset!");

// Function G01.GzBlueprintFunctionLibrary.UnbindObjectInputDelegates
// 0x0010 (0x0010 - 0x0000)
struct GzBlueprintFunctionLibrary_UnbindObjectInputDelegates final
{
public:
	class UObject*                                BindingOwner;                                      // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	const class APawn*                            Pawn;                                              // 0x0008(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzBlueprintFunctionLibrary_UnbindObjectInputDelegates) == 0x000008, "Wrong alignment on GzBlueprintFunctionLibrary_UnbindObjectInputDelegates");
static_assert(sizeof(GzBlueprintFunctionLibrary_UnbindObjectInputDelegates) == 0x000010, "Wrong size on GzBlueprintFunctionLibrary_UnbindObjectInputDelegates");
static_assert(offsetof(GzBlueprintFunctionLibrary_UnbindObjectInputDelegates, BindingOwner) == 0x000000, "Member 'GzBlueprintFunctionLibrary_UnbindObjectInputDelegates::BindingOwner' has a wrong offset!");
static_assert(offsetof(GzBlueprintFunctionLibrary_UnbindObjectInputDelegates, Pawn) == 0x000008, "Member 'GzBlueprintFunctionLibrary_UnbindObjectInputDelegates::Pawn' has a wrong offset!");

// Function G01.GzBlueprintFunctionLibrary.UnsetConsoleVariable
// 0x0010 (0x0010 - 0x0000)
struct GzBlueprintFunctionLibrary_UnsetConsoleVariable final
{
public:
	class FString                                 ConsoleVariableToUnset;                            // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzBlueprintFunctionLibrary_UnsetConsoleVariable) == 0x000008, "Wrong alignment on GzBlueprintFunctionLibrary_UnsetConsoleVariable");
static_assert(sizeof(GzBlueprintFunctionLibrary_UnsetConsoleVariable) == 0x000010, "Wrong size on GzBlueprintFunctionLibrary_UnsetConsoleVariable");
static_assert(offsetof(GzBlueprintFunctionLibrary_UnsetConsoleVariable, ConsoleVariableToUnset) == 0x000000, "Member 'GzBlueprintFunctionLibrary_UnsetConsoleVariable::ConsoleVariableToUnset' has a wrong offset!");

// Function G01.GzBlueprintFunctionLibrary.WorldRotationToAzimuth
// 0x0020 (0x0020 - 0x0000)
struct GzBlueprintFunctionLibrary_WorldRotationToAzimuth final
{
public:
	struct FRotator                               WorldRotation;                                     // 0x0000(0x0018)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	float                                         ReturnValue;                                       // 0x0018(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3031[0x4];                                     // 0x001C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GzBlueprintFunctionLibrary_WorldRotationToAzimuth) == 0x000008, "Wrong alignment on GzBlueprintFunctionLibrary_WorldRotationToAzimuth");
static_assert(sizeof(GzBlueprintFunctionLibrary_WorldRotationToAzimuth) == 0x000020, "Wrong size on GzBlueprintFunctionLibrary_WorldRotationToAzimuth");
static_assert(offsetof(GzBlueprintFunctionLibrary_WorldRotationToAzimuth, WorldRotation) == 0x000000, "Member 'GzBlueprintFunctionLibrary_WorldRotationToAzimuth::WorldRotation' has a wrong offset!");
static_assert(offsetof(GzBlueprintFunctionLibrary_WorldRotationToAzimuth, ReturnValue) == 0x000018, "Member 'GzBlueprintFunctionLibrary_WorldRotationToAzimuth::ReturnValue' has a wrong offset!");

// Function G01.GzCarTrackTransport.GetHullTransformLocal
// 0x0060 (0x0060 - 0x0000)
struct GzCarTrackTransport_GetHullTransformLocal final
{
public:
	struct FTransform                             ReturnValue;                                       // 0x0000(0x0060)(ConstParm, Parm, OutParm, ReturnParm, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzCarTrackTransport_GetHullTransformLocal) == 0x000010, "Wrong alignment on GzCarTrackTransport_GetHullTransformLocal");
static_assert(sizeof(GzCarTrackTransport_GetHullTransformLocal) == 0x000060, "Wrong size on GzCarTrackTransport_GetHullTransformLocal");
static_assert(offsetof(GzCarTrackTransport_GetHullTransformLocal, ReturnValue) == 0x000000, "Member 'GzCarTrackTransport_GetHullTransformLocal::ReturnValue' has a wrong offset!");

// Function G01.GzCarTrackTransport.GetWheelTransform
// 0x0070 (0x0070 - 0x0000)
struct GzCarTrackTransport_GetWheelTransform final
{
public:
	int32                                         Param_Index;                                       // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_303F[0xC];                                     // 0x0004(0x000C)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             ReturnValue;                                       // 0x0010(0x0060)(ConstParm, Parm, OutParm, ReturnParm, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzCarTrackTransport_GetWheelTransform) == 0x000010, "Wrong alignment on GzCarTrackTransport_GetWheelTransform");
static_assert(sizeof(GzCarTrackTransport_GetWheelTransform) == 0x000070, "Wrong size on GzCarTrackTransport_GetWheelTransform");
static_assert(offsetof(GzCarTrackTransport_GetWheelTransform, Param_Index) == 0x000000, "Member 'GzCarTrackTransport_GetWheelTransform::Param_Index' has a wrong offset!");
static_assert(offsetof(GzCarTrackTransport_GetWheelTransform, ReturnValue) == 0x000010, "Member 'GzCarTrackTransport_GetWheelTransform::ReturnValue' has a wrong offset!");

// Function G01.GzLimbUIActivationSubsystem.EndActivation
// 0x0001 (0x0001 - 0x0000)
struct GzLimbUIActivationSubsystem_EndActivation final
{
public:
	EGzLimbType                                   LimbType;                                          // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzLimbUIActivationSubsystem_EndActivation) == 0x000001, "Wrong alignment on GzLimbUIActivationSubsystem_EndActivation");
static_assert(sizeof(GzLimbUIActivationSubsystem_EndActivation) == 0x000001, "Wrong size on GzLimbUIActivationSubsystem_EndActivation");
static_assert(offsetof(GzLimbUIActivationSubsystem_EndActivation, LimbType) == 0x000000, "Member 'GzLimbUIActivationSubsystem_EndActivation::LimbType' has a wrong offset!");

// Function G01.GzLimbUIActivationSubsystem.OnViewTargetChanged
// 0x0008 (0x0008 - 0x0000)
struct GzLimbUIActivationSubsystem_OnViewTargetChanged final
{
public:
	class APawn*                                  Pawn;                                              // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzLimbUIActivationSubsystem_OnViewTargetChanged) == 0x000008, "Wrong alignment on GzLimbUIActivationSubsystem_OnViewTargetChanged");
static_assert(sizeof(GzLimbUIActivationSubsystem_OnViewTargetChanged) == 0x000008, "Wrong size on GzLimbUIActivationSubsystem_OnViewTargetChanged");
static_assert(offsetof(GzLimbUIActivationSubsystem_OnViewTargetChanged, Pawn) == 0x000000, "Member 'GzLimbUIActivationSubsystem_OnViewTargetChanged::Pawn' has a wrong offset!");

// Function G01.GzLimbUIActivationSubsystem.SetActivationValue
// 0x0008 (0x0008 - 0x0000)
struct GzLimbUIActivationSubsystem_SetActivationValue final
{
public:
	EGzLimbType                                   LimbType;                                          // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3040[0x3];                                     // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         NewValue;                                          // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzLimbUIActivationSubsystem_SetActivationValue) == 0x000004, "Wrong alignment on GzLimbUIActivationSubsystem_SetActivationValue");
static_assert(sizeof(GzLimbUIActivationSubsystem_SetActivationValue) == 0x000008, "Wrong size on GzLimbUIActivationSubsystem_SetActivationValue");
static_assert(offsetof(GzLimbUIActivationSubsystem_SetActivationValue, LimbType) == 0x000000, "Member 'GzLimbUIActivationSubsystem_SetActivationValue::LimbType' has a wrong offset!");
static_assert(offsetof(GzLimbUIActivationSubsystem_SetActivationValue, NewValue) == 0x000004, "Member 'GzLimbUIActivationSubsystem_SetActivationValue::NewValue' has a wrong offset!");

// Function G01.GzLimbUIActivationSubsystem.StartActivation
// 0x0030 (0x0030 - 0x0000)
struct GzLimbUIActivationSubsystem_StartActivation final
{
public:
	EGzLimbType                                   LimbType;                                          // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3041[0x7];                                     // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGzLimbGaugeData                       ActivationData;                                    // 0x0008(0x0028)(Parm, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzLimbUIActivationSubsystem_StartActivation) == 0x000008, "Wrong alignment on GzLimbUIActivationSubsystem_StartActivation");
static_assert(sizeof(GzLimbUIActivationSubsystem_StartActivation) == 0x000030, "Wrong size on GzLimbUIActivationSubsystem_StartActivation");
static_assert(offsetof(GzLimbUIActivationSubsystem_StartActivation, LimbType) == 0x000000, "Member 'GzLimbUIActivationSubsystem_StartActivation::LimbType' has a wrong offset!");
static_assert(offsetof(GzLimbUIActivationSubsystem_StartActivation, ActivationData) == 0x000008, "Member 'GzLimbUIActivationSubsystem_StartActivation::ActivationData' has a wrong offset!");

// Function G01.GzLimbUIActivationSubsystem.UpdateActivationValue
// 0x0008 (0x0008 - 0x0000)
struct GzLimbUIActivationSubsystem_UpdateActivationValue final
{
public:
	EGzLimbType                                   LimbType;                                          // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3042[0x3];                                     // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         AddValue;                                          // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzLimbUIActivationSubsystem_UpdateActivationValue) == 0x000004, "Wrong alignment on GzLimbUIActivationSubsystem_UpdateActivationValue");
static_assert(sizeof(GzLimbUIActivationSubsystem_UpdateActivationValue) == 0x000008, "Wrong size on GzLimbUIActivationSubsystem_UpdateActivationValue");
static_assert(offsetof(GzLimbUIActivationSubsystem_UpdateActivationValue, LimbType) == 0x000000, "Member 'GzLimbUIActivationSubsystem_UpdateActivationValue::LimbType' has a wrong offset!");
static_assert(offsetof(GzLimbUIActivationSubsystem_UpdateActivationValue, AddValue) == 0x000004, "Member 'GzLimbUIActivationSubsystem_UpdateActivationValue::AddValue' has a wrong offset!");

// Function G01.GzLaserAttachmentBehaviour.Enable
// 0x0001 (0x0001 - 0x0000)
struct GzLaserAttachmentBehaviour_Enable final
{
public:
	bool                                          bEnable;                                           // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzLaserAttachmentBehaviour_Enable) == 0x000001, "Wrong alignment on GzLaserAttachmentBehaviour_Enable");
static_assert(sizeof(GzLaserAttachmentBehaviour_Enable) == 0x000001, "Wrong size on GzLaserAttachmentBehaviour_Enable");
static_assert(offsetof(GzLaserAttachmentBehaviour_Enable, bEnable) == 0x000000, "Member 'GzLaserAttachmentBehaviour_Enable::bEnable' has a wrong offset!");

// Function G01.GzLaserAttachmentBehaviour.UpdatePoint
// 0x00F8 (0x00F8 - 0x0000)
struct GzLaserAttachmentBehaviour_UpdatePoint final
{
public:
	struct FHitResult                             ReturnValue;                                       // 0x0000(0x00F8)(Parm, OutParm, ReturnParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzLaserAttachmentBehaviour_UpdatePoint) == 0x000008, "Wrong alignment on GzLaserAttachmentBehaviour_UpdatePoint");
static_assert(sizeof(GzLaserAttachmentBehaviour_UpdatePoint) == 0x0000F8, "Wrong size on GzLaserAttachmentBehaviour_UpdatePoint");
static_assert(offsetof(GzLaserAttachmentBehaviour_UpdatePoint, ReturnValue) == 0x000000, "Member 'GzLaserAttachmentBehaviour_UpdatePoint::ReturnValue' has a wrong offset!");

// Function G01.GzVehicleConfig.HasSeat
// 0x0002 (0x0002 - 0x0000)
struct GzVehicleConfig_HasSeat final
{
public:
	EGzVehicleSeatType                            VehicleSeatType;                                   // 0x0000(0x0001)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0001(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzVehicleConfig_HasSeat) == 0x000001, "Wrong alignment on GzVehicleConfig_HasSeat");
static_assert(sizeof(GzVehicleConfig_HasSeat) == 0x000002, "Wrong size on GzVehicleConfig_HasSeat");
static_assert(offsetof(GzVehicleConfig_HasSeat, VehicleSeatType) == 0x000000, "Member 'GzVehicleConfig_HasSeat::VehicleSeatType' has a wrong offset!");
static_assert(offsetof(GzVehicleConfig_HasSeat, ReturnValue) == 0x000001, "Member 'GzVehicleConfig_HasSeat::ReturnValue' has a wrong offset!");

// Function G01.GzUnlockCondition.MakeUnlockCondition
// 0x0020 (0x0020 - 0x0000)
struct GzUnlockCondition_MakeUnlockCondition final
{
public:
	class AGzAdvancedMission*                     Mission;                                           // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UGzCondition*                           Key;                                               // 0x0008(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UGzCondition*                           Param_LockedCondition;                             // 0x0010(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UGzCondition*                           ReturnValue;                                       // 0x0018(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzUnlockCondition_MakeUnlockCondition) == 0x000008, "Wrong alignment on GzUnlockCondition_MakeUnlockCondition");
static_assert(sizeof(GzUnlockCondition_MakeUnlockCondition) == 0x000020, "Wrong size on GzUnlockCondition_MakeUnlockCondition");
static_assert(offsetof(GzUnlockCondition_MakeUnlockCondition, Mission) == 0x000000, "Member 'GzUnlockCondition_MakeUnlockCondition::Mission' has a wrong offset!");
static_assert(offsetof(GzUnlockCondition_MakeUnlockCondition, Key) == 0x000008, "Member 'GzUnlockCondition_MakeUnlockCondition::Key' has a wrong offset!");
static_assert(offsetof(GzUnlockCondition_MakeUnlockCondition, Param_LockedCondition) == 0x000010, "Member 'GzUnlockCondition_MakeUnlockCondition::Param_LockedCondition' has a wrong offset!");
static_assert(offsetof(GzUnlockCondition_MakeUnlockCondition, ReturnValue) == 0x000018, "Member 'GzUnlockCondition_MakeUnlockCondition::ReturnValue' has a wrong offset!");

// Function G01.GzChaosWheeledVehicleMovementComponent.OnOnwerControllerChanged
// 0x0018 (0x0018 - 0x0000)
struct GzChaosWheeledVehicleMovementComponent_OnOnwerControllerChanged final
{
public:
	class APawn*                                  Pawn;                                              // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AController*                            OldController;                                     // 0x0008(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AController*                            NewController;                                     // 0x0010(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzChaosWheeledVehicleMovementComponent_OnOnwerControllerChanged) == 0x000008, "Wrong alignment on GzChaosWheeledVehicleMovementComponent_OnOnwerControllerChanged");
static_assert(sizeof(GzChaosWheeledVehicleMovementComponent_OnOnwerControllerChanged) == 0x000018, "Wrong size on GzChaosWheeledVehicleMovementComponent_OnOnwerControllerChanged");
static_assert(offsetof(GzChaosWheeledVehicleMovementComponent_OnOnwerControllerChanged, Pawn) == 0x000000, "Member 'GzChaosWheeledVehicleMovementComponent_OnOnwerControllerChanged::Pawn' has a wrong offset!");
static_assert(offsetof(GzChaosWheeledVehicleMovementComponent_OnOnwerControllerChanged, OldController) == 0x000008, "Member 'GzChaosWheeledVehicleMovementComponent_OnOnwerControllerChanged::OldController' has a wrong offset!");
static_assert(offsetof(GzChaosWheeledVehicleMovementComponent_OnOnwerControllerChanged, NewController) == 0x000010, "Member 'GzChaosWheeledVehicleMovementComponent_OnOnwerControllerChanged::NewController' has a wrong offset!");

// Function G01.GzChaosWheeledVehicleMovementComponent.GetBrakeInput_Replicated
// 0x0004 (0x0004 - 0x0000)
struct GzChaosWheeledVehicleMovementComponent_GetBrakeInput_Replicated final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzChaosWheeledVehicleMovementComponent_GetBrakeInput_Replicated) == 0x000004, "Wrong alignment on GzChaosWheeledVehicleMovementComponent_GetBrakeInput_Replicated");
static_assert(sizeof(GzChaosWheeledVehicleMovementComponent_GetBrakeInput_Replicated) == 0x000004, "Wrong size on GzChaosWheeledVehicleMovementComponent_GetBrakeInput_Replicated");
static_assert(offsetof(GzChaosWheeledVehicleMovementComponent_GetBrakeInput_Replicated, ReturnValue) == 0x000000, "Member 'GzChaosWheeledVehicleMovementComponent_GetBrakeInput_Replicated::ReturnValue' has a wrong offset!");

// Function G01.GzChaosWheeledVehicleMovementComponent.GetEngineRPM
// 0x0004 (0x0004 - 0x0000)
struct GzChaosWheeledVehicleMovementComponent_GetEngineRPM final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzChaosWheeledVehicleMovementComponent_GetEngineRPM) == 0x000004, "Wrong alignment on GzChaosWheeledVehicleMovementComponent_GetEngineRPM");
static_assert(sizeof(GzChaosWheeledVehicleMovementComponent_GetEngineRPM) == 0x000004, "Wrong size on GzChaosWheeledVehicleMovementComponent_GetEngineRPM");
static_assert(offsetof(GzChaosWheeledVehicleMovementComponent_GetEngineRPM, ReturnValue) == 0x000000, "Member 'GzChaosWheeledVehicleMovementComponent_GetEngineRPM::ReturnValue' has a wrong offset!");

// Function G01.GzChaosWheeledVehicleMovementComponent.GetHandbrakeInput_Replicated
// 0x0001 (0x0001 - 0x0000)
struct GzChaosWheeledVehicleMovementComponent_GetHandbrakeInput_Replicated final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzChaosWheeledVehicleMovementComponent_GetHandbrakeInput_Replicated) == 0x000001, "Wrong alignment on GzChaosWheeledVehicleMovementComponent_GetHandbrakeInput_Replicated");
static_assert(sizeof(GzChaosWheeledVehicleMovementComponent_GetHandbrakeInput_Replicated) == 0x000001, "Wrong size on GzChaosWheeledVehicleMovementComponent_GetHandbrakeInput_Replicated");
static_assert(offsetof(GzChaosWheeledVehicleMovementComponent_GetHandbrakeInput_Replicated, ReturnValue) == 0x000000, "Member 'GzChaosWheeledVehicleMovementComponent_GetHandbrakeInput_Replicated::ReturnValue' has a wrong offset!");

// Function G01.GzChaosWheeledVehicleMovementComponent.GetSteerInput_Replicated
// 0x0004 (0x0004 - 0x0000)
struct GzChaosWheeledVehicleMovementComponent_GetSteerInput_Replicated final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzChaosWheeledVehicleMovementComponent_GetSteerInput_Replicated) == 0x000004, "Wrong alignment on GzChaosWheeledVehicleMovementComponent_GetSteerInput_Replicated");
static_assert(sizeof(GzChaosWheeledVehicleMovementComponent_GetSteerInput_Replicated) == 0x000004, "Wrong size on GzChaosWheeledVehicleMovementComponent_GetSteerInput_Replicated");
static_assert(offsetof(GzChaosWheeledVehicleMovementComponent_GetSteerInput_Replicated, ReturnValue) == 0x000000, "Member 'GzChaosWheeledVehicleMovementComponent_GetSteerInput_Replicated::ReturnValue' has a wrong offset!");

// Function G01.GzChaosWheeledVehicleMovementComponent.GetTargetGear_Replicated
// 0x0004 (0x0004 - 0x0000)
struct GzChaosWheeledVehicleMovementComponent_GetTargetGear_Replicated final
{
public:
	int32                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzChaosWheeledVehicleMovementComponent_GetTargetGear_Replicated) == 0x000004, "Wrong alignment on GzChaosWheeledVehicleMovementComponent_GetTargetGear_Replicated");
static_assert(sizeof(GzChaosWheeledVehicleMovementComponent_GetTargetGear_Replicated) == 0x000004, "Wrong size on GzChaosWheeledVehicleMovementComponent_GetTargetGear_Replicated");
static_assert(offsetof(GzChaosWheeledVehicleMovementComponent_GetTargetGear_Replicated, ReturnValue) == 0x000000, "Member 'GzChaosWheeledVehicleMovementComponent_GetTargetGear_Replicated::ReturnValue' has a wrong offset!");

// Function G01.GzChaosWheeledVehicleMovementComponent.GetThrottleInput_Replicated
// 0x0004 (0x0004 - 0x0000)
struct GzChaosWheeledVehicleMovementComponent_GetThrottleInput_Replicated final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzChaosWheeledVehicleMovementComponent_GetThrottleInput_Replicated) == 0x000004, "Wrong alignment on GzChaosWheeledVehicleMovementComponent_GetThrottleInput_Replicated");
static_assert(sizeof(GzChaosWheeledVehicleMovementComponent_GetThrottleInput_Replicated) == 0x000004, "Wrong size on GzChaosWheeledVehicleMovementComponent_GetThrottleInput_Replicated");
static_assert(offsetof(GzChaosWheeledVehicleMovementComponent_GetThrottleInput_Replicated, ReturnValue) == 0x000000, "Member 'GzChaosWheeledVehicleMovementComponent_GetThrottleInput_Replicated::ReturnValue' has a wrong offset!");

// Function G01.GzChaosWheeledVehicleMovementComponent.GetVelocity
// 0x0018 (0x0018 - 0x0000)
struct GzChaosWheeledVehicleMovementComponent_GetVelocity final
{
public:
	struct FVector                                ReturnValue;                                       // 0x0000(0x0018)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzChaosWheeledVehicleMovementComponent_GetVelocity) == 0x000008, "Wrong alignment on GzChaosWheeledVehicleMovementComponent_GetVelocity");
static_assert(sizeof(GzChaosWheeledVehicleMovementComponent_GetVelocity) == 0x000018, "Wrong size on GzChaosWheeledVehicleMovementComponent_GetVelocity");
static_assert(offsetof(GzChaosWheeledVehicleMovementComponent_GetVelocity, ReturnValue) == 0x000000, "Member 'GzChaosWheeledVehicleMovementComponent_GetVelocity::ReturnValue' has a wrong offset!");

// Function G01.GzChaosWheeledVehicleMovementComponent.GetWheelCount
// 0x0004 (0x0004 - 0x0000)
struct GzChaosWheeledVehicleMovementComponent_GetWheelCount final
{
public:
	int32                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzChaosWheeledVehicleMovementComponent_GetWheelCount) == 0x000004, "Wrong alignment on GzChaosWheeledVehicleMovementComponent_GetWheelCount");
static_assert(sizeof(GzChaosWheeledVehicleMovementComponent_GetWheelCount) == 0x000004, "Wrong size on GzChaosWheeledVehicleMovementComponent_GetWheelCount");
static_assert(offsetof(GzChaosWheeledVehicleMovementComponent_GetWheelCount, ReturnValue) == 0x000000, "Member 'GzChaosWheeledVehicleMovementComponent_GetWheelCount::ReturnValue' has a wrong offset!");

// Function G01.GzChaosWheeledVehicleMovementComponent.GetWheelPhysicalMaterial
// 0x0010 (0x0010 - 0x0000)
struct GzChaosWheeledVehicleMovementComponent_GetWheelPhysicalMaterial final
{
public:
	int32                                         WheelIndex;                                        // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3052[0x4];                                     // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UPhysicalMaterial*                      ReturnValue;                                       // 0x0008(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzChaosWheeledVehicleMovementComponent_GetWheelPhysicalMaterial) == 0x000008, "Wrong alignment on GzChaosWheeledVehicleMovementComponent_GetWheelPhysicalMaterial");
static_assert(sizeof(GzChaosWheeledVehicleMovementComponent_GetWheelPhysicalMaterial) == 0x000010, "Wrong size on GzChaosWheeledVehicleMovementComponent_GetWheelPhysicalMaterial");
static_assert(offsetof(GzChaosWheeledVehicleMovementComponent_GetWheelPhysicalMaterial, WheelIndex) == 0x000000, "Member 'GzChaosWheeledVehicleMovementComponent_GetWheelPhysicalMaterial::WheelIndex' has a wrong offset!");
static_assert(offsetof(GzChaosWheeledVehicleMovementComponent_GetWheelPhysicalMaterial, ReturnValue) == 0x000008, "Member 'GzChaosWheeledVehicleMovementComponent_GetWheelPhysicalMaterial::ReturnValue' has a wrong offset!");

// Function G01.GzChaosWheeledVehicleMovementComponent.GetWheelSteeringAngle
// 0x0008 (0x0008 - 0x0000)
struct GzChaosWheeledVehicleMovementComponent_GetWheelSteeringAngle final
{
public:
	int32                                         WheelIndex;                                        // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ReturnValue;                                       // 0x0004(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzChaosWheeledVehicleMovementComponent_GetWheelSteeringAngle) == 0x000004, "Wrong alignment on GzChaosWheeledVehicleMovementComponent_GetWheelSteeringAngle");
static_assert(sizeof(GzChaosWheeledVehicleMovementComponent_GetWheelSteeringAngle) == 0x000008, "Wrong size on GzChaosWheeledVehicleMovementComponent_GetWheelSteeringAngle");
static_assert(offsetof(GzChaosWheeledVehicleMovementComponent_GetWheelSteeringAngle, WheelIndex) == 0x000000, "Member 'GzChaosWheeledVehicleMovementComponent_GetWheelSteeringAngle::WheelIndex' has a wrong offset!");
static_assert(offsetof(GzChaosWheeledVehicleMovementComponent_GetWheelSteeringAngle, ReturnValue) == 0x000004, "Member 'GzChaosWheeledVehicleMovementComponent_GetWheelSteeringAngle::ReturnValue' has a wrong offset!");

// Function G01.GzChaosWheeledVehicleMovementComponent.GetWheelSuspensionPercentage
// 0x0008 (0x0008 - 0x0000)
struct GzChaosWheeledVehicleMovementComponent_GetWheelSuspensionPercentage final
{
public:
	int32                                         WheelIndex;                                        // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ReturnValue;                                       // 0x0004(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzChaosWheeledVehicleMovementComponent_GetWheelSuspensionPercentage) == 0x000004, "Wrong alignment on GzChaosWheeledVehicleMovementComponent_GetWheelSuspensionPercentage");
static_assert(sizeof(GzChaosWheeledVehicleMovementComponent_GetWheelSuspensionPercentage) == 0x000008, "Wrong size on GzChaosWheeledVehicleMovementComponent_GetWheelSuspensionPercentage");
static_assert(offsetof(GzChaosWheeledVehicleMovementComponent_GetWheelSuspensionPercentage, WheelIndex) == 0x000000, "Member 'GzChaosWheeledVehicleMovementComponent_GetWheelSuspensionPercentage::WheelIndex' has a wrong offset!");
static_assert(offsetof(GzChaosWheeledVehicleMovementComponent_GetWheelSuspensionPercentage, ReturnValue) == 0x000004, "Member 'GzChaosWheeledVehicleMovementComponent_GetWheelSuspensionPercentage::ReturnValue' has a wrong offset!");

// Function G01.GzChaosWheeledVehicleMovementComponent.IsAnyWheelOnGround
// 0x0001 (0x0001 - 0x0000)
struct GzChaosWheeledVehicleMovementComponent_IsAnyWheelOnGround final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzChaosWheeledVehicleMovementComponent_IsAnyWheelOnGround) == 0x000001, "Wrong alignment on GzChaosWheeledVehicleMovementComponent_IsAnyWheelOnGround");
static_assert(sizeof(GzChaosWheeledVehicleMovementComponent_IsAnyWheelOnGround) == 0x000001, "Wrong size on GzChaosWheeledVehicleMovementComponent_IsAnyWheelOnGround");
static_assert(offsetof(GzChaosWheeledVehicleMovementComponent_IsAnyWheelOnGround, ReturnValue) == 0x000000, "Member 'GzChaosWheeledVehicleMovementComponent_IsAnyWheelOnGround::ReturnValue' has a wrong offset!");

// Function G01.GzChaosWheeledVehicleMovementComponent.IsWheelOnGround
// 0x0008 (0x0008 - 0x0000)
struct GzChaosWheeledVehicleMovementComponent_IsWheelOnGround final
{
public:
	int32                                         WheelIndex;                                        // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0004(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3053[0x3];                                     // 0x0005(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GzChaosWheeledVehicleMovementComponent_IsWheelOnGround) == 0x000004, "Wrong alignment on GzChaosWheeledVehicleMovementComponent_IsWheelOnGround");
static_assert(sizeof(GzChaosWheeledVehicleMovementComponent_IsWheelOnGround) == 0x000008, "Wrong size on GzChaosWheeledVehicleMovementComponent_IsWheelOnGround");
static_assert(offsetof(GzChaosWheeledVehicleMovementComponent_IsWheelOnGround, WheelIndex) == 0x000000, "Member 'GzChaosWheeledVehicleMovementComponent_IsWheelOnGround::WheelIndex' has a wrong offset!");
static_assert(offsetof(GzChaosWheeledVehicleMovementComponent_IsWheelOnGround, ReturnValue) == 0x000004, "Member 'GzChaosWheeledVehicleMovementComponent_IsWheelOnGround::ReturnValue' has a wrong offset!");

// Function G01.GzChaosWheeledVehicleMovementComponent.IsWheelSkidding
// 0x0008 (0x0008 - 0x0000)
struct GzChaosWheeledVehicleMovementComponent_IsWheelSkidding final
{
public:
	int32                                         WheelIndex;                                        // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0004(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3054[0x3];                                     // 0x0005(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GzChaosWheeledVehicleMovementComponent_IsWheelSkidding) == 0x000004, "Wrong alignment on GzChaosWheeledVehicleMovementComponent_IsWheelSkidding");
static_assert(sizeof(GzChaosWheeledVehicleMovementComponent_IsWheelSkidding) == 0x000008, "Wrong size on GzChaosWheeledVehicleMovementComponent_IsWheelSkidding");
static_assert(offsetof(GzChaosWheeledVehicleMovementComponent_IsWheelSkidding, WheelIndex) == 0x000000, "Member 'GzChaosWheeledVehicleMovementComponent_IsWheelSkidding::WheelIndex' has a wrong offset!");
static_assert(offsetof(GzChaosWheeledVehicleMovementComponent_IsWheelSkidding, ReturnValue) == 0x000004, "Member 'GzChaosWheeledVehicleMovementComponent_IsWheelSkidding::ReturnValue' has a wrong offset!");

// Function G01.GzChaosWheeledVehicleMovementComponent.IsWheelSlipping
// 0x0008 (0x0008 - 0x0000)
struct GzChaosWheeledVehicleMovementComponent_IsWheelSlipping final
{
public:
	int32                                         WheelIndex;                                        // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0004(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3055[0x3];                                     // 0x0005(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GzChaosWheeledVehicleMovementComponent_IsWheelSlipping) == 0x000004, "Wrong alignment on GzChaosWheeledVehicleMovementComponent_IsWheelSlipping");
static_assert(sizeof(GzChaosWheeledVehicleMovementComponent_IsWheelSlipping) == 0x000008, "Wrong size on GzChaosWheeledVehicleMovementComponent_IsWheelSlipping");
static_assert(offsetof(GzChaosWheeledVehicleMovementComponent_IsWheelSlipping, WheelIndex) == 0x000000, "Member 'GzChaosWheeledVehicleMovementComponent_IsWheelSlipping::WheelIndex' has a wrong offset!");
static_assert(offsetof(GzChaosWheeledVehicleMovementComponent_IsWheelSlipping, ReturnValue) == 0x000004, "Member 'GzChaosWheeledVehicleMovementComponent_IsWheelSlipping::ReturnValue' has a wrong offset!");

// DelegateFunction G01.GzChargeableAbilityComponent.GzLimbAbilityAimAssistTargetChanged__DelegateSignature
// 0x0010 (0x0010 - 0x0000)
struct GzChargeableAbilityComponent_GzLimbAbilityAimAssistTargetChanged__DelegateSignature final
{
public:
	class AActor*                                 PreviousTarget;                                    // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 NewTarget;                                         // 0x0008(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzChargeableAbilityComponent_GzLimbAbilityAimAssistTargetChanged__DelegateSignature) == 0x000008, "Wrong alignment on GzChargeableAbilityComponent_GzLimbAbilityAimAssistTargetChanged__DelegateSignature");
static_assert(sizeof(GzChargeableAbilityComponent_GzLimbAbilityAimAssistTargetChanged__DelegateSignature) == 0x000010, "Wrong size on GzChargeableAbilityComponent_GzLimbAbilityAimAssistTargetChanged__DelegateSignature");
static_assert(offsetof(GzChargeableAbilityComponent_GzLimbAbilityAimAssistTargetChanged__DelegateSignature, PreviousTarget) == 0x000000, "Member 'GzChargeableAbilityComponent_GzLimbAbilityAimAssistTargetChanged__DelegateSignature::PreviousTarget' has a wrong offset!");
static_assert(offsetof(GzChargeableAbilityComponent_GzLimbAbilityAimAssistTargetChanged__DelegateSignature, NewTarget) == 0x000008, "Member 'GzChargeableAbilityComponent_GzLimbAbilityAimAssistTargetChanged__DelegateSignature::NewTarget' has a wrong offset!");

// Function G01.GzChargeableAbilityComponent.CanShoot
// 0x0001 (0x0001 - 0x0000)
struct GzChargeableAbilityComponent_CanShoot final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzChargeableAbilityComponent_CanShoot) == 0x000001, "Wrong alignment on GzChargeableAbilityComponent_CanShoot");
static_assert(sizeof(GzChargeableAbilityComponent_CanShoot) == 0x000001, "Wrong size on GzChargeableAbilityComponent_CanShoot");
static_assert(offsetof(GzChargeableAbilityComponent_CanShoot, ReturnValue) == 0x000000, "Member 'GzChargeableAbilityComponent_CanShoot::ReturnValue' has a wrong offset!");

// Function G01.GzChargeableAbilityComponent.GetAimAssistRange
// 0x0004 (0x0004 - 0x0000)
struct GzChargeableAbilityComponent_GetAimAssistRange final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzChargeableAbilityComponent_GetAimAssistRange) == 0x000004, "Wrong alignment on GzChargeableAbilityComponent_GetAimAssistRange");
static_assert(sizeof(GzChargeableAbilityComponent_GetAimAssistRange) == 0x000004, "Wrong size on GzChargeableAbilityComponent_GetAimAssistRange");
static_assert(offsetof(GzChargeableAbilityComponent_GetAimAssistRange, ReturnValue) == 0x000000, "Member 'GzChargeableAbilityComponent_GetAimAssistRange::ReturnValue' has a wrong offset!");

// Function G01.GzChargeableAbilityComponent.GetAimAssistSingleTarget
// 0x0008 (0x0008 - 0x0000)
struct GzChargeableAbilityComponent_GetAimAssistSingleTarget final
{
public:
	class AActor*                                 ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzChargeableAbilityComponent_GetAimAssistSingleTarget) == 0x000008, "Wrong alignment on GzChargeableAbilityComponent_GetAimAssistSingleTarget");
static_assert(sizeof(GzChargeableAbilityComponent_GetAimAssistSingleTarget) == 0x000008, "Wrong size on GzChargeableAbilityComponent_GetAimAssistSingleTarget");
static_assert(offsetof(GzChargeableAbilityComponent_GetAimAssistSingleTarget, ReturnValue) == 0x000000, "Member 'GzChargeableAbilityComponent_GetAimAssistSingleTarget::ReturnValue' has a wrong offset!");

// Function G01.GzChargeableAbilityComponent.GetAimAssistTargets
// 0x0010 (0x0010 - 0x0000)
struct GzChargeableAbilityComponent_GetAimAssistTargets final
{
public:
	TArray<class AActor*>                         ReturnValue;                                       // 0x0000(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzChargeableAbilityComponent_GetAimAssistTargets) == 0x000008, "Wrong alignment on GzChargeableAbilityComponent_GetAimAssistTargets");
static_assert(sizeof(GzChargeableAbilityComponent_GetAimAssistTargets) == 0x000010, "Wrong size on GzChargeableAbilityComponent_GetAimAssistTargets");
static_assert(offsetof(GzChargeableAbilityComponent_GetAimAssistTargets, ReturnValue) == 0x000000, "Member 'GzChargeableAbilityComponent_GetAimAssistTargets::ReturnValue' has a wrong offset!");

// Function G01.GzChargeableAbilityComponent.GetAimAssistViewDirection
// 0x0018 (0x0018 - 0x0000)
struct GzChargeableAbilityComponent_GetAimAssistViewDirection final
{
public:
	struct FVector                                ReturnValue;                                       // 0x0000(0x0018)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzChargeableAbilityComponent_GetAimAssistViewDirection) == 0x000008, "Wrong alignment on GzChargeableAbilityComponent_GetAimAssistViewDirection");
static_assert(sizeof(GzChargeableAbilityComponent_GetAimAssistViewDirection) == 0x000018, "Wrong size on GzChargeableAbilityComponent_GetAimAssistViewDirection");
static_assert(offsetof(GzChargeableAbilityComponent_GetAimAssistViewDirection, ReturnValue) == 0x000000, "Member 'GzChargeableAbilityComponent_GetAimAssistViewDirection::ReturnValue' has a wrong offset!");

// Function G01.GzChargeableAbilityComponent.GetAimAssistViewLocation
// 0x0018 (0x0018 - 0x0000)
struct GzChargeableAbilityComponent_GetAimAssistViewLocation final
{
public:
	struct FVector                                ReturnValue;                                       // 0x0000(0x0018)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzChargeableAbilityComponent_GetAimAssistViewLocation) == 0x000008, "Wrong alignment on GzChargeableAbilityComponent_GetAimAssistViewLocation");
static_assert(sizeof(GzChargeableAbilityComponent_GetAimAssistViewLocation) == 0x000018, "Wrong size on GzChargeableAbilityComponent_GetAimAssistViewLocation");
static_assert(offsetof(GzChargeableAbilityComponent_GetAimAssistViewLocation, ReturnValue) == 0x000000, "Member 'GzChargeableAbilityComponent_GetAimAssistViewLocation::ReturnValue' has a wrong offset!");

// Function G01.GzChargeableAbilityComponent.GetChargeProgress
// 0x0004 (0x0004 - 0x0000)
struct GzChargeableAbilityComponent_GetChargeProgress final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzChargeableAbilityComponent_GetChargeProgress) == 0x000004, "Wrong alignment on GzChargeableAbilityComponent_GetChargeProgress");
static_assert(sizeof(GzChargeableAbilityComponent_GetChargeProgress) == 0x000004, "Wrong size on GzChargeableAbilityComponent_GetChargeProgress");
static_assert(offsetof(GzChargeableAbilityComponent_GetChargeProgress, ReturnValue) == 0x000000, "Member 'GzChargeableAbilityComponent_GetChargeProgress::ReturnValue' has a wrong offset!");

// Function G01.GzChargeableAbilityComponent.GetCooldownDuration
// 0x0004 (0x0004 - 0x0000)
struct GzChargeableAbilityComponent_GetCooldownDuration final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzChargeableAbilityComponent_GetCooldownDuration) == 0x000004, "Wrong alignment on GzChargeableAbilityComponent_GetCooldownDuration");
static_assert(sizeof(GzChargeableAbilityComponent_GetCooldownDuration) == 0x000004, "Wrong size on GzChargeableAbilityComponent_GetCooldownDuration");
static_assert(offsetof(GzChargeableAbilityComponent_GetCooldownDuration, ReturnValue) == 0x000000, "Member 'GzChargeableAbilityComponent_GetCooldownDuration::ReturnValue' has a wrong offset!");

// Function G01.GzChargeableAbilityComponent.GetCooldownProgress
// 0x0004 (0x0004 - 0x0000)
struct GzChargeableAbilityComponent_GetCooldownProgress final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzChargeableAbilityComponent_GetCooldownProgress) == 0x000004, "Wrong alignment on GzChargeableAbilityComponent_GetCooldownProgress");
static_assert(sizeof(GzChargeableAbilityComponent_GetCooldownProgress) == 0x000004, "Wrong size on GzChargeableAbilityComponent_GetCooldownProgress");
static_assert(offsetof(GzChargeableAbilityComponent_GetCooldownProgress, ReturnValue) == 0x000000, "Member 'GzChargeableAbilityComponent_GetCooldownProgress::ReturnValue' has a wrong offset!");

// Function G01.GzChargeableAbilityComponent.GetLaunchDirection
// 0x0018 (0x0018 - 0x0000)
struct GzChargeableAbilityComponent_GetLaunchDirection final
{
public:
	struct FVector                                ReturnValue;                                       // 0x0000(0x0018)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzChargeableAbilityComponent_GetLaunchDirection) == 0x000008, "Wrong alignment on GzChargeableAbilityComponent_GetLaunchDirection");
static_assert(sizeof(GzChargeableAbilityComponent_GetLaunchDirection) == 0x000018, "Wrong size on GzChargeableAbilityComponent_GetLaunchDirection");
static_assert(offsetof(GzChargeableAbilityComponent_GetLaunchDirection, ReturnValue) == 0x000000, "Member 'GzChargeableAbilityComponent_GetLaunchDirection::ReturnValue' has a wrong offset!");

// Function G01.GzChargeableAbilityComponent.GetLaunchSpeed
// 0x0004 (0x0004 - 0x0000)
struct GzChargeableAbilityComponent_GetLaunchSpeed final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzChargeableAbilityComponent_GetLaunchSpeed) == 0x000004, "Wrong alignment on GzChargeableAbilityComponent_GetLaunchSpeed");
static_assert(sizeof(GzChargeableAbilityComponent_GetLaunchSpeed) == 0x000004, "Wrong size on GzChargeableAbilityComponent_GetLaunchSpeed");
static_assert(offsetof(GzChargeableAbilityComponent_GetLaunchSpeed, ReturnValue) == 0x000000, "Member 'GzChargeableAbilityComponent_GetLaunchSpeed::ReturnValue' has a wrong offset!");

// Function G01.GzChargeableAbilityComponent.GetLaunchWorldLocation
// 0x0018 (0x0018 - 0x0000)
struct GzChargeableAbilityComponent_GetLaunchWorldLocation final
{
public:
	struct FVector                                ReturnValue;                                       // 0x0000(0x0018)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzChargeableAbilityComponent_GetLaunchWorldLocation) == 0x000008, "Wrong alignment on GzChargeableAbilityComponent_GetLaunchWorldLocation");
static_assert(sizeof(GzChargeableAbilityComponent_GetLaunchWorldLocation) == 0x000018, "Wrong size on GzChargeableAbilityComponent_GetLaunchWorldLocation");
static_assert(offsetof(GzChargeableAbilityComponent_GetLaunchWorldLocation, ReturnValue) == 0x000000, "Member 'GzChargeableAbilityComponent_GetLaunchWorldLocation::ReturnValue' has a wrong offset!");

// Function G01.GzChargeableAbilityComponent.GetLaunchWorldLocation_Offset
// 0x0018 (0x0018 - 0x0000)
struct GzChargeableAbilityComponent_GetLaunchWorldLocation_Offset final
{
public:
	struct FVector                                ReturnValue;                                       // 0x0000(0x0018)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzChargeableAbilityComponent_GetLaunchWorldLocation_Offset) == 0x000008, "Wrong alignment on GzChargeableAbilityComponent_GetLaunchWorldLocation_Offset");
static_assert(sizeof(GzChargeableAbilityComponent_GetLaunchWorldLocation_Offset) == 0x000018, "Wrong size on GzChargeableAbilityComponent_GetLaunchWorldLocation_Offset");
static_assert(offsetof(GzChargeableAbilityComponent_GetLaunchWorldLocation_Offset, ReturnValue) == 0x000000, "Member 'GzChargeableAbilityComponent_GetLaunchWorldLocation_Offset::ReturnValue' has a wrong offset!");

// Function G01.GzChargeableAbilityComponent.GetLaunchWorldLocation_Socket
// 0x0018 (0x0018 - 0x0000)
struct GzChargeableAbilityComponent_GetLaunchWorldLocation_Socket final
{
public:
	struct FVector                                ReturnValue;                                       // 0x0000(0x0018)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzChargeableAbilityComponent_GetLaunchWorldLocation_Socket) == 0x000008, "Wrong alignment on GzChargeableAbilityComponent_GetLaunchWorldLocation_Socket");
static_assert(sizeof(GzChargeableAbilityComponent_GetLaunchWorldLocation_Socket) == 0x000018, "Wrong size on GzChargeableAbilityComponent_GetLaunchWorldLocation_Socket");
static_assert(offsetof(GzChargeableAbilityComponent_GetLaunchWorldLocation_Socket, ReturnValue) == 0x000000, "Member 'GzChargeableAbilityComponent_GetLaunchWorldLocation_Socket::ReturnValue' has a wrong offset!");

// Function G01.GzChargeableAbilityComponent.GetProjectileGravityMultiplier
// 0x0004 (0x0004 - 0x0000)
struct GzChargeableAbilityComponent_GetProjectileGravityMultiplier final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzChargeableAbilityComponent_GetProjectileGravityMultiplier) == 0x000004, "Wrong alignment on GzChargeableAbilityComponent_GetProjectileGravityMultiplier");
static_assert(sizeof(GzChargeableAbilityComponent_GetProjectileGravityMultiplier) == 0x000004, "Wrong size on GzChargeableAbilityComponent_GetProjectileGravityMultiplier");
static_assert(offsetof(GzChargeableAbilityComponent_GetProjectileGravityMultiplier, ReturnValue) == 0x000000, "Member 'GzChargeableAbilityComponent_GetProjectileGravityMultiplier::ReturnValue' has a wrong offset!");

// Function G01.GzChargeableAbilityComponent.IsCharging
// 0x0001 (0x0001 - 0x0000)
struct GzChargeableAbilityComponent_IsCharging final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzChargeableAbilityComponent_IsCharging) == 0x000001, "Wrong alignment on GzChargeableAbilityComponent_IsCharging");
static_assert(sizeof(GzChargeableAbilityComponent_IsCharging) == 0x000001, "Wrong size on GzChargeableAbilityComponent_IsCharging");
static_assert(offsetof(GzChargeableAbilityComponent_IsCharging, ReturnValue) == 0x000000, "Member 'GzChargeableAbilityComponent_IsCharging::ReturnValue' has a wrong offset!");

// Function G01.GzChargeableAbilityComponent.ShouldIgnoreActorForAimAssist
// 0x0010 (0x0010 - 0x0000)
struct GzChargeableAbilityComponent_ShouldIgnoreActorForAimAssist final
{
public:
	class AActor*                                 Actor;                                             // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_305D[0x7];                                     // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GzChargeableAbilityComponent_ShouldIgnoreActorForAimAssist) == 0x000008, "Wrong alignment on GzChargeableAbilityComponent_ShouldIgnoreActorForAimAssist");
static_assert(sizeof(GzChargeableAbilityComponent_ShouldIgnoreActorForAimAssist) == 0x000010, "Wrong size on GzChargeableAbilityComponent_ShouldIgnoreActorForAimAssist");
static_assert(offsetof(GzChargeableAbilityComponent_ShouldIgnoreActorForAimAssist, Actor) == 0x000000, "Member 'GzChargeableAbilityComponent_ShouldIgnoreActorForAimAssist::Actor' has a wrong offset!");
static_assert(offsetof(GzChargeableAbilityComponent_ShouldIgnoreActorForAimAssist, ReturnValue) == 0x000008, "Member 'GzChargeableAbilityComponent_ShouldIgnoreActorForAimAssist::ReturnValue' has a wrong offset!");

// Function G01.GzGorillaArmComponent.GetDashDirectionAndLocation
// 0x0030 (0x0030 - 0x0000)
struct GzGorillaArmComponent_GetDashDirectionAndLocation final
{
public:
	struct FVector                                OutDirection;                                      // 0x0000(0x0018)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                OutLocation;                                       // 0x0018(0x0018)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzGorillaArmComponent_GetDashDirectionAndLocation) == 0x000008, "Wrong alignment on GzGorillaArmComponent_GetDashDirectionAndLocation");
static_assert(sizeof(GzGorillaArmComponent_GetDashDirectionAndLocation) == 0x000030, "Wrong size on GzGorillaArmComponent_GetDashDirectionAndLocation");
static_assert(offsetof(GzGorillaArmComponent_GetDashDirectionAndLocation, OutDirection) == 0x000000, "Member 'GzGorillaArmComponent_GetDashDirectionAndLocation::OutDirection' has a wrong offset!");
static_assert(offsetof(GzGorillaArmComponent_GetDashDirectionAndLocation, OutLocation) == 0x000018, "Member 'GzGorillaArmComponent_GetDashDirectionAndLocation::OutLocation' has a wrong offset!");

// Function G01.GzHUDStatesSubsystem.OnComebackArenaStateChanged
// 0x0008 (0x0008 - 0x0000)
struct GzHUDStatesSubsystem_OnComebackArenaStateChanged final
{
public:
	class AGzPlayerState*                         PlayerState;                                       // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzHUDStatesSubsystem_OnComebackArenaStateChanged) == 0x000008, "Wrong alignment on GzHUDStatesSubsystem_OnComebackArenaStateChanged");
static_assert(sizeof(GzHUDStatesSubsystem_OnComebackArenaStateChanged) == 0x000008, "Wrong size on GzHUDStatesSubsystem_OnComebackArenaStateChanged");
static_assert(offsetof(GzHUDStatesSubsystem_OnComebackArenaStateChanged, PlayerState) == 0x000000, "Member 'GzHUDStatesSubsystem_OnComebackArenaStateChanged::PlayerState' has a wrong offset!");

// Function G01.GzHUDStatesSubsystem.OnDeploymentStateChanged
// 0x0001 (0x0001 - 0x0000)
struct GzHUDStatesSubsystem_OnDeploymentStateChanged final
{
public:
	bool                                          bEnabled;                                          // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzHUDStatesSubsystem_OnDeploymentStateChanged) == 0x000001, "Wrong alignment on GzHUDStatesSubsystem_OnDeploymentStateChanged");
static_assert(sizeof(GzHUDStatesSubsystem_OnDeploymentStateChanged) == 0x000001, "Wrong size on GzHUDStatesSubsystem_OnDeploymentStateChanged");
static_assert(offsetof(GzHUDStatesSubsystem_OnDeploymentStateChanged, bEnabled) == 0x000000, "Member 'GzHUDStatesSubsystem_OnDeploymentStateChanged::bEnabled' has a wrong offset!");

// Function G01.GzHUDStatesSubsystem.OnPlayerTagsChanged
// 0x000C (0x000C - 0x0000)
struct GzHUDStatesSubsystem_OnPlayerTagsChanged final
{
public:
	struct FGameplayTag                           GameplayTag;                                       // 0x0000(0x0008)(Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Count;                                             // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzHUDStatesSubsystem_OnPlayerTagsChanged) == 0x000004, "Wrong alignment on GzHUDStatesSubsystem_OnPlayerTagsChanged");
static_assert(sizeof(GzHUDStatesSubsystem_OnPlayerTagsChanged) == 0x00000C, "Wrong size on GzHUDStatesSubsystem_OnPlayerTagsChanged");
static_assert(offsetof(GzHUDStatesSubsystem_OnPlayerTagsChanged, GameplayTag) == 0x000000, "Member 'GzHUDStatesSubsystem_OnPlayerTagsChanged::GameplayTag' has a wrong offset!");
static_assert(offsetof(GzHUDStatesSubsystem_OnPlayerTagsChanged, Count) == 0x000008, "Member 'GzHUDStatesSubsystem_OnPlayerTagsChanged::Count' has a wrong offset!");

// Function G01.GzHUDStatesSubsystem.OnSpectatingKillerChanged
// 0x0001 (0x0001 - 0x0000)
struct GzHUDStatesSubsystem_OnSpectatingKillerChanged final
{
public:
	bool                                          bSpectatingKiller;                                 // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzHUDStatesSubsystem_OnSpectatingKillerChanged) == 0x000001, "Wrong alignment on GzHUDStatesSubsystem_OnSpectatingKillerChanged");
static_assert(sizeof(GzHUDStatesSubsystem_OnSpectatingKillerChanged) == 0x000001, "Wrong size on GzHUDStatesSubsystem_OnSpectatingKillerChanged");
static_assert(offsetof(GzHUDStatesSubsystem_OnSpectatingKillerChanged, bSpectatingKiller) == 0x000000, "Member 'GzHUDStatesSubsystem_OnSpectatingKillerChanged::bSpectatingKiller' has a wrong offset!");

// Function G01.GzHUDStatesSubsystem.OnVehicleSeatChanged
// 0x0010 (0x0010 - 0x0000)
struct GzHUDStatesSubsystem_OnVehicleSeatChanged final
{
public:
	class AGzCharacter*                           Character;                                         // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EGzVehicleSeatType                            NewSeat;                                           // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EGzVehicleSeatType                            OldSeat;                                           // 0x0009(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3061[0x6];                                     // 0x000A(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GzHUDStatesSubsystem_OnVehicleSeatChanged) == 0x000008, "Wrong alignment on GzHUDStatesSubsystem_OnVehicleSeatChanged");
static_assert(sizeof(GzHUDStatesSubsystem_OnVehicleSeatChanged) == 0x000010, "Wrong size on GzHUDStatesSubsystem_OnVehicleSeatChanged");
static_assert(offsetof(GzHUDStatesSubsystem_OnVehicleSeatChanged, Character) == 0x000000, "Member 'GzHUDStatesSubsystem_OnVehicleSeatChanged::Character' has a wrong offset!");
static_assert(offsetof(GzHUDStatesSubsystem_OnVehicleSeatChanged, NewSeat) == 0x000008, "Member 'GzHUDStatesSubsystem_OnVehicleSeatChanged::NewSeat' has a wrong offset!");
static_assert(offsetof(GzHUDStatesSubsystem_OnVehicleSeatChanged, OldSeat) == 0x000009, "Member 'GzHUDStatesSubsystem_OnVehicleSeatChanged::OldSeat' has a wrong offset!");

// Function G01.GzHUDStatesSubsystem.OnViewTargetChanged
// 0x0008 (0x0008 - 0x0000)
struct GzHUDStatesSubsystem_OnViewTargetChanged final
{
public:
	class APawn*                                  NewViewTarget;                                     // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzHUDStatesSubsystem_OnViewTargetChanged) == 0x000008, "Wrong alignment on GzHUDStatesSubsystem_OnViewTargetChanged");
static_assert(sizeof(GzHUDStatesSubsystem_OnViewTargetChanged) == 0x000008, "Wrong size on GzHUDStatesSubsystem_OnViewTargetChanged");
static_assert(offsetof(GzHUDStatesSubsystem_OnViewTargetChanged, NewViewTarget) == 0x000000, "Member 'GzHUDStatesSubsystem_OnViewTargetChanged::NewViewTarget' has a wrong offset!");

// Function G01.GzHUDStatesSubsystem.OnViewTargetWeaponChanged
// 0x0010 (0x0010 - 0x0000)
struct GzHUDStatesSubsystem_OnViewTargetWeaponChanged final
{
public:
	struct FGzInvPocketId                         PocketId;                                          // 0x0000(0x0008)(Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AGzWeaponActor*                         WeaponActor;                                       // 0x0008(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzHUDStatesSubsystem_OnViewTargetWeaponChanged) == 0x000008, "Wrong alignment on GzHUDStatesSubsystem_OnViewTargetWeaponChanged");
static_assert(sizeof(GzHUDStatesSubsystem_OnViewTargetWeaponChanged) == 0x000010, "Wrong size on GzHUDStatesSubsystem_OnViewTargetWeaponChanged");
static_assert(offsetof(GzHUDStatesSubsystem_OnViewTargetWeaponChanged, PocketId) == 0x000000, "Member 'GzHUDStatesSubsystem_OnViewTargetWeaponChanged::PocketId' has a wrong offset!");
static_assert(offsetof(GzHUDStatesSubsystem_OnViewTargetWeaponChanged, WeaponActor) == 0x000008, "Member 'GzHUDStatesSubsystem_OnViewTargetWeaponChanged::WeaponActor' has a wrong offset!");

// Function G01.GzVehiclesCheatExtension.SpawnVehicle
// 0x0004 (0x0004 - 0x0000)
struct GzVehiclesCheatExtension_SpawnVehicle final
{
public:
	int32                                         VehicleClassIndex;                                 // 0x0000(0x0004)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzVehiclesCheatExtension_SpawnVehicle) == 0x000004, "Wrong alignment on GzVehiclesCheatExtension_SpawnVehicle");
static_assert(sizeof(GzVehiclesCheatExtension_SpawnVehicle) == 0x000004, "Wrong size on GzVehiclesCheatExtension_SpawnVehicle");
static_assert(offsetof(GzVehiclesCheatExtension_SpawnVehicle, VehicleClassIndex) == 0x000000, "Member 'GzVehiclesCheatExtension_SpawnVehicle::VehicleClassIndex' has a wrong offset!");

// Function G01.GzMapController.CreateControllerForMap
// 0x0020 (0x0020 - 0x0000)
struct GzMapController_CreateControllerForMap final
{
public:
	class UObject*                                Parent;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UGzMapWidget*                           Param_MapWidget;                                   // 0x0008(0x0008)(Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UGzMapController>           ControllerType;                                    // 0x0010(0x0008)(Parm, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UGzMapController*                       ReturnValue;                                       // 0x0018(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzMapController_CreateControllerForMap) == 0x000008, "Wrong alignment on GzMapController_CreateControllerForMap");
static_assert(sizeof(GzMapController_CreateControllerForMap) == 0x000020, "Wrong size on GzMapController_CreateControllerForMap");
static_assert(offsetof(GzMapController_CreateControllerForMap, Parent) == 0x000000, "Member 'GzMapController_CreateControllerForMap::Parent' has a wrong offset!");
static_assert(offsetof(GzMapController_CreateControllerForMap, Param_MapWidget) == 0x000008, "Member 'GzMapController_CreateControllerForMap::Param_MapWidget' has a wrong offset!");
static_assert(offsetof(GzMapController_CreateControllerForMap, ControllerType) == 0x000010, "Member 'GzMapController_CreateControllerForMap::ControllerType' has a wrong offset!");
static_assert(offsetof(GzMapController_CreateControllerForMap, ReturnValue) == 0x000018, "Member 'GzMapController_CreateControllerForMap::ReturnValue' has a wrong offset!");

// Function G01.GzMapController.OnMapClick
// 0x0020 (0x0020 - 0x0000)
struct GzMapController_OnMapClick final
{
public:
	struct FVector2D                              ScreenPosition;                                    // 0x0000(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              WorldPos;                                          // 0x0010(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzMapController_OnMapClick) == 0x000008, "Wrong alignment on GzMapController_OnMapClick");
static_assert(sizeof(GzMapController_OnMapClick) == 0x000020, "Wrong size on GzMapController_OnMapClick");
static_assert(offsetof(GzMapController_OnMapClick, ScreenPosition) == 0x000000, "Member 'GzMapController_OnMapClick::ScreenPosition' has a wrong offset!");
static_assert(offsetof(GzMapController_OnMapClick, WorldPos) == 0x000010, "Member 'GzMapController_OnMapClick::WorldPos' has a wrong offset!");

// Function G01.GzMapController.OnMapDoubleClick
// 0x0020 (0x0020 - 0x0000)
struct GzMapController_OnMapDoubleClick final
{
public:
	struct FVector2D                              Vector2D;                                          // 0x0000(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              WorldPos;                                          // 0x0010(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzMapController_OnMapDoubleClick) == 0x000008, "Wrong alignment on GzMapController_OnMapDoubleClick");
static_assert(sizeof(GzMapController_OnMapDoubleClick) == 0x000020, "Wrong size on GzMapController_OnMapDoubleClick");
static_assert(offsetof(GzMapController_OnMapDoubleClick, Vector2D) == 0x000000, "Member 'GzMapController_OnMapDoubleClick::Vector2D' has a wrong offset!");
static_assert(offsetof(GzMapController_OnMapDoubleClick, WorldPos) == 0x000010, "Member 'GzMapController_OnMapDoubleClick::WorldPos' has a wrong offset!");

// Function G01.GzMapController.OnMapHover
// 0x0020 (0x0020 - 0x0000)
struct GzMapController_OnMapHover final
{
public:
	struct FVector2D                              Vector2D;                                          // 0x0000(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              WorldPos;                                          // 0x0010(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzMapController_OnMapHover) == 0x000008, "Wrong alignment on GzMapController_OnMapHover");
static_assert(sizeof(GzMapController_OnMapHover) == 0x000020, "Wrong size on GzMapController_OnMapHover");
static_assert(offsetof(GzMapController_OnMapHover, Vector2D) == 0x000000, "Member 'GzMapController_OnMapHover::Vector2D' has a wrong offset!");
static_assert(offsetof(GzMapController_OnMapHover, WorldPos) == 0x000010, "Member 'GzMapController_OnMapHover::WorldPos' has a wrong offset!");

// Function G01.GzMapController.OnMouseButtonUp
// 0x0168 (0x0168 - 0x0000)
struct GzMapController_OnMouseButtonUp final
{
public:
	struct FGeometry                              Geometry;                                          // 0x0000(0x0038)(Parm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FPointerEvent                          MouseEvent;                                        // 0x0038(0x0078)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	struct FEventReply                            ReturnValue;                                       // 0x00B0(0x00B8)(Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzMapController_OnMouseButtonUp) == 0x000008, "Wrong alignment on GzMapController_OnMouseButtonUp");
static_assert(sizeof(GzMapController_OnMouseButtonUp) == 0x000168, "Wrong size on GzMapController_OnMouseButtonUp");
static_assert(offsetof(GzMapController_OnMouseButtonUp, Geometry) == 0x000000, "Member 'GzMapController_OnMouseButtonUp::Geometry' has a wrong offset!");
static_assert(offsetof(GzMapController_OnMouseButtonUp, MouseEvent) == 0x000038, "Member 'GzMapController_OnMouseButtonUp::MouseEvent' has a wrong offset!");
static_assert(offsetof(GzMapController_OnMouseButtonUp, ReturnValue) == 0x0000B0, "Member 'GzMapController_OnMouseButtonUp::ReturnValue' has a wrong offset!");

// Function G01.GzMapController.OnPanelDoubleClick
// 0x0168 (0x0168 - 0x0000)
struct GzMapController_OnPanelDoubleClick final
{
public:
	struct FGeometry                              Geometry;                                          // 0x0000(0x0038)(Parm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FPointerEvent                          MouseEvent;                                        // 0x0038(0x0078)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	struct FEventReply                            ReturnValue;                                       // 0x00B0(0x00B8)(Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzMapController_OnPanelDoubleClick) == 0x000008, "Wrong alignment on GzMapController_OnPanelDoubleClick");
static_assert(sizeof(GzMapController_OnPanelDoubleClick) == 0x000168, "Wrong size on GzMapController_OnPanelDoubleClick");
static_assert(offsetof(GzMapController_OnPanelDoubleClick, Geometry) == 0x000000, "Member 'GzMapController_OnPanelDoubleClick::Geometry' has a wrong offset!");
static_assert(offsetof(GzMapController_OnPanelDoubleClick, MouseEvent) == 0x000038, "Member 'GzMapController_OnPanelDoubleClick::MouseEvent' has a wrong offset!");
static_assert(offsetof(GzMapController_OnPanelDoubleClick, ReturnValue) == 0x0000B0, "Member 'GzMapController_OnPanelDoubleClick::ReturnValue' has a wrong offset!");

// Function G01.GzMapController.OnPanelHover
// 0x0168 (0x0168 - 0x0000)
struct GzMapController_OnPanelHover final
{
public:
	struct FGeometry                              Geometry;                                          // 0x0000(0x0038)(Parm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FPointerEvent                          MouseEvent;                                        // 0x0038(0x0078)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	struct FEventReply                            ReturnValue;                                       // 0x00B0(0x00B8)(Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzMapController_OnPanelHover) == 0x000008, "Wrong alignment on GzMapController_OnPanelHover");
static_assert(sizeof(GzMapController_OnPanelHover) == 0x000168, "Wrong size on GzMapController_OnPanelHover");
static_assert(offsetof(GzMapController_OnPanelHover, Geometry) == 0x000000, "Member 'GzMapController_OnPanelHover::Geometry' has a wrong offset!");
static_assert(offsetof(GzMapController_OnPanelHover, MouseEvent) == 0x000038, "Member 'GzMapController_OnPanelHover::MouseEvent' has a wrong offset!");
static_assert(offsetof(GzMapController_OnPanelHover, ReturnValue) == 0x0000B0, "Member 'GzMapController_OnPanelHover::ReturnValue' has a wrong offset!");

// Function G01.GzMapController.OnTick
// 0x0004 (0x0004 - 0x0000)
struct GzMapController_OnTick final
{
public:
	float                                         DeltaTime;                                         // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzMapController_OnTick) == 0x000004, "Wrong alignment on GzMapController_OnTick");
static_assert(sizeof(GzMapController_OnTick) == 0x000004, "Wrong size on GzMapController_OnTick");
static_assert(offsetof(GzMapController_OnTick, DeltaTime) == 0x000000, "Member 'GzMapController_OnTick::DeltaTime' has a wrong offset!");

// Function G01.GzMapController.OnZoneClick
// 0x0028 (0x0028 - 0x0000)
struct GzMapController_OnZoneClick final
{
public:
	class UGzMapZoneWidget*                       ZoneWidget;                                        // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              Vector2D;                                          // 0x0008(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              WorldPos;                                          // 0x0018(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzMapController_OnZoneClick) == 0x000008, "Wrong alignment on GzMapController_OnZoneClick");
static_assert(sizeof(GzMapController_OnZoneClick) == 0x000028, "Wrong size on GzMapController_OnZoneClick");
static_assert(offsetof(GzMapController_OnZoneClick, ZoneWidget) == 0x000000, "Member 'GzMapController_OnZoneClick::ZoneWidget' has a wrong offset!");
static_assert(offsetof(GzMapController_OnZoneClick, Vector2D) == 0x000008, "Member 'GzMapController_OnZoneClick::Vector2D' has a wrong offset!");
static_assert(offsetof(GzMapController_OnZoneClick, WorldPos) == 0x000018, "Member 'GzMapController_OnZoneClick::WorldPos' has a wrong offset!");

// Function G01.GzMapController.OnZoneDoubleClick
// 0x0028 (0x0028 - 0x0000)
struct GzMapController_OnZoneDoubleClick final
{
public:
	class UGzMapZoneWidget*                       ZoneWidget;                                        // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              Vector2D;                                          // 0x0008(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              WorldPos;                                          // 0x0018(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzMapController_OnZoneDoubleClick) == 0x000008, "Wrong alignment on GzMapController_OnZoneDoubleClick");
static_assert(sizeof(GzMapController_OnZoneDoubleClick) == 0x000028, "Wrong size on GzMapController_OnZoneDoubleClick");
static_assert(offsetof(GzMapController_OnZoneDoubleClick, ZoneWidget) == 0x000000, "Member 'GzMapController_OnZoneDoubleClick::ZoneWidget' has a wrong offset!");
static_assert(offsetof(GzMapController_OnZoneDoubleClick, Vector2D) == 0x000008, "Member 'GzMapController_OnZoneDoubleClick::Vector2D' has a wrong offset!");
static_assert(offsetof(GzMapController_OnZoneDoubleClick, WorldPos) == 0x000018, "Member 'GzMapController_OnZoneDoubleClick::WorldPos' has a wrong offset!");

// Function G01.GzMapController.OnZoneEndHover
// 0x0008 (0x0008 - 0x0000)
struct GzMapController_OnZoneEndHover final
{
public:
	class UGzMapZoneWidget*                       ZoneWidget;                                        // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzMapController_OnZoneEndHover) == 0x000008, "Wrong alignment on GzMapController_OnZoneEndHover");
static_assert(sizeof(GzMapController_OnZoneEndHover) == 0x000008, "Wrong size on GzMapController_OnZoneEndHover");
static_assert(offsetof(GzMapController_OnZoneEndHover, ZoneWidget) == 0x000000, "Member 'GzMapController_OnZoneEndHover::ZoneWidget' has a wrong offset!");

// Function G01.GzMapController.OnZoneStartHover
// 0x0028 (0x0028 - 0x0000)
struct GzMapController_OnZoneStartHover final
{
public:
	class UGzMapZoneWidget*                       ZoneWidget;                                        // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              Vector2D;                                          // 0x0008(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              WorldPos;                                          // 0x0018(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzMapController_OnZoneStartHover) == 0x000008, "Wrong alignment on GzMapController_OnZoneStartHover");
static_assert(sizeof(GzMapController_OnZoneStartHover) == 0x000028, "Wrong size on GzMapController_OnZoneStartHover");
static_assert(offsetof(GzMapController_OnZoneStartHover, ZoneWidget) == 0x000000, "Member 'GzMapController_OnZoneStartHover::ZoneWidget' has a wrong offset!");
static_assert(offsetof(GzMapController_OnZoneStartHover, Vector2D) == 0x000008, "Member 'GzMapController_OnZoneStartHover::Vector2D' has a wrong offset!");
static_assert(offsetof(GzMapController_OnZoneStartHover, WorldPos) == 0x000018, "Member 'GzMapController_OnZoneStartHover::WorldPos' has a wrong offset!");

// Function G01.GzMapController.SetMapCenter
// 0x0010 (0x0010 - 0x0000)
struct GzMapController_SetMapCenter final
{
public:
	struct FVector2D                              Center;                                            // 0x0000(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzMapController_SetMapCenter) == 0x000008, "Wrong alignment on GzMapController_SetMapCenter");
static_assert(sizeof(GzMapController_SetMapCenter) == 0x000010, "Wrong size on GzMapController_SetMapCenter");
static_assert(offsetof(GzMapController_SetMapCenter, Center) == 0x000000, "Member 'GzMapController_SetMapCenter::Center' has a wrong offset!");

// Function G01.GzMapController.SetMapRotation
// 0x0004 (0x0004 - 0x0000)
struct GzMapController_SetMapRotation final
{
public:
	float                                         RotationAngle;                                     // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzMapController_SetMapRotation) == 0x000004, "Wrong alignment on GzMapController_SetMapRotation");
static_assert(sizeof(GzMapController_SetMapRotation) == 0x000004, "Wrong size on GzMapController_SetMapRotation");
static_assert(offsetof(GzMapController_SetMapRotation, RotationAngle) == 0x000000, "Member 'GzMapController_SetMapRotation::RotationAngle' has a wrong offset!");

// Function G01.GzMapController.SetMapZoom
// 0x0004 (0x0004 - 0x0000)
struct GzMapController_SetMapZoom final
{
public:
	float                                         Zoom;                                              // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzMapController_SetMapZoom) == 0x000004, "Wrong alignment on GzMapController_SetMapZoom");
static_assert(sizeof(GzMapController_SetMapZoom) == 0x000004, "Wrong size on GzMapController_SetMapZoom");
static_assert(offsetof(GzMapController_SetMapZoom, Zoom) == 0x000000, "Member 'GzMapController_SetMapZoom::Zoom' has a wrong offset!");

// Function G01.GzMapController.CanInteractWithZone
// 0x000C (0x000C - 0x0000)
struct GzMapController_CanInteractWithZone final
{
public:
	class FName                                   ZoneName;                                          // 0x0000(0x0008)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_306B[0x3];                                     // 0x0009(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GzMapController_CanInteractWithZone) == 0x000004, "Wrong alignment on GzMapController_CanInteractWithZone");
static_assert(sizeof(GzMapController_CanInteractWithZone) == 0x00000C, "Wrong size on GzMapController_CanInteractWithZone");
static_assert(offsetof(GzMapController_CanInteractWithZone, ZoneName) == 0x000000, "Member 'GzMapController_CanInteractWithZone::ZoneName' has a wrong offset!");
static_assert(offsetof(GzMapController_CanInteractWithZone, ReturnValue) == 0x000008, "Member 'GzMapController_CanInteractWithZone::ReturnValue' has a wrong offset!");

// Function G01.GzMapController.GetMapWidget
// 0x0008 (0x0008 - 0x0000)
struct GzMapController_GetMapWidget final
{
public:
	class UGzMapWidget*                           ReturnValue;                                       // 0x0000(0x0008)(ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzMapController_GetMapWidget) == 0x000008, "Wrong alignment on GzMapController_GetMapWidget");
static_assert(sizeof(GzMapController_GetMapWidget) == 0x000008, "Wrong size on GzMapController_GetMapWidget");
static_assert(offsetof(GzMapController_GetMapWidget, ReturnValue) == 0x000000, "Member 'GzMapController_GetMapWidget::ReturnValue' has a wrong offset!");

// Function G01.GzMapController.GetMapWidth
// 0x0004 (0x0004 - 0x0000)
struct GzMapController_GetMapWidth final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzMapController_GetMapWidth) == 0x000004, "Wrong alignment on GzMapController_GetMapWidth");
static_assert(sizeof(GzMapController_GetMapWidth) == 0x000004, "Wrong size on GzMapController_GetMapWidth");
static_assert(offsetof(GzMapController_GetMapWidth, ReturnValue) == 0x000000, "Member 'GzMapController_GetMapWidth::ReturnValue' has a wrong offset!");

// Function G01.GzXRZoneExtension.OnStageChanged
// 0x0004 (0x0004 - 0x0000)
struct GzXRZoneExtension_OnStageChanged final
{
public:
	int32                                         StageIndex;                                        // 0x0000(0x0004)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzXRZoneExtension_OnStageChanged) == 0x000004, "Wrong alignment on GzXRZoneExtension_OnStageChanged");
static_assert(sizeof(GzXRZoneExtension_OnStageChanged) == 0x000004, "Wrong size on GzXRZoneExtension_OnStageChanged");
static_assert(offsetof(GzXRZoneExtension_OnStageChanged, StageIndex) == 0x000000, "Member 'GzXRZoneExtension_OnStageChanged::StageIndex' has a wrong offset!");

// Function G01.GzXRZoneExtension.OnZoneAvailable
// 0x0008 (0x0008 - 0x0000)
struct GzXRZoneExtension_OnZoneAvailable final
{
public:
	class AGzShrinkingZone*                       Zone;                                              // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzXRZoneExtension_OnZoneAvailable) == 0x000008, "Wrong alignment on GzXRZoneExtension_OnZoneAvailable");
static_assert(sizeof(GzXRZoneExtension_OnZoneAvailable) == 0x000008, "Wrong size on GzXRZoneExtension_OnZoneAvailable");
static_assert(offsetof(GzXRZoneExtension_OnZoneAvailable, Zone) == 0x000000, "Member 'GzXRZoneExtension_OnZoneAvailable::Zone' has a wrong offset!");

// Function G01.GzVoiceChatStateWidget.OnControllerInit
// 0x0010 (0x0010 - 0x0000)
struct GzVoiceChatStateWidget_OnControllerInit final
{
public:
	class AGzPlayerController*                    PlayerController;                                  // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AGzPlayerState*                         PlayerState;                                       // 0x0008(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzVoiceChatStateWidget_OnControllerInit) == 0x000008, "Wrong alignment on GzVoiceChatStateWidget_OnControllerInit");
static_assert(sizeof(GzVoiceChatStateWidget_OnControllerInit) == 0x000010, "Wrong size on GzVoiceChatStateWidget_OnControllerInit");
static_assert(offsetof(GzVoiceChatStateWidget_OnControllerInit, PlayerController) == 0x000000, "Member 'GzVoiceChatStateWidget_OnControllerInit::PlayerController' has a wrong offset!");
static_assert(offsetof(GzVoiceChatStateWidget_OnControllerInit, PlayerState) == 0x000008, "Member 'GzVoiceChatStateWidget_OnControllerInit::PlayerState' has a wrong offset!");

// Function G01.GzVoiceChatStateWidget.OnLocalPlayerTeamChanged
// 0x0008 (0x0008 - 0x0000)
struct GzVoiceChatStateWidget_OnLocalPlayerTeamChanged final
{
public:
	class AGzPlayerState*                         PlayerState;                                       // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzVoiceChatStateWidget_OnLocalPlayerTeamChanged) == 0x000008, "Wrong alignment on GzVoiceChatStateWidget_OnLocalPlayerTeamChanged");
static_assert(sizeof(GzVoiceChatStateWidget_OnLocalPlayerTeamChanged) == 0x000008, "Wrong size on GzVoiceChatStateWidget_OnLocalPlayerTeamChanged");
static_assert(offsetof(GzVoiceChatStateWidget_OnLocalPlayerTeamChanged, PlayerState) == 0x000000, "Member 'GzVoiceChatStateWidget_OnLocalPlayerTeamChanged::PlayerState' has a wrong offset!");

// Function G01.GzVoiceChatStateWidget.OnPawnChanged
// 0x0008 (0x0008 - 0x0000)
struct GzVoiceChatStateWidget_OnPawnChanged final
{
public:
	class APawn*                                  Pawn;                                              // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzVoiceChatStateWidget_OnPawnChanged) == 0x000008, "Wrong alignment on GzVoiceChatStateWidget_OnPawnChanged");
static_assert(sizeof(GzVoiceChatStateWidget_OnPawnChanged) == 0x000008, "Wrong size on GzVoiceChatStateWidget_OnPawnChanged");
static_assert(offsetof(GzVoiceChatStateWidget_OnPawnChanged, Pawn) == 0x000000, "Member 'GzVoiceChatStateWidget_OnPawnChanged::Pawn' has a wrong offset!");

// Function G01.GzVoiceChatStateWidget.OnTalkerAdded
// 0x0038 (0x0038 - 0x0000)
struct GzVoiceChatStateWidget_OnTalkerAdded final
{
public:
	struct FGzVoiceChatTalker                     NewTalker;                                         // 0x0000(0x0038)(ConstParm, Parm, OutParm, ReferenceParm, ContainsInstancedReference, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzVoiceChatStateWidget_OnTalkerAdded) == 0x000008, "Wrong alignment on GzVoiceChatStateWidget_OnTalkerAdded");
static_assert(sizeof(GzVoiceChatStateWidget_OnTalkerAdded) == 0x000038, "Wrong size on GzVoiceChatStateWidget_OnTalkerAdded");
static_assert(offsetof(GzVoiceChatStateWidget_OnTalkerAdded, NewTalker) == 0x000000, "Member 'GzVoiceChatStateWidget_OnTalkerAdded::NewTalker' has a wrong offset!");

// Function G01.GzVoiceChatStateWidget.SetNormalizedPosition
// 0x0010 (0x0010 - 0x0000)
struct GzVoiceChatStateWidget_SetNormalizedPosition final
{
public:
	struct FVector2D                              InPosition;                                        // 0x0000(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzVoiceChatStateWidget_SetNormalizedPosition) == 0x000008, "Wrong alignment on GzVoiceChatStateWidget_SetNormalizedPosition");
static_assert(sizeof(GzVoiceChatStateWidget_SetNormalizedPosition) == 0x000010, "Wrong size on GzVoiceChatStateWidget_SetNormalizedPosition");
static_assert(offsetof(GzVoiceChatStateWidget_SetNormalizedPosition, InPosition) == 0x000000, "Member 'GzVoiceChatStateWidget_SetNormalizedPosition::InPosition' has a wrong offset!");

// Function G01.GzInteriorCameraVolume.OnBeginOverlap
// 0x0118 (0x0118 - 0x0000)
struct GzInteriorCameraVolume_OnBeginOverlap final
{
public:
	class UPrimitiveComponent*                    OverlappedComponent;                               // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 OtherActor;                                        // 0x0008(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UPrimitiveComponent*                    OtherComp;                                         // 0x0010(0x0008)(Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         OtherBodyIndex;                                    // 0x0018(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bFromSweep;                                        // 0x001C(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3077[0x3];                                     // 0x001D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FHitResult                             SweepResult;                                       // 0x0020(0x00F8)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzInteriorCameraVolume_OnBeginOverlap) == 0x000008, "Wrong alignment on GzInteriorCameraVolume_OnBeginOverlap");
static_assert(sizeof(GzInteriorCameraVolume_OnBeginOverlap) == 0x000118, "Wrong size on GzInteriorCameraVolume_OnBeginOverlap");
static_assert(offsetof(GzInteriorCameraVolume_OnBeginOverlap, OverlappedComponent) == 0x000000, "Member 'GzInteriorCameraVolume_OnBeginOverlap::OverlappedComponent' has a wrong offset!");
static_assert(offsetof(GzInteriorCameraVolume_OnBeginOverlap, OtherActor) == 0x000008, "Member 'GzInteriorCameraVolume_OnBeginOverlap::OtherActor' has a wrong offset!");
static_assert(offsetof(GzInteriorCameraVolume_OnBeginOverlap, OtherComp) == 0x000010, "Member 'GzInteriorCameraVolume_OnBeginOverlap::OtherComp' has a wrong offset!");
static_assert(offsetof(GzInteriorCameraVolume_OnBeginOverlap, OtherBodyIndex) == 0x000018, "Member 'GzInteriorCameraVolume_OnBeginOverlap::OtherBodyIndex' has a wrong offset!");
static_assert(offsetof(GzInteriorCameraVolume_OnBeginOverlap, bFromSweep) == 0x00001C, "Member 'GzInteriorCameraVolume_OnBeginOverlap::bFromSweep' has a wrong offset!");
static_assert(offsetof(GzInteriorCameraVolume_OnBeginOverlap, SweepResult) == 0x000020, "Member 'GzInteriorCameraVolume_OnBeginOverlap::SweepResult' has a wrong offset!");

// Function G01.GzInteriorCameraVolume.OnEndOverlap
// 0x0020 (0x0020 - 0x0000)
struct GzInteriorCameraVolume_OnEndOverlap final
{
public:
	class UPrimitiveComponent*                    OverlappedComponent;                               // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 OtherActor;                                        // 0x0008(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UPrimitiveComponent*                    OtherComp;                                         // 0x0010(0x0008)(Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         OtherBodyIndex;                                    // 0x0018(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3078[0x4];                                     // 0x001C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GzInteriorCameraVolume_OnEndOverlap) == 0x000008, "Wrong alignment on GzInteriorCameraVolume_OnEndOverlap");
static_assert(sizeof(GzInteriorCameraVolume_OnEndOverlap) == 0x000020, "Wrong size on GzInteriorCameraVolume_OnEndOverlap");
static_assert(offsetof(GzInteriorCameraVolume_OnEndOverlap, OverlappedComponent) == 0x000000, "Member 'GzInteriorCameraVolume_OnEndOverlap::OverlappedComponent' has a wrong offset!");
static_assert(offsetof(GzInteriorCameraVolume_OnEndOverlap, OtherActor) == 0x000008, "Member 'GzInteriorCameraVolume_OnEndOverlap::OtherActor' has a wrong offset!");
static_assert(offsetof(GzInteriorCameraVolume_OnEndOverlap, OtherComp) == 0x000010, "Member 'GzInteriorCameraVolume_OnEndOverlap::OtherComp' has a wrong offset!");
static_assert(offsetof(GzInteriorCameraVolume_OnEndOverlap, OtherBodyIndex) == 0x000018, "Member 'GzInteriorCameraVolume_OnEndOverlap::OtherBodyIndex' has a wrong offset!");

// Function G01.GzBoundaryZone.GetTeamSpawnPoints
// 0x0020 (0x0020 - 0x0000)
struct GzBoundaryZone_GetTeamSpawnPoints final
{
public:
	float                                         TeammatesSpawnOffset;                              // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         TeammatesCount;                                    // 0x0004(0x0004)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SpawnHeight;                                       // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxDistFromCenter;                                 // 0x000C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGzTeamSpawnPoints                     ReturnValue;                                       // 0x0010(0x0010)(Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzBoundaryZone_GetTeamSpawnPoints) == 0x000008, "Wrong alignment on GzBoundaryZone_GetTeamSpawnPoints");
static_assert(sizeof(GzBoundaryZone_GetTeamSpawnPoints) == 0x000020, "Wrong size on GzBoundaryZone_GetTeamSpawnPoints");
static_assert(offsetof(GzBoundaryZone_GetTeamSpawnPoints, TeammatesSpawnOffset) == 0x000000, "Member 'GzBoundaryZone_GetTeamSpawnPoints::TeammatesSpawnOffset' has a wrong offset!");
static_assert(offsetof(GzBoundaryZone_GetTeamSpawnPoints, TeammatesCount) == 0x000004, "Member 'GzBoundaryZone_GetTeamSpawnPoints::TeammatesCount' has a wrong offset!");
static_assert(offsetof(GzBoundaryZone_GetTeamSpawnPoints, SpawnHeight) == 0x000008, "Member 'GzBoundaryZone_GetTeamSpawnPoints::SpawnHeight' has a wrong offset!");
static_assert(offsetof(GzBoundaryZone_GetTeamSpawnPoints, MaxDistFromCenter) == 0x00000C, "Member 'GzBoundaryZone_GetTeamSpawnPoints::MaxDistFromCenter' has a wrong offset!");
static_assert(offsetof(GzBoundaryZone_GetTeamSpawnPoints, ReturnValue) == 0x000010, "Member 'GzBoundaryZone_GetTeamSpawnPoints::ReturnValue' has a wrong offset!");

// Function G01.GzBoundaryZone.SetBounds
// 0x0010 (0x0010 - 0x0000)
struct GzBoundaryZone_SetBounds final
{
public:
	TArray<class FName>                           Zones;                                             // 0x0000(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzBoundaryZone_SetBounds) == 0x000008, "Wrong alignment on GzBoundaryZone_SetBounds");
static_assert(sizeof(GzBoundaryZone_SetBounds) == 0x000010, "Wrong size on GzBoundaryZone_SetBounds");
static_assert(offsetof(GzBoundaryZone_SetBounds, Zones) == 0x000000, "Member 'GzBoundaryZone_SetBounds::Zones' has a wrong offset!");

// Function G01.GzBoundaryZone.IsInsideBoxZoneBounds
// 0x0018 (0x0018 - 0x0000)
struct GzBoundaryZone_IsInsideBoxZoneBounds final
{
public:
	struct FVector2D                              Loc2d;                                             // 0x0000(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0010(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_307B[0x7];                                     // 0x0011(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GzBoundaryZone_IsInsideBoxZoneBounds) == 0x000008, "Wrong alignment on GzBoundaryZone_IsInsideBoxZoneBounds");
static_assert(sizeof(GzBoundaryZone_IsInsideBoxZoneBounds) == 0x000018, "Wrong size on GzBoundaryZone_IsInsideBoxZoneBounds");
static_assert(offsetof(GzBoundaryZone_IsInsideBoxZoneBounds, Loc2d) == 0x000000, "Member 'GzBoundaryZone_IsInsideBoxZoneBounds::Loc2d' has a wrong offset!");
static_assert(offsetof(GzBoundaryZone_IsInsideBoxZoneBounds, ReturnValue) == 0x000010, "Member 'GzBoundaryZone_IsInsideBoxZoneBounds::ReturnValue' has a wrong offset!");

// Function G01.GzSubscriptionManagingComponent.OnSubscriptionsFetchSuccess
// 0x0018 (0x0018 - 0x0000)
struct GzSubscriptionManagingComponent_OnSubscriptionsFetchSuccess final
{
public:
	struct FSubscriptionPlansList                 SubscriptionPlansList;                             // 0x0000(0x0018)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzSubscriptionManagingComponent_OnSubscriptionsFetchSuccess) == 0x000008, "Wrong alignment on GzSubscriptionManagingComponent_OnSubscriptionsFetchSuccess");
static_assert(sizeof(GzSubscriptionManagingComponent_OnSubscriptionsFetchSuccess) == 0x000018, "Wrong size on GzSubscriptionManagingComponent_OnSubscriptionsFetchSuccess");
static_assert(offsetof(GzSubscriptionManagingComponent_OnSubscriptionsFetchSuccess, SubscriptionPlansList) == 0x000000, "Member 'GzSubscriptionManagingComponent_OnSubscriptionsFetchSuccess::SubscriptionPlansList' has a wrong offset!");

// Function G01.GzBR_LootAndShootStage.OnGridOverloadStateChanged
// 0x0001 (0x0001 - 0x0000)
struct GzBR_LootAndShootStage_OnGridOverloadStateChanged final
{
public:
	bool                                          bOverloadActivated;                                // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzBR_LootAndShootStage_OnGridOverloadStateChanged) == 0x000001, "Wrong alignment on GzBR_LootAndShootStage_OnGridOverloadStateChanged");
static_assert(sizeof(GzBR_LootAndShootStage_OnGridOverloadStateChanged) == 0x000001, "Wrong size on GzBR_LootAndShootStage_OnGridOverloadStateChanged");
static_assert(offsetof(GzBR_LootAndShootStage_OnGridOverloadStateChanged, bOverloadActivated) == 0x000000, "Member 'GzBR_LootAndShootStage_OnGridOverloadStateChanged::bOverloadActivated' has a wrong offset!");

// Function G01.GzBR_LootAndShootStage.OnTeamDefeated
// 0x0008 (0x0008 - 0x0000)
struct GzBR_LootAndShootStage_OnTeamDefeated final
{
public:
	class AGzTeam*                                Team;                                              // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzBR_LootAndShootStage_OnTeamDefeated) == 0x000008, "Wrong alignment on GzBR_LootAndShootStage_OnTeamDefeated");
static_assert(sizeof(GzBR_LootAndShootStage_OnTeamDefeated) == 0x000008, "Wrong size on GzBR_LootAndShootStage_OnTeamDefeated");
static_assert(offsetof(GzBR_LootAndShootStage_OnTeamDefeated, Team) == 0x000000, "Member 'GzBR_LootAndShootStage_OnTeamDefeated::Team' has a wrong offset!");

// Function G01.GzBR_MatchInProgressStage.OnTeamChanged
// 0x0010 (0x0010 - 0x0000)
struct GzBR_MatchInProgressStage_OnTeamChanged final
{
public:
	class AGzPlayerState*                         PlayerState;                                       // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         PrevTeamID;                                        // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         NewTeamId;                                         // 0x000C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzBR_MatchInProgressStage_OnTeamChanged) == 0x000008, "Wrong alignment on GzBR_MatchInProgressStage_OnTeamChanged");
static_assert(sizeof(GzBR_MatchInProgressStage_OnTeamChanged) == 0x000010, "Wrong size on GzBR_MatchInProgressStage_OnTeamChanged");
static_assert(offsetof(GzBR_MatchInProgressStage_OnTeamChanged, PlayerState) == 0x000000, "Member 'GzBR_MatchInProgressStage_OnTeamChanged::PlayerState' has a wrong offset!");
static_assert(offsetof(GzBR_MatchInProgressStage_OnTeamChanged, PrevTeamID) == 0x000008, "Member 'GzBR_MatchInProgressStage_OnTeamChanged::PrevTeamID' has a wrong offset!");
static_assert(offsetof(GzBR_MatchInProgressStage_OnTeamChanged, NewTeamId) == 0x00000C, "Member 'GzBR_MatchInProgressStage_OnTeamChanged::NewTeamId' has a wrong offset!");

// Function G01.GzBR_MatchInProgressStage.OnTeamDefeated
// 0x0008 (0x0008 - 0x0000)
struct GzBR_MatchInProgressStage_OnTeamDefeated final
{
public:
	class AGzTeam*                                DefeatedTeam;                                      // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzBR_MatchInProgressStage_OnTeamDefeated) == 0x000008, "Wrong alignment on GzBR_MatchInProgressStage_OnTeamDefeated");
static_assert(sizeof(GzBR_MatchInProgressStage_OnTeamDefeated) == 0x000008, "Wrong size on GzBR_MatchInProgressStage_OnTeamDefeated");
static_assert(offsetof(GzBR_MatchInProgressStage_OnTeamDefeated, DefeatedTeam) == 0x000000, "Member 'GzBR_MatchInProgressStage_OnTeamDefeated::DefeatedTeam' has a wrong offset!");

// Function G01.GzXsollaCoreComponent.LaunchPaymentConsole
// 0x0018 (0x0018 - 0x0000)
struct GzXsollaCoreComponent_LaunchPaymentConsole final
{
public:
	class FString                                 AccessToken;                                       // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         OrderId;                                           // 0x0010(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3086[0x4];                                     // 0x0014(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GzXsollaCoreComponent_LaunchPaymentConsole) == 0x000008, "Wrong alignment on GzXsollaCoreComponent_LaunchPaymentConsole");
static_assert(sizeof(GzXsollaCoreComponent_LaunchPaymentConsole) == 0x000018, "Wrong size on GzXsollaCoreComponent_LaunchPaymentConsole");
static_assert(offsetof(GzXsollaCoreComponent_LaunchPaymentConsole, AccessToken) == 0x000000, "Member 'GzXsollaCoreComponent_LaunchPaymentConsole::AccessToken' has a wrong offset!");
static_assert(offsetof(GzXsollaCoreComponent_LaunchPaymentConsole, OrderId) == 0x000010, "Member 'GzXsollaCoreComponent_LaunchPaymentConsole::OrderId' has a wrong offset!");

// Function G01.GzXsollaCoreComponent.OnGeneralXsollaError
// 0x0018 (0x0018 - 0x0000)
struct GzXsollaCoreComponent_OnGeneralXsollaError final
{
public:
	int32                                         StatusCode;                                        // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ErrorCode;                                         // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 ErrorMessage;                                      // 0x0008(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzXsollaCoreComponent_OnGeneralXsollaError) == 0x000008, "Wrong alignment on GzXsollaCoreComponent_OnGeneralXsollaError");
static_assert(sizeof(GzXsollaCoreComponent_OnGeneralXsollaError) == 0x000018, "Wrong size on GzXsollaCoreComponent_OnGeneralXsollaError");
static_assert(offsetof(GzXsollaCoreComponent_OnGeneralXsollaError, StatusCode) == 0x000000, "Member 'GzXsollaCoreComponent_OnGeneralXsollaError::StatusCode' has a wrong offset!");
static_assert(offsetof(GzXsollaCoreComponent_OnGeneralXsollaError, ErrorCode) == 0x000004, "Member 'GzXsollaCoreComponent_OnGeneralXsollaError::ErrorCode' has a wrong offset!");
static_assert(offsetof(GzXsollaCoreComponent_OnGeneralXsollaError, ErrorMessage) == 0x000008, "Member 'GzXsollaCoreComponent_OnGeneralXsollaError::ErrorMessage' has a wrong offset!");

// Function G01.GzXsollaCoreComponent.OnPaymentBrowserClosed
// 0x0001 (0x0001 - 0x0000)
struct GzXsollaCoreComponent_OnPaymentBrowserClosed final
{
public:
	bool                                          bIsManually;                                       // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzXsollaCoreComponent_OnPaymentBrowserClosed) == 0x000001, "Wrong alignment on GzXsollaCoreComponent_OnPaymentBrowserClosed");
static_assert(sizeof(GzXsollaCoreComponent_OnPaymentBrowserClosed) == 0x000001, "Wrong size on GzXsollaCoreComponent_OnPaymentBrowserClosed");
static_assert(offsetof(GzXsollaCoreComponent_OnPaymentBrowserClosed, bIsManually) == 0x000000, "Member 'GzXsollaCoreComponent_OnPaymentBrowserClosed::bIsManually' has a wrong offset!");

// Function G01.GzVoiceChatHelper.BlockPlayer
// 0x0018 (0x0018 - 0x0000)
struct GzVoiceChatHelper_BlockPlayer final
{
public:
	const class UObject*                          WorldContextObject;                                // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 EpicUserId;                                        // 0x0008(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzVoiceChatHelper_BlockPlayer) == 0x000008, "Wrong alignment on GzVoiceChatHelper_BlockPlayer");
static_assert(sizeof(GzVoiceChatHelper_BlockPlayer) == 0x000018, "Wrong size on GzVoiceChatHelper_BlockPlayer");
static_assert(offsetof(GzVoiceChatHelper_BlockPlayer, WorldContextObject) == 0x000000, "Member 'GzVoiceChatHelper_BlockPlayer::WorldContextObject' has a wrong offset!");
static_assert(offsetof(GzVoiceChatHelper_BlockPlayer, EpicUserId) == 0x000008, "Member 'GzVoiceChatHelper_BlockPlayer::EpicUserId' has a wrong offset!");

// Function G01.GzVoiceChatHelper.GetBlockedPlayers
// 0x0018 (0x0018 - 0x0000)
struct GzVoiceChatHelper_GetBlockedPlayers final
{
public:
	const class UObject*                          WorldContextObject;                                // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class FString>                         ReturnValue;                                       // 0x0008(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzVoiceChatHelper_GetBlockedPlayers) == 0x000008, "Wrong alignment on GzVoiceChatHelper_GetBlockedPlayers");
static_assert(sizeof(GzVoiceChatHelper_GetBlockedPlayers) == 0x000018, "Wrong size on GzVoiceChatHelper_GetBlockedPlayers");
static_assert(offsetof(GzVoiceChatHelper_GetBlockedPlayers, WorldContextObject) == 0x000000, "Member 'GzVoiceChatHelper_GetBlockedPlayers::WorldContextObject' has a wrong offset!");
static_assert(offsetof(GzVoiceChatHelper_GetBlockedPlayers, ReturnValue) == 0x000008, "Member 'GzVoiceChatHelper_GetBlockedPlayers::ReturnValue' has a wrong offset!");

// Function G01.GzVoiceChatHelper.GetInputDevices
// 0x0018 (0x0018 - 0x0000)
struct GzVoiceChatHelper_GetInputDevices final
{
public:
	const class UObject*                          WorldContextObject;                                // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FGzVoiceChatAudioDevice>        Result;                                            // 0x0008(0x0010)(Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzVoiceChatHelper_GetInputDevices) == 0x000008, "Wrong alignment on GzVoiceChatHelper_GetInputDevices");
static_assert(sizeof(GzVoiceChatHelper_GetInputDevices) == 0x000018, "Wrong size on GzVoiceChatHelper_GetInputDevices");
static_assert(offsetof(GzVoiceChatHelper_GetInputDevices, WorldContextObject) == 0x000000, "Member 'GzVoiceChatHelper_GetInputDevices::WorldContextObject' has a wrong offset!");
static_assert(offsetof(GzVoiceChatHelper_GetInputDevices, Result) == 0x000008, "Member 'GzVoiceChatHelper_GetInputDevices::Result' has a wrong offset!");

// Function G01.GzVoiceChatHelper.GetOutputDevices
// 0x0018 (0x0018 - 0x0000)
struct GzVoiceChatHelper_GetOutputDevices final
{
public:
	const class UObject*                          WorldContextObject;                                // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FGzVoiceChatAudioDevice>        Result;                                            // 0x0008(0x0010)(Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzVoiceChatHelper_GetOutputDevices) == 0x000008, "Wrong alignment on GzVoiceChatHelper_GetOutputDevices");
static_assert(sizeof(GzVoiceChatHelper_GetOutputDevices) == 0x000018, "Wrong size on GzVoiceChatHelper_GetOutputDevices");
static_assert(offsetof(GzVoiceChatHelper_GetOutputDevices, WorldContextObject) == 0x000000, "Member 'GzVoiceChatHelper_GetOutputDevices::WorldContextObject' has a wrong offset!");
static_assert(offsetof(GzVoiceChatHelper_GetOutputDevices, Result) == 0x000008, "Member 'GzVoiceChatHelper_GetOutputDevices::Result' has a wrong offset!");

// Function G01.GzVoiceChatHelper.GetVoiceChatEvents
// 0x0010 (0x0010 - 0x0000)
struct GzVoiceChatHelper_GetVoiceChatEvents final
{
public:
	const class UObject*                          WorldContextObject;                                // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UGzVoiceChatBlueprintEventsComponent*   ReturnValue;                                       // 0x0008(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzVoiceChatHelper_GetVoiceChatEvents) == 0x000008, "Wrong alignment on GzVoiceChatHelper_GetVoiceChatEvents");
static_assert(sizeof(GzVoiceChatHelper_GetVoiceChatEvents) == 0x000010, "Wrong size on GzVoiceChatHelper_GetVoiceChatEvents");
static_assert(offsetof(GzVoiceChatHelper_GetVoiceChatEvents, WorldContextObject) == 0x000000, "Member 'GzVoiceChatHelper_GetVoiceChatEvents::WorldContextObject' has a wrong offset!");
static_assert(offsetof(GzVoiceChatHelper_GetVoiceChatEvents, ReturnValue) == 0x000008, "Member 'GzVoiceChatHelper_GetVoiceChatEvents::ReturnValue' has a wrong offset!");

// Function G01.GzVoiceChatHelper.IsPlayerBlocked
// 0x0020 (0x0020 - 0x0000)
struct GzVoiceChatHelper_IsPlayerBlocked final
{
public:
	const class UObject*                          WorldContextObject;                                // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 EpicUserId;                                        // 0x0008(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0018(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3087[0x7];                                     // 0x0019(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GzVoiceChatHelper_IsPlayerBlocked) == 0x000008, "Wrong alignment on GzVoiceChatHelper_IsPlayerBlocked");
static_assert(sizeof(GzVoiceChatHelper_IsPlayerBlocked) == 0x000020, "Wrong size on GzVoiceChatHelper_IsPlayerBlocked");
static_assert(offsetof(GzVoiceChatHelper_IsPlayerBlocked, WorldContextObject) == 0x000000, "Member 'GzVoiceChatHelper_IsPlayerBlocked::WorldContextObject' has a wrong offset!");
static_assert(offsetof(GzVoiceChatHelper_IsPlayerBlocked, EpicUserId) == 0x000008, "Member 'GzVoiceChatHelper_IsPlayerBlocked::EpicUserId' has a wrong offset!");
static_assert(offsetof(GzVoiceChatHelper_IsPlayerBlocked, ReturnValue) == 0x000018, "Member 'GzVoiceChatHelper_IsPlayerBlocked::ReturnValue' has a wrong offset!");

// Function G01.GzVoiceChatHelper.SetVoiceState
// 0x0010 (0x0010 - 0x0000)
struct GzVoiceChatHelper_SetVoiceState final
{
public:
	const class UObject*                          WorldContextObject;                                // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bState;                                            // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3088[0x7];                                     // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GzVoiceChatHelper_SetVoiceState) == 0x000008, "Wrong alignment on GzVoiceChatHelper_SetVoiceState");
static_assert(sizeof(GzVoiceChatHelper_SetVoiceState) == 0x000010, "Wrong size on GzVoiceChatHelper_SetVoiceState");
static_assert(offsetof(GzVoiceChatHelper_SetVoiceState, WorldContextObject) == 0x000000, "Member 'GzVoiceChatHelper_SetVoiceState::WorldContextObject' has a wrong offset!");
static_assert(offsetof(GzVoiceChatHelper_SetVoiceState, bState) == 0x000008, "Member 'GzVoiceChatHelper_SetVoiceState::bState' has a wrong offset!");

// Function G01.GzVoiceChatHelper.UnblockPlayer
// 0x0018 (0x0018 - 0x0000)
struct GzVoiceChatHelper_UnblockPlayer final
{
public:
	const class UObject*                          WorldContextObject;                                // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 EpicUserId;                                        // 0x0008(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzVoiceChatHelper_UnblockPlayer) == 0x000008, "Wrong alignment on GzVoiceChatHelper_UnblockPlayer");
static_assert(sizeof(GzVoiceChatHelper_UnblockPlayer) == 0x000018, "Wrong size on GzVoiceChatHelper_UnblockPlayer");
static_assert(offsetof(GzVoiceChatHelper_UnblockPlayer, WorldContextObject) == 0x000000, "Member 'GzVoiceChatHelper_UnblockPlayer::WorldContextObject' has a wrong offset!");
static_assert(offsetof(GzVoiceChatHelper_UnblockPlayer, EpicUserId) == 0x000008, "Member 'GzVoiceChatHelper_UnblockPlayer::EpicUserId' has a wrong offset!");

// Function G01.GzLoadingScreenView.OnStartup
// 0x0008 (0x0008 - 0x0000)
struct GzLoadingScreenView_OnStartup final
{
public:
	class UGzLoadingScreenContext*                InContext;                                         // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzLoadingScreenView_OnStartup) == 0x000008, "Wrong alignment on GzLoadingScreenView_OnStartup");
static_assert(sizeof(GzLoadingScreenView_OnStartup) == 0x000008, "Wrong size on GzLoadingScreenView_OnStartup");
static_assert(offsetof(GzLoadingScreenView_OnStartup, InContext) == 0x000000, "Member 'GzLoadingScreenView_OnStartup::InContext' has a wrong offset!");

// Function G01.GzLoadingScreenView.GetBackgroundWidgets
// 0x0010 (0x0010 - 0x0000)
struct GzLoadingScreenView_GetBackgroundWidgets final
{
public:
	TArray<class UWidget*>                        ReturnValue;                                       // 0x0000(0x0010)(ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzLoadingScreenView_GetBackgroundWidgets) == 0x000008, "Wrong alignment on GzLoadingScreenView_GetBackgroundWidgets");
static_assert(sizeof(GzLoadingScreenView_GetBackgroundWidgets) == 0x000010, "Wrong size on GzLoadingScreenView_GetBackgroundWidgets");
static_assert(offsetof(GzLoadingScreenView_GetBackgroundWidgets, ReturnValue) == 0x000000, "Member 'GzLoadingScreenView_GetBackgroundWidgets::ReturnValue' has a wrong offset!");

// Function G01.GzLoadingScreenView.GetInputType
// 0x0001 (0x0001 - 0x0000)
struct GzLoadingScreenView_GetInputType final
{
public:
	EGzLoadingInputType                           ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzLoadingScreenView_GetInputType) == 0x000001, "Wrong alignment on GzLoadingScreenView_GetInputType");
static_assert(sizeof(GzLoadingScreenView_GetInputType) == 0x000001, "Wrong size on GzLoadingScreenView_GetInputType");
static_assert(offsetof(GzLoadingScreenView_GetInputType, ReturnValue) == 0x000000, "Member 'GzLoadingScreenView_GetInputType::ReturnValue' has a wrong offset!");

// Function G01.GzJetpackComponent.OnAkEventEnd
// 0x0010 (0x0010 - 0x0000)
struct GzJetpackComponent_OnAkEventEnd final
{
public:
	EAkCallbackType                               CallbackType;                                      // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3095[0x7];                                     // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UAkCallbackInfo*                        CallbackInfo;                                      // 0x0008(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzJetpackComponent_OnAkEventEnd) == 0x000008, "Wrong alignment on GzJetpackComponent_OnAkEventEnd");
static_assert(sizeof(GzJetpackComponent_OnAkEventEnd) == 0x000010, "Wrong size on GzJetpackComponent_OnAkEventEnd");
static_assert(offsetof(GzJetpackComponent_OnAkEventEnd, CallbackType) == 0x000000, "Member 'GzJetpackComponent_OnAkEventEnd::CallbackType' has a wrong offset!");
static_assert(offsetof(GzJetpackComponent_OnAkEventEnd, CallbackInfo) == 0x000008, "Member 'GzJetpackComponent_OnAkEventEnd::CallbackInfo' has a wrong offset!");

// Function G01.GzJetpackComponent.OnVisualMeshSet
// 0x0008 (0x0008 - 0x0000)
struct GzJetpackComponent_OnVisualMeshSet final
{
public:
	class UMeshComponent*                         NewVisualComponent;                                // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzJetpackComponent_OnVisualMeshSet) == 0x000008, "Wrong alignment on GzJetpackComponent_OnVisualMeshSet");
static_assert(sizeof(GzJetpackComponent_OnVisualMeshSet) == 0x000008, "Wrong size on GzJetpackComponent_OnVisualMeshSet");
static_assert(offsetof(GzJetpackComponent_OnVisualMeshSet, NewVisualComponent) == 0x000000, "Member 'GzJetpackComponent_OnVisualMeshSet::NewVisualComponent' has a wrong offset!");

// Function G01.GzJetpackComponent.SetJetpackBoostVisual
// 0x0010 (0x0010 - 0x0000)
struct GzJetpackComponent_SetJetpackBoostVisual final
{
public:
	class UStaticMesh*                            JetpackBoostVisual;                                // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShow;                                             // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3096[0x7];                                     // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GzJetpackComponent_SetJetpackBoostVisual) == 0x000008, "Wrong alignment on GzJetpackComponent_SetJetpackBoostVisual");
static_assert(sizeof(GzJetpackComponent_SetJetpackBoostVisual) == 0x000010, "Wrong size on GzJetpackComponent_SetJetpackBoostVisual");
static_assert(offsetof(GzJetpackComponent_SetJetpackBoostVisual, JetpackBoostVisual) == 0x000000, "Member 'GzJetpackComponent_SetJetpackBoostVisual::JetpackBoostVisual' has a wrong offset!");
static_assert(offsetof(GzJetpackComponent_SetJetpackBoostVisual, bShow) == 0x000008, "Member 'GzJetpackComponent_SetJetpackBoostVisual::bShow' has a wrong offset!");

// Function G01.GzJetpackComponent.GetOwnerCharacter
// 0x0008 (0x0008 - 0x0000)
struct GzJetpackComponent_GetOwnerCharacter final
{
public:
	class AGzMultiPartCharacter*                  ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzJetpackComponent_GetOwnerCharacter) == 0x000008, "Wrong alignment on GzJetpackComponent_GetOwnerCharacter");
static_assert(sizeof(GzJetpackComponent_GetOwnerCharacter) == 0x000008, "Wrong size on GzJetpackComponent_GetOwnerCharacter");
static_assert(offsetof(GzJetpackComponent_GetOwnerCharacter, ReturnValue) == 0x000000, "Member 'GzJetpackComponent_GetOwnerCharacter::ReturnValue' has a wrong offset!");

// Function G01.GzJetpackComponent.GetVisualComponent
// 0x0008 (0x0008 - 0x0000)
struct GzJetpackComponent_GetVisualComponent final
{
public:
	class UMeshComponent*                         ReturnValue;                                       // 0x0000(0x0008)(ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzJetpackComponent_GetVisualComponent) == 0x000008, "Wrong alignment on GzJetpackComponent_GetVisualComponent");
static_assert(sizeof(GzJetpackComponent_GetVisualComponent) == 0x000008, "Wrong size on GzJetpackComponent_GetVisualComponent");
static_assert(offsetof(GzJetpackComponent_GetVisualComponent, ReturnValue) == 0x000000, "Member 'GzJetpackComponent_GetVisualComponent::ReturnValue' has a wrong offset!");

// Function G01.GzGameplayObjective_SingleTarget.OnObjectReceived
// 0x0008 (0x0008 - 0x0000)
struct GzGameplayObjective_SingleTarget_OnObjectReceived final
{
public:
	class AActor*                                 Object;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzGameplayObjective_SingleTarget_OnObjectReceived) == 0x000008, "Wrong alignment on GzGameplayObjective_SingleTarget_OnObjectReceived");
static_assert(sizeof(GzGameplayObjective_SingleTarget_OnObjectReceived) == 0x000008, "Wrong size on GzGameplayObjective_SingleTarget_OnObjectReceived");
static_assert(offsetof(GzGameplayObjective_SingleTarget_OnObjectReceived, Object) == 0x000000, "Member 'GzGameplayObjective_SingleTarget_OnObjectReceived::Object' has a wrong offset!");

// Function G01.GzGameplayObjective_SingleTarget.OnPreviousObjectInvalidated
// 0x0008 (0x0008 - 0x0000)
struct GzGameplayObjective_SingleTarget_OnPreviousObjectInvalidated final
{
public:
	class AActor*                                 InvalidatedObject;                                 // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzGameplayObjective_SingleTarget_OnPreviousObjectInvalidated) == 0x000008, "Wrong alignment on GzGameplayObjective_SingleTarget_OnPreviousObjectInvalidated");
static_assert(sizeof(GzGameplayObjective_SingleTarget_OnPreviousObjectInvalidated) == 0x000008, "Wrong size on GzGameplayObjective_SingleTarget_OnPreviousObjectInvalidated");
static_assert(offsetof(GzGameplayObjective_SingleTarget_OnPreviousObjectInvalidated, InvalidatedObject) == 0x000000, "Member 'GzGameplayObjective_SingleTarget_OnPreviousObjectInvalidated::InvalidatedObject' has a wrong offset!");

// Function G01.GzGameplayObjective_SingleTarget.SetTarget
// 0x0028 (0x0028 - 0x0000)
struct GzGameplayObjective_SingleTarget_SetTarget final
{
public:
	struct FMissionResourceRef                    InTarget;                                          // 0x0000(0x0028)(Parm, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzGameplayObjective_SingleTarget_SetTarget) == 0x000008, "Wrong alignment on GzGameplayObjective_SingleTarget_SetTarget");
static_assert(sizeof(GzGameplayObjective_SingleTarget_SetTarget) == 0x000028, "Wrong size on GzGameplayObjective_SingleTarget_SetTarget");
static_assert(offsetof(GzGameplayObjective_SingleTarget_SetTarget, InTarget) == 0x000000, "Member 'GzGameplayObjective_SingleTarget_SetTarget::InTarget' has a wrong offset!");

// Function G01.GzMissionObjective_Interact.OnInteractionCancelledWithoutTime
// 0x0010 (0x0010 - 0x0000)
struct GzMissionObjective_Interact_OnInteractionCancelledWithoutTime final
{
public:
	class AActor*                                 InteractedBy;                                      // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	const class UGzInteractableComponent*         Interactable;                                      // 0x0008(0x0008)(ConstParm, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzMissionObjective_Interact_OnInteractionCancelledWithoutTime) == 0x000008, "Wrong alignment on GzMissionObjective_Interact_OnInteractionCancelledWithoutTime");
static_assert(sizeof(GzMissionObjective_Interact_OnInteractionCancelledWithoutTime) == 0x000010, "Wrong size on GzMissionObjective_Interact_OnInteractionCancelledWithoutTime");
static_assert(offsetof(GzMissionObjective_Interact_OnInteractionCancelledWithoutTime, InteractedBy) == 0x000000, "Member 'GzMissionObjective_Interact_OnInteractionCancelledWithoutTime::InteractedBy' has a wrong offset!");
static_assert(offsetof(GzMissionObjective_Interact_OnInteractionCancelledWithoutTime, Interactable) == 0x000008, "Member 'GzMissionObjective_Interact_OnInteractionCancelledWithoutTime::Interactable' has a wrong offset!");

// Function G01.GzMissionObjective_Interact.OnInteractionEnded
// 0x0010 (0x0010 - 0x0000)
struct GzMissionObjective_Interact_OnInteractionEnded final
{
public:
	class AActor*                                 Actor;                                             // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	const class UGzInteractableComponent*         GzInteractableComponent;                           // 0x0008(0x0008)(ConstParm, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzMissionObjective_Interact_OnInteractionEnded) == 0x000008, "Wrong alignment on GzMissionObjective_Interact_OnInteractionEnded");
static_assert(sizeof(GzMissionObjective_Interact_OnInteractionEnded) == 0x000010, "Wrong size on GzMissionObjective_Interact_OnInteractionEnded");
static_assert(offsetof(GzMissionObjective_Interact_OnInteractionEnded, Actor) == 0x000000, "Member 'GzMissionObjective_Interact_OnInteractionEnded::Actor' has a wrong offset!");
static_assert(offsetof(GzMissionObjective_Interact_OnInteractionEnded, GzInteractableComponent) == 0x000008, "Member 'GzMissionObjective_Interact_OnInteractionEnded::GzInteractableComponent' has a wrong offset!");

// Function G01.GzCameraOverlayLocationObject.SetOverlayCameraDistance
// 0x0008 (0x0008 - 0x0000)
struct GzCameraOverlayLocationObject_SetOverlayCameraDistance final
{
public:
	float                                         Distance;                                          // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bWithInterpolation;                                // 0x0004(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_30A2[0x3];                                     // 0x0005(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GzCameraOverlayLocationObject_SetOverlayCameraDistance) == 0x000004, "Wrong alignment on GzCameraOverlayLocationObject_SetOverlayCameraDistance");
static_assert(sizeof(GzCameraOverlayLocationObject_SetOverlayCameraDistance) == 0x000008, "Wrong size on GzCameraOverlayLocationObject_SetOverlayCameraDistance");
static_assert(offsetof(GzCameraOverlayLocationObject_SetOverlayCameraDistance, Distance) == 0x000000, "Member 'GzCameraOverlayLocationObject_SetOverlayCameraDistance::Distance' has a wrong offset!");
static_assert(offsetof(GzCameraOverlayLocationObject_SetOverlayCameraDistance, bWithInterpolation) == 0x000004, "Member 'GzCameraOverlayLocationObject_SetOverlayCameraDistance::bWithInterpolation' has a wrong offset!");

// Function G01.GzChallengeServiceCheatExtension.ClientCompleteChallenge
// 0x0008 (0x0008 - 0x0000)
struct GzChallengeServiceCheatExtension_ClientCompleteChallenge final
{
public:
	class FName                                   ChallengeAssetId;                                  // 0x0000(0x0008)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzChallengeServiceCheatExtension_ClientCompleteChallenge) == 0x000004, "Wrong alignment on GzChallengeServiceCheatExtension_ClientCompleteChallenge");
static_assert(sizeof(GzChallengeServiceCheatExtension_ClientCompleteChallenge) == 0x000008, "Wrong size on GzChallengeServiceCheatExtension_ClientCompleteChallenge");
static_assert(offsetof(GzChallengeServiceCheatExtension_ClientCompleteChallenge, ChallengeAssetId) == 0x000000, "Member 'GzChallengeServiceCheatExtension_ClientCompleteChallenge::ChallengeAssetId' has a wrong offset!");

// Function G01.GzChallengeServiceCheatExtension.ClientResetChallenge
// 0x0008 (0x0008 - 0x0000)
struct GzChallengeServiceCheatExtension_ClientResetChallenge final
{
public:
	class FName                                   ChallengeAssetId;                                  // 0x0000(0x0008)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzChallengeServiceCheatExtension_ClientResetChallenge) == 0x000004, "Wrong alignment on GzChallengeServiceCheatExtension_ClientResetChallenge");
static_assert(sizeof(GzChallengeServiceCheatExtension_ClientResetChallenge) == 0x000008, "Wrong size on GzChallengeServiceCheatExtension_ClientResetChallenge");
static_assert(offsetof(GzChallengeServiceCheatExtension_ClientResetChallenge, ChallengeAssetId) == 0x000000, "Member 'GzChallengeServiceCheatExtension_ClientResetChallenge::ChallengeAssetId' has a wrong offset!");

// Function G01.GzChallengeServiceCheatExtension.ClientUpdateChallengeProgress
// 0x000C (0x000C - 0x0000)
struct GzChallengeServiceCheatExtension_ClientUpdateChallengeProgress final
{
public:
	class FName                                   ChallengeAssetId;                                  // 0x0000(0x0008)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         NewProgress;                                       // 0x0008(0x0004)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzChallengeServiceCheatExtension_ClientUpdateChallengeProgress) == 0x000004, "Wrong alignment on GzChallengeServiceCheatExtension_ClientUpdateChallengeProgress");
static_assert(sizeof(GzChallengeServiceCheatExtension_ClientUpdateChallengeProgress) == 0x00000C, "Wrong size on GzChallengeServiceCheatExtension_ClientUpdateChallengeProgress");
static_assert(offsetof(GzChallengeServiceCheatExtension_ClientUpdateChallengeProgress, ChallengeAssetId) == 0x000000, "Member 'GzChallengeServiceCheatExtension_ClientUpdateChallengeProgress::ChallengeAssetId' has a wrong offset!");
static_assert(offsetof(GzChallengeServiceCheatExtension_ClientUpdateChallengeProgress, NewProgress) == 0x000008, "Member 'GzChallengeServiceCheatExtension_ClientUpdateChallengeProgress::NewProgress' has a wrong offset!");

// Function G01.GzLootChooserComponent.GetInvItems
// 0x0020 (0x0020 - 0x0000)
struct GzLootChooserComponent_GetInvItems final
{
public:
	class AActor*                                 InteractActor;                                     // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSkipRarityValidation;                             // 0x0008(0x0001)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_30A4[0x7];                                     // 0x0009(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FGzInvItem>                     ReturnValue;                                       // 0x0010(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzLootChooserComponent_GetInvItems) == 0x000008, "Wrong alignment on GzLootChooserComponent_GetInvItems");
static_assert(sizeof(GzLootChooserComponent_GetInvItems) == 0x000020, "Wrong size on GzLootChooserComponent_GetInvItems");
static_assert(offsetof(GzLootChooserComponent_GetInvItems, InteractActor) == 0x000000, "Member 'GzLootChooserComponent_GetInvItems::InteractActor' has a wrong offset!");
static_assert(offsetof(GzLootChooserComponent_GetInvItems, bSkipRarityValidation) == 0x000008, "Member 'GzLootChooserComponent_GetInvItems::bSkipRarityValidation' has a wrong offset!");
static_assert(offsetof(GzLootChooserComponent_GetInvItems, ReturnValue) == 0x000010, "Member 'GzLootChooserComponent_GetInvItems::ReturnValue' has a wrong offset!");

// DelegateFunction G01.GzVoiceChatBlueprintEventsComponent.GzVoiceChatMemberBlockStateUpdatedDynamic__DelegateSignature
// 0x0018 (0x0018 - 0x0000)
struct GzVoiceChatBlueprintEventsComponent_GzVoiceChatMemberBlockStateUpdatedDynamic__DelegateSignature final
{
public:
	class FString                                 ProductUserId;                                     // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsBlocked;                                        // 0x0010(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_30AF[0x7];                                     // 0x0011(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GzVoiceChatBlueprintEventsComponent_GzVoiceChatMemberBlockStateUpdatedDynamic__DelegateSignature) == 0x000008, "Wrong alignment on GzVoiceChatBlueprintEventsComponent_GzVoiceChatMemberBlockStateUpdatedDynamic__DelegateSignature");
static_assert(sizeof(GzVoiceChatBlueprintEventsComponent_GzVoiceChatMemberBlockStateUpdatedDynamic__DelegateSignature) == 0x000018, "Wrong size on GzVoiceChatBlueprintEventsComponent_GzVoiceChatMemberBlockStateUpdatedDynamic__DelegateSignature");
static_assert(offsetof(GzVoiceChatBlueprintEventsComponent_GzVoiceChatMemberBlockStateUpdatedDynamic__DelegateSignature, ProductUserId) == 0x000000, "Member 'GzVoiceChatBlueprintEventsComponent_GzVoiceChatMemberBlockStateUpdatedDynamic__DelegateSignature::ProductUserId' has a wrong offset!");
static_assert(offsetof(GzVoiceChatBlueprintEventsComponent_GzVoiceChatMemberBlockStateUpdatedDynamic__DelegateSignature, bIsBlocked) == 0x000010, "Member 'GzVoiceChatBlueprintEventsComponent_GzVoiceChatMemberBlockStateUpdatedDynamic__DelegateSignature::bIsBlocked' has a wrong offset!");

// DelegateFunction G01.GzVoiceChatBlueprintEventsComponent.GzVoiceChatMemberStateUpdatedDynamic__DelegateSignature
// 0x0018 (0x0018 - 0x0000)
struct GzVoiceChatBlueprintEventsComponent_GzVoiceChatMemberStateUpdatedDynamic__DelegateSignature final
{
public:
	class FString                                 PlayFabId;                                         // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsMuted;                                          // 0x0010(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_30B0[0x7];                                     // 0x0011(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GzVoiceChatBlueprintEventsComponent_GzVoiceChatMemberStateUpdatedDynamic__DelegateSignature) == 0x000008, "Wrong alignment on GzVoiceChatBlueprintEventsComponent_GzVoiceChatMemberStateUpdatedDynamic__DelegateSignature");
static_assert(sizeof(GzVoiceChatBlueprintEventsComponent_GzVoiceChatMemberStateUpdatedDynamic__DelegateSignature) == 0x000018, "Wrong size on GzVoiceChatBlueprintEventsComponent_GzVoiceChatMemberStateUpdatedDynamic__DelegateSignature");
static_assert(offsetof(GzVoiceChatBlueprintEventsComponent_GzVoiceChatMemberStateUpdatedDynamic__DelegateSignature, PlayFabId) == 0x000000, "Member 'GzVoiceChatBlueprintEventsComponent_GzVoiceChatMemberStateUpdatedDynamic__DelegateSignature::PlayFabId' has a wrong offset!");
static_assert(offsetof(GzVoiceChatBlueprintEventsComponent_GzVoiceChatMemberStateUpdatedDynamic__DelegateSignature, bIsMuted) == 0x000010, "Member 'GzVoiceChatBlueprintEventsComponent_GzVoiceChatMemberStateUpdatedDynamic__DelegateSignature::bIsMuted' has a wrong offset!");

// DelegateFunction G01.GzVoiceChatBlueprintEventsComponent.GzVoiceChatMemberTalkingStateUpdatedDynamic__DelegateSignature
// 0x0018 (0x0018 - 0x0000)
struct GzVoiceChatBlueprintEventsComponent_GzVoiceChatMemberTalkingStateUpdatedDynamic__DelegateSignature final
{
public:
	class FString                                 PlayFabId;                                         // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bTalkingState;                                     // 0x0010(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_30B1[0x7];                                     // 0x0011(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GzVoiceChatBlueprintEventsComponent_GzVoiceChatMemberTalkingStateUpdatedDynamic__DelegateSignature) == 0x000008, "Wrong alignment on GzVoiceChatBlueprintEventsComponent_GzVoiceChatMemberTalkingStateUpdatedDynamic__DelegateSignature");
static_assert(sizeof(GzVoiceChatBlueprintEventsComponent_GzVoiceChatMemberTalkingStateUpdatedDynamic__DelegateSignature) == 0x000018, "Wrong size on GzVoiceChatBlueprintEventsComponent_GzVoiceChatMemberTalkingStateUpdatedDynamic__DelegateSignature");
static_assert(offsetof(GzVoiceChatBlueprintEventsComponent_GzVoiceChatMemberTalkingStateUpdatedDynamic__DelegateSignature, PlayFabId) == 0x000000, "Member 'GzVoiceChatBlueprintEventsComponent_GzVoiceChatMemberTalkingStateUpdatedDynamic__DelegateSignature::PlayFabId' has a wrong offset!");
static_assert(offsetof(GzVoiceChatBlueprintEventsComponent_GzVoiceChatMemberTalkingStateUpdatedDynamic__DelegateSignature, bTalkingState) == 0x000010, "Member 'GzVoiceChatBlueprintEventsComponent_GzVoiceChatMemberTalkingStateUpdatedDynamic__DelegateSignature::bTalkingState' has a wrong offset!");

// Function G01.GzWeaponActor.DestroyBehaviorSpawnedComponent
// 0x0008 (0x0008 - 0x0000)
struct GzWeaponActor_DestroyBehaviorSpawnedComponent final
{
public:
	class UActorComponent*                        ComponentToDestroy;                                // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzWeaponActor_DestroyBehaviorSpawnedComponent) == 0x000008, "Wrong alignment on GzWeaponActor_DestroyBehaviorSpawnedComponent");
static_assert(sizeof(GzWeaponActor_DestroyBehaviorSpawnedComponent) == 0x000008, "Wrong size on GzWeaponActor_DestroyBehaviorSpawnedComponent");
static_assert(offsetof(GzWeaponActor_DestroyBehaviorSpawnedComponent, ComponentToDestroy) == 0x000000, "Member 'GzWeaponActor_DestroyBehaviorSpawnedComponent::ComponentToDestroy' has a wrong offset!");

// Function G01.GzWeaponActor.GetDedicatedPocketID
// 0x0008 (0x0008 - 0x0000)
struct GzWeaponActor_GetDedicatedPocketID final
{
public:
	struct FGzInvPocketId                         ReturnValue;                                       // 0x0000(0x0008)(ConstParm, Parm, OutParm, ReturnParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzWeaponActor_GetDedicatedPocketID) == 0x000004, "Wrong alignment on GzWeaponActor_GetDedicatedPocketID");
static_assert(sizeof(GzWeaponActor_GetDedicatedPocketID) == 0x000008, "Wrong size on GzWeaponActor_GetDedicatedPocketID");
static_assert(offsetof(GzWeaponActor_GetDedicatedPocketID, ReturnValue) == 0x000000, "Member 'GzWeaponActor_GetDedicatedPocketID::ReturnValue' has a wrong offset!");

// Function G01.GzWeaponActor.GetItemData
// 0x0008 (0x0008 - 0x0000)
struct GzWeaponActor_GetItemData final
{
public:
	class UGzWeaponItemData*                      ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzWeaponActor_GetItemData) == 0x000008, "Wrong alignment on GzWeaponActor_GetItemData");
static_assert(sizeof(GzWeaponActor_GetItemData) == 0x000008, "Wrong size on GzWeaponActor_GetItemData");
static_assert(offsetof(GzWeaponActor_GetItemData, ReturnValue) == 0x000000, "Member 'GzWeaponActor_GetItemData::ReturnValue' has a wrong offset!");

// Function G01.GzWeaponActor.GetLeftHandIKTransform
// 0x0070 (0x0070 - 0x0000)
struct GzWeaponActor_GetLeftHandIKTransform final
{
public:
	ERelativeTransformSpace                       CurrentSpace;                                      // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_30B4[0xF];                                     // 0x0001(0x000F)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             ReturnValue;                                       // 0x0010(0x0060)(Parm, OutParm, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzWeaponActor_GetLeftHandIKTransform) == 0x000010, "Wrong alignment on GzWeaponActor_GetLeftHandIKTransform");
static_assert(sizeof(GzWeaponActor_GetLeftHandIKTransform) == 0x000070, "Wrong size on GzWeaponActor_GetLeftHandIKTransform");
static_assert(offsetof(GzWeaponActor_GetLeftHandIKTransform, CurrentSpace) == 0x000000, "Member 'GzWeaponActor_GetLeftHandIKTransform::CurrentSpace' has a wrong offset!");
static_assert(offsetof(GzWeaponActor_GetLeftHandIKTransform, ReturnValue) == 0x000010, "Member 'GzWeaponActor_GetLeftHandIKTransform::ReturnValue' has a wrong offset!");

// Function G01.GzWeaponActor.GetSkeletalMeshComponent
// 0x0008 (0x0008 - 0x0000)
struct GzWeaponActor_GetSkeletalMeshComponent final
{
public:
	class USkeletalMeshComponent*                 ReturnValue;                                       // 0x0000(0x0008)(ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzWeaponActor_GetSkeletalMeshComponent) == 0x000008, "Wrong alignment on GzWeaponActor_GetSkeletalMeshComponent");
static_assert(sizeof(GzWeaponActor_GetSkeletalMeshComponent) == 0x000008, "Wrong size on GzWeaponActor_GetSkeletalMeshComponent");
static_assert(offsetof(GzWeaponActor_GetSkeletalMeshComponent, ReturnValue) == 0x000000, "Member 'GzWeaponActor_GetSkeletalMeshComponent::ReturnValue' has a wrong offset!");

// Function G01.GzWeaponActor.GetSkinItemData
// 0x0008 (0x0008 - 0x0000)
struct GzWeaponActor_GetSkinItemData final
{
public:
	class UGzWeaponSkinItemData*                  ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzWeaponActor_GetSkinItemData) == 0x000008, "Wrong alignment on GzWeaponActor_GetSkinItemData");
static_assert(sizeof(GzWeaponActor_GetSkinItemData) == 0x000008, "Wrong size on GzWeaponActor_GetSkinItemData");
static_assert(offsetof(GzWeaponActor_GetSkinItemData, ReturnValue) == 0x000000, "Member 'GzWeaponActor_GetSkinItemData::ReturnValue' has a wrong offset!");

// Function G01.GzWeaponActor.GetWeaponAttachment
// 0x0010 (0x0010 - 0x0000)
struct GzWeaponActor_GetWeaponAttachment final
{
public:
	EGzWeaponAttachmentType                       Type;                                              // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_30B5[0x7];                                     // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UGzWeaponAttachmentComponent*           ReturnValue;                                       // 0x0008(0x0008)(ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzWeaponActor_GetWeaponAttachment) == 0x000008, "Wrong alignment on GzWeaponActor_GetWeaponAttachment");
static_assert(sizeof(GzWeaponActor_GetWeaponAttachment) == 0x000010, "Wrong size on GzWeaponActor_GetWeaponAttachment");
static_assert(offsetof(GzWeaponActor_GetWeaponAttachment, Type) == 0x000000, "Member 'GzWeaponActor_GetWeaponAttachment::Type' has a wrong offset!");
static_assert(offsetof(GzWeaponActor_GetWeaponAttachment, ReturnValue) == 0x000008, "Member 'GzWeaponActor_GetWeaponAttachment::ReturnValue' has a wrong offset!");

// Function G01.GzWeaponActor.GetWeaponComponent
// 0x0008 (0x0008 - 0x0000)
struct GzWeaponActor_GetWeaponComponent final
{
public:
	class UGzWeaponComponent*                     ReturnValue;                                       // 0x0000(0x0008)(ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzWeaponActor_GetWeaponComponent) == 0x000008, "Wrong alignment on GzWeaponActor_GetWeaponComponent");
static_assert(sizeof(GzWeaponActor_GetWeaponComponent) == 0x000008, "Wrong size on GzWeaponActor_GetWeaponComponent");
static_assert(offsetof(GzWeaponActor_GetWeaponComponent, ReturnValue) == 0x000000, "Member 'GzWeaponActor_GetWeaponComponent::ReturnValue' has a wrong offset!");

// Function G01.GzWeaponActor.GetWeaponSupportHoldType
// 0x0001 (0x0001 - 0x0000)
struct GzWeaponActor_GetWeaponSupportHoldType final
{
public:
	EGzWeaponSupportHoldType                      ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzWeaponActor_GetWeaponSupportHoldType) == 0x000001, "Wrong alignment on GzWeaponActor_GetWeaponSupportHoldType");
static_assert(sizeof(GzWeaponActor_GetWeaponSupportHoldType) == 0x000001, "Wrong size on GzWeaponActor_GetWeaponSupportHoldType");
static_assert(offsetof(GzWeaponActor_GetWeaponSupportHoldType, ReturnValue) == 0x000000, "Member 'GzWeaponActor_GetWeaponSupportHoldType::ReturnValue' has a wrong offset!");

// Function G01.GzWeaponActor.HasLeftHandIKHandling
// 0x0001 (0x0001 - 0x0000)
struct GzWeaponActor_HasLeftHandIKHandling final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzWeaponActor_HasLeftHandIKHandling) == 0x000001, "Wrong alignment on GzWeaponActor_HasLeftHandIKHandling");
static_assert(sizeof(GzWeaponActor_HasLeftHandIKHandling) == 0x000001, "Wrong size on GzWeaponActor_HasLeftHandIKHandling");
static_assert(offsetof(GzWeaponActor_HasLeftHandIKHandling, ReturnValue) == 0x000000, "Member 'GzWeaponActor_HasLeftHandIKHandling::ReturnValue' has a wrong offset!");

// Function G01.GzLimbAnimNotifyState.GetSpawnedEffect
// 0x0010 (0x0010 - 0x0000)
struct GzLimbAnimNotifyState_GetSpawnedEffect final
{
public:
	class UMeshComponent*                         MeshComp;                                          // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UNiagaraComponent*                      ReturnValue;                                       // 0x0008(0x0008)(ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzLimbAnimNotifyState_GetSpawnedEffect) == 0x000008, "Wrong alignment on GzLimbAnimNotifyState_GetSpawnedEffect");
static_assert(sizeof(GzLimbAnimNotifyState_GetSpawnedEffect) == 0x000010, "Wrong size on GzLimbAnimNotifyState_GetSpawnedEffect");
static_assert(offsetof(GzLimbAnimNotifyState_GetSpawnedEffect, MeshComp) == 0x000000, "Member 'GzLimbAnimNotifyState_GetSpawnedEffect::MeshComp' has a wrong offset!");
static_assert(offsetof(GzLimbAnimNotifyState_GetSpawnedEffect, ReturnValue) == 0x000008, "Member 'GzLimbAnimNotifyState_GetSpawnedEffect::ReturnValue' has a wrong offset!");

// Function G01.GzTrialsControllerComponent.GetOwnedTrials
// 0x0010 (0x0010 - 0x0000)
struct GzTrialsControllerComponent_GetOwnedTrials final
{
public:
	TArray<struct FGzGameplayTrial>               ReturnValue;                                       // 0x0000(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzTrialsControllerComponent_GetOwnedTrials) == 0x000008, "Wrong alignment on GzTrialsControllerComponent_GetOwnedTrials");
static_assert(sizeof(GzTrialsControllerComponent_GetOwnedTrials) == 0x000010, "Wrong size on GzTrialsControllerComponent_GetOwnedTrials");
static_assert(offsetof(GzTrialsControllerComponent_GetOwnedTrials, ReturnValue) == 0x000000, "Member 'GzTrialsControllerComponent_GetOwnedTrials::ReturnValue' has a wrong offset!");

// Function G01.GzLoadoutsGrid.SetDataToSlot
// 0x0070 (0x0070 - 0x0000)
struct GzLoadoutsGrid_SetDataToSlot final
{
public:
	struct FGzLoadoutDataConfig                   LoadoutConfig;                                     // 0x0000(0x0070)(ConstParm, Parm, OutParm, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzLoadoutsGrid_SetDataToSlot) == 0x000008, "Wrong alignment on GzLoadoutsGrid_SetDataToSlot");
static_assert(sizeof(GzLoadoutsGrid_SetDataToSlot) == 0x000070, "Wrong size on GzLoadoutsGrid_SetDataToSlot");
static_assert(offsetof(GzLoadoutsGrid_SetDataToSlot, LoadoutConfig) == 0x000000, "Member 'GzLoadoutsGrid_SetDataToSlot::LoadoutConfig' has a wrong offset!");

// Function G01.GzCharacterWorldVisibilityComponent.GetVisibilityState
// 0x0001 (0x0001 - 0x0000)
struct GzCharacterWorldVisibilityComponent_GetVisibilityState final
{
public:
	EGzWorldVisibilityState                       ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzCharacterWorldVisibilityComponent_GetVisibilityState) == 0x000001, "Wrong alignment on GzCharacterWorldVisibilityComponent_GetVisibilityState");
static_assert(sizeof(GzCharacterWorldVisibilityComponent_GetVisibilityState) == 0x000001, "Wrong size on GzCharacterWorldVisibilityComponent_GetVisibilityState");
static_assert(offsetof(GzCharacterWorldVisibilityComponent_GetVisibilityState, ReturnValue) == 0x000000, "Member 'GzCharacterWorldVisibilityComponent_GetVisibilityState::ReturnValue' has a wrong offset!");

// Function G01.GzCharacterWorldVisibilityComponent.GetVisibilityStateStencil
// 0x0001 (0x0001 - 0x0000)
struct GzCharacterWorldVisibilityComponent_GetVisibilityStateStencil final
{
public:
	EGzWorldVisibilityState                       ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzCharacterWorldVisibilityComponent_GetVisibilityStateStencil) == 0x000001, "Wrong alignment on GzCharacterWorldVisibilityComponent_GetVisibilityStateStencil");
static_assert(sizeof(GzCharacterWorldVisibilityComponent_GetVisibilityStateStencil) == 0x000001, "Wrong size on GzCharacterWorldVisibilityComponent_GetVisibilityStateStencil");
static_assert(offsetof(GzCharacterWorldVisibilityComponent_GetVisibilityStateStencil, ReturnValue) == 0x000000, "Member 'GzCharacterWorldVisibilityComponent_GetVisibilityStateStencil::ReturnValue' has a wrong offset!");

// Function G01.GzChargePreviewPathActor.GetAbilityComponent
// 0x0008 (0x0008 - 0x0000)
struct GzChargePreviewPathActor_GetAbilityComponent final
{
public:
	class UGzChargeableAbilityComponent*          ReturnValue;                                       // 0x0000(0x0008)(ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzChargePreviewPathActor_GetAbilityComponent) == 0x000008, "Wrong alignment on GzChargePreviewPathActor_GetAbilityComponent");
static_assert(sizeof(GzChargePreviewPathActor_GetAbilityComponent) == 0x000008, "Wrong size on GzChargePreviewPathActor_GetAbilityComponent");
static_assert(offsetof(GzChargePreviewPathActor_GetAbilityComponent, ReturnValue) == 0x000000, "Member 'GzChargePreviewPathActor_GetAbilityComponent::ReturnValue' has a wrong offset!");

// DelegateFunction G01.GzCheckedOverlapSphereComponent.GzComponentBeginOverlapSignature__DelegateSignature
// 0x0118 (0x0118 - 0x0000)
struct GzCheckedOverlapSphereComponent_GzComponentBeginOverlapSignature__DelegateSignature final
{
public:
	class UPrimitiveComponent*                    OverlappedComponent;                               // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 OtherActor;                                        // 0x0008(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UPrimitiveComponent*                    OtherComp;                                         // 0x0010(0x0008)(Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         OtherBodyIndex;                                    // 0x0018(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bFromSweep;                                        // 0x001C(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_30BE[0x3];                                     // 0x001D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FHitResult                             SweepResult;                                       // 0x0020(0x00F8)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzCheckedOverlapSphereComponent_GzComponentBeginOverlapSignature__DelegateSignature) == 0x000008, "Wrong alignment on GzCheckedOverlapSphereComponent_GzComponentBeginOverlapSignature__DelegateSignature");
static_assert(sizeof(GzCheckedOverlapSphereComponent_GzComponentBeginOverlapSignature__DelegateSignature) == 0x000118, "Wrong size on GzCheckedOverlapSphereComponent_GzComponentBeginOverlapSignature__DelegateSignature");
static_assert(offsetof(GzCheckedOverlapSphereComponent_GzComponentBeginOverlapSignature__DelegateSignature, OverlappedComponent) == 0x000000, "Member 'GzCheckedOverlapSphereComponent_GzComponentBeginOverlapSignature__DelegateSignature::OverlappedComponent' has a wrong offset!");
static_assert(offsetof(GzCheckedOverlapSphereComponent_GzComponentBeginOverlapSignature__DelegateSignature, OtherActor) == 0x000008, "Member 'GzCheckedOverlapSphereComponent_GzComponentBeginOverlapSignature__DelegateSignature::OtherActor' has a wrong offset!");
static_assert(offsetof(GzCheckedOverlapSphereComponent_GzComponentBeginOverlapSignature__DelegateSignature, OtherComp) == 0x000010, "Member 'GzCheckedOverlapSphereComponent_GzComponentBeginOverlapSignature__DelegateSignature::OtherComp' has a wrong offset!");
static_assert(offsetof(GzCheckedOverlapSphereComponent_GzComponentBeginOverlapSignature__DelegateSignature, OtherBodyIndex) == 0x000018, "Member 'GzCheckedOverlapSphereComponent_GzComponentBeginOverlapSignature__DelegateSignature::OtherBodyIndex' has a wrong offset!");
static_assert(offsetof(GzCheckedOverlapSphereComponent_GzComponentBeginOverlapSignature__DelegateSignature, bFromSweep) == 0x00001C, "Member 'GzCheckedOverlapSphereComponent_GzComponentBeginOverlapSignature__DelegateSignature::bFromSweep' has a wrong offset!");
static_assert(offsetof(GzCheckedOverlapSphereComponent_GzComponentBeginOverlapSignature__DelegateSignature, SweepResult) == 0x000020, "Member 'GzCheckedOverlapSphereComponent_GzComponentBeginOverlapSignature__DelegateSignature::SweepResult' has a wrong offset!");

// DelegateFunction G01.GzCheckedOverlapSphereComponent.GzComponentEndOverlapSignature__DelegateSignature
// 0x0020 (0x0020 - 0x0000)
struct GzCheckedOverlapSphereComponent_GzComponentEndOverlapSignature__DelegateSignature final
{
public:
	class UPrimitiveComponent*                    OverlappedComponent;                               // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 OtherActor;                                        // 0x0008(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UPrimitiveComponent*                    OtherComp;                                         // 0x0010(0x0008)(Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         OtherBodyIndex;                                    // 0x0018(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_30BF[0x4];                                     // 0x001C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GzCheckedOverlapSphereComponent_GzComponentEndOverlapSignature__DelegateSignature) == 0x000008, "Wrong alignment on GzCheckedOverlapSphereComponent_GzComponentEndOverlapSignature__DelegateSignature");
static_assert(sizeof(GzCheckedOverlapSphereComponent_GzComponentEndOverlapSignature__DelegateSignature) == 0x000020, "Wrong size on GzCheckedOverlapSphereComponent_GzComponentEndOverlapSignature__DelegateSignature");
static_assert(offsetof(GzCheckedOverlapSphereComponent_GzComponentEndOverlapSignature__DelegateSignature, OverlappedComponent) == 0x000000, "Member 'GzCheckedOverlapSphereComponent_GzComponentEndOverlapSignature__DelegateSignature::OverlappedComponent' has a wrong offset!");
static_assert(offsetof(GzCheckedOverlapSphereComponent_GzComponentEndOverlapSignature__DelegateSignature, OtherActor) == 0x000008, "Member 'GzCheckedOverlapSphereComponent_GzComponentEndOverlapSignature__DelegateSignature::OtherActor' has a wrong offset!");
static_assert(offsetof(GzCheckedOverlapSphereComponent_GzComponentEndOverlapSignature__DelegateSignature, OtherComp) == 0x000010, "Member 'GzCheckedOverlapSphereComponent_GzComponentEndOverlapSignature__DelegateSignature::OtherComp' has a wrong offset!");
static_assert(offsetof(GzCheckedOverlapSphereComponent_GzComponentEndOverlapSignature__DelegateSignature, OtherBodyIndex) == 0x000018, "Member 'GzCheckedOverlapSphereComponent_GzComponentEndOverlapSignature__DelegateSignature::OtherBodyIndex' has a wrong offset!");

// Function G01.GzCheckedOverlapSphereComponent.OnBeginOverlap
// 0x0118 (0x0118 - 0x0000)
struct GzCheckedOverlapSphereComponent_OnBeginOverlap final
{
public:
	class UPrimitiveComponent*                    OverlappedComponent;                               // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 OtherActor;                                        // 0x0008(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UPrimitiveComponent*                    OtherComp;                                         // 0x0010(0x0008)(Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         OtherBodyIndex;                                    // 0x0018(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bFromSweep;                                        // 0x001C(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_30C0[0x3];                                     // 0x001D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FHitResult                             SweepResult;                                       // 0x0020(0x00F8)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzCheckedOverlapSphereComponent_OnBeginOverlap) == 0x000008, "Wrong alignment on GzCheckedOverlapSphereComponent_OnBeginOverlap");
static_assert(sizeof(GzCheckedOverlapSphereComponent_OnBeginOverlap) == 0x000118, "Wrong size on GzCheckedOverlapSphereComponent_OnBeginOverlap");
static_assert(offsetof(GzCheckedOverlapSphereComponent_OnBeginOverlap, OverlappedComponent) == 0x000000, "Member 'GzCheckedOverlapSphereComponent_OnBeginOverlap::OverlappedComponent' has a wrong offset!");
static_assert(offsetof(GzCheckedOverlapSphereComponent_OnBeginOverlap, OtherActor) == 0x000008, "Member 'GzCheckedOverlapSphereComponent_OnBeginOverlap::OtherActor' has a wrong offset!");
static_assert(offsetof(GzCheckedOverlapSphereComponent_OnBeginOverlap, OtherComp) == 0x000010, "Member 'GzCheckedOverlapSphereComponent_OnBeginOverlap::OtherComp' has a wrong offset!");
static_assert(offsetof(GzCheckedOverlapSphereComponent_OnBeginOverlap, OtherBodyIndex) == 0x000018, "Member 'GzCheckedOverlapSphereComponent_OnBeginOverlap::OtherBodyIndex' has a wrong offset!");
static_assert(offsetof(GzCheckedOverlapSphereComponent_OnBeginOverlap, bFromSweep) == 0x00001C, "Member 'GzCheckedOverlapSphereComponent_OnBeginOverlap::bFromSweep' has a wrong offset!");
static_assert(offsetof(GzCheckedOverlapSphereComponent_OnBeginOverlap, SweepResult) == 0x000020, "Member 'GzCheckedOverlapSphereComponent_OnBeginOverlap::SweepResult' has a wrong offset!");

// Function G01.GzCheckedOverlapSphereComponent.OnEndOverlap
// 0x0020 (0x0020 - 0x0000)
struct GzCheckedOverlapSphereComponent_OnEndOverlap final
{
public:
	class UPrimitiveComponent*                    OverlappedComponent;                               // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 OtherActor;                                        // 0x0008(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UPrimitiveComponent*                    OtherComp;                                         // 0x0010(0x0008)(Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         OtherBodyIndex;                                    // 0x0018(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_30C1[0x4];                                     // 0x001C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GzCheckedOverlapSphereComponent_OnEndOverlap) == 0x000008, "Wrong alignment on GzCheckedOverlapSphereComponent_OnEndOverlap");
static_assert(sizeof(GzCheckedOverlapSphereComponent_OnEndOverlap) == 0x000020, "Wrong size on GzCheckedOverlapSphereComponent_OnEndOverlap");
static_assert(offsetof(GzCheckedOverlapSphereComponent_OnEndOverlap, OverlappedComponent) == 0x000000, "Member 'GzCheckedOverlapSphereComponent_OnEndOverlap::OverlappedComponent' has a wrong offset!");
static_assert(offsetof(GzCheckedOverlapSphereComponent_OnEndOverlap, OtherActor) == 0x000008, "Member 'GzCheckedOverlapSphereComponent_OnEndOverlap::OtherActor' has a wrong offset!");
static_assert(offsetof(GzCheckedOverlapSphereComponent_OnEndOverlap, OtherComp) == 0x000010, "Member 'GzCheckedOverlapSphereComponent_OnEndOverlap::OtherComp' has a wrong offset!");
static_assert(offsetof(GzCheckedOverlapSphereComponent_OnEndOverlap, OtherBodyIndex) == 0x000018, "Member 'GzCheckedOverlapSphereComponent_OnEndOverlap::OtherBodyIndex' has a wrong offset!");

// Function G01.GzCircleMarkerShape.SetRadius
// 0x0004 (0x0004 - 0x0000)
struct GzCircleMarkerShape_SetRadius final
{
public:
	float                                         InRadius;                                          // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzCircleMarkerShape_SetRadius) == 0x000004, "Wrong alignment on GzCircleMarkerShape_SetRadius");
static_assert(sizeof(GzCircleMarkerShape_SetRadius) == 0x000004, "Wrong size on GzCircleMarkerShape_SetRadius");
static_assert(offsetof(GzCircleMarkerShape_SetRadius, InRadius) == 0x000000, "Member 'GzCircleMarkerShape_SetRadius::InRadius' has a wrong offset!");

// Function G01.GzCircleMarkerShape.GetAreaRadius
// 0x0004 (0x0004 - 0x0000)
struct GzCircleMarkerShape_GetAreaRadius final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzCircleMarkerShape_GetAreaRadius) == 0x000004, "Wrong alignment on GzCircleMarkerShape_GetAreaRadius");
static_assert(sizeof(GzCircleMarkerShape_GetAreaRadius) == 0x000004, "Wrong size on GzCircleMarkerShape_GetAreaRadius");
static_assert(offsetof(GzCircleMarkerShape_GetAreaRadius, ReturnValue) == 0x000000, "Member 'GzCircleMarkerShape_GetAreaRadius::ReturnValue' has a wrong offset!");

// Function G01.GzGA_WeaponAim.OnHoldBreathPressedInput
// 0x0004 (0x0004 - 0x0000)
struct GzGA_WeaponAim_OnHoldBreathPressedInput final
{
public:
	float                                         TimeHeld;                                          // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzGA_WeaponAim_OnHoldBreathPressedInput) == 0x000004, "Wrong alignment on GzGA_WeaponAim_OnHoldBreathPressedInput");
static_assert(sizeof(GzGA_WeaponAim_OnHoldBreathPressedInput) == 0x000004, "Wrong size on GzGA_WeaponAim_OnHoldBreathPressedInput");
static_assert(offsetof(GzGA_WeaponAim_OnHoldBreathPressedInput, TimeHeld) == 0x000000, "Member 'GzGA_WeaponAim_OnHoldBreathPressedInput::TimeHeld' has a wrong offset!");

// Function G01.GzGA_WeaponAim.OnHoldBreathReleasedInput
// 0x0004 (0x0004 - 0x0000)
struct GzGA_WeaponAim_OnHoldBreathReleasedInput final
{
public:
	float                                         TimeHeld;                                          // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzGA_WeaponAim_OnHoldBreathReleasedInput) == 0x000004, "Wrong alignment on GzGA_WeaponAim_OnHoldBreathReleasedInput");
static_assert(sizeof(GzGA_WeaponAim_OnHoldBreathReleasedInput) == 0x000004, "Wrong size on GzGA_WeaponAim_OnHoldBreathReleasedInput");
static_assert(offsetof(GzGA_WeaponAim_OnHoldBreathReleasedInput, TimeHeld) == 0x000000, "Member 'GzGA_WeaponAim_OnHoldBreathReleasedInput::TimeHeld' has a wrong offset!");

// Function G01.GzCyberLimbsPanel_Limb.OnActivationStateUpdated
// 0x0001 (0x0001 - 0x0000)
struct GzCyberLimbsPanel_Limb_OnActivationStateUpdated final
{
public:
	EGzLimbWidgetState                            NewState;                                          // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzCyberLimbsPanel_Limb_OnActivationStateUpdated) == 0x000001, "Wrong alignment on GzCyberLimbsPanel_Limb_OnActivationStateUpdated");
static_assert(sizeof(GzCyberLimbsPanel_Limb_OnActivationStateUpdated) == 0x000001, "Wrong size on GzCyberLimbsPanel_Limb_OnActivationStateUpdated");
static_assert(offsetof(GzCyberLimbsPanel_Limb_OnActivationStateUpdated, NewState) == 0x000000, "Member 'GzCyberLimbsPanel_Limb_OnActivationStateUpdated::NewState' has a wrong offset!");

// Function G01.GzCyberLimbsPanel_Limb.OnLimbAbilityComponentUpdated
// 0x0001 (0x0001 - 0x0000)
struct GzCyberLimbsPanel_Limb_OnLimbAbilityComponentUpdated final
{
public:
	bool                                          bLimbAbilityComponentValid;                        // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzCyberLimbsPanel_Limb_OnLimbAbilityComponentUpdated) == 0x000001, "Wrong alignment on GzCyberLimbsPanel_Limb_OnLimbAbilityComponentUpdated");
static_assert(sizeof(GzCyberLimbsPanel_Limb_OnLimbAbilityComponentUpdated) == 0x000001, "Wrong size on GzCyberLimbsPanel_Limb_OnLimbAbilityComponentUpdated");
static_assert(offsetof(GzCyberLimbsPanel_Limb_OnLimbAbilityComponentUpdated, bLimbAbilityComponentValid) == 0x000000, "Member 'GzCyberLimbsPanel_Limb_OnLimbAbilityComponentUpdated::bLimbAbilityComponentValid' has a wrong offset!");

// Function G01.GzCyberLimbsPanel_Limb.OnLimbAbilityUpdated
// 0x0001 (0x0001 - 0x0000)
struct GzCyberLimbsPanel_Limb_OnLimbAbilityUpdated final
{
public:
	bool                                          bLimbAbilityValid;                                 // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzCyberLimbsPanel_Limb_OnLimbAbilityUpdated) == 0x000001, "Wrong alignment on GzCyberLimbsPanel_Limb_OnLimbAbilityUpdated");
static_assert(sizeof(GzCyberLimbsPanel_Limb_OnLimbAbilityUpdated) == 0x000001, "Wrong size on GzCyberLimbsPanel_Limb_OnLimbAbilityUpdated");
static_assert(offsetof(GzCyberLimbsPanel_Limb_OnLimbAbilityUpdated, bLimbAbilityValid) == 0x000000, "Member 'GzCyberLimbsPanel_Limb_OnLimbAbilityUpdated::bLimbAbilityValid' has a wrong offset!");

// Function G01.GzCyberLimbsPanel_Limb.OnLimbAtMaxCharges
// 0x0001 (0x0001 - 0x0000)
struct GzCyberLimbsPanel_Limb_OnLimbAtMaxCharges final
{
public:
	bool                                          bHaveMaxCharges;                                   // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzCyberLimbsPanel_Limb_OnLimbAtMaxCharges) == 0x000001, "Wrong alignment on GzCyberLimbsPanel_Limb_OnLimbAtMaxCharges");
static_assert(sizeof(GzCyberLimbsPanel_Limb_OnLimbAtMaxCharges) == 0x000001, "Wrong size on GzCyberLimbsPanel_Limb_OnLimbAtMaxCharges");
static_assert(offsetof(GzCyberLimbsPanel_Limb_OnLimbAtMaxCharges, bHaveMaxCharges) == 0x000000, "Member 'GzCyberLimbsPanel_Limb_OnLimbAtMaxCharges::bHaveMaxCharges' has a wrong offset!");

// Function G01.GzCyberLimbsPanel_Limb.OnLimbChanged
// 0x0001 (0x0001 - 0x0000)
struct GzCyberLimbsPanel_Limb_OnLimbChanged final
{
public:
	EGzLimbType                                   LimbType;                                          // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzCyberLimbsPanel_Limb_OnLimbChanged) == 0x000001, "Wrong alignment on GzCyberLimbsPanel_Limb_OnLimbChanged");
static_assert(sizeof(GzCyberLimbsPanel_Limb_OnLimbChanged) == 0x000001, "Wrong size on GzCyberLimbsPanel_Limb_OnLimbChanged");
static_assert(offsetof(GzCyberLimbsPanel_Limb_OnLimbChanged, LimbType) == 0x000000, "Member 'GzCyberLimbsPanel_Limb_OnLimbChanged::LimbType' has a wrong offset!");

// Function G01.GzCyberLimbsPanel_Limb.OnLimbCooldown
// 0x0001 (0x0001 - 0x0000)
struct GzCyberLimbsPanel_Limb_OnLimbCooldown final
{
public:
	bool                                          bOnCooldown;                                       // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzCyberLimbsPanel_Limb_OnLimbCooldown) == 0x000001, "Wrong alignment on GzCyberLimbsPanel_Limb_OnLimbCooldown");
static_assert(sizeof(GzCyberLimbsPanel_Limb_OnLimbCooldown) == 0x000001, "Wrong size on GzCyberLimbsPanel_Limb_OnLimbCooldown");
static_assert(offsetof(GzCyberLimbsPanel_Limb_OnLimbCooldown, bOnCooldown) == 0x000000, "Member 'GzCyberLimbsPanel_Limb_OnLimbCooldown::bOnCooldown' has a wrong offset!");

// Function G01.GzCyberLimbsPanel_Limb.OnLimbRecharging
// 0x0001 (0x0001 - 0x0000)
struct GzCyberLimbsPanel_Limb_OnLimbRecharging final
{
public:
	bool                                          bRecharging;                                       // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzCyberLimbsPanel_Limb_OnLimbRecharging) == 0x000001, "Wrong alignment on GzCyberLimbsPanel_Limb_OnLimbRecharging");
static_assert(sizeof(GzCyberLimbsPanel_Limb_OnLimbRecharging) == 0x000001, "Wrong size on GzCyberLimbsPanel_Limb_OnLimbRecharging");
static_assert(offsetof(GzCyberLimbsPanel_Limb_OnLimbRecharging, bRecharging) == 0x000000, "Member 'GzCyberLimbsPanel_Limb_OnLimbRecharging::bRecharging' has a wrong offset!");

// Function G01.GzCyberLimbsPanel_Limb.OnLimbUpdated
// 0x0001 (0x0001 - 0x0000)
struct GzCyberLimbsPanel_Limb_OnLimbUpdated final
{
public:
	bool                                          bLimbValid;                                        // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzCyberLimbsPanel_Limb_OnLimbUpdated) == 0x000001, "Wrong alignment on GzCyberLimbsPanel_Limb_OnLimbUpdated");
static_assert(sizeof(GzCyberLimbsPanel_Limb_OnLimbUpdated) == 0x000001, "Wrong size on GzCyberLimbsPanel_Limb_OnLimbUpdated");
static_assert(offsetof(GzCyberLimbsPanel_Limb_OnLimbUpdated, bLimbValid) == 0x000000, "Member 'GzCyberLimbsPanel_Limb_OnLimbUpdated::bLimbValid' has a wrong offset!");

// Function G01.GzPlatformsCheatExtension.SetPlatformType
// 0x0010 (0x0010 - 0x0000)
struct GzPlatformsCheatExtension_SetPlatformType final
{
public:
	class FString                                 PlatformType;                                      // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzPlatformsCheatExtension_SetPlatformType) == 0x000008, "Wrong alignment on GzPlatformsCheatExtension_SetPlatformType");
static_assert(sizeof(GzPlatformsCheatExtension_SetPlatformType) == 0x000010, "Wrong size on GzPlatformsCheatExtension_SetPlatformType");
static_assert(offsetof(GzPlatformsCheatExtension_SetPlatformType, PlatformType) == 0x000000, "Member 'GzPlatformsCheatExtension_SetPlatformType::PlatformType' has a wrong offset!");

// Function G01.GzGA_WingsuitBoost.IsBoostActivate
// 0x0001 (0x0001 - 0x0000)
struct GzGA_WingsuitBoost_IsBoostActivate final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzGA_WingsuitBoost_IsBoostActivate) == 0x000001, "Wrong alignment on GzGA_WingsuitBoost_IsBoostActivate");
static_assert(sizeof(GzGA_WingsuitBoost_IsBoostActivate) == 0x000001, "Wrong size on GzGA_WingsuitBoost_IsBoostActivate");
static_assert(offsetof(GzGA_WingsuitBoost_IsBoostActivate, ReturnValue) == 0x000000, "Member 'GzGA_WingsuitBoost_IsBoostActivate::ReturnValue' has a wrong offset!");

// Function G01.GzSoundNotifyStateBase.SetActionType
// 0x0008 (0x0008 - 0x0000)
struct GzSoundNotifyStateBase_SetActionType final
{
public:
	class FName                                   InActionType;                                      // 0x0000(0x0008)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzSoundNotifyStateBase_SetActionType) == 0x000004, "Wrong alignment on GzSoundNotifyStateBase_SetActionType");
static_assert(sizeof(GzSoundNotifyStateBase_SetActionType) == 0x000008, "Wrong size on GzSoundNotifyStateBase_SetActionType");
static_assert(offsetof(GzSoundNotifyStateBase_SetActionType, InActionType) == 0x000000, "Member 'GzSoundNotifyStateBase_SetActionType::InActionType' has a wrong offset!");

// Function G01.GzSoundNotifyStateBase.SetSoundSourceBodyPart
// 0x0001 (0x0001 - 0x0000)
struct GzSoundNotifyStateBase_SetSoundSourceBodyPart final
{
public:
	EGzSoundSourceBodyPart                        InSoundSourceBodyPart;                             // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzSoundNotifyStateBase_SetSoundSourceBodyPart) == 0x000001, "Wrong alignment on GzSoundNotifyStateBase_SetSoundSourceBodyPart");
static_assert(sizeof(GzSoundNotifyStateBase_SetSoundSourceBodyPart) == 0x000001, "Wrong size on GzSoundNotifyStateBase_SetSoundSourceBodyPart");
static_assert(offsetof(GzSoundNotifyStateBase_SetSoundSourceBodyPart, InSoundSourceBodyPart) == 0x000000, "Member 'GzSoundNotifyStateBase_SetSoundSourceBodyPart::InSoundSourceBodyPart' has a wrong offset!");

// Function G01.GzCustomizationSoundNotifyState.SetSlot
// 0x0008 (0x0008 - 0x0000)
struct GzCustomizationSoundNotifyState_SetSlot final
{
public:
	struct FGameplayTag                           InSlot;                                            // 0x0000(0x0008)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzCustomizationSoundNotifyState_SetSlot) == 0x000004, "Wrong alignment on GzCustomizationSoundNotifyState_SetSlot");
static_assert(sizeof(GzCustomizationSoundNotifyState_SetSlot) == 0x000008, "Wrong size on GzCustomizationSoundNotifyState_SetSlot");
static_assert(offsetof(GzCustomizationSoundNotifyState_SetSlot, InSlot) == 0x000000, "Member 'GzCustomizationSoundNotifyState_SetSlot::InSlot' has a wrong offset!");

// Function G01.GzWeaponItemData.GetSuitableAndOverriddenDefaultAttachments
// 0x0050 (0x0050 - 0x0000)
struct GzWeaponItemData_GetSuitableAndOverriddenDefaultAttachments final
{
public:
	TMap<EGzWeaponAttachmentType, struct FGzSuitableAttachmentsCategory> ReturnValue;                                       // 0x0000(0x0050)(Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzWeaponItemData_GetSuitableAndOverriddenDefaultAttachments) == 0x000008, "Wrong alignment on GzWeaponItemData_GetSuitableAndOverriddenDefaultAttachments");
static_assert(sizeof(GzWeaponItemData_GetSuitableAndOverriddenDefaultAttachments) == 0x000050, "Wrong size on GzWeaponItemData_GetSuitableAndOverriddenDefaultAttachments");
static_assert(offsetof(GzWeaponItemData_GetSuitableAndOverriddenDefaultAttachments, ReturnValue) == 0x000000, "Member 'GzWeaponItemData_GetSuitableAndOverriddenDefaultAttachments::ReturnValue' has a wrong offset!");

// Function G01.GzWeaponItemData.GetSuitableAttachmentsList
// 0x0018 (0x0018 - 0x0000)
struct GzWeaponItemData_GetSuitableAttachmentsList final
{
public:
	bool                                          bIncludeDefaults;                                  // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_30DB[0x7];                                     // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UGzWeaponAttachmentItemData*>    ReturnValue;                                       // 0x0008(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzWeaponItemData_GetSuitableAttachmentsList) == 0x000008, "Wrong alignment on GzWeaponItemData_GetSuitableAttachmentsList");
static_assert(sizeof(GzWeaponItemData_GetSuitableAttachmentsList) == 0x000018, "Wrong size on GzWeaponItemData_GetSuitableAttachmentsList");
static_assert(offsetof(GzWeaponItemData_GetSuitableAttachmentsList, bIncludeDefaults) == 0x000000, "Member 'GzWeaponItemData_GetSuitableAttachmentsList::bIncludeDefaults' has a wrong offset!");
static_assert(offsetof(GzWeaponItemData_GetSuitableAttachmentsList, ReturnValue) == 0x000008, "Member 'GzWeaponItemData_GetSuitableAttachmentsList::ReturnValue' has a wrong offset!");

// Function G01.GzHUDView.NotifyOnAbilityActivated
// 0x0008 (0x0008 - 0x0000)
struct GzHUDView_NotifyOnAbilityActivated final
{
public:
	class UGameplayAbility*                       GameplayAbility;                                   // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzHUDView_NotifyOnAbilityActivated) == 0x000008, "Wrong alignment on GzHUDView_NotifyOnAbilityActivated");
static_assert(sizeof(GzHUDView_NotifyOnAbilityActivated) == 0x000008, "Wrong size on GzHUDView_NotifyOnAbilityActivated");
static_assert(offsetof(GzHUDView_NotifyOnAbilityActivated, GameplayAbility) == 0x000000, "Member 'GzHUDView_NotifyOnAbilityActivated::GameplayAbility' has a wrong offset!");

// Function G01.GzHUDView.NotifyOnAbilityEnded
// 0x0008 (0x0008 - 0x0000)
struct GzHUDView_NotifyOnAbilityEnded final
{
public:
	class UGameplayAbility*                       GameplayAbility;                                   // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzHUDView_NotifyOnAbilityEnded) == 0x000008, "Wrong alignment on GzHUDView_NotifyOnAbilityEnded");
static_assert(sizeof(GzHUDView_NotifyOnAbilityEnded) == 0x000008, "Wrong size on GzHUDView_NotifyOnAbilityEnded");
static_assert(offsetof(GzHUDView_NotifyOnAbilityEnded, GameplayAbility) == 0x000000, "Member 'GzHUDView_NotifyOnAbilityEnded::GameplayAbility' has a wrong offset!");

// Function G01.GzHUDView.OnAbilityActivated
// 0x0008 (0x0008 - 0x0000)
struct GzHUDView_OnAbilityActivated final
{
public:
	class UGzGameplayAbility*                     GameplayAbility;                                   // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzHUDView_OnAbilityActivated) == 0x000008, "Wrong alignment on GzHUDView_OnAbilityActivated");
static_assert(sizeof(GzHUDView_OnAbilityActivated) == 0x000008, "Wrong size on GzHUDView_OnAbilityActivated");
static_assert(offsetof(GzHUDView_OnAbilityActivated, GameplayAbility) == 0x000000, "Member 'GzHUDView_OnAbilityActivated::GameplayAbility' has a wrong offset!");

// Function G01.GzHUDView.OnAbilityEnded
// 0x0008 (0x0008 - 0x0000)
struct GzHUDView_OnAbilityEnded final
{
public:
	class UGzGameplayAbility*                     GameplayAbility;                                   // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzHUDView_OnAbilityEnded) == 0x000008, "Wrong alignment on GzHUDView_OnAbilityEnded");
static_assert(sizeof(GzHUDView_OnAbilityEnded) == 0x000008, "Wrong size on GzHUDView_OnAbilityEnded");
static_assert(offsetof(GzHUDView_OnAbilityEnded, GameplayAbility) == 0x000000, "Member 'GzHUDView_OnAbilityEnded::GameplayAbility' has a wrong offset!");

// Function G01.GzHUDView.ReceiveBindEvents
// 0x0008 (0x0008 - 0x0000)
struct GzHUDView_ReceiveBindEvents final
{
public:
	class APawn*                                  NewViewTarget;                                     // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzHUDView_ReceiveBindEvents) == 0x000008, "Wrong alignment on GzHUDView_ReceiveBindEvents");
static_assert(sizeof(GzHUDView_ReceiveBindEvents) == 0x000008, "Wrong size on GzHUDView_ReceiveBindEvents");
static_assert(offsetof(GzHUDView_ReceiveBindEvents, NewViewTarget) == 0x000000, "Member 'GzHUDView_ReceiveBindEvents::NewViewTarget' has a wrong offset!");

// Function G01.GzHUDView.ReceiveUnbindEvents
// 0x0008 (0x0008 - 0x0000)
struct GzHUDView_ReceiveUnbindEvents final
{
public:
	class APawn*                                  OldViewTarget;                                     // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzHUDView_ReceiveUnbindEvents) == 0x000008, "Wrong alignment on GzHUDView_ReceiveUnbindEvents");
static_assert(sizeof(GzHUDView_ReceiveUnbindEvents) == 0x000008, "Wrong size on GzHUDView_ReceiveUnbindEvents");
static_assert(offsetof(GzHUDView_ReceiveUnbindEvents, OldViewTarget) == 0x000000, "Member 'GzHUDView_ReceiveUnbindEvents::OldViewTarget' has a wrong offset!");

// Function G01.GzHUDView.SubscribeToAttributeChange
// 0x0048 (0x0048 - 0x0000)
struct GzHUDView_SubscribeToAttributeChange final
{
public:
	struct FGameplayAttribute                     Attribute;                                         // 0x0000(0x0038)(ConstParm, Parm, OutParm, ReferenceParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TDelegate<void(float NewValue, float OldValue)> OnAttributeChanged;                                // 0x0038(0x0010)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzHUDView_SubscribeToAttributeChange) == 0x000008, "Wrong alignment on GzHUDView_SubscribeToAttributeChange");
static_assert(sizeof(GzHUDView_SubscribeToAttributeChange) == 0x000048, "Wrong size on GzHUDView_SubscribeToAttributeChange");
static_assert(offsetof(GzHUDView_SubscribeToAttributeChange, Attribute) == 0x000000, "Member 'GzHUDView_SubscribeToAttributeChange::Attribute' has a wrong offset!");
static_assert(offsetof(GzHUDView_SubscribeToAttributeChange, OnAttributeChanged) == 0x000038, "Member 'GzHUDView_SubscribeToAttributeChange::OnAttributeChanged' has a wrong offset!");

// Function G01.GzHUDView.SubscribeToTagChange
// 0x0018 (0x0018 - 0x0000)
struct GzHUDView_SubscribeToTagChange final
{
public:
	struct FGameplayTag                           Tag;                                               // 0x0000(0x0008)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TDelegate<void(bool bWasAdded)>               OnTagChanged;                                      // 0x0008(0x0010)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzHUDView_SubscribeToTagChange) == 0x000004, "Wrong alignment on GzHUDView_SubscribeToTagChange");
static_assert(sizeof(GzHUDView_SubscribeToTagChange) == 0x000018, "Wrong size on GzHUDView_SubscribeToTagChange");
static_assert(offsetof(GzHUDView_SubscribeToTagChange, Tag) == 0x000000, "Member 'GzHUDView_SubscribeToTagChange::Tag' has a wrong offset!");
static_assert(offsetof(GzHUDView_SubscribeToTagChange, OnTagChanged) == 0x000008, "Member 'GzHUDView_SubscribeToTagChange::OnTagChanged' has a wrong offset!");

// Function G01.GzHUDView.IsSpectating
// 0x0001 (0x0001 - 0x0000)
struct GzHUDView_IsSpectating final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzHUDView_IsSpectating) == 0x000001, "Wrong alignment on GzHUDView_IsSpectating");
static_assert(sizeof(GzHUDView_IsSpectating) == 0x000001, "Wrong size on GzHUDView_IsSpectating");
static_assert(offsetof(GzHUDView_IsSpectating, ReturnValue) == 0x000000, "Member 'GzHUDView_IsSpectating::ReturnValue' has a wrong offset!");

// Function G01.GzGA_SuperSprint.OnMovementModeChanged
// 0x0010 (0x0010 - 0x0000)
struct GzGA_SuperSprint_OnMovementModeChanged final
{
public:
	class ACharacter*                             Character;                                         // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EMovementMode                                 PrevMovementMode;                                  // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         PreviousCustomMode;                                // 0x0009(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_30DF[0x6];                                     // 0x000A(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GzGA_SuperSprint_OnMovementModeChanged) == 0x000008, "Wrong alignment on GzGA_SuperSprint_OnMovementModeChanged");
static_assert(sizeof(GzGA_SuperSprint_OnMovementModeChanged) == 0x000010, "Wrong size on GzGA_SuperSprint_OnMovementModeChanged");
static_assert(offsetof(GzGA_SuperSprint_OnMovementModeChanged, Character) == 0x000000, "Member 'GzGA_SuperSprint_OnMovementModeChanged::Character' has a wrong offset!");
static_assert(offsetof(GzGA_SuperSprint_OnMovementModeChanged, PrevMovementMode) == 0x000008, "Member 'GzGA_SuperSprint_OnMovementModeChanged::PrevMovementMode' has a wrong offset!");
static_assert(offsetof(GzGA_SuperSprint_OnMovementModeChanged, PreviousCustomMode) == 0x000009, "Member 'GzGA_SuperSprint_OnMovementModeChanged::PreviousCustomMode' has a wrong offset!");

// Function G01.GzGA_SuperSprint.OnSuperSprintConditionChanged
// 0x0001 (0x0001 - 0x0000)
struct GzGA_SuperSprint_OnSuperSprintConditionChanged final
{
public:
	bool                                          bCanSuperSprint;                                   // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzGA_SuperSprint_OnSuperSprintConditionChanged) == 0x000001, "Wrong alignment on GzGA_SuperSprint_OnSuperSprintConditionChanged");
static_assert(sizeof(GzGA_SuperSprint_OnSuperSprintConditionChanged) == 0x000001, "Wrong size on GzGA_SuperSprint_OnSuperSprintConditionChanged");
static_assert(offsetof(GzGA_SuperSprint_OnSuperSprintConditionChanged, bCanSuperSprint) == 0x000000, "Member 'GzGA_SuperSprint_OnSuperSprintConditionChanged::bCanSuperSprint' has a wrong offset!");

// Function G01.GzViewportMarkerWidget.GetArrowRotationAngle
// 0x0004 (0x0004 - 0x0000)
struct GzViewportMarkerWidget_GetArrowRotationAngle final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzViewportMarkerWidget_GetArrowRotationAngle) == 0x000004, "Wrong alignment on GzViewportMarkerWidget_GetArrowRotationAngle");
static_assert(sizeof(GzViewportMarkerWidget_GetArrowRotationAngle) == 0x000004, "Wrong size on GzViewportMarkerWidget_GetArrowRotationAngle");
static_assert(offsetof(GzViewportMarkerWidget_GetArrowRotationAngle, ReturnValue) == 0x000000, "Member 'GzViewportMarkerWidget_GetArrowRotationAngle::ReturnValue' has a wrong offset!");

// Function G01.GzViewportMarkerWidget.OnMarkerFocusChanged
// 0x0001 (0x0001 - 0x0000)
struct GzViewportMarkerWidget_OnMarkerFocusChanged final
{
public:
	bool                                          bIsFocused;                                        // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzViewportMarkerWidget_OnMarkerFocusChanged) == 0x000001, "Wrong alignment on GzViewportMarkerWidget_OnMarkerFocusChanged");
static_assert(sizeof(GzViewportMarkerWidget_OnMarkerFocusChanged) == 0x000001, "Wrong size on GzViewportMarkerWidget_OnMarkerFocusChanged");
static_assert(offsetof(GzViewportMarkerWidget_OnMarkerFocusChanged, bIsFocused) == 0x000000, "Member 'GzViewportMarkerWidget_OnMarkerFocusChanged::bIsFocused' has a wrong offset!");

// Function G01.GzViewportMarkerWidget.OnMarkerFocusChangedBP
// 0x0001 (0x0001 - 0x0000)
struct GzViewportMarkerWidget_OnMarkerFocusChangedBP final
{
public:
	bool                                          bIsFocused;                                        // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzViewportMarkerWidget_OnMarkerFocusChangedBP) == 0x000001, "Wrong alignment on GzViewportMarkerWidget_OnMarkerFocusChangedBP");
static_assert(sizeof(GzViewportMarkerWidget_OnMarkerFocusChangedBP) == 0x000001, "Wrong size on GzViewportMarkerWidget_OnMarkerFocusChangedBP");
static_assert(offsetof(GzViewportMarkerWidget_OnMarkerFocusChangedBP, bIsFocused) == 0x000000, "Member 'GzViewportMarkerWidget_OnMarkerFocusChangedBP::bIsFocused' has a wrong offset!");

// Function G01.GzViewportMarkerWidget.UpdateDistanceToViewTarget
// 0x0004 (0x0004 - 0x0000)
struct GzViewportMarkerWidget_UpdateDistanceToViewTarget final
{
public:
	float                                         Distance;                                          // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzViewportMarkerWidget_UpdateDistanceToViewTarget) == 0x000004, "Wrong alignment on GzViewportMarkerWidget_UpdateDistanceToViewTarget");
static_assert(sizeof(GzViewportMarkerWidget_UpdateDistanceToViewTarget) == 0x000004, "Wrong size on GzViewportMarkerWidget_UpdateDistanceToViewTarget");
static_assert(offsetof(GzViewportMarkerWidget_UpdateDistanceToViewTarget, Distance) == 0x000000, "Member 'GzViewportMarkerWidget_UpdateDistanceToViewTarget::Distance' has a wrong offset!");

// Function G01.GzViewportMarkerWidget.GetDistanceToTarget
// 0x0004 (0x0004 - 0x0000)
struct GzViewportMarkerWidget_GetDistanceToTarget final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzViewportMarkerWidget_GetDistanceToTarget) == 0x000004, "Wrong alignment on GzViewportMarkerWidget_GetDistanceToTarget");
static_assert(sizeof(GzViewportMarkerWidget_GetDistanceToTarget) == 0x000004, "Wrong size on GzViewportMarkerWidget_GetDistanceToTarget");
static_assert(offsetof(GzViewportMarkerWidget_GetDistanceToTarget, ReturnValue) == 0x000000, "Member 'GzViewportMarkerWidget_GetDistanceToTarget::ReturnValue' has a wrong offset!");

// Function G01.GzZoneEvent.Trigger
// 0x0060 (0x0060 - 0x0000)
struct GzZoneEvent_Trigger final
{
public:
	struct FTransform                             Transform;                                         // 0x0000(0x0060)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzZoneEvent_Trigger) == 0x000010, "Wrong alignment on GzZoneEvent_Trigger");
static_assert(sizeof(GzZoneEvent_Trigger) == 0x000060, "Wrong size on GzZoneEvent_Trigger");
static_assert(offsetof(GzZoneEvent_Trigger, Transform) == 0x000000, "Member 'GzZoneEvent_Trigger::Transform' has a wrong offset!");

// Function G01.GzDamageIndicatorSettings.GetDamageIndicatorSettings
// 0x0008 (0x0008 - 0x0000)
struct GzDamageIndicatorSettings_GetDamageIndicatorSettings final
{
public:
	class UGzDamageIndicatorSettings*             ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzDamageIndicatorSettings_GetDamageIndicatorSettings) == 0x000008, "Wrong alignment on GzDamageIndicatorSettings_GetDamageIndicatorSettings");
static_assert(sizeof(GzDamageIndicatorSettings_GetDamageIndicatorSettings) == 0x000008, "Wrong size on GzDamageIndicatorSettings_GetDamageIndicatorSettings");
static_assert(offsetof(GzDamageIndicatorSettings_GetDamageIndicatorSettings, ReturnValue) == 0x000000, "Member 'GzDamageIndicatorSettings_GetDamageIndicatorSettings::ReturnValue' has a wrong offset!");

// Function G01.GzDamageableCar.ReceiveDamage
// 0x0004 (0x0004 - 0x0000)
struct GzDamageableCar_ReceiveDamage final
{
public:
	float                                         Damage;                                            // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzDamageableCar_ReceiveDamage) == 0x000004, "Wrong alignment on GzDamageableCar_ReceiveDamage");
static_assert(sizeof(GzDamageableCar_ReceiveDamage) == 0x000004, "Wrong size on GzDamageableCar_ReceiveDamage");
static_assert(offsetof(GzDamageableCar_ReceiveDamage, Damage) == 0x000000, "Member 'GzDamageableCar_ReceiveDamage::Damage' has a wrong offset!");

// Function G01.GzDamageableCar.ReceiveHealthChanged
// 0x0004 (0x0004 - 0x0000)
struct GzDamageableCar_ReceiveHealthChanged final
{
public:
	float                                         NewHealth;                                         // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzDamageableCar_ReceiveHealthChanged) == 0x000004, "Wrong alignment on GzDamageableCar_ReceiveHealthChanged");
static_assert(sizeof(GzDamageableCar_ReceiveHealthChanged) == 0x000004, "Wrong size on GzDamageableCar_ReceiveHealthChanged");
static_assert(offsetof(GzDamageableCar_ReceiveHealthChanged, NewHealth) == 0x000000, "Member 'GzDamageableCar_ReceiveHealthChanged::NewHealth' has a wrong offset!");

// Function G01.GzSmokeMissile.OnProjectileStopped
// 0x00F8 (0x00F8 - 0x0000)
struct GzSmokeMissile_OnProjectileStopped final
{
public:
	struct FHitResult                             HitResult;                                         // 0x0000(0x00F8)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzSmokeMissile_OnProjectileStopped) == 0x000008, "Wrong alignment on GzSmokeMissile_OnProjectileStopped");
static_assert(sizeof(GzSmokeMissile_OnProjectileStopped) == 0x0000F8, "Wrong size on GzSmokeMissile_OnProjectileStopped");
static_assert(offsetof(GzSmokeMissile_OnProjectileStopped, HitResult) == 0x000000, "Member 'GzSmokeMissile_OnProjectileStopped::HitResult' has a wrong offset!");

// Function G01.GzDamageIndicator.OnDirectionAngleChanged
// 0x0004 (0x0004 - 0x0000)
struct GzDamageIndicator_OnDirectionAngleChanged final
{
public:
	float                                         NewDirectionAngle;                                 // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzDamageIndicator_OnDirectionAngleChanged) == 0x000004, "Wrong alignment on GzDamageIndicator_OnDirectionAngleChanged");
static_assert(sizeof(GzDamageIndicator_OnDirectionAngleChanged) == 0x000004, "Wrong size on GzDamageIndicator_OnDirectionAngleChanged");
static_assert(offsetof(GzDamageIndicator_OnDirectionAngleChanged, NewDirectionAngle) == 0x000000, "Member 'GzDamageIndicator_OnDirectionAngleChanged::NewDirectionAngle' has a wrong offset!");

// Function G01.GzWeaponSkinItemData.IsUdimDataValid
// 0x0001 (0x0001 - 0x0000)
struct GzWeaponSkinItemData_IsUdimDataValid final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzWeaponSkinItemData_IsUdimDataValid) == 0x000001, "Wrong alignment on GzWeaponSkinItemData_IsUdimDataValid");
static_assert(sizeof(GzWeaponSkinItemData_IsUdimDataValid) == 0x000001, "Wrong size on GzWeaponSkinItemData_IsUdimDataValid");
static_assert(offsetof(GzWeaponSkinItemData_IsUdimDataValid, ReturnValue) == 0x000000, "Member 'GzWeaponSkinItemData_IsUdimDataValid::ReturnValue' has a wrong offset!");

// Function G01.GzSceneViewpoint.ReceiveTransitionFromStarted
// 0x0004 (0x0004 - 0x0000)
struct GzSceneViewpoint_ReceiveTransitionFromStarted final
{
public:
	struct FGzTransitionEventParameters           Parameters;                                        // 0x0000(0x0004)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzSceneViewpoint_ReceiveTransitionFromStarted) == 0x000004, "Wrong alignment on GzSceneViewpoint_ReceiveTransitionFromStarted");
static_assert(sizeof(GzSceneViewpoint_ReceiveTransitionFromStarted) == 0x000004, "Wrong size on GzSceneViewpoint_ReceiveTransitionFromStarted");
static_assert(offsetof(GzSceneViewpoint_ReceiveTransitionFromStarted, Parameters) == 0x000000, "Member 'GzSceneViewpoint_ReceiveTransitionFromStarted::Parameters' has a wrong offset!");

// Function G01.GzSceneViewpoint.ReceiveTransitionToStarted
// 0x0004 (0x0004 - 0x0000)
struct GzSceneViewpoint_ReceiveTransitionToStarted final
{
public:
	struct FGzTransitionEventParameters           Parameters;                                        // 0x0000(0x0004)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzSceneViewpoint_ReceiveTransitionToStarted) == 0x000004, "Wrong alignment on GzSceneViewpoint_ReceiveTransitionToStarted");
static_assert(sizeof(GzSceneViewpoint_ReceiveTransitionToStarted) == 0x000004, "Wrong size on GzSceneViewpoint_ReceiveTransitionToStarted");
static_assert(offsetof(GzSceneViewpoint_ReceiveTransitionToStarted, Parameters) == 0x000000, "Member 'GzSceneViewpoint_ReceiveTransitionToStarted::Parameters' has a wrong offset!");

// Function G01.GzTextStylesDataAsset.GetTextStyle
// 0x0010 (0x0010 - 0x0000)
struct GzTextStylesDataAsset_GetTextStyle final
{
public:
	struct FGameplayTag                           Tag;                                               // 0x0000(0x0008)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCommonTextStyle*                       ReturnValue;                                       // 0x0008(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzTextStylesDataAsset_GetTextStyle) == 0x000008, "Wrong alignment on GzTextStylesDataAsset_GetTextStyle");
static_assert(sizeof(GzTextStylesDataAsset_GetTextStyle) == 0x000010, "Wrong size on GzTextStylesDataAsset_GetTextStyle");
static_assert(offsetof(GzTextStylesDataAsset_GetTextStyle, Tag) == 0x000000, "Member 'GzTextStylesDataAsset_GetTextStyle::Tag' has a wrong offset!");
static_assert(offsetof(GzTextStylesDataAsset_GetTextStyle, ReturnValue) == 0x000008, "Member 'GzTextStylesDataAsset_GetTextStyle::ReturnValue' has a wrong offset!");

// Function G01.GzTextStylesDataAsset.GetTextStyleClass
// 0x0010 (0x0010 - 0x0000)
struct GzTextStylesDataAsset_GetTextStyleClass final
{
public:
	struct FGameplayTag                           Tag;                                               // 0x0000(0x0008)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UCommonTextStyle>           ReturnValue;                                       // 0x0008(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzTextStylesDataAsset_GetTextStyleClass) == 0x000008, "Wrong alignment on GzTextStylesDataAsset_GetTextStyleClass");
static_assert(sizeof(GzTextStylesDataAsset_GetTextStyleClass) == 0x000010, "Wrong size on GzTextStylesDataAsset_GetTextStyleClass");
static_assert(offsetof(GzTextStylesDataAsset_GetTextStyleClass, Tag) == 0x000000, "Member 'GzTextStylesDataAsset_GetTextStyleClass::Tag' has a wrong offset!");
static_assert(offsetof(GzTextStylesDataAsset_GetTextStyleClass, ReturnValue) == 0x000008, "Member 'GzTextStylesDataAsset_GetTextStyleClass::ReturnValue' has a wrong offset!");

// Function G01.GzMissionActivatable.SetActive
// 0x0010 (0x0010 - 0x0000)
struct GzMissionActivatable_SetActive final
{
public:
	bool                                          bActive;                                           // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_30F9[0x7];                                     // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UMissionObjective*                      Objective;                                         // 0x0008(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzMissionActivatable_SetActive) == 0x000008, "Wrong alignment on GzMissionActivatable_SetActive");
static_assert(sizeof(GzMissionActivatable_SetActive) == 0x000010, "Wrong size on GzMissionActivatable_SetActive");
static_assert(offsetof(GzMissionActivatable_SetActive, bActive) == 0x000000, "Member 'GzMissionActivatable_SetActive::bActive' has a wrong offset!");
static_assert(offsetof(GzMissionActivatable_SetActive, Objective) == 0x000008, "Member 'GzMissionActivatable_SetActive::Objective' has a wrong offset!");

// Function G01.GzCloak_Gadget.Init
// 0x0060 (0x0060 - 0x0000)
struct GzCloak_Gadget_Init final
{
public:
	class AGzMultiPartCharacter*                  GadgetOwningPlayer;                                // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGzCloak_Gadget_InitInfo               InInitInfo;                                        // 0x0008(0x0058)(ConstParm, Parm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzCloak_Gadget_Init) == 0x000008, "Wrong alignment on GzCloak_Gadget_Init");
static_assert(sizeof(GzCloak_Gadget_Init) == 0x000060, "Wrong size on GzCloak_Gadget_Init");
static_assert(offsetof(GzCloak_Gadget_Init, GadgetOwningPlayer) == 0x000000, "Member 'GzCloak_Gadget_Init::GadgetOwningPlayer' has a wrong offset!");
static_assert(offsetof(GzCloak_Gadget_Init, InInitInfo) == 0x000008, "Member 'GzCloak_Gadget_Init::InInitInfo' has a wrong offset!");

// Function G01.GzComebackArena.AddComebackArenaStart
// 0x0070 (0x0070 - 0x0000)
struct GzComebackArena_AddComebackArenaStart final
{
public:
	int32                                         TeamIndex;                                         // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_30FF[0xC];                                     // 0x0004(0x000C)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             Transform;                                         // 0x0010(0x0060)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzComebackArena_AddComebackArenaStart) == 0x000010, "Wrong alignment on GzComebackArena_AddComebackArenaStart");
static_assert(sizeof(GzComebackArena_AddComebackArenaStart) == 0x000070, "Wrong size on GzComebackArena_AddComebackArenaStart");
static_assert(offsetof(GzComebackArena_AddComebackArenaStart, TeamIndex) == 0x000000, "Member 'GzComebackArena_AddComebackArenaStart::TeamIndex' has a wrong offset!");
static_assert(offsetof(GzComebackArena_AddComebackArenaStart, Transform) == 0x000010, "Member 'GzComebackArena_AddComebackArenaStart::Transform' has a wrong offset!");

// Function G01.GzComebackArena.WinComebackArenaMatch
// 0x0008 (0x0008 - 0x0000)
struct GzComebackArena_WinComebackArenaMatch final
{
public:
	class APawn*                                  WinnerActor;                                       // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzComebackArena_WinComebackArenaMatch) == 0x000008, "Wrong alignment on GzComebackArena_WinComebackArenaMatch");
static_assert(sizeof(GzComebackArena_WinComebackArenaMatch) == 0x000008, "Wrong size on GzComebackArena_WinComebackArenaMatch");
static_assert(offsetof(GzComebackArena_WinComebackArenaMatch, WinnerActor) == 0x000000, "Member 'GzComebackArena_WinComebackArenaMatch::WinnerActor' has a wrong offset!");

// Function G01.GzComebackArena.GetComebackArenaInstanceId
// 0x0004 (0x0004 - 0x0000)
struct GzComebackArena_GetComebackArenaInstanceId final
{
public:
	int32                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzComebackArena_GetComebackArenaInstanceId) == 0x000004, "Wrong alignment on GzComebackArena_GetComebackArenaInstanceId");
static_assert(sizeof(GzComebackArena_GetComebackArenaInstanceId) == 0x000004, "Wrong size on GzComebackArena_GetComebackArenaInstanceId");
static_assert(offsetof(GzComebackArena_GetComebackArenaInstanceId, ReturnValue) == 0x000000, "Member 'GzComebackArena_GetComebackArenaInstanceId::ReturnValue' has a wrong offset!");

// Function G01.GzComebackArenaContextComponent.GetComebackArena
// 0x0008 (0x0008 - 0x0000)
struct GzComebackArenaContextComponent_GetComebackArena final
{
public:
	class AGzComebackArena*                       ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzComebackArenaContextComponent_GetComebackArena) == 0x000008, "Wrong alignment on GzComebackArenaContextComponent_GetComebackArena");
static_assert(sizeof(GzComebackArenaContextComponent_GetComebackArena) == 0x000008, "Wrong size on GzComebackArenaContextComponent_GetComebackArena");
static_assert(offsetof(GzComebackArenaContextComponent_GetComebackArena, ReturnValue) == 0x000000, "Member 'GzComebackArenaContextComponent_GetComebackArena::ReturnValue' has a wrong offset!");

// Function G01.GzComebackArenaContextComponent.GetComebackArenaEndTime
// 0x0004 (0x0004 - 0x0000)
struct GzComebackArenaContextComponent_GetComebackArenaEndTime final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzComebackArenaContextComponent_GetComebackArenaEndTime) == 0x000004, "Wrong alignment on GzComebackArenaContextComponent_GetComebackArenaEndTime");
static_assert(sizeof(GzComebackArenaContextComponent_GetComebackArenaEndTime) == 0x000004, "Wrong size on GzComebackArenaContextComponent_GetComebackArenaEndTime");
static_assert(offsetof(GzComebackArenaContextComponent_GetComebackArenaEndTime, ReturnValue) == 0x000000, "Member 'GzComebackArenaContextComponent_GetComebackArenaEndTime::ReturnValue' has a wrong offset!");

// Function G01.GzComebackArenaContextComponent.GetComebackArenaQueueEnteredTime
// 0x0004 (0x0004 - 0x0000)
struct GzComebackArenaContextComponent_GetComebackArenaQueueEnteredTime final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzComebackArenaContextComponent_GetComebackArenaQueueEnteredTime) == 0x000004, "Wrong alignment on GzComebackArenaContextComponent_GetComebackArenaQueueEnteredTime");
static_assert(sizeof(GzComebackArenaContextComponent_GetComebackArenaQueueEnteredTime) == 0x000004, "Wrong size on GzComebackArenaContextComponent_GetComebackArenaQueueEnteredTime");
static_assert(offsetof(GzComebackArenaContextComponent_GetComebackArenaQueueEnteredTime, ReturnValue) == 0x000000, "Member 'GzComebackArenaContextComponent_GetComebackArenaQueueEnteredTime::ReturnValue' has a wrong offset!");

// Function G01.GzComebackArenaContextComponent.IsValidContext
// 0x0001 (0x0001 - 0x0000)
struct GzComebackArenaContextComponent_IsValidContext final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzComebackArenaContextComponent_IsValidContext) == 0x000001, "Wrong alignment on GzComebackArenaContextComponent_IsValidContext");
static_assert(sizeof(GzComebackArenaContextComponent_IsValidContext) == 0x000001, "Wrong size on GzComebackArenaContextComponent_IsValidContext");
static_assert(offsetof(GzComebackArenaContextComponent_IsValidContext, ReturnValue) == 0x000000, "Member 'GzComebackArenaContextComponent_IsValidContext::ReturnValue' has a wrong offset!");

// Function G01.PSOWeaponsLogger.IsReady
// 0x0001 (0x0001 - 0x0000)
struct PSOWeaponsLogger_IsReady final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(PSOWeaponsLogger_IsReady) == 0x000001, "Wrong alignment on PSOWeaponsLogger_IsReady");
static_assert(sizeof(PSOWeaponsLogger_IsReady) == 0x000001, "Wrong size on PSOWeaponsLogger_IsReady");
static_assert(offsetof(PSOWeaponsLogger_IsReady, ReturnValue) == 0x000000, "Member 'PSOWeaponsLogger_IsReady::ReturnValue' has a wrong offset!");

// Function G01.GzComebackArenaManager.OnComebackArenaMatchEnded
// 0x0008 (0x0008 - 0x0000)
struct GzComebackArenaManager_OnComebackArenaMatchEnded final
{
public:
	class AGzComebackArena*                       ComebackArena;                                     // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzComebackArenaManager_OnComebackArenaMatchEnded) == 0x000008, "Wrong alignment on GzComebackArenaManager_OnComebackArenaMatchEnded");
static_assert(sizeof(GzComebackArenaManager_OnComebackArenaMatchEnded) == 0x000008, "Wrong size on GzComebackArenaManager_OnComebackArenaMatchEnded");
static_assert(offsetof(GzComebackArenaManager_OnComebackArenaMatchEnded, ComebackArena) == 0x000000, "Member 'GzComebackArenaManager_OnComebackArenaMatchEnded::ComebackArena' has a wrong offset!");

// Function G01.GzComebackArenaManager.OnPlayerDisconnected
// 0x0010 (0x0010 - 0x0000)
struct GzComebackArenaManager_OnPlayerDisconnected final
{
public:
	class AGzPlayerController*                    PC;                                                // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EGzPlayerLogoutReason                         LogoutReason;                                      // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3103[0x7];                                     // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GzComebackArenaManager_OnPlayerDisconnected) == 0x000008, "Wrong alignment on GzComebackArenaManager_OnPlayerDisconnected");
static_assert(sizeof(GzComebackArenaManager_OnPlayerDisconnected) == 0x000010, "Wrong size on GzComebackArenaManager_OnPlayerDisconnected");
static_assert(offsetof(GzComebackArenaManager_OnPlayerDisconnected, PC) == 0x000000, "Member 'GzComebackArenaManager_OnPlayerDisconnected::PC' has a wrong offset!");
static_assert(offsetof(GzComebackArenaManager_OnPlayerDisconnected, LogoutReason) == 0x000008, "Member 'GzComebackArenaManager_OnPlayerDisconnected::LogoutReason' has a wrong offset!");

// Function G01.GzComebackArenaManager.SetIsActive
// 0x0001 (0x0001 - 0x0000)
struct GzComebackArenaManager_SetIsActive final
{
public:
	bool                                          bNewActive;                                        // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzComebackArenaManager_SetIsActive) == 0x000001, "Wrong alignment on GzComebackArenaManager_SetIsActive");
static_assert(sizeof(GzComebackArenaManager_SetIsActive) == 0x000001, "Wrong size on GzComebackArenaManager_SetIsActive");
static_assert(offsetof(GzComebackArenaManager_SetIsActive, bNewActive) == 0x000000, "Member 'GzComebackArenaManager_SetIsActive::bNewActive' has a wrong offset!");

// Function G01.GzCommandLineOptions.GetBackendEnvName
// 0x0010 (0x0010 - 0x0000)
struct GzCommandLineOptions_GetBackendEnvName final
{
public:
	class FString                                 ReturnValue;                                       // 0x0000(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzCommandLineOptions_GetBackendEnvName) == 0x000008, "Wrong alignment on GzCommandLineOptions_GetBackendEnvName");
static_assert(sizeof(GzCommandLineOptions_GetBackendEnvName) == 0x000010, "Wrong size on GzCommandLineOptions_GetBackendEnvName");
static_assert(offsetof(GzCommandLineOptions_GetBackendEnvName, ReturnValue) == 0x000000, "Member 'GzCommandLineOptions_GetBackendEnvName::ReturnValue' has a wrong offset!");

// Function G01.GzCommandLineOptions.GetCoherentApiTestClientMode
// 0x0001 (0x0001 - 0x0000)
struct GzCommandLineOptions_GetCoherentApiTestClientMode final
{
public:
	EGzClientMode                                 ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzCommandLineOptions_GetCoherentApiTestClientMode) == 0x000001, "Wrong alignment on GzCommandLineOptions_GetCoherentApiTestClientMode");
static_assert(sizeof(GzCommandLineOptions_GetCoherentApiTestClientMode) == 0x000001, "Wrong size on GzCommandLineOptions_GetCoherentApiTestClientMode");
static_assert(offsetof(GzCommandLineOptions_GetCoherentApiTestClientMode, ReturnValue) == 0x000000, "Member 'GzCommandLineOptions_GetCoherentApiTestClientMode::ReturnValue' has a wrong offset!");

// Function G01.GzCommandLineOptions.GetCoherentApiTestParams
// 0x0018 (0x0018 - 0x0000)
struct GzCommandLineOptions_GetCoherentApiTestParams final
{
public:
	class FString                                 ApiTestArgs;                                       // 0x0000(0x0010)(Parm, OutParm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0010(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3104[0x7];                                     // 0x0011(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GzCommandLineOptions_GetCoherentApiTestParams) == 0x000008, "Wrong alignment on GzCommandLineOptions_GetCoherentApiTestParams");
static_assert(sizeof(GzCommandLineOptions_GetCoherentApiTestParams) == 0x000018, "Wrong size on GzCommandLineOptions_GetCoherentApiTestParams");
static_assert(offsetof(GzCommandLineOptions_GetCoherentApiTestParams, ApiTestArgs) == 0x000000, "Member 'GzCommandLineOptions_GetCoherentApiTestParams::ApiTestArgs' has a wrong offset!");
static_assert(offsetof(GzCommandLineOptions_GetCoherentApiTestParams, ReturnValue) == 0x000010, "Member 'GzCommandLineOptions_GetCoherentApiTestParams::ReturnValue' has a wrong offset!");

// Function G01.GzCommandLineOptions.GetCoherentApiTestPort
// 0x0004 (0x0004 - 0x0000)
struct GzCommandLineOptions_GetCoherentApiTestPort final
{
public:
	int32                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzCommandLineOptions_GetCoherentApiTestPort) == 0x000004, "Wrong alignment on GzCommandLineOptions_GetCoherentApiTestPort");
static_assert(sizeof(GzCommandLineOptions_GetCoherentApiTestPort) == 0x000004, "Wrong size on GzCommandLineOptions_GetCoherentApiTestPort");
static_assert(offsetof(GzCommandLineOptions_GetCoherentApiTestPort, ReturnValue) == 0x000000, "Member 'GzCommandLineOptions_GetCoherentApiTestPort::ReturnValue' has a wrong offset!");

// Function G01.GzCommandLineOptions.GetEpicAuthLogin
// 0x0010 (0x0010 - 0x0000)
struct GzCommandLineOptions_GetEpicAuthLogin final
{
public:
	class FString                                 ReturnValue;                                       // 0x0000(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzCommandLineOptions_GetEpicAuthLogin) == 0x000008, "Wrong alignment on GzCommandLineOptions_GetEpicAuthLogin");
static_assert(sizeof(GzCommandLineOptions_GetEpicAuthLogin) == 0x000010, "Wrong size on GzCommandLineOptions_GetEpicAuthLogin");
static_assert(offsetof(GzCommandLineOptions_GetEpicAuthLogin, ReturnValue) == 0x000000, "Member 'GzCommandLineOptions_GetEpicAuthLogin::ReturnValue' has a wrong offset!");

// Function G01.GzCommandLineOptions.GetEpicAuthPassword
// 0x0010 (0x0010 - 0x0000)
struct GzCommandLineOptions_GetEpicAuthPassword final
{
public:
	class FString                                 ReturnValue;                                       // 0x0000(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzCommandLineOptions_GetEpicAuthPassword) == 0x000008, "Wrong alignment on GzCommandLineOptions_GetEpicAuthPassword");
static_assert(sizeof(GzCommandLineOptions_GetEpicAuthPassword) == 0x000010, "Wrong size on GzCommandLineOptions_GetEpicAuthPassword");
static_assert(offsetof(GzCommandLineOptions_GetEpicAuthPassword, ReturnValue) == 0x000000, "Member 'GzCommandLineOptions_GetEpicAuthPassword::ReturnValue' has a wrong offset!");

// Function G01.GzCommandLineOptions.GetEpicAuthType
// 0x0010 (0x0010 - 0x0000)
struct GzCommandLineOptions_GetEpicAuthType final
{
public:
	class FString                                 ReturnValue;                                       // 0x0000(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzCommandLineOptions_GetEpicAuthType) == 0x000008, "Wrong alignment on GzCommandLineOptions_GetEpicAuthType");
static_assert(sizeof(GzCommandLineOptions_GetEpicAuthType) == 0x000010, "Wrong size on GzCommandLineOptions_GetEpicAuthType");
static_assert(offsetof(GzCommandLineOptions_GetEpicAuthType, ReturnValue) == 0x000000, "Member 'GzCommandLineOptions_GetEpicAuthType::ReturnValue' has a wrong offset!");

// Function G01.GzCommandLineOptions.GetGameRegisterArgs
// 0x0010 (0x0010 - 0x0000)
struct GzCommandLineOptions_GetGameRegisterArgs final
{
public:
	class FString                                 ReturnValue;                                       // 0x0000(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzCommandLineOptions_GetGameRegisterArgs) == 0x000008, "Wrong alignment on GzCommandLineOptions_GetGameRegisterArgs");
static_assert(sizeof(GzCommandLineOptions_GetGameRegisterArgs) == 0x000010, "Wrong size on GzCommandLineOptions_GetGameRegisterArgs");
static_assert(offsetof(GzCommandLineOptions_GetGameRegisterArgs, ReturnValue) == 0x000000, "Member 'GzCommandLineOptions_GetGameRegisterArgs::ReturnValue' has a wrong offset!");

// Function G01.GzCommandLineOptions.GetMatchmakingType
// 0x0001 (0x0001 - 0x0000)
struct GzCommandLineOptions_GetMatchmakingType final
{
public:
	EGzMatchmakingType                            ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzCommandLineOptions_GetMatchmakingType) == 0x000001, "Wrong alignment on GzCommandLineOptions_GetMatchmakingType");
static_assert(sizeof(GzCommandLineOptions_GetMatchmakingType) == 0x000001, "Wrong size on GzCommandLineOptions_GetMatchmakingType");
static_assert(offsetof(GzCommandLineOptions_GetMatchmakingType, ReturnValue) == 0x000000, "Member 'GzCommandLineOptions_GetMatchmakingType::ReturnValue' has a wrong offset!");

// Function G01.GzCommandLineOptions.GetNoPlayfab
// 0x0001 (0x0001 - 0x0000)
struct GzCommandLineOptions_GetNoPlayfab final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzCommandLineOptions_GetNoPlayfab) == 0x000001, "Wrong alignment on GzCommandLineOptions_GetNoPlayfab");
static_assert(sizeof(GzCommandLineOptions_GetNoPlayfab) == 0x000001, "Wrong size on GzCommandLineOptions_GetNoPlayfab");
static_assert(offsetof(GzCommandLineOptions_GetNoPlayfab, ReturnValue) == 0x000000, "Member 'GzCommandLineOptions_GetNoPlayfab::ReturnValue' has a wrong offset!");

// Function G01.GzCommandLineOptions.GetRegisterGameName
// 0x0010 (0x0010 - 0x0000)
struct GzCommandLineOptions_GetRegisterGameName final
{
public:
	class FString                                 ReturnValue;                                       // 0x0000(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzCommandLineOptions_GetRegisterGameName) == 0x000008, "Wrong alignment on GzCommandLineOptions_GetRegisterGameName");
static_assert(sizeof(GzCommandLineOptions_GetRegisterGameName) == 0x000010, "Wrong size on GzCommandLineOptions_GetRegisterGameName");
static_assert(offsetof(GzCommandLineOptions_GetRegisterGameName, ReturnValue) == 0x000000, "Member 'GzCommandLineOptions_GetRegisterGameName::ReturnValue' has a wrong offset!");

// Function G01.GzCommandLineOptions.HasEpicParams
// 0x0001 (0x0001 - 0x0000)
struct GzCommandLineOptions_HasEpicParams final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzCommandLineOptions_HasEpicParams) == 0x000001, "Wrong alignment on GzCommandLineOptions_HasEpicParams");
static_assert(sizeof(GzCommandLineOptions_HasEpicParams) == 0x000001, "Wrong size on GzCommandLineOptions_HasEpicParams");
static_assert(offsetof(GzCommandLineOptions_HasEpicParams, ReturnValue) == 0x000000, "Member 'GzCommandLineOptions_HasEpicParams::ReturnValue' has a wrong offset!");

// Function G01.GzCommandLineOptions.IsAllowJoiningUnexpectedPlayers
// 0x0001 (0x0001 - 0x0000)
struct GzCommandLineOptions_IsAllowJoiningUnexpectedPlayers final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzCommandLineOptions_IsAllowJoiningUnexpectedPlayers) == 0x000001, "Wrong alignment on GzCommandLineOptions_IsAllowJoiningUnexpectedPlayers");
static_assert(sizeof(GzCommandLineOptions_IsAllowJoiningUnexpectedPlayers) == 0x000001, "Wrong size on GzCommandLineOptions_IsAllowJoiningUnexpectedPlayers");
static_assert(offsetof(GzCommandLineOptions_IsAllowJoiningUnexpectedPlayers, ReturnValue) == 0x000000, "Member 'GzCommandLineOptions_IsAllowJoiningUnexpectedPlayers::ReturnValue' has a wrong offset!");

// Function G01.GzCommandLineOptions.IsRunningUnattended
// 0x0001 (0x0001 - 0x0000)
struct GzCommandLineOptions_IsRunningUnattended final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzCommandLineOptions_IsRunningUnattended) == 0x000001, "Wrong alignment on GzCommandLineOptions_IsRunningUnattended");
static_assert(sizeof(GzCommandLineOptions_IsRunningUnattended) == 0x000001, "Wrong size on GzCommandLineOptions_IsRunningUnattended");
static_assert(offsetof(GzCommandLineOptions_IsRunningUnattended, ReturnValue) == 0x000000, "Member 'GzCommandLineOptions_IsRunningUnattended::ReturnValue' has a wrong offset!");

// Function G01.GzToxicSmokeMissile.OnProjectileStopped
// 0x00F8 (0x00F8 - 0x0000)
struct GzToxicSmokeMissile_OnProjectileStopped final
{
public:
	struct FHitResult                             HitResult;                                         // 0x0000(0x00F8)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzToxicSmokeMissile_OnProjectileStopped) == 0x000008, "Wrong alignment on GzToxicSmokeMissile_OnProjectileStopped");
static_assert(sizeof(GzToxicSmokeMissile_OnProjectileStopped) == 0x0000F8, "Wrong size on GzToxicSmokeMissile_OnProjectileStopped");
static_assert(offsetof(GzToxicSmokeMissile_OnProjectileStopped, HitResult) == 0x000000, "Member 'GzToxicSmokeMissile_OnProjectileStopped::HitResult' has a wrong offset!");

// Function G01.GzCompassMarkerContainer.SetParentCompassSizeBox
// 0x0008 (0x0008 - 0x0000)
struct GzCompassMarkerContainer_SetParentCompassSizeBox final
{
public:
	class USizeBox*                               InSizeBox;                                         // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzCompassMarkerContainer_SetParentCompassSizeBox) == 0x000008, "Wrong alignment on GzCompassMarkerContainer_SetParentCompassSizeBox");
static_assert(sizeof(GzCompassMarkerContainer_SetParentCompassSizeBox) == 0x000008, "Wrong size on GzCompassMarkerContainer_SetParentCompassSizeBox");
static_assert(offsetof(GzCompassMarkerContainer_SetParentCompassSizeBox, InSizeBox) == 0x000000, "Member 'GzCompassMarkerContainer_SetParentCompassSizeBox::InSizeBox' has a wrong offset!");

// Function G01.GzCompassMarkerContainer.SetParentScaleImage
// 0x0008 (0x0008 - 0x0000)
struct GzCompassMarkerContainer_SetParentScaleImage final
{
public:
	class UImage*                                 InScaleImage;                                      // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzCompassMarkerContainer_SetParentScaleImage) == 0x000008, "Wrong alignment on GzCompassMarkerContainer_SetParentScaleImage");
static_assert(sizeof(GzCompassMarkerContainer_SetParentScaleImage) == 0x000008, "Wrong size on GzCompassMarkerContainer_SetParentScaleImage");
static_assert(offsetof(GzCompassMarkerContainer_SetParentScaleImage, InScaleImage) == 0x000000, "Member 'GzCompassMarkerContainer_SetParentScaleImage::InScaleImage' has a wrong offset!");

// Function G01.GzUISystem.GetHUDRuntimeSettings
// 0x0010 (0x0010 - 0x0000)
struct GzUISystem_GetHUDRuntimeSettings final
{
public:
	const class UObject*                          WorldContextObject;                                // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UGzHUDRuntimeSettings*                  ReturnValue;                                       // 0x0008(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzUISystem_GetHUDRuntimeSettings) == 0x000008, "Wrong alignment on GzUISystem_GetHUDRuntimeSettings");
static_assert(sizeof(GzUISystem_GetHUDRuntimeSettings) == 0x000010, "Wrong size on GzUISystem_GetHUDRuntimeSettings");
static_assert(offsetof(GzUISystem_GetHUDRuntimeSettings, WorldContextObject) == 0x000000, "Member 'GzUISystem_GetHUDRuntimeSettings::WorldContextObject' has a wrong offset!");
static_assert(offsetof(GzUISystem_GetHUDRuntimeSettings, ReturnValue) == 0x000008, "Member 'GzUISystem_GetHUDRuntimeSettings::ReturnValue' has a wrong offset!");

// Function G01.GzUISystem.GetUISystem
// 0x0010 (0x0010 - 0x0000)
struct GzUISystem_GetUISystem final
{
public:
	const class UObject*                          WorldContextObject;                                // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UGzUISystem*                            ReturnValue;                                       // 0x0008(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzUISystem_GetUISystem) == 0x000008, "Wrong alignment on GzUISystem_GetUISystem");
static_assert(sizeof(GzUISystem_GetUISystem) == 0x000010, "Wrong size on GzUISystem_GetUISystem");
static_assert(offsetof(GzUISystem_GetUISystem, WorldContextObject) == 0x000000, "Member 'GzUISystem_GetUISystem::WorldContextObject' has a wrong offset!");
static_assert(offsetof(GzUISystem_GetUISystem, ReturnValue) == 0x000008, "Member 'GzUISystem_GetUISystem::ReturnValue' has a wrong offset!");

// Function G01.GzUISystem.OverrideChannelsVisibility
// 0x0002 (0x0002 - 0x0000)
struct GzUISystem_OverrideChannelsVisibility final
{
public:
	EGzUIChannels                                 Channels;                                          // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bNewVisible;                                       // 0x0001(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzUISystem_OverrideChannelsVisibility) == 0x000001, "Wrong alignment on GzUISystem_OverrideChannelsVisibility");
static_assert(sizeof(GzUISystem_OverrideChannelsVisibility) == 0x000002, "Wrong size on GzUISystem_OverrideChannelsVisibility");
static_assert(offsetof(GzUISystem_OverrideChannelsVisibility, Channels) == 0x000000, "Member 'GzUISystem_OverrideChannelsVisibility::Channels' has a wrong offset!");
static_assert(offsetof(GzUISystem_OverrideChannelsVisibility, bNewVisible) == 0x000001, "Member 'GzUISystem_OverrideChannelsVisibility::bNewVisible' has a wrong offset!");

// Function G01.GzUISystem.SetGlobalVisibility
// 0x0001 (0x0001 - 0x0000)
struct GzUISystem_SetGlobalVisibility final
{
public:
	bool                                          bNewVisible;                                       // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzUISystem_SetGlobalVisibility) == 0x000001, "Wrong alignment on GzUISystem_SetGlobalVisibility");
static_assert(sizeof(GzUISystem_SetGlobalVisibility) == 0x000001, "Wrong size on GzUISystem_SetGlobalVisibility");
static_assert(offsetof(GzUISystem_SetGlobalVisibility, bNewVisible) == 0x000000, "Member 'GzUISystem_SetGlobalVisibility::bNewVisible' has a wrong offset!");

// Function G01.GzUISystem.SetVisibleChannels
// 0x0001 (0x0001 - 0x0000)
struct GzUISystem_SetVisibleChannels final
{
public:
	EGzUIChannels                                 Channels;                                          // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzUISystem_SetVisibleChannels) == 0x000001, "Wrong alignment on GzUISystem_SetVisibleChannels");
static_assert(sizeof(GzUISystem_SetVisibleChannels) == 0x000001, "Wrong size on GzUISystem_SetVisibleChannels");
static_assert(offsetof(GzUISystem_SetVisibleChannels, Channels) == 0x000000, "Member 'GzUISystem_SetVisibleChannels::Channels' has a wrong offset!");

// Function G01.GzUISystem.GetHUD
// 0x0008 (0x0008 - 0x0000)
struct GzUISystem_GetHUD final
{
public:
	class AGzHUDBase*                             ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzUISystem_GetHUD) == 0x000008, "Wrong alignment on GzUISystem_GetHUD");
static_assert(sizeof(GzUISystem_GetHUD) == 0x000008, "Wrong size on GzUISystem_GetHUD");
static_assert(offsetof(GzUISystem_GetHUD, ReturnValue) == 0x000000, "Member 'GzUISystem_GetHUD::ReturnValue' has a wrong offset!");

// Function G01.GzUISystem.GetHUDView
// 0x0008 (0x0008 - 0x0000)
struct GzUISystem_GetHUDView final
{
public:
	class UGzHUDView*                             ReturnValue;                                       // 0x0000(0x0008)(ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzUISystem_GetHUDView) == 0x000008, "Wrong alignment on GzUISystem_GetHUDView");
static_assert(sizeof(GzUISystem_GetHUDView) == 0x000008, "Wrong size on GzUISystem_GetHUDView");
static_assert(offsetof(GzUISystem_GetHUDView, ReturnValue) == 0x000000, "Member 'GzUISystem_GetHUDView::ReturnValue' has a wrong offset!");

// Function G01.GzUISystem.GetLoadingScreenController
// 0x0008 (0x0008 - 0x0000)
struct GzUISystem_GetLoadingScreenController final
{
public:
	class UGzLoadingScreenController*             ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzUISystem_GetLoadingScreenController) == 0x000008, "Wrong alignment on GzUISystem_GetLoadingScreenController");
static_assert(sizeof(GzUISystem_GetLoadingScreenController) == 0x000008, "Wrong size on GzUISystem_GetLoadingScreenController");
static_assert(offsetof(GzUISystem_GetLoadingScreenController, ReturnValue) == 0x000000, "Member 'GzUISystem_GetLoadingScreenController::ReturnValue' has a wrong offset!");

// Function G01.GzUISystem.GetLoadingScreenManager
// 0x0008 (0x0008 - 0x0000)
struct GzUISystem_GetLoadingScreenManager final
{
public:
	class UGzLoadingScreenManager*                ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzUISystem_GetLoadingScreenManager) == 0x000008, "Wrong alignment on GzUISystem_GetLoadingScreenManager");
static_assert(sizeof(GzUISystem_GetLoadingScreenManager) == 0x000008, "Wrong size on GzUISystem_GetLoadingScreenManager");
static_assert(offsetof(GzUISystem_GetLoadingScreenManager, ReturnValue) == 0x000000, "Member 'GzUISystem_GetLoadingScreenManager::ReturnValue' has a wrong offset!");

// Function G01.GzUISystem.GetTargetMinimapWidth
// 0x0004 (0x0004 - 0x0000)
struct GzUISystem_GetTargetMinimapWidth final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzUISystem_GetTargetMinimapWidth) == 0x000004, "Wrong alignment on GzUISystem_GetTargetMinimapWidth");
static_assert(sizeof(GzUISystem_GetTargetMinimapWidth) == 0x000004, "Wrong size on GzUISystem_GetTargetMinimapWidth");
static_assert(offsetof(GzUISystem_GetTargetMinimapWidth, ReturnValue) == 0x000000, "Member 'GzUISystem_GetTargetMinimapWidth::ReturnValue' has a wrong offset!");

// Function G01.GzUISystem.GetVisibleChannels
// 0x0001 (0x0001 - 0x0000)
struct GzUISystem_GetVisibleChannels final
{
public:
	EGzUIChannels                                 ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzUISystem_GetVisibleChannels) == 0x000001, "Wrong alignment on GzUISystem_GetVisibleChannels");
static_assert(sizeof(GzUISystem_GetVisibleChannels) == 0x000001, "Wrong size on GzUISystem_GetVisibleChannels");
static_assert(offsetof(GzUISystem_GetVisibleChannels, ReturnValue) == 0x000000, "Member 'GzUISystem_GetVisibleChannels::ReturnValue' has a wrong offset!");

// Function G01.GzComposedCondition.MakeAndCondition
// 0x0020 (0x0020 - 0x0000)
struct GzComposedCondition_MakeAndCondition final
{
public:
	class AGzAdvancedMission*                     Mission;                                           // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class UGzCondition*>                   Conditions;                                        // 0x0008(0x0010)(ConstParm, Parm, ZeroConstructor, NativeAccessSpecifierPublic)
	class UGzCondition*                           ReturnValue;                                       // 0x0018(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzComposedCondition_MakeAndCondition) == 0x000008, "Wrong alignment on GzComposedCondition_MakeAndCondition");
static_assert(sizeof(GzComposedCondition_MakeAndCondition) == 0x000020, "Wrong size on GzComposedCondition_MakeAndCondition");
static_assert(offsetof(GzComposedCondition_MakeAndCondition, Mission) == 0x000000, "Member 'GzComposedCondition_MakeAndCondition::Mission' has a wrong offset!");
static_assert(offsetof(GzComposedCondition_MakeAndCondition, Conditions) == 0x000008, "Member 'GzComposedCondition_MakeAndCondition::Conditions' has a wrong offset!");
static_assert(offsetof(GzComposedCondition_MakeAndCondition, ReturnValue) == 0x000018, "Member 'GzComposedCondition_MakeAndCondition::ReturnValue' has a wrong offset!");

// Function G01.GzComposedCondition.MakeOrCondition
// 0x0020 (0x0020 - 0x0000)
struct GzComposedCondition_MakeOrCondition final
{
public:
	class AGzAdvancedMission*                     Mission;                                           // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class UGzCondition*>                   Conditions;                                        // 0x0008(0x0010)(ConstParm, Parm, ZeroConstructor, NativeAccessSpecifierPublic)
	class UGzCondition*                           ReturnValue;                                       // 0x0018(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzComposedCondition_MakeOrCondition) == 0x000008, "Wrong alignment on GzComposedCondition_MakeOrCondition");
static_assert(sizeof(GzComposedCondition_MakeOrCondition) == 0x000020, "Wrong size on GzComposedCondition_MakeOrCondition");
static_assert(offsetof(GzComposedCondition_MakeOrCondition, Mission) == 0x000000, "Member 'GzComposedCondition_MakeOrCondition::Mission' has a wrong offset!");
static_assert(offsetof(GzComposedCondition_MakeOrCondition, Conditions) == 0x000008, "Member 'GzComposedCondition_MakeOrCondition::Conditions' has a wrong offset!");
static_assert(offsetof(GzComposedCondition_MakeOrCondition, ReturnValue) == 0x000018, "Member 'GzComposedCondition_MakeOrCondition::ReturnValue' has a wrong offset!");

// Function G01.GzGA_WeaponRechamber.OnRechamberEvent
// 0x0008 (0x0008 - 0x0000)
struct GzGA_WeaponRechamber_OnRechamberEvent final
{
public:
	class FName                                   NotifyName;                                        // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzGA_WeaponRechamber_OnRechamberEvent) == 0x000004, "Wrong alignment on GzGA_WeaponRechamber_OnRechamberEvent");
static_assert(sizeof(GzGA_WeaponRechamber_OnRechamberEvent) == 0x000008, "Wrong size on GzGA_WeaponRechamber_OnRechamberEvent");
static_assert(offsetof(GzGA_WeaponRechamber_OnRechamberEvent, NotifyName) == 0x000000, "Member 'GzGA_WeaponRechamber_OnRechamberEvent::NotifyName' has a wrong offset!");

// Function G01.GzComposedObjective.MakeAllObjective
// 0x0020 (0x0020 - 0x0000)
struct GzComposedObjective_MakeAllObjective final
{
public:
	class AGzAdvancedMission*                     Mission;                                           // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class UGzObjective*>                   Objectives;                                        // 0x0008(0x0010)(ConstParm, Parm, ZeroConstructor, NativeAccessSpecifierPublic)
	class UGzObjective*                           ReturnValue;                                       // 0x0018(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzComposedObjective_MakeAllObjective) == 0x000008, "Wrong alignment on GzComposedObjective_MakeAllObjective");
static_assert(sizeof(GzComposedObjective_MakeAllObjective) == 0x000020, "Wrong size on GzComposedObjective_MakeAllObjective");
static_assert(offsetof(GzComposedObjective_MakeAllObjective, Mission) == 0x000000, "Member 'GzComposedObjective_MakeAllObjective::Mission' has a wrong offset!");
static_assert(offsetof(GzComposedObjective_MakeAllObjective, Objectives) == 0x000008, "Member 'GzComposedObjective_MakeAllObjective::Objectives' has a wrong offset!");
static_assert(offsetof(GzComposedObjective_MakeAllObjective, ReturnValue) == 0x000018, "Member 'GzComposedObjective_MakeAllObjective::ReturnValue' has a wrong offset!");

// Function G01.GzComposedObjective.MakeAnyObjective
// 0x0020 (0x0020 - 0x0000)
struct GzComposedObjective_MakeAnyObjective final
{
public:
	class AGzAdvancedMission*                     Mission;                                           // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class UGzObjective*>                   Objectives;                                        // 0x0008(0x0010)(ConstParm, Parm, ZeroConstructor, NativeAccessSpecifierPublic)
	class UGzObjective*                           ReturnValue;                                       // 0x0018(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzComposedObjective_MakeAnyObjective) == 0x000008, "Wrong alignment on GzComposedObjective_MakeAnyObjective");
static_assert(sizeof(GzComposedObjective_MakeAnyObjective) == 0x000020, "Wrong size on GzComposedObjective_MakeAnyObjective");
static_assert(offsetof(GzComposedObjective_MakeAnyObjective, Mission) == 0x000000, "Member 'GzComposedObjective_MakeAnyObjective::Mission' has a wrong offset!");
static_assert(offsetof(GzComposedObjective_MakeAnyObjective, Objectives) == 0x000008, "Member 'GzComposedObjective_MakeAnyObjective::Objectives' has a wrong offset!");
static_assert(offsetof(GzComposedObjective_MakeAnyObjective, ReturnValue) == 0x000018, "Member 'GzComposedObjective_MakeAnyObjective::ReturnValue' has a wrong offset!");

// Function G01.GzComposedObjective.MakeFirstObjective
// 0x0020 (0x0020 - 0x0000)
struct GzComposedObjective_MakeFirstObjective final
{
public:
	class AGzAdvancedMission*                     Mission;                                           // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class UGzObjective*>                   Objectives;                                        // 0x0008(0x0010)(ConstParm, Parm, ZeroConstructor, NativeAccessSpecifierPublic)
	class UGzObjective*                           ReturnValue;                                       // 0x0018(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzComposedObjective_MakeFirstObjective) == 0x000008, "Wrong alignment on GzComposedObjective_MakeFirstObjective");
static_assert(sizeof(GzComposedObjective_MakeFirstObjective) == 0x000020, "Wrong size on GzComposedObjective_MakeFirstObjective");
static_assert(offsetof(GzComposedObjective_MakeFirstObjective, Mission) == 0x000000, "Member 'GzComposedObjective_MakeFirstObjective::Mission' has a wrong offset!");
static_assert(offsetof(GzComposedObjective_MakeFirstObjective, Objectives) == 0x000008, "Member 'GzComposedObjective_MakeFirstObjective::Objectives' has a wrong offset!");
static_assert(offsetof(GzComposedObjective_MakeFirstObjective, ReturnValue) == 0x000018, "Member 'GzComposedObjective_MakeFirstObjective::ReturnValue' has a wrong offset!");

// Function G01.GzConfirmationWidget.InitCancellation
// 0x0010 (0x0010 - 0x0000)
struct GzConfirmationWidget_InitCancellation final
{
public:
	TDelegate<void()>                             Delegate;                                          // 0x0000(0x0010)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzConfirmationWidget_InitCancellation) == 0x000004, "Wrong alignment on GzConfirmationWidget_InitCancellation");
static_assert(sizeof(GzConfirmationWidget_InitCancellation) == 0x000010, "Wrong size on GzConfirmationWidget_InitCancellation");
static_assert(offsetof(GzConfirmationWidget_InitCancellation, Delegate) == 0x000000, "Member 'GzConfirmationWidget_InitCancellation::Delegate' has a wrong offset!");

// Function G01.GzConfirmationWidget.InitConfirmation
// 0x0020 (0x0020 - 0x0000)
struct GzConfirmationWidget_InitConfirmation final
{
public:
	TDelegate<void()>                             Delegate;                                          // 0x0000(0x0010)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   ConfirmationText;                                  // 0x0010(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzConfirmationWidget_InitConfirmation) == 0x000008, "Wrong alignment on GzConfirmationWidget_InitConfirmation");
static_assert(sizeof(GzConfirmationWidget_InitConfirmation) == 0x000020, "Wrong size on GzConfirmationWidget_InitConfirmation");
static_assert(offsetof(GzConfirmationWidget_InitConfirmation, Delegate) == 0x000000, "Member 'GzConfirmationWidget_InitConfirmation::Delegate' has a wrong offset!");
static_assert(offsetof(GzConfirmationWidget_InitConfirmation, ConfirmationText) == 0x000010, "Member 'GzConfirmationWidget_InitConfirmation::ConfirmationText' has a wrong offset!");

// Function G01.GzOperableObjectComponent.OnOperationStart
// 0x0008 (0x0008 - 0x0000)
struct GzOperableObjectComponent_OnOperationStart final
{
public:
	class AGzCharacter*                           NewOperatorCharacter;                              // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzOperableObjectComponent_OnOperationStart) == 0x000008, "Wrong alignment on GzOperableObjectComponent_OnOperationStart");
static_assert(sizeof(GzOperableObjectComponent_OnOperationStart) == 0x000008, "Wrong size on GzOperableObjectComponent_OnOperationStart");
static_assert(offsetof(GzOperableObjectComponent_OnOperationStart, NewOperatorCharacter) == 0x000000, "Member 'GzOperableObjectComponent_OnOperationStart::NewOperatorCharacter' has a wrong offset!");

// Function G01.GzOperableObjectComponent.OnOperationStop
// 0x0008 (0x0008 - 0x0000)
struct GzOperableObjectComponent_OnOperationStop final
{
public:
	class AGzCharacter*                           PreviousOperatorCharacter;                         // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzOperableObjectComponent_OnOperationStop) == 0x000008, "Wrong alignment on GzOperableObjectComponent_OnOperationStop");
static_assert(sizeof(GzOperableObjectComponent_OnOperationStop) == 0x000008, "Wrong size on GzOperableObjectComponent_OnOperationStop");
static_assert(offsetof(GzOperableObjectComponent_OnOperationStop, PreviousOperatorCharacter) == 0x000000, "Member 'GzOperableObjectComponent_OnOperationStop::PreviousOperatorCharacter' has a wrong offset!");

// Function G01.GzOperableObjectComponent.OnRep_OperatorCharacter
// 0x0008 (0x0008 - 0x0000)
struct GzOperableObjectComponent_OnRep_OperatorCharacter final
{
public:
	class AGzCharacter*                           PreviousOperatorCharacter;                         // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzOperableObjectComponent_OnRep_OperatorCharacter) == 0x000008, "Wrong alignment on GzOperableObjectComponent_OnRep_OperatorCharacter");
static_assert(sizeof(GzOperableObjectComponent_OnRep_OperatorCharacter) == 0x000008, "Wrong size on GzOperableObjectComponent_OnRep_OperatorCharacter");
static_assert(offsetof(GzOperableObjectComponent_OnRep_OperatorCharacter, PreviousOperatorCharacter) == 0x000000, "Member 'GzOperableObjectComponent_OnRep_OperatorCharacter::PreviousOperatorCharacter' has a wrong offset!");

// Function G01.GzOperableObjectComponent.TryStartOperation
// 0x0008 (0x0008 - 0x0000)
struct GzOperableObjectComponent_TryStartOperation final
{
public:
	class AGzCharacter*                           NewOperatorCharacter;                              // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzOperableObjectComponent_TryStartOperation) == 0x000008, "Wrong alignment on GzOperableObjectComponent_TryStartOperation");
static_assert(sizeof(GzOperableObjectComponent_TryStartOperation) == 0x000008, "Wrong size on GzOperableObjectComponent_TryStartOperation");
static_assert(offsetof(GzOperableObjectComponent_TryStartOperation, NewOperatorCharacter) == 0x000000, "Member 'GzOperableObjectComponent_TryStartOperation::NewOperatorCharacter' has a wrong offset!");

// Function G01.GzOperableObjectComponent.CanOperate
// 0x0010 (0x0010 - 0x0000)
struct GzOperableObjectComponent_CanOperate final
{
public:
	class AGzCharacter*                           NewOperatorCharacter;                              // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_310E[0x7];                                     // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GzOperableObjectComponent_CanOperate) == 0x000008, "Wrong alignment on GzOperableObjectComponent_CanOperate");
static_assert(sizeof(GzOperableObjectComponent_CanOperate) == 0x000010, "Wrong size on GzOperableObjectComponent_CanOperate");
static_assert(offsetof(GzOperableObjectComponent_CanOperate, NewOperatorCharacter) == 0x000000, "Member 'GzOperableObjectComponent_CanOperate::NewOperatorCharacter' has a wrong offset!");
static_assert(offsetof(GzOperableObjectComponent_CanOperate, ReturnValue) == 0x000008, "Member 'GzOperableObjectComponent_CanOperate::ReturnValue' has a wrong offset!");

// Function G01.GzOperableObjectComponent.GetOperatingCharacter
// 0x0008 (0x0008 - 0x0000)
struct GzOperableObjectComponent_GetOperatingCharacter final
{
public:
	class AGzCharacter*                           ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzOperableObjectComponent_GetOperatingCharacter) == 0x000008, "Wrong alignment on GzOperableObjectComponent_GetOperatingCharacter");
static_assert(sizeof(GzOperableObjectComponent_GetOperatingCharacter) == 0x000008, "Wrong size on GzOperableObjectComponent_GetOperatingCharacter");
static_assert(offsetof(GzOperableObjectComponent_GetOperatingCharacter, ReturnValue) == 0x000000, "Member 'GzOperableObjectComponent_GetOperatingCharacter::ReturnValue' has a wrong offset!");

// Function G01.GzTurretComponent.OnTurretOwnerDestroyed
// 0x0008 (0x0008 - 0x0000)
struct GzTurretComponent_OnTurretOwnerDestroyed final
{
public:
	class AActor*                                 DestroyedActor;                                    // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzTurretComponent_OnTurretOwnerDestroyed) == 0x000008, "Wrong alignment on GzTurretComponent_OnTurretOwnerDestroyed");
static_assert(sizeof(GzTurretComponent_OnTurretOwnerDestroyed) == 0x000008, "Wrong size on GzTurretComponent_OnTurretOwnerDestroyed");
static_assert(offsetof(GzTurretComponent_OnTurretOwnerDestroyed, DestroyedActor) == 0x000000, "Member 'GzTurretComponent_OnTurretOwnerDestroyed::DestroyedActor' has a wrong offset!");

// Function G01.GzTurretComponent.OnTurretWeaponActorOwnerChanged
// 0x0008 (0x0008 - 0x0000)
struct GzTurretComponent_OnTurretWeaponActorOwnerChanged final
{
public:
	class AActor*                                 NewWeaponOwner;                                    // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzTurretComponent_OnTurretWeaponActorOwnerChanged) == 0x000008, "Wrong alignment on GzTurretComponent_OnTurretWeaponActorOwnerChanged");
static_assert(sizeof(GzTurretComponent_OnTurretWeaponActorOwnerChanged) == 0x000008, "Wrong size on GzTurretComponent_OnTurretWeaponActorOwnerChanged");
static_assert(offsetof(GzTurretComponent_OnTurretWeaponActorOwnerChanged, NewWeaponOwner) == 0x000000, "Member 'GzTurretComponent_OnTurretWeaponActorOwnerChanged::NewWeaponOwner' has a wrong offset!");

// Function G01.GzTurretComponent.GetRelativeGunnerTurretOffset
// 0x0018 (0x0018 - 0x0000)
struct GzTurretComponent_GetRelativeGunnerTurretOffset final
{
public:
	struct FVector                                ReturnValue;                                       // 0x0000(0x0018)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzTurretComponent_GetRelativeGunnerTurretOffset) == 0x000008, "Wrong alignment on GzTurretComponent_GetRelativeGunnerTurretOffset");
static_assert(sizeof(GzTurretComponent_GetRelativeGunnerTurretOffset) == 0x000018, "Wrong size on GzTurretComponent_GetRelativeGunnerTurretOffset");
static_assert(offsetof(GzTurretComponent_GetRelativeGunnerTurretOffset, ReturnValue) == 0x000000, "Member 'GzTurretComponent_GetRelativeGunnerTurretOffset::ReturnValue' has a wrong offset!");

// Function G01.GzTurretComponent.GetRelativeTurretRotation
// 0x0020 (0x0020 - 0x0000)
struct GzTurretComponent_GetRelativeTurretRotation final
{
public:
	bool                                          bUseLocalRotation;                                 // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_310F[0x7];                                     // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRotator                               ReturnValue;                                       // 0x0008(0x0018)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzTurretComponent_GetRelativeTurretRotation) == 0x000008, "Wrong alignment on GzTurretComponent_GetRelativeTurretRotation");
static_assert(sizeof(GzTurretComponent_GetRelativeTurretRotation) == 0x000020, "Wrong size on GzTurretComponent_GetRelativeTurretRotation");
static_assert(offsetof(GzTurretComponent_GetRelativeTurretRotation, bUseLocalRotation) == 0x000000, "Member 'GzTurretComponent_GetRelativeTurretRotation::bUseLocalRotation' has a wrong offset!");
static_assert(offsetof(GzTurretComponent_GetRelativeTurretRotation, ReturnValue) == 0x000008, "Member 'GzTurretComponent_GetRelativeTurretRotation::ReturnValue' has a wrong offset!");

// Function G01.GzTurretComponent.GetTurretSkeletalMeshComponent
// 0x0008 (0x0008 - 0x0000)
struct GzTurretComponent_GetTurretSkeletalMeshComponent final
{
public:
	class USkeletalMeshComponent*                 ReturnValue;                                       // 0x0000(0x0008)(ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzTurretComponent_GetTurretSkeletalMeshComponent) == 0x000008, "Wrong alignment on GzTurretComponent_GetTurretSkeletalMeshComponent");
static_assert(sizeof(GzTurretComponent_GetTurretSkeletalMeshComponent) == 0x000008, "Wrong size on GzTurretComponent_GetTurretSkeletalMeshComponent");
static_assert(offsetof(GzTurretComponent_GetTurretSkeletalMeshComponent, ReturnValue) == 0x000000, "Member 'GzTurretComponent_GetTurretSkeletalMeshComponent::ReturnValue' has a wrong offset!");

// Function G01.GzTurretComponent.GetTurretWeaponActor
// 0x0008 (0x0008 - 0x0000)
struct GzTurretComponent_GetTurretWeaponActor final
{
public:
	class AGzTurretWeaponActor*                   ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzTurretComponent_GetTurretWeaponActor) == 0x000008, "Wrong alignment on GzTurretComponent_GetTurretWeaponActor");
static_assert(sizeof(GzTurretComponent_GetTurretWeaponActor) == 0x000008, "Wrong size on GzTurretComponent_GetTurretWeaponActor");
static_assert(offsetof(GzTurretComponent_GetTurretWeaponActor, ReturnValue) == 0x000000, "Member 'GzTurretComponent_GetTurretWeaponActor::ReturnValue' has a wrong offset!");

// Function G01.GzHexExtractionReconstitutedMessage.SetExtractionProgressTime
// 0x0004 (0x0004 - 0x0000)
struct GzHexExtractionReconstitutedMessage_SetExtractionProgressTime final
{
public:
	float                                         Time;                                              // 0x0000(0x0004)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzHexExtractionReconstitutedMessage_SetExtractionProgressTime) == 0x000004, "Wrong alignment on GzHexExtractionReconstitutedMessage_SetExtractionProgressTime");
static_assert(sizeof(GzHexExtractionReconstitutedMessage_SetExtractionProgressTime) == 0x000004, "Wrong size on GzHexExtractionReconstitutedMessage_SetExtractionProgressTime");
static_assert(offsetof(GzHexExtractionReconstitutedMessage_SetExtractionProgressTime, Time) == 0x000000, "Member 'GzHexExtractionReconstitutedMessage_SetExtractionProgressTime::Time' has a wrong offset!");

// Function G01.GzHexExtractionReconstitutedMessage.GetExtractionProgressTime
// 0x0004 (0x0004 - 0x0000)
struct GzHexExtractionReconstitutedMessage_GetExtractionProgressTime final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzHexExtractionReconstitutedMessage_GetExtractionProgressTime) == 0x000004, "Wrong alignment on GzHexExtractionReconstitutedMessage_GetExtractionProgressTime");
static_assert(sizeof(GzHexExtractionReconstitutedMessage_GetExtractionProgressTime) == 0x000004, "Wrong size on GzHexExtractionReconstitutedMessage_GetExtractionProgressTime");
static_assert(offsetof(GzHexExtractionReconstitutedMessage_GetExtractionProgressTime, ReturnValue) == 0x000000, "Member 'GzHexExtractionReconstitutedMessage_GetExtractionProgressTime::ReturnValue' has a wrong offset!");

// Function G01.GzCrosshair.OnAdsUpdated
// 0x0001 (0x0001 - 0x0000)
struct GzCrosshair_OnAdsUpdated final
{
public:
	bool                                          bIsInAds;                                          // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzCrosshair_OnAdsUpdated) == 0x000001, "Wrong alignment on GzCrosshair_OnAdsUpdated");
static_assert(sizeof(GzCrosshair_OnAdsUpdated) == 0x000001, "Wrong size on GzCrosshair_OnAdsUpdated");
static_assert(offsetof(GzCrosshair_OnAdsUpdated, bIsInAds) == 0x000000, "Member 'GzCrosshair_OnAdsUpdated::bIsInAds' has a wrong offset!");

// Function G01.GzCrosshair.OnLimbChanged
// 0x0001 (0x0001 - 0x0000)
struct GzCrosshair_OnLimbChanged final
{
public:
	EGzLimbType                                   LimbType;                                          // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzCrosshair_OnLimbChanged) == 0x000001, "Wrong alignment on GzCrosshair_OnLimbChanged");
static_assert(sizeof(GzCrosshair_OnLimbChanged) == 0x000001, "Wrong size on GzCrosshair_OnLimbChanged");
static_assert(offsetof(GzCrosshair_OnLimbChanged, LimbType) == 0x000000, "Member 'GzCrosshair_OnLimbChanged::LimbType' has a wrong offset!");

// Function G01.GzCrosshair.OnAimUpdated
// 0x0020 (0x0020 - 0x0000)
struct GzCrosshair_OnAimUpdated final
{
public:
	struct FVector                                blockedLocation;                                   // 0x0000(0x0018)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsBlocked;                                        // 0x0018(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3123[0x7];                                     // 0x0019(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GzCrosshair_OnAimUpdated) == 0x000008, "Wrong alignment on GzCrosshair_OnAimUpdated");
static_assert(sizeof(GzCrosshair_OnAimUpdated) == 0x000020, "Wrong size on GzCrosshair_OnAimUpdated");
static_assert(offsetof(GzCrosshair_OnAimUpdated, blockedLocation) == 0x000000, "Member 'GzCrosshair_OnAimUpdated::blockedLocation' has a wrong offset!");
static_assert(offsetof(GzCrosshair_OnAimUpdated, bIsBlocked) == 0x000018, "Member 'GzCrosshair_OnAimUpdated::bIsBlocked' has a wrong offset!");

// Function G01.GzWeaponAdsSystem.UpdateScopeMeshLocation
// 0x0004 (0x0004 - 0x0000)
struct GzWeaponAdsSystem_UpdateScopeMeshLocation final
{
public:
	float                                         InFOV;                                             // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzWeaponAdsSystem_UpdateScopeMeshLocation) == 0x000004, "Wrong alignment on GzWeaponAdsSystem_UpdateScopeMeshLocation");
static_assert(sizeof(GzWeaponAdsSystem_UpdateScopeMeshLocation) == 0x000004, "Wrong size on GzWeaponAdsSystem_UpdateScopeMeshLocation");
static_assert(offsetof(GzWeaponAdsSystem_UpdateScopeMeshLocation, InFOV) == 0x000000, "Member 'GzWeaponAdsSystem_UpdateScopeMeshLocation::InFOV' has a wrong offset!");

// Function G01.GzWeaponAdsSystem.GetCurrenMagnification
// 0x0004 (0x0004 - 0x0000)
struct GzWeaponAdsSystem_GetCurrenMagnification final
{
public:
	int32                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzWeaponAdsSystem_GetCurrenMagnification) == 0x000004, "Wrong alignment on GzWeaponAdsSystem_GetCurrenMagnification");
static_assert(sizeof(GzWeaponAdsSystem_GetCurrenMagnification) == 0x000004, "Wrong size on GzWeaponAdsSystem_GetCurrenMagnification");
static_assert(offsetof(GzWeaponAdsSystem_GetCurrenMagnification, ReturnValue) == 0x000000, "Member 'GzWeaponAdsSystem_GetCurrenMagnification::ReturnValue' has a wrong offset!");

// Function G01.GzWeaponAdsSystem.GetCurrentScopeMode
// 0x0080 (0x0080 - 0x0000)
struct GzWeaponAdsSystem_GetCurrentScopeMode final
{
public:
	struct FGzScopeMode                           ReturnValue;                                       // 0x0000(0x0080)(ConstParm, Parm, OutParm, ReturnParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzWeaponAdsSystem_GetCurrentScopeMode) == 0x000008, "Wrong alignment on GzWeaponAdsSystem_GetCurrentScopeMode");
static_assert(sizeof(GzWeaponAdsSystem_GetCurrentScopeMode) == 0x000080, "Wrong size on GzWeaponAdsSystem_GetCurrentScopeMode");
static_assert(offsetof(GzWeaponAdsSystem_GetCurrentScopeMode, ReturnValue) == 0x000000, "Member 'GzWeaponAdsSystem_GetCurrentScopeMode::ReturnValue' has a wrong offset!");

// Function G01.GzShield.HandleHit
// 0x0001 (0x0001 - 0x0000)
struct GzShield_HandleHit final
{
public:
	bool                                          bHitFromFront;                                     // 0x0000(0x0001)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzShield_HandleHit) == 0x000001, "Wrong alignment on GzShield_HandleHit");
static_assert(sizeof(GzShield_HandleHit) == 0x000001, "Wrong size on GzShield_HandleHit");
static_assert(offsetof(GzShield_HandleHit, bHitFromFront) == 0x000000, "Member 'GzShield_HandleHit::bHitFromFront' has a wrong offset!");

// Function G01.GzShield.OnHealthChanged
// 0x02A8 (0x02A8 - 0x0000)
struct GzShield_OnHealthChanged final
{
public:
	struct FGameplayEffectSpec                    Spec;                                              // 0x0000(0x02A0)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	float                                         Value;                                             // 0x02A0(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_313B[0x4];                                     // 0x02A4(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GzShield_OnHealthChanged) == 0x000008, "Wrong alignment on GzShield_OnHealthChanged");
static_assert(sizeof(GzShield_OnHealthChanged) == 0x0002A8, "Wrong size on GzShield_OnHealthChanged");
static_assert(offsetof(GzShield_OnHealthChanged, Spec) == 0x000000, "Member 'GzShield_OnHealthChanged::Spec' has a wrong offset!");
static_assert(offsetof(GzShield_OnHealthChanged, Value) == 0x0002A0, "Member 'GzShield_OnHealthChanged::Value' has a wrong offset!");

// Function G01.GzShield.SpawnBulletImpactVFX
// 0x0018 (0x0018 - 0x0000)
struct GzShield_SpawnBulletImpactVFX final
{
public:
	struct FVector                                HitLocation;                                       // 0x0000(0x0018)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzShield_SpawnBulletImpactVFX) == 0x000008, "Wrong alignment on GzShield_SpawnBulletImpactVFX");
static_assert(sizeof(GzShield_SpawnBulletImpactVFX) == 0x000018, "Wrong size on GzShield_SpawnBulletImpactVFX");
static_assert(offsetof(GzShield_SpawnBulletImpactVFX, HitLocation) == 0x000000, "Member 'GzShield_SpawnBulletImpactVFX::HitLocation' has a wrong offset!");

// Function G01.GzThrowableShield.HandleShieldMeshBeginOverlap
// 0x0118 (0x0118 - 0x0000)
struct GzThrowableShield_HandleShieldMeshBeginOverlap final
{
public:
	class UPrimitiveComponent*                    OverlappedComponent;                               // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 OtherActor;                                        // 0x0008(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UPrimitiveComponent*                    OtherComp;                                         // 0x0010(0x0008)(Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         OtherBodyIndex;                                    // 0x0018(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bFromSweep;                                        // 0x001C(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_313E[0x3];                                     // 0x001D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FHitResult                             SweepResul;                                        // 0x0020(0x00F8)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzThrowableShield_HandleShieldMeshBeginOverlap) == 0x000008, "Wrong alignment on GzThrowableShield_HandleShieldMeshBeginOverlap");
static_assert(sizeof(GzThrowableShield_HandleShieldMeshBeginOverlap) == 0x000118, "Wrong size on GzThrowableShield_HandleShieldMeshBeginOverlap");
static_assert(offsetof(GzThrowableShield_HandleShieldMeshBeginOverlap, OverlappedComponent) == 0x000000, "Member 'GzThrowableShield_HandleShieldMeshBeginOverlap::OverlappedComponent' has a wrong offset!");
static_assert(offsetof(GzThrowableShield_HandleShieldMeshBeginOverlap, OtherActor) == 0x000008, "Member 'GzThrowableShield_HandleShieldMeshBeginOverlap::OtherActor' has a wrong offset!");
static_assert(offsetof(GzThrowableShield_HandleShieldMeshBeginOverlap, OtherComp) == 0x000010, "Member 'GzThrowableShield_HandleShieldMeshBeginOverlap::OtherComp' has a wrong offset!");
static_assert(offsetof(GzThrowableShield_HandleShieldMeshBeginOverlap, OtherBodyIndex) == 0x000018, "Member 'GzThrowableShield_HandleShieldMeshBeginOverlap::OtherBodyIndex' has a wrong offset!");
static_assert(offsetof(GzThrowableShield_HandleShieldMeshBeginOverlap, bFromSweep) == 0x00001C, "Member 'GzThrowableShield_HandleShieldMeshBeginOverlap::bFromSweep' has a wrong offset!");
static_assert(offsetof(GzThrowableShield_HandleShieldMeshBeginOverlap, SweepResul) == 0x000020, "Member 'GzThrowableShield_HandleShieldMeshBeginOverlap::SweepResul' has a wrong offset!");

// Function G01.GzThrowableShield.HandleTargetingSphereBeginOverlap
// 0x0118 (0x0118 - 0x0000)
struct GzThrowableShield_HandleTargetingSphereBeginOverlap final
{
public:
	class UPrimitiveComponent*                    OverlappedComponent;                               // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 OtherActor;                                        // 0x0008(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UPrimitiveComponent*                    OtherComp;                                         // 0x0010(0x0008)(Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         OtherBodyIndex;                                    // 0x0018(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bFromSweep;                                        // 0x001C(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_313F[0x3];                                     // 0x001D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FHitResult                             SweepResul;                                        // 0x0020(0x00F8)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzThrowableShield_HandleTargetingSphereBeginOverlap) == 0x000008, "Wrong alignment on GzThrowableShield_HandleTargetingSphereBeginOverlap");
static_assert(sizeof(GzThrowableShield_HandleTargetingSphereBeginOverlap) == 0x000118, "Wrong size on GzThrowableShield_HandleTargetingSphereBeginOverlap");
static_assert(offsetof(GzThrowableShield_HandleTargetingSphereBeginOverlap, OverlappedComponent) == 0x000000, "Member 'GzThrowableShield_HandleTargetingSphereBeginOverlap::OverlappedComponent' has a wrong offset!");
static_assert(offsetof(GzThrowableShield_HandleTargetingSphereBeginOverlap, OtherActor) == 0x000008, "Member 'GzThrowableShield_HandleTargetingSphereBeginOverlap::OtherActor' has a wrong offset!");
static_assert(offsetof(GzThrowableShield_HandleTargetingSphereBeginOverlap, OtherComp) == 0x000010, "Member 'GzThrowableShield_HandleTargetingSphereBeginOverlap::OtherComp' has a wrong offset!");
static_assert(offsetof(GzThrowableShield_HandleTargetingSphereBeginOverlap, OtherBodyIndex) == 0x000018, "Member 'GzThrowableShield_HandleTargetingSphereBeginOverlap::OtherBodyIndex' has a wrong offset!");
static_assert(offsetof(GzThrowableShield_HandleTargetingSphereBeginOverlap, bFromSweep) == 0x00001C, "Member 'GzThrowableShield_HandleTargetingSphereBeginOverlap::bFromSweep' has a wrong offset!");
static_assert(offsetof(GzThrowableShield_HandleTargetingSphereBeginOverlap, SweepResul) == 0x000020, "Member 'GzThrowableShield_HandleTargetingSphereBeginOverlap::SweepResul' has a wrong offset!");

// Function G01.GzThrowableShield.HandleTargetingSphereEndOverlap
// 0x0020 (0x0020 - 0x0000)
struct GzThrowableShield_HandleTargetingSphereEndOverlap final
{
public:
	class UPrimitiveComponent*                    OverlappedComponent;                               // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 OtherActor;                                        // 0x0008(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UPrimitiveComponent*                    OtherComp;                                         // 0x0010(0x0008)(Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         OtherBodyIndex;                                    // 0x0018(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3140[0x4];                                     // 0x001C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GzThrowableShield_HandleTargetingSphereEndOverlap) == 0x000008, "Wrong alignment on GzThrowableShield_HandleTargetingSphereEndOverlap");
static_assert(sizeof(GzThrowableShield_HandleTargetingSphereEndOverlap) == 0x000020, "Wrong size on GzThrowableShield_HandleTargetingSphereEndOverlap");
static_assert(offsetof(GzThrowableShield_HandleTargetingSphereEndOverlap, OverlappedComponent) == 0x000000, "Member 'GzThrowableShield_HandleTargetingSphereEndOverlap::OverlappedComponent' has a wrong offset!");
static_assert(offsetof(GzThrowableShield_HandleTargetingSphereEndOverlap, OtherActor) == 0x000008, "Member 'GzThrowableShield_HandleTargetingSphereEndOverlap::OtherActor' has a wrong offset!");
static_assert(offsetof(GzThrowableShield_HandleTargetingSphereEndOverlap, OtherComp) == 0x000010, "Member 'GzThrowableShield_HandleTargetingSphereEndOverlap::OtherComp' has a wrong offset!");
static_assert(offsetof(GzThrowableShield_HandleTargetingSphereEndOverlap, OtherBodyIndex) == 0x000018, "Member 'GzThrowableShield_HandleTargetingSphereEndOverlap::OtherBodyIndex' has a wrong offset!");

// Function G01.GzThrowableShield.GetInterpolatedComponent
// 0x0008 (0x0008 - 0x0000)
struct GzThrowableShield_GetInterpolatedComponent final
{
public:
	class USceneComponent*                        ReturnValue;                                       // 0x0000(0x0008)(ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzThrowableShield_GetInterpolatedComponent) == 0x000008, "Wrong alignment on GzThrowableShield_GetInterpolatedComponent");
static_assert(sizeof(GzThrowableShield_GetInterpolatedComponent) == 0x000008, "Wrong size on GzThrowableShield_GetInterpolatedComponent");
static_assert(offsetof(GzThrowableShield_GetInterpolatedComponent, ReturnValue) == 0x000000, "Member 'GzThrowableShield_GetInterpolatedComponent::ReturnValue' has a wrong offset!");

// Function G01.GzItemExtractor.OnStartItemExtraction
// 0x0010 (0x0010 - 0x0000)
struct GzItemExtractor_OnStartItemExtraction final
{
public:
	class AGzPlayerState*                         Player;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UGzItemData*                            ItemData;                                          // 0x0008(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzItemExtractor_OnStartItemExtraction) == 0x000008, "Wrong alignment on GzItemExtractor_OnStartItemExtraction");
static_assert(sizeof(GzItemExtractor_OnStartItemExtraction) == 0x000010, "Wrong size on GzItemExtractor_OnStartItemExtraction");
static_assert(offsetof(GzItemExtractor_OnStartItemExtraction, Player) == 0x000000, "Member 'GzItemExtractor_OnStartItemExtraction::Player' has a wrong offset!");
static_assert(offsetof(GzItemExtractor_OnStartItemExtraction, ItemData) == 0x000008, "Member 'GzItemExtractor_OnStartItemExtraction::ItemData' has a wrong offset!");

// Function G01.GzItemExtractor.PostHexExtractionReconstitutedMessage
// 0x0004 (0x0004 - 0x0000)
struct GzItemExtractor_PostHexExtractionReconstitutedMessage final
{
public:
	float                                         ExtractionProgressTime;                            // 0x0000(0x0004)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzItemExtractor_PostHexExtractionReconstitutedMessage) == 0x000004, "Wrong alignment on GzItemExtractor_PostHexExtractionReconstitutedMessage");
static_assert(sizeof(GzItemExtractor_PostHexExtractionReconstitutedMessage) == 0x000004, "Wrong size on GzItemExtractor_PostHexExtractionReconstitutedMessage");
static_assert(offsetof(GzItemExtractor_PostHexExtractionReconstitutedMessage, ExtractionProgressTime) == 0x000000, "Member 'GzItemExtractor_PostHexExtractionReconstitutedMessage::ExtractionProgressTime' has a wrong offset!");

// Function G01.GzItemExtractor.SetHackingState
// 0x0008 (0x0008 - 0x0000)
struct GzItemExtractor_SetHackingState final
{
public:
	class AGzPlayerState*                         HackerPS;                                          // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzItemExtractor_SetHackingState) == 0x000008, "Wrong alignment on GzItemExtractor_SetHackingState");
static_assert(sizeof(GzItemExtractor_SetHackingState) == 0x000008, "Wrong size on GzItemExtractor_SetHackingState");
static_assert(offsetof(GzItemExtractor_SetHackingState, HackerPS) == 0x000000, "Member 'GzItemExtractor_SetHackingState::HackerPS' has a wrong offset!");

// Function G01.GzItemExtractor.SetPaused
// 0x0001 (0x0001 - 0x0000)
struct GzItemExtractor_SetPaused final
{
public:
	bool                                          bInPaused;                                         // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzItemExtractor_SetPaused) == 0x000001, "Wrong alignment on GzItemExtractor_SetPaused");
static_assert(sizeof(GzItemExtractor_SetPaused) == 0x000001, "Wrong size on GzItemExtractor_SetPaused");
static_assert(offsetof(GzItemExtractor_SetPaused, bInPaused) == 0x000000, "Member 'GzItemExtractor_SetPaused::bInPaused' has a wrong offset!");

// Function G01.GzItemExtractor.StartItemExtraction
// 0x0018 (0x0018 - 0x0000)
struct GzItemExtractor_StartItemExtraction final
{
public:
	class AGzPlayerState*                         Player;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UGzItemData*                            ItemData;                                          // 0x0008(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ExtractTime;                                       // 0x0010(0x0004)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3144[0x4];                                     // 0x0014(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GzItemExtractor_StartItemExtraction) == 0x000008, "Wrong alignment on GzItemExtractor_StartItemExtraction");
static_assert(sizeof(GzItemExtractor_StartItemExtraction) == 0x000018, "Wrong size on GzItemExtractor_StartItemExtraction");
static_assert(offsetof(GzItemExtractor_StartItemExtraction, Player) == 0x000000, "Member 'GzItemExtractor_StartItemExtraction::Player' has a wrong offset!");
static_assert(offsetof(GzItemExtractor_StartItemExtraction, ItemData) == 0x000008, "Member 'GzItemExtractor_StartItemExtraction::ItemData' has a wrong offset!");
static_assert(offsetof(GzItemExtractor_StartItemExtraction, ExtractTime) == 0x000010, "Member 'GzItemExtractor_StartItemExtraction::ExtractTime' has a wrong offset!");

// Function G01.GzItemExtractor.GetExtractionData
// 0x0040 (0x0040 - 0x0000)
struct GzItemExtractor_GetExtractionData final
{
public:
	struct FGzExtractionData                      ReturnValue;                                       // 0x0000(0x0040)(ConstParm, Parm, OutParm, ReturnParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzItemExtractor_GetExtractionData) == 0x000008, "Wrong alignment on GzItemExtractor_GetExtractionData");
static_assert(sizeof(GzItemExtractor_GetExtractionData) == 0x000040, "Wrong size on GzItemExtractor_GetExtractionData");
static_assert(offsetof(GzItemExtractor_GetExtractionData, ReturnValue) == 0x000000, "Member 'GzItemExtractor_GetExtractionData::ReturnValue' has a wrong offset!");

// Function G01.GzItemExtractor.GetLocalHexItemTransforms
// 0x0010 (0x0010 - 0x0000)
struct GzItemExtractor_GetLocalHexItemTransforms final
{
public:
	TArray<struct FTransform>                     ReturnValue;                                       // 0x0000(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzItemExtractor_GetLocalHexItemTransforms) == 0x000008, "Wrong alignment on GzItemExtractor_GetLocalHexItemTransforms");
static_assert(sizeof(GzItemExtractor_GetLocalHexItemTransforms) == 0x000010, "Wrong size on GzItemExtractor_GetLocalHexItemTransforms");
static_assert(offsetof(GzItemExtractor_GetLocalHexItemTransforms, ReturnValue) == 0x000000, "Member 'GzItemExtractor_GetLocalHexItemTransforms::ReturnValue' has a wrong offset!");

// Function G01.GzItemExtractor.HasHexInside
// 0x0001 (0x0001 - 0x0000)
struct GzItemExtractor_HasHexInside final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzItemExtractor_HasHexInside) == 0x000001, "Wrong alignment on GzItemExtractor_HasHexInside");
static_assert(sizeof(GzItemExtractor_HasHexInside) == 0x000001, "Wrong size on GzItemExtractor_HasHexInside");
static_assert(offsetof(GzItemExtractor_HasHexInside, ReturnValue) == 0x000000, "Member 'GzItemExtractor_HasHexInside::ReturnValue' has a wrong offset!");

// Function G01.GzCyberlimbFunctionLibrary.GetHandSocketName
// 0x000C (0x000C - 0x0000)
struct GzCyberlimbFunctionLibrary_GetHandSocketName final
{
public:
	EGzLimbType                                   LimbType;                                          // 0x0000(0x0001)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3145[0x3];                                     // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   ReturnValue;                                       // 0x0004(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzCyberlimbFunctionLibrary_GetHandSocketName) == 0x000004, "Wrong alignment on GzCyberlimbFunctionLibrary_GetHandSocketName");
static_assert(sizeof(GzCyberlimbFunctionLibrary_GetHandSocketName) == 0x00000C, "Wrong size on GzCyberlimbFunctionLibrary_GetHandSocketName");
static_assert(offsetof(GzCyberlimbFunctionLibrary_GetHandSocketName, LimbType) == 0x000000, "Member 'GzCyberlimbFunctionLibrary_GetHandSocketName::LimbType' has a wrong offset!");
static_assert(offsetof(GzCyberlimbFunctionLibrary_GetHandSocketName, ReturnValue) == 0x000004, "Member 'GzCyberlimbFunctionLibrary_GetHandSocketName::ReturnValue' has a wrong offset!");

// Function G01.GzCyberlimbFunctionLibrary.GetLimbChargeAttribute
// 0x0040 (0x0040 - 0x0000)
struct GzCyberlimbFunctionLibrary_GetLimbChargeAttribute final
{
public:
	EGzLimbType                                   LimbType;                                          // 0x0000(0x0001)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3146[0x7];                                     // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayAttribute                     ReturnValue;                                       // 0x0008(0x0038)(Parm, OutParm, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzCyberlimbFunctionLibrary_GetLimbChargeAttribute) == 0x000008, "Wrong alignment on GzCyberlimbFunctionLibrary_GetLimbChargeAttribute");
static_assert(sizeof(GzCyberlimbFunctionLibrary_GetLimbChargeAttribute) == 0x000040, "Wrong size on GzCyberlimbFunctionLibrary_GetLimbChargeAttribute");
static_assert(offsetof(GzCyberlimbFunctionLibrary_GetLimbChargeAttribute, LimbType) == 0x000000, "Member 'GzCyberlimbFunctionLibrary_GetLimbChargeAttribute::LimbType' has a wrong offset!");
static_assert(offsetof(GzCyberlimbFunctionLibrary_GetLimbChargeAttribute, ReturnValue) == 0x000008, "Member 'GzCyberlimbFunctionLibrary_GetLimbChargeAttribute::ReturnValue' has a wrong offset!");

// Function G01.GzCyberlimbFunctionLibrary.GetLimbCurrentCharges
// 0x0010 (0x0010 - 0x0000)
struct GzCyberlimbFunctionLibrary_GetLimbCurrentCharges final
{
public:
	class AActor*                                 AbilityOwner;                                      // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EGzLimbType                                   LimbType;                                          // 0x0008(0x0001)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3147[0x3];                                     // 0x0009(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         ReturnValue;                                       // 0x000C(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzCyberlimbFunctionLibrary_GetLimbCurrentCharges) == 0x000008, "Wrong alignment on GzCyberlimbFunctionLibrary_GetLimbCurrentCharges");
static_assert(sizeof(GzCyberlimbFunctionLibrary_GetLimbCurrentCharges) == 0x000010, "Wrong size on GzCyberlimbFunctionLibrary_GetLimbCurrentCharges");
static_assert(offsetof(GzCyberlimbFunctionLibrary_GetLimbCurrentCharges, AbilityOwner) == 0x000000, "Member 'GzCyberlimbFunctionLibrary_GetLimbCurrentCharges::AbilityOwner' has a wrong offset!");
static_assert(offsetof(GzCyberlimbFunctionLibrary_GetLimbCurrentCharges, LimbType) == 0x000008, "Member 'GzCyberlimbFunctionLibrary_GetLimbCurrentCharges::LimbType' has a wrong offset!");
static_assert(offsetof(GzCyberlimbFunctionLibrary_GetLimbCurrentCharges, ReturnValue) == 0x00000C, "Member 'GzCyberlimbFunctionLibrary_GetLimbCurrentCharges::ReturnValue' has a wrong offset!");

// Function G01.GzCyberlimbFunctionLibrary.GetLimbMaxCharges
// 0x0010 (0x0010 - 0x0000)
struct GzCyberlimbFunctionLibrary_GetLimbMaxCharges final
{
public:
	class AActor*                                 AbilityOwner;                                      // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EGzLimbType                                   LimbType;                                          // 0x0008(0x0001)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3148[0x3];                                     // 0x0009(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         ReturnValue;                                       // 0x000C(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzCyberlimbFunctionLibrary_GetLimbMaxCharges) == 0x000008, "Wrong alignment on GzCyberlimbFunctionLibrary_GetLimbMaxCharges");
static_assert(sizeof(GzCyberlimbFunctionLibrary_GetLimbMaxCharges) == 0x000010, "Wrong size on GzCyberlimbFunctionLibrary_GetLimbMaxCharges");
static_assert(offsetof(GzCyberlimbFunctionLibrary_GetLimbMaxCharges, AbilityOwner) == 0x000000, "Member 'GzCyberlimbFunctionLibrary_GetLimbMaxCharges::AbilityOwner' has a wrong offset!");
static_assert(offsetof(GzCyberlimbFunctionLibrary_GetLimbMaxCharges, LimbType) == 0x000008, "Member 'GzCyberlimbFunctionLibrary_GetLimbMaxCharges::LimbType' has a wrong offset!");
static_assert(offsetof(GzCyberlimbFunctionLibrary_GetLimbMaxCharges, ReturnValue) == 0x00000C, "Member 'GzCyberlimbFunctionLibrary_GetLimbMaxCharges::ReturnValue' has a wrong offset!");

// Function G01.GzCyberlimbFunctionLibrary.GetLimbMaxChargesAttribute
// 0x0040 (0x0040 - 0x0000)
struct GzCyberlimbFunctionLibrary_GetLimbMaxChargesAttribute final
{
public:
	EGzLimbType                                   LimbType;                                          // 0x0000(0x0001)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3149[0x7];                                     // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayAttribute                     ReturnValue;                                       // 0x0008(0x0038)(Parm, OutParm, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzCyberlimbFunctionLibrary_GetLimbMaxChargesAttribute) == 0x000008, "Wrong alignment on GzCyberlimbFunctionLibrary_GetLimbMaxChargesAttribute");
static_assert(sizeof(GzCyberlimbFunctionLibrary_GetLimbMaxChargesAttribute) == 0x000040, "Wrong size on GzCyberlimbFunctionLibrary_GetLimbMaxChargesAttribute");
static_assert(offsetof(GzCyberlimbFunctionLibrary_GetLimbMaxChargesAttribute, LimbType) == 0x000000, "Member 'GzCyberlimbFunctionLibrary_GetLimbMaxChargesAttribute::LimbType' has a wrong offset!");
static_assert(offsetof(GzCyberlimbFunctionLibrary_GetLimbMaxChargesAttribute, ReturnValue) == 0x000008, "Member 'GzCyberlimbFunctionLibrary_GetLimbMaxChargesAttribute::ReturnValue' has a wrong offset!");

// Function G01.GzCyberlimbFunctionLibrary.GetLimbRechargeTag
// 0x000C (0x000C - 0x0000)
struct GzCyberlimbFunctionLibrary_GetLimbRechargeTag final
{
public:
	EGzLimbType                                   LimbType;                                          // 0x0000(0x0001)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_314A[0x3];                                     // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTag                           ReturnValue;                                       // 0x0004(0x0008)(Parm, OutParm, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzCyberlimbFunctionLibrary_GetLimbRechargeTag) == 0x000004, "Wrong alignment on GzCyberlimbFunctionLibrary_GetLimbRechargeTag");
static_assert(sizeof(GzCyberlimbFunctionLibrary_GetLimbRechargeTag) == 0x00000C, "Wrong size on GzCyberlimbFunctionLibrary_GetLimbRechargeTag");
static_assert(offsetof(GzCyberlimbFunctionLibrary_GetLimbRechargeTag, LimbType) == 0x000000, "Member 'GzCyberlimbFunctionLibrary_GetLimbRechargeTag::LimbType' has a wrong offset!");
static_assert(offsetof(GzCyberlimbFunctionLibrary_GetLimbRechargeTag, ReturnValue) == 0x000004, "Member 'GzCyberlimbFunctionLibrary_GetLimbRechargeTag::ReturnValue' has a wrong offset!");

// Function G01.GzCyberlimbFunctionLibrary.GetShoulderSocketName
// 0x000C (0x000C - 0x0000)
struct GzCyberlimbFunctionLibrary_GetShoulderSocketName final
{
public:
	EGzLimbType                                   LimbType;                                          // 0x0000(0x0001)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_314B[0x3];                                     // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   ReturnValue;                                       // 0x0004(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzCyberlimbFunctionLibrary_GetShoulderSocketName) == 0x000004, "Wrong alignment on GzCyberlimbFunctionLibrary_GetShoulderSocketName");
static_assert(sizeof(GzCyberlimbFunctionLibrary_GetShoulderSocketName) == 0x00000C, "Wrong size on GzCyberlimbFunctionLibrary_GetShoulderSocketName");
static_assert(offsetof(GzCyberlimbFunctionLibrary_GetShoulderSocketName, LimbType) == 0x000000, "Member 'GzCyberlimbFunctionLibrary_GetShoulderSocketName::LimbType' has a wrong offset!");
static_assert(offsetof(GzCyberlimbFunctionLibrary_GetShoulderSocketName, ReturnValue) == 0x000004, "Member 'GzCyberlimbFunctionLibrary_GetShoulderSocketName::ReturnValue' has a wrong offset!");

// Function G01.GzCyberlimbFunctionLibrary.IsLimbAtMaxCharges
// 0x0010 (0x0010 - 0x0000)
struct GzCyberlimbFunctionLibrary_IsLimbAtMaxCharges final
{
public:
	class AActor*                                 AbilityOwner;                                      // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EGzLimbType                                   LimbType;                                          // 0x0008(0x0001)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0009(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_314C[0x6];                                     // 0x000A(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GzCyberlimbFunctionLibrary_IsLimbAtMaxCharges) == 0x000008, "Wrong alignment on GzCyberlimbFunctionLibrary_IsLimbAtMaxCharges");
static_assert(sizeof(GzCyberlimbFunctionLibrary_IsLimbAtMaxCharges) == 0x000010, "Wrong size on GzCyberlimbFunctionLibrary_IsLimbAtMaxCharges");
static_assert(offsetof(GzCyberlimbFunctionLibrary_IsLimbAtMaxCharges, AbilityOwner) == 0x000000, "Member 'GzCyberlimbFunctionLibrary_IsLimbAtMaxCharges::AbilityOwner' has a wrong offset!");
static_assert(offsetof(GzCyberlimbFunctionLibrary_IsLimbAtMaxCharges, LimbType) == 0x000008, "Member 'GzCyberlimbFunctionLibrary_IsLimbAtMaxCharges::LimbType' has a wrong offset!");
static_assert(offsetof(GzCyberlimbFunctionLibrary_IsLimbAtMaxCharges, ReturnValue) == 0x000009, "Member 'GzCyberlimbFunctionLibrary_IsLimbAtMaxCharges::ReturnValue' has a wrong offset!");

// Function G01.GzCyberlimbFunctionLibrary.IsLimbRecharging
// 0x0010 (0x0010 - 0x0000)
struct GzCyberlimbFunctionLibrary_IsLimbRecharging final
{
public:
	class AActor*                                 AbilityOwner;                                      // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EGzLimbType                                   LimbType;                                          // 0x0008(0x0001)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0009(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_314D[0x6];                                     // 0x000A(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GzCyberlimbFunctionLibrary_IsLimbRecharging) == 0x000008, "Wrong alignment on GzCyberlimbFunctionLibrary_IsLimbRecharging");
static_assert(sizeof(GzCyberlimbFunctionLibrary_IsLimbRecharging) == 0x000010, "Wrong size on GzCyberlimbFunctionLibrary_IsLimbRecharging");
static_assert(offsetof(GzCyberlimbFunctionLibrary_IsLimbRecharging, AbilityOwner) == 0x000000, "Member 'GzCyberlimbFunctionLibrary_IsLimbRecharging::AbilityOwner' has a wrong offset!");
static_assert(offsetof(GzCyberlimbFunctionLibrary_IsLimbRecharging, LimbType) == 0x000008, "Member 'GzCyberlimbFunctionLibrary_IsLimbRecharging::LimbType' has a wrong offset!");
static_assert(offsetof(GzCyberlimbFunctionLibrary_IsLimbRecharging, ReturnValue) == 0x000009, "Member 'GzCyberlimbFunctionLibrary_IsLimbRecharging::ReturnValue' has a wrong offset!");

// Function G01.GzCyberlimbFunctionLibrary.StartDashing
// 0x0090 (0x0090 - 0x0000)
struct GzCyberlimbFunctionLibrary_StartDashing final
{
public:
	class AGzCharacter*                           TargetCharacter;                                   // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UGzDashParamsData*                      DashParams;                                        // 0x0008(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                TargetLocation;                                    // 0x0010(0x0018)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTagContainer                  TagsToApply;                                       // 0x0028(0x0020)(Parm, NativeAccessSpecifierPublic)
	class AActor*                                 AimAssistTarget;                                   // 0x0048(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                ExtraOverlapExtents;                               // 0x0050(0x0018)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                ExtraOverlapOffset;                                // 0x0068(0x0018)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   ExtraOverlapCollisionProfile;                      // 0x0080(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bInResetVelocityAtEnd;                             // 0x0088(0x0001)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0089(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_314E[0x6];                                     // 0x008A(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GzCyberlimbFunctionLibrary_StartDashing) == 0x000008, "Wrong alignment on GzCyberlimbFunctionLibrary_StartDashing");
static_assert(sizeof(GzCyberlimbFunctionLibrary_StartDashing) == 0x000090, "Wrong size on GzCyberlimbFunctionLibrary_StartDashing");
static_assert(offsetof(GzCyberlimbFunctionLibrary_StartDashing, TargetCharacter) == 0x000000, "Member 'GzCyberlimbFunctionLibrary_StartDashing::TargetCharacter' has a wrong offset!");
static_assert(offsetof(GzCyberlimbFunctionLibrary_StartDashing, DashParams) == 0x000008, "Member 'GzCyberlimbFunctionLibrary_StartDashing::DashParams' has a wrong offset!");
static_assert(offsetof(GzCyberlimbFunctionLibrary_StartDashing, TargetLocation) == 0x000010, "Member 'GzCyberlimbFunctionLibrary_StartDashing::TargetLocation' has a wrong offset!");
static_assert(offsetof(GzCyberlimbFunctionLibrary_StartDashing, TagsToApply) == 0x000028, "Member 'GzCyberlimbFunctionLibrary_StartDashing::TagsToApply' has a wrong offset!");
static_assert(offsetof(GzCyberlimbFunctionLibrary_StartDashing, AimAssistTarget) == 0x000048, "Member 'GzCyberlimbFunctionLibrary_StartDashing::AimAssistTarget' has a wrong offset!");
static_assert(offsetof(GzCyberlimbFunctionLibrary_StartDashing, ExtraOverlapExtents) == 0x000050, "Member 'GzCyberlimbFunctionLibrary_StartDashing::ExtraOverlapExtents' has a wrong offset!");
static_assert(offsetof(GzCyberlimbFunctionLibrary_StartDashing, ExtraOverlapOffset) == 0x000068, "Member 'GzCyberlimbFunctionLibrary_StartDashing::ExtraOverlapOffset' has a wrong offset!");
static_assert(offsetof(GzCyberlimbFunctionLibrary_StartDashing, ExtraOverlapCollisionProfile) == 0x000080, "Member 'GzCyberlimbFunctionLibrary_StartDashing::ExtraOverlapCollisionProfile' has a wrong offset!");
static_assert(offsetof(GzCyberlimbFunctionLibrary_StartDashing, bInResetVelocityAtEnd) == 0x000088, "Member 'GzCyberlimbFunctionLibrary_StartDashing::bInResetVelocityAtEnd' has a wrong offset!");
static_assert(offsetof(GzCyberlimbFunctionLibrary_StartDashing, ReturnValue) == 0x000089, "Member 'GzCyberlimbFunctionLibrary_StartDashing::ReturnValue' has a wrong offset!");

// Function G01.GzNegativeCondition.MakeNegativeCondition
// 0x0010 (0x0010 - 0x0000)
struct GzNegativeCondition_MakeNegativeCondition final
{
public:
	class AGzAdvancedMission*                     Mission;                                           // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UGzCondition*                           ReturnValue;                                       // 0x0008(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzNegativeCondition_MakeNegativeCondition) == 0x000008, "Wrong alignment on GzNegativeCondition_MakeNegativeCondition");
static_assert(sizeof(GzNegativeCondition_MakeNegativeCondition) == 0x000010, "Wrong size on GzNegativeCondition_MakeNegativeCondition");
static_assert(offsetof(GzNegativeCondition_MakeNegativeCondition, Mission) == 0x000000, "Member 'GzNegativeCondition_MakeNegativeCondition::Mission' has a wrong offset!");
static_assert(offsetof(GzNegativeCondition_MakeNegativeCondition, ReturnValue) == 0x000008, "Member 'GzNegativeCondition_MakeNegativeCondition::ReturnValue' has a wrong offset!");

// Function G01.GzDamageableRepProxy.OnRep_Items
// 0x0010 (0x0010 - 0x0000)
struct GzDamageableRepProxy_OnRep_Items final
{
public:
	TArray<struct FGzFastStaticDamageableItem>    OldItems;                                          // 0x0000(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzDamageableRepProxy_OnRep_Items) == 0x000008, "Wrong alignment on GzDamageableRepProxy_OnRep_Items");
static_assert(sizeof(GzDamageableRepProxy_OnRep_Items) == 0x000010, "Wrong size on GzDamageableRepProxy_OnRep_Items");
static_assert(offsetof(GzDamageableRepProxy_OnRep_Items, OldItems) == 0x000000, "Member 'GzDamageableRepProxy_OnRep_Items::OldItems' has a wrong offset!");

// Function G01.GzDamageIndicatorContainer.AddIndicator
// 0x0008 (0x0008 - 0x0000)
struct GzDamageIndicatorContainer_AddIndicator final
{
public:
	class UGzDamageIndicator*                     NewIndicator;                                      // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzDamageIndicatorContainer_AddIndicator) == 0x000008, "Wrong alignment on GzDamageIndicatorContainer_AddIndicator");
static_assert(sizeof(GzDamageIndicatorContainer_AddIndicator) == 0x000008, "Wrong size on GzDamageIndicatorContainer_AddIndicator");
static_assert(offsetof(GzDamageIndicatorContainer_AddIndicator, NewIndicator) == 0x000000, "Member 'GzDamageIndicatorContainer_AddIndicator::NewIndicator' has a wrong offset!");

// Function G01.GzDamageIndicatorContainer.GetDamageIndicatorClass
// 0x0038 (0x0038 - 0x0000)
struct GzDamageIndicatorContainer_GetDamageIndicatorClass final
{
public:
	struct FGzDamageDirectionData                 DamageData;                                        // 0x0000(0x0030)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	TSubclassOf<class UGzDamageIndicator>         ReturnValue;                                       // 0x0030(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzDamageIndicatorContainer_GetDamageIndicatorClass) == 0x000008, "Wrong alignment on GzDamageIndicatorContainer_GetDamageIndicatorClass");
static_assert(sizeof(GzDamageIndicatorContainer_GetDamageIndicatorClass) == 0x000038, "Wrong size on GzDamageIndicatorContainer_GetDamageIndicatorClass");
static_assert(offsetof(GzDamageIndicatorContainer_GetDamageIndicatorClass, DamageData) == 0x000000, "Member 'GzDamageIndicatorContainer_GetDamageIndicatorClass::DamageData' has a wrong offset!");
static_assert(offsetof(GzDamageIndicatorContainer_GetDamageIndicatorClass, ReturnValue) == 0x000030, "Member 'GzDamageIndicatorContainer_GetDamageIndicatorClass::ReturnValue' has a wrong offset!");

// Function G01.GzDamageIndicatorContainer.RemoveIndicator
// 0x0008 (0x0008 - 0x0000)
struct GzDamageIndicatorContainer_RemoveIndicator final
{
public:
	class UGzDamageIndicator*                     DamageIndicator;                                   // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzDamageIndicatorContainer_RemoveIndicator) == 0x000008, "Wrong alignment on GzDamageIndicatorContainer_RemoveIndicator");
static_assert(sizeof(GzDamageIndicatorContainer_RemoveIndicator) == 0x000008, "Wrong size on GzDamageIndicatorContainer_RemoveIndicator");
static_assert(offsetof(GzDamageIndicatorContainer_RemoveIndicator, DamageIndicator) == 0x000000, "Member 'GzDamageIndicatorContainer_RemoveIndicator::DamageIndicator' has a wrong offset!");

// Function G01.GzDamageSettings.GetDamageSettings
// 0x0008 (0x0008 - 0x0000)
struct GzDamageSettings_GetDamageSettings final
{
public:
	class UGzDamageSettings*                      ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzDamageSettings_GetDamageSettings) == 0x000008, "Wrong alignment on GzDamageSettings_GetDamageSettings");
static_assert(sizeof(GzDamageSettings_GetDamageSettings) == 0x000008, "Wrong size on GzDamageSettings_GetDamageSettings");
static_assert(offsetof(GzDamageSettings_GetDamageSettings, ReturnValue) == 0x000000, "Member 'GzDamageSettings_GetDamageSettings::ReturnValue' has a wrong offset!");

// Function G01.GzDamageStatics.GetBaseMultiHitDamage
// 0x0050 (0x0050 - 0x0000)
struct GzDamageStatics_GetBaseMultiHitDamage final
{
public:
	struct FGzMultiHitDamage                      Damage;                                            // 0x0000(0x0048)(ConstParm, Parm, OutParm, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
	float                                         ReturnValue;                                       // 0x0048(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3156[0x4];                                     // 0x004C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GzDamageStatics_GetBaseMultiHitDamage) == 0x000008, "Wrong alignment on GzDamageStatics_GetBaseMultiHitDamage");
static_assert(sizeof(GzDamageStatics_GetBaseMultiHitDamage) == 0x000050, "Wrong size on GzDamageStatics_GetBaseMultiHitDamage");
static_assert(offsetof(GzDamageStatics_GetBaseMultiHitDamage, Damage) == 0x000000, "Member 'GzDamageStatics_GetBaseMultiHitDamage::Damage' has a wrong offset!");
static_assert(offsetof(GzDamageStatics_GetBaseMultiHitDamage, ReturnValue) == 0x000048, "Member 'GzDamageStatics_GetBaseMultiHitDamage::ReturnValue' has a wrong offset!");

// Function G01.GzDamageStatics.GetBaseSimpleHitDamage
// 0x01F8 (0x01F8 - 0x0000)
struct GzDamageStatics_GetBaseSimpleHitDamage final
{
public:
	struct FGzSingleHitDamage                     Damage;                                            // 0x0000(0x01F0)(ConstParm, Parm, OutParm, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
	float                                         ReturnValue;                                       // 0x01F0(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3157[0x4];                                     // 0x01F4(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GzDamageStatics_GetBaseSimpleHitDamage) == 0x000008, "Wrong alignment on GzDamageStatics_GetBaseSimpleHitDamage");
static_assert(sizeof(GzDamageStatics_GetBaseSimpleHitDamage) == 0x0001F8, "Wrong size on GzDamageStatics_GetBaseSimpleHitDamage");
static_assert(offsetof(GzDamageStatics_GetBaseSimpleHitDamage, Damage) == 0x000000, "Member 'GzDamageStatics_GetBaseSimpleHitDamage::Damage' has a wrong offset!");
static_assert(offsetof(GzDamageStatics_GetBaseSimpleHitDamage, ReturnValue) == 0x0001F0, "Member 'GzDamageStatics_GetBaseSimpleHitDamage::ReturnValue' has a wrong offset!");

// Function G01.GzDamageStatics.MakeAreaAttack
// 0x00F0 (0x00F0 - 0x0000)
struct GzDamageStatics_MakeAreaAttack final
{
public:
	struct FGzAreaAttackParams                    Params_0;                                          // 0x0000(0x00E0)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	TArray<class AActor*>                         ReturnValue;                                       // 0x00E0(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzDamageStatics_MakeAreaAttack) == 0x000008, "Wrong alignment on GzDamageStatics_MakeAreaAttack");
static_assert(sizeof(GzDamageStatics_MakeAreaAttack) == 0x0000F0, "Wrong size on GzDamageStatics_MakeAreaAttack");
static_assert(offsetof(GzDamageStatics_MakeAreaAttack, Params_0) == 0x000000, "Member 'GzDamageStatics_MakeAreaAttack::Params_0' has a wrong offset!");
static_assert(offsetof(GzDamageStatics_MakeAreaAttack, ReturnValue) == 0x0000E0, "Member 'GzDamageStatics_MakeAreaAttack::ReturnValue' has a wrong offset!");

// Function G01.GzDamageStatics.MakeTargetAttack
// 0x0208 (0x0208 - 0x0000)
struct GzDamageStatics_MakeTargetAttack final
{
public:
	struct FGzTargetAttackParams                  Params_0;                                          // 0x0000(0x0200)(ConstParm, Parm, OutParm, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0200(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3158[0x7];                                     // 0x0201(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GzDamageStatics_MakeTargetAttack) == 0x000008, "Wrong alignment on GzDamageStatics_MakeTargetAttack");
static_assert(sizeof(GzDamageStatics_MakeTargetAttack) == 0x000208, "Wrong size on GzDamageStatics_MakeTargetAttack");
static_assert(offsetof(GzDamageStatics_MakeTargetAttack, Params_0) == 0x000000, "Member 'GzDamageStatics_MakeTargetAttack::Params_0' has a wrong offset!");
static_assert(offsetof(GzDamageStatics_MakeTargetAttack, ReturnValue) == 0x000200, "Member 'GzDamageStatics_MakeTargetAttack::ReturnValue' has a wrong offset!");

// Function G01.GzDatacubeDecoder.GetDatacube
// 0x0008 (0x0008 - 0x0000)
struct GzDatacubeDecoder_GetDatacube final
{
public:
	class UGzContainerItemData*                   ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzDatacubeDecoder_GetDatacube) == 0x000008, "Wrong alignment on GzDatacubeDecoder_GetDatacube");
static_assert(sizeof(GzDatacubeDecoder_GetDatacube) == 0x000008, "Wrong size on GzDatacubeDecoder_GetDatacube");
static_assert(offsetof(GzDatacubeDecoder_GetDatacube, ReturnValue) == 0x000000, "Member 'GzDatacubeDecoder_GetDatacube::ReturnValue' has a wrong offset!");

// Function G01.GzDatacubeDecoder.GetDatacubeRarity
// 0x0001 (0x0001 - 0x0000)
struct GzDatacubeDecoder_GetDatacubeRarity final
{
public:
	EGzItemRarity                                 ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzDatacubeDecoder_GetDatacubeRarity) == 0x000001, "Wrong alignment on GzDatacubeDecoder_GetDatacubeRarity");
static_assert(sizeof(GzDatacubeDecoder_GetDatacubeRarity) == 0x000001, "Wrong size on GzDatacubeDecoder_GetDatacubeRarity");
static_assert(offsetof(GzDatacubeDecoder_GetDatacubeRarity, ReturnValue) == 0x000000, "Member 'GzDatacubeDecoder_GetDatacubeRarity::ReturnValue' has a wrong offset!");

// Function G01.GzDatacubeDecoder.IsDatacubeSet
// 0x0001 (0x0001 - 0x0000)
struct GzDatacubeDecoder_IsDatacubeSet final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzDatacubeDecoder_IsDatacubeSet) == 0x000001, "Wrong alignment on GzDatacubeDecoder_IsDatacubeSet");
static_assert(sizeof(GzDatacubeDecoder_IsDatacubeSet) == 0x000001, "Wrong size on GzDatacubeDecoder_IsDatacubeSet");
static_assert(offsetof(GzDatacubeDecoder_IsDatacubeSet, ReturnValue) == 0x000000, "Member 'GzDatacubeDecoder_IsDatacubeSet::ReturnValue' has a wrong offset!");

// Function G01.GzTrialTracker.CommitProgress
// 0x0004 (0x0004 - 0x0000)
struct GzTrialTracker_CommitProgress final
{
public:
	float                                         ProgressMade;                                      // 0x0000(0x0004)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzTrialTracker_CommitProgress) == 0x000004, "Wrong alignment on GzTrialTracker_CommitProgress");
static_assert(sizeof(GzTrialTracker_CommitProgress) == 0x000004, "Wrong size on GzTrialTracker_CommitProgress");
static_assert(offsetof(GzTrialTracker_CommitProgress, ProgressMade) == 0x000000, "Member 'GzTrialTracker_CommitProgress::ProgressMade' has a wrong offset!");

// Function G01.GzMissionData.GetMapAssetNames
// 0x0010 (0x0010 - 0x0000)
struct GzMissionData_GetMapAssetNames final
{
public:
	TArray<class FName>                           ReturnValue;                                       // 0x0000(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzMissionData_GetMapAssetNames) == 0x000008, "Wrong alignment on GzMissionData_GetMapAssetNames");
static_assert(sizeof(GzMissionData_GetMapAssetNames) == 0x000010, "Wrong size on GzMissionData_GetMapAssetNames");
static_assert(offsetof(GzMissionData_GetMapAssetNames, ReturnValue) == 0x000000, "Member 'GzMissionData_GetMapAssetNames::ReturnValue' has a wrong offset!");

// Function G01.GzOnlineMatchManager.OnNetworkFailure
// 0x0028 (0x0028 - 0x0000)
struct GzOnlineMatchManager_OnNetworkFailure final
{
public:
	class UWorld*                                 World;                                             // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UNetDriver*                             NetDriver;                                         // 0x0008(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ENetworkFailure                               Arg;                                               // 0x0010(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_316B[0x7];                                     // 0x0011(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 String;                                            // 0x0018(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzOnlineMatchManager_OnNetworkFailure) == 0x000008, "Wrong alignment on GzOnlineMatchManager_OnNetworkFailure");
static_assert(sizeof(GzOnlineMatchManager_OnNetworkFailure) == 0x000028, "Wrong size on GzOnlineMatchManager_OnNetworkFailure");
static_assert(offsetof(GzOnlineMatchManager_OnNetworkFailure, World) == 0x000000, "Member 'GzOnlineMatchManager_OnNetworkFailure::World' has a wrong offset!");
static_assert(offsetof(GzOnlineMatchManager_OnNetworkFailure, NetDriver) == 0x000008, "Member 'GzOnlineMatchManager_OnNetworkFailure::NetDriver' has a wrong offset!");
static_assert(offsetof(GzOnlineMatchManager_OnNetworkFailure, Arg) == 0x000010, "Member 'GzOnlineMatchManager_OnNetworkFailure::Arg' has a wrong offset!");
static_assert(offsetof(GzOnlineMatchManager_OnNetworkFailure, String) == 0x000018, "Member 'GzOnlineMatchManager_OnNetworkFailure::String' has a wrong offset!");

// Function G01.GzOnlineMatchManager.OnTravelFailure
// 0x0020 (0x0020 - 0x0000)
struct GzOnlineMatchManager_OnTravelFailure final
{
public:
	class UWorld*                                 World;                                             // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETravelFailure                                Arg;                                               // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_316C[0x7];                                     // 0x0009(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 String;                                            // 0x0010(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzOnlineMatchManager_OnTravelFailure) == 0x000008, "Wrong alignment on GzOnlineMatchManager_OnTravelFailure");
static_assert(sizeof(GzOnlineMatchManager_OnTravelFailure) == 0x000020, "Wrong size on GzOnlineMatchManager_OnTravelFailure");
static_assert(offsetof(GzOnlineMatchManager_OnTravelFailure, World) == 0x000000, "Member 'GzOnlineMatchManager_OnTravelFailure::World' has a wrong offset!");
static_assert(offsetof(GzOnlineMatchManager_OnTravelFailure, Arg) == 0x000008, "Member 'GzOnlineMatchManager_OnTravelFailure::Arg' has a wrong offset!");
static_assert(offsetof(GzOnlineMatchManager_OnTravelFailure, String) == 0x000010, "Member 'GzOnlineMatchManager_OnTravelFailure::String' has a wrong offset!");

// Function G01.GzOnlineMatchManager.GetLastMatchResult
// 0x0090 (0x0090 - 0x0000)
struct GzOnlineMatchManager_GetLastMatchResult final
{
public:
	struct FGzMatchResult                         ReturnValue;                                       // 0x0000(0x0090)(ConstParm, Parm, OutParm, ReturnParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzOnlineMatchManager_GetLastMatchResult) == 0x000008, "Wrong alignment on GzOnlineMatchManager_GetLastMatchResult");
static_assert(sizeof(GzOnlineMatchManager_GetLastMatchResult) == 0x000090, "Wrong size on GzOnlineMatchManager_GetLastMatchResult");
static_assert(offsetof(GzOnlineMatchManager_GetLastMatchResult, ReturnValue) == 0x000000, "Member 'GzOnlineMatchManager_GetLastMatchResult::ReturnValue' has a wrong offset!");

// Function G01.GzOnlineMatchManager.HasLastMatchResult
// 0x0001 (0x0001 - 0x0000)
struct GzOnlineMatchManager_HasLastMatchResult final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzOnlineMatchManager_HasLastMatchResult) == 0x000001, "Wrong alignment on GzOnlineMatchManager_HasLastMatchResult");
static_assert(sizeof(GzOnlineMatchManager_HasLastMatchResult) == 0x000001, "Wrong size on GzOnlineMatchManager_HasLastMatchResult");
static_assert(offsetof(GzOnlineMatchManager_HasLastMatchResult, ReturnValue) == 0x000000, "Member 'GzOnlineMatchManager_HasLastMatchResult::ReturnValue' has a wrong offset!");

// Function G01.GzLegacyCameraShake.BlueprintGetCameraManager
// 0x0008 (0x0008 - 0x0000)
struct GzLegacyCameraShake_BlueprintGetCameraManager final
{
public:
	class APlayerCameraManager*                   ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzLegacyCameraShake_BlueprintGetCameraManager) == 0x000008, "Wrong alignment on GzLegacyCameraShake_BlueprintGetCameraManager");
static_assert(sizeof(GzLegacyCameraShake_BlueprintGetCameraManager) == 0x000008, "Wrong size on GzLegacyCameraShake_BlueprintGetCameraManager");
static_assert(offsetof(GzLegacyCameraShake_BlueprintGetCameraManager, ReturnValue) == 0x000000, "Member 'GzLegacyCameraShake_BlueprintGetCameraManager::ReturnValue' has a wrong offset!");

// Function G01.GzLegacyCameraShake.GetDefaultFOV
// 0x0004 (0x0004 - 0x0000)
struct GzLegacyCameraShake_GetDefaultFOV final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzLegacyCameraShake_GetDefaultFOV) == 0x000004, "Wrong alignment on GzLegacyCameraShake_GetDefaultFOV");
static_assert(sizeof(GzLegacyCameraShake_GetDefaultFOV) == 0x000004, "Wrong size on GzLegacyCameraShake_GetDefaultFOV");
static_assert(offsetof(GzLegacyCameraShake_GetDefaultFOV, ReturnValue) == 0x000000, "Member 'GzLegacyCameraShake_GetDefaultFOV::ReturnValue' has a wrong offset!");

// Function G01.GzDebugMenuFunctionLibrary.GetBoolValue
// 0x0028 (0x0028 - 0x0000)
struct GzDebugMenuFunctionLibrary_GetBoolValue final
{
public:
	struct FGzDebugMenuVariableInfo               VariableInfo;                                      // 0x0000(0x0020)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0020(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_316F[0x7];                                     // 0x0021(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GzDebugMenuFunctionLibrary_GetBoolValue) == 0x000008, "Wrong alignment on GzDebugMenuFunctionLibrary_GetBoolValue");
static_assert(sizeof(GzDebugMenuFunctionLibrary_GetBoolValue) == 0x000028, "Wrong size on GzDebugMenuFunctionLibrary_GetBoolValue");
static_assert(offsetof(GzDebugMenuFunctionLibrary_GetBoolValue, VariableInfo) == 0x000000, "Member 'GzDebugMenuFunctionLibrary_GetBoolValue::VariableInfo' has a wrong offset!");
static_assert(offsetof(GzDebugMenuFunctionLibrary_GetBoolValue, ReturnValue) == 0x000020, "Member 'GzDebugMenuFunctionLibrary_GetBoolValue::ReturnValue' has a wrong offset!");

// Function G01.GzDebugMenuFunctionLibrary.GetCategory
// 0x0048 (0x0048 - 0x0000)
struct GzDebugMenuFunctionLibrary_GetCategory final
{
public:
	class FString                                 Param_Name;                                        // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGzDebugMenuCategory                   OutCategory;                                       // 0x0010(0x0030)(Parm, OutParm, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0040(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3170[0x7];                                     // 0x0041(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GzDebugMenuFunctionLibrary_GetCategory) == 0x000008, "Wrong alignment on GzDebugMenuFunctionLibrary_GetCategory");
static_assert(sizeof(GzDebugMenuFunctionLibrary_GetCategory) == 0x000048, "Wrong size on GzDebugMenuFunctionLibrary_GetCategory");
static_assert(offsetof(GzDebugMenuFunctionLibrary_GetCategory, Param_Name) == 0x000000, "Member 'GzDebugMenuFunctionLibrary_GetCategory::Param_Name' has a wrong offset!");
static_assert(offsetof(GzDebugMenuFunctionLibrary_GetCategory, OutCategory) == 0x000010, "Member 'GzDebugMenuFunctionLibrary_GetCategory::OutCategory' has a wrong offset!");
static_assert(offsetof(GzDebugMenuFunctionLibrary_GetCategory, ReturnValue) == 0x000040, "Member 'GzDebugMenuFunctionLibrary_GetCategory::ReturnValue' has a wrong offset!");

// Function G01.GzDebugMenuFunctionLibrary.GetFloatValue
// 0x0028 (0x0028 - 0x0000)
struct GzDebugMenuFunctionLibrary_GetFloatValue final
{
public:
	struct FGzDebugMenuVariableInfo               VariableInfo;                                      // 0x0000(0x0020)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	float                                         ReturnValue;                                       // 0x0020(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3171[0x4];                                     // 0x0024(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GzDebugMenuFunctionLibrary_GetFloatValue) == 0x000008, "Wrong alignment on GzDebugMenuFunctionLibrary_GetFloatValue");
static_assert(sizeof(GzDebugMenuFunctionLibrary_GetFloatValue) == 0x000028, "Wrong size on GzDebugMenuFunctionLibrary_GetFloatValue");
static_assert(offsetof(GzDebugMenuFunctionLibrary_GetFloatValue, VariableInfo) == 0x000000, "Member 'GzDebugMenuFunctionLibrary_GetFloatValue::VariableInfo' has a wrong offset!");
static_assert(offsetof(GzDebugMenuFunctionLibrary_GetFloatValue, ReturnValue) == 0x000020, "Member 'GzDebugMenuFunctionLibrary_GetFloatValue::ReturnValue' has a wrong offset!");

// Function G01.GzDebugMenuFunctionLibrary.GetIntValue
// 0x0028 (0x0028 - 0x0000)
struct GzDebugMenuFunctionLibrary_GetIntValue final
{
public:
	struct FGzDebugMenuVariableInfo               VariableInfo;                                      // 0x0000(0x0020)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	int32                                         ReturnValue;                                       // 0x0020(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3172[0x4];                                     // 0x0024(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GzDebugMenuFunctionLibrary_GetIntValue) == 0x000008, "Wrong alignment on GzDebugMenuFunctionLibrary_GetIntValue");
static_assert(sizeof(GzDebugMenuFunctionLibrary_GetIntValue) == 0x000028, "Wrong size on GzDebugMenuFunctionLibrary_GetIntValue");
static_assert(offsetof(GzDebugMenuFunctionLibrary_GetIntValue, VariableInfo) == 0x000000, "Member 'GzDebugMenuFunctionLibrary_GetIntValue::VariableInfo' has a wrong offset!");
static_assert(offsetof(GzDebugMenuFunctionLibrary_GetIntValue, ReturnValue) == 0x000020, "Member 'GzDebugMenuFunctionLibrary_GetIntValue::ReturnValue' has a wrong offset!");

// Function G01.GzDebugMenuFunctionLibrary.GetStringValue
// 0x0030 (0x0030 - 0x0000)
struct GzDebugMenuFunctionLibrary_GetStringValue final
{
public:
	struct FGzDebugMenuVariableInfo               VariableInfo;                                      // 0x0000(0x0020)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	class FString                                 ReturnValue;                                       // 0x0020(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzDebugMenuFunctionLibrary_GetStringValue) == 0x000008, "Wrong alignment on GzDebugMenuFunctionLibrary_GetStringValue");
static_assert(sizeof(GzDebugMenuFunctionLibrary_GetStringValue) == 0x000030, "Wrong size on GzDebugMenuFunctionLibrary_GetStringValue");
static_assert(offsetof(GzDebugMenuFunctionLibrary_GetStringValue, VariableInfo) == 0x000000, "Member 'GzDebugMenuFunctionLibrary_GetStringValue::VariableInfo' has a wrong offset!");
static_assert(offsetof(GzDebugMenuFunctionLibrary_GetStringValue, ReturnValue) == 0x000020, "Member 'GzDebugMenuFunctionLibrary_GetStringValue::ReturnValue' has a wrong offset!");

// Function G01.GzDebugMenuFunctionLibrary.GetVariableInfo
// 0x0038 (0x0038 - 0x0000)
struct GzDebugMenuFunctionLibrary_GetVariableInfo final
{
public:
	class FString                                 Param_Name;                                        // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGzDebugMenuVariableInfo               VariableInfoOut;                                   // 0x0010(0x0020)(Parm, OutParm, NativeAccessSpecifierPublic)
	bool                                          bExists;                                           // 0x0030(0x0001)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3173[0x7];                                     // 0x0031(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GzDebugMenuFunctionLibrary_GetVariableInfo) == 0x000008, "Wrong alignment on GzDebugMenuFunctionLibrary_GetVariableInfo");
static_assert(sizeof(GzDebugMenuFunctionLibrary_GetVariableInfo) == 0x000038, "Wrong size on GzDebugMenuFunctionLibrary_GetVariableInfo");
static_assert(offsetof(GzDebugMenuFunctionLibrary_GetVariableInfo, Param_Name) == 0x000000, "Member 'GzDebugMenuFunctionLibrary_GetVariableInfo::Param_Name' has a wrong offset!");
static_assert(offsetof(GzDebugMenuFunctionLibrary_GetVariableInfo, VariableInfoOut) == 0x000010, "Member 'GzDebugMenuFunctionLibrary_GetVariableInfo::VariableInfoOut' has a wrong offset!");
static_assert(offsetof(GzDebugMenuFunctionLibrary_GetVariableInfo, bExists) == 0x000030, "Member 'GzDebugMenuFunctionLibrary_GetVariableInfo::bExists' has a wrong offset!");

// Function G01.GzDebugMenuFunctionLibrary.IsBool
// 0x0018 (0x0018 - 0x0000)
struct GzDebugMenuFunctionLibrary_IsBool final
{
public:
	class FString                                 Param_Name;                                        // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0010(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3174[0x7];                                     // 0x0011(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GzDebugMenuFunctionLibrary_IsBool) == 0x000008, "Wrong alignment on GzDebugMenuFunctionLibrary_IsBool");
static_assert(sizeof(GzDebugMenuFunctionLibrary_IsBool) == 0x000018, "Wrong size on GzDebugMenuFunctionLibrary_IsBool");
static_assert(offsetof(GzDebugMenuFunctionLibrary_IsBool, Param_Name) == 0x000000, "Member 'GzDebugMenuFunctionLibrary_IsBool::Param_Name' has a wrong offset!");
static_assert(offsetof(GzDebugMenuFunctionLibrary_IsBool, ReturnValue) == 0x000010, "Member 'GzDebugMenuFunctionLibrary_IsBool::ReturnValue' has a wrong offset!");

// Function G01.GzDebugMenuFunctionLibrary.IsFloat
// 0x0018 (0x0018 - 0x0000)
struct GzDebugMenuFunctionLibrary_IsFloat final
{
public:
	class FString                                 Param_Name;                                        // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0010(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3175[0x7];                                     // 0x0011(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GzDebugMenuFunctionLibrary_IsFloat) == 0x000008, "Wrong alignment on GzDebugMenuFunctionLibrary_IsFloat");
static_assert(sizeof(GzDebugMenuFunctionLibrary_IsFloat) == 0x000018, "Wrong size on GzDebugMenuFunctionLibrary_IsFloat");
static_assert(offsetof(GzDebugMenuFunctionLibrary_IsFloat, Param_Name) == 0x000000, "Member 'GzDebugMenuFunctionLibrary_IsFloat::Param_Name' has a wrong offset!");
static_assert(offsetof(GzDebugMenuFunctionLibrary_IsFloat, ReturnValue) == 0x000010, "Member 'GzDebugMenuFunctionLibrary_IsFloat::ReturnValue' has a wrong offset!");

// Function G01.GzDebugMenuFunctionLibrary.IsInt
// 0x0018 (0x0018 - 0x0000)
struct GzDebugMenuFunctionLibrary_IsInt final
{
public:
	class FString                                 Param_Name;                                        // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0010(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3176[0x7];                                     // 0x0011(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GzDebugMenuFunctionLibrary_IsInt) == 0x000008, "Wrong alignment on GzDebugMenuFunctionLibrary_IsInt");
static_assert(sizeof(GzDebugMenuFunctionLibrary_IsInt) == 0x000018, "Wrong size on GzDebugMenuFunctionLibrary_IsInt");
static_assert(offsetof(GzDebugMenuFunctionLibrary_IsInt, Param_Name) == 0x000000, "Member 'GzDebugMenuFunctionLibrary_IsInt::Param_Name' has a wrong offset!");
static_assert(offsetof(GzDebugMenuFunctionLibrary_IsInt, ReturnValue) == 0x000010, "Member 'GzDebugMenuFunctionLibrary_IsInt::ReturnValue' has a wrong offset!");

// Function G01.GzDebugMenuFunctionLibrary.IsString
// 0x0018 (0x0018 - 0x0000)
struct GzDebugMenuFunctionLibrary_IsString final
{
public:
	class FString                                 Param_Name;                                        // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0010(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3177[0x7];                                     // 0x0011(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GzDebugMenuFunctionLibrary_IsString) == 0x000008, "Wrong alignment on GzDebugMenuFunctionLibrary_IsString");
static_assert(sizeof(GzDebugMenuFunctionLibrary_IsString) == 0x000018, "Wrong size on GzDebugMenuFunctionLibrary_IsString");
static_assert(offsetof(GzDebugMenuFunctionLibrary_IsString, Param_Name) == 0x000000, "Member 'GzDebugMenuFunctionLibrary_IsString::Param_Name' has a wrong offset!");
static_assert(offsetof(GzDebugMenuFunctionLibrary_IsString, ReturnValue) == 0x000010, "Member 'GzDebugMenuFunctionLibrary_IsString::ReturnValue' has a wrong offset!");

// Function G01.GzDebugMenuFunctionLibrary.RegisterBoolVariable
// 0x0038 (0x0038 - 0x0000)
struct GzDebugMenuFunctionLibrary_RegisterBoolVariable final
{
public:
	class FString                                 Param_Name;                                        // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Value;                                             // 0x0010(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3178[0x7];                                     // 0x0011(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGzDebugMenuVariableInfo               ReturnValue;                                       // 0x0018(0x0020)(Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzDebugMenuFunctionLibrary_RegisterBoolVariable) == 0x000008, "Wrong alignment on GzDebugMenuFunctionLibrary_RegisterBoolVariable");
static_assert(sizeof(GzDebugMenuFunctionLibrary_RegisterBoolVariable) == 0x000038, "Wrong size on GzDebugMenuFunctionLibrary_RegisterBoolVariable");
static_assert(offsetof(GzDebugMenuFunctionLibrary_RegisterBoolVariable, Param_Name) == 0x000000, "Member 'GzDebugMenuFunctionLibrary_RegisterBoolVariable::Param_Name' has a wrong offset!");
static_assert(offsetof(GzDebugMenuFunctionLibrary_RegisterBoolVariable, Value) == 0x000010, "Member 'GzDebugMenuFunctionLibrary_RegisterBoolVariable::Value' has a wrong offset!");
static_assert(offsetof(GzDebugMenuFunctionLibrary_RegisterBoolVariable, ReturnValue) == 0x000018, "Member 'GzDebugMenuFunctionLibrary_RegisterBoolVariable::ReturnValue' has a wrong offset!");

// Function G01.GzDebugMenuFunctionLibrary.RegisterFloatVariable
// 0x0038 (0x0038 - 0x0000)
struct GzDebugMenuFunctionLibrary_RegisterFloatVariable final
{
public:
	class FString                                 Param_Name;                                        // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Value;                                             // 0x0010(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3179[0x4];                                     // 0x0014(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGzDebugMenuVariableInfo               ReturnValue;                                       // 0x0018(0x0020)(Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzDebugMenuFunctionLibrary_RegisterFloatVariable) == 0x000008, "Wrong alignment on GzDebugMenuFunctionLibrary_RegisterFloatVariable");
static_assert(sizeof(GzDebugMenuFunctionLibrary_RegisterFloatVariable) == 0x000038, "Wrong size on GzDebugMenuFunctionLibrary_RegisterFloatVariable");
static_assert(offsetof(GzDebugMenuFunctionLibrary_RegisterFloatVariable, Param_Name) == 0x000000, "Member 'GzDebugMenuFunctionLibrary_RegisterFloatVariable::Param_Name' has a wrong offset!");
static_assert(offsetof(GzDebugMenuFunctionLibrary_RegisterFloatVariable, Value) == 0x000010, "Member 'GzDebugMenuFunctionLibrary_RegisterFloatVariable::Value' has a wrong offset!");
static_assert(offsetof(GzDebugMenuFunctionLibrary_RegisterFloatVariable, ReturnValue) == 0x000018, "Member 'GzDebugMenuFunctionLibrary_RegisterFloatVariable::ReturnValue' has a wrong offset!");

// Function G01.GzDebugMenuFunctionLibrary.RegisterIntVariable
// 0x0038 (0x0038 - 0x0000)
struct GzDebugMenuFunctionLibrary_RegisterIntVariable final
{
public:
	class FString                                 Param_Name;                                        // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Value;                                             // 0x0010(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_317A[0x4];                                     // 0x0014(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGzDebugMenuVariableInfo               ReturnValue;                                       // 0x0018(0x0020)(Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzDebugMenuFunctionLibrary_RegisterIntVariable) == 0x000008, "Wrong alignment on GzDebugMenuFunctionLibrary_RegisterIntVariable");
static_assert(sizeof(GzDebugMenuFunctionLibrary_RegisterIntVariable) == 0x000038, "Wrong size on GzDebugMenuFunctionLibrary_RegisterIntVariable");
static_assert(offsetof(GzDebugMenuFunctionLibrary_RegisterIntVariable, Param_Name) == 0x000000, "Member 'GzDebugMenuFunctionLibrary_RegisterIntVariable::Param_Name' has a wrong offset!");
static_assert(offsetof(GzDebugMenuFunctionLibrary_RegisterIntVariable, Value) == 0x000010, "Member 'GzDebugMenuFunctionLibrary_RegisterIntVariable::Value' has a wrong offset!");
static_assert(offsetof(GzDebugMenuFunctionLibrary_RegisterIntVariable, ReturnValue) == 0x000018, "Member 'GzDebugMenuFunctionLibrary_RegisterIntVariable::ReturnValue' has a wrong offset!");

// Function G01.GzDebugMenuFunctionLibrary.RegisterStringVariable
// 0x0040 (0x0040 - 0x0000)
struct GzDebugMenuFunctionLibrary_RegisterStringVariable final
{
public:
	class FString                                 Param_Name;                                        // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Value;                                             // 0x0010(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGzDebugMenuVariableInfo               ReturnValue;                                       // 0x0020(0x0020)(Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzDebugMenuFunctionLibrary_RegisterStringVariable) == 0x000008, "Wrong alignment on GzDebugMenuFunctionLibrary_RegisterStringVariable");
static_assert(sizeof(GzDebugMenuFunctionLibrary_RegisterStringVariable) == 0x000040, "Wrong size on GzDebugMenuFunctionLibrary_RegisterStringVariable");
static_assert(offsetof(GzDebugMenuFunctionLibrary_RegisterStringVariable, Param_Name) == 0x000000, "Member 'GzDebugMenuFunctionLibrary_RegisterStringVariable::Param_Name' has a wrong offset!");
static_assert(offsetof(GzDebugMenuFunctionLibrary_RegisterStringVariable, Value) == 0x000010, "Member 'GzDebugMenuFunctionLibrary_RegisterStringVariable::Value' has a wrong offset!");
static_assert(offsetof(GzDebugMenuFunctionLibrary_RegisterStringVariable, ReturnValue) == 0x000020, "Member 'GzDebugMenuFunctionLibrary_RegisterStringVariable::ReturnValue' has a wrong offset!");

// Function G01.GzDebugMenuItemComboBox.InitializeList
// 0x0001 (0x0001 - 0x0000)
struct GzDebugMenuItemComboBox_InitializeList final
{
public:
	EGzItemType                                   InItemType;                                        // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzDebugMenuItemComboBox_InitializeList) == 0x000001, "Wrong alignment on GzDebugMenuItemComboBox_InitializeList");
static_assert(sizeof(GzDebugMenuItemComboBox_InitializeList) == 0x000001, "Wrong size on GzDebugMenuItemComboBox_InitializeList");
static_assert(offsetof(GzDebugMenuItemComboBox_InitializeList, InItemType) == 0x000000, "Member 'GzDebugMenuItemComboBox_InitializeList::InItemType' has a wrong offset!");

// Function G01.GzDebugMenuItemComboBox.InitializeListForLimb
// 0x0002 (0x0002 - 0x0000)
struct GzDebugMenuItemComboBox_InitializeListForLimb final
{
public:
	EGzItemType                                   InItemType;                                        // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EGzLimbType                                   InLimbType;                                        // 0x0001(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzDebugMenuItemComboBox_InitializeListForLimb) == 0x000001, "Wrong alignment on GzDebugMenuItemComboBox_InitializeListForLimb");
static_assert(sizeof(GzDebugMenuItemComboBox_InitializeListForLimb) == 0x000002, "Wrong size on GzDebugMenuItemComboBox_InitializeListForLimb");
static_assert(offsetof(GzDebugMenuItemComboBox_InitializeListForLimb, InItemType) == 0x000000, "Member 'GzDebugMenuItemComboBox_InitializeListForLimb::InItemType' has a wrong offset!");
static_assert(offsetof(GzDebugMenuItemComboBox_InitializeListForLimb, InLimbType) == 0x000001, "Member 'GzDebugMenuItemComboBox_InitializeListForLimb::InLimbType' has a wrong offset!");

// Function G01.GzDebugMenuItemComboBox.SetItemRarity
// 0x0001 (0x0001 - 0x0000)
struct GzDebugMenuItemComboBox_SetItemRarity final
{
public:
	EGzItemRarity                                 Rarity;                                            // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzDebugMenuItemComboBox_SetItemRarity) == 0x000001, "Wrong alignment on GzDebugMenuItemComboBox_SetItemRarity");
static_assert(sizeof(GzDebugMenuItemComboBox_SetItemRarity) == 0x000001, "Wrong size on GzDebugMenuItemComboBox_SetItemRarity");
static_assert(offsetof(GzDebugMenuItemComboBox_SetItemRarity, Rarity) == 0x000000, "Member 'GzDebugMenuItemComboBox_SetItemRarity::Rarity' has a wrong offset!");

// Function G01.GzDebugMenuItemComboBox.SetShowHiddenItems
// 0x0001 (0x0001 - 0x0000)
struct GzDebugMenuItemComboBox_SetShowHiddenItems final
{
public:
	bool                                          bShouldShow;                                       // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzDebugMenuItemComboBox_SetShowHiddenItems) == 0x000001, "Wrong alignment on GzDebugMenuItemComboBox_SetShowHiddenItems");
static_assert(sizeof(GzDebugMenuItemComboBox_SetShowHiddenItems) == 0x000001, "Wrong size on GzDebugMenuItemComboBox_SetShowHiddenItems");
static_assert(offsetof(GzDebugMenuItemComboBox_SetShowHiddenItems, bShouldShow) == 0x000000, "Member 'GzDebugMenuItemComboBox_SetShowHiddenItems::bShouldShow' has a wrong offset!");

// Function G01.GzDebugMenuItemComboBox.FindItemData
// 0x0018 (0x0018 - 0x0000)
struct GzDebugMenuItemComboBox_FindItemData final
{
public:
	class FString                                 Key;                                               // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	const class UGzItemData*                      ReturnValue;                                       // 0x0010(0x0008)(ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzDebugMenuItemComboBox_FindItemData) == 0x000008, "Wrong alignment on GzDebugMenuItemComboBox_FindItemData");
static_assert(sizeof(GzDebugMenuItemComboBox_FindItemData) == 0x000018, "Wrong size on GzDebugMenuItemComboBox_FindItemData");
static_assert(offsetof(GzDebugMenuItemComboBox_FindItemData, Key) == 0x000000, "Member 'GzDebugMenuItemComboBox_FindItemData::Key' has a wrong offset!");
static_assert(offsetof(GzDebugMenuItemComboBox_FindItemData, ReturnValue) == 0x000010, "Member 'GzDebugMenuItemComboBox_FindItemData::ReturnValue' has a wrong offset!");

// Function G01.GzDebugMenuItemComboBox.GetSelectedItemData
// 0x0008 (0x0008 - 0x0000)
struct GzDebugMenuItemComboBox_GetSelectedItemData final
{
public:
	const class UGzItemData*                      ReturnValue;                                       // 0x0000(0x0008)(ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzDebugMenuItemComboBox_GetSelectedItemData) == 0x000008, "Wrong alignment on GzDebugMenuItemComboBox_GetSelectedItemData");
static_assert(sizeof(GzDebugMenuItemComboBox_GetSelectedItemData) == 0x000008, "Wrong size on GzDebugMenuItemComboBox_GetSelectedItemData");
static_assert(offsetof(GzDebugMenuItemComboBox_GetSelectedItemData, ReturnValue) == 0x000000, "Member 'GzDebugMenuItemComboBox_GetSelectedItemData::ReturnValue' has a wrong offset!");

// Function G01.GzGA_MortarLegs.OnScanUpdate
// 0x0004 (0x0004 - 0x0000)
struct GzGA_MortarLegs_OnScanUpdate final
{
public:
	float                                         NewProgress;                                       // 0x0000(0x0004)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzGA_MortarLegs_OnScanUpdate) == 0x000004, "Wrong alignment on GzGA_MortarLegs_OnScanUpdate");
static_assert(sizeof(GzGA_MortarLegs_OnScanUpdate) == 0x000004, "Wrong size on GzGA_MortarLegs_OnScanUpdate");
static_assert(offsetof(GzGA_MortarLegs_OnScanUpdate, NewProgress) == 0x000000, "Member 'GzGA_MortarLegs_OnScanUpdate::NewProgress' has a wrong offset!");

// Function G01.GzGA_MortarLegs.ReceiveTargetData
// 0x0028 (0x0028 - 0x0000)
struct GzGA_MortarLegs_ReceiveTargetData final
{
public:
	struct FGameplayAbilityTargetDataHandle       TargetData;                                        // 0x0000(0x0028)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzGA_MortarLegs_ReceiveTargetData) == 0x000008, "Wrong alignment on GzGA_MortarLegs_ReceiveTargetData");
static_assert(sizeof(GzGA_MortarLegs_ReceiveTargetData) == 0x000028, "Wrong size on GzGA_MortarLegs_ReceiveTargetData");
static_assert(offsetof(GzGA_MortarLegs_ReceiveTargetData, TargetData) == 0x000000, "Member 'GzGA_MortarLegs_ReceiveTargetData::TargetData' has a wrong offset!");

// Function G01.GzSpiderMine_PreviewComponent.UpdateLinkPreviewActor
// 0x0038 (0x0038 - 0x0000)
struct GzSpiderMine_PreviewComponent_UpdateLinkPreviewActor final
{
public:
	bool                                          bCanShow;                                          // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bValid;                                            // 0x0001(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3188[0x6];                                     // 0x0002(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                Start;                                             // 0x0008(0x0018)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                End;                                               // 0x0020(0x0018)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzSpiderMine_PreviewComponent_UpdateLinkPreviewActor) == 0x000008, "Wrong alignment on GzSpiderMine_PreviewComponent_UpdateLinkPreviewActor");
static_assert(sizeof(GzSpiderMine_PreviewComponent_UpdateLinkPreviewActor) == 0x000038, "Wrong size on GzSpiderMine_PreviewComponent_UpdateLinkPreviewActor");
static_assert(offsetof(GzSpiderMine_PreviewComponent_UpdateLinkPreviewActor, bCanShow) == 0x000000, "Member 'GzSpiderMine_PreviewComponent_UpdateLinkPreviewActor::bCanShow' has a wrong offset!");
static_assert(offsetof(GzSpiderMine_PreviewComponent_UpdateLinkPreviewActor, bValid) == 0x000001, "Member 'GzSpiderMine_PreviewComponent_UpdateLinkPreviewActor::bValid' has a wrong offset!");
static_assert(offsetof(GzSpiderMine_PreviewComponent_UpdateLinkPreviewActor, Start) == 0x000008, "Member 'GzSpiderMine_PreviewComponent_UpdateLinkPreviewActor::Start' has a wrong offset!");
static_assert(offsetof(GzSpiderMine_PreviewComponent_UpdateLinkPreviewActor, End) == 0x000020, "Member 'GzSpiderMine_PreviewComponent_UpdateLinkPreviewActor::End' has a wrong offset!");

// Function G01.GzLoadoutSelectionScreenQuickOrder.HandleDroneCallAvailability
// 0x0010 (0x0010 - 0x0000)
struct GzLoadoutSelectionScreenQuickOrder_HandleDroneCallAvailability final
{
public:
	struct FGuid                                  Guid;                                              // 0x0000(0x0010)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzLoadoutSelectionScreenQuickOrder_HandleDroneCallAvailability) == 0x000004, "Wrong alignment on GzLoadoutSelectionScreenQuickOrder_HandleDroneCallAvailability");
static_assert(sizeof(GzLoadoutSelectionScreenQuickOrder_HandleDroneCallAvailability) == 0x000010, "Wrong size on GzLoadoutSelectionScreenQuickOrder_HandleDroneCallAvailability");
static_assert(offsetof(GzLoadoutSelectionScreenQuickOrder_HandleDroneCallAvailability, Guid) == 0x000000, "Member 'GzLoadoutSelectionScreenQuickOrder_HandleDroneCallAvailability::Guid' has a wrong offset!");

// Function G01.GzLoadoutSelectionScreenQuickOrder.OnValidationFailed
// 0x0001 (0x0001 - 0x0000)
struct GzLoadoutSelectionScreenQuickOrder_OnValidationFailed final
{
public:
	EGzQuickOrderCallValidationFailReason         FailReason;                                        // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzLoadoutSelectionScreenQuickOrder_OnValidationFailed) == 0x000001, "Wrong alignment on GzLoadoutSelectionScreenQuickOrder_OnValidationFailed");
static_assert(sizeof(GzLoadoutSelectionScreenQuickOrder_OnValidationFailed) == 0x000001, "Wrong size on GzLoadoutSelectionScreenQuickOrder_OnValidationFailed");
static_assert(offsetof(GzLoadoutSelectionScreenQuickOrder_OnValidationFailed, FailReason) == 0x000000, "Member 'GzLoadoutSelectionScreenQuickOrder_OnValidationFailed::FailReason' has a wrong offset!");

// Function G01.ModularCharacterAnimInstance.GetModularCharacter
// 0x0008 (0x0008 - 0x0000)
struct ModularCharacterAnimInstance_GetModularCharacter final
{
public:
	class AGzMultiPartCharacter*                  ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ModularCharacterAnimInstance_GetModularCharacter) == 0x000008, "Wrong alignment on ModularCharacterAnimInstance_GetModularCharacter");
static_assert(sizeof(ModularCharacterAnimInstance_GetModularCharacter) == 0x000008, "Wrong size on ModularCharacterAnimInstance_GetModularCharacter");
static_assert(offsetof(ModularCharacterAnimInstance_GetModularCharacter, ReturnValue) == 0x000000, "Member 'ModularCharacterAnimInstance_GetModularCharacter::ReturnValue' has a wrong offset!");

// Function G01.GzDefaultCharacterAnimInstance.GetAnimCache
// 0x0218 (0x0218 - 0x0000)
struct GzDefaultCharacterAnimInstance_GetAnimCache final
{
public:
	struct FAnimCache                             ReturnValue;                                       // 0x0000(0x0218)(Parm, OutParm, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzDefaultCharacterAnimInstance_GetAnimCache) == 0x000008, "Wrong alignment on GzDefaultCharacterAnimInstance_GetAnimCache");
static_assert(sizeof(GzDefaultCharacterAnimInstance_GetAnimCache) == 0x000218, "Wrong size on GzDefaultCharacterAnimInstance_GetAnimCache");
static_assert(offsetof(GzDefaultCharacterAnimInstance_GetAnimCache, ReturnValue) == 0x000000, "Member 'GzDefaultCharacterAnimInstance_GetAnimCache::ReturnValue' has a wrong offset!");

// Function G01.GzDefaultCharacterAnimInstance.GetAnimHitReactionData
// 0x0010 (0x0010 - 0x0000)
struct GzDefaultCharacterAnimInstance_GetAnimHitReactionData final
{
public:
	TArray<struct FGzAnimHitReactionData>         ReturnValue;                                       // 0x0000(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzDefaultCharacterAnimInstance_GetAnimHitReactionData) == 0x000008, "Wrong alignment on GzDefaultCharacterAnimInstance_GetAnimHitReactionData");
static_assert(sizeof(GzDefaultCharacterAnimInstance_GetAnimHitReactionData) == 0x000010, "Wrong size on GzDefaultCharacterAnimInstance_GetAnimHitReactionData");
static_assert(offsetof(GzDefaultCharacterAnimInstance_GetAnimHitReactionData, ReturnValue) == 0x000000, "Member 'GzDefaultCharacterAnimInstance_GetAnimHitReactionData::ReturnValue' has a wrong offset!");

// Function G01.GzDefaultCharacterAnimInstance.GetOppositeCardinalDirectionNative
// 0x0002 (0x0002 - 0x0000)
struct GzDefaultCharacterAnimInstance_GetOppositeCardinalDirectionNative final
{
public:
	ECardinalDirectionType                        CurrentDirection;                                  // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECardinalDirectionType                        ReturnValue;                                       // 0x0001(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzDefaultCharacterAnimInstance_GetOppositeCardinalDirectionNative) == 0x000001, "Wrong alignment on GzDefaultCharacterAnimInstance_GetOppositeCardinalDirectionNative");
static_assert(sizeof(GzDefaultCharacterAnimInstance_GetOppositeCardinalDirectionNative) == 0x000002, "Wrong size on GzDefaultCharacterAnimInstance_GetOppositeCardinalDirectionNative");
static_assert(offsetof(GzDefaultCharacterAnimInstance_GetOppositeCardinalDirectionNative, CurrentDirection) == 0x000000, "Member 'GzDefaultCharacterAnimInstance_GetOppositeCardinalDirectionNative::CurrentDirection' has a wrong offset!");
static_assert(offsetof(GzDefaultCharacterAnimInstance_GetOppositeCardinalDirectionNative, ReturnValue) == 0x000001, "Member 'GzDefaultCharacterAnimInstance_GetOppositeCardinalDirectionNative::ReturnValue' has a wrong offset!");

// Function G01.GzDefaultCharacterAnimInstance.SelectCardinalDirectionFromAngleNative
// 0x000C (0x000C - 0x0000)
struct GzDefaultCharacterAnimInstance_SelectCardinalDirectionFromAngleNative final
{
public:
	float                                         Angle;                                             // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DeadZone;                                          // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECardinalDirectionType                        CurrentDirection;                                  // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          UseCurrentDirection;                               // 0x0009(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECardinalDirectionType                        ReturnValue;                                       // 0x000A(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_31AA[0x1];                                     // 0x000B(0x0001)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GzDefaultCharacterAnimInstance_SelectCardinalDirectionFromAngleNative) == 0x000004, "Wrong alignment on GzDefaultCharacterAnimInstance_SelectCardinalDirectionFromAngleNative");
static_assert(sizeof(GzDefaultCharacterAnimInstance_SelectCardinalDirectionFromAngleNative) == 0x00000C, "Wrong size on GzDefaultCharacterAnimInstance_SelectCardinalDirectionFromAngleNative");
static_assert(offsetof(GzDefaultCharacterAnimInstance_SelectCardinalDirectionFromAngleNative, Angle) == 0x000000, "Member 'GzDefaultCharacterAnimInstance_SelectCardinalDirectionFromAngleNative::Angle' has a wrong offset!");
static_assert(offsetof(GzDefaultCharacterAnimInstance_SelectCardinalDirectionFromAngleNative, DeadZone) == 0x000004, "Member 'GzDefaultCharacterAnimInstance_SelectCardinalDirectionFromAngleNative::DeadZone' has a wrong offset!");
static_assert(offsetof(GzDefaultCharacterAnimInstance_SelectCardinalDirectionFromAngleNative, CurrentDirection) == 0x000008, "Member 'GzDefaultCharacterAnimInstance_SelectCardinalDirectionFromAngleNative::CurrentDirection' has a wrong offset!");
static_assert(offsetof(GzDefaultCharacterAnimInstance_SelectCardinalDirectionFromAngleNative, UseCurrentDirection) == 0x000009, "Member 'GzDefaultCharacterAnimInstance_SelectCardinalDirectionFromAngleNative::UseCurrentDirection' has a wrong offset!");
static_assert(offsetof(GzDefaultCharacterAnimInstance_SelectCardinalDirectionFromAngleNative, ReturnValue) == 0x00000A, "Member 'GzDefaultCharacterAnimInstance_SelectCardinalDirectionFromAngleNative::ReturnValue' has a wrong offset!");

// Function G01.GzDefaultCharacterAnimInstance.SetAnimAbilityState
// 0x0001 (0x0001 - 0x0000)
struct GzDefaultCharacterAnimInstance_SetAnimAbilityState final
{
public:
	bool                                          bIsActive;                                         // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzDefaultCharacterAnimInstance_SetAnimAbilityState) == 0x000001, "Wrong alignment on GzDefaultCharacterAnimInstance_SetAnimAbilityState");
static_assert(sizeof(GzDefaultCharacterAnimInstance_SetAnimAbilityState) == 0x000001, "Wrong size on GzDefaultCharacterAnimInstance_SetAnimAbilityState");
static_assert(offsetof(GzDefaultCharacterAnimInstance_SetAnimAbilityState, bIsActive) == 0x000000, "Member 'GzDefaultCharacterAnimInstance_SetAnimAbilityState::bIsActive' has a wrong offset!");

// Function G01.GzDefaultCharacterAnimInstance.SetAnimLayerInstance
// 0x0008 (0x0008 - 0x0000)
struct GzDefaultCharacterAnimInstance_SetAnimLayerInstance final
{
public:
	TSubclassOf<class UAnimInstance>              NewLayer;                                          // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzDefaultCharacterAnimInstance_SetAnimLayerInstance) == 0x000008, "Wrong alignment on GzDefaultCharacterAnimInstance_SetAnimLayerInstance");
static_assert(sizeof(GzDefaultCharacterAnimInstance_SetAnimLayerInstance) == 0x000008, "Wrong size on GzDefaultCharacterAnimInstance_SetAnimLayerInstance");
static_assert(offsetof(GzDefaultCharacterAnimInstance_SetAnimLayerInstance, NewLayer) == 0x000000, "Member 'GzDefaultCharacterAnimInstance_SetAnimLayerInstance::NewLayer' has a wrong offset!");

// Function G01.GzDefaultCharacterAnimInstance.SetAnimStance
// 0x0001 (0x0001 - 0x0000)
struct GzDefaultCharacterAnimInstance_SetAnimStance final
{
public:
	EAnimStances                                  Value;                                             // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzDefaultCharacterAnimInstance_SetAnimStance) == 0x000001, "Wrong alignment on GzDefaultCharacterAnimInstance_SetAnimStance");
static_assert(sizeof(GzDefaultCharacterAnimInstance_SetAnimStance) == 0x000001, "Wrong size on GzDefaultCharacterAnimInstance_SetAnimStance");
static_assert(offsetof(GzDefaultCharacterAnimInstance_SetAnimStance, Value) == 0x000000, "Member 'GzDefaultCharacterAnimInstance_SetAnimStance::Value' has a wrong offset!");

// Function G01.GzDefaultCharacterAnimInstance.SetLastLinkedLayer
// 0x0008 (0x0008 - 0x0000)
struct GzDefaultCharacterAnimInstance_SetLastLinkedLayer final
{
public:
	class UAnimInstance*                          NewInstance;                                       // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzDefaultCharacterAnimInstance_SetLastLinkedLayer) == 0x000008, "Wrong alignment on GzDefaultCharacterAnimInstance_SetLastLinkedLayer");
static_assert(sizeof(GzDefaultCharacterAnimInstance_SetLastLinkedLayer) == 0x000008, "Wrong size on GzDefaultCharacterAnimInstance_SetLastLinkedLayer");
static_assert(offsetof(GzDefaultCharacterAnimInstance_SetLastLinkedLayer, NewInstance) == 0x000000, "Member 'GzDefaultCharacterAnimInstance_SetLastLinkedLayer::NewInstance' has a wrong offset!");

// Function G01.GzDefaultCharacterAnimInstance.SetLastPivotTime
// 0x0004 (0x0004 - 0x0000)
struct GzDefaultCharacterAnimInstance_SetLastPivotTime final
{
public:
	float                                         Value;                                             // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzDefaultCharacterAnimInstance_SetLastPivotTime) == 0x000004, "Wrong alignment on GzDefaultCharacterAnimInstance_SetLastPivotTime");
static_assert(sizeof(GzDefaultCharacterAnimInstance_SetLastPivotTime) == 0x000004, "Wrong size on GzDefaultCharacterAnimInstance_SetLastPivotTime");
static_assert(offsetof(GzDefaultCharacterAnimInstance_SetLastPivotTime, Value) == 0x000000, "Member 'GzDefaultCharacterAnimInstance_SetLastPivotTime::Value' has a wrong offset!");

// Function G01.GzDefaultCharacterAnimInstance.SetLinkedLayerChanged
// 0x0001 (0x0001 - 0x0000)
struct GzDefaultCharacterAnimInstance_SetLinkedLayerChanged final
{
public:
	bool                                          Value;                                             // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzDefaultCharacterAnimInstance_SetLinkedLayerChanged) == 0x000001, "Wrong alignment on GzDefaultCharacterAnimInstance_SetLinkedLayerChanged");
static_assert(sizeof(GzDefaultCharacterAnimInstance_SetLinkedLayerChanged) == 0x000001, "Wrong size on GzDefaultCharacterAnimInstance_SetLinkedLayerChanged");
static_assert(offsetof(GzDefaultCharacterAnimInstance_SetLinkedLayerChanged, Value) == 0x000000, "Member 'GzDefaultCharacterAnimInstance_SetLinkedLayerChanged::Value' has a wrong offset!");

// Function G01.GzDefaultCharacterAnimInstance.SetRootYawOffsetNative
// 0x0004 (0x0004 - 0x0000)
struct GzDefaultCharacterAnimInstance_SetRootYawOffsetNative final
{
public:
	float                                         InRootYawOffset;                                   // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzDefaultCharacterAnimInstance_SetRootYawOffsetNative) == 0x000004, "Wrong alignment on GzDefaultCharacterAnimInstance_SetRootYawOffsetNative");
static_assert(sizeof(GzDefaultCharacterAnimInstance_SetRootYawOffsetNative) == 0x000004, "Wrong size on GzDefaultCharacterAnimInstance_SetRootYawOffsetNative");
static_assert(offsetof(GzDefaultCharacterAnimInstance_SetRootYawOffsetNative, InRootYawOffset) == 0x000000, "Member 'GzDefaultCharacterAnimInstance_SetRootYawOffsetNative::InRootYawOffset' has a wrong offset!");

// Function G01.GzDefaultCharacterAnimInstance.SetUpPivotStateNative
// 0x0020 (0x0020 - 0x0000)
struct GzDefaultCharacterAnimInstance_SetUpPivotStateNative final
{
public:
	struct FAnimUpdateContext                     Context;                                           // 0x0000(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	struct FAnimNodeReference                     Node;                                              // 0x0010(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzDefaultCharacterAnimInstance_SetUpPivotStateNative) == 0x000008, "Wrong alignment on GzDefaultCharacterAnimInstance_SetUpPivotStateNative");
static_assert(sizeof(GzDefaultCharacterAnimInstance_SetUpPivotStateNative) == 0x000020, "Wrong size on GzDefaultCharacterAnimInstance_SetUpPivotStateNative");
static_assert(offsetof(GzDefaultCharacterAnimInstance_SetUpPivotStateNative, Context) == 0x000000, "Member 'GzDefaultCharacterAnimInstance_SetUpPivotStateNative::Context' has a wrong offset!");
static_assert(offsetof(GzDefaultCharacterAnimInstance_SetUpPivotStateNative, Node) == 0x000010, "Member 'GzDefaultCharacterAnimInstance_SetUpPivotStateNative::Node' has a wrong offset!");

// Function G01.GzDefaultCharacterAnimInstance.SetUpStartStateNative
// 0x0020 (0x0020 - 0x0000)
struct GzDefaultCharacterAnimInstance_SetUpStartStateNative final
{
public:
	struct FAnimUpdateContext                     Context;                                           // 0x0000(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	struct FAnimNodeReference                     Node;                                              // 0x0010(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzDefaultCharacterAnimInstance_SetUpStartStateNative) == 0x000008, "Wrong alignment on GzDefaultCharacterAnimInstance_SetUpStartStateNative");
static_assert(sizeof(GzDefaultCharacterAnimInstance_SetUpStartStateNative) == 0x000020, "Wrong size on GzDefaultCharacterAnimInstance_SetUpStartStateNative");
static_assert(offsetof(GzDefaultCharacterAnimInstance_SetUpStartStateNative, Context) == 0x000000, "Member 'GzDefaultCharacterAnimInstance_SetUpStartStateNative::Context' has a wrong offset!");
static_assert(offsetof(GzDefaultCharacterAnimInstance_SetUpStartStateNative, Node) == 0x000010, "Member 'GzDefaultCharacterAnimInstance_SetUpStartStateNative::Node' has a wrong offset!");

// Function G01.GzDefaultCharacterAnimInstance.SwitchAnimLayer
// 0x0001 (0x0001 - 0x0000)
struct GzDefaultCharacterAnimInstance_SwitchAnimLayer final
{
public:
	EGzLayerItemType                              LayerIndex;                                        // 0x0000(0x0001)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzDefaultCharacterAnimInstance_SwitchAnimLayer) == 0x000001, "Wrong alignment on GzDefaultCharacterAnimInstance_SwitchAnimLayer");
static_assert(sizeof(GzDefaultCharacterAnimInstance_SwitchAnimLayer) == 0x000001, "Wrong size on GzDefaultCharacterAnimInstance_SwitchAnimLayer");
static_assert(offsetof(GzDefaultCharacterAnimInstance_SwitchAnimLayer, LayerIndex) == 0x000000, "Member 'GzDefaultCharacterAnimInstance_SwitchAnimLayer::LayerIndex' has a wrong offset!");

// Function G01.GzDefaultCharacterAnimInstance.SwitchAnimLayerInstance
// 0x0008 (0x0008 - 0x0000)
struct GzDefaultCharacterAnimInstance_SwitchAnimLayerInstance final
{
public:
	TSubclassOf<class UAnimInstance>              NewLayer;                                          // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzDefaultCharacterAnimInstance_SwitchAnimLayerInstance) == 0x000008, "Wrong alignment on GzDefaultCharacterAnimInstance_SwitchAnimLayerInstance");
static_assert(sizeof(GzDefaultCharacterAnimInstance_SwitchAnimLayerInstance) == 0x000008, "Wrong size on GzDefaultCharacterAnimInstance_SwitchAnimLayerInstance");
static_assert(offsetof(GzDefaultCharacterAnimInstance_SwitchAnimLayerInstance, NewLayer) == 0x000000, "Member 'GzDefaultCharacterAnimInstance_SwitchAnimLayerInstance::NewLayer' has a wrong offset!");

// Function G01.GzDefaultCharacterAnimInstance.UpdateAbilityAnimWeight
// 0x0004 (0x0004 - 0x0000)
struct GzDefaultCharacterAnimInstance_UpdateAbilityAnimWeight final
{
public:
	float                                         DeltaSeconds;                                      // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzDefaultCharacterAnimInstance_UpdateAbilityAnimWeight) == 0x000004, "Wrong alignment on GzDefaultCharacterAnimInstance_UpdateAbilityAnimWeight");
static_assert(sizeof(GzDefaultCharacterAnimInstance_UpdateAbilityAnimWeight) == 0x000004, "Wrong size on GzDefaultCharacterAnimInstance_UpdateAbilityAnimWeight");
static_assert(offsetof(GzDefaultCharacterAnimInstance_UpdateAbilityAnimWeight, DeltaSeconds) == 0x000000, "Member 'GzDefaultCharacterAnimInstance_UpdateAbilityAnimWeight::DeltaSeconds' has a wrong offset!");

// Function G01.GzDefaultCharacterAnimInstance.UpdateBlendWeightDataNative
// 0x0004 (0x0004 - 0x0000)
struct GzDefaultCharacterAnimInstance_UpdateBlendWeightDataNative final
{
public:
	float                                         DeltaTime;                                         // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzDefaultCharacterAnimInstance_UpdateBlendWeightDataNative) == 0x000004, "Wrong alignment on GzDefaultCharacterAnimInstance_UpdateBlendWeightDataNative");
static_assert(sizeof(GzDefaultCharacterAnimInstance_UpdateBlendWeightDataNative) == 0x000004, "Wrong size on GzDefaultCharacterAnimInstance_UpdateBlendWeightDataNative");
static_assert(offsetof(GzDefaultCharacterAnimInstance_UpdateBlendWeightDataNative, DeltaTime) == 0x000000, "Member 'GzDefaultCharacterAnimInstance_UpdateBlendWeightDataNative::DeltaTime' has a wrong offset!");

// Function G01.GzDefaultCharacterAnimInstance.UpdateCacheLimbFlags
// 0x0004 (0x0004 - 0x0000)
struct GzDefaultCharacterAnimInstance_UpdateCacheLimbFlags final
{
public:
	int32                                         NewLimbFlags;                                      // 0x0000(0x0004)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzDefaultCharacterAnimInstance_UpdateCacheLimbFlags) == 0x000004, "Wrong alignment on GzDefaultCharacterAnimInstance_UpdateCacheLimbFlags");
static_assert(sizeof(GzDefaultCharacterAnimInstance_UpdateCacheLimbFlags) == 0x000004, "Wrong size on GzDefaultCharacterAnimInstance_UpdateCacheLimbFlags");
static_assert(offsetof(GzDefaultCharacterAnimInstance_UpdateCacheLimbFlags, NewLimbFlags) == 0x000000, "Member 'GzDefaultCharacterAnimInstance_UpdateCacheLimbFlags::NewLimbFlags' has a wrong offset!");

// Function G01.GzDefaultCharacterAnimInstance.UpdateIdleStateNative
// 0x0020 (0x0020 - 0x0000)
struct GzDefaultCharacterAnimInstance_UpdateIdleStateNative final
{
public:
	struct FAnimUpdateContext                     Context;                                           // 0x0000(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	struct FAnimNodeReference                     Node;                                              // 0x0010(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzDefaultCharacterAnimInstance_UpdateIdleStateNative) == 0x000008, "Wrong alignment on GzDefaultCharacterAnimInstance_UpdateIdleStateNative");
static_assert(sizeof(GzDefaultCharacterAnimInstance_UpdateIdleStateNative) == 0x000020, "Wrong size on GzDefaultCharacterAnimInstance_UpdateIdleStateNative");
static_assert(offsetof(GzDefaultCharacterAnimInstance_UpdateIdleStateNative, Context) == 0x000000, "Member 'GzDefaultCharacterAnimInstance_UpdateIdleStateNative::Context' has a wrong offset!");
static_assert(offsetof(GzDefaultCharacterAnimInstance_UpdateIdleStateNative, Node) == 0x000010, "Member 'GzDefaultCharacterAnimInstance_UpdateIdleStateNative::Node' has a wrong offset!");

// Function G01.GzDefaultCharacterAnimInstance.UpdateLeanDataNative
// 0x0008 (0x0008 - 0x0000)
struct GzDefaultCharacterAnimInstance_UpdateLeanDataNative final
{
public:
	const class UGzCharacterMovementComponent*    CharacterMovementCmpRef;                           // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzDefaultCharacterAnimInstance_UpdateLeanDataNative) == 0x000008, "Wrong alignment on GzDefaultCharacterAnimInstance_UpdateLeanDataNative");
static_assert(sizeof(GzDefaultCharacterAnimInstance_UpdateLeanDataNative) == 0x000008, "Wrong size on GzDefaultCharacterAnimInstance_UpdateLeanDataNative");
static_assert(offsetof(GzDefaultCharacterAnimInstance_UpdateLeanDataNative, CharacterMovementCmpRef) == 0x000000, "Member 'GzDefaultCharacterAnimInstance_UpdateLeanDataNative::CharacterMovementCmpRef' has a wrong offset!");

// Function G01.GzDefaultCharacterAnimInstance.UpdateLocationDataNative
// 0x0004 (0x0004 - 0x0000)
struct GzDefaultCharacterAnimInstance_UpdateLocationDataNative final
{
public:
	float                                         DeltaTime;                                         // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzDefaultCharacterAnimInstance_UpdateLocationDataNative) == 0x000004, "Wrong alignment on GzDefaultCharacterAnimInstance_UpdateLocationDataNative");
static_assert(sizeof(GzDefaultCharacterAnimInstance_UpdateLocationDataNative) == 0x000004, "Wrong size on GzDefaultCharacterAnimInstance_UpdateLocationDataNative");
static_assert(offsetof(GzDefaultCharacterAnimInstance_UpdateLocationDataNative, DeltaTime) == 0x000000, "Member 'GzDefaultCharacterAnimInstance_UpdateLocationDataNative::DeltaTime' has a wrong offset!");

// Function G01.GzDefaultCharacterAnimInstance.UpdateLocomotionStateMachineNative
// 0x0020 (0x0020 - 0x0000)
struct GzDefaultCharacterAnimInstance_UpdateLocomotionStateMachineNative final
{
public:
	struct FAnimUpdateContext                     Context;                                           // 0x0000(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	struct FAnimNodeReference                     Node;                                              // 0x0010(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzDefaultCharacterAnimInstance_UpdateLocomotionStateMachineNative) == 0x000008, "Wrong alignment on GzDefaultCharacterAnimInstance_UpdateLocomotionStateMachineNative");
static_assert(sizeof(GzDefaultCharacterAnimInstance_UpdateLocomotionStateMachineNative) == 0x000020, "Wrong size on GzDefaultCharacterAnimInstance_UpdateLocomotionStateMachineNative");
static_assert(offsetof(GzDefaultCharacterAnimInstance_UpdateLocomotionStateMachineNative, Context) == 0x000000, "Member 'GzDefaultCharacterAnimInstance_UpdateLocomotionStateMachineNative::Context' has a wrong offset!");
static_assert(offsetof(GzDefaultCharacterAnimInstance_UpdateLocomotionStateMachineNative, Node) == 0x000010, "Member 'GzDefaultCharacterAnimInstance_UpdateLocomotionStateMachineNative::Node' has a wrong offset!");

// Function G01.GzDefaultCharacterAnimInstance.UpdatePivotStateNative
// 0x0020 (0x0020 - 0x0000)
struct GzDefaultCharacterAnimInstance_UpdatePivotStateNative final
{
public:
	struct FAnimUpdateContext                     Context;                                           // 0x0000(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	struct FAnimNodeReference                     Node;                                              // 0x0010(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzDefaultCharacterAnimInstance_UpdatePivotStateNative) == 0x000008, "Wrong alignment on GzDefaultCharacterAnimInstance_UpdatePivotStateNative");
static_assert(sizeof(GzDefaultCharacterAnimInstance_UpdatePivotStateNative) == 0x000020, "Wrong size on GzDefaultCharacterAnimInstance_UpdatePivotStateNative");
static_assert(offsetof(GzDefaultCharacterAnimInstance_UpdatePivotStateNative, Context) == 0x000000, "Member 'GzDefaultCharacterAnimInstance_UpdatePivotStateNative::Context' has a wrong offset!");
static_assert(offsetof(GzDefaultCharacterAnimInstance_UpdatePivotStateNative, Node) == 0x000010, "Member 'GzDefaultCharacterAnimInstance_UpdatePivotStateNative::Node' has a wrong offset!");

// Function G01.GzDefaultCharacterAnimInstance.UpdateRootYawOffsetNative
// 0x0004 (0x0004 - 0x0000)
struct GzDefaultCharacterAnimInstance_UpdateRootYawOffsetNative final
{
public:
	float                                         DeltaTime;                                         // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzDefaultCharacterAnimInstance_UpdateRootYawOffsetNative) == 0x000004, "Wrong alignment on GzDefaultCharacterAnimInstance_UpdateRootYawOffsetNative");
static_assert(sizeof(GzDefaultCharacterAnimInstance_UpdateRootYawOffsetNative) == 0x000004, "Wrong size on GzDefaultCharacterAnimInstance_UpdateRootYawOffsetNative");
static_assert(offsetof(GzDefaultCharacterAnimInstance_UpdateRootYawOffsetNative, DeltaTime) == 0x000000, "Member 'GzDefaultCharacterAnimInstance_UpdateRootYawOffsetNative::DeltaTime' has a wrong offset!");

// Function G01.GzDefaultCharacterAnimInstance.UpdateStartStateNative
// 0x0020 (0x0020 - 0x0000)
struct GzDefaultCharacterAnimInstance_UpdateStartStateNative final
{
public:
	struct FAnimUpdateContext                     Context;                                           // 0x0000(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	struct FAnimNodeReference                     Node;                                              // 0x0010(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzDefaultCharacterAnimInstance_UpdateStartStateNative) == 0x000008, "Wrong alignment on GzDefaultCharacterAnimInstance_UpdateStartStateNative");
static_assert(sizeof(GzDefaultCharacterAnimInstance_UpdateStartStateNative) == 0x000020, "Wrong size on GzDefaultCharacterAnimInstance_UpdateStartStateNative");
static_assert(offsetof(GzDefaultCharacterAnimInstance_UpdateStartStateNative, Context) == 0x000000, "Member 'GzDefaultCharacterAnimInstance_UpdateStartStateNative::Context' has a wrong offset!");
static_assert(offsetof(GzDefaultCharacterAnimInstance_UpdateStartStateNative, Node) == 0x000010, "Member 'GzDefaultCharacterAnimInstance_UpdateStartStateNative::Node' has a wrong offset!");

// Function G01.GzDefaultCharacterAnimInstance.UpdateStopStateNative
// 0x0020 (0x0020 - 0x0000)
struct GzDefaultCharacterAnimInstance_UpdateStopStateNative final
{
public:
	struct FAnimUpdateContext                     Context;                                           // 0x0000(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	struct FAnimNodeReference                     Node;                                              // 0x0010(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzDefaultCharacterAnimInstance_UpdateStopStateNative) == 0x000008, "Wrong alignment on GzDefaultCharacterAnimInstance_UpdateStopStateNative");
static_assert(sizeof(GzDefaultCharacterAnimInstance_UpdateStopStateNative) == 0x000020, "Wrong size on GzDefaultCharacterAnimInstance_UpdateStopStateNative");
static_assert(offsetof(GzDefaultCharacterAnimInstance_UpdateStopStateNative, Context) == 0x000000, "Member 'GzDefaultCharacterAnimInstance_UpdateStopStateNative::Context' has a wrong offset!");
static_assert(offsetof(GzDefaultCharacterAnimInstance_UpdateStopStateNative, Node) == 0x000010, "Member 'GzDefaultCharacterAnimInstance_UpdateStopStateNative::Node' has a wrong offset!");

// Function G01.GzDefaultCharacterAnimInstance.GetActiveLimbType
// 0x0001 (0x0001 - 0x0000)
struct GzDefaultCharacterAnimInstance_GetActiveLimbType final
{
public:
	EGzLimbType                                   ReturnValue;                                       // 0x0000(0x0001)(ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzDefaultCharacterAnimInstance_GetActiveLimbType) == 0x000001, "Wrong alignment on GzDefaultCharacterAnimInstance_GetActiveLimbType");
static_assert(sizeof(GzDefaultCharacterAnimInstance_GetActiveLimbType) == 0x000001, "Wrong size on GzDefaultCharacterAnimInstance_GetActiveLimbType");
static_assert(offsetof(GzDefaultCharacterAnimInstance_GetActiveLimbType, ReturnValue) == 0x000000, "Member 'GzDefaultCharacterAnimInstance_GetActiveLimbType::ReturnValue' has a wrong offset!");

// Function G01.GzDefaultCharacterAnimInstance.GetAimPoint
// 0x0018 (0x0018 - 0x0000)
struct GzDefaultCharacterAnimInstance_GetAimPoint final
{
public:
	struct FVector                                ReturnValue;                                       // 0x0000(0x0018)(ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzDefaultCharacterAnimInstance_GetAimPoint) == 0x000008, "Wrong alignment on GzDefaultCharacterAnimInstance_GetAimPoint");
static_assert(sizeof(GzDefaultCharacterAnimInstance_GetAimPoint) == 0x000018, "Wrong size on GzDefaultCharacterAnimInstance_GetAimPoint");
static_assert(offsetof(GzDefaultCharacterAnimInstance_GetAimPoint, ReturnValue) == 0x000000, "Member 'GzDefaultCharacterAnimInstance_GetAimPoint::ReturnValue' has a wrong offset!");

// Function G01.GzDefaultCharacterAnimInstance.GetAnimStance
// 0x0001 (0x0001 - 0x0000)
struct GzDefaultCharacterAnimInstance_GetAnimStance final
{
public:
	EAnimStances                                  ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzDefaultCharacterAnimInstance_GetAnimStance) == 0x000001, "Wrong alignment on GzDefaultCharacterAnimInstance_GetAnimStance");
static_assert(sizeof(GzDefaultCharacterAnimInstance_GetAnimStance) == 0x000001, "Wrong size on GzDefaultCharacterAnimInstance_GetAnimStance");
static_assert(offsetof(GzDefaultCharacterAnimInstance_GetAnimStance, ReturnValue) == 0x000000, "Member 'GzDefaultCharacterAnimInstance_GetAnimStance::ReturnValue' has a wrong offset!");

// Function G01.GzDefaultCharacterAnimInstance.GetAnimStanceBlendValue
// 0x0004 (0x0004 - 0x0000)
struct GzDefaultCharacterAnimInstance_GetAnimStanceBlendValue final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzDefaultCharacterAnimInstance_GetAnimStanceBlendValue) == 0x000004, "Wrong alignment on GzDefaultCharacterAnimInstance_GetAnimStanceBlendValue");
static_assert(sizeof(GzDefaultCharacterAnimInstance_GetAnimStanceBlendValue) == 0x000004, "Wrong size on GzDefaultCharacterAnimInstance_GetAnimStanceBlendValue");
static_assert(offsetof(GzDefaultCharacterAnimInstance_GetAnimStanceBlendValue, ReturnValue) == 0x000000, "Member 'GzDefaultCharacterAnimInstance_GetAnimStanceBlendValue::ReturnValue' has a wrong offset!");

// Function G01.GzDefaultCharacterAnimInstance.GetCurrentLayerType
// 0x0001 (0x0001 - 0x0000)
struct GzDefaultCharacterAnimInstance_GetCurrentLayerType final
{
public:
	EGzLayerItemType                              ReturnValue;                                       // 0x0000(0x0001)(ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzDefaultCharacterAnimInstance_GetCurrentLayerType) == 0x000001, "Wrong alignment on GzDefaultCharacterAnimInstance_GetCurrentLayerType");
static_assert(sizeof(GzDefaultCharacterAnimInstance_GetCurrentLayerType) == 0x000001, "Wrong size on GzDefaultCharacterAnimInstance_GetCurrentLayerType");
static_assert(offsetof(GzDefaultCharacterAnimInstance_GetCurrentLayerType, ReturnValue) == 0x000000, "Member 'GzDefaultCharacterAnimInstance_GetCurrentLayerType::ReturnValue' has a wrong offset!");

// Function G01.GzDefaultCharacterAnimInstance.GetCurrentLogicalLayerType
// 0x0001 (0x0001 - 0x0000)
struct GzDefaultCharacterAnimInstance_GetCurrentLogicalLayerType final
{
public:
	EGzLayerItemType                              ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzDefaultCharacterAnimInstance_GetCurrentLogicalLayerType) == 0x000001, "Wrong alignment on GzDefaultCharacterAnimInstance_GetCurrentLogicalLayerType");
static_assert(sizeof(GzDefaultCharacterAnimInstance_GetCurrentLogicalLayerType) == 0x000001, "Wrong size on GzDefaultCharacterAnimInstance_GetCurrentLogicalLayerType");
static_assert(offsetof(GzDefaultCharacterAnimInstance_GetCurrentLogicalLayerType, ReturnValue) == 0x000000, "Member 'GzDefaultCharacterAnimInstance_GetCurrentLogicalLayerType::ReturnValue' has a wrong offset!");

// Function G01.GzDefaultCharacterAnimInstance.GetGroundFeetIKMaxDistance
// 0x0004 (0x0004 - 0x0000)
struct GzDefaultCharacterAnimInstance_GetGroundFeetIKMaxDistance final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzDefaultCharacterAnimInstance_GetGroundFeetIKMaxDistance) == 0x000004, "Wrong alignment on GzDefaultCharacterAnimInstance_GetGroundFeetIKMaxDistance");
static_assert(sizeof(GzDefaultCharacterAnimInstance_GetGroundFeetIKMaxDistance) == 0x000004, "Wrong size on GzDefaultCharacterAnimInstance_GetGroundFeetIKMaxDistance");
static_assert(offsetof(GzDefaultCharacterAnimInstance_GetGroundFeetIKMaxDistance, ReturnValue) == 0x000000, "Member 'GzDefaultCharacterAnimInstance_GetGroundFeetIKMaxDistance::ReturnValue' has a wrong offset!");

// Function G01.GzDefaultCharacterAnimInstance.GetGroundFootIKPositionLeftCurveName
// 0x0008 (0x0008 - 0x0000)
struct GzDefaultCharacterAnimInstance_GetGroundFootIKPositionLeftCurveName final
{
public:
	class FName                                   ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzDefaultCharacterAnimInstance_GetGroundFootIKPositionLeftCurveName) == 0x000004, "Wrong alignment on GzDefaultCharacterAnimInstance_GetGroundFootIKPositionLeftCurveName");
static_assert(sizeof(GzDefaultCharacterAnimInstance_GetGroundFootIKPositionLeftCurveName) == 0x000008, "Wrong size on GzDefaultCharacterAnimInstance_GetGroundFootIKPositionLeftCurveName");
static_assert(offsetof(GzDefaultCharacterAnimInstance_GetGroundFootIKPositionLeftCurveName, ReturnValue) == 0x000000, "Member 'GzDefaultCharacterAnimInstance_GetGroundFootIKPositionLeftCurveName::ReturnValue' has a wrong offset!");

// Function G01.GzDefaultCharacterAnimInstance.GetGroundFootIKPositionRightCurveName
// 0x0008 (0x0008 - 0x0000)
struct GzDefaultCharacterAnimInstance_GetGroundFootIKPositionRightCurveName final
{
public:
	class FName                                   ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzDefaultCharacterAnimInstance_GetGroundFootIKPositionRightCurveName) == 0x000004, "Wrong alignment on GzDefaultCharacterAnimInstance_GetGroundFootIKPositionRightCurveName");
static_assert(sizeof(GzDefaultCharacterAnimInstance_GetGroundFootIKPositionRightCurveName) == 0x000008, "Wrong size on GzDefaultCharacterAnimInstance_GetGroundFootIKPositionRightCurveName");
static_assert(offsetof(GzDefaultCharacterAnimInstance_GetGroundFootIKPositionRightCurveName, ReturnValue) == 0x000000, "Member 'GzDefaultCharacterAnimInstance_GetGroundFootIKPositionRightCurveName::ReturnValue' has a wrong offset!");

// Function G01.GzDefaultCharacterAnimInstance.GetGroundHandsIKMaxDistance
// 0x0004 (0x0004 - 0x0000)
struct GzDefaultCharacterAnimInstance_GetGroundHandsIKMaxDistance final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzDefaultCharacterAnimInstance_GetGroundHandsIKMaxDistance) == 0x000004, "Wrong alignment on GzDefaultCharacterAnimInstance_GetGroundHandsIKMaxDistance");
static_assert(sizeof(GzDefaultCharacterAnimInstance_GetGroundHandsIKMaxDistance) == 0x000004, "Wrong size on GzDefaultCharacterAnimInstance_GetGroundHandsIKMaxDistance");
static_assert(offsetof(GzDefaultCharacterAnimInstance_GetGroundHandsIKMaxDistance, ReturnValue) == 0x000000, "Member 'GzDefaultCharacterAnimInstance_GetGroundHandsIKMaxDistance::ReturnValue' has a wrong offset!");

// Function G01.GzDefaultCharacterAnimInstance.GetGroundHandsIKPositionLeftCurveName
// 0x0008 (0x0008 - 0x0000)
struct GzDefaultCharacterAnimInstance_GetGroundHandsIKPositionLeftCurveName final
{
public:
	class FName                                   ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzDefaultCharacterAnimInstance_GetGroundHandsIKPositionLeftCurveName) == 0x000004, "Wrong alignment on GzDefaultCharacterAnimInstance_GetGroundHandsIKPositionLeftCurveName");
static_assert(sizeof(GzDefaultCharacterAnimInstance_GetGroundHandsIKPositionLeftCurveName) == 0x000008, "Wrong size on GzDefaultCharacterAnimInstance_GetGroundHandsIKPositionLeftCurveName");
static_assert(offsetof(GzDefaultCharacterAnimInstance_GetGroundHandsIKPositionLeftCurveName, ReturnValue) == 0x000000, "Member 'GzDefaultCharacterAnimInstance_GetGroundHandsIKPositionLeftCurveName::ReturnValue' has a wrong offset!");

// Function G01.GzDefaultCharacterAnimInstance.GetGroundHandsIKPositionRightCurveName
// 0x0008 (0x0008 - 0x0000)
struct GzDefaultCharacterAnimInstance_GetGroundHandsIKPositionRightCurveName final
{
public:
	class FName                                   ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzDefaultCharacterAnimInstance_GetGroundHandsIKPositionRightCurveName) == 0x000004, "Wrong alignment on GzDefaultCharacterAnimInstance_GetGroundHandsIKPositionRightCurveName");
static_assert(sizeof(GzDefaultCharacterAnimInstance_GetGroundHandsIKPositionRightCurveName) == 0x000008, "Wrong size on GzDefaultCharacterAnimInstance_GetGroundHandsIKPositionRightCurveName");
static_assert(offsetof(GzDefaultCharacterAnimInstance_GetGroundHandsIKPositionRightCurveName, ReturnValue) == 0x000000, "Member 'GzDefaultCharacterAnimInstance_GetGroundHandsIKPositionRightCurveName::ReturnValue' has a wrong offset!");

// Function G01.GzDefaultCharacterAnimInstance.GetGroundHandsIKStartOffset
// 0x0004 (0x0004 - 0x0000)
struct GzDefaultCharacterAnimInstance_GetGroundHandsIKStartOffset final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzDefaultCharacterAnimInstance_GetGroundHandsIKStartOffset) == 0x000004, "Wrong alignment on GzDefaultCharacterAnimInstance_GetGroundHandsIKStartOffset");
static_assert(sizeof(GzDefaultCharacterAnimInstance_GetGroundHandsIKStartOffset) == 0x000004, "Wrong size on GzDefaultCharacterAnimInstance_GetGroundHandsIKStartOffset");
static_assert(offsetof(GzDefaultCharacterAnimInstance_GetGroundHandsIKStartOffset, ReturnValue) == 0x000000, "Member 'GzDefaultCharacterAnimInstance_GetGroundHandsIKStartOffset::ReturnValue' has a wrong offset!");

// Function G01.GzDefaultCharacterAnimInstance.GetGzCharacter
// 0x0008 (0x0008 - 0x0000)
struct GzDefaultCharacterAnimInstance_GetGzCharacter final
{
public:
	class AGzCharacter*                           ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzDefaultCharacterAnimInstance_GetGzCharacter) == 0x000008, "Wrong alignment on GzDefaultCharacterAnimInstance_GetGzCharacter");
static_assert(sizeof(GzDefaultCharacterAnimInstance_GetGzCharacter) == 0x000008, "Wrong size on GzDefaultCharacterAnimInstance_GetGzCharacter");
static_assert(offsetof(GzDefaultCharacterAnimInstance_GetGzCharacter, ReturnValue) == 0x000000, "Member 'GzDefaultCharacterAnimInstance_GetGzCharacter::ReturnValue' has a wrong offset!");

// Function G01.GzDefaultCharacterAnimInstance.GetJointTargetLocation
// 0x0018 (0x0018 - 0x0000)
struct GzDefaultCharacterAnimInstance_GetJointTargetLocation final
{
public:
	struct FVector                                ReturnValue;                                       // 0x0000(0x0018)(ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzDefaultCharacterAnimInstance_GetJointTargetLocation) == 0x000008, "Wrong alignment on GzDefaultCharacterAnimInstance_GetJointTargetLocation");
static_assert(sizeof(GzDefaultCharacterAnimInstance_GetJointTargetLocation) == 0x000018, "Wrong size on GzDefaultCharacterAnimInstance_GetJointTargetLocation");
static_assert(offsetof(GzDefaultCharacterAnimInstance_GetJointTargetLocation, ReturnValue) == 0x000000, "Member 'GzDefaultCharacterAnimInstance_GetJointTargetLocation::ReturnValue' has a wrong offset!");

// Function G01.GzDefaultCharacterAnimInstance.GetLeftHandIKBlendValue
// 0x0004 (0x0004 - 0x0000)
struct GzDefaultCharacterAnimInstance_GetLeftHandIKBlendValue final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzDefaultCharacterAnimInstance_GetLeftHandIKBlendValue) == 0x000004, "Wrong alignment on GzDefaultCharacterAnimInstance_GetLeftHandIKBlendValue");
static_assert(sizeof(GzDefaultCharacterAnimInstance_GetLeftHandIKBlendValue) == 0x000004, "Wrong size on GzDefaultCharacterAnimInstance_GetLeftHandIKBlendValue");
static_assert(offsetof(GzDefaultCharacterAnimInstance_GetLeftHandIKBlendValue, ReturnValue) == 0x000000, "Member 'GzDefaultCharacterAnimInstance_GetLeftHandIKBlendValue::ReturnValue' has a wrong offset!");

// Function G01.GzDefaultCharacterAnimInstance.GetLeftHandIKCurveName
// 0x0008 (0x0008 - 0x0000)
struct GzDefaultCharacterAnimInstance_GetLeftHandIKCurveName final
{
public:
	class FName                                   ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzDefaultCharacterAnimInstance_GetLeftHandIKCurveName) == 0x000004, "Wrong alignment on GzDefaultCharacterAnimInstance_GetLeftHandIKCurveName");
static_assert(sizeof(GzDefaultCharacterAnimInstance_GetLeftHandIKCurveName) == 0x000008, "Wrong size on GzDefaultCharacterAnimInstance_GetLeftHandIKCurveName");
static_assert(offsetof(GzDefaultCharacterAnimInstance_GetLeftHandIKCurveName, ReturnValue) == 0x000000, "Member 'GzDefaultCharacterAnimInstance_GetLeftHandIKCurveName::ReturnValue' has a wrong offset!");

// Function G01.GzDefaultCharacterAnimInstance.GetLeftHandIKLocation
// 0x0018 (0x0018 - 0x0000)
struct GzDefaultCharacterAnimInstance_GetLeftHandIKLocation final
{
public:
	struct FVector                                ReturnValue;                                       // 0x0000(0x0018)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzDefaultCharacterAnimInstance_GetLeftHandIKLocation) == 0x000008, "Wrong alignment on GzDefaultCharacterAnimInstance_GetLeftHandIKLocation");
static_assert(sizeof(GzDefaultCharacterAnimInstance_GetLeftHandIKLocation) == 0x000018, "Wrong size on GzDefaultCharacterAnimInstance_GetLeftHandIKLocation");
static_assert(offsetof(GzDefaultCharacterAnimInstance_GetLeftHandIKLocation, ReturnValue) == 0x000000, "Member 'GzDefaultCharacterAnimInstance_GetLeftHandIKLocation::ReturnValue' has a wrong offset!");

// Function G01.GzDefaultCharacterAnimInstance.GetLeftHandIKOffsetLocation
// 0x0018 (0x0018 - 0x0000)
struct GzDefaultCharacterAnimInstance_GetLeftHandIKOffsetLocation final
{
public:
	struct FVector                                ReturnValue;                                       // 0x0000(0x0018)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzDefaultCharacterAnimInstance_GetLeftHandIKOffsetLocation) == 0x000008, "Wrong alignment on GzDefaultCharacterAnimInstance_GetLeftHandIKOffsetLocation");
static_assert(sizeof(GzDefaultCharacterAnimInstance_GetLeftHandIKOffsetLocation) == 0x000018, "Wrong size on GzDefaultCharacterAnimInstance_GetLeftHandIKOffsetLocation");
static_assert(offsetof(GzDefaultCharacterAnimInstance_GetLeftHandIKOffsetLocation, ReturnValue) == 0x000000, "Member 'GzDefaultCharacterAnimInstance_GetLeftHandIKOffsetLocation::ReturnValue' has a wrong offset!");

// Function G01.GzDefaultCharacterAnimInstance.GetLeftHandIKOffsetRotation
// 0x0020 (0x0020 - 0x0000)
struct GzDefaultCharacterAnimInstance_GetLeftHandIKOffsetRotation final
{
public:
	struct FQuat                                  ReturnValue;                                       // 0x0000(0x0020)(Parm, OutParm, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzDefaultCharacterAnimInstance_GetLeftHandIKOffsetRotation) == 0x000010, "Wrong alignment on GzDefaultCharacterAnimInstance_GetLeftHandIKOffsetRotation");
static_assert(sizeof(GzDefaultCharacterAnimInstance_GetLeftHandIKOffsetRotation) == 0x000020, "Wrong size on GzDefaultCharacterAnimInstance_GetLeftHandIKOffsetRotation");
static_assert(offsetof(GzDefaultCharacterAnimInstance_GetLeftHandIKOffsetRotation, ReturnValue) == 0x000000, "Member 'GzDefaultCharacterAnimInstance_GetLeftHandIKOffsetRotation::ReturnValue' has a wrong offset!");

// Function G01.GzDefaultCharacterAnimInstance.GetLeftHandIKOffsetXName
// 0x0008 (0x0008 - 0x0000)
struct GzDefaultCharacterAnimInstance_GetLeftHandIKOffsetXName final
{
public:
	class FName                                   ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzDefaultCharacterAnimInstance_GetLeftHandIKOffsetXName) == 0x000004, "Wrong alignment on GzDefaultCharacterAnimInstance_GetLeftHandIKOffsetXName");
static_assert(sizeof(GzDefaultCharacterAnimInstance_GetLeftHandIKOffsetXName) == 0x000008, "Wrong size on GzDefaultCharacterAnimInstance_GetLeftHandIKOffsetXName");
static_assert(offsetof(GzDefaultCharacterAnimInstance_GetLeftHandIKOffsetXName, ReturnValue) == 0x000000, "Member 'GzDefaultCharacterAnimInstance_GetLeftHandIKOffsetXName::ReturnValue' has a wrong offset!");

// Function G01.GzDefaultCharacterAnimInstance.GetLeftHandIKOffsetXValue
// 0x0004 (0x0004 - 0x0000)
struct GzDefaultCharacterAnimInstance_GetLeftHandIKOffsetXValue final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzDefaultCharacterAnimInstance_GetLeftHandIKOffsetXValue) == 0x000004, "Wrong alignment on GzDefaultCharacterAnimInstance_GetLeftHandIKOffsetXValue");
static_assert(sizeof(GzDefaultCharacterAnimInstance_GetLeftHandIKOffsetXValue) == 0x000004, "Wrong size on GzDefaultCharacterAnimInstance_GetLeftHandIKOffsetXValue");
static_assert(offsetof(GzDefaultCharacterAnimInstance_GetLeftHandIKOffsetXValue, ReturnValue) == 0x000000, "Member 'GzDefaultCharacterAnimInstance_GetLeftHandIKOffsetXValue::ReturnValue' has a wrong offset!");

// Function G01.GzDefaultCharacterAnimInstance.GetLeftHandIKOffsetYName
// 0x0008 (0x0008 - 0x0000)
struct GzDefaultCharacterAnimInstance_GetLeftHandIKOffsetYName final
{
public:
	class FName                                   ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzDefaultCharacterAnimInstance_GetLeftHandIKOffsetYName) == 0x000004, "Wrong alignment on GzDefaultCharacterAnimInstance_GetLeftHandIKOffsetYName");
static_assert(sizeof(GzDefaultCharacterAnimInstance_GetLeftHandIKOffsetYName) == 0x000008, "Wrong size on GzDefaultCharacterAnimInstance_GetLeftHandIKOffsetYName");
static_assert(offsetof(GzDefaultCharacterAnimInstance_GetLeftHandIKOffsetYName, ReturnValue) == 0x000000, "Member 'GzDefaultCharacterAnimInstance_GetLeftHandIKOffsetYName::ReturnValue' has a wrong offset!");

// Function G01.GzDefaultCharacterAnimInstance.GetLeftHandIKOffsetYValue
// 0x0004 (0x0004 - 0x0000)
struct GzDefaultCharacterAnimInstance_GetLeftHandIKOffsetYValue final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzDefaultCharacterAnimInstance_GetLeftHandIKOffsetYValue) == 0x000004, "Wrong alignment on GzDefaultCharacterAnimInstance_GetLeftHandIKOffsetYValue");
static_assert(sizeof(GzDefaultCharacterAnimInstance_GetLeftHandIKOffsetYValue) == 0x000004, "Wrong size on GzDefaultCharacterAnimInstance_GetLeftHandIKOffsetYValue");
static_assert(offsetof(GzDefaultCharacterAnimInstance_GetLeftHandIKOffsetYValue, ReturnValue) == 0x000000, "Member 'GzDefaultCharacterAnimInstance_GetLeftHandIKOffsetYValue::ReturnValue' has a wrong offset!");

// Function G01.GzDefaultCharacterAnimInstance.GetLeftHandIKOffsetZName
// 0x0008 (0x0008 - 0x0000)
struct GzDefaultCharacterAnimInstance_GetLeftHandIKOffsetZName final
{
public:
	class FName                                   ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzDefaultCharacterAnimInstance_GetLeftHandIKOffsetZName) == 0x000004, "Wrong alignment on GzDefaultCharacterAnimInstance_GetLeftHandIKOffsetZName");
static_assert(sizeof(GzDefaultCharacterAnimInstance_GetLeftHandIKOffsetZName) == 0x000008, "Wrong size on GzDefaultCharacterAnimInstance_GetLeftHandIKOffsetZName");
static_assert(offsetof(GzDefaultCharacterAnimInstance_GetLeftHandIKOffsetZName, ReturnValue) == 0x000000, "Member 'GzDefaultCharacterAnimInstance_GetLeftHandIKOffsetZName::ReturnValue' has a wrong offset!");

// Function G01.GzDefaultCharacterAnimInstance.GetLeftHandIKOffsetZValue
// 0x0004 (0x0004 - 0x0000)
struct GzDefaultCharacterAnimInstance_GetLeftHandIKOffsetZValue final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzDefaultCharacterAnimInstance_GetLeftHandIKOffsetZValue) == 0x000004, "Wrong alignment on GzDefaultCharacterAnimInstance_GetLeftHandIKOffsetZValue");
static_assert(sizeof(GzDefaultCharacterAnimInstance_GetLeftHandIKOffsetZValue) == 0x000004, "Wrong size on GzDefaultCharacterAnimInstance_GetLeftHandIKOffsetZValue");
static_assert(offsetof(GzDefaultCharacterAnimInstance_GetLeftHandIKOffsetZValue, ReturnValue) == 0x000000, "Member 'GzDefaultCharacterAnimInstance_GetLeftHandIKOffsetZValue::ReturnValue' has a wrong offset!");

// Function G01.GzDefaultCharacterAnimInstance.GetLeftHandIKRotation
// 0x0018 (0x0018 - 0x0000)
struct GzDefaultCharacterAnimInstance_GetLeftHandIKRotation final
{
public:
	struct FRotator                               ReturnValue;                                       // 0x0000(0x0018)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzDefaultCharacterAnimInstance_GetLeftHandIKRotation) == 0x000008, "Wrong alignment on GzDefaultCharacterAnimInstance_GetLeftHandIKRotation");
static_assert(sizeof(GzDefaultCharacterAnimInstance_GetLeftHandIKRotation) == 0x000018, "Wrong size on GzDefaultCharacterAnimInstance_GetLeftHandIKRotation");
static_assert(offsetof(GzDefaultCharacterAnimInstance_GetLeftHandIKRotation, ReturnValue) == 0x000000, "Member 'GzDefaultCharacterAnimInstance_GetLeftHandIKRotation::ReturnValue' has a wrong offset!");

// Function G01.GzDefaultCharacterAnimInstance.GetOwnerMovementState
// 0x0001 (0x0001 - 0x0000)
struct GzDefaultCharacterAnimInstance_GetOwnerMovementState final
{
public:
	ELocomotionMovementState                      ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzDefaultCharacterAnimInstance_GetOwnerMovementState) == 0x000001, "Wrong alignment on GzDefaultCharacterAnimInstance_GetOwnerMovementState");
static_assert(sizeof(GzDefaultCharacterAnimInstance_GetOwnerMovementState) == 0x000001, "Wrong size on GzDefaultCharacterAnimInstance_GetOwnerMovementState");
static_assert(offsetof(GzDefaultCharacterAnimInstance_GetOwnerMovementState, ReturnValue) == 0x000000, "Member 'GzDefaultCharacterAnimInstance_GetOwnerMovementState::ReturnValue' has a wrong offset!");

// Function G01.GzDefaultCharacterAnimInstance.GetOwnerStance
// 0x0001 (0x0001 - 0x0000)
struct GzDefaultCharacterAnimInstance_GetOwnerStance final
{
public:
	ELocomotionStance                             ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzDefaultCharacterAnimInstance_GetOwnerStance) == 0x000001, "Wrong alignment on GzDefaultCharacterAnimInstance_GetOwnerStance");
static_assert(sizeof(GzDefaultCharacterAnimInstance_GetOwnerStance) == 0x000001, "Wrong size on GzDefaultCharacterAnimInstance_GetOwnerStance");
static_assert(offsetof(GzDefaultCharacterAnimInstance_GetOwnerStance, ReturnValue) == 0x000000, "Member 'GzDefaultCharacterAnimInstance_GetOwnerStance::ReturnValue' has a wrong offset!");

// Function G01.GzDefaultCharacterAnimInstance.GetWeaponUnderBarrelGripType
// 0x0001 (0x0001 - 0x0000)
struct GzDefaultCharacterAnimInstance_GetWeaponUnderBarrelGripType final
{
public:
	EGzWeaponSupportHoldType                      ReturnValue;                                       // 0x0000(0x0001)(ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzDefaultCharacterAnimInstance_GetWeaponUnderBarrelGripType) == 0x000001, "Wrong alignment on GzDefaultCharacterAnimInstance_GetWeaponUnderBarrelGripType");
static_assert(sizeof(GzDefaultCharacterAnimInstance_GetWeaponUnderBarrelGripType) == 0x000001, "Wrong size on GzDefaultCharacterAnimInstance_GetWeaponUnderBarrelGripType");
static_assert(offsetof(GzDefaultCharacterAnimInstance_GetWeaponUnderBarrelGripType, ReturnValue) == 0x000000, "Member 'GzDefaultCharacterAnimInstance_GetWeaponUnderBarrelGripType::ReturnValue' has a wrong offset!");

// Function G01.GzDefaultCharacterAnimInstance.IsMovingPerpendicularToInitialPivotNative
// 0x0001 (0x0001 - 0x0000)
struct GzDefaultCharacterAnimInstance_IsMovingPerpendicularToInitialPivotNative final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzDefaultCharacterAnimInstance_IsMovingPerpendicularToInitialPivotNative) == 0x000001, "Wrong alignment on GzDefaultCharacterAnimInstance_IsMovingPerpendicularToInitialPivotNative");
static_assert(sizeof(GzDefaultCharacterAnimInstance_IsMovingPerpendicularToInitialPivotNative) == 0x000001, "Wrong size on GzDefaultCharacterAnimInstance_IsMovingPerpendicularToInitialPivotNative");
static_assert(offsetof(GzDefaultCharacterAnimInstance_IsMovingPerpendicularToInitialPivotNative, ReturnValue) == 0x000000, "Member 'GzDefaultCharacterAnimInstance_IsMovingPerpendicularToInitialPivotNative::ReturnValue' has a wrong offset!");

// Function G01.GzDefilerTarget.CanScanOnAnyDistance
// 0x0001 (0x0001 - 0x0000)
struct GzDefilerTarget_CanScanOnAnyDistance final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzDefilerTarget_CanScanOnAnyDistance) == 0x000001, "Wrong alignment on GzDefilerTarget_CanScanOnAnyDistance");
static_assert(sizeof(GzDefilerTarget_CanScanOnAnyDistance) == 0x000001, "Wrong size on GzDefilerTarget_CanScanOnAnyDistance");
static_assert(offsetof(GzDefilerTarget_CanScanOnAnyDistance, ReturnValue) == 0x000000, "Member 'GzDefilerTarget_CanScanOnAnyDistance::ReturnValue' has a wrong offset!");

// Function G01.GzDefilerTarget.OnDefilerEffectApplied
// 0x0001 (0x0001 - 0x0000)
struct GzDefilerTarget_OnDefilerEffectApplied final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzDefilerTarget_OnDefilerEffectApplied) == 0x000001, "Wrong alignment on GzDefilerTarget_OnDefilerEffectApplied");
static_assert(sizeof(GzDefilerTarget_OnDefilerEffectApplied) == 0x000001, "Wrong size on GzDefilerTarget_OnDefilerEffectApplied");
static_assert(offsetof(GzDefilerTarget_OnDefilerEffectApplied, ReturnValue) == 0x000000, "Member 'GzDefilerTarget_OnDefilerEffectApplied::ReturnValue' has a wrong offset!");

// Function G01.GzDefilerTarget.OnDefilerEffectRemoved
// 0x0001 (0x0001 - 0x0000)
struct GzDefilerTarget_OnDefilerEffectRemoved final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzDefilerTarget_OnDefilerEffectRemoved) == 0x000001, "Wrong alignment on GzDefilerTarget_OnDefilerEffectRemoved");
static_assert(sizeof(GzDefilerTarget_OnDefilerEffectRemoved) == 0x000001, "Wrong size on GzDefilerTarget_OnDefilerEffectRemoved");
static_assert(offsetof(GzDefilerTarget_OnDefilerEffectRemoved, ReturnValue) == 0x000000, "Member 'GzDefilerTarget_OnDefilerEffectRemoved::ReturnValue' has a wrong offset!");

// Function G01.GzDefilerTarget.GetDefilerTargetType
// 0x0001 (0x0001 - 0x0000)
struct GzDefilerTarget_GetDefilerTargetType final
{
public:
	EGzDefilerTargetType                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzDefilerTarget_GetDefilerTargetType) == 0x000001, "Wrong alignment on GzDefilerTarget_GetDefilerTargetType");
static_assert(sizeof(GzDefilerTarget_GetDefilerTargetType) == 0x000001, "Wrong size on GzDefilerTarget_GetDefilerTargetType");
static_assert(offsetof(GzDefilerTarget_GetDefilerTargetType, ReturnValue) == 0x000000, "Member 'GzDefilerTarget_GetDefilerTargetType::ReturnValue' has a wrong offset!");

// Function G01.GzDeliveryDrone.GetCallerTeamID
// 0x0004 (0x0004 - 0x0000)
struct GzDeliveryDrone_GetCallerTeamID final
{
public:
	int32                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzDeliveryDrone_GetCallerTeamID) == 0x000004, "Wrong alignment on GzDeliveryDrone_GetCallerTeamID");
static_assert(sizeof(GzDeliveryDrone_GetCallerTeamID) == 0x000004, "Wrong size on GzDeliveryDrone_GetCallerTeamID");
static_assert(offsetof(GzDeliveryDrone_GetCallerTeamID, ReturnValue) == 0x000000, "Member 'GzDeliveryDrone_GetCallerTeamID::ReturnValue' has a wrong offset!");

// Function G01.GzDeliveryDrone.GetDeliveryLocation
// 0x0018 (0x0018 - 0x0000)
struct GzDeliveryDrone_GetDeliveryLocation final
{
public:
	struct FVector                                ReturnValue;                                       // 0x0000(0x0018)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzDeliveryDrone_GetDeliveryLocation) == 0x000008, "Wrong alignment on GzDeliveryDrone_GetDeliveryLocation");
static_assert(sizeof(GzDeliveryDrone_GetDeliveryLocation) == 0x000018, "Wrong size on GzDeliveryDrone_GetDeliveryLocation");
static_assert(offsetof(GzDeliveryDrone_GetDeliveryLocation, ReturnValue) == 0x000000, "Member 'GzDeliveryDrone_GetDeliveryLocation::ReturnValue' has a wrong offset!");

// Function G01.GzDeliveryPreviewMarker.UpdateDeliveryPreview
// 0x0002 (0x0002 - 0x0000)
struct GzDeliveryPreviewMarker_UpdateDeliveryPreview final
{
public:
	bool                                          bHasHit;                                           // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bValidHit;                                         // 0x0001(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzDeliveryPreviewMarker_UpdateDeliveryPreview) == 0x000001, "Wrong alignment on GzDeliveryPreviewMarker_UpdateDeliveryPreview");
static_assert(sizeof(GzDeliveryPreviewMarker_UpdateDeliveryPreview) == 0x000002, "Wrong size on GzDeliveryPreviewMarker_UpdateDeliveryPreview");
static_assert(offsetof(GzDeliveryPreviewMarker_UpdateDeliveryPreview, bHasHit) == 0x000000, "Member 'GzDeliveryPreviewMarker_UpdateDeliveryPreview::bHasHit' has a wrong offset!");
static_assert(offsetof(GzDeliveryPreviewMarker_UpdateDeliveryPreview, bValidHit) == 0x000001, "Member 'GzDeliveryPreviewMarker_UpdateDeliveryPreview::bValidHit' has a wrong offset!");

// Function G01.GzKatanaComponent.ShouldDashVertically
// 0x0001 (0x0001 - 0x0000)
struct GzKatanaComponent_ShouldDashVertically final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzKatanaComponent_ShouldDashVertically) == 0x000001, "Wrong alignment on GzKatanaComponent_ShouldDashVertically");
static_assert(sizeof(GzKatanaComponent_ShouldDashVertically) == 0x000001, "Wrong size on GzKatanaComponent_ShouldDashVertically");
static_assert(offsetof(GzKatanaComponent_ShouldDashVertically, ReturnValue) == 0x000000, "Member 'GzKatanaComponent_ShouldDashVertically::ReturnValue' has a wrong offset!");

// Function G01.GzSettingEditConditionBP.GetDisableType
// 0x0001 (0x0001 - 0x0000)
struct GzSettingEditConditionBP_GetDisableType final
{
public:
	EGzDisableSettingType                         ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzSettingEditConditionBP_GetDisableType) == 0x000001, "Wrong alignment on GzSettingEditConditionBP_GetDisableType");
static_assert(sizeof(GzSettingEditConditionBP_GetDisableType) == 0x000001, "Wrong size on GzSettingEditConditionBP_GetDisableType");
static_assert(offsetof(GzSettingEditConditionBP_GetDisableType, ReturnValue) == 0x000000, "Member 'GzSettingEditConditionBP_GetDisableType::ReturnValue' has a wrong offset!");

// Function G01.GzPhysicsSimulationSyncComponent.OnPhysicsStartSleeping
// 0x0010 (0x0010 - 0x0000)
struct GzPhysicsSimulationSyncComponent_OnPhysicsStartSleeping final
{
public:
	class UPrimitiveComponent*                    SleepingComponent;                                 // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   BoneName;                                          // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzPhysicsSimulationSyncComponent_OnPhysicsStartSleeping) == 0x000008, "Wrong alignment on GzPhysicsSimulationSyncComponent_OnPhysicsStartSleeping");
static_assert(sizeof(GzPhysicsSimulationSyncComponent_OnPhysicsStartSleeping) == 0x000010, "Wrong size on GzPhysicsSimulationSyncComponent_OnPhysicsStartSleeping");
static_assert(offsetof(GzPhysicsSimulationSyncComponent_OnPhysicsStartSleeping, SleepingComponent) == 0x000000, "Member 'GzPhysicsSimulationSyncComponent_OnPhysicsStartSleeping::SleepingComponent' has a wrong offset!");
static_assert(offsetof(GzPhysicsSimulationSyncComponent_OnPhysicsStartSleeping, BoneName) == 0x000008, "Member 'GzPhysicsSimulationSyncComponent_OnPhysicsStartSleeping::BoneName' has a wrong offset!");

// Function G01.GzPhysicsSimulationSyncComponent.OnRep_PhysicsState
// 0x0008 (0x0008 - 0x0000)
struct GzPhysicsSimulationSyncComponent_OnRep_PhysicsState final
{
public:
	struct FGzPhysicsSimulationState              PrevState;                                         // 0x0000(0x0008)(ConstParm, Parm, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzPhysicsSimulationSyncComponent_OnRep_PhysicsState) == 0x000004, "Wrong alignment on GzPhysicsSimulationSyncComponent_OnRep_PhysicsState");
static_assert(sizeof(GzPhysicsSimulationSyncComponent_OnRep_PhysicsState) == 0x000008, "Wrong size on GzPhysicsSimulationSyncComponent_OnRep_PhysicsState");
static_assert(offsetof(GzPhysicsSimulationSyncComponent_OnRep_PhysicsState, PrevState) == 0x000000, "Member 'GzPhysicsSimulationSyncComponent_OnRep_PhysicsState::PrevState' has a wrong offset!");

// Function G01.GzPhysicsSimulationSyncComponent.SetPoseReplicationFrequency
// 0x0004 (0x0004 - 0x0000)
struct GzPhysicsSimulationSyncComponent_SetPoseReplicationFrequency final
{
public:
	float                                         ReplicationsPerSecond;                             // 0x0000(0x0004)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzPhysicsSimulationSyncComponent_SetPoseReplicationFrequency) == 0x000004, "Wrong alignment on GzPhysicsSimulationSyncComponent_SetPoseReplicationFrequency");
static_assert(sizeof(GzPhysicsSimulationSyncComponent_SetPoseReplicationFrequency) == 0x000004, "Wrong size on GzPhysicsSimulationSyncComponent_SetPoseReplicationFrequency");
static_assert(offsetof(GzPhysicsSimulationSyncComponent_SetPoseReplicationFrequency, ReplicationsPerSecond) == 0x000000, "Member 'GzPhysicsSimulationSyncComponent_SetPoseReplicationFrequency::ReplicationsPerSecond' has a wrong offset!");

// Function G01.GzPhysicsSimulationSyncComponent.SetUp
// 0x0008 (0x0008 - 0x0000)
struct GzPhysicsSimulationSyncComponent_SetUp final
{
public:
	class UMeshComponent*                         InMeshComponent;                                   // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzPhysicsSimulationSyncComponent_SetUp) == 0x000008, "Wrong alignment on GzPhysicsSimulationSyncComponent_SetUp");
static_assert(sizeof(GzPhysicsSimulationSyncComponent_SetUp) == 0x000008, "Wrong size on GzPhysicsSimulationSyncComponent_SetUp");
static_assert(offsetof(GzPhysicsSimulationSyncComponent_SetUp, InMeshComponent) == 0x000000, "Member 'GzPhysicsSimulationSyncComponent_SetUp::InMeshComponent' has a wrong offset!");

// Function G01.GzPhysicsSimulationSyncComponent.TryStartSimulating
// 0x0028 (0x0028 - 0x0000)
struct GzPhysicsSimulationSyncComponent_TryStartSimulating final
{
public:
	struct FGzImpulseInfo                         InImpulseInfo;                                     // 0x0000(0x0028)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzPhysicsSimulationSyncComponent_TryStartSimulating) == 0x000008, "Wrong alignment on GzPhysicsSimulationSyncComponent_TryStartSimulating");
static_assert(sizeof(GzPhysicsSimulationSyncComponent_TryStartSimulating) == 0x000028, "Wrong size on GzPhysicsSimulationSyncComponent_TryStartSimulating");
static_assert(offsetof(GzPhysicsSimulationSyncComponent_TryStartSimulating, InImpulseInfo) == 0x000000, "Member 'GzPhysicsSimulationSyncComponent_TryStartSimulating::InImpulseInfo' has a wrong offset!");

// Function G01.GzPhysicsSimulationSyncComponent.GetPhysicsSimulationStateType
// 0x0001 (0x0001 - 0x0000)
struct GzPhysicsSimulationSyncComponent_GetPhysicsSimulationStateType final
{
public:
	EGzPhysicsSimulationStateType                 ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzPhysicsSimulationSyncComponent_GetPhysicsSimulationStateType) == 0x000001, "Wrong alignment on GzPhysicsSimulationSyncComponent_GetPhysicsSimulationStateType");
static_assert(sizeof(GzPhysicsSimulationSyncComponent_GetPhysicsSimulationStateType) == 0x000001, "Wrong size on GzPhysicsSimulationSyncComponent_GetPhysicsSimulationStateType");
static_assert(offsetof(GzPhysicsSimulationSyncComponent_GetPhysicsSimulationStateType, ReturnValue) == 0x000000, "Member 'GzPhysicsSimulationSyncComponent_GetPhysicsSimulationStateType::ReturnValue' has a wrong offset!");

// Function G01.GzDeploymentPathSetup.GetTransportOffset
// 0x0020 (0x0020 - 0x0000)
struct GzDeploymentPathSetup_GetTransportOffset final
{
public:
	int32                                         TransportIndex;                                    // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         NumOfTransport;                                    // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                ReturnValue;                                       // 0x0008(0x0018)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzDeploymentPathSetup_GetTransportOffset) == 0x000008, "Wrong alignment on GzDeploymentPathSetup_GetTransportOffset");
static_assert(sizeof(GzDeploymentPathSetup_GetTransportOffset) == 0x000020, "Wrong size on GzDeploymentPathSetup_GetTransportOffset");
static_assert(offsetof(GzDeploymentPathSetup_GetTransportOffset, TransportIndex) == 0x000000, "Member 'GzDeploymentPathSetup_GetTransportOffset::TransportIndex' has a wrong offset!");
static_assert(offsetof(GzDeploymentPathSetup_GetTransportOffset, NumOfTransport) == 0x000004, "Member 'GzDeploymentPathSetup_GetTransportOffset::NumOfTransport' has a wrong offset!");
static_assert(offsetof(GzDeploymentPathSetup_GetTransportOffset, ReturnValue) == 0x000008, "Member 'GzDeploymentPathSetup_GetTransportOffset::ReturnValue' has a wrong offset!");

// Function G01.GzDeploymentPathSetup.GetZoneTag
// 0x0008 (0x0008 - 0x0000)
struct GzDeploymentPathSetup_GetZoneTag final
{
public:
	struct FGameplayTag                           ReturnValue;                                       // 0x0000(0x0008)(ConstParm, Parm, OutParm, ReturnParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzDeploymentPathSetup_GetZoneTag) == 0x000004, "Wrong alignment on GzDeploymentPathSetup_GetZoneTag");
static_assert(sizeof(GzDeploymentPathSetup_GetZoneTag) == 0x000008, "Wrong size on GzDeploymentPathSetup_GetZoneTag");
static_assert(offsetof(GzDeploymentPathSetup_GetZoneTag, ReturnValue) == 0x000000, "Member 'GzDeploymentPathSetup_GetZoneTag::ReturnValue' has a wrong offset!");

// Function G01.GzDeploymentPawn.ReceiveDeploymentAllowed
// 0x0001 (0x0001 - 0x0000)
struct GzDeploymentPawn_ReceiveDeploymentAllowed final
{
public:
	bool                                          bCanPawnDeploy;                                    // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzDeploymentPawn_ReceiveDeploymentAllowed) == 0x000001, "Wrong alignment on GzDeploymentPawn_ReceiveDeploymentAllowed");
static_assert(sizeof(GzDeploymentPawn_ReceiveDeploymentAllowed) == 0x000001, "Wrong size on GzDeploymentPawn_ReceiveDeploymentAllowed");
static_assert(offsetof(GzDeploymentPawn_ReceiveDeploymentAllowed, bCanPawnDeploy) == 0x000000, "Member 'GzDeploymentPawn_ReceiveDeploymentAllowed::bCanPawnDeploy' has a wrong offset!");

// Function G01.GzDeploymentPawn.ServerDeploy
// 0x0004 (0x0004 - 0x0000)
struct GzDeploymentPawn_ServerDeploy final
{
public:
	float                                         ViewRotationYaw;                                   // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzDeploymentPawn_ServerDeploy) == 0x000004, "Wrong alignment on GzDeploymentPawn_ServerDeploy");
static_assert(sizeof(GzDeploymentPawn_ServerDeploy) == 0x000004, "Wrong size on GzDeploymentPawn_ServerDeploy");
static_assert(offsetof(GzDeploymentPawn_ServerDeploy, ViewRotationYaw) == 0x000000, "Member 'GzDeploymentPawn_ServerDeploy::ViewRotationYaw' has a wrong offset!");

// Function G01.GzDeploymentPawn.CanDeploy
// 0x0001 (0x0001 - 0x0000)
struct GzDeploymentPawn_CanDeploy final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzDeploymentPawn_CanDeploy) == 0x000001, "Wrong alignment on GzDeploymentPawn_CanDeploy");
static_assert(sizeof(GzDeploymentPawn_CanDeploy) == 0x000001, "Wrong size on GzDeploymentPawn_CanDeploy");
static_assert(offsetof(GzDeploymentPawn_CanDeploy, ReturnValue) == 0x000000, "Member 'GzDeploymentPawn_CanDeploy::ReturnValue' has a wrong offset!");

// Function G01.GzDeploymentPawn.GetDeploymentTransport
// 0x0008 (0x0008 - 0x0000)
struct GzDeploymentPawn_GetDeploymentTransport final
{
public:
	class AGzDeploymentTransport*                 ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzDeploymentPawn_GetDeploymentTransport) == 0x000008, "Wrong alignment on GzDeploymentPawn_GetDeploymentTransport");
static_assert(sizeof(GzDeploymentPawn_GetDeploymentTransport) == 0x000008, "Wrong size on GzDeploymentPawn_GetDeploymentTransport");
static_assert(offsetof(GzDeploymentPawn_GetDeploymentTransport, ReturnValue) == 0x000000, "Member 'GzDeploymentPawn_GetDeploymentTransport::ReturnValue' has a wrong offset!");

// Function G01.GzDeploymentTransport.AddDeploymentPawn
// 0x0008 (0x0008 - 0x0000)
struct GzDeploymentTransport_AddDeploymentPawn final
{
public:
	class AGzDeploymentPawn*                      DeploymentPawn;                                    // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzDeploymentTransport_AddDeploymentPawn) == 0x000008, "Wrong alignment on GzDeploymentTransport_AddDeploymentPawn");
static_assert(sizeof(GzDeploymentTransport_AddDeploymentPawn) == 0x000008, "Wrong size on GzDeploymentTransport_AddDeploymentPawn");
static_assert(offsetof(GzDeploymentTransport_AddDeploymentPawn, DeploymentPawn) == 0x000000, "Member 'GzDeploymentTransport_AddDeploymentPawn::DeploymentPawn' has a wrong offset!");

// Function G01.GzDeploymentTransport.GetDeploymentAvailableTime
// 0x0004 (0x0004 - 0x0000)
struct GzDeploymentTransport_GetDeploymentAvailableTime final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzDeploymentTransport_GetDeploymentAvailableTime) == 0x000004, "Wrong alignment on GzDeploymentTransport_GetDeploymentAvailableTime");
static_assert(sizeof(GzDeploymentTransport_GetDeploymentAvailableTime) == 0x000004, "Wrong size on GzDeploymentTransport_GetDeploymentAvailableTime");
static_assert(offsetof(GzDeploymentTransport_GetDeploymentAvailableTime, ReturnValue) == 0x000000, "Member 'GzDeploymentTransport_GetDeploymentAvailableTime::ReturnValue' has a wrong offset!");

// Function G01.GzDeploymentTransport.SetDeploymentEnabled
// 0x0001 (0x0001 - 0x0000)
struct GzDeploymentTransport_SetDeploymentEnabled final
{
public:
	bool                                          bEnable;                                           // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzDeploymentTransport_SetDeploymentEnabled) == 0x000001, "Wrong alignment on GzDeploymentTransport_SetDeploymentEnabled");
static_assert(sizeof(GzDeploymentTransport_SetDeploymentEnabled) == 0x000001, "Wrong size on GzDeploymentTransport_SetDeploymentEnabled");
static_assert(offsetof(GzDeploymentTransport_SetDeploymentEnabled, bEnable) == 0x000000, "Member 'GzDeploymentTransport_SetDeploymentEnabled::bEnable' has a wrong offset!");

// Function G01.GzImpulseAffectedInterface.AddDampedImpulse
// 0x0018 (0x0018 - 0x0000)
struct GzImpulseAffectedInterface_AddDampedImpulse final
{
public:
	struct FVector                                Impulse;                                           // 0x0000(0x0018)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzImpulseAffectedInterface_AddDampedImpulse) == 0x000008, "Wrong alignment on GzImpulseAffectedInterface_AddDampedImpulse");
static_assert(sizeof(GzImpulseAffectedInterface_AddDampedImpulse) == 0x000018, "Wrong size on GzImpulseAffectedInterface_AddDampedImpulse");
static_assert(offsetof(GzImpulseAffectedInterface_AddDampedImpulse, Impulse) == 0x000000, "Member 'GzImpulseAffectedInterface_AddDampedImpulse::Impulse' has a wrong offset!");

// Function G01.GzFloatingStatusBarWidget.SetHealthPercentage
// 0x0004 (0x0004 - 0x0000)
struct GzFloatingStatusBarWidget_SetHealthPercentage final
{
public:
	float                                         HealthPercentage;                                  // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzFloatingStatusBarWidget_SetHealthPercentage) == 0x000004, "Wrong alignment on GzFloatingStatusBarWidget_SetHealthPercentage");
static_assert(sizeof(GzFloatingStatusBarWidget_SetHealthPercentage) == 0x000004, "Wrong size on GzFloatingStatusBarWidget_SetHealthPercentage");
static_assert(offsetof(GzFloatingStatusBarWidget_SetHealthPercentage, HealthPercentage) == 0x000000, "Member 'GzFloatingStatusBarWidget_SetHealthPercentage::HealthPercentage' has a wrong offset!");

// Function G01.GzFloatingStatusBarWidget.SetName
// 0x0010 (0x0010 - 0x0000)
struct GzFloatingStatusBarWidget_SetName final
{
public:
	class FText                                   NewName;                                           // 0x0000(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzFloatingStatusBarWidget_SetName) == 0x000008, "Wrong alignment on GzFloatingStatusBarWidget_SetName");
static_assert(sizeof(GzFloatingStatusBarWidget_SetName) == 0x000010, "Wrong size on GzFloatingStatusBarWidget_SetName");
static_assert(offsetof(GzFloatingStatusBarWidget_SetName, NewName) == 0x000000, "Member 'GzFloatingStatusBarWidget_SetName::NewName' has a wrong offset!");

// Function G01.GzFloatingStatusBarWidget.SetOwnerActor
// 0x0008 (0x0008 - 0x0000)
struct GzFloatingStatusBarWidget_SetOwnerActor final
{
public:
	class AActor*                                 Actor;                                             // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzFloatingStatusBarWidget_SetOwnerActor) == 0x000008, "Wrong alignment on GzFloatingStatusBarWidget_SetOwnerActor");
static_assert(sizeof(GzFloatingStatusBarWidget_SetOwnerActor) == 0x000008, "Wrong size on GzFloatingStatusBarWidget_SetOwnerActor");
static_assert(offsetof(GzFloatingStatusBarWidget_SetOwnerActor, Actor) == 0x000000, "Member 'GzFloatingStatusBarWidget_SetOwnerActor::Actor' has a wrong offset!");

// Function G01.GzFloatingStatusBarWidget.ShouldShow
// 0x0001 (0x0001 - 0x0000)
struct GzFloatingStatusBarWidget_ShouldShow final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzFloatingStatusBarWidget_ShouldShow) == 0x000001, "Wrong alignment on GzFloatingStatusBarWidget_ShouldShow");
static_assert(sizeof(GzFloatingStatusBarWidget_ShouldShow) == 0x000001, "Wrong size on GzFloatingStatusBarWidget_ShouldShow");
static_assert(offsetof(GzFloatingStatusBarWidget_ShouldShow, ReturnValue) == 0x000000, "Member 'GzFloatingStatusBarWidget_ShouldShow::ReturnValue' has a wrong offset!");

// Function G01.GzPhosphorousDartProjectile.BP_OnHit
// 0x00F8 (0x00F8 - 0x0000)
struct GzPhosphorousDartProjectile_BP_OnHit final
{
public:
	struct FHitResult                             Hit;                                               // 0x0000(0x00F8)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzPhosphorousDartProjectile_BP_OnHit) == 0x000008, "Wrong alignment on GzPhosphorousDartProjectile_BP_OnHit");
static_assert(sizeof(GzPhosphorousDartProjectile_BP_OnHit) == 0x0000F8, "Wrong size on GzPhosphorousDartProjectile_BP_OnHit");
static_assert(offsetof(GzPhosphorousDartProjectile_BP_OnHit, Hit) == 0x000000, "Member 'GzPhosphorousDartProjectile_BP_OnHit::Hit' has a wrong offset!");

// Function G01.GzPhosphorousDartProjectile.OnSphereOverlapBegin
// 0x0118 (0x0118 - 0x0000)
struct GzPhosphorousDartProjectile_OnSphereOverlapBegin final
{
public:
	class UPrimitiveComponent*                    OverlappedComponent;                               // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 OtherActor;                                        // 0x0008(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UPrimitiveComponent*                    OtherComp;                                         // 0x0010(0x0008)(Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         OtherBodyIndex;                                    // 0x0018(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bFromSweep;                                        // 0x001C(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_31C4[0x3];                                     // 0x001D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FHitResult                             SweepResult;                                       // 0x0020(0x00F8)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzPhosphorousDartProjectile_OnSphereOverlapBegin) == 0x000008, "Wrong alignment on GzPhosphorousDartProjectile_OnSphereOverlapBegin");
static_assert(sizeof(GzPhosphorousDartProjectile_OnSphereOverlapBegin) == 0x000118, "Wrong size on GzPhosphorousDartProjectile_OnSphereOverlapBegin");
static_assert(offsetof(GzPhosphorousDartProjectile_OnSphereOverlapBegin, OverlappedComponent) == 0x000000, "Member 'GzPhosphorousDartProjectile_OnSphereOverlapBegin::OverlappedComponent' has a wrong offset!");
static_assert(offsetof(GzPhosphorousDartProjectile_OnSphereOverlapBegin, OtherActor) == 0x000008, "Member 'GzPhosphorousDartProjectile_OnSphereOverlapBegin::OtherActor' has a wrong offset!");
static_assert(offsetof(GzPhosphorousDartProjectile_OnSphereOverlapBegin, OtherComp) == 0x000010, "Member 'GzPhosphorousDartProjectile_OnSphereOverlapBegin::OtherComp' has a wrong offset!");
static_assert(offsetof(GzPhosphorousDartProjectile_OnSphereOverlapBegin, OtherBodyIndex) == 0x000018, "Member 'GzPhosphorousDartProjectile_OnSphereOverlapBegin::OtherBodyIndex' has a wrong offset!");
static_assert(offsetof(GzPhosphorousDartProjectile_OnSphereOverlapBegin, bFromSweep) == 0x00001C, "Member 'GzPhosphorousDartProjectile_OnSphereOverlapBegin::bFromSweep' has a wrong offset!");
static_assert(offsetof(GzPhosphorousDartProjectile_OnSphereOverlapBegin, SweepResult) == 0x000020, "Member 'GzPhosphorousDartProjectile_OnSphereOverlapBegin::SweepResult' has a wrong offset!");

// Function G01.GzPhosphorousDartProjectile.OnSphereOverlapEnd
// 0x0020 (0x0020 - 0x0000)
struct GzPhosphorousDartProjectile_OnSphereOverlapEnd final
{
public:
	class UPrimitiveComponent*                    OverlappedComponent;                               // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 OtherActor;                                        // 0x0008(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UPrimitiveComponent*                    OtherComp;                                         // 0x0010(0x0008)(Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         OtherBodyIndex;                                    // 0x0018(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_31C5[0x4];                                     // 0x001C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GzPhosphorousDartProjectile_OnSphereOverlapEnd) == 0x000008, "Wrong alignment on GzPhosphorousDartProjectile_OnSphereOverlapEnd");
static_assert(sizeof(GzPhosphorousDartProjectile_OnSphereOverlapEnd) == 0x000020, "Wrong size on GzPhosphorousDartProjectile_OnSphereOverlapEnd");
static_assert(offsetof(GzPhosphorousDartProjectile_OnSphereOverlapEnd, OverlappedComponent) == 0x000000, "Member 'GzPhosphorousDartProjectile_OnSphereOverlapEnd::OverlappedComponent' has a wrong offset!");
static_assert(offsetof(GzPhosphorousDartProjectile_OnSphereOverlapEnd, OtherActor) == 0x000008, "Member 'GzPhosphorousDartProjectile_OnSphereOverlapEnd::OtherActor' has a wrong offset!");
static_assert(offsetof(GzPhosphorousDartProjectile_OnSphereOverlapEnd, OtherComp) == 0x000010, "Member 'GzPhosphorousDartProjectile_OnSphereOverlapEnd::OtherComp' has a wrong offset!");
static_assert(offsetof(GzPhosphorousDartProjectile_OnSphereOverlapEnd, OtherBodyIndex) == 0x000018, "Member 'GzPhosphorousDartProjectile_OnSphereOverlapEnd::OtherBodyIndex' has a wrong offset!");

// Function G01.GzDestructibleActor.OnHealthChanged
// 0x0004 (0x0004 - 0x0000)
struct GzDestructibleActor_OnHealthChanged final
{
public:
	float                                         Health;                                            // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzDestructibleActor_OnHealthChanged) == 0x000004, "Wrong alignment on GzDestructibleActor_OnHealthChanged");
static_assert(sizeof(GzDestructibleActor_OnHealthChanged) == 0x000004, "Wrong size on GzDestructibleActor_OnHealthChanged");
static_assert(offsetof(GzDestructibleActor_OnHealthChanged, Health) == 0x000000, "Member 'GzDestructibleActor_OnHealthChanged::Health' has a wrong offset!");

// Function G01.GzDestructibleActor.IsDestructed
// 0x0001 (0x0001 - 0x0000)
struct GzDestructibleActor_IsDestructed final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzDestructibleActor_IsDestructed) == 0x000001, "Wrong alignment on GzDestructibleActor_IsDestructed");
static_assert(sizeof(GzDestructibleActor_IsDestructed) == 0x000001, "Wrong size on GzDestructibleActor_IsDestructed");
static_assert(offsetof(GzDestructibleActor_IsDestructed, ReturnValue) == 0x000000, "Member 'GzDestructibleActor_IsDestructed::ReturnValue' has a wrong offset!");

// Function G01.GzDestructibleBase.ReceiveDestructibleDestroyed
// 0x0018 (0x0018 - 0x0000)
struct GzDestructibleBase_ReceiveDestructibleDestroyed final
{
public:
	struct FVector                                DestructionImpulse;                                // 0x0000(0x0018)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzDestructibleBase_ReceiveDestructibleDestroyed) == 0x000008, "Wrong alignment on GzDestructibleBase_ReceiveDestructibleDestroyed");
static_assert(sizeof(GzDestructibleBase_ReceiveDestructibleDestroyed) == 0x000018, "Wrong size on GzDestructibleBase_ReceiveDestructibleDestroyed");
static_assert(offsetof(GzDestructibleBase_ReceiveDestructibleDestroyed, DestructionImpulse) == 0x000000, "Member 'GzDestructibleBase_ReceiveDestructibleDestroyed::DestructionImpulse' has a wrong offset!");

// Function G01.GzDestructibleBase.ReceiveDestructibleHit
// 0x0018 (0x0018 - 0x0000)
struct GzDestructibleBase_ReceiveDestructibleHit final
{
public:
	struct FVector                                HitImpulse;                                        // 0x0000(0x0018)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzDestructibleBase_ReceiveDestructibleHit) == 0x000008, "Wrong alignment on GzDestructibleBase_ReceiveDestructibleHit");
static_assert(sizeof(GzDestructibleBase_ReceiveDestructibleHit) == 0x000018, "Wrong size on GzDestructibleBase_ReceiveDestructibleHit");
static_assert(offsetof(GzDestructibleBase_ReceiveDestructibleHit, HitImpulse) == 0x000000, "Member 'GzDestructibleBase_ReceiveDestructibleHit::HitImpulse' has a wrong offset!");

// Function G01.GzDestructibleBase.GetDestroyHitMask
// 0x0001 (0x0001 - 0x0000)
struct GzDestructibleBase_GetDestroyHitMask final
{
public:
	EGzDestructibleHitType                        ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzDestructibleBase_GetDestroyHitMask) == 0x000001, "Wrong alignment on GzDestructibleBase_GetDestroyHitMask");
static_assert(sizeof(GzDestructibleBase_GetDestroyHitMask) == 0x000001, "Wrong size on GzDestructibleBase_GetDestroyHitMask");
static_assert(offsetof(GzDestructibleBase_GetDestroyHitMask, ReturnValue) == 0x000000, "Member 'GzDestructibleBase_GetDestroyHitMask::ReturnValue' has a wrong offset!");

// Function G01.GzDestructibleBase.GetHitMask
// 0x0001 (0x0001 - 0x0000)
struct GzDestructibleBase_GetHitMask final
{
public:
	EGzDestructibleHitType                        ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzDestructibleBase_GetHitMask) == 0x000001, "Wrong alignment on GzDestructibleBase_GetHitMask");
static_assert(sizeof(GzDestructibleBase_GetHitMask) == 0x000001, "Wrong size on GzDestructibleBase_GetHitMask");
static_assert(offsetof(GzDestructibleBase_GetHitMask, ReturnValue) == 0x000000, "Member 'GzDestructibleBase_GetHitMask::ReturnValue' has a wrong offset!");

// Function G01.GzInvStatics.CanAddItem
// 0x0020 (0x0020 - 0x0000)
struct GzInvStatics_CanAddItem final
{
public:
	const class UGzInvComponent*                  Inventory;                                         // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGzInvItem                             Item;                                              // 0x0008(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	bool                                          bAllowSwap;                                        // 0x0018(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0019(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_31CE[0x6];                                     // 0x001A(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GzInvStatics_CanAddItem) == 0x000008, "Wrong alignment on GzInvStatics_CanAddItem");
static_assert(sizeof(GzInvStatics_CanAddItem) == 0x000020, "Wrong size on GzInvStatics_CanAddItem");
static_assert(offsetof(GzInvStatics_CanAddItem, Inventory) == 0x000000, "Member 'GzInvStatics_CanAddItem::Inventory' has a wrong offset!");
static_assert(offsetof(GzInvStatics_CanAddItem, Item) == 0x000008, "Member 'GzInvStatics_CanAddItem::Item' has a wrong offset!");
static_assert(offsetof(GzInvStatics_CanAddItem, bAllowSwap) == 0x000018, "Member 'GzInvStatics_CanAddItem::bAllowSwap' has a wrong offset!");
static_assert(offsetof(GzInvStatics_CanAddItem, ReturnValue) == 0x000019, "Member 'GzInvStatics_CanAddItem::ReturnValue' has a wrong offset!");

// Function G01.GzInvStatics.EquipLoadout
// 0x0020 (0x0020 - 0x0000)
struct GzInvStatics_EquipLoadout final
{
public:
	class UGzInvComponent*                        Inventory;                                         // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FGzInvItem>                     Items;                                             // 0x0008(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	bool                                          bDropReplacedItems;                                // 0x0018(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_31CF[0x7];                                     // 0x0019(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GzInvStatics_EquipLoadout) == 0x000008, "Wrong alignment on GzInvStatics_EquipLoadout");
static_assert(sizeof(GzInvStatics_EquipLoadout) == 0x000020, "Wrong size on GzInvStatics_EquipLoadout");
static_assert(offsetof(GzInvStatics_EquipLoadout, Inventory) == 0x000000, "Member 'GzInvStatics_EquipLoadout::Inventory' has a wrong offset!");
static_assert(offsetof(GzInvStatics_EquipLoadout, Items) == 0x000008, "Member 'GzInvStatics_EquipLoadout::Items' has a wrong offset!");
static_assert(offsetof(GzInvStatics_EquipLoadout, bDropReplacedItems) == 0x000018, "Member 'GzInvStatics_EquipLoadout::bDropReplacedItems' has a wrong offset!");

// Function G01.GzInvStatics.GetAllItems
// 0x0018 (0x0018 - 0x0000)
struct GzInvStatics_GetAllItems final
{
public:
	const class UGzInvComponent*                  Inventory;                                         // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FGzInvItem>                     ReturnValue;                                       // 0x0008(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzInvStatics_GetAllItems) == 0x000008, "Wrong alignment on GzInvStatics_GetAllItems");
static_assert(sizeof(GzInvStatics_GetAllItems) == 0x000018, "Wrong size on GzInvStatics_GetAllItems");
static_assert(offsetof(GzInvStatics_GetAllItems, Inventory) == 0x000000, "Member 'GzInvStatics_GetAllItems::Inventory' has a wrong offset!");
static_assert(offsetof(GzInvStatics_GetAllItems, ReturnValue) == 0x000008, "Member 'GzInvStatics_GetAllItems::ReturnValue' has a wrong offset!");

// Function G01.GzInvStatics.GetAttributeFromItemByTag
// 0x0020 (0x0020 - 0x0000)
struct GzInvStatics_GetAttributeFromItemByTag final
{
public:
	struct FGzInvItem                             Item;                                              // 0x0000(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	struct FGameplayTag                           Tag;                                               // 0x0010(0x0008)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ReturnValue;                                       // 0x0018(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_31D0[0x4];                                     // 0x001C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GzInvStatics_GetAttributeFromItemByTag) == 0x000008, "Wrong alignment on GzInvStatics_GetAttributeFromItemByTag");
static_assert(sizeof(GzInvStatics_GetAttributeFromItemByTag) == 0x000020, "Wrong size on GzInvStatics_GetAttributeFromItemByTag");
static_assert(offsetof(GzInvStatics_GetAttributeFromItemByTag, Item) == 0x000000, "Member 'GzInvStatics_GetAttributeFromItemByTag::Item' has a wrong offset!");
static_assert(offsetof(GzInvStatics_GetAttributeFromItemByTag, Tag) == 0x000010, "Member 'GzInvStatics_GetAttributeFromItemByTag::Tag' has a wrong offset!");
static_assert(offsetof(GzInvStatics_GetAttributeFromItemByTag, ReturnValue) == 0x000018, "Member 'GzInvStatics_GetAttributeFromItemByTag::ReturnValue' has a wrong offset!");

// Function G01.GzInvStatics.GetCapacityToAutoStack
// 0x0020 (0x0020 - 0x0000)
struct GzInvStatics_GetCapacityToAutoStack final
{
public:
	const class UGzInvComponent*                  Inventory;                                         // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGzInvItem                             Item;                                              // 0x0008(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	int32                                         ReturnValue;                                       // 0x0018(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_31D1[0x4];                                     // 0x001C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GzInvStatics_GetCapacityToAutoStack) == 0x000008, "Wrong alignment on GzInvStatics_GetCapacityToAutoStack");
static_assert(sizeof(GzInvStatics_GetCapacityToAutoStack) == 0x000020, "Wrong size on GzInvStatics_GetCapacityToAutoStack");
static_assert(offsetof(GzInvStatics_GetCapacityToAutoStack, Inventory) == 0x000000, "Member 'GzInvStatics_GetCapacityToAutoStack::Inventory' has a wrong offset!");
static_assert(offsetof(GzInvStatics_GetCapacityToAutoStack, Item) == 0x000008, "Member 'GzInvStatics_GetCapacityToAutoStack::Item' has a wrong offset!");
static_assert(offsetof(GzInvStatics_GetCapacityToAutoStack, ReturnValue) == 0x000018, "Member 'GzInvStatics_GetCapacityToAutoStack::ReturnValue' has a wrong offset!");

// Function G01.GzInvStatics.GetDefaultAttributeFromItemByTag
// 0x0020 (0x0020 - 0x0000)
struct GzInvStatics_GetDefaultAttributeFromItemByTag final
{
public:
	struct FGzInvItem                             Item;                                              // 0x0000(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	struct FGameplayTag                           Tag;                                               // 0x0010(0x0008)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ReturnValue;                                       // 0x0018(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_31D2[0x4];                                     // 0x001C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GzInvStatics_GetDefaultAttributeFromItemByTag) == 0x000008, "Wrong alignment on GzInvStatics_GetDefaultAttributeFromItemByTag");
static_assert(sizeof(GzInvStatics_GetDefaultAttributeFromItemByTag) == 0x000020, "Wrong size on GzInvStatics_GetDefaultAttributeFromItemByTag");
static_assert(offsetof(GzInvStatics_GetDefaultAttributeFromItemByTag, Item) == 0x000000, "Member 'GzInvStatics_GetDefaultAttributeFromItemByTag::Item' has a wrong offset!");
static_assert(offsetof(GzInvStatics_GetDefaultAttributeFromItemByTag, Tag) == 0x000010, "Member 'GzInvStatics_GetDefaultAttributeFromItemByTag::Tag' has a wrong offset!");
static_assert(offsetof(GzInvStatics_GetDefaultAttributeFromItemByTag, ReturnValue) == 0x000018, "Member 'GzInvStatics_GetDefaultAttributeFromItemByTag::ReturnValue' has a wrong offset!");

// Function G01.GzInvStatics.GetDefaultAttributeFromItemDataByTag
// 0x0018 (0x0018 - 0x0000)
struct GzInvStatics_GetDefaultAttributeFromItemDataByTag final
{
public:
	const class UGzItemData*                      ItemData;                                          // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           Tag;                                               // 0x0008(0x0008)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ReturnValue;                                       // 0x0010(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_31D3[0x4];                                     // 0x0014(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GzInvStatics_GetDefaultAttributeFromItemDataByTag) == 0x000008, "Wrong alignment on GzInvStatics_GetDefaultAttributeFromItemDataByTag");
static_assert(sizeof(GzInvStatics_GetDefaultAttributeFromItemDataByTag) == 0x000018, "Wrong size on GzInvStatics_GetDefaultAttributeFromItemDataByTag");
static_assert(offsetof(GzInvStatics_GetDefaultAttributeFromItemDataByTag, ItemData) == 0x000000, "Member 'GzInvStatics_GetDefaultAttributeFromItemDataByTag::ItemData' has a wrong offset!");
static_assert(offsetof(GzInvStatics_GetDefaultAttributeFromItemDataByTag, Tag) == 0x000008, "Member 'GzInvStatics_GetDefaultAttributeFromItemDataByTag::Tag' has a wrong offset!");
static_assert(offsetof(GzInvStatics_GetDefaultAttributeFromItemDataByTag, ReturnValue) == 0x000010, "Member 'GzInvStatics_GetDefaultAttributeFromItemDataByTag::ReturnValue' has a wrong offset!");

// Function G01.GzInvStatics.GetDefaultPockets
// 0x0018 (0x0018 - 0x0000)
struct GzInvStatics_GetDefaultPockets final
{
public:
	const class UGzInvComponent*                  Inventory;                                         // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FGzInvPocket>                   ReturnValue;                                       // 0x0008(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzInvStatics_GetDefaultPockets) == 0x000008, "Wrong alignment on GzInvStatics_GetDefaultPockets");
static_assert(sizeof(GzInvStatics_GetDefaultPockets) == 0x000018, "Wrong size on GzInvStatics_GetDefaultPockets");
static_assert(offsetof(GzInvStatics_GetDefaultPockets, Inventory) == 0x000000, "Member 'GzInvStatics_GetDefaultPockets::Inventory' has a wrong offset!");
static_assert(offsetof(GzInvStatics_GetDefaultPockets, ReturnValue) == 0x000008, "Member 'GzInvStatics_GetDefaultPockets::ReturnValue' has a wrong offset!");

// Function G01.GzInvStatics.GetHighestRarityItem
// 0x0020 (0x0020 - 0x0000)
struct GzInvStatics_GetHighestRarityItem final
{
public:
	TArray<struct FGzInvItem>                     Items;                                             // 0x0000(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	struct FGzInvItem                             ReturnValue;                                       // 0x0010(0x0010)(Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzInvStatics_GetHighestRarityItem) == 0x000008, "Wrong alignment on GzInvStatics_GetHighestRarityItem");
static_assert(sizeof(GzInvStatics_GetHighestRarityItem) == 0x000020, "Wrong size on GzInvStatics_GetHighestRarityItem");
static_assert(offsetof(GzInvStatics_GetHighestRarityItem, Items) == 0x000000, "Member 'GzInvStatics_GetHighestRarityItem::Items' has a wrong offset!");
static_assert(offsetof(GzInvStatics_GetHighestRarityItem, ReturnValue) == 0x000010, "Member 'GzInvStatics_GetHighestRarityItem::ReturnValue' has a wrong offset!");

// Function G01.GzInvStatics.GetItemCountByItemData
// 0x0018 (0x0018 - 0x0000)
struct GzInvStatics_GetItemCountByItemData final
{
public:
	const class UGzInvComponent*                  Inventory;                                         // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	const class UGzItemData*                      ItemData;                                          // 0x0008(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ReturnValue;                                       // 0x0010(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_31D4[0x4];                                     // 0x0014(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GzInvStatics_GetItemCountByItemData) == 0x000008, "Wrong alignment on GzInvStatics_GetItemCountByItemData");
static_assert(sizeof(GzInvStatics_GetItemCountByItemData) == 0x000018, "Wrong size on GzInvStatics_GetItemCountByItemData");
static_assert(offsetof(GzInvStatics_GetItemCountByItemData, Inventory) == 0x000000, "Member 'GzInvStatics_GetItemCountByItemData::Inventory' has a wrong offset!");
static_assert(offsetof(GzInvStatics_GetItemCountByItemData, ItemData) == 0x000008, "Member 'GzInvStatics_GetItemCountByItemData::ItemData' has a wrong offset!");
static_assert(offsetof(GzInvStatics_GetItemCountByItemData, ReturnValue) == 0x000010, "Member 'GzInvStatics_GetItemCountByItemData::ReturnValue' has a wrong offset!");

// Function G01.GzInvStatics.GetItemCountByType
// 0x0018 (0x0018 - 0x0000)
struct GzInvStatics_GetItemCountByType final
{
public:
	const class UGzInvComponent*                  Inventory;                                         // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           ItemType;                                          // 0x0008(0x0008)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ReturnValue;                                       // 0x0010(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_31D5[0x4];                                     // 0x0014(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GzInvStatics_GetItemCountByType) == 0x000008, "Wrong alignment on GzInvStatics_GetItemCountByType");
static_assert(sizeof(GzInvStatics_GetItemCountByType) == 0x000018, "Wrong size on GzInvStatics_GetItemCountByType");
static_assert(offsetof(GzInvStatics_GetItemCountByType, Inventory) == 0x000000, "Member 'GzInvStatics_GetItemCountByType::Inventory' has a wrong offset!");
static_assert(offsetof(GzInvStatics_GetItemCountByType, ItemType) == 0x000008, "Member 'GzInvStatics_GetItemCountByType::ItemType' has a wrong offset!");
static_assert(offsetof(GzInvStatics_GetItemCountByType, ReturnValue) == 0x000010, "Member 'GzInvStatics_GetItemCountByType::ReturnValue' has a wrong offset!");

// Function G01.GzInvStatics.GetItemData
// 0x0018 (0x0018 - 0x0000)
struct GzInvStatics_GetItemData final
{
public:
	struct FGzInvItem                             Item;                                              // 0x0000(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	class UGzItemData*                            ReturnValue;                                       // 0x0010(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzInvStatics_GetItemData) == 0x000008, "Wrong alignment on GzInvStatics_GetItemData");
static_assert(sizeof(GzInvStatics_GetItemData) == 0x000018, "Wrong size on GzInvStatics_GetItemData");
static_assert(offsetof(GzInvStatics_GetItemData, Item) == 0x000000, "Member 'GzInvStatics_GetItemData::Item' has a wrong offset!");
static_assert(offsetof(GzInvStatics_GetItemData, ReturnValue) == 0x000010, "Member 'GzInvStatics_GetItemData::ReturnValue' has a wrong offset!");

// Function G01.GzInvStatics.GetItemDataByItemType
// 0x0018 (0x0018 - 0x0000)
struct GzInvStatics_GetItemDataByItemType final
{
public:
	const class UGzInvComponent*                  Inventory;                                         // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           Slot;                                              // 0x0008(0x0008)(ConstParm, Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UGzItemData*                            ReturnValue;                                       // 0x0010(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzInvStatics_GetItemDataByItemType) == 0x000008, "Wrong alignment on GzInvStatics_GetItemDataByItemType");
static_assert(sizeof(GzInvStatics_GetItemDataByItemType) == 0x000018, "Wrong size on GzInvStatics_GetItemDataByItemType");
static_assert(offsetof(GzInvStatics_GetItemDataByItemType, Inventory) == 0x000000, "Member 'GzInvStatics_GetItemDataByItemType::Inventory' has a wrong offset!");
static_assert(offsetof(GzInvStatics_GetItemDataByItemType, Slot) == 0x000008, "Member 'GzInvStatics_GetItemDataByItemType::Slot' has a wrong offset!");
static_assert(offsetof(GzInvStatics_GetItemDataByItemType, ReturnValue) == 0x000010, "Member 'GzInvStatics_GetItemDataByItemType::ReturnValue' has a wrong offset!");

// Function G01.GzInvStatics.GetItemQuantity
// 0x0018 (0x0018 - 0x0000)
struct GzInvStatics_GetItemQuantity final
{
public:
	struct FGzInvItem                             Item;                                              // 0x0000(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	int32                                         ReturnValue;                                       // 0x0010(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_31D6[0x4];                                     // 0x0014(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GzInvStatics_GetItemQuantity) == 0x000008, "Wrong alignment on GzInvStatics_GetItemQuantity");
static_assert(sizeof(GzInvStatics_GetItemQuantity) == 0x000018, "Wrong size on GzInvStatics_GetItemQuantity");
static_assert(offsetof(GzInvStatics_GetItemQuantity, Item) == 0x000000, "Member 'GzInvStatics_GetItemQuantity::Item' has a wrong offset!");
static_assert(offsetof(GzInvStatics_GetItemQuantity, ReturnValue) == 0x000010, "Member 'GzInvStatics_GetItemQuantity::ReturnValue' has a wrong offset!");

// Function G01.GzInvStatics.GetItemsByItemData
// 0x0020 (0x0020 - 0x0000)
struct GzInvStatics_GetItemsByItemData final
{
public:
	const class UGzInvComponent*                  Inventory;                                         // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	const class UGzItemData*                      ItemData;                                          // 0x0008(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FGzInvItem>                     ReturnValue;                                       // 0x0010(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzInvStatics_GetItemsByItemData) == 0x000008, "Wrong alignment on GzInvStatics_GetItemsByItemData");
static_assert(sizeof(GzInvStatics_GetItemsByItemData) == 0x000020, "Wrong size on GzInvStatics_GetItemsByItemData");
static_assert(offsetof(GzInvStatics_GetItemsByItemData, Inventory) == 0x000000, "Member 'GzInvStatics_GetItemsByItemData::Inventory' has a wrong offset!");
static_assert(offsetof(GzInvStatics_GetItemsByItemData, ItemData) == 0x000008, "Member 'GzInvStatics_GetItemsByItemData::ItemData' has a wrong offset!");
static_assert(offsetof(GzInvStatics_GetItemsByItemData, ReturnValue) == 0x000010, "Member 'GzInvStatics_GetItemsByItemData::ReturnValue' has a wrong offset!");

// Function G01.GzInvStatics.GetItemsByItemType
// 0x0020 (0x0020 - 0x0000)
struct GzInvStatics_GetItemsByItemType final
{
public:
	const class UGzInvComponent*                  Inventory;                                         // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           ItemType;                                          // 0x0008(0x0008)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FGzInvItem>                     ReturnValue;                                       // 0x0010(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzInvStatics_GetItemsByItemType) == 0x000008, "Wrong alignment on GzInvStatics_GetItemsByItemType");
static_assert(sizeof(GzInvStatics_GetItemsByItemType) == 0x000020, "Wrong size on GzInvStatics_GetItemsByItemType");
static_assert(offsetof(GzInvStatics_GetItemsByItemType, Inventory) == 0x000000, "Member 'GzInvStatics_GetItemsByItemType::Inventory' has a wrong offset!");
static_assert(offsetof(GzInvStatics_GetItemsByItemType, ItemType) == 0x000008, "Member 'GzInvStatics_GetItemsByItemType::ItemType' has a wrong offset!");
static_assert(offsetof(GzInvStatics_GetItemsByItemType, ReturnValue) == 0x000010, "Member 'GzInvStatics_GetItemsByItemType::ReturnValue' has a wrong offset!");

// Function G01.GzInvStatics.GetItemsBySlot
// 0x0020 (0x0020 - 0x0000)
struct GzInvStatics_GetItemsBySlot final
{
public:
	const class UGzInvComponent*                  Inventory;                                         // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           Slot;                                              // 0x0008(0x0008)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FGzInvItem>                     ReturnValue;                                       // 0x0010(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzInvStatics_GetItemsBySlot) == 0x000008, "Wrong alignment on GzInvStatics_GetItemsBySlot");
static_assert(sizeof(GzInvStatics_GetItemsBySlot) == 0x000020, "Wrong size on GzInvStatics_GetItemsBySlot");
static_assert(offsetof(GzInvStatics_GetItemsBySlot, Inventory) == 0x000000, "Member 'GzInvStatics_GetItemsBySlot::Inventory' has a wrong offset!");
static_assert(offsetof(GzInvStatics_GetItemsBySlot, Slot) == 0x000008, "Member 'GzInvStatics_GetItemsBySlot::Slot' has a wrong offset!");
static_assert(offsetof(GzInvStatics_GetItemsBySlot, ReturnValue) == 0x000010, "Member 'GzInvStatics_GetItemsBySlot::ReturnValue' has a wrong offset!");

// Function G01.GzInvStatics.GetLimbItem
// 0x0070 (0x0070 - 0x0000)
struct GzInvStatics_GetLimbItem final
{
public:
	struct FGzInvItem                             Item;                                              // 0x0000(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	EGzExecResult                                 ExecResult;                                        // 0x0010(0x0001)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_31D7[0x7];                                     // 0x0011(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGzLimbInvItem                         ReturnValue;                                       // 0x0018(0x0058)(Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzInvStatics_GetLimbItem) == 0x000008, "Wrong alignment on GzInvStatics_GetLimbItem");
static_assert(sizeof(GzInvStatics_GetLimbItem) == 0x000070, "Wrong size on GzInvStatics_GetLimbItem");
static_assert(offsetof(GzInvStatics_GetLimbItem, Item) == 0x000000, "Member 'GzInvStatics_GetLimbItem::Item' has a wrong offset!");
static_assert(offsetof(GzInvStatics_GetLimbItem, ExecResult) == 0x000010, "Member 'GzInvStatics_GetLimbItem::ExecResult' has a wrong offset!");
static_assert(offsetof(GzInvStatics_GetLimbItem, ReturnValue) == 0x000018, "Member 'GzInvStatics_GetLimbItem::ReturnValue' has a wrong offset!");

// Function G01.GzInvStatics.GetLimbTypeBySlot
// 0x000C (0x000C - 0x0000)
struct GzInvStatics_GetLimbTypeBySlot final
{
public:
	struct FGameplayTag                           Slot;                                              // 0x0000(0x0008)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EGzLimbType                                   ReturnValue;                                       // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_31D8[0x3];                                     // 0x0009(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GzInvStatics_GetLimbTypeBySlot) == 0x000004, "Wrong alignment on GzInvStatics_GetLimbTypeBySlot");
static_assert(sizeof(GzInvStatics_GetLimbTypeBySlot) == 0x00000C, "Wrong size on GzInvStatics_GetLimbTypeBySlot");
static_assert(offsetof(GzInvStatics_GetLimbTypeBySlot, Slot) == 0x000000, "Member 'GzInvStatics_GetLimbTypeBySlot::Slot' has a wrong offset!");
static_assert(offsetof(GzInvStatics_GetLimbTypeBySlot, ReturnValue) == 0x000008, "Member 'GzInvStatics_GetLimbTypeBySlot::ReturnValue' has a wrong offset!");

// Function G01.GzInvStatics.GetPocketByItemData
// 0x0038 (0x0038 - 0x0000)
struct GzInvStatics_GetPocketByItemData final
{
public:
	const class UGzInvComponent*                  Inventory;                                         // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	const class UGzItemData*                      ItemData;                                          // 0x0008(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGzInvPocket                           ReturnValue;                                       // 0x0010(0x0028)(ConstParm, Parm, OutParm, ReturnParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzInvStatics_GetPocketByItemData) == 0x000008, "Wrong alignment on GzInvStatics_GetPocketByItemData");
static_assert(sizeof(GzInvStatics_GetPocketByItemData) == 0x000038, "Wrong size on GzInvStatics_GetPocketByItemData");
static_assert(offsetof(GzInvStatics_GetPocketByItemData, Inventory) == 0x000000, "Member 'GzInvStatics_GetPocketByItemData::Inventory' has a wrong offset!");
static_assert(offsetof(GzInvStatics_GetPocketByItemData, ItemData) == 0x000008, "Member 'GzInvStatics_GetPocketByItemData::ItemData' has a wrong offset!");
static_assert(offsetof(GzInvStatics_GetPocketByItemData, ReturnValue) == 0x000010, "Member 'GzInvStatics_GetPocketByItemData::ReturnValue' has a wrong offset!");

// Function G01.GzInvStatics.GetPocketByItemType
// 0x0038 (0x0038 - 0x0000)
struct GzInvStatics_GetPocketByItemType final
{
public:
	const class UGzInvComponent*                  Inventory;                                         // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           ItemType;                                          // 0x0008(0x0008)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGzInvPocket                           ReturnValue;                                       // 0x0010(0x0028)(ConstParm, Parm, OutParm, ReturnParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzInvStatics_GetPocketByItemType) == 0x000008, "Wrong alignment on GzInvStatics_GetPocketByItemType");
static_assert(sizeof(GzInvStatics_GetPocketByItemType) == 0x000038, "Wrong size on GzInvStatics_GetPocketByItemType");
static_assert(offsetof(GzInvStatics_GetPocketByItemType, Inventory) == 0x000000, "Member 'GzInvStatics_GetPocketByItemType::Inventory' has a wrong offset!");
static_assert(offsetof(GzInvStatics_GetPocketByItemType, ItemType) == 0x000008, "Member 'GzInvStatics_GetPocketByItemType::ItemType' has a wrong offset!");
static_assert(offsetof(GzInvStatics_GetPocketByItemType, ReturnValue) == 0x000010, "Member 'GzInvStatics_GetPocketByItemType::ReturnValue' has a wrong offset!");

// Function G01.GzInvStatics.GetPocketBySlot
// 0x0038 (0x0038 - 0x0000)
struct GzInvStatics_GetPocketBySlot final
{
public:
	const class UGzInvComponent*                  Inventory;                                         // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           Slot;                                              // 0x0008(0x0008)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGzInvPocket                           ReturnValue;                                       // 0x0010(0x0028)(ConstParm, Parm, OutParm, ReturnParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzInvStatics_GetPocketBySlot) == 0x000008, "Wrong alignment on GzInvStatics_GetPocketBySlot");
static_assert(sizeof(GzInvStatics_GetPocketBySlot) == 0x000038, "Wrong size on GzInvStatics_GetPocketBySlot");
static_assert(offsetof(GzInvStatics_GetPocketBySlot, Inventory) == 0x000000, "Member 'GzInvStatics_GetPocketBySlot::Inventory' has a wrong offset!");
static_assert(offsetof(GzInvStatics_GetPocketBySlot, Slot) == 0x000008, "Member 'GzInvStatics_GetPocketBySlot::Slot' has a wrong offset!");
static_assert(offsetof(GzInvStatics_GetPocketBySlot, ReturnValue) == 0x000010, "Member 'GzInvStatics_GetPocketBySlot::ReturnValue' has a wrong offset!");

// Function G01.GzInvStatics.GetPocketsByItemData
// 0x0020 (0x0020 - 0x0000)
struct GzInvStatics_GetPocketsByItemData final
{
public:
	const class UGzInvComponent*                  Inventory;                                         // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	const class UGzItemData*                      ItemData;                                          // 0x0008(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FGzInvPocket>                   ReturnValue;                                       // 0x0010(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzInvStatics_GetPocketsByItemData) == 0x000008, "Wrong alignment on GzInvStatics_GetPocketsByItemData");
static_assert(sizeof(GzInvStatics_GetPocketsByItemData) == 0x000020, "Wrong size on GzInvStatics_GetPocketsByItemData");
static_assert(offsetof(GzInvStatics_GetPocketsByItemData, Inventory) == 0x000000, "Member 'GzInvStatics_GetPocketsByItemData::Inventory' has a wrong offset!");
static_assert(offsetof(GzInvStatics_GetPocketsByItemData, ItemData) == 0x000008, "Member 'GzInvStatics_GetPocketsByItemData::ItemData' has a wrong offset!");
static_assert(offsetof(GzInvStatics_GetPocketsByItemData, ReturnValue) == 0x000010, "Member 'GzInvStatics_GetPocketsByItemData::ReturnValue' has a wrong offset!");

// Function G01.GzInvStatics.GetPocketsByItemType
// 0x0020 (0x0020 - 0x0000)
struct GzInvStatics_GetPocketsByItemType final
{
public:
	const class UGzInvComponent*                  Inventory;                                         // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           ItemType;                                          // 0x0008(0x0008)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FGzInvPocket>                   ReturnValue;                                       // 0x0010(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzInvStatics_GetPocketsByItemType) == 0x000008, "Wrong alignment on GzInvStatics_GetPocketsByItemType");
static_assert(sizeof(GzInvStatics_GetPocketsByItemType) == 0x000020, "Wrong size on GzInvStatics_GetPocketsByItemType");
static_assert(offsetof(GzInvStatics_GetPocketsByItemType, Inventory) == 0x000000, "Member 'GzInvStatics_GetPocketsByItemType::Inventory' has a wrong offset!");
static_assert(offsetof(GzInvStatics_GetPocketsByItemType, ItemType) == 0x000008, "Member 'GzInvStatics_GetPocketsByItemType::ItemType' has a wrong offset!");
static_assert(offsetof(GzInvStatics_GetPocketsByItemType, ReturnValue) == 0x000010, "Member 'GzInvStatics_GetPocketsByItemType::ReturnValue' has a wrong offset!");

// Function G01.GzInvStatics.GetPocketsBySlot
// 0x0020 (0x0020 - 0x0000)
struct GzInvStatics_GetPocketsBySlot final
{
public:
	const class UGzInvComponent*                  Inventory;                                         // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           Slot;                                              // 0x0008(0x0008)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FGzInvPocket>                   ReturnValue;                                       // 0x0010(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzInvStatics_GetPocketsBySlot) == 0x000008, "Wrong alignment on GzInvStatics_GetPocketsBySlot");
static_assert(sizeof(GzInvStatics_GetPocketsBySlot) == 0x000020, "Wrong size on GzInvStatics_GetPocketsBySlot");
static_assert(offsetof(GzInvStatics_GetPocketsBySlot, Inventory) == 0x000000, "Member 'GzInvStatics_GetPocketsBySlot::Inventory' has a wrong offset!");
static_assert(offsetof(GzInvStatics_GetPocketsBySlot, Slot) == 0x000008, "Member 'GzInvStatics_GetPocketsBySlot::Slot' has a wrong offset!");
static_assert(offsetof(GzInvStatics_GetPocketsBySlot, ReturnValue) == 0x000010, "Member 'GzInvStatics_GetPocketsBySlot::ReturnValue' has a wrong offset!");

// Function G01.GzInvStatics.GetSimpleItem
// 0x0050 (0x0050 - 0x0000)
struct GzInvStatics_GetSimpleItem final
{
public:
	struct FGzInvItem                             Item;                                              // 0x0000(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	EGzExecResult                                 ExecResult;                                        // 0x0010(0x0001)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_31D9[0x7];                                     // 0x0011(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGzSimpleInvItem                       ReturnValue;                                       // 0x0018(0x0038)(Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzInvStatics_GetSimpleItem) == 0x000008, "Wrong alignment on GzInvStatics_GetSimpleItem");
static_assert(sizeof(GzInvStatics_GetSimpleItem) == 0x000050, "Wrong size on GzInvStatics_GetSimpleItem");
static_assert(offsetof(GzInvStatics_GetSimpleItem, Item) == 0x000000, "Member 'GzInvStatics_GetSimpleItem::Item' has a wrong offset!");
static_assert(offsetof(GzInvStatics_GetSimpleItem, ExecResult) == 0x000010, "Member 'GzInvStatics_GetSimpleItem::ExecResult' has a wrong offset!");
static_assert(offsetof(GzInvStatics_GetSimpleItem, ReturnValue) == 0x000018, "Member 'GzInvStatics_GetSimpleItem::ReturnValue' has a wrong offset!");

// Function G01.GzInvStatics.GetSortedByRarity
// 0x0028 (0x0028 - 0x0000)
struct GzInvStatics_GetSortedByRarity final
{
public:
	TArray<struct FGzInvItem>                     Items;                                             // 0x0000(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	bool                                          bAscending;                                        // 0x0010(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_31DA[0x7];                                     // 0x0011(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FGzInvItem>                     ReturnValue;                                       // 0x0018(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzInvStatics_GetSortedByRarity) == 0x000008, "Wrong alignment on GzInvStatics_GetSortedByRarity");
static_assert(sizeof(GzInvStatics_GetSortedByRarity) == 0x000028, "Wrong size on GzInvStatics_GetSortedByRarity");
static_assert(offsetof(GzInvStatics_GetSortedByRarity, Items) == 0x000000, "Member 'GzInvStatics_GetSortedByRarity::Items' has a wrong offset!");
static_assert(offsetof(GzInvStatics_GetSortedByRarity, bAscending) == 0x000010, "Member 'GzInvStatics_GetSortedByRarity::bAscending' has a wrong offset!");
static_assert(offsetof(GzInvStatics_GetSortedByRarity, ReturnValue) == 0x000018, "Member 'GzInvStatics_GetSortedByRarity::ReturnValue' has a wrong offset!");

// Function G01.GzInvStatics.GetVirtualPockets
// 0x0018 (0x0018 - 0x0000)
struct GzInvStatics_GetVirtualPockets final
{
public:
	const class UGzInvComponent*                  Inventory;                                         // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FGzInvPocket>                   ReturnValue;                                       // 0x0008(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzInvStatics_GetVirtualPockets) == 0x000008, "Wrong alignment on GzInvStatics_GetVirtualPockets");
static_assert(sizeof(GzInvStatics_GetVirtualPockets) == 0x000018, "Wrong size on GzInvStatics_GetVirtualPockets");
static_assert(offsetof(GzInvStatics_GetVirtualPockets, Inventory) == 0x000000, "Member 'GzInvStatics_GetVirtualPockets::Inventory' has a wrong offset!");
static_assert(offsetof(GzInvStatics_GetVirtualPockets, ReturnValue) == 0x000008, "Member 'GzInvStatics_GetVirtualPockets::ReturnValue' has a wrong offset!");

// Function G01.GzInvStatics.GetWeaponItem
// 0x0068 (0x0068 - 0x0000)
struct GzInvStatics_GetWeaponItem final
{
public:
	struct FGzInvItem                             Item;                                              // 0x0000(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	EGzExecResult                                 ExecResult;                                        // 0x0010(0x0001)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_31DB[0x7];                                     // 0x0011(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGzWeaponInvItem                       ReturnValue;                                       // 0x0018(0x0050)(Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzInvStatics_GetWeaponItem) == 0x000008, "Wrong alignment on GzInvStatics_GetWeaponItem");
static_assert(sizeof(GzInvStatics_GetWeaponItem) == 0x000068, "Wrong size on GzInvStatics_GetWeaponItem");
static_assert(offsetof(GzInvStatics_GetWeaponItem, Item) == 0x000000, "Member 'GzInvStatics_GetWeaponItem::Item' has a wrong offset!");
static_assert(offsetof(GzInvStatics_GetWeaponItem, ExecResult) == 0x000010, "Member 'GzInvStatics_GetWeaponItem::ExecResult' has a wrong offset!");
static_assert(offsetof(GzInvStatics_GetWeaponItem, ReturnValue) == 0x000018, "Member 'GzInvStatics_GetWeaponItem::ReturnValue' has a wrong offset!");

// Function G01.GzInvStatics.HasItemInSlot
// 0x0018 (0x0018 - 0x0000)
struct GzInvStatics_HasItemInSlot final
{
public:
	const class UGzInvComponent*                  Inventory;                                         // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           Slot;                                              // 0x0008(0x0008)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0010(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_31DC[0x7];                                     // 0x0011(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GzInvStatics_HasItemInSlot) == 0x000008, "Wrong alignment on GzInvStatics_HasItemInSlot");
static_assert(sizeof(GzInvStatics_HasItemInSlot) == 0x000018, "Wrong size on GzInvStatics_HasItemInSlot");
static_assert(offsetof(GzInvStatics_HasItemInSlot, Inventory) == 0x000000, "Member 'GzInvStatics_HasItemInSlot::Inventory' has a wrong offset!");
static_assert(offsetof(GzInvStatics_HasItemInSlot, Slot) == 0x000008, "Member 'GzInvStatics_HasItemInSlot::Slot' has a wrong offset!");
static_assert(offsetof(GzInvStatics_HasItemInSlot, ReturnValue) == 0x000010, "Member 'GzInvStatics_HasItemInSlot::ReturnValue' has a wrong offset!");

// Function G01.GzInvStatics.HasItemOfType
// 0x0018 (0x0018 - 0x0000)
struct GzInvStatics_HasItemOfType final
{
public:
	const class UGzInvComponent*                  Inventory;                                         // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           ItemType;                                          // 0x0008(0x0008)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0010(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_31DD[0x7];                                     // 0x0011(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GzInvStatics_HasItemOfType) == 0x000008, "Wrong alignment on GzInvStatics_HasItemOfType");
static_assert(sizeof(GzInvStatics_HasItemOfType) == 0x000018, "Wrong size on GzInvStatics_HasItemOfType");
static_assert(offsetof(GzInvStatics_HasItemOfType, Inventory) == 0x000000, "Member 'GzInvStatics_HasItemOfType::Inventory' has a wrong offset!");
static_assert(offsetof(GzInvStatics_HasItemOfType, ItemType) == 0x000008, "Member 'GzInvStatics_HasItemOfType::ItemType' has a wrong offset!");
static_assert(offsetof(GzInvStatics_HasItemOfType, ReturnValue) == 0x000010, "Member 'GzInvStatics_HasItemOfType::ReturnValue' has a wrong offset!");

// Function G01.GzInvStatics.HasItemWithData
// 0x0018 (0x0018 - 0x0000)
struct GzInvStatics_HasItemWithData final
{
public:
	const class UGzInvComponent*                  Inventory;                                         // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	const class UGzItemData*                      ItemData;                                          // 0x0008(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0010(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_31DE[0x7];                                     // 0x0011(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GzInvStatics_HasItemWithData) == 0x000008, "Wrong alignment on GzInvStatics_HasItemWithData");
static_assert(sizeof(GzInvStatics_HasItemWithData) == 0x000018, "Wrong size on GzInvStatics_HasItemWithData");
static_assert(offsetof(GzInvStatics_HasItemWithData, Inventory) == 0x000000, "Member 'GzInvStatics_HasItemWithData::Inventory' has a wrong offset!");
static_assert(offsetof(GzInvStatics_HasItemWithData, ItemData) == 0x000008, "Member 'GzInvStatics_HasItemWithData::ItemData' has a wrong offset!");
static_assert(offsetof(GzInvStatics_HasItemWithData, ReturnValue) == 0x000010, "Member 'GzInvStatics_HasItemWithData::ReturnValue' has a wrong offset!");

// Function G01.GzInvStatics.IsAmmoItemType
// 0x000C (0x000C - 0x0000)
struct GzInvStatics_IsAmmoItemType final
{
public:
	struct FGameplayTag                           Type;                                              // 0x0000(0x0008)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_31DF[0x3];                                     // 0x0009(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GzInvStatics_IsAmmoItemType) == 0x000004, "Wrong alignment on GzInvStatics_IsAmmoItemType");
static_assert(sizeof(GzInvStatics_IsAmmoItemType) == 0x00000C, "Wrong size on GzInvStatics_IsAmmoItemType");
static_assert(offsetof(GzInvStatics_IsAmmoItemType, Type) == 0x000000, "Member 'GzInvStatics_IsAmmoItemType::Type' has a wrong offset!");
static_assert(offsetof(GzInvStatics_IsAmmoItemType, ReturnValue) == 0x000008, "Member 'GzInvStatics_IsAmmoItemType::ReturnValue' has a wrong offset!");

// Function G01.GzInvStatics.IsBackpackItemType
// 0x000C (0x000C - 0x0000)
struct GzInvStatics_IsBackpackItemType final
{
public:
	struct FGameplayTag                           Type;                                              // 0x0000(0x0008)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_31E0[0x3];                                     // 0x0009(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GzInvStatics_IsBackpackItemType) == 0x000004, "Wrong alignment on GzInvStatics_IsBackpackItemType");
static_assert(sizeof(GzInvStatics_IsBackpackItemType) == 0x00000C, "Wrong size on GzInvStatics_IsBackpackItemType");
static_assert(offsetof(GzInvStatics_IsBackpackItemType, Type) == 0x000000, "Member 'GzInvStatics_IsBackpackItemType::Type' has a wrong offset!");
static_assert(offsetof(GzInvStatics_IsBackpackItemType, ReturnValue) == 0x000008, "Member 'GzInvStatics_IsBackpackItemType::ReturnValue' has a wrong offset!");

// Function G01.GzInvStatics.IsConsumableItemType
// 0x000C (0x000C - 0x0000)
struct GzInvStatics_IsConsumableItemType final
{
public:
	struct FGameplayTag                           Type;                                              // 0x0000(0x0008)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_31E1[0x3];                                     // 0x0009(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GzInvStatics_IsConsumableItemType) == 0x000004, "Wrong alignment on GzInvStatics_IsConsumableItemType");
static_assert(sizeof(GzInvStatics_IsConsumableItemType) == 0x00000C, "Wrong size on GzInvStatics_IsConsumableItemType");
static_assert(offsetof(GzInvStatics_IsConsumableItemType, Type) == 0x000000, "Member 'GzInvStatics_IsConsumableItemType::Type' has a wrong offset!");
static_assert(offsetof(GzInvStatics_IsConsumableItemType, ReturnValue) == 0x000008, "Member 'GzInvStatics_IsConsumableItemType::ReturnValue' has a wrong offset!");

// Function G01.GzInvStatics.IsEmptyPocket
// 0x0030 (0x0030 - 0x0000)
struct GzInvStatics_IsEmptyPocket final
{
public:
	struct FGzInvPocket                           Pocket;                                            // 0x0000(0x0028)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0028(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_31E2[0x7];                                     // 0x0029(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GzInvStatics_IsEmptyPocket) == 0x000008, "Wrong alignment on GzInvStatics_IsEmptyPocket");
static_assert(sizeof(GzInvStatics_IsEmptyPocket) == 0x000030, "Wrong size on GzInvStatics_IsEmptyPocket");
static_assert(offsetof(GzInvStatics_IsEmptyPocket, Pocket) == 0x000000, "Member 'GzInvStatics_IsEmptyPocket::Pocket' has a wrong offset!");
static_assert(offsetof(GzInvStatics_IsEmptyPocket, ReturnValue) == 0x000028, "Member 'GzInvStatics_IsEmptyPocket::ReturnValue' has a wrong offset!");

// Function G01.GzInvStatics.IsEqualPocketIds
// 0x0014 (0x0014 - 0x0000)
struct GzInvStatics_IsEqualPocketIds final
{
public:
	struct FGzInvPocketId                         LHS;                                               // 0x0000(0x0008)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGzInvPocketId                         RHS;                                               // 0x0008(0x0008)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0010(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_31E3[0x3];                                     // 0x0011(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GzInvStatics_IsEqualPocketIds) == 0x000004, "Wrong alignment on GzInvStatics_IsEqualPocketIds");
static_assert(sizeof(GzInvStatics_IsEqualPocketIds) == 0x000014, "Wrong size on GzInvStatics_IsEqualPocketIds");
static_assert(offsetof(GzInvStatics_IsEqualPocketIds, LHS) == 0x000000, "Member 'GzInvStatics_IsEqualPocketIds::LHS' has a wrong offset!");
static_assert(offsetof(GzInvStatics_IsEqualPocketIds, RHS) == 0x000008, "Member 'GzInvStatics_IsEqualPocketIds::RHS' has a wrong offset!");
static_assert(offsetof(GzInvStatics_IsEqualPocketIds, ReturnValue) == 0x000010, "Member 'GzInvStatics_IsEqualPocketIds::ReturnValue' has a wrong offset!");

// Function G01.GzInvStatics.IsInGameCurrencyItemType
// 0x000C (0x000C - 0x0000)
struct GzInvStatics_IsInGameCurrencyItemType final
{
public:
	struct FGameplayTag                           Type;                                              // 0x0000(0x0008)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_31E4[0x3];                                     // 0x0009(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GzInvStatics_IsInGameCurrencyItemType) == 0x000004, "Wrong alignment on GzInvStatics_IsInGameCurrencyItemType");
static_assert(sizeof(GzInvStatics_IsInGameCurrencyItemType) == 0x00000C, "Wrong size on GzInvStatics_IsInGameCurrencyItemType");
static_assert(offsetof(GzInvStatics_IsInGameCurrencyItemType, Type) == 0x000000, "Member 'GzInvStatics_IsInGameCurrencyItemType::Type' has a wrong offset!");
static_assert(offsetof(GzInvStatics_IsInGameCurrencyItemType, ReturnValue) == 0x000008, "Member 'GzInvStatics_IsInGameCurrencyItemType::ReturnValue' has a wrong offset!");

// Function G01.GzInvStatics.IsLimbItemType
// 0x000C (0x000C - 0x0000)
struct GzInvStatics_IsLimbItemType final
{
public:
	struct FGameplayTag                           Type;                                              // 0x0000(0x0008)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_31E5[0x3];                                     // 0x0009(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GzInvStatics_IsLimbItemType) == 0x000004, "Wrong alignment on GzInvStatics_IsLimbItemType");
static_assert(sizeof(GzInvStatics_IsLimbItemType) == 0x00000C, "Wrong size on GzInvStatics_IsLimbItemType");
static_assert(offsetof(GzInvStatics_IsLimbItemType, Type) == 0x000000, "Member 'GzInvStatics_IsLimbItemType::Type' has a wrong offset!");
static_assert(offsetof(GzInvStatics_IsLimbItemType, ReturnValue) == 0x000008, "Member 'GzInvStatics_IsLimbItemType::ReturnValue' has a wrong offset!");

// Function G01.GzInvStatics.IsPrimaryWeaponItemType
// 0x000C (0x000C - 0x0000)
struct GzInvStatics_IsPrimaryWeaponItemType final
{
public:
	struct FGameplayTag                           Type;                                              // 0x0000(0x0008)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_31E6[0x3];                                     // 0x0009(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GzInvStatics_IsPrimaryWeaponItemType) == 0x000004, "Wrong alignment on GzInvStatics_IsPrimaryWeaponItemType");
static_assert(sizeof(GzInvStatics_IsPrimaryWeaponItemType) == 0x00000C, "Wrong size on GzInvStatics_IsPrimaryWeaponItemType");
static_assert(offsetof(GzInvStatics_IsPrimaryWeaponItemType, Type) == 0x000000, "Member 'GzInvStatics_IsPrimaryWeaponItemType::Type' has a wrong offset!");
static_assert(offsetof(GzInvStatics_IsPrimaryWeaponItemType, ReturnValue) == 0x000008, "Member 'GzInvStatics_IsPrimaryWeaponItemType::ReturnValue' has a wrong offset!");

// Function G01.GzInvStatics.IsSidearmItemType
// 0x000C (0x000C - 0x0000)
struct GzInvStatics_IsSidearmItemType final
{
public:
	struct FGameplayTag                           Type;                                              // 0x0000(0x0008)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_31E7[0x3];                                     // 0x0009(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GzInvStatics_IsSidearmItemType) == 0x000004, "Wrong alignment on GzInvStatics_IsSidearmItemType");
static_assert(sizeof(GzInvStatics_IsSidearmItemType) == 0x00000C, "Wrong size on GzInvStatics_IsSidearmItemType");
static_assert(offsetof(GzInvStatics_IsSidearmItemType, Type) == 0x000000, "Member 'GzInvStatics_IsSidearmItemType::Type' has a wrong offset!");
static_assert(offsetof(GzInvStatics_IsSidearmItemType, ReturnValue) == 0x000008, "Member 'GzInvStatics_IsSidearmItemType::ReturnValue' has a wrong offset!");

// Function G01.GzInvStatics.IsValidItem
// 0x0018 (0x0018 - 0x0000)
struct GzInvStatics_IsValidItem final
{
public:
	struct FGzInvItem                             Item;                                              // 0x0000(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0010(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_31E8[0x7];                                     // 0x0011(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GzInvStatics_IsValidItem) == 0x000008, "Wrong alignment on GzInvStatics_IsValidItem");
static_assert(sizeof(GzInvStatics_IsValidItem) == 0x000018, "Wrong size on GzInvStatics_IsValidItem");
static_assert(offsetof(GzInvStatics_IsValidItem, Item) == 0x000000, "Member 'GzInvStatics_IsValidItem::Item' has a wrong offset!");
static_assert(offsetof(GzInvStatics_IsValidItem, ReturnValue) == 0x000010, "Member 'GzInvStatics_IsValidItem::ReturnValue' has a wrong offset!");

// Function G01.GzInvStatics.IsValidPocket
// 0x0030 (0x0030 - 0x0000)
struct GzInvStatics_IsValidPocket final
{
public:
	struct FGzInvPocket                           Pocket;                                            // 0x0000(0x0028)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0028(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_31E9[0x7];                                     // 0x0029(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GzInvStatics_IsValidPocket) == 0x000008, "Wrong alignment on GzInvStatics_IsValidPocket");
static_assert(sizeof(GzInvStatics_IsValidPocket) == 0x000030, "Wrong size on GzInvStatics_IsValidPocket");
static_assert(offsetof(GzInvStatics_IsValidPocket, Pocket) == 0x000000, "Member 'GzInvStatics_IsValidPocket::Pocket' has a wrong offset!");
static_assert(offsetof(GzInvStatics_IsValidPocket, ReturnValue) == 0x000028, "Member 'GzInvStatics_IsValidPocket::ReturnValue' has a wrong offset!");

// Function G01.GzInvStatics.IsWeaponItemType
// 0x000C (0x000C - 0x0000)
struct GzInvStatics_IsWeaponItemType final
{
public:
	struct FGameplayTag                           Type;                                              // 0x0000(0x0008)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_31EA[0x3];                                     // 0x0009(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GzInvStatics_IsWeaponItemType) == 0x000004, "Wrong alignment on GzInvStatics_IsWeaponItemType");
static_assert(sizeof(GzInvStatics_IsWeaponItemType) == 0x00000C, "Wrong size on GzInvStatics_IsWeaponItemType");
static_assert(offsetof(GzInvStatics_IsWeaponItemType, Type) == 0x000000, "Member 'GzInvStatics_IsWeaponItemType::Type' has a wrong offset!");
static_assert(offsetof(GzInvStatics_IsWeaponItemType, ReturnValue) == 0x000008, "Member 'GzInvStatics_IsWeaponItemType::ReturnValue' has a wrong offset!");

// Function G01.GzInvStatics.MakeItemFromContent
// 0x0058 (0x0058 - 0x0000)
struct GzInvStatics_MakeItemFromContent final
{
public:
	struct FGzInventoryItemContent                Content;                                           // 0x0000(0x0048)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	struct FGzInvItem                             ReturnValue;                                       // 0x0048(0x0010)(Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzInvStatics_MakeItemFromContent) == 0x000008, "Wrong alignment on GzInvStatics_MakeItemFromContent");
static_assert(sizeof(GzInvStatics_MakeItemFromContent) == 0x000058, "Wrong size on GzInvStatics_MakeItemFromContent");
static_assert(offsetof(GzInvStatics_MakeItemFromContent, Content) == 0x000000, "Member 'GzInvStatics_MakeItemFromContent::Content' has a wrong offset!");
static_assert(offsetof(GzInvStatics_MakeItemFromContent, ReturnValue) == 0x000048, "Member 'GzInvStatics_MakeItemFromContent::ReturnValue' has a wrong offset!");

// Function G01.GzInvStatics.MakeItemFromLimb
// 0x0068 (0x0068 - 0x0000)
struct GzInvStatics_MakeItemFromLimb final
{
public:
	struct FGzLimbInvItem                         Item;                                              // 0x0000(0x0058)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	struct FGzInvItem                             ReturnValue;                                       // 0x0058(0x0010)(Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzInvStatics_MakeItemFromLimb) == 0x000008, "Wrong alignment on GzInvStatics_MakeItemFromLimb");
static_assert(sizeof(GzInvStatics_MakeItemFromLimb) == 0x000068, "Wrong size on GzInvStatics_MakeItemFromLimb");
static_assert(offsetof(GzInvStatics_MakeItemFromLimb, Item) == 0x000000, "Member 'GzInvStatics_MakeItemFromLimb::Item' has a wrong offset!");
static_assert(offsetof(GzInvStatics_MakeItemFromLimb, ReturnValue) == 0x000058, "Member 'GzInvStatics_MakeItemFromLimb::ReturnValue' has a wrong offset!");

// Function G01.GzInvStatics.MakeItemFromSimple
// 0x0048 (0x0048 - 0x0000)
struct GzInvStatics_MakeItemFromSimple final
{
public:
	struct FGzSimpleInvItem                       Item;                                              // 0x0000(0x0038)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	struct FGzInvItem                             ReturnValue;                                       // 0x0038(0x0010)(Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzInvStatics_MakeItemFromSimple) == 0x000008, "Wrong alignment on GzInvStatics_MakeItemFromSimple");
static_assert(sizeof(GzInvStatics_MakeItemFromSimple) == 0x000048, "Wrong size on GzInvStatics_MakeItemFromSimple");
static_assert(offsetof(GzInvStatics_MakeItemFromSimple, Item) == 0x000000, "Member 'GzInvStatics_MakeItemFromSimple::Item' has a wrong offset!");
static_assert(offsetof(GzInvStatics_MakeItemFromSimple, ReturnValue) == 0x000038, "Member 'GzInvStatics_MakeItemFromSimple::ReturnValue' has a wrong offset!");

// Function G01.GzInvStatics.MakeItemFromWeapon
// 0x0060 (0x0060 - 0x0000)
struct GzInvStatics_MakeItemFromWeapon final
{
public:
	struct FGzWeaponInvItem                       Item;                                              // 0x0000(0x0050)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	struct FGzInvItem                             ReturnValue;                                       // 0x0050(0x0010)(Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzInvStatics_MakeItemFromWeapon) == 0x000008, "Wrong alignment on GzInvStatics_MakeItemFromWeapon");
static_assert(sizeof(GzInvStatics_MakeItemFromWeapon) == 0x000060, "Wrong size on GzInvStatics_MakeItemFromWeapon");
static_assert(offsetof(GzInvStatics_MakeItemFromWeapon, Item) == 0x000000, "Member 'GzInvStatics_MakeItemFromWeapon::Item' has a wrong offset!");
static_assert(offsetof(GzInvStatics_MakeItemFromWeapon, ReturnValue) == 0x000050, "Member 'GzInvStatics_MakeItemFromWeapon::ReturnValue' has a wrong offset!");

// Function G01.GzInvStatics.MatchItemToType
// 0x0020 (0x0020 - 0x0000)
struct GzInvStatics_MatchItemToType final
{
public:
	struct FGzInvItem                             Item;                                              // 0x0000(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	struct FGameplayTag                           ItemType;                                          // 0x0010(0x0008)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0018(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_31EB[0x7];                                     // 0x0019(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GzInvStatics_MatchItemToType) == 0x000008, "Wrong alignment on GzInvStatics_MatchItemToType");
static_assert(sizeof(GzInvStatics_MatchItemToType) == 0x000020, "Wrong size on GzInvStatics_MatchItemToType");
static_assert(offsetof(GzInvStatics_MatchItemToType, Item) == 0x000000, "Member 'GzInvStatics_MatchItemToType::Item' has a wrong offset!");
static_assert(offsetof(GzInvStatics_MatchItemToType, ItemType) == 0x000010, "Member 'GzInvStatics_MatchItemToType::ItemType' has a wrong offset!");
static_assert(offsetof(GzInvStatics_MatchItemToType, ReturnValue) == 0x000018, "Member 'GzInvStatics_MatchItemToType::ReturnValue' has a wrong offset!");

// Function G01.GzInvStatics.SubscribeToInventoryItemChange
// 0x0038 (0x0038 - 0x0000)
struct GzInvStatics_SubscribeToInventoryItemChange final
{
public:
	class UGzInvComponent*                        Inventory;                                         // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGzItemChangeHandle                    Handle;                                            // 0x0008(0x000C)(Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TDelegate<void(struct FGzInvItem& Item, EGzInvChangeEvent ChangeEvent)> Filter;                                            // 0x0014(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TDelegate<void(struct FGzInvItem& ItemDelta, EGzInvChangeEvent Event)> Callback;                                          // 0x0024(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_31EC[0x4];                                     // 0x0034(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GzInvStatics_SubscribeToInventoryItemChange) == 0x000008, "Wrong alignment on GzInvStatics_SubscribeToInventoryItemChange");
static_assert(sizeof(GzInvStatics_SubscribeToInventoryItemChange) == 0x000038, "Wrong size on GzInvStatics_SubscribeToInventoryItemChange");
static_assert(offsetof(GzInvStatics_SubscribeToInventoryItemChange, Inventory) == 0x000000, "Member 'GzInvStatics_SubscribeToInventoryItemChange::Inventory' has a wrong offset!");
static_assert(offsetof(GzInvStatics_SubscribeToInventoryItemChange, Handle) == 0x000008, "Member 'GzInvStatics_SubscribeToInventoryItemChange::Handle' has a wrong offset!");
static_assert(offsetof(GzInvStatics_SubscribeToInventoryItemChange, Filter) == 0x000014, "Member 'GzInvStatics_SubscribeToInventoryItemChange::Filter' has a wrong offset!");
static_assert(offsetof(GzInvStatics_SubscribeToInventoryItemChange, Callback) == 0x000024, "Member 'GzInvStatics_SubscribeToInventoryItemChange::Callback' has a wrong offset!");

// Function G01.GzInvStatics.SubscribeToInventoryPocketChange
// 0x0038 (0x0038 - 0x0000)
struct GzInvStatics_SubscribeToInventoryPocketChange final
{
public:
	class UGzInvComponent*                        Inventory;                                         // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGzPocketChangeHandle                  Handle;                                            // 0x0008(0x000C)(Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TDelegate<void(struct FGzInvPocketDef& PocketDef, struct FGzInvPocket& Pocket)> Filter;                                            // 0x0014(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TDelegate<void(struct FGzInvPocketChangeData& PocketChangeData)> Callback;                                          // 0x0024(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_31ED[0x4];                                     // 0x0034(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GzInvStatics_SubscribeToInventoryPocketChange) == 0x000008, "Wrong alignment on GzInvStatics_SubscribeToInventoryPocketChange");
static_assert(sizeof(GzInvStatics_SubscribeToInventoryPocketChange) == 0x000038, "Wrong size on GzInvStatics_SubscribeToInventoryPocketChange");
static_assert(offsetof(GzInvStatics_SubscribeToInventoryPocketChange, Inventory) == 0x000000, "Member 'GzInvStatics_SubscribeToInventoryPocketChange::Inventory' has a wrong offset!");
static_assert(offsetof(GzInvStatics_SubscribeToInventoryPocketChange, Handle) == 0x000008, "Member 'GzInvStatics_SubscribeToInventoryPocketChange::Handle' has a wrong offset!");
static_assert(offsetof(GzInvStatics_SubscribeToInventoryPocketChange, Filter) == 0x000014, "Member 'GzInvStatics_SubscribeToInventoryPocketChange::Filter' has a wrong offset!");
static_assert(offsetof(GzInvStatics_SubscribeToInventoryPocketChange, Callback) == 0x000024, "Member 'GzInvStatics_SubscribeToInventoryPocketChange::Callback' has a wrong offset!");

// Function G01.GzInvStatics.TryConsumeInGameCurrency
// 0x0010 (0x0010 - 0x0000)
struct GzInvStatics_TryConsumeInGameCurrency final
{
public:
	class UGzInvComponent*                        Inventory;                                         // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Quantity;                                          // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x000C(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_31EE[0x3];                                     // 0x000D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GzInvStatics_TryConsumeInGameCurrency) == 0x000008, "Wrong alignment on GzInvStatics_TryConsumeInGameCurrency");
static_assert(sizeof(GzInvStatics_TryConsumeInGameCurrency) == 0x000010, "Wrong size on GzInvStatics_TryConsumeInGameCurrency");
static_assert(offsetof(GzInvStatics_TryConsumeInGameCurrency, Inventory) == 0x000000, "Member 'GzInvStatics_TryConsumeInGameCurrency::Inventory' has a wrong offset!");
static_assert(offsetof(GzInvStatics_TryConsumeInGameCurrency, Quantity) == 0x000008, "Member 'GzInvStatics_TryConsumeInGameCurrency::Quantity' has a wrong offset!");
static_assert(offsetof(GzInvStatics_TryConsumeInGameCurrency, ReturnValue) == 0x00000C, "Member 'GzInvStatics_TryConsumeInGameCurrency::ReturnValue' has a wrong offset!");

// Function G01.GzInvStatics.UnsubscribeFromItemChange
// 0x000C (0x000C - 0x0000)
struct GzInvStatics_UnsubscribeFromItemChange final
{
public:
	struct FGzItemChangeHandle                    Handle;                                            // 0x0000(0x000C)(Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzInvStatics_UnsubscribeFromItemChange) == 0x000004, "Wrong alignment on GzInvStatics_UnsubscribeFromItemChange");
static_assert(sizeof(GzInvStatics_UnsubscribeFromItemChange) == 0x00000C, "Wrong size on GzInvStatics_UnsubscribeFromItemChange");
static_assert(offsetof(GzInvStatics_UnsubscribeFromItemChange, Handle) == 0x000000, "Member 'GzInvStatics_UnsubscribeFromItemChange::Handle' has a wrong offset!");

// Function G01.GzInvStatics.UnsubscribeFromPocketChange
// 0x000C (0x000C - 0x0000)
struct GzInvStatics_UnsubscribeFromPocketChange final
{
public:
	struct FGzPocketChangeHandle                  Handle;                                            // 0x0000(0x000C)(Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzInvStatics_UnsubscribeFromPocketChange) == 0x000004, "Wrong alignment on GzInvStatics_UnsubscribeFromPocketChange");
static_assert(sizeof(GzInvStatics_UnsubscribeFromPocketChange) == 0x00000C, "Wrong size on GzInvStatics_UnsubscribeFromPocketChange");
static_assert(offsetof(GzInvStatics_UnsubscribeFromPocketChange, Handle) == 0x000000, "Member 'GzInvStatics_UnsubscribeFromPocketChange::Handle' has a wrong offset!");

// Function G01.GzDestructibleHeatSink.OnMultiHit
// 0x0050 (0x0050 - 0x0000)
struct GzDestructibleHeatSink_OnMultiHit final
{
public:
	class UGzDamageableComponent*                 Receiver;                                          // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGzMultiHitDamage                      MultiHit;                                          // 0x0008(0x0048)(ConstParm, Parm, OutParm, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzDestructibleHeatSink_OnMultiHit) == 0x000008, "Wrong alignment on GzDestructibleHeatSink_OnMultiHit");
static_assert(sizeof(GzDestructibleHeatSink_OnMultiHit) == 0x000050, "Wrong size on GzDestructibleHeatSink_OnMultiHit");
static_assert(offsetof(GzDestructibleHeatSink_OnMultiHit, Receiver) == 0x000000, "Member 'GzDestructibleHeatSink_OnMultiHit::Receiver' has a wrong offset!");
static_assert(offsetof(GzDestructibleHeatSink_OnMultiHit, MultiHit) == 0x000008, "Member 'GzDestructibleHeatSink_OnMultiHit::MultiHit' has a wrong offset!");

// Function G01.GzDestructibleHeatSink.OnSingleHit
// 0x01F8 (0x01F8 - 0x0000)
struct GzDestructibleHeatSink_OnSingleHit final
{
public:
	class UGzDamageableComponent*                 Receiver;                                          // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGzSingleHitDamage                     SingleHit;                                         // 0x0008(0x01F0)(ConstParm, Parm, OutParm, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzDestructibleHeatSink_OnSingleHit) == 0x000008, "Wrong alignment on GzDestructibleHeatSink_OnSingleHit");
static_assert(sizeof(GzDestructibleHeatSink_OnSingleHit) == 0x0001F8, "Wrong size on GzDestructibleHeatSink_OnSingleHit");
static_assert(offsetof(GzDestructibleHeatSink_OnSingleHit, Receiver) == 0x000000, "Member 'GzDestructibleHeatSink_OnSingleHit::Receiver' has a wrong offset!");
static_assert(offsetof(GzDestructibleHeatSink_OnSingleHit, SingleHit) == 0x000008, "Member 'GzDestructibleHeatSink_OnSingleHit::SingleHit' has a wrong offset!");

// Function G01.GzDestructibleHeatSink.ReceiveDestroy
// 0x0100 (0x0100 - 0x0000)
struct GzDestructibleHeatSink_ReceiveDestroy final
{
public:
	struct FHitResult                             HitResult;                                         // 0x0000(0x00F8)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	bool                                          bInstant;                                          // 0x00F8(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_31F0[0x7];                                     // 0x00F9(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GzDestructibleHeatSink_ReceiveDestroy) == 0x000008, "Wrong alignment on GzDestructibleHeatSink_ReceiveDestroy");
static_assert(sizeof(GzDestructibleHeatSink_ReceiveDestroy) == 0x000100, "Wrong size on GzDestructibleHeatSink_ReceiveDestroy");
static_assert(offsetof(GzDestructibleHeatSink_ReceiveDestroy, HitResult) == 0x000000, "Member 'GzDestructibleHeatSink_ReceiveDestroy::HitResult' has a wrong offset!");
static_assert(offsetof(GzDestructibleHeatSink_ReceiveDestroy, bInstant) == 0x0000F8, "Member 'GzDestructibleHeatSink_ReceiveDestroy::bInstant' has a wrong offset!");

// Function G01.GzDestructibleHeatSink.SetOwningTeam
// 0x0004 (0x0004 - 0x0000)
struct GzDestructibleHeatSink_SetOwningTeam final
{
public:
	int32                                         TeamID;                                            // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzDestructibleHeatSink_SetOwningTeam) == 0x000004, "Wrong alignment on GzDestructibleHeatSink_SetOwningTeam");
static_assert(sizeof(GzDestructibleHeatSink_SetOwningTeam) == 0x000004, "Wrong size on GzDestructibleHeatSink_SetOwningTeam");
static_assert(offsetof(GzDestructibleHeatSink_SetOwningTeam, TeamID) == 0x000000, "Member 'GzDestructibleHeatSink_SetOwningTeam::TeamID' has a wrong offset!");

// Function G01.GzDestructibleHeatSink.IsDestroyed
// 0x0001 (0x0001 - 0x0000)
struct GzDestructibleHeatSink_IsDestroyed final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzDestructibleHeatSink_IsDestroyed) == 0x000001, "Wrong alignment on GzDestructibleHeatSink_IsDestroyed");
static_assert(sizeof(GzDestructibleHeatSink_IsDestroyed) == 0x000001, "Wrong size on GzDestructibleHeatSink_IsDestroyed");
static_assert(offsetof(GzDestructibleHeatSink_IsDestroyed, ReturnValue) == 0x000000, "Member 'GzDestructibleHeatSink_IsDestroyed::ReturnValue' has a wrong offset!");

// Function G01.GzRewardData.GetIdentifierString
// 0x0010 (0x0010 - 0x0000)
struct GzRewardData_GetIdentifierString final
{
public:
	class FString                                 ReturnValue;                                       // 0x0000(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzRewardData_GetIdentifierString) == 0x000008, "Wrong alignment on GzRewardData_GetIdentifierString");
static_assert(sizeof(GzRewardData_GetIdentifierString) == 0x000010, "Wrong size on GzRewardData_GetIdentifierString");
static_assert(offsetof(GzRewardData_GetIdentifierString, ReturnValue) == 0x000000, "Member 'GzRewardData_GetIdentifierString::ReturnValue' has a wrong offset!");

// Function G01.GzDomeShield.SpawnBulletImpactVFX
// 0x0030 (0x0030 - 0x0000)
struct GzDomeShield_SpawnBulletImpactVFX final
{
public:
	struct FVector                                HitLocation;                                       // 0x0000(0x0018)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               HitRotation;                                       // 0x0018(0x0018)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzDomeShield_SpawnBulletImpactVFX) == 0x000008, "Wrong alignment on GzDomeShield_SpawnBulletImpactVFX");
static_assert(sizeof(GzDomeShield_SpawnBulletImpactVFX) == 0x000030, "Wrong size on GzDomeShield_SpawnBulletImpactVFX");
static_assert(offsetof(GzDomeShield_SpawnBulletImpactVFX, HitLocation) == 0x000000, "Member 'GzDomeShield_SpawnBulletImpactVFX::HitLocation' has a wrong offset!");
static_assert(offsetof(GzDomeShield_SpawnBulletImpactVFX, HitRotation) == 0x000018, "Member 'GzDomeShield_SpawnBulletImpactVFX::HitRotation' has a wrong offset!");

// Function G01.GzDoorBase.GetShowInteractionTooltipIfDisabled
// 0x0001 (0x0001 - 0x0000)
struct GzDoorBase_GetShowInteractionTooltipIfDisabled final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzDoorBase_GetShowInteractionTooltipIfDisabled) == 0x000001, "Wrong alignment on GzDoorBase_GetShowInteractionTooltipIfDisabled");
static_assert(sizeof(GzDoorBase_GetShowInteractionTooltipIfDisabled) == 0x000001, "Wrong size on GzDoorBase_GetShowInteractionTooltipIfDisabled");
static_assert(offsetof(GzDoorBase_GetShowInteractionTooltipIfDisabled, ReturnValue) == 0x000000, "Member 'GzDoorBase_GetShowInteractionTooltipIfDisabled::ReturnValue' has a wrong offset!");

// Function G01.GzDoorBase.OnComponentBeginOverlap
// 0x0118 (0x0118 - 0x0000)
struct GzDoorBase_OnComponentBeginOverlap final
{
public:
	class UPrimitiveComponent*                    OverlappedComponent;                               // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 OtherActor;                                        // 0x0008(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UPrimitiveComponent*                    OtherComp;                                         // 0x0010(0x0008)(Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         OtherBodyIndex;                                    // 0x0018(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bFromSweep;                                        // 0x001C(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_31F6[0x3];                                     // 0x001D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FHitResult                             SweepResult;                                       // 0x0020(0x00F8)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzDoorBase_OnComponentBeginOverlap) == 0x000008, "Wrong alignment on GzDoorBase_OnComponentBeginOverlap");
static_assert(sizeof(GzDoorBase_OnComponentBeginOverlap) == 0x000118, "Wrong size on GzDoorBase_OnComponentBeginOverlap");
static_assert(offsetof(GzDoorBase_OnComponentBeginOverlap, OverlappedComponent) == 0x000000, "Member 'GzDoorBase_OnComponentBeginOverlap::OverlappedComponent' has a wrong offset!");
static_assert(offsetof(GzDoorBase_OnComponentBeginOverlap, OtherActor) == 0x000008, "Member 'GzDoorBase_OnComponentBeginOverlap::OtherActor' has a wrong offset!");
static_assert(offsetof(GzDoorBase_OnComponentBeginOverlap, OtherComp) == 0x000010, "Member 'GzDoorBase_OnComponentBeginOverlap::OtherComp' has a wrong offset!");
static_assert(offsetof(GzDoorBase_OnComponentBeginOverlap, OtherBodyIndex) == 0x000018, "Member 'GzDoorBase_OnComponentBeginOverlap::OtherBodyIndex' has a wrong offset!");
static_assert(offsetof(GzDoorBase_OnComponentBeginOverlap, bFromSweep) == 0x00001C, "Member 'GzDoorBase_OnComponentBeginOverlap::bFromSweep' has a wrong offset!");
static_assert(offsetof(GzDoorBase_OnComponentBeginOverlap, SweepResult) == 0x000020, "Member 'GzDoorBase_OnComponentBeginOverlap::SweepResult' has a wrong offset!");

// Function G01.GzDoorBase.OnComponentEndOverlap
// 0x0020 (0x0020 - 0x0000)
struct GzDoorBase_OnComponentEndOverlap final
{
public:
	class UPrimitiveComponent*                    OverlappedComponent;                               // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 OtherActor;                                        // 0x0008(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UPrimitiveComponent*                    OtherComp;                                         // 0x0010(0x0008)(Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         OtherBodyIndex;                                    // 0x0018(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_31F7[0x4];                                     // 0x001C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GzDoorBase_OnComponentEndOverlap) == 0x000008, "Wrong alignment on GzDoorBase_OnComponentEndOverlap");
static_assert(sizeof(GzDoorBase_OnComponentEndOverlap) == 0x000020, "Wrong size on GzDoorBase_OnComponentEndOverlap");
static_assert(offsetof(GzDoorBase_OnComponentEndOverlap, OverlappedComponent) == 0x000000, "Member 'GzDoorBase_OnComponentEndOverlap::OverlappedComponent' has a wrong offset!");
static_assert(offsetof(GzDoorBase_OnComponentEndOverlap, OtherActor) == 0x000008, "Member 'GzDoorBase_OnComponentEndOverlap::OtherActor' has a wrong offset!");
static_assert(offsetof(GzDoorBase_OnComponentEndOverlap, OtherComp) == 0x000010, "Member 'GzDoorBase_OnComponentEndOverlap::OtherComp' has a wrong offset!");
static_assert(offsetof(GzDoorBase_OnComponentEndOverlap, OtherBodyIndex) == 0x000018, "Member 'GzDoorBase_OnComponentEndOverlap::OtherBodyIndex' has a wrong offset!");

// Function G01.GzDoorBase.OnInteract
// 0x0010 (0x0010 - 0x0000)
struct GzDoorBase_OnInteract final
{
public:
	class AActor*                                 InteractedBy;                                      // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	const class UGzInteractableComponent*         Interactable;                                      // 0x0008(0x0008)(ConstParm, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzDoorBase_OnInteract) == 0x000008, "Wrong alignment on GzDoorBase_OnInteract");
static_assert(sizeof(GzDoorBase_OnInteract) == 0x000010, "Wrong size on GzDoorBase_OnInteract");
static_assert(offsetof(GzDoorBase_OnInteract, InteractedBy) == 0x000000, "Member 'GzDoorBase_OnInteract::InteractedBy' has a wrong offset!");
static_assert(offsetof(GzDoorBase_OnInteract, Interactable) == 0x000008, "Member 'GzDoorBase_OnInteract::Interactable' has a wrong offset!");

// Function G01.GzDoorBase.OnRep_State
// 0x0001 (0x0001 - 0x0000)
struct GzDoorBase_OnRep_State final
{
public:
	EGzDoorState                                  OldState;                                          // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzDoorBase_OnRep_State) == 0x000001, "Wrong alignment on GzDoorBase_OnRep_State");
static_assert(sizeof(GzDoorBase_OnRep_State) == 0x000001, "Wrong size on GzDoorBase_OnRep_State");
static_assert(offsetof(GzDoorBase_OnRep_State, OldState) == 0x000000, "Member 'GzDoorBase_OnRep_State::OldState' has a wrong offset!");

// Function G01.GzDoorBase.ReceiveDynamicStateChanged
// 0x0001 (0x0001 - 0x0000)
struct GzDoorBase_ReceiveDynamicStateChanged final
{
public:
	bool                                          bOpening;                                          // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzDoorBase_ReceiveDynamicStateChanged) == 0x000001, "Wrong alignment on GzDoorBase_ReceiveDynamicStateChanged");
static_assert(sizeof(GzDoorBase_ReceiveDynamicStateChanged) == 0x000001, "Wrong size on GzDoorBase_ReceiveDynamicStateChanged");
static_assert(offsetof(GzDoorBase_ReceiveDynamicStateChanged, bOpening) == 0x000000, "Member 'GzDoorBase_ReceiveDynamicStateChanged::bOpening' has a wrong offset!");

// Function G01.GzDoorBase.ReceiveLockedStateChanged
// 0x0001 (0x0001 - 0x0000)
struct GzDoorBase_ReceiveLockedStateChanged final
{
public:
	bool                                          bNewLocked;                                        // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzDoorBase_ReceiveLockedStateChanged) == 0x000001, "Wrong alignment on GzDoorBase_ReceiveLockedStateChanged");
static_assert(sizeof(GzDoorBase_ReceiveLockedStateChanged) == 0x000001, "Wrong size on GzDoorBase_ReceiveLockedStateChanged");
static_assert(offsetof(GzDoorBase_ReceiveLockedStateChanged, bNewLocked) == 0x000000, "Member 'GzDoorBase_ReceiveLockedStateChanged::bNewLocked' has a wrong offset!");

// Function G01.GzDoorBase.ReceiveStaticStateChanged
// 0x0001 (0x0001 - 0x0000)
struct GzDoorBase_ReceiveStaticStateChanged final
{
public:
	bool                                          bOpened;                                           // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzDoorBase_ReceiveStaticStateChanged) == 0x000001, "Wrong alignment on GzDoorBase_ReceiveStaticStateChanged");
static_assert(sizeof(GzDoorBase_ReceiveStaticStateChanged) == 0x000001, "Wrong size on GzDoorBase_ReceiveStaticStateChanged");
static_assert(offsetof(GzDoorBase_ReceiveStaticStateChanged, bOpened) == 0x000000, "Member 'GzDoorBase_ReceiveStaticStateChanged::bOpened' has a wrong offset!");

// Function G01.GzDoorBase.SetIsLocked
// 0x0001 (0x0001 - 0x0000)
struct GzDoorBase_SetIsLocked final
{
public:
	bool                                          bNewLocked;                                        // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzDoorBase_SetIsLocked) == 0x000001, "Wrong alignment on GzDoorBase_SetIsLocked");
static_assert(sizeof(GzDoorBase_SetIsLocked) == 0x000001, "Wrong size on GzDoorBase_SetIsLocked");
static_assert(offsetof(GzDoorBase_SetIsLocked, bNewLocked) == 0x000000, "Member 'GzDoorBase_SetIsLocked::bNewLocked' has a wrong offset!");

// Function G01.GzDoorBase.SetOpen
// 0x0001 (0x0001 - 0x0000)
struct GzDoorBase_SetOpen final
{
public:
	bool                                          bInOpen;                                           // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzDoorBase_SetOpen) == 0x000001, "Wrong alignment on GzDoorBase_SetOpen");
static_assert(sizeof(GzDoorBase_SetOpen) == 0x000001, "Wrong size on GzDoorBase_SetOpen");
static_assert(offsetof(GzDoorBase_SetOpen, bInOpen) == 0x000000, "Member 'GzDoorBase_SetOpen::bInOpen' has a wrong offset!");

// Function G01.GzDoorBase.SetShowInteractionTooltipIfDisabled
// 0x0001 (0x0001 - 0x0000)
struct GzDoorBase_SetShowInteractionTooltipIfDisabled final
{
public:
	bool                                          bNewShowTooltip;                                   // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzDoorBase_SetShowInteractionTooltipIfDisabled) == 0x000001, "Wrong alignment on GzDoorBase_SetShowInteractionTooltipIfDisabled");
static_assert(sizeof(GzDoorBase_SetShowInteractionTooltipIfDisabled) == 0x000001, "Wrong size on GzDoorBase_SetShowInteractionTooltipIfDisabled");
static_assert(offsetof(GzDoorBase_SetShowInteractionTooltipIfDisabled, bNewShowTooltip) == 0x000000, "Member 'GzDoorBase_SetShowInteractionTooltipIfDisabled::bNewShowTooltip' has a wrong offset!");

// Function G01.GzDoorBase.SetTransitionTime
// 0x0004 (0x0004 - 0x0000)
struct GzDoorBase_SetTransitionTime final
{
public:
	float                                         Time;                                              // 0x0000(0x0004)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzDoorBase_SetTransitionTime) == 0x000004, "Wrong alignment on GzDoorBase_SetTransitionTime");
static_assert(sizeof(GzDoorBase_SetTransitionTime) == 0x000004, "Wrong size on GzDoorBase_SetTransitionTime");
static_assert(offsetof(GzDoorBase_SetTransitionTime, Time) == 0x000000, "Member 'GzDoorBase_SetTransitionTime::Time' has a wrong offset!");

// Function G01.GzDoorBase.ShouldReactToOverlappedActor
// 0x0010 (0x0010 - 0x0000)
struct GzDoorBase_ShouldReactToOverlappedActor final
{
public:
	class AActor*                                 Actor;                                             // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_31F8[0x7];                                     // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GzDoorBase_ShouldReactToOverlappedActor) == 0x000008, "Wrong alignment on GzDoorBase_ShouldReactToOverlappedActor");
static_assert(sizeof(GzDoorBase_ShouldReactToOverlappedActor) == 0x000010, "Wrong size on GzDoorBase_ShouldReactToOverlappedActor");
static_assert(offsetof(GzDoorBase_ShouldReactToOverlappedActor, Actor) == 0x000000, "Member 'GzDoorBase_ShouldReactToOverlappedActor::Actor' has a wrong offset!");
static_assert(offsetof(GzDoorBase_ShouldReactToOverlappedActor, ReturnValue) == 0x000008, "Member 'GzDoorBase_ShouldReactToOverlappedActor::ReturnValue' has a wrong offset!");

// Function G01.GzDoorBase.GetDoorState
// 0x0001 (0x0001 - 0x0000)
struct GzDoorBase_GetDoorState final
{
public:
	EGzDoorState                                  ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzDoorBase_GetDoorState) == 0x000001, "Wrong alignment on GzDoorBase_GetDoorState");
static_assert(sizeof(GzDoorBase_GetDoorState) == 0x000001, "Wrong size on GzDoorBase_GetDoorState");
static_assert(offsetof(GzDoorBase_GetDoorState, ReturnValue) == 0x000000, "Member 'GzDoorBase_GetDoorState::ReturnValue' has a wrong offset!");

// Function G01.GzDoorBase.GetMontagePlaybackRate
// 0x0010 (0x0010 - 0x0000)
struct GzDoorBase_GetMontagePlaybackRate final
{
public:
	const class UAnimMontage*                     Montage;                                           // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ReturnValue;                                       // 0x0008(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_31F9[0x4];                                     // 0x000C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GzDoorBase_GetMontagePlaybackRate) == 0x000008, "Wrong alignment on GzDoorBase_GetMontagePlaybackRate");
static_assert(sizeof(GzDoorBase_GetMontagePlaybackRate) == 0x000010, "Wrong size on GzDoorBase_GetMontagePlaybackRate");
static_assert(offsetof(GzDoorBase_GetMontagePlaybackRate, Montage) == 0x000000, "Member 'GzDoorBase_GetMontagePlaybackRate::Montage' has a wrong offset!");
static_assert(offsetof(GzDoorBase_GetMontagePlaybackRate, ReturnValue) == 0x000008, "Member 'GzDoorBase_GetMontagePlaybackRate::ReturnValue' has a wrong offset!");

// Function G01.GzDoorBase.GetMontageStartingPosition
// 0x0010 (0x0010 - 0x0000)
struct GzDoorBase_GetMontageStartingPosition final
{
public:
	const class UAnimMontage*                     Montage;                                           // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bOpenMontage;                                      // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_31FA[0x3];                                     // 0x0009(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ReturnValue;                                       // 0x000C(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzDoorBase_GetMontageStartingPosition) == 0x000008, "Wrong alignment on GzDoorBase_GetMontageStartingPosition");
static_assert(sizeof(GzDoorBase_GetMontageStartingPosition) == 0x000010, "Wrong size on GzDoorBase_GetMontageStartingPosition");
static_assert(offsetof(GzDoorBase_GetMontageStartingPosition, Montage) == 0x000000, "Member 'GzDoorBase_GetMontageStartingPosition::Montage' has a wrong offset!");
static_assert(offsetof(GzDoorBase_GetMontageStartingPosition, bOpenMontage) == 0x000008, "Member 'GzDoorBase_GetMontageStartingPosition::bOpenMontage' has a wrong offset!");
static_assert(offsetof(GzDoorBase_GetMontageStartingPosition, ReturnValue) == 0x00000C, "Member 'GzDoorBase_GetMontageStartingPosition::ReturnValue' has a wrong offset!");

// Function G01.GzDoorBase.GetTransitionProgress
// 0x0004 (0x0004 - 0x0000)
struct GzDoorBase_GetTransitionProgress final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzDoorBase_GetTransitionProgress) == 0x000004, "Wrong alignment on GzDoorBase_GetTransitionProgress");
static_assert(sizeof(GzDoorBase_GetTransitionProgress) == 0x000004, "Wrong size on GzDoorBase_GetTransitionProgress");
static_assert(offsetof(GzDoorBase_GetTransitionProgress, ReturnValue) == 0x000000, "Member 'GzDoorBase_GetTransitionProgress::ReturnValue' has a wrong offset!");

// Function G01.GzDoorBase.GetTransitionTime
// 0x0004 (0x0004 - 0x0000)
struct GzDoorBase_GetTransitionTime final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzDoorBase_GetTransitionTime) == 0x000004, "Wrong alignment on GzDoorBase_GetTransitionTime");
static_assert(sizeof(GzDoorBase_GetTransitionTime) == 0x000004, "Wrong size on GzDoorBase_GetTransitionTime");
static_assert(offsetof(GzDoorBase_GetTransitionTime, ReturnValue) == 0x000000, "Member 'GzDoorBase_GetTransitionTime::ReturnValue' has a wrong offset!");

// Function G01.GzDoorBase.IsAutomaticDoor
// 0x0001 (0x0001 - 0x0000)
struct GzDoorBase_IsAutomaticDoor final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzDoorBase_IsAutomaticDoor) == 0x000001, "Wrong alignment on GzDoorBase_IsAutomaticDoor");
static_assert(sizeof(GzDoorBase_IsAutomaticDoor) == 0x000001, "Wrong size on GzDoorBase_IsAutomaticDoor");
static_assert(offsetof(GzDoorBase_IsAutomaticDoor, ReturnValue) == 0x000000, "Member 'GzDoorBase_IsAutomaticDoor::ReturnValue' has a wrong offset!");

// Function G01.GzDoorBase.IsCloseState
// 0x0001 (0x0001 - 0x0000)
struct GzDoorBase_IsCloseState final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzDoorBase_IsCloseState) == 0x000001, "Wrong alignment on GzDoorBase_IsCloseState");
static_assert(sizeof(GzDoorBase_IsCloseState) == 0x000001, "Wrong size on GzDoorBase_IsCloseState");
static_assert(offsetof(GzDoorBase_IsCloseState, ReturnValue) == 0x000000, "Member 'GzDoorBase_IsCloseState::ReturnValue' has a wrong offset!");

// Function G01.GzDoorBase.IsLocked
// 0x0001 (0x0001 - 0x0000)
struct GzDoorBase_IsLocked final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzDoorBase_IsLocked) == 0x000001, "Wrong alignment on GzDoorBase_IsLocked");
static_assert(sizeof(GzDoorBase_IsLocked) == 0x000001, "Wrong size on GzDoorBase_IsLocked");
static_assert(offsetof(GzDoorBase_IsLocked, ReturnValue) == 0x000000, "Member 'GzDoorBase_IsLocked::ReturnValue' has a wrong offset!");

// Function G01.GzDoorBase.IsOpenState
// 0x0001 (0x0001 - 0x0000)
struct GzDoorBase_IsOpenState final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzDoorBase_IsOpenState) == 0x000001, "Wrong alignment on GzDoorBase_IsOpenState");
static_assert(sizeof(GzDoorBase_IsOpenState) == 0x000001, "Wrong size on GzDoorBase_IsOpenState");
static_assert(offsetof(GzDoorBase_IsOpenState, ReturnValue) == 0x000000, "Member 'GzDoorBase_IsOpenState::ReturnValue' has a wrong offset!");

// Function G01.GzGA_QuickMeleeAttack.OnMeleeAttackAnimationNotification
// 0x0008 (0x0008 - 0x0000)
struct GzGA_QuickMeleeAttack_OnMeleeAttackAnimationNotification final
{
public:
	class FName                                   NotifyName;                                        // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzGA_QuickMeleeAttack_OnMeleeAttackAnimationNotification) == 0x000004, "Wrong alignment on GzGA_QuickMeleeAttack_OnMeleeAttackAnimationNotification");
static_assert(sizeof(GzGA_QuickMeleeAttack_OnMeleeAttackAnimationNotification) == 0x000008, "Wrong size on GzGA_QuickMeleeAttack_OnMeleeAttackAnimationNotification");
static_assert(offsetof(GzGA_QuickMeleeAttack_OnMeleeAttackAnimationNotification, NotifyName) == 0x000000, "Member 'GzGA_QuickMeleeAttack_OnMeleeAttackAnimationNotification::NotifyName' has a wrong offset!");

// Function G01.GzHexExtractionStartedMessage.SetTerminalLocation
// 0x0018 (0x0018 - 0x0000)
struct GzHexExtractionStartedMessage_SetTerminalLocation final
{
public:
	struct FVector                                Location;                                          // 0x0000(0x0018)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzHexExtractionStartedMessage_SetTerminalLocation) == 0x000008, "Wrong alignment on GzHexExtractionStartedMessage_SetTerminalLocation");
static_assert(sizeof(GzHexExtractionStartedMessage_SetTerminalLocation) == 0x000018, "Wrong size on GzHexExtractionStartedMessage_SetTerminalLocation");
static_assert(offsetof(GzHexExtractionStartedMessage_SetTerminalLocation, Location) == 0x000000, "Member 'GzHexExtractionStartedMessage_SetTerminalLocation::Location' has a wrong offset!");

// Function G01.GzHexExtractionStartedMessage.SetTime
// 0x0004 (0x0004 - 0x0000)
struct GzHexExtractionStartedMessage_SetTime final
{
public:
	float                                         InTime;                                            // 0x0000(0x0004)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzHexExtractionStartedMessage_SetTime) == 0x000004, "Wrong alignment on GzHexExtractionStartedMessage_SetTime");
static_assert(sizeof(GzHexExtractionStartedMessage_SetTime) == 0x000004, "Wrong size on GzHexExtractionStartedMessage_SetTime");
static_assert(offsetof(GzHexExtractionStartedMessage_SetTime, InTime) == 0x000000, "Member 'GzHexExtractionStartedMessage_SetTime::InTime' has a wrong offset!");

// Function G01.GzHexExtractionStartedMessage.GetTerminalLocation
// 0x0018 (0x0018 - 0x0000)
struct GzHexExtractionStartedMessage_GetTerminalLocation final
{
public:
	struct FVector                                ReturnValue;                                       // 0x0000(0x0018)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzHexExtractionStartedMessage_GetTerminalLocation) == 0x000008, "Wrong alignment on GzHexExtractionStartedMessage_GetTerminalLocation");
static_assert(sizeof(GzHexExtractionStartedMessage_GetTerminalLocation) == 0x000018, "Wrong size on GzHexExtractionStartedMessage_GetTerminalLocation");
static_assert(offsetof(GzHexExtractionStartedMessage_GetTerminalLocation, ReturnValue) == 0x000000, "Member 'GzHexExtractionStartedMessage_GetTerminalLocation::ReturnValue' has a wrong offset!");

// Function G01.GzHexExtractionStartedMessage.GetTime
// 0x0004 (0x0004 - 0x0000)
struct GzHexExtractionStartedMessage_GetTime final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzHexExtractionStartedMessage_GetTime) == 0x000004, "Wrong alignment on GzHexExtractionStartedMessage_GetTime");
static_assert(sizeof(GzHexExtractionStartedMessage_GetTime) == 0x000004, "Wrong size on GzHexExtractionStartedMessage_GetTime");
static_assert(offsetof(GzHexExtractionStartedMessage_GetTime, ReturnValue) == 0x000000, "Member 'GzHexExtractionStartedMessage_GetTime::ReturnValue' has a wrong offset!");

// Function G01.GzDroneGoblinSpawner.TriggerDroneSpawn
// 0x0008 (0x0008 - 0x0000)
struct GzDroneGoblinSpawner_TriggerDroneSpawn final
{
public:
	class AGzDroneGoblin*                         ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzDroneGoblinSpawner_TriggerDroneSpawn) == 0x000008, "Wrong alignment on GzDroneGoblinSpawner_TriggerDroneSpawn");
static_assert(sizeof(GzDroneGoblinSpawner_TriggerDroneSpawn) == 0x000008, "Wrong size on GzDroneGoblinSpawner_TriggerDroneSpawn");
static_assert(offsetof(GzDroneGoblinSpawner_TriggerDroneSpawn, ReturnValue) == 0x000000, "Member 'GzDroneGoblinSpawner_TriggerDroneSpawn::ReturnValue' has a wrong offset!");

// Function G01.GzDroneGoblinSpawner.GetTrackSet
// 0x0010 (0x0010 - 0x0000)
struct GzDroneGoblinSpawner_GetTrackSet final
{
public:
	TArray<class AGzTrack*>                       ReturnValue;                                       // 0x0000(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzDroneGoblinSpawner_GetTrackSet) == 0x000008, "Wrong alignment on GzDroneGoblinSpawner_GetTrackSet");
static_assert(sizeof(GzDroneGoblinSpawner_GetTrackSet) == 0x000010, "Wrong size on GzDroneGoblinSpawner_GetTrackSet");
static_assert(offsetof(GzDroneGoblinSpawner_GetTrackSet, ReturnValue) == 0x000000, "Member 'GzDroneGoblinSpawner_GetTrackSet::ReturnValue' has a wrong offset!");

// Function G01.GzDropTableData.RollItem
// 0x0048 (0x0048 - 0x0000)
struct GzDropTableData_RollItem final
{
public:
	struct FGzInventoryItemContent                ReturnValue;                                       // 0x0000(0x0048)(Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzDropTableData_RollItem) == 0x000008, "Wrong alignment on GzDropTableData_RollItem");
static_assert(sizeof(GzDropTableData_RollItem) == 0x000048, "Wrong size on GzDropTableData_RollItem");
static_assert(offsetof(GzDropTableData_RollItem, ReturnValue) == 0x000000, "Member 'GzDropTableData_RollItem::ReturnValue' has a wrong offset!");

// Function G01.GzPostProcessFX.StopSelf
// 0x0001 (0x0001 - 0x0000)
struct GzPostProcessFX_StopSelf final
{
public:
	bool                                          bImmediate;                                        // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzPostProcessFX_StopSelf) == 0x000001, "Wrong alignment on GzPostProcessFX_StopSelf");
static_assert(sizeof(GzPostProcessFX_StopSelf) == 0x000001, "Wrong size on GzPostProcessFX_StopSelf");
static_assert(offsetof(GzPostProcessFX_StopSelf, bImmediate) == 0x000000, "Member 'GzPostProcessFX_StopSelf::bImmediate' has a wrong offset!");

// Function G01.GzPostProcessFX.TickBP
// 0x0004 (0x0004 - 0x0000)
struct GzPostProcessFX_TickBP final
{
public:
	float                                         DeltaTime;                                         // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzPostProcessFX_TickBP) == 0x000004, "Wrong alignment on GzPostProcessFX_TickBP");
static_assert(sizeof(GzPostProcessFX_TickBP) == 0x000004, "Wrong size on GzPostProcessFX_TickBP");
static_assert(offsetof(GzPostProcessFX_TickBP, DeltaTime) == 0x000000, "Member 'GzPostProcessFX_TickBP::DeltaTime' has a wrong offset!");

// Function G01.GzPostProcessFX.GetFadeInProgress
// 0x0004 (0x0004 - 0x0000)
struct GzPostProcessFX_GetFadeInProgress final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzPostProcessFX_GetFadeInProgress) == 0x000004, "Wrong alignment on GzPostProcessFX_GetFadeInProgress");
static_assert(sizeof(GzPostProcessFX_GetFadeInProgress) == 0x000004, "Wrong size on GzPostProcessFX_GetFadeInProgress");
static_assert(offsetof(GzPostProcessFX_GetFadeInProgress, ReturnValue) == 0x000000, "Member 'GzPostProcessFX_GetFadeInProgress::ReturnValue' has a wrong offset!");

// Function G01.GzPostProcessFX.GetFadeOutProgress
// 0x0004 (0x0004 - 0x0000)
struct GzPostProcessFX_GetFadeOutProgress final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzPostProcessFX_GetFadeOutProgress) == 0x000004, "Wrong alignment on GzPostProcessFX_GetFadeOutProgress");
static_assert(sizeof(GzPostProcessFX_GetFadeOutProgress) == 0x000004, "Wrong size on GzPostProcessFX_GetFadeOutProgress");
static_assert(offsetof(GzPostProcessFX_GetFadeOutProgress, ReturnValue) == 0x000000, "Member 'GzPostProcessFX_GetFadeOutProgress::ReturnValue' has a wrong offset!");

// Function G01.GzPostProcessFX.IsFadingIn
// 0x0001 (0x0001 - 0x0000)
struct GzPostProcessFX_IsFadingIn final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzPostProcessFX_IsFadingIn) == 0x000001, "Wrong alignment on GzPostProcessFX_IsFadingIn");
static_assert(sizeof(GzPostProcessFX_IsFadingIn) == 0x000001, "Wrong size on GzPostProcessFX_IsFadingIn");
static_assert(offsetof(GzPostProcessFX_IsFadingIn, ReturnValue) == 0x000000, "Member 'GzPostProcessFX_IsFadingIn::ReturnValue' has a wrong offset!");

// Function G01.GzPostProcessFX.IsFadingOut
// 0x0001 (0x0001 - 0x0000)
struct GzPostProcessFX_IsFadingOut final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzPostProcessFX_IsFadingOut) == 0x000001, "Wrong alignment on GzPostProcessFX_IsFadingOut");
static_assert(sizeof(GzPostProcessFX_IsFadingOut) == 0x000001, "Wrong size on GzPostProcessFX_IsFadingOut");
static_assert(offsetof(GzPostProcessFX_IsFadingOut, ReturnValue) == 0x000000, "Member 'GzPostProcessFX_IsFadingOut::ReturnValue' has a wrong offset!");

// Function G01.GzEditorPreviewCharacter.EditorInitMeshComponents
// 0x0008 (0x0008 - 0x0000)
struct GzEditorPreviewCharacter_EditorInitMeshComponents final
{
public:
	class UGzCharacterCustomizationComponent*     EditorCustomizationComponent;                      // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzEditorPreviewCharacter_EditorInitMeshComponents) == 0x000008, "Wrong alignment on GzEditorPreviewCharacter_EditorInitMeshComponents");
static_assert(sizeof(GzEditorPreviewCharacter_EditorInitMeshComponents) == 0x000008, "Wrong size on GzEditorPreviewCharacter_EditorInitMeshComponents");
static_assert(offsetof(GzEditorPreviewCharacter_EditorInitMeshComponents, EditorCustomizationComponent) == 0x000000, "Member 'GzEditorPreviewCharacter_EditorInitMeshComponents::EditorCustomizationComponent' has a wrong offset!");

// Function G01.GzEffectPropagationActor.OnPawnBeginOverlap
// 0x0010 (0x0010 - 0x0000)
struct GzEffectPropagationActor_OnPawnBeginOverlap final
{
public:
	class AActor*                                 OverlappedActor;                                   // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 OtherActor;                                        // 0x0008(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzEffectPropagationActor_OnPawnBeginOverlap) == 0x000008, "Wrong alignment on GzEffectPropagationActor_OnPawnBeginOverlap");
static_assert(sizeof(GzEffectPropagationActor_OnPawnBeginOverlap) == 0x000010, "Wrong size on GzEffectPropagationActor_OnPawnBeginOverlap");
static_assert(offsetof(GzEffectPropagationActor_OnPawnBeginOverlap, OverlappedActor) == 0x000000, "Member 'GzEffectPropagationActor_OnPawnBeginOverlap::OverlappedActor' has a wrong offset!");
static_assert(offsetof(GzEffectPropagationActor_OnPawnBeginOverlap, OtherActor) == 0x000008, "Member 'GzEffectPropagationActor_OnPawnBeginOverlap::OtherActor' has a wrong offset!");

// Function G01.GzEffectPropagationActor.OnPawnEndOverlap
// 0x0010 (0x0010 - 0x0000)
struct GzEffectPropagationActor_OnPawnEndOverlap final
{
public:
	class AActor*                                 OverlappedActor;                                   // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 OtherActor;                                        // 0x0008(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzEffectPropagationActor_OnPawnEndOverlap) == 0x000008, "Wrong alignment on GzEffectPropagationActor_OnPawnEndOverlap");
static_assert(sizeof(GzEffectPropagationActor_OnPawnEndOverlap) == 0x000010, "Wrong size on GzEffectPropagationActor_OnPawnEndOverlap");
static_assert(offsetof(GzEffectPropagationActor_OnPawnEndOverlap, OverlappedActor) == 0x000000, "Member 'GzEffectPropagationActor_OnPawnEndOverlap::OverlappedActor' has a wrong offset!");
static_assert(offsetof(GzEffectPropagationActor_OnPawnEndOverlap, OtherActor) == 0x000008, "Member 'GzEffectPropagationActor_OnPawnEndOverlap::OtherActor' has a wrong offset!");

// Function G01.GzBPEmoteHelper.GetEmoteCIT
// 0x0030 (0x0030 - 0x0000)
struct GzBPEmoteHelper_GetEmoteCIT final
{
public:
	struct FGzEmoteCustomizationData              CustomizationData;                                 // 0x0000(0x0028)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	const class UGzCIT_Emote*                     ReturnValue;                                       // 0x0028(0x0008)(ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzBPEmoteHelper_GetEmoteCIT) == 0x000008, "Wrong alignment on GzBPEmoteHelper_GetEmoteCIT");
static_assert(sizeof(GzBPEmoteHelper_GetEmoteCIT) == 0x000030, "Wrong size on GzBPEmoteHelper_GetEmoteCIT");
static_assert(offsetof(GzBPEmoteHelper_GetEmoteCIT, CustomizationData) == 0x000000, "Member 'GzBPEmoteHelper_GetEmoteCIT::CustomizationData' has a wrong offset!");
static_assert(offsetof(GzBPEmoteHelper_GetEmoteCIT, ReturnValue) == 0x000028, "Member 'GzBPEmoteHelper_GetEmoteCIT::ReturnValue' has a wrong offset!");

// Function G01.GzPlayerMarkersHolderComponent.GetMarkerById
// 0x0010 (0x0010 - 0x0000)
struct GzPlayerMarkersHolderComponent_GetMarkerById final
{
public:
	int32                                         MarkerId;                                          // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_320D[0x4];                                     // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UGzMarkerComponent*                     ReturnValue;                                       // 0x0008(0x0008)(ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzPlayerMarkersHolderComponent_GetMarkerById) == 0x000008, "Wrong alignment on GzPlayerMarkersHolderComponent_GetMarkerById");
static_assert(sizeof(GzPlayerMarkersHolderComponent_GetMarkerById) == 0x000010, "Wrong size on GzPlayerMarkersHolderComponent_GetMarkerById");
static_assert(offsetof(GzPlayerMarkersHolderComponent_GetMarkerById, MarkerId) == 0x000000, "Member 'GzPlayerMarkersHolderComponent_GetMarkerById::MarkerId' has a wrong offset!");
static_assert(offsetof(GzPlayerMarkersHolderComponent_GetMarkerById, ReturnValue) == 0x000008, "Member 'GzPlayerMarkersHolderComponent_GetMarkerById::ReturnValue' has a wrong offset!");

// Function G01.GzPlayerMarkersHolderComponent.OnControllerInit
// 0x0010 (0x0010 - 0x0000)
struct GzPlayerMarkersHolderComponent_OnControllerInit final
{
public:
	class AGzPlayerController*                    PlayerController;                                  // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AGzPlayerState*                         PlayerState;                                       // 0x0008(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzPlayerMarkersHolderComponent_OnControllerInit) == 0x000008, "Wrong alignment on GzPlayerMarkersHolderComponent_OnControllerInit");
static_assert(sizeof(GzPlayerMarkersHolderComponent_OnControllerInit) == 0x000010, "Wrong size on GzPlayerMarkersHolderComponent_OnControllerInit");
static_assert(offsetof(GzPlayerMarkersHolderComponent_OnControllerInit, PlayerController) == 0x000000, "Member 'GzPlayerMarkersHolderComponent_OnControllerInit::PlayerController' has a wrong offset!");
static_assert(offsetof(GzPlayerMarkersHolderComponent_OnControllerInit, PlayerState) == 0x000008, "Member 'GzPlayerMarkersHolderComponent_OnControllerInit::PlayerState' has a wrong offset!");

// Function G01.GzPlayerMarkersHolderComponent.OnMissionStarted
// 0x0008 (0x0008 - 0x0000)
struct GzPlayerMarkersHolderComponent_OnMissionStarted final
{
public:
	class AGzMission*                             Mission;                                           // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzPlayerMarkersHolderComponent_OnMissionStarted) == 0x000008, "Wrong alignment on GzPlayerMarkersHolderComponent_OnMissionStarted");
static_assert(sizeof(GzPlayerMarkersHolderComponent_OnMissionStarted) == 0x000008, "Wrong size on GzPlayerMarkersHolderComponent_OnMissionStarted");
static_assert(offsetof(GzPlayerMarkersHolderComponent_OnMissionStarted, Mission) == 0x000000, "Member 'GzPlayerMarkersHolderComponent_OnMissionStarted::Mission' has a wrong offset!");

// Function G01.GzPlayerMarkersHolderComponent.OnMissionStateChanged
// 0x0020 (0x0020 - 0x0000)
struct GzPlayerMarkersHolderComponent_OnMissionStateChanged final
{
public:
	class AGzMission*                             Mission;                                           // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGzMissionState                        OldState;                                          // 0x0008(0x000C)(Parm, NoDestructor, NativeAccessSpecifierPublic)
	struct FGzMissionState                        MissionState;                                      // 0x0014(0x000C)(Parm, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzPlayerMarkersHolderComponent_OnMissionStateChanged) == 0x000008, "Wrong alignment on GzPlayerMarkersHolderComponent_OnMissionStateChanged");
static_assert(sizeof(GzPlayerMarkersHolderComponent_OnMissionStateChanged) == 0x000020, "Wrong size on GzPlayerMarkersHolderComponent_OnMissionStateChanged");
static_assert(offsetof(GzPlayerMarkersHolderComponent_OnMissionStateChanged, Mission) == 0x000000, "Member 'GzPlayerMarkersHolderComponent_OnMissionStateChanged::Mission' has a wrong offset!");
static_assert(offsetof(GzPlayerMarkersHolderComponent_OnMissionStateChanged, OldState) == 0x000008, "Member 'GzPlayerMarkersHolderComponent_OnMissionStateChanged::OldState' has a wrong offset!");
static_assert(offsetof(GzPlayerMarkersHolderComponent_OnMissionStateChanged, MissionState) == 0x000014, "Member 'GzPlayerMarkersHolderComponent_OnMissionStateChanged::MissionState' has a wrong offset!");

// Function G01.GzPlayerMarkersHolderComponent.OnMissionTrackingChanged
// 0x0010 (0x0010 - 0x0000)
struct GzPlayerMarkersHolderComponent_OnMissionTrackingChanged final
{
public:
	class AGzAdvancedMission*                     Mission;                                           // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsTracked;                                        // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_320E[0x7];                                     // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GzPlayerMarkersHolderComponent_OnMissionTrackingChanged) == 0x000008, "Wrong alignment on GzPlayerMarkersHolderComponent_OnMissionTrackingChanged");
static_assert(sizeof(GzPlayerMarkersHolderComponent_OnMissionTrackingChanged) == 0x000010, "Wrong size on GzPlayerMarkersHolderComponent_OnMissionTrackingChanged");
static_assert(offsetof(GzPlayerMarkersHolderComponent_OnMissionTrackingChanged, Mission) == 0x000000, "Member 'GzPlayerMarkersHolderComponent_OnMissionTrackingChanged::Mission' has a wrong offset!");
static_assert(offsetof(GzPlayerMarkersHolderComponent_OnMissionTrackingChanged, bIsTracked) == 0x000008, "Member 'GzPlayerMarkersHolderComponent_OnMissionTrackingChanged::bIsTracked' has a wrong offset!");

// Function G01.GzPlayerMarkersHolderComponent.OnPawnChanged
// 0x0008 (0x0008 - 0x0000)
struct GzPlayerMarkersHolderComponent_OnPawnChanged final
{
public:
	class APawn*                                  Pawn;                                              // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzPlayerMarkersHolderComponent_OnPawnChanged) == 0x000008, "Wrong alignment on GzPlayerMarkersHolderComponent_OnPawnChanged");
static_assert(sizeof(GzPlayerMarkersHolderComponent_OnPawnChanged) == 0x000008, "Wrong size on GzPlayerMarkersHolderComponent_OnPawnChanged");
static_assert(offsetof(GzPlayerMarkersHolderComponent_OnPawnChanged, Pawn) == 0x000000, "Member 'GzPlayerMarkersHolderComponent_OnPawnChanged::Pawn' has a wrong offset!");

// Function G01.GzPlayerMarkersHolderComponent.OnPlayerChangeTeam
// 0x0008 (0x0008 - 0x0000)
struct GzPlayerMarkersHolderComponent_OnPlayerChangeTeam final
{
public:
	class AGzPlayerState*                         PlayerState;                                       // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzPlayerMarkersHolderComponent_OnPlayerChangeTeam) == 0x000008, "Wrong alignment on GzPlayerMarkersHolderComponent_OnPlayerChangeTeam");
static_assert(sizeof(GzPlayerMarkersHolderComponent_OnPlayerChangeTeam) == 0x000008, "Wrong size on GzPlayerMarkersHolderComponent_OnPlayerChangeTeam");
static_assert(offsetof(GzPlayerMarkersHolderComponent_OnPlayerChangeTeam, PlayerState) == 0x000000, "Member 'GzPlayerMarkersHolderComponent_OnPlayerChangeTeam::PlayerState' has a wrong offset!");

// Function G01.GzPlayerMarkersHolderComponent.OnRedeployPriceChanged
// 0x0008 (0x0008 - 0x0000)
struct GzPlayerMarkersHolderComponent_OnRedeployPriceChanged final
{
public:
	const class AGzGameState*                     GS;                                                // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzPlayerMarkersHolderComponent_OnRedeployPriceChanged) == 0x000008, "Wrong alignment on GzPlayerMarkersHolderComponent_OnRedeployPriceChanged");
static_assert(sizeof(GzPlayerMarkersHolderComponent_OnRedeployPriceChanged) == 0x000008, "Wrong size on GzPlayerMarkersHolderComponent_OnRedeployPriceChanged");
static_assert(offsetof(GzPlayerMarkersHolderComponent_OnRedeployPriceChanged, GS) == 0x000000, "Member 'GzPlayerMarkersHolderComponent_OnRedeployPriceChanged::GS' has a wrong offset!");

// Function G01.GzPlayerMarkersHolderComponent.OnTeammateAliveStateChanged
// 0x0008 (0x0008 - 0x0000)
struct GzPlayerMarkersHolderComponent_OnTeammateAliveStateChanged final
{
public:
	class AGzPlayerState*                         PlayerState;                                       // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzPlayerMarkersHolderComponent_OnTeammateAliveStateChanged) == 0x000008, "Wrong alignment on GzPlayerMarkersHolderComponent_OnTeammateAliveStateChanged");
static_assert(sizeof(GzPlayerMarkersHolderComponent_OnTeammateAliveStateChanged) == 0x000008, "Wrong size on GzPlayerMarkersHolderComponent_OnTeammateAliveStateChanged");
static_assert(offsetof(GzPlayerMarkersHolderComponent_OnTeammateAliveStateChanged, PlayerState) == 0x000000, "Member 'GzPlayerMarkersHolderComponent_OnTeammateAliveStateChanged::PlayerState' has a wrong offset!");

// Function G01.GzPlayerMarkersHolderComponent.OnWorldInstanceIdChanged
// 0x0008 (0x0008 - 0x0000)
struct GzPlayerMarkersHolderComponent_OnWorldInstanceIdChanged final
{
public:
	class AGzPlayerState*                         PlayerState;                                       // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzPlayerMarkersHolderComponent_OnWorldInstanceIdChanged) == 0x000008, "Wrong alignment on GzPlayerMarkersHolderComponent_OnWorldInstanceIdChanged");
static_assert(sizeof(GzPlayerMarkersHolderComponent_OnWorldInstanceIdChanged) == 0x000008, "Wrong size on GzPlayerMarkersHolderComponent_OnWorldInstanceIdChanged");
static_assert(offsetof(GzPlayerMarkersHolderComponent_OnWorldInstanceIdChanged, PlayerState) == 0x000000, "Member 'GzPlayerMarkersHolderComponent_OnWorldInstanceIdChanged::PlayerState' has a wrong offset!");

// Function G01.GzPlayerMarkersHolderComponent.GetActiveMarkers
// 0x0010 (0x0010 - 0x0000)
struct GzPlayerMarkersHolderComponent_GetActiveMarkers final
{
public:
	TArray<class UGzMarkerComponent*>             ReturnValue;                                       // 0x0000(0x0010)(ConstParm, ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzPlayerMarkersHolderComponent_GetActiveMarkers) == 0x000008, "Wrong alignment on GzPlayerMarkersHolderComponent_GetActiveMarkers");
static_assert(sizeof(GzPlayerMarkersHolderComponent_GetActiveMarkers) == 0x000010, "Wrong size on GzPlayerMarkersHolderComponent_GetActiveMarkers");
static_assert(offsetof(GzPlayerMarkersHolderComponent_GetActiveMarkers, ReturnValue) == 0x000000, "Member 'GzPlayerMarkersHolderComponent_GetActiveMarkers::ReturnValue' has a wrong offset!");

// Function G01.GzPlayerMarkersHolderComponent.GetClosestMarkerByOwnerClass
// 0x0010 (0x0010 - 0x0000)
struct GzPlayerMarkersHolderComponent_GetClosestMarkerByOwnerClass final
{
public:
	class UClass*                                 OwnerClass;                                        // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UGzMarkerComponent*                     ReturnValue;                                       // 0x0008(0x0008)(ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzPlayerMarkersHolderComponent_GetClosestMarkerByOwnerClass) == 0x000008, "Wrong alignment on GzPlayerMarkersHolderComponent_GetClosestMarkerByOwnerClass");
static_assert(sizeof(GzPlayerMarkersHolderComponent_GetClosestMarkerByOwnerClass) == 0x000010, "Wrong size on GzPlayerMarkersHolderComponent_GetClosestMarkerByOwnerClass");
static_assert(offsetof(GzPlayerMarkersHolderComponent_GetClosestMarkerByOwnerClass, OwnerClass) == 0x000000, "Member 'GzPlayerMarkersHolderComponent_GetClosestMarkerByOwnerClass::OwnerClass' has a wrong offset!");
static_assert(offsetof(GzPlayerMarkersHolderComponent_GetClosestMarkerByOwnerClass, ReturnValue) == 0x000008, "Member 'GzPlayerMarkersHolderComponent_GetClosestMarkerByOwnerClass::ReturnValue' has a wrong offset!");

// Function G01.GzEnvironmentZoneComponent.GetPriority
// 0x0004 (0x0004 - 0x0000)
struct GzEnvironmentZoneComponent_GetPriority final
{
public:
	int32                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzEnvironmentZoneComponent_GetPriority) == 0x000004, "Wrong alignment on GzEnvironmentZoneComponent_GetPriority");
static_assert(sizeof(GzEnvironmentZoneComponent_GetPriority) == 0x000004, "Wrong size on GzEnvironmentZoneComponent_GetPriority");
static_assert(offsetof(GzEnvironmentZoneComponent_GetPriority, ReturnValue) == 0x000000, "Member 'GzEnvironmentZoneComponent_GetPriority::ReturnValue' has a wrong offset!");

// Function G01.GzEnvironmentZoneComponent.IsLocationInside
// 0x0020 (0x0020 - 0x0000)
struct GzEnvironmentZoneComponent_IsLocationInside final
{
public:
	struct FVector                                Location;                                          // 0x0000(0x0018)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0018(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3212[0x7];                                     // 0x0019(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GzEnvironmentZoneComponent_IsLocationInside) == 0x000008, "Wrong alignment on GzEnvironmentZoneComponent_IsLocationInside");
static_assert(sizeof(GzEnvironmentZoneComponent_IsLocationInside) == 0x000020, "Wrong size on GzEnvironmentZoneComponent_IsLocationInside");
static_assert(offsetof(GzEnvironmentZoneComponent_IsLocationInside, Location) == 0x000000, "Member 'GzEnvironmentZoneComponent_IsLocationInside::Location' has a wrong offset!");
static_assert(offsetof(GzEnvironmentZoneComponent_IsLocationInside, ReturnValue) == 0x000018, "Member 'GzEnvironmentZoneComponent_IsLocationInside::ReturnValue' has a wrong offset!");

// Function G01.GzEnvironmentZoneManagerComponent.GetHighestPriorityEnvironmentZone
// 0x0008 (0x0008 - 0x0000)
struct GzEnvironmentZoneManagerComponent_GetHighestPriorityEnvironmentZone final
{
public:
	class UGzEnvironmentZoneComponent*            ReturnValue;                                       // 0x0000(0x0008)(ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzEnvironmentZoneManagerComponent_GetHighestPriorityEnvironmentZone) == 0x000008, "Wrong alignment on GzEnvironmentZoneManagerComponent_GetHighestPriorityEnvironmentZone");
static_assert(sizeof(GzEnvironmentZoneManagerComponent_GetHighestPriorityEnvironmentZone) == 0x000008, "Wrong size on GzEnvironmentZoneManagerComponent_GetHighestPriorityEnvironmentZone");
static_assert(offsetof(GzEnvironmentZoneManagerComponent_GetHighestPriorityEnvironmentZone, ReturnValue) == 0x000000, "Member 'GzEnvironmentZoneManagerComponent_GetHighestPriorityEnvironmentZone::ReturnValue' has a wrong offset!");

// Function G01.GzEnvironmentZoneManagerComponent.GetHighestPriorityEnvironmentZoneType
// 0x0060 (0x0060 - 0x0000)
struct GzEnvironmentZoneManagerComponent_GetHighestPriorityEnvironmentZoneType final
{
public:
	struct FGzEnvironmentZoneType                 OutEnvZoneType;                                    // 0x0000(0x0058)(Parm, OutParm, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0058(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3215[0x7];                                     // 0x0059(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GzEnvironmentZoneManagerComponent_GetHighestPriorityEnvironmentZoneType) == 0x000008, "Wrong alignment on GzEnvironmentZoneManagerComponent_GetHighestPriorityEnvironmentZoneType");
static_assert(sizeof(GzEnvironmentZoneManagerComponent_GetHighestPriorityEnvironmentZoneType) == 0x000060, "Wrong size on GzEnvironmentZoneManagerComponent_GetHighestPriorityEnvironmentZoneType");
static_assert(offsetof(GzEnvironmentZoneManagerComponent_GetHighestPriorityEnvironmentZoneType, OutEnvZoneType) == 0x000000, "Member 'GzEnvironmentZoneManagerComponent_GetHighestPriorityEnvironmentZoneType::OutEnvZoneType' has a wrong offset!");
static_assert(offsetof(GzEnvironmentZoneManagerComponent_GetHighestPriorityEnvironmentZoneType, ReturnValue) == 0x000058, "Member 'GzEnvironmentZoneManagerComponent_GetHighestPriorityEnvironmentZoneType::ReturnValue' has a wrong offset!");

// Function G01.GzErrorNotificationsCheatExtension.PostMetaErrorFromAzureCode
// 0x0004 (0x0004 - 0x0000)
struct GzErrorNotificationsCheatExtension_PostMetaErrorFromAzureCode final
{
public:
	int32                                         InCode;                                            // 0x0000(0x0004)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzErrorNotificationsCheatExtension_PostMetaErrorFromAzureCode) == 0x000004, "Wrong alignment on GzErrorNotificationsCheatExtension_PostMetaErrorFromAzureCode");
static_assert(sizeof(GzErrorNotificationsCheatExtension_PostMetaErrorFromAzureCode) == 0x000004, "Wrong size on GzErrorNotificationsCheatExtension_PostMetaErrorFromAzureCode");
static_assert(offsetof(GzErrorNotificationsCheatExtension_PostMetaErrorFromAzureCode, InCode) == 0x000000, "Member 'GzErrorNotificationsCheatExtension_PostMetaErrorFromAzureCode::InCode' has a wrong offset!");

// Function G01.GzErrorNotificationsCheatExtension.PostMetaErrorFromErrorNotification
// 0x0004 (0x0004 - 0x0000)
struct GzErrorNotificationsCheatExtension_PostMetaErrorFromErrorNotification final
{
public:
	int32                                         InCode;                                            // 0x0000(0x0004)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzErrorNotificationsCheatExtension_PostMetaErrorFromErrorNotification) == 0x000004, "Wrong alignment on GzErrorNotificationsCheatExtension_PostMetaErrorFromErrorNotification");
static_assert(sizeof(GzErrorNotificationsCheatExtension_PostMetaErrorFromErrorNotification) == 0x000004, "Wrong size on GzErrorNotificationsCheatExtension_PostMetaErrorFromErrorNotification");
static_assert(offsetof(GzErrorNotificationsCheatExtension_PostMetaErrorFromErrorNotification, InCode) == 0x000000, "Member 'GzErrorNotificationsCheatExtension_PostMetaErrorFromErrorNotification::InCode' has a wrong offset!");

// Function G01.GzErrorNotificationsCheatExtension.PostMetaErrorFromPlayFabCode
// 0x0004 (0x0004 - 0x0000)
struct GzErrorNotificationsCheatExtension_PostMetaErrorFromPlayFabCode final
{
public:
	int32                                         InCode;                                            // 0x0000(0x0004)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzErrorNotificationsCheatExtension_PostMetaErrorFromPlayFabCode) == 0x000004, "Wrong alignment on GzErrorNotificationsCheatExtension_PostMetaErrorFromPlayFabCode");
static_assert(sizeof(GzErrorNotificationsCheatExtension_PostMetaErrorFromPlayFabCode) == 0x000004, "Wrong size on GzErrorNotificationsCheatExtension_PostMetaErrorFromPlayFabCode");
static_assert(offsetof(GzErrorNotificationsCheatExtension_PostMetaErrorFromPlayFabCode, InCode) == 0x000000, "Member 'GzErrorNotificationsCheatExtension_PostMetaErrorFromPlayFabCode::InCode' has a wrong offset!");

// Function G01.GzEventLogWidget.AddPlayerOutOfHealthNotification_BP
// 0x0008 (0x0008 - 0x0000)
struct GzEventLogWidget_AddPlayerOutOfHealthNotification_BP final
{
public:
	const class UGzPlayerOutOfHealthMessage*      PlayerOutOfHealthMessage;                          // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzEventLogWidget_AddPlayerOutOfHealthNotification_BP) == 0x000008, "Wrong alignment on GzEventLogWidget_AddPlayerOutOfHealthNotification_BP");
static_assert(sizeof(GzEventLogWidget_AddPlayerOutOfHealthNotification_BP) == 0x000008, "Wrong size on GzEventLogWidget_AddPlayerOutOfHealthNotification_BP");
static_assert(offsetof(GzEventLogWidget_AddPlayerOutOfHealthNotification_BP, PlayerOutOfHealthMessage) == 0x000000, "Member 'GzEventLogWidget_AddPlayerOutOfHealthNotification_BP::PlayerOutOfHealthMessage' has a wrong offset!");

// Function G01.GzExplosionComponent.ExplodeAtClients
// 0x0028 (0x0028 - 0x0000)
struct GzExplosionComponent_ExplodeAtClients final
{
public:
	struct FGzProjectileImpactData                ImpactData;                                        // 0x0000(0x0028)(ConstParm, Parm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzExplosionComponent_ExplodeAtClients) == 0x000008, "Wrong alignment on GzExplosionComponent_ExplodeAtClients");
static_assert(sizeof(GzExplosionComponent_ExplodeAtClients) == 0x000028, "Wrong size on GzExplosionComponent_ExplodeAtClients");
static_assert(offsetof(GzExplosionComponent_ExplodeAtClients, ImpactData) == 0x000000, "Member 'GzExplosionComponent_ExplodeAtClients::ImpactData' has a wrong offset!");

// Function G01.GzExplosionComponent.ExplodeWithInstigator
// 0x0010 (0x0010 - 0x0000)
struct GzExplosionComponent_ExplodeWithInstigator final
{
public:
	class APawn*                                  InstigatorPawn;                                    // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 CharacterIdAccessActor;                            // 0x0008(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzExplosionComponent_ExplodeWithInstigator) == 0x000008, "Wrong alignment on GzExplosionComponent_ExplodeWithInstigator");
static_assert(sizeof(GzExplosionComponent_ExplodeWithInstigator) == 0x000010, "Wrong size on GzExplosionComponent_ExplodeWithInstigator");
static_assert(offsetof(GzExplosionComponent_ExplodeWithInstigator, InstigatorPawn) == 0x000000, "Member 'GzExplosionComponent_ExplodeWithInstigator::InstigatorPawn' has a wrong offset!");
static_assert(offsetof(GzExplosionComponent_ExplodeWithInstigator, CharacterIdAccessActor) == 0x000008, "Member 'GzExplosionComponent_ExplodeWithInstigator::CharacterIdAccessActor' has a wrong offset!");

// Function G01.GzExplosionComponent.ExplodeWithParameters
// 0x0060 (0x0060 - 0x0000)
struct GzExplosionComponent_ExplodeWithParameters final
{
public:
	struct FGzExplosionParameters                 Params_0;                                          // 0x0000(0x0060)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzExplosionComponent_ExplodeWithParameters) == 0x000008, "Wrong alignment on GzExplosionComponent_ExplodeWithParameters");
static_assert(sizeof(GzExplosionComponent_ExplodeWithParameters) == 0x000060, "Wrong size on GzExplosionComponent_ExplodeWithParameters");
static_assert(offsetof(GzExplosionComponent_ExplodeWithParameters, Params_0) == 0x000000, "Member 'GzExplosionComponent_ExplodeWithParameters::Params_0' has a wrong offset!");

// Function G01.GzExplosionComponent.SetCharge
// 0x0004 (0x0004 - 0x0000)
struct GzExplosionComponent_SetCharge final
{
public:
	float                                         Charge;                                            // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzExplosionComponent_SetCharge) == 0x000004, "Wrong alignment on GzExplosionComponent_SetCharge");
static_assert(sizeof(GzExplosionComponent_SetCharge) == 0x000004, "Wrong size on GzExplosionComponent_SetCharge");
static_assert(offsetof(GzExplosionComponent_SetCharge, Charge) == 0x000000, "Member 'GzExplosionComponent_SetCharge::Charge' has a wrong offset!");

// Function G01.GzExplosionComponent.SetExplosionData
// 0x0008 (0x0008 - 0x0000)
struct GzExplosionComponent_SetExplosionData final
{
public:
	class UGzExplosionData*                       Data;                                              // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzExplosionComponent_SetExplosionData) == 0x000008, "Wrong alignment on GzExplosionComponent_SetExplosionData");
static_assert(sizeof(GzExplosionComponent_SetExplosionData) == 0x000008, "Wrong size on GzExplosionComponent_SetExplosionData");
static_assert(offsetof(GzExplosionComponent_SetExplosionData, Data) == 0x000000, "Member 'GzExplosionComponent_SetExplosionData::Data' has a wrong offset!");

// Function G01.GzExplosionComponent.GetExplosionData
// 0x0008 (0x0008 - 0x0000)
struct GzExplosionComponent_GetExplosionData final
{
public:
	class UGzExplosionData*                       ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzExplosionComponent_GetExplosionData) == 0x000008, "Wrong alignment on GzExplosionComponent_GetExplosionData");
static_assert(sizeof(GzExplosionComponent_GetExplosionData) == 0x000008, "Wrong size on GzExplosionComponent_GetExplosionData");
static_assert(offsetof(GzExplosionComponent_GetExplosionData, ReturnValue) == 0x000000, "Member 'GzExplosionComponent_GetExplosionData::ReturnValue' has a wrong offset!");

// Function G01.GzExplosionComponent.GetExplosionTraceTypes
// 0x0010 (0x0010 - 0x0000)
struct GzExplosionComponent_GetExplosionTraceTypes final
{
public:
	TArray<ECollisionChannel>                     ReturnValue;                                       // 0x0000(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzExplosionComponent_GetExplosionTraceTypes) == 0x000008, "Wrong alignment on GzExplosionComponent_GetExplosionTraceTypes");
static_assert(sizeof(GzExplosionComponent_GetExplosionTraceTypes) == 0x000010, "Wrong size on GzExplosionComponent_GetExplosionTraceTypes");
static_assert(offsetof(GzExplosionComponent_GetExplosionTraceTypes, ReturnValue) == 0x000000, "Member 'GzExplosionComponent_GetExplosionTraceTypes::ReturnValue' has a wrong offset!");

// Function G01.GzExtractionRoyaleCheatExtension.NotificationRecieved
// 0x0010 (0x0010 - 0x0000)
struct GzExtractionRoyaleCheatExtension_NotificationRecieved final
{
public:
	struct FGzEventNotificationData               GzEventNotificationData;                           // 0x0000(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzExtractionRoyaleCheatExtension_NotificationRecieved) == 0x000004, "Wrong alignment on GzExtractionRoyaleCheatExtension_NotificationRecieved");
static_assert(sizeof(GzExtractionRoyaleCheatExtension_NotificationRecieved) == 0x000010, "Wrong size on GzExtractionRoyaleCheatExtension_NotificationRecieved");
static_assert(offsetof(GzExtractionRoyaleCheatExtension_NotificationRecieved, GzEventNotificationData) == 0x000000, "Member 'GzExtractionRoyaleCheatExtension_NotificationRecieved::GzEventNotificationData' has a wrong offset!");

// Function G01.GzExtractionRoyaleGameState.Multicast_PostEventNotification
// 0x0010 (0x0010 - 0x0000)
struct GzExtractionRoyaleGameState_Multicast_PostEventNotification final
{
public:
	struct FGzEventNotificationData               EventData;                                         // 0x0000(0x0010)(ConstParm, Parm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzExtractionRoyaleGameState_Multicast_PostEventNotification) == 0x000004, "Wrong alignment on GzExtractionRoyaleGameState_Multicast_PostEventNotification");
static_assert(sizeof(GzExtractionRoyaleGameState_Multicast_PostEventNotification) == 0x000010, "Wrong size on GzExtractionRoyaleGameState_Multicast_PostEventNotification");
static_assert(offsetof(GzExtractionRoyaleGameState_Multicast_PostEventNotification, EventData) == 0x000000, "Member 'GzExtractionRoyaleGameState_Multicast_PostEventNotification::EventData' has a wrong offset!");

// Function G01.GzExtractionRoyaleGameState.GetActivePersistantNotifications
// 0x0010 (0x0010 - 0x0000)
struct GzExtractionRoyaleGameState_GetActivePersistantNotifications final
{
public:
	TArray<struct FGzEventNotificationData>       ReturnValue;                                       // 0x0000(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzExtractionRoyaleGameState_GetActivePersistantNotifications) == 0x000008, "Wrong alignment on GzExtractionRoyaleGameState_GetActivePersistantNotifications");
static_assert(sizeof(GzExtractionRoyaleGameState_GetActivePersistantNotifications) == 0x000010, "Wrong size on GzExtractionRoyaleGameState_GetActivePersistantNotifications");
static_assert(offsetof(GzExtractionRoyaleGameState_GetActivePersistantNotifications, ReturnValue) == 0x000000, "Member 'GzExtractionRoyaleGameState_GetActivePersistantNotifications::ReturnValue' has a wrong offset!");

// Function G01.GzExtractionRoyaleGameState.GetRedeployPriceMultiplier
// 0x0004 (0x0004 - 0x0000)
struct GzExtractionRoyaleGameState_GetRedeployPriceMultiplier final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzExtractionRoyaleGameState_GetRedeployPriceMultiplier) == 0x000004, "Wrong alignment on GzExtractionRoyaleGameState_GetRedeployPriceMultiplier");
static_assert(sizeof(GzExtractionRoyaleGameState_GetRedeployPriceMultiplier) == 0x000004, "Wrong size on GzExtractionRoyaleGameState_GetRedeployPriceMultiplier");
static_assert(offsetof(GzExtractionRoyaleGameState_GetRedeployPriceMultiplier, ReturnValue) == 0x000000, "Member 'GzExtractionRoyaleGameState_GetRedeployPriceMultiplier::ReturnValue' has a wrong offset!");

// Function G01.GzExtractionRoyaleGameState.IsNextStageShift
// 0x0001 (0x0001 - 0x0000)
struct GzExtractionRoyaleGameState_IsNextStageShift final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzExtractionRoyaleGameState_IsNextStageShift) == 0x000001, "Wrong alignment on GzExtractionRoyaleGameState_IsNextStageShift");
static_assert(sizeof(GzExtractionRoyaleGameState_IsNextStageShift) == 0x000001, "Wrong size on GzExtractionRoyaleGameState_IsNextStageShift");
static_assert(offsetof(GzExtractionRoyaleGameState_IsNextStageShift, ReturnValue) == 0x000000, "Member 'GzExtractionRoyaleGameState_IsNextStageShift::ReturnValue' has a wrong offset!");

// Function G01.GzReplayCameraRecorder.Server_UpdateLocation
// 0x0030 (0x0030 - 0x0000)
struct GzReplayCameraRecorder_Server_UpdateLocation final
{
public:
	struct FVector                                InLocation;                                        // 0x0000(0x0018)(ConstParm, Parm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               InRotator;                                         // 0x0018(0x0018)(ConstParm, Parm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzReplayCameraRecorder_Server_UpdateLocation) == 0x000008, "Wrong alignment on GzReplayCameraRecorder_Server_UpdateLocation");
static_assert(sizeof(GzReplayCameraRecorder_Server_UpdateLocation) == 0x000030, "Wrong size on GzReplayCameraRecorder_Server_UpdateLocation");
static_assert(offsetof(GzReplayCameraRecorder_Server_UpdateLocation, InLocation) == 0x000000, "Member 'GzReplayCameraRecorder_Server_UpdateLocation::InLocation' has a wrong offset!");
static_assert(offsetof(GzReplayCameraRecorder_Server_UpdateLocation, InRotator) == 0x000018, "Member 'GzReplayCameraRecorder_Server_UpdateLocation::InRotator' has a wrong offset!");

// Function G01.GzExtractionRoyalePlayerState.GetRespawnBonusTime
// 0x0004 (0x0004 - 0x0000)
struct GzExtractionRoyalePlayerState_GetRespawnBonusTime final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzExtractionRoyalePlayerState_GetRespawnBonusTime) == 0x000004, "Wrong alignment on GzExtractionRoyalePlayerState_GetRespawnBonusTime");
static_assert(sizeof(GzExtractionRoyalePlayerState_GetRespawnBonusTime) == 0x000004, "Wrong size on GzExtractionRoyalePlayerState_GetRespawnBonusTime");
static_assert(offsetof(GzExtractionRoyalePlayerState_GetRespawnBonusTime, ReturnValue) == 0x000000, "Member 'GzExtractionRoyalePlayerState_GetRespawnBonusTime::ReturnValue' has a wrong offset!");

// Function G01.GzExtractionRoyaleSettings.GetMinPlayersForCountdown
// 0x0004 (0x0004 - 0x0000)
struct GzExtractionRoyaleSettings_GetMinPlayersForCountdown final
{
public:
	int32                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzExtractionRoyaleSettings_GetMinPlayersForCountdown) == 0x000004, "Wrong alignment on GzExtractionRoyaleSettings_GetMinPlayersForCountdown");
static_assert(sizeof(GzExtractionRoyaleSettings_GetMinPlayersForCountdown) == 0x000004, "Wrong size on GzExtractionRoyaleSettings_GetMinPlayersForCountdown");
static_assert(offsetof(GzExtractionRoyaleSettings_GetMinPlayersForCountdown, ReturnValue) == 0x000000, "Member 'GzExtractionRoyaleSettings_GetMinPlayersForCountdown::ReturnValue' has a wrong offset!");

// Function G01.GzExtractionRoyaleSettings.GetMinPlayersForPreMatchTimeReduction
// 0x0004 (0x0004 - 0x0000)
struct GzExtractionRoyaleSettings_GetMinPlayersForPreMatchTimeReduction final
{
public:
	int32                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzExtractionRoyaleSettings_GetMinPlayersForPreMatchTimeReduction) == 0x000004, "Wrong alignment on GzExtractionRoyaleSettings_GetMinPlayersForPreMatchTimeReduction");
static_assert(sizeof(GzExtractionRoyaleSettings_GetMinPlayersForPreMatchTimeReduction) == 0x000004, "Wrong size on GzExtractionRoyaleSettings_GetMinPlayersForPreMatchTimeReduction");
static_assert(offsetof(GzExtractionRoyaleSettings_GetMinPlayersForPreMatchTimeReduction, ReturnValue) == 0x000000, "Member 'GzExtractionRoyaleSettings_GetMinPlayersForPreMatchTimeReduction::ReturnValue' has a wrong offset!");

// Function G01.GzExtractionRoyaleSettings.GetPostMatchDuration
// 0x0004 (0x0004 - 0x0000)
struct GzExtractionRoyaleSettings_GetPostMatchDuration final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzExtractionRoyaleSettings_GetPostMatchDuration) == 0x000004, "Wrong alignment on GzExtractionRoyaleSettings_GetPostMatchDuration");
static_assert(sizeof(GzExtractionRoyaleSettings_GetPostMatchDuration) == 0x000004, "Wrong size on GzExtractionRoyaleSettings_GetPostMatchDuration");
static_assert(offsetof(GzExtractionRoyaleSettings_GetPostMatchDuration, ReturnValue) == 0x000000, "Member 'GzExtractionRoyaleSettings_GetPostMatchDuration::ReturnValue' has a wrong offset!");

// Function G01.GzExtractionRoyaleSettings.GetPreMatchCountdownDuration
// 0x0004 (0x0004 - 0x0000)
struct GzExtractionRoyaleSettings_GetPreMatchCountdownDuration final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzExtractionRoyaleSettings_GetPreMatchCountdownDuration) == 0x000004, "Wrong alignment on GzExtractionRoyaleSettings_GetPreMatchCountdownDuration");
static_assert(sizeof(GzExtractionRoyaleSettings_GetPreMatchCountdownDuration) == 0x000004, "Wrong size on GzExtractionRoyaleSettings_GetPreMatchCountdownDuration");
static_assert(offsetof(GzExtractionRoyaleSettings_GetPreMatchCountdownDuration, ReturnValue) == 0x000000, "Member 'GzExtractionRoyaleSettings_GetPreMatchCountdownDuration::ReturnValue' has a wrong offset!");

// Function G01.GzExtractionRoyaleSettings.GetPreMatchDurationRange
// 0x0004 (0x0004 - 0x0000)
struct GzExtractionRoyaleSettings_GetPreMatchDurationRange final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzExtractionRoyaleSettings_GetPreMatchDurationRange) == 0x000004, "Wrong alignment on GzExtractionRoyaleSettings_GetPreMatchDurationRange");
static_assert(sizeof(GzExtractionRoyaleSettings_GetPreMatchDurationRange) == 0x000004, "Wrong size on GzExtractionRoyaleSettings_GetPreMatchDurationRange");
static_assert(offsetof(GzExtractionRoyaleSettings_GetPreMatchDurationRange, ReturnValue) == 0x000000, "Member 'GzExtractionRoyaleSettings_GetPreMatchDurationRange::ReturnValue' has a wrong offset!");

// Function G01.GzExtractionRoyaleSettings.GetPreMatchReducedDuration
// 0x0004 (0x0004 - 0x0000)
struct GzExtractionRoyaleSettings_GetPreMatchReducedDuration final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzExtractionRoyaleSettings_GetPreMatchReducedDuration) == 0x000004, "Wrong alignment on GzExtractionRoyaleSettings_GetPreMatchReducedDuration");
static_assert(sizeof(GzExtractionRoyaleSettings_GetPreMatchReducedDuration) == 0x000004, "Wrong size on GzExtractionRoyaleSettings_GetPreMatchReducedDuration");
static_assert(offsetof(GzExtractionRoyaleSettings_GetPreMatchReducedDuration, ReturnValue) == 0x000000, "Member 'GzExtractionRoyaleSettings_GetPreMatchReducedDuration::ReturnValue' has a wrong offset!");

// Function G01.GzExtractionRoyaleSettings.GetRequiredPlayers
// 0x0004 (0x0004 - 0x0000)
struct GzExtractionRoyaleSettings_GetRequiredPlayers final
{
public:
	int32                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzExtractionRoyaleSettings_GetRequiredPlayers) == 0x000004, "Wrong alignment on GzExtractionRoyaleSettings_GetRequiredPlayers");
static_assert(sizeof(GzExtractionRoyaleSettings_GetRequiredPlayers) == 0x000004, "Wrong size on GzExtractionRoyaleSettings_GetRequiredPlayers");
static_assert(offsetof(GzExtractionRoyaleSettings_GetRequiredPlayers, ReturnValue) == 0x000000, "Member 'GzExtractionRoyaleSettings_GetRequiredPlayers::ReturnValue' has a wrong offset!");

// Function G01.GzExtractionRoyaleSettings.GetZoneSetupIndex
// 0x0004 (0x0004 - 0x0000)
struct GzExtractionRoyaleSettings_GetZoneSetupIndex final
{
public:
	int32                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzExtractionRoyaleSettings_GetZoneSetupIndex) == 0x000004, "Wrong alignment on GzExtractionRoyaleSettings_GetZoneSetupIndex");
static_assert(sizeof(GzExtractionRoyaleSettings_GetZoneSetupIndex) == 0x000004, "Wrong size on GzExtractionRoyaleSettings_GetZoneSetupIndex");
static_assert(offsetof(GzExtractionRoyaleSettings_GetZoneSetupIndex, ReturnValue) == 0x000000, "Member 'GzExtractionRoyaleSettings_GetZoneSetupIndex::ReturnValue' has a wrong offset!");

// Function G01.GzLoadoutListPreMatch.MemorizeLastChoosenGuid
// 0x0080 (0x0080 - 0x0000)
struct GzLoadoutListPreMatch_MemorizeLastChoosenGuid final
{
public:
	bool                                          bSuccessfull;                                      // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_323E[0x7];                                     // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	const class AGzPlayerController*              Controller;                                        // 0x0008(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGzLoadoutDataConfig                   CompletedWithConfig;                               // 0x0010(0x0070)(ConstParm, Parm, OutParm, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzLoadoutListPreMatch_MemorizeLastChoosenGuid) == 0x000008, "Wrong alignment on GzLoadoutListPreMatch_MemorizeLastChoosenGuid");
static_assert(sizeof(GzLoadoutListPreMatch_MemorizeLastChoosenGuid) == 0x000080, "Wrong size on GzLoadoutListPreMatch_MemorizeLastChoosenGuid");
static_assert(offsetof(GzLoadoutListPreMatch_MemorizeLastChoosenGuid, bSuccessfull) == 0x000000, "Member 'GzLoadoutListPreMatch_MemorizeLastChoosenGuid::bSuccessfull' has a wrong offset!");
static_assert(offsetof(GzLoadoutListPreMatch_MemorizeLastChoosenGuid, Controller) == 0x000008, "Member 'GzLoadoutListPreMatch_MemorizeLastChoosenGuid::Controller' has a wrong offset!");
static_assert(offsetof(GzLoadoutListPreMatch_MemorizeLastChoosenGuid, CompletedWithConfig) == 0x000010, "Member 'GzLoadoutListPreMatch_MemorizeLastChoosenGuid::CompletedWithConfig' has a wrong offset!");

// Function G01.GzExtractorTowerSupply.CollectHeatSinks
// 0x0010 (0x0010 - 0x0000)
struct GzExtractorTowerSupply_CollectHeatSinks final
{
public:
	TArray<class AGzDestructibleHeatSink*>        ReturnValue;                                       // 0x0000(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzExtractorTowerSupply_CollectHeatSinks) == 0x000008, "Wrong alignment on GzExtractorTowerSupply_CollectHeatSinks");
static_assert(sizeof(GzExtractorTowerSupply_CollectHeatSinks) == 0x000010, "Wrong size on GzExtractorTowerSupply_CollectHeatSinks");
static_assert(offsetof(GzExtractorTowerSupply_CollectHeatSinks, ReturnValue) == 0x000000, "Member 'GzExtractorTowerSupply_CollectHeatSinks::ReturnValue' has a wrong offset!");

// Function G01.GzExtractorTowerSupply.Multicast_HeatSinkDestroyed
// 0x0100 (0x0100 - 0x0000)
struct GzExtractorTowerSupply_Multicast_HeatSinkDestroyed final
{
public:
	int32                                         Param_Index;                                       // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3243[0x4];                                     // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FHitResult                             HitResult;                                         // 0x0008(0x00F8)(ConstParm, Parm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzExtractorTowerSupply_Multicast_HeatSinkDestroyed) == 0x000008, "Wrong alignment on GzExtractorTowerSupply_Multicast_HeatSinkDestroyed");
static_assert(sizeof(GzExtractorTowerSupply_Multicast_HeatSinkDestroyed) == 0x000100, "Wrong size on GzExtractorTowerSupply_Multicast_HeatSinkDestroyed");
static_assert(offsetof(GzExtractorTowerSupply_Multicast_HeatSinkDestroyed, Param_Index) == 0x000000, "Member 'GzExtractorTowerSupply_Multicast_HeatSinkDestroyed::Param_Index' has a wrong offset!");
static_assert(offsetof(GzExtractorTowerSupply_Multicast_HeatSinkDestroyed, HitResult) == 0x000008, "Member 'GzExtractorTowerSupply_Multicast_HeatSinkDestroyed::HitResult' has a wrong offset!");

// Function G01.GzExtractorTowerSupply.OnExtractionDataChanged
// 0x0040 (0x0040 - 0x0000)
struct GzExtractorTowerSupply_OnExtractionDataChanged final
{
public:
	struct FGzExtractionData                      Current;                                           // 0x0000(0x0040)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzExtractorTowerSupply_OnExtractionDataChanged) == 0x000008, "Wrong alignment on GzExtractorTowerSupply_OnExtractionDataChanged");
static_assert(sizeof(GzExtractorTowerSupply_OnExtractionDataChanged) == 0x000040, "Wrong size on GzExtractorTowerSupply_OnExtractionDataChanged");
static_assert(offsetof(GzExtractorTowerSupply_OnExtractionDataChanged, Current) == 0x000000, "Member 'GzExtractorTowerSupply_OnExtractionDataChanged::Current' has a wrong offset!");

// Function G01.GzExtractorTowerSupply.SetExtractionOwnerTeam
// 0x0004 (0x0004 - 0x0000)
struct GzExtractorTowerSupply_SetExtractionOwnerTeam final
{
public:
	int32                                         TeamID;                                            // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzExtractorTowerSupply_SetExtractionOwnerTeam) == 0x000004, "Wrong alignment on GzExtractorTowerSupply_SetExtractionOwnerTeam");
static_assert(sizeof(GzExtractorTowerSupply_SetExtractionOwnerTeam) == 0x000004, "Wrong size on GzExtractorTowerSupply_SetExtractionOwnerTeam");
static_assert(offsetof(GzExtractorTowerSupply_SetExtractionOwnerTeam, TeamID) == 0x000000, "Member 'GzExtractorTowerSupply_SetExtractionOwnerTeam::TeamID' has a wrong offset!");

// Function G01.GzExtractorTowerSupply.SetProtectionDown
// 0x0001 (0x0001 - 0x0000)
struct GzExtractorTowerSupply_SetProtectionDown final
{
public:
	bool                                          bInProtectionDown;                                 // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzExtractorTowerSupply_SetProtectionDown) == 0x000001, "Wrong alignment on GzExtractorTowerSupply_SetProtectionDown");
static_assert(sizeof(GzExtractorTowerSupply_SetProtectionDown) == 0x000001, "Wrong size on GzExtractorTowerSupply_SetProtectionDown");
static_assert(offsetof(GzExtractorTowerSupply_SetProtectionDown, bInProtectionDown) == 0x000000, "Member 'GzExtractorTowerSupply_SetProtectionDown::bInProtectionDown' has a wrong offset!");

// Function G01.GzExtractorTowerSupply.GetDestroyedHeatSinkNum
// 0x0004 (0x0004 - 0x0000)
struct GzExtractorTowerSupply_GetDestroyedHeatSinkNum final
{
public:
	int32                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzExtractorTowerSupply_GetDestroyedHeatSinkNum) == 0x000004, "Wrong alignment on GzExtractorTowerSupply_GetDestroyedHeatSinkNum");
static_assert(sizeof(GzExtractorTowerSupply_GetDestroyedHeatSinkNum) == 0x000004, "Wrong size on GzExtractorTowerSupply_GetDestroyedHeatSinkNum");
static_assert(offsetof(GzExtractorTowerSupply_GetDestroyedHeatSinkNum, ReturnValue) == 0x000000, "Member 'GzExtractorTowerSupply_GetDestroyedHeatSinkNum::ReturnValue' has a wrong offset!");

// Function G01.GzExtractorTowerSupply.GetHeatSinks
// 0x0010 (0x0010 - 0x0000)
struct GzExtractorTowerSupply_GetHeatSinks final
{
public:
	TArray<class AGzDestructibleHeatSink*>        ReturnValue;                                       // 0x0000(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzExtractorTowerSupply_GetHeatSinks) == 0x000008, "Wrong alignment on GzExtractorTowerSupply_GetHeatSinks");
static_assert(sizeof(GzExtractorTowerSupply_GetHeatSinks) == 0x000010, "Wrong size on GzExtractorTowerSupply_GetHeatSinks");
static_assert(offsetof(GzExtractorTowerSupply_GetHeatSinks, ReturnValue) == 0x000000, "Member 'GzExtractorTowerSupply_GetHeatSinks::ReturnValue' has a wrong offset!");

// Function G01.GzExtractorTowerSupply.GetItemExtractor
// 0x0008 (0x0008 - 0x0000)
struct GzExtractorTowerSupply_GetItemExtractor final
{
public:
	class AGzItemExtractor*                       ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzExtractorTowerSupply_GetItemExtractor) == 0x000008, "Wrong alignment on GzExtractorTowerSupply_GetItemExtractor");
static_assert(sizeof(GzExtractorTowerSupply_GetItemExtractor) == 0x000008, "Wrong size on GzExtractorTowerSupply_GetItemExtractor");
static_assert(offsetof(GzExtractorTowerSupply_GetItemExtractor, ReturnValue) == 0x000000, "Member 'GzExtractorTowerSupply_GetItemExtractor::ReturnValue' has a wrong offset!");

// Function G01.GzExtractorTowerSupply.GetRemainingHeatSinkNum
// 0x0004 (0x0004 - 0x0000)
struct GzExtractorTowerSupply_GetRemainingHeatSinkNum final
{
public:
	int32                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzExtractorTowerSupply_GetRemainingHeatSinkNum) == 0x000004, "Wrong alignment on GzExtractorTowerSupply_GetRemainingHeatSinkNum");
static_assert(sizeof(GzExtractorTowerSupply_GetRemainingHeatSinkNum) == 0x000004, "Wrong size on GzExtractorTowerSupply_GetRemainingHeatSinkNum");
static_assert(offsetof(GzExtractorTowerSupply_GetRemainingHeatSinkNum, ReturnValue) == 0x000000, "Member 'GzExtractorTowerSupply_GetRemainingHeatSinkNum::ReturnValue' has a wrong offset!");

// Function G01.GzExtractorTowerSupply.IsHeatSinkDestroyed
// 0x0008 (0x0008 - 0x0000)
struct GzExtractorTowerSupply_IsHeatSinkDestroyed final
{
public:
	int32                                         Param_Index;                                       // 0x0000(0x0004)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0004(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3244[0x3];                                     // 0x0005(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GzExtractorTowerSupply_IsHeatSinkDestroyed) == 0x000004, "Wrong alignment on GzExtractorTowerSupply_IsHeatSinkDestroyed");
static_assert(sizeof(GzExtractorTowerSupply_IsHeatSinkDestroyed) == 0x000008, "Wrong size on GzExtractorTowerSupply_IsHeatSinkDestroyed");
static_assert(offsetof(GzExtractorTowerSupply_IsHeatSinkDestroyed, Param_Index) == 0x000000, "Member 'GzExtractorTowerSupply_IsHeatSinkDestroyed::Param_Index' has a wrong offset!");
static_assert(offsetof(GzExtractorTowerSupply_IsHeatSinkDestroyed, ReturnValue) == 0x000004, "Member 'GzExtractorTowerSupply_IsHeatSinkDestroyed::ReturnValue' has a wrong offset!");

// Function G01.GzExtractorTowerSupply.IsProtectionDown
// 0x0001 (0x0001 - 0x0000)
struct GzExtractorTowerSupply_IsProtectionDown final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzExtractorTowerSupply_IsProtectionDown) == 0x000001, "Wrong alignment on GzExtractorTowerSupply_IsProtectionDown");
static_assert(sizeof(GzExtractorTowerSupply_IsProtectionDown) == 0x000001, "Wrong size on GzExtractorTowerSupply_IsProtectionDown");
static_assert(offsetof(GzExtractorTowerSupply_IsProtectionDown, ReturnValue) == 0x000000, "Member 'GzExtractorTowerSupply_IsProtectionDown::ReturnValue' has a wrong offset!");

// Function G01.GzFactionSettings.GetFactionSettings
// 0x0008 (0x0008 - 0x0000)
struct GzFactionSettings_GetFactionSettings final
{
public:
	const class UGzFactionSettings*               ReturnValue;                                       // 0x0000(0x0008)(ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzFactionSettings_GetFactionSettings) == 0x000008, "Wrong alignment on GzFactionSettings_GetFactionSettings");
static_assert(sizeof(GzFactionSettings_GetFactionSettings) == 0x000008, "Wrong size on GzFactionSettings_GetFactionSettings");
static_assert(offsetof(GzFactionSettings_GetFactionSettings, ReturnValue) == 0x000000, "Member 'GzFactionSettings_GetFactionSettings::ReturnValue' has a wrong offset!");

// Function G01.GzFactionUtility.GetFactionData
// 0x0050 (0x0050 - 0x0000)
struct GzFactionUtility_GetFactionData final
{
public:
	struct FGzFactionKey                          Faction;                                           // 0x0000(0x0008)(Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGzFaction                             ReturnValue;                                       // 0x0008(0x0048)(Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzFactionUtility_GetFactionData) == 0x000008, "Wrong alignment on GzFactionUtility_GetFactionData");
static_assert(sizeof(GzFactionUtility_GetFactionData) == 0x000050, "Wrong size on GzFactionUtility_GetFactionData");
static_assert(offsetof(GzFactionUtility_GetFactionData, Faction) == 0x000000, "Member 'GzFactionUtility_GetFactionData::Faction' has a wrong offset!");
static_assert(offsetof(GzFactionUtility_GetFactionData, ReturnValue) == 0x000008, "Member 'GzFactionUtility_GetFactionData::ReturnValue' has a wrong offset!");

// Function G01.GzFactionUtility.GetFactionId
// 0x000C (0x000C - 0x0000)
struct GzFactionUtility_GetFactionId final
{
public:
	struct FGzFactionKey                          Faction;                                           // 0x0000(0x0008)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ReturnValue;                                       // 0x0008(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzFactionUtility_GetFactionId) == 0x000004, "Wrong alignment on GzFactionUtility_GetFactionId");
static_assert(sizeof(GzFactionUtility_GetFactionId) == 0x00000C, "Wrong size on GzFactionUtility_GetFactionId");
static_assert(offsetof(GzFactionUtility_GetFactionId, Faction) == 0x000000, "Member 'GzFactionUtility_GetFactionId::Faction' has a wrong offset!");
static_assert(offsetof(GzFactionUtility_GetFactionId, ReturnValue) == 0x000008, "Member 'GzFactionUtility_GetFactionId::ReturnValue' has a wrong offset!");

// Function G01.GzFactionUtility.GetFactionsNames
// 0x0010 (0x0010 - 0x0000)
struct GzFactionUtility_GetFactionsNames final
{
public:
	TArray<class FName>                           ReturnValue;                                       // 0x0000(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzFactionUtility_GetFactionsNames) == 0x000008, "Wrong alignment on GzFactionUtility_GetFactionsNames");
static_assert(sizeof(GzFactionUtility_GetFactionsNames) == 0x000010, "Wrong size on GzFactionUtility_GetFactionsNames");
static_assert(offsetof(GzFactionUtility_GetFactionsNames, ReturnValue) == 0x000000, "Member 'GzFactionUtility_GetFactionsNames::ReturnValue' has a wrong offset!");

// Function G01.GzFactionUtility.GetPlayerFactionIds
// 0x0010 (0x0010 - 0x0000)
struct GzFactionUtility_GetPlayerFactionIds final
{
public:
	TArray<int32>                                 ReturnValue;                                       // 0x0000(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzFactionUtility_GetPlayerFactionIds) == 0x000008, "Wrong alignment on GzFactionUtility_GetPlayerFactionIds");
static_assert(sizeof(GzFactionUtility_GetPlayerFactionIds) == 0x000010, "Wrong size on GzFactionUtility_GetPlayerFactionIds");
static_assert(offsetof(GzFactionUtility_GetPlayerFactionIds, ReturnValue) == 0x000000, "Member 'GzFactionUtility_GetPlayerFactionIds::ReturnValue' has a wrong offset!");

// Function G01.GzFactionUtility.GetPlayerFactionsNames
// 0x0010 (0x0010 - 0x0000)
struct GzFactionUtility_GetPlayerFactionsNames final
{
public:
	TArray<class FName>                           ReturnValue;                                       // 0x0000(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzFactionUtility_GetPlayerFactionsNames) == 0x000008, "Wrong alignment on GzFactionUtility_GetPlayerFactionsNames");
static_assert(sizeof(GzFactionUtility_GetPlayerFactionsNames) == 0x000010, "Wrong size on GzFactionUtility_GetPlayerFactionsNames");
static_assert(offsetof(GzFactionUtility_GetPlayerFactionsNames, ReturnValue) == 0x000000, "Member 'GzFactionUtility_GetPlayerFactionsNames::ReturnValue' has a wrong offset!");

// Function G01.GzFactionUtility.GetRandomFactionId
// 0x0004 (0x0004 - 0x0000)
struct GzFactionUtility_GetRandomFactionId final
{
public:
	int32                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzFactionUtility_GetRandomFactionId) == 0x000004, "Wrong alignment on GzFactionUtility_GetRandomFactionId");
static_assert(sizeof(GzFactionUtility_GetRandomFactionId) == 0x000004, "Wrong size on GzFactionUtility_GetRandomFactionId");
static_assert(offsetof(GzFactionUtility_GetRandomFactionId, ReturnValue) == 0x000000, "Member 'GzFactionUtility_GetRandomFactionId::ReturnValue' has a wrong offset!");

// Function G01.GzPolygonMarkerShape.GetWorldPoints
// 0x0010 (0x0010 - 0x0000)
struct GzPolygonMarkerShape_GetWorldPoints final
{
public:
	TArray<struct FVector>                        ReturnValue;                                       // 0x0000(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzPolygonMarkerShape_GetWorldPoints) == 0x000008, "Wrong alignment on GzPolygonMarkerShape_GetWorldPoints");
static_assert(sizeof(GzPolygonMarkerShape_GetWorldPoints) == 0x000010, "Wrong size on GzPolygonMarkerShape_GetWorldPoints");
static_assert(offsetof(GzPolygonMarkerShape_GetWorldPoints, ReturnValue) == 0x000000, "Member 'GzPolygonMarkerShape_GetWorldPoints::ReturnValue' has a wrong offset!");

// Function G01.GzFailedObjective.MakeCompletedObjective
// 0x0010 (0x0010 - 0x0000)
struct GzFailedObjective_MakeCompletedObjective final
{
public:
	class AGzAdvancedMission*                     Mission;                                           // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UGzObjective*                           ReturnValue;                                       // 0x0008(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzFailedObjective_MakeCompletedObjective) == 0x000008, "Wrong alignment on GzFailedObjective_MakeCompletedObjective");
static_assert(sizeof(GzFailedObjective_MakeCompletedObjective) == 0x000010, "Wrong size on GzFailedObjective_MakeCompletedObjective");
static_assert(offsetof(GzFailedObjective_MakeCompletedObjective, Mission) == 0x000000, "Member 'GzFailedObjective_MakeCompletedObjective::Mission' has a wrong offset!");
static_assert(offsetof(GzFailedObjective_MakeCompletedObjective, ReturnValue) == 0x000008, "Member 'GzFailedObjective_MakeCompletedObjective::ReturnValue' has a wrong offset!");

// Function G01.GzFeedbackProviderSubsystem.PlayHitResponse
// 0x0048 (0x0048 - 0x0000)
struct GzFeedbackProviderSubsystem_PlayHitResponse final
{
public:
	class AActor*                                 TargetActor;                                       // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 Instigator;                                        // 0x0008(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGzHitResponseData                     HitResponseData;                                   // 0x0010(0x0038)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzFeedbackProviderSubsystem_PlayHitResponse) == 0x000008, "Wrong alignment on GzFeedbackProviderSubsystem_PlayHitResponse");
static_assert(sizeof(GzFeedbackProviderSubsystem_PlayHitResponse) == 0x000048, "Wrong size on GzFeedbackProviderSubsystem_PlayHitResponse");
static_assert(offsetof(GzFeedbackProviderSubsystem_PlayHitResponse, TargetActor) == 0x000000, "Member 'GzFeedbackProviderSubsystem_PlayHitResponse::TargetActor' has a wrong offset!");
static_assert(offsetof(GzFeedbackProviderSubsystem_PlayHitResponse, Instigator) == 0x000008, "Member 'GzFeedbackProviderSubsystem_PlayHitResponse::Instigator' has a wrong offset!");
static_assert(offsetof(GzFeedbackProviderSubsystem_PlayHitResponse, HitResponseData) == 0x000010, "Member 'GzFeedbackProviderSubsystem_PlayHitResponse::HitResponseData' has a wrong offset!");

// Function G01.GzJobZeroPlayerController.ClientSetJobZeroResult
// 0x0018 (0x0018 - 0x0000)
struct GzJobZeroPlayerController_ClientSetJobZeroResult final
{
public:
	struct FGzJobZeroMatchResult                  Result;                                            // 0x0000(0x0018)(ConstParm, Parm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzJobZeroPlayerController_ClientSetJobZeroResult) == 0x000008, "Wrong alignment on GzJobZeroPlayerController_ClientSetJobZeroResult");
static_assert(sizeof(GzJobZeroPlayerController_ClientSetJobZeroResult) == 0x000018, "Wrong size on GzJobZeroPlayerController_ClientSetJobZeroResult");
static_assert(offsetof(GzJobZeroPlayerController_ClientSetJobZeroResult, Result) == 0x000000, "Member 'GzJobZeroPlayerController_ClientSetJobZeroResult::Result' has a wrong offset!");

// Function G01.GzJobZeroPlayerController.HasJobZeroResults
// 0x0001 (0x0001 - 0x0000)
struct GzJobZeroPlayerController_HasJobZeroResults final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzJobZeroPlayerController_HasJobZeroResults) == 0x000001, "Wrong alignment on GzJobZeroPlayerController_HasJobZeroResults");
static_assert(sizeof(GzJobZeroPlayerController_HasJobZeroResults) == 0x000001, "Wrong size on GzJobZeroPlayerController_HasJobZeroResults");
static_assert(offsetof(GzJobZeroPlayerController_HasJobZeroResults, ReturnValue) == 0x000000, "Member 'GzJobZeroPlayerController_HasJobZeroResults::ReturnValue' has a wrong offset!");

// Function G01.GzFlowStateManagerCheatExtension.LoginWithPlayFab
// 0x0020 (0x0020 - 0x0000)
struct GzFlowStateManagerCheatExtension_LoginWithPlayFab final
{
public:
	class FString                                 Login;                                             // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Password;                                          // 0x0010(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzFlowStateManagerCheatExtension_LoginWithPlayFab) == 0x000008, "Wrong alignment on GzFlowStateManagerCheatExtension_LoginWithPlayFab");
static_assert(sizeof(GzFlowStateManagerCheatExtension_LoginWithPlayFab) == 0x000020, "Wrong size on GzFlowStateManagerCheatExtension_LoginWithPlayFab");
static_assert(offsetof(GzFlowStateManagerCheatExtension_LoginWithPlayFab, Login) == 0x000000, "Member 'GzFlowStateManagerCheatExtension_LoginWithPlayFab::Login' has a wrong offset!");
static_assert(offsetof(GzFlowStateManagerCheatExtension_LoginWithPlayFab, Password) == 0x000010, "Member 'GzFlowStateManagerCheatExtension_LoginWithPlayFab::Password' has a wrong offset!");

// Function G01.GzFlowStateManagerCheatExtension.SetPlayFabId
// 0x0010 (0x0010 - 0x0000)
struct GzFlowStateManagerCheatExtension_SetPlayFabId final
{
public:
	class FString                                 PlayFabId;                                         // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzFlowStateManagerCheatExtension_SetPlayFabId) == 0x000008, "Wrong alignment on GzFlowStateManagerCheatExtension_SetPlayFabId");
static_assert(sizeof(GzFlowStateManagerCheatExtension_SetPlayFabId) == 0x000010, "Wrong size on GzFlowStateManagerCheatExtension_SetPlayFabId");
static_assert(offsetof(GzFlowStateManagerCheatExtension_SetPlayFabId, PlayFabId) == 0x000000, "Member 'GzFlowStateManagerCheatExtension_SetPlayFabId::PlayFabId' has a wrong offset!");

// Function G01.GzGadgetMovementComponent.Move
// 0x0090 (0x0090 - 0x0000)
struct GzGadgetMovementComponent_Move final
{
public:
	struct FGzGadgetMoveData                      Data;                                              // 0x0000(0x0090)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzGadgetMovementComponent_Move) == 0x000010, "Wrong alignment on GzGadgetMovementComponent_Move");
static_assert(sizeof(GzGadgetMovementComponent_Move) == 0x000090, "Wrong size on GzGadgetMovementComponent_Move");
static_assert(offsetof(GzGadgetMovementComponent_Move, Data) == 0x000000, "Member 'GzGadgetMovementComponent_Move::Data' has a wrong offset!");

// Function G01.GzGadgetMovementComponent.OnParentDestroyed
// 0x0008 (0x0008 - 0x0000)
struct GzGadgetMovementComponent_OnParentDestroyed final
{
public:
	class AActor*                                 DestroyedActor;                                    // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzGadgetMovementComponent_OnParentDestroyed) == 0x000008, "Wrong alignment on GzGadgetMovementComponent_OnParentDestroyed");
static_assert(sizeof(GzGadgetMovementComponent_OnParentDestroyed) == 0x000008, "Wrong size on GzGadgetMovementComponent_OnParentDestroyed");
static_assert(offsetof(GzGadgetMovementComponent_OnParentDestroyed, DestroyedActor) == 0x000000, "Member 'GzGadgetMovementComponent_OnParentDestroyed::DestroyedActor' has a wrong offset!");

// Function G01.GzGadgetMovementComponent.OnParentRecieveDamage
// 0x01F8 (0x01F8 - 0x0000)
struct GzGadgetMovementComponent_OnParentRecieveDamage final
{
public:
	class UGzDamageableComponent*                 Receiver;                                          // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGzSingleHitDamage                     Hit;                                               // 0x0008(0x01F0)(ConstParm, Parm, OutParm, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzGadgetMovementComponent_OnParentRecieveDamage) == 0x000008, "Wrong alignment on GzGadgetMovementComponent_OnParentRecieveDamage");
static_assert(sizeof(GzGadgetMovementComponent_OnParentRecieveDamage) == 0x0001F8, "Wrong size on GzGadgetMovementComponent_OnParentRecieveDamage");
static_assert(offsetof(GzGadgetMovementComponent_OnParentRecieveDamage, Receiver) == 0x000000, "Member 'GzGadgetMovementComponent_OnParentRecieveDamage::Receiver' has a wrong offset!");
static_assert(offsetof(GzGadgetMovementComponent_OnParentRecieveDamage, Hit) == 0x000008, "Member 'GzGadgetMovementComponent_OnParentRecieveDamage::Hit' has a wrong offset!");

// Function G01.GzGadgetMovementComponent.OnParentRecieveMultiDamage
// 0x0050 (0x0050 - 0x0000)
struct GzGadgetMovementComponent_OnParentRecieveMultiDamage final
{
public:
	class UGzDamageableComponent*                 Receiver;                                          // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGzMultiHitDamage                      Hit;                                               // 0x0008(0x0048)(ConstParm, Parm, OutParm, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzGadgetMovementComponent_OnParentRecieveMultiDamage) == 0x000008, "Wrong alignment on GzGadgetMovementComponent_OnParentRecieveMultiDamage");
static_assert(sizeof(GzGadgetMovementComponent_OnParentRecieveMultiDamage) == 0x000050, "Wrong size on GzGadgetMovementComponent_OnParentRecieveMultiDamage");
static_assert(offsetof(GzGadgetMovementComponent_OnParentRecieveMultiDamage, Receiver) == 0x000000, "Member 'GzGadgetMovementComponent_OnParentRecieveMultiDamage::Receiver' has a wrong offset!");
static_assert(offsetof(GzGadgetMovementComponent_OnParentRecieveMultiDamage, Hit) == 0x000008, "Member 'GzGadgetMovementComponent_OnParentRecieveMultiDamage::Hit' has a wrong offset!");

// Function G01.GzGadgetValidAttachment.CanAttachTo
// 0x0010 (0x0010 - 0x0000)
struct GzGadgetValidAttachment_CanAttachTo final
{
public:
	class AActor*                                 Actor;                                             // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3257[0x7];                                     // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GzGadgetValidAttachment_CanAttachTo) == 0x000008, "Wrong alignment on GzGadgetValidAttachment_CanAttachTo");
static_assert(sizeof(GzGadgetValidAttachment_CanAttachTo) == 0x000010, "Wrong size on GzGadgetValidAttachment_CanAttachTo");
static_assert(offsetof(GzGadgetValidAttachment_CanAttachTo, Actor) == 0x000000, "Member 'GzGadgetValidAttachment_CanAttachTo::Actor' has a wrong offset!");
static_assert(offsetof(GzGadgetValidAttachment_CanAttachTo, ReturnValue) == 0x000008, "Member 'GzGadgetValidAttachment_CanAttachTo::ReturnValue' has a wrong offset!");

// Function G01.GzGadgetValidAttachment.IsValidAttachment
// 0x0001 (0x0001 - 0x0000)
struct GzGadgetValidAttachment_IsValidAttachment final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzGadgetValidAttachment_IsValidAttachment) == 0x000001, "Wrong alignment on GzGadgetValidAttachment_IsValidAttachment");
static_assert(sizeof(GzGadgetValidAttachment_IsValidAttachment) == 0x000001, "Wrong size on GzGadgetValidAttachment_IsValidAttachment");
static_assert(offsetof(GzGadgetValidAttachment_IsValidAttachment, ReturnValue) == 0x000000, "Member 'GzGadgetValidAttachment_IsValidAttachment::ReturnValue' has a wrong offset!");

// Function G01.GzGameMessageSubsystem.BP_PostMessage
// 0x0008 (0x0008 - 0x0000)
struct GzGameMessageSubsystem_BP_PostMessage final
{
public:
	class UGzGameMessage*                         Message;                                           // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzGameMessageSubsystem_BP_PostMessage) == 0x000008, "Wrong alignment on GzGameMessageSubsystem_BP_PostMessage");
static_assert(sizeof(GzGameMessageSubsystem_BP_PostMessage) == 0x000008, "Wrong size on GzGameMessageSubsystem_BP_PostMessage");
static_assert(offsetof(GzGameMessageSubsystem_BP_PostMessage, Message) == 0x000000, "Member 'GzGameMessageSubsystem_BP_PostMessage::Message' has a wrong offset!");

// Function G01.GzGameMessageSubsystem.BP_PostMessageToPlayers
// 0x0018 (0x0018 - 0x0000)
struct GzGameMessageSubsystem_BP_PostMessageToPlayers final
{
public:
	class UGzGameMessage*                         Message;                                           // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class AGzPlayerController*>            Receivers;                                         // 0x0008(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzGameMessageSubsystem_BP_PostMessageToPlayers) == 0x000008, "Wrong alignment on GzGameMessageSubsystem_BP_PostMessageToPlayers");
static_assert(sizeof(GzGameMessageSubsystem_BP_PostMessageToPlayers) == 0x000018, "Wrong size on GzGameMessageSubsystem_BP_PostMessageToPlayers");
static_assert(offsetof(GzGameMessageSubsystem_BP_PostMessageToPlayers, Message) == 0x000000, "Member 'GzGameMessageSubsystem_BP_PostMessageToPlayers::Message' has a wrong offset!");
static_assert(offsetof(GzGameMessageSubsystem_BP_PostMessageToPlayers, Receivers) == 0x000008, "Member 'GzGameMessageSubsystem_BP_PostMessageToPlayers::Receivers' has a wrong offset!");

// Function G01.GzGameMessageSubsystem.BP_PostMessageToTeam
// 0x0010 (0x0010 - 0x0000)
struct GzGameMessageSubsystem_BP_PostMessageToTeam final
{
public:
	class UGzGameMessage*                         Message;                                           // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AGzTeam*                                Team;                                              // 0x0008(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzGameMessageSubsystem_BP_PostMessageToTeam) == 0x000008, "Wrong alignment on GzGameMessageSubsystem_BP_PostMessageToTeam");
static_assert(sizeof(GzGameMessageSubsystem_BP_PostMessageToTeam) == 0x000010, "Wrong size on GzGameMessageSubsystem_BP_PostMessageToTeam");
static_assert(offsetof(GzGameMessageSubsystem_BP_PostMessageToTeam, Message) == 0x000000, "Member 'GzGameMessageSubsystem_BP_PostMessageToTeam::Message' has a wrong offset!");
static_assert(offsetof(GzGameMessageSubsystem_BP_PostMessageToTeam, Team) == 0x000008, "Member 'GzGameMessageSubsystem_BP_PostMessageToTeam::Team' has a wrong offset!");

// Function G01.GzGameMessageSubsystem.GetInstance
// 0x0010 (0x0010 - 0x0000)
struct GzGameMessageSubsystem_GetInstance final
{
public:
	class UObject*                                WorldContextObject;                                // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AGzGameMessageSubsystem*                ReturnValue;                                       // 0x0008(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzGameMessageSubsystem_GetInstance) == 0x000008, "Wrong alignment on GzGameMessageSubsystem_GetInstance");
static_assert(sizeof(GzGameMessageSubsystem_GetInstance) == 0x000010, "Wrong size on GzGameMessageSubsystem_GetInstance");
static_assert(offsetof(GzGameMessageSubsystem_GetInstance, WorldContextObject) == 0x000000, "Member 'GzGameMessageSubsystem_GetInstance::WorldContextObject' has a wrong offset!");
static_assert(offsetof(GzGameMessageSubsystem_GetInstance, ReturnValue) == 0x000008, "Member 'GzGameMessageSubsystem_GetInstance::ReturnValue' has a wrong offset!");

// Function G01.GzGameMessageSubsystem.DistributeMessage
// 0x0018 (0x0018 - 0x0000)
struct GzGameMessageSubsystem_DistributeMessage final
{
public:
	struct FGzMessageNetData                      MessageData;                                       // 0x0000(0x0018)(Parm, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzGameMessageSubsystem_DistributeMessage) == 0x000008, "Wrong alignment on GzGameMessageSubsystem_DistributeMessage");
static_assert(sizeof(GzGameMessageSubsystem_DistributeMessage) == 0x000018, "Wrong size on GzGameMessageSubsystem_DistributeMessage");
static_assert(offsetof(GzGameMessageSubsystem_DistributeMessage, MessageData) == 0x000000, "Member 'GzGameMessageSubsystem_DistributeMessage::MessageData' has a wrong offset!");

// Function G01.GzGameMessageSubsystem.SubscribeToMessage
// 0x0018 (0x0018 - 0x0000)
struct GzGameMessageSubsystem_SubscribeToMessage final
{
public:
	TSubclassOf<class UGzGameMessage>             MessageClass;                                      // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TDelegate<void(class UGzGameMessage* Message)> BPCallback;                                        // 0x0008(0x0010)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzGameMessageSubsystem_SubscribeToMessage) == 0x000008, "Wrong alignment on GzGameMessageSubsystem_SubscribeToMessage");
static_assert(sizeof(GzGameMessageSubsystem_SubscribeToMessage) == 0x000018, "Wrong size on GzGameMessageSubsystem_SubscribeToMessage");
static_assert(offsetof(GzGameMessageSubsystem_SubscribeToMessage, MessageClass) == 0x000000, "Member 'GzGameMessageSubsystem_SubscribeToMessage::MessageClass' has a wrong offset!");
static_assert(offsetof(GzGameMessageSubsystem_SubscribeToMessage, BPCallback) == 0x000008, "Member 'GzGameMessageSubsystem_SubscribeToMessage::BPCallback' has a wrong offset!");

// Function G01.GzGameMessageSubsystem.UnsubscribeToMessage
// 0x0010 (0x0010 - 0x0000)
struct GzGameMessageSubsystem_UnsubscribeToMessage final
{
public:
	TSubclassOf<class UGzGameMessage>             MessageClass;                                      // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UObject*                                DelegateObject;                                    // 0x0008(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzGameMessageSubsystem_UnsubscribeToMessage) == 0x000008, "Wrong alignment on GzGameMessageSubsystem_UnsubscribeToMessage");
static_assert(sizeof(GzGameMessageSubsystem_UnsubscribeToMessage) == 0x000010, "Wrong size on GzGameMessageSubsystem_UnsubscribeToMessage");
static_assert(offsetof(GzGameMessageSubsystem_UnsubscribeToMessage, MessageClass) == 0x000000, "Member 'GzGameMessageSubsystem_UnsubscribeToMessage::MessageClass' has a wrong offset!");
static_assert(offsetof(GzGameMessageSubsystem_UnsubscribeToMessage, DelegateObject) == 0x000008, "Member 'GzGameMessageSubsystem_UnsubscribeToMessage::DelegateObject' has a wrong offset!");

// Function G01.GzGameNotificationBody.SetNotificationData
// 0x00A8 (0x00A8 - 0x0000)
struct GzGameNotificationBody_SetNotificationData final
{
public:
	struct FGzGameNotificationSpec                InNotificationSpec;                                // 0x0000(0x00A0)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	class UGzNotificationDisplayData*             InDisplayData;                                     // 0x00A0(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzGameNotificationBody_SetNotificationData) == 0x000008, "Wrong alignment on GzGameNotificationBody_SetNotificationData");
static_assert(sizeof(GzGameNotificationBody_SetNotificationData) == 0x0000A8, "Wrong size on GzGameNotificationBody_SetNotificationData");
static_assert(offsetof(GzGameNotificationBody_SetNotificationData, InNotificationSpec) == 0x000000, "Member 'GzGameNotificationBody_SetNotificationData::InNotificationSpec' has a wrong offset!");
static_assert(offsetof(GzGameNotificationBody_SetNotificationData, InDisplayData) == 0x0000A0, "Member 'GzGameNotificationBody_SetNotificationData::InDisplayData' has a wrong offset!");

// Function G01.GzGameNotificationBody.UpdateNotificationData
// 0x0001 (0x0001 - 0x0000)
struct GzGameNotificationBody_UpdateNotificationData final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzGameNotificationBody_UpdateNotificationData) == 0x000001, "Wrong alignment on GzGameNotificationBody_UpdateNotificationData");
static_assert(sizeof(GzGameNotificationBody_UpdateNotificationData) == 0x000001, "Wrong size on GzGameNotificationBody_UpdateNotificationData");
static_assert(offsetof(GzGameNotificationBody_UpdateNotificationData, ReturnValue) == 0x000000, "Member 'GzGameNotificationBody_UpdateNotificationData::ReturnValue' has a wrong offset!");

// Function G01.GzGameNotificationBody.GetDisplayData
// 0x0008 (0x0008 - 0x0000)
struct GzGameNotificationBody_GetDisplayData final
{
public:
	class UGzNotificationDisplayData*             ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzGameNotificationBody_GetDisplayData) == 0x000008, "Wrong alignment on GzGameNotificationBody_GetDisplayData");
static_assert(sizeof(GzGameNotificationBody_GetDisplayData) == 0x000008, "Wrong size on GzGameNotificationBody_GetDisplayData");
static_assert(offsetof(GzGameNotificationBody_GetDisplayData, ReturnValue) == 0x000000, "Member 'GzGameNotificationBody_GetDisplayData::ReturnValue' has a wrong offset!");

// Function G01.GzGameNotificationBody.GetNotificationSpec
// 0x00A0 (0x00A0 - 0x0000)
struct GzGameNotificationBody_GetNotificationSpec final
{
public:
	struct FGzGameNotificationSpec                ReturnValue;                                       // 0x0000(0x00A0)(ConstParm, Parm, OutParm, ReturnParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzGameNotificationBody_GetNotificationSpec) == 0x000008, "Wrong alignment on GzGameNotificationBody_GetNotificationSpec");
static_assert(sizeof(GzGameNotificationBody_GetNotificationSpec) == 0x0000A0, "Wrong size on GzGameNotificationBody_GetNotificationSpec");
static_assert(offsetof(GzGameNotificationBody_GetNotificationSpec, ReturnValue) == 0x000000, "Member 'GzGameNotificationBody_GetNotificationSpec::ReturnValue' has a wrong offset!");

// Function G01.GzGA_MicroMissiles.OnMissileShootingFinished
// 0x0004 (0x0004 - 0x0000)
struct GzGA_MicroMissiles_OnMissileShootingFinished final
{
public:
	int32                                         MissileIndex;                                      // 0x0000(0x0004)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzGA_MicroMissiles_OnMissileShootingFinished) == 0x000004, "Wrong alignment on GzGA_MicroMissiles_OnMissileShootingFinished");
static_assert(sizeof(GzGA_MicroMissiles_OnMissileShootingFinished) == 0x000004, "Wrong size on GzGA_MicroMissiles_OnMissileShootingFinished");
static_assert(offsetof(GzGA_MicroMissiles_OnMissileShootingFinished, MissileIndex) == 0x000000, "Member 'GzGA_MicroMissiles_OnMissileShootingFinished::MissileIndex' has a wrong offset!");

// Function G01.GzGA_MicroMissiles.ShootMissile
// 0x0004 (0x0004 - 0x0000)
struct GzGA_MicroMissiles_ShootMissile final
{
public:
	int32                                         MissileIndex;                                      // 0x0000(0x0004)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzGA_MicroMissiles_ShootMissile) == 0x000004, "Wrong alignment on GzGA_MicroMissiles_ShootMissile");
static_assert(sizeof(GzGA_MicroMissiles_ShootMissile) == 0x000004, "Wrong size on GzGA_MicroMissiles_ShootMissile");
static_assert(offsetof(GzGA_MicroMissiles_ShootMissile, MissileIndex) == 0x000000, "Member 'GzGA_MicroMissiles_ShootMissile::MissileIndex' has a wrong offset!");

// Function G01.GzGA_MicroMissiles.StartShootingMissiles
// 0x0028 (0x0028 - 0x0000)
struct GzGA_MicroMissiles_StartShootingMissiles final
{
public:
	struct FGameplayAbilityTargetDataHandle       TargetDataHandle;                                  // 0x0000(0x0028)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzGA_MicroMissiles_StartShootingMissiles) == 0x000008, "Wrong alignment on GzGA_MicroMissiles_StartShootingMissiles");
static_assert(sizeof(GzGA_MicroMissiles_StartShootingMissiles) == 0x000028, "Wrong size on GzGA_MicroMissiles_StartShootingMissiles");
static_assert(offsetof(GzGA_MicroMissiles_StartShootingMissiles, TargetDataHandle) == 0x000000, "Member 'GzGA_MicroMissiles_StartShootingMissiles::TargetDataHandle' has a wrong offset!");

// Function G01.GzSettingsMenuWidget.AddMappingUpdateNotification
// 0x0010 (0x0010 - 0x0000)
struct GzSettingsMenuWidget_AddMappingUpdateNotification final
{
public:
	TArray<struct FGzInputActionMappingChange>    InputActionMappingChanges;                         // 0x0000(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzSettingsMenuWidget_AddMappingUpdateNotification) == 0x000008, "Wrong alignment on GzSettingsMenuWidget_AddMappingUpdateNotification");
static_assert(sizeof(GzSettingsMenuWidget_AddMappingUpdateNotification) == 0x000010, "Wrong size on GzSettingsMenuWidget_AddMappingUpdateNotification");
static_assert(offsetof(GzSettingsMenuWidget_AddMappingUpdateNotification, InputActionMappingChanges) == 0x000000, "Member 'GzSettingsMenuWidget_AddMappingUpdateNotification::InputActionMappingChanges' has a wrong offset!");

// Function G01.GzSettingsMenuWidget.InitResetConfirmation
// 0x0008 (0x0008 - 0x0000)
struct GzSettingsMenuWidget_InitResetConfirmation final
{
public:
	class UGzNavigationWidget*                    NavigationWidget;                                  // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzSettingsMenuWidget_InitResetConfirmation) == 0x000008, "Wrong alignment on GzSettingsMenuWidget_InitResetConfirmation");
static_assert(sizeof(GzSettingsMenuWidget_InitResetConfirmation) == 0x000008, "Wrong size on GzSettingsMenuWidget_InitResetConfirmation");
static_assert(offsetof(GzSettingsMenuWidget_InitResetConfirmation, NavigationWidget) == 0x000000, "Member 'GzSettingsMenuWidget_InitResetConfirmation::NavigationWidget' has a wrong offset!");

// Function G01.GzSettingsMenuWidget.OnTabSelected
// 0x0008 (0x0008 - 0x0000)
struct GzSettingsMenuWidget_OnTabSelected final
{
public:
	class FName                                   TabId;                                             // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzSettingsMenuWidget_OnTabSelected) == 0x000004, "Wrong alignment on GzSettingsMenuWidget_OnTabSelected");
static_assert(sizeof(GzSettingsMenuWidget_OnTabSelected) == 0x000008, "Wrong size on GzSettingsMenuWidget_OnTabSelected");
static_assert(offsetof(GzSettingsMenuWidget_OnTabSelected, TabId) == 0x000000, "Member 'GzSettingsMenuWidget_OnTabSelected::TabId' has a wrong offset!");

// Function G01.GzLootArchetypeTableData.RollItemArchetype
// 0x0010 (0x0010 - 0x0000)
struct GzLootArchetypeTableData_RollItemArchetype final
{
public:
	const class UGzLootModifierTableData*         ModifiersTable;                                    // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UGzLootArchetypeData*                   ReturnValue;                                       // 0x0008(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzLootArchetypeTableData_RollItemArchetype) == 0x000008, "Wrong alignment on GzLootArchetypeTableData_RollItemArchetype");
static_assert(sizeof(GzLootArchetypeTableData_RollItemArchetype) == 0x000010, "Wrong size on GzLootArchetypeTableData_RollItemArchetype");
static_assert(offsetof(GzLootArchetypeTableData_RollItemArchetype, ModifiersTable) == 0x000000, "Member 'GzLootArchetypeTableData_RollItemArchetype::ModifiersTable' has a wrong offset!");
static_assert(offsetof(GzLootArchetypeTableData_RollItemArchetype, ReturnValue) == 0x000008, "Member 'GzLootArchetypeTableData_RollItemArchetype::ReturnValue' has a wrong offset!");

// Function G01.GzLootArchetypeTableData.RollItemArchetypeWithModArray
// 0x0018 (0x0018 - 0x0000)
struct GzLootArchetypeTableData_RollItemArchetypeWithModArray final
{
public:
	TArray<struct FGzLootModifier>                ModifiersTable;                                    // 0x0000(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	class UGzLootArchetypeData*                   ReturnValue;                                       // 0x0010(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzLootArchetypeTableData_RollItemArchetypeWithModArray) == 0x000008, "Wrong alignment on GzLootArchetypeTableData_RollItemArchetypeWithModArray");
static_assert(sizeof(GzLootArchetypeTableData_RollItemArchetypeWithModArray) == 0x000018, "Wrong size on GzLootArchetypeTableData_RollItemArchetypeWithModArray");
static_assert(offsetof(GzLootArchetypeTableData_RollItemArchetypeWithModArray, ModifiersTable) == 0x000000, "Member 'GzLootArchetypeTableData_RollItemArchetypeWithModArray::ModifiersTable' has a wrong offset!");
static_assert(offsetof(GzLootArchetypeTableData_RollItemArchetypeWithModArray, ReturnValue) == 0x000010, "Member 'GzLootArchetypeTableData_RollItemArchetypeWithModArray::ReturnValue' has a wrong offset!");

// Function G01.GzNotificationContainerBase.GetNotificationSettings
// 0x0008 (0x0008 - 0x0000)
struct GzNotificationContainerBase_GetNotificationSettings final
{
public:
	struct FGzNotificationSettings                ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzNotificationContainerBase_GetNotificationSettings) == 0x000004, "Wrong alignment on GzNotificationContainerBase_GetNotificationSettings");
static_assert(sizeof(GzNotificationContainerBase_GetNotificationSettings) == 0x000008, "Wrong size on GzNotificationContainerBase_GetNotificationSettings");
static_assert(offsetof(GzNotificationContainerBase_GetNotificationSettings, ReturnValue) == 0x000000, "Member 'GzNotificationContainerBase_GetNotificationSettings::ReturnValue' has a wrong offset!");

// Function G01.GzGameNotificationContainer.CanCreateNotification
// 0x000C (0x000C - 0x0000)
struct GzGameNotificationContainer_CanCreateNotification final
{
public:
	class FName                                   InNotificationID;                                  // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3268[0x3];                                     // 0x0009(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GzGameNotificationContainer_CanCreateNotification) == 0x000004, "Wrong alignment on GzGameNotificationContainer_CanCreateNotification");
static_assert(sizeof(GzGameNotificationContainer_CanCreateNotification) == 0x00000C, "Wrong size on GzGameNotificationContainer_CanCreateNotification");
static_assert(offsetof(GzGameNotificationContainer_CanCreateNotification, InNotificationID) == 0x000000, "Member 'GzGameNotificationContainer_CanCreateNotification::InNotificationID' has a wrong offset!");
static_assert(offsetof(GzGameNotificationContainer_CanCreateNotification, ReturnValue) == 0x000008, "Member 'GzGameNotificationContainer_CanCreateNotification::ReturnValue' has a wrong offset!");

// Function G01.GzGameNotificationContainer.CreateNotifiction
// 0x0018 (0x0018 - 0x0000)
struct GzGameNotificationContainer_CreateNotifiction final
{
public:
	class FName                                   InNotificationID;                                  // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UGzGameNotificationDisplayData*         NotificationData;                                  // 0x0008(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0010(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3269[0x7];                                     // 0x0011(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GzGameNotificationContainer_CreateNotifiction) == 0x000008, "Wrong alignment on GzGameNotificationContainer_CreateNotifiction");
static_assert(sizeof(GzGameNotificationContainer_CreateNotifiction) == 0x000018, "Wrong size on GzGameNotificationContainer_CreateNotifiction");
static_assert(offsetof(GzGameNotificationContainer_CreateNotifiction, InNotificationID) == 0x000000, "Member 'GzGameNotificationContainer_CreateNotifiction::InNotificationID' has a wrong offset!");
static_assert(offsetof(GzGameNotificationContainer_CreateNotifiction, NotificationData) == 0x000008, "Member 'GzGameNotificationContainer_CreateNotifiction::NotificationData' has a wrong offset!");
static_assert(offsetof(GzGameNotificationContainer_CreateNotifiction, ReturnValue) == 0x000010, "Member 'GzGameNotificationContainer_CreateNotifiction::ReturnValue' has a wrong offset!");

// Function G01.GzGameNotificationContainer.CreateNotifictionDisplayData
// 0x00B8 (0x00B8 - 0x0000)
struct GzGameNotificationContainer_CreateNotifictionDisplayData final
{
public:
	class FName                                   InNotificationID;                                  // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UGzGameNotificationDisplayData> GameNotificationClass;                             // 0x0008(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGzGameNotificationSpec                CustomeDisplaySpec;                                // 0x0010(0x00A0)(ConstParm, Parm, NativeAccessSpecifierPublic)
	class UGzGameNotificationDisplayData*         ReturnValue;                                       // 0x00B0(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzGameNotificationContainer_CreateNotifictionDisplayData) == 0x000008, "Wrong alignment on GzGameNotificationContainer_CreateNotifictionDisplayData");
static_assert(sizeof(GzGameNotificationContainer_CreateNotifictionDisplayData) == 0x0000B8, "Wrong size on GzGameNotificationContainer_CreateNotifictionDisplayData");
static_assert(offsetof(GzGameNotificationContainer_CreateNotifictionDisplayData, InNotificationID) == 0x000000, "Member 'GzGameNotificationContainer_CreateNotifictionDisplayData::InNotificationID' has a wrong offset!");
static_assert(offsetof(GzGameNotificationContainer_CreateNotifictionDisplayData, GameNotificationClass) == 0x000008, "Member 'GzGameNotificationContainer_CreateNotifictionDisplayData::GameNotificationClass' has a wrong offset!");
static_assert(offsetof(GzGameNotificationContainer_CreateNotifictionDisplayData, CustomeDisplaySpec) == 0x000010, "Member 'GzGameNotificationContainer_CreateNotifictionDisplayData::CustomeDisplaySpec' has a wrong offset!");
static_assert(offsetof(GzGameNotificationContainer_CreateNotifictionDisplayData, ReturnValue) == 0x0000B0, "Member 'GzGameNotificationContainer_CreateNotifictionDisplayData::ReturnValue' has a wrong offset!");

// Function G01.GzGameNotificationContainer.ForceClearCurrentNotification
// 0x000C (0x000C - 0x0000)
struct GzGameNotificationContainer_ForceClearCurrentNotification final
{
public:
	class FName                                   InNotificationID;                                  // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_326A[0x3];                                     // 0x0009(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GzGameNotificationContainer_ForceClearCurrentNotification) == 0x000004, "Wrong alignment on GzGameNotificationContainer_ForceClearCurrentNotification");
static_assert(sizeof(GzGameNotificationContainer_ForceClearCurrentNotification) == 0x00000C, "Wrong size on GzGameNotificationContainer_ForceClearCurrentNotification");
static_assert(offsetof(GzGameNotificationContainer_ForceClearCurrentNotification, InNotificationID) == 0x000000, "Member 'GzGameNotificationContainer_ForceClearCurrentNotification::InNotificationID' has a wrong offset!");
static_assert(offsetof(GzGameNotificationContainer_ForceClearCurrentNotification, ReturnValue) == 0x000008, "Member 'GzGameNotificationContainer_ForceClearCurrentNotification::ReturnValue' has a wrong offset!");

// Function G01.GzGameNotificationDisplayData.SetBodyIcon
// 0x0008 (0x0008 - 0x0000)
struct GzGameNotificationDisplayData_SetBodyIcon final
{
public:
	class UTexture2D*                             Value;                                             // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzGameNotificationDisplayData_SetBodyIcon) == 0x000008, "Wrong alignment on GzGameNotificationDisplayData_SetBodyIcon");
static_assert(sizeof(GzGameNotificationDisplayData_SetBodyIcon) == 0x000008, "Wrong size on GzGameNotificationDisplayData_SetBodyIcon");
static_assert(offsetof(GzGameNotificationDisplayData_SetBodyIcon, Value) == 0x000000, "Member 'GzGameNotificationDisplayData_SetBodyIcon::Value' has a wrong offset!");

// Function G01.GzGameNotificationDisplayData.SetBodyIconColor
// 0x0010 (0x0010 - 0x0000)
struct GzGameNotificationDisplayData_SetBodyIconColor final
{
public:
	struct FLinearColor                           Color;                                             // 0x0000(0x0010)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzGameNotificationDisplayData_SetBodyIconColor) == 0x000004, "Wrong alignment on GzGameNotificationDisplayData_SetBodyIconColor");
static_assert(sizeof(GzGameNotificationDisplayData_SetBodyIconColor) == 0x000010, "Wrong size on GzGameNotificationDisplayData_SetBodyIconColor");
static_assert(offsetof(GzGameNotificationDisplayData_SetBodyIconColor, Color) == 0x000000, "Member 'GzGameNotificationDisplayData_SetBodyIconColor::Color' has a wrong offset!");

// Function G01.GzGameNotificationDisplayData.SetDefaultHeaderText
// 0x0010 (0x0010 - 0x0000)
struct GzGameNotificationDisplayData_SetDefaultHeaderText final
{
public:
	class FText                                   InText;                                            // 0x0000(0x0010)(Parm, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzGameNotificationDisplayData_SetDefaultHeaderText) == 0x000008, "Wrong alignment on GzGameNotificationDisplayData_SetDefaultHeaderText");
static_assert(sizeof(GzGameNotificationDisplayData_SetDefaultHeaderText) == 0x000010, "Wrong size on GzGameNotificationDisplayData_SetDefaultHeaderText");
static_assert(offsetof(GzGameNotificationDisplayData_SetDefaultHeaderText, InText) == 0x000000, "Member 'GzGameNotificationDisplayData_SetDefaultHeaderText::InText' has a wrong offset!");

// Function G01.GzGameNotificationDisplayData.SetDisplayShowTime
// 0x0004 (0x0004 - 0x0000)
struct GzGameNotificationDisplayData_SetDisplayShowTime final
{
public:
	float                                         Value;                                             // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzGameNotificationDisplayData_SetDisplayShowTime) == 0x000004, "Wrong alignment on GzGameNotificationDisplayData_SetDisplayShowTime");
static_assert(sizeof(GzGameNotificationDisplayData_SetDisplayShowTime) == 0x000004, "Wrong size on GzGameNotificationDisplayData_SetDisplayShowTime");
static_assert(offsetof(GzGameNotificationDisplayData_SetDisplayShowTime, Value) == 0x000000, "Member 'GzGameNotificationDisplayData_SetDisplayShowTime::Value' has a wrong offset!");

// Function G01.GzGameNotificationDisplayData.SetRemainingTime
// 0x0004 (0x0004 - 0x0000)
struct GzGameNotificationDisplayData_SetRemainingTime final
{
public:
	float                                         Value;                                             // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzGameNotificationDisplayData_SetRemainingTime) == 0x000004, "Wrong alignment on GzGameNotificationDisplayData_SetRemainingTime");
static_assert(sizeof(GzGameNotificationDisplayData_SetRemainingTime) == 0x000004, "Wrong size on GzGameNotificationDisplayData_SetRemainingTime");
static_assert(offsetof(GzGameNotificationDisplayData_SetRemainingTime, Value) == 0x000000, "Member 'GzGameNotificationDisplayData_SetRemainingTime::Value' has a wrong offset!");

// Function G01.GzGameNotificationDisplayData.SetVoiceLineTag
// 0x0008 (0x0008 - 0x0000)
struct GzGameNotificationDisplayData_SetVoiceLineTag final
{
public:
	struct FGameplayTag                           VoiceLineTag;                                      // 0x0000(0x0008)(Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzGameNotificationDisplayData_SetVoiceLineTag) == 0x000004, "Wrong alignment on GzGameNotificationDisplayData_SetVoiceLineTag");
static_assert(sizeof(GzGameNotificationDisplayData_SetVoiceLineTag) == 0x000008, "Wrong size on GzGameNotificationDisplayData_SetVoiceLineTag");
static_assert(offsetof(GzGameNotificationDisplayData_SetVoiceLineTag, VoiceLineTag) == 0x000000, "Member 'GzGameNotificationDisplayData_SetVoiceLineTag::VoiceLineTag' has a wrong offset!");

// Function G01.GzGameNotificationDisplayData.GetDefaultHeaderText
// 0x0010 (0x0010 - 0x0000)
struct GzGameNotificationDisplayData_GetDefaultHeaderText final
{
public:
	class FText                                   ReturnValue;                                       // 0x0000(0x0010)(Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzGameNotificationDisplayData_GetDefaultHeaderText) == 0x000008, "Wrong alignment on GzGameNotificationDisplayData_GetDefaultHeaderText");
static_assert(sizeof(GzGameNotificationDisplayData_GetDefaultHeaderText) == 0x000010, "Wrong size on GzGameNotificationDisplayData_GetDefaultHeaderText");
static_assert(offsetof(GzGameNotificationDisplayData_GetDefaultHeaderText, ReturnValue) == 0x000000, "Member 'GzGameNotificationDisplayData_GetDefaultHeaderText::ReturnValue' has a wrong offset!");

// Function G01.GzGameNotificationDisplayData.GetNotificationSpec
// 0x00A0 (0x00A0 - 0x0000)
struct GzGameNotificationDisplayData_GetNotificationSpec final
{
public:
	struct FGzGameNotificationSpec                ReturnValue;                                       // 0x0000(0x00A0)(ConstParm, Parm, OutParm, ReturnParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzGameNotificationDisplayData_GetNotificationSpec) == 0x000008, "Wrong alignment on GzGameNotificationDisplayData_GetNotificationSpec");
static_assert(sizeof(GzGameNotificationDisplayData_GetNotificationSpec) == 0x0000A0, "Wrong size on GzGameNotificationDisplayData_GetNotificationSpec");
static_assert(offsetof(GzGameNotificationDisplayData_GetNotificationSpec, ReturnValue) == 0x000000, "Member 'GzGameNotificationDisplayData_GetNotificationSpec::ReturnValue' has a wrong offset!");

// Function G01.GzGameNotificationDisplayData.IsEnableDefaultHeaderText
// 0x0001 (0x0001 - 0x0000)
struct GzGameNotificationDisplayData_IsEnableDefaultHeaderText final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzGameNotificationDisplayData_IsEnableDefaultHeaderText) == 0x000001, "Wrong alignment on GzGameNotificationDisplayData_IsEnableDefaultHeaderText");
static_assert(sizeof(GzGameNotificationDisplayData_IsEnableDefaultHeaderText) == 0x000001, "Wrong size on GzGameNotificationDisplayData_IsEnableDefaultHeaderText");
static_assert(offsetof(GzGameNotificationDisplayData_IsEnableDefaultHeaderText, ReturnValue) == 0x000000, "Member 'GzGameNotificationDisplayData_IsEnableDefaultHeaderText::ReturnValue' has a wrong offset!");

// Function G01.GzSelectObjective.MakeSelectObjective
// 0x0028 (0x0028 - 0x0000)
struct GzSelectObjective_MakeSelectObjective final
{
public:
	class AGzAdvancedMission*                     Mission;                                           // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UGzObjective*                           If;                                                // 0x0008(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UGzObjective*                           Success;                                           // 0x0010(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UGzObjective*                           Fail;                                              // 0x0018(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UGzObjective*                           ReturnValue;                                       // 0x0020(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzSelectObjective_MakeSelectObjective) == 0x000008, "Wrong alignment on GzSelectObjective_MakeSelectObjective");
static_assert(sizeof(GzSelectObjective_MakeSelectObjective) == 0x000028, "Wrong size on GzSelectObjective_MakeSelectObjective");
static_assert(offsetof(GzSelectObjective_MakeSelectObjective, Mission) == 0x000000, "Member 'GzSelectObjective_MakeSelectObjective::Mission' has a wrong offset!");
static_assert(offsetof(GzSelectObjective_MakeSelectObjective, If) == 0x000008, "Member 'GzSelectObjective_MakeSelectObjective::If' has a wrong offset!");
static_assert(offsetof(GzSelectObjective_MakeSelectObjective, Success) == 0x000010, "Member 'GzSelectObjective_MakeSelectObjective::Success' has a wrong offset!");
static_assert(offsetof(GzSelectObjective_MakeSelectObjective, Fail) == 0x000018, "Member 'GzSelectObjective_MakeSelectObjective::Fail' has a wrong offset!");
static_assert(offsetof(GzSelectObjective_MakeSelectObjective, ReturnValue) == 0x000020, "Member 'GzSelectObjective_MakeSelectObjective::ReturnValue' has a wrong offset!");

// Function G01.GzGameNotificationDisplayDataMission.SetMissionData
// 0x0008 (0x0008 - 0x0000)
struct GzGameNotificationDisplayDataMission_SetMissionData final
{
public:
	class UGzMissionData*                         InMissionData;                                     // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzGameNotificationDisplayDataMission_SetMissionData) == 0x000008, "Wrong alignment on GzGameNotificationDisplayDataMission_SetMissionData");
static_assert(sizeof(GzGameNotificationDisplayDataMission_SetMissionData) == 0x000008, "Wrong size on GzGameNotificationDisplayDataMission_SetMissionData");
static_assert(offsetof(GzGameNotificationDisplayDataMission_SetMissionData, InMissionData) == 0x000000, "Member 'GzGameNotificationDisplayDataMission_SetMissionData::InMissionData' has a wrong offset!");

// Function G01.GzProgressLogUISubsystem.CancelProgress
// 0x0004 (0x0004 - 0x0000)
struct GzProgressLogUISubsystem_CancelProgress final
{
public:
	int32                                         Handle;                                            // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzProgressLogUISubsystem_CancelProgress) == 0x000004, "Wrong alignment on GzProgressLogUISubsystem_CancelProgress");
static_assert(sizeof(GzProgressLogUISubsystem_CancelProgress) == 0x000004, "Wrong size on GzProgressLogUISubsystem_CancelProgress");
static_assert(offsetof(GzProgressLogUISubsystem_CancelProgress, Handle) == 0x000000, "Member 'GzProgressLogUISubsystem_CancelProgress::Handle' has a wrong offset!");

// Function G01.GzProgressLogUISubsystem.SetCurrentProgress
// 0x0008 (0x0008 - 0x0000)
struct GzProgressLogUISubsystem_SetCurrentProgress final
{
public:
	int32                                         Handle;                                            // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         NewDuration;                                       // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzProgressLogUISubsystem_SetCurrentProgress) == 0x000004, "Wrong alignment on GzProgressLogUISubsystem_SetCurrentProgress");
static_assert(sizeof(GzProgressLogUISubsystem_SetCurrentProgress) == 0x000008, "Wrong size on GzProgressLogUISubsystem_SetCurrentProgress");
static_assert(offsetof(GzProgressLogUISubsystem_SetCurrentProgress, Handle) == 0x000000, "Member 'GzProgressLogUISubsystem_SetCurrentProgress::Handle' has a wrong offset!");
static_assert(offsetof(GzProgressLogUISubsystem_SetCurrentProgress, NewDuration) == 0x000004, "Member 'GzProgressLogUISubsystem_SetCurrentProgress::NewDuration' has a wrong offset!");

// Function G01.GzProgressLogUISubsystem.StartProgress
// 0x0010 (0x0010 - 0x0000)
struct GzProgressLogUISubsystem_StartProgress final
{
public:
	TSubclassOf<class UGzProgressLogEntryWidget>  ProgressWidgetClass;                               // 0x0000(0x0008)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Duration;                                          // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ReturnValue;                                       // 0x000C(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzProgressLogUISubsystem_StartProgress) == 0x000008, "Wrong alignment on GzProgressLogUISubsystem_StartProgress");
static_assert(sizeof(GzProgressLogUISubsystem_StartProgress) == 0x000010, "Wrong size on GzProgressLogUISubsystem_StartProgress");
static_assert(offsetof(GzProgressLogUISubsystem_StartProgress, ProgressWidgetClass) == 0x000000, "Member 'GzProgressLogUISubsystem_StartProgress::ProgressWidgetClass' has a wrong offset!");
static_assert(offsetof(GzProgressLogUISubsystem_StartProgress, Duration) == 0x000008, "Member 'GzProgressLogUISubsystem_StartProgress::Duration' has a wrong offset!");
static_assert(offsetof(GzProgressLogUISubsystem_StartProgress, ReturnValue) == 0x00000C, "Member 'GzProgressLogUISubsystem_StartProgress::ReturnValue' has a wrong offset!");

// Function G01.GzGameNotificationDisplayDataPlayer.SetDisplayDataInfo
// 0x0028 (0x0028 - 0x0000)
struct GzGameNotificationDisplayDataPlayer_SetDisplayDataInfo final
{
public:
	class FText                                   InPlayerName;                                      // 0x0000(0x0010)(ConstParm, Parm, NativeAccessSpecifierPublic)
	int32                                         InPlayerIndexInTeam;                               // 0x0010(0x0004)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_326E[0x4];                                     // 0x0014(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   InPlayerClanTag;                                   // 0x0018(0x0010)(ConstParm, Parm, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzGameNotificationDisplayDataPlayer_SetDisplayDataInfo) == 0x000008, "Wrong alignment on GzGameNotificationDisplayDataPlayer_SetDisplayDataInfo");
static_assert(sizeof(GzGameNotificationDisplayDataPlayer_SetDisplayDataInfo) == 0x000028, "Wrong size on GzGameNotificationDisplayDataPlayer_SetDisplayDataInfo");
static_assert(offsetof(GzGameNotificationDisplayDataPlayer_SetDisplayDataInfo, InPlayerName) == 0x000000, "Member 'GzGameNotificationDisplayDataPlayer_SetDisplayDataInfo::InPlayerName' has a wrong offset!");
static_assert(offsetof(GzGameNotificationDisplayDataPlayer_SetDisplayDataInfo, InPlayerIndexInTeam) == 0x000010, "Member 'GzGameNotificationDisplayDataPlayer_SetDisplayDataInfo::InPlayerIndexInTeam' has a wrong offset!");
static_assert(offsetof(GzGameNotificationDisplayDataPlayer_SetDisplayDataInfo, InPlayerClanTag) == 0x000018, "Member 'GzGameNotificationDisplayDataPlayer_SetDisplayDataInfo::InPlayerClanTag' has a wrong offset!");

// Function G01.GzGameNotificationHeader.GetDisplayData
// 0x0008 (0x0008 - 0x0000)
struct GzGameNotificationHeader_GetDisplayData final
{
public:
	class UGzGameNotificationDisplayData*         ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzGameNotificationHeader_GetDisplayData) == 0x000008, "Wrong alignment on GzGameNotificationHeader_GetDisplayData");
static_assert(sizeof(GzGameNotificationHeader_GetDisplayData) == 0x000008, "Wrong size on GzGameNotificationHeader_GetDisplayData");
static_assert(offsetof(GzGameNotificationHeader_GetDisplayData, ReturnValue) == 0x000000, "Member 'GzGameNotificationHeader_GetDisplayData::ReturnValue' has a wrong offset!");

// Function G01.GzGameNotificationHeader.GetNotificationText
// 0x0008 (0x0008 - 0x0000)
struct GzGameNotificationHeader_GetNotificationText final
{
public:
	class UGzTextBlock*                           ReturnValue;                                       // 0x0000(0x0008)(ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzGameNotificationHeader_GetNotificationText) == 0x000008, "Wrong alignment on GzGameNotificationHeader_GetNotificationText");
static_assert(sizeof(GzGameNotificationHeader_GetNotificationText) == 0x000008, "Wrong size on GzGameNotificationHeader_GetNotificationText");
static_assert(offsetof(GzGameNotificationHeader_GetNotificationText, ReturnValue) == 0x000000, "Member 'GzGameNotificationHeader_GetNotificationText::ReturnValue' has a wrong offset!");

// Function G01.GzGameNotificationHeader.SetHeaderText
// 0x0010 (0x0010 - 0x0000)
struct GzGameNotificationHeader_SetHeaderText final
{
public:
	class FText                                   InText;                                            // 0x0000(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzGameNotificationHeader_SetHeaderText) == 0x000008, "Wrong alignment on GzGameNotificationHeader_SetHeaderText");
static_assert(sizeof(GzGameNotificationHeader_SetHeaderText) == 0x000010, "Wrong size on GzGameNotificationHeader_SetHeaderText");
static_assert(offsetof(GzGameNotificationHeader_SetHeaderText, InText) == 0x000000, "Member 'GzGameNotificationHeader_SetHeaderText::InText' has a wrong offset!");

// Function G01.GzGameNotificationHeader.UpdateHeaderNotification
// 0x0010 (0x0010 - 0x0000)
struct GzGameNotificationHeader_UpdateHeaderNotification final
{
public:
	const class UGzGameNotificationDisplayData*   InNotificationData;                                // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_326F[0x7];                                     // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GzGameNotificationHeader_UpdateHeaderNotification) == 0x000008, "Wrong alignment on GzGameNotificationHeader_UpdateHeaderNotification");
static_assert(sizeof(GzGameNotificationHeader_UpdateHeaderNotification) == 0x000010, "Wrong size on GzGameNotificationHeader_UpdateHeaderNotification");
static_assert(offsetof(GzGameNotificationHeader_UpdateHeaderNotification, InNotificationData) == 0x000000, "Member 'GzGameNotificationHeader_UpdateHeaderNotification::InNotificationData' has a wrong offset!");
static_assert(offsetof(GzGameNotificationHeader_UpdateHeaderNotification, ReturnValue) == 0x000008, "Member 'GzGameNotificationHeader_UpdateHeaderNotification::ReturnValue' has a wrong offset!");

// Function G01.GzNotificationSlotBase.GetNotificationSpec
// 0x00A0 (0x00A0 - 0x0000)
struct GzNotificationSlotBase_GetNotificationSpec final
{
public:
	struct FGzGameNotificationSpec                ReturnValue;                                       // 0x0000(0x00A0)(Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzNotificationSlotBase_GetNotificationSpec) == 0x000008, "Wrong alignment on GzNotificationSlotBase_GetNotificationSpec");
static_assert(sizeof(GzNotificationSlotBase_GetNotificationSpec) == 0x0000A0, "Wrong size on GzNotificationSlotBase_GetNotificationSpec");
static_assert(offsetof(GzNotificationSlotBase_GetNotificationSpec, ReturnValue) == 0x000000, "Member 'GzNotificationSlotBase_GetNotificationSpec::ReturnValue' has a wrong offset!");

// Function G01.GzNotificationSlotBase.PlayAnimationById
// 0x0008 (0x0008 - 0x0000)
struct GzNotificationSlotBase_PlayAnimationById final
{
public:
	class FName                                   AnimationID;                                       // 0x0000(0x0008)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzNotificationSlotBase_PlayAnimationById) == 0x000004, "Wrong alignment on GzNotificationSlotBase_PlayAnimationById");
static_assert(sizeof(GzNotificationSlotBase_PlayAnimationById) == 0x000008, "Wrong size on GzNotificationSlotBase_PlayAnimationById");
static_assert(offsetof(GzNotificationSlotBase_PlayAnimationById, AnimationID) == 0x000000, "Member 'GzNotificationSlotBase_PlayAnimationById::AnimationID' has a wrong offset!");

// Function G01.GzNotificationSlotBase.SetActivateAnimation
// 0x0001 (0x0001 - 0x0000)
struct GzNotificationSlotBase_SetActivateAnimation final
{
public:
	bool                                          bActivated;                                        // 0x0000(0x0001)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzNotificationSlotBase_SetActivateAnimation) == 0x000001, "Wrong alignment on GzNotificationSlotBase_SetActivateAnimation");
static_assert(sizeof(GzNotificationSlotBase_SetActivateAnimation) == 0x000001, "Wrong size on GzNotificationSlotBase_SetActivateAnimation");
static_assert(offsetof(GzNotificationSlotBase_SetActivateAnimation, bActivated) == 0x000000, "Member 'GzNotificationSlotBase_SetActivateAnimation::bActivated' has a wrong offset!");

// Function G01.GzNotificationSlotBase.UpdateNotification
// 0x0028 (0x0028 - 0x0000)
struct GzNotificationSlotBase_UpdateNotification final
{
public:
	struct FGzNotificationQueue                   Notification;                                      // 0x0000(0x0028)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzNotificationSlotBase_UpdateNotification) == 0x000008, "Wrong alignment on GzNotificationSlotBase_UpdateNotification");
static_assert(sizeof(GzNotificationSlotBase_UpdateNotification) == 0x000028, "Wrong size on GzNotificationSlotBase_UpdateNotification");
static_assert(offsetof(GzNotificationSlotBase_UpdateNotification, Notification) == 0x000000, "Member 'GzNotificationSlotBase_UpdateNotification::Notification' has a wrong offset!");

// Function G01.GzNotificationSlotBase.GetNotificationData
// 0x0028 (0x0028 - 0x0000)
struct GzNotificationSlotBase_GetNotificationData final
{
public:
	struct FGzNotificationQueue                   ReturnValue;                                       // 0x0000(0x0028)(ConstParm, Parm, OutParm, ReturnParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzNotificationSlotBase_GetNotificationData) == 0x000008, "Wrong alignment on GzNotificationSlotBase_GetNotificationData");
static_assert(sizeof(GzNotificationSlotBase_GetNotificationData) == 0x000028, "Wrong size on GzNotificationSlotBase_GetNotificationData");
static_assert(offsetof(GzNotificationSlotBase_GetNotificationData, ReturnValue) == 0x000000, "Member 'GzNotificationSlotBase_GetNotificationData::ReturnValue' has a wrong offset!");

// Function G01.GzGameNotificationSubsystem.EventNotificationStage
// 0x001C (0x001C - 0x0000)
struct GzGameNotificationSubsystem_EventNotificationStage final
{
public:
	class FName                                   NotificationID;                                    // 0x0000(0x0008)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EGzNotificationStageType                      StageType;                                         // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCustomData;                                       // 0x0009(0x0001)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3271[0x2];                                     // 0x000A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGzEventNotificationData               NotificationData;                                  // 0x000C(0x0010)(Parm, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzGameNotificationSubsystem_EventNotificationStage) == 0x000004, "Wrong alignment on GzGameNotificationSubsystem_EventNotificationStage");
static_assert(sizeof(GzGameNotificationSubsystem_EventNotificationStage) == 0x00001C, "Wrong size on GzGameNotificationSubsystem_EventNotificationStage");
static_assert(offsetof(GzGameNotificationSubsystem_EventNotificationStage, NotificationID) == 0x000000, "Member 'GzGameNotificationSubsystem_EventNotificationStage::NotificationID' has a wrong offset!");
static_assert(offsetof(GzGameNotificationSubsystem_EventNotificationStage, StageType) == 0x000008, "Member 'GzGameNotificationSubsystem_EventNotificationStage::StageType' has a wrong offset!");
static_assert(offsetof(GzGameNotificationSubsystem_EventNotificationStage, bCustomData) == 0x000009, "Member 'GzGameNotificationSubsystem_EventNotificationStage::bCustomData' has a wrong offset!");
static_assert(offsetof(GzGameNotificationSubsystem_EventNotificationStage, NotificationData) == 0x00000C, "Member 'GzGameNotificationSubsystem_EventNotificationStage::NotificationData' has a wrong offset!");

// Function G01.GzGameNotificationSubsystem.RequestGameNotification
// 0x0008 (0x0008 - 0x0000)
struct GzGameNotificationSubsystem_RequestGameNotification final
{
public:
	class FName                                   NotificationID;                                    // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzGameNotificationSubsystem_RequestGameNotification) == 0x000004, "Wrong alignment on GzGameNotificationSubsystem_RequestGameNotification");
static_assert(sizeof(GzGameNotificationSubsystem_RequestGameNotification) == 0x000008, "Wrong size on GzGameNotificationSubsystem_RequestGameNotification");
static_assert(offsetof(GzGameNotificationSubsystem_RequestGameNotification, NotificationID) == 0x000000, "Member 'GzGameNotificationSubsystem_RequestGameNotification::NotificationID' has a wrong offset!");

// Function G01.GzGameNotificationSubsystem.ShowDebugGameNotification
// 0x0008 (0x0008 - 0x0000)
struct GzGameNotificationSubsystem_ShowDebugGameNotification final
{
public:
	class FName                                   TestNotificationID;                                // 0x0000(0x0008)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzGameNotificationSubsystem_ShowDebugGameNotification) == 0x000004, "Wrong alignment on GzGameNotificationSubsystem_ShowDebugGameNotification");
static_assert(sizeof(GzGameNotificationSubsystem_ShowDebugGameNotification) == 0x000008, "Wrong size on GzGameNotificationSubsystem_ShowDebugGameNotification");
static_assert(offsetof(GzGameNotificationSubsystem_ShowDebugGameNotification, TestNotificationID) == 0x000000, "Member 'GzGameNotificationSubsystem_ShowDebugGameNotification::TestNotificationID' has a wrong offset!");

// Function G01.GzGamepadFeedbackController.AddActiveFeedback
// 0x0018 (0x0018 - 0x0000)
struct GzGamepadFeedbackController_AddActiveFeedback final
{
public:
	struct FGzGamepadFeedbackSpec                 FoundSpec;                                         // 0x0000(0x0018)(ConstParm, Parm, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzGamepadFeedbackController_AddActiveFeedback) == 0x000008, "Wrong alignment on GzGamepadFeedbackController_AddActiveFeedback");
static_assert(sizeof(GzGamepadFeedbackController_AddActiveFeedback) == 0x000018, "Wrong size on GzGamepadFeedbackController_AddActiveFeedback");
static_assert(offsetof(GzGamepadFeedbackController_AddActiveFeedback, FoundSpec) == 0x000000, "Member 'GzGamepadFeedbackController_AddActiveFeedback::FoundSpec' has a wrong offset!");

// Function G01.GzGamepadFeedbackController.OnEquippedWeaponChanged
// 0x0018 (0x0018 - 0x0000)
struct GzGamepadFeedbackController_OnEquippedWeaponChanged final
{
public:
	struct FGzInvPocketId                         InvPocketId;                                       // 0x0000(0x0008)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	const class AGzWeaponActor*                   WeaponActor;                                       // 0x0008(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEquipped;                                         // 0x0010(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3274[0x7];                                     // 0x0011(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GzGamepadFeedbackController_OnEquippedWeaponChanged) == 0x000008, "Wrong alignment on GzGamepadFeedbackController_OnEquippedWeaponChanged");
static_assert(sizeof(GzGamepadFeedbackController_OnEquippedWeaponChanged) == 0x000018, "Wrong size on GzGamepadFeedbackController_OnEquippedWeaponChanged");
static_assert(offsetof(GzGamepadFeedbackController_OnEquippedWeaponChanged, InvPocketId) == 0x000000, "Member 'GzGamepadFeedbackController_OnEquippedWeaponChanged::InvPocketId' has a wrong offset!");
static_assert(offsetof(GzGamepadFeedbackController_OnEquippedWeaponChanged, WeaponActor) == 0x000008, "Member 'GzGamepadFeedbackController_OnEquippedWeaponChanged::WeaponActor' has a wrong offset!");
static_assert(offsetof(GzGamepadFeedbackController_OnEquippedWeaponChanged, bEquipped) == 0x000010, "Member 'GzGamepadFeedbackController_OnEquippedWeaponChanged::bEquipped' has a wrong offset!");

// Function G01.GzGamepadFeedbackController.OnPawnChanged
// 0x0008 (0x0008 - 0x0000)
struct GzGamepadFeedbackController_OnPawnChanged final
{
public:
	class APawn*                                  NewPawn;                                           // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzGamepadFeedbackController_OnPawnChanged) == 0x000008, "Wrong alignment on GzGamepadFeedbackController_OnPawnChanged");
static_assert(sizeof(GzGamepadFeedbackController_OnPawnChanged) == 0x000008, "Wrong size on GzGamepadFeedbackController_OnPawnChanged");
static_assert(offsetof(GzGamepadFeedbackController_OnPawnChanged, NewPawn) == 0x000000, "Member 'GzGamepadFeedbackController_OnPawnChanged::NewPawn' has a wrong offset!");

// Function G01.GzGamepadFeedbackController.PushFeedbackByTag
// 0x000C (0x000C - 0x0000)
struct GzGamepadFeedbackController_PushFeedbackByTag final
{
public:
	struct FGameplayTag                           GameplayTag;                                       // 0x0000(0x0008)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAddition;                                         // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3275[0x3];                                     // 0x0009(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GzGamepadFeedbackController_PushFeedbackByTag) == 0x000004, "Wrong alignment on GzGamepadFeedbackController_PushFeedbackByTag");
static_assert(sizeof(GzGamepadFeedbackController_PushFeedbackByTag) == 0x00000C, "Wrong size on GzGamepadFeedbackController_PushFeedbackByTag");
static_assert(offsetof(GzGamepadFeedbackController_PushFeedbackByTag, GameplayTag) == 0x000000, "Member 'GzGamepadFeedbackController_PushFeedbackByTag::GameplayTag' has a wrong offset!");
static_assert(offsetof(GzGamepadFeedbackController_PushFeedbackByTag, bAddition) == 0x000008, "Member 'GzGamepadFeedbackController_PushFeedbackByTag::bAddition' has a wrong offset!");

// Function G01.GzGamepadFeedbackController.RemoveActiveFeedback
// 0x0018 (0x0018 - 0x0000)
struct GzGamepadFeedbackController_RemoveActiveFeedback final
{
public:
	struct FGzGamepadFeedbackSpec                 FoundSpec;                                         // 0x0000(0x0018)(ConstParm, Parm, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzGamepadFeedbackController_RemoveActiveFeedback) == 0x000008, "Wrong alignment on GzGamepadFeedbackController_RemoveActiveFeedback");
static_assert(sizeof(GzGamepadFeedbackController_RemoveActiveFeedback) == 0x000018, "Wrong size on GzGamepadFeedbackController_RemoveActiveFeedback");
static_assert(offsetof(GzGamepadFeedbackController_RemoveActiveFeedback, FoundSpec) == 0x000000, "Member 'GzGamepadFeedbackController_RemoveActiveFeedback::FoundSpec' has a wrong offset!");

// Function G01.GzPropagationStrategyConfig.GetTileExtents
// 0x0018 (0x0018 - 0x0000)
struct GzPropagationStrategyConfig_GetTileExtents final
{
public:
	struct FVector                                ReturnValue;                                       // 0x0000(0x0018)(ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzPropagationStrategyConfig_GetTileExtents) == 0x000008, "Wrong alignment on GzPropagationStrategyConfig_GetTileExtents");
static_assert(sizeof(GzPropagationStrategyConfig_GetTileExtents) == 0x000018, "Wrong size on GzPropagationStrategyConfig_GetTileExtents");
static_assert(offsetof(GzPropagationStrategyConfig_GetTileExtents, ReturnValue) == 0x000000, "Member 'GzPropagationStrategyConfig_GetTileExtents::ReturnValue' has a wrong offset!");

// Function G01.GzPropagationStrategyConfig_Grid.GetHeight
// 0x0008 (0x0008 - 0x0000)
struct GzPropagationStrategyConfig_Grid_GetHeight final
{
public:
	int32                                         Level;                                             // 0x0000(0x0004)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ReturnValue;                                       // 0x0004(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzPropagationStrategyConfig_Grid_GetHeight) == 0x000004, "Wrong alignment on GzPropagationStrategyConfig_Grid_GetHeight");
static_assert(sizeof(GzPropagationStrategyConfig_Grid_GetHeight) == 0x000008, "Wrong size on GzPropagationStrategyConfig_Grid_GetHeight");
static_assert(offsetof(GzPropagationStrategyConfig_Grid_GetHeight, Level) == 0x000000, "Member 'GzPropagationStrategyConfig_Grid_GetHeight::Level' has a wrong offset!");
static_assert(offsetof(GzPropagationStrategyConfig_Grid_GetHeight, ReturnValue) == 0x000004, "Member 'GzPropagationStrategyConfig_Grid_GetHeight::ReturnValue' has a wrong offset!");

// Function G01.GzPropagationStrategyConfig_Grid.GetLength
// 0x0008 (0x0008 - 0x0000)
struct GzPropagationStrategyConfig_Grid_GetLength final
{
public:
	int32                                         Level;                                             // 0x0000(0x0004)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ReturnValue;                                       // 0x0004(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzPropagationStrategyConfig_Grid_GetLength) == 0x000004, "Wrong alignment on GzPropagationStrategyConfig_Grid_GetLength");
static_assert(sizeof(GzPropagationStrategyConfig_Grid_GetLength) == 0x000008, "Wrong size on GzPropagationStrategyConfig_Grid_GetLength");
static_assert(offsetof(GzPropagationStrategyConfig_Grid_GetLength, Level) == 0x000000, "Member 'GzPropagationStrategyConfig_Grid_GetLength::Level' has a wrong offset!");
static_assert(offsetof(GzPropagationStrategyConfig_Grid_GetLength, ReturnValue) == 0x000004, "Member 'GzPropagationStrategyConfig_Grid_GetLength::ReturnValue' has a wrong offset!");

// Function G01.GzPropagationStrategyConfig_Grid.GetWidth
// 0x0008 (0x0008 - 0x0000)
struct GzPropagationStrategyConfig_Grid_GetWidth final
{
public:
	int32                                         Level;                                             // 0x0000(0x0004)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ReturnValue;                                       // 0x0004(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzPropagationStrategyConfig_Grid_GetWidth) == 0x000004, "Wrong alignment on GzPropagationStrategyConfig_Grid_GetWidth");
static_assert(sizeof(GzPropagationStrategyConfig_Grid_GetWidth) == 0x000008, "Wrong size on GzPropagationStrategyConfig_Grid_GetWidth");
static_assert(offsetof(GzPropagationStrategyConfig_Grid_GetWidth, Level) == 0x000000, "Member 'GzPropagationStrategyConfig_Grid_GetWidth::Level' has a wrong offset!");
static_assert(offsetof(GzPropagationStrategyConfig_Grid_GetWidth, ReturnValue) == 0x000004, "Member 'GzPropagationStrategyConfig_Grid_GetWidth::ReturnValue' has a wrong offset!");

// Function G01.GzPropagationStrategyConfig_Grid.IsCenteredAt
// 0x0002 (0x0002 - 0x0000)
struct GzPropagationStrategyConfig_Grid_IsCenteredAt final
{
public:
	EGzCenterLocation                             CenterLocation;                                    // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0001(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzPropagationStrategyConfig_Grid_IsCenteredAt) == 0x000001, "Wrong alignment on GzPropagationStrategyConfig_Grid_IsCenteredAt");
static_assert(sizeof(GzPropagationStrategyConfig_Grid_IsCenteredAt) == 0x000002, "Wrong size on GzPropagationStrategyConfig_Grid_IsCenteredAt");
static_assert(offsetof(GzPropagationStrategyConfig_Grid_IsCenteredAt, CenterLocation) == 0x000000, "Member 'GzPropagationStrategyConfig_Grid_IsCenteredAt::CenterLocation' has a wrong offset!");
static_assert(offsetof(GzPropagationStrategyConfig_Grid_IsCenteredAt, ReturnValue) == 0x000001, "Member 'GzPropagationStrategyConfig_Grid_IsCenteredAt::ReturnValue' has a wrong offset!");

// Function G01.GzGameplayCondition.OnPlayerJoined
// 0x0004 (0x0004 - 0x0000)
struct GzGameplayCondition_OnPlayerJoined final
{
public:
	int32                                         PlayerId;                                          // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzGameplayCondition_OnPlayerJoined) == 0x000004, "Wrong alignment on GzGameplayCondition_OnPlayerJoined");
static_assert(sizeof(GzGameplayCondition_OnPlayerJoined) == 0x000004, "Wrong size on GzGameplayCondition_OnPlayerJoined");
static_assert(offsetof(GzGameplayCondition_OnPlayerJoined, PlayerId) == 0x000000, "Member 'GzGameplayCondition_OnPlayerJoined::PlayerId' has a wrong offset!");

// Function G01.GzGameplayCondition.OnPlayerLeft
// 0x0004 (0x0004 - 0x0000)
struct GzGameplayCondition_OnPlayerLeft final
{
public:
	int32                                         PlayerId;                                          // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzGameplayCondition_OnPlayerLeft) == 0x000004, "Wrong alignment on GzGameplayCondition_OnPlayerLeft");
static_assert(sizeof(GzGameplayCondition_OnPlayerLeft) == 0x000004, "Wrong size on GzGameplayCondition_OnPlayerLeft");
static_assert(offsetof(GzGameplayCondition_OnPlayerLeft, PlayerId) == 0x000000, "Member 'GzGameplayCondition_OnPlayerLeft::PlayerId' has a wrong offset!");

// Function G01.GzGameplayCondition.OnStateChanged_BP
// 0x0001 (0x0001 - 0x0000)
struct GzGameplayCondition_OnStateChanged_BP final
{
public:
	EGzConditionState                             NewState;                                          // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzGameplayCondition_OnStateChanged_BP) == 0x000001, "Wrong alignment on GzGameplayCondition_OnStateChanged_BP");
static_assert(sizeof(GzGameplayCondition_OnStateChanged_BP) == 0x000001, "Wrong size on GzGameplayCondition_OnStateChanged_BP");
static_assert(offsetof(GzGameplayCondition_OnStateChanged_BP, NewState) == 0x000000, "Member 'GzGameplayCondition_OnStateChanged_BP::NewState' has a wrong offset!");

// Function G01.GzGameplayCondition.Signal
// 0x0001 (0x0001 - 0x0000)
struct GzGameplayCondition_Signal final
{
public:
	bool                                          bValue;                                            // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzGameplayCondition_Signal) == 0x000001, "Wrong alignment on GzGameplayCondition_Signal");
static_assert(sizeof(GzGameplayCondition_Signal) == 0x000001, "Wrong size on GzGameplayCondition_Signal");
static_assert(offsetof(GzGameplayCondition_Signal, bValue) == 0x000000, "Member 'GzGameplayCondition_Signal::bValue' has a wrong offset!");

// Function G01.GzGameplayCondition.GetPlayerState
// 0x0008 (0x0008 - 0x0000)
struct GzGameplayCondition_GetPlayerState final
{
public:
	int32                                         PlayerId;                                          // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EGzConditionState                             ReturnValue;                                       // 0x0004(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_327B[0x3];                                     // 0x0005(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GzGameplayCondition_GetPlayerState) == 0x000004, "Wrong alignment on GzGameplayCondition_GetPlayerState");
static_assert(sizeof(GzGameplayCondition_GetPlayerState) == 0x000008, "Wrong size on GzGameplayCondition_GetPlayerState");
static_assert(offsetof(GzGameplayCondition_GetPlayerState, PlayerId) == 0x000000, "Member 'GzGameplayCondition_GetPlayerState::PlayerId' has a wrong offset!");
static_assert(offsetof(GzGameplayCondition_GetPlayerState, ReturnValue) == 0x000004, "Member 'GzGameplayCondition_GetPlayerState::ReturnValue' has a wrong offset!");

// Function G01.GzJZ_MatchInProgressStage.OnMissionStateChanged
// 0x0010 (0x0010 - 0x0000)
struct GzJZ_MatchInProgressStage_OnMissionStateChanged final
{
public:
	class AGzAdvancedMission*                     Mission;                                           // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EGzMissionState                               NewState;                                          // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3280[0x7];                                     // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GzJZ_MatchInProgressStage_OnMissionStateChanged) == 0x000008, "Wrong alignment on GzJZ_MatchInProgressStage_OnMissionStateChanged");
static_assert(sizeof(GzJZ_MatchInProgressStage_OnMissionStateChanged) == 0x000010, "Wrong size on GzJZ_MatchInProgressStage_OnMissionStateChanged");
static_assert(offsetof(GzJZ_MatchInProgressStage_OnMissionStateChanged, Mission) == 0x000000, "Member 'GzJZ_MatchInProgressStage_OnMissionStateChanged::Mission' has a wrong offset!");
static_assert(offsetof(GzJZ_MatchInProgressStage_OnMissionStateChanged, NewState) == 0x000008, "Member 'GzJZ_MatchInProgressStage_OnMissionStateChanged::NewState' has a wrong offset!");

// Function G01.GzMatchmakingCheatExtension.MatchmakingPingsFake
// 0x000C (0x000C - 0x0000)
struct GzMatchmakingCheatExtension_MatchmakingPingsFake final
{
public:
	uint32                                        Param_Index;                                       // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint32                                        Latency;                                           // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PacketLoss;                                        // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzMatchmakingCheatExtension_MatchmakingPingsFake) == 0x000004, "Wrong alignment on GzMatchmakingCheatExtension_MatchmakingPingsFake");
static_assert(sizeof(GzMatchmakingCheatExtension_MatchmakingPingsFake) == 0x00000C, "Wrong size on GzMatchmakingCheatExtension_MatchmakingPingsFake");
static_assert(offsetof(GzMatchmakingCheatExtension_MatchmakingPingsFake, Param_Index) == 0x000000, "Member 'GzMatchmakingCheatExtension_MatchmakingPingsFake::Param_Index' has a wrong offset!");
static_assert(offsetof(GzMatchmakingCheatExtension_MatchmakingPingsFake, Latency) == 0x000004, "Member 'GzMatchmakingCheatExtension_MatchmakingPingsFake::Latency' has a wrong offset!");
static_assert(offsetof(GzMatchmakingCheatExtension_MatchmakingPingsFake, PacketLoss) == 0x000008, "Member 'GzMatchmakingCheatExtension_MatchmakingPingsFake::PacketLoss' has a wrong offset!");

// Function G01.GzMatchmakingCheatExtension.MatchmakingPingsFakeDeleteRegion
// 0x0004 (0x0004 - 0x0000)
struct GzMatchmakingCheatExtension_MatchmakingPingsFakeDeleteRegion final
{
public:
	uint32                                        Param_Index;                                       // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzMatchmakingCheatExtension_MatchmakingPingsFakeDeleteRegion) == 0x000004, "Wrong alignment on GzMatchmakingCheatExtension_MatchmakingPingsFakeDeleteRegion");
static_assert(sizeof(GzMatchmakingCheatExtension_MatchmakingPingsFakeDeleteRegion) == 0x000004, "Wrong size on GzMatchmakingCheatExtension_MatchmakingPingsFakeDeleteRegion");
static_assert(offsetof(GzMatchmakingCheatExtension_MatchmakingPingsFakeDeleteRegion, Param_Index) == 0x000000, "Member 'GzMatchmakingCheatExtension_MatchmakingPingsFakeDeleteRegion::Param_Index' has a wrong offset!");

// Function G01.GzMatchmakingCheatExtension.MatchmakingQueueSet
// 0x0010 (0x0010 - 0x0000)
struct GzMatchmakingCheatExtension_MatchmakingQueueSet final
{
public:
	class FString                                 QueueName;                                         // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzMatchmakingCheatExtension_MatchmakingQueueSet) == 0x000008, "Wrong alignment on GzMatchmakingCheatExtension_MatchmakingQueueSet");
static_assert(sizeof(GzMatchmakingCheatExtension_MatchmakingQueueSet) == 0x000010, "Wrong size on GzMatchmakingCheatExtension_MatchmakingQueueSet");
static_assert(offsetof(GzMatchmakingCheatExtension_MatchmakingQueueSet, QueueName) == 0x000000, "Member 'GzMatchmakingCheatExtension_MatchmakingQueueSet::QueueName' has a wrong offset!");

// Function G01.GzMatchmakingCheatExtension.MatchmakingSetReady
// 0x0001 (0x0001 - 0x0000)
struct GzMatchmakingCheatExtension_MatchmakingSetReady final
{
public:
	bool                                          bReady;                                            // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzMatchmakingCheatExtension_MatchmakingSetReady) == 0x000001, "Wrong alignment on GzMatchmakingCheatExtension_MatchmakingSetReady");
static_assert(sizeof(GzMatchmakingCheatExtension_MatchmakingSetReady) == 0x000001, "Wrong size on GzMatchmakingCheatExtension_MatchmakingSetReady");
static_assert(offsetof(GzMatchmakingCheatExtension_MatchmakingSetReady, bReady) == 0x000000, "Member 'GzMatchmakingCheatExtension_MatchmakingSetReady::bReady' has a wrong offset!");

// Function G01.GzMarketplaceCheatExtension.ReportPlayerMarketplaceLot
// 0x0020 (0x0020 - 0x0000)
struct GzMarketplaceCheatExtension_ReportPlayerMarketplaceLot final
{
public:
	class FString                                 LotId;                                             // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Reason;                                            // 0x0010(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzMarketplaceCheatExtension_ReportPlayerMarketplaceLot) == 0x000008, "Wrong alignment on GzMarketplaceCheatExtension_ReportPlayerMarketplaceLot");
static_assert(sizeof(GzMarketplaceCheatExtension_ReportPlayerMarketplaceLot) == 0x000020, "Wrong size on GzMarketplaceCheatExtension_ReportPlayerMarketplaceLot");
static_assert(offsetof(GzMarketplaceCheatExtension_ReportPlayerMarketplaceLot, LotId) == 0x000000, "Member 'GzMarketplaceCheatExtension_ReportPlayerMarketplaceLot::LotId' has a wrong offset!");
static_assert(offsetof(GzMarketplaceCheatExtension_ReportPlayerMarketplaceLot, Reason) == 0x000010, "Member 'GzMarketplaceCheatExtension_ReportPlayerMarketplaceLot::Reason' has a wrong offset!");

// Function G01.GzGameplayObjective.FinishObjective
// 0x0001 (0x0001 - 0x0000)
struct GzGameplayObjective_FinishObjective final
{
public:
	bool                                          bSuccessful;                                       // 0x0000(0x0001)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzGameplayObjective_FinishObjective) == 0x000001, "Wrong alignment on GzGameplayObjective_FinishObjective");
static_assert(sizeof(GzGameplayObjective_FinishObjective) == 0x000001, "Wrong size on GzGameplayObjective_FinishObjective");
static_assert(offsetof(GzGameplayObjective_FinishObjective, bSuccessful) == 0x000000, "Member 'GzGameplayObjective_FinishObjective::bSuccessful' has a wrong offset!");

// Function G01.GzGameplayObjective.OnPlayerJoined
// 0x0004 (0x0004 - 0x0000)
struct GzGameplayObjective_OnPlayerJoined final
{
public:
	int32                                         PlayerId;                                          // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzGameplayObjective_OnPlayerJoined) == 0x000004, "Wrong alignment on GzGameplayObjective_OnPlayerJoined");
static_assert(sizeof(GzGameplayObjective_OnPlayerJoined) == 0x000004, "Wrong size on GzGameplayObjective_OnPlayerJoined");
static_assert(offsetof(GzGameplayObjective_OnPlayerJoined, PlayerId) == 0x000000, "Member 'GzGameplayObjective_OnPlayerJoined::PlayerId' has a wrong offset!");

// Function G01.GzGameplayObjective.OnPlayerLeft
// 0x0004 (0x0004 - 0x0000)
struct GzGameplayObjective_OnPlayerLeft final
{
public:
	int32                                         PlayerId;                                          // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzGameplayObjective_OnPlayerLeft) == 0x000004, "Wrong alignment on GzGameplayObjective_OnPlayerLeft");
static_assert(sizeof(GzGameplayObjective_OnPlayerLeft) == 0x000004, "Wrong size on GzGameplayObjective_OnPlayerLeft");
static_assert(offsetof(GzGameplayObjective_OnPlayerLeft, PlayerId) == 0x000000, "Member 'GzGameplayObjective_OnPlayerLeft::PlayerId' has a wrong offset!");

// Function G01.GzGameplayObjective.SetProgress
// 0x0004 (0x0004 - 0x0000)
struct GzGameplayObjective_SetProgress final
{
public:
	float                                         NewProgress;                                       // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzGameplayObjective_SetProgress) == 0x000004, "Wrong alignment on GzGameplayObjective_SetProgress");
static_assert(sizeof(GzGameplayObjective_SetProgress) == 0x000004, "Wrong size on GzGameplayObjective_SetProgress");
static_assert(offsetof(GzGameplayObjective_SetProgress, NewProgress) == 0x000000, "Member 'GzGameplayObjective_SetProgress::NewProgress' has a wrong offset!");

// Function G01.GzGameplayObjective.SubscribeOnProgressChange
// 0x0010 (0x0010 - 0x0000)
struct GzGameplayObjective_SubscribeOnProgressChange final
{
public:
	TDelegate<void()>                             OnProgressChanged;                                 // 0x0000(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzGameplayObjective_SubscribeOnProgressChange) == 0x000004, "Wrong alignment on GzGameplayObjective_SubscribeOnProgressChange");
static_assert(sizeof(GzGameplayObjective_SubscribeOnProgressChange) == 0x000010, "Wrong size on GzGameplayObjective_SubscribeOnProgressChange");
static_assert(offsetof(GzGameplayObjective_SubscribeOnProgressChange, OnProgressChanged) == 0x000000, "Member 'GzGameplayObjective_SubscribeOnProgressChange::OnProgressChanged' has a wrong offset!");

// Function G01.GzGameplayObjective.TryFinishObjective
// 0x0001 (0x0001 - 0x0000)
struct GzGameplayObjective_TryFinishObjective final
{
public:
	bool                                          bSuccessful;                                       // 0x0000(0x0001)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzGameplayObjective_TryFinishObjective) == 0x000001, "Wrong alignment on GzGameplayObjective_TryFinishObjective");
static_assert(sizeof(GzGameplayObjective_TryFinishObjective) == 0x000001, "Wrong size on GzGameplayObjective_TryFinishObjective");
static_assert(offsetof(GzGameplayObjective_TryFinishObjective, bSuccessful) == 0x000000, "Member 'GzGameplayObjective_TryFinishObjective::bSuccessful' has a wrong offset!");

// Function G01.GzGameplayObjective.GetObjectiveState
// 0x0001 (0x0001 - 0x0000)
struct GzGameplayObjective_GetObjectiveState final
{
public:
	EGzObjectiveState                             ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzGameplayObjective_GetObjectiveState) == 0x000001, "Wrong alignment on GzGameplayObjective_GetObjectiveState");
static_assert(sizeof(GzGameplayObjective_GetObjectiveState) == 0x000001, "Wrong size on GzGameplayObjective_GetObjectiveState");
static_assert(offsetof(GzGameplayObjective_GetObjectiveState, ReturnValue) == 0x000000, "Member 'GzGameplayObjective_GetObjectiveState::ReturnValue' has a wrong offset!");

// Function G01.GzGameplayObjective.GetProgress
// 0x0004 (0x0004 - 0x0000)
struct GzGameplayObjective_GetProgress final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzGameplayObjective_GetProgress) == 0x000004, "Wrong alignment on GzGameplayObjective_GetProgress");
static_assert(sizeof(GzGameplayObjective_GetProgress) == 0x000004, "Wrong size on GzGameplayObjective_GetProgress");
static_assert(offsetof(GzGameplayObjective_GetProgress, ReturnValue) == 0x000000, "Member 'GzGameplayObjective_GetProgress::ReturnValue' has a wrong offset!");

// Function G01.GzGameplayObjective.GetRequiredProgress
// 0x0004 (0x0004 - 0x0000)
struct GzGameplayObjective_GetRequiredProgress final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzGameplayObjective_GetRequiredProgress) == 0x000004, "Wrong alignment on GzGameplayObjective_GetRequiredProgress");
static_assert(sizeof(GzGameplayObjective_GetRequiredProgress) == 0x000004, "Wrong size on GzGameplayObjective_GetRequiredProgress");
static_assert(offsetof(GzGameplayObjective_GetRequiredProgress, ReturnValue) == 0x000000, "Member 'GzGameplayObjective_GetRequiredProgress::ReturnValue' has a wrong offset!");

// Function G01.GzGameplayObjective.IsSupportingProgress
// 0x0001 (0x0001 - 0x0000)
struct GzGameplayObjective_IsSupportingProgress final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzGameplayObjective_IsSupportingProgress) == 0x000001, "Wrong alignment on GzGameplayObjective_IsSupportingProgress");
static_assert(sizeof(GzGameplayObjective_IsSupportingProgress) == 0x000001, "Wrong size on GzGameplayObjective_IsSupportingProgress");
static_assert(offsetof(GzGameplayObjective_IsSupportingProgress, ReturnValue) == 0x000000, "Member 'GzGameplayObjective_IsSupportingProgress::ReturnValue' has a wrong offset!");

// Function G01.GzGameplayPerformanceTrackerExtension.SetClientGameplayPerformanceTrackerInterval
// 0x0004 (0x0004 - 0x0000)
struct GzGameplayPerformanceTrackerExtension_SetClientGameplayPerformanceTrackerInterval final
{
public:
	float                                         Interval;                                          // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzGameplayPerformanceTrackerExtension_SetClientGameplayPerformanceTrackerInterval) == 0x000004, "Wrong alignment on GzGameplayPerformanceTrackerExtension_SetClientGameplayPerformanceTrackerInterval");
static_assert(sizeof(GzGameplayPerformanceTrackerExtension_SetClientGameplayPerformanceTrackerInterval) == 0x000004, "Wrong size on GzGameplayPerformanceTrackerExtension_SetClientGameplayPerformanceTrackerInterval");
static_assert(offsetof(GzGameplayPerformanceTrackerExtension_SetClientGameplayPerformanceTrackerInterval, Interval) == 0x000000, "Member 'GzGameplayPerformanceTrackerExtension_SetClientGameplayPerformanceTrackerInterval::Interval' has a wrong offset!");

// Function G01.GzGameplayPerformanceTrackerExtension.SetServerGameplayPerformanceTrackerInterval
// 0x0004 (0x0004 - 0x0000)
struct GzGameplayPerformanceTrackerExtension_SetServerGameplayPerformanceTrackerInterval final
{
public:
	float                                         Interval;                                          // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzGameplayPerformanceTrackerExtension_SetServerGameplayPerformanceTrackerInterval) == 0x000004, "Wrong alignment on GzGameplayPerformanceTrackerExtension_SetServerGameplayPerformanceTrackerInterval");
static_assert(sizeof(GzGameplayPerformanceTrackerExtension_SetServerGameplayPerformanceTrackerInterval) == 0x000004, "Wrong size on GzGameplayPerformanceTrackerExtension_SetServerGameplayPerformanceTrackerInterval");
static_assert(offsetof(GzGameplayPerformanceTrackerExtension_SetServerGameplayPerformanceTrackerInterval, Interval) == 0x000000, "Member 'GzGameplayPerformanceTrackerExtension_SetServerGameplayPerformanceTrackerInterval::Interval' has a wrong offset!");

// Function G01.GzGameplayStatics.AddDynamicTagGameplayEffect
// 0x0010 (0x0010 - 0x0000)
struct GzGameplayStatics_AddDynamicTagGameplayEffect final
{
public:
	class UGzAbilitySystemComponent*              TargetASC;                                         // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           Tag;                                               // 0x0008(0x0008)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzGameplayStatics_AddDynamicTagGameplayEffect) == 0x000008, "Wrong alignment on GzGameplayStatics_AddDynamicTagGameplayEffect");
static_assert(sizeof(GzGameplayStatics_AddDynamicTagGameplayEffect) == 0x000010, "Wrong size on GzGameplayStatics_AddDynamicTagGameplayEffect");
static_assert(offsetof(GzGameplayStatics_AddDynamicTagGameplayEffect, TargetASC) == 0x000000, "Member 'GzGameplayStatics_AddDynamicTagGameplayEffect::TargetASC' has a wrong offset!");
static_assert(offsetof(GzGameplayStatics_AddDynamicTagGameplayEffect, Tag) == 0x000008, "Member 'GzGameplayStatics_AddDynamicTagGameplayEffect::Tag' has a wrong offset!");

// Function G01.GzGameplayStatics.Blueprint_PredictProjectilePath_Advanced_WithDrag
// 0x01D8 (0x01D8 - 0x0000)
struct GzGameplayStatics_Blueprint_PredictProjectilePath_Advanced_WithDrag final
{
public:
	const class UObject*                          WorldContextObject;                                // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGzPredictProjectilePathParams         PredictParams;                                     // 0x0008(0x0088)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	struct FPredictProjectilePathResult           PredictResult;                                     // 0x0090(0x0140)(Parm, OutParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x01D0(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3286[0x7];                                     // 0x01D1(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GzGameplayStatics_Blueprint_PredictProjectilePath_Advanced_WithDrag) == 0x000008, "Wrong alignment on GzGameplayStatics_Blueprint_PredictProjectilePath_Advanced_WithDrag");
static_assert(sizeof(GzGameplayStatics_Blueprint_PredictProjectilePath_Advanced_WithDrag) == 0x0001D8, "Wrong size on GzGameplayStatics_Blueprint_PredictProjectilePath_Advanced_WithDrag");
static_assert(offsetof(GzGameplayStatics_Blueprint_PredictProjectilePath_Advanced_WithDrag, WorldContextObject) == 0x000000, "Member 'GzGameplayStatics_Blueprint_PredictProjectilePath_Advanced_WithDrag::WorldContextObject' has a wrong offset!");
static_assert(offsetof(GzGameplayStatics_Blueprint_PredictProjectilePath_Advanced_WithDrag, PredictParams) == 0x000008, "Member 'GzGameplayStatics_Blueprint_PredictProjectilePath_Advanced_WithDrag::PredictParams' has a wrong offset!");
static_assert(offsetof(GzGameplayStatics_Blueprint_PredictProjectilePath_Advanced_WithDrag, PredictResult) == 0x000090, "Member 'GzGameplayStatics_Blueprint_PredictProjectilePath_Advanced_WithDrag::PredictResult' has a wrong offset!");
static_assert(offsetof(GzGameplayStatics_Blueprint_PredictProjectilePath_Advanced_WithDrag, ReturnValue) == 0x0001D0, "Member 'GzGameplayStatics_Blueprint_PredictProjectilePath_Advanced_WithDrag::ReturnValue' has a wrong offset!");

// Function G01.GzGameplayStatics.Blueprint_PredictProjectilePath_Advanced_WithHoming
// 0x0208 (0x0208 - 0x0000)
struct GzGameplayStatics_Blueprint_PredictProjectilePath_Advanced_WithHoming final
{
public:
	const class UObject*                          WorldContextObject;                                // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGzPredictProjectilePathParams_WithHoming PredictParams;                                     // 0x0008(0x00B8)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	struct FPredictProjectilePathResult           PredictResult;                                     // 0x00C0(0x0140)(Parm, OutParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0200(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3287[0x7];                                     // 0x0201(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GzGameplayStatics_Blueprint_PredictProjectilePath_Advanced_WithHoming) == 0x000008, "Wrong alignment on GzGameplayStatics_Blueprint_PredictProjectilePath_Advanced_WithHoming");
static_assert(sizeof(GzGameplayStatics_Blueprint_PredictProjectilePath_Advanced_WithHoming) == 0x000208, "Wrong size on GzGameplayStatics_Blueprint_PredictProjectilePath_Advanced_WithHoming");
static_assert(offsetof(GzGameplayStatics_Blueprint_PredictProjectilePath_Advanced_WithHoming, WorldContextObject) == 0x000000, "Member 'GzGameplayStatics_Blueprint_PredictProjectilePath_Advanced_WithHoming::WorldContextObject' has a wrong offset!");
static_assert(offsetof(GzGameplayStatics_Blueprint_PredictProjectilePath_Advanced_WithHoming, PredictParams) == 0x000008, "Member 'GzGameplayStatics_Blueprint_PredictProjectilePath_Advanced_WithHoming::PredictParams' has a wrong offset!");
static_assert(offsetof(GzGameplayStatics_Blueprint_PredictProjectilePath_Advanced_WithHoming, PredictResult) == 0x0000C0, "Member 'GzGameplayStatics_Blueprint_PredictProjectilePath_Advanced_WithHoming::PredictResult' has a wrong offset!");
static_assert(offsetof(GzGameplayStatics_Blueprint_PredictProjectilePath_Advanced_WithHoming, ReturnValue) == 0x000200, "Member 'GzGameplayStatics_Blueprint_PredictProjectilePath_Advanced_WithHoming::ReturnValue' has a wrong offset!");

// Function G01.GzGameplayStatics.BulletMultiTraceSkipOwner
// 0x0060 (0x0060 - 0x0000)
struct GzGameplayStatics_BulletMultiTraceSkipOwner final
{
public:
	const class AActor*                           Owner;                                             // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSkipRecursively;                                  // 0x0008(0x0001)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3288[0x7];                                     // 0x0009(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                Start;                                             // 0x0010(0x0018)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                End;                                               // 0x0028(0x0018)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseComplex;                                       // 0x0040(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3289[0x3];                                     // 0x0041(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   TraceTag;                                          // 0x0044(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_328A[0x4];                                     // 0x004C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FHitResult>                     ReturnValue;                                       // 0x0050(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzGameplayStatics_BulletMultiTraceSkipOwner) == 0x000008, "Wrong alignment on GzGameplayStatics_BulletMultiTraceSkipOwner");
static_assert(sizeof(GzGameplayStatics_BulletMultiTraceSkipOwner) == 0x000060, "Wrong size on GzGameplayStatics_BulletMultiTraceSkipOwner");
static_assert(offsetof(GzGameplayStatics_BulletMultiTraceSkipOwner, Owner) == 0x000000, "Member 'GzGameplayStatics_BulletMultiTraceSkipOwner::Owner' has a wrong offset!");
static_assert(offsetof(GzGameplayStatics_BulletMultiTraceSkipOwner, bSkipRecursively) == 0x000008, "Member 'GzGameplayStatics_BulletMultiTraceSkipOwner::bSkipRecursively' has a wrong offset!");
static_assert(offsetof(GzGameplayStatics_BulletMultiTraceSkipOwner, Start) == 0x000010, "Member 'GzGameplayStatics_BulletMultiTraceSkipOwner::Start' has a wrong offset!");
static_assert(offsetof(GzGameplayStatics_BulletMultiTraceSkipOwner, End) == 0x000028, "Member 'GzGameplayStatics_BulletMultiTraceSkipOwner::End' has a wrong offset!");
static_assert(offsetof(GzGameplayStatics_BulletMultiTraceSkipOwner, bUseComplex) == 0x000040, "Member 'GzGameplayStatics_BulletMultiTraceSkipOwner::bUseComplex' has a wrong offset!");
static_assert(offsetof(GzGameplayStatics_BulletMultiTraceSkipOwner, TraceTag) == 0x000044, "Member 'GzGameplayStatics_BulletMultiTraceSkipOwner::TraceTag' has a wrong offset!");
static_assert(offsetof(GzGameplayStatics_BulletMultiTraceSkipOwner, ReturnValue) == 0x000050, "Member 'GzGameplayStatics_BulletMultiTraceSkipOwner::ReturnValue' has a wrong offset!");

// Function G01.GzGameplayStatics.BulletTraceSkipOwner
// 0x0140 (0x0140 - 0x0000)
struct GzGameplayStatics_BulletTraceSkipOwner final
{
public:
	const class AActor*                           Owner;                                             // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSkipRecursively;                                  // 0x0008(0x0001)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_328B[0x7];                                     // 0x0009(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                Start;                                             // 0x0010(0x0018)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                End;                                               // 0x0028(0x0018)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseComplex;                                       // 0x0040(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_328C[0x7];                                     // 0x0041(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FHitResult                             ReturnValue;                                       // 0x0048(0x00F8)(Parm, OutParm, ReturnParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzGameplayStatics_BulletTraceSkipOwner) == 0x000008, "Wrong alignment on GzGameplayStatics_BulletTraceSkipOwner");
static_assert(sizeof(GzGameplayStatics_BulletTraceSkipOwner) == 0x000140, "Wrong size on GzGameplayStatics_BulletTraceSkipOwner");
static_assert(offsetof(GzGameplayStatics_BulletTraceSkipOwner, Owner) == 0x000000, "Member 'GzGameplayStatics_BulletTraceSkipOwner::Owner' has a wrong offset!");
static_assert(offsetof(GzGameplayStatics_BulletTraceSkipOwner, bSkipRecursively) == 0x000008, "Member 'GzGameplayStatics_BulletTraceSkipOwner::bSkipRecursively' has a wrong offset!");
static_assert(offsetof(GzGameplayStatics_BulletTraceSkipOwner, Start) == 0x000010, "Member 'GzGameplayStatics_BulletTraceSkipOwner::Start' has a wrong offset!");
static_assert(offsetof(GzGameplayStatics_BulletTraceSkipOwner, End) == 0x000028, "Member 'GzGameplayStatics_BulletTraceSkipOwner::End' has a wrong offset!");
static_assert(offsetof(GzGameplayStatics_BulletTraceSkipOwner, bUseComplex) == 0x000040, "Member 'GzGameplayStatics_BulletTraceSkipOwner::bUseComplex' has a wrong offset!");
static_assert(offsetof(GzGameplayStatics_BulletTraceSkipOwner, ReturnValue) == 0x000048, "Member 'GzGameplayStatics_BulletTraceSkipOwner::ReturnValue' has a wrong offset!");

// Function G01.GzGameplayStatics.CreateBoundaryZone
// 0x0018 (0x0018 - 0x0000)
struct GzGameplayStatics_CreateBoundaryZone final
{
public:
	TSubclassOf<class AGzBoundaryZone>            BoundaryZoneClass;                                 // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UObject*                                WorldContextObject;                                // 0x0008(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AGzBoundaryZone*                        ReturnValue;                                       // 0x0010(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzGameplayStatics_CreateBoundaryZone) == 0x000008, "Wrong alignment on GzGameplayStatics_CreateBoundaryZone");
static_assert(sizeof(GzGameplayStatics_CreateBoundaryZone) == 0x000018, "Wrong size on GzGameplayStatics_CreateBoundaryZone");
static_assert(offsetof(GzGameplayStatics_CreateBoundaryZone, BoundaryZoneClass) == 0x000000, "Member 'GzGameplayStatics_CreateBoundaryZone::BoundaryZoneClass' has a wrong offset!");
static_assert(offsetof(GzGameplayStatics_CreateBoundaryZone, WorldContextObject) == 0x000008, "Member 'GzGameplayStatics_CreateBoundaryZone::WorldContextObject' has a wrong offset!");
static_assert(offsetof(GzGameplayStatics_CreateBoundaryZone, ReturnValue) == 0x000010, "Member 'GzGameplayStatics_CreateBoundaryZone::ReturnValue' has a wrong offset!");

// Function G01.GzGameplayStatics.CreateSyncCutscene
// 0x0018 (0x0018 - 0x0000)
struct GzGameplayStatics_CreateSyncCutscene final
{
public:
	const class UObject*                          WorldContextObject;                                // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class AGzSyncCutscene>            CutsceneClass;                                     // 0x0008(0x0008)(Parm, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AGzSyncCutscene*                        ReturnValue;                                       // 0x0010(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzGameplayStatics_CreateSyncCutscene) == 0x000008, "Wrong alignment on GzGameplayStatics_CreateSyncCutscene");
static_assert(sizeof(GzGameplayStatics_CreateSyncCutscene) == 0x000018, "Wrong size on GzGameplayStatics_CreateSyncCutscene");
static_assert(offsetof(GzGameplayStatics_CreateSyncCutscene, WorldContextObject) == 0x000000, "Member 'GzGameplayStatics_CreateSyncCutscene::WorldContextObject' has a wrong offset!");
static_assert(offsetof(GzGameplayStatics_CreateSyncCutscene, CutsceneClass) == 0x000008, "Member 'GzGameplayStatics_CreateSyncCutscene::CutsceneClass' has a wrong offset!");
static_assert(offsetof(GzGameplayStatics_CreateSyncCutscene, ReturnValue) == 0x000010, "Member 'GzGameplayStatics_CreateSyncCutscene::ReturnValue' has a wrong offset!");

// Function G01.GzGameplayStatics.DeprojectSignNormalizedScreenToWorld
// 0x0050 (0x0050 - 0x0000)
struct GzGameplayStatics_DeprojectSignNormalizedScreenToWorld final
{
public:
	class APlayerController*                      PlayerController;                                  // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              ScreenPosition;                                    // 0x0008(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                WorldPosition;                                     // 0x0018(0x0018)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                WorldDirection;                                    // 0x0030(0x0018)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0048(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_328D[0x7];                                     // 0x0049(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GzGameplayStatics_DeprojectSignNormalizedScreenToWorld) == 0x000008, "Wrong alignment on GzGameplayStatics_DeprojectSignNormalizedScreenToWorld");
static_assert(sizeof(GzGameplayStatics_DeprojectSignNormalizedScreenToWorld) == 0x000050, "Wrong size on GzGameplayStatics_DeprojectSignNormalizedScreenToWorld");
static_assert(offsetof(GzGameplayStatics_DeprojectSignNormalizedScreenToWorld, PlayerController) == 0x000000, "Member 'GzGameplayStatics_DeprojectSignNormalizedScreenToWorld::PlayerController' has a wrong offset!");
static_assert(offsetof(GzGameplayStatics_DeprojectSignNormalizedScreenToWorld, ScreenPosition) == 0x000008, "Member 'GzGameplayStatics_DeprojectSignNormalizedScreenToWorld::ScreenPosition' has a wrong offset!");
static_assert(offsetof(GzGameplayStatics_DeprojectSignNormalizedScreenToWorld, WorldPosition) == 0x000018, "Member 'GzGameplayStatics_DeprojectSignNormalizedScreenToWorld::WorldPosition' has a wrong offset!");
static_assert(offsetof(GzGameplayStatics_DeprojectSignNormalizedScreenToWorld, WorldDirection) == 0x000030, "Member 'GzGameplayStatics_DeprojectSignNormalizedScreenToWorld::WorldDirection' has a wrong offset!");
static_assert(offsetof(GzGameplayStatics_DeprojectSignNormalizedScreenToWorld, ReturnValue) == 0x000048, "Member 'GzGameplayStatics_DeprojectSignNormalizedScreenToWorld::ReturnValue' has a wrong offset!");

// Function G01.GzGameplayStatics.DestroyNetForce
// 0x0008 (0x0008 - 0x0000)
struct GzGameplayStatics_DestroyNetForce final
{
public:
	class AActor*                                 Target;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzGameplayStatics_DestroyNetForce) == 0x000008, "Wrong alignment on GzGameplayStatics_DestroyNetForce");
static_assert(sizeof(GzGameplayStatics_DestroyNetForce) == 0x000008, "Wrong size on GzGameplayStatics_DestroyNetForce");
static_assert(offsetof(GzGameplayStatics_DestroyNetForce, Target) == 0x000000, "Member 'GzGameplayStatics_DestroyNetForce::Target' has a wrong offset!");

// Function G01.GzGameplayStatics.EstimateAttributeValueChange
// 0x0050 (0x0050 - 0x0000)
struct GzGameplayStatics_EstimateAttributeValueChange final
{
public:
	TArray<class UGameplayEffect*>                Effects;                                           // 0x0000(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	struct FGameplayAttribute                     Attribute;                                         // 0x0010(0x0038)(ConstParm, Parm, OutParm, ReferenceParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ReturnValue;                                       // 0x0048(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_328E[0x4];                                     // 0x004C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GzGameplayStatics_EstimateAttributeValueChange) == 0x000008, "Wrong alignment on GzGameplayStatics_EstimateAttributeValueChange");
static_assert(sizeof(GzGameplayStatics_EstimateAttributeValueChange) == 0x000050, "Wrong size on GzGameplayStatics_EstimateAttributeValueChange");
static_assert(offsetof(GzGameplayStatics_EstimateAttributeValueChange, Effects) == 0x000000, "Member 'GzGameplayStatics_EstimateAttributeValueChange::Effects' has a wrong offset!");
static_assert(offsetof(GzGameplayStatics_EstimateAttributeValueChange, Attribute) == 0x000010, "Member 'GzGameplayStatics_EstimateAttributeValueChange::Attribute' has a wrong offset!");
static_assert(offsetof(GzGameplayStatics_EstimateAttributeValueChange, ReturnValue) == 0x000048, "Member 'GzGameplayStatics_EstimateAttributeValueChange::ReturnValue' has a wrong offset!");

// Function G01.GzGameplayStatics.ExitOfflineSession
// 0x0008 (0x0008 - 0x0000)
struct GzGameplayStatics_ExitOfflineSession final
{
public:
	const class UObject*                          WorldContextObject;                                // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzGameplayStatics_ExitOfflineSession) == 0x000008, "Wrong alignment on GzGameplayStatics_ExitOfflineSession");
static_assert(sizeof(GzGameplayStatics_ExitOfflineSession) == 0x000008, "Wrong size on GzGameplayStatics_ExitOfflineSession");
static_assert(offsetof(GzGameplayStatics_ExitOfflineSession, WorldContextObject) == 0x000000, "Member 'GzGameplayStatics_ExitOfflineSession::WorldContextObject' has a wrong offset!");

// Function G01.GzGameplayStatics.FindClosestEnemy
// 0x0018 (0x0018 - 0x0000)
struct GzGameplayStatics_FindClosestEnemy final
{
public:
	class AGzBaseCharacter*                       MyPawn;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinDist;                                           // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxDist;                                           // 0x000C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class APawn*                                  ReturnValue;                                       // 0x0010(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzGameplayStatics_FindClosestEnemy) == 0x000008, "Wrong alignment on GzGameplayStatics_FindClosestEnemy");
static_assert(sizeof(GzGameplayStatics_FindClosestEnemy) == 0x000018, "Wrong size on GzGameplayStatics_FindClosestEnemy");
static_assert(offsetof(GzGameplayStatics_FindClosestEnemy, MyPawn) == 0x000000, "Member 'GzGameplayStatics_FindClosestEnemy::MyPawn' has a wrong offset!");
static_assert(offsetof(GzGameplayStatics_FindClosestEnemy, MinDist) == 0x000008, "Member 'GzGameplayStatics_FindClosestEnemy::MinDist' has a wrong offset!");
static_assert(offsetof(GzGameplayStatics_FindClosestEnemy, MaxDist) == 0x00000C, "Member 'GzGameplayStatics_FindClosestEnemy::MaxDist' has a wrong offset!");
static_assert(offsetof(GzGameplayStatics_FindClosestEnemy, ReturnValue) == 0x000010, "Member 'GzGameplayStatics_FindClosestEnemy::ReturnValue' has a wrong offset!");

// Function G01.GzGameplayStatics.FindClosestPlayerLocationToTarget
// 0x0040 (0x0040 - 0x0000)
struct GzGameplayStatics_FindClosestPlayerLocationToTarget final
{
public:
	class AGzTeam*                                Team;                                              // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Location;                                          // 0x0008(0x0018)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                OutPosition;                                       // 0x0020(0x0018)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0038(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_328F[0x7];                                     // 0x0039(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GzGameplayStatics_FindClosestPlayerLocationToTarget) == 0x000008, "Wrong alignment on GzGameplayStatics_FindClosestPlayerLocationToTarget");
static_assert(sizeof(GzGameplayStatics_FindClosestPlayerLocationToTarget) == 0x000040, "Wrong size on GzGameplayStatics_FindClosestPlayerLocationToTarget");
static_assert(offsetof(GzGameplayStatics_FindClosestPlayerLocationToTarget, Team) == 0x000000, "Member 'GzGameplayStatics_FindClosestPlayerLocationToTarget::Team' has a wrong offset!");
static_assert(offsetof(GzGameplayStatics_FindClosestPlayerLocationToTarget, Location) == 0x000008, "Member 'GzGameplayStatics_FindClosestPlayerLocationToTarget::Location' has a wrong offset!");
static_assert(offsetof(GzGameplayStatics_FindClosestPlayerLocationToTarget, OutPosition) == 0x000020, "Member 'GzGameplayStatics_FindClosestPlayerLocationToTarget::OutPosition' has a wrong offset!");
static_assert(offsetof(GzGameplayStatics_FindClosestPlayerLocationToTarget, ReturnValue) == 0x000038, "Member 'GzGameplayStatics_FindClosestPlayerLocationToTarget::ReturnValue' has a wrong offset!");

// Function G01.GzGameplayStatics.GetAllLevelTypes
// 0x0020 (0x0020 - 0x0000)
struct GzGameplayStatics_GetAllLevelTypes final
{
public:
	const class UObject*                          WorldContextObject;                                // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class AActor>                     Param_Class;                                       // 0x0008(0x0008)(Parm, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class UClass*>                         OutClasses;                                        // 0x0010(0x0010)(Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzGameplayStatics_GetAllLevelTypes) == 0x000008, "Wrong alignment on GzGameplayStatics_GetAllLevelTypes");
static_assert(sizeof(GzGameplayStatics_GetAllLevelTypes) == 0x000020, "Wrong size on GzGameplayStatics_GetAllLevelTypes");
static_assert(offsetof(GzGameplayStatics_GetAllLevelTypes, WorldContextObject) == 0x000000, "Member 'GzGameplayStatics_GetAllLevelTypes::WorldContextObject' has a wrong offset!");
static_assert(offsetof(GzGameplayStatics_GetAllLevelTypes, Param_Class) == 0x000008, "Member 'GzGameplayStatics_GetAllLevelTypes::Param_Class' has a wrong offset!");
static_assert(offsetof(GzGameplayStatics_GetAllLevelTypes, OutClasses) == 0x000010, "Member 'GzGameplayStatics_GetAllLevelTypes::OutClasses' has a wrong offset!");

// Function G01.GzGameplayStatics.GetBoundaryZone
// 0x0010 (0x0010 - 0x0000)
struct GzGameplayStatics_GetBoundaryZone final
{
public:
	class UObject*                                WorldContextObject;                                // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AGzBoundaryZone*                        ReturnValue;                                       // 0x0008(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzGameplayStatics_GetBoundaryZone) == 0x000008, "Wrong alignment on GzGameplayStatics_GetBoundaryZone");
static_assert(sizeof(GzGameplayStatics_GetBoundaryZone) == 0x000010, "Wrong size on GzGameplayStatics_GetBoundaryZone");
static_assert(offsetof(GzGameplayStatics_GetBoundaryZone, WorldContextObject) == 0x000000, "Member 'GzGameplayStatics_GetBoundaryZone::WorldContextObject' has a wrong offset!");
static_assert(offsetof(GzGameplayStatics_GetBoundaryZone, ReturnValue) == 0x000008, "Member 'GzGameplayStatics_GetBoundaryZone::ReturnValue' has a wrong offset!");

// Function G01.GzGameplayStatics.GetCharacterIdAccessActor
// 0x0018 (0x0018 - 0x0000)
struct GzGameplayStatics_GetCharacterIdAccessActor final
{
public:
	struct FGzCharacterIdAccess                   CharacterIdAccess;                                 // 0x0000(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	class AActor*                                 ReturnValue;                                       // 0x0010(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzGameplayStatics_GetCharacterIdAccessActor) == 0x000008, "Wrong alignment on GzGameplayStatics_GetCharacterIdAccessActor");
static_assert(sizeof(GzGameplayStatics_GetCharacterIdAccessActor) == 0x000018, "Wrong size on GzGameplayStatics_GetCharacterIdAccessActor");
static_assert(offsetof(GzGameplayStatics_GetCharacterIdAccessActor, CharacterIdAccess) == 0x000000, "Member 'GzGameplayStatics_GetCharacterIdAccessActor::CharacterIdAccess' has a wrong offset!");
static_assert(offsetof(GzGameplayStatics_GetCharacterIdAccessActor, ReturnValue) == 0x000010, "Member 'GzGameplayStatics_GetCharacterIdAccessActor::ReturnValue' has a wrong offset!");

// Function G01.GzGameplayStatics.GetCurrentAimAssistSettings
// 0x0018 (0x0018 - 0x0000)
struct GzGameplayStatics_GetCurrentAimAssistSettings final
{
public:
	struct FGzAimAssistPresetSettings             ReturnValue;                                       // 0x0000(0x0018)(ConstParm, Parm, OutParm, ReturnParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzGameplayStatics_GetCurrentAimAssistSettings) == 0x000008, "Wrong alignment on GzGameplayStatics_GetCurrentAimAssistSettings");
static_assert(sizeof(GzGameplayStatics_GetCurrentAimAssistSettings) == 0x000018, "Wrong size on GzGameplayStatics_GetCurrentAimAssistSettings");
static_assert(offsetof(GzGameplayStatics_GetCurrentAimAssistSettings, ReturnValue) == 0x000000, "Member 'GzGameplayStatics_GetCurrentAimAssistSettings::ReturnValue' has a wrong offset!");

// Function G01.GzGameplayStatics.GetCurrentTime
// 0x0010 (0x0010 - 0x0000)
struct GzGameplayStatics_GetCurrentTime final
{
public:
	const class UObject*                          WorldContextObject;                                // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ReturnValue;                                       // 0x0008(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3290[0x4];                                     // 0x000C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GzGameplayStatics_GetCurrentTime) == 0x000008, "Wrong alignment on GzGameplayStatics_GetCurrentTime");
static_assert(sizeof(GzGameplayStatics_GetCurrentTime) == 0x000010, "Wrong size on GzGameplayStatics_GetCurrentTime");
static_assert(offsetof(GzGameplayStatics_GetCurrentTime, WorldContextObject) == 0x000000, "Member 'GzGameplayStatics_GetCurrentTime::WorldContextObject' has a wrong offset!");
static_assert(offsetof(GzGameplayStatics_GetCurrentTime, ReturnValue) == 0x000008, "Member 'GzGameplayStatics_GetCurrentTime::ReturnValue' has a wrong offset!");

// Function G01.GzGameplayStatics.GetHexExtractionCostMultiplier
// 0x0010 (0x0010 - 0x0000)
struct GzGameplayStatics_GetHexExtractionCostMultiplier final
{
public:
	const class UObject*                          WorldContextObject;                                // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ReturnValue;                                       // 0x0008(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3291[0x4];                                     // 0x000C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GzGameplayStatics_GetHexExtractionCostMultiplier) == 0x000008, "Wrong alignment on GzGameplayStatics_GetHexExtractionCostMultiplier");
static_assert(sizeof(GzGameplayStatics_GetHexExtractionCostMultiplier) == 0x000010, "Wrong size on GzGameplayStatics_GetHexExtractionCostMultiplier");
static_assert(offsetof(GzGameplayStatics_GetHexExtractionCostMultiplier, WorldContextObject) == 0x000000, "Member 'GzGameplayStatics_GetHexExtractionCostMultiplier::WorldContextObject' has a wrong offset!");
static_assert(offsetof(GzGameplayStatics_GetHexExtractionCostMultiplier, ReturnValue) == 0x000008, "Member 'GzGameplayStatics_GetHexExtractionCostMultiplier::ReturnValue' has a wrong offset!");

// Function G01.GzGameplayStatics.GetHexExtractionTimeMultiplier
// 0x0010 (0x0010 - 0x0000)
struct GzGameplayStatics_GetHexExtractionTimeMultiplier final
{
public:
	const class UObject*                          WorldContextObject;                                // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ReturnValue;                                       // 0x0008(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3292[0x4];                                     // 0x000C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GzGameplayStatics_GetHexExtractionTimeMultiplier) == 0x000008, "Wrong alignment on GzGameplayStatics_GetHexExtractionTimeMultiplier");
static_assert(sizeof(GzGameplayStatics_GetHexExtractionTimeMultiplier) == 0x000010, "Wrong size on GzGameplayStatics_GetHexExtractionTimeMultiplier");
static_assert(offsetof(GzGameplayStatics_GetHexExtractionTimeMultiplier, WorldContextObject) == 0x000000, "Member 'GzGameplayStatics_GetHexExtractionTimeMultiplier::WorldContextObject' has a wrong offset!");
static_assert(offsetof(GzGameplayStatics_GetHexExtractionTimeMultiplier, ReturnValue) == 0x000008, "Member 'GzGameplayStatics_GetHexExtractionTimeMultiplier::ReturnValue' has a wrong offset!");

// Function G01.GzGameplayStatics.GetImpactPhysicalMaterial
// 0x0108 (0x0108 - 0x0000)
struct GzGameplayStatics_GetImpactPhysicalMaterial final
{
public:
	struct FHitResult                             Hit;                                               // 0x0000(0x00F8)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	bool                                          bHitArmor;                                         // 0x00F8(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3293[0x7];                                     // 0x00F9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UPhysicalMaterial*                      ReturnValue;                                       // 0x0100(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzGameplayStatics_GetImpactPhysicalMaterial) == 0x000008, "Wrong alignment on GzGameplayStatics_GetImpactPhysicalMaterial");
static_assert(sizeof(GzGameplayStatics_GetImpactPhysicalMaterial) == 0x000108, "Wrong size on GzGameplayStatics_GetImpactPhysicalMaterial");
static_assert(offsetof(GzGameplayStatics_GetImpactPhysicalMaterial, Hit) == 0x000000, "Member 'GzGameplayStatics_GetImpactPhysicalMaterial::Hit' has a wrong offset!");
static_assert(offsetof(GzGameplayStatics_GetImpactPhysicalMaterial, bHitArmor) == 0x0000F8, "Member 'GzGameplayStatics_GetImpactPhysicalMaterial::bHitArmor' has a wrong offset!");
static_assert(offsetof(GzGameplayStatics_GetImpactPhysicalMaterial, ReturnValue) == 0x000100, "Member 'GzGameplayStatics_GetImpactPhysicalMaterial::ReturnValue' has a wrong offset!");

// Function G01.GzGameplayStatics.GetItemExtractionCost
// 0x0018 (0x0018 - 0x0000)
struct GzGameplayStatics_GetItemExtractionCost final
{
public:
	const class UObject*                          WorldContextObject;                                // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	const class UGzItemData*                      Item;                                              // 0x0008(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ReturnValue;                                       // 0x0010(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3294[0x4];                                     // 0x0014(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GzGameplayStatics_GetItemExtractionCost) == 0x000008, "Wrong alignment on GzGameplayStatics_GetItemExtractionCost");
static_assert(sizeof(GzGameplayStatics_GetItemExtractionCost) == 0x000018, "Wrong size on GzGameplayStatics_GetItemExtractionCost");
static_assert(offsetof(GzGameplayStatics_GetItemExtractionCost, WorldContextObject) == 0x000000, "Member 'GzGameplayStatics_GetItemExtractionCost::WorldContextObject' has a wrong offset!");
static_assert(offsetof(GzGameplayStatics_GetItemExtractionCost, Item) == 0x000008, "Member 'GzGameplayStatics_GetItemExtractionCost::Item' has a wrong offset!");
static_assert(offsetof(GzGameplayStatics_GetItemExtractionCost, ReturnValue) == 0x000010, "Member 'GzGameplayStatics_GetItemExtractionCost::ReturnValue' has a wrong offset!");

// Function G01.GzGameplayStatics.GetLocalPlayerController
// 0x0010 (0x0010 - 0x0000)
struct GzGameplayStatics_GetLocalPlayerController final
{
public:
	const class UObject*                          WorldContextObject;                                // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AGzPlayerController*                    ReturnValue;                                       // 0x0008(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzGameplayStatics_GetLocalPlayerController) == 0x000008, "Wrong alignment on GzGameplayStatics_GetLocalPlayerController");
static_assert(sizeof(GzGameplayStatics_GetLocalPlayerController) == 0x000010, "Wrong size on GzGameplayStatics_GetLocalPlayerController");
static_assert(offsetof(GzGameplayStatics_GetLocalPlayerController, WorldContextObject) == 0x000000, "Member 'GzGameplayStatics_GetLocalPlayerController::WorldContextObject' has a wrong offset!");
static_assert(offsetof(GzGameplayStatics_GetLocalPlayerController, ReturnValue) == 0x000008, "Member 'GzGameplayStatics_GetLocalPlayerController::ReturnValue' has a wrong offset!");

// Function G01.GzGameplayStatics.GetLocalViewTarget
// 0x0010 (0x0010 - 0x0000)
struct GzGameplayStatics_GetLocalViewTarget final
{
public:
	const class UObject*                          WorldContextObject;                                // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 ReturnValue;                                       // 0x0008(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzGameplayStatics_GetLocalViewTarget) == 0x000008, "Wrong alignment on GzGameplayStatics_GetLocalViewTarget");
static_assert(sizeof(GzGameplayStatics_GetLocalViewTarget) == 0x000010, "Wrong size on GzGameplayStatics_GetLocalViewTarget");
static_assert(offsetof(GzGameplayStatics_GetLocalViewTarget, WorldContextObject) == 0x000000, "Member 'GzGameplayStatics_GetLocalViewTarget::WorldContextObject' has a wrong offset!");
static_assert(offsetof(GzGameplayStatics_GetLocalViewTarget, ReturnValue) == 0x000008, "Member 'GzGameplayStatics_GetLocalViewTarget::ReturnValue' has a wrong offset!");

// Function G01.GzGameplayStatics.GetPickupsInRadius
// 0x0040 (0x0040 - 0x0000)
struct GzGameplayStatics_GetPickupsInRadius final
{
public:
	const class UObject*                          WorldContextObject;                                // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Location;                                          // 0x0008(0x0018)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Radius;                                            // 0x0020(0x0004)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           ItemType;                                          // 0x0024(0x0008)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3295[0x4];                                     // 0x002C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class AGzPickableBase*>                ReturnValue;                                       // 0x0030(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzGameplayStatics_GetPickupsInRadius) == 0x000008, "Wrong alignment on GzGameplayStatics_GetPickupsInRadius");
static_assert(sizeof(GzGameplayStatics_GetPickupsInRadius) == 0x000040, "Wrong size on GzGameplayStatics_GetPickupsInRadius");
static_assert(offsetof(GzGameplayStatics_GetPickupsInRadius, WorldContextObject) == 0x000000, "Member 'GzGameplayStatics_GetPickupsInRadius::WorldContextObject' has a wrong offset!");
static_assert(offsetof(GzGameplayStatics_GetPickupsInRadius, Location) == 0x000008, "Member 'GzGameplayStatics_GetPickupsInRadius::Location' has a wrong offset!");
static_assert(offsetof(GzGameplayStatics_GetPickupsInRadius, Radius) == 0x000020, "Member 'GzGameplayStatics_GetPickupsInRadius::Radius' has a wrong offset!");
static_assert(offsetof(GzGameplayStatics_GetPickupsInRadius, ItemType) == 0x000024, "Member 'GzGameplayStatics_GetPickupsInRadius::ItemType' has a wrong offset!");
static_assert(offsetof(GzGameplayStatics_GetPickupsInRadius, ReturnValue) == 0x000030, "Member 'GzGameplayStatics_GetPickupsInRadius::ReturnValue' has a wrong offset!");

// Function G01.GzGameplayStatics.GetPlayerStateFromContext
// 0x0010 (0x0010 - 0x0000)
struct GzGameplayStatics_GetPlayerStateFromContext final
{
public:
	class AActor*                                 ActorContext;                                      // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AGzPlayerState*                         ReturnValue;                                       // 0x0008(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzGameplayStatics_GetPlayerStateFromContext) == 0x000008, "Wrong alignment on GzGameplayStatics_GetPlayerStateFromContext");
static_assert(sizeof(GzGameplayStatics_GetPlayerStateFromContext) == 0x000010, "Wrong size on GzGameplayStatics_GetPlayerStateFromContext");
static_assert(offsetof(GzGameplayStatics_GetPlayerStateFromContext, ActorContext) == 0x000000, "Member 'GzGameplayStatics_GetPlayerStateFromContext::ActorContext' has a wrong offset!");
static_assert(offsetof(GzGameplayStatics_GetPlayerStateFromContext, ReturnValue) == 0x000008, "Member 'GzGameplayStatics_GetPlayerStateFromContext::ReturnValue' has a wrong offset!");

// Function G01.GzGameplayStatics.GetPlayerStateFromPlayerId
// 0x0018 (0x0018 - 0x0000)
struct GzGameplayStatics_GetPlayerStateFromPlayerId final
{
public:
	const class UObject*                          WorldContextObject;                                // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         PlayerId;                                          // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3296[0x4];                                     // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class AGzPlayerState*                         ReturnValue;                                       // 0x0010(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzGameplayStatics_GetPlayerStateFromPlayerId) == 0x000008, "Wrong alignment on GzGameplayStatics_GetPlayerStateFromPlayerId");
static_assert(sizeof(GzGameplayStatics_GetPlayerStateFromPlayerId) == 0x000018, "Wrong size on GzGameplayStatics_GetPlayerStateFromPlayerId");
static_assert(offsetof(GzGameplayStatics_GetPlayerStateFromPlayerId, WorldContextObject) == 0x000000, "Member 'GzGameplayStatics_GetPlayerStateFromPlayerId::WorldContextObject' has a wrong offset!");
static_assert(offsetof(GzGameplayStatics_GetPlayerStateFromPlayerId, PlayerId) == 0x000008, "Member 'GzGameplayStatics_GetPlayerStateFromPlayerId::PlayerId' has a wrong offset!");
static_assert(offsetof(GzGameplayStatics_GetPlayerStateFromPlayerId, ReturnValue) == 0x000010, "Member 'GzGameplayStatics_GetPlayerStateFromPlayerId::ReturnValue' has a wrong offset!");

// Function G01.GzGameplayStatics.GetPlayerStateFromPlayFabId
// 0x0020 (0x0020 - 0x0000)
struct GzGameplayStatics_GetPlayerStateFromPlayFabId final
{
public:
	const class UObject*                          WorldContextObject;                                // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 PlayFabId;                                         // 0x0008(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AGzPlayerState*                         ReturnValue;                                       // 0x0018(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzGameplayStatics_GetPlayerStateFromPlayFabId) == 0x000008, "Wrong alignment on GzGameplayStatics_GetPlayerStateFromPlayFabId");
static_assert(sizeof(GzGameplayStatics_GetPlayerStateFromPlayFabId) == 0x000020, "Wrong size on GzGameplayStatics_GetPlayerStateFromPlayFabId");
static_assert(offsetof(GzGameplayStatics_GetPlayerStateFromPlayFabId, WorldContextObject) == 0x000000, "Member 'GzGameplayStatics_GetPlayerStateFromPlayFabId::WorldContextObject' has a wrong offset!");
static_assert(offsetof(GzGameplayStatics_GetPlayerStateFromPlayFabId, PlayFabId) == 0x000008, "Member 'GzGameplayStatics_GetPlayerStateFromPlayFabId::PlayFabId' has a wrong offset!");
static_assert(offsetof(GzGameplayStatics_GetPlayerStateFromPlayFabId, ReturnValue) == 0x000018, "Member 'GzGameplayStatics_GetPlayerStateFromPlayFabId::ReturnValue' has a wrong offset!");

// Function G01.GzGameplayStatics.GetRandomActorOfClass
// 0x0018 (0x0018 - 0x0000)
struct GzGameplayStatics_GetRandomActorOfClass final
{
public:
	const class UObject*                          WorldContextObject;                                // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class AActor>                     Param_Class;                                       // 0x0008(0x0008)(Parm, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 ReturnValue;                                       // 0x0010(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzGameplayStatics_GetRandomActorOfClass) == 0x000008, "Wrong alignment on GzGameplayStatics_GetRandomActorOfClass");
static_assert(sizeof(GzGameplayStatics_GetRandomActorOfClass) == 0x000018, "Wrong size on GzGameplayStatics_GetRandomActorOfClass");
static_assert(offsetof(GzGameplayStatics_GetRandomActorOfClass, WorldContextObject) == 0x000000, "Member 'GzGameplayStatics_GetRandomActorOfClass::WorldContextObject' has a wrong offset!");
static_assert(offsetof(GzGameplayStatics_GetRandomActorOfClass, Param_Class) == 0x000008, "Member 'GzGameplayStatics_GetRandomActorOfClass::Param_Class' has a wrong offset!");
static_assert(offsetof(GzGameplayStatics_GetRandomActorOfClass, ReturnValue) == 0x000010, "Member 'GzGameplayStatics_GetRandomActorOfClass::ReturnValue' has a wrong offset!");

// Function G01.GzGameplayStatics.GetServerWorldTimeSeconds
// 0x0010 (0x0010 - 0x0000)
struct GzGameplayStatics_GetServerWorldTimeSeconds final
{
public:
	class UObject*                                WorldContextObject;                                // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ReturnValue;                                       // 0x0008(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3297[0x4];                                     // 0x000C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GzGameplayStatics_GetServerWorldTimeSeconds) == 0x000008, "Wrong alignment on GzGameplayStatics_GetServerWorldTimeSeconds");
static_assert(sizeof(GzGameplayStatics_GetServerWorldTimeSeconds) == 0x000010, "Wrong size on GzGameplayStatics_GetServerWorldTimeSeconds");
static_assert(offsetof(GzGameplayStatics_GetServerWorldTimeSeconds, WorldContextObject) == 0x000000, "Member 'GzGameplayStatics_GetServerWorldTimeSeconds::WorldContextObject' has a wrong offset!");
static_assert(offsetof(GzGameplayStatics_GetServerWorldTimeSeconds, ReturnValue) == 0x000008, "Member 'GzGameplayStatics_GetServerWorldTimeSeconds::ReturnValue' has a wrong offset!");

// Function G01.GzGameplayStatics.GetSubsystem
// 0x0020 (0x0020 - 0x0000)
struct GzGameplayStatics_GetSubsystem final
{
public:
	class UObject*                                WorldContextObject;                                // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class AGzGameModeSubsystem>       InClass;                                           // 0x0008(0x0008)(Parm, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AGzGameModeSubsystem*                   OutSubsystem;                                      // 0x0010(0x0008)(Parm, OutParm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EGzGetSubsystemResult                         OutExecNodes;                                      // 0x0018(0x0001)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3298[0x7];                                     // 0x0019(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GzGameplayStatics_GetSubsystem) == 0x000008, "Wrong alignment on GzGameplayStatics_GetSubsystem");
static_assert(sizeof(GzGameplayStatics_GetSubsystem) == 0x000020, "Wrong size on GzGameplayStatics_GetSubsystem");
static_assert(offsetof(GzGameplayStatics_GetSubsystem, WorldContextObject) == 0x000000, "Member 'GzGameplayStatics_GetSubsystem::WorldContextObject' has a wrong offset!");
static_assert(offsetof(GzGameplayStatics_GetSubsystem, InClass) == 0x000008, "Member 'GzGameplayStatics_GetSubsystem::InClass' has a wrong offset!");
static_assert(offsetof(GzGameplayStatics_GetSubsystem, OutSubsystem) == 0x000010, "Member 'GzGameplayStatics_GetSubsystem::OutSubsystem' has a wrong offset!");
static_assert(offsetof(GzGameplayStatics_GetSubsystem, OutExecNodes) == 0x000018, "Member 'GzGameplayStatics_GetSubsystem::OutExecNodes' has a wrong offset!");

// Function G01.GzGameplayStatics.GetTeamFromPlayerId
// 0x0018 (0x0018 - 0x0000)
struct GzGameplayStatics_GetTeamFromPlayerId final
{
public:
	const class UObject*                          WorldContextObject;                                // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         PlayerId;                                          // 0x0008(0x0004)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3299[0x4];                                     // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class AGzTeam*                                ReturnValue;                                       // 0x0010(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzGameplayStatics_GetTeamFromPlayerId) == 0x000008, "Wrong alignment on GzGameplayStatics_GetTeamFromPlayerId");
static_assert(sizeof(GzGameplayStatics_GetTeamFromPlayerId) == 0x000018, "Wrong size on GzGameplayStatics_GetTeamFromPlayerId");
static_assert(offsetof(GzGameplayStatics_GetTeamFromPlayerId, WorldContextObject) == 0x000000, "Member 'GzGameplayStatics_GetTeamFromPlayerId::WorldContextObject' has a wrong offset!");
static_assert(offsetof(GzGameplayStatics_GetTeamFromPlayerId, PlayerId) == 0x000008, "Member 'GzGameplayStatics_GetTeamFromPlayerId::PlayerId' has a wrong offset!");
static_assert(offsetof(GzGameplayStatics_GetTeamFromPlayerId, ReturnValue) == 0x000010, "Member 'GzGameplayStatics_GetTeamFromPlayerId::ReturnValue' has a wrong offset!");

// Function G01.GzGameplayStatics.GetTotalRedeployCostModifier
// 0x0010 (0x0010 - 0x0000)
struct GzGameplayStatics_GetTotalRedeployCostModifier final
{
public:
	const class UObject*                          WorldContextObject;                                // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ReturnValue;                                       // 0x0008(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_329A[0x4];                                     // 0x000C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GzGameplayStatics_GetTotalRedeployCostModifier) == 0x000008, "Wrong alignment on GzGameplayStatics_GetTotalRedeployCostModifier");
static_assert(sizeof(GzGameplayStatics_GetTotalRedeployCostModifier) == 0x000010, "Wrong size on GzGameplayStatics_GetTotalRedeployCostModifier");
static_assert(offsetof(GzGameplayStatics_GetTotalRedeployCostModifier, WorldContextObject) == 0x000000, "Member 'GzGameplayStatics_GetTotalRedeployCostModifier::WorldContextObject' has a wrong offset!");
static_assert(offsetof(GzGameplayStatics_GetTotalRedeployCostModifier, ReturnValue) == 0x000008, "Member 'GzGameplayStatics_GetTotalRedeployCostModifier::ReturnValue' has a wrong offset!");

// Function G01.GzGameplayStatics.GetWorldZoneGameplayTag
// 0x0010 (0x0010 - 0x0000)
struct GzGameplayStatics_GetWorldZoneGameplayTag final
{
public:
	class UGzWorldZone*                           WorldZone;                                         // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           ReturnValue;                                       // 0x0008(0x0008)(Parm, OutParm, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzGameplayStatics_GetWorldZoneGameplayTag) == 0x000008, "Wrong alignment on GzGameplayStatics_GetWorldZoneGameplayTag");
static_assert(sizeof(GzGameplayStatics_GetWorldZoneGameplayTag) == 0x000010, "Wrong size on GzGameplayStatics_GetWorldZoneGameplayTag");
static_assert(offsetof(GzGameplayStatics_GetWorldZoneGameplayTag, WorldZone) == 0x000000, "Member 'GzGameplayStatics_GetWorldZoneGameplayTag::WorldZone' has a wrong offset!");
static_assert(offsetof(GzGameplayStatics_GetWorldZoneGameplayTag, ReturnValue) == 0x000008, "Member 'GzGameplayStatics_GetWorldZoneGameplayTag::ReturnValue' has a wrong offset!");

// Function G01.GzGameplayStatics.HasWeaponLOSToCharacter
// 0x0020 (0x0020 - 0x0000)
struct GzGameplayStatics_HasWeaponLOSToCharacter final
{
public:
	class AGzCharacter*                           MyPawn;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AGzCharacter*                           TargetCharacter;                                   // 0x0008(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAnyCharacter;                                     // 0x0010(0x0001)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_329B[0x7];                                     // 0x0011(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class AGzCharacter*                           ReturnValue;                                       // 0x0018(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzGameplayStatics_HasWeaponLOSToCharacter) == 0x000008, "Wrong alignment on GzGameplayStatics_HasWeaponLOSToCharacter");
static_assert(sizeof(GzGameplayStatics_HasWeaponLOSToCharacter) == 0x000020, "Wrong size on GzGameplayStatics_HasWeaponLOSToCharacter");
static_assert(offsetof(GzGameplayStatics_HasWeaponLOSToCharacter, MyPawn) == 0x000000, "Member 'GzGameplayStatics_HasWeaponLOSToCharacter::MyPawn' has a wrong offset!");
static_assert(offsetof(GzGameplayStatics_HasWeaponLOSToCharacter, TargetCharacter) == 0x000008, "Member 'GzGameplayStatics_HasWeaponLOSToCharacter::TargetCharacter' has a wrong offset!");
static_assert(offsetof(GzGameplayStatics_HasWeaponLOSToCharacter, bAnyCharacter) == 0x000010, "Member 'GzGameplayStatics_HasWeaponLOSToCharacter::bAnyCharacter' has a wrong offset!");
static_assert(offsetof(GzGameplayStatics_HasWeaponLOSToCharacter, ReturnValue) == 0x000018, "Member 'GzGameplayStatics_HasWeaponLOSToCharacter::ReturnValue' has a wrong offset!");

// Function G01.GzGameplayStatics.IsGameRuleEnabled
// 0x0018 (0x0018 - 0x0000)
struct GzGameplayStatics_IsGameRuleEnabled final
{
public:
	const class UObject*                          WorldContextObject;                                // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           Rule;                                              // 0x0008(0x0008)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0010(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_329C[0x7];                                     // 0x0011(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GzGameplayStatics_IsGameRuleEnabled) == 0x000008, "Wrong alignment on GzGameplayStatics_IsGameRuleEnabled");
static_assert(sizeof(GzGameplayStatics_IsGameRuleEnabled) == 0x000018, "Wrong size on GzGameplayStatics_IsGameRuleEnabled");
static_assert(offsetof(GzGameplayStatics_IsGameRuleEnabled, WorldContextObject) == 0x000000, "Member 'GzGameplayStatics_IsGameRuleEnabled::WorldContextObject' has a wrong offset!");
static_assert(offsetof(GzGameplayStatics_IsGameRuleEnabled, Rule) == 0x000008, "Member 'GzGameplayStatics_IsGameRuleEnabled::Rule' has a wrong offset!");
static_assert(offsetof(GzGameplayStatics_IsGameRuleEnabled, ReturnValue) == 0x000010, "Member 'GzGameplayStatics_IsGameRuleEnabled::ReturnValue' has a wrong offset!");

// Function G01.GzGameplayStatics.IsLocalPlayerCommunicationRestricted
// 0x0010 (0x0010 - 0x0000)
struct GzGameplayStatics_IsLocalPlayerCommunicationRestricted final
{
public:
	const class UObject*                          WorldContextObject;                                // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_329D[0x7];                                     // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GzGameplayStatics_IsLocalPlayerCommunicationRestricted) == 0x000008, "Wrong alignment on GzGameplayStatics_IsLocalPlayerCommunicationRestricted");
static_assert(sizeof(GzGameplayStatics_IsLocalPlayerCommunicationRestricted) == 0x000010, "Wrong size on GzGameplayStatics_IsLocalPlayerCommunicationRestricted");
static_assert(offsetof(GzGameplayStatics_IsLocalPlayerCommunicationRestricted, WorldContextObject) == 0x000000, "Member 'GzGameplayStatics_IsLocalPlayerCommunicationRestricted::WorldContextObject' has a wrong offset!");
static_assert(offsetof(GzGameplayStatics_IsLocalPlayerCommunicationRestricted, ReturnValue) == 0x000008, "Member 'GzGameplayStatics_IsLocalPlayerCommunicationRestricted::ReturnValue' has a wrong offset!");

// Function G01.GzGameplayStatics.IsWithEditor
// 0x0001 (0x0001 - 0x0000)
struct GzGameplayStatics_IsWithEditor final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzGameplayStatics_IsWithEditor) == 0x000001, "Wrong alignment on GzGameplayStatics_IsWithEditor");
static_assert(sizeof(GzGameplayStatics_IsWithEditor) == 0x000001, "Wrong size on GzGameplayStatics_IsWithEditor");
static_assert(offsetof(GzGameplayStatics_IsWithEditor, ReturnValue) == 0x000000, "Member 'GzGameplayStatics_IsWithEditor::ReturnValue' has a wrong offset!");

// Function G01.GzGameplayStatics.LineTraceSkipOwner
// 0x0140 (0x0140 - 0x0000)
struct GzGameplayStatics_LineTraceSkipOwner final
{
public:
	const class AActor*                           Owner;                                             // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSkipRecursively;                                  // 0x0008(0x0001)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECollisionChannel                             CollisionChannel;                                  // 0x0009(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_329E[0x6];                                     // 0x000A(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                Start;                                             // 0x0010(0x0018)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                End;                                               // 0x0028(0x0018)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseComplex;                                       // 0x0040(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_329F[0x7];                                     // 0x0041(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FHitResult                             ReturnValue;                                       // 0x0048(0x00F8)(Parm, OutParm, ReturnParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzGameplayStatics_LineTraceSkipOwner) == 0x000008, "Wrong alignment on GzGameplayStatics_LineTraceSkipOwner");
static_assert(sizeof(GzGameplayStatics_LineTraceSkipOwner) == 0x000140, "Wrong size on GzGameplayStatics_LineTraceSkipOwner");
static_assert(offsetof(GzGameplayStatics_LineTraceSkipOwner, Owner) == 0x000000, "Member 'GzGameplayStatics_LineTraceSkipOwner::Owner' has a wrong offset!");
static_assert(offsetof(GzGameplayStatics_LineTraceSkipOwner, bSkipRecursively) == 0x000008, "Member 'GzGameplayStatics_LineTraceSkipOwner::bSkipRecursively' has a wrong offset!");
static_assert(offsetof(GzGameplayStatics_LineTraceSkipOwner, CollisionChannel) == 0x000009, "Member 'GzGameplayStatics_LineTraceSkipOwner::CollisionChannel' has a wrong offset!");
static_assert(offsetof(GzGameplayStatics_LineTraceSkipOwner, Start) == 0x000010, "Member 'GzGameplayStatics_LineTraceSkipOwner::Start' has a wrong offset!");
static_assert(offsetof(GzGameplayStatics_LineTraceSkipOwner, End) == 0x000028, "Member 'GzGameplayStatics_LineTraceSkipOwner::End' has a wrong offset!");
static_assert(offsetof(GzGameplayStatics_LineTraceSkipOwner, bUseComplex) == 0x000040, "Member 'GzGameplayStatics_LineTraceSkipOwner::bUseComplex' has a wrong offset!");
static_assert(offsetof(GzGameplayStatics_LineTraceSkipOwner, ReturnValue) == 0x000048, "Member 'GzGameplayStatics_LineTraceSkipOwner::ReturnValue' has a wrong offset!");

// Function G01.GzGameplayStatics.MarkSplineEdited
// 0x0010 (0x0010 - 0x0000)
struct GzGameplayStatics_MarkSplineEdited final
{
public:
	class USplineComponent*                       Spline;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEdited;                                           // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_32A0[0x7];                                     // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GzGameplayStatics_MarkSplineEdited) == 0x000008, "Wrong alignment on GzGameplayStatics_MarkSplineEdited");
static_assert(sizeof(GzGameplayStatics_MarkSplineEdited) == 0x000010, "Wrong size on GzGameplayStatics_MarkSplineEdited");
static_assert(offsetof(GzGameplayStatics_MarkSplineEdited, Spline) == 0x000000, "Member 'GzGameplayStatics_MarkSplineEdited::Spline' has a wrong offset!");
static_assert(offsetof(GzGameplayStatics_MarkSplineEdited, bEdited) == 0x000008, "Member 'GzGameplayStatics_MarkSplineEdited::bEdited' has a wrong offset!");

// Function G01.GzGameplayStatics.PlaySyncCutscene
// 0x0018 (0x0018 - 0x0000)
struct GzGameplayStatics_PlaySyncCutscene final
{
public:
	const class UObject*                          WorldContextObject;                                // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class AGzSyncCutscene>            CutsceneClass;                                     // 0x0008(0x0008)(Parm, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AGzSyncCutscene*                        ReturnValue;                                       // 0x0010(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzGameplayStatics_PlaySyncCutscene) == 0x000008, "Wrong alignment on GzGameplayStatics_PlaySyncCutscene");
static_assert(sizeof(GzGameplayStatics_PlaySyncCutscene) == 0x000018, "Wrong size on GzGameplayStatics_PlaySyncCutscene");
static_assert(offsetof(GzGameplayStatics_PlaySyncCutscene, WorldContextObject) == 0x000000, "Member 'GzGameplayStatics_PlaySyncCutscene::WorldContextObject' has a wrong offset!");
static_assert(offsetof(GzGameplayStatics_PlaySyncCutscene, CutsceneClass) == 0x000008, "Member 'GzGameplayStatics_PlaySyncCutscene::CutsceneClass' has a wrong offset!");
static_assert(offsetof(GzGameplayStatics_PlaySyncCutscene, ReturnValue) == 0x000010, "Member 'GzGameplayStatics_PlaySyncCutscene::ReturnValue' has a wrong offset!");

// Function G01.GzGameplayStatics.PrintCallstack_FULL
// 0x0001 (0x0001 - 0x0000)
struct GzGameplayStatics_PrintCallstack_FULL final
{
public:
	bool                                          bCollapseVMStack;                                  // 0x0000(0x0001)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzGameplayStatics_PrintCallstack_FULL) == 0x000001, "Wrong alignment on GzGameplayStatics_PrintCallstack_FULL");
static_assert(sizeof(GzGameplayStatics_PrintCallstack_FULL) == 0x000001, "Wrong size on GzGameplayStatics_PrintCallstack_FULL");
static_assert(offsetof(GzGameplayStatics_PrintCallstack_FULL, bCollapseVMStack) == 0x000000, "Member 'GzGameplayStatics_PrintCallstack_FULL::bCollapseVMStack' has a wrong offset!");

// Function G01.GzGameplayStatics.ReportPlayer
// 0x0018 (0x0018 - 0x0000)
struct GzGameplayStatics_ReportPlayer final
{
public:
	class AGzPlayerState*                         PlayerToReport;                                    // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<EGzReportReason>                       Reasons;                                           // 0x0008(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzGameplayStatics_ReportPlayer) == 0x000008, "Wrong alignment on GzGameplayStatics_ReportPlayer");
static_assert(sizeof(GzGameplayStatics_ReportPlayer) == 0x000018, "Wrong size on GzGameplayStatics_ReportPlayer");
static_assert(offsetof(GzGameplayStatics_ReportPlayer, PlayerToReport) == 0x000000, "Member 'GzGameplayStatics_ReportPlayer::PlayerToReport' has a wrong offset!");
static_assert(offsetof(GzGameplayStatics_ReportPlayer, Reasons) == 0x000008, "Member 'GzGameplayStatics_ReportPlayer::Reasons' has a wrong offset!");

// Function G01.GzGameplayStatics.SetCharacterIdAccessActor
// 0x0018 (0x0018 - 0x0000)
struct GzGameplayStatics_SetCharacterIdAccessActor final
{
public:
	struct FGzCharacterIdAccess                   CharacterIdAccess;                                 // 0x0000(0x0010)(Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	class AActor*                                 Actor;                                             // 0x0010(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzGameplayStatics_SetCharacterIdAccessActor) == 0x000008, "Wrong alignment on GzGameplayStatics_SetCharacterIdAccessActor");
static_assert(sizeof(GzGameplayStatics_SetCharacterIdAccessActor) == 0x000018, "Wrong size on GzGameplayStatics_SetCharacterIdAccessActor");
static_assert(offsetof(GzGameplayStatics_SetCharacterIdAccessActor, CharacterIdAccess) == 0x000000, "Member 'GzGameplayStatics_SetCharacterIdAccessActor::CharacterIdAccess' has a wrong offset!");
static_assert(offsetof(GzGameplayStatics_SetCharacterIdAccessActor, Actor) == 0x000010, "Member 'GzGameplayStatics_SetCharacterIdAccessActor::Actor' has a wrong offset!");

// Function G01.GzGameplayStatics.SetNetAddressable
// 0x0008 (0x0008 - 0x0000)
struct GzGameplayStatics_SetNetAddressable final
{
public:
	class UActorComponent*                        Component;                                         // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzGameplayStatics_SetNetAddressable) == 0x000008, "Wrong alignment on GzGameplayStatics_SetNetAddressable");
static_assert(sizeof(GzGameplayStatics_SetNetAddressable) == 0x000008, "Wrong size on GzGameplayStatics_SetNetAddressable");
static_assert(offsetof(GzGameplayStatics_SetNetAddressable, Component) == 0x000000, "Member 'GzGameplayStatics_SetNetAddressable::Component' has a wrong offset!");

// Function G01.GzGameplayStatics.SortActorsArrayByName
// 0x0010 (0x0010 - 0x0000)
struct GzGameplayStatics_SortActorsArrayByName final
{
public:
	TArray<class AActor*>                         Actors;                                            // 0x0000(0x0010)(Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzGameplayStatics_SortActorsArrayByName) == 0x000008, "Wrong alignment on GzGameplayStatics_SortActorsArrayByName");
static_assert(sizeof(GzGameplayStatics_SortActorsArrayByName) == 0x000010, "Wrong size on GzGameplayStatics_SortActorsArrayByName");
static_assert(offsetof(GzGameplayStatics_SortActorsArrayByName, Actors) == 0x000000, "Member 'GzGameplayStatics_SortActorsArrayByName::Actors' has a wrong offset!");

// Function G01.GzGameplayStatics.SpawnAI
// 0x00A0 (0x00A0 - 0x0000)
struct GzGameplayStatics_SpawnAI final
{
public:
	const class UObject*                          WorldContextObject;                                // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 BotName;                                           // 0x0008(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_32A1[0x8];                                     // 0x0018(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             Transform;                                         // 0x0020(0x0060)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseTransform;                                     // 0x0080(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_32A2[0x3];                                     // 0x0081(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         TeamID;                                            // 0x0084(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class AGzAIController>            ControllerClass;                                   // 0x0088(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AGzAIController*                        ReturnValue;                                       // 0x0090(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_32A3[0x8];                                     // 0x0098(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GzGameplayStatics_SpawnAI) == 0x000010, "Wrong alignment on GzGameplayStatics_SpawnAI");
static_assert(sizeof(GzGameplayStatics_SpawnAI) == 0x0000A0, "Wrong size on GzGameplayStatics_SpawnAI");
static_assert(offsetof(GzGameplayStatics_SpawnAI, WorldContextObject) == 0x000000, "Member 'GzGameplayStatics_SpawnAI::WorldContextObject' has a wrong offset!");
static_assert(offsetof(GzGameplayStatics_SpawnAI, BotName) == 0x000008, "Member 'GzGameplayStatics_SpawnAI::BotName' has a wrong offset!");
static_assert(offsetof(GzGameplayStatics_SpawnAI, Transform) == 0x000020, "Member 'GzGameplayStatics_SpawnAI::Transform' has a wrong offset!");
static_assert(offsetof(GzGameplayStatics_SpawnAI, bUseTransform) == 0x000080, "Member 'GzGameplayStatics_SpawnAI::bUseTransform' has a wrong offset!");
static_assert(offsetof(GzGameplayStatics_SpawnAI, TeamID) == 0x000084, "Member 'GzGameplayStatics_SpawnAI::TeamID' has a wrong offset!");
static_assert(offsetof(GzGameplayStatics_SpawnAI, ControllerClass) == 0x000088, "Member 'GzGameplayStatics_SpawnAI::ControllerClass' has a wrong offset!");
static_assert(offsetof(GzGameplayStatics_SpawnAI, ReturnValue) == 0x000090, "Member 'GzGameplayStatics_SpawnAI::ReturnValue' has a wrong offset!");

// Function G01.GzGameplayStatics.SpawnMirrorBreaker
// 0x0090 (0x0090 - 0x0000)
struct GzGameplayStatics_SpawnMirrorBreaker final
{
public:
	const class UObject*                          WorldContextObject;                                // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_32A4[0x8];                                     // 0x0008(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             Transform;                                         // 0x0010(0x0060)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	const class AGzPlayerCharacter*               InPlayerCharacter;                                 // 0x0070(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           NPCTypeTag;                                        // 0x0078(0x0008)(ConstParm, Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AGzAIController*                        ReturnValue;                                       // 0x0080(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_32A5[0x8];                                     // 0x0088(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GzGameplayStatics_SpawnMirrorBreaker) == 0x000010, "Wrong alignment on GzGameplayStatics_SpawnMirrorBreaker");
static_assert(sizeof(GzGameplayStatics_SpawnMirrorBreaker) == 0x000090, "Wrong size on GzGameplayStatics_SpawnMirrorBreaker");
static_assert(offsetof(GzGameplayStatics_SpawnMirrorBreaker, WorldContextObject) == 0x000000, "Member 'GzGameplayStatics_SpawnMirrorBreaker::WorldContextObject' has a wrong offset!");
static_assert(offsetof(GzGameplayStatics_SpawnMirrorBreaker, Transform) == 0x000010, "Member 'GzGameplayStatics_SpawnMirrorBreaker::Transform' has a wrong offset!");
static_assert(offsetof(GzGameplayStatics_SpawnMirrorBreaker, InPlayerCharacter) == 0x000070, "Member 'GzGameplayStatics_SpawnMirrorBreaker::InPlayerCharacter' has a wrong offset!");
static_assert(offsetof(GzGameplayStatics_SpawnMirrorBreaker, NPCTypeTag) == 0x000078, "Member 'GzGameplayStatics_SpawnMirrorBreaker::NPCTypeTag' has a wrong offset!");
static_assert(offsetof(GzGameplayStatics_SpawnMirrorBreaker, ReturnValue) == 0x000080, "Member 'GzGameplayStatics_SpawnMirrorBreaker::ReturnValue' has a wrong offset!");

// Function G01.GzGameplayStatics.SpawnNPC
// 0x00B0 (0x00B0 - 0x0000)
struct GzGameplayStatics_SpawnNPC final
{
public:
	const class UObject*                          WorldContextObject;                                // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 NPCName;                                           // 0x0008(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_32A6[0x8];                                     // 0x0018(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             Transform;                                         // 0x0020(0x0060)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         TeamID;                                            // 0x0080(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_32A7[0x4];                                     // 0x0084(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class AGzAIController>            ControllerClass;                                   // 0x0088(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class APawn>                      NonPlayerCharacterClass;                           // 0x0090(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ENPCType                                      Type;                                              // 0x0098(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_32A8[0x7];                                     // 0x0099(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UBehaviorTree*                          BehaviorTree;                                      // 0x00A0(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AGzAIController*                        ReturnValue;                                       // 0x00A8(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzGameplayStatics_SpawnNPC) == 0x000010, "Wrong alignment on GzGameplayStatics_SpawnNPC");
static_assert(sizeof(GzGameplayStatics_SpawnNPC) == 0x0000B0, "Wrong size on GzGameplayStatics_SpawnNPC");
static_assert(offsetof(GzGameplayStatics_SpawnNPC, WorldContextObject) == 0x000000, "Member 'GzGameplayStatics_SpawnNPC::WorldContextObject' has a wrong offset!");
static_assert(offsetof(GzGameplayStatics_SpawnNPC, NPCName) == 0x000008, "Member 'GzGameplayStatics_SpawnNPC::NPCName' has a wrong offset!");
static_assert(offsetof(GzGameplayStatics_SpawnNPC, Transform) == 0x000020, "Member 'GzGameplayStatics_SpawnNPC::Transform' has a wrong offset!");
static_assert(offsetof(GzGameplayStatics_SpawnNPC, TeamID) == 0x000080, "Member 'GzGameplayStatics_SpawnNPC::TeamID' has a wrong offset!");
static_assert(offsetof(GzGameplayStatics_SpawnNPC, ControllerClass) == 0x000088, "Member 'GzGameplayStatics_SpawnNPC::ControllerClass' has a wrong offset!");
static_assert(offsetof(GzGameplayStatics_SpawnNPC, NonPlayerCharacterClass) == 0x000090, "Member 'GzGameplayStatics_SpawnNPC::NonPlayerCharacterClass' has a wrong offset!");
static_assert(offsetof(GzGameplayStatics_SpawnNPC, Type) == 0x000098, "Member 'GzGameplayStatics_SpawnNPC::Type' has a wrong offset!");
static_assert(offsetof(GzGameplayStatics_SpawnNPC, BehaviorTree) == 0x0000A0, "Member 'GzGameplayStatics_SpawnNPC::BehaviorTree' has a wrong offset!");
static_assert(offsetof(GzGameplayStatics_SpawnNPC, ReturnValue) == 0x0000A8, "Member 'GzGameplayStatics_SpawnNPC::ReturnValue' has a wrong offset!");

// Function G01.GzGameplayStatics.SpawnNPCByTag
// 0x0090 (0x0090 - 0x0000)
struct GzGameplayStatics_SpawnNPCByTag final
{
public:
	const class UObject*                          WorldContextObject;                                // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_32A9[0x8];                                     // 0x0008(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             Transform;                                         // 0x0010(0x0060)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         TeamID;                                            // 0x0070(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           NPCTypeTag;                                        // 0x0074(0x0008)(ConstParm, Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_32AA[0x4];                                     // 0x007C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class AGzAIController*                        ReturnValue;                                       // 0x0080(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_32AB[0x8];                                     // 0x0088(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GzGameplayStatics_SpawnNPCByTag) == 0x000010, "Wrong alignment on GzGameplayStatics_SpawnNPCByTag");
static_assert(sizeof(GzGameplayStatics_SpawnNPCByTag) == 0x000090, "Wrong size on GzGameplayStatics_SpawnNPCByTag");
static_assert(offsetof(GzGameplayStatics_SpawnNPCByTag, WorldContextObject) == 0x000000, "Member 'GzGameplayStatics_SpawnNPCByTag::WorldContextObject' has a wrong offset!");
static_assert(offsetof(GzGameplayStatics_SpawnNPCByTag, Transform) == 0x000010, "Member 'GzGameplayStatics_SpawnNPCByTag::Transform' has a wrong offset!");
static_assert(offsetof(GzGameplayStatics_SpawnNPCByTag, TeamID) == 0x000070, "Member 'GzGameplayStatics_SpawnNPCByTag::TeamID' has a wrong offset!");
static_assert(offsetof(GzGameplayStatics_SpawnNPCByTag, NPCTypeTag) == 0x000074, "Member 'GzGameplayStatics_SpawnNPCByTag::NPCTypeTag' has a wrong offset!");
static_assert(offsetof(GzGameplayStatics_SpawnNPCByTag, ReturnValue) == 0x000080, "Member 'GzGameplayStatics_SpawnNPCByTag::ReturnValue' has a wrong offset!");

// Function G01.GzGameplayStatics.SphereSweepSkipOwner
// 0x0140 (0x0140 - 0x0000)
struct GzGameplayStatics_SphereSweepSkipOwner final
{
public:
	const class AActor*                           Owner;                                             // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSkipRecursively;                                  // 0x0008(0x0001)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECollisionChannel                             CollisionChannel;                                  // 0x0009(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_32AC[0x6];                                     // 0x000A(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                Start;                                             // 0x0010(0x0018)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                End;                                               // 0x0028(0x0018)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SphereRadius;                                      // 0x0040(0x0004)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_32AD[0x4];                                     // 0x0044(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FHitResult                             ReturnValue;                                       // 0x0048(0x00F8)(Parm, OutParm, ReturnParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzGameplayStatics_SphereSweepSkipOwner) == 0x000008, "Wrong alignment on GzGameplayStatics_SphereSweepSkipOwner");
static_assert(sizeof(GzGameplayStatics_SphereSweepSkipOwner) == 0x000140, "Wrong size on GzGameplayStatics_SphereSweepSkipOwner");
static_assert(offsetof(GzGameplayStatics_SphereSweepSkipOwner, Owner) == 0x000000, "Member 'GzGameplayStatics_SphereSweepSkipOwner::Owner' has a wrong offset!");
static_assert(offsetof(GzGameplayStatics_SphereSweepSkipOwner, bSkipRecursively) == 0x000008, "Member 'GzGameplayStatics_SphereSweepSkipOwner::bSkipRecursively' has a wrong offset!");
static_assert(offsetof(GzGameplayStatics_SphereSweepSkipOwner, CollisionChannel) == 0x000009, "Member 'GzGameplayStatics_SphereSweepSkipOwner::CollisionChannel' has a wrong offset!");
static_assert(offsetof(GzGameplayStatics_SphereSweepSkipOwner, Start) == 0x000010, "Member 'GzGameplayStatics_SphereSweepSkipOwner::Start' has a wrong offset!");
static_assert(offsetof(GzGameplayStatics_SphereSweepSkipOwner, End) == 0x000028, "Member 'GzGameplayStatics_SphereSweepSkipOwner::End' has a wrong offset!");
static_assert(offsetof(GzGameplayStatics_SphereSweepSkipOwner, SphereRadius) == 0x000040, "Member 'GzGameplayStatics_SphereSweepSkipOwner::SphereRadius' has a wrong offset!");
static_assert(offsetof(GzGameplayStatics_SphereSweepSkipOwner, ReturnValue) == 0x000048, "Member 'GzGameplayStatics_SphereSweepSkipOwner::ReturnValue' has a wrong offset!");

// Function G01.GzGameplayStatics.TriggerLocalGameplayTagEvent
// 0x0010 (0x0010 - 0x0000)
struct GzGameplayStatics_TriggerLocalGameplayTagEvent final
{
public:
	class AActor*                                 TargetActor;                                       // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           Tag;                                               // 0x0008(0x0008)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzGameplayStatics_TriggerLocalGameplayTagEvent) == 0x000008, "Wrong alignment on GzGameplayStatics_TriggerLocalGameplayTagEvent");
static_assert(sizeof(GzGameplayStatics_TriggerLocalGameplayTagEvent) == 0x000010, "Wrong size on GzGameplayStatics_TriggerLocalGameplayTagEvent");
static_assert(offsetof(GzGameplayStatics_TriggerLocalGameplayTagEvent, TargetActor) == 0x000000, "Member 'GzGameplayStatics_TriggerLocalGameplayTagEvent::TargetActor' has a wrong offset!");
static_assert(offsetof(GzGameplayStatics_TriggerLocalGameplayTagEvent, Tag) == 0x000008, "Member 'GzGameplayStatics_TriggerLocalGameplayTagEvent::Tag' has a wrong offset!");

// Function G01.GzGameplayStatics.TryGetWorldZoneSetup
// 0x0040 (0x0040 - 0x0000)
struct GzGameplayStatics_TryGetWorldZoneSetup final
{
public:
	const class UObject*                          WorldContextObject;                                // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGzWorldZoneSetup                      OutSetup;                                          // 0x0008(0x0030)(Parm, OutParm, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0038(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_32AE[0x7];                                     // 0x0039(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GzGameplayStatics_TryGetWorldZoneSetup) == 0x000008, "Wrong alignment on GzGameplayStatics_TryGetWorldZoneSetup");
static_assert(sizeof(GzGameplayStatics_TryGetWorldZoneSetup) == 0x000040, "Wrong size on GzGameplayStatics_TryGetWorldZoneSetup");
static_assert(offsetof(GzGameplayStatics_TryGetWorldZoneSetup, WorldContextObject) == 0x000000, "Member 'GzGameplayStatics_TryGetWorldZoneSetup::WorldContextObject' has a wrong offset!");
static_assert(offsetof(GzGameplayStatics_TryGetWorldZoneSetup, OutSetup) == 0x000008, "Member 'GzGameplayStatics_TryGetWorldZoneSetup::OutSetup' has a wrong offset!");
static_assert(offsetof(GzGameplayStatics_TryGetWorldZoneSetup, ReturnValue) == 0x000038, "Member 'GzGameplayStatics_TryGetWorldZoneSetup::ReturnValue' has a wrong offset!");

// Function G01.GzGameplayEffectHandler.OnEffectAdded
// 0x02A8 (0x02A8 - 0x0000)
struct GzGameplayEffectHandler_OnEffectAdded final
{
public:
	class UGzAbilitySystemComponent*              Target;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayEffectSpec                    Spec;                                              // 0x0008(0x02A0)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzGameplayEffectHandler_OnEffectAdded) == 0x000008, "Wrong alignment on GzGameplayEffectHandler_OnEffectAdded");
static_assert(sizeof(GzGameplayEffectHandler_OnEffectAdded) == 0x0002A8, "Wrong size on GzGameplayEffectHandler_OnEffectAdded");
static_assert(offsetof(GzGameplayEffectHandler_OnEffectAdded, Target) == 0x000000, "Member 'GzGameplayEffectHandler_OnEffectAdded::Target' has a wrong offset!");
static_assert(offsetof(GzGameplayEffectHandler_OnEffectAdded, Spec) == 0x000008, "Member 'GzGameplayEffectHandler_OnEffectAdded::Spec' has a wrong offset!");

// Function G01.GzGameplayEffectHandler.OnEffectRemoved
// 0x02A8 (0x02A8 - 0x0000)
struct GzGameplayEffectHandler_OnEffectRemoved final
{
public:
	class UGzAbilitySystemComponent*              Target;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayEffectSpec                    Spec;                                              // 0x0008(0x02A0)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzGameplayEffectHandler_OnEffectRemoved) == 0x000008, "Wrong alignment on GzGameplayEffectHandler_OnEffectRemoved");
static_assert(sizeof(GzGameplayEffectHandler_OnEffectRemoved) == 0x0002A8, "Wrong size on GzGameplayEffectHandler_OnEffectRemoved");
static_assert(offsetof(GzGameplayEffectHandler_OnEffectRemoved, Target) == 0x000000, "Member 'GzGameplayEffectHandler_OnEffectRemoved::Target' has a wrong offset!");
static_assert(offsetof(GzGameplayEffectHandler_OnEffectRemoved, Spec) == 0x000008, "Member 'GzGameplayEffectHandler_OnEffectRemoved::Spec' has a wrong offset!");

// Function G01.GzGameplayTagHandlingComponent.OnGameplayEffectAddedToSelf
// 0x02B0 (0x02B0 - 0x0000)
struct GzGameplayTagHandlingComponent_OnGameplayEffectAddedToSelf final
{
public:
	class UAbilitySystemComponent*                Target;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayEffectSpec                    Spec;                                              // 0x0008(0x02A0)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	struct FActiveGameplayEffectHandle            Handle;                                            // 0x02A8(0x0008)(Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzGameplayTagHandlingComponent_OnGameplayEffectAddedToSelf) == 0x000008, "Wrong alignment on GzGameplayTagHandlingComponent_OnGameplayEffectAddedToSelf");
static_assert(sizeof(GzGameplayTagHandlingComponent_OnGameplayEffectAddedToSelf) == 0x0002B0, "Wrong size on GzGameplayTagHandlingComponent_OnGameplayEffectAddedToSelf");
static_assert(offsetof(GzGameplayTagHandlingComponent_OnGameplayEffectAddedToSelf, Target) == 0x000000, "Member 'GzGameplayTagHandlingComponent_OnGameplayEffectAddedToSelf::Target' has a wrong offset!");
static_assert(offsetof(GzGameplayTagHandlingComponent_OnGameplayEffectAddedToSelf, Spec) == 0x000008, "Member 'GzGameplayTagHandlingComponent_OnGameplayEffectAddedToSelf::Spec' has a wrong offset!");
static_assert(offsetof(GzGameplayTagHandlingComponent_OnGameplayEffectAddedToSelf, Handle) == 0x0002A8, "Member 'GzGameplayTagHandlingComponent_OnGameplayEffectAddedToSelf::Handle' has a wrong offset!");

// Function G01.GzGameplayTagHandlingComponent.OnGameplayEffectRemoved
// 0x0368 (0x0368 - 0x0000)
struct GzGameplayTagHandlingComponent_OnGameplayEffectRemoved final
{
public:
	struct FActiveGameplayEffect                  Effect;                                            // 0x0000(0x0368)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzGameplayTagHandlingComponent_OnGameplayEffectRemoved) == 0x000008, "Wrong alignment on GzGameplayTagHandlingComponent_OnGameplayEffectRemoved");
static_assert(sizeof(GzGameplayTagHandlingComponent_OnGameplayEffectRemoved) == 0x000368, "Wrong size on GzGameplayTagHandlingComponent_OnGameplayEffectRemoved");
static_assert(offsetof(GzGameplayTagHandlingComponent_OnGameplayEffectRemoved, Effect) == 0x000000, "Member 'GzGameplayTagHandlingComponent_OnGameplayEffectRemoved::Effect' has a wrong offset!");

// Function G01.GzMapDeploymentTrackExtension.OnViewTargetChanged
// 0x0008 (0x0008 - 0x0000)
struct GzMapDeploymentTrackExtension_OnViewTargetChanged final
{
public:
	class APawn*                                  Pawn;                                              // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzMapDeploymentTrackExtension_OnViewTargetChanged) == 0x000008, "Wrong alignment on GzMapDeploymentTrackExtension_OnViewTargetChanged");
static_assert(sizeof(GzMapDeploymentTrackExtension_OnViewTargetChanged) == 0x000008, "Wrong size on GzMapDeploymentTrackExtension_OnViewTargetChanged");
static_assert(offsetof(GzMapDeploymentTrackExtension_OnViewTargetChanged, Pawn) == 0x000000, "Member 'GzMapDeploymentTrackExtension_OnViewTargetChanged::Pawn' has a wrong offset!");

// Function G01.GzGameSettingDiscreteDataSourceBP.GetValue
// 0x0010 (0x0010 - 0x0000)
struct GzGameSettingDiscreteDataSourceBP_GetValue final
{
public:
	class FString                                 ReturnValue;                                       // 0x0000(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzGameSettingDiscreteDataSourceBP_GetValue) == 0x000008, "Wrong alignment on GzGameSettingDiscreteDataSourceBP_GetValue");
static_assert(sizeof(GzGameSettingDiscreteDataSourceBP_GetValue) == 0x000010, "Wrong size on GzGameSettingDiscreteDataSourceBP_GetValue");
static_assert(offsetof(GzGameSettingDiscreteDataSourceBP_GetValue, ReturnValue) == 0x000000, "Member 'GzGameSettingDiscreteDataSourceBP_GetValue::ReturnValue' has a wrong offset!");

// Function G01.GzGameSettingDiscreteDataSourceBP.SetValue
// 0x0010 (0x0010 - 0x0000)
struct GzGameSettingDiscreteDataSourceBP_SetValue final
{
public:
	class FString                                 NewValue;                                          // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzGameSettingDiscreteDataSourceBP_SetValue) == 0x000008, "Wrong alignment on GzGameSettingDiscreteDataSourceBP_SetValue");
static_assert(sizeof(GzGameSettingDiscreteDataSourceBP_SetValue) == 0x000010, "Wrong size on GzGameSettingDiscreteDataSourceBP_SetValue");
static_assert(offsetof(GzGameSettingDiscreteDataSourceBP_SetValue, NewValue) == 0x000000, "Member 'GzGameSettingDiscreteDataSourceBP_SetValue::NewValue' has a wrong offset!");

// Function G01.GzGameSettingDiscreteDataSourceBP.GetUserSettings
// 0x0008 (0x0008 - 0x0000)
struct GzGameSettingDiscreteDataSourceBP_GetUserSettings final
{
public:
	class UGzGameUserSettings*                    ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzGameSettingDiscreteDataSourceBP_GetUserSettings) == 0x000008, "Wrong alignment on GzGameSettingDiscreteDataSourceBP_GetUserSettings");
static_assert(sizeof(GzGameSettingDiscreteDataSourceBP_GetUserSettings) == 0x000008, "Wrong size on GzGameSettingDiscreteDataSourceBP_GetUserSettings");
static_assert(offsetof(GzGameSettingDiscreteDataSourceBP_GetUserSettings, ReturnValue) == 0x000000, "Member 'GzGameSettingDiscreteDataSourceBP_GetUserSettings::ReturnValue' has a wrong offset!");

// Function G01.GzHitReactionInterface.CalculateHitReactionPowerValue
// 0x0008 (0x0008 - 0x0000)
struct GzHitReactionInterface_CalculateHitReactionPowerValue final
{
public:
	float                                         InPowerValue;                                      // 0x0000(0x0004)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ReturnValue;                                       // 0x0004(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzHitReactionInterface_CalculateHitReactionPowerValue) == 0x000004, "Wrong alignment on GzHitReactionInterface_CalculateHitReactionPowerValue");
static_assert(sizeof(GzHitReactionInterface_CalculateHitReactionPowerValue) == 0x000008, "Wrong size on GzHitReactionInterface_CalculateHitReactionPowerValue");
static_assert(offsetof(GzHitReactionInterface_CalculateHitReactionPowerValue, InPowerValue) == 0x000000, "Member 'GzHitReactionInterface_CalculateHitReactionPowerValue::InPowerValue' has a wrong offset!");
static_assert(offsetof(GzHitReactionInterface_CalculateHitReactionPowerValue, ReturnValue) == 0x000004, "Member 'GzHitReactionInterface_CalculateHitReactionPowerValue::ReturnValue' has a wrong offset!");

// Function G01.GzGameSettingScalarDataSourceBP.GetValue
// 0x0008 (0x0008 - 0x0000)
struct GzGameSettingScalarDataSourceBP_GetValue final
{
public:
	double                                        ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzGameSettingScalarDataSourceBP_GetValue) == 0x000008, "Wrong alignment on GzGameSettingScalarDataSourceBP_GetValue");
static_assert(sizeof(GzGameSettingScalarDataSourceBP_GetValue) == 0x000008, "Wrong size on GzGameSettingScalarDataSourceBP_GetValue");
static_assert(offsetof(GzGameSettingScalarDataSourceBP_GetValue, ReturnValue) == 0x000000, "Member 'GzGameSettingScalarDataSourceBP_GetValue::ReturnValue' has a wrong offset!");

// Function G01.GzGameSettingScalarDataSourceBP.SetValue
// 0x0008 (0x0008 - 0x0000)
struct GzGameSettingScalarDataSourceBP_SetValue final
{
public:
	double                                        NewValue;                                          // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzGameSettingScalarDataSourceBP_SetValue) == 0x000008, "Wrong alignment on GzGameSettingScalarDataSourceBP_SetValue");
static_assert(sizeof(GzGameSettingScalarDataSourceBP_SetValue) == 0x000008, "Wrong size on GzGameSettingScalarDataSourceBP_SetValue");
static_assert(offsetof(GzGameSettingScalarDataSourceBP_SetValue, NewValue) == 0x000000, "Member 'GzGameSettingScalarDataSourceBP_SetValue::NewValue' has a wrong offset!");

// Function G01.GzGameSettingScalarDataSourceBP.GetUserSettings
// 0x0008 (0x0008 - 0x0000)
struct GzGameSettingScalarDataSourceBP_GetUserSettings final
{
public:
	class UGzGameUserSettings*                    ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzGameSettingScalarDataSourceBP_GetUserSettings) == 0x000008, "Wrong alignment on GzGameSettingScalarDataSourceBP_GetUserSettings");
static_assert(sizeof(GzGameSettingScalarDataSourceBP_GetUserSettings) == 0x000008, "Wrong size on GzGameSettingScalarDataSourceBP_GetUserSettings");
static_assert(offsetof(GzGameSettingScalarDataSourceBP_GetUserSettings, ReturnValue) == 0x000000, "Member 'GzGameSettingScalarDataSourceBP_GetUserSettings::ReturnValue' has a wrong offset!");

// Function G01.GzPickableBase.OnInteract
// 0x0010 (0x0010 - 0x0000)
struct GzPickableBase_OnInteract final
{
public:
	class AActor*                                 InteractedBy;                                      // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	const class UGzInteractableComponent*         Interactable;                                      // 0x0008(0x0008)(ConstParm, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzPickableBase_OnInteract) == 0x000008, "Wrong alignment on GzPickableBase_OnInteract");
static_assert(sizeof(GzPickableBase_OnInteract) == 0x000010, "Wrong size on GzPickableBase_OnInteract");
static_assert(offsetof(GzPickableBase_OnInteract, InteractedBy) == 0x000000, "Member 'GzPickableBase_OnInteract::InteractedBy' has a wrong offset!");
static_assert(offsetof(GzPickableBase_OnInteract, Interactable) == 0x000008, "Member 'GzPickableBase_OnInteract::Interactable' has a wrong offset!");

// Function G01.GzPickableBase.GetEffectsComponent
// 0x0008 (0x0008 - 0x0000)
struct GzPickableBase_GetEffectsComponent final
{
public:
	class UGzPickableEffectsComponent*            ReturnValue;                                       // 0x0000(0x0008)(ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzPickableBase_GetEffectsComponent) == 0x000008, "Wrong alignment on GzPickableBase_GetEffectsComponent");
static_assert(sizeof(GzPickableBase_GetEffectsComponent) == 0x000008, "Wrong size on GzPickableBase_GetEffectsComponent");
static_assert(offsetof(GzPickableBase_GetEffectsComponent, ReturnValue) == 0x000000, "Member 'GzPickableBase_GetEffectsComponent::ReturnValue' has a wrong offset!");

// Function G01.GzPickableBase.GetInteractableComponent
// 0x0008 (0x0008 - 0x0000)
struct GzPickableBase_GetInteractableComponent final
{
public:
	class UGzInteractableComponent*               ReturnValue;                                       // 0x0000(0x0008)(ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzPickableBase_GetInteractableComponent) == 0x000008, "Wrong alignment on GzPickableBase_GetInteractableComponent");
static_assert(sizeof(GzPickableBase_GetInteractableComponent) == 0x000008, "Wrong size on GzPickableBase_GetInteractableComponent");
static_assert(offsetof(GzPickableBase_GetInteractableComponent, ReturnValue) == 0x000000, "Member 'GzPickableBase_GetInteractableComponent::ReturnValue' has a wrong offset!");

// Function G01.GzPickableBase.GetInventoryItem
// 0x0010 (0x0010 - 0x0000)
struct GzPickableBase_GetInventoryItem final
{
public:
	struct FGzInvItem                             ReturnValue;                                       // 0x0000(0x0010)(Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzPickableBase_GetInventoryItem) == 0x000008, "Wrong alignment on GzPickableBase_GetInventoryItem");
static_assert(sizeof(GzPickableBase_GetInventoryItem) == 0x000010, "Wrong size on GzPickableBase_GetInventoryItem");
static_assert(offsetof(GzPickableBase_GetInventoryItem, ReturnValue) == 0x000000, "Member 'GzPickableBase_GetInventoryItem::ReturnValue' has a wrong offset!");

// Function G01.GzPickableBase.GetItemAttributeValue
// 0x0018 (0x0018 - 0x0000)
struct GzPickableBase_GetItemAttributeValue final
{
public:
	struct FGameplayTag                           Tag;                                               // 0x0000(0x0008)(ConstParm, Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          OutSuccessful;                                     // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_32BD[0x3];                                     // 0x0009(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGzItemAttribute                       ReturnValue;                                       // 0x000C(0x000C)(Parm, OutParm, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzPickableBase_GetItemAttributeValue) == 0x000004, "Wrong alignment on GzPickableBase_GetItemAttributeValue");
static_assert(sizeof(GzPickableBase_GetItemAttributeValue) == 0x000018, "Wrong size on GzPickableBase_GetItemAttributeValue");
static_assert(offsetof(GzPickableBase_GetItemAttributeValue, Tag) == 0x000000, "Member 'GzPickableBase_GetItemAttributeValue::Tag' has a wrong offset!");
static_assert(offsetof(GzPickableBase_GetItemAttributeValue, OutSuccessful) == 0x000008, "Member 'GzPickableBase_GetItemAttributeValue::OutSuccessful' has a wrong offset!");
static_assert(offsetof(GzPickableBase_GetItemAttributeValue, ReturnValue) == 0x00000C, "Member 'GzPickableBase_GetItemAttributeValue::ReturnValue' has a wrong offset!");

// Function G01.GzPickableBase.GetItemAttributeValueMax
// 0x0018 (0x0018 - 0x0000)
struct GzPickableBase_GetItemAttributeValueMax final
{
public:
	struct FGameplayTag                           Tag;                                               // 0x0000(0x0008)(ConstParm, Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          OutSuccessful;                                     // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_32BE[0x3];                                     // 0x0009(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGzItemAttribute                       ReturnValue;                                       // 0x000C(0x000C)(Parm, OutParm, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzPickableBase_GetItemAttributeValueMax) == 0x000004, "Wrong alignment on GzPickableBase_GetItemAttributeValueMax");
static_assert(sizeof(GzPickableBase_GetItemAttributeValueMax) == 0x000018, "Wrong size on GzPickableBase_GetItemAttributeValueMax");
static_assert(offsetof(GzPickableBase_GetItemAttributeValueMax, Tag) == 0x000000, "Member 'GzPickableBase_GetItemAttributeValueMax::Tag' has a wrong offset!");
static_assert(offsetof(GzPickableBase_GetItemAttributeValueMax, OutSuccessful) == 0x000008, "Member 'GzPickableBase_GetItemAttributeValueMax::OutSuccessful' has a wrong offset!");
static_assert(offsetof(GzPickableBase_GetItemAttributeValueMax, ReturnValue) == 0x00000C, "Member 'GzPickableBase_GetItemAttributeValueMax::ReturnValue' has a wrong offset!");

// Function G01.GzPickableBase.GetItemData
// 0x0008 (0x0008 - 0x0000)
struct GzPickableBase_GetItemData final
{
public:
	class UGzItemData*                            ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzPickableBase_GetItemData) == 0x000008, "Wrong alignment on GzPickableBase_GetItemData");
static_assert(sizeof(GzPickableBase_GetItemData) == 0x000008, "Wrong size on GzPickableBase_GetItemData");
static_assert(offsetof(GzPickableBase_GetItemData, ReturnValue) == 0x000000, "Member 'GzPickableBase_GetItemData::ReturnValue' has a wrong offset!");

// Function G01.GzPickableBase.GetMeshComponent
// 0x0008 (0x0008 - 0x0000)
struct GzPickableBase_GetMeshComponent final
{
public:
	class UMeshComponent*                         ReturnValue;                                       // 0x0000(0x0008)(ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzPickableBase_GetMeshComponent) == 0x000008, "Wrong alignment on GzPickableBase_GetMeshComponent");
static_assert(sizeof(GzPickableBase_GetMeshComponent) == 0x000008, "Wrong size on GzPickableBase_GetMeshComponent");
static_assert(offsetof(GzPickableBase_GetMeshComponent, ReturnValue) == 0x000000, "Member 'GzPickableBase_GetMeshComponent::ReturnValue' has a wrong offset!");

// Function G01.GzGameStatTemplate.GetStatDisplayName
// 0x0010 (0x0010 - 0x0000)
struct GzGameStatTemplate_GetStatDisplayName final
{
public:
	class FText                                   ReturnValue;                                       // 0x0000(0x0010)(Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzGameStatTemplate_GetStatDisplayName) == 0x000008, "Wrong alignment on GzGameStatTemplate_GetStatDisplayName");
static_assert(sizeof(GzGameStatTemplate_GetStatDisplayName) == 0x000010, "Wrong size on GzGameStatTemplate_GetStatDisplayName");
static_assert(offsetof(GzGameStatTemplate_GetStatDisplayName, ReturnValue) == 0x000000, "Member 'GzGameStatTemplate_GetStatDisplayName::ReturnValue' has a wrong offset!");

// Function G01.GzGA_Tether.SpawnTetherLink
// 0x0001 (0x0001 - 0x0000)
struct GzGA_Tether_SpawnTetherLink final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzGA_Tether_SpawnTetherLink) == 0x000001, "Wrong alignment on GzGA_Tether_SpawnTetherLink");
static_assert(sizeof(GzGA_Tether_SpawnTetherLink) == 0x000001, "Wrong size on GzGA_Tether_SpawnTetherLink");
static_assert(offsetof(GzGA_Tether_SpawnTetherLink, ReturnValue) == 0x000000, "Member 'GzGA_Tether_SpawnTetherLink::ReturnValue' has a wrong offset!");

// Function G01.GzGameUserSettings.ApplyAndSaveSettings
// 0x0001 (0x0001 - 0x0000)
struct GzGameUserSettings_ApplyAndSaveSettings final
{
public:
	bool                                          bCheckForConsoleOverrides;                         // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzGameUserSettings_ApplyAndSaveSettings) == 0x000001, "Wrong alignment on GzGameUserSettings_ApplyAndSaveSettings");
static_assert(sizeof(GzGameUserSettings_ApplyAndSaveSettings) == 0x000001, "Wrong size on GzGameUserSettings_ApplyAndSaveSettings");
static_assert(offsetof(GzGameUserSettings_ApplyAndSaveSettings, bCheckForConsoleOverrides) == 0x000000, "Member 'GzGameUserSettings_ApplyAndSaveSettings::bCheckForConsoleOverrides' has a wrong offset!");

// Function G01.GzGameUserSettings.GetAudioPresetName
// 0x0010 (0x0010 - 0x0000)
struct GzGameUserSettings_GetAudioPresetName final
{
public:
	class FString                                 ReturnValue;                                       // 0x0000(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzGameUserSettings_GetAudioPresetName) == 0x000008, "Wrong alignment on GzGameUserSettings_GetAudioPresetName");
static_assert(sizeof(GzGameUserSettings_GetAudioPresetName) == 0x000010, "Wrong size on GzGameUserSettings_GetAudioPresetName");
static_assert(offsetof(GzGameUserSettings_GetAudioPresetName, ReturnValue) == 0x000000, "Member 'GzGameUserSettings_GetAudioPresetName::ReturnValue' has a wrong offset!");

// Function G01.GzGameUserSettings.GetPersonalAssistantVoiceType
// 0x0010 (0x0010 - 0x0000)
struct GzGameUserSettings_GetPersonalAssistantVoiceType final
{
public:
	class FString                                 ReturnValue;                                       // 0x0000(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzGameUserSettings_GetPersonalAssistantVoiceType) == 0x000008, "Wrong alignment on GzGameUserSettings_GetPersonalAssistantVoiceType");
static_assert(sizeof(GzGameUserSettings_GetPersonalAssistantVoiceType) == 0x000010, "Wrong size on GzGameUserSettings_GetPersonalAssistantVoiceType");
static_assert(offsetof(GzGameUserSettings_GetPersonalAssistantVoiceType, ReturnValue) == 0x000000, "Member 'GzGameUserSettings_GetPersonalAssistantVoiceType::ReturnValue' has a wrong offset!");

// Function G01.GzGameUserSettings.SetAcesGamutCompression
// 0x0004 (0x0004 - 0x0000)
struct GzGameUserSettings_SetAcesGamutCompression final
{
public:
	float                                         InGamutCompression;                                // 0x0000(0x0004)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzGameUserSettings_SetAcesGamutCompression) == 0x000004, "Wrong alignment on GzGameUserSettings_SetAcesGamutCompression");
static_assert(sizeof(GzGameUserSettings_SetAcesGamutCompression) == 0x000004, "Wrong size on GzGameUserSettings_SetAcesGamutCompression");
static_assert(offsetof(GzGameUserSettings_SetAcesGamutCompression, InGamutCompression) == 0x000000, "Member 'GzGameUserSettings_SetAcesGamutCompression::InGamutCompression' has a wrong offset!");

// Function G01.GzGameUserSettings.SetAcesSceneColorMultiplier
// 0x0004 (0x0004 - 0x0000)
struct GzGameUserSettings_SetAcesSceneColorMultiplier final
{
public:
	float                                         InAcesSceneColorMultiplier;                        // 0x0000(0x0004)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzGameUserSettings_SetAcesSceneColorMultiplier) == 0x000004, "Wrong alignment on GzGameUserSettings_SetAcesSceneColorMultiplier");
static_assert(sizeof(GzGameUserSettings_SetAcesSceneColorMultiplier) == 0x000004, "Wrong size on GzGameUserSettings_SetAcesSceneColorMultiplier");
static_assert(offsetof(GzGameUserSettings_SetAcesSceneColorMultiplier, InAcesSceneColorMultiplier) == 0x000000, "Member 'GzGameUserSettings_SetAcesSceneColorMultiplier::InAcesSceneColorMultiplier' has a wrong offset!");

// Function G01.GzGameUserSettings.SetAimAssistPreset
// 0x0010 (0x0010 - 0x0000)
struct GzGameUserSettings_SetAimAssistPreset final
{
public:
	class FString                                 InAimAssistPreset;                                 // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzGameUserSettings_SetAimAssistPreset) == 0x000008, "Wrong alignment on GzGameUserSettings_SetAimAssistPreset");
static_assert(sizeof(GzGameUserSettings_SetAimAssistPreset) == 0x000010, "Wrong size on GzGameUserSettings_SetAimAssistPreset");
static_assert(offsetof(GzGameUserSettings_SetAimAssistPreset, InAimAssistPreset) == 0x000000, "Member 'GzGameUserSettings_SetAimAssistPreset::InAimAssistPreset' has a wrong offset!");

// Function G01.GzGameUserSettings.SetAlignMinimap
// 0x0001 (0x0001 - 0x0000)
struct GzGameUserSettings_SetAlignMinimap final
{
public:
	bool                                          bInAlignMinimap;                                   // 0x0000(0x0001)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzGameUserSettings_SetAlignMinimap) == 0x000001, "Wrong alignment on GzGameUserSettings_SetAlignMinimap");
static_assert(sizeof(GzGameUserSettings_SetAlignMinimap) == 0x000001, "Wrong size on GzGameUserSettings_SetAlignMinimap");
static_assert(offsetof(GzGameUserSettings_SetAlignMinimap, bInAlignMinimap) == 0x000000, "Member 'GzGameUserSettings_SetAlignMinimap::bInAlignMinimap' has a wrong offset!");

// Function G01.GzGameUserSettings.SetAntiAliasingMethod
// 0x0004 (0x0004 - 0x0000)
struct GzGameUserSettings_SetAntiAliasingMethod final
{
public:
	int32                                         Value;                                             // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzGameUserSettings_SetAntiAliasingMethod) == 0x000004, "Wrong alignment on GzGameUserSettings_SetAntiAliasingMethod");
static_assert(sizeof(GzGameUserSettings_SetAntiAliasingMethod) == 0x000004, "Wrong size on GzGameUserSettings_SetAntiAliasingMethod");
static_assert(offsetof(GzGameUserSettings_SetAntiAliasingMethod, Value) == 0x000000, "Member 'GzGameUserSettings_SetAntiAliasingMethod::Value' has a wrong offset!");

// Function G01.GzGameUserSettings.SetAudioPresetName
// 0x0010 (0x0010 - 0x0000)
struct GzGameUserSettings_SetAudioPresetName final
{
public:
	class FString                                 InAudioPresetName;                                 // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzGameUserSettings_SetAudioPresetName) == 0x000008, "Wrong alignment on GzGameUserSettings_SetAudioPresetName");
static_assert(sizeof(GzGameUserSettings_SetAudioPresetName) == 0x000010, "Wrong size on GzGameUserSettings_SetAudioPresetName");
static_assert(offsetof(GzGameUserSettings_SetAudioPresetName, InAudioPresetName) == 0x000000, "Member 'GzGameUserSettings_SetAudioPresetName::InAudioPresetName' has a wrong offset!");

// Function G01.GzGameUserSettings.SetAutoLoginEnabled
// 0x0001 (0x0001 - 0x0000)
struct GzGameUserSettings_SetAutoLoginEnabled final
{
public:
	bool                                          Value;                                             // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzGameUserSettings_SetAutoLoginEnabled) == 0x000001, "Wrong alignment on GzGameUserSettings_SetAutoLoginEnabled");
static_assert(sizeof(GzGameUserSettings_SetAutoLoginEnabled) == 0x000001, "Wrong size on GzGameUserSettings_SetAutoLoginEnabled");
static_assert(offsetof(GzGameUserSettings_SetAutoLoginEnabled, Value) == 0x000000, "Member 'GzGameUserSettings_SetAutoLoginEnabled::Value' has a wrong offset!");

// Function G01.GzGameUserSettings.SetAutomaticallyConnectToHostHideout
// 0x0001 (0x0001 - 0x0000)
struct GzGameUserSettings_SetAutomaticallyConnectToHostHideout final
{
public:
	bool                                          Value;                                             // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzGameUserSettings_SetAutomaticallyConnectToHostHideout) == 0x000001, "Wrong alignment on GzGameUserSettings_SetAutomaticallyConnectToHostHideout");
static_assert(sizeof(GzGameUserSettings_SetAutomaticallyConnectToHostHideout) == 0x000001, "Wrong size on GzGameUserSettings_SetAutomaticallyConnectToHostHideout");
static_assert(offsetof(GzGameUserSettings_SetAutomaticallyConnectToHostHideout, Value) == 0x000000, "Member 'GzGameUserSettings_SetAutomaticallyConnectToHostHideout::Value' has a wrong offset!");

// Function G01.GzGameUserSettings.SetAutoPickUpEnabled
// 0x0001 (0x0001 - 0x0000)
struct GzGameUserSettings_SetAutoPickUpEnabled final
{
public:
	bool                                          Value;                                             // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzGameUserSettings_SetAutoPickUpEnabled) == 0x000001, "Wrong alignment on GzGameUserSettings_SetAutoPickUpEnabled");
static_assert(sizeof(GzGameUserSettings_SetAutoPickUpEnabled) == 0x000001, "Wrong size on GzGameUserSettings_SetAutoPickUpEnabled");
static_assert(offsetof(GzGameUserSettings_SetAutoPickUpEnabled, Value) == 0x000000, "Member 'GzGameUserSettings_SetAutoPickUpEnabled::Value' has a wrong offset!");

// Function G01.GzGameUserSettings.SetCharacterVoiceVolumeScale
// 0x0004 (0x0004 - 0x0000)
struct GzGameUserSettings_SetCharacterVoiceVolumeScale final
{
public:
	float                                         NewScaleFactor;                                    // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzGameUserSettings_SetCharacterVoiceVolumeScale) == 0x000004, "Wrong alignment on GzGameUserSettings_SetCharacterVoiceVolumeScale");
static_assert(sizeof(GzGameUserSettings_SetCharacterVoiceVolumeScale) == 0x000004, "Wrong size on GzGameUserSettings_SetCharacterVoiceVolumeScale");
static_assert(offsetof(GzGameUserSettings_SetCharacterVoiceVolumeScale, NewScaleFactor) == 0x000000, "Member 'GzGameUserSettings_SetCharacterVoiceVolumeScale::NewScaleFactor' has a wrong offset!");

// Function G01.GzGameUserSettings.SetColorVisionDeficiency
// 0x0001 (0x0001 - 0x0000)
struct GzGameUserSettings_SetColorVisionDeficiency final
{
public:
	EColorVisionDeficiency                        InDeficiency;                                      // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzGameUserSettings_SetColorVisionDeficiency) == 0x000001, "Wrong alignment on GzGameUserSettings_SetColorVisionDeficiency");
static_assert(sizeof(GzGameUserSettings_SetColorVisionDeficiency) == 0x000001, "Wrong size on GzGameUserSettings_SetColorVisionDeficiency");
static_assert(offsetof(GzGameUserSettings_SetColorVisionDeficiency, InDeficiency) == 0x000000, "Member 'GzGameUserSettings_SetColorVisionDeficiency::InDeficiency' has a wrong offset!");

// Function G01.GzGameUserSettings.SetDeadZone
// 0x0004 (0x0004 - 0x0000)
struct GzGameUserSettings_SetDeadZone final
{
public:
	float                                         InDeadZone;                                        // 0x0000(0x0004)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzGameUserSettings_SetDeadZone) == 0x000004, "Wrong alignment on GzGameUserSettings_SetDeadZone");
static_assert(sizeof(GzGameUserSettings_SetDeadZone) == 0x000004, "Wrong size on GzGameUserSettings_SetDeadZone");
static_assert(offsetof(GzGameUserSettings_SetDeadZone, InDeadZone) == 0x000000, "Member 'GzGameUserSettings_SetDeadZone::InDeadZone' has a wrong offset!");

// Function G01.GzGameUserSettings.SetDevNotificationsEnabled
// 0x0001 (0x0001 - 0x0000)
struct GzGameUserSettings_SetDevNotificationsEnabled final
{
public:
	bool                                          Value;                                             // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzGameUserSettings_SetDevNotificationsEnabled) == 0x000001, "Wrong alignment on GzGameUserSettings_SetDevNotificationsEnabled");
static_assert(sizeof(GzGameUserSettings_SetDevNotificationsEnabled) == 0x000001, "Wrong size on GzGameUserSettings_SetDevNotificationsEnabled");
static_assert(offsetof(GzGameUserSettings_SetDevNotificationsEnabled, Value) == 0x000000, "Member 'GzGameUserSettings_SetDevNotificationsEnabled::Value' has a wrong offset!");

// Function G01.GzGameUserSettings.SetDisplayGamma
// 0x0004 (0x0004 - 0x0000)
struct GzGameUserSettings_SetDisplayGamma final
{
public:
	float                                         InGamma;                                           // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzGameUserSettings_SetDisplayGamma) == 0x000004, "Wrong alignment on GzGameUserSettings_SetDisplayGamma");
static_assert(sizeof(GzGameUserSettings_SetDisplayGamma) == 0x000004, "Wrong size on GzGameUserSettings_SetDisplayGamma");
static_assert(offsetof(GzGameUserSettings_SetDisplayGamma, InGamma) == 0x000000, "Member 'GzGameUserSettings_SetDisplayGamma::InGamma' has a wrong offset!");

// Function G01.GzGameUserSettings.SetDisplayIndex
// 0x0004 (0x0004 - 0x0000)
struct GzGameUserSettings_SetDisplayIndex final
{
public:
	int32                                         Value;                                             // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzGameUserSettings_SetDisplayIndex) == 0x000004, "Wrong alignment on GzGameUserSettings_SetDisplayIndex");
static_assert(sizeof(GzGameUserSettings_SetDisplayIndex) == 0x000004, "Wrong size on GzGameUserSettings_SetDisplayIndex");
static_assert(offsetof(GzGameUserSettings_SetDisplayIndex, Value) == 0x000000, "Member 'GzGameUserSettings_SetDisplayIndex::Value' has a wrong offset!");

// Function G01.GzGameUserSettings.SetEnableAdaptiveTriggers
// 0x0001 (0x0001 - 0x0000)
struct GzGameUserSettings_SetEnableAdaptiveTriggers final
{
public:
	bool                                          bInEnable;                                         // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzGameUserSettings_SetEnableAdaptiveTriggers) == 0x000001, "Wrong alignment on GzGameUserSettings_SetEnableAdaptiveTriggers");
static_assert(sizeof(GzGameUserSettings_SetEnableAdaptiveTriggers) == 0x000001, "Wrong size on GzGameUserSettings_SetEnableAdaptiveTriggers");
static_assert(offsetof(GzGameUserSettings_SetEnableAdaptiveTriggers, bInEnable) == 0x000000, "Member 'GzGameUserSettings_SetEnableAdaptiveTriggers::bInEnable' has a wrong offset!");

// Function G01.GzGameUserSettings.SetEnableHapticsFeedback
// 0x0001 (0x0001 - 0x0000)
struct GzGameUserSettings_SetEnableHapticsFeedback final
{
public:
	bool                                          bInEnable;                                         // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzGameUserSettings_SetEnableHapticsFeedback) == 0x000001, "Wrong alignment on GzGameUserSettings_SetEnableHapticsFeedback");
static_assert(sizeof(GzGameUserSettings_SetEnableHapticsFeedback) == 0x000001, "Wrong size on GzGameUserSettings_SetEnableHapticsFeedback");
static_assert(offsetof(GzGameUserSettings_SetEnableHapticsFeedback, bInEnable) == 0x000000, "Member 'GzGameUserSettings_SetEnableHapticsFeedback::bInEnable' has a wrong offset!");

// Function G01.GzGameUserSettings.SetFullCatalogAccessEnabled
// 0x0001 (0x0001 - 0x0000)
struct GzGameUserSettings_SetFullCatalogAccessEnabled final
{
public:
	bool                                          Value;                                             // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzGameUserSettings_SetFullCatalogAccessEnabled) == 0x000001, "Wrong alignment on GzGameUserSettings_SetFullCatalogAccessEnabled");
static_assert(sizeof(GzGameUserSettings_SetFullCatalogAccessEnabled) == 0x000001, "Wrong size on GzGameUserSettings_SetFullCatalogAccessEnabled");
static_assert(offsetof(GzGameUserSettings_SetFullCatalogAccessEnabled, Value) == 0x000000, "Member 'GzGameUserSettings_SetFullCatalogAccessEnabled::Value' has a wrong offset!");

// Function G01.GzGameUserSettings.SetGameMeshMinLODQuality
// 0x0004 (0x0004 - 0x0000)
struct GzGameUserSettings_SetGameMeshMinLODQuality final
{
public:
	int32                                         InQuality;                                         // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzGameUserSettings_SetGameMeshMinLODQuality) == 0x000004, "Wrong alignment on GzGameUserSettings_SetGameMeshMinLODQuality");
static_assert(sizeof(GzGameUserSettings_SetGameMeshMinLODQuality) == 0x000004, "Wrong size on GzGameUserSettings_SetGameMeshMinLODQuality");
static_assert(offsetof(GzGameUserSettings_SetGameMeshMinLODQuality, InQuality) == 0x000000, "Member 'GzGameUserSettings_SetGameMeshMinLODQuality::InQuality' has a wrong offset!");

// Function G01.GzGameUserSettings.SetGamepadHorizontalAimSensitivityScale
// 0x0004 (0x0004 - 0x0000)
struct GzGameUserSettings_SetGamepadHorizontalAimSensitivityScale final
{
public:
	float                                         InGamepadHorizontalAimSensitivityScale;            // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzGameUserSettings_SetGamepadHorizontalAimSensitivityScale) == 0x000004, "Wrong alignment on GzGameUserSettings_SetGamepadHorizontalAimSensitivityScale");
static_assert(sizeof(GzGameUserSettings_SetGamepadHorizontalAimSensitivityScale) == 0x000004, "Wrong size on GzGameUserSettings_SetGamepadHorizontalAimSensitivityScale");
static_assert(offsetof(GzGameUserSettings_SetGamepadHorizontalAimSensitivityScale, InGamepadHorizontalAimSensitivityScale) == 0x000000, "Member 'GzGameUserSettings_SetGamepadHorizontalAimSensitivityScale::InGamepadHorizontalAimSensitivityScale' has a wrong offset!");

// Function G01.GzGameUserSettings.SetGamepadHorizontalLookSensitivityScale
// 0x0004 (0x0004 - 0x0000)
struct GzGameUserSettings_SetGamepadHorizontalLookSensitivityScale final
{
public:
	float                                         InGamepadHorizontalLookSensitivityScale;           // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzGameUserSettings_SetGamepadHorizontalLookSensitivityScale) == 0x000004, "Wrong alignment on GzGameUserSettings_SetGamepadHorizontalLookSensitivityScale");
static_assert(sizeof(GzGameUserSettings_SetGamepadHorizontalLookSensitivityScale) == 0x000004, "Wrong size on GzGameUserSettings_SetGamepadHorizontalLookSensitivityScale");
static_assert(offsetof(GzGameUserSettings_SetGamepadHorizontalLookSensitivityScale, InGamepadHorizontalLookSensitivityScale) == 0x000000, "Member 'GzGameUserSettings_SetGamepadHorizontalLookSensitivityScale::InGamepadHorizontalLookSensitivityScale' has a wrong offset!");

// Function G01.GzGameUserSettings.SetGamepadHorizontalSnipeSensitivityScale
// 0x0004 (0x0004 - 0x0000)
struct GzGameUserSettings_SetGamepadHorizontalSnipeSensitivityScale final
{
public:
	float                                         InGamepadHorizontalSnipeSensitivityScale;          // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzGameUserSettings_SetGamepadHorizontalSnipeSensitivityScale) == 0x000004, "Wrong alignment on GzGameUserSettings_SetGamepadHorizontalSnipeSensitivityScale");
static_assert(sizeof(GzGameUserSettings_SetGamepadHorizontalSnipeSensitivityScale) == 0x000004, "Wrong size on GzGameUserSettings_SetGamepadHorizontalSnipeSensitivityScale");
static_assert(offsetof(GzGameUserSettings_SetGamepadHorizontalSnipeSensitivityScale, InGamepadHorizontalSnipeSensitivityScale) == 0x000000, "Member 'GzGameUserSettings_SetGamepadHorizontalSnipeSensitivityScale::InGamepadHorizontalSnipeSensitivityScale' has a wrong offset!");

// Function G01.GzGameUserSettings.SetGamepadVerticalAimSensitivityScale
// 0x0004 (0x0004 - 0x0000)
struct GzGameUserSettings_SetGamepadVerticalAimSensitivityScale final
{
public:
	float                                         InGamepadVerticalAimSensitivityScaleFactor;        // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzGameUserSettings_SetGamepadVerticalAimSensitivityScale) == 0x000004, "Wrong alignment on GzGameUserSettings_SetGamepadVerticalAimSensitivityScale");
static_assert(sizeof(GzGameUserSettings_SetGamepadVerticalAimSensitivityScale) == 0x000004, "Wrong size on GzGameUserSettings_SetGamepadVerticalAimSensitivityScale");
static_assert(offsetof(GzGameUserSettings_SetGamepadVerticalAimSensitivityScale, InGamepadVerticalAimSensitivityScaleFactor) == 0x000000, "Member 'GzGameUserSettings_SetGamepadVerticalAimSensitivityScale::InGamepadVerticalAimSensitivityScaleFactor' has a wrong offset!");

// Function G01.GzGameUserSettings.SetGamepadVerticalLookSensitivityScale
// 0x0004 (0x0004 - 0x0000)
struct GzGameUserSettings_SetGamepadVerticalLookSensitivityScale final
{
public:
	float                                         InGamepadVerticalLookSensitivityScale;             // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzGameUserSettings_SetGamepadVerticalLookSensitivityScale) == 0x000004, "Wrong alignment on GzGameUserSettings_SetGamepadVerticalLookSensitivityScale");
static_assert(sizeof(GzGameUserSettings_SetGamepadVerticalLookSensitivityScale) == 0x000004, "Wrong size on GzGameUserSettings_SetGamepadVerticalLookSensitivityScale");
static_assert(offsetof(GzGameUserSettings_SetGamepadVerticalLookSensitivityScale, InGamepadVerticalLookSensitivityScale) == 0x000000, "Member 'GzGameUserSettings_SetGamepadVerticalLookSensitivityScale::InGamepadVerticalLookSensitivityScale' has a wrong offset!");

// Function G01.GzGameUserSettings.SetGamepadVerticalSnipeSensitivityScale
// 0x0004 (0x0004 - 0x0000)
struct GzGameUserSettings_SetGamepadVerticalSnipeSensitivityScale final
{
public:
	float                                         InGamepadVerticalSnipeSensitivityScale;            // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzGameUserSettings_SetGamepadVerticalSnipeSensitivityScale) == 0x000004, "Wrong alignment on GzGameUserSettings_SetGamepadVerticalSnipeSensitivityScale");
static_assert(sizeof(GzGameUserSettings_SetGamepadVerticalSnipeSensitivityScale) == 0x000004, "Wrong size on GzGameUserSettings_SetGamepadVerticalSnipeSensitivityScale");
static_assert(offsetof(GzGameUserSettings_SetGamepadVerticalSnipeSensitivityScale, InGamepadVerticalSnipeSensitivityScale) == 0x000000, "Member 'GzGameUserSettings_SetGamepadVerticalSnipeSensitivityScale::InGamepadVerticalSnipeSensitivityScale' has a wrong offset!");

// Function G01.GzGameUserSettings.SetGzAntiAliasingQuality
// 0x0004 (0x0004 - 0x0000)
struct GzGameUserSettings_SetGzAntiAliasingQuality final
{
public:
	int32                                         Value;                                             // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzGameUserSettings_SetGzAntiAliasingQuality) == 0x000004, "Wrong alignment on GzGameUserSettings_SetGzAntiAliasingQuality");
static_assert(sizeof(GzGameUserSettings_SetGzAntiAliasingQuality) == 0x000004, "Wrong size on GzGameUserSettings_SetGzAntiAliasingQuality");
static_assert(offsetof(GzGameUserSettings_SetGzAntiAliasingQuality, Value) == 0x000000, "Member 'GzGameUserSettings_SetGzAntiAliasingQuality::Value' has a wrong offset!");

// Function G01.GzGameUserSettings.SetGzFoliageQuality
// 0x0004 (0x0004 - 0x0000)
struct GzGameUserSettings_SetGzFoliageQuality final
{
public:
	int32                                         Value;                                             // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzGameUserSettings_SetGzFoliageQuality) == 0x000004, "Wrong alignment on GzGameUserSettings_SetGzFoliageQuality");
static_assert(sizeof(GzGameUserSettings_SetGzFoliageQuality) == 0x000004, "Wrong size on GzGameUserSettings_SetGzFoliageQuality");
static_assert(offsetof(GzGameUserSettings_SetGzFoliageQuality, Value) == 0x000000, "Member 'GzGameUserSettings_SetGzFoliageQuality::Value' has a wrong offset!");

// Function G01.GzGameUserSettings.SetGzFrameRateLimit
// 0x0004 (0x0004 - 0x0000)
struct GzGameUserSettings_SetGzFrameRateLimit final
{
public:
	float                                         NewLimit;                                          // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzGameUserSettings_SetGzFrameRateLimit) == 0x000004, "Wrong alignment on GzGameUserSettings_SetGzFrameRateLimit");
static_assert(sizeof(GzGameUserSettings_SetGzFrameRateLimit) == 0x000004, "Wrong size on GzGameUserSettings_SetGzFrameRateLimit");
static_assert(offsetof(GzGameUserSettings_SetGzFrameRateLimit, NewLimit) == 0x000000, "Member 'GzGameUserSettings_SetGzFrameRateLimit::NewLimit' has a wrong offset!");

// Function G01.GzGameUserSettings.SetGzFullscreenMode
// 0x0001 (0x0001 - 0x0000)
struct GzGameUserSettings_SetGzFullscreenMode final
{
public:
	EWindowMode                                   InFullscreenMode;                                  // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzGameUserSettings_SetGzFullscreenMode) == 0x000001, "Wrong alignment on GzGameUserSettings_SetGzFullscreenMode");
static_assert(sizeof(GzGameUserSettings_SetGzFullscreenMode) == 0x000001, "Wrong size on GzGameUserSettings_SetGzFullscreenMode");
static_assert(offsetof(GzGameUserSettings_SetGzFullscreenMode, InFullscreenMode) == 0x000000, "Member 'GzGameUserSettings_SetGzFullscreenMode::InFullscreenMode' has a wrong offset!");

// Function G01.GzGameUserSettings.SetGzGlobalIlluminationQuality
// 0x0004 (0x0004 - 0x0000)
struct GzGameUserSettings_SetGzGlobalIlluminationQuality final
{
public:
	int32                                         Value;                                             // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzGameUserSettings_SetGzGlobalIlluminationQuality) == 0x000004, "Wrong alignment on GzGameUserSettings_SetGzGlobalIlluminationQuality");
static_assert(sizeof(GzGameUserSettings_SetGzGlobalIlluminationQuality) == 0x000004, "Wrong size on GzGameUserSettings_SetGzGlobalIlluminationQuality");
static_assert(offsetof(GzGameUserSettings_SetGzGlobalIlluminationQuality, Value) == 0x000000, "Member 'GzGameUserSettings_SetGzGlobalIlluminationQuality::Value' has a wrong offset!");

// Function G01.GzGameUserSettings.SetGzOverallScalabilityLevel
// 0x0004 (0x0004 - 0x0000)
struct GzGameUserSettings_SetGzOverallScalabilityLevel final
{
public:
	int32                                         Value;                                             // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzGameUserSettings_SetGzOverallScalabilityLevel) == 0x000004, "Wrong alignment on GzGameUserSettings_SetGzOverallScalabilityLevel");
static_assert(sizeof(GzGameUserSettings_SetGzOverallScalabilityLevel) == 0x000004, "Wrong size on GzGameUserSettings_SetGzOverallScalabilityLevel");
static_assert(offsetof(GzGameUserSettings_SetGzOverallScalabilityLevel, Value) == 0x000000, "Member 'GzGameUserSettings_SetGzOverallScalabilityLevel::Value' has a wrong offset!");

// Function G01.GzGameUserSettings.SetGzPostProcessingQuality
// 0x0004 (0x0004 - 0x0000)
struct GzGameUserSettings_SetGzPostProcessingQuality final
{
public:
	int32                                         Value;                                             // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzGameUserSettings_SetGzPostProcessingQuality) == 0x000004, "Wrong alignment on GzGameUserSettings_SetGzPostProcessingQuality");
static_assert(sizeof(GzGameUserSettings_SetGzPostProcessingQuality) == 0x000004, "Wrong size on GzGameUserSettings_SetGzPostProcessingQuality");
static_assert(offsetof(GzGameUserSettings_SetGzPostProcessingQuality, Value) == 0x000000, "Member 'GzGameUserSettings_SetGzPostProcessingQuality::Value' has a wrong offset!");

// Function G01.GzGameUserSettings.SetGzReflectionQuality
// 0x0004 (0x0004 - 0x0000)
struct GzGameUserSettings_SetGzReflectionQuality final
{
public:
	int32                                         Value;                                             // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzGameUserSettings_SetGzReflectionQuality) == 0x000004, "Wrong alignment on GzGameUserSettings_SetGzReflectionQuality");
static_assert(sizeof(GzGameUserSettings_SetGzReflectionQuality) == 0x000004, "Wrong size on GzGameUserSettings_SetGzReflectionQuality");
static_assert(offsetof(GzGameUserSettings_SetGzReflectionQuality, Value) == 0x000000, "Member 'GzGameUserSettings_SetGzReflectionQuality::Value' has a wrong offset!");

// Function G01.GzGameUserSettings.SetGzScreenResolution
// 0x0008 (0x0008 - 0x0000)
struct GzGameUserSettings_SetGzScreenResolution final
{
public:
	struct FIntPoint                              Resolution;                                        // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzGameUserSettings_SetGzScreenResolution) == 0x000004, "Wrong alignment on GzGameUserSettings_SetGzScreenResolution");
static_assert(sizeof(GzGameUserSettings_SetGzScreenResolution) == 0x000008, "Wrong size on GzGameUserSettings_SetGzScreenResolution");
static_assert(offsetof(GzGameUserSettings_SetGzScreenResolution, Resolution) == 0x000000, "Member 'GzGameUserSettings_SetGzScreenResolution::Resolution' has a wrong offset!");

// Function G01.GzGameUserSettings.SetGzShadingQuality
// 0x0004 (0x0004 - 0x0000)
struct GzGameUserSettings_SetGzShadingQuality final
{
public:
	int32                                         Value;                                             // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzGameUserSettings_SetGzShadingQuality) == 0x000004, "Wrong alignment on GzGameUserSettings_SetGzShadingQuality");
static_assert(sizeof(GzGameUserSettings_SetGzShadingQuality) == 0x000004, "Wrong size on GzGameUserSettings_SetGzShadingQuality");
static_assert(offsetof(GzGameUserSettings_SetGzShadingQuality, Value) == 0x000000, "Member 'GzGameUserSettings_SetGzShadingQuality::Value' has a wrong offset!");

// Function G01.GzGameUserSettings.SetGzShadowQuality
// 0x0004 (0x0004 - 0x0000)
struct GzGameUserSettings_SetGzShadowQuality final
{
public:
	int32                                         Value;                                             // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzGameUserSettings_SetGzShadowQuality) == 0x000004, "Wrong alignment on GzGameUserSettings_SetGzShadowQuality");
static_assert(sizeof(GzGameUserSettings_SetGzShadowQuality) == 0x000004, "Wrong size on GzGameUserSettings_SetGzShadowQuality");
static_assert(offsetof(GzGameUserSettings_SetGzShadowQuality, Value) == 0x000000, "Member 'GzGameUserSettings_SetGzShadowQuality::Value' has a wrong offset!");

// Function G01.GzGameUserSettings.SetGzTextureQuality
// 0x0004 (0x0004 - 0x0000)
struct GzGameUserSettings_SetGzTextureQuality final
{
public:
	int32                                         Value;                                             // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzGameUserSettings_SetGzTextureQuality) == 0x000004, "Wrong alignment on GzGameUserSettings_SetGzTextureQuality");
static_assert(sizeof(GzGameUserSettings_SetGzTextureQuality) == 0x000004, "Wrong size on GzGameUserSettings_SetGzTextureQuality");
static_assert(offsetof(GzGameUserSettings_SetGzTextureQuality, Value) == 0x000000, "Member 'GzGameUserSettings_SetGzTextureQuality::Value' has a wrong offset!");

// Function G01.GzGameUserSettings.SetGzViewDistanceQuality
// 0x0004 (0x0004 - 0x0000)
struct GzGameUserSettings_SetGzViewDistanceQuality final
{
public:
	int32                                         Value;                                             // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzGameUserSettings_SetGzViewDistanceQuality) == 0x000004, "Wrong alignment on GzGameUserSettings_SetGzViewDistanceQuality");
static_assert(sizeof(GzGameUserSettings_SetGzViewDistanceQuality) == 0x000004, "Wrong size on GzGameUserSettings_SetGzViewDistanceQuality");
static_assert(offsetof(GzGameUserSettings_SetGzViewDistanceQuality, Value) == 0x000000, "Member 'GzGameUserSettings_SetGzViewDistanceQuality::Value' has a wrong offset!");

// Function G01.GzGameUserSettings.SetGzVisualEffectQuality
// 0x0004 (0x0004 - 0x0000)
struct GzGameUserSettings_SetGzVisualEffectQuality final
{
public:
	int32                                         Value;                                             // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzGameUserSettings_SetGzVisualEffectQuality) == 0x000004, "Wrong alignment on GzGameUserSettings_SetGzVisualEffectQuality");
static_assert(sizeof(GzGameUserSettings_SetGzVisualEffectQuality) == 0x000004, "Wrong size on GzGameUserSettings_SetGzVisualEffectQuality");
static_assert(offsetof(GzGameUserSettings_SetGzVisualEffectQuality, Value) == 0x000000, "Member 'GzGameUserSettings_SetGzVisualEffectQuality::Value' has a wrong offset!");

// Function G01.GzGameUserSettings.SetGzVSyncEnabled
// 0x0001 (0x0001 - 0x0000)
struct GzGameUserSettings_SetGzVSyncEnabled final
{
public:
	bool                                          bEnabled;                                          // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzGameUserSettings_SetGzVSyncEnabled) == 0x000001, "Wrong alignment on GzGameUserSettings_SetGzVSyncEnabled");
static_assert(sizeof(GzGameUserSettings_SetGzVSyncEnabled) == 0x000001, "Wrong size on GzGameUserSettings_SetGzVSyncEnabled");
static_assert(offsetof(GzGameUserSettings_SetGzVSyncEnabled, bEnabled) == 0x000000, "Member 'GzGameUserSettings_SetGzVSyncEnabled::bEnabled' has a wrong offset!");

// Function G01.GzGameUserSettings.SetHardwareRayTracingEnabled
// 0x0001 (0x0001 - 0x0000)
struct GzGameUserSettings_SetHardwareRayTracingEnabled final
{
public:
	bool                                          bInHardwareRayTracingEnabled;                      // 0x0000(0x0001)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzGameUserSettings_SetHardwareRayTracingEnabled) == 0x000001, "Wrong alignment on GzGameUserSettings_SetHardwareRayTracingEnabled");
static_assert(sizeof(GzGameUserSettings_SetHardwareRayTracingEnabled) == 0x000001, "Wrong size on GzGameUserSettings_SetHardwareRayTracingEnabled");
static_assert(offsetof(GzGameUserSettings_SetHardwareRayTracingEnabled, bInHardwareRayTracingEnabled) == 0x000000, "Member 'GzGameUserSettings_SetHardwareRayTracingEnabled::bInHardwareRayTracingEnabled' has a wrong offset!");

// Function G01.GzGameUserSettings.SetHDROutputEnabled
// 0x0001 (0x0001 - 0x0000)
struct GzGameUserSettings_SetHDROutputEnabled final
{
public:
	bool                                          bEnable;                                           // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzGameUserSettings_SetHDROutputEnabled) == 0x000001, "Wrong alignment on GzGameUserSettings_SetHDROutputEnabled");
static_assert(sizeof(GzGameUserSettings_SetHDROutputEnabled) == 0x000001, "Wrong size on GzGameUserSettings_SetHDROutputEnabled");
static_assert(offsetof(GzGameUserSettings_SetHDROutputEnabled, bEnable) == 0x000000, "Member 'GzGameUserSettings_SetHDROutputEnabled::bEnable' has a wrong offset!");

// Function G01.GzGameUserSettings.SetHDRUiLevel
// 0x0004 (0x0004 - 0x0000)
struct GzGameUserSettings_SetHDRUiLevel final
{
public:
	float                                         InHDRUiLevel;                                      // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzGameUserSettings_SetHDRUiLevel) == 0x000004, "Wrong alignment on GzGameUserSettings_SetHDRUiLevel");
static_assert(sizeof(GzGameUserSettings_SetHDRUiLevel) == 0x000004, "Wrong size on GzGameUserSettings_SetHDRUiLevel");
static_assert(offsetof(GzGameUserSettings_SetHDRUiLevel, InHDRUiLevel) == 0x000000, "Member 'GzGameUserSettings_SetHDRUiLevel::InHDRUiLevel' has a wrong offset!");

// Function G01.GzGameUserSettings.SetHideoutMeshMinLODQuality
// 0x0004 (0x0004 - 0x0000)
struct GzGameUserSettings_SetHideoutMeshMinLODQuality final
{
public:
	int32                                         InQuality;                                         // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzGameUserSettings_SetHideoutMeshMinLODQuality) == 0x000004, "Wrong alignment on GzGameUserSettings_SetHideoutMeshMinLODQuality");
static_assert(sizeof(GzGameUserSettings_SetHideoutMeshMinLODQuality) == 0x000004, "Wrong size on GzGameUserSettings_SetHideoutMeshMinLODQuality");
static_assert(offsetof(GzGameUserSettings_SetHideoutMeshMinLODQuality, InQuality) == 0x000000, "Member 'GzGameUserSettings_SetHideoutMeshMinLODQuality::InQuality' has a wrong offset!");

// Function G01.GzGameUserSettings.SetHorizontalAimSensitivityScaleFactor
// 0x0004 (0x0004 - 0x0000)
struct GzGameUserSettings_SetHorizontalAimSensitivityScaleFactor final
{
public:
	float                                         NewScaleFactor;                                    // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzGameUserSettings_SetHorizontalAimSensitivityScaleFactor) == 0x000004, "Wrong alignment on GzGameUserSettings_SetHorizontalAimSensitivityScaleFactor");
static_assert(sizeof(GzGameUserSettings_SetHorizontalAimSensitivityScaleFactor) == 0x000004, "Wrong size on GzGameUserSettings_SetHorizontalAimSensitivityScaleFactor");
static_assert(offsetof(GzGameUserSettings_SetHorizontalAimSensitivityScaleFactor, NewScaleFactor) == 0x000000, "Member 'GzGameUserSettings_SetHorizontalAimSensitivityScaleFactor::NewScaleFactor' has a wrong offset!");

// Function G01.GzGameUserSettings.SetHorizontalInputInverted
// 0x0001 (0x0001 - 0x0000)
struct GzGameUserSettings_SetHorizontalInputInverted final
{
public:
	bool                                          bInverted;                                         // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzGameUserSettings_SetHorizontalInputInverted) == 0x000001, "Wrong alignment on GzGameUserSettings_SetHorizontalInputInverted");
static_assert(sizeof(GzGameUserSettings_SetHorizontalInputInverted) == 0x000001, "Wrong size on GzGameUserSettings_SetHorizontalInputInverted");
static_assert(offsetof(GzGameUserSettings_SetHorizontalInputInverted, bInverted) == 0x000000, "Member 'GzGameUserSettings_SetHorizontalInputInverted::bInverted' has a wrong offset!");

// Function G01.GzGameUserSettings.SetHorizontalLookSensitivityScaleFactor
// 0x0004 (0x0004 - 0x0000)
struct GzGameUserSettings_SetHorizontalLookSensitivityScaleFactor final
{
public:
	float                                         NewScaleFactor;                                    // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzGameUserSettings_SetHorizontalLookSensitivityScaleFactor) == 0x000004, "Wrong alignment on GzGameUserSettings_SetHorizontalLookSensitivityScaleFactor");
static_assert(sizeof(GzGameUserSettings_SetHorizontalLookSensitivityScaleFactor) == 0x000004, "Wrong size on GzGameUserSettings_SetHorizontalLookSensitivityScaleFactor");
static_assert(offsetof(GzGameUserSettings_SetHorizontalLookSensitivityScaleFactor, NewScaleFactor) == 0x000000, "Member 'GzGameUserSettings_SetHorizontalLookSensitivityScaleFactor::NewScaleFactor' has a wrong offset!");

// Function G01.GzGameUserSettings.SetHorizontalSnipeSensitivityScaleFactor
// 0x0004 (0x0004 - 0x0000)
struct GzGameUserSettings_SetHorizontalSnipeSensitivityScaleFactor final
{
public:
	float                                         NewScaleFactor;                                    // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzGameUserSettings_SetHorizontalSnipeSensitivityScaleFactor) == 0x000004, "Wrong alignment on GzGameUserSettings_SetHorizontalSnipeSensitivityScaleFactor");
static_assert(sizeof(GzGameUserSettings_SetHorizontalSnipeSensitivityScaleFactor) == 0x000004, "Wrong size on GzGameUserSettings_SetHorizontalSnipeSensitivityScaleFactor");
static_assert(offsetof(GzGameUserSettings_SetHorizontalSnipeSensitivityScaleFactor, NewScaleFactor) == 0x000000, "Member 'GzGameUserSettings_SetHorizontalSnipeSensitivityScaleFactor::NewScaleFactor' has a wrong offset!");

// Function G01.GzGameUserSettings.SetIsAdvancedKeyBindings
// 0x0001 (0x0001 - 0x0000)
struct GzGameUserSettings_SetIsAdvancedKeyBindings final
{
public:
	bool                                          bIsAdvanced;                                       // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzGameUserSettings_SetIsAdvancedKeyBindings) == 0x000001, "Wrong alignment on GzGameUserSettings_SetIsAdvancedKeyBindings");
static_assert(sizeof(GzGameUserSettings_SetIsAdvancedKeyBindings) == 0x000001, "Wrong size on GzGameUserSettings_SetIsAdvancedKeyBindings");
static_assert(offsetof(GzGameUserSettings_SetIsAdvancedKeyBindings, bIsAdvanced) == 0x000000, "Member 'GzGameUserSettings_SetIsAdvancedKeyBindings::bIsAdvanced' has a wrong offset!");

// Function G01.GzGameUserSettings.SetLanguage
// 0x0010 (0x0010 - 0x0000)
struct GzGameUserSettings_SetLanguage final
{
public:
	class FString                                 LanguageId;                                        // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzGameUserSettings_SetLanguage) == 0x000008, "Wrong alignment on GzGameUserSettings_SetLanguage");
static_assert(sizeof(GzGameUserSettings_SetLanguage) == 0x000010, "Wrong size on GzGameUserSettings_SetLanguage");
static_assert(offsetof(GzGameUserSettings_SetLanguage, LanguageId) == 0x000000, "Member 'GzGameUserSettings_SetLanguage::LanguageId' has a wrong offset!");

// Function G01.GzGameUserSettings.SetLootBeamsEnabled
// 0x0001 (0x0001 - 0x0000)
struct GzGameUserSettings_SetLootBeamsEnabled final
{
public:
	bool                                          Value;                                             // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzGameUserSettings_SetLootBeamsEnabled) == 0x000001, "Wrong alignment on GzGameUserSettings_SetLootBeamsEnabled");
static_assert(sizeof(GzGameUserSettings_SetLootBeamsEnabled) == 0x000001, "Wrong size on GzGameUserSettings_SetLootBeamsEnabled");
static_assert(offsetof(GzGameUserSettings_SetLootBeamsEnabled, Value) == 0x000000, "Member 'GzGameUserSettings_SetLootBeamsEnabled::Value' has a wrong offset!");

// Function G01.GzGameUserSettings.SetMainVolumeScale
// 0x0004 (0x0004 - 0x0000)
struct GzGameUserSettings_SetMainVolumeScale final
{
public:
	float                                         NewScaleFactor;                                    // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzGameUserSettings_SetMainVolumeScale) == 0x000004, "Wrong alignment on GzGameUserSettings_SetMainVolumeScale");
static_assert(sizeof(GzGameUserSettings_SetMainVolumeScale) == 0x000004, "Wrong size on GzGameUserSettings_SetMainVolumeScale");
static_assert(offsetof(GzGameUserSettings_SetMainVolumeScale, NewScaleFactor) == 0x000000, "Member 'GzGameUserSettings_SetMainVolumeScale::NewScaleFactor' has a wrong offset!");

// Function G01.GzGameUserSettings.SetMatchStateAnnouncerVolumeScale
// 0x0004 (0x0004 - 0x0000)
struct GzGameUserSettings_SetMatchStateAnnouncerVolumeScale final
{
public:
	float                                         NewScaleFactor;                                    // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzGameUserSettings_SetMatchStateAnnouncerVolumeScale) == 0x000004, "Wrong alignment on GzGameUserSettings_SetMatchStateAnnouncerVolumeScale");
static_assert(sizeof(GzGameUserSettings_SetMatchStateAnnouncerVolumeScale) == 0x000004, "Wrong size on GzGameUserSettings_SetMatchStateAnnouncerVolumeScale");
static_assert(offsetof(GzGameUserSettings_SetMatchStateAnnouncerVolumeScale, NewScaleFactor) == 0x000000, "Member 'GzGameUserSettings_SetMatchStateAnnouncerVolumeScale::NewScaleFactor' has a wrong offset!");

// Function G01.GzGameUserSettings.SetMicrophoneSensitivity
// 0x0004 (0x0004 - 0x0000)
struct GzGameUserSettings_SetMicrophoneSensitivity final
{
public:
	float                                         Value;                                             // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzGameUserSettings_SetMicrophoneSensitivity) == 0x000004, "Wrong alignment on GzGameUserSettings_SetMicrophoneSensitivity");
static_assert(sizeof(GzGameUserSettings_SetMicrophoneSensitivity) == 0x000004, "Wrong size on GzGameUserSettings_SetMicrophoneSensitivity");
static_assert(offsetof(GzGameUserSettings_SetMicrophoneSensitivity, Value) == 0x000000, "Member 'GzGameUserSettings_SetMicrophoneSensitivity::Value' has a wrong offset!");

// Function G01.GzGameUserSettings.SetMidLuminance
// 0x0004 (0x0004 - 0x0000)
struct GzGameUserSettings_SetMidLuminance final
{
public:
	float                                         InMidLuminance;                                    // 0x0000(0x0004)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzGameUserSettings_SetMidLuminance) == 0x000004, "Wrong alignment on GzGameUserSettings_SetMidLuminance");
static_assert(sizeof(GzGameUserSettings_SetMidLuminance) == 0x000004, "Wrong size on GzGameUserSettings_SetMidLuminance");
static_assert(offsetof(GzGameUserSettings_SetMidLuminance, InMidLuminance) == 0x000000, "Member 'GzGameUserSettings_SetMidLuminance::InMidLuminance' has a wrong offset!");

// Function G01.GzGameUserSettings.SetMinLuminanceLog10
// 0x0004 (0x0004 - 0x0000)
struct GzGameUserSettings_SetMinLuminanceLog10 final
{
public:
	float                                         InMinLuminanceLog10;                               // 0x0000(0x0004)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzGameUserSettings_SetMinLuminanceLog10) == 0x000004, "Wrong alignment on GzGameUserSettings_SetMinLuminanceLog10");
static_assert(sizeof(GzGameUserSettings_SetMinLuminanceLog10) == 0x000004, "Wrong size on GzGameUserSettings_SetMinLuminanceLog10");
static_assert(offsetof(GzGameUserSettings_SetMinLuminanceLog10, InMinLuminanceLog10) == 0x000000, "Member 'GzGameUserSettings_SetMinLuminanceLog10::InMinLuminanceLog10' has a wrong offset!");

// Function G01.GzGameUserSettings.SetMotionBlurActive
// 0x0001 (0x0001 - 0x0000)
struct GzGameUserSettings_SetMotionBlurActive final
{
public:
	bool                                          bActive;                                           // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzGameUserSettings_SetMotionBlurActive) == 0x000001, "Wrong alignment on GzGameUserSettings_SetMotionBlurActive");
static_assert(sizeof(GzGameUserSettings_SetMotionBlurActive) == 0x000001, "Wrong size on GzGameUserSettings_SetMotionBlurActive");
static_assert(offsetof(GzGameUserSettings_SetMotionBlurActive, bActive) == 0x000000, "Member 'GzGameUserSettings_SetMotionBlurActive::bActive' has a wrong offset!");

// Function G01.GzGameUserSettings.SetMusicVolumeScale
// 0x0004 (0x0004 - 0x0000)
struct GzGameUserSettings_SetMusicVolumeScale final
{
public:
	float                                         NewScaleFactor;                                    // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzGameUserSettings_SetMusicVolumeScale) == 0x000004, "Wrong alignment on GzGameUserSettings_SetMusicVolumeScale");
static_assert(sizeof(GzGameUserSettings_SetMusicVolumeScale) == 0x000004, "Wrong size on GzGameUserSettings_SetMusicVolumeScale");
static_assert(offsetof(GzGameUserSettings_SetMusicVolumeScale, NewScaleFactor) == 0x000000, "Member 'GzGameUserSettings_SetMusicVolumeScale::NewScaleFactor' has a wrong offset!");

// Function G01.GzGameUserSettings.SetMuteAudioWhenUnfocused
// 0x0001 (0x0001 - 0x0000)
struct GzGameUserSettings_SetMuteAudioWhenUnfocused final
{
public:
	bool                                          bMute;                                             // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzGameUserSettings_SetMuteAudioWhenUnfocused) == 0x000001, "Wrong alignment on GzGameUserSettings_SetMuteAudioWhenUnfocused");
static_assert(sizeof(GzGameUserSettings_SetMuteAudioWhenUnfocused) == 0x000001, "Wrong size on GzGameUserSettings_SetMuteAudioWhenUnfocused");
static_assert(offsetof(GzGameUserSettings_SetMuteAudioWhenUnfocused, bMute) == 0x000000, "Member 'GzGameUserSettings_SetMuteAudioWhenUnfocused::bMute' has a wrong offset!");

// Function G01.GzGameUserSettings.SetPerformanceStatsEnabled
// 0x0001 (0x0001 - 0x0000)
struct GzGameUserSettings_SetPerformanceStatsEnabled final
{
public:
	bool                                          bEnabled;                                          // 0x0000(0x0001)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzGameUserSettings_SetPerformanceStatsEnabled) == 0x000001, "Wrong alignment on GzGameUserSettings_SetPerformanceStatsEnabled");
static_assert(sizeof(GzGameUserSettings_SetPerformanceStatsEnabled) == 0x000001, "Wrong size on GzGameUserSettings_SetPerformanceStatsEnabled");
static_assert(offsetof(GzGameUserSettings_SetPerformanceStatsEnabled, bEnabled) == 0x000000, "Member 'GzGameUserSettings_SetPerformanceStatsEnabled::bEnabled' has a wrong offset!");

// Function G01.GzGameUserSettings.SetPersonalAssistantVoiceType
// 0x0010 (0x0010 - 0x0000)
struct GzGameUserSettings_SetPersonalAssistantVoiceType final
{
public:
	class FString                                 InPersonalAssistantVoiceType;                      // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzGameUserSettings_SetPersonalAssistantVoiceType) == 0x000008, "Wrong alignment on GzGameUserSettings_SetPersonalAssistantVoiceType");
static_assert(sizeof(GzGameUserSettings_SetPersonalAssistantVoiceType) == 0x000010, "Wrong size on GzGameUserSettings_SetPersonalAssistantVoiceType");
static_assert(offsetof(GzGameUserSettings_SetPersonalAssistantVoiceType, InPersonalAssistantVoiceType) == 0x000000, "Member 'GzGameUserSettings_SetPersonalAssistantVoiceType::InPersonalAssistantVoiceType' has a wrong offset!");

// Function G01.GzGameUserSettings.SetPersonalAssistantVolumeScale
// 0x0004 (0x0004 - 0x0000)
struct GzGameUserSettings_SetPersonalAssistantVolumeScale final
{
public:
	float                                         NewScaleFactor;                                    // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzGameUserSettings_SetPersonalAssistantVolumeScale) == 0x000004, "Wrong alignment on GzGameUserSettings_SetPersonalAssistantVolumeScale");
static_assert(sizeof(GzGameUserSettings_SetPersonalAssistantVolumeScale) == 0x000004, "Wrong size on GzGameUserSettings_SetPersonalAssistantVolumeScale");
static_assert(offsetof(GzGameUserSettings_SetPersonalAssistantVolumeScale, NewScaleFactor) == 0x000000, "Member 'GzGameUserSettings_SetPersonalAssistantVolumeScale::NewScaleFactor' has a wrong offset!");

// Function G01.GzGameUserSettings.SetQualityMode
// 0x0001 (0x0001 - 0x0000)
struct GzGameUserSettings_SetQualityMode final
{
public:
	bool                                          bInIsPerformanceMode;                              // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzGameUserSettings_SetQualityMode) == 0x000001, "Wrong alignment on GzGameUserSettings_SetQualityMode");
static_assert(sizeof(GzGameUserSettings_SetQualityMode) == 0x000001, "Wrong size on GzGameUserSettings_SetQualityMode");
static_assert(offsetof(GzGameUserSettings_SetQualityMode, bInIsPerformanceMode) == 0x000000, "Member 'GzGameUserSettings_SetQualityMode::bInIsPerformanceMode' has a wrong offset!");

// Function G01.GzGameUserSettings.SetResolutionScaleValue
// 0x0004 (0x0004 - 0x0000)
struct GzGameUserSettings_SetResolutionScaleValue final
{
public:
	float                                         Value;                                             // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzGameUserSettings_SetResolutionScaleValue) == 0x000004, "Wrong alignment on GzGameUserSettings_SetResolutionScaleValue");
static_assert(sizeof(GzGameUserSettings_SetResolutionScaleValue) == 0x000004, "Wrong size on GzGameUserSettings_SetResolutionScaleValue");
static_assert(offsetof(GzGameUserSettings_SetResolutionScaleValue, Value) == 0x000000, "Member 'GzGameUserSettings_SetResolutionScaleValue::Value' has a wrong offset!");

// Function G01.GzGameUserSettings.SetResolutionScalingMethod
// 0x0010 (0x0010 - 0x0000)
struct GzGameUserSettings_SetResolutionScalingMethod final
{
public:
	class FString                                 ScalingMethod;                                     // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzGameUserSettings_SetResolutionScalingMethod) == 0x000008, "Wrong alignment on GzGameUserSettings_SetResolutionScalingMethod");
static_assert(sizeof(GzGameUserSettings_SetResolutionScalingMethod) == 0x000010, "Wrong size on GzGameUserSettings_SetResolutionScalingMethod");
static_assert(offsetof(GzGameUserSettings_SetResolutionScalingMethod, ScalingMethod) == 0x000000, "Member 'GzGameUserSettings_SetResolutionScalingMethod::ScalingMethod' has a wrong offset!");

// Function G01.GzGameUserSettings.SetSfxVolumeScale
// 0x0004 (0x0004 - 0x0000)
struct GzGameUserSettings_SetSfxVolumeScale final
{
public:
	float                                         NewScaleFactor;                                    // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzGameUserSettings_SetSfxVolumeScale) == 0x000004, "Wrong alignment on GzGameUserSettings_SetSfxVolumeScale");
static_assert(sizeof(GzGameUserSettings_SetSfxVolumeScale) == 0x000004, "Wrong size on GzGameUserSettings_SetSfxVolumeScale");
static_assert(offsetof(GzGameUserSettings_SetSfxVolumeScale, NewScaleFactor) == 0x000000, "Member 'GzGameUserSettings_SetSfxVolumeScale::NewScaleFactor' has a wrong offset!");

// Function G01.GzGameUserSettings.SetShowLobbyOldScreenEffect
// 0x0001 (0x0001 - 0x0000)
struct GzGameUserSettings_SetShowLobbyOldScreenEffect final
{
public:
	bool                                          bInShowOldScreenEffect;                            // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzGameUserSettings_SetShowLobbyOldScreenEffect) == 0x000001, "Wrong alignment on GzGameUserSettings_SetShowLobbyOldScreenEffect");
static_assert(sizeof(GzGameUserSettings_SetShowLobbyOldScreenEffect) == 0x000001, "Wrong size on GzGameUserSettings_SetShowLobbyOldScreenEffect");
static_assert(offsetof(GzGameUserSettings_SetShowLobbyOldScreenEffect, bInShowOldScreenEffect) == 0x000000, "Member 'GzGameUserSettings_SetShowLobbyOldScreenEffect::bInShowOldScreenEffect' has a wrong offset!");

// Function G01.GzGameUserSettings.SetSidearmAmmoAutoPickUpEnabled
// 0x0001 (0x0001 - 0x0000)
struct GzGameUserSettings_SetSidearmAmmoAutoPickUpEnabled final
{
public:
	bool                                          Value;                                             // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzGameUserSettings_SetSidearmAmmoAutoPickUpEnabled) == 0x000001, "Wrong alignment on GzGameUserSettings_SetSidearmAmmoAutoPickUpEnabled");
static_assert(sizeof(GzGameUserSettings_SetSidearmAmmoAutoPickUpEnabled) == 0x000001, "Wrong size on GzGameUserSettings_SetSidearmAmmoAutoPickUpEnabled");
static_assert(offsetof(GzGameUserSettings_SetSidearmAmmoAutoPickUpEnabled, Value) == 0x000000, "Member 'GzGameUserSettings_SetSidearmAmmoAutoPickUpEnabled::Value' has a wrong offset!");

// Function G01.GzGameUserSettings.SetToggleAimingMode
// 0x0001 (0x0001 - 0x0000)
struct GzGameUserSettings_SetToggleAimingMode final
{
public:
	bool                                          bToggle;                                           // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzGameUserSettings_SetToggleAimingMode) == 0x000001, "Wrong alignment on GzGameUserSettings_SetToggleAimingMode");
static_assert(sizeof(GzGameUserSettings_SetToggleAimingMode) == 0x000001, "Wrong size on GzGameUserSettings_SetToggleAimingMode");
static_assert(offsetof(GzGameUserSettings_SetToggleAimingMode, bToggle) == 0x000000, "Member 'GzGameUserSettings_SetToggleAimingMode::bToggle' has a wrong offset!");

// Function G01.GzGameUserSettings.SetToggleSprint
// 0x0001 (0x0001 - 0x0000)
struct GzGameUserSettings_SetToggleSprint final
{
public:
	bool                                          bToggle;                                           // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzGameUserSettings_SetToggleSprint) == 0x000001, "Wrong alignment on GzGameUserSettings_SetToggleSprint");
static_assert(sizeof(GzGameUserSettings_SetToggleSprint) == 0x000001, "Wrong size on GzGameUserSettings_SetToggleSprint");
static_assert(offsetof(GzGameUserSettings_SetToggleSprint, bToggle) == 0x000000, "Member 'GzGameUserSettings_SetToggleSprint::bToggle' has a wrong offset!");

// Function G01.GzGameUserSettings.SetUIAspectRatio
// 0x0004 (0x0004 - 0x0000)
struct GzGameUserSettings_SetUIAspectRatio final
{
public:
	float                                         Ratio;                                             // 0x0000(0x0004)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzGameUserSettings_SetUIAspectRatio) == 0x000004, "Wrong alignment on GzGameUserSettings_SetUIAspectRatio");
static_assert(sizeof(GzGameUserSettings_SetUIAspectRatio) == 0x000004, "Wrong size on GzGameUserSettings_SetUIAspectRatio");
static_assert(offsetof(GzGameUserSettings_SetUIAspectRatio, Ratio) == 0x000000, "Member 'GzGameUserSettings_SetUIAspectRatio::Ratio' has a wrong offset!");

// Function G01.GzGameUserSettings.SetVerticalAimSensitivityScaleFactor
// 0x0004 (0x0004 - 0x0000)
struct GzGameUserSettings_SetVerticalAimSensitivityScaleFactor final
{
public:
	float                                         NewScaleFactor;                                    // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzGameUserSettings_SetVerticalAimSensitivityScaleFactor) == 0x000004, "Wrong alignment on GzGameUserSettings_SetVerticalAimSensitivityScaleFactor");
static_assert(sizeof(GzGameUserSettings_SetVerticalAimSensitivityScaleFactor) == 0x000004, "Wrong size on GzGameUserSettings_SetVerticalAimSensitivityScaleFactor");
static_assert(offsetof(GzGameUserSettings_SetVerticalAimSensitivityScaleFactor, NewScaleFactor) == 0x000000, "Member 'GzGameUserSettings_SetVerticalAimSensitivityScaleFactor::NewScaleFactor' has a wrong offset!");

// Function G01.GzGameUserSettings.SetVerticalInputInverted
// 0x0001 (0x0001 - 0x0000)
struct GzGameUserSettings_SetVerticalInputInverted final
{
public:
	bool                                          bInverted;                                         // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzGameUserSettings_SetVerticalInputInverted) == 0x000001, "Wrong alignment on GzGameUserSettings_SetVerticalInputInverted");
static_assert(sizeof(GzGameUserSettings_SetVerticalInputInverted) == 0x000001, "Wrong size on GzGameUserSettings_SetVerticalInputInverted");
static_assert(offsetof(GzGameUserSettings_SetVerticalInputInverted, bInverted) == 0x000000, "Member 'GzGameUserSettings_SetVerticalInputInverted::bInverted' has a wrong offset!");

// Function G01.GzGameUserSettings.SetVerticalLookSensitivityScaleFactor
// 0x0004 (0x0004 - 0x0000)
struct GzGameUserSettings_SetVerticalLookSensitivityScaleFactor final
{
public:
	float                                         NewScaleFactor;                                    // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzGameUserSettings_SetVerticalLookSensitivityScaleFactor) == 0x000004, "Wrong alignment on GzGameUserSettings_SetVerticalLookSensitivityScaleFactor");
static_assert(sizeof(GzGameUserSettings_SetVerticalLookSensitivityScaleFactor) == 0x000004, "Wrong size on GzGameUserSettings_SetVerticalLookSensitivityScaleFactor");
static_assert(offsetof(GzGameUserSettings_SetVerticalLookSensitivityScaleFactor, NewScaleFactor) == 0x000000, "Member 'GzGameUserSettings_SetVerticalLookSensitivityScaleFactor::NewScaleFactor' has a wrong offset!");

// Function G01.GzGameUserSettings.SetVerticalSnipeSensitivityScaleFactor
// 0x0004 (0x0004 - 0x0000)
struct GzGameUserSettings_SetVerticalSnipeSensitivityScaleFactor final
{
public:
	float                                         NewScaleFactor;                                    // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzGameUserSettings_SetVerticalSnipeSensitivityScaleFactor) == 0x000004, "Wrong alignment on GzGameUserSettings_SetVerticalSnipeSensitivityScaleFactor");
static_assert(sizeof(GzGameUserSettings_SetVerticalSnipeSensitivityScaleFactor) == 0x000004, "Wrong size on GzGameUserSettings_SetVerticalSnipeSensitivityScaleFactor");
static_assert(offsetof(GzGameUserSettings_SetVerticalSnipeSensitivityScaleFactor, NewScaleFactor) == 0x000000, "Member 'GzGameUserSettings_SetVerticalSnipeSensitivityScaleFactor::NewScaleFactor' has a wrong offset!");

// Function G01.GzGameUserSettings.SetVoiceChatInputDeviceId
// 0x0010 (0x0010 - 0x0000)
struct GzGameUserSettings_SetVoiceChatInputDeviceId final
{
public:
	class FString                                 DeviceID;                                          // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzGameUserSettings_SetVoiceChatInputDeviceId) == 0x000008, "Wrong alignment on GzGameUserSettings_SetVoiceChatInputDeviceId");
static_assert(sizeof(GzGameUserSettings_SetVoiceChatInputDeviceId) == 0x000010, "Wrong size on GzGameUserSettings_SetVoiceChatInputDeviceId");
static_assert(offsetof(GzGameUserSettings_SetVoiceChatInputDeviceId, DeviceID) == 0x000000, "Member 'GzGameUserSettings_SetVoiceChatInputDeviceId::DeviceID' has a wrong offset!");

// Function G01.GzGameUserSettings.SetVoiceChatOutputDeviceId
// 0x0010 (0x0010 - 0x0000)
struct GzGameUserSettings_SetVoiceChatOutputDeviceId final
{
public:
	class FString                                 DeviceID;                                          // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzGameUserSettings_SetVoiceChatOutputDeviceId) == 0x000008, "Wrong alignment on GzGameUserSettings_SetVoiceChatOutputDeviceId");
static_assert(sizeof(GzGameUserSettings_SetVoiceChatOutputDeviceId) == 0x000010, "Wrong size on GzGameUserSettings_SetVoiceChatOutputDeviceId");
static_assert(offsetof(GzGameUserSettings_SetVoiceChatOutputDeviceId, DeviceID) == 0x000000, "Member 'GzGameUserSettings_SetVoiceChatOutputDeviceId::DeviceID' has a wrong offset!");

// Function G01.GzGameUserSettings.SetVoiceChatState
// 0x0001 (0x0001 - 0x0000)
struct GzGameUserSettings_SetVoiceChatState final
{
public:
	EGzVoiceChatState                             NewValue;                                          // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzGameUserSettings_SetVoiceChatState) == 0x000001, "Wrong alignment on GzGameUserSettings_SetVoiceChatState");
static_assert(sizeof(GzGameUserSettings_SetVoiceChatState) == 0x000001, "Wrong size on GzGameUserSettings_SetVoiceChatState");
static_assert(offsetof(GzGameUserSettings_SetVoiceChatState, NewValue) == 0x000000, "Member 'GzGameUserSettings_SetVoiceChatState::NewValue' has a wrong offset!");

// Function G01.GzGameUserSettings.SetVoiceChatVolumeScale
// 0x0004 (0x0004 - 0x0000)
struct GzGameUserSettings_SetVoiceChatVolumeScale final
{
public:
	float                                         NewScaleFactor;                                    // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzGameUserSettings_SetVoiceChatVolumeScale) == 0x000004, "Wrong alignment on GzGameUserSettings_SetVoiceChatVolumeScale");
static_assert(sizeof(GzGameUserSettings_SetVoiceChatVolumeScale) == 0x000004, "Wrong size on GzGameUserSettings_SetVoiceChatVolumeScale");
static_assert(offsetof(GzGameUserSettings_SetVoiceChatVolumeScale, NewScaleFactor) == 0x000000, "Member 'GzGameUserSettings_SetVoiceChatVolumeScale::NewScaleFactor' has a wrong offset!");

// Function G01.GzGameUserSettings.SetVovVolumeScale
// 0x0004 (0x0004 - 0x0000)
struct GzGameUserSettings_SetVovVolumeScale final
{
public:
	float                                         NewScaleFactor;                                    // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzGameUserSettings_SetVovVolumeScale) == 0x000004, "Wrong alignment on GzGameUserSettings_SetVovVolumeScale");
static_assert(sizeof(GzGameUserSettings_SetVovVolumeScale) == 0x000004, "Wrong size on GzGameUserSettings_SetVovVolumeScale");
static_assert(offsetof(GzGameUserSettings_SetVovVolumeScale, NewScaleFactor) == 0x000000, "Member 'GzGameUserSettings_SetVovVolumeScale::NewScaleFactor' has a wrong offset!");

// Function G01.GzGameUserSettings.ShowDamageNumbers
// 0x0001 (0x0001 - 0x0000)
struct GzGameUserSettings_ShowDamageNumbers final
{
public:
	bool                                          bInShowDamageNumbers;                              // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzGameUserSettings_ShowDamageNumbers) == 0x000001, "Wrong alignment on GzGameUserSettings_ShowDamageNumbers");
static_assert(sizeof(GzGameUserSettings_ShowDamageNumbers) == 0x000001, "Wrong size on GzGameUserSettings_ShowDamageNumbers");
static_assert(offsetof(GzGameUserSettings_ShowDamageNumbers, bInShowDamageNumbers) == 0x000000, "Member 'GzGameUserSettings_ShowDamageNumbers::bInShowDamageNumbers' has a wrong offset!");

// Function G01.GzGameUserSettings.ShowShowComparisonTooltip
// 0x0001 (0x0001 - 0x0000)
struct GzGameUserSettings_ShowShowComparisonTooltip final
{
public:
	bool                                          bInShowComparisonTooltip;                          // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzGameUserSettings_ShowShowComparisonTooltip) == 0x000001, "Wrong alignment on GzGameUserSettings_ShowShowComparisonTooltip");
static_assert(sizeof(GzGameUserSettings_ShowShowComparisonTooltip) == 0x000001, "Wrong size on GzGameUserSettings_ShowShowComparisonTooltip");
static_assert(offsetof(GzGameUserSettings_ShowShowComparisonTooltip, bInShowComparisonTooltip) == 0x000000, "Member 'GzGameUserSettings_ShowShowComparisonTooltip::bInShowComparisonTooltip' has a wrong offset!");

// Function G01.GzGameUserSettings.AreLootBeamsEnabled
// 0x0001 (0x0001 - 0x0000)
struct GzGameUserSettings_AreLootBeamsEnabled final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzGameUserSettings_AreLootBeamsEnabled) == 0x000001, "Wrong alignment on GzGameUserSettings_AreLootBeamsEnabled");
static_assert(sizeof(GzGameUserSettings_AreLootBeamsEnabled) == 0x000001, "Wrong size on GzGameUserSettings_AreLootBeamsEnabled");
static_assert(offsetof(GzGameUserSettings_AreLootBeamsEnabled, ReturnValue) == 0x000000, "Member 'GzGameUserSettings_AreLootBeamsEnabled::ReturnValue' has a wrong offset!");

// Function G01.GzGameUserSettings.ArePerformanceStatsEnabled
// 0x0001 (0x0001 - 0x0000)
struct GzGameUserSettings_ArePerformanceStatsEnabled final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzGameUserSettings_ArePerformanceStatsEnabled) == 0x000001, "Wrong alignment on GzGameUserSettings_ArePerformanceStatsEnabled");
static_assert(sizeof(GzGameUserSettings_ArePerformanceStatsEnabled) == 0x000001, "Wrong size on GzGameUserSettings_ArePerformanceStatsEnabled");
static_assert(offsetof(GzGameUserSettings_ArePerformanceStatsEnabled, ReturnValue) == 0x000000, "Member 'GzGameUserSettings_ArePerformanceStatsEnabled::ReturnValue' has a wrong offset!");

// Function G01.GzGameUserSettings.AreSettingsDirty
// 0x0001 (0x0001 - 0x0000)
struct GzGameUserSettings_AreSettingsDirty final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzGameUserSettings_AreSettingsDirty) == 0x000001, "Wrong alignment on GzGameUserSettings_AreSettingsDirty");
static_assert(sizeof(GzGameUserSettings_AreSettingsDirty) == 0x000001, "Wrong size on GzGameUserSettings_AreSettingsDirty");
static_assert(offsetof(GzGameUserSettings_AreSettingsDirty, ReturnValue) == 0x000000, "Member 'GzGameUserSettings_AreSettingsDirty::ReturnValue' has a wrong offset!");

// Function G01.GzGameUserSettings.AreVideoSettingsDirty
// 0x0001 (0x0001 - 0x0000)
struct GzGameUserSettings_AreVideoSettingsDirty final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzGameUserSettings_AreVideoSettingsDirty) == 0x000001, "Wrong alignment on GzGameUserSettings_AreVideoSettingsDirty");
static_assert(sizeof(GzGameUserSettings_AreVideoSettingsDirty) == 0x000001, "Wrong size on GzGameUserSettings_AreVideoSettingsDirty");
static_assert(offsetof(GzGameUserSettings_AreVideoSettingsDirty, ReturnValue) == 0x000000, "Member 'GzGameUserSettings_AreVideoSettingsDirty::ReturnValue' has a wrong offset!");

// Function G01.GzGameUserSettings.GetAcesGamutCompression
// 0x0004 (0x0004 - 0x0000)
struct GzGameUserSettings_GetAcesGamutCompression final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzGameUserSettings_GetAcesGamutCompression) == 0x000004, "Wrong alignment on GzGameUserSettings_GetAcesGamutCompression");
static_assert(sizeof(GzGameUserSettings_GetAcesGamutCompression) == 0x000004, "Wrong size on GzGameUserSettings_GetAcesGamutCompression");
static_assert(offsetof(GzGameUserSettings_GetAcesGamutCompression, ReturnValue) == 0x000000, "Member 'GzGameUserSettings_GetAcesGamutCompression::ReturnValue' has a wrong offset!");

// Function G01.GzGameUserSettings.GetAcesSceneColorMultiplier
// 0x0004 (0x0004 - 0x0000)
struct GzGameUserSettings_GetAcesSceneColorMultiplier final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzGameUserSettings_GetAcesSceneColorMultiplier) == 0x000004, "Wrong alignment on GzGameUserSettings_GetAcesSceneColorMultiplier");
static_assert(sizeof(GzGameUserSettings_GetAcesSceneColorMultiplier) == 0x000004, "Wrong size on GzGameUserSettings_GetAcesSceneColorMultiplier");
static_assert(offsetof(GzGameUserSettings_GetAcesSceneColorMultiplier, ReturnValue) == 0x000000, "Member 'GzGameUserSettings_GetAcesSceneColorMultiplier::ReturnValue' has a wrong offset!");

// Function G01.GzGameUserSettings.GetActiveMonitorResolution
// 0x0008 (0x0008 - 0x0000)
struct GzGameUserSettings_GetActiveMonitorResolution final
{
public:
	struct FIntPoint                              ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzGameUserSettings_GetActiveMonitorResolution) == 0x000004, "Wrong alignment on GzGameUserSettings_GetActiveMonitorResolution");
static_assert(sizeof(GzGameUserSettings_GetActiveMonitorResolution) == 0x000008, "Wrong size on GzGameUserSettings_GetActiveMonitorResolution");
static_assert(offsetof(GzGameUserSettings_GetActiveMonitorResolution, ReturnValue) == 0x000000, "Member 'GzGameUserSettings_GetActiveMonitorResolution::ReturnValue' has a wrong offset!");

// Function G01.GzGameUserSettings.GetAimAssistPreset
// 0x0010 (0x0010 - 0x0000)
struct GzGameUserSettings_GetAimAssistPreset final
{
public:
	class FString                                 ReturnValue;                                       // 0x0000(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzGameUserSettings_GetAimAssistPreset) == 0x000008, "Wrong alignment on GzGameUserSettings_GetAimAssistPreset");
static_assert(sizeof(GzGameUserSettings_GetAimAssistPreset) == 0x000010, "Wrong size on GzGameUserSettings_GetAimAssistPreset");
static_assert(offsetof(GzGameUserSettings_GetAimAssistPreset, ReturnValue) == 0x000000, "Member 'GzGameUserSettings_GetAimAssistPreset::ReturnValue' has a wrong offset!");

// Function G01.GzGameUserSettings.GetAntialiasingMethod
// 0x0004 (0x0004 - 0x0000)
struct GzGameUserSettings_GetAntialiasingMethod final
{
public:
	int32                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzGameUserSettings_GetAntialiasingMethod) == 0x000004, "Wrong alignment on GzGameUserSettings_GetAntialiasingMethod");
static_assert(sizeof(GzGameUserSettings_GetAntialiasingMethod) == 0x000004, "Wrong size on GzGameUserSettings_GetAntialiasingMethod");
static_assert(offsetof(GzGameUserSettings_GetAntialiasingMethod, ReturnValue) == 0x000000, "Member 'GzGameUserSettings_GetAntialiasingMethod::ReturnValue' has a wrong offset!");

// Function G01.GzGameUserSettings.GetAutoLoginEnabled
// 0x0001 (0x0001 - 0x0000)
struct GzGameUserSettings_GetAutoLoginEnabled final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzGameUserSettings_GetAutoLoginEnabled) == 0x000001, "Wrong alignment on GzGameUserSettings_GetAutoLoginEnabled");
static_assert(sizeof(GzGameUserSettings_GetAutoLoginEnabled) == 0x000001, "Wrong size on GzGameUserSettings_GetAutoLoginEnabled");
static_assert(offsetof(GzGameUserSettings_GetAutoLoginEnabled, ReturnValue) == 0x000000, "Member 'GzGameUserSettings_GetAutoLoginEnabled::ReturnValue' has a wrong offset!");

// Function G01.GzGameUserSettings.GetAutomaticallyConnectToHostHideout
// 0x0001 (0x0001 - 0x0000)
struct GzGameUserSettings_GetAutomaticallyConnectToHostHideout final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzGameUserSettings_GetAutomaticallyConnectToHostHideout) == 0x000001, "Wrong alignment on GzGameUserSettings_GetAutomaticallyConnectToHostHideout");
static_assert(sizeof(GzGameUserSettings_GetAutomaticallyConnectToHostHideout) == 0x000001, "Wrong size on GzGameUserSettings_GetAutomaticallyConnectToHostHideout");
static_assert(offsetof(GzGameUserSettings_GetAutomaticallyConnectToHostHideout, ReturnValue) == 0x000000, "Member 'GzGameUserSettings_GetAutomaticallyConnectToHostHideout::ReturnValue' has a wrong offset!");

// Function G01.GzGameUserSettings.GetAutoPickUpEnabled
// 0x0001 (0x0001 - 0x0000)
struct GzGameUserSettings_GetAutoPickUpEnabled final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzGameUserSettings_GetAutoPickUpEnabled) == 0x000001, "Wrong alignment on GzGameUserSettings_GetAutoPickUpEnabled");
static_assert(sizeof(GzGameUserSettings_GetAutoPickUpEnabled) == 0x000001, "Wrong size on GzGameUserSettings_GetAutoPickUpEnabled");
static_assert(offsetof(GzGameUserSettings_GetAutoPickUpEnabled, ReturnValue) == 0x000000, "Member 'GzGameUserSettings_GetAutoPickUpEnabled::ReturnValue' has a wrong offset!");

// Function G01.GzGameUserSettings.GetCharacterVoiceVolumeScale
// 0x0004 (0x0004 - 0x0000)
struct GzGameUserSettings_GetCharacterVoiceVolumeScale final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzGameUserSettings_GetCharacterVoiceVolumeScale) == 0x000004, "Wrong alignment on GzGameUserSettings_GetCharacterVoiceVolumeScale");
static_assert(sizeof(GzGameUserSettings_GetCharacterVoiceVolumeScale) == 0x000004, "Wrong size on GzGameUserSettings_GetCharacterVoiceVolumeScale");
static_assert(offsetof(GzGameUserSettings_GetCharacterVoiceVolumeScale, ReturnValue) == 0x000000, "Member 'GzGameUserSettings_GetCharacterVoiceVolumeScale::ReturnValue' has a wrong offset!");

// Function G01.GzGameUserSettings.GetColorVisionDeficiency
// 0x0001 (0x0001 - 0x0000)
struct GzGameUserSettings_GetColorVisionDeficiency final
{
public:
	EColorVisionDeficiency                        ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzGameUserSettings_GetColorVisionDeficiency) == 0x000001, "Wrong alignment on GzGameUserSettings_GetColorVisionDeficiency");
static_assert(sizeof(GzGameUserSettings_GetColorVisionDeficiency) == 0x000001, "Wrong size on GzGameUserSettings_GetColorVisionDeficiency");
static_assert(offsetof(GzGameUserSettings_GetColorVisionDeficiency, ReturnValue) == 0x000000, "Member 'GzGameUserSettings_GetColorVisionDeficiency::ReturnValue' has a wrong offset!");

// Function G01.GzGameUserSettings.GetCurrentLanguage
// 0x0010 (0x0010 - 0x0000)
struct GzGameUserSettings_GetCurrentLanguage final
{
public:
	class FString                                 ReturnValue;                                       // 0x0000(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzGameUserSettings_GetCurrentLanguage) == 0x000008, "Wrong alignment on GzGameUserSettings_GetCurrentLanguage");
static_assert(sizeof(GzGameUserSettings_GetCurrentLanguage) == 0x000010, "Wrong size on GzGameUserSettings_GetCurrentLanguage");
static_assert(offsetof(GzGameUserSettings_GetCurrentLanguage, ReturnValue) == 0x000000, "Member 'GzGameUserSettings_GetCurrentLanguage::ReturnValue' has a wrong offset!");

// Function G01.GzGameUserSettings.GetDeadZone
// 0x0004 (0x0004 - 0x0000)
struct GzGameUserSettings_GetDeadZone final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzGameUserSettings_GetDeadZone) == 0x000004, "Wrong alignment on GzGameUserSettings_GetDeadZone");
static_assert(sizeof(GzGameUserSettings_GetDeadZone) == 0x000004, "Wrong size on GzGameUserSettings_GetDeadZone");
static_assert(offsetof(GzGameUserSettings_GetDeadZone, ReturnValue) == 0x000000, "Member 'GzGameUserSettings_GetDeadZone::ReturnValue' has a wrong offset!");

// Function G01.GzGameUserSettings.GetDevNotificationsEnabled
// 0x0001 (0x0001 - 0x0000)
struct GzGameUserSettings_GetDevNotificationsEnabled final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzGameUserSettings_GetDevNotificationsEnabled) == 0x000001, "Wrong alignment on GzGameUserSettings_GetDevNotificationsEnabled");
static_assert(sizeof(GzGameUserSettings_GetDevNotificationsEnabled) == 0x000001, "Wrong size on GzGameUserSettings_GetDevNotificationsEnabled");
static_assert(offsetof(GzGameUserSettings_GetDevNotificationsEnabled, ReturnValue) == 0x000000, "Member 'GzGameUserSettings_GetDevNotificationsEnabled::ReturnValue' has a wrong offset!");

// Function G01.GzGameUserSettings.GetDisplayGamma
// 0x0004 (0x0004 - 0x0000)
struct GzGameUserSettings_GetDisplayGamma final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzGameUserSettings_GetDisplayGamma) == 0x000004, "Wrong alignment on GzGameUserSettings_GetDisplayGamma");
static_assert(sizeof(GzGameUserSettings_GetDisplayGamma) == 0x000004, "Wrong size on GzGameUserSettings_GetDisplayGamma");
static_assert(offsetof(GzGameUserSettings_GetDisplayGamma, ReturnValue) == 0x000000, "Member 'GzGameUserSettings_GetDisplayGamma::ReturnValue' has a wrong offset!");

// Function G01.GzGameUserSettings.GetDisplayIndex
// 0x0004 (0x0004 - 0x0000)
struct GzGameUserSettings_GetDisplayIndex final
{
public:
	int32                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzGameUserSettings_GetDisplayIndex) == 0x000004, "Wrong alignment on GzGameUserSettings_GetDisplayIndex");
static_assert(sizeof(GzGameUserSettings_GetDisplayIndex) == 0x000004, "Wrong size on GzGameUserSettings_GetDisplayIndex");
static_assert(offsetof(GzGameUserSettings_GetDisplayIndex, ReturnValue) == 0x000000, "Member 'GzGameUserSettings_GetDisplayIndex::ReturnValue' has a wrong offset!");

// Function G01.GzGameUserSettings.GetEnableAdaptiveTriggers
// 0x0001 (0x0001 - 0x0000)
struct GzGameUserSettings_GetEnableAdaptiveTriggers final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzGameUserSettings_GetEnableAdaptiveTriggers) == 0x000001, "Wrong alignment on GzGameUserSettings_GetEnableAdaptiveTriggers");
static_assert(sizeof(GzGameUserSettings_GetEnableAdaptiveTriggers) == 0x000001, "Wrong size on GzGameUserSettings_GetEnableAdaptiveTriggers");
static_assert(offsetof(GzGameUserSettings_GetEnableAdaptiveTriggers, ReturnValue) == 0x000000, "Member 'GzGameUserSettings_GetEnableAdaptiveTriggers::ReturnValue' has a wrong offset!");

// Function G01.GzGameUserSettings.GetEnableHapticsFeedback
// 0x0001 (0x0001 - 0x0000)
struct GzGameUserSettings_GetEnableHapticsFeedback final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzGameUserSettings_GetEnableHapticsFeedback) == 0x000001, "Wrong alignment on GzGameUserSettings_GetEnableHapticsFeedback");
static_assert(sizeof(GzGameUserSettings_GetEnableHapticsFeedback) == 0x000001, "Wrong size on GzGameUserSettings_GetEnableHapticsFeedback");
static_assert(offsetof(GzGameUserSettings_GetEnableHapticsFeedback, ReturnValue) == 0x000000, "Member 'GzGameUserSettings_GetEnableHapticsFeedback::ReturnValue' has a wrong offset!");

// Function G01.GzGameUserSettings.GetFullCatalogAccessEnabled
// 0x0001 (0x0001 - 0x0000)
struct GzGameUserSettings_GetFullCatalogAccessEnabled final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzGameUserSettings_GetFullCatalogAccessEnabled) == 0x000001, "Wrong alignment on GzGameUserSettings_GetFullCatalogAccessEnabled");
static_assert(sizeof(GzGameUserSettings_GetFullCatalogAccessEnabled) == 0x000001, "Wrong size on GzGameUserSettings_GetFullCatalogAccessEnabled");
static_assert(offsetof(GzGameUserSettings_GetFullCatalogAccessEnabled, ReturnValue) == 0x000000, "Member 'GzGameUserSettings_GetFullCatalogAccessEnabled::ReturnValue' has a wrong offset!");

// Function G01.GzGameUserSettings.GetGameMeshMinLODQuality
// 0x0004 (0x0004 - 0x0000)
struct GzGameUserSettings_GetGameMeshMinLODQuality final
{
public:
	int32                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzGameUserSettings_GetGameMeshMinLODQuality) == 0x000004, "Wrong alignment on GzGameUserSettings_GetGameMeshMinLODQuality");
static_assert(sizeof(GzGameUserSettings_GetGameMeshMinLODQuality) == 0x000004, "Wrong size on GzGameUserSettings_GetGameMeshMinLODQuality");
static_assert(offsetof(GzGameUserSettings_GetGameMeshMinLODQuality, ReturnValue) == 0x000000, "Member 'GzGameUserSettings_GetGameMeshMinLODQuality::ReturnValue' has a wrong offset!");

// Function G01.GzGameUserSettings.GetGamepadHorizontalAimSensitivityScale
// 0x0004 (0x0004 - 0x0000)
struct GzGameUserSettings_GetGamepadHorizontalAimSensitivityScale final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzGameUserSettings_GetGamepadHorizontalAimSensitivityScale) == 0x000004, "Wrong alignment on GzGameUserSettings_GetGamepadHorizontalAimSensitivityScale");
static_assert(sizeof(GzGameUserSettings_GetGamepadHorizontalAimSensitivityScale) == 0x000004, "Wrong size on GzGameUserSettings_GetGamepadHorizontalAimSensitivityScale");
static_assert(offsetof(GzGameUserSettings_GetGamepadHorizontalAimSensitivityScale, ReturnValue) == 0x000000, "Member 'GzGameUserSettings_GetGamepadHorizontalAimSensitivityScale::ReturnValue' has a wrong offset!");

// Function G01.GzGameUserSettings.GetGamepadHorizontalLookSensitivityScale
// 0x0004 (0x0004 - 0x0000)
struct GzGameUserSettings_GetGamepadHorizontalLookSensitivityScale final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzGameUserSettings_GetGamepadHorizontalLookSensitivityScale) == 0x000004, "Wrong alignment on GzGameUserSettings_GetGamepadHorizontalLookSensitivityScale");
static_assert(sizeof(GzGameUserSettings_GetGamepadHorizontalLookSensitivityScale) == 0x000004, "Wrong size on GzGameUserSettings_GetGamepadHorizontalLookSensitivityScale");
static_assert(offsetof(GzGameUserSettings_GetGamepadHorizontalLookSensitivityScale, ReturnValue) == 0x000000, "Member 'GzGameUserSettings_GetGamepadHorizontalLookSensitivityScale::ReturnValue' has a wrong offset!");

// Function G01.GzGameUserSettings.GetGamepadHorizontalSnipeSensitivityScale
// 0x0004 (0x0004 - 0x0000)
struct GzGameUserSettings_GetGamepadHorizontalSnipeSensitivityScale final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzGameUserSettings_GetGamepadHorizontalSnipeSensitivityScale) == 0x000004, "Wrong alignment on GzGameUserSettings_GetGamepadHorizontalSnipeSensitivityScale");
static_assert(sizeof(GzGameUserSettings_GetGamepadHorizontalSnipeSensitivityScale) == 0x000004, "Wrong size on GzGameUserSettings_GetGamepadHorizontalSnipeSensitivityScale");
static_assert(offsetof(GzGameUserSettings_GetGamepadHorizontalSnipeSensitivityScale, ReturnValue) == 0x000000, "Member 'GzGameUserSettings_GetGamepadHorizontalSnipeSensitivityScale::ReturnValue' has a wrong offset!");

// Function G01.GzGameUserSettings.GetGamepadProfileIdentifier
// 0x0008 (0x0008 - 0x0000)
struct GzGameUserSettings_GetGamepadProfileIdentifier final
{
public:
	struct FGameplayTag                           ReturnValue;                                       // 0x0000(0x0008)(ConstParm, Parm, OutParm, ReturnParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzGameUserSettings_GetGamepadProfileIdentifier) == 0x000004, "Wrong alignment on GzGameUserSettings_GetGamepadProfileIdentifier");
static_assert(sizeof(GzGameUserSettings_GetGamepadProfileIdentifier) == 0x000008, "Wrong size on GzGameUserSettings_GetGamepadProfileIdentifier");
static_assert(offsetof(GzGameUserSettings_GetGamepadProfileIdentifier, ReturnValue) == 0x000000, "Member 'GzGameUserSettings_GetGamepadProfileIdentifier::ReturnValue' has a wrong offset!");

// Function G01.GzGameUserSettings.GetGamepadVerticalAimSensitivityScale
// 0x0004 (0x0004 - 0x0000)
struct GzGameUserSettings_GetGamepadVerticalAimSensitivityScale final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzGameUserSettings_GetGamepadVerticalAimSensitivityScale) == 0x000004, "Wrong alignment on GzGameUserSettings_GetGamepadVerticalAimSensitivityScale");
static_assert(sizeof(GzGameUserSettings_GetGamepadVerticalAimSensitivityScale) == 0x000004, "Wrong size on GzGameUserSettings_GetGamepadVerticalAimSensitivityScale");
static_assert(offsetof(GzGameUserSettings_GetGamepadVerticalAimSensitivityScale, ReturnValue) == 0x000000, "Member 'GzGameUserSettings_GetGamepadVerticalAimSensitivityScale::ReturnValue' has a wrong offset!");

// Function G01.GzGameUserSettings.GetGamepadVerticalLookSensitivityScale
// 0x0004 (0x0004 - 0x0000)
struct GzGameUserSettings_GetGamepadVerticalLookSensitivityScale final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzGameUserSettings_GetGamepadVerticalLookSensitivityScale) == 0x000004, "Wrong alignment on GzGameUserSettings_GetGamepadVerticalLookSensitivityScale");
static_assert(sizeof(GzGameUserSettings_GetGamepadVerticalLookSensitivityScale) == 0x000004, "Wrong size on GzGameUserSettings_GetGamepadVerticalLookSensitivityScale");
static_assert(offsetof(GzGameUserSettings_GetGamepadVerticalLookSensitivityScale, ReturnValue) == 0x000000, "Member 'GzGameUserSettings_GetGamepadVerticalLookSensitivityScale::ReturnValue' has a wrong offset!");

// Function G01.GzGameUserSettings.GetGamepadVerticalSnipeSensitivityScale
// 0x0004 (0x0004 - 0x0000)
struct GzGameUserSettings_GetGamepadVerticalSnipeSensitivityScale final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzGameUserSettings_GetGamepadVerticalSnipeSensitivityScale) == 0x000004, "Wrong alignment on GzGameUserSettings_GetGamepadVerticalSnipeSensitivityScale");
static_assert(sizeof(GzGameUserSettings_GetGamepadVerticalSnipeSensitivityScale) == 0x000004, "Wrong size on GzGameUserSettings_GetGamepadVerticalSnipeSensitivityScale");
static_assert(offsetof(GzGameUserSettings_GetGamepadVerticalSnipeSensitivityScale, ReturnValue) == 0x000000, "Member 'GzGameUserSettings_GetGamepadVerticalSnipeSensitivityScale::ReturnValue' has a wrong offset!");

// Function G01.GzGameUserSettings.GetHDRUILevel
// 0x0004 (0x0004 - 0x0000)
struct GzGameUserSettings_GetHDRUILevel final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzGameUserSettings_GetHDRUILevel) == 0x000004, "Wrong alignment on GzGameUserSettings_GetHDRUILevel");
static_assert(sizeof(GzGameUserSettings_GetHDRUILevel) == 0x000004, "Wrong size on GzGameUserSettings_GetHDRUILevel");
static_assert(offsetof(GzGameUserSettings_GetHDRUILevel, ReturnValue) == 0x000000, "Member 'GzGameUserSettings_GetHDRUILevel::ReturnValue' has a wrong offset!");

// Function G01.GzGameUserSettings.GetHideoutMeshMinLODQuality
// 0x0004 (0x0004 - 0x0000)
struct GzGameUserSettings_GetHideoutMeshMinLODQuality final
{
public:
	int32                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzGameUserSettings_GetHideoutMeshMinLODQuality) == 0x000004, "Wrong alignment on GzGameUserSettings_GetHideoutMeshMinLODQuality");
static_assert(sizeof(GzGameUserSettings_GetHideoutMeshMinLODQuality) == 0x000004, "Wrong size on GzGameUserSettings_GetHideoutMeshMinLODQuality");
static_assert(offsetof(GzGameUserSettings_GetHideoutMeshMinLODQuality, ReturnValue) == 0x000000, "Member 'GzGameUserSettings_GetHideoutMeshMinLODQuality::ReturnValue' has a wrong offset!");

// Function G01.GzGameUserSettings.GetHorizontalAimSensitivityScaleFactor
// 0x0004 (0x0004 - 0x0000)
struct GzGameUserSettings_GetHorizontalAimSensitivityScaleFactor final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzGameUserSettings_GetHorizontalAimSensitivityScaleFactor) == 0x000004, "Wrong alignment on GzGameUserSettings_GetHorizontalAimSensitivityScaleFactor");
static_assert(sizeof(GzGameUserSettings_GetHorizontalAimSensitivityScaleFactor) == 0x000004, "Wrong size on GzGameUserSettings_GetHorizontalAimSensitivityScaleFactor");
static_assert(offsetof(GzGameUserSettings_GetHorizontalAimSensitivityScaleFactor, ReturnValue) == 0x000000, "Member 'GzGameUserSettings_GetHorizontalAimSensitivityScaleFactor::ReturnValue' has a wrong offset!");

// Function G01.GzGameUserSettings.GetHorizontalLookSensitivityScaleFactor
// 0x0004 (0x0004 - 0x0000)
struct GzGameUserSettings_GetHorizontalLookSensitivityScaleFactor final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzGameUserSettings_GetHorizontalLookSensitivityScaleFactor) == 0x000004, "Wrong alignment on GzGameUserSettings_GetHorizontalLookSensitivityScaleFactor");
static_assert(sizeof(GzGameUserSettings_GetHorizontalLookSensitivityScaleFactor) == 0x000004, "Wrong size on GzGameUserSettings_GetHorizontalLookSensitivityScaleFactor");
static_assert(offsetof(GzGameUserSettings_GetHorizontalLookSensitivityScaleFactor, ReturnValue) == 0x000000, "Member 'GzGameUserSettings_GetHorizontalLookSensitivityScaleFactor::ReturnValue' has a wrong offset!");

// Function G01.GzGameUserSettings.GetHorizontalSnipeSensitivityScaleFactor
// 0x0004 (0x0004 - 0x0000)
struct GzGameUserSettings_GetHorizontalSnipeSensitivityScaleFactor final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzGameUserSettings_GetHorizontalSnipeSensitivityScaleFactor) == 0x000004, "Wrong alignment on GzGameUserSettings_GetHorizontalSnipeSensitivityScaleFactor");
static_assert(sizeof(GzGameUserSettings_GetHorizontalSnipeSensitivityScaleFactor) == 0x000004, "Wrong size on GzGameUserSettings_GetHorizontalSnipeSensitivityScaleFactor");
static_assert(offsetof(GzGameUserSettings_GetHorizontalSnipeSensitivityScaleFactor, ReturnValue) == 0x000000, "Member 'GzGameUserSettings_GetHorizontalSnipeSensitivityScaleFactor::ReturnValue' has a wrong offset!");

// Function G01.GzGameUserSettings.GetIsAdvancedKeyBindings
// 0x0001 (0x0001 - 0x0000)
struct GzGameUserSettings_GetIsAdvancedKeyBindings final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzGameUserSettings_GetIsAdvancedKeyBindings) == 0x000001, "Wrong alignment on GzGameUserSettings_GetIsAdvancedKeyBindings");
static_assert(sizeof(GzGameUserSettings_GetIsAdvancedKeyBindings) == 0x000001, "Wrong size on GzGameUserSettings_GetIsAdvancedKeyBindings");
static_assert(offsetof(GzGameUserSettings_GetIsAdvancedKeyBindings, ReturnValue) == 0x000000, "Member 'GzGameUserSettings_GetIsAdvancedKeyBindings::ReturnValue' has a wrong offset!");

// Function G01.GzGameUserSettings.GetLanguages
// 0x0010 (0x0010 - 0x0000)
struct GzGameUserSettings_GetLanguages final
{
public:
	TArray<class FString>                         ReturnValue;                                       // 0x0000(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzGameUserSettings_GetLanguages) == 0x000008, "Wrong alignment on GzGameUserSettings_GetLanguages");
static_assert(sizeof(GzGameUserSettings_GetLanguages) == 0x000010, "Wrong size on GzGameUserSettings_GetLanguages");
static_assert(offsetof(GzGameUserSettings_GetLanguages, ReturnValue) == 0x000000, "Member 'GzGameUserSettings_GetLanguages::ReturnValue' has a wrong offset!");

// Function G01.GzGameUserSettings.GetLastConfirmedDisplayIndex
// 0x0004 (0x0004 - 0x0000)
struct GzGameUserSettings_GetLastConfirmedDisplayIndex final
{
public:
	int32                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzGameUserSettings_GetLastConfirmedDisplayIndex) == 0x000004, "Wrong alignment on GzGameUserSettings_GetLastConfirmedDisplayIndex");
static_assert(sizeof(GzGameUserSettings_GetLastConfirmedDisplayIndex) == 0x000004, "Wrong size on GzGameUserSettings_GetLastConfirmedDisplayIndex");
static_assert(offsetof(GzGameUserSettings_GetLastConfirmedDisplayIndex, ReturnValue) == 0x000000, "Member 'GzGameUserSettings_GetLastConfirmedDisplayIndex::ReturnValue' has a wrong offset!");

// Function G01.GzGameUserSettings.GetMainVolumeScale
// 0x0004 (0x0004 - 0x0000)
struct GzGameUserSettings_GetMainVolumeScale final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzGameUserSettings_GetMainVolumeScale) == 0x000004, "Wrong alignment on GzGameUserSettings_GetMainVolumeScale");
static_assert(sizeof(GzGameUserSettings_GetMainVolumeScale) == 0x000004, "Wrong size on GzGameUserSettings_GetMainVolumeScale");
static_assert(offsetof(GzGameUserSettings_GetMainVolumeScale, ReturnValue) == 0x000000, "Member 'GzGameUserSettings_GetMainVolumeScale::ReturnValue' has a wrong offset!");

// Function G01.GzGameUserSettings.GetMatchStateAnnouncerVolumeScale
// 0x0004 (0x0004 - 0x0000)
struct GzGameUserSettings_GetMatchStateAnnouncerVolumeScale final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzGameUserSettings_GetMatchStateAnnouncerVolumeScale) == 0x000004, "Wrong alignment on GzGameUserSettings_GetMatchStateAnnouncerVolumeScale");
static_assert(sizeof(GzGameUserSettings_GetMatchStateAnnouncerVolumeScale) == 0x000004, "Wrong size on GzGameUserSettings_GetMatchStateAnnouncerVolumeScale");
static_assert(offsetof(GzGameUserSettings_GetMatchStateAnnouncerVolumeScale, ReturnValue) == 0x000000, "Member 'GzGameUserSettings_GetMatchStateAnnouncerVolumeScale::ReturnValue' has a wrong offset!");

// Function G01.GzGameUserSettings.GetMicrophoneSensitivity
// 0x0004 (0x0004 - 0x0000)
struct GzGameUserSettings_GetMicrophoneSensitivity final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzGameUserSettings_GetMicrophoneSensitivity) == 0x000004, "Wrong alignment on GzGameUserSettings_GetMicrophoneSensitivity");
static_assert(sizeof(GzGameUserSettings_GetMicrophoneSensitivity) == 0x000004, "Wrong size on GzGameUserSettings_GetMicrophoneSensitivity");
static_assert(offsetof(GzGameUserSettings_GetMicrophoneSensitivity, ReturnValue) == 0x000000, "Member 'GzGameUserSettings_GetMicrophoneSensitivity::ReturnValue' has a wrong offset!");

// Function G01.GzGameUserSettings.GetMidLuminance
// 0x0004 (0x0004 - 0x0000)
struct GzGameUserSettings_GetMidLuminance final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzGameUserSettings_GetMidLuminance) == 0x000004, "Wrong alignment on GzGameUserSettings_GetMidLuminance");
static_assert(sizeof(GzGameUserSettings_GetMidLuminance) == 0x000004, "Wrong size on GzGameUserSettings_GetMidLuminance");
static_assert(offsetof(GzGameUserSettings_GetMidLuminance, ReturnValue) == 0x000000, "Member 'GzGameUserSettings_GetMidLuminance::ReturnValue' has a wrong offset!");

// Function G01.GzGameUserSettings.GetMinLuminanceLog10
// 0x0004 (0x0004 - 0x0000)
struct GzGameUserSettings_GetMinLuminanceLog10 final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzGameUserSettings_GetMinLuminanceLog10) == 0x000004, "Wrong alignment on GzGameUserSettings_GetMinLuminanceLog10");
static_assert(sizeof(GzGameUserSettings_GetMinLuminanceLog10) == 0x000004, "Wrong size on GzGameUserSettings_GetMinLuminanceLog10");
static_assert(offsetof(GzGameUserSettings_GetMinLuminanceLog10, ReturnValue) == 0x000000, "Member 'GzGameUserSettings_GetMinLuminanceLog10::ReturnValue' has a wrong offset!");

// Function G01.GzGameUserSettings.GetMusicVolumeScale
// 0x0004 (0x0004 - 0x0000)
struct GzGameUserSettings_GetMusicVolumeScale final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzGameUserSettings_GetMusicVolumeScale) == 0x000004, "Wrong alignment on GzGameUserSettings_GetMusicVolumeScale");
static_assert(sizeof(GzGameUserSettings_GetMusicVolumeScale) == 0x000004, "Wrong size on GzGameUserSettings_GetMusicVolumeScale");
static_assert(offsetof(GzGameUserSettings_GetMusicVolumeScale, ReturnValue) == 0x000000, "Member 'GzGameUserSettings_GetMusicVolumeScale::ReturnValue' has a wrong offset!");

// Function G01.GzGameUserSettings.GetMuteAudioWhenUnfocused
// 0x0001 (0x0001 - 0x0000)
struct GzGameUserSettings_GetMuteAudioWhenUnfocused final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzGameUserSettings_GetMuteAudioWhenUnfocused) == 0x000001, "Wrong alignment on GzGameUserSettings_GetMuteAudioWhenUnfocused");
static_assert(sizeof(GzGameUserSettings_GetMuteAudioWhenUnfocused) == 0x000001, "Wrong size on GzGameUserSettings_GetMuteAudioWhenUnfocused");
static_assert(offsetof(GzGameUserSettings_GetMuteAudioWhenUnfocused, ReturnValue) == 0x000000, "Member 'GzGameUserSettings_GetMuteAudioWhenUnfocused::ReturnValue' has a wrong offset!");

// Function G01.GzGameUserSettings.GetPersonalAssistantVolumeScale
// 0x0004 (0x0004 - 0x0000)
struct GzGameUserSettings_GetPersonalAssistantVolumeScale final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzGameUserSettings_GetPersonalAssistantVolumeScale) == 0x000004, "Wrong alignment on GzGameUserSettings_GetPersonalAssistantVolumeScale");
static_assert(sizeof(GzGameUserSettings_GetPersonalAssistantVolumeScale) == 0x000004, "Wrong size on GzGameUserSettings_GetPersonalAssistantVolumeScale");
static_assert(offsetof(GzGameUserSettings_GetPersonalAssistantVolumeScale, ReturnValue) == 0x000000, "Member 'GzGameUserSettings_GetPersonalAssistantVolumeScale::ReturnValue' has a wrong offset!");

// Function G01.GzGameUserSettings.GetResolutionScaleValue
// 0x0004 (0x0004 - 0x0000)
struct GzGameUserSettings_GetResolutionScaleValue final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzGameUserSettings_GetResolutionScaleValue) == 0x000004, "Wrong alignment on GzGameUserSettings_GetResolutionScaleValue");
static_assert(sizeof(GzGameUserSettings_GetResolutionScaleValue) == 0x000004, "Wrong size on GzGameUserSettings_GetResolutionScaleValue");
static_assert(offsetof(GzGameUserSettings_GetResolutionScaleValue, ReturnValue) == 0x000000, "Member 'GzGameUserSettings_GetResolutionScaleValue::ReturnValue' has a wrong offset!");

// Function G01.GzGameUserSettings.GetResolutionScalingMethod
// 0x0010 (0x0010 - 0x0000)
struct GzGameUserSettings_GetResolutionScalingMethod final
{
public:
	class FString                                 ReturnValue;                                       // 0x0000(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzGameUserSettings_GetResolutionScalingMethod) == 0x000008, "Wrong alignment on GzGameUserSettings_GetResolutionScalingMethod");
static_assert(sizeof(GzGameUserSettings_GetResolutionScalingMethod) == 0x000010, "Wrong size on GzGameUserSettings_GetResolutionScalingMethod");
static_assert(offsetof(GzGameUserSettings_GetResolutionScalingMethod, ReturnValue) == 0x000000, "Member 'GzGameUserSettings_GetResolutionScalingMethod::ReturnValue' has a wrong offset!");

// Function G01.GzGameUserSettings.GetSfxVolumeScale
// 0x0004 (0x0004 - 0x0000)
struct GzGameUserSettings_GetSfxVolumeScale final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzGameUserSettings_GetSfxVolumeScale) == 0x000004, "Wrong alignment on GzGameUserSettings_GetSfxVolumeScale");
static_assert(sizeof(GzGameUserSettings_GetSfxVolumeScale) == 0x000004, "Wrong size on GzGameUserSettings_GetSfxVolumeScale");
static_assert(offsetof(GzGameUserSettings_GetSfxVolumeScale, ReturnValue) == 0x000000, "Member 'GzGameUserSettings_GetSfxVolumeScale::ReturnValue' has a wrong offset!");

// Function G01.GzGameUserSettings.GetShowLobbyOldScreenEffect
// 0x0001 (0x0001 - 0x0000)
struct GzGameUserSettings_GetShowLobbyOldScreenEffect final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzGameUserSettings_GetShowLobbyOldScreenEffect) == 0x000001, "Wrong alignment on GzGameUserSettings_GetShowLobbyOldScreenEffect");
static_assert(sizeof(GzGameUserSettings_GetShowLobbyOldScreenEffect) == 0x000001, "Wrong size on GzGameUserSettings_GetShowLobbyOldScreenEffect");
static_assert(offsetof(GzGameUserSettings_GetShowLobbyOldScreenEffect, ReturnValue) == 0x000000, "Member 'GzGameUserSettings_GetShowLobbyOldScreenEffect::ReturnValue' has a wrong offset!");

// Function G01.GzGameUserSettings.GetSidearmAmmoAutoPickUpEnabled
// 0x0001 (0x0001 - 0x0000)
struct GzGameUserSettings_GetSidearmAmmoAutoPickUpEnabled final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzGameUserSettings_GetSidearmAmmoAutoPickUpEnabled) == 0x000001, "Wrong alignment on GzGameUserSettings_GetSidearmAmmoAutoPickUpEnabled");
static_assert(sizeof(GzGameUserSettings_GetSidearmAmmoAutoPickUpEnabled) == 0x000001, "Wrong size on GzGameUserSettings_GetSidearmAmmoAutoPickUpEnabled");
static_assert(offsetof(GzGameUserSettings_GetSidearmAmmoAutoPickUpEnabled, ReturnValue) == 0x000000, "Member 'GzGameUserSettings_GetSidearmAmmoAutoPickUpEnabled::ReturnValue' has a wrong offset!");

// Function G01.GzGameUserSettings.GetUIAspectRatio
// 0x0004 (0x0004 - 0x0000)
struct GzGameUserSettings_GetUIAspectRatio final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzGameUserSettings_GetUIAspectRatio) == 0x000004, "Wrong alignment on GzGameUserSettings_GetUIAspectRatio");
static_assert(sizeof(GzGameUserSettings_GetUIAspectRatio) == 0x000004, "Wrong size on GzGameUserSettings_GetUIAspectRatio");
static_assert(offsetof(GzGameUserSettings_GetUIAspectRatio, ReturnValue) == 0x000000, "Member 'GzGameUserSettings_GetUIAspectRatio::ReturnValue' has a wrong offset!");

// Function G01.GzGameUserSettings.GetVerticalAimSensitivityScaleFactor
// 0x0004 (0x0004 - 0x0000)
struct GzGameUserSettings_GetVerticalAimSensitivityScaleFactor final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzGameUserSettings_GetVerticalAimSensitivityScaleFactor) == 0x000004, "Wrong alignment on GzGameUserSettings_GetVerticalAimSensitivityScaleFactor");
static_assert(sizeof(GzGameUserSettings_GetVerticalAimSensitivityScaleFactor) == 0x000004, "Wrong size on GzGameUserSettings_GetVerticalAimSensitivityScaleFactor");
static_assert(offsetof(GzGameUserSettings_GetVerticalAimSensitivityScaleFactor, ReturnValue) == 0x000000, "Member 'GzGameUserSettings_GetVerticalAimSensitivityScaleFactor::ReturnValue' has a wrong offset!");

// Function G01.GzGameUserSettings.GetVerticalLookSensitivityScaleFactor
// 0x0004 (0x0004 - 0x0000)
struct GzGameUserSettings_GetVerticalLookSensitivityScaleFactor final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzGameUserSettings_GetVerticalLookSensitivityScaleFactor) == 0x000004, "Wrong alignment on GzGameUserSettings_GetVerticalLookSensitivityScaleFactor");
static_assert(sizeof(GzGameUserSettings_GetVerticalLookSensitivityScaleFactor) == 0x000004, "Wrong size on GzGameUserSettings_GetVerticalLookSensitivityScaleFactor");
static_assert(offsetof(GzGameUserSettings_GetVerticalLookSensitivityScaleFactor, ReturnValue) == 0x000000, "Member 'GzGameUserSettings_GetVerticalLookSensitivityScaleFactor::ReturnValue' has a wrong offset!");

// Function G01.GzGameUserSettings.GetVerticalSnipeSensitivityScaleFactor
// 0x0004 (0x0004 - 0x0000)
struct GzGameUserSettings_GetVerticalSnipeSensitivityScaleFactor final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzGameUserSettings_GetVerticalSnipeSensitivityScaleFactor) == 0x000004, "Wrong alignment on GzGameUserSettings_GetVerticalSnipeSensitivityScaleFactor");
static_assert(sizeof(GzGameUserSettings_GetVerticalSnipeSensitivityScaleFactor) == 0x000004, "Wrong size on GzGameUserSettings_GetVerticalSnipeSensitivityScaleFactor");
static_assert(offsetof(GzGameUserSettings_GetVerticalSnipeSensitivityScaleFactor, ReturnValue) == 0x000000, "Member 'GzGameUserSettings_GetVerticalSnipeSensitivityScaleFactor::ReturnValue' has a wrong offset!");

// Function G01.GzGameUserSettings.GetVoiceChatInputDeviceId
// 0x0010 (0x0010 - 0x0000)
struct GzGameUserSettings_GetVoiceChatInputDeviceId final
{
public:
	class FString                                 ReturnValue;                                       // 0x0000(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzGameUserSettings_GetVoiceChatInputDeviceId) == 0x000008, "Wrong alignment on GzGameUserSettings_GetVoiceChatInputDeviceId");
static_assert(sizeof(GzGameUserSettings_GetVoiceChatInputDeviceId) == 0x000010, "Wrong size on GzGameUserSettings_GetVoiceChatInputDeviceId");
static_assert(offsetof(GzGameUserSettings_GetVoiceChatInputDeviceId, ReturnValue) == 0x000000, "Member 'GzGameUserSettings_GetVoiceChatInputDeviceId::ReturnValue' has a wrong offset!");

// Function G01.GzGameUserSettings.GetVoiceChatOutputDeviceId
// 0x0010 (0x0010 - 0x0000)
struct GzGameUserSettings_GetVoiceChatOutputDeviceId final
{
public:
	class FString                                 ReturnValue;                                       // 0x0000(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzGameUserSettings_GetVoiceChatOutputDeviceId) == 0x000008, "Wrong alignment on GzGameUserSettings_GetVoiceChatOutputDeviceId");
static_assert(sizeof(GzGameUserSettings_GetVoiceChatOutputDeviceId) == 0x000010, "Wrong size on GzGameUserSettings_GetVoiceChatOutputDeviceId");
static_assert(offsetof(GzGameUserSettings_GetVoiceChatOutputDeviceId, ReturnValue) == 0x000000, "Member 'GzGameUserSettings_GetVoiceChatOutputDeviceId::ReturnValue' has a wrong offset!");

// Function G01.GzGameUserSettings.GetVoiceChatState
// 0x0001 (0x0001 - 0x0000)
struct GzGameUserSettings_GetVoiceChatState final
{
public:
	EGzVoiceChatState                             ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzGameUserSettings_GetVoiceChatState) == 0x000001, "Wrong alignment on GzGameUserSettings_GetVoiceChatState");
static_assert(sizeof(GzGameUserSettings_GetVoiceChatState) == 0x000001, "Wrong size on GzGameUserSettings_GetVoiceChatState");
static_assert(offsetof(GzGameUserSettings_GetVoiceChatState, ReturnValue) == 0x000000, "Member 'GzGameUserSettings_GetVoiceChatState::ReturnValue' has a wrong offset!");

// Function G01.GzGameUserSettings.GetVoiceChatVolumeScale
// 0x0004 (0x0004 - 0x0000)
struct GzGameUserSettings_GetVoiceChatVolumeScale final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzGameUserSettings_GetVoiceChatVolumeScale) == 0x000004, "Wrong alignment on GzGameUserSettings_GetVoiceChatVolumeScale");
static_assert(sizeof(GzGameUserSettings_GetVoiceChatVolumeScale) == 0x000004, "Wrong size on GzGameUserSettings_GetVoiceChatVolumeScale");
static_assert(offsetof(GzGameUserSettings_GetVoiceChatVolumeScale, ReturnValue) == 0x000000, "Member 'GzGameUserSettings_GetVoiceChatVolumeScale::ReturnValue' has a wrong offset!");

// Function G01.GzGameUserSettings.GetVovVolumeScale
// 0x0004 (0x0004 - 0x0000)
struct GzGameUserSettings_GetVovVolumeScale final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzGameUserSettings_GetVovVolumeScale) == 0x000004, "Wrong alignment on GzGameUserSettings_GetVovVolumeScale");
static_assert(sizeof(GzGameUserSettings_GetVovVolumeScale) == 0x000004, "Wrong size on GzGameUserSettings_GetVovVolumeScale");
static_assert(offsetof(GzGameUserSettings_GetVovVolumeScale, ReturnValue) == 0x000000, "Member 'GzGameUserSettings_GetVovVolumeScale::ReturnValue' has a wrong offset!");

// Function G01.GzGameUserSettings.HasMonitorChanged
// 0x0001 (0x0001 - 0x0000)
struct GzGameUserSettings_HasMonitorChanged final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzGameUserSettings_HasMonitorChanged) == 0x000001, "Wrong alignment on GzGameUserSettings_HasMonitorChanged");
static_assert(sizeof(GzGameUserSettings_HasMonitorChanged) == 0x000001, "Wrong size on GzGameUserSettings_HasMonitorChanged");
static_assert(offsetof(GzGameUserSettings_HasMonitorChanged, ReturnValue) == 0x000000, "Member 'GzGameUserSettings_HasMonitorChanged::ReturnValue' has a wrong offset!");

// Function G01.GzGameUserSettings.IsAlignMinimap
// 0x0001 (0x0001 - 0x0000)
struct GzGameUserSettings_IsAlignMinimap final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzGameUserSettings_IsAlignMinimap) == 0x000001, "Wrong alignment on GzGameUserSettings_IsAlignMinimap");
static_assert(sizeof(GzGameUserSettings_IsAlignMinimap) == 0x000001, "Wrong size on GzGameUserSettings_IsAlignMinimap");
static_assert(offsetof(GzGameUserSettings_IsAlignMinimap, ReturnValue) == 0x000000, "Member 'GzGameUserSettings_IsAlignMinimap::ReturnValue' has a wrong offset!");

// Function G01.GzGameUserSettings.IsDLSSSupported
// 0x0001 (0x0001 - 0x0000)
struct GzGameUserSettings_IsDLSSSupported final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzGameUserSettings_IsDLSSSupported) == 0x000001, "Wrong alignment on GzGameUserSettings_IsDLSSSupported");
static_assert(sizeof(GzGameUserSettings_IsDLSSSupported) == 0x000001, "Wrong size on GzGameUserSettings_IsDLSSSupported");
static_assert(offsetof(GzGameUserSettings_IsDLSSSupported, ReturnValue) == 0x000000, "Member 'GzGameUserSettings_IsDLSSSupported::ReturnValue' has a wrong offset!");

// Function G01.GzGameUserSettings.IsHardwareRayTracingEnabled
// 0x0001 (0x0001 - 0x0000)
struct GzGameUserSettings_IsHardwareRayTracingEnabled final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzGameUserSettings_IsHardwareRayTracingEnabled) == 0x000001, "Wrong alignment on GzGameUserSettings_IsHardwareRayTracingEnabled");
static_assert(sizeof(GzGameUserSettings_IsHardwareRayTracingEnabled) == 0x000001, "Wrong size on GzGameUserSettings_IsHardwareRayTracingEnabled");
static_assert(offsetof(GzGameUserSettings_IsHardwareRayTracingEnabled, ReturnValue) == 0x000000, "Member 'GzGameUserSettings_IsHardwareRayTracingEnabled::ReturnValue' has a wrong offset!");

// Function G01.GzGameUserSettings.IsHDROutputEnabled
// 0x0001 (0x0001 - 0x0000)
struct GzGameUserSettings_IsHDROutputEnabled final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzGameUserSettings_IsHDROutputEnabled) == 0x000001, "Wrong alignment on GzGameUserSettings_IsHDROutputEnabled");
static_assert(sizeof(GzGameUserSettings_IsHDROutputEnabled) == 0x000001, "Wrong size on GzGameUserSettings_IsHDROutputEnabled");
static_assert(offsetof(GzGameUserSettings_IsHDROutputEnabled, ReturnValue) == 0x000000, "Member 'GzGameUserSettings_IsHDROutputEnabled::ReturnValue' has a wrong offset!");

// Function G01.GzGameUserSettings.IsHorizontalInputInverted
// 0x0001 (0x0001 - 0x0000)
struct GzGameUserSettings_IsHorizontalInputInverted final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzGameUserSettings_IsHorizontalInputInverted) == 0x000001, "Wrong alignment on GzGameUserSettings_IsHorizontalInputInverted");
static_assert(sizeof(GzGameUserSettings_IsHorizontalInputInverted) == 0x000001, "Wrong size on GzGameUserSettings_IsHorizontalInputInverted");
static_assert(offsetof(GzGameUserSettings_IsHorizontalInputInverted, ReturnValue) == 0x000000, "Member 'GzGameUserSettings_IsHorizontalInputInverted::ReturnValue' has a wrong offset!");

// Function G01.GzGameUserSettings.IsMotionBlurActive
// 0x0001 (0x0001 - 0x0000)
struct GzGameUserSettings_IsMotionBlurActive final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzGameUserSettings_IsMotionBlurActive) == 0x000001, "Wrong alignment on GzGameUserSettings_IsMotionBlurActive");
static_assert(sizeof(GzGameUserSettings_IsMotionBlurActive) == 0x000001, "Wrong size on GzGameUserSettings_IsMotionBlurActive");
static_assert(offsetof(GzGameUserSettings_IsMotionBlurActive, ReturnValue) == 0x000000, "Member 'GzGameUserSettings_IsMotionBlurActive::ReturnValue' has a wrong offset!");

// Function G01.GzGameUserSettings.IsPerformanceMode
// 0x0001 (0x0001 - 0x0000)
struct GzGameUserSettings_IsPerformanceMode final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzGameUserSettings_IsPerformanceMode) == 0x000001, "Wrong alignment on GzGameUserSettings_IsPerformanceMode");
static_assert(sizeof(GzGameUserSettings_IsPerformanceMode) == 0x000001, "Wrong size on GzGameUserSettings_IsPerformanceMode");
static_assert(offsetof(GzGameUserSettings_IsPerformanceMode, ReturnValue) == 0x000000, "Member 'GzGameUserSettings_IsPerformanceMode::ReturnValue' has a wrong offset!");

// Function G01.GzGameUserSettings.IsToggleAimingMode
// 0x0001 (0x0001 - 0x0000)
struct GzGameUserSettings_IsToggleAimingMode final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzGameUserSettings_IsToggleAimingMode) == 0x000001, "Wrong alignment on GzGameUserSettings_IsToggleAimingMode");
static_assert(sizeof(GzGameUserSettings_IsToggleAimingMode) == 0x000001, "Wrong size on GzGameUserSettings_IsToggleAimingMode");
static_assert(offsetof(GzGameUserSettings_IsToggleAimingMode, ReturnValue) == 0x000000, "Member 'GzGameUserSettings_IsToggleAimingMode::ReturnValue' has a wrong offset!");

// Function G01.GzGameUserSettings.IsToggleSprintMode
// 0x0001 (0x0001 - 0x0000)
struct GzGameUserSettings_IsToggleSprintMode final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzGameUserSettings_IsToggleSprintMode) == 0x000001, "Wrong alignment on GzGameUserSettings_IsToggleSprintMode");
static_assert(sizeof(GzGameUserSettings_IsToggleSprintMode) == 0x000001, "Wrong size on GzGameUserSettings_IsToggleSprintMode");
static_assert(offsetof(GzGameUserSettings_IsToggleSprintMode, ReturnValue) == 0x000000, "Member 'GzGameUserSettings_IsToggleSprintMode::ReturnValue' has a wrong offset!");

// Function G01.GzGameUserSettings.IsVerticalInputInverted
// 0x0001 (0x0001 - 0x0000)
struct GzGameUserSettings_IsVerticalInputInverted final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzGameUserSettings_IsVerticalInputInverted) == 0x000001, "Wrong alignment on GzGameUserSettings_IsVerticalInputInverted");
static_assert(sizeof(GzGameUserSettings_IsVerticalInputInverted) == 0x000001, "Wrong size on GzGameUserSettings_IsVerticalInputInverted");
static_assert(offsetof(GzGameUserSettings_IsVerticalInputInverted, ReturnValue) == 0x000000, "Member 'GzGameUserSettings_IsVerticalInputInverted::ReturnValue' has a wrong offset!");

// Function G01.GzGameUserSettings.ShouldShowComparisonTooltip
// 0x0001 (0x0001 - 0x0000)
struct GzGameUserSettings_ShouldShowComparisonTooltip final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzGameUserSettings_ShouldShowComparisonTooltip) == 0x000001, "Wrong alignment on GzGameUserSettings_ShouldShowComparisonTooltip");
static_assert(sizeof(GzGameUserSettings_ShouldShowComparisonTooltip) == 0x000001, "Wrong size on GzGameUserSettings_ShouldShowComparisonTooltip");
static_assert(offsetof(GzGameUserSettings_ShouldShowComparisonTooltip, ReturnValue) == 0x000000, "Member 'GzGameUserSettings_ShouldShowComparisonTooltip::ReturnValue' has a wrong offset!");

// Function G01.GzGameUserSettings.ShouldShowDamageNumbers
// 0x0001 (0x0001 - 0x0000)
struct GzGameUserSettings_ShouldShowDamageNumbers final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzGameUserSettings_ShouldShowDamageNumbers) == 0x000001, "Wrong alignment on GzGameUserSettings_ShouldShowDamageNumbers");
static_assert(sizeof(GzGameUserSettings_ShouldShowDamageNumbers) == 0x000001, "Wrong size on GzGameUserSettings_ShouldShowDamageNumbers");
static_assert(offsetof(GzGameUserSettings_ShouldShowDamageNumbers, ReturnValue) == 0x000000, "Member 'GzGameUserSettings_ShouldShowDamageNumbers::ReturnValue' has a wrong offset!");

// Function G01.GzGateObjective.MakeUntilObjective
// 0x0020 (0x0020 - 0x0000)
struct GzGateObjective_MakeUntilObjective final
{
public:
	class AGzAdvancedMission*                     Mission;                                           // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UGzCondition*                           Param_Condition;                                   // 0x0008(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UGzObjective*                           Param_Objective;                                   // 0x0010(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UGzObjective*                           ReturnValue;                                       // 0x0018(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzGateObjective_MakeUntilObjective) == 0x000008, "Wrong alignment on GzGateObjective_MakeUntilObjective");
static_assert(sizeof(GzGateObjective_MakeUntilObjective) == 0x000020, "Wrong size on GzGateObjective_MakeUntilObjective");
static_assert(offsetof(GzGateObjective_MakeUntilObjective, Mission) == 0x000000, "Member 'GzGateObjective_MakeUntilObjective::Mission' has a wrong offset!");
static_assert(offsetof(GzGateObjective_MakeUntilObjective, Param_Condition) == 0x000008, "Member 'GzGateObjective_MakeUntilObjective::Param_Condition' has a wrong offset!");
static_assert(offsetof(GzGateObjective_MakeUntilObjective, Param_Objective) == 0x000010, "Member 'GzGateObjective_MakeUntilObjective::Param_Objective' has a wrong offset!");
static_assert(offsetof(GzGateObjective_MakeUntilObjective, ReturnValue) == 0x000018, "Member 'GzGateObjective_MakeUntilObjective::ReturnValue' has a wrong offset!");

// Function G01.GzGateObjective.MakeWhileObjective
// 0x0020 (0x0020 - 0x0000)
struct GzGateObjective_MakeWhileObjective final
{
public:
	class AGzAdvancedMission*                     Mission;                                           // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UGzCondition*                           Param_Condition;                                   // 0x0008(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UGzObjective*                           Param_Objective;                                   // 0x0010(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UGzObjective*                           ReturnValue;                                       // 0x0018(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzGateObjective_MakeWhileObjective) == 0x000008, "Wrong alignment on GzGateObjective_MakeWhileObjective");
static_assert(sizeof(GzGateObjective_MakeWhileObjective) == 0x000020, "Wrong size on GzGateObjective_MakeWhileObjective");
static_assert(offsetof(GzGateObjective_MakeWhileObjective, Mission) == 0x000000, "Member 'GzGateObjective_MakeWhileObjective::Mission' has a wrong offset!");
static_assert(offsetof(GzGateObjective_MakeWhileObjective, Param_Condition) == 0x000008, "Member 'GzGateObjective_MakeWhileObjective::Param_Condition' has a wrong offset!");
static_assert(offsetof(GzGateObjective_MakeWhileObjective, Param_Objective) == 0x000010, "Member 'GzGateObjective_MakeWhileObjective::Param_Objective' has a wrong offset!");
static_assert(offsetof(GzGateObjective_MakeWhileObjective, ReturnValue) == 0x000018, "Member 'GzGateObjective_MakeWhileObjective::ReturnValue' has a wrong offset!");

// Function G01.GzMissionMarker.SetMarkerLocation
// 0x0018 (0x0018 - 0x0000)
struct GzMissionMarker_SetMarkerLocation final
{
public:
	struct FVector                                Location;                                          // 0x0000(0x0018)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzMissionMarker_SetMarkerLocation) == 0x000008, "Wrong alignment on GzMissionMarker_SetMarkerLocation");
static_assert(sizeof(GzMissionMarker_SetMarkerLocation) == 0x000018, "Wrong size on GzMissionMarker_SetMarkerLocation");
static_assert(offsetof(GzMissionMarker_SetMarkerLocation, Location) == 0x000000, "Member 'GzMissionMarker_SetMarkerLocation::Location' has a wrong offset!");

// Function G01.GzMissionMarker.SetMarkerTargetAttached
// 0x0020 (0x0020 - 0x0000)
struct GzMissionMarker_SetMarkerTargetAttached final
{
public:
	class AActor*                                 Target;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Offset;                                            // 0x0008(0x0018)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzMissionMarker_SetMarkerTargetAttached) == 0x000008, "Wrong alignment on GzMissionMarker_SetMarkerTargetAttached");
static_assert(sizeof(GzMissionMarker_SetMarkerTargetAttached) == 0x000020, "Wrong size on GzMissionMarker_SetMarkerTargetAttached");
static_assert(offsetof(GzMissionMarker_SetMarkerTargetAttached, Target) == 0x000000, "Member 'GzMissionMarker_SetMarkerTargetAttached::Target' has a wrong offset!");
static_assert(offsetof(GzMissionMarker_SetMarkerTargetAttached, Offset) == 0x000008, "Member 'GzMissionMarker_SetMarkerTargetAttached::Offset' has a wrong offset!");

// Function G01.GzMissionMarker.SetMarkerTargetLocation
// 0x0020 (0x0020 - 0x0000)
struct GzMissionMarker_SetMarkerTargetLocation final
{
public:
	const class AActor*                           Target;                                            // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Offset;                                            // 0x0008(0x0018)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzMissionMarker_SetMarkerTargetLocation) == 0x000008, "Wrong alignment on GzMissionMarker_SetMarkerTargetLocation");
static_assert(sizeof(GzMissionMarker_SetMarkerTargetLocation) == 0x000020, "Wrong size on GzMissionMarker_SetMarkerTargetLocation");
static_assert(offsetof(GzMissionMarker_SetMarkerTargetLocation, Target) == 0x000000, "Member 'GzMissionMarker_SetMarkerTargetLocation::Target' has a wrong offset!");
static_assert(offsetof(GzMissionMarker_SetMarkerTargetLocation, Offset) == 0x000008, "Member 'GzMissionMarker_SetMarkerTargetLocation::Offset' has a wrong offset!");

// Function G01.GzMissionMarker.SetVisibility
// 0x0001 (0x0001 - 0x0000)
struct GzMissionMarker_SetVisibility final
{
public:
	bool                                          bNewVisibility;                                    // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzMissionMarker_SetVisibility) == 0x000001, "Wrong alignment on GzMissionMarker_SetVisibility");
static_assert(sizeof(GzMissionMarker_SetVisibility) == 0x000001, "Wrong size on GzMissionMarker_SetVisibility");
static_assert(offsetof(GzMissionMarker_SetVisibility, bNewVisibility) == 0x000000, "Member 'GzMissionMarker_SetVisibility::bNewVisibility' has a wrong offset!");

// Function G01.GzMissionMarker.IsVisible
// 0x0001 (0x0001 - 0x0000)
struct GzMissionMarker_IsVisible final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzMissionMarker_IsVisible) == 0x000001, "Wrong alignment on GzMissionMarker_IsVisible");
static_assert(sizeof(GzMissionMarker_IsVisible) == 0x000001, "Wrong size on GzMissionMarker_IsVisible");
static_assert(offsetof(GzMissionMarker_IsVisible, ReturnValue) == 0x000000, "Member 'GzMissionMarker_IsVisible::ReturnValue' has a wrong offset!");

// Function G01.GzGA_BaseLimbInteraction.OnMontageNotify
// 0x0008 (0x0008 - 0x0000)
struct GzGA_BaseLimbInteraction_OnMontageNotify final
{
public:
	class FName                                   NotifyName;                                        // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzGA_BaseLimbInteraction_OnMontageNotify) == 0x000004, "Wrong alignment on GzGA_BaseLimbInteraction_OnMontageNotify");
static_assert(sizeof(GzGA_BaseLimbInteraction_OnMontageNotify) == 0x000008, "Wrong size on GzGA_BaseLimbInteraction_OnMontageNotify");
static_assert(offsetof(GzGA_BaseLimbInteraction_OnMontageNotify, NotifyName) == 0x000000, "Member 'GzGA_BaseLimbInteraction_OnMontageNotify::NotifyName' has a wrong offset!");

// Function G01.GzPositiveCondition.MakePositiveCondition
// 0x0010 (0x0010 - 0x0000)
struct GzPositiveCondition_MakePositiveCondition final
{
public:
	class AGzAdvancedMission*                     Mission;                                           // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UGzCondition*                           ReturnValue;                                       // 0x0008(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzPositiveCondition_MakePositiveCondition) == 0x000008, "Wrong alignment on GzPositiveCondition_MakePositiveCondition");
static_assert(sizeof(GzPositiveCondition_MakePositiveCondition) == 0x000010, "Wrong size on GzPositiveCondition_MakePositiveCondition");
static_assert(offsetof(GzPositiveCondition_MakePositiveCondition, Mission) == 0x000000, "Member 'GzPositiveCondition_MakePositiveCondition::Mission' has a wrong offset!");
static_assert(offsetof(GzPositiveCondition_MakePositiveCondition, ReturnValue) == 0x000008, "Member 'GzPositiveCondition_MakePositiveCondition::ReturnValue' has a wrong offset!");

// Function G01.GzShrinkingZone.Init
// 0x0018 (0x0018 - 0x0000)
struct GzShrinkingZone_Init final
{
public:
	struct FGzCircle2D                            InInitialCircle;                                   // 0x0000(0x0018)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzShrinkingZone_Init) == 0x000008, "Wrong alignment on GzShrinkingZone_Init");
static_assert(sizeof(GzShrinkingZone_Init) == 0x000018, "Wrong size on GzShrinkingZone_Init");
static_assert(offsetof(GzShrinkingZone_Init, InInitialCircle) == 0x000000, "Member 'GzShrinkingZone_Init::InInitialCircle' has a wrong offset!");

// Function G01.GzShrinkingZone.SetTarget
// 0x0020 (0x0020 - 0x0000)
struct GzShrinkingZone_SetTarget final
{
public:
	struct FGzCircle2D                            InTargetCircle;                                    // 0x0000(0x0018)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	float                                         Time;                                              // 0x0018(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_32D1[0x4];                                     // 0x001C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GzShrinkingZone_SetTarget) == 0x000008, "Wrong alignment on GzShrinkingZone_SetTarget");
static_assert(sizeof(GzShrinkingZone_SetTarget) == 0x000020, "Wrong size on GzShrinkingZone_SetTarget");
static_assert(offsetof(GzShrinkingZone_SetTarget, InTargetCircle) == 0x000000, "Member 'GzShrinkingZone_SetTarget::InTargetCircle' has a wrong offset!");
static_assert(offsetof(GzShrinkingZone_SetTarget, Time) == 0x000018, "Member 'GzShrinkingZone_SetTarget::Time' has a wrong offset!");

// Function G01.GzShrinkingZone.GetCurrentCircle
// 0x0018 (0x0018 - 0x0000)
struct GzShrinkingZone_GetCurrentCircle final
{
public:
	struct FGzCircle2D                            ReturnValue;                                       // 0x0000(0x0018)(ConstParm, Parm, OutParm, ReturnParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzShrinkingZone_GetCurrentCircle) == 0x000008, "Wrong alignment on GzShrinkingZone_GetCurrentCircle");
static_assert(sizeof(GzShrinkingZone_GetCurrentCircle) == 0x000018, "Wrong size on GzShrinkingZone_GetCurrentCircle");
static_assert(offsetof(GzShrinkingZone_GetCurrentCircle, ReturnValue) == 0x000000, "Member 'GzShrinkingZone_GetCurrentCircle::ReturnValue' has a wrong offset!");

// Function G01.GzShrinkingZone.GetShrinkingTime
// 0x0004 (0x0004 - 0x0000)
struct GzShrinkingZone_GetShrinkingTime final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzShrinkingZone_GetShrinkingTime) == 0x000004, "Wrong alignment on GzShrinkingZone_GetShrinkingTime");
static_assert(sizeof(GzShrinkingZone_GetShrinkingTime) == 0x000004, "Wrong size on GzShrinkingZone_GetShrinkingTime");
static_assert(offsetof(GzShrinkingZone_GetShrinkingTime, ReturnValue) == 0x000000, "Member 'GzShrinkingZone_GetShrinkingTime::ReturnValue' has a wrong offset!");

// Function G01.GzShrinkingZone.GetTargetCircle
// 0x0018 (0x0018 - 0x0000)
struct GzShrinkingZone_GetTargetCircle final
{
public:
	struct FGzCircle2D                            ReturnValue;                                       // 0x0000(0x0018)(ConstParm, Parm, OutParm, ReturnParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzShrinkingZone_GetTargetCircle) == 0x000008, "Wrong alignment on GzShrinkingZone_GetTargetCircle");
static_assert(sizeof(GzShrinkingZone_GetTargetCircle) == 0x000018, "Wrong size on GzShrinkingZone_GetTargetCircle");
static_assert(offsetof(GzShrinkingZone_GetTargetCircle, ReturnValue) == 0x000000, "Member 'GzShrinkingZone_GetTargetCircle::ReturnValue' has a wrong offset!");

// Function G01.GzShrinkingZone.OnCurrentCircleChanged
// 0x0018 (0x0018 - 0x0000)
struct GzShrinkingZone_OnCurrentCircleChanged final
{
public:
	struct FGzCircle2D                            NewCurrentCircle;                                  // 0x0000(0x0018)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzShrinkingZone_OnCurrentCircleChanged) == 0x000008, "Wrong alignment on GzShrinkingZone_OnCurrentCircleChanged");
static_assert(sizeof(GzShrinkingZone_OnCurrentCircleChanged) == 0x000018, "Wrong size on GzShrinkingZone_OnCurrentCircleChanged");
static_assert(offsetof(GzShrinkingZone_OnCurrentCircleChanged, NewCurrentCircle) == 0x000000, "Member 'GzShrinkingZone_OnCurrentCircleChanged::NewCurrentCircle' has a wrong offset!");

// Function G01.GzGA_BoostSlide.OnTickTaskEnds
// 0x0001 (0x0001 - 0x0000)
struct GzGA_BoostSlide_OnTickTaskEnds final
{
public:
	bool                                          bWasCompleted;                                     // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzGA_BoostSlide_OnTickTaskEnds) == 0x000001, "Wrong alignment on GzGA_BoostSlide_OnTickTaskEnds");
static_assert(sizeof(GzGA_BoostSlide_OnTickTaskEnds) == 0x000001, "Wrong size on GzGA_BoostSlide_OnTickTaskEnds");
static_assert(offsetof(GzGA_BoostSlide_OnTickTaskEnds, bWasCompleted) == 0x000000, "Member 'GzGA_BoostSlide_OnTickTaskEnds::bWasCompleted' has a wrong offset!");

// Function G01.GzGA_ChargedJump.OnChargeUpComplete
// 0x0004 (0x0004 - 0x0000)
struct GzGA_ChargedJump_OnChargeUpComplete final
{
public:
	float                                         AmountOfTimeHeld;                                  // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzGA_ChargedJump_OnChargeUpComplete) == 0x000004, "Wrong alignment on GzGA_ChargedJump_OnChargeUpComplete");
static_assert(sizeof(GzGA_ChargedJump_OnChargeUpComplete) == 0x000004, "Wrong size on GzGA_ChargedJump_OnChargeUpComplete");
static_assert(offsetof(GzGA_ChargedJump_OnChargeUpComplete, AmountOfTimeHeld) == 0x000000, "Member 'GzGA_ChargedJump_OnChargeUpComplete::AmountOfTimeHeld' has a wrong offset!");

// Function G01.GzGA_ChargedJump.OnMovementModeChange
// 0x0010 (0x0010 - 0x0000)
struct GzGA_ChargedJump_OnMovementModeChange final
{
public:
	class ACharacter*                             Character;                                         // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EMovementMode                                 PrevMovementMode;                                  // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         PreviousCustomMode;                                // 0x0009(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_32D9[0x6];                                     // 0x000A(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GzGA_ChargedJump_OnMovementModeChange) == 0x000008, "Wrong alignment on GzGA_ChargedJump_OnMovementModeChange");
static_assert(sizeof(GzGA_ChargedJump_OnMovementModeChange) == 0x000010, "Wrong size on GzGA_ChargedJump_OnMovementModeChange");
static_assert(offsetof(GzGA_ChargedJump_OnMovementModeChange, Character) == 0x000000, "Member 'GzGA_ChargedJump_OnMovementModeChange::Character' has a wrong offset!");
static_assert(offsetof(GzGA_ChargedJump_OnMovementModeChange, PrevMovementMode) == 0x000008, "Member 'GzGA_ChargedJump_OnMovementModeChange::PrevMovementMode' has a wrong offset!");
static_assert(offsetof(GzGA_ChargedJump_OnMovementModeChange, PreviousCustomMode) == 0x000009, "Member 'GzGA_ChargedJump_OnMovementModeChange::PreviousCustomMode' has a wrong offset!");

// Function G01.GzGA_ChargedJump.GetChargePercent
// 0x0004 (0x0004 - 0x0000)
struct GzGA_ChargedJump_GetChargePercent final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzGA_ChargedJump_GetChargePercent) == 0x000004, "Wrong alignment on GzGA_ChargedJump_GetChargePercent");
static_assert(sizeof(GzGA_ChargedJump_GetChargePercent) == 0x000004, "Wrong size on GzGA_ChargedJump_GetChargePercent");
static_assert(offsetof(GzGA_ChargedJump_GetChargePercent, ReturnValue) == 0x000000, "Member 'GzGA_ChargedJump_GetChargePercent::ReturnValue' has a wrong offset!");

// Function G01.GzInventoryFunctionLibrary.GetAllBackpacks
// 0x0010 (0x0010 - 0x0000)
struct GzInventoryFunctionLibrary_GetAllBackpacks final
{
public:
	TArray<class FName>                           ReturnValue;                                       // 0x0000(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzInventoryFunctionLibrary_GetAllBackpacks) == 0x000008, "Wrong alignment on GzInventoryFunctionLibrary_GetAllBackpacks");
static_assert(sizeof(GzInventoryFunctionLibrary_GetAllBackpacks) == 0x000010, "Wrong size on GzInventoryFunctionLibrary_GetAllBackpacks");
static_assert(offsetof(GzInventoryFunctionLibrary_GetAllBackpacks, ReturnValue) == 0x000000, "Member 'GzInventoryFunctionLibrary_GetAllBackpacks::ReturnValue' has a wrong offset!");

// Function G01.GzInventoryFunctionLibrary.GetAllConsumables
// 0x0010 (0x0010 - 0x0000)
struct GzInventoryFunctionLibrary_GetAllConsumables final
{
public:
	TArray<class FName>                           ReturnValue;                                       // 0x0000(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzInventoryFunctionLibrary_GetAllConsumables) == 0x000008, "Wrong alignment on GzInventoryFunctionLibrary_GetAllConsumables");
static_assert(sizeof(GzInventoryFunctionLibrary_GetAllConsumables) == 0x000010, "Wrong size on GzInventoryFunctionLibrary_GetAllConsumables");
static_assert(offsetof(GzInventoryFunctionLibrary_GetAllConsumables, ReturnValue) == 0x000000, "Member 'GzInventoryFunctionLibrary_GetAllConsumables::ReturnValue' has a wrong offset!");

// Function G01.GzInventoryFunctionLibrary.GetAllContainerItems
// 0x0010 (0x0010 - 0x0000)
struct GzInventoryFunctionLibrary_GetAllContainerItems final
{
public:
	TArray<class FName>                           ReturnValue;                                       // 0x0000(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzInventoryFunctionLibrary_GetAllContainerItems) == 0x000008, "Wrong alignment on GzInventoryFunctionLibrary_GetAllContainerItems");
static_assert(sizeof(GzInventoryFunctionLibrary_GetAllContainerItems) == 0x000010, "Wrong size on GzInventoryFunctionLibrary_GetAllContainerItems");
static_assert(offsetof(GzInventoryFunctionLibrary_GetAllContainerItems, ReturnValue) == 0x000000, "Member 'GzInventoryFunctionLibrary_GetAllContainerItems::ReturnValue' has a wrong offset!");

// Function G01.GzInventoryFunctionLibrary.GetAllCyberLimbs
// 0x0010 (0x0010 - 0x0000)
struct GzInventoryFunctionLibrary_GetAllCyberLimbs final
{
public:
	TArray<class FName>                           ReturnValue;                                       // 0x0000(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzInventoryFunctionLibrary_GetAllCyberLimbs) == 0x000008, "Wrong alignment on GzInventoryFunctionLibrary_GetAllCyberLimbs");
static_assert(sizeof(GzInventoryFunctionLibrary_GetAllCyberLimbs) == 0x000010, "Wrong size on GzInventoryFunctionLibrary_GetAllCyberLimbs");
static_assert(offsetof(GzInventoryFunctionLibrary_GetAllCyberLimbs, ReturnValue) == 0x000000, "Member 'GzInventoryFunctionLibrary_GetAllCyberLimbs::ReturnValue' has a wrong offset!");

// Function G01.GzInventoryFunctionLibrary.GetAllMiscItems
// 0x0010 (0x0010 - 0x0000)
struct GzInventoryFunctionLibrary_GetAllMiscItems final
{
public:
	TArray<class FName>                           ReturnValue;                                       // 0x0000(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzInventoryFunctionLibrary_GetAllMiscItems) == 0x000008, "Wrong alignment on GzInventoryFunctionLibrary_GetAllMiscItems");
static_assert(sizeof(GzInventoryFunctionLibrary_GetAllMiscItems) == 0x000010, "Wrong size on GzInventoryFunctionLibrary_GetAllMiscItems");
static_assert(offsetof(GzInventoryFunctionLibrary_GetAllMiscItems, ReturnValue) == 0x000000, "Member 'GzInventoryFunctionLibrary_GetAllMiscItems::ReturnValue' has a wrong offset!");

// Function G01.GzInventoryFunctionLibrary.GetAllWeapons
// 0x0010 (0x0010 - 0x0000)
struct GzInventoryFunctionLibrary_GetAllWeapons final
{
public:
	TArray<class FName>                           ReturnValue;                                       // 0x0000(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzInventoryFunctionLibrary_GetAllWeapons) == 0x000008, "Wrong alignment on GzInventoryFunctionLibrary_GetAllWeapons");
static_assert(sizeof(GzInventoryFunctionLibrary_GetAllWeapons) == 0x000010, "Wrong size on GzInventoryFunctionLibrary_GetAllWeapons");
static_assert(offsetof(GzInventoryFunctionLibrary_GetAllWeapons, ReturnValue) == 0x000000, "Member 'GzInventoryFunctionLibrary_GetAllWeapons::ReturnValue' has a wrong offset!");

// Function G01.GzInventoryFunctionLibrary.GetAllWeaponsByRarity
// 0x0018 (0x0018 - 0x0000)
struct GzInventoryFunctionLibrary_GetAllWeaponsByRarity final
{
public:
	EGzItemRarity                                 WeaponRarity;                                      // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_32DA[0x7];                                     // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FName>                           ReturnValue;                                       // 0x0008(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzInventoryFunctionLibrary_GetAllWeaponsByRarity) == 0x000008, "Wrong alignment on GzInventoryFunctionLibrary_GetAllWeaponsByRarity");
static_assert(sizeof(GzInventoryFunctionLibrary_GetAllWeaponsByRarity) == 0x000018, "Wrong size on GzInventoryFunctionLibrary_GetAllWeaponsByRarity");
static_assert(offsetof(GzInventoryFunctionLibrary_GetAllWeaponsByRarity, WeaponRarity) == 0x000000, "Member 'GzInventoryFunctionLibrary_GetAllWeaponsByRarity::WeaponRarity' has a wrong offset!");
static_assert(offsetof(GzInventoryFunctionLibrary_GetAllWeaponsByRarity, ReturnValue) == 0x000008, "Member 'GzInventoryFunctionLibrary_GetAllWeaponsByRarity::ReturnValue' has a wrong offset!");

// Function G01.GzInventoryFunctionLibrary.GetCyberLimbs
// 0x0018 (0x0018 - 0x0000)
struct GzInventoryFunctionLibrary_GetCyberLimbs final
{
public:
	EGzLimbType                                   Type;                                              // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_32DB[0x7];                                     // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FName>                           ReturnValue;                                       // 0x0008(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzInventoryFunctionLibrary_GetCyberLimbs) == 0x000008, "Wrong alignment on GzInventoryFunctionLibrary_GetCyberLimbs");
static_assert(sizeof(GzInventoryFunctionLibrary_GetCyberLimbs) == 0x000018, "Wrong size on GzInventoryFunctionLibrary_GetCyberLimbs");
static_assert(offsetof(GzInventoryFunctionLibrary_GetCyberLimbs, Type) == 0x000000, "Member 'GzInventoryFunctionLibrary_GetCyberLimbs::Type' has a wrong offset!");
static_assert(offsetof(GzInventoryFunctionLibrary_GetCyberLimbs, ReturnValue) == 0x000008, "Member 'GzInventoryFunctionLibrary_GetCyberLimbs::ReturnValue' has a wrong offset!");

// Function G01.GzInventoryFunctionLibrary.GetCyberLimbsByRarity
// 0x0018 (0x0018 - 0x0000)
struct GzInventoryFunctionLibrary_GetCyberLimbsByRarity final
{
public:
	EGzLimbType                                   Type;                                              // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EGzItemRarity                                 LimbRarity;                                        // 0x0001(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_32DC[0x6];                                     // 0x0002(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FName>                           ReturnValue;                                       // 0x0008(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzInventoryFunctionLibrary_GetCyberLimbsByRarity) == 0x000008, "Wrong alignment on GzInventoryFunctionLibrary_GetCyberLimbsByRarity");
static_assert(sizeof(GzInventoryFunctionLibrary_GetCyberLimbsByRarity) == 0x000018, "Wrong size on GzInventoryFunctionLibrary_GetCyberLimbsByRarity");
static_assert(offsetof(GzInventoryFunctionLibrary_GetCyberLimbsByRarity, Type) == 0x000000, "Member 'GzInventoryFunctionLibrary_GetCyberLimbsByRarity::Type' has a wrong offset!");
static_assert(offsetof(GzInventoryFunctionLibrary_GetCyberLimbsByRarity, LimbRarity) == 0x000001, "Member 'GzInventoryFunctionLibrary_GetCyberLimbsByRarity::LimbRarity' has a wrong offset!");
static_assert(offsetof(GzInventoryFunctionLibrary_GetCyberLimbsByRarity, ReturnValue) == 0x000008, "Member 'GzInventoryFunctionLibrary_GetCyberLimbsByRarity::ReturnValue' has a wrong offset!");

// Function G01.GzInventoryFunctionLibrary.GetSuitableWeaponAttachmentsOfType
// 0x0020 (0x0020 - 0x0000)
struct GzInventoryFunctionLibrary_GetSuitableWeaponAttachmentsOfType final
{
public:
	class AGzWeaponActor*                         WeaponActor;                                       // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EGzWeaponAttachmentType                       AttachmentType;                                    // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_32DD[0x7];                                     // 0x0009(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FName>                           ReturnValue;                                       // 0x0010(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzInventoryFunctionLibrary_GetSuitableWeaponAttachmentsOfType) == 0x000008, "Wrong alignment on GzInventoryFunctionLibrary_GetSuitableWeaponAttachmentsOfType");
static_assert(sizeof(GzInventoryFunctionLibrary_GetSuitableWeaponAttachmentsOfType) == 0x000020, "Wrong size on GzInventoryFunctionLibrary_GetSuitableWeaponAttachmentsOfType");
static_assert(offsetof(GzInventoryFunctionLibrary_GetSuitableWeaponAttachmentsOfType, WeaponActor) == 0x000000, "Member 'GzInventoryFunctionLibrary_GetSuitableWeaponAttachmentsOfType::WeaponActor' has a wrong offset!");
static_assert(offsetof(GzInventoryFunctionLibrary_GetSuitableWeaponAttachmentsOfType, AttachmentType) == 0x000008, "Member 'GzInventoryFunctionLibrary_GetSuitableWeaponAttachmentsOfType::AttachmentType' has a wrong offset!");
static_assert(offsetof(GzInventoryFunctionLibrary_GetSuitableWeaponAttachmentsOfType, ReturnValue) == 0x000010, "Member 'GzInventoryFunctionLibrary_GetSuitableWeaponAttachmentsOfType::ReturnValue' has a wrong offset!");

// Function G01.GzInventoryFunctionLibrary.GetSuitableWeaponAttachmentsOfTypeFromItemData
// 0x0020 (0x0020 - 0x0000)
struct GzInventoryFunctionLibrary_GetSuitableWeaponAttachmentsOfTypeFromItemData final
{
public:
	class UGzWeaponItemData*                      WeaponItemData;                                    // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EGzWeaponAttachmentType                       AttachmentType;                                    // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_32DE[0x7];                                     // 0x0009(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FName>                           ReturnValue;                                       // 0x0010(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzInventoryFunctionLibrary_GetSuitableWeaponAttachmentsOfTypeFromItemData) == 0x000008, "Wrong alignment on GzInventoryFunctionLibrary_GetSuitableWeaponAttachmentsOfTypeFromItemData");
static_assert(sizeof(GzInventoryFunctionLibrary_GetSuitableWeaponAttachmentsOfTypeFromItemData) == 0x000020, "Wrong size on GzInventoryFunctionLibrary_GetSuitableWeaponAttachmentsOfTypeFromItemData");
static_assert(offsetof(GzInventoryFunctionLibrary_GetSuitableWeaponAttachmentsOfTypeFromItemData, WeaponItemData) == 0x000000, "Member 'GzInventoryFunctionLibrary_GetSuitableWeaponAttachmentsOfTypeFromItemData::WeaponItemData' has a wrong offset!");
static_assert(offsetof(GzInventoryFunctionLibrary_GetSuitableWeaponAttachmentsOfTypeFromItemData, AttachmentType) == 0x000008, "Member 'GzInventoryFunctionLibrary_GetSuitableWeaponAttachmentsOfTypeFromItemData::AttachmentType' has a wrong offset!");
static_assert(offsetof(GzInventoryFunctionLibrary_GetSuitableWeaponAttachmentsOfTypeFromItemData, ReturnValue) == 0x000010, "Member 'GzInventoryFunctionLibrary_GetSuitableWeaponAttachmentsOfTypeFromItemData::ReturnValue' has a wrong offset!");

// Function G01.GzInventoryFunctionLibrary.MatchItemContentToType
// 0x0058 (0x0058 - 0x0000)
struct GzInventoryFunctionLibrary_MatchItemContentToType final
{
public:
	struct FGzInventoryItemContent                ItemContent;                                       // 0x0000(0x0048)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	struct FGameplayTag                           ItemType;                                          // 0x0048(0x0008)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0050(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_32DF[0x7];                                     // 0x0051(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GzInventoryFunctionLibrary_MatchItemContentToType) == 0x000008, "Wrong alignment on GzInventoryFunctionLibrary_MatchItemContentToType");
static_assert(sizeof(GzInventoryFunctionLibrary_MatchItemContentToType) == 0x000058, "Wrong size on GzInventoryFunctionLibrary_MatchItemContentToType");
static_assert(offsetof(GzInventoryFunctionLibrary_MatchItemContentToType, ItemContent) == 0x000000, "Member 'GzInventoryFunctionLibrary_MatchItemContentToType::ItemContent' has a wrong offset!");
static_assert(offsetof(GzInventoryFunctionLibrary_MatchItemContentToType, ItemType) == 0x000048, "Member 'GzInventoryFunctionLibrary_MatchItemContentToType::ItemType' has a wrong offset!");
static_assert(offsetof(GzInventoryFunctionLibrary_MatchItemContentToType, ReturnValue) == 0x000050, "Member 'GzInventoryFunctionLibrary_MatchItemContentToType::ReturnValue' has a wrong offset!");

// Function G01.GzLimbDoubleAbilityComponent.SetCurrentSecondaryCharges
// 0x0004 (0x0004 - 0x0000)
struct GzLimbDoubleAbilityComponent_SetCurrentSecondaryCharges final
{
public:
	float                                         Current;                                           // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzLimbDoubleAbilityComponent_SetCurrentSecondaryCharges) == 0x000004, "Wrong alignment on GzLimbDoubleAbilityComponent_SetCurrentSecondaryCharges");
static_assert(sizeof(GzLimbDoubleAbilityComponent_SetCurrentSecondaryCharges) == 0x000004, "Wrong size on GzLimbDoubleAbilityComponent_SetCurrentSecondaryCharges");
static_assert(offsetof(GzLimbDoubleAbilityComponent_SetCurrentSecondaryCharges, Current) == 0x000000, "Member 'GzLimbDoubleAbilityComponent_SetCurrentSecondaryCharges::Current' has a wrong offset!");

// Function G01.GzLimbDoubleAbilityComponent.SetSecondaryChargesAvailable
// 0x0001 (0x0001 - 0x0000)
struct GzLimbDoubleAbilityComponent_SetSecondaryChargesAvailable final
{
public:
	bool                                          bAvailable;                                        // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzLimbDoubleAbilityComponent_SetSecondaryChargesAvailable) == 0x000001, "Wrong alignment on GzLimbDoubleAbilityComponent_SetSecondaryChargesAvailable");
static_assert(sizeof(GzLimbDoubleAbilityComponent_SetSecondaryChargesAvailable) == 0x000001, "Wrong size on GzLimbDoubleAbilityComponent_SetSecondaryChargesAvailable");
static_assert(offsetof(GzLimbDoubleAbilityComponent_SetSecondaryChargesAvailable, bAvailable) == 0x000000, "Member 'GzLimbDoubleAbilityComponent_SetSecondaryChargesAvailable::bAvailable' has a wrong offset!");

// Function G01.GzLimbDoubleAbilityComponent.GetCurrentSecondaryCharges
// 0x0004 (0x0004 - 0x0000)
struct GzLimbDoubleAbilityComponent_GetCurrentSecondaryCharges final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzLimbDoubleAbilityComponent_GetCurrentSecondaryCharges) == 0x000004, "Wrong alignment on GzLimbDoubleAbilityComponent_GetCurrentSecondaryCharges");
static_assert(sizeof(GzLimbDoubleAbilityComponent_GetCurrentSecondaryCharges) == 0x000004, "Wrong size on GzLimbDoubleAbilityComponent_GetCurrentSecondaryCharges");
static_assert(offsetof(GzLimbDoubleAbilityComponent_GetCurrentSecondaryCharges, ReturnValue) == 0x000000, "Member 'GzLimbDoubleAbilityComponent_GetCurrentSecondaryCharges::ReturnValue' has a wrong offset!");

// Function G01.GzLimbDoubleAbilityComponent.GetMaxSecondaryCharges
// 0x0004 (0x0004 - 0x0000)
struct GzLimbDoubleAbilityComponent_GetMaxSecondaryCharges final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzLimbDoubleAbilityComponent_GetMaxSecondaryCharges) == 0x000004, "Wrong alignment on GzLimbDoubleAbilityComponent_GetMaxSecondaryCharges");
static_assert(sizeof(GzLimbDoubleAbilityComponent_GetMaxSecondaryCharges) == 0x000004, "Wrong size on GzLimbDoubleAbilityComponent_GetMaxSecondaryCharges");
static_assert(offsetof(GzLimbDoubleAbilityComponent_GetMaxSecondaryCharges, ReturnValue) == 0x000000, "Member 'GzLimbDoubleAbilityComponent_GetMaxSecondaryCharges::ReturnValue' has a wrong offset!");

// Function G01.GzLimbDoubleAbilityComponent.GetSecondaryChargeDuration
// 0x0004 (0x0004 - 0x0000)
struct GzLimbDoubleAbilityComponent_GetSecondaryChargeDuration final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzLimbDoubleAbilityComponent_GetSecondaryChargeDuration) == 0x000004, "Wrong alignment on GzLimbDoubleAbilityComponent_GetSecondaryChargeDuration");
static_assert(sizeof(GzLimbDoubleAbilityComponent_GetSecondaryChargeDuration) == 0x000004, "Wrong size on GzLimbDoubleAbilityComponent_GetSecondaryChargeDuration");
static_assert(offsetof(GzLimbDoubleAbilityComponent_GetSecondaryChargeDuration, ReturnValue) == 0x000000, "Member 'GzLimbDoubleAbilityComponent_GetSecondaryChargeDuration::ReturnValue' has a wrong offset!");

// Function G01.GzLimbDoubleAbilityComponent.GetSecondaryChargesAvailable
// 0x0001 (0x0001 - 0x0000)
struct GzLimbDoubleAbilityComponent_GetSecondaryChargesAvailable final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzLimbDoubleAbilityComponent_GetSecondaryChargesAvailable) == 0x000001, "Wrong alignment on GzLimbDoubleAbilityComponent_GetSecondaryChargesAvailable");
static_assert(sizeof(GzLimbDoubleAbilityComponent_GetSecondaryChargesAvailable) == 0x000001, "Wrong size on GzLimbDoubleAbilityComponent_GetSecondaryChargesAvailable");
static_assert(offsetof(GzLimbDoubleAbilityComponent_GetSecondaryChargesAvailable, ReturnValue) == 0x000000, "Member 'GzLimbDoubleAbilityComponent_GetSecondaryChargesAvailable::ReturnValue' has a wrong offset!");

// Function G01.GzGA_CloakArm.ParseGadgetSpawnData
// 0x0060 (0x0060 - 0x0000)
struct GzGA_CloakArm_ParseGadgetSpawnData final
{
public:
	struct FGameplayAbilityTargetDataHandle       TargetData;                                        // 0x0000(0x0028)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	class AGzMultiPartCharacter*                  Character;                                         // 0x0028(0x0008)(Parm, OutParm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector_NetQuantize                    SpawnLocation;                                     // 0x0030(0x0018)(Parm, OutParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector_NetQuantize                    TargetLocation;                                    // 0x0048(0x0018)(Parm, OutParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzGA_CloakArm_ParseGadgetSpawnData) == 0x000008, "Wrong alignment on GzGA_CloakArm_ParseGadgetSpawnData");
static_assert(sizeof(GzGA_CloakArm_ParseGadgetSpawnData) == 0x000060, "Wrong size on GzGA_CloakArm_ParseGadgetSpawnData");
static_assert(offsetof(GzGA_CloakArm_ParseGadgetSpawnData, TargetData) == 0x000000, "Member 'GzGA_CloakArm_ParseGadgetSpawnData::TargetData' has a wrong offset!");
static_assert(offsetof(GzGA_CloakArm_ParseGadgetSpawnData, Character) == 0x000028, "Member 'GzGA_CloakArm_ParseGadgetSpawnData::Character' has a wrong offset!");
static_assert(offsetof(GzGA_CloakArm_ParseGadgetSpawnData, SpawnLocation) == 0x000030, "Member 'GzGA_CloakArm_ParseGadgetSpawnData::SpawnLocation' has a wrong offset!");
static_assert(offsetof(GzGA_CloakArm_ParseGadgetSpawnData, TargetLocation) == 0x000048, "Member 'GzGA_CloakArm_ParseGadgetSpawnData::TargetLocation' has a wrong offset!");

// Function G01.GzLoadoutSelectionButton.GetIsRandomLoadout
// 0x0001 (0x0001 - 0x0000)
struct GzLoadoutSelectionButton_GetIsRandomLoadout final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzLoadoutSelectionButton_GetIsRandomLoadout) == 0x000001, "Wrong alignment on GzLoadoutSelectionButton_GetIsRandomLoadout");
static_assert(sizeof(GzLoadoutSelectionButton_GetIsRandomLoadout) == 0x000001, "Wrong size on GzLoadoutSelectionButton_GetIsRandomLoadout");
static_assert(offsetof(GzLoadoutSelectionButton_GetIsRandomLoadout, ReturnValue) == 0x000000, "Member 'GzLoadoutSelectionButton_GetIsRandomLoadout::ReturnValue' has a wrong offset!");

// Function G01.GzLoadoutSelectionButton.GetLoadoutData
// 0x0070 (0x0070 - 0x0000)
struct GzLoadoutSelectionButton_GetLoadoutData final
{
public:
	struct FGzLoadoutDataConfig                   ReturnValue;                                       // 0x0000(0x0070)(ConstParm, Parm, OutParm, ReturnParm, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzLoadoutSelectionButton_GetLoadoutData) == 0x000008, "Wrong alignment on GzLoadoutSelectionButton_GetLoadoutData");
static_assert(sizeof(GzLoadoutSelectionButton_GetLoadoutData) == 0x000070, "Wrong size on GzLoadoutSelectionButton_GetLoadoutData");
static_assert(offsetof(GzLoadoutSelectionButton_GetLoadoutData, ReturnValue) == 0x000000, "Member 'GzLoadoutSelectionButton_GetLoadoutData::ReturnValue' has a wrong offset!");

// Function G01.GzLoadoutSelectionButton.GetShowLoadoutPrice
// 0x0001 (0x0001 - 0x0000)
struct GzLoadoutSelectionButton_GetShowLoadoutPrice final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzLoadoutSelectionButton_GetShowLoadoutPrice) == 0x000001, "Wrong alignment on GzLoadoutSelectionButton_GetShowLoadoutPrice");
static_assert(sizeof(GzLoadoutSelectionButton_GetShowLoadoutPrice) == 0x000001, "Wrong size on GzLoadoutSelectionButton_GetShowLoadoutPrice");
static_assert(offsetof(GzLoadoutSelectionButton_GetShowLoadoutPrice, ReturnValue) == 0x000000, "Member 'GzLoadoutSelectionButton_GetShowLoadoutPrice::ReturnValue' has a wrong offset!");

// Function G01.GzTrack.GetDistanceAt
// 0x0010 (0x0010 - 0x0000)
struct GzTrack_GetDistanceAt final
{
public:
	int32                                         Param_Index;                                       // 0x0000(0x0004)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_32E4[0x4];                                     // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	double                                        ReturnValue;                                       // 0x0008(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzTrack_GetDistanceAt) == 0x000008, "Wrong alignment on GzTrack_GetDistanceAt");
static_assert(sizeof(GzTrack_GetDistanceAt) == 0x000010, "Wrong size on GzTrack_GetDistanceAt");
static_assert(offsetof(GzTrack_GetDistanceAt, Param_Index) == 0x000000, "Member 'GzTrack_GetDistanceAt::Param_Index' has a wrong offset!");
static_assert(offsetof(GzTrack_GetDistanceAt, ReturnValue) == 0x000008, "Member 'GzTrack_GetDistanceAt::ReturnValue' has a wrong offset!");

// Function G01.GzTrack.GetDistanceAtTrackPoint
// 0x0010 (0x0010 - 0x0000)
struct GzTrack_GetDistanceAtTrackPoint final
{
public:
	int32                                         TrackPointIndex;                                   // 0x0000(0x0004)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_32E5[0x4];                                     // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	double                                        ReturnValue;                                       // 0x0008(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzTrack_GetDistanceAtTrackPoint) == 0x000008, "Wrong alignment on GzTrack_GetDistanceAtTrackPoint");
static_assert(sizeof(GzTrack_GetDistanceAtTrackPoint) == 0x000010, "Wrong size on GzTrack_GetDistanceAtTrackPoint");
static_assert(offsetof(GzTrack_GetDistanceAtTrackPoint, TrackPointIndex) == 0x000000, "Member 'GzTrack_GetDistanceAtTrackPoint::TrackPointIndex' has a wrong offset!");
static_assert(offsetof(GzTrack_GetDistanceAtTrackPoint, ReturnValue) == 0x000008, "Member 'GzTrack_GetDistanceAtTrackPoint::ReturnValue' has a wrong offset!");

// Function G01.GzTrack.GetLoopLength
// 0x0008 (0x0008 - 0x0000)
struct GzTrack_GetLoopLength final
{
public:
	double                                        ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzTrack_GetLoopLength) == 0x000008, "Wrong alignment on GzTrack_GetLoopLength");
static_assert(sizeof(GzTrack_GetLoopLength) == 0x000008, "Wrong size on GzTrack_GetLoopLength");
static_assert(offsetof(GzTrack_GetLoopLength, ReturnValue) == 0x000000, "Member 'GzTrack_GetLoopLength::ReturnValue' has a wrong offset!");

// Function G01.GzTrack.GetTrackLength
// 0x0008 (0x0008 - 0x0000)
struct GzTrack_GetTrackLength final
{
public:
	double                                        ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzTrack_GetTrackLength) == 0x000008, "Wrong alignment on GzTrack_GetTrackLength");
static_assert(sizeof(GzTrack_GetTrackLength) == 0x000008, "Wrong size on GzTrack_GetTrackLength");
static_assert(offsetof(GzTrack_GetTrackLength, ReturnValue) == 0x000000, "Member 'GzTrack_GetTrackLength::ReturnValue' has a wrong offset!");

// Function G01.GzTrack.GetTrackStop
// 0x0018 (0x0018 - 0x0000)
struct GzTrack_GetTrackStop final
{
public:
	int32                                         StopIndex;                                         // 0x0000(0x0004)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_32E6[0x4];                                     // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGzTrackStop                           ReturnValue;                                       // 0x0008(0x0010)(ConstParm, Parm, OutParm, ReturnParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzTrack_GetTrackStop) == 0x000008, "Wrong alignment on GzTrack_GetTrackStop");
static_assert(sizeof(GzTrack_GetTrackStop) == 0x000018, "Wrong size on GzTrack_GetTrackStop");
static_assert(offsetof(GzTrack_GetTrackStop, StopIndex) == 0x000000, "Member 'GzTrack_GetTrackStop::StopIndex' has a wrong offset!");
static_assert(offsetof(GzTrack_GetTrackStop, ReturnValue) == 0x000008, "Member 'GzTrack_GetTrackStop::ReturnValue' has a wrong offset!");

// Function G01.GzTrack.GetTrackStopsCount
// 0x0004 (0x0004 - 0x0000)
struct GzTrack_GetTrackStopsCount final
{
public:
	int32                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzTrack_GetTrackStopsCount) == 0x000004, "Wrong alignment on GzTrack_GetTrackStopsCount");
static_assert(sizeof(GzTrack_GetTrackStopsCount) == 0x000004, "Wrong size on GzTrack_GetTrackStopsCount");
static_assert(offsetof(GzTrack_GetTrackStopsCount, ReturnValue) == 0x000000, "Member 'GzTrack_GetTrackStopsCount::ReturnValue' has a wrong offset!");

// Function G01.GzGA_ConsumeHold.GetCurrentHoldProgress
// 0x0004 (0x0004 - 0x0000)
struct GzGA_ConsumeHold_GetCurrentHoldProgress final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzGA_ConsumeHold_GetCurrentHoldProgress) == 0x000004, "Wrong alignment on GzGA_ConsumeHold_GetCurrentHoldProgress");
static_assert(sizeof(GzGA_ConsumeHold_GetCurrentHoldProgress) == 0x000004, "Wrong size on GzGA_ConsumeHold_GetCurrentHoldProgress");
static_assert(offsetof(GzGA_ConsumeHold_GetCurrentHoldProgress, ReturnValue) == 0x000000, "Member 'GzGA_ConsumeHold_GetCurrentHoldProgress::ReturnValue' has a wrong offset!");

// Function G01.GzGA_Crouch.OnUncrouchEvent
// 0x00B0 (0x00B0 - 0x0000)
struct GzGA_Crouch_OnUncrouchEvent final
{
public:
	struct FGameplayEventData                     TriggerEventData;                                  // 0x0000(0x00B0)(Parm, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzGA_Crouch_OnUncrouchEvent) == 0x000008, "Wrong alignment on GzGA_Crouch_OnUncrouchEvent");
static_assert(sizeof(GzGA_Crouch_OnUncrouchEvent) == 0x0000B0, "Wrong size on GzGA_Crouch_OnUncrouchEvent");
static_assert(offsetof(GzGA_Crouch_OnUncrouchEvent, TriggerEventData) == 0x000000, "Member 'GzGA_Crouch_OnUncrouchEvent::TriggerEventData' has a wrong offset!");

// Function G01.GzGA_Dash.OnCancelEvent
// 0x00B0 (0x00B0 - 0x0000)
struct GzGA_Dash_OnCancelEvent final
{
public:
	struct FGameplayEventData                     EventData;                                         // 0x0000(0x00B0)(Parm, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzGA_Dash_OnCancelEvent) == 0x000008, "Wrong alignment on GzGA_Dash_OnCancelEvent");
static_assert(sizeof(GzGA_Dash_OnCancelEvent) == 0x0000B0, "Wrong size on GzGA_Dash_OnCancelEvent");
static_assert(offsetof(GzGA_Dash_OnCancelEvent, EventData) == 0x000000, "Member 'GzGA_Dash_OnCancelEvent::EventData' has a wrong offset!");

// Function G01.GzGA_Dash.OnDashFinished
// 0x0020 (0x0020 - 0x0000)
struct GzGA_Dash_OnDashFinished final
{
public:
	bool                                          DestinationReached;                                // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          TimedOut;                                          // 0x0001(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_32EA[0x6];                                     // 0x0002(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                FinalTargetLocation;                               // 0x0008(0x0018)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzGA_Dash_OnDashFinished) == 0x000008, "Wrong alignment on GzGA_Dash_OnDashFinished");
static_assert(sizeof(GzGA_Dash_OnDashFinished) == 0x000020, "Wrong size on GzGA_Dash_OnDashFinished");
static_assert(offsetof(GzGA_Dash_OnDashFinished, DestinationReached) == 0x000000, "Member 'GzGA_Dash_OnDashFinished::DestinationReached' has a wrong offset!");
static_assert(offsetof(GzGA_Dash_OnDashFinished, TimedOut) == 0x000001, "Member 'GzGA_Dash_OnDashFinished::TimedOut' has a wrong offset!");
static_assert(offsetof(GzGA_Dash_OnDashFinished, FinalTargetLocation) == 0x000008, "Member 'GzGA_Dash_OnDashFinished::FinalTargetLocation' has a wrong offset!");

// Function G01.GzGA_Dash.OnDashHit
// 0x0118 (0x0118 - 0x0000)
struct GzGA_Dash_OnDashHit final
{
public:
	class AActor*                                 OtherActor;                                        // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                NormalImpulse;                                     // 0x0008(0x0018)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FHitResult                             Hit;                                               // 0x0020(0x00F8)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzGA_Dash_OnDashHit) == 0x000008, "Wrong alignment on GzGA_Dash_OnDashHit");
static_assert(sizeof(GzGA_Dash_OnDashHit) == 0x000118, "Wrong size on GzGA_Dash_OnDashHit");
static_assert(offsetof(GzGA_Dash_OnDashHit, OtherActor) == 0x000000, "Member 'GzGA_Dash_OnDashHit::OtherActor' has a wrong offset!");
static_assert(offsetof(GzGA_Dash_OnDashHit, NormalImpulse) == 0x000008, "Member 'GzGA_Dash_OnDashHit::NormalImpulse' has a wrong offset!");
static_assert(offsetof(GzGA_Dash_OnDashHit, Hit) == 0x000020, "Member 'GzGA_Dash_OnDashHit::Hit' has a wrong offset!");

// Function G01.GzGA_Dash.OnDashHitCharacter
// 0x0118 (0x0118 - 0x0000)
struct GzGA_Dash_OnDashHitCharacter final
{
public:
	class AGzMultiPartCharacter*                  HitCharacter;                                      // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                NormalImpulse;                                     // 0x0008(0x0018)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FHitResult                             Hit;                                               // 0x0020(0x00F8)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzGA_Dash_OnDashHitCharacter) == 0x000008, "Wrong alignment on GzGA_Dash_OnDashHitCharacter");
static_assert(sizeof(GzGA_Dash_OnDashHitCharacter) == 0x000118, "Wrong size on GzGA_Dash_OnDashHitCharacter");
static_assert(offsetof(GzGA_Dash_OnDashHitCharacter, HitCharacter) == 0x000000, "Member 'GzGA_Dash_OnDashHitCharacter::HitCharacter' has a wrong offset!");
static_assert(offsetof(GzGA_Dash_OnDashHitCharacter, NormalImpulse) == 0x000008, "Member 'GzGA_Dash_OnDashHitCharacter::NormalImpulse' has a wrong offset!");
static_assert(offsetof(GzGA_Dash_OnDashHitCharacter, Hit) == 0x000020, "Member 'GzGA_Dash_OnDashHitCharacter::Hit' has a wrong offset!");

// Function G01.GzGA_Dash.OnExtraCollisionBeginOverlap
// 0x0118 (0x0118 - 0x0000)
struct GzGA_Dash_OnExtraCollisionBeginOverlap final
{
public:
	class UPrimitiveComponent*                    OverlappedComponent;                               // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 OtherActor;                                        // 0x0008(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UPrimitiveComponent*                    OtherComp;                                         // 0x0010(0x0008)(Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         OtherBodyIndex;                                    // 0x0018(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bFromSweep;                                        // 0x001C(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_32EB[0x3];                                     // 0x001D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FHitResult                             SweepResult;                                       // 0x0020(0x00F8)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzGA_Dash_OnExtraCollisionBeginOverlap) == 0x000008, "Wrong alignment on GzGA_Dash_OnExtraCollisionBeginOverlap");
static_assert(sizeof(GzGA_Dash_OnExtraCollisionBeginOverlap) == 0x000118, "Wrong size on GzGA_Dash_OnExtraCollisionBeginOverlap");
static_assert(offsetof(GzGA_Dash_OnExtraCollisionBeginOverlap, OverlappedComponent) == 0x000000, "Member 'GzGA_Dash_OnExtraCollisionBeginOverlap::OverlappedComponent' has a wrong offset!");
static_assert(offsetof(GzGA_Dash_OnExtraCollisionBeginOverlap, OtherActor) == 0x000008, "Member 'GzGA_Dash_OnExtraCollisionBeginOverlap::OtherActor' has a wrong offset!");
static_assert(offsetof(GzGA_Dash_OnExtraCollisionBeginOverlap, OtherComp) == 0x000010, "Member 'GzGA_Dash_OnExtraCollisionBeginOverlap::OtherComp' has a wrong offset!");
static_assert(offsetof(GzGA_Dash_OnExtraCollisionBeginOverlap, OtherBodyIndex) == 0x000018, "Member 'GzGA_Dash_OnExtraCollisionBeginOverlap::OtherBodyIndex' has a wrong offset!");
static_assert(offsetof(GzGA_Dash_OnExtraCollisionBeginOverlap, bFromSweep) == 0x00001C, "Member 'GzGA_Dash_OnExtraCollisionBeginOverlap::bFromSweep' has a wrong offset!");
static_assert(offsetof(GzGA_Dash_OnExtraCollisionBeginOverlap, SweepResult) == 0x000020, "Member 'GzGA_Dash_OnExtraCollisionBeginOverlap::SweepResult' has a wrong offset!");

// Function G01.GzInteractionTooltip.OnFocusChange
// 0x0010 (0x0010 - 0x0000)
struct GzInteractionTooltip_OnFocusChange final
{
public:
	class UGzInteractableComponent*               Interactable;                                      // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bInInteractionRange;                               // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_32EE[0x7];                                     // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GzInteractionTooltip_OnFocusChange) == 0x000008, "Wrong alignment on GzInteractionTooltip_OnFocusChange");
static_assert(sizeof(GzInteractionTooltip_OnFocusChange) == 0x000010, "Wrong size on GzInteractionTooltip_OnFocusChange");
static_assert(offsetof(GzInteractionTooltip_OnFocusChange, Interactable) == 0x000000, "Member 'GzInteractionTooltip_OnFocusChange::Interactable' has a wrong offset!");
static_assert(offsetof(GzInteractionTooltip_OnFocusChange, bInInteractionRange) == 0x000008, "Member 'GzInteractionTooltip_OnFocusChange::bInInteractionRange' has a wrong offset!");

// Function G01.GzInteractionTooltip.OnFocusChange_BP
// 0x0010 (0x0010 - 0x0000)
struct GzInteractionTooltip_OnFocusChange_BP final
{
public:
	class UGzInteractableComponent*               Interactable;                                      // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bFocused;                                          // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_32EF[0x7];                                     // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GzInteractionTooltip_OnFocusChange_BP) == 0x000008, "Wrong alignment on GzInteractionTooltip_OnFocusChange_BP");
static_assert(sizeof(GzInteractionTooltip_OnFocusChange_BP) == 0x000010, "Wrong size on GzInteractionTooltip_OnFocusChange_BP");
static_assert(offsetof(GzInteractionTooltip_OnFocusChange_BP, Interactable) == 0x000000, "Member 'GzInteractionTooltip_OnFocusChange_BP::Interactable' has a wrong offset!");
static_assert(offsetof(GzInteractionTooltip_OnFocusChange_BP, bFocused) == 0x000008, "Member 'GzInteractionTooltip_OnFocusChange_BP::bFocused' has a wrong offset!");

// Function G01.GzInteractionTooltip.OnFollowFocusable_BP
// 0x0001 (0x0001 - 0x0000)
struct GzInteractionTooltip_OnFollowFocusable_BP final
{
public:
	bool                                          bShouldFollow;                                     // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzInteractionTooltip_OnFollowFocusable_BP) == 0x000001, "Wrong alignment on GzInteractionTooltip_OnFollowFocusable_BP");
static_assert(sizeof(GzInteractionTooltip_OnFollowFocusable_BP) == 0x000001, "Wrong size on GzInteractionTooltip_OnFollowFocusable_BP");
static_assert(offsetof(GzInteractionTooltip_OnFollowFocusable_BP, bShouldFollow) == 0x000000, "Member 'GzInteractionTooltip_OnFollowFocusable_BP::bShouldFollow' has a wrong offset!");

// Function G01.GzInteractionTooltip.SetFollowFocusable
// 0x0001 (0x0001 - 0x0000)
struct GzInteractionTooltip_SetFollowFocusable final
{
public:
	bool                                          bShouldFollow;                                     // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzInteractionTooltip_SetFollowFocusable) == 0x000001, "Wrong alignment on GzInteractionTooltip_SetFollowFocusable");
static_assert(sizeof(GzInteractionTooltip_SetFollowFocusable) == 0x000001, "Wrong size on GzInteractionTooltip_SetFollowFocusable");
static_assert(offsetof(GzInteractionTooltip_SetFollowFocusable, bShouldFollow) == 0x000000, "Member 'GzInteractionTooltip_SetFollowFocusable::bShouldFollow' has a wrong offset!");

// Function G01.GzInteractionTooltip.SetTooltipOffset
// 0x0018 (0x0018 - 0x0000)
struct GzInteractionTooltip_SetTooltipOffset final
{
public:
	struct FVector                                InOffset;                                          // 0x0000(0x0018)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzInteractionTooltip_SetTooltipOffset) == 0x000008, "Wrong alignment on GzInteractionTooltip_SetTooltipOffset");
static_assert(sizeof(GzInteractionTooltip_SetTooltipOffset) == 0x000018, "Wrong size on GzInteractionTooltip_SetTooltipOffset");
static_assert(offsetof(GzInteractionTooltip_SetTooltipOffset, InOffset) == 0x000000, "Member 'GzInteractionTooltip_SetTooltipOffset::InOffset' has a wrong offset!");

// Function G01.GzGA_Emotion.OnCancelEmotePressed
// 0x0004 (0x0004 - 0x0000)
struct GzGA_Emotion_OnCancelEmotePressed final
{
public:
	float                                         WaitTime;                                          // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzGA_Emotion_OnCancelEmotePressed) == 0x000004, "Wrong alignment on GzGA_Emotion_OnCancelEmotePressed");
static_assert(sizeof(GzGA_Emotion_OnCancelEmotePressed) == 0x000004, "Wrong size on GzGA_Emotion_OnCancelEmotePressed");
static_assert(offsetof(GzGA_Emotion_OnCancelEmotePressed, WaitTime) == 0x000000, "Member 'GzGA_Emotion_OnCancelEmotePressed::WaitTime' has a wrong offset!");

// Function G01.GzGA_Equip.OnTaskEvent
// 0x0008 (0x0008 - 0x0000)
struct GzGA_Equip_OnTaskEvent final
{
public:
	class UGzAbilityTaskBase*                     AbilityTask;                                       // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzGA_Equip_OnTaskEvent) == 0x000008, "Wrong alignment on GzGA_Equip_OnTaskEvent");
static_assert(sizeof(GzGA_Equip_OnTaskEvent) == 0x000008, "Wrong size on GzGA_Equip_OnTaskEvent");
static_assert(offsetof(GzGA_Equip_OnTaskEvent, AbilityTask) == 0x000000, "Member 'GzGA_Equip_OnTaskEvent::AbilityTask' has a wrong offset!");

// Function G01.GzGA_GorillaArm.BP_OnDashStarted
// 0x0018 (0x0018 - 0x0000)
struct GzGA_GorillaArm_BP_OnDashStarted final
{
public:
	struct FVector                                Direction;                                         // 0x0000(0x0018)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzGA_GorillaArm_BP_OnDashStarted) == 0x000008, "Wrong alignment on GzGA_GorillaArm_BP_OnDashStarted");
static_assert(sizeof(GzGA_GorillaArm_BP_OnDashStarted) == 0x000018, "Wrong size on GzGA_GorillaArm_BP_OnDashStarted");
static_assert(offsetof(GzGA_GorillaArm_BP_OnDashStarted, Direction) == 0x000000, "Member 'GzGA_GorillaArm_BP_OnDashStarted::Direction' has a wrong offset!");

// Function G01.GzGA_GorillaArm.BP_OnPunch
// 0x00F8 (0x00F8 - 0x0000)
struct GzGA_GorillaArm_BP_OnPunch final
{
public:
	struct FHitResult                             HitResult;                                         // 0x0000(0x00F8)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzGA_GorillaArm_BP_OnPunch) == 0x000008, "Wrong alignment on GzGA_GorillaArm_BP_OnPunch");
static_assert(sizeof(GzGA_GorillaArm_BP_OnPunch) == 0x0000F8, "Wrong size on GzGA_GorillaArm_BP_OnPunch");
static_assert(offsetof(GzGA_GorillaArm_BP_OnPunch, HitResult) == 0x000000, "Member 'GzGA_GorillaArm_BP_OnPunch::HitResult' has a wrong offset!");

// Function G01.GzGA_GorillaArm.OnDashEvent
// 0x00B0 (0x00B0 - 0x0000)
struct GzGA_GorillaArm_OnDashEvent final
{
public:
	struct FGameplayEventData                     Payload;                                           // 0x0000(0x00B0)(Parm, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzGA_GorillaArm_OnDashEvent) == 0x000008, "Wrong alignment on GzGA_GorillaArm_OnDashEvent");
static_assert(sizeof(GzGA_GorillaArm_OnDashEvent) == 0x0000B0, "Wrong size on GzGA_GorillaArm_OnDashEvent");
static_assert(offsetof(GzGA_GorillaArm_OnDashEvent, Payload) == 0x000000, "Member 'GzGA_GorillaArm_OnDashEvent::Payload' has a wrong offset!");

// Function G01.GzGA_GorillaArm.OnDashFinished
// 0x00B0 (0x00B0 - 0x0000)
struct GzGA_GorillaArm_OnDashFinished final
{
public:
	struct FGameplayEventData                     Payload;                                           // 0x0000(0x00B0)(Parm, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzGA_GorillaArm_OnDashFinished) == 0x000008, "Wrong alignment on GzGA_GorillaArm_OnDashFinished");
static_assert(sizeof(GzGA_GorillaArm_OnDashFinished) == 0x0000B0, "Wrong size on GzGA_GorillaArm_OnDashFinished");
static_assert(offsetof(GzGA_GorillaArm_OnDashFinished, Payload) == 0x000000, "Member 'GzGA_GorillaArm_OnDashFinished::Payload' has a wrong offset!");

// Function G01.GzGA_GorillaArm.ServerHandleClientPunchTargetData
// 0x0028 (0x0028 - 0x0000)
struct GzGA_GorillaArm_ServerHandleClientPunchTargetData final
{
public:
	struct FGameplayAbilityTargetDataHandle       TargetData;                                        // 0x0000(0x0028)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzGA_GorillaArm_ServerHandleClientPunchTargetData) == 0x000008, "Wrong alignment on GzGA_GorillaArm_ServerHandleClientPunchTargetData");
static_assert(sizeof(GzGA_GorillaArm_ServerHandleClientPunchTargetData) == 0x000028, "Wrong size on GzGA_GorillaArm_ServerHandleClientPunchTargetData");
static_assert(offsetof(GzGA_GorillaArm_ServerHandleClientPunchTargetData, TargetData) == 0x000000, "Member 'GzGA_GorillaArm_ServerHandleClientPunchTargetData::TargetData' has a wrong offset!");

// Function G01.GzGA_GrappleHook.OnPullCharacterAnimationNotification
// 0x0008 (0x0008 - 0x0000)
struct GzGA_GrappleHook_OnPullCharacterAnimationNotification final
{
public:
	class FName                                   NotifyName;                                        // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzGA_GrappleHook_OnPullCharacterAnimationNotification) == 0x000004, "Wrong alignment on GzGA_GrappleHook_OnPullCharacterAnimationNotification");
static_assert(sizeof(GzGA_GrappleHook_OnPullCharacterAnimationNotification) == 0x000008, "Wrong size on GzGA_GrappleHook_OnPullCharacterAnimationNotification");
static_assert(offsetof(GzGA_GrappleHook_OnPullCharacterAnimationNotification, NotifyName) == 0x000000, "Member 'GzGA_GrappleHook_OnPullCharacterAnimationNotification::NotifyName' has a wrong offset!");

// Function G01.GzGA_GrappleHook.OnThrowAnimationNotification
// 0x0008 (0x0008 - 0x0000)
struct GzGA_GrappleHook_OnThrowAnimationNotification final
{
public:
	class FName                                   NotifyName;                                        // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzGA_GrappleHook_OnThrowAnimationNotification) == 0x000004, "Wrong alignment on GzGA_GrappleHook_OnThrowAnimationNotification");
static_assert(sizeof(GzGA_GrappleHook_OnThrowAnimationNotification) == 0x000008, "Wrong size on GzGA_GrappleHook_OnThrowAnimationNotification");
static_assert(offsetof(GzGA_GrappleHook_OnThrowAnimationNotification, NotifyName) == 0x000000, "Member 'GzGA_GrappleHook_OnThrowAnimationNotification::NotifyName' has a wrong offset!");

// Function G01.GzGA_GrappleHook.IsTargetInRange
// 0x0001 (0x0001 - 0x0000)
struct GzGA_GrappleHook_IsTargetInRange final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzGA_GrappleHook_IsTargetInRange) == 0x000001, "Wrong alignment on GzGA_GrappleHook_IsTargetInRange");
static_assert(sizeof(GzGA_GrappleHook_IsTargetInRange) == 0x000001, "Wrong size on GzGA_GrappleHook_IsTargetInRange");
static_assert(offsetof(GzGA_GrappleHook_IsTargetInRange, ReturnValue) == 0x000000, "Member 'GzGA_GrappleHook_IsTargetInRange::ReturnValue' has a wrong offset!");

// Function G01.GzGA_GrappleHookEnemy.OnCancelInputReleased
// 0x0004 (0x0004 - 0x0000)
struct GzGA_GrappleHookEnemy_OnCancelInputReleased final
{
public:
	float                                         Time;                                              // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzGA_GrappleHookEnemy_OnCancelInputReleased) == 0x000004, "Wrong alignment on GzGA_GrappleHookEnemy_OnCancelInputReleased");
static_assert(sizeof(GzGA_GrappleHookEnemy_OnCancelInputReleased) == 0x000004, "Wrong size on GzGA_GrappleHookEnemy_OnCancelInputReleased");
static_assert(offsetof(GzGA_GrappleHookEnemy_OnCancelInputReleased, Time) == 0x000000, "Member 'GzGA_GrappleHookEnemy_OnCancelInputReleased::Time' has a wrong offset!");

// Function G01.GzGA_GrappleHookEnemy.OnPullEnded
// 0x00B0 (0x00B0 - 0x0000)
struct GzGA_GrappleHookEnemy_OnPullEnded final
{
public:
	struct FGameplayEventData                     Payload;                                           // 0x0000(0x00B0)(Parm, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzGA_GrappleHookEnemy_OnPullEnded) == 0x000008, "Wrong alignment on GzGA_GrappleHookEnemy_OnPullEnded");
static_assert(sizeof(GzGA_GrappleHookEnemy_OnPullEnded) == 0x0000B0, "Wrong size on GzGA_GrappleHookEnemy_OnPullEnded");
static_assert(offsetof(GzGA_GrappleHookEnemy_OnPullEnded, Payload) == 0x000000, "Member 'GzGA_GrappleHookEnemy_OnPullEnded::Payload' has a wrong offset!");

// Function G01.GzGA_GrapplePull.OnCancelInputReleased
// 0x0004 (0x0004 - 0x0000)
struct GzGA_GrapplePull_OnCancelInputReleased final
{
public:
	float                                         Time;                                              // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzGA_GrapplePull_OnCancelInputReleased) == 0x000004, "Wrong alignment on GzGA_GrapplePull_OnCancelInputReleased");
static_assert(sizeof(GzGA_GrapplePull_OnCancelInputReleased) == 0x000004, "Wrong size on GzGA_GrapplePull_OnCancelInputReleased");
static_assert(offsetof(GzGA_GrapplePull_OnCancelInputReleased, Time) == 0x000000, "Member 'GzGA_GrapplePull_OnCancelInputReleased::Time' has a wrong offset!");

// Function G01.GzGA_HexInsertion.OnAnimNotifyReceived
// 0x0008 (0x0008 - 0x0000)
struct GzGA_HexInsertion_OnAnimNotifyReceived final
{
public:
	class FName                                   NotifyName;                                        // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzGA_HexInsertion_OnAnimNotifyReceived) == 0x000004, "Wrong alignment on GzGA_HexInsertion_OnAnimNotifyReceived");
static_assert(sizeof(GzGA_HexInsertion_OnAnimNotifyReceived) == 0x000008, "Wrong size on GzGA_HexInsertion_OnAnimNotifyReceived");
static_assert(offsetof(GzGA_HexInsertion_OnAnimNotifyReceived, NotifyName) == 0x000000, "Member 'GzGA_HexInsertion_OnAnimNotifyReceived::NotifyName' has a wrong offset!");

// Function G01.GzGA_Interact.OnConnectionChanged
// 0x0008 (0x0008 - 0x0000)
struct GzGA_Interact_OnConnectionChanged final
{
public:
	class AGzPlayerState*                         InPlayerState;                                     // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzGA_Interact_OnConnectionChanged) == 0x000008, "Wrong alignment on GzGA_Interact_OnConnectionChanged");
static_assert(sizeof(GzGA_Interact_OnConnectionChanged) == 0x000008, "Wrong size on GzGA_Interact_OnConnectionChanged");
static_assert(offsetof(GzGA_Interact_OnConnectionChanged, InPlayerState) == 0x000000, "Member 'GzGA_Interact_OnConnectionChanged::InPlayerState' has a wrong offset!");

// Function G01.GzGA_Interact.OnMontageNotify
// 0x0008 (0x0008 - 0x0000)
struct GzGA_Interact_OnMontageNotify final
{
public:
	class FName                                   NotifyName;                                        // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzGA_Interact_OnMontageNotify) == 0x000004, "Wrong alignment on GzGA_Interact_OnMontageNotify");
static_assert(sizeof(GzGA_Interact_OnMontageNotify) == 0x000008, "Wrong size on GzGA_Interact_OnMontageNotify");
static_assert(offsetof(GzGA_Interact_OnMontageNotify, NotifyName) == 0x000000, "Member 'GzGA_Interact_OnMontageNotify::NotifyName' has a wrong offset!");

// Function G01.GzGA_JumpBoost.OnCharacterHit
// 0x0120 (0x0120 - 0x0000)
struct GzGA_JumpBoost_OnCharacterHit final
{
public:
	class AActor*                                 SelfActor;                                         // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 OtherActor;                                        // 0x0008(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                NormalImpulse;                                     // 0x0010(0x0018)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FHitResult                             Hit;                                               // 0x0028(0x00F8)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzGA_JumpBoost_OnCharacterHit) == 0x000008, "Wrong alignment on GzGA_JumpBoost_OnCharacterHit");
static_assert(sizeof(GzGA_JumpBoost_OnCharacterHit) == 0x000120, "Wrong size on GzGA_JumpBoost_OnCharacterHit");
static_assert(offsetof(GzGA_JumpBoost_OnCharacterHit, SelfActor) == 0x000000, "Member 'GzGA_JumpBoost_OnCharacterHit::SelfActor' has a wrong offset!");
static_assert(offsetof(GzGA_JumpBoost_OnCharacterHit, OtherActor) == 0x000008, "Member 'GzGA_JumpBoost_OnCharacterHit::OtherActor' has a wrong offset!");
static_assert(offsetof(GzGA_JumpBoost_OnCharacterHit, NormalImpulse) == 0x000010, "Member 'GzGA_JumpBoost_OnCharacterHit::NormalImpulse' has a wrong offset!");
static_assert(offsetof(GzGA_JumpBoost_OnCharacterHit, Hit) == 0x000028, "Member 'GzGA_JumpBoost_OnCharacterHit::Hit' has a wrong offset!");

// Function G01.GzGA_JumpBoost.OnMovementModeChanged
// 0x0010 (0x0010 - 0x0000)
struct GzGA_JumpBoost_OnMovementModeChanged final
{
public:
	class ACharacter*                             Character;                                         // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EMovementMode                                 PrevMovementMode;                                  // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         PreviousCustomMode;                                // 0x0009(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3300[0x6];                                     // 0x000A(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GzGA_JumpBoost_OnMovementModeChanged) == 0x000008, "Wrong alignment on GzGA_JumpBoost_OnMovementModeChanged");
static_assert(sizeof(GzGA_JumpBoost_OnMovementModeChanged) == 0x000010, "Wrong size on GzGA_JumpBoost_OnMovementModeChanged");
static_assert(offsetof(GzGA_JumpBoost_OnMovementModeChanged, Character) == 0x000000, "Member 'GzGA_JumpBoost_OnMovementModeChanged::Character' has a wrong offset!");
static_assert(offsetof(GzGA_JumpBoost_OnMovementModeChanged, PrevMovementMode) == 0x000008, "Member 'GzGA_JumpBoost_OnMovementModeChanged::PrevMovementMode' has a wrong offset!");
static_assert(offsetof(GzGA_JumpBoost_OnMovementModeChanged, PreviousCustomMode) == 0x000009, "Member 'GzGA_JumpBoost_OnMovementModeChanged::PreviousCustomMode' has a wrong offset!");

// Function G01.GzGA_KatanaArm.OnAttackStart
// 0x00B0 (0x00B0 - 0x0000)
struct GzGA_KatanaArm_OnAttackStart final
{
public:
	struct FGameplayEventData                     Payload;                                           // 0x0000(0x00B0)(Parm, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzGA_KatanaArm_OnAttackStart) == 0x000008, "Wrong alignment on GzGA_KatanaArm_OnAttackStart");
static_assert(sizeof(GzGA_KatanaArm_OnAttackStart) == 0x0000B0, "Wrong size on GzGA_KatanaArm_OnAttackStart");
static_assert(offsetof(GzGA_KatanaArm_OnAttackStart, Payload) == 0x000000, "Member 'GzGA_KatanaArm_OnAttackStart::Payload' has a wrong offset!");

// Function G01.GzGA_KatanaArm.OnDashEvent
// 0x00B0 (0x00B0 - 0x0000)
struct GzGA_KatanaArm_OnDashEvent final
{
public:
	struct FGameplayEventData                     Payload;                                           // 0x0000(0x00B0)(Parm, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzGA_KatanaArm_OnDashEvent) == 0x000008, "Wrong alignment on GzGA_KatanaArm_OnDashEvent");
static_assert(sizeof(GzGA_KatanaArm_OnDashEvent) == 0x0000B0, "Wrong size on GzGA_KatanaArm_OnDashEvent");
static_assert(offsetof(GzGA_KatanaArm_OnDashEvent, Payload) == 0x000000, "Member 'GzGA_KatanaArm_OnDashEvent::Payload' has a wrong offset!");

// Function G01.GzGA_KatanaArm.OnDashFinished
// 0x00B0 (0x00B0 - 0x0000)
struct GzGA_KatanaArm_OnDashFinished final
{
public:
	struct FGameplayEventData                     Payload;                                           // 0x0000(0x00B0)(Parm, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzGA_KatanaArm_OnDashFinished) == 0x000008, "Wrong alignment on GzGA_KatanaArm_OnDashFinished");
static_assert(sizeof(GzGA_KatanaArm_OnDashFinished) == 0x0000B0, "Wrong size on GzGA_KatanaArm_OnDashFinished");
static_assert(offsetof(GzGA_KatanaArm_OnDashFinished, Payload) == 0x000000, "Member 'GzGA_KatanaArm_OnDashFinished::Payload' has a wrong offset!");

// Function G01.GzGA_KatanaArm.ReceiveTargetData
// 0x0028 (0x0028 - 0x0000)
struct GzGA_KatanaArm_ReceiveTargetData final
{
public:
	struct FGameplayAbilityTargetDataHandle       TargetData;                                        // 0x0000(0x0028)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzGA_KatanaArm_ReceiveTargetData) == 0x000008, "Wrong alignment on GzGA_KatanaArm_ReceiveTargetData");
static_assert(sizeof(GzGA_KatanaArm_ReceiveTargetData) == 0x000028, "Wrong size on GzGA_KatanaArm_ReceiveTargetData");
static_assert(offsetof(GzGA_KatanaArm_ReceiveTargetData, TargetData) == 0x000000, "Member 'GzGA_KatanaArm_ReceiveTargetData::TargetData' has a wrong offset!");

// Function G01.GzGA_KineticShield.ApplyBlastDamage
// 0x0100 (0x0100 - 0x0000)
struct GzGA_KineticShield_ApplyBlastDamage final
{
public:
	struct FHitResult                             TargetHitResult;                                   // 0x0000(0x00F8)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	float                                         DamageAmount;                                      // 0x00F8(0x0004)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x00FC(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3306[0x3];                                     // 0x00FD(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GzGA_KineticShield_ApplyBlastDamage) == 0x000008, "Wrong alignment on GzGA_KineticShield_ApplyBlastDamage");
static_assert(sizeof(GzGA_KineticShield_ApplyBlastDamage) == 0x000100, "Wrong size on GzGA_KineticShield_ApplyBlastDamage");
static_assert(offsetof(GzGA_KineticShield_ApplyBlastDamage, TargetHitResult) == 0x000000, "Member 'GzGA_KineticShield_ApplyBlastDamage::TargetHitResult' has a wrong offset!");
static_assert(offsetof(GzGA_KineticShield_ApplyBlastDamage, DamageAmount) == 0x0000F8, "Member 'GzGA_KineticShield_ApplyBlastDamage::DamageAmount' has a wrong offset!");
static_assert(offsetof(GzGA_KineticShield_ApplyBlastDamage, ReturnValue) == 0x0000FC, "Member 'GzGA_KineticShield_ApplyBlastDamage::ReturnValue' has a wrong offset!");

// Function G01.GzMissionObjectInteractionBehavior.RegisterObjective
// 0x0008 (0x0008 - 0x0000)
struct GzMissionObjectInteractionBehavior_RegisterObjective final
{
public:
	class UGzObjective*                           Objective;                                         // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzMissionObjectInteractionBehavior_RegisterObjective) == 0x000008, "Wrong alignment on GzMissionObjectInteractionBehavior_RegisterObjective");
static_assert(sizeof(GzMissionObjectInteractionBehavior_RegisterObjective) == 0x000008, "Wrong size on GzMissionObjectInteractionBehavior_RegisterObjective");
static_assert(offsetof(GzMissionObjectInteractionBehavior_RegisterObjective, Objective) == 0x000000, "Member 'GzMissionObjectInteractionBehavior_RegisterObjective::Objective' has a wrong offset!");

// Function G01.GzMissionObjectInteractionBehavior.UnregisterObjective
// 0x0008 (0x0008 - 0x0000)
struct GzMissionObjectInteractionBehavior_UnregisterObjective final
{
public:
	class UGzObjective*                           Objective;                                         // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzMissionObjectInteractionBehavior_UnregisterObjective) == 0x000008, "Wrong alignment on GzMissionObjectInteractionBehavior_UnregisterObjective");
static_assert(sizeof(GzMissionObjectInteractionBehavior_UnregisterObjective) == 0x000008, "Wrong size on GzMissionObjectInteractionBehavior_UnregisterObjective");
static_assert(offsetof(GzMissionObjectInteractionBehavior_UnregisterObjective, Objective) == 0x000000, "Member 'GzMissionObjectInteractionBehavior_UnregisterObjective::Objective' has a wrong offset!");

// Function G01.GzProjectileAttackStrategy.ProcessAttackRequest
// 0x0038 (0x0038 - 0x0000)
struct GzProjectileAttackStrategy_ProcessAttackRequest final
{
public:
	struct FVector                                Location;                                          // 0x0000(0x0018)(ConstParm, Parm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Direction;                                         // 0x0018(0x0018)(ConstParm, Parm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         ShotID;                                            // 0x0030(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_330A[0x7];                                     // 0x0031(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GzProjectileAttackStrategy_ProcessAttackRequest) == 0x000008, "Wrong alignment on GzProjectileAttackStrategy_ProcessAttackRequest");
static_assert(sizeof(GzProjectileAttackStrategy_ProcessAttackRequest) == 0x000038, "Wrong size on GzProjectileAttackStrategy_ProcessAttackRequest");
static_assert(offsetof(GzProjectileAttackStrategy_ProcessAttackRequest, Location) == 0x000000, "Member 'GzProjectileAttackStrategy_ProcessAttackRequest::Location' has a wrong offset!");
static_assert(offsetof(GzProjectileAttackStrategy_ProcessAttackRequest, Direction) == 0x000018, "Member 'GzProjectileAttackStrategy_ProcessAttackRequest::Direction' has a wrong offset!");
static_assert(offsetof(GzProjectileAttackStrategy_ProcessAttackRequest, ShotID) == 0x000030, "Member 'GzProjectileAttackStrategy_ProcessAttackRequest::ShotID' has a wrong offset!");

// Function G01.GzGA_LimbPassive.GetAbilityData
// 0x0008 (0x0008 - 0x0000)
struct GzGA_LimbPassive_GetAbilityData final
{
public:
	class UGzBodyPartAbilityData*                 ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzGA_LimbPassive_GetAbilityData) == 0x000008, "Wrong alignment on GzGA_LimbPassive_GetAbilityData");
static_assert(sizeof(GzGA_LimbPassive_GetAbilityData) == 0x000008, "Wrong size on GzGA_LimbPassive_GetAbilityData");
static_assert(offsetof(GzGA_LimbPassive_GetAbilityData, ReturnValue) == 0x000000, "Member 'GzGA_LimbPassive_GetAbilityData::ReturnValue' has a wrong offset!");

// Function G01.GzGA_Mantle.UpdateTick
// 0x0004 (0x0004 - 0x0000)
struct GzGA_Mantle_UpdateTick final
{
public:
	float                                         DeltaTime;                                         // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzGA_Mantle_UpdateTick) == 0x000004, "Wrong alignment on GzGA_Mantle_UpdateTick");
static_assert(sizeof(GzGA_Mantle_UpdateTick) == 0x000004, "Wrong size on GzGA_Mantle_UpdateTick");
static_assert(offsetof(GzGA_Mantle_UpdateTick, DeltaTime) == 0x000000, "Member 'GzGA_Mantle_UpdateTick::DeltaTime' has a wrong offset!");

// Function G01.GzWeaponPickable.GetWeaponItem
// 0x0050 (0x0050 - 0x0000)
struct GzWeaponPickable_GetWeaponItem final
{
public:
	struct FGzWeaponInvItem                       ReturnValue;                                       // 0x0000(0x0050)(ConstParm, Parm, OutParm, ReturnParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzWeaponPickable_GetWeaponItem) == 0x000008, "Wrong alignment on GzWeaponPickable_GetWeaponItem");
static_assert(sizeof(GzWeaponPickable_GetWeaponItem) == 0x000050, "Wrong size on GzWeaponPickable_GetWeaponItem");
static_assert(offsetof(GzWeaponPickable_GetWeaponItem, ReturnValue) == 0x000000, "Member 'GzWeaponPickable_GetWeaponItem::ReturnValue' has a wrong offset!");

// Function G01.GzGA_SpiderMine.GetHandTransform
// 0x0018 (0x0018 - 0x0000)
struct GzGA_SpiderMine_GetHandTransform final
{
public:
	struct FVector                                ReturnValue;                                       // 0x0000(0x0018)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzGA_SpiderMine_GetHandTransform) == 0x000008, "Wrong alignment on GzGA_SpiderMine_GetHandTransform");
static_assert(sizeof(GzGA_SpiderMine_GetHandTransform) == 0x000018, "Wrong size on GzGA_SpiderMine_GetHandTransform");
static_assert(offsetof(GzGA_SpiderMine_GetHandTransform, ReturnValue) == 0x000000, "Member 'GzGA_SpiderMine_GetHandTransform::ReturnValue' has a wrong offset!");

// Function G01.GzGA_SpiderMine.OnMineInputRelease
// 0x0004 (0x0004 - 0x0000)
struct GzGA_SpiderMine_OnMineInputRelease final
{
public:
	float                                         TimeHeld;                                          // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzGA_SpiderMine_OnMineInputRelease) == 0x000004, "Wrong alignment on GzGA_SpiderMine_OnMineInputRelease");
static_assert(sizeof(GzGA_SpiderMine_OnMineInputRelease) == 0x000004, "Wrong size on GzGA_SpiderMine_OnMineInputRelease");
static_assert(offsetof(GzGA_SpiderMine_OnMineInputRelease, TimeHeld) == 0x000000, "Member 'GzGA_SpiderMine_OnMineInputRelease::TimeHeld' has a wrong offset!");

// Function G01.GzGA_SpiderMine.OnReceiveTargetLocationOnServer
// 0x0028 (0x0028 - 0x0000)
struct GzGA_SpiderMine_OnReceiveTargetLocationOnServer final
{
public:
	struct FGameplayAbilityTargetDataHandle       TargetDataHandle;                                  // 0x0000(0x0028)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzGA_SpiderMine_OnReceiveTargetLocationOnServer) == 0x000008, "Wrong alignment on GzGA_SpiderMine_OnReceiveTargetLocationOnServer");
static_assert(sizeof(GzGA_SpiderMine_OnReceiveTargetLocationOnServer) == 0x000028, "Wrong size on GzGA_SpiderMine_OnReceiveTargetLocationOnServer");
static_assert(offsetof(GzGA_SpiderMine_OnReceiveTargetLocationOnServer, TargetDataHandle) == 0x000000, "Member 'GzGA_SpiderMine_OnReceiveTargetLocationOnServer::TargetDataHandle' has a wrong offset!");

// Function G01.GzGA_SpiderMine.SpawnMine
// 0x0070 (0x0070 - 0x0000)
struct GzGA_SpiderMine_SpawnMine final
{
public:
	struct FTransform                             Transform;                                         // 0x0000(0x0060)(Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGzSpiderMine_SpawnInfo                SpawnInfo;                                         // 0x0060(0x0004)(Parm, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_3314[0x4];                                     // 0x0064(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class AGzSpiderMine*                          ReturnValue;                                       // 0x0068(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzGA_SpiderMine_SpawnMine) == 0x000010, "Wrong alignment on GzGA_SpiderMine_SpawnMine");
static_assert(sizeof(GzGA_SpiderMine_SpawnMine) == 0x000070, "Wrong size on GzGA_SpiderMine_SpawnMine");
static_assert(offsetof(GzGA_SpiderMine_SpawnMine, Transform) == 0x000000, "Member 'GzGA_SpiderMine_SpawnMine::Transform' has a wrong offset!");
static_assert(offsetof(GzGA_SpiderMine_SpawnMine, SpawnInfo) == 0x000060, "Member 'GzGA_SpiderMine_SpawnMine::SpawnInfo' has a wrong offset!");
static_assert(offsetof(GzGA_SpiderMine_SpawnMine, ReturnValue) == 0x000068, "Member 'GzGA_SpiderMine_SpawnMine::ReturnValue' has a wrong offset!");

// Function G01.GzGA_SuperSprint_Sprint.OnSprintConditionFailed
// 0x00B0 (0x00B0 - 0x0000)
struct GzGA_SuperSprint_Sprint_OnSprintConditionFailed final
{
public:
	struct FGameplayEventData                     Payload;                                           // 0x0000(0x00B0)(Parm, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzGA_SuperSprint_Sprint_OnSprintConditionFailed) == 0x000008, "Wrong alignment on GzGA_SuperSprint_Sprint_OnSprintConditionFailed");
static_assert(sizeof(GzGA_SuperSprint_Sprint_OnSprintConditionFailed) == 0x0000B0, "Wrong size on GzGA_SuperSprint_Sprint_OnSprintConditionFailed");
static_assert(offsetof(GzGA_SuperSprint_Sprint_OnSprintConditionFailed, Payload) == 0x000000, "Member 'GzGA_SuperSprint_Sprint_OnSprintConditionFailed::Payload' has a wrong offset!");

// Function G01.GzGA_ThrowableShield.HandleAbilityInputPressed
// 0x0004 (0x0004 - 0x0000)
struct GzGA_ThrowableShield_HandleAbilityInputPressed final
{
public:
	float                                         TimeHeld;                                          // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzGA_ThrowableShield_HandleAbilityInputPressed) == 0x000004, "Wrong alignment on GzGA_ThrowableShield_HandleAbilityInputPressed");
static_assert(sizeof(GzGA_ThrowableShield_HandleAbilityInputPressed) == 0x000004, "Wrong size on GzGA_ThrowableShield_HandleAbilityInputPressed");
static_assert(offsetof(GzGA_ThrowableShield_HandleAbilityInputPressed, TimeHeld) == 0x000000, "Member 'GzGA_ThrowableShield_HandleAbilityInputPressed::TimeHeld' has a wrong offset!");

// Function G01.GzGA_ThrowableShield.HandleLaunchInputPressed
// 0x0004 (0x0004 - 0x0000)
struct GzGA_ThrowableShield_HandleLaunchInputPressed final
{
public:
	float                                         TimeHeld;                                          // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzGA_ThrowableShield_HandleLaunchInputPressed) == 0x000004, "Wrong alignment on GzGA_ThrowableShield_HandleLaunchInputPressed");
static_assert(sizeof(GzGA_ThrowableShield_HandleLaunchInputPressed) == 0x000004, "Wrong size on GzGA_ThrowableShield_HandleLaunchInputPressed");
static_assert(offsetof(GzGA_ThrowableShield_HandleLaunchInputPressed, TimeHeld) == 0x000000, "Member 'GzGA_ThrowableShield_HandleLaunchInputPressed::TimeHeld' has a wrong offset!");

// Function G01.GzGA_ThrowableShield.HandleLaunchInputReleased
// 0x0004 (0x0004 - 0x0000)
struct GzGA_ThrowableShield_HandleLaunchInputReleased final
{
public:
	float                                         TimeHeld;                                          // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzGA_ThrowableShield_HandleLaunchInputReleased) == 0x000004, "Wrong alignment on GzGA_ThrowableShield_HandleLaunchInputReleased");
static_assert(sizeof(GzGA_ThrowableShield_HandleLaunchInputReleased) == 0x000004, "Wrong size on GzGA_ThrowableShield_HandleLaunchInputReleased");
static_assert(offsetof(GzGA_ThrowableShield_HandleLaunchInputReleased, TimeHeld) == 0x000000, "Member 'GzGA_ThrowableShield_HandleLaunchInputReleased::TimeHeld' has a wrong offset!");

// Function G01.GzGA_ThrowableShield.ReceiveClientTargetData
// 0x0028 (0x0028 - 0x0000)
struct GzGA_ThrowableShield_ReceiveClientTargetData final
{
public:
	struct FGameplayAbilityTargetDataHandle       TargetData;                                        // 0x0000(0x0028)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzGA_ThrowableShield_ReceiveClientTargetData) == 0x000008, "Wrong alignment on GzGA_ThrowableShield_ReceiveClientTargetData");
static_assert(sizeof(GzGA_ThrowableShield_ReceiveClientTargetData) == 0x000028, "Wrong size on GzGA_ThrowableShield_ReceiveClientTargetData");
static_assert(offsetof(GzGA_ThrowableShield_ReceiveClientTargetData, TargetData) == 0x000000, "Member 'GzGA_ThrowableShield_ReceiveClientTargetData::TargetData' has a wrong offset!");

// Function G01.GzGenericCharacter.OnHealthChange
// 0x0004 (0x0004 - 0x0000)
struct GzGenericCharacter_OnHealthChange final
{
public:
	float                                         Health;                                            // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzGenericCharacter_OnHealthChange) == 0x000004, "Wrong alignment on GzGenericCharacter_OnHealthChange");
static_assert(sizeof(GzGenericCharacter_OnHealthChange) == 0x000004, "Wrong size on GzGenericCharacter_OnHealthChange");
static_assert(offsetof(GzGenericCharacter_OnHealthChange, Health) == 0x000000, "Member 'GzGenericCharacter_OnHealthChange::Health' has a wrong offset!");

// Function G01.GzGridOverloadStatCollector.OnOverloadActivated
// 0x0001 (0x0001 - 0x0000)
struct GzGridOverloadStatCollector_OnOverloadActivated final
{
public:
	bool                                          bActivated;                                        // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzGridOverloadStatCollector_OnOverloadActivated) == 0x000001, "Wrong alignment on GzGridOverloadStatCollector_OnOverloadActivated");
static_assert(sizeof(GzGridOverloadStatCollector_OnOverloadActivated) == 0x000001, "Wrong size on GzGridOverloadStatCollector_OnOverloadActivated");
static_assert(offsetof(GzGridOverloadStatCollector_OnOverloadActivated, bActivated) == 0x000000, "Member 'GzGridOverloadStatCollector_OnOverloadActivated::bActivated' has a wrong offset!");

// Function G01.GzXR_MatchInProgressStage.OnTeamAliveStateChanged
// 0x0008 (0x0008 - 0x0000)
struct GzXR_MatchInProgressStage_OnTeamAliveStateChanged final
{
public:
	class AGzTeam*                                Team;                                              // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzXR_MatchInProgressStage_OnTeamAliveStateChanged) == 0x000008, "Wrong alignment on GzXR_MatchInProgressStage_OnTeamAliveStateChanged");
static_assert(sizeof(GzXR_MatchInProgressStage_OnTeamAliveStateChanged) == 0x000008, "Wrong size on GzXR_MatchInProgressStage_OnTeamAliveStateChanged");
static_assert(offsetof(GzXR_MatchInProgressStage_OnTeamAliveStateChanged, Team) == 0x000000, "Member 'GzXR_MatchInProgressStage_OnTeamAliveStateChanged::Team' has a wrong offset!");

// Function G01.GzXR_MatchInProgressStage.OnTeamChanged
// 0x0010 (0x0010 - 0x0000)
struct GzXR_MatchInProgressStage_OnTeamChanged final
{
public:
	class AGzPlayerState*                         PlayerState;                                       // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         PrevTeamID;                                        // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         NewTeamId;                                         // 0x000C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzXR_MatchInProgressStage_OnTeamChanged) == 0x000008, "Wrong alignment on GzXR_MatchInProgressStage_OnTeamChanged");
static_assert(sizeof(GzXR_MatchInProgressStage_OnTeamChanged) == 0x000010, "Wrong size on GzXR_MatchInProgressStage_OnTeamChanged");
static_assert(offsetof(GzXR_MatchInProgressStage_OnTeamChanged, PlayerState) == 0x000000, "Member 'GzXR_MatchInProgressStage_OnTeamChanged::PlayerState' has a wrong offset!");
static_assert(offsetof(GzXR_MatchInProgressStage_OnTeamChanged, PrevTeamID) == 0x000008, "Member 'GzXR_MatchInProgressStage_OnTeamChanged::PrevTeamID' has a wrong offset!");
static_assert(offsetof(GzXR_MatchInProgressStage_OnTeamChanged, NewTeamId) == 0x00000C, "Member 'GzXR_MatchInProgressStage_OnTeamChanged::NewTeamId' has a wrong offset!");

// Function G01.GzXR_MatchInProgressStage.SetupInitialAutoRedeploy
// 0x0018 (0x0018 - 0x0000)
struct GzXR_MatchInProgressStage_SetupInitialAutoRedeploy final
{
public:
	class APlayerState*                           Player;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class APawn*                                  NewPawn;                                           // 0x0008(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class APawn*                                  OldPawn;                                           // 0x0010(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzXR_MatchInProgressStage_SetupInitialAutoRedeploy) == 0x000008, "Wrong alignment on GzXR_MatchInProgressStage_SetupInitialAutoRedeploy");
static_assert(sizeof(GzXR_MatchInProgressStage_SetupInitialAutoRedeploy) == 0x000018, "Wrong size on GzXR_MatchInProgressStage_SetupInitialAutoRedeploy");
static_assert(offsetof(GzXR_MatchInProgressStage_SetupInitialAutoRedeploy, Player) == 0x000000, "Member 'GzXR_MatchInProgressStage_SetupInitialAutoRedeploy::Player' has a wrong offset!");
static_assert(offsetof(GzXR_MatchInProgressStage_SetupInitialAutoRedeploy, NewPawn) == 0x000008, "Member 'GzXR_MatchInProgressStage_SetupInitialAutoRedeploy::NewPawn' has a wrong offset!");
static_assert(offsetof(GzXR_MatchInProgressStage_SetupInitialAutoRedeploy, OldPawn) == 0x000010, "Member 'GzXR_MatchInProgressStage_SetupInitialAutoRedeploy::OldPawn' has a wrong offset!");

// Function G01.GzTetherLink.ApplySlowEffect
// 0x0008 (0x0008 - 0x0000)
struct GzTetherLink_ApplySlowEffect final
{
public:
	class UAbilitySystemComponent*                TargetASC;                                         // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzTetherLink_ApplySlowEffect) == 0x000008, "Wrong alignment on GzTetherLink_ApplySlowEffect");
static_assert(sizeof(GzTetherLink_ApplySlowEffect) == 0x000008, "Wrong size on GzTetherLink_ApplySlowEffect");
static_assert(offsetof(GzTetherLink_ApplySlowEffect, TargetASC) == 0x000000, "Member 'GzTetherLink_ApplySlowEffect::TargetASC' has a wrong offset!");

// Function G01.GzTetherLink.ApplyTrapDamage
// 0x0020 (0x0020 - 0x0000)
struct GzTetherLink_ApplyTrapDamage final
{
public:
	class UAbilitySystemComponent*                TargetASC;                                         // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                ExplosionOrigin;                                   // 0x0008(0x0018)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzTetherLink_ApplyTrapDamage) == 0x000008, "Wrong alignment on GzTetherLink_ApplyTrapDamage");
static_assert(sizeof(GzTetherLink_ApplyTrapDamage) == 0x000020, "Wrong size on GzTetherLink_ApplyTrapDamage");
static_assert(offsetof(GzTetherLink_ApplyTrapDamage, TargetASC) == 0x000000, "Member 'GzTetherLink_ApplyTrapDamage::TargetASC' has a wrong offset!");
static_assert(offsetof(GzTetherLink_ApplyTrapDamage, ExplosionOrigin) == 0x000008, "Member 'GzTetherLink_ApplyTrapDamage::ExplosionOrigin' has a wrong offset!");

// Function G01.GzHitmark.GetDisplayAnimation
// 0x0008 (0x0008 - 0x0000)
struct GzHitmark_GetDisplayAnimation final
{
public:
	class UWidgetAnimation*                       ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzHitmark_GetDisplayAnimation) == 0x000008, "Wrong alignment on GzHitmark_GetDisplayAnimation");
static_assert(sizeof(GzHitmark_GetDisplayAnimation) == 0x000008, "Wrong size on GzHitmark_GetDisplayAnimation");
static_assert(offsetof(GzHitmark_GetDisplayAnimation, ReturnValue) == 0x000000, "Member 'GzHitmark_GetDisplayAnimation::ReturnValue' has a wrong offset!");

// Function G01.GzHitmarkContainer.NotifyHitResponse
// 0x0038 (0x0038 - 0x0000)
struct GzHitmarkContainer_NotifyHitResponse final
{
public:
	struct FGzHitResponseData                     HitResponseData;                                   // 0x0000(0x0038)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzHitmarkContainer_NotifyHitResponse) == 0x000008, "Wrong alignment on GzHitmarkContainer_NotifyHitResponse");
static_assert(sizeof(GzHitmarkContainer_NotifyHitResponse) == 0x000038, "Wrong size on GzHitmarkContainer_NotifyHitResponse");
static_assert(offsetof(GzHitmarkContainer_NotifyHitResponse, HitResponseData) == 0x000000, "Member 'GzHitmarkContainer_NotifyHitResponse::HitResponseData' has a wrong offset!");

// Function G01.GzHitScanAttackStrategy.ClientProcessValidationInfo
// 0x0008 (0x0008 - 0x0000)
struct GzHitScanAttackStrategy_ClientProcessValidationInfo final
{
public:
	struct FGzHitValidationInfo                   ValidationInfo;                                    // 0x0000(0x0008)(ConstParm, Parm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzHitScanAttackStrategy_ClientProcessValidationInfo) == 0x000004, "Wrong alignment on GzHitScanAttackStrategy_ClientProcessValidationInfo");
static_assert(sizeof(GzHitScanAttackStrategy_ClientProcessValidationInfo) == 0x000008, "Wrong size on GzHitScanAttackStrategy_ClientProcessValidationInfo");
static_assert(offsetof(GzHitScanAttackStrategy_ClientProcessValidationInfo, ValidationInfo) == 0x000000, "Member 'GzHitScanAttackStrategy_ClientProcessValidationInfo::ValidationInfo' has a wrong offset!");

// Function G01.GzHitScanAttackStrategy.NotifyAttack
// 0x0070 (0x0070 - 0x0000)
struct GzHitScanAttackStrategy_NotifyAttack final
{
public:
	struct FVector                                SpawnLocation;                                     // 0x0000(0x0018)(ConstParm, Parm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               SpawnRotation;                                     // 0x0018(0x0018)(ConstParm, Parm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FGzShootNotificationInfo               NotificationInfo;                                  // 0x0030(0x0040)(ConstParm, Parm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzHitScanAttackStrategy_NotifyAttack) == 0x000008, "Wrong alignment on GzHitScanAttackStrategy_NotifyAttack");
static_assert(sizeof(GzHitScanAttackStrategy_NotifyAttack) == 0x000070, "Wrong size on GzHitScanAttackStrategy_NotifyAttack");
static_assert(offsetof(GzHitScanAttackStrategy_NotifyAttack, SpawnLocation) == 0x000000, "Member 'GzHitScanAttackStrategy_NotifyAttack::SpawnLocation' has a wrong offset!");
static_assert(offsetof(GzHitScanAttackStrategy_NotifyAttack, SpawnRotation) == 0x000018, "Member 'GzHitScanAttackStrategy_NotifyAttack::SpawnRotation' has a wrong offset!");
static_assert(offsetof(GzHitScanAttackStrategy_NotifyAttack, NotificationInfo) == 0x000030, "Member 'GzHitScanAttackStrategy_NotifyAttack::NotificationInfo' has a wrong offset!");

// Function G01.GzHitScanAttackStrategy.ServerProcessAttackRequest
// 0x0070 (0x0070 - 0x0000)
struct GzHitScanAttackStrategy_ServerProcessAttackRequest final
{
public:
	struct FVector                                SpawnLocation;                                     // 0x0000(0x0018)(ConstParm, Parm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               SpawnRotation;                                     // 0x0018(0x0018)(ConstParm, Parm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FGzHitReport                           HitReport;                                         // 0x0030(0x0040)(ConstParm, Parm, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzHitScanAttackStrategy_ServerProcessAttackRequest) == 0x000008, "Wrong alignment on GzHitScanAttackStrategy_ServerProcessAttackRequest");
static_assert(sizeof(GzHitScanAttackStrategy_ServerProcessAttackRequest) == 0x000070, "Wrong size on GzHitScanAttackStrategy_ServerProcessAttackRequest");
static_assert(offsetof(GzHitScanAttackStrategy_ServerProcessAttackRequest, SpawnLocation) == 0x000000, "Member 'GzHitScanAttackStrategy_ServerProcessAttackRequest::SpawnLocation' has a wrong offset!");
static_assert(offsetof(GzHitScanAttackStrategy_ServerProcessAttackRequest, SpawnRotation) == 0x000018, "Member 'GzHitScanAttackStrategy_ServerProcessAttackRequest::SpawnRotation' has a wrong offset!");
static_assert(offsetof(GzHitScanAttackStrategy_ServerProcessAttackRequest, HitReport) == 0x000030, "Member 'GzHitScanAttackStrategy_ServerProcessAttackRequest::HitReport' has a wrong offset!");

// Function G01.GzHUD.AddWidget
// 0x0018 (0x0018 - 0x0000)
struct GzHUD_AddWidget final
{
public:
	TSubclassOf<class UUserWidget>                WidgetClass;                                       // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           WidgetId;                                          // 0x0008(0x0008)(Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UUserWidget*                            ReturnValue;                                       // 0x0010(0x0008)(ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzHUD_AddWidget) == 0x000008, "Wrong alignment on GzHUD_AddWidget");
static_assert(sizeof(GzHUD_AddWidget) == 0x000018, "Wrong size on GzHUD_AddWidget");
static_assert(offsetof(GzHUD_AddWidget, WidgetClass) == 0x000000, "Member 'GzHUD_AddWidget::WidgetClass' has a wrong offset!");
static_assert(offsetof(GzHUD_AddWidget, WidgetId) == 0x000008, "Member 'GzHUD_AddWidget::WidgetId' has a wrong offset!");
static_assert(offsetof(GzHUD_AddWidget, ReturnValue) == 0x000010, "Member 'GzHUD_AddWidget::ReturnValue' has a wrong offset!");

// Function G01.GzHUD.EnableCohtmlInput
// 0x0002 (0x0002 - 0x0000)
struct GzHUD_EnableCohtmlInput final
{
public:
	bool                                          bFocus;                                            // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0001(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzHUD_EnableCohtmlInput) == 0x000001, "Wrong alignment on GzHUD_EnableCohtmlInput");
static_assert(sizeof(GzHUD_EnableCohtmlInput) == 0x000002, "Wrong size on GzHUD_EnableCohtmlInput");
static_assert(offsetof(GzHUD_EnableCohtmlInput, bFocus) == 0x000000, "Member 'GzHUD_EnableCohtmlInput::bFocus' has a wrong offset!");
static_assert(offsetof(GzHUD_EnableCohtmlInput, ReturnValue) == 0x000001, "Member 'GzHUD_EnableCohtmlInput::ReturnValue' has a wrong offset!");

// Function G01.GzHUD.RemoveWidget
// 0x0008 (0x0008 - 0x0000)
struct GzHUD_RemoveWidget final
{
public:
	struct FGameplayTag                           WidgetId;                                          // 0x0000(0x0008)(Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzHUD_RemoveWidget) == 0x000004, "Wrong alignment on GzHUD_RemoveWidget");
static_assert(sizeof(GzHUD_RemoveWidget) == 0x000008, "Wrong size on GzHUD_RemoveWidget");
static_assert(offsetof(GzHUD_RemoveWidget, WidgetId) == 0x000000, "Member 'GzHUD_RemoveWidget::WidgetId' has a wrong offset!");

// Function G01.GzHUD.ToggleCohtmlUIVisibility
// 0x0001 (0x0001 - 0x0000)
struct GzHUD_ToggleCohtmlUIVisibility final
{
public:
	bool                                          bFocus;                                            // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzHUD_ToggleCohtmlUIVisibility) == 0x000001, "Wrong alignment on GzHUD_ToggleCohtmlUIVisibility");
static_assert(sizeof(GzHUD_ToggleCohtmlUIVisibility) == 0x000001, "Wrong size on GzHUD_ToggleCohtmlUIVisibility");
static_assert(offsetof(GzHUD_ToggleCohtmlUIVisibility, bFocus) == 0x000000, "Member 'GzHUD_ToggleCohtmlUIVisibility::bFocus' has a wrong offset!");

// Function G01.GzInteractionDataInterface.GetCurrentInteractionInfo
// 0x0120 (0x0120 - 0x0000)
struct GzInteractionDataInterface_GetCurrentInteractionInfo final
{
public:
	const class AGzCharacter*                     InteractedBy;                                      // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FGzInteractionInfo>             InteractionInfoArray;                              // 0x0008(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FGameplayTag                           OutInteractionTag;                                 // 0x0018(0x0008)(Parm, OutParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGzInteractionData                     OutInteractionData;                                // 0x0020(0x00F8)(Parm, OutParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0118(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3339[0x7];                                     // 0x0119(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GzInteractionDataInterface_GetCurrentInteractionInfo) == 0x000008, "Wrong alignment on GzInteractionDataInterface_GetCurrentInteractionInfo");
static_assert(sizeof(GzInteractionDataInterface_GetCurrentInteractionInfo) == 0x000120, "Wrong size on GzInteractionDataInterface_GetCurrentInteractionInfo");
static_assert(offsetof(GzInteractionDataInterface_GetCurrentInteractionInfo, InteractedBy) == 0x000000, "Member 'GzInteractionDataInterface_GetCurrentInteractionInfo::InteractedBy' has a wrong offset!");
static_assert(offsetof(GzInteractionDataInterface_GetCurrentInteractionInfo, InteractionInfoArray) == 0x000008, "Member 'GzInteractionDataInterface_GetCurrentInteractionInfo::InteractionInfoArray' has a wrong offset!");
static_assert(offsetof(GzInteractionDataInterface_GetCurrentInteractionInfo, OutInteractionTag) == 0x000018, "Member 'GzInteractionDataInterface_GetCurrentInteractionInfo::OutInteractionTag' has a wrong offset!");
static_assert(offsetof(GzInteractionDataInterface_GetCurrentInteractionInfo, OutInteractionData) == 0x000020, "Member 'GzInteractionDataInterface_GetCurrentInteractionInfo::OutInteractionData' has a wrong offset!");
static_assert(offsetof(GzInteractionDataInterface_GetCurrentInteractionInfo, ReturnValue) == 0x000118, "Member 'GzInteractionDataInterface_GetCurrentInteractionInfo::ReturnValue' has a wrong offset!");

// Function G01.GzSymbolEncodeWidget.SetHexString
// 0x0010 (0x0010 - 0x0000)
struct GzSymbolEncodeWidget_SetHexString final
{
public:
	class FString                                 InString;                                          // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzSymbolEncodeWidget_SetHexString) == 0x000008, "Wrong alignment on GzSymbolEncodeWidget_SetHexString");
static_assert(sizeof(GzSymbolEncodeWidget_SetHexString) == 0x000010, "Wrong size on GzSymbolEncodeWidget_SetHexString");
static_assert(offsetof(GzSymbolEncodeWidget_SetHexString, InString) == 0x000000, "Member 'GzSymbolEncodeWidget_SetHexString::InString' has a wrong offset!");

// Function G01.GzWorldSettings.GetLayerWorldZones
// 0x0018 (0x0018 - 0x0000)
struct GzWorldSettings_GetLayerWorldZones final
{
public:
	class FName                                   Layer;                                             // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class UGzWorldZone*>                   ReturnValue;                                       // 0x0008(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzWorldSettings_GetLayerWorldZones) == 0x000008, "Wrong alignment on GzWorldSettings_GetLayerWorldZones");
static_assert(sizeof(GzWorldSettings_GetLayerWorldZones) == 0x000018, "Wrong size on GzWorldSettings_GetLayerWorldZones");
static_assert(offsetof(GzWorldSettings_GetLayerWorldZones, Layer) == 0x000000, "Member 'GzWorldSettings_GetLayerWorldZones::Layer' has a wrong offset!");
static_assert(offsetof(GzWorldSettings_GetLayerWorldZones, ReturnValue) == 0x000008, "Member 'GzWorldSettings_GetLayerWorldZones::ReturnValue' has a wrong offset!");

// Function G01.GzWorldZonesSubsystem.GetNumActorsInWorldZone
// 0x0018 (0x0018 - 0x0000)
struct GzWorldZonesSubsystem_GetNumActorsInWorldZone final
{
public:
	class UClass*                                 Param_Class;                                       // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UGzWorldZone*                           InZone;                                            // 0x0008(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ReturnValue;                                       // 0x0010(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3345[0x4];                                     // 0x0014(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GzWorldZonesSubsystem_GetNumActorsInWorldZone) == 0x000008, "Wrong alignment on GzWorldZonesSubsystem_GetNumActorsInWorldZone");
static_assert(sizeof(GzWorldZonesSubsystem_GetNumActorsInWorldZone) == 0x000018, "Wrong size on GzWorldZonesSubsystem_GetNumActorsInWorldZone");
static_assert(offsetof(GzWorldZonesSubsystem_GetNumActorsInWorldZone, Param_Class) == 0x000000, "Member 'GzWorldZonesSubsystem_GetNumActorsInWorldZone::Param_Class' has a wrong offset!");
static_assert(offsetof(GzWorldZonesSubsystem_GetNumActorsInWorldZone, InZone) == 0x000008, "Member 'GzWorldZonesSubsystem_GetNumActorsInWorldZone::InZone' has a wrong offset!");
static_assert(offsetof(GzWorldZonesSubsystem_GetNumActorsInWorldZone, ReturnValue) == 0x000010, "Member 'GzWorldZonesSubsystem_GetNumActorsInWorldZone::ReturnValue' has a wrong offset!");

// Function G01.GzWorldZonesSubsystem.GetWorldZoneNames
// 0x0018 (0x0018 - 0x0000)
struct GzWorldZonesSubsystem_GetWorldZoneNames final
{
public:
	class FName                                   Layer;                                             // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class FName>                           ReturnValue;                                       // 0x0008(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzWorldZonesSubsystem_GetWorldZoneNames) == 0x000008, "Wrong alignment on GzWorldZonesSubsystem_GetWorldZoneNames");
static_assert(sizeof(GzWorldZonesSubsystem_GetWorldZoneNames) == 0x000018, "Wrong size on GzWorldZonesSubsystem_GetWorldZoneNames");
static_assert(offsetof(GzWorldZonesSubsystem_GetWorldZoneNames, Layer) == 0x000000, "Member 'GzWorldZonesSubsystem_GetWorldZoneNames::Layer' has a wrong offset!");
static_assert(offsetof(GzWorldZonesSubsystem_GetWorldZoneNames, ReturnValue) == 0x000008, "Member 'GzWorldZonesSubsystem_GetWorldZoneNames::ReturnValue' has a wrong offset!");

// Function G01.GzWorldZonesSubsystem.GetZoneByPosition
// 0x0020 (0x0020 - 0x0000)
struct GzWorldZonesSubsystem_GetZoneByPosition final
{
public:
	class FName                                   Layer;                                             // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              Position;                                          // 0x0008(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	const class UGzWorldZone*                     ReturnValue;                                       // 0x0018(0x0008)(ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzWorldZonesSubsystem_GetZoneByPosition) == 0x000008, "Wrong alignment on GzWorldZonesSubsystem_GetZoneByPosition");
static_assert(sizeof(GzWorldZonesSubsystem_GetZoneByPosition) == 0x000020, "Wrong size on GzWorldZonesSubsystem_GetZoneByPosition");
static_assert(offsetof(GzWorldZonesSubsystem_GetZoneByPosition, Layer) == 0x000000, "Member 'GzWorldZonesSubsystem_GetZoneByPosition::Layer' has a wrong offset!");
static_assert(offsetof(GzWorldZonesSubsystem_GetZoneByPosition, Position) == 0x000008, "Member 'GzWorldZonesSubsystem_GetZoneByPosition::Position' has a wrong offset!");
static_assert(offsetof(GzWorldZonesSubsystem_GetZoneByPosition, ReturnValue) == 0x000018, "Member 'GzWorldZonesSubsystem_GetZoneByPosition::ReturnValue' has a wrong offset!");

// Function G01.GzWorldZonesSubsystem.GetZoneDisplayName
// 0x0030 (0x0030 - 0x0000)
struct GzWorldZonesSubsystem_GetZoneDisplayName final
{
public:
	class FName                                   Layer;                                             // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Location;                                          // 0x0008(0x0018)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   ReturnValue;                                       // 0x0020(0x0010)(Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzWorldZonesSubsystem_GetZoneDisplayName) == 0x000008, "Wrong alignment on GzWorldZonesSubsystem_GetZoneDisplayName");
static_assert(sizeof(GzWorldZonesSubsystem_GetZoneDisplayName) == 0x000030, "Wrong size on GzWorldZonesSubsystem_GetZoneDisplayName");
static_assert(offsetof(GzWorldZonesSubsystem_GetZoneDisplayName, Layer) == 0x000000, "Member 'GzWorldZonesSubsystem_GetZoneDisplayName::Layer' has a wrong offset!");
static_assert(offsetof(GzWorldZonesSubsystem_GetZoneDisplayName, Location) == 0x000008, "Member 'GzWorldZonesSubsystem_GetZoneDisplayName::Location' has a wrong offset!");
static_assert(offsetof(GzWorldZonesSubsystem_GetZoneDisplayName, ReturnValue) == 0x000020, "Member 'GzWorldZonesSubsystem_GetZoneDisplayName::ReturnValue' has a wrong offset!");

// Function G01.GzWorldZonesSubsystem.GetZoneName
// 0x0028 (0x0028 - 0x0000)
struct GzWorldZonesSubsystem_GetZoneName final
{
public:
	class FName                                   Layer;                                             // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Position;                                          // 0x0008(0x0018)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   ReturnValue;                                       // 0x0020(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzWorldZonesSubsystem_GetZoneName) == 0x000008, "Wrong alignment on GzWorldZonesSubsystem_GetZoneName");
static_assert(sizeof(GzWorldZonesSubsystem_GetZoneName) == 0x000028, "Wrong size on GzWorldZonesSubsystem_GetZoneName");
static_assert(offsetof(GzWorldZonesSubsystem_GetZoneName, Layer) == 0x000000, "Member 'GzWorldZonesSubsystem_GetZoneName::Layer' has a wrong offset!");
static_assert(offsetof(GzWorldZonesSubsystem_GetZoneName, Position) == 0x000008, "Member 'GzWorldZonesSubsystem_GetZoneName::Position' has a wrong offset!");
static_assert(offsetof(GzWorldZonesSubsystem_GetZoneName, ReturnValue) == 0x000020, "Member 'GzWorldZonesSubsystem_GetZoneName::ReturnValue' has a wrong offset!");

// Function G01.GzWorldZonesSubsystem.HasWorldZone
// 0x0014 (0x0014 - 0x0000)
struct GzWorldZonesSubsystem_HasWorldZone final
{
public:
	class FName                                   Layer;                                             // 0x0000(0x0008)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Param_Name;                                        // 0x0008(0x0008)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0010(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3346[0x3];                                     // 0x0011(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GzWorldZonesSubsystem_HasWorldZone) == 0x000004, "Wrong alignment on GzWorldZonesSubsystem_HasWorldZone");
static_assert(sizeof(GzWorldZonesSubsystem_HasWorldZone) == 0x000014, "Wrong size on GzWorldZonesSubsystem_HasWorldZone");
static_assert(offsetof(GzWorldZonesSubsystem_HasWorldZone, Layer) == 0x000000, "Member 'GzWorldZonesSubsystem_HasWorldZone::Layer' has a wrong offset!");
static_assert(offsetof(GzWorldZonesSubsystem_HasWorldZone, Param_Name) == 0x000008, "Member 'GzWorldZonesSubsystem_HasWorldZone::Param_Name' has a wrong offset!");
static_assert(offsetof(GzWorldZonesSubsystem_HasWorldZone, ReturnValue) == 0x000010, "Member 'GzWorldZonesSubsystem_HasWorldZone::ReturnValue' has a wrong offset!");

// Function G01.GzStatsSubsystem.NotifyNewCollectionStage
// 0x0001 (0x0001 - 0x0000)
struct GzStatsSubsystem_NotifyNewCollectionStage final
{
public:
	EGzGameStatCollectionStage                    NewCollectionStage;                                // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzStatsSubsystem_NotifyNewCollectionStage) == 0x000001, "Wrong alignment on GzStatsSubsystem_NotifyNewCollectionStage");
static_assert(sizeof(GzStatsSubsystem_NotifyNewCollectionStage) == 0x000001, "Wrong size on GzStatsSubsystem_NotifyNewCollectionStage");
static_assert(offsetof(GzStatsSubsystem_NotifyNewCollectionStage, NewCollectionStage) == 0x000000, "Member 'GzStatsSubsystem_NotifyNewCollectionStage::NewCollectionStage' has a wrong offset!");

// Function G01.GzStatsSubsystem.GetAllPlayerStats
// 0x0018 (0x0018 - 0x0000)
struct GzStatsSubsystem_GetAllPlayerStats final
{
public:
	int32                                         PlayerId;                                          // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3348[0x4];                                     // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FGzGameStat>                    ReturnValue;                                       // 0x0008(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzStatsSubsystem_GetAllPlayerStats) == 0x000008, "Wrong alignment on GzStatsSubsystem_GetAllPlayerStats");
static_assert(sizeof(GzStatsSubsystem_GetAllPlayerStats) == 0x000018, "Wrong size on GzStatsSubsystem_GetAllPlayerStats");
static_assert(offsetof(GzStatsSubsystem_GetAllPlayerStats, PlayerId) == 0x000000, "Member 'GzStatsSubsystem_GetAllPlayerStats::PlayerId' has a wrong offset!");
static_assert(offsetof(GzStatsSubsystem_GetAllPlayerStats, ReturnValue) == 0x000008, "Member 'GzStatsSubsystem_GetAllPlayerStats::ReturnValue' has a wrong offset!");

// Function G01.GzStatsSubsystem.GetStatTemplates
// 0x0010 (0x0010 - 0x0000)
struct GzStatsSubsystem_GetStatTemplates final
{
public:
	TArray<class UGzGameStatTemplate*>            ReturnValue;                                       // 0x0000(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzStatsSubsystem_GetStatTemplates) == 0x000008, "Wrong alignment on GzStatsSubsystem_GetStatTemplates");
static_assert(sizeof(GzStatsSubsystem_GetStatTemplates) == 0x000010, "Wrong size on GzStatsSubsystem_GetStatTemplates");
static_assert(offsetof(GzStatsSubsystem_GetStatTemplates, ReturnValue) == 0x000000, "Member 'GzStatsSubsystem_GetStatTemplates::ReturnValue' has a wrong offset!");

// Function G01.GzStatsSubsystem.GetStatValue
// 0x0010 (0x0010 - 0x0000)
struct GzStatsSubsystem_GetStatValue final
{
public:
	int32                                         PlayerId;                                          // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Key;                                               // 0x0004(0x0008)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ReturnValue;                                       // 0x000C(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzStatsSubsystem_GetStatValue) == 0x000004, "Wrong alignment on GzStatsSubsystem_GetStatValue");
static_assert(sizeof(GzStatsSubsystem_GetStatValue) == 0x000010, "Wrong size on GzStatsSubsystem_GetStatValue");
static_assert(offsetof(GzStatsSubsystem_GetStatValue, PlayerId) == 0x000000, "Member 'GzStatsSubsystem_GetStatValue::PlayerId' has a wrong offset!");
static_assert(offsetof(GzStatsSubsystem_GetStatValue, Key) == 0x000004, "Member 'GzStatsSubsystem_GetStatValue::Key' has a wrong offset!");
static_assert(offsetof(GzStatsSubsystem_GetStatValue, ReturnValue) == 0x00000C, "Member 'GzStatsSubsystem_GetStatValue::ReturnValue' has a wrong offset!");

// Function G01.GzStatsSubsystem.HasPlayer
// 0x0008 (0x0008 - 0x0000)
struct GzStatsSubsystem_HasPlayer final
{
public:
	int32                                         PlayerId;                                          // 0x0000(0x0004)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0004(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3349[0x3];                                     // 0x0005(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GzStatsSubsystem_HasPlayer) == 0x000004, "Wrong alignment on GzStatsSubsystem_HasPlayer");
static_assert(sizeof(GzStatsSubsystem_HasPlayer) == 0x000008, "Wrong size on GzStatsSubsystem_HasPlayer");
static_assert(offsetof(GzStatsSubsystem_HasPlayer, PlayerId) == 0x000000, "Member 'GzStatsSubsystem_HasPlayer::PlayerId' has a wrong offset!");
static_assert(offsetof(GzStatsSubsystem_HasPlayer, ReturnValue) == 0x000004, "Member 'GzStatsSubsystem_HasPlayer::ReturnValue' has a wrong offset!");

// Function G01.GzStatsSubsystem.IsInitialized
// 0x0001 (0x0001 - 0x0000)
struct GzStatsSubsystem_IsInitialized final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzStatsSubsystem_IsInitialized) == 0x000001, "Wrong alignment on GzStatsSubsystem_IsInitialized");
static_assert(sizeof(GzStatsSubsystem_IsInitialized) == 0x000001, "Wrong size on GzStatsSubsystem_IsInitialized");
static_assert(offsetof(GzStatsSubsystem_IsInitialized, ReturnValue) == 0x000000, "Member 'GzStatsSubsystem_IsInitialized::ReturnValue' has a wrong offset!");

// Function G01.GzLimbAttachingReplica.StartAttaching
// 0x0058 (0x0058 - 0x0000)
struct GzLimbAttachingReplica_StartAttaching final
{
public:
	class AGzMultiPartCharacter*                  InCharacter;                                       // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	const class UGzBodyPartItemData*              InBodyPartItemData;                                // 0x0008(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGzLimbAttachingParams                 Params_0;                                          // 0x0010(0x0040)(ConstParm, Parm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	const class AGzLimbPickable*                  Pickable;                                          // 0x0050(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzLimbAttachingReplica_StartAttaching) == 0x000008, "Wrong alignment on GzLimbAttachingReplica_StartAttaching");
static_assert(sizeof(GzLimbAttachingReplica_StartAttaching) == 0x000058, "Wrong size on GzLimbAttachingReplica_StartAttaching");
static_assert(offsetof(GzLimbAttachingReplica_StartAttaching, InCharacter) == 0x000000, "Member 'GzLimbAttachingReplica_StartAttaching::InCharacter' has a wrong offset!");
static_assert(offsetof(GzLimbAttachingReplica_StartAttaching, InBodyPartItemData) == 0x000008, "Member 'GzLimbAttachingReplica_StartAttaching::InBodyPartItemData' has a wrong offset!");
static_assert(offsetof(GzLimbAttachingReplica_StartAttaching, Params_0) == 0x000010, "Member 'GzLimbAttachingReplica_StartAttaching::Params_0' has a wrong offset!");
static_assert(offsetof(GzLimbAttachingReplica_StartAttaching, Pickable) == 0x000050, "Member 'GzLimbAttachingReplica_StartAttaching::Pickable' has a wrong offset!");

// Function G01.GzLimbCrosshair.OnLimbActivated
// 0x0030 (0x0030 - 0x0000)
struct GzLimbCrosshair_OnLimbActivated final
{
public:
	EGzLimbType                                   LimbType;                                          // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3351[0x7];                                     // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGzLimbGaugeData                       GaugeData;                                         // 0x0008(0x0028)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzLimbCrosshair_OnLimbActivated) == 0x000008, "Wrong alignment on GzLimbCrosshair_OnLimbActivated");
static_assert(sizeof(GzLimbCrosshair_OnLimbActivated) == 0x000030, "Wrong size on GzLimbCrosshair_OnLimbActivated");
static_assert(offsetof(GzLimbCrosshair_OnLimbActivated, LimbType) == 0x000000, "Member 'GzLimbCrosshair_OnLimbActivated::LimbType' has a wrong offset!");
static_assert(offsetof(GzLimbCrosshair_OnLimbActivated, GaugeData) == 0x000008, "Member 'GzLimbCrosshair_OnLimbActivated::GaugeData' has a wrong offset!");

// Function G01.GzLimbCrosshair.OnLimbActivationEnded
// 0x0001 (0x0001 - 0x0000)
struct GzLimbCrosshair_OnLimbActivationEnded final
{
public:
	EGzLimbType                                   LimbType;                                          // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzLimbCrosshair_OnLimbActivationEnded) == 0x000001, "Wrong alignment on GzLimbCrosshair_OnLimbActivationEnded");
static_assert(sizeof(GzLimbCrosshair_OnLimbActivationEnded) == 0x000001, "Wrong size on GzLimbCrosshair_OnLimbActivationEnded");
static_assert(offsetof(GzLimbCrosshair_OnLimbActivationEnded, LimbType) == 0x000000, "Member 'GzLimbCrosshair_OnLimbActivationEnded::LimbType' has a wrong offset!");

// Function G01.GzLimbCrosshair.OnLimbActivationReachedFinalValue
// 0x0030 (0x0030 - 0x0000)
struct GzLimbCrosshair_OnLimbActivationReachedFinalValue final
{
public:
	EGzLimbType                                   LimbType;                                          // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3352[0x7];                                     // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGzLimbGaugeData                       GaugeData;                                         // 0x0008(0x0028)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzLimbCrosshair_OnLimbActivationReachedFinalValue) == 0x000008, "Wrong alignment on GzLimbCrosshair_OnLimbActivationReachedFinalValue");
static_assert(sizeof(GzLimbCrosshair_OnLimbActivationReachedFinalValue) == 0x000030, "Wrong size on GzLimbCrosshair_OnLimbActivationReachedFinalValue");
static_assert(offsetof(GzLimbCrosshair_OnLimbActivationReachedFinalValue, LimbType) == 0x000000, "Member 'GzLimbCrosshair_OnLimbActivationReachedFinalValue::LimbType' has a wrong offset!");
static_assert(offsetof(GzLimbCrosshair_OnLimbActivationReachedFinalValue, GaugeData) == 0x000008, "Member 'GzLimbCrosshair_OnLimbActivationReachedFinalValue::GaugeData' has a wrong offset!");

// Function G01.GzLimbCrosshair.OnLimbActivationUpdate
// 0x0030 (0x0030 - 0x0000)
struct GzLimbCrosshair_OnLimbActivationUpdate final
{
public:
	EGzLimbType                                   LimbType;                                          // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3353[0x7];                                     // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGzLimbGaugeData                       GaugeData;                                         // 0x0008(0x0028)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzLimbCrosshair_OnLimbActivationUpdate) == 0x000008, "Wrong alignment on GzLimbCrosshair_OnLimbActivationUpdate");
static_assert(sizeof(GzLimbCrosshair_OnLimbActivationUpdate) == 0x000030, "Wrong size on GzLimbCrosshair_OnLimbActivationUpdate");
static_assert(offsetof(GzLimbCrosshair_OnLimbActivationUpdate, LimbType) == 0x000000, "Member 'GzLimbCrosshair_OnLimbActivationUpdate::LimbType' has a wrong offset!");
static_assert(offsetof(GzLimbCrosshair_OnLimbActivationUpdate, GaugeData) == 0x000008, "Member 'GzLimbCrosshair_OnLimbActivationUpdate::GaugeData' has a wrong offset!");

// Function G01.GzLimbGaugeWidget.NotifyReachedFinal
// 0x0008 (0x0008 - 0x0000)
struct GzLimbGaugeWidget_NotifyReachedFinal final
{
public:
	float                                         CurrentValue;                                      // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxValue;                                          // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzLimbGaugeWidget_NotifyReachedFinal) == 0x000004, "Wrong alignment on GzLimbGaugeWidget_NotifyReachedFinal");
static_assert(sizeof(GzLimbGaugeWidget_NotifyReachedFinal) == 0x000008, "Wrong size on GzLimbGaugeWidget_NotifyReachedFinal");
static_assert(offsetof(GzLimbGaugeWidget_NotifyReachedFinal, CurrentValue) == 0x000000, "Member 'GzLimbGaugeWidget_NotifyReachedFinal::CurrentValue' has a wrong offset!");
static_assert(offsetof(GzLimbGaugeWidget_NotifyReachedFinal, MaxValue) == 0x000004, "Member 'GzLimbGaugeWidget_NotifyReachedFinal::MaxValue' has a wrong offset!");

// Function G01.GzLimbGaugeWidget.SetCurrentValue
// 0x0008 (0x0008 - 0x0000)
struct GzLimbGaugeWidget_SetCurrentValue final
{
public:
	float                                         CurrentValue;                                      // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxValue;                                          // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzLimbGaugeWidget_SetCurrentValue) == 0x000004, "Wrong alignment on GzLimbGaugeWidget_SetCurrentValue");
static_assert(sizeof(GzLimbGaugeWidget_SetCurrentValue) == 0x000008, "Wrong size on GzLimbGaugeWidget_SetCurrentValue");
static_assert(offsetof(GzLimbGaugeWidget_SetCurrentValue, CurrentValue) == 0x000000, "Member 'GzLimbGaugeWidget_SetCurrentValue::CurrentValue' has a wrong offset!");
static_assert(offsetof(GzLimbGaugeWidget_SetCurrentValue, MaxValue) == 0x000004, "Member 'GzLimbGaugeWidget_SetCurrentValue::MaxValue' has a wrong offset!");

// Function G01.GzLimbPickable.OnRep_Health
// 0x0004 (0x0004 - 0x0000)
struct GzLimbPickable_OnRep_Health final
{
public:
	float                                         OldHealth;                                         // 0x0000(0x0004)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzLimbPickable_OnRep_Health) == 0x000004, "Wrong alignment on GzLimbPickable_OnRep_Health");
static_assert(sizeof(GzLimbPickable_OnRep_Health) == 0x000004, "Wrong size on GzLimbPickable_OnRep_Health");
static_assert(offsetof(GzLimbPickable_OnRep_Health, OldHealth) == 0x000000, "Member 'GzLimbPickable_OnRep_Health::OldHealth' has a wrong offset!");

// Function G01.GzLimbPickable.OnRep_LimbStatus
// 0x0018 (0x0018 - 0x0000)
struct GzLimbPickable_OnRep_LimbStatus final
{
public:
	struct FGzLimbStatusData                      OldStatus;                                         // 0x0000(0x0018)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzLimbPickable_OnRep_LimbStatus) == 0x000004, "Wrong alignment on GzLimbPickable_OnRep_LimbStatus");
static_assert(sizeof(GzLimbPickable_OnRep_LimbStatus) == 0x000018, "Wrong size on GzLimbPickable_OnRep_LimbStatus");
static_assert(offsetof(GzLimbPickable_OnRep_LimbStatus, OldStatus) == 0x000000, "Member 'GzLimbPickable_OnRep_LimbStatus::OldStatus' has a wrong offset!");

// Function G01.GzLimbPickable.GetHealth
// 0x0004 (0x0004 - 0x0000)
struct GzLimbPickable_GetHealth final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzLimbPickable_GetHealth) == 0x000004, "Wrong alignment on GzLimbPickable_GetHealth");
static_assert(sizeof(GzLimbPickable_GetHealth) == 0x000004, "Wrong size on GzLimbPickable_GetHealth");
static_assert(offsetof(GzLimbPickable_GetHealth, ReturnValue) == 0x000000, "Member 'GzLimbPickable_GetHealth::ReturnValue' has a wrong offset!");

// Function G01.GzLimbPickable.GetHealthNormalized
// 0x0004 (0x0004 - 0x0000)
struct GzLimbPickable_GetHealthNormalized final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzLimbPickable_GetHealthNormalized) == 0x000004, "Wrong alignment on GzLimbPickable_GetHealthNormalized");
static_assert(sizeof(GzLimbPickable_GetHealthNormalized) == 0x000004, "Wrong size on GzLimbPickable_GetHealthNormalized");
static_assert(offsetof(GzLimbPickable_GetHealthNormalized, ReturnValue) == 0x000000, "Member 'GzLimbPickable_GetHealthNormalized::ReturnValue' has a wrong offset!");

// Function G01.GzLimbPickable.GetHealthToAllowPickup
// 0x0004 (0x0004 - 0x0000)
struct GzLimbPickable_GetHealthToAllowPickup final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzLimbPickable_GetHealthToAllowPickup) == 0x000004, "Wrong alignment on GzLimbPickable_GetHealthToAllowPickup");
static_assert(sizeof(GzLimbPickable_GetHealthToAllowPickup) == 0x000004, "Wrong size on GzLimbPickable_GetHealthToAllowPickup");
static_assert(offsetof(GzLimbPickable_GetHealthToAllowPickup, ReturnValue) == 0x000000, "Member 'GzLimbPickable_GetHealthToAllowPickup::ReturnValue' has a wrong offset!");

// Function G01.GzLimbPickable.GetLimbStatus
// 0x0018 (0x0018 - 0x0000)
struct GzLimbPickable_GetLimbStatus final
{
public:
	struct FGzLimbStatusData                      ReturnValue;                                       // 0x0000(0x0018)(ConstParm, Parm, OutParm, ReturnParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzLimbPickable_GetLimbStatus) == 0x000004, "Wrong alignment on GzLimbPickable_GetLimbStatus");
static_assert(sizeof(GzLimbPickable_GetLimbStatus) == 0x000018, "Wrong size on GzLimbPickable_GetLimbStatus");
static_assert(offsetof(GzLimbPickable_GetLimbStatus, ReturnValue) == 0x000000, "Member 'GzLimbPickable_GetLimbStatus::ReturnValue' has a wrong offset!");

// Function G01.GzLimbPickable.GetLimbType
// 0x0001 (0x0001 - 0x0000)
struct GzLimbPickable_GetLimbType final
{
public:
	EGzLimbType                                   ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzLimbPickable_GetLimbType) == 0x000001, "Wrong alignment on GzLimbPickable_GetLimbType");
static_assert(sizeof(GzLimbPickable_GetLimbType) == 0x000001, "Wrong size on GzLimbPickable_GetLimbType");
static_assert(offsetof(GzLimbPickable_GetLimbType, ReturnValue) == 0x000000, "Member 'GzLimbPickable_GetLimbType::ReturnValue' has a wrong offset!");

// Function G01.GzLimbPickable.GetMaxHealth
// 0x0004 (0x0004 - 0x0000)
struct GzLimbPickable_GetMaxHealth final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzLimbPickable_GetMaxHealth) == 0x000004, "Wrong alignment on GzLimbPickable_GetMaxHealth");
static_assert(sizeof(GzLimbPickable_GetMaxHealth) == 0x000004, "Wrong size on GzLimbPickable_GetMaxHealth");
static_assert(offsetof(GzLimbPickable_GetMaxHealth, ReturnValue) == 0x000000, "Member 'GzLimbPickable_GetMaxHealth::ReturnValue' has a wrong offset!");

// Function G01.GzViewpointManager.GetViewpointNames
// 0x0010 (0x0010 - 0x0000)
struct GzViewpointManager_GetViewpointNames final
{
public:
	TArray<class FString>                         ReturnValue;                                       // 0x0000(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzViewpointManager_GetViewpointNames) == 0x000008, "Wrong alignment on GzViewpointManager_GetViewpointNames");
static_assert(sizeof(GzViewpointManager_GetViewpointNames) == 0x000010, "Wrong size on GzViewpointManager_GetViewpointNames");
static_assert(offsetof(GzViewpointManager_GetViewpointNames, ReturnValue) == 0x000000, "Member 'GzViewpointManager_GetViewpointNames::ReturnValue' has a wrong offset!");

// Function G01.GzWaitSubsystem.WaitSubsystem
// 0x0018 (0x0018 - 0x0000)
struct GzWaitSubsystem_WaitSubsystem final
{
public:
	const class UObject*                          Param_WorldContextObject;                          // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class AGzGameModeSubsystem>       Param_Class;                                       // 0x0008(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UGzWaitSubsystem*                       ReturnValue;                                       // 0x0010(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzWaitSubsystem_WaitSubsystem) == 0x000008, "Wrong alignment on GzWaitSubsystem_WaitSubsystem");
static_assert(sizeof(GzWaitSubsystem_WaitSubsystem) == 0x000018, "Wrong size on GzWaitSubsystem_WaitSubsystem");
static_assert(offsetof(GzWaitSubsystem_WaitSubsystem, Param_WorldContextObject) == 0x000000, "Member 'GzWaitSubsystem_WaitSubsystem::Param_WorldContextObject' has a wrong offset!");
static_assert(offsetof(GzWaitSubsystem_WaitSubsystem, Param_Class) == 0x000008, "Member 'GzWaitSubsystem_WaitSubsystem::Param_Class' has a wrong offset!");
static_assert(offsetof(GzWaitSubsystem_WaitSubsystem, ReturnValue) == 0x000010, "Member 'GzWaitSubsystem_WaitSubsystem::ReturnValue' has a wrong offset!");

// Function G01.GzWaitSubsystem.OnSubsystemReady
// 0x0008 (0x0008 - 0x0000)
struct GzWaitSubsystem_OnSubsystemReady final
{
public:
	class AGzGameModeSubsystem*                   Subsystem;                                         // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzWaitSubsystem_OnSubsystemReady) == 0x000008, "Wrong alignment on GzWaitSubsystem_OnSubsystemReady");
static_assert(sizeof(GzWaitSubsystem_OnSubsystemReady) == 0x000008, "Wrong size on GzWaitSubsystem_OnSubsystemReady");
static_assert(offsetof(GzWaitSubsystem_OnSubsystemReady, Subsystem) == 0x000000, "Member 'GzWaitSubsystem_OnSubsystemReady::Subsystem' has a wrong offset!");

// Function G01.GzLoadoutListMultiTab.OnTabAdded
// 0x0008 (0x0008 - 0x0000)
struct GzLoadoutListMultiTab_OnTabAdded final
{
public:
	class UGzLoadoutListTab*                      NewTab;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzLoadoutListMultiTab_OnTabAdded) == 0x000008, "Wrong alignment on GzLoadoutListMultiTab_OnTabAdded");
static_assert(sizeof(GzLoadoutListMultiTab_OnTabAdded) == 0x000008, "Wrong size on GzLoadoutListMultiTab_OnTabAdded");
static_assert(offsetof(GzLoadoutListMultiTab_OnTabAdded, NewTab) == 0x000000, "Member 'GzLoadoutListMultiTab_OnTabAdded::NewTab' has a wrong offset!");

// Function G01.GzLoadoutListMultiTab.OnTabSelected
// 0x0008 (0x0008 - 0x0000)
struct GzLoadoutListMultiTab_OnTabSelected final
{
public:
	class FName                                   TabId;                                             // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzLoadoutListMultiTab_OnTabSelected) == 0x000004, "Wrong alignment on GzLoadoutListMultiTab_OnTabSelected");
static_assert(sizeof(GzLoadoutListMultiTab_OnTabSelected) == 0x000008, "Wrong size on GzLoadoutListMultiTab_OnTabSelected");
static_assert(offsetof(GzLoadoutListMultiTab_OnTabSelected, TabId) == 0x000000, "Member 'GzLoadoutListMultiTab_OnTabSelected::TabId' has a wrong offset!");

// Function G01.GzTrackEventHandlerComponent.HandleTrackEvent
// 0x0010 (0x0010 - 0x0000)
struct GzTrackEventHandlerComponent_HandleTrackEvent final
{
public:
	class UGzTrackEventBase*                      Event;                                             // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         TrackPoint;                                        // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3362[0x4];                                     // 0x000C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GzTrackEventHandlerComponent_HandleTrackEvent) == 0x000008, "Wrong alignment on GzTrackEventHandlerComponent_HandleTrackEvent");
static_assert(sizeof(GzTrackEventHandlerComponent_HandleTrackEvent) == 0x000010, "Wrong size on GzTrackEventHandlerComponent_HandleTrackEvent");
static_assert(offsetof(GzTrackEventHandlerComponent_HandleTrackEvent, Event) == 0x000000, "Member 'GzTrackEventHandlerComponent_HandleTrackEvent::Event' has a wrong offset!");
static_assert(offsetof(GzTrackEventHandlerComponent_HandleTrackEvent, TrackPoint) == 0x000008, "Member 'GzTrackEventHandlerComponent_HandleTrackEvent::TrackPoint' has a wrong offset!");

// Function G01.GzLoadoutListTab.BP_Init
// 0x000C (0x000C - 0x0000)
struct GzLoadoutListTab_BP_Init final
{
public:
	EGzLoadoutListTabOptions                      TabOf;                                             // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3364[0x3];                                     // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGzLoadoutSelectionTabShowData         Data;                                              // 0x0004(0x0008)(Parm, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzLoadoutListTab_BP_Init) == 0x000004, "Wrong alignment on GzLoadoutListTab_BP_Init");
static_assert(sizeof(GzLoadoutListTab_BP_Init) == 0x00000C, "Wrong size on GzLoadoutListTab_BP_Init");
static_assert(offsetof(GzLoadoutListTab_BP_Init, TabOf) == 0x000000, "Member 'GzLoadoutListTab_BP_Init::TabOf' has a wrong offset!");
static_assert(offsetof(GzLoadoutListTab_BP_Init, Data) == 0x000004, "Member 'GzLoadoutListTab_BP_Init::Data' has a wrong offset!");

// Function G01.GzLoadoutListTab.GetCategory
// 0x0001 (0x0001 - 0x0000)
struct GzLoadoutListTab_GetCategory final
{
public:
	EGzLoadoutListTabOptions                      ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzLoadoutListTab_GetCategory) == 0x000001, "Wrong alignment on GzLoadoutListTab_GetCategory");
static_assert(sizeof(GzLoadoutListTab_GetCategory) == 0x000001, "Wrong size on GzLoadoutListTab_GetCategory");
static_assert(offsetof(GzLoadoutListTab_GetCategory, ReturnValue) == 0x000000, "Member 'GzLoadoutListTab_GetCategory::ReturnValue' has a wrong offset!");

// Function G01.GzLoadoutListTab.GetIsInitialized
// 0x0001 (0x0001 - 0x0000)
struct GzLoadoutListTab_GetIsInitialized final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzLoadoutListTab_GetIsInitialized) == 0x000001, "Wrong alignment on GzLoadoutListTab_GetIsInitialized");
static_assert(sizeof(GzLoadoutListTab_GetIsInitialized) == 0x000001, "Wrong size on GzLoadoutListTab_GetIsInitialized");
static_assert(offsetof(GzLoadoutListTab_GetIsInitialized, ReturnValue) == 0x000000, "Member 'GzLoadoutListTab_GetIsInitialized::ReturnValue' has a wrong offset!");

// Function G01.GzLoadoutListTab.GetShowData
// 0x0008 (0x0008 - 0x0000)
struct GzLoadoutListTab_GetShowData final
{
public:
	struct FGzLoadoutSelectionTabShowData         ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzLoadoutListTab_GetShowData) == 0x000004, "Wrong alignment on GzLoadoutListTab_GetShowData");
static_assert(sizeof(GzLoadoutListTab_GetShowData) == 0x000008, "Wrong size on GzLoadoutListTab_GetShowData");
static_assert(offsetof(GzLoadoutListTab_GetShowData, ReturnValue) == 0x000000, "Member 'GzLoadoutListTab_GetShowData::ReturnValue' has a wrong offset!");

// Function G01.GzSettingEntryScalarWidget.HandleOnValueChanged
// 0x0004 (0x0004 - 0x0000)
struct GzSettingEntryScalarWidget_HandleOnValueChanged final
{
public:
	float                                         NewValue;                                          // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzSettingEntryScalarWidget_HandleOnValueChanged) == 0x000004, "Wrong alignment on GzSettingEntryScalarWidget_HandleOnValueChanged");
static_assert(sizeof(GzSettingEntryScalarWidget_HandleOnValueChanged) == 0x000004, "Wrong size on GzSettingEntryScalarWidget_HandleOnValueChanged");
static_assert(offsetof(GzSettingEntryScalarWidget_HandleOnValueChanged, NewValue) == 0x000000, "Member 'GzSettingEntryScalarWidget_HandleOnValueChanged::NewValue' has a wrong offset!");

// Function G01.GzSettingEntryScalarWidget.OnDefaultValueChanged
// 0x0008 (0x0008 - 0x0000)
struct GzSettingEntryScalarWidget_OnDefaultValueChanged final
{
public:
	double                                        NewDefaultValue;                                   // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzSettingEntryScalarWidget_OnDefaultValueChanged) == 0x000008, "Wrong alignment on GzSettingEntryScalarWidget_OnDefaultValueChanged");
static_assert(sizeof(GzSettingEntryScalarWidget_OnDefaultValueChanged) == 0x000008, "Wrong size on GzSettingEntryScalarWidget_OnDefaultValueChanged");
static_assert(offsetof(GzSettingEntryScalarWidget_OnDefaultValueChanged, NewDefaultValue) == 0x000000, "Member 'GzSettingEntryScalarWidget_OnDefaultValueChanged::NewDefaultValue' has a wrong offset!");

// Function G01.GzSettingEntryScalarWidget.OnValueChanged
// 0x0004 (0x0004 - 0x0000)
struct GzSettingEntryScalarWidget_OnValueChanged final
{
public:
	float                                         NewValue;                                          // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzSettingEntryScalarWidget_OnValueChanged) == 0x000004, "Wrong alignment on GzSettingEntryScalarWidget_OnValueChanged");
static_assert(sizeof(GzSettingEntryScalarWidget_OnValueChanged) == 0x000004, "Wrong size on GzSettingEntryScalarWidget_OnValueChanged");
static_assert(offsetof(GzSettingEntryScalarWidget_OnValueChanged, NewValue) == 0x000000, "Member 'GzSettingEntryScalarWidget_OnValueChanged::NewValue' has a wrong offset!");

// Function G01.GzLootArchetypeData.GetItemByRarity
// 0x0010 (0x0010 - 0x0000)
struct GzLootArchetypeData_GetItemByRarity final
{
public:
	EGzItemRarity                                 Rarity;                                            // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3365[0x7];                                     // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	const class UGzLootItemVariationsTableData*   ReturnValue;                                       // 0x0008(0x0008)(ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzLootArchetypeData_GetItemByRarity) == 0x000008, "Wrong alignment on GzLootArchetypeData_GetItemByRarity");
static_assert(sizeof(GzLootArchetypeData_GetItemByRarity) == 0x000010, "Wrong size on GzLootArchetypeData_GetItemByRarity");
static_assert(offsetof(GzLootArchetypeData_GetItemByRarity, Rarity) == 0x000000, "Member 'GzLootArchetypeData_GetItemByRarity::Rarity' has a wrong offset!");
static_assert(offsetof(GzLootArchetypeData_GetItemByRarity, ReturnValue) == 0x000008, "Member 'GzLootArchetypeData_GetItemByRarity::ReturnValue' has a wrong offset!");

// Function G01.GzLootRarityTableData.RollItemRarity
// 0x0010 (0x0010 - 0x0000)
struct GzLootRarityTableData_RollItemRarity final
{
public:
	const class UGzLootModifierTableData*         ModifiersTable;                                    // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EGzItemRarity                                 ReturnValue;                                       // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3366[0x7];                                     // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GzLootRarityTableData_RollItemRarity) == 0x000008, "Wrong alignment on GzLootRarityTableData_RollItemRarity");
static_assert(sizeof(GzLootRarityTableData_RollItemRarity) == 0x000010, "Wrong size on GzLootRarityTableData_RollItemRarity");
static_assert(offsetof(GzLootRarityTableData_RollItemRarity, ModifiersTable) == 0x000000, "Member 'GzLootRarityTableData_RollItemRarity::ModifiersTable' has a wrong offset!");
static_assert(offsetof(GzLootRarityTableData_RollItemRarity, ReturnValue) == 0x000008, "Member 'GzLootRarityTableData_RollItemRarity::ReturnValue' has a wrong offset!");

// Function G01.GzLootRarityTableData.RollItemRarityWithModArray
// 0x0018 (0x0018 - 0x0000)
struct GzLootRarityTableData_RollItemRarityWithModArray final
{
public:
	TArray<struct FGzLootModifier>                Modifiers;                                         // 0x0000(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	EGzItemRarity                                 ReturnValue;                                       // 0x0010(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3367[0x7];                                     // 0x0011(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GzLootRarityTableData_RollItemRarityWithModArray) == 0x000008, "Wrong alignment on GzLootRarityTableData_RollItemRarityWithModArray");
static_assert(sizeof(GzLootRarityTableData_RollItemRarityWithModArray) == 0x000018, "Wrong size on GzLootRarityTableData_RollItemRarityWithModArray");
static_assert(offsetof(GzLootRarityTableData_RollItemRarityWithModArray, Modifiers) == 0x000000, "Member 'GzLootRarityTableData_RollItemRarityWithModArray::Modifiers' has a wrong offset!");
static_assert(offsetof(GzLootRarityTableData_RollItemRarityWithModArray, ReturnValue) == 0x000010, "Member 'GzLootRarityTableData_RollItemRarityWithModArray::ReturnValue' has a wrong offset!");

// Function G01.GzLootSpawnInterface.GetInitialWorldSpawnTransforms
// 0x0010 (0x0010 - 0x0000)
struct GzLootSpawnInterface_GetInitialWorldSpawnTransforms final
{
public:
	TArray<struct FTransform>                     ReturnValue;                                       // 0x0000(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzLootSpawnInterface_GetInitialWorldSpawnTransforms) == 0x000008, "Wrong alignment on GzLootSpawnInterface_GetInitialWorldSpawnTransforms");
static_assert(sizeof(GzLootSpawnInterface_GetInitialWorldSpawnTransforms) == 0x000010, "Wrong size on GzLootSpawnInterface_GetInitialWorldSpawnTransforms");
static_assert(offsetof(GzLootSpawnInterface_GetInitialWorldSpawnTransforms, ReturnValue) == 0x000000, "Member 'GzLootSpawnInterface_GetInitialWorldSpawnTransforms::ReturnValue' has a wrong offset!");

// Function G01.GzLootSpawnInterface.GetLootSpawnerComponent
// 0x0008 (0x0008 - 0x0000)
struct GzLootSpawnInterface_GetLootSpawnerComponent final
{
public:
	class UGzLootSpawnerComponent*                ReturnValue;                                       // 0x0000(0x0008)(ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzLootSpawnInterface_GetLootSpawnerComponent) == 0x000008, "Wrong alignment on GzLootSpawnInterface_GetLootSpawnerComponent");
static_assert(sizeof(GzLootSpawnInterface_GetLootSpawnerComponent) == 0x000008, "Wrong size on GzLootSpawnInterface_GetLootSpawnerComponent");
static_assert(offsetof(GzLootSpawnInterface_GetLootSpawnerComponent, ReturnValue) == 0x000000, "Member 'GzLootSpawnInterface_GetLootSpawnerComponent::ReturnValue' has a wrong offset!");

// Function G01.GzLootItemVariationsTableData.RollItemVariation
// 0x0050 (0x0050 - 0x0000)
struct GzLootItemVariationsTableData_RollItemVariation final
{
public:
	const class UGzLootModifierTableData*         ModifiersTable;                                    // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGzInventoryItemContent                ReturnValue;                                       // 0x0008(0x0048)(Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzLootItemVariationsTableData_RollItemVariation) == 0x000008, "Wrong alignment on GzLootItemVariationsTableData_RollItemVariation");
static_assert(sizeof(GzLootItemVariationsTableData_RollItemVariation) == 0x000050, "Wrong size on GzLootItemVariationsTableData_RollItemVariation");
static_assert(offsetof(GzLootItemVariationsTableData_RollItemVariation, ModifiersTable) == 0x000000, "Member 'GzLootItemVariationsTableData_RollItemVariation::ModifiersTable' has a wrong offset!");
static_assert(offsetof(GzLootItemVariationsTableData_RollItemVariation, ReturnValue) == 0x000008, "Member 'GzLootItemVariationsTableData_RollItemVariation::ReturnValue' has a wrong offset!");

// Function G01.GzLootItemVariationsTableData.RollItemVariationWithModArray
// 0x0058 (0x0058 - 0x0000)
struct GzLootItemVariationsTableData_RollItemVariationWithModArray final
{
public:
	TArray<struct FGzLootModifier>                Modifiers;                                         // 0x0000(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	struct FGzInventoryItemContent                ReturnValue;                                       // 0x0010(0x0048)(Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzLootItemVariationsTableData_RollItemVariationWithModArray) == 0x000008, "Wrong alignment on GzLootItemVariationsTableData_RollItemVariationWithModArray");
static_assert(sizeof(GzLootItemVariationsTableData_RollItemVariationWithModArray) == 0x000058, "Wrong size on GzLootItemVariationsTableData_RollItemVariationWithModArray");
static_assert(offsetof(GzLootItemVariationsTableData_RollItemVariationWithModArray, Modifiers) == 0x000000, "Member 'GzLootItemVariationsTableData_RollItemVariationWithModArray::Modifiers' has a wrong offset!");
static_assert(offsetof(GzLootItemVariationsTableData_RollItemVariationWithModArray, ReturnValue) == 0x000010, "Member 'GzLootItemVariationsTableData_RollItemVariationWithModArray::ReturnValue' has a wrong offset!");

// DelegateFunction G01.GzScenePuppeteer.GzOnPlayAnimationRequested__DelegateSignature
// 0x0001 (0x0001 - 0x0000)
struct GzScenePuppeteer_GzOnPlayAnimationRequested__DelegateSignature final
{
public:
	EGzAnimationActionType                        AnimationAction;                                   // 0x0000(0x0001)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzScenePuppeteer_GzOnPlayAnimationRequested__DelegateSignature) == 0x000001, "Wrong alignment on GzScenePuppeteer_GzOnPlayAnimationRequested__DelegateSignature");
static_assert(sizeof(GzScenePuppeteer_GzOnPlayAnimationRequested__DelegateSignature) == 0x000001, "Wrong size on GzScenePuppeteer_GzOnPlayAnimationRequested__DelegateSignature");
static_assert(offsetof(GzScenePuppeteer_GzOnPlayAnimationRequested__DelegateSignature, AnimationAction) == 0x000000, "Member 'GzScenePuppeteer_GzOnPlayAnimationRequested__DelegateSignature::AnimationAction' has a wrong offset!");

// Function G01.GzManualTrackTransport.ForceSetPosition
// 0x0008 (0x0008 - 0x0000)
struct GzManualTrackTransport_ForceSetPosition final
{
public:
	double                                        Distance;                                          // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzManualTrackTransport_ForceSetPosition) == 0x000008, "Wrong alignment on GzManualTrackTransport_ForceSetPosition");
static_assert(sizeof(GzManualTrackTransport_ForceSetPosition) == 0x000008, "Wrong size on GzManualTrackTransport_ForceSetPosition");
static_assert(offsetof(GzManualTrackTransport_ForceSetPosition, Distance) == 0x000000, "Member 'GzManualTrackTransport_ForceSetPosition::Distance' has a wrong offset!");

// Function G01.GzManualTrackTransport.MoveToDistance
// 0x0008 (0x0008 - 0x0000)
struct GzManualTrackTransport_MoveToDistance final
{
public:
	double                                        Distance;                                          // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzManualTrackTransport_MoveToDistance) == 0x000008, "Wrong alignment on GzManualTrackTransport_MoveToDistance");
static_assert(sizeof(GzManualTrackTransport_MoveToDistance) == 0x000008, "Wrong size on GzManualTrackTransport_MoveToDistance");
static_assert(offsetof(GzManualTrackTransport_MoveToDistance, Distance) == 0x000000, "Member 'GzManualTrackTransport_MoveToDistance::Distance' has a wrong offset!");

// Function G01.GzManualTrackTransport.MulticastForceSetPosition
// 0x0008 (0x0008 - 0x0000)
struct GzManualTrackTransport_MulticastForceSetPosition final
{
public:
	double                                        Distance;                                          // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzManualTrackTransport_MulticastForceSetPosition) == 0x000008, "Wrong alignment on GzManualTrackTransport_MulticastForceSetPosition");
static_assert(sizeof(GzManualTrackTransport_MulticastForceSetPosition) == 0x000008, "Wrong size on GzManualTrackTransport_MulticastForceSetPosition");
static_assert(offsetof(GzManualTrackTransport_MulticastForceSetPosition, Distance) == 0x000000, "Member 'GzManualTrackTransport_MulticastForceSetPosition::Distance' has a wrong offset!");

// Function G01.GzScoreboard.OnStatChanged
// 0x0018 (0x0018 - 0x0000)
struct GzScoreboard_OnStatChanged final
{
public:
	int32                                         PlayerId;                                          // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3369[0x4];                                     // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGzGameStat                            Stat;                                              // 0x0008(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzScoreboard_OnStatChanged) == 0x000008, "Wrong alignment on GzScoreboard_OnStatChanged");
static_assert(sizeof(GzScoreboard_OnStatChanged) == 0x000018, "Wrong size on GzScoreboard_OnStatChanged");
static_assert(offsetof(GzScoreboard_OnStatChanged, PlayerId) == 0x000000, "Member 'GzScoreboard_OnStatChanged::PlayerId' has a wrong offset!");
static_assert(offsetof(GzScoreboard_OnStatChanged, Stat) == 0x000008, "Member 'GzScoreboard_OnStatChanged::Stat' has a wrong offset!");

// Function G01.GzScoreboard.RefreshStats
// 0x0001 (0x0001 - 0x0000)
struct GzScoreboard_RefreshStats final
{
public:
	bool                                          bClear;                                            // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzScoreboard_RefreshStats) == 0x000001, "Wrong alignment on GzScoreboard_RefreshStats");
static_assert(sizeof(GzScoreboard_RefreshStats) == 0x000001, "Wrong size on GzScoreboard_RefreshStats");
static_assert(offsetof(GzScoreboard_RefreshStats, bClear) == 0x000000, "Member 'GzScoreboard_RefreshStats::bClear' has a wrong offset!");

// Function G01.GzMapDecoration.SetMaxZoom
// 0x0004 (0x0004 - 0x0000)
struct GzMapDecoration_SetMaxZoom final
{
public:
	float                                         InMaxZoom;                                         // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzMapDecoration_SetMaxZoom) == 0x000004, "Wrong alignment on GzMapDecoration_SetMaxZoom");
static_assert(sizeof(GzMapDecoration_SetMaxZoom) == 0x000004, "Wrong size on GzMapDecoration_SetMaxZoom");
static_assert(offsetof(GzMapDecoration_SetMaxZoom, InMaxZoom) == 0x000000, "Member 'GzMapDecoration_SetMaxZoom::InMaxZoom' has a wrong offset!");

// Function G01.GzMapDecoration.SetMinZoom
// 0x0004 (0x0004 - 0x0000)
struct GzMapDecoration_SetMinZoom final
{
public:
	float                                         InMinZoom;                                         // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzMapDecoration_SetMinZoom) == 0x000004, "Wrong alignment on GzMapDecoration_SetMinZoom");
static_assert(sizeof(GzMapDecoration_SetMinZoom) == 0x000004, "Wrong size on GzMapDecoration_SetMinZoom");
static_assert(offsetof(GzMapDecoration_SetMinZoom, InMinZoom) == 0x000000, "Member 'GzMapDecoration_SetMinZoom::InMinZoom' has a wrong offset!");

// Function G01.GzMapTextDecoration.OnTextSet
// 0x0010 (0x0010 - 0x0000)
struct GzMapTextDecoration_OnTextSet final
{
public:
	class FText                                   InText;                                            // 0x0000(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzMapTextDecoration_OnTextSet) == 0x000008, "Wrong alignment on GzMapTextDecoration_OnTextSet");
static_assert(sizeof(GzMapTextDecoration_OnTextSet) == 0x000010, "Wrong size on GzMapTextDecoration_OnTextSet");
static_assert(offsetof(GzMapTextDecoration_OnTextSet, InText) == 0x000000, "Member 'GzMapTextDecoration_OnTextSet::InText' has a wrong offset!");

// Function G01.GzMapWidget.AddDecoration
// 0x0020 (0x0020 - 0x0000)
struct GzMapWidget_AddDecoration final
{
public:
	class UUserWidget*                            InWidget;                                          // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              WorldPosition;                                     // 0x0008(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ZOrder;                                            // 0x0018(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bOverlay;                                          // 0x001C(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3370[0x3];                                     // 0x001D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GzMapWidget_AddDecoration) == 0x000008, "Wrong alignment on GzMapWidget_AddDecoration");
static_assert(sizeof(GzMapWidget_AddDecoration) == 0x000020, "Wrong size on GzMapWidget_AddDecoration");
static_assert(offsetof(GzMapWidget_AddDecoration, InWidget) == 0x000000, "Member 'GzMapWidget_AddDecoration::InWidget' has a wrong offset!");
static_assert(offsetof(GzMapWidget_AddDecoration, WorldPosition) == 0x000008, "Member 'GzMapWidget_AddDecoration::WorldPosition' has a wrong offset!");
static_assert(offsetof(GzMapWidget_AddDecoration, ZOrder) == 0x000018, "Member 'GzMapWidget_AddDecoration::ZOrder' has a wrong offset!");
static_assert(offsetof(GzMapWidget_AddDecoration, bOverlay) == 0x00001C, "Member 'GzMapWidget_AddDecoration::bOverlay' has a wrong offset!");

// Function G01.GzMapWidget.AddDecorationToScreen
// 0x0018 (0x0018 - 0x0000)
struct GzMapWidget_AddDecorationToScreen final
{
public:
	class UUserWidget*                            InWidget;                                          // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bOverlay;                                          // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3371[0x7];                                     // 0x0009(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UCanvasPanelSlot*                       ReturnValue;                                       // 0x0010(0x0008)(ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzMapWidget_AddDecorationToScreen) == 0x000008, "Wrong alignment on GzMapWidget_AddDecorationToScreen");
static_assert(sizeof(GzMapWidget_AddDecorationToScreen) == 0x000018, "Wrong size on GzMapWidget_AddDecorationToScreen");
static_assert(offsetof(GzMapWidget_AddDecorationToScreen, InWidget) == 0x000000, "Member 'GzMapWidget_AddDecorationToScreen::InWidget' has a wrong offset!");
static_assert(offsetof(GzMapWidget_AddDecorationToScreen, bOverlay) == 0x000008, "Member 'GzMapWidget_AddDecorationToScreen::bOverlay' has a wrong offset!");
static_assert(offsetof(GzMapWidget_AddDecorationToScreen, ReturnValue) == 0x000010, "Member 'GzMapWidget_AddDecorationToScreen::ReturnValue' has a wrong offset!");

// Function G01.GzMapWidget.AddSplineDecoration
// 0x0010 (0x0010 - 0x0000)
struct GzMapWidget_AddSplineDecoration final
{
public:
	class UGzSplineMapWidget*                     InWidget;                                          // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bOverlay;                                          // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3372[0x7];                                     // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GzMapWidget_AddSplineDecoration) == 0x000008, "Wrong alignment on GzMapWidget_AddSplineDecoration");
static_assert(sizeof(GzMapWidget_AddSplineDecoration) == 0x000010, "Wrong size on GzMapWidget_AddSplineDecoration");
static_assert(offsetof(GzMapWidget_AddSplineDecoration, InWidget) == 0x000000, "Member 'GzMapWidget_AddSplineDecoration::InWidget' has a wrong offset!");
static_assert(offsetof(GzMapWidget_AddSplineDecoration, bOverlay) == 0x000008, "Member 'GzMapWidget_AddSplineDecoration::bOverlay' has a wrong offset!");

// Function G01.GzMapWidget.AddZoneFillLayer
// 0x0018 (0x0018 - 0x0000)
struct GzMapWidget_AddZoneFillLayer final
{
public:
	class UMaterialInterface*                     InMaterial;                                        // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ZOrder;                                            // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3373[0x4];                                     // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UGzZoneFillLayerWidget*                 ReturnValue;                                       // 0x0010(0x0008)(ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzMapWidget_AddZoneFillLayer) == 0x000008, "Wrong alignment on GzMapWidget_AddZoneFillLayer");
static_assert(sizeof(GzMapWidget_AddZoneFillLayer) == 0x000018, "Wrong size on GzMapWidget_AddZoneFillLayer");
static_assert(offsetof(GzMapWidget_AddZoneFillLayer, InMaterial) == 0x000000, "Member 'GzMapWidget_AddZoneFillLayer::InMaterial' has a wrong offset!");
static_assert(offsetof(GzMapWidget_AddZoneFillLayer, ZOrder) == 0x000008, "Member 'GzMapWidget_AddZoneFillLayer::ZOrder' has a wrong offset!");
static_assert(offsetof(GzMapWidget_AddZoneFillLayer, ReturnValue) == 0x000010, "Member 'GzMapWidget_AddZoneFillLayer::ReturnValue' has a wrong offset!");

// Function G01.GzMapWidget.RemoveDecoration
// 0x0008 (0x0008 - 0x0000)
struct GzMapWidget_RemoveDecoration final
{
public:
	class UUserWidget*                            InWidget;                                          // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzMapWidget_RemoveDecoration) == 0x000008, "Wrong alignment on GzMapWidget_RemoveDecoration");
static_assert(sizeof(GzMapWidget_RemoveDecoration) == 0x000008, "Wrong size on GzMapWidget_RemoveDecoration");
static_assert(offsetof(GzMapWidget_RemoveDecoration, InWidget) == 0x000000, "Member 'GzMapWidget_RemoveDecoration::InWidget' has a wrong offset!");

// Function G01.GzMapWidget.RemoveZoneFillLayer
// 0x0008 (0x0008 - 0x0000)
struct GzMapWidget_RemoveZoneFillLayer final
{
public:
	class UGzZoneFillLayerWidget*                 LayerWidget;                                       // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzMapWidget_RemoveZoneFillLayer) == 0x000008, "Wrong alignment on GzMapWidget_RemoveZoneFillLayer");
static_assert(sizeof(GzMapWidget_RemoveZoneFillLayer) == 0x000008, "Wrong size on GzMapWidget_RemoveZoneFillLayer");
static_assert(offsetof(GzMapWidget_RemoveZoneFillLayer, LayerWidget) == 0x000000, "Member 'GzMapWidget_RemoveZoneFillLayer::LayerWidget' has a wrong offset!");

// Function G01.GzMapWidget.SetBoundingGeometryOverride
// 0x0038 (0x0038 - 0x0000)
struct GzMapWidget_SetBoundingGeometryOverride final
{
public:
	struct FGeometry                              InGeometry;                                        // 0x0000(0x0038)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzMapWidget_SetBoundingGeometryOverride) == 0x000004, "Wrong alignment on GzMapWidget_SetBoundingGeometryOverride");
static_assert(sizeof(GzMapWidget_SetBoundingGeometryOverride) == 0x000038, "Wrong size on GzMapWidget_SetBoundingGeometryOverride");
static_assert(offsetof(GzMapWidget_SetBoundingGeometryOverride, InGeometry) == 0x000000, "Member 'GzMapWidget_SetBoundingGeometryOverride::InGeometry' has a wrong offset!");

// Function G01.GzMapWidget.SetCaptureEveryFrame
// 0x0001 (0x0001 - 0x0000)
struct GzMapWidget_SetCaptureEveryFrame final
{
public:
	bool                                          bCaptureEveryFram;                                 // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzMapWidget_SetCaptureEveryFrame) == 0x000001, "Wrong alignment on GzMapWidget_SetCaptureEveryFrame");
static_assert(sizeof(GzMapWidget_SetCaptureEveryFrame) == 0x000001, "Wrong size on GzMapWidget_SetCaptureEveryFrame");
static_assert(offsetof(GzMapWidget_SetCaptureEveryFrame, bCaptureEveryFram) == 0x000000, "Member 'GzMapWidget_SetCaptureEveryFrame::bCaptureEveryFram' has a wrong offset!");

// Function G01.GzMapWidget.SetMapZoom
// 0x0004 (0x0004 - 0x0000)
struct GzMapWidget_SetMapZoom final
{
public:
	float                                         Zoom;                                              // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzMapWidget_SetMapZoom) == 0x000004, "Wrong alignment on GzMapWidget_SetMapZoom");
static_assert(sizeof(GzMapWidget_SetMapZoom) == 0x000004, "Wrong size on GzMapWidget_SetMapZoom");
static_assert(offsetof(GzMapWidget_SetMapZoom, Zoom) == 0x000000, "Member 'GzMapWidget_SetMapZoom::Zoom' has a wrong offset!");

// Function G01.GzMapWidget.ZoomToExtent
// 0x0030 (0x0030 - 0x0000)
struct GzMapWidget_ZoomToExtent final
{
public:
	struct FBox2D                                 Box;                                               // 0x0000(0x0028)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	float                                         ZoomMultiplier;                                    // 0x0028(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3374[0x4];                                     // 0x002C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GzMapWidget_ZoomToExtent) == 0x000008, "Wrong alignment on GzMapWidget_ZoomToExtent");
static_assert(sizeof(GzMapWidget_ZoomToExtent) == 0x000030, "Wrong size on GzMapWidget_ZoomToExtent");
static_assert(offsetof(GzMapWidget_ZoomToExtent, Box) == 0x000000, "Member 'GzMapWidget_ZoomToExtent::Box' has a wrong offset!");
static_assert(offsetof(GzMapWidget_ZoomToExtent, ZoomMultiplier) == 0x000028, "Member 'GzMapWidget_ZoomToExtent::ZoomMultiplier' has a wrong offset!");

// Function G01.GzMapWidget.ZoomToFit
// 0x0018 (0x0018 - 0x0000)
struct GzMapWidget_ZoomToFit final
{
public:
	TArray<struct FVector2D>                      InWorldPoints;                                     // 0x0000(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	float                                         ZoomMultiplier;                                    // 0x0010(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3375[0x4];                                     // 0x0014(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GzMapWidget_ZoomToFit) == 0x000008, "Wrong alignment on GzMapWidget_ZoomToFit");
static_assert(sizeof(GzMapWidget_ZoomToFit) == 0x000018, "Wrong size on GzMapWidget_ZoomToFit");
static_assert(offsetof(GzMapWidget_ZoomToFit, InWorldPoints) == 0x000000, "Member 'GzMapWidget_ZoomToFit::InWorldPoints' has a wrong offset!");
static_assert(offsetof(GzMapWidget_ZoomToFit, ZoomMultiplier) == 0x000010, "Member 'GzMapWidget_ZoomToFit::ZoomMultiplier' has a wrong offset!");

// Function G01.GzMapWidget.GetBoundingGeometry
// 0x0038 (0x0038 - 0x0000)
struct GzMapWidget_GetBoundingGeometry final
{
public:
	struct FGeometry                              ReturnValue;                                       // 0x0000(0x0038)(Parm, OutParm, ReturnParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzMapWidget_GetBoundingGeometry) == 0x000004, "Wrong alignment on GzMapWidget_GetBoundingGeometry");
static_assert(sizeof(GzMapWidget_GetBoundingGeometry) == 0x000038, "Wrong size on GzMapWidget_GetBoundingGeometry");
static_assert(offsetof(GzMapWidget_GetBoundingGeometry, ReturnValue) == 0x000000, "Member 'GzMapWidget_GetBoundingGeometry::ReturnValue' has a wrong offset!");

// Function G01.GzMapWidget.GetMapRotationAngle
// 0x0004 (0x0004 - 0x0000)
struct GzMapWidget_GetMapRotationAngle final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzMapWidget_GetMapRotationAngle) == 0x000004, "Wrong alignment on GzMapWidget_GetMapRotationAngle");
static_assert(sizeof(GzMapWidget_GetMapRotationAngle) == 0x000004, "Wrong size on GzMapWidget_GetMapRotationAngle");
static_assert(offsetof(GzMapWidget_GetMapRotationAngle, ReturnValue) == 0x000000, "Member 'GzMapWidget_GetMapRotationAngle::ReturnValue' has a wrong offset!");

// Function G01.GzMapWidget.GetMapSize
// 0x0010 (0x0010 - 0x0000)
struct GzMapWidget_GetMapSize final
{
public:
	struct FVector2D                              ReturnValue;                                       // 0x0000(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzMapWidget_GetMapSize) == 0x000008, "Wrong alignment on GzMapWidget_GetMapSize");
static_assert(sizeof(GzMapWidget_GetMapSize) == 0x000010, "Wrong size on GzMapWidget_GetMapSize");
static_assert(offsetof(GzMapWidget_GetMapSize, ReturnValue) == 0x000000, "Member 'GzMapWidget_GetMapSize::ReturnValue' has a wrong offset!");

// Function G01.GzMapWidget.GetMapZoom
// 0x0004 (0x0004 - 0x0000)
struct GzMapWidget_GetMapZoom final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzMapWidget_GetMapZoom) == 0x000004, "Wrong alignment on GzMapWidget_GetMapZoom");
static_assert(sizeof(GzMapWidget_GetMapZoom) == 0x000004, "Wrong size on GzMapWidget_GetMapZoom");
static_assert(offsetof(GzMapWidget_GetMapZoom, ReturnValue) == 0x000000, "Member 'GzMapWidget_GetMapZoom::ReturnValue' has a wrong offset!");

// Function G01.GzMapWidget.GetMarkerContainer
// 0x0008 (0x0008 - 0x0000)
struct GzMapWidget_GetMarkerContainer final
{
public:
	class UGzMapMarkerContainer*                  ReturnValue;                                       // 0x0000(0x0008)(ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzMapWidget_GetMarkerContainer) == 0x000008, "Wrong alignment on GzMapWidget_GetMarkerContainer");
static_assert(sizeof(GzMapWidget_GetMarkerContainer) == 0x000008, "Wrong size on GzMapWidget_GetMarkerContainer");
static_assert(offsetof(GzMapWidget_GetMarkerContainer, ReturnValue) == 0x000000, "Member 'GzMapWidget_GetMarkerContainer::ReturnValue' has a wrong offset!");

// Function G01.GzMapWidget.GetMaxZoom
// 0x0004 (0x0004 - 0x0000)
struct GzMapWidget_GetMaxZoom final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzMapWidget_GetMaxZoom) == 0x000004, "Wrong alignment on GzMapWidget_GetMaxZoom");
static_assert(sizeof(GzMapWidget_GetMaxZoom) == 0x000004, "Wrong size on GzMapWidget_GetMaxZoom");
static_assert(offsetof(GzMapWidget_GetMaxZoom, ReturnValue) == 0x000000, "Member 'GzMapWidget_GetMaxZoom::ReturnValue' has a wrong offset!");

// Function G01.GzMapWidget.GetMinZoom
// 0x0004 (0x0004 - 0x0000)
struct GzMapWidget_GetMinZoom final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzMapWidget_GetMinZoom) == 0x000004, "Wrong alignment on GzMapWidget_GetMinZoom");
static_assert(sizeof(GzMapWidget_GetMinZoom) == 0x000004, "Wrong size on GzMapWidget_GetMinZoom");
static_assert(offsetof(GzMapWidget_GetMinZoom, ReturnValue) == 0x000000, "Member 'GzMapWidget_GetMinZoom::ReturnValue' has a wrong offset!");

// Function G01.GzMapWidget.IsMinimap
// 0x0001 (0x0001 - 0x0000)
struct GzMapWidget_IsMinimap final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzMapWidget_IsMinimap) == 0x000001, "Wrong alignment on GzMapWidget_IsMinimap");
static_assert(sizeof(GzMapWidget_IsMinimap) == 0x000001, "Wrong size on GzMapWidget_IsMinimap");
static_assert(offsetof(GzMapWidget_IsMinimap, ReturnValue) == 0x000000, "Member 'GzMapWidget_IsMinimap::ReturnValue' has a wrong offset!");

// Function G01.GzMapWidget.IsReady
// 0x0001 (0x0001 - 0x0000)
struct GzMapWidget_IsReady final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzMapWidget_IsReady) == 0x000001, "Wrong alignment on GzMapWidget_IsReady");
static_assert(sizeof(GzMapWidget_IsReady) == 0x000001, "Wrong size on GzMapWidget_IsReady");
static_assert(offsetof(GzMapWidget_IsReady, ReturnValue) == 0x000000, "Member 'GzMapWidget_IsReady::ReturnValue' has a wrong offset!");

// Function G01.GzMapWidget.TransformScreenToWorldSpace
// 0x0020 (0x0020 - 0x0000)
struct GzMapWidget_TransformScreenToWorldSpace final
{
public:
	struct FVector2D                              Pos;                                               // 0x0000(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              ReturnValue;                                       // 0x0010(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzMapWidget_TransformScreenToWorldSpace) == 0x000008, "Wrong alignment on GzMapWidget_TransformScreenToWorldSpace");
static_assert(sizeof(GzMapWidget_TransformScreenToWorldSpace) == 0x000020, "Wrong size on GzMapWidget_TransformScreenToWorldSpace");
static_assert(offsetof(GzMapWidget_TransformScreenToWorldSpace, Pos) == 0x000000, "Member 'GzMapWidget_TransformScreenToWorldSpace::Pos' has a wrong offset!");
static_assert(offsetof(GzMapWidget_TransformScreenToWorldSpace, ReturnValue) == 0x000010, "Member 'GzMapWidget_TransformScreenToWorldSpace::ReturnValue' has a wrong offset!");

// Function G01.GzMapWidget.TransformWorldToScreenRotation
// 0x0008 (0x0008 - 0x0000)
struct GzMapWidget_TransformWorldToScreenRotation final
{
public:
	float                                         ActorRotation;                                     // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ReturnValue;                                       // 0x0004(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzMapWidget_TransformWorldToScreenRotation) == 0x000004, "Wrong alignment on GzMapWidget_TransformWorldToScreenRotation");
static_assert(sizeof(GzMapWidget_TransformWorldToScreenRotation) == 0x000008, "Wrong size on GzMapWidget_TransformWorldToScreenRotation");
static_assert(offsetof(GzMapWidget_TransformWorldToScreenRotation, ActorRotation) == 0x000000, "Member 'GzMapWidget_TransformWorldToScreenRotation::ActorRotation' has a wrong offset!");
static_assert(offsetof(GzMapWidget_TransformWorldToScreenRotation, ReturnValue) == 0x000004, "Member 'GzMapWidget_TransformWorldToScreenRotation::ReturnValue' has a wrong offset!");

// Function G01.GzMapWidget.TransformWorldToScreenSpace
// 0x0020 (0x0020 - 0x0000)
struct GzMapWidget_TransformWorldToScreenSpace final
{
public:
	struct FVector2D                              Pos;                                               // 0x0000(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              ReturnValue;                                       // 0x0010(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzMapWidget_TransformWorldToScreenSpace) == 0x000008, "Wrong alignment on GzMapWidget_TransformWorldToScreenSpace");
static_assert(sizeof(GzMapWidget_TransformWorldToScreenSpace) == 0x000020, "Wrong size on GzMapWidget_TransformWorldToScreenSpace");
static_assert(offsetof(GzMapWidget_TransformWorldToScreenSpace, Pos) == 0x000000, "Member 'GzMapWidget_TransformWorldToScreenSpace::Pos' has a wrong offset!");
static_assert(offsetof(GzMapWidget_TransformWorldToScreenSpace, ReturnValue) == 0x000010, "Member 'GzMapWidget_TransformWorldToScreenSpace::ReturnValue' has a wrong offset!");

// Function G01.GzMapZoneWidget.OnRadiusChange
// 0x0004 (0x0004 - 0x0000)
struct GzMapZoneWidget_OnRadiusChange final
{
public:
	float                                         NewRadius;                                         // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzMapZoneWidget_OnRadiusChange) == 0x000004, "Wrong alignment on GzMapZoneWidget_OnRadiusChange");
static_assert(sizeof(GzMapZoneWidget_OnRadiusChange) == 0x000004, "Wrong size on GzMapZoneWidget_OnRadiusChange");
static_assert(offsetof(GzMapZoneWidget_OnRadiusChange, NewRadius) == 0x000000, "Member 'GzMapZoneWidget_OnRadiusChange::NewRadius' has a wrong offset!");

// Function G01.GzMapZoneWidget.GetLandingZonesPositions
// 0x0010 (0x0010 - 0x0000)
struct GzMapZoneWidget_GetLandingZonesPositions final
{
public:
	TArray<struct FGzLandingZoneUIData>           ReturnValue;                                       // 0x0000(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzMapZoneWidget_GetLandingZonesPositions) == 0x000008, "Wrong alignment on GzMapZoneWidget_GetLandingZonesPositions");
static_assert(sizeof(GzMapZoneWidget_GetLandingZonesPositions) == 0x000010, "Wrong size on GzMapZoneWidget_GetLandingZonesPositions");
static_assert(offsetof(GzMapZoneWidget_GetLandingZonesPositions, ReturnValue) == 0x000000, "Member 'GzMapZoneWidget_GetLandingZonesPositions::ReturnValue' has a wrong offset!");

// Function G01.GzSeethroughScope.GetScopeMesh
// 0x0008 (0x0008 - 0x0000)
struct GzSeethroughScope_GetScopeMesh final
{
public:
	class UMeshComponent*                         ReturnValue;                                       // 0x0000(0x0008)(ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzSeethroughScope_GetScopeMesh) == 0x000008, "Wrong alignment on GzSeethroughScope_GetScopeMesh");
static_assert(sizeof(GzSeethroughScope_GetScopeMesh) == 0x000008, "Wrong size on GzSeethroughScope_GetScopeMesh");
static_assert(offsetof(GzSeethroughScope_GetScopeMesh, ReturnValue) == 0x000000, "Member 'GzSeethroughScope_GetScopeMesh::ReturnValue' has a wrong offset!");

// Function G01.GzReplayPlayerController.GotoReplayTimeInSeconds
// 0x0004 (0x0004 - 0x0000)
struct GzReplayPlayerController_GotoReplayTimeInSeconds final
{
public:
	float                                         Seconds;                                           // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzReplayPlayerController_GotoReplayTimeInSeconds) == 0x000004, "Wrong alignment on GzReplayPlayerController_GotoReplayTimeInSeconds");
static_assert(sizeof(GzReplayPlayerController_GotoReplayTimeInSeconds) == 0x000004, "Wrong size on GzReplayPlayerController_GotoReplayTimeInSeconds");
static_assert(offsetof(GzReplayPlayerController_GotoReplayTimeInSeconds, Seconds) == 0x000000, "Member 'GzReplayPlayerController_GotoReplayTimeInSeconds::Seconds' has a wrong offset!");

// Function G01.GzReplayPlayerController.SetReplayPlayRate
// 0x0004 (0x0004 - 0x0000)
struct GzReplayPlayerController_SetReplayPlayRate final
{
public:
	float                                         PlayRate;                                          // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzReplayPlayerController_SetReplayPlayRate) == 0x000004, "Wrong alignment on GzReplayPlayerController_SetReplayPlayRate");
static_assert(sizeof(GzReplayPlayerController_SetReplayPlayRate) == 0x000004, "Wrong size on GzReplayPlayerController_SetReplayPlayRate");
static_assert(offsetof(GzReplayPlayerController_SetReplayPlayRate, PlayRate) == 0x000000, "Member 'GzReplayPlayerController_SetReplayPlayRate::PlayRate' has a wrong offset!");

// Function G01.GzReplayPlayerController.SwitchPlayerByName
// 0x0010 (0x0010 - 0x0000)
struct GzReplayPlayerController_SwitchPlayerByName final
{
public:
	class FString                                 PlayerName;                                        // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzReplayPlayerController_SwitchPlayerByName) == 0x000008, "Wrong alignment on GzReplayPlayerController_SwitchPlayerByName");
static_assert(sizeof(GzReplayPlayerController_SwitchPlayerByName) == 0x000010, "Wrong size on GzReplayPlayerController_SwitchPlayerByName");
static_assert(offsetof(GzReplayPlayerController_SwitchPlayerByName, PlayerName) == 0x000000, "Member 'GzReplayPlayerController_SwitchPlayerByName::PlayerName' has a wrong offset!");

// Function G01.GzMetaPlayerInventoryCheatExtension.AddItem
// 0x0018 (0x0018 - 0x0000)
struct GzMetaPlayerInventoryCheatExtension_AddItem final
{
public:
	class FString                                 AssetId;                                           // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bLimitAndMint;                                     // 0x0010(0x0001)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3381[0x7];                                     // 0x0011(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GzMetaPlayerInventoryCheatExtension_AddItem) == 0x000008, "Wrong alignment on GzMetaPlayerInventoryCheatExtension_AddItem");
static_assert(sizeof(GzMetaPlayerInventoryCheatExtension_AddItem) == 0x000018, "Wrong size on GzMetaPlayerInventoryCheatExtension_AddItem");
static_assert(offsetof(GzMetaPlayerInventoryCheatExtension_AddItem, AssetId) == 0x000000, "Member 'GzMetaPlayerInventoryCheatExtension_AddItem::AssetId' has a wrong offset!");
static_assert(offsetof(GzMetaPlayerInventoryCheatExtension_AddItem, bLimitAndMint) == 0x000010, "Member 'GzMetaPlayerInventoryCheatExtension_AddItem::bLimitAndMint' has a wrong offset!");

// Function G01.GzMetaPlayerInventoryCheatExtension.AddItemsByFilters
// 0x0038 (0x0038 - 0x0000)
struct GzMetaPlayerInventoryCheatExtension_AddItemsByFilters final
{
public:
	class FString                                 Type;                                              // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Rarity;                                            // 0x0010(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 InventoryType;                                     // 0x0020(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bLimitAndMint;                                     // 0x0030(0x0001)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3382[0x7];                                     // 0x0031(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GzMetaPlayerInventoryCheatExtension_AddItemsByFilters) == 0x000008, "Wrong alignment on GzMetaPlayerInventoryCheatExtension_AddItemsByFilters");
static_assert(sizeof(GzMetaPlayerInventoryCheatExtension_AddItemsByFilters) == 0x000038, "Wrong size on GzMetaPlayerInventoryCheatExtension_AddItemsByFilters");
static_assert(offsetof(GzMetaPlayerInventoryCheatExtension_AddItemsByFilters, Type) == 0x000000, "Member 'GzMetaPlayerInventoryCheatExtension_AddItemsByFilters::Type' has a wrong offset!");
static_assert(offsetof(GzMetaPlayerInventoryCheatExtension_AddItemsByFilters, Rarity) == 0x000010, "Member 'GzMetaPlayerInventoryCheatExtension_AddItemsByFilters::Rarity' has a wrong offset!");
static_assert(offsetof(GzMetaPlayerInventoryCheatExtension_AddItemsByFilters, InventoryType) == 0x000020, "Member 'GzMetaPlayerInventoryCheatExtension_AddItemsByFilters::InventoryType' has a wrong offset!");
static_assert(offsetof(GzMetaPlayerInventoryCheatExtension_AddItemsByFilters, bLimitAndMint) == 0x000030, "Member 'GzMetaPlayerInventoryCheatExtension_AddItemsByFilters::bLimitAndMint' has a wrong offset!");

// Function G01.GzMetaPlayerInventoryCheatExtension.AddItemsOfTypeV2
// 0x0018 (0x0018 - 0x0000)
struct GzMetaPlayerInventoryCheatExtension_AddItemsOfTypeV2 final
{
public:
	class FString                                 ItemType;                                          // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bLimitAndMint;                                     // 0x0010(0x0001)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3383[0x7];                                     // 0x0011(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GzMetaPlayerInventoryCheatExtension_AddItemsOfTypeV2) == 0x000008, "Wrong alignment on GzMetaPlayerInventoryCheatExtension_AddItemsOfTypeV2");
static_assert(sizeof(GzMetaPlayerInventoryCheatExtension_AddItemsOfTypeV2) == 0x000018, "Wrong size on GzMetaPlayerInventoryCheatExtension_AddItemsOfTypeV2");
static_assert(offsetof(GzMetaPlayerInventoryCheatExtension_AddItemsOfTypeV2, ItemType) == 0x000000, "Member 'GzMetaPlayerInventoryCheatExtension_AddItemsOfTypeV2::ItemType' has a wrong offset!");
static_assert(offsetof(GzMetaPlayerInventoryCheatExtension_AddItemsOfTypeV2, bLimitAndMint) == 0x000010, "Member 'GzMetaPlayerInventoryCheatExtension_AddItemsOfTypeV2::bLimitAndMint' has a wrong offset!");

// Function G01.GzMetaPlayerInventoryCheatExtension.DisableSingleItemFromUICatalog
// 0x0010 (0x0010 - 0x0000)
struct GzMetaPlayerInventoryCheatExtension_DisableSingleItemFromUICatalog final
{
public:
	class FString                                 AssetId;                                           // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzMetaPlayerInventoryCheatExtension_DisableSingleItemFromUICatalog) == 0x000008, "Wrong alignment on GzMetaPlayerInventoryCheatExtension_DisableSingleItemFromUICatalog");
static_assert(sizeof(GzMetaPlayerInventoryCheatExtension_DisableSingleItemFromUICatalog) == 0x000010, "Wrong size on GzMetaPlayerInventoryCheatExtension_DisableSingleItemFromUICatalog");
static_assert(offsetof(GzMetaPlayerInventoryCheatExtension_DisableSingleItemFromUICatalog, AssetId) == 0x000000, "Member 'GzMetaPlayerInventoryCheatExtension_DisableSingleItemFromUICatalog::AssetId' has a wrong offset!");

// Function G01.GzMetaPlayerInventoryCheatExtension.DumpAllCITsForSlot
// 0x0010 (0x0010 - 0x0000)
struct GzMetaPlayerInventoryCheatExtension_DumpAllCITsForSlot final
{
public:
	class FString                                 SlotID;                                            // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzMetaPlayerInventoryCheatExtension_DumpAllCITsForSlot) == 0x000008, "Wrong alignment on GzMetaPlayerInventoryCheatExtension_DumpAllCITsForSlot");
static_assert(sizeof(GzMetaPlayerInventoryCheatExtension_DumpAllCITsForSlot) == 0x000010, "Wrong size on GzMetaPlayerInventoryCheatExtension_DumpAllCITsForSlot");
static_assert(offsetof(GzMetaPlayerInventoryCheatExtension_DumpAllCITsForSlot, SlotID) == 0x000000, "Member 'GzMetaPlayerInventoryCheatExtension_DumpAllCITsForSlot::SlotID' has a wrong offset!");

// Function G01.GzMetaPlayerInventoryCheatExtension.MarkInventoryItemReviewed
// 0x0010 (0x0010 - 0x0000)
struct GzMetaPlayerInventoryCheatExtension_MarkInventoryItemReviewed final
{
public:
	class FString                                 ItemGuid;                                          // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzMetaPlayerInventoryCheatExtension_MarkInventoryItemReviewed) == 0x000008, "Wrong alignment on GzMetaPlayerInventoryCheatExtension_MarkInventoryItemReviewed");
static_assert(sizeof(GzMetaPlayerInventoryCheatExtension_MarkInventoryItemReviewed) == 0x000010, "Wrong size on GzMetaPlayerInventoryCheatExtension_MarkInventoryItemReviewed");
static_assert(offsetof(GzMetaPlayerInventoryCheatExtension_MarkInventoryItemReviewed, ItemGuid) == 0x000000, "Member 'GzMetaPlayerInventoryCheatExtension_MarkInventoryItemReviewed::ItemGuid' has a wrong offset!");

// Function G01.GzMetaPlayerInventoryCheatExtension.RevokeItemsByFilters
// 0x0030 (0x0030 - 0x0000)
struct GzMetaPlayerInventoryCheatExtension_RevokeItemsByFilters final
{
public:
	class FString                                 Type;                                              // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Rarity;                                            // 0x0010(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 InventoryType;                                     // 0x0020(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzMetaPlayerInventoryCheatExtension_RevokeItemsByFilters) == 0x000008, "Wrong alignment on GzMetaPlayerInventoryCheatExtension_RevokeItemsByFilters");
static_assert(sizeof(GzMetaPlayerInventoryCheatExtension_RevokeItemsByFilters) == 0x000030, "Wrong size on GzMetaPlayerInventoryCheatExtension_RevokeItemsByFilters");
static_assert(offsetof(GzMetaPlayerInventoryCheatExtension_RevokeItemsByFilters, Type) == 0x000000, "Member 'GzMetaPlayerInventoryCheatExtension_RevokeItemsByFilters::Type' has a wrong offset!");
static_assert(offsetof(GzMetaPlayerInventoryCheatExtension_RevokeItemsByFilters, Rarity) == 0x000010, "Member 'GzMetaPlayerInventoryCheatExtension_RevokeItemsByFilters::Rarity' has a wrong offset!");
static_assert(offsetof(GzMetaPlayerInventoryCheatExtension_RevokeItemsByFilters, InventoryType) == 0x000020, "Member 'GzMetaPlayerInventoryCheatExtension_RevokeItemsByFilters::InventoryType' has a wrong offset!");

// Function G01.GzMetaPlayerInventoryCheatExtension.RevokeItemsOfTypeV2
// 0x0010 (0x0010 - 0x0000)
struct GzMetaPlayerInventoryCheatExtension_RevokeItemsOfTypeV2 final
{
public:
	class FString                                 ItemType;                                          // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzMetaPlayerInventoryCheatExtension_RevokeItemsOfTypeV2) == 0x000008, "Wrong alignment on GzMetaPlayerInventoryCheatExtension_RevokeItemsOfTypeV2");
static_assert(sizeof(GzMetaPlayerInventoryCheatExtension_RevokeItemsOfTypeV2) == 0x000010, "Wrong size on GzMetaPlayerInventoryCheatExtension_RevokeItemsOfTypeV2");
static_assert(offsetof(GzMetaPlayerInventoryCheatExtension_RevokeItemsOfTypeV2, ItemType) == 0x000000, "Member 'GzMetaPlayerInventoryCheatExtension_RevokeItemsOfTypeV2::ItemType' has a wrong offset!");

// Function G01.GzMetricsSubsystem.OnMissionStateChanged
// 0x0020 (0x0020 - 0x0000)
struct GzMetricsSubsystem_OnMissionStateChanged final
{
public:
	class AGzMission*                             Mission;                                           // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGzMissionState                        OldState;                                          // 0x0008(0x000C)(Parm, NoDestructor, NativeAccessSpecifierPublic)
	struct FGzMissionState                        MissionState;                                      // 0x0014(0x000C)(Parm, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzMetricsSubsystem_OnMissionStateChanged) == 0x000008, "Wrong alignment on GzMetricsSubsystem_OnMissionStateChanged");
static_assert(sizeof(GzMetricsSubsystem_OnMissionStateChanged) == 0x000020, "Wrong size on GzMetricsSubsystem_OnMissionStateChanged");
static_assert(offsetof(GzMetricsSubsystem_OnMissionStateChanged, Mission) == 0x000000, "Member 'GzMetricsSubsystem_OnMissionStateChanged::Mission' has a wrong offset!");
static_assert(offsetof(GzMetricsSubsystem_OnMissionStateChanged, OldState) == 0x000008, "Member 'GzMetricsSubsystem_OnMissionStateChanged::OldState' has a wrong offset!");
static_assert(offsetof(GzMetricsSubsystem_OnMissionStateChanged, MissionState) == 0x000014, "Member 'GzMetricsSubsystem_OnMissionStateChanged::MissionState' has a wrong offset!");

// Function G01.GzMicroMissilesComponent.Client_AckLockonTarget
// 0x0008 (0x0008 - 0x0000)
struct GzMicroMissilesComponent_Client_AckLockonTarget final
{
public:
	int32                                         SlotNumber;                                        // 0x0000(0x0004)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsValid;                                          // 0x0004(0x0001)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3388[0x3];                                     // 0x0005(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GzMicroMissilesComponent_Client_AckLockonTarget) == 0x000004, "Wrong alignment on GzMicroMissilesComponent_Client_AckLockonTarget");
static_assert(sizeof(GzMicroMissilesComponent_Client_AckLockonTarget) == 0x000008, "Wrong size on GzMicroMissilesComponent_Client_AckLockonTarget");
static_assert(offsetof(GzMicroMissilesComponent_Client_AckLockonTarget, SlotNumber) == 0x000000, "Member 'GzMicroMissilesComponent_Client_AckLockonTarget::SlotNumber' has a wrong offset!");
static_assert(offsetof(GzMicroMissilesComponent_Client_AckLockonTarget, bIsValid) == 0x000004, "Member 'GzMicroMissilesComponent_Client_AckLockonTarget::bIsValid' has a wrong offset!");

// Function G01.GzMicroMissilesComponent.GetCurrentLockOnDataAsAbilityTargetData
// 0x0028 (0x0028 - 0x0000)
struct GzMicroMissilesComponent_GetCurrentLockOnDataAsAbilityTargetData final
{
public:
	struct FGameplayAbilityTargetDataHandle       ReturnValue;                                       // 0x0000(0x0028)(Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzMicroMissilesComponent_GetCurrentLockOnDataAsAbilityTargetData) == 0x000008, "Wrong alignment on GzMicroMissilesComponent_GetCurrentLockOnDataAsAbilityTargetData");
static_assert(sizeof(GzMicroMissilesComponent_GetCurrentLockOnDataAsAbilityTargetData) == 0x000028, "Wrong size on GzMicroMissilesComponent_GetCurrentLockOnDataAsAbilityTargetData");
static_assert(offsetof(GzMicroMissilesComponent_GetCurrentLockOnDataAsAbilityTargetData, ReturnValue) == 0x000000, "Member 'GzMicroMissilesComponent_GetCurrentLockOnDataAsAbilityTargetData::ReturnValue' has a wrong offset!");

// DelegateFunction G01.GzMicroMissilesComponent.GzLockOnChanged__DelegateSignature
// 0x0120 (0x0120 - 0x0000)
struct GzMicroMissilesComponent_GzLockOnChanged__DelegateSignature final
{
public:
	struct FGzMicroMissiles_LockOnTarget          TargetData;                                        // 0x0000(0x0120)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzMicroMissilesComponent_GzLockOnChanged__DelegateSignature) == 0x000008, "Wrong alignment on GzMicroMissilesComponent_GzLockOnChanged__DelegateSignature");
static_assert(sizeof(GzMicroMissilesComponent_GzLockOnChanged__DelegateSignature) == 0x000120, "Wrong size on GzMicroMissilesComponent_GzLockOnChanged__DelegateSignature");
static_assert(offsetof(GzMicroMissilesComponent_GzLockOnChanged__DelegateSignature, TargetData) == 0x000000, "Member 'GzMicroMissilesComponent_GzLockOnChanged__DelegateSignature::TargetData' has a wrong offset!");

// Function G01.GzMicroMissilesComponent.Server_RemoveLockonTarget
// 0x0004 (0x0004 - 0x0000)
struct GzMicroMissilesComponent_Server_RemoveLockonTarget final
{
public:
	int32                                         SlotNumber;                                        // 0x0000(0x0004)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzMicroMissilesComponent_Server_RemoveLockonTarget) == 0x000004, "Wrong alignment on GzMicroMissilesComponent_Server_RemoveLockonTarget");
static_assert(sizeof(GzMicroMissilesComponent_Server_RemoveLockonTarget) == 0x000004, "Wrong size on GzMicroMissilesComponent_Server_RemoveLockonTarget");
static_assert(offsetof(GzMicroMissilesComponent_Server_RemoveLockonTarget, SlotNumber) == 0x000000, "Member 'GzMicroMissilesComponent_Server_RemoveLockonTarget::SlotNumber' has a wrong offset!");

// Function G01.GzMicroMissilesComponent.Server_ValidateLockonTarget
// 0x0128 (0x0128 - 0x0000)
struct GzMicroMissilesComponent_Server_ValidateLockonTarget final
{
public:
	struct FGzMicroMissiles_LockOnTarget          LockOnTargetData;                                  // 0x0000(0x0120)(ConstParm, Parm, ReferenceParm, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	int32                                         SlotNumber;                                        // 0x0120(0x0004)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3389[0x4];                                     // 0x0124(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GzMicroMissilesComponent_Server_ValidateLockonTarget) == 0x000008, "Wrong alignment on GzMicroMissilesComponent_Server_ValidateLockonTarget");
static_assert(sizeof(GzMicroMissilesComponent_Server_ValidateLockonTarget) == 0x000128, "Wrong size on GzMicroMissilesComponent_Server_ValidateLockonTarget");
static_assert(offsetof(GzMicroMissilesComponent_Server_ValidateLockonTarget, LockOnTargetData) == 0x000000, "Member 'GzMicroMissilesComponent_Server_ValidateLockonTarget::LockOnTargetData' has a wrong offset!");
static_assert(offsetof(GzMicroMissilesComponent_Server_ValidateLockonTarget, SlotNumber) == 0x000120, "Member 'GzMicroMissilesComponent_Server_ValidateLockonTarget::SlotNumber' has a wrong offset!");

// Function G01.GzMicroMissilesComponent.StartLockOn
// 0x0120 (0x0120 - 0x0000)
struct GzMicroMissilesComponent_StartLockOn final
{
public:
	struct FGzMicroMissiles_LockOnTarget          TargetData;                                        // 0x0000(0x0120)(Parm, OutParm, ReferenceParm, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzMicroMissilesComponent_StartLockOn) == 0x000008, "Wrong alignment on GzMicroMissilesComponent_StartLockOn");
static_assert(sizeof(GzMicroMissilesComponent_StartLockOn) == 0x000120, "Wrong size on GzMicroMissilesComponent_StartLockOn");
static_assert(offsetof(GzMicroMissilesComponent_StartLockOn, TargetData) == 0x000000, "Member 'GzMicroMissilesComponent_StartLockOn::TargetData' has a wrong offset!");

// Function G01.GzMicroMissilesComponent.GetCurrentLockOnTargetLimit
// 0x0004 (0x0004 - 0x0000)
struct GzMicroMissilesComponent_GetCurrentLockOnTargetLimit final
{
public:
	int32                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzMicroMissilesComponent_GetCurrentLockOnTargetLimit) == 0x000004, "Wrong alignment on GzMicroMissilesComponent_GetCurrentLockOnTargetLimit");
static_assert(sizeof(GzMicroMissilesComponent_GetCurrentLockOnTargetLimit) == 0x000004, "Wrong size on GzMicroMissilesComponent_GetCurrentLockOnTargetLimit");
static_assert(offsetof(GzMicroMissilesComponent_GetCurrentLockOnTargetLimit, ReturnValue) == 0x000000, "Member 'GzMicroMissilesComponent_GetCurrentLockOnTargetLimit::ReturnValue' has a wrong offset!");

// Function G01.GzMicroMissilesComponent.GetLockOnTargetAmount
// 0x0004 (0x0004 - 0x0000)
struct GzMicroMissilesComponent_GetLockOnTargetAmount final
{
public:
	int32                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzMicroMissilesComponent_GetLockOnTargetAmount) == 0x000004, "Wrong alignment on GzMicroMissilesComponent_GetLockOnTargetAmount");
static_assert(sizeof(GzMicroMissilesComponent_GetLockOnTargetAmount) == 0x000004, "Wrong size on GzMicroMissilesComponent_GetLockOnTargetAmount");
static_assert(offsetof(GzMicroMissilesComponent_GetLockOnTargetAmount, ReturnValue) == 0x000000, "Member 'GzMicroMissilesComponent_GetLockOnTargetAmount::ReturnValue' has a wrong offset!");

// Function G01.GzMicroMissilesComponent.IsTargetInRange
// 0x0128 (0x0128 - 0x0000)
struct GzMicroMissilesComponent_IsTargetInRange final
{
public:
	struct FGzMicroMissiles_LockOnTarget          TargetData;                                        // 0x0000(0x0120)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0120(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_338A[0x7];                                     // 0x0121(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GzMicroMissilesComponent_IsTargetInRange) == 0x000008, "Wrong alignment on GzMicroMissilesComponent_IsTargetInRange");
static_assert(sizeof(GzMicroMissilesComponent_IsTargetInRange) == 0x000128, "Wrong size on GzMicroMissilesComponent_IsTargetInRange");
static_assert(offsetof(GzMicroMissilesComponent_IsTargetInRange, TargetData) == 0x000000, "Member 'GzMicroMissilesComponent_IsTargetInRange::TargetData' has a wrong offset!");
static_assert(offsetof(GzMicroMissilesComponent_IsTargetInRange, ReturnValue) == 0x000120, "Member 'GzMicroMissilesComponent_IsTargetInRange::ReturnValue' has a wrong offset!");

// Function G01.GzMicroMissilesComponent.IsTargetVisible
// 0x0128 (0x0128 - 0x0000)
struct GzMicroMissilesComponent_IsTargetVisible final
{
public:
	struct FGzMicroMissiles_LockOnTarget          TargetData;                                        // 0x0000(0x0120)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0120(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_338B[0x7];                                     // 0x0121(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GzMicroMissilesComponent_IsTargetVisible) == 0x000008, "Wrong alignment on GzMicroMissilesComponent_IsTargetVisible");
static_assert(sizeof(GzMicroMissilesComponent_IsTargetVisible) == 0x000128, "Wrong size on GzMicroMissilesComponent_IsTargetVisible");
static_assert(offsetof(GzMicroMissilesComponent_IsTargetVisible, TargetData) == 0x000000, "Member 'GzMicroMissilesComponent_IsTargetVisible::TargetData' has a wrong offset!");
static_assert(offsetof(GzMicroMissilesComponent_IsTargetVisible, ReturnValue) == 0x000120, "Member 'GzMicroMissilesComponent_IsTargetVisible::ReturnValue' has a wrong offset!");

// Function G01.GzMicroMissilesComponent.IsValidLockOnTarget
// 0x0128 (0x0128 - 0x0000)
struct GzMicroMissilesComponent_IsValidLockOnTarget final
{
public:
	struct FGzMicroMissiles_LockOnTarget          TargetData;                                        // 0x0000(0x0120)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0120(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_338C[0x7];                                     // 0x0121(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GzMicroMissilesComponent_IsValidLockOnTarget) == 0x000008, "Wrong alignment on GzMicroMissilesComponent_IsValidLockOnTarget");
static_assert(sizeof(GzMicroMissilesComponent_IsValidLockOnTarget) == 0x000128, "Wrong size on GzMicroMissilesComponent_IsValidLockOnTarget");
static_assert(offsetof(GzMicroMissilesComponent_IsValidLockOnTarget, TargetData) == 0x000000, "Member 'GzMicroMissilesComponent_IsValidLockOnTarget::TargetData' has a wrong offset!");
static_assert(offsetof(GzMicroMissilesComponent_IsValidLockOnTarget, ReturnValue) == 0x000120, "Member 'GzMicroMissilesComponent_IsValidLockOnTarget::ReturnValue' has a wrong offset!");

// Function G01.GzMicroMissilesLockOnIndicator.GetLockOnProgress
// 0x0004 (0x0004 - 0x0000)
struct GzMicroMissilesLockOnIndicator_GetLockOnProgress final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzMicroMissilesLockOnIndicator_GetLockOnProgress) == 0x000004, "Wrong alignment on GzMicroMissilesLockOnIndicator_GetLockOnProgress");
static_assert(sizeof(GzMicroMissilesLockOnIndicator_GetLockOnProgress) == 0x000004, "Wrong size on GzMicroMissilesLockOnIndicator_GetLockOnProgress");
static_assert(offsetof(GzMicroMissilesLockOnIndicator_GetLockOnProgress, ReturnValue) == 0x000000, "Member 'GzMicroMissilesLockOnIndicator_GetLockOnProgress::ReturnValue' has a wrong offset!");

// Function G01.GzProjectileGrenade.SetMaxGrenadeTimerSeconds
// 0x0004 (0x0004 - 0x0000)
struct GzProjectileGrenade_SetMaxGrenadeTimerSeconds final
{
public:
	float                                         MaxTimer;                                          // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzProjectileGrenade_SetMaxGrenadeTimerSeconds) == 0x000004, "Wrong alignment on GzProjectileGrenade_SetMaxGrenadeTimerSeconds");
static_assert(sizeof(GzProjectileGrenade_SetMaxGrenadeTimerSeconds) == 0x000004, "Wrong size on GzProjectileGrenade_SetMaxGrenadeTimerSeconds");
static_assert(offsetof(GzProjectileGrenade_SetMaxGrenadeTimerSeconds, MaxTimer) == 0x000000, "Member 'GzProjectileGrenade_SetMaxGrenadeTimerSeconds::MaxTimer' has a wrong offset!");

// Function G01.GzProjectileGrenade.GetCurrentGrenadeTimerSeconds
// 0x0004 (0x0004 - 0x0000)
struct GzProjectileGrenade_GetCurrentGrenadeTimerSeconds final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzProjectileGrenade_GetCurrentGrenadeTimerSeconds) == 0x000004, "Wrong alignment on GzProjectileGrenade_GetCurrentGrenadeTimerSeconds");
static_assert(sizeof(GzProjectileGrenade_GetCurrentGrenadeTimerSeconds) == 0x000004, "Wrong size on GzProjectileGrenade_GetCurrentGrenadeTimerSeconds");
static_assert(offsetof(GzProjectileGrenade_GetCurrentGrenadeTimerSeconds, ReturnValue) == 0x000000, "Member 'GzProjectileGrenade_GetCurrentGrenadeTimerSeconds::ReturnValue' has a wrong offset!");

// Function G01.GzProjectileGrenade.GetMaxGrenadeTimerSeconds
// 0x0004 (0x0004 - 0x0000)
struct GzProjectileGrenade_GetMaxGrenadeTimerSeconds final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzProjectileGrenade_GetMaxGrenadeTimerSeconds) == 0x000004, "Wrong alignment on GzProjectileGrenade_GetMaxGrenadeTimerSeconds");
static_assert(sizeof(GzProjectileGrenade_GetMaxGrenadeTimerSeconds) == 0x000004, "Wrong size on GzProjectileGrenade_GetMaxGrenadeTimerSeconds");
static_assert(offsetof(GzProjectileGrenade_GetMaxGrenadeTimerSeconds, ReturnValue) == 0x000000, "Member 'GzProjectileGrenade_GetMaxGrenadeTimerSeconds::ReturnValue' has a wrong offset!");

// Function G01.GzMicroMissiles_Missile.LaunchWithDelay
// 0x0004 (0x0004 - 0x0000)
struct GzMicroMissiles_Missile_LaunchWithDelay final
{
public:
	float                                         DelaySeconds;                                      // 0x0000(0x0004)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzMicroMissiles_Missile_LaunchWithDelay) == 0x000004, "Wrong alignment on GzMicroMissiles_Missile_LaunchWithDelay");
static_assert(sizeof(GzMicroMissiles_Missile_LaunchWithDelay) == 0x000004, "Wrong size on GzMicroMissiles_Missile_LaunchWithDelay");
static_assert(offsetof(GzMicroMissiles_Missile_LaunchWithDelay, DelaySeconds) == 0x000000, "Member 'GzMicroMissiles_Missile_LaunchWithDelay::DelaySeconds' has a wrong offset!");

// Function G01.GzMinigunComponent.ClientNotifyHostEndShooting
// 0x0001 (0x0001 - 0x0000)
struct GzMinigunComponent_ClientNotifyHostEndShooting final
{
public:
	bool                                          bOverheated;                                       // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzMinigunComponent_ClientNotifyHostEndShooting) == 0x000001, "Wrong alignment on GzMinigunComponent_ClientNotifyHostEndShooting");
static_assert(sizeof(GzMinigunComponent_ClientNotifyHostEndShooting) == 0x000001, "Wrong size on GzMinigunComponent_ClientNotifyHostEndShooting");
static_assert(offsetof(GzMinigunComponent_ClientNotifyHostEndShooting, bOverheated) == 0x000000, "Member 'GzMinigunComponent_ClientNotifyHostEndShooting::bOverheated' has a wrong offset!");

// Function G01.GzMinigunComponent.GetOverheatPercentage
// 0x0004 (0x0004 - 0x0000)
struct GzMinigunComponent_GetOverheatPercentage final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzMinigunComponent_GetOverheatPercentage) == 0x000004, "Wrong alignment on GzMinigunComponent_GetOverheatPercentage");
static_assert(sizeof(GzMinigunComponent_GetOverheatPercentage) == 0x000004, "Wrong size on GzMinigunComponent_GetOverheatPercentage");
static_assert(offsetof(GzMinigunComponent_GetOverheatPercentage, ReturnValue) == 0x000000, "Member 'GzMinigunComponent_GetOverheatPercentage::ReturnValue' has a wrong offset!");

// Function G01.GzMinigunComponent.GetRemainingAmmo
// 0x0004 (0x0004 - 0x0000)
struct GzMinigunComponent_GetRemainingAmmo final
{
public:
	int32                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzMinigunComponent_GetRemainingAmmo) == 0x000004, "Wrong alignment on GzMinigunComponent_GetRemainingAmmo");
static_assert(sizeof(GzMinigunComponent_GetRemainingAmmo) == 0x000004, "Wrong size on GzMinigunComponent_GetRemainingAmmo");
static_assert(offsetof(GzMinigunComponent_GetRemainingAmmo, ReturnValue) == 0x000000, "Member 'GzMinigunComponent_GetRemainingAmmo::ReturnValue' has a wrong offset!");

// Function G01.GzMinigunComponent.GetSpreadScale
// 0x0004 (0x0004 - 0x0000)
struct GzMinigunComponent_GetSpreadScale final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzMinigunComponent_GetSpreadScale) == 0x000004, "Wrong alignment on GzMinigunComponent_GetSpreadScale");
static_assert(sizeof(GzMinigunComponent_GetSpreadScale) == 0x000004, "Wrong size on GzMinigunComponent_GetSpreadScale");
static_assert(offsetof(GzMinigunComponent_GetSpreadScale, ReturnValue) == 0x000000, "Member 'GzMinigunComponent_GetSpreadScale::ReturnValue' has a wrong offset!");

// Function G01.GzMinigunComponent.IsOverheated
// 0x0001 (0x0001 - 0x0000)
struct GzMinigunComponent_IsOverheated final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzMinigunComponent_IsOverheated) == 0x000001, "Wrong alignment on GzMinigunComponent_IsOverheated");
static_assert(sizeof(GzMinigunComponent_IsOverheated) == 0x000001, "Wrong size on GzMinigunComponent_IsOverheated");
static_assert(offsetof(GzMinigunComponent_IsOverheated, ReturnValue) == 0x000000, "Member 'GzMinigunComponent_IsOverheated::ReturnValue' has a wrong offset!");

// Function G01.GzMissionAction_FailOnObjectiveConsumption.OnOwningObjectiveStateChanged
// 0x0010 (0x0010 - 0x0000)
struct GzMissionAction_FailOnObjectiveConsumption_OnOwningObjectiveStateChanged final
{
public:
	class UMissionObjective*                      Objective;                                         // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EMissionObjectiveState                        OldState;                                          // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EMissionObjectiveState                        NewState;                                          // 0x0009(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_339F[0x6];                                     // 0x000A(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GzMissionAction_FailOnObjectiveConsumption_OnOwningObjectiveStateChanged) == 0x000008, "Wrong alignment on GzMissionAction_FailOnObjectiveConsumption_OnOwningObjectiveStateChanged");
static_assert(sizeof(GzMissionAction_FailOnObjectiveConsumption_OnOwningObjectiveStateChanged) == 0x000010, "Wrong size on GzMissionAction_FailOnObjectiveConsumption_OnOwningObjectiveStateChanged");
static_assert(offsetof(GzMissionAction_FailOnObjectiveConsumption_OnOwningObjectiveStateChanged, Objective) == 0x000000, "Member 'GzMissionAction_FailOnObjectiveConsumption_OnOwningObjectiveStateChanged::Objective' has a wrong offset!");
static_assert(offsetof(GzMissionAction_FailOnObjectiveConsumption_OnOwningObjectiveStateChanged, OldState) == 0x000008, "Member 'GzMissionAction_FailOnObjectiveConsumption_OnOwningObjectiveStateChanged::OldState' has a wrong offset!");
static_assert(offsetof(GzMissionAction_FailOnObjectiveConsumption_OnOwningObjectiveStateChanged, NewState) == 0x000009, "Member 'GzMissionAction_FailOnObjectiveConsumption_OnOwningObjectiveStateChanged::NewState' has a wrong offset!");

// Function G01.GzMissionAction_FailOnObjectiveConsumption.OnStageChanged
// 0x0004 (0x0004 - 0x0000)
struct GzMissionAction_FailOnObjectiveConsumption_OnStageChanged final
{
public:
	int32                                         StageIndex;                                        // 0x0000(0x0004)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzMissionAction_FailOnObjectiveConsumption_OnStageChanged) == 0x000004, "Wrong alignment on GzMissionAction_FailOnObjectiveConsumption_OnStageChanged");
static_assert(sizeof(GzMissionAction_FailOnObjectiveConsumption_OnStageChanged) == 0x000004, "Wrong size on GzMissionAction_FailOnObjectiveConsumption_OnStageChanged");
static_assert(offsetof(GzMissionAction_FailOnObjectiveConsumption_OnStageChanged, StageIndex) == 0x000000, "Member 'GzMissionAction_FailOnObjectiveConsumption_OnStageChanged::StageIndex' has a wrong offset!");

// Function G01.GzMissionBaseMessage.SetMissionData
// 0x0008 (0x0008 - 0x0000)
struct GzMissionBaseMessage_SetMissionData final
{
public:
	class UGzMissionData*                         InMissionData;                                     // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzMissionBaseMessage_SetMissionData) == 0x000008, "Wrong alignment on GzMissionBaseMessage_SetMissionData");
static_assert(sizeof(GzMissionBaseMessage_SetMissionData) == 0x000008, "Wrong size on GzMissionBaseMessage_SetMissionData");
static_assert(offsetof(GzMissionBaseMessage_SetMissionData, InMissionData) == 0x000000, "Member 'GzMissionBaseMessage_SetMissionData::InMissionData' has a wrong offset!");

// Function G01.GzMissionBaseMessage.GetMissionData
// 0x0008 (0x0008 - 0x0000)
struct GzMissionBaseMessage_GetMissionData final
{
public:
	const class UGzMissionData*                   ReturnValue;                                       // 0x0000(0x0008)(ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzMissionBaseMessage_GetMissionData) == 0x000008, "Wrong alignment on GzMissionBaseMessage_GetMissionData");
static_assert(sizeof(GzMissionBaseMessage_GetMissionData) == 0x000008, "Wrong size on GzMissionBaseMessage_GetMissionData");
static_assert(offsetof(GzMissionBaseMessage_GetMissionData, ReturnValue) == 0x000000, "Member 'GzMissionBaseMessage_GetMissionData::ReturnValue' has a wrong offset!");

// Function G01.GzMissionBlueprintFunctionLibrary.GenerateMissionUI
// 0x0060 (0x0060 - 0x0000)
struct GzMissionBlueprintFunctionLibrary_GenerateMissionUI final
{
public:
	class AGzAdvancedMission*                     Mission;                                           // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGzUIBuilderParams                     Params_0;                                          // 0x0008(0x0050)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	class UGzMTW_Base*                            ReturnValue;                                       // 0x0058(0x0008)(ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzMissionBlueprintFunctionLibrary_GenerateMissionUI) == 0x000008, "Wrong alignment on GzMissionBlueprintFunctionLibrary_GenerateMissionUI");
static_assert(sizeof(GzMissionBlueprintFunctionLibrary_GenerateMissionUI) == 0x000060, "Wrong size on GzMissionBlueprintFunctionLibrary_GenerateMissionUI");
static_assert(offsetof(GzMissionBlueprintFunctionLibrary_GenerateMissionUI, Mission) == 0x000000, "Member 'GzMissionBlueprintFunctionLibrary_GenerateMissionUI::Mission' has a wrong offset!");
static_assert(offsetof(GzMissionBlueprintFunctionLibrary_GenerateMissionUI, Params_0) == 0x000008, "Member 'GzMissionBlueprintFunctionLibrary_GenerateMissionUI::Params_0' has a wrong offset!");
static_assert(offsetof(GzMissionBlueprintFunctionLibrary_GenerateMissionUI, ReturnValue) == 0x000058, "Member 'GzMissionBlueprintFunctionLibrary_GenerateMissionUI::ReturnValue' has a wrong offset!");

// Function G01.GzMissionBlueprintFunctionLibrary.GetAllPlayerMissionsOfClass
// 0x0020 (0x0020 - 0x0000)
struct GzMissionBlueprintFunctionLibrary_GetAllPlayerMissionsOfClass final
{
public:
	const class UObject*                          WorldContextObject;                                // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class AGzAdvancedMission>         ClassType;                                         // 0x0008(0x0008)(Parm, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class AGzAdvancedMission*>             Missions;                                          // 0x0010(0x0010)(Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzMissionBlueprintFunctionLibrary_GetAllPlayerMissionsOfClass) == 0x000008, "Wrong alignment on GzMissionBlueprintFunctionLibrary_GetAllPlayerMissionsOfClass");
static_assert(sizeof(GzMissionBlueprintFunctionLibrary_GetAllPlayerMissionsOfClass) == 0x000020, "Wrong size on GzMissionBlueprintFunctionLibrary_GetAllPlayerMissionsOfClass");
static_assert(offsetof(GzMissionBlueprintFunctionLibrary_GetAllPlayerMissionsOfClass, WorldContextObject) == 0x000000, "Member 'GzMissionBlueprintFunctionLibrary_GetAllPlayerMissionsOfClass::WorldContextObject' has a wrong offset!");
static_assert(offsetof(GzMissionBlueprintFunctionLibrary_GetAllPlayerMissionsOfClass, ClassType) == 0x000008, "Member 'GzMissionBlueprintFunctionLibrary_GetAllPlayerMissionsOfClass::ClassType' has a wrong offset!");
static_assert(offsetof(GzMissionBlueprintFunctionLibrary_GetAllPlayerMissionsOfClass, Missions) == 0x000010, "Member 'GzMissionBlueprintFunctionLibrary_GetAllPlayerMissionsOfClass::Missions' has a wrong offset!");

// Function G01.GzMissionCheatExtension.DumpMissionStateByMissionId
// 0x0010 (0x0010 - 0x0000)
struct GzMissionCheatExtension_DumpMissionStateByMissionId final
{
public:
	class FString                                 MissionId;                                         // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzMissionCheatExtension_DumpMissionStateByMissionId) == 0x000008, "Wrong alignment on GzMissionCheatExtension_DumpMissionStateByMissionId");
static_assert(sizeof(GzMissionCheatExtension_DumpMissionStateByMissionId) == 0x000010, "Wrong size on GzMissionCheatExtension_DumpMissionStateByMissionId");
static_assert(offsetof(GzMissionCheatExtension_DumpMissionStateByMissionId, MissionId) == 0x000000, "Member 'GzMissionCheatExtension_DumpMissionStateByMissionId::MissionId' has a wrong offset!");

// Function G01.GzMissionCheatExtension.DumpMissionStateByRuntimeId
// 0x0004 (0x0004 - 0x0000)
struct GzMissionCheatExtension_DumpMissionStateByRuntimeId final
{
public:
	int32                                         RuntimeId;                                         // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzMissionCheatExtension_DumpMissionStateByRuntimeId) == 0x000004, "Wrong alignment on GzMissionCheatExtension_DumpMissionStateByRuntimeId");
static_assert(sizeof(GzMissionCheatExtension_DumpMissionStateByRuntimeId) == 0x000004, "Wrong size on GzMissionCheatExtension_DumpMissionStateByRuntimeId");
static_assert(offsetof(GzMissionCheatExtension_DumpMissionStateByRuntimeId, RuntimeId) == 0x000000, "Member 'GzMissionCheatExtension_DumpMissionStateByRuntimeId::RuntimeId' has a wrong offset!");

// Function G01.GzMissionCheatExtension.StartMissionForPlayer
// 0x0010 (0x0010 - 0x0000)
struct GzMissionCheatExtension_StartMissionForPlayer final
{
public:
	class FString                                 MissionId;                                         // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzMissionCheatExtension_StartMissionForPlayer) == 0x000008, "Wrong alignment on GzMissionCheatExtension_StartMissionForPlayer");
static_assert(sizeof(GzMissionCheatExtension_StartMissionForPlayer) == 0x000010, "Wrong size on GzMissionCheatExtension_StartMissionForPlayer");
static_assert(offsetof(GzMissionCheatExtension_StartMissionForPlayer, MissionId) == 0x000000, "Member 'GzMissionCheatExtension_StartMissionForPlayer::MissionId' has a wrong offset!");

// Function G01.GzMissionCondition_IsPlayerInLocation.OnActorEndOverlap
// 0x0010 (0x0010 - 0x0000)
struct GzMissionCondition_IsPlayerInLocation_OnActorEndOverlap final
{
public:
	class AActor*                                 OverlappedActor;                                   // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 OtherActor;                                        // 0x0008(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzMissionCondition_IsPlayerInLocation_OnActorEndOverlap) == 0x000008, "Wrong alignment on GzMissionCondition_IsPlayerInLocation_OnActorEndOverlap");
static_assert(sizeof(GzMissionCondition_IsPlayerInLocation_OnActorEndOverlap) == 0x000010, "Wrong size on GzMissionCondition_IsPlayerInLocation_OnActorEndOverlap");
static_assert(offsetof(GzMissionCondition_IsPlayerInLocation_OnActorEndOverlap, OverlappedActor) == 0x000000, "Member 'GzMissionCondition_IsPlayerInLocation_OnActorEndOverlap::OverlappedActor' has a wrong offset!");
static_assert(offsetof(GzMissionCondition_IsPlayerInLocation_OnActorEndOverlap, OtherActor) == 0x000008, "Member 'GzMissionCondition_IsPlayerInLocation_OnActorEndOverlap::OtherActor' has a wrong offset!");

// Function G01.GzMissionCondition_IsPlayerInLocation.OnActorOverlap
// 0x0010 (0x0010 - 0x0000)
struct GzMissionCondition_IsPlayerInLocation_OnActorOverlap final
{
public:
	class AActor*                                 OverlappedActor;                                   // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 OtherActor;                                        // 0x0008(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzMissionCondition_IsPlayerInLocation_OnActorOverlap) == 0x000008, "Wrong alignment on GzMissionCondition_IsPlayerInLocation_OnActorOverlap");
static_assert(sizeof(GzMissionCondition_IsPlayerInLocation_OnActorOverlap) == 0x000010, "Wrong size on GzMissionCondition_IsPlayerInLocation_OnActorOverlap");
static_assert(offsetof(GzMissionCondition_IsPlayerInLocation_OnActorOverlap, OverlappedActor) == 0x000000, "Member 'GzMissionCondition_IsPlayerInLocation_OnActorOverlap::OverlappedActor' has a wrong offset!");
static_assert(offsetof(GzMissionCondition_IsPlayerInLocation_OnActorOverlap, OtherActor) == 0x000008, "Member 'GzMissionCondition_IsPlayerInLocation_OnActorOverlap::OtherActor' has a wrong offset!");

// Function G01.GzMissionCreator.BookTarget
// 0x0008 (0x0008 - 0x0000)
struct GzMissionCreator_BookTarget final
{
public:
	class UMissionResourceComponent*              MissionResourceComponent;                          // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzMissionCreator_BookTarget) == 0x000008, "Wrong alignment on GzMissionCreator_BookTarget");
static_assert(sizeof(GzMissionCreator_BookTarget) == 0x000008, "Wrong size on GzMissionCreator_BookTarget");
static_assert(offsetof(GzMissionCreator_BookTarget, MissionResourceComponent) == 0x000000, "Member 'GzMissionCreator_BookTarget::MissionResourceComponent' has a wrong offset!");

// Function G01.GzMissionCreator.CreateMission
// 0x0020 (0x0020 - 0x0000)
struct GzMissionCreator_CreateMission final
{
public:
	class APlayerState*                           InInstigator;                                      // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UGzMissionData*                         InMissionData;                                     // 0x0008(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 InMissionStarterActor;                             // 0x0010(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0018(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_33A5[0x7];                                     // 0x0019(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GzMissionCreator_CreateMission) == 0x000008, "Wrong alignment on GzMissionCreator_CreateMission");
static_assert(sizeof(GzMissionCreator_CreateMission) == 0x000020, "Wrong size on GzMissionCreator_CreateMission");
static_assert(offsetof(GzMissionCreator_CreateMission, InInstigator) == 0x000000, "Member 'GzMissionCreator_CreateMission::InInstigator' has a wrong offset!");
static_assert(offsetof(GzMissionCreator_CreateMission, InMissionData) == 0x000008, "Member 'GzMissionCreator_CreateMission::InMissionData' has a wrong offset!");
static_assert(offsetof(GzMissionCreator_CreateMission, InMissionStarterActor) == 0x000010, "Member 'GzMissionCreator_CreateMission::InMissionStarterActor' has a wrong offset!");
static_assert(offsetof(GzMissionCreator_CreateMission, ReturnValue) == 0x000018, "Member 'GzMissionCreator_CreateMission::ReturnValue' has a wrong offset!");

// Function G01.GzMissionCreator.GatherMissionResources
// 0x0018 (0x0018 - 0x0000)
struct GzMissionCreator_GatherMissionResources final
{
public:
	class UGzMissionData*                         InMissionData;                                     // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 InMissionStarterActor;                             // 0x0008(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0010(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_33A6[0x7];                                     // 0x0011(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GzMissionCreator_GatherMissionResources) == 0x000008, "Wrong alignment on GzMissionCreator_GatherMissionResources");
static_assert(sizeof(GzMissionCreator_GatherMissionResources) == 0x000018, "Wrong size on GzMissionCreator_GatherMissionResources");
static_assert(offsetof(GzMissionCreator_GatherMissionResources, InMissionData) == 0x000000, "Member 'GzMissionCreator_GatherMissionResources::InMissionData' has a wrong offset!");
static_assert(offsetof(GzMissionCreator_GatherMissionResources, InMissionStarterActor) == 0x000008, "Member 'GzMissionCreator_GatherMissionResources::InMissionStarterActor' has a wrong offset!");
static_assert(offsetof(GzMissionCreator_GatherMissionResources, ReturnValue) == 0x000010, "Member 'GzMissionCreator_GatherMissionResources::ReturnValue' has a wrong offset!");

// Function G01.GzMissionCreator.OnBookedTargetDestroyed
// 0x0010 (0x0010 - 0x0000)
struct GzMissionCreator_OnBookedTargetDestroyed final
{
public:
	class UMissionResourceComponent*              Resource;                                          // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Duration;                                          // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_33A7[0x4];                                     // 0x000C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GzMissionCreator_OnBookedTargetDestroyed) == 0x000008, "Wrong alignment on GzMissionCreator_OnBookedTargetDestroyed");
static_assert(sizeof(GzMissionCreator_OnBookedTargetDestroyed) == 0x000010, "Wrong size on GzMissionCreator_OnBookedTargetDestroyed");
static_assert(offsetof(GzMissionCreator_OnBookedTargetDestroyed, Resource) == 0x000000, "Member 'GzMissionCreator_OnBookedTargetDestroyed::Resource' has a wrong offset!");
static_assert(offsetof(GzMissionCreator_OnBookedTargetDestroyed, Duration) == 0x000008, "Member 'GzMissionCreator_OnBookedTargetDestroyed::Duration' has a wrong offset!");

// Function G01.GzMissionCreator.OnBookedTargetReserved
// 0x0010 (0x0010 - 0x0000)
struct GzMissionCreator_OnBookedTargetReserved final
{
public:
	class UMissionResourceComponent*              Resource;                                          // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UObject*                                ReservedBy;                                        // 0x0008(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzMissionCreator_OnBookedTargetReserved) == 0x000008, "Wrong alignment on GzMissionCreator_OnBookedTargetReserved");
static_assert(sizeof(GzMissionCreator_OnBookedTargetReserved) == 0x000010, "Wrong size on GzMissionCreator_OnBookedTargetReserved");
static_assert(offsetof(GzMissionCreator_OnBookedTargetReserved, Resource) == 0x000000, "Member 'GzMissionCreator_OnBookedTargetReserved::Resource' has a wrong offset!");
static_assert(offsetof(GzMissionCreator_OnBookedTargetReserved, ReservedBy) == 0x000008, "Member 'GzMissionCreator_OnBookedTargetReserved::ReservedBy' has a wrong offset!");

// Function G01.GzMissionCreator.OnStageChanged
// 0x0004 (0x0004 - 0x0000)
struct GzMissionCreator_OnStageChanged final
{
public:
	int32                                         StageIndex;                                        // 0x0000(0x0004)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzMissionCreator_OnStageChanged) == 0x000004, "Wrong alignment on GzMissionCreator_OnStageChanged");
static_assert(sizeof(GzMissionCreator_OnStageChanged) == 0x000004, "Wrong size on GzMissionCreator_OnStageChanged");
static_assert(offsetof(GzMissionCreator_OnStageChanged, StageIndex) == 0x000000, "Member 'GzMissionCreator_OnStageChanged::StageIndex' has a wrong offset!");

// Function G01.GzMissionCreator.GetMissionData
// 0x0008 (0x0008 - 0x0000)
struct GzMissionCreator_GetMissionData final
{
public:
	class UGzMissionData*                         ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzMissionCreator_GetMissionData) == 0x000008, "Wrong alignment on GzMissionCreator_GetMissionData");
static_assert(sizeof(GzMissionCreator_GetMissionData) == 0x000008, "Wrong size on GzMissionCreator_GetMissionData");
static_assert(offsetof(GzMissionCreator_GetMissionData, ReturnValue) == 0x000000, "Member 'GzMissionCreator_GetMissionData::ReturnValue' has a wrong offset!");

// Function G01.GzMissionCreator.IsCulledByStageCount
// 0x0001 (0x0001 - 0x0000)
struct GzMissionCreator_IsCulledByStageCount final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzMissionCreator_IsCulledByStageCount) == 0x000001, "Wrong alignment on GzMissionCreator_IsCulledByStageCount");
static_assert(sizeof(GzMissionCreator_IsCulledByStageCount) == 0x000001, "Wrong size on GzMissionCreator_IsCulledByStageCount");
static_assert(offsetof(GzMissionCreator_IsCulledByStageCount, ReturnValue) == 0x000000, "Member 'GzMissionCreator_IsCulledByStageCount::ReturnValue' has a wrong offset!");

// Function G01.GzMissionEntryWidget.NotifyMissionStateChanged
// 0x0018 (0x0018 - 0x0000)
struct GzMissionEntryWidget_NotifyMissionStateChanged final
{
public:
	struct FGzMissionState                        OldState;                                          // 0x0000(0x000C)(Parm, NoDestructor, NativeAccessSpecifierPublic)
	struct FGzMissionState                        MissionState;                                      // 0x000C(0x000C)(Parm, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzMissionEntryWidget_NotifyMissionStateChanged) == 0x000004, "Wrong alignment on GzMissionEntryWidget_NotifyMissionStateChanged");
static_assert(sizeof(GzMissionEntryWidget_NotifyMissionStateChanged) == 0x000018, "Wrong size on GzMissionEntryWidget_NotifyMissionStateChanged");
static_assert(offsetof(GzMissionEntryWidget_NotifyMissionStateChanged, OldState) == 0x000000, "Member 'GzMissionEntryWidget_NotifyMissionStateChanged::OldState' has a wrong offset!");
static_assert(offsetof(GzMissionEntryWidget_NotifyMissionStateChanged, MissionState) == 0x00000C, "Member 'GzMissionEntryWidget_NotifyMissionStateChanged::MissionState' has a wrong offset!");

// Function G01.GzMissionEntryWidget.OnMissionSet
// 0x0008 (0x0008 - 0x0000)
struct GzMissionEntryWidget_OnMissionSet final
{
public:
	class AGzMission*                             InMission;                                         // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzMissionEntryWidget_OnMissionSet) == 0x000008, "Wrong alignment on GzMissionEntryWidget_OnMissionSet");
static_assert(sizeof(GzMissionEntryWidget_OnMissionSet) == 0x000008, "Wrong size on GzMissionEntryWidget_OnMissionSet");
static_assert(offsetof(GzMissionEntryWidget_OnMissionSet, InMission) == 0x000000, "Member 'GzMissionEntryWidget_OnMissionSet::InMission' has a wrong offset!");

// Function G01.GzMissionEntryWidget.OnMissionStateChanged
// 0x0020 (0x0020 - 0x0000)
struct GzMissionEntryWidget_OnMissionStateChanged final
{
public:
	class AGzMission*                             InMission;                                         // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGzMissionState                        OldState;                                          // 0x0008(0x000C)(Parm, NoDestructor, NativeAccessSpecifierPublic)
	struct FGzMissionState                        MissionState;                                      // 0x0014(0x000C)(Parm, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzMissionEntryWidget_OnMissionStateChanged) == 0x000008, "Wrong alignment on GzMissionEntryWidget_OnMissionStateChanged");
static_assert(sizeof(GzMissionEntryWidget_OnMissionStateChanged) == 0x000020, "Wrong size on GzMissionEntryWidget_OnMissionStateChanged");
static_assert(offsetof(GzMissionEntryWidget_OnMissionStateChanged, InMission) == 0x000000, "Member 'GzMissionEntryWidget_OnMissionStateChanged::InMission' has a wrong offset!");
static_assert(offsetof(GzMissionEntryWidget_OnMissionStateChanged, OldState) == 0x000008, "Member 'GzMissionEntryWidget_OnMissionStateChanged::OldState' has a wrong offset!");
static_assert(offsetof(GzMissionEntryWidget_OnMissionStateChanged, MissionState) == 0x000014, "Member 'GzMissionEntryWidget_OnMissionStateChanged::MissionState' has a wrong offset!");

// Function G01.GzMissionEntryWidget.OnMissionStateChanged_BP
// 0x0020 (0x0020 - 0x0000)
struct GzMissionEntryWidget_OnMissionStateChanged_BP final
{
public:
	class AGzMission*                             InMission;                                         // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGzMissionState                        OldState;                                          // 0x0008(0x000C)(Parm, NoDestructor, NativeAccessSpecifierPublic)
	struct FGzMissionState                        MissionState;                                      // 0x0014(0x000C)(Parm, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzMissionEntryWidget_OnMissionStateChanged_BP) == 0x000008, "Wrong alignment on GzMissionEntryWidget_OnMissionStateChanged_BP");
static_assert(sizeof(GzMissionEntryWidget_OnMissionStateChanged_BP) == 0x000020, "Wrong size on GzMissionEntryWidget_OnMissionStateChanged_BP");
static_assert(offsetof(GzMissionEntryWidget_OnMissionStateChanged_BP, InMission) == 0x000000, "Member 'GzMissionEntryWidget_OnMissionStateChanged_BP::InMission' has a wrong offset!");
static_assert(offsetof(GzMissionEntryWidget_OnMissionStateChanged_BP, OldState) == 0x000008, "Member 'GzMissionEntryWidget_OnMissionStateChanged_BP::OldState' has a wrong offset!");
static_assert(offsetof(GzMissionEntryWidget_OnMissionStateChanged_BP, MissionState) == 0x000014, "Member 'GzMissionEntryWidget_OnMissionStateChanged_BP::MissionState' has a wrong offset!");

// Function G01.GzMissionEntryWidget.OnMissionTrackedChanged
// 0x0010 (0x0010 - 0x0000)
struct GzMissionEntryWidget_OnMissionTrackedChanged final
{
public:
	class AGzMission*                             InMission;                                         // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bTracked;                                          // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_33A9[0x7];                                     // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GzMissionEntryWidget_OnMissionTrackedChanged) == 0x000008, "Wrong alignment on GzMissionEntryWidget_OnMissionTrackedChanged");
static_assert(sizeof(GzMissionEntryWidget_OnMissionTrackedChanged) == 0x000010, "Wrong size on GzMissionEntryWidget_OnMissionTrackedChanged");
static_assert(offsetof(GzMissionEntryWidget_OnMissionTrackedChanged, InMission) == 0x000000, "Member 'GzMissionEntryWidget_OnMissionTrackedChanged::InMission' has a wrong offset!");
static_assert(offsetof(GzMissionEntryWidget_OnMissionTrackedChanged, bTracked) == 0x000008, "Member 'GzMissionEntryWidget_OnMissionTrackedChanged::bTracked' has a wrong offset!");

// Function G01.GzMissionEntryWidget.OnMissionTrackedStateChanged_BP
// 0x0010 (0x0010 - 0x0000)
struct GzMissionEntryWidget_OnMissionTrackedStateChanged_BP final
{
public:
	class AGzMission*                             InMission;                                         // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bTracked;                                          // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_33AA[0x7];                                     // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GzMissionEntryWidget_OnMissionTrackedStateChanged_BP) == 0x000008, "Wrong alignment on GzMissionEntryWidget_OnMissionTrackedStateChanged_BP");
static_assert(sizeof(GzMissionEntryWidget_OnMissionTrackedStateChanged_BP) == 0x000010, "Wrong size on GzMissionEntryWidget_OnMissionTrackedStateChanged_BP");
static_assert(offsetof(GzMissionEntryWidget_OnMissionTrackedStateChanged_BP, InMission) == 0x000000, "Member 'GzMissionEntryWidget_OnMissionTrackedStateChanged_BP::InMission' has a wrong offset!");
static_assert(offsetof(GzMissionEntryWidget_OnMissionTrackedStateChanged_BP, bTracked) == 0x000008, "Member 'GzMissionEntryWidget_OnMissionTrackedStateChanged_BP::bTracked' has a wrong offset!");

// Function G01.GzMissionEntryWidget.OnRootWidgetCreated_BP
// 0x0008 (0x0008 - 0x0000)
struct GzMissionEntryWidget_OnRootWidgetCreated_BP final
{
public:
	class UGzMissionObjectiveWidget*              RootWidget;                                        // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzMissionEntryWidget_OnRootWidgetCreated_BP) == 0x000008, "Wrong alignment on GzMissionEntryWidget_OnRootWidgetCreated_BP");
static_assert(sizeof(GzMissionEntryWidget_OnRootWidgetCreated_BP) == 0x000008, "Wrong size on GzMissionEntryWidget_OnRootWidgetCreated_BP");
static_assert(offsetof(GzMissionEntryWidget_OnRootWidgetCreated_BP, RootWidget) == 0x000000, "Member 'GzMissionEntryWidget_OnRootWidgetCreated_BP::RootWidget' has a wrong offset!");

// Function G01.GzShootingRangeSettings.GetInitTransitionTime
// 0x0004 (0x0004 - 0x0000)
struct GzShootingRangeSettings_GetInitTransitionTime final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzShootingRangeSettings_GetInitTransitionTime) == 0x000004, "Wrong alignment on GzShootingRangeSettings_GetInitTransitionTime");
static_assert(sizeof(GzShootingRangeSettings_GetInitTransitionTime) == 0x000004, "Wrong size on GzShootingRangeSettings_GetInitTransitionTime");
static_assert(offsetof(GzShootingRangeSettings_GetInitTransitionTime, ReturnValue) == 0x000000, "Member 'GzShootingRangeSettings_GetInitTransitionTime::ReturnValue' has a wrong offset!");

// Function G01.GzMissionExtension_Marker.GetTextForTarget
// 0x0038 (0x0038 - 0x0000)
struct GzMissionExtension_Marker_GetTextForTarget final
{
public:
	TSoftObjectPtr<class AActor>                  Target;                                            // 0x0000(0x0028)(ConstParm, Parm, OutParm, ReferenceParm, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   ReturnValue;                                       // 0x0028(0x0010)(Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzMissionExtension_Marker_GetTextForTarget) == 0x000008, "Wrong alignment on GzMissionExtension_Marker_GetTextForTarget");
static_assert(sizeof(GzMissionExtension_Marker_GetTextForTarget) == 0x000038, "Wrong size on GzMissionExtension_Marker_GetTextForTarget");
static_assert(offsetof(GzMissionExtension_Marker_GetTextForTarget, Target) == 0x000000, "Member 'GzMissionExtension_Marker_GetTextForTarget::Target' has a wrong offset!");
static_assert(offsetof(GzMissionExtension_Marker_GetTextForTarget, ReturnValue) == 0x000028, "Member 'GzMissionExtension_Marker_GetTextForTarget::ReturnValue' has a wrong offset!");

// Function G01.GzMissionExtension_Marker.OnMissionTrackedStateChanged
// 0x0010 (0x0010 - 0x0000)
struct GzMissionExtension_Marker_OnMissionTrackedStateChanged final
{
public:
	class AGzMission*                             Mission;                                           // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bTracked;                                          // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_33B1[0x7];                                     // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GzMissionExtension_Marker_OnMissionTrackedStateChanged) == 0x000008, "Wrong alignment on GzMissionExtension_Marker_OnMissionTrackedStateChanged");
static_assert(sizeof(GzMissionExtension_Marker_OnMissionTrackedStateChanged) == 0x000010, "Wrong size on GzMissionExtension_Marker_OnMissionTrackedStateChanged");
static_assert(offsetof(GzMissionExtension_Marker_OnMissionTrackedStateChanged, Mission) == 0x000000, "Member 'GzMissionExtension_Marker_OnMissionTrackedStateChanged::Mission' has a wrong offset!");
static_assert(offsetof(GzMissionExtension_Marker_OnMissionTrackedStateChanged, bTracked) == 0x000008, "Member 'GzMissionExtension_Marker_OnMissionTrackedStateChanged::bTracked' has a wrong offset!");

// Function G01.GzMissionExtension_Marker.ShouldDisplayMarkers
// 0x0001 (0x0001 - 0x0000)
struct GzMissionExtension_Marker_ShouldDisplayMarkers final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzMissionExtension_Marker_ShouldDisplayMarkers) == 0x000001, "Wrong alignment on GzMissionExtension_Marker_ShouldDisplayMarkers");
static_assert(sizeof(GzMissionExtension_Marker_ShouldDisplayMarkers) == 0x000001, "Wrong size on GzMissionExtension_Marker_ShouldDisplayMarkers");
static_assert(offsetof(GzMissionExtension_Marker_ShouldDisplayMarkers, ReturnValue) == 0x000000, "Member 'GzMissionExtension_Marker_ShouldDisplayMarkers::ReturnValue' has a wrong offset!");

// Function G01.GzMissionHelper.BindOnMissionAccepted
// 0x0018 (0x0018 - 0x0000)
struct GzMissionHelper_BindOnMissionAccepted final
{
public:
	const class UObject*                          WorldContextObject;                                // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TDelegate<void(class UGzMissionData* MissionData)> OnMissionAccepted;                                 // 0x0008(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzMissionHelper_BindOnMissionAccepted) == 0x000008, "Wrong alignment on GzMissionHelper_BindOnMissionAccepted");
static_assert(sizeof(GzMissionHelper_BindOnMissionAccepted) == 0x000018, "Wrong size on GzMissionHelper_BindOnMissionAccepted");
static_assert(offsetof(GzMissionHelper_BindOnMissionAccepted, WorldContextObject) == 0x000000, "Member 'GzMissionHelper_BindOnMissionAccepted::WorldContextObject' has a wrong offset!");
static_assert(offsetof(GzMissionHelper_BindOnMissionAccepted, OnMissionAccepted) == 0x000008, "Member 'GzMissionHelper_BindOnMissionAccepted::OnMissionAccepted' has a wrong offset!");

// DelegateFunction G01.GzMissionHelper.GzMissionAccepted__DelegateSignature
// 0x0008 (0x0008 - 0x0000)
struct GzMissionHelper_GzMissionAccepted__DelegateSignature final
{
public:
	const class UGzMissionData*                   MissionData;                                       // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzMissionHelper_GzMissionAccepted__DelegateSignature) == 0x000008, "Wrong alignment on GzMissionHelper_GzMissionAccepted__DelegateSignature");
static_assert(sizeof(GzMissionHelper_GzMissionAccepted__DelegateSignature) == 0x000008, "Wrong size on GzMissionHelper_GzMissionAccepted__DelegateSignature");
static_assert(offsetof(GzMissionHelper_GzMissionAccepted__DelegateSignature, MissionData) == 0x000000, "Member 'GzMissionHelper_GzMissionAccepted__DelegateSignature::MissionData' has a wrong offset!");

// Function G01.GzMissionInteractable.EnableAnimationForDuration
// 0x0004 (0x0004 - 0x0000)
struct GzMissionInteractable_EnableAnimationForDuration final
{
public:
	float                                         Duration;                                          // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzMissionInteractable_EnableAnimationForDuration) == 0x000004, "Wrong alignment on GzMissionInteractable_EnableAnimationForDuration");
static_assert(sizeof(GzMissionInteractable_EnableAnimationForDuration) == 0x000004, "Wrong size on GzMissionInteractable_EnableAnimationForDuration");
static_assert(offsetof(GzMissionInteractable_EnableAnimationForDuration, Duration) == 0x000000, "Member 'GzMissionInteractable_EnableAnimationForDuration::Duration' has a wrong offset!");

// Function G01.GzMissionInteractable.OnDetectionSphereBeginOverlap
// 0x0118 (0x0118 - 0x0000)
struct GzMissionInteractable_OnDetectionSphereBeginOverlap final
{
public:
	class UPrimitiveComponent*                    OverlappedComponent;                               // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 OtherActor;                                        // 0x0008(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UPrimitiveComponent*                    OtherComp;                                         // 0x0010(0x0008)(Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         OtherBodyIndex;                                    // 0x0018(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bFromSweep;                                        // 0x001C(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_33B8[0x3];                                     // 0x001D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FHitResult                             SweepResult;                                       // 0x0020(0x00F8)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzMissionInteractable_OnDetectionSphereBeginOverlap) == 0x000008, "Wrong alignment on GzMissionInteractable_OnDetectionSphereBeginOverlap");
static_assert(sizeof(GzMissionInteractable_OnDetectionSphereBeginOverlap) == 0x000118, "Wrong size on GzMissionInteractable_OnDetectionSphereBeginOverlap");
static_assert(offsetof(GzMissionInteractable_OnDetectionSphereBeginOverlap, OverlappedComponent) == 0x000000, "Member 'GzMissionInteractable_OnDetectionSphereBeginOverlap::OverlappedComponent' has a wrong offset!");
static_assert(offsetof(GzMissionInteractable_OnDetectionSphereBeginOverlap, OtherActor) == 0x000008, "Member 'GzMissionInteractable_OnDetectionSphereBeginOverlap::OtherActor' has a wrong offset!");
static_assert(offsetof(GzMissionInteractable_OnDetectionSphereBeginOverlap, OtherComp) == 0x000010, "Member 'GzMissionInteractable_OnDetectionSphereBeginOverlap::OtherComp' has a wrong offset!");
static_assert(offsetof(GzMissionInteractable_OnDetectionSphereBeginOverlap, OtherBodyIndex) == 0x000018, "Member 'GzMissionInteractable_OnDetectionSphereBeginOverlap::OtherBodyIndex' has a wrong offset!");
static_assert(offsetof(GzMissionInteractable_OnDetectionSphereBeginOverlap, bFromSweep) == 0x00001C, "Member 'GzMissionInteractable_OnDetectionSphereBeginOverlap::bFromSweep' has a wrong offset!");
static_assert(offsetof(GzMissionInteractable_OnDetectionSphereBeginOverlap, SweepResult) == 0x000020, "Member 'GzMissionInteractable_OnDetectionSphereBeginOverlap::SweepResult' has a wrong offset!");

// Function G01.GzMissionInteractable.OnDetectionSphereEndOverlap
// 0x0020 (0x0020 - 0x0000)
struct GzMissionInteractable_OnDetectionSphereEndOverlap final
{
public:
	class UPrimitiveComponent*                    OverlappedComponent;                               // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 OtherActor;                                        // 0x0008(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UPrimitiveComponent*                    OtherComp;                                         // 0x0010(0x0008)(Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         OtherBodyIndex;                                    // 0x0018(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_33B9[0x4];                                     // 0x001C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GzMissionInteractable_OnDetectionSphereEndOverlap) == 0x000008, "Wrong alignment on GzMissionInteractable_OnDetectionSphereEndOverlap");
static_assert(sizeof(GzMissionInteractable_OnDetectionSphereEndOverlap) == 0x000020, "Wrong size on GzMissionInteractable_OnDetectionSphereEndOverlap");
static_assert(offsetof(GzMissionInteractable_OnDetectionSphereEndOverlap, OverlappedComponent) == 0x000000, "Member 'GzMissionInteractable_OnDetectionSphereEndOverlap::OverlappedComponent' has a wrong offset!");
static_assert(offsetof(GzMissionInteractable_OnDetectionSphereEndOverlap, OtherActor) == 0x000008, "Member 'GzMissionInteractable_OnDetectionSphereEndOverlap::OtherActor' has a wrong offset!");
static_assert(offsetof(GzMissionInteractable_OnDetectionSphereEndOverlap, OtherComp) == 0x000010, "Member 'GzMissionInteractable_OnDetectionSphereEndOverlap::OtherComp' has a wrong offset!");
static_assert(offsetof(GzMissionInteractable_OnDetectionSphereEndOverlap, OtherBodyIndex) == 0x000018, "Member 'GzMissionInteractable_OnDetectionSphereEndOverlap::OtherBodyIndex' has a wrong offset!");

// Function G01.GzMissionListWidget.OnMissionEntryAdded
// 0x0008 (0x0008 - 0x0000)
struct GzMissionListWidget_OnMissionEntryAdded final
{
public:
	class UGzMissionEntryWidget*                  MissionEntryWidget;                                // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzMissionListWidget_OnMissionEntryAdded) == 0x000008, "Wrong alignment on GzMissionListWidget_OnMissionEntryAdded");
static_assert(sizeof(GzMissionListWidget_OnMissionEntryAdded) == 0x000008, "Wrong size on GzMissionListWidget_OnMissionEntryAdded");
static_assert(offsetof(GzMissionListWidget_OnMissionEntryAdded, MissionEntryWidget) == 0x000000, "Member 'GzMissionListWidget_OnMissionEntryAdded::MissionEntryWidget' has a wrong offset!");

// Function G01.GzMissionListWidget.OnMissionEntryStateChanged
// 0x0020 (0x0020 - 0x0000)
struct GzMissionListWidget_OnMissionEntryStateChanged final
{
public:
	class AGzMission*                             InMission;                                         // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGzMissionState                        OldState;                                          // 0x0008(0x000C)(Parm, NoDestructor, NativeAccessSpecifierPublic)
	struct FGzMissionState                        MissionState;                                      // 0x0014(0x000C)(Parm, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzMissionListWidget_OnMissionEntryStateChanged) == 0x000008, "Wrong alignment on GzMissionListWidget_OnMissionEntryStateChanged");
static_assert(sizeof(GzMissionListWidget_OnMissionEntryStateChanged) == 0x000020, "Wrong size on GzMissionListWidget_OnMissionEntryStateChanged");
static_assert(offsetof(GzMissionListWidget_OnMissionEntryStateChanged, InMission) == 0x000000, "Member 'GzMissionListWidget_OnMissionEntryStateChanged::InMission' has a wrong offset!");
static_assert(offsetof(GzMissionListWidget_OnMissionEntryStateChanged, OldState) == 0x000008, "Member 'GzMissionListWidget_OnMissionEntryStateChanged::OldState' has a wrong offset!");
static_assert(offsetof(GzMissionListWidget_OnMissionEntryStateChanged, MissionState) == 0x000014, "Member 'GzMissionListWidget_OnMissionEntryStateChanged::MissionState' has a wrong offset!");

// Function G01.GzMissionLogWidget.OnListWidgetAdded_BP
// 0x0008 (0x0008 - 0x0000)
struct GzMissionLogWidget_OnListWidgetAdded_BP final
{
public:
	class UGzMissionListWidget*                   MissionListWidget;                                 // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzMissionLogWidget_OnListWidgetAdded_BP) == 0x000008, "Wrong alignment on GzMissionLogWidget_OnListWidgetAdded_BP");
static_assert(sizeof(GzMissionLogWidget_OnListWidgetAdded_BP) == 0x000008, "Wrong size on GzMissionLogWidget_OnListWidgetAdded_BP");
static_assert(offsetof(GzMissionLogWidget_OnListWidgetAdded_BP, MissionListWidget) == 0x000000, "Member 'GzMissionLogWidget_OnListWidgetAdded_BP::MissionListWidget' has a wrong offset!");

// Function G01.GzMissionLogWidget.OnMissionTrackedStateChanged
// 0x0010 (0x0010 - 0x0000)
struct GzMissionLogWidget_OnMissionTrackedStateChanged final
{
public:
	class AGzMission*                             InMission;                                         // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bTracked;                                          // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_33BC[0x7];                                     // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GzMissionLogWidget_OnMissionTrackedStateChanged) == 0x000008, "Wrong alignment on GzMissionLogWidget_OnMissionTrackedStateChanged");
static_assert(sizeof(GzMissionLogWidget_OnMissionTrackedStateChanged) == 0x000010, "Wrong size on GzMissionLogWidget_OnMissionTrackedStateChanged");
static_assert(offsetof(GzMissionLogWidget_OnMissionTrackedStateChanged, InMission) == 0x000000, "Member 'GzMissionLogWidget_OnMissionTrackedStateChanged::InMission' has a wrong offset!");
static_assert(offsetof(GzMissionLogWidget_OnMissionTrackedStateChanged, bTracked) == 0x000008, "Member 'GzMissionLogWidget_OnMissionTrackedStateChanged::bTracked' has a wrong offset!");

// Function G01.GzMissionLogWidget.OnNewMissionStarted
// 0x0008 (0x0008 - 0x0000)
struct GzMissionLogWidget_OnNewMissionStarted final
{
public:
	class AGzMission*                             NewMission;                                        // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzMissionLogWidget_OnNewMissionStarted) == 0x000008, "Wrong alignment on GzMissionLogWidget_OnNewMissionStarted");
static_assert(sizeof(GzMissionLogWidget_OnNewMissionStarted) == 0x000008, "Wrong size on GzMissionLogWidget_OnNewMissionStarted");
static_assert(offsetof(GzMissionLogWidget_OnNewMissionStarted, NewMission) == 0x000000, "Member 'GzMissionLogWidget_OnNewMissionStarted::NewMission' has a wrong offset!");

// Function G01.GzProgressionSettings.GetProgressionSettings
// 0x0008 (0x0008 - 0x0000)
struct GzProgressionSettings_GetProgressionSettings final
{
public:
	const class UGzProgressionSettings*           ReturnValue;                                       // 0x0000(0x0008)(ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzProgressionSettings_GetProgressionSettings) == 0x000008, "Wrong alignment on GzProgressionSettings_GetProgressionSettings");
static_assert(sizeof(GzProgressionSettings_GetProgressionSettings) == 0x000008, "Wrong size on GzProgressionSettings_GetProgressionSettings");
static_assert(offsetof(GzProgressionSettings_GetProgressionSettings, ReturnValue) == 0x000000, "Member 'GzProgressionSettings_GetProgressionSettings::ReturnValue' has a wrong offset!");

// Function G01.GzMissionManager.OnMissionStateChanged
// 0x0010 (0x0010 - 0x0000)
struct GzMissionManager_OnMissionStateChanged final
{
public:
	class AGzAdvancedMission*                     Mission;                                           // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EGzMissionState                               NewState;                                          // 0x0008(0x0001)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_33C1[0x7];                                     // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GzMissionManager_OnMissionStateChanged) == 0x000008, "Wrong alignment on GzMissionManager_OnMissionStateChanged");
static_assert(sizeof(GzMissionManager_OnMissionStateChanged) == 0x000010, "Wrong size on GzMissionManager_OnMissionStateChanged");
static_assert(offsetof(GzMissionManager_OnMissionStateChanged, Mission) == 0x000000, "Member 'GzMissionManager_OnMissionStateChanged::Mission' has a wrong offset!");
static_assert(offsetof(GzMissionManager_OnMissionStateChanged, NewState) == 0x000008, "Member 'GzMissionManager_OnMissionStateChanged::NewState' has a wrong offset!");

// Function G01.GzMissionManager.SetMissionTrackingEnabled
// 0x0010 (0x0010 - 0x0000)
struct GzMissionManager_SetMissionTrackingEnabled final
{
public:
	class AGzAdvancedMission*                     InMission;                                         // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsEnabled;                                        // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0009(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_33C2[0x6];                                     // 0x000A(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GzMissionManager_SetMissionTrackingEnabled) == 0x000008, "Wrong alignment on GzMissionManager_SetMissionTrackingEnabled");
static_assert(sizeof(GzMissionManager_SetMissionTrackingEnabled) == 0x000010, "Wrong size on GzMissionManager_SetMissionTrackingEnabled");
static_assert(offsetof(GzMissionManager_SetMissionTrackingEnabled, InMission) == 0x000000, "Member 'GzMissionManager_SetMissionTrackingEnabled::InMission' has a wrong offset!");
static_assert(offsetof(GzMissionManager_SetMissionTrackingEnabled, bIsEnabled) == 0x000008, "Member 'GzMissionManager_SetMissionTrackingEnabled::bIsEnabled' has a wrong offset!");
static_assert(offsetof(GzMissionManager_SetMissionTrackingEnabled, ReturnValue) == 0x000009, "Member 'GzMissionManager_SetMissionTrackingEnabled::ReturnValue' has a wrong offset!");

// Function G01.GzMissionManager.IsMissionTracked
// 0x0010 (0x0010 - 0x0000)
struct GzMissionManager_IsMissionTracked final
{
public:
	const class AGzAdvancedMission*               InMission;                                         // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_33C3[0x7];                                     // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GzMissionManager_IsMissionTracked) == 0x000008, "Wrong alignment on GzMissionManager_IsMissionTracked");
static_assert(sizeof(GzMissionManager_IsMissionTracked) == 0x000010, "Wrong size on GzMissionManager_IsMissionTracked");
static_assert(offsetof(GzMissionManager_IsMissionTracked, InMission) == 0x000000, "Member 'GzMissionManager_IsMissionTracked::InMission' has a wrong offset!");
static_assert(offsetof(GzMissionManager_IsMissionTracked, ReturnValue) == 0x000008, "Member 'GzMissionManager_IsMissionTracked::ReturnValue' has a wrong offset!");

// Function G01.GzMissionMarkerActor.SetOwningMarkerExtension
// 0x0008 (0x0008 - 0x0000)
struct GzMissionMarkerActor_SetOwningMarkerExtension final
{
public:
	class UGzMissionExtension_Marker*             InMarkerExtension;                                 // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzMissionMarkerActor_SetOwningMarkerExtension) == 0x000008, "Wrong alignment on GzMissionMarkerActor_SetOwningMarkerExtension");
static_assert(sizeof(GzMissionMarkerActor_SetOwningMarkerExtension) == 0x000008, "Wrong size on GzMissionMarkerActor_SetOwningMarkerExtension");
static_assert(offsetof(GzMissionMarkerActor_SetOwningMarkerExtension, InMarkerExtension) == 0x000000, "Member 'GzMissionMarkerActor_SetOwningMarkerExtension::InMarkerExtension' has a wrong offset!");

// Function G01.GzSequenceObjective.MakeSequenceObjective
// 0x0020 (0x0020 - 0x0000)
struct GzSequenceObjective_MakeSequenceObjective final
{
public:
	class AGzAdvancedMission*                     Mission;                                           // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class UGzObjective*>                   Objectives;                                        // 0x0008(0x0010)(ConstParm, Parm, ZeroConstructor, NativeAccessSpecifierPublic)
	class UGzObjective*                           ReturnValue;                                       // 0x0018(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzSequenceObjective_MakeSequenceObjective) == 0x000008, "Wrong alignment on GzSequenceObjective_MakeSequenceObjective");
static_assert(sizeof(GzSequenceObjective_MakeSequenceObjective) == 0x000020, "Wrong size on GzSequenceObjective_MakeSequenceObjective");
static_assert(offsetof(GzSequenceObjective_MakeSequenceObjective, Mission) == 0x000000, "Member 'GzSequenceObjective_MakeSequenceObjective::Mission' has a wrong offset!");
static_assert(offsetof(GzSequenceObjective_MakeSequenceObjective, Objectives) == 0x000008, "Member 'GzSequenceObjective_MakeSequenceObjective::Objectives' has a wrong offset!");
static_assert(offsetof(GzSequenceObjective_MakeSequenceObjective, ReturnValue) == 0x000018, "Member 'GzSequenceObjective_MakeSequenceObjective::ReturnValue' has a wrong offset!");

// Function G01.GzMissionObjectiveWidget.OnChildObjectiveWidgetCreated_BP
// 0x0008 (0x0008 - 0x0000)
struct GzMissionObjectiveWidget_OnChildObjectiveWidgetCreated_BP final
{
public:
	class UGzMissionObjectiveWidget*              NewWidget;                                         // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzMissionObjectiveWidget_OnChildObjectiveWidgetCreated_BP) == 0x000008, "Wrong alignment on GzMissionObjectiveWidget_OnChildObjectiveWidgetCreated_BP");
static_assert(sizeof(GzMissionObjectiveWidget_OnChildObjectiveWidgetCreated_BP) == 0x000008, "Wrong size on GzMissionObjectiveWidget_OnChildObjectiveWidgetCreated_BP");
static_assert(offsetof(GzMissionObjectiveWidget_OnChildObjectiveWidgetCreated_BP, NewWidget) == 0x000000, "Member 'GzMissionObjectiveWidget_OnChildObjectiveWidgetCreated_BP::NewWidget' has a wrong offset!");

// Function G01.GzMissionObjectiveWidget.OnObjectiveSet_BP
// 0x0008 (0x0008 - 0x0000)
struct GzMissionObjectiveWidget_OnObjectiveSet_BP final
{
public:
	class UMissionObjective*                      InObjective;                                       // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzMissionObjectiveWidget_OnObjectiveSet_BP) == 0x000008, "Wrong alignment on GzMissionObjectiveWidget_OnObjectiveSet_BP");
static_assert(sizeof(GzMissionObjectiveWidget_OnObjectiveSet_BP) == 0x000008, "Wrong size on GzMissionObjectiveWidget_OnObjectiveSet_BP");
static_assert(offsetof(GzMissionObjectiveWidget_OnObjectiveSet_BP, InObjective) == 0x000000, "Member 'GzMissionObjectiveWidget_OnObjectiveSet_BP::InObjective' has a wrong offset!");

// Function G01.GzMissionObjectiveWidget.OnObjectiveStateChanged_BP
// 0x0010 (0x0010 - 0x0000)
struct GzMissionObjectiveWidget_OnObjectiveStateChanged_BP final
{
public:
	class UMissionObjective*                      MissionObjective;                                  // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EMissionObjectiveState                        OldState;                                          // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EMissionObjectiveState                        NewState;                                          // 0x0009(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_33C7[0x6];                                     // 0x000A(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GzMissionObjectiveWidget_OnObjectiveStateChanged_BP) == 0x000008, "Wrong alignment on GzMissionObjectiveWidget_OnObjectiveStateChanged_BP");
static_assert(sizeof(GzMissionObjectiveWidget_OnObjectiveStateChanged_BP) == 0x000010, "Wrong size on GzMissionObjectiveWidget_OnObjectiveStateChanged_BP");
static_assert(offsetof(GzMissionObjectiveWidget_OnObjectiveStateChanged_BP, MissionObjective) == 0x000000, "Member 'GzMissionObjectiveWidget_OnObjectiveStateChanged_BP::MissionObjective' has a wrong offset!");
static_assert(offsetof(GzMissionObjectiveWidget_OnObjectiveStateChanged_BP, OldState) == 0x000008, "Member 'GzMissionObjectiveWidget_OnObjectiveStateChanged_BP::OldState' has a wrong offset!");
static_assert(offsetof(GzMissionObjectiveWidget_OnObjectiveStateChanged_BP, NewState) == 0x000009, "Member 'GzMissionObjectiveWidget_OnObjectiveStateChanged_BP::NewState' has a wrong offset!");

// Function G01.GzMissionObjective_Destroy.SetTarget
// 0x0028 (0x0028 - 0x0000)
struct GzMissionObjective_Destroy_SetTarget final
{
public:
	struct FMissionResourceRef                    InTarget;                                          // 0x0000(0x0028)(Parm, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzMissionObjective_Destroy_SetTarget) == 0x000008, "Wrong alignment on GzMissionObjective_Destroy_SetTarget");
static_assert(sizeof(GzMissionObjective_Destroy_SetTarget) == 0x000028, "Wrong size on GzMissionObjective_Destroy_SetTarget");
static_assert(offsetof(GzMissionObjective_Destroy_SetTarget, InTarget) == 0x000000, "Member 'GzMissionObjective_Destroy_SetTarget::InTarget' has a wrong offset!");

// Function G01.GzMissionObjective_GoToLocation.OnTriggerOverlap
// 0x0010 (0x0010 - 0x0000)
struct GzMissionObjective_GoToLocation_OnTriggerOverlap final
{
public:
	class AActor*                                 OverlappedActor;                                   // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 OtherActor;                                        // 0x0008(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzMissionObjective_GoToLocation_OnTriggerOverlap) == 0x000008, "Wrong alignment on GzMissionObjective_GoToLocation_OnTriggerOverlap");
static_assert(sizeof(GzMissionObjective_GoToLocation_OnTriggerOverlap) == 0x000010, "Wrong size on GzMissionObjective_GoToLocation_OnTriggerOverlap");
static_assert(offsetof(GzMissionObjective_GoToLocation_OnTriggerOverlap, OverlappedActor) == 0x000000, "Member 'GzMissionObjective_GoToLocation_OnTriggerOverlap::OverlappedActor' has a wrong offset!");
static_assert(offsetof(GzMissionObjective_GoToLocation_OnTriggerOverlap, OtherActor) == 0x000008, "Member 'GzMissionObjective_GoToLocation_OnTriggerOverlap::OtherActor' has a wrong offset!");

// Function G01.GzMissionObjective_GoToLocation.SetTarget
// 0x0028 (0x0028 - 0x0000)
struct GzMissionObjective_GoToLocation_SetTarget final
{
public:
	struct FMissionResourceRef                    InTarget;                                          // 0x0000(0x0028)(Parm, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzMissionObjective_GoToLocation_SetTarget) == 0x000008, "Wrong alignment on GzMissionObjective_GoToLocation_SetTarget");
static_assert(sizeof(GzMissionObjective_GoToLocation_SetTarget) == 0x000028, "Wrong size on GzMissionObjective_GoToLocation_SetTarget");
static_assert(offsetof(GzMissionObjective_GoToLocation_SetTarget, InTarget) == 0x000000, "Member 'GzMissionObjective_GoToLocation_SetTarget::InTarget' has a wrong offset!");

// Function G01.GzMissionResourceSubsystem.OnStageChanged
// 0x0004 (0x0004 - 0x0000)
struct GzMissionResourceSubsystem_OnStageChanged final
{
public:
	int32                                         StageIndex;                                        // 0x0000(0x0004)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzMissionResourceSubsystem_OnStageChanged) == 0x000004, "Wrong alignment on GzMissionResourceSubsystem_OnStageChanged");
static_assert(sizeof(GzMissionResourceSubsystem_OnStageChanged) == 0x000004, "Wrong size on GzMissionResourceSubsystem_OnStageChanged");
static_assert(offsetof(GzMissionResourceSubsystem_OnStageChanged, StageIndex) == 0x000000, "Member 'GzMissionResourceSubsystem_OnStageChanged::StageIndex' has a wrong offset!");

// Function G01.GzMissionStarterActor.TryStartMission
// 0x0010 (0x0010 - 0x0000)
struct GzMissionStarterActor_TryStartMission final
{
public:
	class AGzPlayerState*                         PlayerState;                                       // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_33CE[0x7];                                     // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GzMissionStarterActor_TryStartMission) == 0x000008, "Wrong alignment on GzMissionStarterActor_TryStartMission");
static_assert(sizeof(GzMissionStarterActor_TryStartMission) == 0x000010, "Wrong size on GzMissionStarterActor_TryStartMission");
static_assert(offsetof(GzMissionStarterActor_TryStartMission, PlayerState) == 0x000000, "Member 'GzMissionStarterActor_TryStartMission::PlayerState' has a wrong offset!");
static_assert(offsetof(GzMissionStarterActor_TryStartMission, ReturnValue) == 0x000008, "Member 'GzMissionStarterActor_TryStartMission::ReturnValue' has a wrong offset!");

// Function G01.GzMissionStarterActor.GetMissionData
// 0x0008 (0x0008 - 0x0000)
struct GzMissionStarterActor_GetMissionData final
{
public:
	class UGzMissionData*                         ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzMissionStarterActor_GetMissionData) == 0x000008, "Wrong alignment on GzMissionStarterActor_GetMissionData");
static_assert(sizeof(GzMissionStarterActor_GetMissionData) == 0x000008, "Wrong size on GzMissionStarterActor_GetMissionData");
static_assert(offsetof(GzMissionStarterActor_GetMissionData, ReturnValue) == 0x000000, "Member 'GzMissionStarterActor_GetMissionData::ReturnValue' has a wrong offset!");

// Function G01.GzMissionStarterSpawner.OnMissionCreated
// 0x0008 (0x0008 - 0x0000)
struct GzMissionStarterSpawner_OnMissionCreated final
{
public:
	class AGzMissionStarterActor*                 MissionStarterActor;                               // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzMissionStarterSpawner_OnMissionCreated) == 0x000008, "Wrong alignment on GzMissionStarterSpawner_OnMissionCreated");
static_assert(sizeof(GzMissionStarterSpawner_OnMissionCreated) == 0x000008, "Wrong size on GzMissionStarterSpawner_OnMissionCreated");
static_assert(offsetof(GzMissionStarterSpawner_OnMissionCreated, MissionStarterActor) == 0x000000, "Member 'GzMissionStarterSpawner_OnMissionCreated::MissionStarterActor' has a wrong offset!");

// Function G01.GzMissionStarterSpawner.IsAvailable
// 0x0001 (0x0001 - 0x0000)
struct GzMissionStarterSpawner_IsAvailable final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzMissionStarterSpawner_IsAvailable) == 0x000001, "Wrong alignment on GzMissionStarterSpawner_IsAvailable");
static_assert(sizeof(GzMissionStarterSpawner_IsAvailable) == 0x000001, "Wrong size on GzMissionStarterSpawner_IsAvailable");
static_assert(offsetof(GzMissionStarterSpawner_IsAvailable, ReturnValue) == 0x000000, "Member 'GzMissionStarterSpawner_IsAvailable::ReturnValue' has a wrong offset!");

// Function G01.GzMissionStatCollector.OnMissionStateChanged
// 0x0020 (0x0020 - 0x0000)
struct GzMissionStatCollector_OnMissionStateChanged final
{
public:
	class AGzMission*                             Mission;                                           // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGzMissionState                        OldState;                                          // 0x0008(0x000C)(Parm, NoDestructor, NativeAccessSpecifierPublic)
	struct FGzMissionState                        MissionState;                                      // 0x0014(0x000C)(Parm, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzMissionStatCollector_OnMissionStateChanged) == 0x000008, "Wrong alignment on GzMissionStatCollector_OnMissionStateChanged");
static_assert(sizeof(GzMissionStatCollector_OnMissionStateChanged) == 0x000020, "Wrong size on GzMissionStatCollector_OnMissionStateChanged");
static_assert(offsetof(GzMissionStatCollector_OnMissionStateChanged, Mission) == 0x000000, "Member 'GzMissionStatCollector_OnMissionStateChanged::Mission' has a wrong offset!");
static_assert(offsetof(GzMissionStatCollector_OnMissionStateChanged, OldState) == 0x000008, "Member 'GzMissionStatCollector_OnMissionStateChanged::OldState' has a wrong offset!");
static_assert(offsetof(GzMissionStatCollector_OnMissionStateChanged, MissionState) == 0x000014, "Member 'GzMissionStatCollector_OnMissionStateChanged::MissionState' has a wrong offset!");

// Function G01.GzMissionStatics.GetAliveMissionParticipants
// 0x0018 (0x0018 - 0x0000)
struct GzMissionStatics_GetAliveMissionParticipants final
{
public:
	const class AMission*                         Mission;                                           // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class AGzPlayerState*>                 ReturnValue;                                       // 0x0008(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzMissionStatics_GetAliveMissionParticipants) == 0x000008, "Wrong alignment on GzMissionStatics_GetAliveMissionParticipants");
static_assert(sizeof(GzMissionStatics_GetAliveMissionParticipants) == 0x000018, "Wrong size on GzMissionStatics_GetAliveMissionParticipants");
static_assert(offsetof(GzMissionStatics_GetAliveMissionParticipants, Mission) == 0x000000, "Member 'GzMissionStatics_GetAliveMissionParticipants::Mission' has a wrong offset!");
static_assert(offsetof(GzMissionStatics_GetAliveMissionParticipants, ReturnValue) == 0x000008, "Member 'GzMissionStatics_GetAliveMissionParticipants::ReturnValue' has a wrong offset!");

// Function G01.GzMissionStatics.GetAliveMissionParticipantsCount
// 0x0010 (0x0010 - 0x0000)
struct GzMissionStatics_GetAliveMissionParticipantsCount final
{
public:
	const class AMission*                         Mission;                                           // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ReturnValue;                                       // 0x0008(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_33D5[0x4];                                     // 0x000C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GzMissionStatics_GetAliveMissionParticipantsCount) == 0x000008, "Wrong alignment on GzMissionStatics_GetAliveMissionParticipantsCount");
static_assert(sizeof(GzMissionStatics_GetAliveMissionParticipantsCount) == 0x000010, "Wrong size on GzMissionStatics_GetAliveMissionParticipantsCount");
static_assert(offsetof(GzMissionStatics_GetAliveMissionParticipantsCount, Mission) == 0x000000, "Member 'GzMissionStatics_GetAliveMissionParticipantsCount::Mission' has a wrong offset!");
static_assert(offsetof(GzMissionStatics_GetAliveMissionParticipantsCount, ReturnValue) == 0x000008, "Member 'GzMissionStatics_GetAliveMissionParticipantsCount::ReturnValue' has a wrong offset!");

// Function G01.GzMissionStatics.GetAliveParticipantsFromGroup
// 0x0038 (0x0038 - 0x0000)
struct GzMissionStatics_GetAliveParticipantsFromGroup final
{
public:
	const class UObject*                          WorldContextObject;                                // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGzMissionGroup                        MissionGroup;                                      // 0x0008(0x0020)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	TArray<int32>                                 ReturnValue;                                       // 0x0028(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzMissionStatics_GetAliveParticipantsFromGroup) == 0x000008, "Wrong alignment on GzMissionStatics_GetAliveParticipantsFromGroup");
static_assert(sizeof(GzMissionStatics_GetAliveParticipantsFromGroup) == 0x000038, "Wrong size on GzMissionStatics_GetAliveParticipantsFromGroup");
static_assert(offsetof(GzMissionStatics_GetAliveParticipantsFromGroup, WorldContextObject) == 0x000000, "Member 'GzMissionStatics_GetAliveParticipantsFromGroup::WorldContextObject' has a wrong offset!");
static_assert(offsetof(GzMissionStatics_GetAliveParticipantsFromGroup, MissionGroup) == 0x000008, "Member 'GzMissionStatics_GetAliveParticipantsFromGroup::MissionGroup' has a wrong offset!");
static_assert(offsetof(GzMissionStatics_GetAliveParticipantsFromGroup, ReturnValue) == 0x000028, "Member 'GzMissionStatics_GetAliveParticipantsFromGroup::ReturnValue' has a wrong offset!");

// Function G01.GzMissionStatics.GetMissionData
// 0x0018 (0x0018 - 0x0000)
struct GzMissionStatics_GetMissionData final
{
public:
	class FString                                 MissionId;                                         // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UGzMissionData*                         ReturnValue;                                       // 0x0010(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzMissionStatics_GetMissionData) == 0x000008, "Wrong alignment on GzMissionStatics_GetMissionData");
static_assert(sizeof(GzMissionStatics_GetMissionData) == 0x000018, "Wrong size on GzMissionStatics_GetMissionData");
static_assert(offsetof(GzMissionStatics_GetMissionData, MissionId) == 0x000000, "Member 'GzMissionStatics_GetMissionData::MissionId' has a wrong offset!");
static_assert(offsetof(GzMissionStatics_GetMissionData, ReturnValue) == 0x000010, "Member 'GzMissionStatics_GetMissionData::ReturnValue' has a wrong offset!");

// Function G01.GzMissionStatics.Resolve
// 0x0038 (0x0038 - 0x0000)
struct GzMissionStatics_Resolve final
{
public:
	const class UObject*                          WorldContextObject;                                // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FMissionResourceRef                    Ref;                                               // 0x0008(0x0028)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	class AActor*                                 ReturnValue;                                       // 0x0030(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzMissionStatics_Resolve) == 0x000008, "Wrong alignment on GzMissionStatics_Resolve");
static_assert(sizeof(GzMissionStatics_Resolve) == 0x000038, "Wrong size on GzMissionStatics_Resolve");
static_assert(offsetof(GzMissionStatics_Resolve, WorldContextObject) == 0x000000, "Member 'GzMissionStatics_Resolve::WorldContextObject' has a wrong offset!");
static_assert(offsetof(GzMissionStatics_Resolve, Ref) == 0x000008, "Member 'GzMissionStatics_Resolve::Ref' has a wrong offset!");
static_assert(offsetof(GzMissionStatics_Resolve, ReturnValue) == 0x000030, "Member 'GzMissionStatics_Resolve::ReturnValue' has a wrong offset!");

// Function G01.GzMissionSubsystem.CreateMission
// 0x0018 (0x0018 - 0x0000)
struct GzMissionSubsystem_CreateMission final
{
public:
	class AActor*                                 InstigatorContext;                                 // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UGzMissionData*                         MissionData;                                       // 0x0008(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMissionRuntimeContext*                 RuntimeContext;                                    // 0x0010(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzMissionSubsystem_CreateMission) == 0x000008, "Wrong alignment on GzMissionSubsystem_CreateMission");
static_assert(sizeof(GzMissionSubsystem_CreateMission) == 0x000018, "Wrong size on GzMissionSubsystem_CreateMission");
static_assert(offsetof(GzMissionSubsystem_CreateMission, InstigatorContext) == 0x000000, "Member 'GzMissionSubsystem_CreateMission::InstigatorContext' has a wrong offset!");
static_assert(offsetof(GzMissionSubsystem_CreateMission, MissionData) == 0x000008, "Member 'GzMissionSubsystem_CreateMission::MissionData' has a wrong offset!");
static_assert(offsetof(GzMissionSubsystem_CreateMission, RuntimeContext) == 0x000010, "Member 'GzMissionSubsystem_CreateMission::RuntimeContext' has a wrong offset!");

// Function G01.GzMissionSubsystem.CreateSelectedMissionForPlayer
// 0x0008 (0x0008 - 0x0000)
struct GzMissionSubsystem_CreateSelectedMissionForPlayer final
{
public:
	class AGzPlayerState*                         PlayerState;                                       // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzMissionSubsystem_CreateSelectedMissionForPlayer) == 0x000008, "Wrong alignment on GzMissionSubsystem_CreateSelectedMissionForPlayer");
static_assert(sizeof(GzMissionSubsystem_CreateSelectedMissionForPlayer) == 0x000008, "Wrong size on GzMissionSubsystem_CreateSelectedMissionForPlayer");
static_assert(offsetof(GzMissionSubsystem_CreateSelectedMissionForPlayer, PlayerState) == 0x000000, "Member 'GzMissionSubsystem_CreateSelectedMissionForPlayer::PlayerState' has a wrong offset!");

// Function G01.GzMissionSubsystem.GetActiveMissionsByType
// 0x0018 (0x0018 - 0x0000)
struct GzMissionSubsystem_GetActiveMissionsByType final
{
public:
	EGzMissionType                                MissionType;                                       // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_33D8[0x7];                                     // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class AGzMission*>                     ReturnValue;                                       // 0x0008(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzMissionSubsystem_GetActiveMissionsByType) == 0x000008, "Wrong alignment on GzMissionSubsystem_GetActiveMissionsByType");
static_assert(sizeof(GzMissionSubsystem_GetActiveMissionsByType) == 0x000018, "Wrong size on GzMissionSubsystem_GetActiveMissionsByType");
static_assert(offsetof(GzMissionSubsystem_GetActiveMissionsByType, MissionType) == 0x000000, "Member 'GzMissionSubsystem_GetActiveMissionsByType::MissionType' has a wrong offset!");
static_assert(offsetof(GzMissionSubsystem_GetActiveMissionsByType, ReturnValue) == 0x000008, "Member 'GzMissionSubsystem_GetActiveMissionsByType::ReturnValue' has a wrong offset!");

// Function G01.GzMissionSubsystem.InitializeMissionStarters
// 0x0008 (0x0008 - 0x0000)
struct GzMissionSubsystem_InitializeMissionStarters final
{
public:
	class UGzMissionStarterSpawnParams*           InMissionStarterSpawnParams;                       // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzMissionSubsystem_InitializeMissionStarters) == 0x000008, "Wrong alignment on GzMissionSubsystem_InitializeMissionStarters");
static_assert(sizeof(GzMissionSubsystem_InitializeMissionStarters) == 0x000008, "Wrong size on GzMissionSubsystem_InitializeMissionStarters");
static_assert(offsetof(GzMissionSubsystem_InitializeMissionStarters, InMissionStarterSpawnParams) == 0x000000, "Member 'GzMissionSubsystem_InitializeMissionStarters::InMissionStarterSpawnParams' has a wrong offset!");

// Function G01.GzMissionSubsystem.OnLocalMissionStateChanged
// 0x0020 (0x0020 - 0x0000)
struct GzMissionSubsystem_OnLocalMissionStateChanged final
{
public:
	class AGzMission*                             Mission;                                           // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGzMissionState                        OldState;                                          // 0x0008(0x000C)(Parm, NoDestructor, NativeAccessSpecifierPublic)
	struct FGzMissionState                        MissionState;                                      // 0x0014(0x000C)(Parm, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzMissionSubsystem_OnLocalMissionStateChanged) == 0x000008, "Wrong alignment on GzMissionSubsystem_OnLocalMissionStateChanged");
static_assert(sizeof(GzMissionSubsystem_OnLocalMissionStateChanged) == 0x000020, "Wrong size on GzMissionSubsystem_OnLocalMissionStateChanged");
static_assert(offsetof(GzMissionSubsystem_OnLocalMissionStateChanged, Mission) == 0x000000, "Member 'GzMissionSubsystem_OnLocalMissionStateChanged::Mission' has a wrong offset!");
static_assert(offsetof(GzMissionSubsystem_OnLocalMissionStateChanged, OldState) == 0x000008, "Member 'GzMissionSubsystem_OnLocalMissionStateChanged::OldState' has a wrong offset!");
static_assert(offsetof(GzMissionSubsystem_OnLocalMissionStateChanged, MissionState) == 0x000014, "Member 'GzMissionSubsystem_OnLocalMissionStateChanged::MissionState' has a wrong offset!");

// Function G01.GzMissionSubsystem.OnResourcesFiltered
// 0x0004 (0x0004 - 0x0000)
struct GzMissionSubsystem_OnResourcesFiltered final
{
public:
	int32                                         StageIndex;                                        // 0x0000(0x0004)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzMissionSubsystem_OnResourcesFiltered) == 0x000004, "Wrong alignment on GzMissionSubsystem_OnResourcesFiltered");
static_assert(sizeof(GzMissionSubsystem_OnResourcesFiltered) == 0x000004, "Wrong size on GzMissionSubsystem_OnResourcesFiltered");
static_assert(offsetof(GzMissionSubsystem_OnResourcesFiltered, StageIndex) == 0x000000, "Member 'GzMissionSubsystem_OnResourcesFiltered::StageIndex' has a wrong offset!");

// Function G01.GzMissionSubsystem.TrackMission
// 0x0008 (0x0008 - 0x0000)
struct GzMissionSubsystem_TrackMission final
{
public:
	class AGzMission*                             InMission;                                         // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzMissionSubsystem_TrackMission) == 0x000008, "Wrong alignment on GzMissionSubsystem_TrackMission");
static_assert(sizeof(GzMissionSubsystem_TrackMission) == 0x000008, "Wrong size on GzMissionSubsystem_TrackMission");
static_assert(offsetof(GzMissionSubsystem_TrackMission, InMission) == 0x000000, "Member 'GzMissionSubsystem_TrackMission::InMission' has a wrong offset!");

// Function G01.GzMissionSubsystem.UntrackMission
// 0x0008 (0x0008 - 0x0000)
struct GzMissionSubsystem_UntrackMission final
{
public:
	class AGzMission*                             InMission;                                         // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzMissionSubsystem_UntrackMission) == 0x000008, "Wrong alignment on GzMissionSubsystem_UntrackMission");
static_assert(sizeof(GzMissionSubsystem_UntrackMission) == 0x000008, "Wrong size on GzMissionSubsystem_UntrackMission");
static_assert(offsetof(GzMissionSubsystem_UntrackMission, InMission) == 0x000000, "Member 'GzMissionSubsystem_UntrackMission::InMission' has a wrong offset!");

// Function G01.GzMissionSubsystem.GetActiveMissions
// 0x0010 (0x0010 - 0x0000)
struct GzMissionSubsystem_GetActiveMissions final
{
public:
	TArray<class AGzMission*>                     ReturnValue;                                       // 0x0000(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzMissionSubsystem_GetActiveMissions) == 0x000008, "Wrong alignment on GzMissionSubsystem_GetActiveMissions");
static_assert(sizeof(GzMissionSubsystem_GetActiveMissions) == 0x000010, "Wrong size on GzMissionSubsystem_GetActiveMissions");
static_assert(offsetof(GzMissionSubsystem_GetActiveMissions, ReturnValue) == 0x000000, "Member 'GzMissionSubsystem_GetActiveMissions::ReturnValue' has a wrong offset!");

// Function G01.GzMissionSubsystem.GetTrackedMissions
// 0x0010 (0x0010 - 0x0000)
struct GzMissionSubsystem_GetTrackedMissions final
{
public:
	TArray<class AGzMission*>                     ReturnValue;                                       // 0x0000(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzMissionSubsystem_GetTrackedMissions) == 0x000008, "Wrong alignment on GzMissionSubsystem_GetTrackedMissions");
static_assert(sizeof(GzMissionSubsystem_GetTrackedMissions) == 0x000010, "Wrong size on GzMissionSubsystem_GetTrackedMissions");
static_assert(offsetof(GzMissionSubsystem_GetTrackedMissions, ReturnValue) == 0x000000, "Member 'GzMissionSubsystem_GetTrackedMissions::ReturnValue' has a wrong offset!");

// Function G01.GzMissionSubsystem.HasMission
// 0x0018 (0x0018 - 0x0000)
struct GzMissionSubsystem_HasMission final
{
public:
	class AActor*                                 ParticipantContext;                                // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	const class UGzMissionData*                   MissionData;                                       // 0x0008(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0010(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_33D9[0x7];                                     // 0x0011(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GzMissionSubsystem_HasMission) == 0x000008, "Wrong alignment on GzMissionSubsystem_HasMission");
static_assert(sizeof(GzMissionSubsystem_HasMission) == 0x000018, "Wrong size on GzMissionSubsystem_HasMission");
static_assert(offsetof(GzMissionSubsystem_HasMission, ParticipantContext) == 0x000000, "Member 'GzMissionSubsystem_HasMission::ParticipantContext' has a wrong offset!");
static_assert(offsetof(GzMissionSubsystem_HasMission, MissionData) == 0x000008, "Member 'GzMissionSubsystem_HasMission::MissionData' has a wrong offset!");
static_assert(offsetof(GzMissionSubsystem_HasMission, ReturnValue) == 0x000010, "Member 'GzMissionSubsystem_HasMission::ReturnValue' has a wrong offset!");

// Function G01.GzMissionSubsystem.HasMissionOfSameType
// 0x0018 (0x0018 - 0x0000)
struct GzMissionSubsystem_HasMissionOfSameType final
{
public:
	class AActor*                                 ParticipantContext;                                // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	const class UGzMissionData*                   MissionData;                                       // 0x0008(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0010(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_33DA[0x7];                                     // 0x0011(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GzMissionSubsystem_HasMissionOfSameType) == 0x000008, "Wrong alignment on GzMissionSubsystem_HasMissionOfSameType");
static_assert(sizeof(GzMissionSubsystem_HasMissionOfSameType) == 0x000018, "Wrong size on GzMissionSubsystem_HasMissionOfSameType");
static_assert(offsetof(GzMissionSubsystem_HasMissionOfSameType, ParticipantContext) == 0x000000, "Member 'GzMissionSubsystem_HasMissionOfSameType::ParticipantContext' has a wrong offset!");
static_assert(offsetof(GzMissionSubsystem_HasMissionOfSameType, MissionData) == 0x000008, "Member 'GzMissionSubsystem_HasMissionOfSameType::MissionData' has a wrong offset!");
static_assert(offsetof(GzMissionSubsystem_HasMissionOfSameType, ReturnValue) == 0x000010, "Member 'GzMissionSubsystem_HasMissionOfSameType::ReturnValue' has a wrong offset!");

// Function G01.GzMissionSubsystem.IsEligibleForMission
// 0x0018 (0x0018 - 0x0000)
struct GzMissionSubsystem_IsEligibleForMission final
{
public:
	class AActor*                                 ParticipantContext;                                // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	const class UGzMissionData*                   MissionData;                                       // 0x0008(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0010(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_33DB[0x7];                                     // 0x0011(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GzMissionSubsystem_IsEligibleForMission) == 0x000008, "Wrong alignment on GzMissionSubsystem_IsEligibleForMission");
static_assert(sizeof(GzMissionSubsystem_IsEligibleForMission) == 0x000018, "Wrong size on GzMissionSubsystem_IsEligibleForMission");
static_assert(offsetof(GzMissionSubsystem_IsEligibleForMission, ParticipantContext) == 0x000000, "Member 'GzMissionSubsystem_IsEligibleForMission::ParticipantContext' has a wrong offset!");
static_assert(offsetof(GzMissionSubsystem_IsEligibleForMission, MissionData) == 0x000008, "Member 'GzMissionSubsystem_IsEligibleForMission::MissionData' has a wrong offset!");
static_assert(offsetof(GzMissionSubsystem_IsEligibleForMission, ReturnValue) == 0x000010, "Member 'GzMissionSubsystem_IsEligibleForMission::ReturnValue' has a wrong offset!");

// Function G01.GzMissionSubsystem.IsMissionTracked
// 0x0010 (0x0010 - 0x0000)
struct GzMissionSubsystem_IsMissionTracked final
{
public:
	class AGzMission*                             InMission;                                         // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_33DC[0x7];                                     // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GzMissionSubsystem_IsMissionTracked) == 0x000008, "Wrong alignment on GzMissionSubsystem_IsMissionTracked");
static_assert(sizeof(GzMissionSubsystem_IsMissionTracked) == 0x000010, "Wrong size on GzMissionSubsystem_IsMissionTracked");
static_assert(offsetof(GzMissionSubsystem_IsMissionTracked, InMission) == 0x000000, "Member 'GzMissionSubsystem_IsMissionTracked::InMission' has a wrong offset!");
static_assert(offsetof(GzMissionSubsystem_IsMissionTracked, ReturnValue) == 0x000008, "Member 'GzMissionSubsystem_IsMissionTracked::ReturnValue' has a wrong offset!");

// Function G01.GzMissionTargetInterface.GetTargetActor
// 0x0008 (0x0008 - 0x0000)
struct GzMissionTargetInterface_GetTargetActor final
{
public:
	class AActor*                                 ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzMissionTargetInterface_GetTargetActor) == 0x000008, "Wrong alignment on GzMissionTargetInterface_GetTargetActor");
static_assert(sizeof(GzMissionTargetInterface_GetTargetActor) == 0x000008, "Wrong size on GzMissionTargetInterface_GetTargetActor");
static_assert(offsetof(GzMissionTargetInterface_GetTargetActor, ReturnValue) == 0x000000, "Member 'GzMissionTargetInterface_GetTargetActor::ReturnValue' has a wrong offset!");

// Function G01.GzMissionTimeStatCollector.OnMissionStateChanged
// 0x0020 (0x0020 - 0x0000)
struct GzMissionTimeStatCollector_OnMissionStateChanged final
{
public:
	class AGzMission*                             Mission;                                           // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGzMissionState                        OldState;                                          // 0x0008(0x000C)(Parm, NoDestructor, NativeAccessSpecifierPublic)
	struct FGzMissionState                        MissionState;                                      // 0x0014(0x000C)(Parm, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzMissionTimeStatCollector_OnMissionStateChanged) == 0x000008, "Wrong alignment on GzMissionTimeStatCollector_OnMissionStateChanged");
static_assert(sizeof(GzMissionTimeStatCollector_OnMissionStateChanged) == 0x000020, "Wrong size on GzMissionTimeStatCollector_OnMissionStateChanged");
static_assert(offsetof(GzMissionTimeStatCollector_OnMissionStateChanged, Mission) == 0x000000, "Member 'GzMissionTimeStatCollector_OnMissionStateChanged::Mission' has a wrong offset!");
static_assert(offsetof(GzMissionTimeStatCollector_OnMissionStateChanged, OldState) == 0x000008, "Member 'GzMissionTimeStatCollector_OnMissionStateChanged::OldState' has a wrong offset!");
static_assert(offsetof(GzMissionTimeStatCollector_OnMissionStateChanged, MissionState) == 0x000014, "Member 'GzMissionTimeStatCollector_OnMissionStateChanged::MissionState' has a wrong offset!");

// Function G01.GzSoundStatics.GetAllSoundActionTypes
// 0x0010 (0x0010 - 0x0000)
struct GzSoundStatics_GetAllSoundActionTypes final
{
public:
	TArray<class FName>                           ReturnValue;                                       // 0x0000(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzSoundStatics_GetAllSoundActionTypes) == 0x000008, "Wrong alignment on GzSoundStatics_GetAllSoundActionTypes");
static_assert(sizeof(GzSoundStatics_GetAllSoundActionTypes) == 0x000010, "Wrong size on GzSoundStatics_GetAllSoundActionTypes");
static_assert(offsetof(GzSoundStatics_GetAllSoundActionTypes, ReturnValue) == 0x000000, "Member 'GzSoundStatics_GetAllSoundActionTypes::ReturnValue' has a wrong offset!");

// Function G01.GzSoundStatics.GetAllSoundStatesKeys
// 0x0010 (0x0010 - 0x0000)
struct GzSoundStatics_GetAllSoundStatesKeys final
{
public:
	TArray<class FName>                           ReturnValue;                                       // 0x0000(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzSoundStatics_GetAllSoundStatesKeys) == 0x000008, "Wrong alignment on GzSoundStatics_GetAllSoundStatesKeys");
static_assert(sizeof(GzSoundStatics_GetAllSoundStatesKeys) == 0x000010, "Wrong size on GzSoundStatics_GetAllSoundStatesKeys");
static_assert(offsetof(GzSoundStatics_GetAllSoundStatesKeys, ReturnValue) == 0x000000, "Member 'GzSoundStatics_GetAllSoundStatesKeys::ReturnValue' has a wrong offset!");

// Function G01.GzSoundStatics.GetEnvironmentZoneSwitch
// 0x0018 (0x0018 - 0x0000)
struct GzSoundStatics_GetEnvironmentZoneSwitch final
{
public:
	class UGzEnvironmentZoneManagerComponent*     EnvZoneManager;                                    // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUpdateZones;                                      // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_33DD[0x7];                                     // 0x0009(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UAkSwitchValue*                         ReturnValue;                                       // 0x0010(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzSoundStatics_GetEnvironmentZoneSwitch) == 0x000008, "Wrong alignment on GzSoundStatics_GetEnvironmentZoneSwitch");
static_assert(sizeof(GzSoundStatics_GetEnvironmentZoneSwitch) == 0x000018, "Wrong size on GzSoundStatics_GetEnvironmentZoneSwitch");
static_assert(offsetof(GzSoundStatics_GetEnvironmentZoneSwitch, EnvZoneManager) == 0x000000, "Member 'GzSoundStatics_GetEnvironmentZoneSwitch::EnvZoneManager' has a wrong offset!");
static_assert(offsetof(GzSoundStatics_GetEnvironmentZoneSwitch, bUpdateZones) == 0x000008, "Member 'GzSoundStatics_GetEnvironmentZoneSwitch::bUpdateZones' has a wrong offset!");
static_assert(offsetof(GzSoundStatics_GetEnvironmentZoneSwitch, ReturnValue) == 0x000010, "Member 'GzSoundStatics_GetEnvironmentZoneSwitch::ReturnValue' has a wrong offset!");

// Function G01.GzSoundStatics.GetEnvironmentZoneSwitchForActor
// 0x0018 (0x0018 - 0x0000)
struct GzSoundStatics_GetEnvironmentZoneSwitchForActor final
{
public:
	const class AActor*                           Actor;                                             // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUpdateZones;                                      // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_33DE[0x7];                                     // 0x0009(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UAkSwitchValue*                         ReturnValue;                                       // 0x0010(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzSoundStatics_GetEnvironmentZoneSwitchForActor) == 0x000008, "Wrong alignment on GzSoundStatics_GetEnvironmentZoneSwitchForActor");
static_assert(sizeof(GzSoundStatics_GetEnvironmentZoneSwitchForActor) == 0x000018, "Wrong size on GzSoundStatics_GetEnvironmentZoneSwitchForActor");
static_assert(offsetof(GzSoundStatics_GetEnvironmentZoneSwitchForActor, Actor) == 0x000000, "Member 'GzSoundStatics_GetEnvironmentZoneSwitchForActor::Actor' has a wrong offset!");
static_assert(offsetof(GzSoundStatics_GetEnvironmentZoneSwitchForActor, bUpdateZones) == 0x000008, "Member 'GzSoundStatics_GetEnvironmentZoneSwitchForActor::bUpdateZones' has a wrong offset!");
static_assert(offsetof(GzSoundStatics_GetEnvironmentZoneSwitchForActor, ReturnValue) == 0x000010, "Member 'GzSoundStatics_GetEnvironmentZoneSwitchForActor::ReturnValue' has a wrong offset!");

// Function G01.GzSoundStatics.GetEnvironmentZoneSwitchForLocation
// 0x0028 (0x0028 - 0x0000)
struct GzSoundStatics_GetEnvironmentZoneSwitchForLocation final
{
public:
	const class UObject*                          WorldContext;                                      // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Location;                                          // 0x0008(0x0018)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAkSwitchValue*                         ReturnValue;                                       // 0x0020(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzSoundStatics_GetEnvironmentZoneSwitchForLocation) == 0x000008, "Wrong alignment on GzSoundStatics_GetEnvironmentZoneSwitchForLocation");
static_assert(sizeof(GzSoundStatics_GetEnvironmentZoneSwitchForLocation) == 0x000028, "Wrong size on GzSoundStatics_GetEnvironmentZoneSwitchForLocation");
static_assert(offsetof(GzSoundStatics_GetEnvironmentZoneSwitchForLocation, WorldContext) == 0x000000, "Member 'GzSoundStatics_GetEnvironmentZoneSwitchForLocation::WorldContext' has a wrong offset!");
static_assert(offsetof(GzSoundStatics_GetEnvironmentZoneSwitchForLocation, Location) == 0x000008, "Member 'GzSoundStatics_GetEnvironmentZoneSwitchForLocation::Location' has a wrong offset!");
static_assert(offsetof(GzSoundStatics_GetEnvironmentZoneSwitchForLocation, ReturnValue) == 0x000020, "Member 'GzSoundStatics_GetEnvironmentZoneSwitchForLocation::ReturnValue' has a wrong offset!");

// Function G01.GzSoundStatics.GetEventForPhysicalMaterial
// 0x0018 (0x0018 - 0x0000)
struct GzSoundStatics_GetEventForPhysicalMaterial final
{
public:
	class UGzSurfaceTypeEvents*                   SurfaceTypeEvents;                                 // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	const class UPhysicalMaterial*                PhysicalMaterial;                                  // 0x0008(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAkAudioEvent*                          ReturnValue;                                       // 0x0010(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzSoundStatics_GetEventForPhysicalMaterial) == 0x000008, "Wrong alignment on GzSoundStatics_GetEventForPhysicalMaterial");
static_assert(sizeof(GzSoundStatics_GetEventForPhysicalMaterial) == 0x000018, "Wrong size on GzSoundStatics_GetEventForPhysicalMaterial");
static_assert(offsetof(GzSoundStatics_GetEventForPhysicalMaterial, SurfaceTypeEvents) == 0x000000, "Member 'GzSoundStatics_GetEventForPhysicalMaterial::SurfaceTypeEvents' has a wrong offset!");
static_assert(offsetof(GzSoundStatics_GetEventForPhysicalMaterial, PhysicalMaterial) == 0x000008, "Member 'GzSoundStatics_GetEventForPhysicalMaterial::PhysicalMaterial' has a wrong offset!");
static_assert(offsetof(GzSoundStatics_GetEventForPhysicalMaterial, ReturnValue) == 0x000010, "Member 'GzSoundStatics_GetEventForPhysicalMaterial::ReturnValue' has a wrong offset!");

// Function G01.GzSoundStatics.GetLocalAudioController
// 0x0010 (0x0010 - 0x0000)
struct GzSoundStatics_GetLocalAudioController final
{
public:
	const class UObject*                          ContextObject;                                     // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UGzAudioControllerComponent*            ReturnValue;                                       // 0x0008(0x0008)(ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzSoundStatics_GetLocalAudioController) == 0x000008, "Wrong alignment on GzSoundStatics_GetLocalAudioController");
static_assert(sizeof(GzSoundStatics_GetLocalAudioController) == 0x000010, "Wrong size on GzSoundStatics_GetLocalAudioController");
static_assert(offsetof(GzSoundStatics_GetLocalAudioController, ContextObject) == 0x000000, "Member 'GzSoundStatics_GetLocalAudioController::ContextObject' has a wrong offset!");
static_assert(offsetof(GzSoundStatics_GetLocalAudioController, ReturnValue) == 0x000008, "Member 'GzSoundStatics_GetLocalAudioController::ReturnValue' has a wrong offset!");

// Function G01.GzSoundStatics.GetMovementSounds
// 0x0008 (0x0008 - 0x0000)
struct GzSoundStatics_GetMovementSounds final
{
public:
	class UGzLimbStepSoundsData*                  ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzSoundStatics_GetMovementSounds) == 0x000008, "Wrong alignment on GzSoundStatics_GetMovementSounds");
static_assert(sizeof(GzSoundStatics_GetMovementSounds) == 0x000008, "Wrong size on GzSoundStatics_GetMovementSounds");
static_assert(offsetof(GzSoundStatics_GetMovementSounds, ReturnValue) == 0x000000, "Member 'GzSoundStatics_GetMovementSounds::ReturnValue' has a wrong offset!");

// Function G01.GzSoundStatics.GetSoundPlayDelayForLocalPlayer
// 0x0028 (0x0028 - 0x0000)
struct GzSoundStatics_GetSoundPlayDelayForLocalPlayer final
{
public:
	class UObject*                                WorldContextObject;                                // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                SoundLocation;                                     // 0x0008(0x0018)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	double                                        ReturnValue;                                       // 0x0020(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzSoundStatics_GetSoundPlayDelayForLocalPlayer) == 0x000008, "Wrong alignment on GzSoundStatics_GetSoundPlayDelayForLocalPlayer");
static_assert(sizeof(GzSoundStatics_GetSoundPlayDelayForLocalPlayer) == 0x000028, "Wrong size on GzSoundStatics_GetSoundPlayDelayForLocalPlayer");
static_assert(offsetof(GzSoundStatics_GetSoundPlayDelayForLocalPlayer, WorldContextObject) == 0x000000, "Member 'GzSoundStatics_GetSoundPlayDelayForLocalPlayer::WorldContextObject' has a wrong offset!");
static_assert(offsetof(GzSoundStatics_GetSoundPlayDelayForLocalPlayer, SoundLocation) == 0x000008, "Member 'GzSoundStatics_GetSoundPlayDelayForLocalPlayer::SoundLocation' has a wrong offset!");
static_assert(offsetof(GzSoundStatics_GetSoundPlayDelayForLocalPlayer, ReturnValue) == 0x000020, "Member 'GzSoundStatics_GetSoundPlayDelayForLocalPlayer::ReturnValue' has a wrong offset!");

// Function G01.GzSoundStatics.PostActionVoiceLineForTeam
// 0x0018 (0x0018 - 0x0000)
struct GzSoundStatics_PostActionVoiceLineForTeam final
{
public:
	class AGzPlayerState*                         Instigator;                                        // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           Tag;                                               // 0x0008(0x0008)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bStarted;                                          // 0x0010(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_33DF[0x7];                                     // 0x0011(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GzSoundStatics_PostActionVoiceLineForTeam) == 0x000008, "Wrong alignment on GzSoundStatics_PostActionVoiceLineForTeam");
static_assert(sizeof(GzSoundStatics_PostActionVoiceLineForTeam) == 0x000018, "Wrong size on GzSoundStatics_PostActionVoiceLineForTeam");
static_assert(offsetof(GzSoundStatics_PostActionVoiceLineForTeam, Instigator) == 0x000000, "Member 'GzSoundStatics_PostActionVoiceLineForTeam::Instigator' has a wrong offset!");
static_assert(offsetof(GzSoundStatics_PostActionVoiceLineForTeam, Tag) == 0x000008, "Member 'GzSoundStatics_PostActionVoiceLineForTeam::Tag' has a wrong offset!");
static_assert(offsetof(GzSoundStatics_PostActionVoiceLineForTeam, bStarted) == 0x000010, "Member 'GzSoundStatics_PostActionVoiceLineForTeam::bStarted' has a wrong offset!");

// Function G01.GzSoundStatics.PostAkEventWithEnvZoneAtLocation
// 0x0028 (0x0028 - 0x0000)
struct GzSoundStatics_PostAkEventWithEnvZoneAtLocation final
{
public:
	class UAkAudioEvent*                          Event;                                             // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Location;                                          // 0x0008(0x0018)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UObject*                                WorldContext;                                      // 0x0020(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzSoundStatics_PostAkEventWithEnvZoneAtLocation) == 0x000008, "Wrong alignment on GzSoundStatics_PostAkEventWithEnvZoneAtLocation");
static_assert(sizeof(GzSoundStatics_PostAkEventWithEnvZoneAtLocation) == 0x000028, "Wrong size on GzSoundStatics_PostAkEventWithEnvZoneAtLocation");
static_assert(offsetof(GzSoundStatics_PostAkEventWithEnvZoneAtLocation, Event) == 0x000000, "Member 'GzSoundStatics_PostAkEventWithEnvZoneAtLocation::Event' has a wrong offset!");
static_assert(offsetof(GzSoundStatics_PostAkEventWithEnvZoneAtLocation, Location) == 0x000008, "Member 'GzSoundStatics_PostAkEventWithEnvZoneAtLocation::Location' has a wrong offset!");
static_assert(offsetof(GzSoundStatics_PostAkEventWithEnvZoneAtLocation, WorldContext) == 0x000020, "Member 'GzSoundStatics_PostAkEventWithEnvZoneAtLocation::WorldContext' has a wrong offset!");

// Function G01.GzSoundStatics.PostLocalAnnouncement
// 0x0020 (0x0020 - 0x0000)
struct GzSoundStatics_PostLocalAnnouncement final
{
public:
	const class UObject*                          WorldContext;                                      // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           AnnouncerTag;                                      // 0x0008(0x0008)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           VoiceLineTag;                                      // 0x0010(0x0008)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bStarted;                                          // 0x0018(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0019(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_33E0[0x6];                                     // 0x001A(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GzSoundStatics_PostLocalAnnouncement) == 0x000008, "Wrong alignment on GzSoundStatics_PostLocalAnnouncement");
static_assert(sizeof(GzSoundStatics_PostLocalAnnouncement) == 0x000020, "Wrong size on GzSoundStatics_PostLocalAnnouncement");
static_assert(offsetof(GzSoundStatics_PostLocalAnnouncement, WorldContext) == 0x000000, "Member 'GzSoundStatics_PostLocalAnnouncement::WorldContext' has a wrong offset!");
static_assert(offsetof(GzSoundStatics_PostLocalAnnouncement, AnnouncerTag) == 0x000008, "Member 'GzSoundStatics_PostLocalAnnouncement::AnnouncerTag' has a wrong offset!");
static_assert(offsetof(GzSoundStatics_PostLocalAnnouncement, VoiceLineTag) == 0x000010, "Member 'GzSoundStatics_PostLocalAnnouncement::VoiceLineTag' has a wrong offset!");
static_assert(offsetof(GzSoundStatics_PostLocalAnnouncement, bStarted) == 0x000018, "Member 'GzSoundStatics_PostLocalAnnouncement::bStarted' has a wrong offset!");
static_assert(offsetof(GzSoundStatics_PostLocalAnnouncement, ReturnValue) == 0x000019, "Member 'GzSoundStatics_PostLocalAnnouncement::ReturnValue' has a wrong offset!");

// Function G01.GzSoundStatics.PostLocalAnnouncementAndWaitForEnd
// 0x0030 (0x0030 - 0x0000)
struct GzSoundStatics_PostLocalAnnouncementAndWaitForEnd final
{
public:
	const class UObject*                          WorldContext;                                      // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           AnnouncerTag;                                      // 0x0008(0x0008)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           VoiceLineTag;                                      // 0x0010(0x0008)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bStarted;                                          // 0x0018(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_33E1[0x3];                                     // 0x0019(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TDelegate<void()>                             AnnouncementEndDelegate;                           // 0x001C(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x002C(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_33E2[0x3];                                     // 0x002D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GzSoundStatics_PostLocalAnnouncementAndWaitForEnd) == 0x000008, "Wrong alignment on GzSoundStatics_PostLocalAnnouncementAndWaitForEnd");
static_assert(sizeof(GzSoundStatics_PostLocalAnnouncementAndWaitForEnd) == 0x000030, "Wrong size on GzSoundStatics_PostLocalAnnouncementAndWaitForEnd");
static_assert(offsetof(GzSoundStatics_PostLocalAnnouncementAndWaitForEnd, WorldContext) == 0x000000, "Member 'GzSoundStatics_PostLocalAnnouncementAndWaitForEnd::WorldContext' has a wrong offset!");
static_assert(offsetof(GzSoundStatics_PostLocalAnnouncementAndWaitForEnd, AnnouncerTag) == 0x000008, "Member 'GzSoundStatics_PostLocalAnnouncementAndWaitForEnd::AnnouncerTag' has a wrong offset!");
static_assert(offsetof(GzSoundStatics_PostLocalAnnouncementAndWaitForEnd, VoiceLineTag) == 0x000010, "Member 'GzSoundStatics_PostLocalAnnouncementAndWaitForEnd::VoiceLineTag' has a wrong offset!");
static_assert(offsetof(GzSoundStatics_PostLocalAnnouncementAndWaitForEnd, bStarted) == 0x000018, "Member 'GzSoundStatics_PostLocalAnnouncementAndWaitForEnd::bStarted' has a wrong offset!");
static_assert(offsetof(GzSoundStatics_PostLocalAnnouncementAndWaitForEnd, AnnouncementEndDelegate) == 0x00001C, "Member 'GzSoundStatics_PostLocalAnnouncementAndWaitForEnd::AnnouncementEndDelegate' has a wrong offset!");
static_assert(offsetof(GzSoundStatics_PostLocalAnnouncementAndWaitForEnd, ReturnValue) == 0x00002C, "Member 'GzSoundStatics_PostLocalAnnouncementAndWaitForEnd::ReturnValue' has a wrong offset!");

// Function G01.GzSoundStatics.PostLocalAnnouncementByData
// 0x0028 (0x0028 - 0x0000)
struct GzSoundStatics_PostLocalAnnouncementByData final
{
public:
	const class UObject*                          WorldContext;                                      // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           AnnouncerTag;                                      // 0x0008(0x0008)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGzPingVoiceLineData                   Data;                                              // 0x0010(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0020(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_33E3[0x7];                                     // 0x0021(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GzSoundStatics_PostLocalAnnouncementByData) == 0x000008, "Wrong alignment on GzSoundStatics_PostLocalAnnouncementByData");
static_assert(sizeof(GzSoundStatics_PostLocalAnnouncementByData) == 0x000028, "Wrong size on GzSoundStatics_PostLocalAnnouncementByData");
static_assert(offsetof(GzSoundStatics_PostLocalAnnouncementByData, WorldContext) == 0x000000, "Member 'GzSoundStatics_PostLocalAnnouncementByData::WorldContext' has a wrong offset!");
static_assert(offsetof(GzSoundStatics_PostLocalAnnouncementByData, AnnouncerTag) == 0x000008, "Member 'GzSoundStatics_PostLocalAnnouncementByData::AnnouncerTag' has a wrong offset!");
static_assert(offsetof(GzSoundStatics_PostLocalAnnouncementByData, Data) == 0x000010, "Member 'GzSoundStatics_PostLocalAnnouncementByData::Data' has a wrong offset!");
static_assert(offsetof(GzSoundStatics_PostLocalAnnouncementByData, ReturnValue) == 0x000020, "Member 'GzSoundStatics_PostLocalAnnouncementByData::ReturnValue' has a wrong offset!");

// Function G01.GzSoundStatics.PostLocalAnnouncementWithPriority
// 0x0038 (0x0038 - 0x0000)
struct GzSoundStatics_PostLocalAnnouncementWithPriority final
{
public:
	const class UObject*                          WorldContext;                                      // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           AnnouncerTag;                                      // 0x0008(0x0008)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           VoiceLineTag;                                      // 0x0010(0x0008)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bStarted;                                          // 0x0018(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_33E4[0x3];                                     // 0x0019(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         PriorityOverride;                                  // 0x001C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TDelegate<void()>                             AnnouncementEndDelegate;                           // 0x0020(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0030(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_33E5[0x7];                                     // 0x0031(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GzSoundStatics_PostLocalAnnouncementWithPriority) == 0x000008, "Wrong alignment on GzSoundStatics_PostLocalAnnouncementWithPriority");
static_assert(sizeof(GzSoundStatics_PostLocalAnnouncementWithPriority) == 0x000038, "Wrong size on GzSoundStatics_PostLocalAnnouncementWithPriority");
static_assert(offsetof(GzSoundStatics_PostLocalAnnouncementWithPriority, WorldContext) == 0x000000, "Member 'GzSoundStatics_PostLocalAnnouncementWithPriority::WorldContext' has a wrong offset!");
static_assert(offsetof(GzSoundStatics_PostLocalAnnouncementWithPriority, AnnouncerTag) == 0x000008, "Member 'GzSoundStatics_PostLocalAnnouncementWithPriority::AnnouncerTag' has a wrong offset!");
static_assert(offsetof(GzSoundStatics_PostLocalAnnouncementWithPriority, VoiceLineTag) == 0x000010, "Member 'GzSoundStatics_PostLocalAnnouncementWithPriority::VoiceLineTag' has a wrong offset!");
static_assert(offsetof(GzSoundStatics_PostLocalAnnouncementWithPriority, bStarted) == 0x000018, "Member 'GzSoundStatics_PostLocalAnnouncementWithPriority::bStarted' has a wrong offset!");
static_assert(offsetof(GzSoundStatics_PostLocalAnnouncementWithPriority, PriorityOverride) == 0x00001C, "Member 'GzSoundStatics_PostLocalAnnouncementWithPriority::PriorityOverride' has a wrong offset!");
static_assert(offsetof(GzSoundStatics_PostLocalAnnouncementWithPriority, AnnouncementEndDelegate) == 0x000020, "Member 'GzSoundStatics_PostLocalAnnouncementWithPriority::AnnouncementEndDelegate' has a wrong offset!");
static_assert(offsetof(GzSoundStatics_PostLocalAnnouncementWithPriority, ReturnValue) == 0x000030, "Member 'GzSoundStatics_PostLocalAnnouncementWithPriority::ReturnValue' has a wrong offset!");

// Function G01.GzSoundStatics.SetInGameSoundEnabled
// 0x0008 (0x0008 - 0x0000)
struct GzSoundStatics_SetInGameSoundEnabled final
{
public:
	bool                                          bEnable;                                           // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_33E6[0x3];                                     // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         InterpolationTimeMs;                               // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzSoundStatics_SetInGameSoundEnabled) == 0x000004, "Wrong alignment on GzSoundStatics_SetInGameSoundEnabled");
static_assert(sizeof(GzSoundStatics_SetInGameSoundEnabled) == 0x000008, "Wrong size on GzSoundStatics_SetInGameSoundEnabled");
static_assert(offsetof(GzSoundStatics_SetInGameSoundEnabled, bEnable) == 0x000000, "Member 'GzSoundStatics_SetInGameSoundEnabled::bEnable' has a wrong offset!");
static_assert(offsetof(GzSoundStatics_SetInGameSoundEnabled, InterpolationTimeMs) == 0x000004, "Member 'GzSoundStatics_SetInGameSoundEnabled::InterpolationTimeMs' has a wrong offset!");

// Function G01.GzSoundStatics.SetInGameSoundPercent
// 0x0008 (0x0008 - 0x0000)
struct GzSoundStatics_SetInGameSoundPercent final
{
public:
	float                                         Percent;                                           // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InterpolationTimeMs;                               // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzSoundStatics_SetInGameSoundPercent) == 0x000004, "Wrong alignment on GzSoundStatics_SetInGameSoundPercent");
static_assert(sizeof(GzSoundStatics_SetInGameSoundPercent) == 0x000008, "Wrong size on GzSoundStatics_SetInGameSoundPercent");
static_assert(offsetof(GzSoundStatics_SetInGameSoundPercent, Percent) == 0x000000, "Member 'GzSoundStatics_SetInGameSoundPercent::Percent' has a wrong offset!");
static_assert(offsetof(GzSoundStatics_SetInGameSoundPercent, InterpolationTimeMs) == 0x000004, "Member 'GzSoundStatics_SetInGameSoundPercent::InterpolationTimeMs' has a wrong offset!");

// Function G01.GzSoundStatics.SetSoundState
// 0x0010 (0x0010 - 0x0000)
struct GzSoundStatics_SetSoundState final
{
public:
	struct FGzSoundStateKey                       State;                                             // 0x0000(0x0008)(Parm, NoDestructor, NativeAccessSpecifierPublic)
	class AActor*                                 ContextObject;                                     // 0x0008(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzSoundStatics_SetSoundState) == 0x000008, "Wrong alignment on GzSoundStatics_SetSoundState");
static_assert(sizeof(GzSoundStatics_SetSoundState) == 0x000010, "Wrong size on GzSoundStatics_SetSoundState");
static_assert(offsetof(GzSoundStatics_SetSoundState, State) == 0x000000, "Member 'GzSoundStatics_SetSoundState::State' has a wrong offset!");
static_assert(offsetof(GzSoundStatics_SetSoundState, ContextObject) == 0x000008, "Member 'GzSoundStatics_SetSoundState::ContextObject' has a wrong offset!");

// Function G01.GzModularEnvStaticMeshComponent.GetMeshSlotOptions
// 0x0010 (0x0010 - 0x0000)
struct GzModularEnvStaticMeshComponent_GetMeshSlotOptions final
{
public:
	TArray<class FString>                         ReturnValue;                                       // 0x0000(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzModularEnvStaticMeshComponent_GetMeshSlotOptions) == 0x000008, "Wrong alignment on GzModularEnvStaticMeshComponent_GetMeshSlotOptions");
static_assert(sizeof(GzModularEnvStaticMeshComponent_GetMeshSlotOptions) == 0x000010, "Wrong size on GzModularEnvStaticMeshComponent_GetMeshSlotOptions");
static_assert(offsetof(GzModularEnvStaticMeshComponent_GetMeshSlotOptions, ReturnValue) == 0x000000, "Member 'GzModularEnvStaticMeshComponent_GetMeshSlotOptions::ReturnValue' has a wrong offset!");

// Function G01.GzSpectatorPawn.GetSpectatedPawn
// 0x0008 (0x0008 - 0x0000)
struct GzSpectatorPawn_GetSpectatedPawn final
{
public:
	class APawn*                                  ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzSpectatorPawn_GetSpectatedPawn) == 0x000008, "Wrong alignment on GzSpectatorPawn_GetSpectatedPawn");
static_assert(sizeof(GzSpectatorPawn_GetSpectatedPawn) == 0x000008, "Wrong size on GzSpectatorPawn_GetSpectatedPawn");
static_assert(offsetof(GzSpectatorPawn_GetSpectatedPawn, ReturnValue) == 0x000000, "Member 'GzSpectatorPawn_GetSpectatedPawn::ReturnValue' has a wrong offset!");

// Function G01.GzSpectatorPawn.GetSpectatedPlayer
// 0x0008 (0x0008 - 0x0000)
struct GzSpectatorPawn_GetSpectatedPlayer final
{
public:
	class AActor*                                 ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzSpectatorPawn_GetSpectatedPlayer) == 0x000008, "Wrong alignment on GzSpectatorPawn_GetSpectatedPlayer");
static_assert(sizeof(GzSpectatorPawn_GetSpectatedPlayer) == 0x000008, "Wrong size on GzSpectatorPawn_GetSpectatedPlayer");
static_assert(offsetof(GzSpectatorPawn_GetSpectatedPlayer, ReturnValue) == 0x000000, "Member 'GzSpectatorPawn_GetSpectatedPlayer::ReturnValue' has a wrong offset!");

// Function G01.GzMortarLegsComponent.ApplyTabletInput_Horizontal
// 0x0004 (0x0004 - 0x0000)
struct GzMortarLegsComponent_ApplyTabletInput_Horizontal final
{
public:
	float                                         Value;                                             // 0x0000(0x0004)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzMortarLegsComponent_ApplyTabletInput_Horizontal) == 0x000004, "Wrong alignment on GzMortarLegsComponent_ApplyTabletInput_Horizontal");
static_assert(sizeof(GzMortarLegsComponent_ApplyTabletInput_Horizontal) == 0x000004, "Wrong size on GzMortarLegsComponent_ApplyTabletInput_Horizontal");
static_assert(offsetof(GzMortarLegsComponent_ApplyTabletInput_Horizontal, Value) == 0x000000, "Member 'GzMortarLegsComponent_ApplyTabletInput_Horizontal::Value' has a wrong offset!");

// Function G01.GzMortarLegsComponent.ApplyTabletInput_Vertical
// 0x0004 (0x0004 - 0x0000)
struct GzMortarLegsComponent_ApplyTabletInput_Vertical final
{
public:
	float                                         Value;                                             // 0x0000(0x0004)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzMortarLegsComponent_ApplyTabletInput_Vertical) == 0x000004, "Wrong alignment on GzMortarLegsComponent_ApplyTabletInput_Vertical");
static_assert(sizeof(GzMortarLegsComponent_ApplyTabletInput_Vertical) == 0x000004, "Wrong size on GzMortarLegsComponent_ApplyTabletInput_Vertical");
static_assert(offsetof(GzMortarLegsComponent_ApplyTabletInput_Vertical, Value) == 0x000000, "Member 'GzMortarLegsComponent_ApplyTabletInput_Vertical::Value' has a wrong offset!");

// Function G01.GzMortarLegsComponent.OnEventTagAdded
// 0x0008 (0x0008 - 0x0000)
struct GzMortarLegsComponent_OnEventTagAdded final
{
public:
	struct FGameplayTag                           Tag;                                               // 0x0000(0x0008)(Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzMortarLegsComponent_OnEventTagAdded) == 0x000004, "Wrong alignment on GzMortarLegsComponent_OnEventTagAdded");
static_assert(sizeof(GzMortarLegsComponent_OnEventTagAdded) == 0x000008, "Wrong size on GzMortarLegsComponent_OnEventTagAdded");
static_assert(offsetof(GzMortarLegsComponent_OnEventTagAdded, Tag) == 0x000000, "Member 'GzMortarLegsComponent_OnEventTagAdded::Tag' has a wrong offset!");

// Function G01.GzMortarLegsComponent.IsTabletVisible
// 0x0001 (0x0001 - 0x0000)
struct GzMortarLegsComponent_IsTabletVisible final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzMortarLegsComponent_IsTabletVisible) == 0x000001, "Wrong alignment on GzMortarLegsComponent_IsTabletVisible");
static_assert(sizeof(GzMortarLegsComponent_IsTabletVisible) == 0x000001, "Wrong size on GzMortarLegsComponent_IsTabletVisible");
static_assert(offsetof(GzMortarLegsComponent_IsTabletVisible, ReturnValue) == 0x000000, "Member 'GzMortarLegsComponent_IsTabletVisible::ReturnValue' has a wrong offset!");

// Function G01.GzMortarLegs_MapScreen.CreateMapController
// 0x0008 (0x0008 - 0x0000)
struct GzMortarLegs_MapScreen_CreateMapController final
{
public:
	class UGzMortarLegs_MapScreenController*      ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzMortarLegs_MapScreen_CreateMapController) == 0x000008, "Wrong alignment on GzMortarLegs_MapScreen_CreateMapController");
static_assert(sizeof(GzMortarLegs_MapScreen_CreateMapController) == 0x000008, "Wrong size on GzMortarLegs_MapScreen_CreateMapController");
static_assert(offsetof(GzMortarLegs_MapScreen_CreateMapController, ReturnValue) == 0x000000, "Member 'GzMortarLegs_MapScreen_CreateMapController::ReturnValue' has a wrong offset!");

// Function G01.GzMortarLegs_MapScreen.GetTargetLocations2D
// 0x0010 (0x0010 - 0x0000)
struct GzMortarLegs_MapScreen_GetTargetLocations2D final
{
public:
	TArray<struct FVector2D>                      ReturnValue;                                       // 0x0000(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzMortarLegs_MapScreen_GetTargetLocations2D) == 0x000008, "Wrong alignment on GzMortarLegs_MapScreen_GetTargetLocations2D");
static_assert(sizeof(GzMortarLegs_MapScreen_GetTargetLocations2D) == 0x000010, "Wrong size on GzMortarLegs_MapScreen_GetTargetLocations2D");
static_assert(offsetof(GzMortarLegs_MapScreen_GetTargetLocations2D, ReturnValue) == 0x000000, "Member 'GzMortarLegs_MapScreen_GetTargetLocations2D::ReturnValue' has a wrong offset!");

// Function G01.GzMortarLegs_MapScreenController.AddTargetLocation
// 0x0018 (0x0018 - 0x0000)
struct GzMortarLegs_MapScreenController_AddTargetLocation final
{
public:
	struct FVector2D                              WorldLocation2D;                                   // 0x0000(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0010(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_33EF[0x7];                                     // 0x0011(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GzMortarLegs_MapScreenController_AddTargetLocation) == 0x000008, "Wrong alignment on GzMortarLegs_MapScreenController_AddTargetLocation");
static_assert(sizeof(GzMortarLegs_MapScreenController_AddTargetLocation) == 0x000018, "Wrong size on GzMortarLegs_MapScreenController_AddTargetLocation");
static_assert(offsetof(GzMortarLegs_MapScreenController_AddTargetLocation, WorldLocation2D) == 0x000000, "Member 'GzMortarLegs_MapScreenController_AddTargetLocation::WorldLocation2D' has a wrong offset!");
static_assert(offsetof(GzMortarLegs_MapScreenController_AddTargetLocation, ReturnValue) == 0x000010, "Member 'GzMortarLegs_MapScreenController_AddTargetLocation::ReturnValue' has a wrong offset!");

// Function G01.GzMortarLegs_MapScreenController.CalculateMapRectangle
// 0x0028 (0x0028 - 0x0000)
struct GzMortarLegs_MapScreenController_CalculateMapRectangle final
{
public:
	struct FBox2D                                 ReturnValue;                                       // 0x0000(0x0028)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzMortarLegs_MapScreenController_CalculateMapRectangle) == 0x000008, "Wrong alignment on GzMortarLegs_MapScreenController_CalculateMapRectangle");
static_assert(sizeof(GzMortarLegs_MapScreenController_CalculateMapRectangle) == 0x000028, "Wrong size on GzMortarLegs_MapScreenController_CalculateMapRectangle");
static_assert(offsetof(GzMortarLegs_MapScreenController_CalculateMapRectangle, ReturnValue) == 0x000000, "Member 'GzMortarLegs_MapScreenController_CalculateMapRectangle::ReturnValue' has a wrong offset!");

// Function G01.GzMortarLegs_MapScreenController.GetTargetLocations2D
// 0x0010 (0x0010 - 0x0000)
struct GzMortarLegs_MapScreenController_GetTargetLocations2D final
{
public:
	TArray<struct FVector2D>                      ReturnValue;                                       // 0x0000(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzMortarLegs_MapScreenController_GetTargetLocations2D) == 0x000008, "Wrong alignment on GzMortarLegs_MapScreenController_GetTargetLocations2D");
static_assert(sizeof(GzMortarLegs_MapScreenController_GetTargetLocations2D) == 0x000010, "Wrong size on GzMortarLegs_MapScreenController_GetTargetLocations2D");
static_assert(offsetof(GzMortarLegs_MapScreenController_GetTargetLocations2D, ReturnValue) == 0x000000, "Member 'GzMortarLegs_MapScreenController_GetTargetLocations2D::ReturnValue' has a wrong offset!");

// Function G01.GzMortarLegs_MapScreenController.IsValidTargetLocation
// 0x0018 (0x0018 - 0x0000)
struct GzMortarLegs_MapScreenController_IsValidTargetLocation final
{
public:
	struct FVector2D                              WorldLocation2D;                                   // 0x0000(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0010(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_33F0[0x7];                                     // 0x0011(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GzMortarLegs_MapScreenController_IsValidTargetLocation) == 0x000008, "Wrong alignment on GzMortarLegs_MapScreenController_IsValidTargetLocation");
static_assert(sizeof(GzMortarLegs_MapScreenController_IsValidTargetLocation) == 0x000018, "Wrong size on GzMortarLegs_MapScreenController_IsValidTargetLocation");
static_assert(offsetof(GzMortarLegs_MapScreenController_IsValidTargetLocation, WorldLocation2D) == 0x000000, "Member 'GzMortarLegs_MapScreenController_IsValidTargetLocation::WorldLocation2D' has a wrong offset!");
static_assert(offsetof(GzMortarLegs_MapScreenController_IsValidTargetLocation, ReturnValue) == 0x000010, "Member 'GzMortarLegs_MapScreenController_IsValidTargetLocation::ReturnValue' has a wrong offset!");

// Function G01.GzSplineMapWidget.Init
// 0x0020 (0x0020 - 0x0000)
struct GzSplineMapWidget_Init final
{
public:
	class UGzMapWidget*                           InParentMap;                                       // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FVector>                        WorldPoints;                                       // 0x0008(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	bool                                          bInClosedLoop;                                     // 0x0018(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_33F3[0x7];                                     // 0x0019(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GzSplineMapWidget_Init) == 0x000008, "Wrong alignment on GzSplineMapWidget_Init");
static_assert(sizeof(GzSplineMapWidget_Init) == 0x000020, "Wrong size on GzSplineMapWidget_Init");
static_assert(offsetof(GzSplineMapWidget_Init, InParentMap) == 0x000000, "Member 'GzSplineMapWidget_Init::InParentMap' has a wrong offset!");
static_assert(offsetof(GzSplineMapWidget_Init, WorldPoints) == 0x000008, "Member 'GzSplineMapWidget_Init::WorldPoints' has a wrong offset!");
static_assert(offsetof(GzSplineMapWidget_Init, bInClosedLoop) == 0x000018, "Member 'GzSplineMapWidget_Init::bInClosedLoop' has a wrong offset!");

// Function G01.GzSplineMapWidget.InitWith2DPoints
// 0x0020 (0x0020 - 0x0000)
struct GzSplineMapWidget_InitWith2DPoints final
{
public:
	class UGzMapWidget*                           InParentMap;                                       // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FVector2D>                      WorldPoints;                                       // 0x0008(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	bool                                          bInClosedLoop;                                     // 0x0018(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_33F4[0x7];                                     // 0x0019(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GzSplineMapWidget_InitWith2DPoints) == 0x000008, "Wrong alignment on GzSplineMapWidget_InitWith2DPoints");
static_assert(sizeof(GzSplineMapWidget_InitWith2DPoints) == 0x000020, "Wrong size on GzSplineMapWidget_InitWith2DPoints");
static_assert(offsetof(GzSplineMapWidget_InitWith2DPoints, InParentMap) == 0x000000, "Member 'GzSplineMapWidget_InitWith2DPoints::InParentMap' has a wrong offset!");
static_assert(offsetof(GzSplineMapWidget_InitWith2DPoints, WorldPoints) == 0x000008, "Member 'GzSplineMapWidget_InitWith2DPoints::WorldPoints' has a wrong offset!");
static_assert(offsetof(GzSplineMapWidget_InitWith2DPoints, bInClosedLoop) == 0x000018, "Member 'GzSplineMapWidget_InitWith2DPoints::bInClosedLoop' has a wrong offset!");

// Function G01.GzSplineMapWidget.InitWithSpline
// 0x0018 (0x0018 - 0x0000)
struct GzSplineMapWidget_InitWithSpline final
{
public:
	class UGzMapWidget*                           InParentMap;                                       // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USplineComponent*                       InSpline;                                          // 0x0008(0x0008)(Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         InStart;                                           // 0x0010(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         InEnd;                                             // 0x0014(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzSplineMapWidget_InitWithSpline) == 0x000008, "Wrong alignment on GzSplineMapWidget_InitWithSpline");
static_assert(sizeof(GzSplineMapWidget_InitWithSpline) == 0x000018, "Wrong size on GzSplineMapWidget_InitWithSpline");
static_assert(offsetof(GzSplineMapWidget_InitWithSpline, InParentMap) == 0x000000, "Member 'GzSplineMapWidget_InitWithSpline::InParentMap' has a wrong offset!");
static_assert(offsetof(GzSplineMapWidget_InitWithSpline, InSpline) == 0x000008, "Member 'GzSplineMapWidget_InitWithSpline::InSpline' has a wrong offset!");
static_assert(offsetof(GzSplineMapWidget_InitWithSpline, InStart) == 0x000010, "Member 'GzSplineMapWidget_InitWithSpline::InStart' has a wrong offset!");
static_assert(offsetof(GzSplineMapWidget_InitWithSpline, InEnd) == 0x000014, "Member 'GzSplineMapWidget_InitWithSpline::InEnd' has a wrong offset!");

// Function G01.GzPoseableSkeletalMeshComponent.CopyPoseFromSkeletalComponent
// 0x0008 (0x0008 - 0x0000)
struct GzPoseableSkeletalMeshComponent_CopyPoseFromSkeletalComponent final
{
public:
	class USkeletalMeshComponent*                 InComponentToCopy;                                 // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzPoseableSkeletalMeshComponent_CopyPoseFromSkeletalComponent) == 0x000008, "Wrong alignment on GzPoseableSkeletalMeshComponent_CopyPoseFromSkeletalComponent");
static_assert(sizeof(GzPoseableSkeletalMeshComponent_CopyPoseFromSkeletalComponent) == 0x000008, "Wrong size on GzPoseableSkeletalMeshComponent_CopyPoseFromSkeletalComponent");
static_assert(offsetof(GzPoseableSkeletalMeshComponent_CopyPoseFromSkeletalComponent, InComponentToCopy) == 0x000000, "Member 'GzPoseableSkeletalMeshComponent_CopyPoseFromSkeletalComponent::InComponentToCopy' has a wrong offset!");

// Function G01.GzPoseableSkeletalMeshComponent.GetBoneLocationByName
// 0x0028 (0x0028 - 0x0000)
struct GzPoseableSkeletalMeshComponent_GetBoneLocationByName final
{
public:
	class FName                                   BoneName;                                          // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EBoneSpaces                                   BoneSpace;                                         // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_33FA[0x7];                                     // 0x0009(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                ReturnValue;                                       // 0x0010(0x0018)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzPoseableSkeletalMeshComponent_GetBoneLocationByName) == 0x000008, "Wrong alignment on GzPoseableSkeletalMeshComponent_GetBoneLocationByName");
static_assert(sizeof(GzPoseableSkeletalMeshComponent_GetBoneLocationByName) == 0x000028, "Wrong size on GzPoseableSkeletalMeshComponent_GetBoneLocationByName");
static_assert(offsetof(GzPoseableSkeletalMeshComponent_GetBoneLocationByName, BoneName) == 0x000000, "Member 'GzPoseableSkeletalMeshComponent_GetBoneLocationByName::BoneName' has a wrong offset!");
static_assert(offsetof(GzPoseableSkeletalMeshComponent_GetBoneLocationByName, BoneSpace) == 0x000008, "Member 'GzPoseableSkeletalMeshComponent_GetBoneLocationByName::BoneSpace' has a wrong offset!");
static_assert(offsetof(GzPoseableSkeletalMeshComponent_GetBoneLocationByName, ReturnValue) == 0x000010, "Member 'GzPoseableSkeletalMeshComponent_GetBoneLocationByName::ReturnValue' has a wrong offset!");

// Function G01.GzPoseableSkeletalMeshComponent.GetBoneRotationByName
// 0x0028 (0x0028 - 0x0000)
struct GzPoseableSkeletalMeshComponent_GetBoneRotationByName final
{
public:
	class FName                                   BoneName;                                          // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EBoneSpaces                                   BoneSpace;                                         // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_33FB[0x7];                                     // 0x0009(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRotator                               ReturnValue;                                       // 0x0010(0x0018)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzPoseableSkeletalMeshComponent_GetBoneRotationByName) == 0x000008, "Wrong alignment on GzPoseableSkeletalMeshComponent_GetBoneRotationByName");
static_assert(sizeof(GzPoseableSkeletalMeshComponent_GetBoneRotationByName) == 0x000028, "Wrong size on GzPoseableSkeletalMeshComponent_GetBoneRotationByName");
static_assert(offsetof(GzPoseableSkeletalMeshComponent_GetBoneRotationByName, BoneName) == 0x000000, "Member 'GzPoseableSkeletalMeshComponent_GetBoneRotationByName::BoneName' has a wrong offset!");
static_assert(offsetof(GzPoseableSkeletalMeshComponent_GetBoneRotationByName, BoneSpace) == 0x000008, "Member 'GzPoseableSkeletalMeshComponent_GetBoneRotationByName::BoneSpace' has a wrong offset!");
static_assert(offsetof(GzPoseableSkeletalMeshComponent_GetBoneRotationByName, ReturnValue) == 0x000010, "Member 'GzPoseableSkeletalMeshComponent_GetBoneRotationByName::ReturnValue' has a wrong offset!");

// Function G01.GzPoseableSkeletalMeshComponent.GetBoneScaleByName
// 0x0028 (0x0028 - 0x0000)
struct GzPoseableSkeletalMeshComponent_GetBoneScaleByName final
{
public:
	class FName                                   BoneName;                                          // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EBoneSpaces                                   BoneSpace;                                         // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_33FC[0x7];                                     // 0x0009(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                ReturnValue;                                       // 0x0010(0x0018)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzPoseableSkeletalMeshComponent_GetBoneScaleByName) == 0x000008, "Wrong alignment on GzPoseableSkeletalMeshComponent_GetBoneScaleByName");
static_assert(sizeof(GzPoseableSkeletalMeshComponent_GetBoneScaleByName) == 0x000028, "Wrong size on GzPoseableSkeletalMeshComponent_GetBoneScaleByName");
static_assert(offsetof(GzPoseableSkeletalMeshComponent_GetBoneScaleByName, BoneName) == 0x000000, "Member 'GzPoseableSkeletalMeshComponent_GetBoneScaleByName::BoneName' has a wrong offset!");
static_assert(offsetof(GzPoseableSkeletalMeshComponent_GetBoneScaleByName, BoneSpace) == 0x000008, "Member 'GzPoseableSkeletalMeshComponent_GetBoneScaleByName::BoneSpace' has a wrong offset!");
static_assert(offsetof(GzPoseableSkeletalMeshComponent_GetBoneScaleByName, ReturnValue) == 0x000010, "Member 'GzPoseableSkeletalMeshComponent_GetBoneScaleByName::ReturnValue' has a wrong offset!");

// Function G01.GzPoseableSkeletalMeshComponent.GetBoneTransformByName
// 0x0070 (0x0070 - 0x0000)
struct GzPoseableSkeletalMeshComponent_GetBoneTransformByName final
{
public:
	class FName                                   BoneName;                                          // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EBoneSpaces                                   BoneSpace;                                         // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_33FD[0x7];                                     // 0x0009(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             ReturnValue;                                       // 0x0010(0x0060)(Parm, OutParm, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzPoseableSkeletalMeshComponent_GetBoneTransformByName) == 0x000010, "Wrong alignment on GzPoseableSkeletalMeshComponent_GetBoneTransformByName");
static_assert(sizeof(GzPoseableSkeletalMeshComponent_GetBoneTransformByName) == 0x000070, "Wrong size on GzPoseableSkeletalMeshComponent_GetBoneTransformByName");
static_assert(offsetof(GzPoseableSkeletalMeshComponent_GetBoneTransformByName, BoneName) == 0x000000, "Member 'GzPoseableSkeletalMeshComponent_GetBoneTransformByName::BoneName' has a wrong offset!");
static_assert(offsetof(GzPoseableSkeletalMeshComponent_GetBoneTransformByName, BoneSpace) == 0x000008, "Member 'GzPoseableSkeletalMeshComponent_GetBoneTransformByName::BoneSpace' has a wrong offset!");
static_assert(offsetof(GzPoseableSkeletalMeshComponent_GetBoneTransformByName, ReturnValue) == 0x000010, "Member 'GzPoseableSkeletalMeshComponent_GetBoneTransformByName::ReturnValue' has a wrong offset!");

// Function G01.GzPoseableSkeletalMeshComponent.ResetBoneTransformByName
// 0x0008 (0x0008 - 0x0000)
struct GzPoseableSkeletalMeshComponent_ResetBoneTransformByName final
{
public:
	class FName                                   BoneName;                                          // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzPoseableSkeletalMeshComponent_ResetBoneTransformByName) == 0x000004, "Wrong alignment on GzPoseableSkeletalMeshComponent_ResetBoneTransformByName");
static_assert(sizeof(GzPoseableSkeletalMeshComponent_ResetBoneTransformByName) == 0x000008, "Wrong size on GzPoseableSkeletalMeshComponent_ResetBoneTransformByName");
static_assert(offsetof(GzPoseableSkeletalMeshComponent_ResetBoneTransformByName, BoneName) == 0x000000, "Member 'GzPoseableSkeletalMeshComponent_ResetBoneTransformByName::BoneName' has a wrong offset!");

// Function G01.GzPoseableSkeletalMeshComponent.SetBoneLocationAndQuatByName
// 0x0050 (0x0050 - 0x0000)
struct GzPoseableSkeletalMeshComponent_SetBoneLocationAndQuatByName final
{
public:
	class FName                                   BoneName;                                          // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                InLocation;                                        // 0x0008(0x0018)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FQuat                                  InQuat;                                            // 0x0020(0x0020)(Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EBoneSpaces                                   BoneSpace;                                         // 0x0040(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_33FE[0xF];                                     // 0x0041(0x000F)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GzPoseableSkeletalMeshComponent_SetBoneLocationAndQuatByName) == 0x000010, "Wrong alignment on GzPoseableSkeletalMeshComponent_SetBoneLocationAndQuatByName");
static_assert(sizeof(GzPoseableSkeletalMeshComponent_SetBoneLocationAndQuatByName) == 0x000050, "Wrong size on GzPoseableSkeletalMeshComponent_SetBoneLocationAndQuatByName");
static_assert(offsetof(GzPoseableSkeletalMeshComponent_SetBoneLocationAndQuatByName, BoneName) == 0x000000, "Member 'GzPoseableSkeletalMeshComponent_SetBoneLocationAndQuatByName::BoneName' has a wrong offset!");
static_assert(offsetof(GzPoseableSkeletalMeshComponent_SetBoneLocationAndQuatByName, InLocation) == 0x000008, "Member 'GzPoseableSkeletalMeshComponent_SetBoneLocationAndQuatByName::InLocation' has a wrong offset!");
static_assert(offsetof(GzPoseableSkeletalMeshComponent_SetBoneLocationAndQuatByName, InQuat) == 0x000020, "Member 'GzPoseableSkeletalMeshComponent_SetBoneLocationAndQuatByName::InQuat' has a wrong offset!");
static_assert(offsetof(GzPoseableSkeletalMeshComponent_SetBoneLocationAndQuatByName, BoneSpace) == 0x000040, "Member 'GzPoseableSkeletalMeshComponent_SetBoneLocationAndQuatByName::BoneSpace' has a wrong offset!");

// Function G01.GzPoseableSkeletalMeshComponent.SetBoneLocationByName
// 0x0028 (0x0028 - 0x0000)
struct GzPoseableSkeletalMeshComponent_SetBoneLocationByName final
{
public:
	class FName                                   BoneName;                                          // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                InLocation;                                        // 0x0008(0x0018)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EBoneSpaces                                   BoneSpace;                                         // 0x0020(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_33FF[0x7];                                     // 0x0021(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GzPoseableSkeletalMeshComponent_SetBoneLocationByName) == 0x000008, "Wrong alignment on GzPoseableSkeletalMeshComponent_SetBoneLocationByName");
static_assert(sizeof(GzPoseableSkeletalMeshComponent_SetBoneLocationByName) == 0x000028, "Wrong size on GzPoseableSkeletalMeshComponent_SetBoneLocationByName");
static_assert(offsetof(GzPoseableSkeletalMeshComponent_SetBoneLocationByName, BoneName) == 0x000000, "Member 'GzPoseableSkeletalMeshComponent_SetBoneLocationByName::BoneName' has a wrong offset!");
static_assert(offsetof(GzPoseableSkeletalMeshComponent_SetBoneLocationByName, InLocation) == 0x000008, "Member 'GzPoseableSkeletalMeshComponent_SetBoneLocationByName::InLocation' has a wrong offset!");
static_assert(offsetof(GzPoseableSkeletalMeshComponent_SetBoneLocationByName, BoneSpace) == 0x000020, "Member 'GzPoseableSkeletalMeshComponent_SetBoneLocationByName::BoneSpace' has a wrong offset!");

// Function G01.GzPoseableSkeletalMeshComponent.SetBoneRotationByName
// 0x0028 (0x0028 - 0x0000)
struct GzPoseableSkeletalMeshComponent_SetBoneRotationByName final
{
public:
	class FName                                   BoneName;                                          // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               InRotation;                                        // 0x0008(0x0018)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	EBoneSpaces                                   BoneSpace;                                         // 0x0020(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3400[0x7];                                     // 0x0021(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GzPoseableSkeletalMeshComponent_SetBoneRotationByName) == 0x000008, "Wrong alignment on GzPoseableSkeletalMeshComponent_SetBoneRotationByName");
static_assert(sizeof(GzPoseableSkeletalMeshComponent_SetBoneRotationByName) == 0x000028, "Wrong size on GzPoseableSkeletalMeshComponent_SetBoneRotationByName");
static_assert(offsetof(GzPoseableSkeletalMeshComponent_SetBoneRotationByName, BoneName) == 0x000000, "Member 'GzPoseableSkeletalMeshComponent_SetBoneRotationByName::BoneName' has a wrong offset!");
static_assert(offsetof(GzPoseableSkeletalMeshComponent_SetBoneRotationByName, InRotation) == 0x000008, "Member 'GzPoseableSkeletalMeshComponent_SetBoneRotationByName::InRotation' has a wrong offset!");
static_assert(offsetof(GzPoseableSkeletalMeshComponent_SetBoneRotationByName, BoneSpace) == 0x000020, "Member 'GzPoseableSkeletalMeshComponent_SetBoneRotationByName::BoneSpace' has a wrong offset!");

// Function G01.GzPoseableSkeletalMeshComponent.SetBoneScaleByName
// 0x0028 (0x0028 - 0x0000)
struct GzPoseableSkeletalMeshComponent_SetBoneScaleByName final
{
public:
	class FName                                   BoneName;                                          // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                InScale3D;                                         // 0x0008(0x0018)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EBoneSpaces                                   BoneSpace;                                         // 0x0020(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3401[0x7];                                     // 0x0021(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GzPoseableSkeletalMeshComponent_SetBoneScaleByName) == 0x000008, "Wrong alignment on GzPoseableSkeletalMeshComponent_SetBoneScaleByName");
static_assert(sizeof(GzPoseableSkeletalMeshComponent_SetBoneScaleByName) == 0x000028, "Wrong size on GzPoseableSkeletalMeshComponent_SetBoneScaleByName");
static_assert(offsetof(GzPoseableSkeletalMeshComponent_SetBoneScaleByName, BoneName) == 0x000000, "Member 'GzPoseableSkeletalMeshComponent_SetBoneScaleByName::BoneName' has a wrong offset!");
static_assert(offsetof(GzPoseableSkeletalMeshComponent_SetBoneScaleByName, InScale3D) == 0x000008, "Member 'GzPoseableSkeletalMeshComponent_SetBoneScaleByName::InScale3D' has a wrong offset!");
static_assert(offsetof(GzPoseableSkeletalMeshComponent_SetBoneScaleByName, BoneSpace) == 0x000020, "Member 'GzPoseableSkeletalMeshComponent_SetBoneScaleByName::BoneSpace' has a wrong offset!");

// Function G01.GzPoseableSkeletalMeshComponent.SetBoneTransformByName
// 0x0080 (0x0080 - 0x0000)
struct GzPoseableSkeletalMeshComponent_SetBoneTransformByName final
{
public:
	class FName                                   BoneName;                                          // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3402[0x8];                                     // 0x0008(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             InTransform;                                       // 0x0010(0x0060)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EBoneSpaces                                   BoneSpace;                                         // 0x0070(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3403[0xF];                                     // 0x0071(0x000F)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GzPoseableSkeletalMeshComponent_SetBoneTransformByName) == 0x000010, "Wrong alignment on GzPoseableSkeletalMeshComponent_SetBoneTransformByName");
static_assert(sizeof(GzPoseableSkeletalMeshComponent_SetBoneTransformByName) == 0x000080, "Wrong size on GzPoseableSkeletalMeshComponent_SetBoneTransformByName");
static_assert(offsetof(GzPoseableSkeletalMeshComponent_SetBoneTransformByName, BoneName) == 0x000000, "Member 'GzPoseableSkeletalMeshComponent_SetBoneTransformByName::BoneName' has a wrong offset!");
static_assert(offsetof(GzPoseableSkeletalMeshComponent_SetBoneTransformByName, InTransform) == 0x000010, "Member 'GzPoseableSkeletalMeshComponent_SetBoneTransformByName::InTransform' has a wrong offset!");
static_assert(offsetof(GzPoseableSkeletalMeshComponent_SetBoneTransformByName, BoneSpace) == 0x000070, "Member 'GzPoseableSkeletalMeshComponent_SetBoneTransformByName::BoneSpace' has a wrong offset!");

// Function G01.GzMovableMapController.AreZoomLevelsEnabled
// 0x0001 (0x0001 - 0x0000)
struct GzMovableMapController_AreZoomLevelsEnabled final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzMovableMapController_AreZoomLevelsEnabled) == 0x000001, "Wrong alignment on GzMovableMapController_AreZoomLevelsEnabled");
static_assert(sizeof(GzMovableMapController_AreZoomLevelsEnabled) == 0x000001, "Wrong size on GzMovableMapController_AreZoomLevelsEnabled");
static_assert(offsetof(GzMovableMapController_AreZoomLevelsEnabled, ReturnValue) == 0x000000, "Member 'GzMovableMapController_AreZoomLevelsEnabled::ReturnValue' has a wrong offset!");

// Function G01.GzMovableMapController.GetTargetZoomLevel
// 0x0008 (0x0008 - 0x0000)
struct GzMovableMapController_GetTargetZoomLevel final
{
public:
	int32                                         ZoomLevelIndex;                                    // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ReturnValue;                                       // 0x0004(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzMovableMapController_GetTargetZoomLevel) == 0x000004, "Wrong alignment on GzMovableMapController_GetTargetZoomLevel");
static_assert(sizeof(GzMovableMapController_GetTargetZoomLevel) == 0x000008, "Wrong size on GzMovableMapController_GetTargetZoomLevel");
static_assert(offsetof(GzMovableMapController_GetTargetZoomLevel, ZoomLevelIndex) == 0x000000, "Member 'GzMovableMapController_GetTargetZoomLevel::ZoomLevelIndex' has a wrong offset!");
static_assert(offsetof(GzMovableMapController_GetTargetZoomLevel, ReturnValue) == 0x000004, "Member 'GzMovableMapController_GetTargetZoomLevel::ReturnValue' has a wrong offset!");

// Function G01.GzMovableMapController.GetZoomLevelsCount
// 0x0004 (0x0004 - 0x0000)
struct GzMovableMapController_GetZoomLevelsCount final
{
public:
	int32                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzMovableMapController_GetZoomLevelsCount) == 0x000004, "Wrong alignment on GzMovableMapController_GetZoomLevelsCount");
static_assert(sizeof(GzMovableMapController_GetZoomLevelsCount) == 0x000004, "Wrong size on GzMovableMapController_GetZoomLevelsCount");
static_assert(offsetof(GzMovableMapController_GetZoomLevelsCount, ReturnValue) == 0x000000, "Member 'GzMovableMapController_GetZoomLevelsCount::ReturnValue' has a wrong offset!");

// Function G01.GzMovableMapController.OnAnalogValueChanged
// 0x0048 (0x0048 - 0x0000)
struct GzMovableMapController_OnAnalogValueChanged final
{
public:
	struct FAnalogInputEvent                      InKeyEvent;                                        // 0x0000(0x0048)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzMovableMapController_OnAnalogValueChanged) == 0x000008, "Wrong alignment on GzMovableMapController_OnAnalogValueChanged");
static_assert(sizeof(GzMovableMapController_OnAnalogValueChanged) == 0x000048, "Wrong size on GzMovableMapController_OnAnalogValueChanged");
static_assert(offsetof(GzMovableMapController_OnAnalogValueChanged, InKeyEvent) == 0x000000, "Member 'GzMovableMapController_OnAnalogValueChanged::InKeyEvent' has a wrong offset!");

// Function G01.GzMovableMapController.OnKeyDown
// 0x0040 (0x0040 - 0x0000)
struct GzMovableMapController_OnKeyDown final
{
public:
	struct FKeyEvent                              InKeyEvent;                                        // 0x0000(0x0040)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzMovableMapController_OnKeyDown) == 0x000008, "Wrong alignment on GzMovableMapController_OnKeyDown");
static_assert(sizeof(GzMovableMapController_OnKeyDown) == 0x000040, "Wrong size on GzMovableMapController_OnKeyDown");
static_assert(offsetof(GzMovableMapController_OnKeyDown, InKeyEvent) == 0x000000, "Member 'GzMovableMapController_OnKeyDown::InKeyEvent' has a wrong offset!");

// Function G01.GzMovableMapController.OnMouseButtonDown
// 0x0168 (0x0168 - 0x0000)
struct GzMovableMapController_OnMouseButtonDown final
{
public:
	struct FGeometry                              MyGeometry;                                        // 0x0000(0x0038)(Parm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FPointerEvent                          MouseEvent;                                        // 0x0038(0x0078)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	struct FEventReply                            ReturnValue;                                       // 0x00B0(0x00B8)(Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzMovableMapController_OnMouseButtonDown) == 0x000008, "Wrong alignment on GzMovableMapController_OnMouseButtonDown");
static_assert(sizeof(GzMovableMapController_OnMouseButtonDown) == 0x000168, "Wrong size on GzMovableMapController_OnMouseButtonDown");
static_assert(offsetof(GzMovableMapController_OnMouseButtonDown, MyGeometry) == 0x000000, "Member 'GzMovableMapController_OnMouseButtonDown::MyGeometry' has a wrong offset!");
static_assert(offsetof(GzMovableMapController_OnMouseButtonDown, MouseEvent) == 0x000038, "Member 'GzMovableMapController_OnMouseButtonDown::MouseEvent' has a wrong offset!");
static_assert(offsetof(GzMovableMapController_OnMouseButtonDown, ReturnValue) == 0x0000B0, "Member 'GzMovableMapController_OnMouseButtonDown::ReturnValue' has a wrong offset!");

// Function G01.GzMovableMapController.OnMouseLeave
// 0x0078 (0x0078 - 0x0000)
struct GzMovableMapController_OnMouseLeave final
{
public:
	struct FPointerEvent                          InMouseEvent;                                      // 0x0000(0x0078)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzMovableMapController_OnMouseLeave) == 0x000008, "Wrong alignment on GzMovableMapController_OnMouseLeave");
static_assert(sizeof(GzMovableMapController_OnMouseLeave) == 0x000078, "Wrong size on GzMovableMapController_OnMouseLeave");
static_assert(offsetof(GzMovableMapController_OnMouseLeave, InMouseEvent) == 0x000000, "Member 'GzMovableMapController_OnMouseLeave::InMouseEvent' has a wrong offset!");

// Function G01.GzMovableMapController.OnMouseWheel
// 0x0078 (0x0078 - 0x0000)
struct GzMovableMapController_OnMouseWheel final
{
public:
	struct FPointerEvent                          InMouseEvent;                                      // 0x0000(0x0078)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzMovableMapController_OnMouseWheel) == 0x000008, "Wrong alignment on GzMovableMapController_OnMouseWheel");
static_assert(sizeof(GzMovableMapController_OnMouseWheel) == 0x000078, "Wrong size on GzMovableMapController_OnMouseWheel");
static_assert(offsetof(GzMovableMapController_OnMouseWheel, InMouseEvent) == 0x000000, "Member 'GzMovableMapController_OnMouseWheel::InMouseEvent' has a wrong offset!");

// Function G01.GzMovableMapController.SetTrackingTarget
// 0x0008 (0x0008 - 0x0000)
struct GzMovableMapController_SetTrackingTarget final
{
public:
	class AActor*                                 Target;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzMovableMapController_SetTrackingTarget) == 0x000008, "Wrong alignment on GzMovableMapController_SetTrackingTarget");
static_assert(sizeof(GzMovableMapController_SetTrackingTarget) == 0x000008, "Wrong size on GzMovableMapController_SetTrackingTarget");
static_assert(offsetof(GzMovableMapController_SetTrackingTarget, Target) == 0x000000, "Member 'GzMovableMapController_SetTrackingTarget::Target' has a wrong offset!");

// Function G01.GzMovementSoundComponent.OnCustomizationChanged
// 0x0150 (0x0150 - 0x0000)
struct GzMovementSoundComponent_OnCustomizationChanged final
{
public:
	struct FGzCharacterCustomizationProfile       NewCustomizationProfile;                           // 0x0000(0x0150)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzMovementSoundComponent_OnCustomizationChanged) == 0x000008, "Wrong alignment on GzMovementSoundComponent_OnCustomizationChanged");
static_assert(sizeof(GzMovementSoundComponent_OnCustomizationChanged) == 0x000150, "Wrong size on GzMovementSoundComponent_OnCustomizationChanged");
static_assert(offsetof(GzMovementSoundComponent_OnCustomizationChanged, NewCustomizationProfile) == 0x000000, "Member 'GzMovementSoundComponent_OnCustomizationChanged::NewCustomizationProfile' has a wrong offset!");

// Function G01.GzPostProcessControllerComponent.AddPostProcessBlend
// 0x0010 (0x0010 - 0x0000)
struct GzPostProcessControllerComponent_AddPostProcessBlend final
{
public:
	TSubclassOf<class UGzPostProcessFX>           FXClass;                                           // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UGzPostProcessFX*                       ReturnValue;                                       // 0x0008(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzPostProcessControllerComponent_AddPostProcessBlend) == 0x000008, "Wrong alignment on GzPostProcessControllerComponent_AddPostProcessBlend");
static_assert(sizeof(GzPostProcessControllerComponent_AddPostProcessBlend) == 0x000010, "Wrong size on GzPostProcessControllerComponent_AddPostProcessBlend");
static_assert(offsetof(GzPostProcessControllerComponent_AddPostProcessBlend, FXClass) == 0x000000, "Member 'GzPostProcessControllerComponent_AddPostProcessBlend::FXClass' has a wrong offset!");
static_assert(offsetof(GzPostProcessControllerComponent_AddPostProcessBlend, ReturnValue) == 0x000008, "Member 'GzPostProcessControllerComponent_AddPostProcessBlend::ReturnValue' has a wrong offset!");

// Function G01.GzPostProcessControllerComponent.AddPostProcessInstance
// 0x0010 (0x0010 - 0x0000)
struct GzPostProcessControllerComponent_AddPostProcessInstance final
{
public:
	class UGzPostProcessFX*                       NewFX;                                             // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UGzPostProcessFX*                       ReturnValue;                                       // 0x0008(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzPostProcessControllerComponent_AddPostProcessInstance) == 0x000008, "Wrong alignment on GzPostProcessControllerComponent_AddPostProcessInstance");
static_assert(sizeof(GzPostProcessControllerComponent_AddPostProcessInstance) == 0x000010, "Wrong size on GzPostProcessControllerComponent_AddPostProcessInstance");
static_assert(offsetof(GzPostProcessControllerComponent_AddPostProcessInstance, NewFX) == 0x000000, "Member 'GzPostProcessControllerComponent_AddPostProcessInstance::NewFX' has a wrong offset!");
static_assert(offsetof(GzPostProcessControllerComponent_AddPostProcessInstance, ReturnValue) == 0x000008, "Member 'GzPostProcessControllerComponent_AddPostProcessInstance::ReturnValue' has a wrong offset!");

// Function G01.GzPostProcessControllerComponent.OnViewTargetChanged
// 0x0008 (0x0008 - 0x0000)
struct GzPostProcessControllerComponent_OnViewTargetChanged final
{
public:
	class APawn*                                  NewPawn;                                           // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzPostProcessControllerComponent_OnViewTargetChanged) == 0x000008, "Wrong alignment on GzPostProcessControllerComponent_OnViewTargetChanged");
static_assert(sizeof(GzPostProcessControllerComponent_OnViewTargetChanged) == 0x000008, "Wrong size on GzPostProcessControllerComponent_OnViewTargetChanged");
static_assert(offsetof(GzPostProcessControllerComponent_OnViewTargetChanged, NewPawn) == 0x000000, "Member 'GzPostProcessControllerComponent_OnViewTargetChanged::NewPawn' has a wrong offset!");

// Function G01.GzPostProcessControllerComponent.RemovePostProcess
// 0x0008 (0x0008 - 0x0000)
struct GzPostProcessControllerComponent_RemovePostProcess final
{
public:
	class UGzPostProcessFX*                       PostProcessFX;                                     // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzPostProcessControllerComponent_RemovePostProcess) == 0x000008, "Wrong alignment on GzPostProcessControllerComponent_RemovePostProcess");
static_assert(sizeof(GzPostProcessControllerComponent_RemovePostProcess) == 0x000008, "Wrong size on GzPostProcessControllerComponent_RemovePostProcess");
static_assert(offsetof(GzPostProcessControllerComponent_RemovePostProcess, PostProcessFX) == 0x000000, "Member 'GzPostProcessControllerComponent_RemovePostProcess::PostProcessFX' has a wrong offset!");

// Function G01.GzPostProcessControllerComponent.GetViewTargetCameraComponent
// 0x0008 (0x0008 - 0x0000)
struct GzPostProcessControllerComponent_GetViewTargetCameraComponent final
{
public:
	class UGzCameraComponent*                     ReturnValue;                                       // 0x0000(0x0008)(ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzPostProcessControllerComponent_GetViewTargetCameraComponent) == 0x000008, "Wrong alignment on GzPostProcessControllerComponent_GetViewTargetCameraComponent");
static_assert(sizeof(GzPostProcessControllerComponent_GetViewTargetCameraComponent) == 0x000008, "Wrong size on GzPostProcessControllerComponent_GetViewTargetCameraComponent");
static_assert(offsetof(GzPostProcessControllerComponent_GetViewTargetCameraComponent, ReturnValue) == 0x000000, "Member 'GzPostProcessControllerComponent_GetViewTargetCameraComponent::ReturnValue' has a wrong offset!");

// Function G01.GzLocomotionStatics.BreakLocomotionCurrentStates
// 0x0012 (0x0012 - 0x0000)
struct GzLocomotionStatics_BreakLocomotionCurrentStates final
{
public:
	struct FLocomotionCurrentStates               Parameters;                                        // 0x0000(0x0009)(Parm, NoDestructor, NativeAccessSpecifierPublic)
	EMovementMode                                 PawnMovementMode;                                  // 0x0009(0x0001)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ELocomotionMovementState                      MovementState;                                     // 0x000A(0x0001)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ELocomotionMovementState                      PrevMovementState;                                 // 0x000B(0x0001)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ELocomotionMovementAction                     MovementAction;                                    // 0x000C(0x0001)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ELocomotionRotationMode                       RotationMode;                                      // 0x000D(0x0001)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ELocomotionGait                               ActualGait;                                        // 0x000E(0x0001)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ELocomotionStance                             ActualStance;                                      // 0x000F(0x0001)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ELocomotionViewMode                           ViewMode;                                          // 0x0010(0x0001)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ELocomotionOverlayState                       OverlayState;                                      // 0x0011(0x0001)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzLocomotionStatics_BreakLocomotionCurrentStates) == 0x000001, "Wrong alignment on GzLocomotionStatics_BreakLocomotionCurrentStates");
static_assert(sizeof(GzLocomotionStatics_BreakLocomotionCurrentStates) == 0x000012, "Wrong size on GzLocomotionStatics_BreakLocomotionCurrentStates");
static_assert(offsetof(GzLocomotionStatics_BreakLocomotionCurrentStates, Parameters) == 0x000000, "Member 'GzLocomotionStatics_BreakLocomotionCurrentStates::Parameters' has a wrong offset!");
static_assert(offsetof(GzLocomotionStatics_BreakLocomotionCurrentStates, PawnMovementMode) == 0x000009, "Member 'GzLocomotionStatics_BreakLocomotionCurrentStates::PawnMovementMode' has a wrong offset!");
static_assert(offsetof(GzLocomotionStatics_BreakLocomotionCurrentStates, MovementState) == 0x00000A, "Member 'GzLocomotionStatics_BreakLocomotionCurrentStates::MovementState' has a wrong offset!");
static_assert(offsetof(GzLocomotionStatics_BreakLocomotionCurrentStates, PrevMovementState) == 0x00000B, "Member 'GzLocomotionStatics_BreakLocomotionCurrentStates::PrevMovementState' has a wrong offset!");
static_assert(offsetof(GzLocomotionStatics_BreakLocomotionCurrentStates, MovementAction) == 0x00000C, "Member 'GzLocomotionStatics_BreakLocomotionCurrentStates::MovementAction' has a wrong offset!");
static_assert(offsetof(GzLocomotionStatics_BreakLocomotionCurrentStates, RotationMode) == 0x00000D, "Member 'GzLocomotionStatics_BreakLocomotionCurrentStates::RotationMode' has a wrong offset!");
static_assert(offsetof(GzLocomotionStatics_BreakLocomotionCurrentStates, ActualGait) == 0x00000E, "Member 'GzLocomotionStatics_BreakLocomotionCurrentStates::ActualGait' has a wrong offset!");
static_assert(offsetof(GzLocomotionStatics_BreakLocomotionCurrentStates, ActualStance) == 0x00000F, "Member 'GzLocomotionStatics_BreakLocomotionCurrentStates::ActualStance' has a wrong offset!");
static_assert(offsetof(GzLocomotionStatics_BreakLocomotionCurrentStates, ViewMode) == 0x000010, "Member 'GzLocomotionStatics_BreakLocomotionCurrentStates::ViewMode' has a wrong offset!");
static_assert(offsetof(GzLocomotionStatics_BreakLocomotionCurrentStates, OverlayState) == 0x000011, "Member 'GzLocomotionStatics_BreakLocomotionCurrentStates::OverlayState' has a wrong offset!");

// Function G01.GzLocomotionStatics.BreakLocomotionEssentialValues
// 0x00F0 (0x00F0 - 0x0000)
struct GzLocomotionStatics_BreakLocomotionEssentialValues final
{
public:
	struct FLocomotionEssentialValues             Parameters;                                        // 0x0000(0x0078)(Parm, NoDestructor, NativeAccessSpecifierPublic)
	struct FVector                                Velocity;                                          // 0x0078(0x0018)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Acceleration;                                      // 0x0090(0x0018)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                MovementInput;                                     // 0x00A8(0x0018)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsMoving;                                         // 0x00C0(0x0001)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bHasMovementInput;                                 // 0x00C1(0x0001)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3411[0x2];                                     // 0x00C2(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Speed;                                             // 0x00C4(0x0004)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MovementInputAmount;                               // 0x00C8(0x0004)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3412[0x4];                                     // 0x00CC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRotator                               AimingRotation;                                    // 0x00D0(0x0018)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, NativeAccessSpecifierPublic)
	float                                         AimYawRate;                                        // 0x00E8(0x0004)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3413[0x4];                                     // 0x00EC(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GzLocomotionStatics_BreakLocomotionEssentialValues) == 0x000008, "Wrong alignment on GzLocomotionStatics_BreakLocomotionEssentialValues");
static_assert(sizeof(GzLocomotionStatics_BreakLocomotionEssentialValues) == 0x0000F0, "Wrong size on GzLocomotionStatics_BreakLocomotionEssentialValues");
static_assert(offsetof(GzLocomotionStatics_BreakLocomotionEssentialValues, Parameters) == 0x000000, "Member 'GzLocomotionStatics_BreakLocomotionEssentialValues::Parameters' has a wrong offset!");
static_assert(offsetof(GzLocomotionStatics_BreakLocomotionEssentialValues, Velocity) == 0x000078, "Member 'GzLocomotionStatics_BreakLocomotionEssentialValues::Velocity' has a wrong offset!");
static_assert(offsetof(GzLocomotionStatics_BreakLocomotionEssentialValues, Acceleration) == 0x000090, "Member 'GzLocomotionStatics_BreakLocomotionEssentialValues::Acceleration' has a wrong offset!");
static_assert(offsetof(GzLocomotionStatics_BreakLocomotionEssentialValues, MovementInput) == 0x0000A8, "Member 'GzLocomotionStatics_BreakLocomotionEssentialValues::MovementInput' has a wrong offset!");
static_assert(offsetof(GzLocomotionStatics_BreakLocomotionEssentialValues, bIsMoving) == 0x0000C0, "Member 'GzLocomotionStatics_BreakLocomotionEssentialValues::bIsMoving' has a wrong offset!");
static_assert(offsetof(GzLocomotionStatics_BreakLocomotionEssentialValues, bHasMovementInput) == 0x0000C1, "Member 'GzLocomotionStatics_BreakLocomotionEssentialValues::bHasMovementInput' has a wrong offset!");
static_assert(offsetof(GzLocomotionStatics_BreakLocomotionEssentialValues, Speed) == 0x0000C4, "Member 'GzLocomotionStatics_BreakLocomotionEssentialValues::Speed' has a wrong offset!");
static_assert(offsetof(GzLocomotionStatics_BreakLocomotionEssentialValues, MovementInputAmount) == 0x0000C8, "Member 'GzLocomotionStatics_BreakLocomotionEssentialValues::MovementInputAmount' has a wrong offset!");
static_assert(offsetof(GzLocomotionStatics_BreakLocomotionEssentialValues, AimingRotation) == 0x0000D0, "Member 'GzLocomotionStatics_BreakLocomotionEssentialValues::AimingRotation' has a wrong offset!");
static_assert(offsetof(GzLocomotionStatics_BreakLocomotionEssentialValues, AimYawRate) == 0x0000E8, "Member 'GzLocomotionStatics_BreakLocomotionEssentialValues::AimYawRate' has a wrong offset!");

// Function G01.GzLocomotionStatics.GetAllAnimMetaData
// 0x0018 (0x0018 - 0x0000)
struct GzLocomotionStatics_GetAllAnimMetaData final
{
public:
	class UAnimationAsset*                        Animation;                                         // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class UAnimMetaData*>                  ReturnValue;                                       // 0x0008(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzLocomotionStatics_GetAllAnimMetaData) == 0x000008, "Wrong alignment on GzLocomotionStatics_GetAllAnimMetaData");
static_assert(sizeof(GzLocomotionStatics_GetAllAnimMetaData) == 0x000018, "Wrong size on GzLocomotionStatics_GetAllAnimMetaData");
static_assert(offsetof(GzLocomotionStatics_GetAllAnimMetaData, Animation) == 0x000000, "Member 'GzLocomotionStatics_GetAllAnimMetaData::Animation' has a wrong offset!");
static_assert(offsetof(GzLocomotionStatics_GetAllAnimMetaData, ReturnValue) == 0x000008, "Member 'GzLocomotionStatics_GetAllAnimMetaData::ReturnValue' has a wrong offset!");

// Function G01.GzLocomotionStatics.GetAnimMetaDataByClass
// 0x0018 (0x0018 - 0x0000)
struct GzLocomotionStatics_GetAnimMetaDataByClass final
{
public:
	class UAnimationAsset*                        Animation;                                         // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UGzTraversalAnimMetaData>   MetaDataClass;                                     // 0x0008(0x0008)(Parm, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UGzTraversalAnimMetaData*               ReturnValue;                                       // 0x0010(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzLocomotionStatics_GetAnimMetaDataByClass) == 0x000008, "Wrong alignment on GzLocomotionStatics_GetAnimMetaDataByClass");
static_assert(sizeof(GzLocomotionStatics_GetAnimMetaDataByClass) == 0x000018, "Wrong size on GzLocomotionStatics_GetAnimMetaDataByClass");
static_assert(offsetof(GzLocomotionStatics_GetAnimMetaDataByClass, Animation) == 0x000000, "Member 'GzLocomotionStatics_GetAnimMetaDataByClass::Animation' has a wrong offset!");
static_assert(offsetof(GzLocomotionStatics_GetAnimMetaDataByClass, MetaDataClass) == 0x000008, "Member 'GzLocomotionStatics_GetAnimMetaDataByClass::MetaDataClass' has a wrong offset!");
static_assert(offsetof(GzLocomotionStatics_GetAnimMetaDataByClass, ReturnValue) == 0x000010, "Member 'GzLocomotionStatics_GetAnimMetaDataByClass::ReturnValue' has a wrong offset!");

// Function G01.GzMTW_Condition.OnConditionStateChanged
// 0x0001 (0x0001 - 0x0000)
struct GzMTW_Condition_OnConditionStateChanged final
{
public:
	EGzConditionState                             NewState;                                          // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzMTW_Condition_OnConditionStateChanged) == 0x000001, "Wrong alignment on GzMTW_Condition_OnConditionStateChanged");
static_assert(sizeof(GzMTW_Condition_OnConditionStateChanged) == 0x000001, "Wrong size on GzMTW_Condition_OnConditionStateChanged");
static_assert(offsetof(GzMTW_Condition_OnConditionStateChanged, NewState) == 0x000000, "Member 'GzMTW_Condition_OnConditionStateChanged::NewState' has a wrong offset!");

// Function G01.GzMTW_Condition.OnStateChanged_BP
// 0x0001 (0x0001 - 0x0000)
struct GzMTW_Condition_OnStateChanged_BP final
{
public:
	EGzConditionState                             NewState;                                          // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzMTW_Condition_OnStateChanged_BP) == 0x000001, "Wrong alignment on GzMTW_Condition_OnStateChanged_BP");
static_assert(sizeof(GzMTW_Condition_OnStateChanged_BP) == 0x000001, "Wrong size on GzMTW_Condition_OnStateChanged_BP");
static_assert(offsetof(GzMTW_Condition_OnStateChanged_BP, NewState) == 0x000000, "Member 'GzMTW_Condition_OnStateChanged_BP::NewState' has a wrong offset!");

// Function G01.GzMTW_Condition.GetConditionState
// 0x0001 (0x0001 - 0x0000)
struct GzMTW_Condition_GetConditionState final
{
public:
	EGzConditionState                             ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzMTW_Condition_GetConditionState) == 0x000001, "Wrong alignment on GzMTW_Condition_GetConditionState");
static_assert(sizeof(GzMTW_Condition_GetConditionState) == 0x000001, "Wrong size on GzMTW_Condition_GetConditionState");
static_assert(offsetof(GzMTW_Condition_GetConditionState, ReturnValue) == 0x000000, "Member 'GzMTW_Condition_GetConditionState::ReturnValue' has a wrong offset!");

// Function G01.GzMTW_Condition.IsInActiveState
// 0x0002 (0x0002 - 0x0000)
struct GzMTW_Condition_IsInActiveState final
{
public:
	EGzConditionState                             State;                                             // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0001(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzMTW_Condition_IsInActiveState) == 0x000001, "Wrong alignment on GzMTW_Condition_IsInActiveState");
static_assert(sizeof(GzMTW_Condition_IsInActiveState) == 0x000002, "Wrong size on GzMTW_Condition_IsInActiveState");
static_assert(offsetof(GzMTW_Condition_IsInActiveState, State) == 0x000000, "Member 'GzMTW_Condition_IsInActiveState::State' has a wrong offset!");
static_assert(offsetof(GzMTW_Condition_IsInActiveState, ReturnValue) == 0x000001, "Member 'GzMTW_Condition_IsInActiveState::ReturnValue' has a wrong offset!");

// Function G01.GzMTW_Container.OnChildStateChanged
// 0x0001 (0x0001 - 0x0000)
struct GzMTW_Container_OnChildStateChanged final
{
public:
	bool                                          bNewActive;                                        // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzMTW_Container_OnChildStateChanged) == 0x000001, "Wrong alignment on GzMTW_Container_OnChildStateChanged");
static_assert(sizeof(GzMTW_Container_OnChildStateChanged) == 0x000001, "Wrong size on GzMTW_Container_OnChildStateChanged");
static_assert(offsetof(GzMTW_Container_OnChildStateChanged, bNewActive) == 0x000000, "Member 'GzMTW_Container_OnChildStateChanged::bNewActive' has a wrong offset!");

// Function G01.GzMTW_Decorator.OnChildStateChanged
// 0x0001 (0x0001 - 0x0000)
struct GzMTW_Decorator_OnChildStateChanged final
{
public:
	bool                                          bNewActive;                                        // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzMTW_Decorator_OnChildStateChanged) == 0x000001, "Wrong alignment on GzMTW_Decorator_OnChildStateChanged");
static_assert(sizeof(GzMTW_Decorator_OnChildStateChanged) == 0x000001, "Wrong size on GzMTW_Decorator_OnChildStateChanged");
static_assert(offsetof(GzMTW_Decorator_OnChildStateChanged, bNewActive) == 0x000000, "Member 'GzMTW_Decorator_OnChildStateChanged::bNewActive' has a wrong offset!");

// Function G01.GzMTW_Objective.OnObjectiveStateChanged
// 0x0001 (0x0001 - 0x0000)
struct GzMTW_Objective_OnObjectiveStateChanged final
{
public:
	EGzObjectiveState                             NewState;                                          // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzMTW_Objective_OnObjectiveStateChanged) == 0x000001, "Wrong alignment on GzMTW_Objective_OnObjectiveStateChanged");
static_assert(sizeof(GzMTW_Objective_OnObjectiveStateChanged) == 0x000001, "Wrong size on GzMTW_Objective_OnObjectiveStateChanged");
static_assert(offsetof(GzMTW_Objective_OnObjectiveStateChanged, NewState) == 0x000000, "Member 'GzMTW_Objective_OnObjectiveStateChanged::NewState' has a wrong offset!");

// Function G01.GzMTW_Objective.OnStateChanged_BP
// 0x0001 (0x0001 - 0x0000)
struct GzMTW_Objective_OnStateChanged_BP final
{
public:
	EGzObjectiveState                             NewState;                                          // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzMTW_Objective_OnStateChanged_BP) == 0x000001, "Wrong alignment on GzMTW_Objective_OnStateChanged_BP");
static_assert(sizeof(GzMTW_Objective_OnStateChanged_BP) == 0x000001, "Wrong size on GzMTW_Objective_OnStateChanged_BP");
static_assert(offsetof(GzMTW_Objective_OnStateChanged_BP, NewState) == 0x000000, "Member 'GzMTW_Objective_OnStateChanged_BP::NewState' has a wrong offset!");

// Function G01.GzMTW_Objective.GetObjectiveState
// 0x0001 (0x0001 - 0x0000)
struct GzMTW_Objective_GetObjectiveState final
{
public:
	EGzObjectiveState                             ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzMTW_Objective_GetObjectiveState) == 0x000001, "Wrong alignment on GzMTW_Objective_GetObjectiveState");
static_assert(sizeof(GzMTW_Objective_GetObjectiveState) == 0x000001, "Wrong size on GzMTW_Objective_GetObjectiveState");
static_assert(offsetof(GzMTW_Objective_GetObjectiveState, ReturnValue) == 0x000000, "Member 'GzMTW_Objective_GetObjectiveState::ReturnValue' has a wrong offset!");

// Function G01.GzMTW_Objective.IsInActiveState
// 0x0002 (0x0002 - 0x0000)
struct GzMTW_Objective_IsInActiveState final
{
public:
	EGzObjectiveState                             State;                                             // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0001(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzMTW_Objective_IsInActiveState) == 0x000001, "Wrong alignment on GzMTW_Objective_IsInActiveState");
static_assert(sizeof(GzMTW_Objective_IsInActiveState) == 0x000002, "Wrong size on GzMTW_Objective_IsInActiveState");
static_assert(offsetof(GzMTW_Objective_IsInActiveState, State) == 0x000000, "Member 'GzMTW_Objective_IsInActiveState::State' has a wrong offset!");
static_assert(offsetof(GzMTW_Objective_IsInActiveState, ReturnValue) == 0x000001, "Member 'GzMTW_Objective_IsInActiveState::ReturnValue' has a wrong offset!");

// Function G01.LocomotionAnimationInterface.SetGroundedEntryState
// 0x0001 (0x0001 - 0x0000)
struct LocomotionAnimationInterface_SetGroundedEntryState final
{
public:
	ELocomotionGroundedEntryState                 EntryState;                                        // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LocomotionAnimationInterface_SetGroundedEntryState) == 0x000001, "Wrong alignment on LocomotionAnimationInterface_SetGroundedEntryState");
static_assert(sizeof(LocomotionAnimationInterface_SetGroundedEntryState) == 0x000001, "Wrong size on LocomotionAnimationInterface_SetGroundedEntryState");
static_assert(offsetof(LocomotionAnimationInterface_SetGroundedEntryState, EntryState) == 0x000000, "Member 'LocomotionAnimationInterface_SetGroundedEntryState::EntryState' has a wrong offset!");

// Function G01.LocomotionAnimationInterface.SetOverlayOverrideState
// 0x0004 (0x0004 - 0x0000)
struct LocomotionAnimationInterface_SetOverlayOverrideState final
{
public:
	int32                                         OverlayOverride;                                   // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LocomotionAnimationInterface_SetOverlayOverrideState) == 0x000004, "Wrong alignment on LocomotionAnimationInterface_SetOverlayOverrideState");
static_assert(sizeof(LocomotionAnimationInterface_SetOverlayOverrideState) == 0x000004, "Wrong size on LocomotionAnimationInterface_SetOverlayOverrideState");
static_assert(offsetof(LocomotionAnimationInterface_SetOverlayOverrideState, OverlayOverride) == 0x000000, "Member 'LocomotionAnimationInterface_SetOverlayOverrideState::OverlayOverride' has a wrong offset!");

// Function G01.GzNavigationRoot.GetNavigationRoot
// 0x0010 (0x0010 - 0x0000)
struct GzNavigationRoot_GetNavigationRoot final
{
public:
	const class UObject*                          WorldContextObject;                                // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UGzNavigationRoot*                      ReturnValue;                                       // 0x0008(0x0008)(ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzNavigationRoot_GetNavigationRoot) == 0x000008, "Wrong alignment on GzNavigationRoot_GetNavigationRoot");
static_assert(sizeof(GzNavigationRoot_GetNavigationRoot) == 0x000010, "Wrong size on GzNavigationRoot_GetNavigationRoot");
static_assert(offsetof(GzNavigationRoot_GetNavigationRoot, WorldContextObject) == 0x000000, "Member 'GzNavigationRoot_GetNavigationRoot::WorldContextObject' has a wrong offset!");
static_assert(offsetof(GzNavigationRoot_GetNavigationRoot, ReturnValue) == 0x000008, "Member 'GzNavigationRoot_GetNavigationRoot::ReturnValue' has a wrong offset!");

// Function G01.GzNavigationRoot.AddWidget
// 0x0008 (0x0008 - 0x0000)
struct GzNavigationRoot_AddWidget final
{
public:
	class UGzNavigationWidget*                    Widget;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzNavigationRoot_AddWidget) == 0x000008, "Wrong alignment on GzNavigationRoot_AddWidget");
static_assert(sizeof(GzNavigationRoot_AddWidget) == 0x000008, "Wrong size on GzNavigationRoot_AddWidget");
static_assert(offsetof(GzNavigationRoot_AddWidget, Widget) == 0x000000, "Member 'GzNavigationRoot_AddWidget::Widget' has a wrong offset!");

// Function G01.GzNavigationRoot.AddWidgetCached
// 0x0010 (0x0010 - 0x0000)
struct GzNavigationRoot_AddWidgetCached final
{
public:
	TSubclassOf<class UGzNavigationWidget>        WidgetClass;                                       // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UGzNavigationWidget*                    ReturnValue;                                       // 0x0008(0x0008)(ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzNavigationRoot_AddWidgetCached) == 0x000008, "Wrong alignment on GzNavigationRoot_AddWidgetCached");
static_assert(sizeof(GzNavigationRoot_AddWidgetCached) == 0x000010, "Wrong size on GzNavigationRoot_AddWidgetCached");
static_assert(offsetof(GzNavigationRoot_AddWidgetCached, WidgetClass) == 0x000000, "Member 'GzNavigationRoot_AddWidgetCached::WidgetClass' has a wrong offset!");
static_assert(offsetof(GzNavigationRoot_AddWidgetCached, ReturnValue) == 0x000008, "Member 'GzNavigationRoot_AddWidgetCached::ReturnValue' has a wrong offset!");

// Function G01.GzNavigationRoot.AddWidgetSoft
// 0x0038 (0x0038 - 0x0000)
struct GzNavigationRoot_AddWidgetSoft final
{
public:
	TSoftClassPtr<class UClass>                   WidgetClass;                                       // 0x0000(0x0028)(Parm, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TDelegate<void(class UGzNavigationWidget* NavigationWidget)> Delegate;                                          // 0x0028(0x0010)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzNavigationRoot_AddWidgetSoft) == 0x000008, "Wrong alignment on GzNavigationRoot_AddWidgetSoft");
static_assert(sizeof(GzNavigationRoot_AddWidgetSoft) == 0x000038, "Wrong size on GzNavigationRoot_AddWidgetSoft");
static_assert(offsetof(GzNavigationRoot_AddWidgetSoft, WidgetClass) == 0x000000, "Member 'GzNavigationRoot_AddWidgetSoft::WidgetClass' has a wrong offset!");
static_assert(offsetof(GzNavigationRoot_AddWidgetSoft, Delegate) == 0x000028, "Member 'GzNavigationRoot_AddWidgetSoft::Delegate' has a wrong offset!");

// Function G01.GzNavigationRoot.AddWidgetToLayer
// 0x0010 (0x0010 - 0x0000)
struct GzNavigationRoot_AddWidgetToLayer final
{
public:
	class FName                                   Layer;                                             // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UGzNavigationWidget*                    Widget;                                            // 0x0008(0x0008)(Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzNavigationRoot_AddWidgetToLayer) == 0x000008, "Wrong alignment on GzNavigationRoot_AddWidgetToLayer");
static_assert(sizeof(GzNavigationRoot_AddWidgetToLayer) == 0x000010, "Wrong size on GzNavigationRoot_AddWidgetToLayer");
static_assert(offsetof(GzNavigationRoot_AddWidgetToLayer, Layer) == 0x000000, "Member 'GzNavigationRoot_AddWidgetToLayer::Layer' has a wrong offset!");
static_assert(offsetof(GzNavigationRoot_AddWidgetToLayer, Widget) == 0x000008, "Member 'GzNavigationRoot_AddWidgetToLayer::Widget' has a wrong offset!");

// Function G01.GzNavigationRoot.AddWidgetToLayerCached
// 0x0018 (0x0018 - 0x0000)
struct GzNavigationRoot_AddWidgetToLayerCached final
{
public:
	class FName                                   Layer;                                             // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UGzNavigationWidget>        WidgetClass;                                       // 0x0008(0x0008)(Parm, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UGzNavigationWidget*                    ReturnValue;                                       // 0x0010(0x0008)(ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzNavigationRoot_AddWidgetToLayerCached) == 0x000008, "Wrong alignment on GzNavigationRoot_AddWidgetToLayerCached");
static_assert(sizeof(GzNavigationRoot_AddWidgetToLayerCached) == 0x000018, "Wrong size on GzNavigationRoot_AddWidgetToLayerCached");
static_assert(offsetof(GzNavigationRoot_AddWidgetToLayerCached, Layer) == 0x000000, "Member 'GzNavigationRoot_AddWidgetToLayerCached::Layer' has a wrong offset!");
static_assert(offsetof(GzNavigationRoot_AddWidgetToLayerCached, WidgetClass) == 0x000008, "Member 'GzNavigationRoot_AddWidgetToLayerCached::WidgetClass' has a wrong offset!");
static_assert(offsetof(GzNavigationRoot_AddWidgetToLayerCached, ReturnValue) == 0x000010, "Member 'GzNavigationRoot_AddWidgetToLayerCached::ReturnValue' has a wrong offset!");

// Function G01.GzNavigationRoot.AddWidgetToLayerSoft
// 0x0040 (0x0040 - 0x0000)
struct GzNavigationRoot_AddWidgetToLayerSoft final
{
public:
	class FName                                   Layer;                                             // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftClassPtr<class UClass>                   WidgetClass;                                       // 0x0008(0x0028)(Parm, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TDelegate<void(class UGzNavigationWidget* NavigationWidget)> Delegate;                                          // 0x0030(0x0010)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzNavigationRoot_AddWidgetToLayerSoft) == 0x000008, "Wrong alignment on GzNavigationRoot_AddWidgetToLayerSoft");
static_assert(sizeof(GzNavigationRoot_AddWidgetToLayerSoft) == 0x000040, "Wrong size on GzNavigationRoot_AddWidgetToLayerSoft");
static_assert(offsetof(GzNavigationRoot_AddWidgetToLayerSoft, Layer) == 0x000000, "Member 'GzNavigationRoot_AddWidgetToLayerSoft::Layer' has a wrong offset!");
static_assert(offsetof(GzNavigationRoot_AddWidgetToLayerSoft, WidgetClass) == 0x000008, "Member 'GzNavigationRoot_AddWidgetToLayerSoft::WidgetClass' has a wrong offset!");
static_assert(offsetof(GzNavigationRoot_AddWidgetToLayerSoft, Delegate) == 0x000030, "Member 'GzNavigationRoot_AddWidgetToLayerSoft::Delegate' has a wrong offset!");

// Function G01.GzNavigationRoot.EnableAnalogCursor
// 0x0008 (0x0008 - 0x0000)
struct GzNavigationRoot_EnableAnalogCursor final
{
public:
	const class UWidget*                          ContextWidget;                                     // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzNavigationRoot_EnableAnalogCursor) == 0x000008, "Wrong alignment on GzNavigationRoot_EnableAnalogCursor");
static_assert(sizeof(GzNavigationRoot_EnableAnalogCursor) == 0x000008, "Wrong size on GzNavigationRoot_EnableAnalogCursor");
static_assert(offsetof(GzNavigationRoot_EnableAnalogCursor, ContextWidget) == 0x000000, "Member 'GzNavigationRoot_EnableAnalogCursor::ContextWidget' has a wrong offset!");

// Function G01.GzNavigationRoot.GetAllByClass
// 0x0018 (0x0018 - 0x0000)
struct GzNavigationRoot_GetAllByClass final
{
public:
	TSubclassOf<class UGzNavigationWidget>        WidgetClass;                                       // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class UGzNavigationWidget*>            ReturnValue;                                       // 0x0008(0x0010)(ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzNavigationRoot_GetAllByClass) == 0x000008, "Wrong alignment on GzNavigationRoot_GetAllByClass");
static_assert(sizeof(GzNavigationRoot_GetAllByClass) == 0x000018, "Wrong size on GzNavigationRoot_GetAllByClass");
static_assert(offsetof(GzNavigationRoot_GetAllByClass, WidgetClass) == 0x000000, "Member 'GzNavigationRoot_GetAllByClass::WidgetClass' has a wrong offset!");
static_assert(offsetof(GzNavigationRoot_GetAllByClass, ReturnValue) == 0x000008, "Member 'GzNavigationRoot_GetAllByClass::ReturnValue' has a wrong offset!");

// Function G01.GzNavigationRoot.GetFirstByClass
// 0x0010 (0x0010 - 0x0000)
struct GzNavigationRoot_GetFirstByClass final
{
public:
	TSubclassOf<class UGzNavigationWidget>        WidgetClass;                                       // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UGzNavigationWidget*                    ReturnValue;                                       // 0x0008(0x0008)(ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzNavigationRoot_GetFirstByClass) == 0x000008, "Wrong alignment on GzNavigationRoot_GetFirstByClass");
static_assert(sizeof(GzNavigationRoot_GetFirstByClass) == 0x000010, "Wrong size on GzNavigationRoot_GetFirstByClass");
static_assert(offsetof(GzNavigationRoot_GetFirstByClass, WidgetClass) == 0x000000, "Member 'GzNavigationRoot_GetFirstByClass::WidgetClass' has a wrong offset!");
static_assert(offsetof(GzNavigationRoot_GetFirstByClass, ReturnValue) == 0x000008, "Member 'GzNavigationRoot_GetFirstByClass::ReturnValue' has a wrong offset!");

// Function G01.GzNavigationRoot.OnWidgetPreloaded
// 0x0008 (0x0008 - 0x0000)
struct GzNavigationRoot_OnWidgetPreloaded final
{
public:
	class UGzNavigationWidget*                    NavigationWidget;                                  // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzNavigationRoot_OnWidgetPreloaded) == 0x000008, "Wrong alignment on GzNavigationRoot_OnWidgetPreloaded");
static_assert(sizeof(GzNavigationRoot_OnWidgetPreloaded) == 0x000008, "Wrong size on GzNavigationRoot_OnWidgetPreloaded");
static_assert(offsetof(GzNavigationRoot_OnWidgetPreloaded, NavigationWidget) == 0x000000, "Member 'GzNavigationRoot_OnWidgetPreloaded::NavigationWidget' has a wrong offset!");

// Function G01.GzNavigationRoot.PopUIInputMapping
// 0x0008 (0x0008 - 0x0000)
struct GzNavigationRoot_PopUIInputMapping final
{
public:
	class UGzInputControlsComponent*              ControlsComp;                                      // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzNavigationRoot_PopUIInputMapping) == 0x000008, "Wrong alignment on GzNavigationRoot_PopUIInputMapping");
static_assert(sizeof(GzNavigationRoot_PopUIInputMapping) == 0x000008, "Wrong size on GzNavigationRoot_PopUIInputMapping");
static_assert(offsetof(GzNavigationRoot_PopUIInputMapping, ControlsComp) == 0x000000, "Member 'GzNavigationRoot_PopUIInputMapping::ControlsComp' has a wrong offset!");

// Function G01.GzNavigationRoot.PopWidgetFromLayer
// 0x0008 (0x0008 - 0x0000)
struct GzNavigationRoot_PopWidgetFromLayer final
{
public:
	class FName                                   Layer;                                             // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzNavigationRoot_PopWidgetFromLayer) == 0x000004, "Wrong alignment on GzNavigationRoot_PopWidgetFromLayer");
static_assert(sizeof(GzNavigationRoot_PopWidgetFromLayer) == 0x000008, "Wrong size on GzNavigationRoot_PopWidgetFromLayer");
static_assert(offsetof(GzNavigationRoot_PopWidgetFromLayer, Layer) == 0x000000, "Member 'GzNavigationRoot_PopWidgetFromLayer::Layer' has a wrong offset!");

// Function G01.GzNavigationRoot.PushUIInputMapping
// 0x0008 (0x0008 - 0x0000)
struct GzNavigationRoot_PushUIInputMapping final
{
public:
	class UGzInputControlsComponent*              ControlsComp;                                      // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzNavigationRoot_PushUIInputMapping) == 0x000008, "Wrong alignment on GzNavigationRoot_PushUIInputMapping");
static_assert(sizeof(GzNavigationRoot_PushUIInputMapping) == 0x000008, "Wrong size on GzNavigationRoot_PushUIInputMapping");
static_assert(offsetof(GzNavigationRoot_PushUIInputMapping, ControlsComp) == 0x000000, "Member 'GzNavigationRoot_PushUIInputMapping::ControlsComp' has a wrong offset!");

// Function G01.GzNavigationRoot.RemoveAllByClass
// 0x0008 (0x0008 - 0x0000)
struct GzNavigationRoot_RemoveAllByClass final
{
public:
	TSubclassOf<class UGzNavigationWidget>        WidgetClass;                                       // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzNavigationRoot_RemoveAllByClass) == 0x000008, "Wrong alignment on GzNavigationRoot_RemoveAllByClass");
static_assert(sizeof(GzNavigationRoot_RemoveAllByClass) == 0x000008, "Wrong size on GzNavigationRoot_RemoveAllByClass");
static_assert(offsetof(GzNavigationRoot_RemoveAllByClass, WidgetClass) == 0x000000, "Member 'GzNavigationRoot_RemoveAllByClass::WidgetClass' has a wrong offset!");

// Function G01.GzNavigationRoot.RemoveFirstByClass
// 0x0008 (0x0008 - 0x0000)
struct GzNavigationRoot_RemoveFirstByClass final
{
public:
	TSubclassOf<class UGzNavigationWidget>        WidgetClass;                                       // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzNavigationRoot_RemoveFirstByClass) == 0x000008, "Wrong alignment on GzNavigationRoot_RemoveFirstByClass");
static_assert(sizeof(GzNavigationRoot_RemoveFirstByClass) == 0x000008, "Wrong size on GzNavigationRoot_RemoveFirstByClass");
static_assert(offsetof(GzNavigationRoot_RemoveFirstByClass, WidgetClass) == 0x000000, "Member 'GzNavigationRoot_RemoveFirstByClass::WidgetClass' has a wrong offset!");

// Function G01.GzNavigationRoot.RemoveWidget
// 0x0008 (0x0008 - 0x0000)
struct GzNavigationRoot_RemoveWidget final
{
public:
	class UGzNavigationWidget*                    Widget;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzNavigationRoot_RemoveWidget) == 0x000008, "Wrong alignment on GzNavigationRoot_RemoveWidget");
static_assert(sizeof(GzNavigationRoot_RemoveWidget) == 0x000008, "Wrong size on GzNavigationRoot_RemoveWidget");
static_assert(offsetof(GzNavigationRoot_RemoveWidget, Widget) == 0x000000, "Member 'GzNavigationRoot_RemoveWidget::Widget' has a wrong offset!");

// Function G01.GzNavigationRoot.RemoveWidgetFromLayer
// 0x0010 (0x0010 - 0x0000)
struct GzNavigationRoot_RemoveWidgetFromLayer final
{
public:
	class FName                                   Layer;                                             // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UGzNavigationWidget*                    Widget;                                            // 0x0008(0x0008)(Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzNavigationRoot_RemoveWidgetFromLayer) == 0x000008, "Wrong alignment on GzNavigationRoot_RemoveWidgetFromLayer");
static_assert(sizeof(GzNavigationRoot_RemoveWidgetFromLayer) == 0x000010, "Wrong size on GzNavigationRoot_RemoveWidgetFromLayer");
static_assert(offsetof(GzNavigationRoot_RemoveWidgetFromLayer, Layer) == 0x000000, "Member 'GzNavigationRoot_RemoveWidgetFromLayer::Layer' has a wrong offset!");
static_assert(offsetof(GzNavigationRoot_RemoveWidgetFromLayer, Widget) == 0x000008, "Member 'GzNavigationRoot_RemoveWidgetFromLayer::Widget' has a wrong offset!");

// Function G01.GzNavigationRoot.SetAnalogCursorWidget
// 0x0008 (0x0008 - 0x0000)
struct GzNavigationRoot_SetAnalogCursorWidget final
{
public:
	class UUserWidget*                            InAnalogCursorWidget;                              // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzNavigationRoot_SetAnalogCursorWidget) == 0x000008, "Wrong alignment on GzNavigationRoot_SetAnalogCursorWidget");
static_assert(sizeof(GzNavigationRoot_SetAnalogCursorWidget) == 0x000008, "Wrong size on GzNavigationRoot_SetAnalogCursorWidget");
static_assert(offsetof(GzNavigationRoot_SetAnalogCursorWidget, InAnalogCursorWidget) == 0x000000, "Member 'GzNavigationRoot_SetAnalogCursorWidget::InAnalogCursorWidget' has a wrong offset!");

// Function G01.GzNavigationRoot.SimulateKeyPress
// 0x0020 (0x0020 - 0x0000)
struct GzNavigationRoot_SimulateKeyPress final
{
public:
	struct FKey                                   Key;                                               // 0x0000(0x0018)(ConstParm, Parm, OutParm, ReferenceParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EInputEvent                                   InputEvent;                                        // 0x0018(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3421[0x7];                                     // 0x0019(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GzNavigationRoot_SimulateKeyPress) == 0x000008, "Wrong alignment on GzNavigationRoot_SimulateKeyPress");
static_assert(sizeof(GzNavigationRoot_SimulateKeyPress) == 0x000020, "Wrong size on GzNavigationRoot_SimulateKeyPress");
static_assert(offsetof(GzNavigationRoot_SimulateKeyPress, Key) == 0x000000, "Member 'GzNavigationRoot_SimulateKeyPress::Key' has a wrong offset!");
static_assert(offsetof(GzNavigationRoot_SimulateKeyPress, InputEvent) == 0x000018, "Member 'GzNavigationRoot_SimulateKeyPress::InputEvent' has a wrong offset!");

// Function G01.GzNavigationRoot.GetLayerStack
// 0x0010 (0x0010 - 0x0000)
struct GzNavigationRoot_GetLayerStack final
{
public:
	class FName                                   LayerName;                                         // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UGzActivatableWidgetStack*              ReturnValue;                                       // 0x0008(0x0008)(ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzNavigationRoot_GetLayerStack) == 0x000008, "Wrong alignment on GzNavigationRoot_GetLayerStack");
static_assert(sizeof(GzNavigationRoot_GetLayerStack) == 0x000010, "Wrong size on GzNavigationRoot_GetLayerStack");
static_assert(offsetof(GzNavigationRoot_GetLayerStack, LayerName) == 0x000000, "Member 'GzNavigationRoot_GetLayerStack::LayerName' has a wrong offset!");
static_assert(offsetof(GzNavigationRoot_GetLayerStack, ReturnValue) == 0x000008, "Member 'GzNavigationRoot_GetLayerStack::ReturnValue' has a wrong offset!");

// Function G01.GzNavigationRoot.GetUIMappingConfig
// 0x0008 (0x0008 - 0x0000)
struct GzNavigationRoot_GetUIMappingConfig final
{
public:
	class UGzPawnInputMappingConfig*              ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzNavigationRoot_GetUIMappingConfig) == 0x000008, "Wrong alignment on GzNavigationRoot_GetUIMappingConfig");
static_assert(sizeof(GzNavigationRoot_GetUIMappingConfig) == 0x000008, "Wrong size on GzNavigationRoot_GetUIMappingConfig");
static_assert(offsetof(GzNavigationRoot_GetUIMappingConfig, ReturnValue) == 0x000000, "Member 'GzNavigationRoot_GetUIMappingConfig::ReturnValue' has a wrong offset!");

// Function G01.GzNavigationRoot.IsTopWidget
// 0x0010 (0x0010 - 0x0000)
struct GzNavigationRoot_IsTopWidget final
{
public:
	const class UGzNavigationWidget*              Widget;                                            // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3422[0x7];                                     // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GzNavigationRoot_IsTopWidget) == 0x000008, "Wrong alignment on GzNavigationRoot_IsTopWidget");
static_assert(sizeof(GzNavigationRoot_IsTopWidget) == 0x000010, "Wrong size on GzNavigationRoot_IsTopWidget");
static_assert(offsetof(GzNavigationRoot_IsTopWidget, Widget) == 0x000000, "Member 'GzNavigationRoot_IsTopWidget::Widget' has a wrong offset!");
static_assert(offsetof(GzNavigationRoot_IsTopWidget, ReturnValue) == 0x000008, "Member 'GzNavigationRoot_IsTopWidget::ReturnValue' has a wrong offset!");

// Function G01.GzNavigationUtility.GetLayerNames
// 0x0010 (0x0010 - 0x0000)
struct GzNavigationUtility_GetLayerNames final
{
public:
	TArray<class FString>                         ReturnValue;                                       // 0x0000(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzNavigationUtility_GetLayerNames) == 0x000008, "Wrong alignment on GzNavigationUtility_GetLayerNames");
static_assert(sizeof(GzNavigationUtility_GetLayerNames) == 0x000010, "Wrong size on GzNavigationUtility_GetLayerNames");
static_assert(offsetof(GzNavigationUtility_GetLayerNames, ReturnValue) == 0x000000, "Member 'GzNavigationUtility_GetLayerNames::ReturnValue' has a wrong offset!");

// Function G01.GzNegateCondition.MakeNegateCondition
// 0x0018 (0x0018 - 0x0000)
struct GzNegateCondition_MakeNegateCondition final
{
public:
	class AGzAdvancedMission*                     Mission;                                           // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UGzCondition*                           Condition;                                         // 0x0008(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UGzCondition*                           ReturnValue;                                       // 0x0010(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzNegateCondition_MakeNegateCondition) == 0x000008, "Wrong alignment on GzNegateCondition_MakeNegateCondition");
static_assert(sizeof(GzNegateCondition_MakeNegateCondition) == 0x000018, "Wrong size on GzNegateCondition_MakeNegateCondition");
static_assert(offsetof(GzNegateCondition_MakeNegateCondition, Mission) == 0x000000, "Member 'GzNegateCondition_MakeNegateCondition::Mission' has a wrong offset!");
static_assert(offsetof(GzNegateCondition_MakeNegateCondition, Condition) == 0x000008, "Member 'GzNegateCondition_MakeNegateCondition::Condition' has a wrong offset!");
static_assert(offsetof(GzNegateCondition_MakeNegateCondition, ReturnValue) == 0x000010, "Member 'GzNegateCondition_MakeNegateCondition::ReturnValue' has a wrong offset!");

// Function G01.GzNegateObjective.MakeNegateObjective
// 0x0018 (0x0018 - 0x0000)
struct GzNegateObjective_MakeNegateObjective final
{
public:
	class AGzAdvancedMission*                     Mission;                                           // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UGzObjective*                           Objective;                                         // 0x0008(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UGzObjective*                           ReturnValue;                                       // 0x0010(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzNegateObjective_MakeNegateObjective) == 0x000008, "Wrong alignment on GzNegateObjective_MakeNegateObjective");
static_assert(sizeof(GzNegateObjective_MakeNegateObjective) == 0x000018, "Wrong size on GzNegateObjective_MakeNegateObjective");
static_assert(offsetof(GzNegateObjective_MakeNegateObjective, Mission) == 0x000000, "Member 'GzNegateObjective_MakeNegateObjective::Mission' has a wrong offset!");
static_assert(offsetof(GzNegateObjective_MakeNegateObjective, Objective) == 0x000008, "Member 'GzNegateObjective_MakeNegateObjective::Objective' has a wrong offset!");
static_assert(offsetof(GzNegateObjective_MakeNegateObjective, ReturnValue) == 0x000010, "Member 'GzNegateObjective_MakeNegateObjective::ReturnValue' has a wrong offset!");

// Function G01.GzProgressLogWidget.AddLogEntry
// 0x0010 (0x0010 - 0x0000)
struct GzProgressLogWidget_AddLogEntry final
{
public:
	TSubclassOf<class UGzProgressLogEntryWidget>  ProgressWidgetClass;                               // 0x0000(0x0008)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Duration;                                          // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Handle;                                            // 0x000C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzProgressLogWidget_AddLogEntry) == 0x000008, "Wrong alignment on GzProgressLogWidget_AddLogEntry");
static_assert(sizeof(GzProgressLogWidget_AddLogEntry) == 0x000010, "Wrong size on GzProgressLogWidget_AddLogEntry");
static_assert(offsetof(GzProgressLogWidget_AddLogEntry, ProgressWidgetClass) == 0x000000, "Member 'GzProgressLogWidget_AddLogEntry::ProgressWidgetClass' has a wrong offset!");
static_assert(offsetof(GzProgressLogWidget_AddLogEntry, Duration) == 0x000008, "Member 'GzProgressLogWidget_AddLogEntry::Duration' has a wrong offset!");
static_assert(offsetof(GzProgressLogWidget_AddLogEntry, Handle) == 0x00000C, "Member 'GzProgressLogWidget_AddLogEntry::Handle' has a wrong offset!");

// Function G01.GzProgressLogWidget.CancelProgress
// 0x0004 (0x0004 - 0x0000)
struct GzProgressLogWidget_CancelProgress final
{
public:
	int32                                         Handle;                                            // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzProgressLogWidget_CancelProgress) == 0x000004, "Wrong alignment on GzProgressLogWidget_CancelProgress");
static_assert(sizeof(GzProgressLogWidget_CancelProgress) == 0x000004, "Wrong size on GzProgressLogWidget_CancelProgress");
static_assert(offsetof(GzProgressLogWidget_CancelProgress, Handle) == 0x000000, "Member 'GzProgressLogWidget_CancelProgress::Handle' has a wrong offset!");

// Function G01.GzProgressLogWidget.UpdateEntryProgress
// 0x0008 (0x0008 - 0x0000)
struct GzProgressLogWidget_UpdateEntryProgress final
{
public:
	int32                                         Handle;                                            // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Duration;                                          // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzProgressLogWidget_UpdateEntryProgress) == 0x000004, "Wrong alignment on GzProgressLogWidget_UpdateEntryProgress");
static_assert(sizeof(GzProgressLogWidget_UpdateEntryProgress) == 0x000008, "Wrong size on GzProgressLogWidget_UpdateEntryProgress");
static_assert(offsetof(GzProgressLogWidget_UpdateEntryProgress, Handle) == 0x000000, "Member 'GzProgressLogWidget_UpdateEntryProgress::Handle' has a wrong offset!");
static_assert(offsetof(GzProgressLogWidget_UpdateEntryProgress, Duration) == 0x000004, "Member 'GzProgressLogWidget_UpdateEntryProgress::Duration' has a wrong offset!");

// Function G01.GzProjectileMovementComponent.EnableHomingLeading
// 0x0001 (0x0001 - 0x0000)
struct GzProjectileMovementComponent_EnableHomingLeading final
{
public:
	bool                                          bEnableLeading;                                    // 0x0000(0x0001)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzProjectileMovementComponent_EnableHomingLeading) == 0x000001, "Wrong alignment on GzProjectileMovementComponent_EnableHomingLeading");
static_assert(sizeof(GzProjectileMovementComponent_EnableHomingLeading) == 0x000001, "Wrong size on GzProjectileMovementComponent_EnableHomingLeading");
static_assert(offsetof(GzProjectileMovementComponent_EnableHomingLeading, bEnableLeading) == 0x000000, "Member 'GzProjectileMovementComponent_EnableHomingLeading::bEnableLeading' has a wrong offset!");

// Function G01.GzProjectileMovementComponent.SetDragEnabled
// 0x0001 (0x0001 - 0x0000)
struct GzProjectileMovementComponent_SetDragEnabled final
{
public:
	bool                                          bNewDragEnabled;                                   // 0x0000(0x0001)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzProjectileMovementComponent_SetDragEnabled) == 0x000001, "Wrong alignment on GzProjectileMovementComponent_SetDragEnabled");
static_assert(sizeof(GzProjectileMovementComponent_SetDragEnabled) == 0x000001, "Wrong size on GzProjectileMovementComponent_SetDragEnabled");
static_assert(offsetof(GzProjectileMovementComponent_SetDragEnabled, bNewDragEnabled) == 0x000000, "Member 'GzProjectileMovementComponent_SetDragEnabled::bNewDragEnabled' has a wrong offset!");

// Function G01.GzProjectileMovementComponent.SetHomingLocation
// 0x0018 (0x0018 - 0x0000)
struct GzProjectileMovementComponent_SetHomingLocation final
{
public:
	struct FVector                                NewHomingLocation;                                 // 0x0000(0x0018)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzProjectileMovementComponent_SetHomingLocation) == 0x000008, "Wrong alignment on GzProjectileMovementComponent_SetHomingLocation");
static_assert(sizeof(GzProjectileMovementComponent_SetHomingLocation) == 0x000018, "Wrong size on GzProjectileMovementComponent_SetHomingLocation");
static_assert(offsetof(GzProjectileMovementComponent_SetHomingLocation, NewHomingLocation) == 0x000000, "Member 'GzProjectileMovementComponent_SetHomingLocation::NewHomingLocation' has a wrong offset!");

// Function G01.GzProjectileMovementComponent.SetHomingMagnitudeMultiplier
// 0x0004 (0x0004 - 0x0000)
struct GzProjectileMovementComponent_SetHomingMagnitudeMultiplier final
{
public:
	float                                         NewMagnitudeMultiplier;                            // 0x0000(0x0004)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzProjectileMovementComponent_SetHomingMagnitudeMultiplier) == 0x000004, "Wrong alignment on GzProjectileMovementComponent_SetHomingMagnitudeMultiplier");
static_assert(sizeof(GzProjectileMovementComponent_SetHomingMagnitudeMultiplier) == 0x000004, "Wrong size on GzProjectileMovementComponent_SetHomingMagnitudeMultiplier");
static_assert(offsetof(GzProjectileMovementComponent_SetHomingMagnitudeMultiplier, NewMagnitudeMultiplier) == 0x000000, "Member 'GzProjectileMovementComponent_SetHomingMagnitudeMultiplier::NewMagnitudeMultiplier' has a wrong offset!");

// Function G01.GzProjectileMovementComponent.SetHomingTarget
// 0x0008 (0x0008 - 0x0000)
struct GzProjectileMovementComponent_SetHomingTarget final
{
public:
	class USceneComponent*                        TargetComponent;                                   // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzProjectileMovementComponent_SetHomingTarget) == 0x000008, "Wrong alignment on GzProjectileMovementComponent_SetHomingTarget");
static_assert(sizeof(GzProjectileMovementComponent_SetHomingTarget) == 0x000008, "Wrong size on GzProjectileMovementComponent_SetHomingTarget");
static_assert(offsetof(GzProjectileMovementComponent_SetHomingTarget, TargetComponent) == 0x000000, "Member 'GzProjectileMovementComponent_SetHomingTarget::TargetComponent' has a wrong offset!");

// Function G01.GzProjectileMovementComponent.GetDistanceToHomingTarget
// 0x0004 (0x0004 - 0x0000)
struct GzProjectileMovementComponent_GetDistanceToHomingTarget final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzProjectileMovementComponent_GetDistanceToHomingTarget) == 0x000004, "Wrong alignment on GzProjectileMovementComponent_GetDistanceToHomingTarget");
static_assert(sizeof(GzProjectileMovementComponent_GetDistanceToHomingTarget) == 0x000004, "Wrong size on GzProjectileMovementComponent_GetDistanceToHomingTarget");
static_assert(offsetof(GzProjectileMovementComponent_GetDistanceToHomingTarget, ReturnValue) == 0x000000, "Member 'GzProjectileMovementComponent_GetDistanceToHomingTarget::ReturnValue' has a wrong offset!");

// Function G01.GzProjectileMovementComponent.GetDistanceToHomingTargetSquared
// 0x0004 (0x0004 - 0x0000)
struct GzProjectileMovementComponent_GetDistanceToHomingTargetSquared final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzProjectileMovementComponent_GetDistanceToHomingTargetSquared) == 0x000004, "Wrong alignment on GzProjectileMovementComponent_GetDistanceToHomingTargetSquared");
static_assert(sizeof(GzProjectileMovementComponent_GetDistanceToHomingTargetSquared) == 0x000004, "Wrong size on GzProjectileMovementComponent_GetDistanceToHomingTargetSquared");
static_assert(offsetof(GzProjectileMovementComponent_GetDistanceToHomingTargetSquared, ReturnValue) == 0x000000, "Member 'GzProjectileMovementComponent_GetDistanceToHomingTargetSquared::ReturnValue' has a wrong offset!");

// Function G01.GzProjectileMovementComponent.GetHomingTargetLeadingLocation
// 0x0018 (0x0018 - 0x0000)
struct GzProjectileMovementComponent_GetHomingTargetLeadingLocation final
{
public:
	struct FVector                                ReturnValue;                                       // 0x0000(0x0018)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzProjectileMovementComponent_GetHomingTargetLeadingLocation) == 0x000008, "Wrong alignment on GzProjectileMovementComponent_GetHomingTargetLeadingLocation");
static_assert(sizeof(GzProjectileMovementComponent_GetHomingTargetLeadingLocation) == 0x000018, "Wrong size on GzProjectileMovementComponent_GetHomingTargetLeadingLocation");
static_assert(offsetof(GzProjectileMovementComponent_GetHomingTargetLeadingLocation, ReturnValue) == 0x000000, "Member 'GzProjectileMovementComponent_GetHomingTargetLeadingLocation::ReturnValue' has a wrong offset!");

// Function G01.GzShrinkingZoneManager.Init
// 0x0010 (0x0010 - 0x0000)
struct GzShrinkingZoneManager_Init final
{
public:
	TArray<class UGzBaseZoneStageParams*>         ZoneParams;                                        // 0x0000(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzShrinkingZoneManager_Init) == 0x000008, "Wrong alignment on GzShrinkingZoneManager_Init");
static_assert(sizeof(GzShrinkingZoneManager_Init) == 0x000010, "Wrong size on GzShrinkingZoneManager_Init");
static_assert(offsetof(GzShrinkingZoneManager_Init, ZoneParams) == 0x000000, "Member 'GzShrinkingZoneManager_Init::ZoneParams' has a wrong offset!");

// Function G01.GzShrinkingZoneManager.StartNextStage
// 0x0004 (0x0004 - 0x0000)
struct GzShrinkingZoneManager_StartNextStage final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzShrinkingZoneManager_StartNextStage) == 0x000004, "Wrong alignment on GzShrinkingZoneManager_StartNextStage");
static_assert(sizeof(GzShrinkingZoneManager_StartNextStage) == 0x000004, "Wrong size on GzShrinkingZoneManager_StartNextStage");
static_assert(offsetof(GzShrinkingZoneManager_StartNextStage, ReturnValue) == 0x000000, "Member 'GzShrinkingZoneManager_StartNextStage::ReturnValue' has a wrong offset!");

// Function G01.GzShrinkingZoneManager.CalculateTimeToGetConsumedByNextCircle
// 0x0018 (0x0018 - 0x0000)
struct GzShrinkingZoneManager_CalculateTimeToGetConsumedByNextCircle final
{
public:
	struct FVector2D                              WorldPosition;                                     // 0x0000(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         OutTime;                                           // 0x0010(0x0004)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0014(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3436[0x3];                                     // 0x0015(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GzShrinkingZoneManager_CalculateTimeToGetConsumedByNextCircle) == 0x000008, "Wrong alignment on GzShrinkingZoneManager_CalculateTimeToGetConsumedByNextCircle");
static_assert(sizeof(GzShrinkingZoneManager_CalculateTimeToGetConsumedByNextCircle) == 0x000018, "Wrong size on GzShrinkingZoneManager_CalculateTimeToGetConsumedByNextCircle");
static_assert(offsetof(GzShrinkingZoneManager_CalculateTimeToGetConsumedByNextCircle, WorldPosition) == 0x000000, "Member 'GzShrinkingZoneManager_CalculateTimeToGetConsumedByNextCircle::WorldPosition' has a wrong offset!");
static_assert(offsetof(GzShrinkingZoneManager_CalculateTimeToGetConsumedByNextCircle, OutTime) == 0x000010, "Member 'GzShrinkingZoneManager_CalculateTimeToGetConsumedByNextCircle::OutTime' has a wrong offset!");
static_assert(offsetof(GzShrinkingZoneManager_CalculateTimeToGetConsumedByNextCircle, ReturnValue) == 0x000014, "Member 'GzShrinkingZoneManager_CalculateTimeToGetConsumedByNextCircle::ReturnValue' has a wrong offset!");

// Function G01.GzShrinkingZoneManager.GetCurrentCircle
// 0x0018 (0x0018 - 0x0000)
struct GzShrinkingZoneManager_GetCurrentCircle final
{
public:
	struct FGzCircle2D                            ReturnValue;                                       // 0x0000(0x0018)(ConstParm, Parm, OutParm, ReturnParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzShrinkingZoneManager_GetCurrentCircle) == 0x000008, "Wrong alignment on GzShrinkingZoneManager_GetCurrentCircle");
static_assert(sizeof(GzShrinkingZoneManager_GetCurrentCircle) == 0x000018, "Wrong size on GzShrinkingZoneManager_GetCurrentCircle");
static_assert(offsetof(GzShrinkingZoneManager_GetCurrentCircle, ReturnValue) == 0x000000, "Member 'GzShrinkingZoneManager_GetCurrentCircle::ReturnValue' has a wrong offset!");

// Function G01.GzShrinkingZoneManager.GetCurrentStage
// 0x0004 (0x0004 - 0x0000)
struct GzShrinkingZoneManager_GetCurrentStage final
{
public:
	int32                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzShrinkingZoneManager_GetCurrentStage) == 0x000004, "Wrong alignment on GzShrinkingZoneManager_GetCurrentStage");
static_assert(sizeof(GzShrinkingZoneManager_GetCurrentStage) == 0x000004, "Wrong size on GzShrinkingZoneManager_GetCurrentStage");
static_assert(offsetof(GzShrinkingZoneManager_GetCurrentStage, ReturnValue) == 0x000000, "Member 'GzShrinkingZoneManager_GetCurrentStage::ReturnValue' has a wrong offset!");

// Function G01.GzShrinkingZoneManager.GetSpawnHeight
// 0x0004 (0x0004 - 0x0000)
struct GzShrinkingZoneManager_GetSpawnHeight final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzShrinkingZoneManager_GetSpawnHeight) == 0x000004, "Wrong alignment on GzShrinkingZoneManager_GetSpawnHeight");
static_assert(sizeof(GzShrinkingZoneManager_GetSpawnHeight) == 0x000004, "Wrong size on GzShrinkingZoneManager_GetSpawnHeight");
static_assert(offsetof(GzShrinkingZoneManager_GetSpawnHeight, ReturnValue) == 0x000000, "Member 'GzShrinkingZoneManager_GetSpawnHeight::ReturnValue' has a wrong offset!");

// Function G01.GzShrinkingZoneManager.GetStageCircle
// 0x0020 (0x0020 - 0x0000)
struct GzShrinkingZoneManager_GetStageCircle final
{
public:
	int32                                         Param_Index;                                       // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3437[0x4];                                     // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGzCircle2D                            ReturnValue;                                       // 0x0008(0x0018)(ConstParm, Parm, OutParm, ReturnParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzShrinkingZoneManager_GetStageCircle) == 0x000008, "Wrong alignment on GzShrinkingZoneManager_GetStageCircle");
static_assert(sizeof(GzShrinkingZoneManager_GetStageCircle) == 0x000020, "Wrong size on GzShrinkingZoneManager_GetStageCircle");
static_assert(offsetof(GzShrinkingZoneManager_GetStageCircle, Param_Index) == 0x000000, "Member 'GzShrinkingZoneManager_GetStageCircle::Param_Index' has a wrong offset!");
static_assert(offsetof(GzShrinkingZoneManager_GetStageCircle, ReturnValue) == 0x000008, "Member 'GzShrinkingZoneManager_GetStageCircle::ReturnValue' has a wrong offset!");

// Function G01.GzShrinkingZoneManager.GetTargetCircle
// 0x0018 (0x0018 - 0x0000)
struct GzShrinkingZoneManager_GetTargetCircle final
{
public:
	struct FGzCircle2D                            ReturnValue;                                       // 0x0000(0x0018)(ConstParm, Parm, OutParm, ReturnParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzShrinkingZoneManager_GetTargetCircle) == 0x000008, "Wrong alignment on GzShrinkingZoneManager_GetTargetCircle");
static_assert(sizeof(GzShrinkingZoneManager_GetTargetCircle) == 0x000018, "Wrong size on GzShrinkingZoneManager_GetTargetCircle");
static_assert(offsetof(GzShrinkingZoneManager_GetTargetCircle, ReturnValue) == 0x000000, "Member 'GzShrinkingZoneManager_GetTargetCircle::ReturnValue' has a wrong offset!");

// Function G01.GzShrinkingZoneManager.GetZone
// 0x0008 (0x0008 - 0x0000)
struct GzShrinkingZoneManager_GetZone final
{
public:
	class AGzShrinkingZone*                       ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzShrinkingZoneManager_GetZone) == 0x000008, "Wrong alignment on GzShrinkingZoneManager_GetZone");
static_assert(sizeof(GzShrinkingZoneManager_GetZone) == 0x000008, "Wrong size on GzShrinkingZoneManager_GetZone");
static_assert(offsetof(GzShrinkingZoneManager_GetZone, ReturnValue) == 0x000000, "Member 'GzShrinkingZoneManager_GetZone::ReturnValue' has a wrong offset!");

// Function G01.GzShrinkingZoneManager.IsShrinking
// 0x0001 (0x0001 - 0x0000)
struct GzShrinkingZoneManager_IsShrinking final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzShrinkingZoneManager_IsShrinking) == 0x000001, "Wrong alignment on GzShrinkingZoneManager_IsShrinking");
static_assert(sizeof(GzShrinkingZoneManager_IsShrinking) == 0x000001, "Wrong size on GzShrinkingZoneManager_IsShrinking");
static_assert(offsetof(GzShrinkingZoneManager_IsShrinking, ReturnValue) == 0x000000, "Member 'GzShrinkingZoneManager_IsShrinking::ReturnValue' has a wrong offset!");

// Function G01.GzPropagationComponent.GetPropagationController
// 0x0008 (0x0008 - 0x0000)
struct GzPropagationComponent_GetPropagationController final
{
public:
	class AGzSurfacePropagationController*        ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzPropagationComponent_GetPropagationController) == 0x000008, "Wrong alignment on GzPropagationComponent_GetPropagationController");
static_assert(sizeof(GzPropagationComponent_GetPropagationController) == 0x000008, "Wrong size on GzPropagationComponent_GetPropagationController");
static_assert(offsetof(GzPropagationComponent_GetPropagationController, ReturnValue) == 0x000000, "Member 'GzPropagationComponent_GetPropagationController::ReturnValue' has a wrong offset!");

// Function G01.GzNPCSpawner.AddUniqueNPC
// 0x0008 (0x0008 - 0x0000)
struct GzNPCSpawner_AddUniqueNPC final
{
public:
	class AGzAIController*                        InValue;                                           // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzNPCSpawner_AddUniqueNPC) == 0x000008, "Wrong alignment on GzNPCSpawner_AddUniqueNPC");
static_assert(sizeof(GzNPCSpawner_AddUniqueNPC) == 0x000008, "Wrong size on GzNPCSpawner_AddUniqueNPC");
static_assert(offsetof(GzNPCSpawner_AddUniqueNPC, InValue) == 0x000000, "Member 'GzNPCSpawner_AddUniqueNPC::InValue' has a wrong offset!");

// Function G01.GzNPCSpawner.SetAlwaysInAlertState
// 0x0001 (0x0001 - 0x0000)
struct GzNPCSpawner_SetAlwaysInAlertState final
{
public:
	bool                                          InValue;                                           // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzNPCSpawner_SetAlwaysInAlertState) == 0x000001, "Wrong alignment on GzNPCSpawner_SetAlwaysInAlertState");
static_assert(sizeof(GzNPCSpawner_SetAlwaysInAlertState) == 0x000001, "Wrong size on GzNPCSpawner_SetAlwaysInAlertState");
static_assert(offsetof(GzNPCSpawner_SetAlwaysInAlertState, InValue) == 0x000000, "Member 'GzNPCSpawner_SetAlwaysInAlertState::InValue' has a wrong offset!");

// Function G01.GzNPCSpawner.TrySpawn
// 0x0001 (0x0001 - 0x0000)
struct GzNPCSpawner_TrySpawn final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzNPCSpawner_TrySpawn) == 0x000001, "Wrong alignment on GzNPCSpawner_TrySpawn");
static_assert(sizeof(GzNPCSpawner_TrySpawn) == 0x000001, "Wrong size on GzNPCSpawner_TrySpawn");
static_assert(offsetof(GzNPCSpawner_TrySpawn, ReturnValue) == 0x000000, "Member 'GzNPCSpawner_TrySpawn::ReturnValue' has a wrong offset!");

// Function G01.GzNPCSpawner.CanReinforcenent
// 0x0001 (0x0001 - 0x0000)
struct GzNPCSpawner_CanReinforcenent final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzNPCSpawner_CanReinforcenent) == 0x000001, "Wrong alignment on GzNPCSpawner_CanReinforcenent");
static_assert(sizeof(GzNPCSpawner_CanReinforcenent) == 0x000001, "Wrong size on GzNPCSpawner_CanReinforcenent");
static_assert(offsetof(GzNPCSpawner_CanReinforcenent, ReturnValue) == 0x000000, "Member 'GzNPCSpawner_CanReinforcenent::ReturnValue' has a wrong offset!");

// Function G01.GzNPCSpawner.CanSpawn
// 0x0001 (0x0001 - 0x0000)
struct GzNPCSpawner_CanSpawn final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzNPCSpawner_CanSpawn) == 0x000001, "Wrong alignment on GzNPCSpawner_CanSpawn");
static_assert(sizeof(GzNPCSpawner_CanSpawn) == 0x000001, "Wrong size on GzNPCSpawner_CanSpawn");
static_assert(offsetof(GzNPCSpawner_CanSpawn, ReturnValue) == 0x000000, "Member 'GzNPCSpawner_CanSpawn::ReturnValue' has a wrong offset!");

// Function G01.GzNPCSpawner.GetAllNPCs
// 0x0010 (0x0010 - 0x0000)
struct GzNPCSpawner_GetAllNPCs final
{
public:
	TArray<class APawn*>                          ReturnValue;                                       // 0x0000(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzNPCSpawner_GetAllNPCs) == 0x000008, "Wrong alignment on GzNPCSpawner_GetAllNPCs");
static_assert(sizeof(GzNPCSpawner_GetAllNPCs) == 0x000010, "Wrong size on GzNPCSpawner_GetAllNPCs");
static_assert(offsetof(GzNPCSpawner_GetAllNPCs, ReturnValue) == 0x000000, "Member 'GzNPCSpawner_GetAllNPCs::ReturnValue' has a wrong offset!");

// Function G01.GzNPCSpawner.GetNPC
// 0x0010 (0x0010 - 0x0000)
struct GzNPCSpawner_GetNPC final
{
public:
	int32                                         Param_Index;                                       // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3441[0x4];                                     // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class APawn*                                  ReturnValue;                                       // 0x0008(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzNPCSpawner_GetNPC) == 0x000008, "Wrong alignment on GzNPCSpawner_GetNPC");
static_assert(sizeof(GzNPCSpawner_GetNPC) == 0x000010, "Wrong size on GzNPCSpawner_GetNPC");
static_assert(offsetof(GzNPCSpawner_GetNPC, Param_Index) == 0x000000, "Member 'GzNPCSpawner_GetNPC::Param_Index' has a wrong offset!");
static_assert(offsetof(GzNPCSpawner_GetNPC, ReturnValue) == 0x000008, "Member 'GzNPCSpawner_GetNPC::ReturnValue' has a wrong offset!");

// Function G01.GzNPCSpawner.GetNPCNum
// 0x0004 (0x0004 - 0x0000)
struct GzNPCSpawner_GetNPCNum final
{
public:
	int32                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzNPCSpawner_GetNPCNum) == 0x000004, "Wrong alignment on GzNPCSpawner_GetNPCNum");
static_assert(sizeof(GzNPCSpawner_GetNPCNum) == 0x000004, "Wrong size on GzNPCSpawner_GetNPCNum");
static_assert(offsetof(GzNPCSpawner_GetNPCNum, ReturnValue) == 0x000000, "Member 'GzNPCSpawner_GetNPCNum::ReturnValue' has a wrong offset!");

// Function G01.GzNPCSpawner.GetRandomNPC
// 0x0008 (0x0008 - 0x0000)
struct GzNPCSpawner_GetRandomNPC final
{
public:
	class APawn*                                  ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzNPCSpawner_GetRandomNPC) == 0x000008, "Wrong alignment on GzNPCSpawner_GetRandomNPC");
static_assert(sizeof(GzNPCSpawner_GetRandomNPC) == 0x000008, "Wrong size on GzNPCSpawner_GetRandomNPC");
static_assert(offsetof(GzNPCSpawner_GetRandomNPC, ReturnValue) == 0x000000, "Member 'GzNPCSpawner_GetRandomNPC::ReturnValue' has a wrong offset!");

// Function G01.GzNPCSpawner.GetZoneControlBox
// 0x0038 (0x0038 - 0x0000)
struct GzNPCSpawner_GetZoneControlBox final
{
public:
	struct FBox                                   ReturnValue;                                       // 0x0000(0x0038)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzNPCSpawner_GetZoneControlBox) == 0x000008, "Wrong alignment on GzNPCSpawner_GetZoneControlBox");
static_assert(sizeof(GzNPCSpawner_GetZoneControlBox) == 0x000038, "Wrong size on GzNPCSpawner_GetZoneControlBox");
static_assert(offsetof(GzNPCSpawner_GetZoneControlBox, ReturnValue) == 0x000000, "Member 'GzNPCSpawner_GetZoneControlBox::ReturnValue' has a wrong offset!");

// Function G01.GzNPCSpawner.IsEmpty
// 0x0001 (0x0001 - 0x0000)
struct GzNPCSpawner_IsEmpty final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzNPCSpawner_IsEmpty) == 0x000001, "Wrong alignment on GzNPCSpawner_IsEmpty");
static_assert(sizeof(GzNPCSpawner_IsEmpty) == 0x000001, "Wrong size on GzNPCSpawner_IsEmpty");
static_assert(offsetof(GzNPCSpawner_IsEmpty, ReturnValue) == 0x000000, "Member 'GzNPCSpawner_IsEmpty::ReturnValue' has a wrong offset!");

// Function G01.GzOfflineSessionManager.IsInOfflineSession
// 0x0001 (0x0001 - 0x0000)
struct GzOfflineSessionManager_IsInOfflineSession final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzOfflineSessionManager_IsInOfflineSession) == 0x000001, "Wrong alignment on GzOfflineSessionManager_IsInOfflineSession");
static_assert(sizeof(GzOfflineSessionManager_IsInOfflineSession) == 0x000001, "Wrong size on GzOfflineSessionManager_IsInOfflineSession");
static_assert(offsetof(GzOfflineSessionManager_IsInOfflineSession, ReturnValue) == 0x000000, "Member 'GzOfflineSessionManager_IsInOfflineSession::ReturnValue' has a wrong offset!");

// Function G01.GzZoneStatsCollector.SubmitZoneStats
// 0x0018 (0x0018 - 0x0000)
struct GzZoneStatsCollector_SubmitZoneStats final
{
public:
	int32                                         PlayerId;                                          // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3454[0x4];                                     // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGzGameStat                            Stat;                                              // 0x0008(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzZoneStatsCollector_SubmitZoneStats) == 0x000008, "Wrong alignment on GzZoneStatsCollector_SubmitZoneStats");
static_assert(sizeof(GzZoneStatsCollector_SubmitZoneStats) == 0x000018, "Wrong size on GzZoneStatsCollector_SubmitZoneStats");
static_assert(offsetof(GzZoneStatsCollector_SubmitZoneStats, PlayerId) == 0x000000, "Member 'GzZoneStatsCollector_SubmitZoneStats::PlayerId' has a wrong offset!");
static_assert(offsetof(GzZoneStatsCollector_SubmitZoneStats, Stat) == 0x000008, "Member 'GzZoneStatsCollector_SubmitZoneStats::Stat' has a wrong offset!");

// Function G01.GzRectangleMarkerShape.SetRectSize
// 0x0010 (0x0010 - 0x0000)
struct GzRectangleMarkerShape_SetRectSize final
{
public:
	struct FVector2D                              InSize;                                            // 0x0000(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzRectangleMarkerShape_SetRectSize) == 0x000008, "Wrong alignment on GzRectangleMarkerShape_SetRectSize");
static_assert(sizeof(GzRectangleMarkerShape_SetRectSize) == 0x000010, "Wrong size on GzRectangleMarkerShape_SetRectSize");
static_assert(offsetof(GzRectangleMarkerShape_SetRectSize, InSize) == 0x000000, "Member 'GzRectangleMarkerShape_SetRectSize::InSize' has a wrong offset!");

// Function G01.GzRectangleMarkerShape.GetWorldRectSize
// 0x0010 (0x0010 - 0x0000)
struct GzRectangleMarkerShape_GetWorldRectSize final
{
public:
	struct FVector2D                              ReturnValue;                                       // 0x0000(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzRectangleMarkerShape_GetWorldRectSize) == 0x000008, "Wrong alignment on GzRectangleMarkerShape_GetWorldRectSize");
static_assert(sizeof(GzRectangleMarkerShape_GetWorldRectSize) == 0x000010, "Wrong size on GzRectangleMarkerShape_GetWorldRectSize");
static_assert(offsetof(GzRectangleMarkerShape_GetWorldRectSize, ReturnValue) == 0x000000, "Member 'GzRectangleMarkerShape_GetWorldRectSize::ReturnValue' has a wrong offset!");

// Function G01.GzOverloadingZoneBordersExtension.OnZoneStartedOverload
// 0x0008 (0x0008 - 0x0000)
struct GzOverloadingZoneBordersExtension_OnZoneStartedOverload final
{
public:
	class AGzBattleRoyaleZone*                    Zone;                                              // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzOverloadingZoneBordersExtension_OnZoneStartedOverload) == 0x000008, "Wrong alignment on GzOverloadingZoneBordersExtension_OnZoneStartedOverload");
static_assert(sizeof(GzOverloadingZoneBordersExtension_OnZoneStartedOverload) == 0x000008, "Wrong size on GzOverloadingZoneBordersExtension_OnZoneStartedOverload");
static_assert(offsetof(GzOverloadingZoneBordersExtension_OnZoneStartedOverload, Zone) == 0x000000, "Member 'GzOverloadingZoneBordersExtension_OnZoneStartedOverload::Zone' has a wrong offset!");

// Function G01.GzReplicatedCommandInterface.IsReplicatedDateInitialized
// 0x0001 (0x0001 - 0x0000)
struct GzReplicatedCommandInterface_IsReplicatedDateInitialized final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzReplicatedCommandInterface_IsReplicatedDateInitialized) == 0x000001, "Wrong alignment on GzReplicatedCommandInterface_IsReplicatedDateInitialized");
static_assert(sizeof(GzReplicatedCommandInterface_IsReplicatedDateInitialized) == 0x000001, "Wrong size on GzReplicatedCommandInterface_IsReplicatedDateInitialized");
static_assert(offsetof(GzReplicatedCommandInterface_IsReplicatedDateInitialized, ReturnValue) == 0x000000, "Member 'GzReplicatedCommandInterface_IsReplicatedDateInitialized::ReturnValue' has a wrong offset!");

// Function G01.GzPartyCustomization.GetDisplayName
// 0x0018 (0x0018 - 0x0000)
struct GzPartyCustomization_GetDisplayName final
{
public:
	const class AGzCharacter*                     Character;                                         // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 ReturnValue;                                       // 0x0008(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzPartyCustomization_GetDisplayName) == 0x000008, "Wrong alignment on GzPartyCustomization_GetDisplayName");
static_assert(sizeof(GzPartyCustomization_GetDisplayName) == 0x000018, "Wrong size on GzPartyCustomization_GetDisplayName");
static_assert(offsetof(GzPartyCustomization_GetDisplayName, Character) == 0x000000, "Member 'GzPartyCustomization_GetDisplayName::Character' has a wrong offset!");
static_assert(offsetof(GzPartyCustomization_GetDisplayName, ReturnValue) == 0x000008, "Member 'GzPartyCustomization_GetDisplayName::ReturnValue' has a wrong offset!");

// Function G01.GzPartyCustomization.GetMatchmakingStatus
// 0x0010 (0x0010 - 0x0000)
struct GzPartyCustomization_GetMatchmakingStatus final
{
public:
	const class AGzCharacter*                     Character;                                         // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3459[0x7];                                     // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GzPartyCustomization_GetMatchmakingStatus) == 0x000008, "Wrong alignment on GzPartyCustomization_GetMatchmakingStatus");
static_assert(sizeof(GzPartyCustomization_GetMatchmakingStatus) == 0x000010, "Wrong size on GzPartyCustomization_GetMatchmakingStatus");
static_assert(offsetof(GzPartyCustomization_GetMatchmakingStatus, Character) == 0x000000, "Member 'GzPartyCustomization_GetMatchmakingStatus::Character' has a wrong offset!");
static_assert(offsetof(GzPartyCustomization_GetMatchmakingStatus, ReturnValue) == 0x000008, "Member 'GzPartyCustomization_GetMatchmakingStatus::ReturnValue' has a wrong offset!");

// DelegateFunction G01.GzPartyCustomization.GzMatchmakingStatusChanged__DelegateSignature
// 0x0010 (0x0010 - 0x0000)
struct GzPartyCustomization_GzMatchmakingStatusChanged__DelegateSignature final
{
public:
	const class AGzCharacter*                     Character;                                         // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bStatus;                                           // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_345A[0x7];                                     // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GzPartyCustomization_GzMatchmakingStatusChanged__DelegateSignature) == 0x000008, "Wrong alignment on GzPartyCustomization_GzMatchmakingStatusChanged__DelegateSignature");
static_assert(sizeof(GzPartyCustomization_GzMatchmakingStatusChanged__DelegateSignature) == 0x000010, "Wrong size on GzPartyCustomization_GzMatchmakingStatusChanged__DelegateSignature");
static_assert(offsetof(GzPartyCustomization_GzMatchmakingStatusChanged__DelegateSignature, Character) == 0x000000, "Member 'GzPartyCustomization_GzMatchmakingStatusChanged__DelegateSignature::Character' has a wrong offset!");
static_assert(offsetof(GzPartyCustomization_GzMatchmakingStatusChanged__DelegateSignature, bStatus) == 0x000008, "Member 'GzPartyCustomization_GzMatchmakingStatusChanged__DelegateSignature::bStatus' has a wrong offset!");

// DelegateFunction G01.GzPartyCustomization.GzMiscDataUpdated__DelegateSignature
// 0x0028 (0x0028 - 0x0000)
struct GzPartyCustomization_GzMiscDataUpdated__DelegateSignature final
{
public:
	const class AGzCharacter*                     Character;                                         // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGzPartyMemberMiscData                 Data;                                              // 0x0008(0x0020)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzPartyCustomization_GzMiscDataUpdated__DelegateSignature) == 0x000008, "Wrong alignment on GzPartyCustomization_GzMiscDataUpdated__DelegateSignature");
static_assert(sizeof(GzPartyCustomization_GzMiscDataUpdated__DelegateSignature) == 0x000028, "Wrong size on GzPartyCustomization_GzMiscDataUpdated__DelegateSignature");
static_assert(offsetof(GzPartyCustomization_GzMiscDataUpdated__DelegateSignature, Character) == 0x000000, "Member 'GzPartyCustomization_GzMiscDataUpdated__DelegateSignature::Character' has a wrong offset!");
static_assert(offsetof(GzPartyCustomization_GzMiscDataUpdated__DelegateSignature, Data) == 0x000008, "Member 'GzPartyCustomization_GzMiscDataUpdated__DelegateSignature::Data' has a wrong offset!");

// DelegateFunction G01.GzPartyCustomization.GzPartyMembershipStateChanged__DelegateSignature
// 0x0001 (0x0001 - 0x0000)
struct GzPartyCustomization_GzPartyMembershipStateChanged__DelegateSignature final
{
public:
	bool                                          bInParty;                                          // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzPartyCustomization_GzPartyMembershipStateChanged__DelegateSignature) == 0x000001, "Wrong alignment on GzPartyCustomization_GzPartyMembershipStateChanged__DelegateSignature");
static_assert(sizeof(GzPartyCustomization_GzPartyMembershipStateChanged__DelegateSignature) == 0x000001, "Wrong size on GzPartyCustomization_GzPartyMembershipStateChanged__DelegateSignature");
static_assert(offsetof(GzPartyCustomization_GzPartyMembershipStateChanged__DelegateSignature, bInParty) == 0x000000, "Member 'GzPartyCustomization_GzPartyMembershipStateChanged__DelegateSignature::bInParty' has a wrong offset!");

// DelegateFunction G01.GzPartyCustomization.GzPlayerNameChanged__DelegateSignature
// 0x0008 (0x0008 - 0x0000)
struct GzPartyCustomization_GzPlayerNameChanged__DelegateSignature final
{
public:
	const class AGzCharacter*                     Character;                                         // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzPartyCustomization_GzPlayerNameChanged__DelegateSignature) == 0x000008, "Wrong alignment on GzPartyCustomization_GzPlayerNameChanged__DelegateSignature");
static_assert(sizeof(GzPartyCustomization_GzPlayerNameChanged__DelegateSignature) == 0x000008, "Wrong size on GzPartyCustomization_GzPlayerNameChanged__DelegateSignature");
static_assert(offsetof(GzPartyCustomization_GzPlayerNameChanged__DelegateSignature, Character) == 0x000000, "Member 'GzPartyCustomization_GzPlayerNameChanged__DelegateSignature::Character' has a wrong offset!");

// DelegateFunction G01.GzPartyCustomization.GzPlayerTalkingStateChanged__DelegateSignature
// 0x0010 (0x0010 - 0x0000)
struct GzPartyCustomization_GzPlayerTalkingStateChanged__DelegateSignature final
{
public:
	const class AGzCharacter*                     Character;                                         // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bTalkingState;                                     // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_345B[0x7];                                     // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GzPartyCustomization_GzPlayerTalkingStateChanged__DelegateSignature) == 0x000008, "Wrong alignment on GzPartyCustomization_GzPlayerTalkingStateChanged__DelegateSignature");
static_assert(sizeof(GzPartyCustomization_GzPlayerTalkingStateChanged__DelegateSignature) == 0x000010, "Wrong size on GzPartyCustomization_GzPlayerTalkingStateChanged__DelegateSignature");
static_assert(offsetof(GzPartyCustomization_GzPlayerTalkingStateChanged__DelegateSignature, Character) == 0x000000, "Member 'GzPartyCustomization_GzPlayerTalkingStateChanged__DelegateSignature::Character' has a wrong offset!");
static_assert(offsetof(GzPartyCustomization_GzPlayerTalkingStateChanged__DelegateSignature, bTalkingState) == 0x000008, "Member 'GzPartyCustomization_GzPlayerTalkingStateChanged__DelegateSignature::bTalkingState' has a wrong offset!");

// DelegateFunction G01.GzPartyCustomization.GzPlayerVoiceChatStateChanged__DelegateSignature
// 0x0010 (0x0010 - 0x0000)
struct GzPartyCustomization_GzPlayerVoiceChatStateChanged__DelegateSignature final
{
public:
	const class AGzCharacter*                     Character;                                         // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsMuted;                                          // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_345C[0x7];                                     // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GzPartyCustomization_GzPlayerVoiceChatStateChanged__DelegateSignature) == 0x000008, "Wrong alignment on GzPartyCustomization_GzPlayerVoiceChatStateChanged__DelegateSignature");
static_assert(sizeof(GzPartyCustomization_GzPlayerVoiceChatStateChanged__DelegateSignature) == 0x000010, "Wrong size on GzPartyCustomization_GzPlayerVoiceChatStateChanged__DelegateSignature");
static_assert(offsetof(GzPartyCustomization_GzPlayerVoiceChatStateChanged__DelegateSignature, Character) == 0x000000, "Member 'GzPartyCustomization_GzPlayerVoiceChatStateChanged__DelegateSignature::Character' has a wrong offset!");
static_assert(offsetof(GzPartyCustomization_GzPlayerVoiceChatStateChanged__DelegateSignature, bIsMuted) == 0x000008, "Member 'GzPartyCustomization_GzPlayerVoiceChatStateChanged__DelegateSignature::bIsMuted' has a wrong offset!");

// Function G01.GzPathTrackingComponent.ShouldCloseLoop
// 0x0001 (0x0001 - 0x0000)
struct GzPathTrackingComponent_ShouldCloseLoop final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzPathTrackingComponent_ShouldCloseLoop) == 0x000001, "Wrong alignment on GzPathTrackingComponent_ShouldCloseLoop");
static_assert(sizeof(GzPathTrackingComponent_ShouldCloseLoop) == 0x000001, "Wrong size on GzPathTrackingComponent_ShouldCloseLoop");
static_assert(offsetof(GzPathTrackingComponent_ShouldCloseLoop, ReturnValue) == 0x000000, "Member 'GzPathTrackingComponent_ShouldCloseLoop::ReturnValue' has a wrong offset!");

// Function G01.GzPaymentCheatExtension.OpenUrlInPaymentBrowser
// 0x0010 (0x0010 - 0x0000)
struct GzPaymentCheatExtension_OpenUrlInPaymentBrowser final
{
public:
	class FString                                 URL;                                               // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzPaymentCheatExtension_OpenUrlInPaymentBrowser) == 0x000008, "Wrong alignment on GzPaymentCheatExtension_OpenUrlInPaymentBrowser");
static_assert(sizeof(GzPaymentCheatExtension_OpenUrlInPaymentBrowser) == 0x000010, "Wrong size on GzPaymentCheatExtension_OpenUrlInPaymentBrowser");
static_assert(offsetof(GzPaymentCheatExtension_OpenUrlInPaymentBrowser, URL) == 0x000000, "Member 'GzPaymentCheatExtension_OpenUrlInPaymentBrowser::URL' has a wrong offset!");

// Function G01.GzPickableEffectsComponent.CreateLootBeam_BP
// 0x0018 (0x0018 - 0x0000)
struct GzPickableEffectsComponent_CreateLootBeam_BP final
{
public:
	struct FVector                                Location;                                          // 0x0000(0x0018)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzPickableEffectsComponent_CreateLootBeam_BP) == 0x000008, "Wrong alignment on GzPickableEffectsComponent_CreateLootBeam_BP");
static_assert(sizeof(GzPickableEffectsComponent_CreateLootBeam_BP) == 0x000018, "Wrong size on GzPickableEffectsComponent_CreateLootBeam_BP");
static_assert(offsetof(GzPickableEffectsComponent_CreateLootBeam_BP, Location) == 0x000000, "Member 'GzPickableEffectsComponent_CreateLootBeam_BP::Location' has a wrong offset!");

// Function G01.GzPickableEffectsComponent.CreateNiagara_BP
// 0x0018 (0x0018 - 0x0000)
struct GzPickableEffectsComponent_CreateNiagara_BP final
{
public:
	struct FVector                                Location;                                          // 0x0000(0x0018)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzPickableEffectsComponent_CreateNiagara_BP) == 0x000008, "Wrong alignment on GzPickableEffectsComponent_CreateNiagara_BP");
static_assert(sizeof(GzPickableEffectsComponent_CreateNiagara_BP) == 0x000018, "Wrong size on GzPickableEffectsComponent_CreateNiagara_BP");
static_assert(offsetof(GzPickableEffectsComponent_CreateNiagara_BP, Location) == 0x000000, "Member 'GzPickableEffectsComponent_CreateNiagara_BP::Location' has a wrong offset!");

// Function G01.GzPickableEffectsComponent.CreateSFX_BP
// 0x0018 (0x0018 - 0x0000)
struct GzPickableEffectsComponent_CreateSFX_BP final
{
public:
	struct FVector                                Location;                                          // 0x0000(0x0018)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzPickableEffectsComponent_CreateSFX_BP) == 0x000008, "Wrong alignment on GzPickableEffectsComponent_CreateSFX_BP");
static_assert(sizeof(GzPickableEffectsComponent_CreateSFX_BP) == 0x000018, "Wrong size on GzPickableEffectsComponent_CreateSFX_BP");
static_assert(offsetof(GzPickableEffectsComponent_CreateSFX_BP, Location) == 0x000000, "Member 'GzPickableEffectsComponent_CreateSFX_BP::Location' has a wrong offset!");

// Function G01.GzPickableEffectsComponent.IsLootBeamCreated
// 0x0001 (0x0001 - 0x0000)
struct GzPickableEffectsComponent_IsLootBeamCreated final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzPickableEffectsComponent_IsLootBeamCreated) == 0x000001, "Wrong alignment on GzPickableEffectsComponent_IsLootBeamCreated");
static_assert(sizeof(GzPickableEffectsComponent_IsLootBeamCreated) == 0x000001, "Wrong size on GzPickableEffectsComponent_IsLootBeamCreated");
static_assert(offsetof(GzPickableEffectsComponent_IsLootBeamCreated, ReturnValue) == 0x000000, "Member 'GzPickableEffectsComponent_IsLootBeamCreated::ReturnValue' has a wrong offset!");

// Function G01.GzPickableEffectsComponent.IsNiagaraCreated
// 0x0001 (0x0001 - 0x0000)
struct GzPickableEffectsComponent_IsNiagaraCreated final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzPickableEffectsComponent_IsNiagaraCreated) == 0x000001, "Wrong alignment on GzPickableEffectsComponent_IsNiagaraCreated");
static_assert(sizeof(GzPickableEffectsComponent_IsNiagaraCreated) == 0x000001, "Wrong size on GzPickableEffectsComponent_IsNiagaraCreated");
static_assert(offsetof(GzPickableEffectsComponent_IsNiagaraCreated, ReturnValue) == 0x000000, "Member 'GzPickableEffectsComponent_IsNiagaraCreated::ReturnValue' has a wrong offset!");

// Function G01.GzPickableEffectsComponent.IsSFXCreated
// 0x0001 (0x0001 - 0x0000)
struct GzPickableEffectsComponent_IsSFXCreated final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzPickableEffectsComponent_IsSFXCreated) == 0x000001, "Wrong alignment on GzPickableEffectsComponent_IsSFXCreated");
static_assert(sizeof(GzPickableEffectsComponent_IsSFXCreated) == 0x000001, "Wrong size on GzPickableEffectsComponent_IsSFXCreated");
static_assert(offsetof(GzPickableEffectsComponent_IsSFXCreated, ReturnValue) == 0x000000, "Member 'GzPickableEffectsComponent_IsSFXCreated::ReturnValue' has a wrong offset!");

// Function G01.GzPickableHelper2.CalculateDropLocationFor
// 0x0020 (0x0020 - 0x0000)
struct GzPickableHelper2_CalculateDropLocationFor final
{
public:
	const class AActor*                           Actor;                                             // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                ReturnValue;                                       // 0x0008(0x0018)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzPickableHelper2_CalculateDropLocationFor) == 0x000008, "Wrong alignment on GzPickableHelper2_CalculateDropLocationFor");
static_assert(sizeof(GzPickableHelper2_CalculateDropLocationFor) == 0x000020, "Wrong size on GzPickableHelper2_CalculateDropLocationFor");
static_assert(offsetof(GzPickableHelper2_CalculateDropLocationFor, Actor) == 0x000000, "Member 'GzPickableHelper2_CalculateDropLocationFor::Actor' has a wrong offset!");
static_assert(offsetof(GzPickableHelper2_CalculateDropLocationFor, ReturnValue) == 0x000008, "Member 'GzPickableHelper2_CalculateDropLocationFor::ReturnValue' has a wrong offset!");

// Function G01.GzPickableHelper2.CalculateImpulseForDroppedItemFor
// 0x0020 (0x0020 - 0x0000)
struct GzPickableHelper2_CalculateImpulseForDroppedItemFor final
{
public:
	const class AActor*                           Actor;                                             // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                ReturnValue;                                       // 0x0008(0x0018)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzPickableHelper2_CalculateImpulseForDroppedItemFor) == 0x000008, "Wrong alignment on GzPickableHelper2_CalculateImpulseForDroppedItemFor");
static_assert(sizeof(GzPickableHelper2_CalculateImpulseForDroppedItemFor) == 0x000020, "Wrong size on GzPickableHelper2_CalculateImpulseForDroppedItemFor");
static_assert(offsetof(GzPickableHelper2_CalculateImpulseForDroppedItemFor, Actor) == 0x000000, "Member 'GzPickableHelper2_CalculateImpulseForDroppedItemFor::Actor' has a wrong offset!");
static_assert(offsetof(GzPickableHelper2_CalculateImpulseForDroppedItemFor, ReturnValue) == 0x000008, "Member 'GzPickableHelper2_CalculateImpulseForDroppedItemFor::ReturnValue' has a wrong offset!");

// Function G01.GzPickableHelper2.CalculateSpawnLocationForDroppedItemFor
// 0x0020 (0x0020 - 0x0000)
struct GzPickableHelper2_CalculateSpawnLocationForDroppedItemFor final
{
public:
	const class AActor*                           Actor;                                             // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                ReturnValue;                                       // 0x0008(0x0018)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzPickableHelper2_CalculateSpawnLocationForDroppedItemFor) == 0x000008, "Wrong alignment on GzPickableHelper2_CalculateSpawnLocationForDroppedItemFor");
static_assert(sizeof(GzPickableHelper2_CalculateSpawnLocationForDroppedItemFor) == 0x000020, "Wrong size on GzPickableHelper2_CalculateSpawnLocationForDroppedItemFor");
static_assert(offsetof(GzPickableHelper2_CalculateSpawnLocationForDroppedItemFor, Actor) == 0x000000, "Member 'GzPickableHelper2_CalculateSpawnLocationForDroppedItemFor::Actor' has a wrong offset!");
static_assert(offsetof(GzPickableHelper2_CalculateSpawnLocationForDroppedItemFor, ReturnValue) == 0x000008, "Member 'GzPickableHelper2_CalculateSpawnLocationForDroppedItemFor::ReturnValue' has a wrong offset!");

// Function G01.GzPickableHelper2.CreateLimbPickable
// 0x0140 (0x0140 - 0x0000)
struct GzPickableHelper2_CreateLimbPickable final
{
public:
	const class UObject*                          WorldContextObject;                                // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3465[0x8];                                     // 0x0008(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGzPickableSpawnInfo                   SpawnInfo;                                         // 0x0010(0x00D0)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	struct FGzLimbInvItem                         InvItem;                                           // 0x00E0(0x0058)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	class AGzPickableBase*                        ReturnValue;                                       // 0x0138(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzPickableHelper2_CreateLimbPickable) == 0x000010, "Wrong alignment on GzPickableHelper2_CreateLimbPickable");
static_assert(sizeof(GzPickableHelper2_CreateLimbPickable) == 0x000140, "Wrong size on GzPickableHelper2_CreateLimbPickable");
static_assert(offsetof(GzPickableHelper2_CreateLimbPickable, WorldContextObject) == 0x000000, "Member 'GzPickableHelper2_CreateLimbPickable::WorldContextObject' has a wrong offset!");
static_assert(offsetof(GzPickableHelper2_CreateLimbPickable, SpawnInfo) == 0x000010, "Member 'GzPickableHelper2_CreateLimbPickable::SpawnInfo' has a wrong offset!");
static_assert(offsetof(GzPickableHelper2_CreateLimbPickable, InvItem) == 0x0000E0, "Member 'GzPickableHelper2_CreateLimbPickable::InvItem' has a wrong offset!");
static_assert(offsetof(GzPickableHelper2_CreateLimbPickable, ReturnValue) == 0x000138, "Member 'GzPickableHelper2_CreateLimbPickable::ReturnValue' has a wrong offset!");

// Function G01.GzPickableHelper2.CreateLimbPickableItem
// 0x0068 (0x0068 - 0x0000)
struct GzPickableHelper2_CreateLimbPickableItem final
{
public:
	struct FGzLimbInvItem                         LimbItem;                                          // 0x0000(0x0058)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	struct FGzInvItem                             ReturnValue;                                       // 0x0058(0x0010)(Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzPickableHelper2_CreateLimbPickableItem) == 0x000008, "Wrong alignment on GzPickableHelper2_CreateLimbPickableItem");
static_assert(sizeof(GzPickableHelper2_CreateLimbPickableItem) == 0x000068, "Wrong size on GzPickableHelper2_CreateLimbPickableItem");
static_assert(offsetof(GzPickableHelper2_CreateLimbPickableItem, LimbItem) == 0x000000, "Member 'GzPickableHelper2_CreateLimbPickableItem::LimbItem' has a wrong offset!");
static_assert(offsetof(GzPickableHelper2_CreateLimbPickableItem, ReturnValue) == 0x000058, "Member 'GzPickableHelper2_CreateLimbPickableItem::ReturnValue' has a wrong offset!");

// Function G01.GzPickableHelper2.CreatePickable
// 0x0100 (0x0100 - 0x0000)
struct GzPickableHelper2_CreatePickable final
{
public:
	const class UObject*                          WorldContextObject;                                // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3466[0x8];                                     // 0x0008(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGzPickableSpawnInfo                   SpawnInfo;                                         // 0x0010(0x00D0)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	struct FGzInvItem                             InvItem;                                           // 0x00E0(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	class AGzPickableBase*                        ReturnValue;                                       // 0x00F0(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3467[0x8];                                     // 0x00F8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GzPickableHelper2_CreatePickable) == 0x000010, "Wrong alignment on GzPickableHelper2_CreatePickable");
static_assert(sizeof(GzPickableHelper2_CreatePickable) == 0x000100, "Wrong size on GzPickableHelper2_CreatePickable");
static_assert(offsetof(GzPickableHelper2_CreatePickable, WorldContextObject) == 0x000000, "Member 'GzPickableHelper2_CreatePickable::WorldContextObject' has a wrong offset!");
static_assert(offsetof(GzPickableHelper2_CreatePickable, SpawnInfo) == 0x000010, "Member 'GzPickableHelper2_CreatePickable::SpawnInfo' has a wrong offset!");
static_assert(offsetof(GzPickableHelper2_CreatePickable, InvItem) == 0x0000E0, "Member 'GzPickableHelper2_CreatePickable::InvItem' has a wrong offset!");
static_assert(offsetof(GzPickableHelper2_CreatePickable, ReturnValue) == 0x0000F0, "Member 'GzPickableHelper2_CreatePickable::ReturnValue' has a wrong offset!");

// Function G01.GzPickableHelper2.CreatePickableOld
// 0x0130 (0x0130 - 0x0000)
struct GzPickableHelper2_CreatePickableOld final
{
public:
	const class UObject*                          WorldContextObject;                                // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3468[0x8];                                     // 0x0008(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGzPickableSpawnInfo                   SpawnInfo;                                         // 0x0010(0x00D0)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	struct FGzInventoryItemContent                ItemContent;                                       // 0x00E0(0x0048)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	class AGzPickableBase*                        ReturnValue;                                       // 0x0128(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzPickableHelper2_CreatePickableOld) == 0x000010, "Wrong alignment on GzPickableHelper2_CreatePickableOld");
static_assert(sizeof(GzPickableHelper2_CreatePickableOld) == 0x000130, "Wrong size on GzPickableHelper2_CreatePickableOld");
static_assert(offsetof(GzPickableHelper2_CreatePickableOld, WorldContextObject) == 0x000000, "Member 'GzPickableHelper2_CreatePickableOld::WorldContextObject' has a wrong offset!");
static_assert(offsetof(GzPickableHelper2_CreatePickableOld, SpawnInfo) == 0x000010, "Member 'GzPickableHelper2_CreatePickableOld::SpawnInfo' has a wrong offset!");
static_assert(offsetof(GzPickableHelper2_CreatePickableOld, ItemContent) == 0x0000E0, "Member 'GzPickableHelper2_CreatePickableOld::ItemContent' has a wrong offset!");
static_assert(offsetof(GzPickableHelper2_CreatePickableOld, ReturnValue) == 0x000128, "Member 'GzPickableHelper2_CreatePickableOld::ReturnValue' has a wrong offset!");

// Function G01.GzPickableHelper2.CreateSimplePickable
// 0x0120 (0x0120 - 0x0000)
struct GzPickableHelper2_CreateSimplePickable final
{
public:
	const class UObject*                          WorldContextObject;                                // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3469[0x8];                                     // 0x0008(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGzPickableSpawnInfo                   SpawnInfo;                                         // 0x0010(0x00D0)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	struct FGzSimpleInvItem                       InvItem;                                           // 0x00E0(0x0038)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	class AGzPickableBase*                        ReturnValue;                                       // 0x0118(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzPickableHelper2_CreateSimplePickable) == 0x000010, "Wrong alignment on GzPickableHelper2_CreateSimplePickable");
static_assert(sizeof(GzPickableHelper2_CreateSimplePickable) == 0x000120, "Wrong size on GzPickableHelper2_CreateSimplePickable");
static_assert(offsetof(GzPickableHelper2_CreateSimplePickable, WorldContextObject) == 0x000000, "Member 'GzPickableHelper2_CreateSimplePickable::WorldContextObject' has a wrong offset!");
static_assert(offsetof(GzPickableHelper2_CreateSimplePickable, SpawnInfo) == 0x000010, "Member 'GzPickableHelper2_CreateSimplePickable::SpawnInfo' has a wrong offset!");
static_assert(offsetof(GzPickableHelper2_CreateSimplePickable, InvItem) == 0x0000E0, "Member 'GzPickableHelper2_CreateSimplePickable::InvItem' has a wrong offset!");
static_assert(offsetof(GzPickableHelper2_CreateSimplePickable, ReturnValue) == 0x000118, "Member 'GzPickableHelper2_CreateSimplePickable::ReturnValue' has a wrong offset!");

// Function G01.GzPickableHelper2.CreateSimplePickableItem
// 0x0048 (0x0048 - 0x0000)
struct GzPickableHelper2_CreateSimplePickableItem final
{
public:
	struct FGzSimpleInvItem                       MiscItem;                                          // 0x0000(0x0038)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	struct FGzInvItem                             ReturnValue;                                       // 0x0038(0x0010)(Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzPickableHelper2_CreateSimplePickableItem) == 0x000008, "Wrong alignment on GzPickableHelper2_CreateSimplePickableItem");
static_assert(sizeof(GzPickableHelper2_CreateSimplePickableItem) == 0x000048, "Wrong size on GzPickableHelper2_CreateSimplePickableItem");
static_assert(offsetof(GzPickableHelper2_CreateSimplePickableItem, MiscItem) == 0x000000, "Member 'GzPickableHelper2_CreateSimplePickableItem::MiscItem' has a wrong offset!");
static_assert(offsetof(GzPickableHelper2_CreateSimplePickableItem, ReturnValue) == 0x000038, "Member 'GzPickableHelper2_CreateSimplePickableItem::ReturnValue' has a wrong offset!");

// Function G01.GzPickableHelper2.CreateWeaponPickable
// 0x0140 (0x0140 - 0x0000)
struct GzPickableHelper2_CreateWeaponPickable final
{
public:
	const class UObject*                          WorldContextObject;                                // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_346A[0x8];                                     // 0x0008(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGzPickableSpawnInfo                   SpawnInfo;                                         // 0x0010(0x00D0)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	struct FGzWeaponInvItem                       InvItem;                                           // 0x00E0(0x0050)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	class AGzPickableBase*                        ReturnValue;                                       // 0x0130(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_346B[0x8];                                     // 0x0138(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GzPickableHelper2_CreateWeaponPickable) == 0x000010, "Wrong alignment on GzPickableHelper2_CreateWeaponPickable");
static_assert(sizeof(GzPickableHelper2_CreateWeaponPickable) == 0x000140, "Wrong size on GzPickableHelper2_CreateWeaponPickable");
static_assert(offsetof(GzPickableHelper2_CreateWeaponPickable, WorldContextObject) == 0x000000, "Member 'GzPickableHelper2_CreateWeaponPickable::WorldContextObject' has a wrong offset!");
static_assert(offsetof(GzPickableHelper2_CreateWeaponPickable, SpawnInfo) == 0x000010, "Member 'GzPickableHelper2_CreateWeaponPickable::SpawnInfo' has a wrong offset!");
static_assert(offsetof(GzPickableHelper2_CreateWeaponPickable, InvItem) == 0x0000E0, "Member 'GzPickableHelper2_CreateWeaponPickable::InvItem' has a wrong offset!");
static_assert(offsetof(GzPickableHelper2_CreateWeaponPickable, ReturnValue) == 0x000130, "Member 'GzPickableHelper2_CreateWeaponPickable::ReturnValue' has a wrong offset!");

// Function G01.GzPickableHelper2.CreateWeaponPickableItem
// 0x0060 (0x0060 - 0x0000)
struct GzPickableHelper2_CreateWeaponPickableItem final
{
public:
	struct FGzWeaponInvItem                       WeaponItem;                                        // 0x0000(0x0050)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	struct FGzInvItem                             ReturnValue;                                       // 0x0050(0x0010)(Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzPickableHelper2_CreateWeaponPickableItem) == 0x000008, "Wrong alignment on GzPickableHelper2_CreateWeaponPickableItem");
static_assert(sizeof(GzPickableHelper2_CreateWeaponPickableItem) == 0x000060, "Wrong size on GzPickableHelper2_CreateWeaponPickableItem");
static_assert(offsetof(GzPickableHelper2_CreateWeaponPickableItem, WeaponItem) == 0x000000, "Member 'GzPickableHelper2_CreateWeaponPickableItem::WeaponItem' has a wrong offset!");
static_assert(offsetof(GzPickableHelper2_CreateWeaponPickableItem, ReturnValue) == 0x000050, "Member 'GzPickableHelper2_CreateWeaponPickableItem::ReturnValue' has a wrong offset!");

// Function G01.GzPickableHelper2.DropItem
// 0x0100 (0x0100 - 0x0000)
struct GzPickableHelper2_DropItem final
{
public:
	const class UObject*                          WorldContextObject;                                // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGzInvItem                             InvItem;                                           // 0x0008(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	uint8                                         Pad_346C[0x8];                                     // 0x0018(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGzPickableSpawnInfo                   SpawnInfo;                                         // 0x0020(0x00D0)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	class AActor*                                 ReturnValue;                                       // 0x00F0(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_346D[0x8];                                     // 0x00F8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GzPickableHelper2_DropItem) == 0x000010, "Wrong alignment on GzPickableHelper2_DropItem");
static_assert(sizeof(GzPickableHelper2_DropItem) == 0x000100, "Wrong size on GzPickableHelper2_DropItem");
static_assert(offsetof(GzPickableHelper2_DropItem, WorldContextObject) == 0x000000, "Member 'GzPickableHelper2_DropItem::WorldContextObject' has a wrong offset!");
static_assert(offsetof(GzPickableHelper2_DropItem, InvItem) == 0x000008, "Member 'GzPickableHelper2_DropItem::InvItem' has a wrong offset!");
static_assert(offsetof(GzPickableHelper2_DropItem, SpawnInfo) == 0x000020, "Member 'GzPickableHelper2_DropItem::SpawnInfo' has a wrong offset!");
static_assert(offsetof(GzPickableHelper2_DropItem, ReturnValue) == 0x0000F0, "Member 'GzPickableHelper2_DropItem::ReturnValue' has a wrong offset!");

// Function G01.GzPickableHelper2.DropItemDefault
// 0x0028 (0x0028 - 0x0000)
struct GzPickableHelper2_DropItemDefault final
{
public:
	const class UObject*                          WorldContextObject;                                // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGzInvItem                             InvItem;                                           // 0x0008(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	const class AActor*                           LastOwner;                                         // 0x0018(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 ReturnValue;                                       // 0x0020(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzPickableHelper2_DropItemDefault) == 0x000008, "Wrong alignment on GzPickableHelper2_DropItemDefault");
static_assert(sizeof(GzPickableHelper2_DropItemDefault) == 0x000028, "Wrong size on GzPickableHelper2_DropItemDefault");
static_assert(offsetof(GzPickableHelper2_DropItemDefault, WorldContextObject) == 0x000000, "Member 'GzPickableHelper2_DropItemDefault::WorldContextObject' has a wrong offset!");
static_assert(offsetof(GzPickableHelper2_DropItemDefault, InvItem) == 0x000008, "Member 'GzPickableHelper2_DropItemDefault::InvItem' has a wrong offset!");
static_assert(offsetof(GzPickableHelper2_DropItemDefault, LastOwner) == 0x000018, "Member 'GzPickableHelper2_DropItemDefault::LastOwner' has a wrong offset!");
static_assert(offsetof(GzPickableHelper2_DropItemDefault, ReturnValue) == 0x000020, "Member 'GzPickableHelper2_DropItemDefault::ReturnValue' has a wrong offset!");

// Function G01.GzPickableHelper2.FindHighPriorityPickup
// 0x0020 (0x0020 - 0x0000)
struct GzPickableHelper2_FindHighPriorityPickup final
{
public:
	const class AGzCharacter*                     Character;                                         // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class AGzPickableBase*>                PickableArray;                                     // 0x0008(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	class AGzPickableBase*                        ReturnValue;                                       // 0x0018(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzPickableHelper2_FindHighPriorityPickup) == 0x000008, "Wrong alignment on GzPickableHelper2_FindHighPriorityPickup");
static_assert(sizeof(GzPickableHelper2_FindHighPriorityPickup) == 0x000020, "Wrong size on GzPickableHelper2_FindHighPriorityPickup");
static_assert(offsetof(GzPickableHelper2_FindHighPriorityPickup, Character) == 0x000000, "Member 'GzPickableHelper2_FindHighPriorityPickup::Character' has a wrong offset!");
static_assert(offsetof(GzPickableHelper2_FindHighPriorityPickup, PickableArray) == 0x000008, "Member 'GzPickableHelper2_FindHighPriorityPickup::PickableArray' has a wrong offset!");
static_assert(offsetof(GzPickableHelper2_FindHighPriorityPickup, ReturnValue) == 0x000018, "Member 'GzPickableHelper2_FindHighPriorityPickup::ReturnValue' has a wrong offset!");

// Function G01.GzPickableHelper2.GetPickableRealPosition
// 0x0020 (0x0020 - 0x0000)
struct GzPickableHelper2_GetPickableRealPosition final
{
public:
	const class AGzPickableBase*                  Pickable;                                          // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                ReturnValue;                                       // 0x0008(0x0018)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzPickableHelper2_GetPickableRealPosition) == 0x000008, "Wrong alignment on GzPickableHelper2_GetPickableRealPosition");
static_assert(sizeof(GzPickableHelper2_GetPickableRealPosition) == 0x000020, "Wrong size on GzPickableHelper2_GetPickableRealPosition");
static_assert(offsetof(GzPickableHelper2_GetPickableRealPosition, Pickable) == 0x000000, "Member 'GzPickableHelper2_GetPickableRealPosition::Pickable' has a wrong offset!");
static_assert(offsetof(GzPickableHelper2_GetPickableRealPosition, ReturnValue) == 0x000008, "Member 'GzPickableHelper2_GetPickableRealPosition::ReturnValue' has a wrong offset!");

// Function G01.GzPickUpLogEntryWidget.SetItemInfo
// 0x0010 (0x0010 - 0x0000)
struct GzPickUpLogEntryWidget_SetItemInfo final
{
public:
	struct FGzInvItem                             InvItem;                                           // 0x0000(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzPickUpLogEntryWidget_SetItemInfo) == 0x000008, "Wrong alignment on GzPickUpLogEntryWidget_SetItemInfo");
static_assert(sizeof(GzPickUpLogEntryWidget_SetItemInfo) == 0x000010, "Wrong size on GzPickUpLogEntryWidget_SetItemInfo");
static_assert(offsetof(GzPickUpLogEntryWidget_SetItemInfo, InvItem) == 0x000000, "Member 'GzPickUpLogEntryWidget_SetItemInfo::InvItem' has a wrong offset!");

// Function G01.GzPingActor.GetMarkerComponent
// 0x0008 (0x0008 - 0x0000)
struct GzPingActor_GetMarkerComponent final
{
public:
	class UGzMarkerComponent*                     ReturnValue;                                       // 0x0000(0x0008)(ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzPingActor_GetMarkerComponent) == 0x000008, "Wrong alignment on GzPingActor_GetMarkerComponent");
static_assert(sizeof(GzPingActor_GetMarkerComponent) == 0x000008, "Wrong size on GzPingActor_GetMarkerComponent");
static_assert(offsetof(GzPingActor_GetMarkerComponent, ReturnValue) == 0x000000, "Member 'GzPingActor_GetMarkerComponent::ReturnValue' has a wrong offset!");

// Function G01.GzPingActor.GetPingData
// 0x0060 (0x0060 - 0x0000)
struct GzPingActor_GetPingData final
{
public:
	struct FGzPingData                            ReturnValue;                                       // 0x0000(0x0060)(ConstParm, Parm, OutParm, ReturnParm, ReferenceParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzPingActor_GetPingData) == 0x000008, "Wrong alignment on GzPingActor_GetPingData");
static_assert(sizeof(GzPingActor_GetPingData) == 0x000060, "Wrong size on GzPingActor_GetPingData");
static_assert(offsetof(GzPingActor_GetPingData, ReturnValue) == 0x000000, "Member 'GzPingActor_GetPingData::ReturnValue' has a wrong offset!");

// Function G01.GzPingControllerComponent.Client_AddPing
// 0x0060 (0x0060 - 0x0000)
struct GzPingControllerComponent_Client_AddPing final
{
public:
	struct FGzPingData                            PingRequest;                                       // 0x0000(0x0060)(ConstParm, Parm, ReferenceParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzPingControllerComponent_Client_AddPing) == 0x000008, "Wrong alignment on GzPingControllerComponent_Client_AddPing");
static_assert(sizeof(GzPingControllerComponent_Client_AddPing) == 0x000060, "Wrong size on GzPingControllerComponent_Client_AddPing");
static_assert(offsetof(GzPingControllerComponent_Client_AddPing, PingRequest) == 0x000000, "Member 'GzPingControllerComponent_Client_AddPing::PingRequest' has a wrong offset!");

// Function G01.GzPingControllerComponent.Client_CancelPing
// 0x0060 (0x0060 - 0x0000)
struct GzPingControllerComponent_Client_CancelPing final
{
public:
	struct FGzPingData                            PingRequest;                                       // 0x0000(0x0060)(ConstParm, Parm, ReferenceParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzPingControllerComponent_Client_CancelPing) == 0x000008, "Wrong alignment on GzPingControllerComponent_Client_CancelPing");
static_assert(sizeof(GzPingControllerComponent_Client_CancelPing) == 0x000060, "Wrong size on GzPingControllerComponent_Client_CancelPing");
static_assert(offsetof(GzPingControllerComponent_Client_CancelPing, PingRequest) == 0x000000, "Member 'GzPingControllerComponent_Client_CancelPing::PingRequest' has a wrong offset!");

// Function G01.GzPingControllerComponent.Client_RemovePing
// 0x0060 (0x0060 - 0x0000)
struct GzPingControllerComponent_Client_RemovePing final
{
public:
	struct FGzPingData                            PingRequest;                                       // 0x0000(0x0060)(ConstParm, Parm, ReferenceParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzPingControllerComponent_Client_RemovePing) == 0x000008, "Wrong alignment on GzPingControllerComponent_Client_RemovePing");
static_assert(sizeof(GzPingControllerComponent_Client_RemovePing) == 0x000060, "Wrong size on GzPingControllerComponent_Client_RemovePing");
static_assert(offsetof(GzPingControllerComponent_Client_RemovePing, PingRequest) == 0x000000, "Member 'GzPingControllerComponent_Client_RemovePing::PingRequest' has a wrong offset!");

// Function G01.GzPingControllerComponent.Client_SetAgree
// 0x0070 (0x0070 - 0x0000)
struct GzPingControllerComponent_Client_SetAgree final
{
public:
	struct FGzPingData                            PingData;                                          // 0x0000(0x0060)(ConstParm, Parm, ReferenceParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AGzPlayerState*                         PS;                                                // 0x0060(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAgrees;                                           // 0x0068(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3471[0x7];                                     // 0x0069(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GzPingControllerComponent_Client_SetAgree) == 0x000008, "Wrong alignment on GzPingControllerComponent_Client_SetAgree");
static_assert(sizeof(GzPingControllerComponent_Client_SetAgree) == 0x000070, "Wrong size on GzPingControllerComponent_Client_SetAgree");
static_assert(offsetof(GzPingControllerComponent_Client_SetAgree, PingData) == 0x000000, "Member 'GzPingControllerComponent_Client_SetAgree::PingData' has a wrong offset!");
static_assert(offsetof(GzPingControllerComponent_Client_SetAgree, PS) == 0x000060, "Member 'GzPingControllerComponent_Client_SetAgree::PS' has a wrong offset!");
static_assert(offsetof(GzPingControllerComponent_Client_SetAgree, bAgrees) == 0x000068, "Member 'GzPingControllerComponent_Client_SetAgree::bAgrees' has a wrong offset!");

// Function G01.GzPingControllerComponent.Ping
// 0x000C (0x000C - 0x0000)
struct GzPingControllerComponent_Ping final
{
public:
	struct FGameplayTag                           PingType;                                          // 0x0000(0x0008)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EGzPingChannels                               PingChannel;                                       // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bConsumeSnapshot;                                  // 0x0009(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x000A(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3472[0x1];                                     // 0x000B(0x0001)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GzPingControllerComponent_Ping) == 0x000004, "Wrong alignment on GzPingControllerComponent_Ping");
static_assert(sizeof(GzPingControllerComponent_Ping) == 0x00000C, "Wrong size on GzPingControllerComponent_Ping");
static_assert(offsetof(GzPingControllerComponent_Ping, PingType) == 0x000000, "Member 'GzPingControllerComponent_Ping::PingType' has a wrong offset!");
static_assert(offsetof(GzPingControllerComponent_Ping, PingChannel) == 0x000008, "Member 'GzPingControllerComponent_Ping::PingChannel' has a wrong offset!");
static_assert(offsetof(GzPingControllerComponent_Ping, bConsumeSnapshot) == 0x000009, "Member 'GzPingControllerComponent_Ping::bConsumeSnapshot' has a wrong offset!");
static_assert(offsetof(GzPingControllerComponent_Ping, ReturnValue) == 0x00000A, "Member 'GzPingControllerComponent_Ping::ReturnValue' has a wrong offset!");

// Function G01.GzPingControllerComponent.PingAtLocation
// 0x0018 (0x0018 - 0x0000)
struct GzPingControllerComponent_PingAtLocation final
{
public:
	struct FGameplayTag                           PingType;                                          // 0x0000(0x0008)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              WorldLocation;                                     // 0x0008(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzPingControllerComponent_PingAtLocation) == 0x000008, "Wrong alignment on GzPingControllerComponent_PingAtLocation");
static_assert(sizeof(GzPingControllerComponent_PingAtLocation) == 0x000018, "Wrong size on GzPingControllerComponent_PingAtLocation");
static_assert(offsetof(GzPingControllerComponent_PingAtLocation, PingType) == 0x000000, "Member 'GzPingControllerComponent_PingAtLocation::PingType' has a wrong offset!");
static_assert(offsetof(GzPingControllerComponent_PingAtLocation, WorldLocation) == 0x000008, "Member 'GzPingControllerComponent_PingAtLocation::WorldLocation' has a wrong offset!");

// Function G01.GzPingControllerComponent.PingClosestActorOfClass
// 0x0018 (0x0018 - 0x0000)
struct GzPingControllerComponent_PingClosestActorOfClass final
{
public:
	struct FGameplayTag                           PingType;                                          // 0x0000(0x0008)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class AActor>                     ActorClass;                                        // 0x0008(0x0008)(Parm, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0010(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3473[0x7];                                     // 0x0011(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GzPingControllerComponent_PingClosestActorOfClass) == 0x000008, "Wrong alignment on GzPingControllerComponent_PingClosestActorOfClass");
static_assert(sizeof(GzPingControllerComponent_PingClosestActorOfClass) == 0x000018, "Wrong size on GzPingControllerComponent_PingClosestActorOfClass");
static_assert(offsetof(GzPingControllerComponent_PingClosestActorOfClass, PingType) == 0x000000, "Member 'GzPingControllerComponent_PingClosestActorOfClass::PingType' has a wrong offset!");
static_assert(offsetof(GzPingControllerComponent_PingClosestActorOfClass, ActorClass) == 0x000008, "Member 'GzPingControllerComponent_PingClosestActorOfClass::ActorClass' has a wrong offset!");
static_assert(offsetof(GzPingControllerComponent_PingClosestActorOfClass, ReturnValue) == 0x000010, "Member 'GzPingControllerComponent_PingClosestActorOfClass::ReturnValue' has a wrong offset!");

// Function G01.GzPingControllerComponent.PingMarker
// 0x0010 (0x0010 - 0x0000)
struct GzPingControllerComponent_PingMarker final
{
public:
	struct FGameplayTag                           PingType;                                          // 0x0000(0x0008)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UGzMarkerComponent*                     MarkerComponent;                                   // 0x0008(0x0008)(Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzPingControllerComponent_PingMarker) == 0x000008, "Wrong alignment on GzPingControllerComponent_PingMarker");
static_assert(sizeof(GzPingControllerComponent_PingMarker) == 0x000010, "Wrong size on GzPingControllerComponent_PingMarker");
static_assert(offsetof(GzPingControllerComponent_PingMarker, PingType) == 0x000000, "Member 'GzPingControllerComponent_PingMarker::PingType' has a wrong offset!");
static_assert(offsetof(GzPingControllerComponent_PingMarker, MarkerComponent) == 0x000008, "Member 'GzPingControllerComponent_PingMarker::MarkerComponent' has a wrong offset!");

// Function G01.GzPingControllerComponent.Server_CancelPing
// 0x0060 (0x0060 - 0x0000)
struct GzPingControllerComponent_Server_CancelPing final
{
public:
	struct FGzPingData                            PingRequest;                                       // 0x0000(0x0060)(ConstParm, Parm, ReferenceParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzPingControllerComponent_Server_CancelPing) == 0x000008, "Wrong alignment on GzPingControllerComponent_Server_CancelPing");
static_assert(sizeof(GzPingControllerComponent_Server_CancelPing) == 0x000060, "Wrong size on GzPingControllerComponent_Server_CancelPing");
static_assert(offsetof(GzPingControllerComponent_Server_CancelPing, PingRequest) == 0x000000, "Member 'GzPingControllerComponent_Server_CancelPing::PingRequest' has a wrong offset!");

// Function G01.GzPingControllerComponent.Server_CreatePing
// 0x0060 (0x0060 - 0x0000)
struct GzPingControllerComponent_Server_CreatePing final
{
public:
	struct FGzPingData                            PingRequest;                                       // 0x0000(0x0060)(ConstParm, Parm, ReferenceParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzPingControllerComponent_Server_CreatePing) == 0x000008, "Wrong alignment on GzPingControllerComponent_Server_CreatePing");
static_assert(sizeof(GzPingControllerComponent_Server_CreatePing) == 0x000060, "Wrong size on GzPingControllerComponent_Server_CreatePing");
static_assert(offsetof(GzPingControllerComponent_Server_CreatePing, PingRequest) == 0x000000, "Member 'GzPingControllerComponent_Server_CreatePing::PingRequest' has a wrong offset!");

// Function G01.GzPingControllerComponent.Server_RemovePing
// 0x0060 (0x0060 - 0x0000)
struct GzPingControllerComponent_Server_RemovePing final
{
public:
	struct FGzPingData                            PingRequest;                                       // 0x0000(0x0060)(ConstParm, Parm, ReferenceParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzPingControllerComponent_Server_RemovePing) == 0x000008, "Wrong alignment on GzPingControllerComponent_Server_RemovePing");
static_assert(sizeof(GzPingControllerComponent_Server_RemovePing) == 0x000060, "Wrong size on GzPingControllerComponent_Server_RemovePing");
static_assert(offsetof(GzPingControllerComponent_Server_RemovePing, PingRequest) == 0x000000, "Member 'GzPingControllerComponent_Server_RemovePing::PingRequest' has a wrong offset!");

// Function G01.GzPingControllerComponent.Server_SetAgree
// 0x0070 (0x0070 - 0x0000)
struct GzPingControllerComponent_Server_SetAgree final
{
public:
	struct FGzPingData                            PingData;                                          // 0x0000(0x0060)(ConstParm, Parm, ReferenceParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AGzPlayerState*                         PS;                                                // 0x0060(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAgrees;                                           // 0x0068(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3474[0x7];                                     // 0x0069(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GzPingControllerComponent_Server_SetAgree) == 0x000008, "Wrong alignment on GzPingControllerComponent_Server_SetAgree");
static_assert(sizeof(GzPingControllerComponent_Server_SetAgree) == 0x000070, "Wrong size on GzPingControllerComponent_Server_SetAgree");
static_assert(offsetof(GzPingControllerComponent_Server_SetAgree, PingData) == 0x000000, "Member 'GzPingControllerComponent_Server_SetAgree::PingData' has a wrong offset!");
static_assert(offsetof(GzPingControllerComponent_Server_SetAgree, PS) == 0x000060, "Member 'GzPingControllerComponent_Server_SetAgree::PS' has a wrong offset!");
static_assert(offsetof(GzPingControllerComponent_Server_SetAgree, bAgrees) == 0x000068, "Member 'GzPingControllerComponent_Server_SetAgree::bAgrees' has a wrong offset!");

// Function G01.GzPingControllerComponent.GetPingActor
// 0x0010 (0x0010 - 0x0000)
struct GzPingControllerComponent_GetPingActor final
{
public:
	class AActor*                                 InActor;                                           // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AGzPingActor*                           ReturnValue;                                       // 0x0008(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzPingControllerComponent_GetPingActor) == 0x000008, "Wrong alignment on GzPingControllerComponent_GetPingActor");
static_assert(sizeof(GzPingControllerComponent_GetPingActor) == 0x000010, "Wrong size on GzPingControllerComponent_GetPingActor");
static_assert(offsetof(GzPingControllerComponent_GetPingActor, InActor) == 0x000000, "Member 'GzPingControllerComponent_GetPingActor::InActor' has a wrong offset!");
static_assert(offsetof(GzPingControllerComponent_GetPingActor, ReturnValue) == 0x000008, "Member 'GzPingControllerComponent_GetPingActor::ReturnValue' has a wrong offset!");

// Function G01.GzPingControllerComponent.IsPinged
// 0x0010 (0x0010 - 0x0000)
struct GzPingControllerComponent_IsPinged final
{
public:
	class AActor*                                 InActor;                                           // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3475[0x7];                                     // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GzPingControllerComponent_IsPinged) == 0x000008, "Wrong alignment on GzPingControllerComponent_IsPinged");
static_assert(sizeof(GzPingControllerComponent_IsPinged) == 0x000010, "Wrong size on GzPingControllerComponent_IsPinged");
static_assert(offsetof(GzPingControllerComponent_IsPinged, InActor) == 0x000000, "Member 'GzPingControllerComponent_IsPinged::InActor' has a wrong offset!");
static_assert(offsetof(GzPingControllerComponent_IsPinged, ReturnValue) == 0x000008, "Member 'GzPingControllerComponent_IsPinged::ReturnValue' has a wrong offset!");

// Function G01.GzSA_ActionOnEvent.OnEvent
// 0x00B0 (0x00B0 - 0x0000)
struct GzSA_ActionOnEvent_OnEvent final
{
public:
	struct FGameplayEventData                     TriggerEventData;                                  // 0x0000(0x00B0)(Parm, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzSA_ActionOnEvent_OnEvent) == 0x000008, "Wrong alignment on GzSA_ActionOnEvent_OnEvent");
static_assert(sizeof(GzSA_ActionOnEvent_OnEvent) == 0x0000B0, "Wrong size on GzSA_ActionOnEvent_OnEvent");
static_assert(offsetof(GzSA_ActionOnEvent_OnEvent, TriggerEventData) == 0x000000, "Member 'GzSA_ActionOnEvent_OnEvent::TriggerEventData' has a wrong offset!");

// Function G01.GzPingTooltipExtension.InteractionFocusChanged
// 0x0010 (0x0010 - 0x0000)
struct GzPingTooltipExtension_InteractionFocusChanged final
{
public:
	class UGzInteractableComponent*               Interactable;                                      // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bInInteractionRange;                               // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3478[0x7];                                     // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GzPingTooltipExtension_InteractionFocusChanged) == 0x000008, "Wrong alignment on GzPingTooltipExtension_InteractionFocusChanged");
static_assert(sizeof(GzPingTooltipExtension_InteractionFocusChanged) == 0x000010, "Wrong size on GzPingTooltipExtension_InteractionFocusChanged");
static_assert(offsetof(GzPingTooltipExtension_InteractionFocusChanged, Interactable) == 0x000000, "Member 'GzPingTooltipExtension_InteractionFocusChanged::Interactable' has a wrong offset!");
static_assert(offsetof(GzPingTooltipExtension_InteractionFocusChanged, bInInteractionRange) == 0x000008, "Member 'GzPingTooltipExtension_InteractionFocusChanged::bInInteractionRange' has a wrong offset!");

// Function G01.GzPingTooltipExtension.OnPingRemoved
// 0x0060 (0x0060 - 0x0000)
struct GzPingTooltipExtension_OnPingRemoved final
{
public:
	struct FGzPingData                            PingData;                                          // 0x0000(0x0060)(ConstParm, Parm, OutParm, ReferenceParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzPingTooltipExtension_OnPingRemoved) == 0x000008, "Wrong alignment on GzPingTooltipExtension_OnPingRemoved");
static_assert(sizeof(GzPingTooltipExtension_OnPingRemoved) == 0x000060, "Wrong size on GzPingTooltipExtension_OnPingRemoved");
static_assert(offsetof(GzPingTooltipExtension_OnPingRemoved, PingData) == 0x000000, "Member 'GzPingTooltipExtension_OnPingRemoved::PingData' has a wrong offset!");

// Function G01.GzPlayableAreaSubsystem.GetLayer
// 0x0008 (0x0008 - 0x0000)
struct GzPlayableAreaSubsystem_GetLayer final
{
public:
	class FName                                   ReturnValue;                                       // 0x0000(0x0008)(ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzPlayableAreaSubsystem_GetLayer) == 0x000004, "Wrong alignment on GzPlayableAreaSubsystem_GetLayer");
static_assert(sizeof(GzPlayableAreaSubsystem_GetLayer) == 0x000008, "Wrong size on GzPlayableAreaSubsystem_GetLayer");
static_assert(offsetof(GzPlayableAreaSubsystem_GetLayer, ReturnValue) == 0x000000, "Member 'GzPlayableAreaSubsystem_GetLayer::ReturnValue' has a wrong offset!");

// Function G01.GzPlayableAreaSubsystem.GetZones
// 0x0010 (0x0010 - 0x0000)
struct GzPlayableAreaSubsystem_GetZones final
{
public:
	TArray<class FName>                           ReturnValue;                                       // 0x0000(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzPlayableAreaSubsystem_GetZones) == 0x000008, "Wrong alignment on GzPlayableAreaSubsystem_GetZones");
static_assert(sizeof(GzPlayableAreaSubsystem_GetZones) == 0x000010, "Wrong size on GzPlayableAreaSubsystem_GetZones");
static_assert(offsetof(GzPlayableAreaSubsystem_GetZones, ReturnValue) == 0x000000, "Member 'GzPlayableAreaSubsystem_GetZones::ReturnValue' has a wrong offset!");

// Function G01.GzPlayerCharacter.AddRevealedActor
// 0x0018 (0x0018 - 0x0000)
struct GzPlayerCharacter_AddRevealedActor final
{
public:
	class AActor*                                 SourceActor;                                       // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           RevealedTag;                                       // 0x0008(0x0008)(Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 Actor;                                             // 0x0010(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzPlayerCharacter_AddRevealedActor) == 0x000008, "Wrong alignment on GzPlayerCharacter_AddRevealedActor");
static_assert(sizeof(GzPlayerCharacter_AddRevealedActor) == 0x000018, "Wrong size on GzPlayerCharacter_AddRevealedActor");
static_assert(offsetof(GzPlayerCharacter_AddRevealedActor, SourceActor) == 0x000000, "Member 'GzPlayerCharacter_AddRevealedActor::SourceActor' has a wrong offset!");
static_assert(offsetof(GzPlayerCharacter_AddRevealedActor, RevealedTag) == 0x000008, "Member 'GzPlayerCharacter_AddRevealedActor::RevealedTag' has a wrong offset!");
static_assert(offsetof(GzPlayerCharacter_AddRevealedActor, Actor) == 0x000010, "Member 'GzPlayerCharacter_AddRevealedActor::Actor' has a wrong offset!");

// Function G01.GzPlayerCharacter.OnAnyAbilityEnded
// 0x0010 (0x0010 - 0x0000)
struct GzPlayerCharacter_OnAnyAbilityEnded final
{
public:
	struct FAbilityEndedData                      AbilityEndedData;                                  // 0x0000(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzPlayerCharacter_OnAnyAbilityEnded) == 0x000008, "Wrong alignment on GzPlayerCharacter_OnAnyAbilityEnded");
static_assert(sizeof(GzPlayerCharacter_OnAnyAbilityEnded) == 0x000010, "Wrong size on GzPlayerCharacter_OnAnyAbilityEnded");
static_assert(offsetof(GzPlayerCharacter_OnAnyAbilityEnded, AbilityEndedData) == 0x000000, "Member 'GzPlayerCharacter_OnAnyAbilityEnded::AbilityEndedData' has a wrong offset!");

// Function G01.GzPlayerCharacter.OnAnyAbilityEndedNextFrame
// 0x0010 (0x0010 - 0x0000)
struct GzPlayerCharacter_OnAnyAbilityEndedNextFrame final
{
public:
	struct FAbilityEndedData                      AbilityEndedData;                                  // 0x0000(0x0010)(ConstParm, Parm, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzPlayerCharacter_OnAnyAbilityEndedNextFrame) == 0x000008, "Wrong alignment on GzPlayerCharacter_OnAnyAbilityEndedNextFrame");
static_assert(sizeof(GzPlayerCharacter_OnAnyAbilityEndedNextFrame) == 0x000010, "Wrong size on GzPlayerCharacter_OnAnyAbilityEndedNextFrame");
static_assert(offsetof(GzPlayerCharacter_OnAnyAbilityEndedNextFrame, AbilityEndedData) == 0x000000, "Member 'GzPlayerCharacter_OnAnyAbilityEndedNextFrame::AbilityEndedData' has a wrong offset!");

// Function G01.GzPlayerCharacter.OnCustomizationChanged
// 0x0008 (0x0008 - 0x0000)
struct GzPlayerCharacter_OnCustomizationChanged final
{
public:
	class AGzPlayerState*                         GzPlayerState;                                     // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzPlayerCharacter_OnCustomizationChanged) == 0x000008, "Wrong alignment on GzPlayerCharacter_OnCustomizationChanged");
static_assert(sizeof(GzPlayerCharacter_OnCustomizationChanged) == 0x000008, "Wrong size on GzPlayerCharacter_OnCustomizationChanged");
static_assert(offsetof(GzPlayerCharacter_OnCustomizationChanged, GzPlayerState) == 0x000000, "Member 'GzPlayerCharacter_OnCustomizationChanged::GzPlayerState' has a wrong offset!");

// Function G01.GzPlayerCharacter.OnInteract
// 0x0010 (0x0010 - 0x0000)
struct GzPlayerCharacter_OnInteract final
{
public:
	class AActor*                                 InteractedBy;                                      // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	const class UGzInteractableComponent*         Interactable;                                      // 0x0008(0x0008)(ConstParm, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzPlayerCharacter_OnInteract) == 0x000008, "Wrong alignment on GzPlayerCharacter_OnInteract");
static_assert(sizeof(GzPlayerCharacter_OnInteract) == 0x000010, "Wrong size on GzPlayerCharacter_OnInteract");
static_assert(offsetof(GzPlayerCharacter_OnInteract, InteractedBy) == 0x000000, "Member 'GzPlayerCharacter_OnInteract::InteractedBy' has a wrong offset!");
static_assert(offsetof(GzPlayerCharacter_OnInteract, Interactable) == 0x000008, "Member 'GzPlayerCharacter_OnInteract::Interactable' has a wrong offset!");

// Function G01.GzPlayerCharacter.OnInteractionCanceled
// 0x0010 (0x0010 - 0x0000)
struct GzPlayerCharacter_OnInteractionCanceled final
{
public:
	class AActor*                                 InteractedBy;                                      // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	const class UGzInteractableComponent*         Interactable;                                      // 0x0008(0x0008)(ConstParm, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzPlayerCharacter_OnInteractionCanceled) == 0x000008, "Wrong alignment on GzPlayerCharacter_OnInteractionCanceled");
static_assert(sizeof(GzPlayerCharacter_OnInteractionCanceled) == 0x000010, "Wrong size on GzPlayerCharacter_OnInteractionCanceled");
static_assert(offsetof(GzPlayerCharacter_OnInteractionCanceled, InteractedBy) == 0x000000, "Member 'GzPlayerCharacter_OnInteractionCanceled::InteractedBy' has a wrong offset!");
static_assert(offsetof(GzPlayerCharacter_OnInteractionCanceled, Interactable) == 0x000008, "Member 'GzPlayerCharacter_OnInteractionCanceled::Interactable' has a wrong offset!");

// Function G01.GzPlayerCharacter.OnInteractionStarted
// 0x0010 (0x0010 - 0x0000)
struct GzPlayerCharacter_OnInteractionStarted final
{
public:
	class AActor*                                 InteractedBy;                                      // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	const class UGzInteractableComponent*         Interactable;                                      // 0x0008(0x0008)(ConstParm, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzPlayerCharacter_OnInteractionStarted) == 0x000008, "Wrong alignment on GzPlayerCharacter_OnInteractionStarted");
static_assert(sizeof(GzPlayerCharacter_OnInteractionStarted) == 0x000010, "Wrong size on GzPlayerCharacter_OnInteractionStarted");
static_assert(offsetof(GzPlayerCharacter_OnInteractionStarted, InteractedBy) == 0x000000, "Member 'GzPlayerCharacter_OnInteractionStarted::InteractedBy' has a wrong offset!");
static_assert(offsetof(GzPlayerCharacter_OnInteractionStarted, Interactable) == 0x000008, "Member 'GzPlayerCharacter_OnInteractionStarted::Interactable' has a wrong offset!");

// Function G01.GzPlayerCharacter.OnKnockedDownTagChanged
// 0x000C (0x000C - 0x0000)
struct GzPlayerCharacter_OnKnockedDownTagChanged final
{
public:
	struct FGameplayTag                           Tag;                                               // 0x0000(0x0008)(ConstParm, Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Count;                                             // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzPlayerCharacter_OnKnockedDownTagChanged) == 0x000004, "Wrong alignment on GzPlayerCharacter_OnKnockedDownTagChanged");
static_assert(sizeof(GzPlayerCharacter_OnKnockedDownTagChanged) == 0x00000C, "Wrong size on GzPlayerCharacter_OnKnockedDownTagChanged");
static_assert(offsetof(GzPlayerCharacter_OnKnockedDownTagChanged, Tag) == 0x000000, "Member 'GzPlayerCharacter_OnKnockedDownTagChanged::Tag' has a wrong offset!");
static_assert(offsetof(GzPlayerCharacter_OnKnockedDownTagChanged, Count) == 0x000008, "Member 'GzPlayerCharacter_OnKnockedDownTagChanged::Count' has a wrong offset!");

// Function G01.GzPlayerCharacter.RemoveRevealedActor
// 0x0018 (0x0018 - 0x0000)
struct GzPlayerCharacter_RemoveRevealedActor final
{
public:
	class AActor*                                 SourceActor;                                       // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           RevealedTag;                                       // 0x0008(0x0008)(Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 Actor;                                             // 0x0010(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzPlayerCharacter_RemoveRevealedActor) == 0x000008, "Wrong alignment on GzPlayerCharacter_RemoveRevealedActor");
static_assert(sizeof(GzPlayerCharacter_RemoveRevealedActor) == 0x000018, "Wrong size on GzPlayerCharacter_RemoveRevealedActor");
static_assert(offsetof(GzPlayerCharacter_RemoveRevealedActor, SourceActor) == 0x000000, "Member 'GzPlayerCharacter_RemoveRevealedActor::SourceActor' has a wrong offset!");
static_assert(offsetof(GzPlayerCharacter_RemoveRevealedActor, RevealedTag) == 0x000008, "Member 'GzPlayerCharacter_RemoveRevealedActor::RevealedTag' has a wrong offset!");
static_assert(offsetof(GzPlayerCharacter_RemoveRevealedActor, Actor) == 0x000010, "Member 'GzPlayerCharacter_RemoveRevealedActor::Actor' has a wrong offset!");

// Function G01.GzPlayerCharacter.ResetPlayerCamera
// 0x0001 (0x0001 - 0x0000)
struct GzPlayerCharacter_ResetPlayerCamera final
{
public:
	bool                                          WithInterpolation;                                 // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzPlayerCharacter_ResetPlayerCamera) == 0x000001, "Wrong alignment on GzPlayerCharacter_ResetPlayerCamera");
static_assert(sizeof(GzPlayerCharacter_ResetPlayerCamera) == 0x000001, "Wrong size on GzPlayerCharacter_ResetPlayerCamera");
static_assert(offsetof(GzPlayerCharacter_ResetPlayerCamera, WithInterpolation) == 0x000000, "Member 'GzPlayerCharacter_ResetPlayerCamera::WithInterpolation' has a wrong offset!");

// Function G01.GzPlayerCharacter.Server_GiveLoadoutFromContainer
// 0x0018 (0x0018 - 0x0000)
struct GzPlayerCharacter_Server_GiveLoadoutFromContainer final
{
public:
	class UGzLoadoutSelectionComponent*           LoadoutSelectionComponent;                         // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGuid                                  LoadoutGuid;                                       // 0x0008(0x0010)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzPlayerCharacter_Server_GiveLoadoutFromContainer) == 0x000008, "Wrong alignment on GzPlayerCharacter_Server_GiveLoadoutFromContainer");
static_assert(sizeof(GzPlayerCharacter_Server_GiveLoadoutFromContainer) == 0x000018, "Wrong size on GzPlayerCharacter_Server_GiveLoadoutFromContainer");
static_assert(offsetof(GzPlayerCharacter_Server_GiveLoadoutFromContainer, LoadoutSelectionComponent) == 0x000000, "Member 'GzPlayerCharacter_Server_GiveLoadoutFromContainer::LoadoutSelectionComponent' has a wrong offset!");
static_assert(offsetof(GzPlayerCharacter_Server_GiveLoadoutFromContainer, LoadoutGuid) == 0x000008, "Member 'GzPlayerCharacter_Server_GiveLoadoutFromContainer::LoadoutGuid' has a wrong offset!");

// Function G01.GzPlayerCharacter.Server_SetCameraCompensateRotation
// 0x0018 (0x0018 - 0x0000)
struct GzPlayerCharacter_Server_SetCameraCompensateRotation final
{
public:
	struct FRotator                               Rotation;                                          // 0x0000(0x0018)(ConstParm, Parm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzPlayerCharacter_Server_SetCameraCompensateRotation) == 0x000008, "Wrong alignment on GzPlayerCharacter_Server_SetCameraCompensateRotation");
static_assert(sizeof(GzPlayerCharacter_Server_SetCameraCompensateRotation) == 0x000018, "Wrong size on GzPlayerCharacter_Server_SetCameraCompensateRotation");
static_assert(offsetof(GzPlayerCharacter_Server_SetCameraCompensateRotation, Rotation) == 0x000000, "Member 'GzPlayerCharacter_Server_SetCameraCompensateRotation::Rotation' has a wrong offset!");

// Function G01.GzPlayerCharacter.ServerSetFreeRotationEnabled
// 0x0001 (0x0001 - 0x0000)
struct GzPlayerCharacter_ServerSetFreeRotationEnabled final
{
public:
	bool                                          bEnable;                                           // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzPlayerCharacter_ServerSetFreeRotationEnabled) == 0x000001, "Wrong alignment on GzPlayerCharacter_ServerSetFreeRotationEnabled");
static_assert(sizeof(GzPlayerCharacter_ServerSetFreeRotationEnabled) == 0x000001, "Wrong size on GzPlayerCharacter_ServerSetFreeRotationEnabled");
static_assert(offsetof(GzPlayerCharacter_ServerSetFreeRotationEnabled, bEnable) == 0x000000, "Member 'GzPlayerCharacter_ServerSetFreeRotationEnabled::bEnable' has a wrong offset!");

// Function G01.GzPlayerCharacter.SetFreeRotationEnabled
// 0x0001 (0x0001 - 0x0000)
struct GzPlayerCharacter_SetFreeRotationEnabled final
{
public:
	bool                                          bEnable;                                           // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzPlayerCharacter_SetFreeRotationEnabled) == 0x000001, "Wrong alignment on GzPlayerCharacter_SetFreeRotationEnabled");
static_assert(sizeof(GzPlayerCharacter_SetFreeRotationEnabled) == 0x000001, "Wrong size on GzPlayerCharacter_SetFreeRotationEnabled");
static_assert(offsetof(GzPlayerCharacter_SetFreeRotationEnabled, bEnable) == 0x000000, "Member 'GzPlayerCharacter_SetFreeRotationEnabled::bEnable' has a wrong offset!");

// Function G01.GzPlayerCharacter.TryInteract
// 0x0001 (0x0001 - 0x0000)
struct GzPlayerCharacter_TryInteract final
{
public:
	bool                                          bAutoInteract;                                     // 0x0000(0x0001)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzPlayerCharacter_TryInteract) == 0x000001, "Wrong alignment on GzPlayerCharacter_TryInteract");
static_assert(sizeof(GzPlayerCharacter_TryInteract) == 0x000001, "Wrong size on GzPlayerCharacter_TryInteract");
static_assert(offsetof(GzPlayerCharacter_TryInteract, bAutoInteract) == 0x000000, "Member 'GzPlayerCharacter_TryInteract::bAutoInteract' has a wrong offset!");

// Function G01.GzPlayerCharacter.WingsuitOpenCloseEvent
// 0x0001 (0x0001 - 0x0000)
struct GzPlayerCharacter_WingsuitOpenCloseEvent final
{
public:
	bool                                          bIsOpened;                                         // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzPlayerCharacter_WingsuitOpenCloseEvent) == 0x000001, "Wrong alignment on GzPlayerCharacter_WingsuitOpenCloseEvent");
static_assert(sizeof(GzPlayerCharacter_WingsuitOpenCloseEvent) == 0x000001, "Wrong size on GzPlayerCharacter_WingsuitOpenCloseEvent");
static_assert(offsetof(GzPlayerCharacter_WingsuitOpenCloseEvent, bIsOpened) == 0x000000, "Member 'GzPlayerCharacter_WingsuitOpenCloseEvent::bIsOpened' has a wrong offset!");

// Function G01.GzPlayerCharacter.CanHoldBreath
// 0x0001 (0x0001 - 0x0000)
struct GzPlayerCharacter_CanHoldBreath final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzPlayerCharacter_CanHoldBreath) == 0x000001, "Wrong alignment on GzPlayerCharacter_CanHoldBreath");
static_assert(sizeof(GzPlayerCharacter_CanHoldBreath) == 0x000001, "Wrong size on GzPlayerCharacter_CanHoldBreath");
static_assert(offsetof(GzPlayerCharacter_CanHoldBreath, ReturnValue) == 0x000000, "Member 'GzPlayerCharacter_CanHoldBreath::ReturnValue' has a wrong offset!");

// Function G01.GzPlayerCharacter.CanShootAutomaticWeapon
// 0x0001 (0x0001 - 0x0000)
struct GzPlayerCharacter_CanShootAutomaticWeapon final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzPlayerCharacter_CanShootAutomaticWeapon) == 0x000001, "Wrong alignment on GzPlayerCharacter_CanShootAutomaticWeapon");
static_assert(sizeof(GzPlayerCharacter_CanShootAutomaticWeapon) == 0x000001, "Wrong size on GzPlayerCharacter_CanShootAutomaticWeapon");
static_assert(offsetof(GzPlayerCharacter_CanShootAutomaticWeapon, ReturnValue) == 0x000000, "Member 'GzPlayerCharacter_CanShootAutomaticWeapon::ReturnValue' has a wrong offset!");

// Function G01.GzPlayerCharacter.GetAdvancedCameraComponent
// 0x0008 (0x0008 - 0x0000)
struct GzPlayerCharacter_GetAdvancedCameraComponent final
{
public:
	class UGzAdvancedCameraParamsComponent*       ReturnValue;                                       // 0x0000(0x0008)(ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzPlayerCharacter_GetAdvancedCameraComponent) == 0x000008, "Wrong alignment on GzPlayerCharacter_GetAdvancedCameraComponent");
static_assert(sizeof(GzPlayerCharacter_GetAdvancedCameraComponent) == 0x000008, "Wrong size on GzPlayerCharacter_GetAdvancedCameraComponent");
static_assert(offsetof(GzPlayerCharacter_GetAdvancedCameraComponent, ReturnValue) == 0x000000, "Member 'GzPlayerCharacter_GetAdvancedCameraComponent::ReturnValue' has a wrong offset!");

// Function G01.GzPlayerCharacter.GetBlockingHealDamageableAreaTime
// 0x0008 (0x0008 - 0x0000)
struct GzPlayerCharacter_GetBlockingHealDamageableAreaTime final
{
public:
	EGzCharacterDamageAreaType                    Type;                                              // 0x0000(0x0001)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_348C[0x3];                                     // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ReturnValue;                                       // 0x0004(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzPlayerCharacter_GetBlockingHealDamageableAreaTime) == 0x000004, "Wrong alignment on GzPlayerCharacter_GetBlockingHealDamageableAreaTime");
static_assert(sizeof(GzPlayerCharacter_GetBlockingHealDamageableAreaTime) == 0x000008, "Wrong size on GzPlayerCharacter_GetBlockingHealDamageableAreaTime");
static_assert(offsetof(GzPlayerCharacter_GetBlockingHealDamageableAreaTime, Type) == 0x000000, "Member 'GzPlayerCharacter_GetBlockingHealDamageableAreaTime::Type' has a wrong offset!");
static_assert(offsetof(GzPlayerCharacter_GetBlockingHealDamageableAreaTime, ReturnValue) == 0x000004, "Member 'GzPlayerCharacter_GetBlockingHealDamageableAreaTime::ReturnValue' has a wrong offset!");

// Function G01.GzPlayerCharacter.GetCameraComponent
// 0x0008 (0x0008 - 0x0000)
struct GzPlayerCharacter_GetCameraComponent final
{
public:
	class UGzCameraComponent*                     ReturnValue;                                       // 0x0000(0x0008)(ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzPlayerCharacter_GetCameraComponent) == 0x000008, "Wrong alignment on GzPlayerCharacter_GetCameraComponent");
static_assert(sizeof(GzPlayerCharacter_GetCameraComponent) == 0x000008, "Wrong size on GzPlayerCharacter_GetCameraComponent");
static_assert(offsetof(GzPlayerCharacter_GetCameraComponent, ReturnValue) == 0x000000, "Member 'GzPlayerCharacter_GetCameraComponent::ReturnValue' has a wrong offset!");

// Function G01.GzPlayerCharacter.GetDesiredOnEndInteractionCameraRotation
// 0x0018 (0x0018 - 0x0000)
struct GzPlayerCharacter_GetDesiredOnEndInteractionCameraRotation final
{
public:
	struct FRotator                               ReturnValue;                                       // 0x0000(0x0018)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzPlayerCharacter_GetDesiredOnEndInteractionCameraRotation) == 0x000008, "Wrong alignment on GzPlayerCharacter_GetDesiredOnEndInteractionCameraRotation");
static_assert(sizeof(GzPlayerCharacter_GetDesiredOnEndInteractionCameraRotation) == 0x000018, "Wrong size on GzPlayerCharacter_GetDesiredOnEndInteractionCameraRotation");
static_assert(offsetof(GzPlayerCharacter_GetDesiredOnEndInteractionCameraRotation, ReturnValue) == 0x000000, "Member 'GzPlayerCharacter_GetDesiredOnEndInteractionCameraRotation::ReturnValue' has a wrong offset!");

// Function G01.GzPlayerCharacter.GetInteractionComponent
// 0x0008 (0x0008 - 0x0000)
struct GzPlayerCharacter_GetInteractionComponent final
{
public:
	class UGzInteractionComponent*                ReturnValue;                                       // 0x0000(0x0008)(ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzPlayerCharacter_GetInteractionComponent) == 0x000008, "Wrong alignment on GzPlayerCharacter_GetInteractionComponent");
static_assert(sizeof(GzPlayerCharacter_GetInteractionComponent) == 0x000008, "Wrong size on GzPlayerCharacter_GetInteractionComponent");
static_assert(offsetof(GzPlayerCharacter_GetInteractionComponent, ReturnValue) == 0x000000, "Member 'GzPlayerCharacter_GetInteractionComponent::ReturnValue' has a wrong offset!");

// Function G01.GzPlayerCharacter.GetJetpackDelayAndRepairTime
// 0x0080 (0x0080 - 0x0000)
struct GzPlayerCharacter_GetJetpackDelayAndRepairTime final
{
public:
	struct FGameplayTag                           ProhibitionTag;                                    // 0x0000(0x0008)(ConstParm, Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayAttribute                     JetpackHPCurrAttribute;                            // 0x0008(0x0038)(ConstParm, Parm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayAttribute                     JetpackHPMaxAttribute;                             // 0x0040(0x0038)(ConstParm, Parm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ReturnValue;                                       // 0x0078(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_348D[0x4];                                     // 0x007C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GzPlayerCharacter_GetJetpackDelayAndRepairTime) == 0x000008, "Wrong alignment on GzPlayerCharacter_GetJetpackDelayAndRepairTime");
static_assert(sizeof(GzPlayerCharacter_GetJetpackDelayAndRepairTime) == 0x000080, "Wrong size on GzPlayerCharacter_GetJetpackDelayAndRepairTime");
static_assert(offsetof(GzPlayerCharacter_GetJetpackDelayAndRepairTime, ProhibitionTag) == 0x000000, "Member 'GzPlayerCharacter_GetJetpackDelayAndRepairTime::ProhibitionTag' has a wrong offset!");
static_assert(offsetof(GzPlayerCharacter_GetJetpackDelayAndRepairTime, JetpackHPCurrAttribute) == 0x000008, "Member 'GzPlayerCharacter_GetJetpackDelayAndRepairTime::JetpackHPCurrAttribute' has a wrong offset!");
static_assert(offsetof(GzPlayerCharacter_GetJetpackDelayAndRepairTime, JetpackHPMaxAttribute) == 0x000040, "Member 'GzPlayerCharacter_GetJetpackDelayAndRepairTime::JetpackHPMaxAttribute' has a wrong offset!");
static_assert(offsetof(GzPlayerCharacter_GetJetpackDelayAndRepairTime, ReturnValue) == 0x000078, "Member 'GzPlayerCharacter_GetJetpackDelayAndRepairTime::ReturnValue' has a wrong offset!");

// Function G01.GzPlayerCharacter.GetRegenerationTime
// 0x0080 (0x0080 - 0x0000)
struct GzPlayerCharacter_GetRegenerationTime final
{
public:
	struct FGameplayTag                           ProhibitionTag;                                    // 0x0000(0x0008)(ConstParm, Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayAttribute                     HPCurrAttribute;                                   // 0x0008(0x0038)(ConstParm, Parm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayAttribute                     HPMaxAttribute;                                    // 0x0040(0x0038)(ConstParm, Parm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ReturnValue;                                       // 0x0078(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_348E[0x4];                                     // 0x007C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GzPlayerCharacter_GetRegenerationTime) == 0x000008, "Wrong alignment on GzPlayerCharacter_GetRegenerationTime");
static_assert(sizeof(GzPlayerCharacter_GetRegenerationTime) == 0x000080, "Wrong size on GzPlayerCharacter_GetRegenerationTime");
static_assert(offsetof(GzPlayerCharacter_GetRegenerationTime, ProhibitionTag) == 0x000000, "Member 'GzPlayerCharacter_GetRegenerationTime::ProhibitionTag' has a wrong offset!");
static_assert(offsetof(GzPlayerCharacter_GetRegenerationTime, HPCurrAttribute) == 0x000008, "Member 'GzPlayerCharacter_GetRegenerationTime::HPCurrAttribute' has a wrong offset!");
static_assert(offsetof(GzPlayerCharacter_GetRegenerationTime, HPMaxAttribute) == 0x000040, "Member 'GzPlayerCharacter_GetRegenerationTime::HPMaxAttribute' has a wrong offset!");
static_assert(offsetof(GzPlayerCharacter_GetRegenerationTime, ReturnValue) == 0x000078, "Member 'GzPlayerCharacter_GetRegenerationTime::ReturnValue' has a wrong offset!");

// Function G01.GzPlayerCharacter.IsInCustomCameraMode
// 0x0001 (0x0001 - 0x0000)
struct GzPlayerCharacter_IsInCustomCameraMode final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzPlayerCharacter_IsInCustomCameraMode) == 0x000001, "Wrong alignment on GzPlayerCharacter_IsInCustomCameraMode");
static_assert(sizeof(GzPlayerCharacter_IsInCustomCameraMode) == 0x000001, "Wrong size on GzPlayerCharacter_IsInCustomCameraMode");
static_assert(offsetof(GzPlayerCharacter_IsInCustomCameraMode, ReturnValue) == 0x000000, "Member 'GzPlayerCharacter_IsInCustomCameraMode::ReturnValue' has a wrong offset!");

// Function G01.GzPlayerDeathLocationRevealSubsystem.OnPlayerAliveStateChanged
// 0x0008 (0x0008 - 0x0000)
struct GzPlayerDeathLocationRevealSubsystem_OnPlayerAliveStateChanged final
{
public:
	class AGzPlayerState*                         PlayerState;                                       // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzPlayerDeathLocationRevealSubsystem_OnPlayerAliveStateChanged) == 0x000008, "Wrong alignment on GzPlayerDeathLocationRevealSubsystem_OnPlayerAliveStateChanged");
static_assert(sizeof(GzPlayerDeathLocationRevealSubsystem_OnPlayerAliveStateChanged) == 0x000008, "Wrong size on GzPlayerDeathLocationRevealSubsystem_OnPlayerAliveStateChanged");
static_assert(offsetof(GzPlayerDeathLocationRevealSubsystem_OnPlayerAliveStateChanged, PlayerState) == 0x000000, "Member 'GzPlayerDeathLocationRevealSubsystem_OnPlayerAliveStateChanged::PlayerState' has a wrong offset!");

// Function G01.GzPlayerJoinValidationBeaconClient.ClientOnValidationResult
// 0x0018 (0x0018 - 0x0000)
struct GzPlayerJoinValidationBeaconClient_ClientOnValidationResult final
{
public:
	bool                                          bCanJoin;                                          // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3495[0x7];                                     // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 Reason;                                            // 0x0008(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzPlayerJoinValidationBeaconClient_ClientOnValidationResult) == 0x000008, "Wrong alignment on GzPlayerJoinValidationBeaconClient_ClientOnValidationResult");
static_assert(sizeof(GzPlayerJoinValidationBeaconClient_ClientOnValidationResult) == 0x000018, "Wrong size on GzPlayerJoinValidationBeaconClient_ClientOnValidationResult");
static_assert(offsetof(GzPlayerJoinValidationBeaconClient_ClientOnValidationResult, bCanJoin) == 0x000000, "Member 'GzPlayerJoinValidationBeaconClient_ClientOnValidationResult::bCanJoin' has a wrong offset!");
static_assert(offsetof(GzPlayerJoinValidationBeaconClient_ClientOnValidationResult, Reason) == 0x000008, "Member 'GzPlayerJoinValidationBeaconClient_ClientOnValidationResult::Reason' has a wrong offset!");

// Function G01.GzPlayerJoinValidationBeaconClient.ServerValidatePlayerCanJoin
// 0x0010 (0x0010 - 0x0000)
struct GzPlayerJoinValidationBeaconClient_ServerValidatePlayerCanJoin final
{
public:
	class FString                                 PlayerId;                                          // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzPlayerJoinValidationBeaconClient_ServerValidatePlayerCanJoin) == 0x000008, "Wrong alignment on GzPlayerJoinValidationBeaconClient_ServerValidatePlayerCanJoin");
static_assert(sizeof(GzPlayerJoinValidationBeaconClient_ServerValidatePlayerCanJoin) == 0x000010, "Wrong size on GzPlayerJoinValidationBeaconClient_ServerValidatePlayerCanJoin");
static_assert(offsetof(GzPlayerJoinValidationBeaconClient_ServerValidatePlayerCanJoin, PlayerId) == 0x000000, "Member 'GzPlayerJoinValidationBeaconClient_ServerValidatePlayerCanJoin::PlayerId' has a wrong offset!");

// Function G01.GzRadialMenu.CreateSegments
// 0x0004 (0x0004 - 0x0000)
struct GzRadialMenu_CreateSegments final
{
public:
	int32                                         InNumberOfSegments;                                // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzRadialMenu_CreateSegments) == 0x000004, "Wrong alignment on GzRadialMenu_CreateSegments");
static_assert(sizeof(GzRadialMenu_CreateSegments) == 0x000004, "Wrong size on GzRadialMenu_CreateSegments");
static_assert(offsetof(GzRadialMenu_CreateSegments, InNumberOfSegments) == 0x000000, "Member 'GzRadialMenu_CreateSegments::InNumberOfSegments' has a wrong offset!");

// Function G01.GzRadialMenu.UpdateRadialScroll
// 0x0004 (0x0004 - 0x0000)
struct GzRadialMenu_UpdateRadialScroll final
{
public:
	float                                         MouseDirectionAngle;                               // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzRadialMenu_UpdateRadialScroll) == 0x000004, "Wrong alignment on GzRadialMenu_UpdateRadialScroll");
static_assert(sizeof(GzRadialMenu_UpdateRadialScroll) == 0x000004, "Wrong size on GzRadialMenu_UpdateRadialScroll");
static_assert(offsetof(GzRadialMenu_UpdateRadialScroll, MouseDirectionAngle) == 0x000000, "Member 'GzRadialMenu_UpdateRadialScroll::MouseDirectionAngle' has a wrong offset!");

// Function G01.GzPlayerProfileSettings.GetAvatarsIds
// 0x0010 (0x0010 - 0x0000)
struct GzPlayerProfileSettings_GetAvatarsIds final
{
public:
	TArray<class FName>                           ReturnValue;                                       // 0x0000(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzPlayerProfileSettings_GetAvatarsIds) == 0x000008, "Wrong alignment on GzPlayerProfileSettings_GetAvatarsIds");
static_assert(sizeof(GzPlayerProfileSettings_GetAvatarsIds) == 0x000010, "Wrong size on GzPlayerProfileSettings_GetAvatarsIds");
static_assert(offsetof(GzPlayerProfileSettings_GetAvatarsIds, ReturnValue) == 0x000000, "Member 'GzPlayerProfileSettings_GetAvatarsIds::ReturnValue' has a wrong offset!");

// Function G01.GzPlayerService.GetPlayer
// 0x0110 (0x0110 - 0x0000)
struct GzPlayerService_GetPlayer final
{
public:
	struct FGzClientUserInfo                      ReturnValue;                                       // 0x0000(0x0110)(ConstParm, Parm, OutParm, ReturnParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzPlayerService_GetPlayer) == 0x000008, "Wrong alignment on GzPlayerService_GetPlayer");
static_assert(sizeof(GzPlayerService_GetPlayer) == 0x000110, "Wrong size on GzPlayerService_GetPlayer");
static_assert(offsetof(GzPlayerService_GetPlayer, ReturnValue) == 0x000000, "Member 'GzPlayerService_GetPlayer::ReturnValue' has a wrong offset!");

// Function G01.GzPlayerViewTargetInterface.GetViewTargetAbilityComponent
// 0x0008 (0x0008 - 0x0000)
struct GzPlayerViewTargetInterface_GetViewTargetAbilityComponent final
{
public:
	class UAbilitySystemComponent*                ReturnValue;                                       // 0x0000(0x0008)(ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzPlayerViewTargetInterface_GetViewTargetAbilityComponent) == 0x000008, "Wrong alignment on GzPlayerViewTargetInterface_GetViewTargetAbilityComponent");
static_assert(sizeof(GzPlayerViewTargetInterface_GetViewTargetAbilityComponent) == 0x000008, "Wrong size on GzPlayerViewTargetInterface_GetViewTargetAbilityComponent");
static_assert(offsetof(GzPlayerViewTargetInterface_GetViewTargetAbilityComponent, ReturnValue) == 0x000000, "Member 'GzPlayerViewTargetInterface_GetViewTargetAbilityComponent::ReturnValue' has a wrong offset!");

// Function G01.GzPlayerViewTargetInterface.GetViewTargetCharacter
// 0x0008 (0x0008 - 0x0000)
struct GzPlayerViewTargetInterface_GetViewTargetCharacter final
{
public:
	class AGzBaseCharacter*                       ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzPlayerViewTargetInterface_GetViewTargetCharacter) == 0x000008, "Wrong alignment on GzPlayerViewTargetInterface_GetViewTargetCharacter");
static_assert(sizeof(GzPlayerViewTargetInterface_GetViewTargetCharacter) == 0x000008, "Wrong size on GzPlayerViewTargetInterface_GetViewTargetCharacter");
static_assert(offsetof(GzPlayerViewTargetInterface_GetViewTargetCharacter, ReturnValue) == 0x000000, "Member 'GzPlayerViewTargetInterface_GetViewTargetCharacter::ReturnValue' has a wrong offset!");

// Function G01.GzPlayerViewTargetInterface.GetViewTargetInventory
// 0x0008 (0x0008 - 0x0000)
struct GzPlayerViewTargetInterface_GetViewTargetInventory final
{
public:
	class UGzInvComponent*                        ReturnValue;                                       // 0x0000(0x0008)(ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzPlayerViewTargetInterface_GetViewTargetInventory) == 0x000008, "Wrong alignment on GzPlayerViewTargetInterface_GetViewTargetInventory");
static_assert(sizeof(GzPlayerViewTargetInterface_GetViewTargetInventory) == 0x000008, "Wrong size on GzPlayerViewTargetInterface_GetViewTargetInventory");
static_assert(offsetof(GzPlayerViewTargetInterface_GetViewTargetInventory, ReturnValue) == 0x000000, "Member 'GzPlayerViewTargetInterface_GetViewTargetInventory::ReturnValue' has a wrong offset!");

// Function G01.GzPlayerViewTargetInterface.GetViewTargetPlayerState
// 0x0008 (0x0008 - 0x0000)
struct GzPlayerViewTargetInterface_GetViewTargetPlayerState final
{
public:
	class AGzPlayerState*                         ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzPlayerViewTargetInterface_GetViewTargetPlayerState) == 0x000008, "Wrong alignment on GzPlayerViewTargetInterface_GetViewTargetPlayerState");
static_assert(sizeof(GzPlayerViewTargetInterface_GetViewTargetPlayerState) == 0x000008, "Wrong size on GzPlayerViewTargetInterface_GetViewTargetPlayerState");
static_assert(offsetof(GzPlayerViewTargetInterface_GetViewTargetPlayerState, ReturnValue) == 0x000000, "Member 'GzPlayerViewTargetInterface_GetViewTargetPlayerState::ReturnValue' has a wrong offset!");

// Function G01.GzPocketGroupWidget.OnPocketWidgetAdded
// 0x0010 (0x0010 - 0x0000)
struct GzPocketGroupWidget_OnPocketWidgetAdded final
{
public:
	class UGzPocketWidget*                        PocketWidget;                                      // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Param_Index;                                       // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_34A5[0x4];                                     // 0x000C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GzPocketGroupWidget_OnPocketWidgetAdded) == 0x000008, "Wrong alignment on GzPocketGroupWidget_OnPocketWidgetAdded");
static_assert(sizeof(GzPocketGroupWidget_OnPocketWidgetAdded) == 0x000010, "Wrong size on GzPocketGroupWidget_OnPocketWidgetAdded");
static_assert(offsetof(GzPocketGroupWidget_OnPocketWidgetAdded, PocketWidget) == 0x000000, "Member 'GzPocketGroupWidget_OnPocketWidgetAdded::PocketWidget' has a wrong offset!");
static_assert(offsetof(GzPocketGroupWidget_OnPocketWidgetAdded, Param_Index) == 0x000008, "Member 'GzPocketGroupWidget_OnPocketWidgetAdded::Param_Index' has a wrong offset!");

// Function G01.GzProcedureTrackTransportLandingLocation.GetDebugLoadoutDrop
// 0x0001 (0x0001 - 0x0000)
struct GzProcedureTrackTransportLandingLocation_GetDebugLoadoutDrop final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzProcedureTrackTransportLandingLocation_GetDebugLoadoutDrop) == 0x000001, "Wrong alignment on GzProcedureTrackTransportLandingLocation_GetDebugLoadoutDrop");
static_assert(sizeof(GzProcedureTrackTransportLandingLocation_GetDebugLoadoutDrop) == 0x000001, "Wrong size on GzProcedureTrackTransportLandingLocation_GetDebugLoadoutDrop");
static_assert(offsetof(GzProcedureTrackTransportLandingLocation_GetDebugLoadoutDrop, ReturnValue) == 0x000000, "Member 'GzProcedureTrackTransportLandingLocation_GetDebugLoadoutDrop::ReturnValue' has a wrong offset!");

// Function G01.GzProcedureTrackTransportLandingLocation.CanBeUsed
// 0x0001 (0x0001 - 0x0000)
struct GzProcedureTrackTransportLandingLocation_CanBeUsed final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzProcedureTrackTransportLandingLocation_CanBeUsed) == 0x000001, "Wrong alignment on GzProcedureTrackTransportLandingLocation_CanBeUsed");
static_assert(sizeof(GzProcedureTrackTransportLandingLocation_CanBeUsed) == 0x000001, "Wrong size on GzProcedureTrackTransportLandingLocation_CanBeUsed");
static_assert(offsetof(GzProcedureTrackTransportLandingLocation_CanBeUsed, ReturnValue) == 0x000000, "Member 'GzProcedureTrackTransportLandingLocation_CanBeUsed::ReturnValue' has a wrong offset!");

// Function G01.GzProcedureTrackTransportLandingLocation.OnDeliveryTriggered
// 0x0008 (0x0008 - 0x0000)
struct GzProcedureTrackTransportLandingLocation_OnDeliveryTriggered final
{
public:
	class AGzProceduralTrackTransport*            Transport;                                         // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzProcedureTrackTransportLandingLocation_OnDeliveryTriggered) == 0x000008, "Wrong alignment on GzProcedureTrackTransportLandingLocation_OnDeliveryTriggered");
static_assert(sizeof(GzProcedureTrackTransportLandingLocation_OnDeliveryTriggered) == 0x000008, "Wrong size on GzProcedureTrackTransportLandingLocation_OnDeliveryTriggered");
static_assert(offsetof(GzProcedureTrackTransportLandingLocation_OnDeliveryTriggered, Transport) == 0x000000, "Member 'GzProcedureTrackTransportLandingLocation_OnDeliveryTriggered::Transport' has a wrong offset!");

// Function G01.GzProcedureTrackTransportLandingLocation.TriggerDropPodDelivery
// 0x0008 (0x0008 - 0x0000)
struct GzProcedureTrackTransportLandingLocation_TriggerDropPodDelivery final
{
public:
	TSubclassOf<class AGzProceduralTrackTransport> DropPodClass;                                      // 0x0000(0x0008)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzProcedureTrackTransportLandingLocation_TriggerDropPodDelivery) == 0x000008, "Wrong alignment on GzProcedureTrackTransportLandingLocation_TriggerDropPodDelivery");
static_assert(sizeof(GzProcedureTrackTransportLandingLocation_TriggerDropPodDelivery) == 0x000008, "Wrong size on GzProcedureTrackTransportLandingLocation_TriggerDropPodDelivery");
static_assert(offsetof(GzProcedureTrackTransportLandingLocation_TriggerDropPodDelivery, DropPodClass) == 0x000000, "Member 'GzProcedureTrackTransportLandingLocation_TriggerDropPodDelivery::DropPodClass' has a wrong offset!");

// Function G01.GzProgressionSubsystem.CalculateBaseHardCurrency
// 0x0010 (0x0010 - 0x0000)
struct GzProgressionSubsystem_CalculateBaseHardCurrency final
{
public:
	int32                                         PlayerId;                                          // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_34AD[0x4];                                     // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	double                                        ReturnValue;                                       // 0x0008(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzProgressionSubsystem_CalculateBaseHardCurrency) == 0x000008, "Wrong alignment on GzProgressionSubsystem_CalculateBaseHardCurrency");
static_assert(sizeof(GzProgressionSubsystem_CalculateBaseHardCurrency) == 0x000010, "Wrong size on GzProgressionSubsystem_CalculateBaseHardCurrency");
static_assert(offsetof(GzProgressionSubsystem_CalculateBaseHardCurrency, PlayerId) == 0x000000, "Member 'GzProgressionSubsystem_CalculateBaseHardCurrency::PlayerId' has a wrong offset!");
static_assert(offsetof(GzProgressionSubsystem_CalculateBaseHardCurrency, ReturnValue) == 0x000008, "Member 'GzProgressionSubsystem_CalculateBaseHardCurrency::ReturnValue' has a wrong offset!");

// Function G01.GzProgressionSubsystem.CalculateBaseSoftCurrency
// 0x0008 (0x0008 - 0x0000)
struct GzProgressionSubsystem_CalculateBaseSoftCurrency final
{
public:
	int32                                         PlayerId;                                          // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ReturnValue;                                       // 0x0004(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzProgressionSubsystem_CalculateBaseSoftCurrency) == 0x000004, "Wrong alignment on GzProgressionSubsystem_CalculateBaseSoftCurrency");
static_assert(sizeof(GzProgressionSubsystem_CalculateBaseSoftCurrency) == 0x000008, "Wrong size on GzProgressionSubsystem_CalculateBaseSoftCurrency");
static_assert(offsetof(GzProgressionSubsystem_CalculateBaseSoftCurrency, PlayerId) == 0x000000, "Member 'GzProgressionSubsystem_CalculateBaseSoftCurrency::PlayerId' has a wrong offset!");
static_assert(offsetof(GzProgressionSubsystem_CalculateBaseSoftCurrency, ReturnValue) == 0x000004, "Member 'GzProgressionSubsystem_CalculateBaseSoftCurrency::ReturnValue' has a wrong offset!");

// Function G01.GzProgressionSubsystem.CalculateBaseXp
// 0x0008 (0x0008 - 0x0000)
struct GzProgressionSubsystem_CalculateBaseXp final
{
public:
	int32                                         PlayerId;                                          // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ReturnValue;                                       // 0x0004(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzProgressionSubsystem_CalculateBaseXp) == 0x000004, "Wrong alignment on GzProgressionSubsystem_CalculateBaseXp");
static_assert(sizeof(GzProgressionSubsystem_CalculateBaseXp) == 0x000008, "Wrong size on GzProgressionSubsystem_CalculateBaseXp");
static_assert(offsetof(GzProgressionSubsystem_CalculateBaseXp, PlayerId) == 0x000000, "Member 'GzProgressionSubsystem_CalculateBaseXp::PlayerId' has a wrong offset!");
static_assert(offsetof(GzProgressionSubsystem_CalculateBaseXp, ReturnValue) == 0x000004, "Member 'GzProgressionSubsystem_CalculateBaseXp::ReturnValue' has a wrong offset!");

// Function G01.GzProjectileMine.ExplodeAtClients
// 0x0028 (0x0028 - 0x0000)
struct GzProjectileMine_ExplodeAtClients final
{
public:
	struct FGzProjectileImpactData                ImpactData;                                        // 0x0000(0x0028)(ConstParm, Parm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzProjectileMine_ExplodeAtClients) == 0x000008, "Wrong alignment on GzProjectileMine_ExplodeAtClients");
static_assert(sizeof(GzProjectileMine_ExplodeAtClients) == 0x000028, "Wrong size on GzProjectileMine_ExplodeAtClients");
static_assert(offsetof(GzProjectileMine_ExplodeAtClients, ImpactData) == 0x000000, "Member 'GzProjectileMine_ExplodeAtClients::ImpactData' has a wrong offset!");

// Function G01.GzRadialMenuButton.SetButtonName
// 0x0008 (0x0008 - 0x0000)
struct GzRadialMenuButton_SetButtonName final
{
public:
	class FName                                   InButtonName;                                      // 0x0000(0x0008)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzRadialMenuButton_SetButtonName) == 0x000004, "Wrong alignment on GzRadialMenuButton_SetButtonName");
static_assert(sizeof(GzRadialMenuButton_SetButtonName) == 0x000008, "Wrong size on GzRadialMenuButton_SetButtonName");
static_assert(offsetof(GzRadialMenuButton_SetButtonName, InButtonName) == 0x000000, "Member 'GzRadialMenuButton_SetButtonName::InButtonName' has a wrong offset!");

// Function G01.GzRadialMenuButton.GetButtonName
// 0x0008 (0x0008 - 0x0000)
struct GzRadialMenuButton_GetButtonName final
{
public:
	class FName                                   ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzRadialMenuButton_GetButtonName) == 0x000004, "Wrong alignment on GzRadialMenuButton_GetButtonName");
static_assert(sizeof(GzRadialMenuButton_GetButtonName) == 0x000008, "Wrong size on GzRadialMenuButton_GetButtonName");
static_assert(offsetof(GzRadialMenuButton_GetButtonName, ReturnValue) == 0x000000, "Member 'GzRadialMenuButton_GetButtonName::ReturnValue' has a wrong offset!");

// Function G01.GzRailTransport.EnableCarsAlignment
// 0x0001 (0x0001 - 0x0000)
struct GzRailTransport_EnableCarsAlignment final
{
public:
	bool                                          bEnable;                                           // 0x0000(0x0001)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzRailTransport_EnableCarsAlignment) == 0x000001, "Wrong alignment on GzRailTransport_EnableCarsAlignment");
static_assert(sizeof(GzRailTransport_EnableCarsAlignment) == 0x000001, "Wrong size on GzRailTransport_EnableCarsAlignment");
static_assert(offsetof(GzRailTransport_EnableCarsAlignment, bEnable) == 0x000000, "Member 'GzRailTransport_EnableCarsAlignment::bEnable' has a wrong offset!");

// Function G01.GzRandomStatics.RandomChoice
// 0x0028 (0x0028 - 0x0000)
struct GzRandomStatics_RandomChoice final
{
public:
	TArray<int32>                                 Weights;                                           // 0x0000(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	int32                                         Num;                                               // 0x0010(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_34BB[0x4];                                     // 0x0014(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<int32>                                 Result;                                            // 0x0018(0x0010)(Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzRandomStatics_RandomChoice) == 0x000008, "Wrong alignment on GzRandomStatics_RandomChoice");
static_assert(sizeof(GzRandomStatics_RandomChoice) == 0x000028, "Wrong size on GzRandomStatics_RandomChoice");
static_assert(offsetof(GzRandomStatics_RandomChoice, Weights) == 0x000000, "Member 'GzRandomStatics_RandomChoice::Weights' has a wrong offset!");
static_assert(offsetof(GzRandomStatics_RandomChoice, Num) == 0x000010, "Member 'GzRandomStatics_RandomChoice::Num' has a wrong offset!");
static_assert(offsetof(GzRandomStatics_RandomChoice, Result) == 0x000018, "Member 'GzRandomStatics_RandomChoice::Result' has a wrong offset!");

// Function G01.GzRandomStatics.RandomFloat
// 0x0014 (0x0014 - 0x0000)
struct GzRandomStatics_RandomFloat final
{
public:
	struct FFloatRange                            Range;                                             // 0x0000(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ReturnValue;                                       // 0x0010(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzRandomStatics_RandomFloat) == 0x000004, "Wrong alignment on GzRandomStatics_RandomFloat");
static_assert(sizeof(GzRandomStatics_RandomFloat) == 0x000014, "Wrong size on GzRandomStatics_RandomFloat");
static_assert(offsetof(GzRandomStatics_RandomFloat, Range) == 0x000000, "Member 'GzRandomStatics_RandomFloat::Range' has a wrong offset!");
static_assert(offsetof(GzRandomStatics_RandomFloat, ReturnValue) == 0x000010, "Member 'GzRandomStatics_RandomFloat::ReturnValue' has a wrong offset!");

// Function G01.GzRandomStatics.RandomInt
// 0x0014 (0x0014 - 0x0000)
struct GzRandomStatics_RandomInt final
{
public:
	struct FInt32Range                            Range;                                             // 0x0000(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ReturnValue;                                       // 0x0010(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzRandomStatics_RandomInt) == 0x000004, "Wrong alignment on GzRandomStatics_RandomInt");
static_assert(sizeof(GzRandomStatics_RandomInt) == 0x000014, "Wrong size on GzRandomStatics_RandomInt");
static_assert(offsetof(GzRandomStatics_RandomInt, Range) == 0x000000, "Member 'GzRandomStatics_RandomInt::Range' has a wrong offset!");
static_assert(offsetof(GzRandomStatics_RandomInt, ReturnValue) == 0x000010, "Member 'GzRandomStatics_RandomInt::ReturnValue' has a wrong offset!");

// Function G01.GzRarityRandomizationInterface.OnRarityRandomized
// 0x0008 (0x0008 - 0x0000)
struct GzRarityRandomizationInterface_OnRarityRandomized final
{
public:
	struct FGameplayTag                           RarityRandomizationTag;                            // 0x0000(0x0008)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzRarityRandomizationInterface_OnRarityRandomized) == 0x000004, "Wrong alignment on GzRarityRandomizationInterface_OnRarityRandomized");
static_assert(sizeof(GzRarityRandomizationInterface_OnRarityRandomized) == 0x000008, "Wrong size on GzRarityRandomizationInterface_OnRarityRandomized");
static_assert(offsetof(GzRarityRandomizationInterface_OnRarityRandomized, RarityRandomizationTag) == 0x000000, "Member 'GzRarityRandomizationInterface_OnRarityRandomized::RarityRandomizationTag' has a wrong offset!");

// Function G01.GzRarityRandomizationInterface.GetAvailableRarityPresets
// 0x0040 (0x0040 - 0x0000)
struct GzRarityRandomizationInterface_GetAvailableRarityPresets final
{
public:
	struct FGameplayTagContainer                  RarityPresets;                                     // 0x0000(0x0020)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	struct FGameplayTagContainer                  ReturnValue;                                       // 0x0020(0x0020)(Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzRarityRandomizationInterface_GetAvailableRarityPresets) == 0x000008, "Wrong alignment on GzRarityRandomizationInterface_GetAvailableRarityPresets");
static_assert(sizeof(GzRarityRandomizationInterface_GetAvailableRarityPresets) == 0x000040, "Wrong size on GzRarityRandomizationInterface_GetAvailableRarityPresets");
static_assert(offsetof(GzRarityRandomizationInterface_GetAvailableRarityPresets, RarityPresets) == 0x000000, "Member 'GzRarityRandomizationInterface_GetAvailableRarityPresets::RarityPresets' has a wrong offset!");
static_assert(offsetof(GzRarityRandomizationInterface_GetAvailableRarityPresets, ReturnValue) == 0x000020, "Member 'GzRarityRandomizationInterface_GetAvailableRarityPresets::ReturnValue' has a wrong offset!");

// Function G01.GzRarityRandomizationInterface.GetRarityRandomizationGroup
// 0x0008 (0x0008 - 0x0000)
struct GzRarityRandomizationInterface_GetRarityRandomizationGroup final
{
public:
	struct FGameplayTag                           ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzRarityRandomizationInterface_GetRarityRandomizationGroup) == 0x000004, "Wrong alignment on GzRarityRandomizationInterface_GetRarityRandomizationGroup");
static_assert(sizeof(GzRarityRandomizationInterface_GetRarityRandomizationGroup) == 0x000008, "Wrong size on GzRarityRandomizationInterface_GetRarityRandomizationGroup");
static_assert(offsetof(GzRarityRandomizationInterface_GetRarityRandomizationGroup, ReturnValue) == 0x000000, "Member 'GzRarityRandomizationInterface_GetRarityRandomizationGroup::ReturnValue' has a wrong offset!");

// Function G01.GzReconDrone.AddAffectedActor
// 0x0008 (0x0008 - 0x0000)
struct GzReconDrone_AddAffectedActor final
{
public:
	class AActor*                                 Actor;                                             // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzReconDrone_AddAffectedActor) == 0x000008, "Wrong alignment on GzReconDrone_AddAffectedActor");
static_assert(sizeof(GzReconDrone_AddAffectedActor) == 0x000008, "Wrong size on GzReconDrone_AddAffectedActor");
static_assert(offsetof(GzReconDrone_AddAffectedActor, Actor) == 0x000000, "Member 'GzReconDrone_AddAffectedActor::Actor' has a wrong offset!");

// Function G01.GzReconDrone.DestroyWithReason
// 0x0001 (0x0001 - 0x0000)
struct GzReconDrone_DestroyWithReason final
{
public:
	EGzReconDestroyReason                         Reason;                                            // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzReconDrone_DestroyWithReason) == 0x000001, "Wrong alignment on GzReconDrone_DestroyWithReason");
static_assert(sizeof(GzReconDrone_DestroyWithReason) == 0x000001, "Wrong size on GzReconDrone_DestroyWithReason");
static_assert(offsetof(GzReconDrone_DestroyWithReason, Reason) == 0x000000, "Member 'GzReconDrone_DestroyWithReason::Reason' has a wrong offset!");

// Function G01.GzReconDrone.RemoveAffectedActor
// 0x0008 (0x0008 - 0x0000)
struct GzReconDrone_RemoveAffectedActor final
{
public:
	class AActor*                                 Actor;                                             // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzReconDrone_RemoveAffectedActor) == 0x000008, "Wrong alignment on GzReconDrone_RemoveAffectedActor");
static_assert(sizeof(GzReconDrone_RemoveAffectedActor) == 0x000008, "Wrong size on GzReconDrone_RemoveAffectedActor");
static_assert(offsetof(GzReconDrone_RemoveAffectedActor, Actor) == 0x000000, "Member 'GzReconDrone_RemoveAffectedActor::Actor' has a wrong offset!");

// Function G01.GzRedeploymentContainer.NotifyOnTagAdded
// 0x0028 (0x0028 - 0x0000)
struct GzRedeploymentContainer_NotifyOnTagAdded final
{
public:
	struct FGameplayTag                           NewTag;                                            // 0x0000(0x0008)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTagContainer                  CurrentTags;                                       // 0x0008(0x0020)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzRedeploymentContainer_NotifyOnTagAdded) == 0x000008, "Wrong alignment on GzRedeploymentContainer_NotifyOnTagAdded");
static_assert(sizeof(GzRedeploymentContainer_NotifyOnTagAdded) == 0x000028, "Wrong size on GzRedeploymentContainer_NotifyOnTagAdded");
static_assert(offsetof(GzRedeploymentContainer_NotifyOnTagAdded, NewTag) == 0x000000, "Member 'GzRedeploymentContainer_NotifyOnTagAdded::NewTag' has a wrong offset!");
static_assert(offsetof(GzRedeploymentContainer_NotifyOnTagAdded, CurrentTags) == 0x000008, "Member 'GzRedeploymentContainer_NotifyOnTagAdded::CurrentTags' has a wrong offset!");

// Function G01.GzRedeploymentContainer.NotifyOnTagRemoved
// 0x0028 (0x0028 - 0x0000)
struct GzRedeploymentContainer_NotifyOnTagRemoved final
{
public:
	struct FGameplayTag                           RemovedTag;                                        // 0x0000(0x0008)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTagContainer                  CurrentTags;                                       // 0x0008(0x0020)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzRedeploymentContainer_NotifyOnTagRemoved) == 0x000008, "Wrong alignment on GzRedeploymentContainer_NotifyOnTagRemoved");
static_assert(sizeof(GzRedeploymentContainer_NotifyOnTagRemoved) == 0x000028, "Wrong size on GzRedeploymentContainer_NotifyOnTagRemoved");
static_assert(offsetof(GzRedeploymentContainer_NotifyOnTagRemoved, RemovedTag) == 0x000000, "Member 'GzRedeploymentContainer_NotifyOnTagRemoved::RemovedTag' has a wrong offset!");
static_assert(offsetof(GzRedeploymentContainer_NotifyOnTagRemoved, CurrentTags) == 0x000008, "Member 'GzRedeploymentContainer_NotifyOnTagRemoved::CurrentTags' has a wrong offset!");

// Function G01.GzRedeploymentTerminal.GetRedeploymentTransformOverride
// 0x0060 (0x0060 - 0x0000)
struct GzRedeploymentTerminal_GetRedeploymentTransformOverride final
{
public:
	struct FTransform                             ReturnValue;                                       // 0x0000(0x0060)(Parm, OutParm, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzRedeploymentTerminal_GetRedeploymentTransformOverride) == 0x000010, "Wrong alignment on GzRedeploymentTerminal_GetRedeploymentTransformOverride");
static_assert(sizeof(GzRedeploymentTerminal_GetRedeploymentTransformOverride) == 0x000060, "Wrong size on GzRedeploymentTerminal_GetRedeploymentTransformOverride");
static_assert(offsetof(GzRedeploymentTerminal_GetRedeploymentTransformOverride, ReturnValue) == 0x000000, "Member 'GzRedeploymentTerminal_GetRedeploymentTransformOverride::ReturnValue' has a wrong offset!");

// Function G01.GzRedeploymentTerminal.OnAvailabilityChanged
// 0x0001 (0x0001 - 0x0000)
struct GzRedeploymentTerminal_OnAvailabilityChanged final
{
public:
	bool                                          bNewAvailable;                                     // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzRedeploymentTerminal_OnAvailabilityChanged) == 0x000001, "Wrong alignment on GzRedeploymentTerminal_OnAvailabilityChanged");
static_assert(sizeof(GzRedeploymentTerminal_OnAvailabilityChanged) == 0x000001, "Wrong size on GzRedeploymentTerminal_OnAvailabilityChanged");
static_assert(offsetof(GzRedeploymentTerminal_OnAvailabilityChanged, bNewAvailable) == 0x000000, "Member 'GzRedeploymentTerminal_OnAvailabilityChanged::bNewAvailable' has a wrong offset!");

// Function G01.GzRedeploymentTerminal.OnPlayerStateReplicated
// 0x0008 (0x0008 - 0x0000)
struct GzRedeploymentTerminal_OnPlayerStateReplicated final
{
public:
	class AGzPlayerState*                         PlayerState;                                       // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzRedeploymentTerminal_OnPlayerStateReplicated) == 0x000008, "Wrong alignment on GzRedeploymentTerminal_OnPlayerStateReplicated");
static_assert(sizeof(GzRedeploymentTerminal_OnPlayerStateReplicated) == 0x000008, "Wrong size on GzRedeploymentTerminal_OnPlayerStateReplicated");
static_assert(offsetof(GzRedeploymentTerminal_OnPlayerStateReplicated, PlayerState) == 0x000000, "Member 'GzRedeploymentTerminal_OnPlayerStateReplicated::PlayerState' has a wrong offset!");

// Function G01.GzRedeploymentTerminal.OnPlayersTeamChanged
// 0x0008 (0x0008 - 0x0000)
struct GzRedeploymentTerminal_OnPlayersTeamChanged final
{
public:
	class AGzPlayerState*                         PlayerState;                                       // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzRedeploymentTerminal_OnPlayersTeamChanged) == 0x000008, "Wrong alignment on GzRedeploymentTerminal_OnPlayersTeamChanged");
static_assert(sizeof(GzRedeploymentTerminal_OnPlayersTeamChanged) == 0x000008, "Wrong size on GzRedeploymentTerminal_OnPlayersTeamChanged");
static_assert(offsetof(GzRedeploymentTerminal_OnPlayersTeamChanged, PlayerState) == 0x000000, "Member 'GzRedeploymentTerminal_OnPlayersTeamChanged::PlayerState' has a wrong offset!");

// Function G01.GzRedeploymentTerminal.OnTeammateStateChanged
// 0x0008 (0x0008 - 0x0000)
struct GzRedeploymentTerminal_OnTeammateStateChanged final
{
public:
	class AGzPlayerState*                         Teammate;                                          // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzRedeploymentTerminal_OnTeammateStateChanged) == 0x000008, "Wrong alignment on GzRedeploymentTerminal_OnTeammateStateChanged");
static_assert(sizeof(GzRedeploymentTerminal_OnTeammateStateChanged) == 0x000008, "Wrong size on GzRedeploymentTerminal_OnTeammateStateChanged");
static_assert(offsetof(GzRedeploymentTerminal_OnTeammateStateChanged, Teammate) == 0x000000, "Member 'GzRedeploymentTerminal_OnTeammateStateChanged::Teammate' has a wrong offset!");

// Function G01.GzRedeploymentTerminal.OnViewTargetChanged
// 0x0008 (0x0008 - 0x0000)
struct GzRedeploymentTerminal_OnViewTargetChanged final
{
public:
	class APawn*                                  NewViewTarget;                                     // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzRedeploymentTerminal_OnViewTargetChanged) == 0x000008, "Wrong alignment on GzRedeploymentTerminal_OnViewTargetChanged");
static_assert(sizeof(GzRedeploymentTerminal_OnViewTargetChanged) == 0x000008, "Wrong size on GzRedeploymentTerminal_OnViewTargetChanged");
static_assert(offsetof(GzRedeploymentTerminal_OnViewTargetChanged, NewViewTarget) == 0x000000, "Member 'GzRedeploymentTerminal_OnViewTargetChanged::NewViewTarget' has a wrong offset!");

// Function G01.GzRedeploymentTerminal.OnZoneStageChanged
// 0x0004 (0x0004 - 0x0000)
struct GzRedeploymentTerminal_OnZoneStageChanged final
{
public:
	int32                                         StageIndex;                                        // 0x0000(0x0004)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzRedeploymentTerminal_OnZoneStageChanged) == 0x000004, "Wrong alignment on GzRedeploymentTerminal_OnZoneStageChanged");
static_assert(sizeof(GzRedeploymentTerminal_OnZoneStageChanged) == 0x000004, "Wrong size on GzRedeploymentTerminal_OnZoneStageChanged");
static_assert(offsetof(GzRedeploymentTerminal_OnZoneStageChanged, StageIndex) == 0x000000, "Member 'GzRedeploymentTerminal_OnZoneStageChanged::StageIndex' has a wrong offset!");

// Function G01.GzRedeploymentTerminal.RedeployPlayers
// 0x0018 (0x0018 - 0x0000)
struct GzRedeploymentTerminal_RedeployPlayers final
{
public:
	class AGzPlayerController*                    Caller;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class AGzPlayerState*>                 PlayerStates;                                      // 0x0008(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzRedeploymentTerminal_RedeployPlayers) == 0x000008, "Wrong alignment on GzRedeploymentTerminal_RedeployPlayers");
static_assert(sizeof(GzRedeploymentTerminal_RedeployPlayers) == 0x000018, "Wrong size on GzRedeploymentTerminal_RedeployPlayers");
static_assert(offsetof(GzRedeploymentTerminal_RedeployPlayers, Caller) == 0x000000, "Member 'GzRedeploymentTerminal_RedeployPlayers::Caller' has a wrong offset!");
static_assert(offsetof(GzRedeploymentTerminal_RedeployPlayers, PlayerStates) == 0x000008, "Member 'GzRedeploymentTerminal_RedeployPlayers::PlayerStates' has a wrong offset!");

// Function G01.GzRedeploymentTerminal.GetRedeploymentCost
// 0x0010 (0x0010 - 0x0000)
struct GzRedeploymentTerminal_GetRedeploymentCost final
{
public:
	const class AGzPlayerState*                   PlayerState;                                       // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ReturnValue;                                       // 0x0008(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_34C5[0x4];                                     // 0x000C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GzRedeploymentTerminal_GetRedeploymentCost) == 0x000008, "Wrong alignment on GzRedeploymentTerminal_GetRedeploymentCost");
static_assert(sizeof(GzRedeploymentTerminal_GetRedeploymentCost) == 0x000010, "Wrong size on GzRedeploymentTerminal_GetRedeploymentCost");
static_assert(offsetof(GzRedeploymentTerminal_GetRedeploymentCost, PlayerState) == 0x000000, "Member 'GzRedeploymentTerminal_GetRedeploymentCost::PlayerState' has a wrong offset!");
static_assert(offsetof(GzRedeploymentTerminal_GetRedeploymentCost, ReturnValue) == 0x000008, "Member 'GzRedeploymentTerminal_GetRedeploymentCost::ReturnValue' has a wrong offset!");

// Function G01.GzRedeploymentTerminal.GetTotalRedeploymentCost
// 0x0018 (0x0018 - 0x0000)
struct GzRedeploymentTerminal_GetTotalRedeploymentCost final
{
public:
	TArray<class AGzPlayerState*>                 PlayerStates;                                      // 0x0000(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	int32                                         ReturnValue;                                       // 0x0010(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_34C6[0x4];                                     // 0x0014(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GzRedeploymentTerminal_GetTotalRedeploymentCost) == 0x000008, "Wrong alignment on GzRedeploymentTerminal_GetTotalRedeploymentCost");
static_assert(sizeof(GzRedeploymentTerminal_GetTotalRedeploymentCost) == 0x000018, "Wrong size on GzRedeploymentTerminal_GetTotalRedeploymentCost");
static_assert(offsetof(GzRedeploymentTerminal_GetTotalRedeploymentCost, PlayerStates) == 0x000000, "Member 'GzRedeploymentTerminal_GetTotalRedeploymentCost::PlayerStates' has a wrong offset!");
static_assert(offsetof(GzRedeploymentTerminal_GetTotalRedeploymentCost, ReturnValue) == 0x000010, "Member 'GzRedeploymentTerminal_GetTotalRedeploymentCost::ReturnValue' has a wrong offset!");

// Function G01.GzRedeploymentTerminal.IsAvailable
// 0x0001 (0x0001 - 0x0000)
struct GzRedeploymentTerminal_IsAvailable final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzRedeploymentTerminal_IsAvailable) == 0x000001, "Wrong alignment on GzRedeploymentTerminal_IsAvailable");
static_assert(sizeof(GzRedeploymentTerminal_IsAvailable) == 0x000001, "Wrong size on GzRedeploymentTerminal_IsAvailable");
static_assert(offsetof(GzRedeploymentTerminal_IsAvailable, ReturnValue) == 0x000000, "Member 'GzRedeploymentTerminal_IsAvailable::ReturnValue' has a wrong offset!");

// Function G01.GzSearchZonesSubsystem.AssignZoneToPlayer
// 0x0008 (0x0008 - 0x0000)
struct GzSearchZonesSubsystem_AssignZoneToPlayer final
{
public:
	int32                                         PlayerId;                                          // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ZoneId;                                            // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzSearchZonesSubsystem_AssignZoneToPlayer) == 0x000004, "Wrong alignment on GzSearchZonesSubsystem_AssignZoneToPlayer");
static_assert(sizeof(GzSearchZonesSubsystem_AssignZoneToPlayer) == 0x000008, "Wrong size on GzSearchZonesSubsystem_AssignZoneToPlayer");
static_assert(offsetof(GzSearchZonesSubsystem_AssignZoneToPlayer, PlayerId) == 0x000000, "Member 'GzSearchZonesSubsystem_AssignZoneToPlayer::PlayerId' has a wrong offset!");
static_assert(offsetof(GzSearchZonesSubsystem_AssignZoneToPlayer, ZoneId) == 0x000004, "Member 'GzSearchZonesSubsystem_AssignZoneToPlayer::ZoneId' has a wrong offset!");

// Function G01.GzSearchZonesSubsystem.AssignZoneToTeam
// 0x0010 (0x0010 - 0x0000)
struct GzSearchZonesSubsystem_AssignZoneToTeam final
{
public:
	class AGzTeam*                                Team;                                              // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ZoneId;                                            // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_34D5[0x4];                                     // 0x000C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GzSearchZonesSubsystem_AssignZoneToTeam) == 0x000008, "Wrong alignment on GzSearchZonesSubsystem_AssignZoneToTeam");
static_assert(sizeof(GzSearchZonesSubsystem_AssignZoneToTeam) == 0x000010, "Wrong size on GzSearchZonesSubsystem_AssignZoneToTeam");
static_assert(offsetof(GzSearchZonesSubsystem_AssignZoneToTeam, Team) == 0x000000, "Member 'GzSearchZonesSubsystem_AssignZoneToTeam::Team' has a wrong offset!");
static_assert(offsetof(GzSearchZonesSubsystem_AssignZoneToTeam, ZoneId) == 0x000008, "Member 'GzSearchZonesSubsystem_AssignZoneToTeam::ZoneId' has a wrong offset!");

// Function G01.GzSearchZonesSubsystem.CreateZone
// 0x0058 (0x0058 - 0x0000)
struct GzSearchZonesSubsystem_CreateZone final
{
public:
	struct FGzSearchZoneSpec                      InSpec;                                            // 0x0000(0x0048)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	class AActor*                                 TargetActor;                                       // 0x0048(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ReturnValue;                                       // 0x0050(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_34D6[0x4];                                     // 0x0054(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GzSearchZonesSubsystem_CreateZone) == 0x000008, "Wrong alignment on GzSearchZonesSubsystem_CreateZone");
static_assert(sizeof(GzSearchZonesSubsystem_CreateZone) == 0x000058, "Wrong size on GzSearchZonesSubsystem_CreateZone");
static_assert(offsetof(GzSearchZonesSubsystem_CreateZone, InSpec) == 0x000000, "Member 'GzSearchZonesSubsystem_CreateZone::InSpec' has a wrong offset!");
static_assert(offsetof(GzSearchZonesSubsystem_CreateZone, TargetActor) == 0x000048, "Member 'GzSearchZonesSubsystem_CreateZone::TargetActor' has a wrong offset!");
static_assert(offsetof(GzSearchZonesSubsystem_CreateZone, ReturnValue) == 0x000050, "Member 'GzSearchZonesSubsystem_CreateZone::ReturnValue' has a wrong offset!");

// Function G01.GzSearchZonesSubsystem.RemoveZone
// 0x0004 (0x0004 - 0x0000)
struct GzSearchZonesSubsystem_RemoveZone final
{
public:
	int32                                         ZoneId;                                            // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzSearchZonesSubsystem_RemoveZone) == 0x000004, "Wrong alignment on GzSearchZonesSubsystem_RemoveZone");
static_assert(sizeof(GzSearchZonesSubsystem_RemoveZone) == 0x000004, "Wrong size on GzSearchZonesSubsystem_RemoveZone");
static_assert(offsetof(GzSearchZonesSubsystem_RemoveZone, ZoneId) == 0x000000, "Member 'GzSearchZonesSubsystem_RemoveZone::ZoneId' has a wrong offset!");

// Function G01.GzSearchZonesSubsystem.UnassignZoneFromPlayer
// 0x0008 (0x0008 - 0x0000)
struct GzSearchZonesSubsystem_UnassignZoneFromPlayer final
{
public:
	int32                                         PlayerId;                                          // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ZoneId;                                            // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzSearchZonesSubsystem_UnassignZoneFromPlayer) == 0x000004, "Wrong alignment on GzSearchZonesSubsystem_UnassignZoneFromPlayer");
static_assert(sizeof(GzSearchZonesSubsystem_UnassignZoneFromPlayer) == 0x000008, "Wrong size on GzSearchZonesSubsystem_UnassignZoneFromPlayer");
static_assert(offsetof(GzSearchZonesSubsystem_UnassignZoneFromPlayer, PlayerId) == 0x000000, "Member 'GzSearchZonesSubsystem_UnassignZoneFromPlayer::PlayerId' has a wrong offset!");
static_assert(offsetof(GzSearchZonesSubsystem_UnassignZoneFromPlayer, ZoneId) == 0x000004, "Member 'GzSearchZonesSubsystem_UnassignZoneFromPlayer::ZoneId' has a wrong offset!");

// Function G01.GzSearchZonesSubsystem.UnassignZoneFromTeam
// 0x0010 (0x0010 - 0x0000)
struct GzSearchZonesSubsystem_UnassignZoneFromTeam final
{
public:
	class AGzTeam*                                Team;                                              // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ZoneId;                                            // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_34D7[0x4];                                     // 0x000C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GzSearchZonesSubsystem_UnassignZoneFromTeam) == 0x000008, "Wrong alignment on GzSearchZonesSubsystem_UnassignZoneFromTeam");
static_assert(sizeof(GzSearchZonesSubsystem_UnassignZoneFromTeam) == 0x000010, "Wrong size on GzSearchZonesSubsystem_UnassignZoneFromTeam");
static_assert(offsetof(GzSearchZonesSubsystem_UnassignZoneFromTeam, Team) == 0x000000, "Member 'GzSearchZonesSubsystem_UnassignZoneFromTeam::Team' has a wrong offset!");
static_assert(offsetof(GzSearchZonesSubsystem_UnassignZoneFromTeam, ZoneId) == 0x000008, "Member 'GzSearchZonesSubsystem_UnassignZoneFromTeam::ZoneId' has a wrong offset!");

// Function G01.GzSearchZonesSubsystem.HasWatcher
// 0x000C (0x000C - 0x0000)
struct GzSearchZonesSubsystem_HasWatcher final
{
public:
	int32                                         ZoneId;                                            // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         PlayerId;                                          // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_34D8[0x3];                                     // 0x0009(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GzSearchZonesSubsystem_HasWatcher) == 0x000004, "Wrong alignment on GzSearchZonesSubsystem_HasWatcher");
static_assert(sizeof(GzSearchZonesSubsystem_HasWatcher) == 0x00000C, "Wrong size on GzSearchZonesSubsystem_HasWatcher");
static_assert(offsetof(GzSearchZonesSubsystem_HasWatcher, ZoneId) == 0x000000, "Member 'GzSearchZonesSubsystem_HasWatcher::ZoneId' has a wrong offset!");
static_assert(offsetof(GzSearchZonesSubsystem_HasWatcher, PlayerId) == 0x000004, "Member 'GzSearchZonesSubsystem_HasWatcher::PlayerId' has a wrong offset!");
static_assert(offsetof(GzSearchZonesSubsystem_HasWatcher, ReturnValue) == 0x000008, "Member 'GzSearchZonesSubsystem_HasWatcher::ReturnValue' has a wrong offset!");

// Function G01.GzSearchZonesSubsystem.HasZone
// 0x0008 (0x0008 - 0x0000)
struct GzSearchZonesSubsystem_HasZone final
{
public:
	int32                                         ZoneId;                                            // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0004(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_34D9[0x3];                                     // 0x0005(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GzSearchZonesSubsystem_HasZone) == 0x000004, "Wrong alignment on GzSearchZonesSubsystem_HasZone");
static_assert(sizeof(GzSearchZonesSubsystem_HasZone) == 0x000008, "Wrong size on GzSearchZonesSubsystem_HasZone");
static_assert(offsetof(GzSearchZonesSubsystem_HasZone, ZoneId) == 0x000000, "Member 'GzSearchZonesSubsystem_HasZone::ZoneId' has a wrong offset!");
static_assert(offsetof(GzSearchZonesSubsystem_HasZone, ReturnValue) == 0x000004, "Member 'GzSearchZonesSubsystem_HasZone::ReturnValue' has a wrong offset!");

// Function G01.GzServerMarkerSubsystem.AssignMarkerToPlayer
// 0x0010 (0x0010 - 0x0000)
struct GzServerMarkerSubsystem_AssignMarkerToPlayer final
{
public:
	int32                                         MarkerId;                                          // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_34DF[0x4];                                     // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class AGzPlayerState*                         PS;                                                // 0x0008(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzServerMarkerSubsystem_AssignMarkerToPlayer) == 0x000008, "Wrong alignment on GzServerMarkerSubsystem_AssignMarkerToPlayer");
static_assert(sizeof(GzServerMarkerSubsystem_AssignMarkerToPlayer) == 0x000010, "Wrong size on GzServerMarkerSubsystem_AssignMarkerToPlayer");
static_assert(offsetof(GzServerMarkerSubsystem_AssignMarkerToPlayer, MarkerId) == 0x000000, "Member 'GzServerMarkerSubsystem_AssignMarkerToPlayer::MarkerId' has a wrong offset!");
static_assert(offsetof(GzServerMarkerSubsystem_AssignMarkerToPlayer, PS) == 0x000008, "Member 'GzServerMarkerSubsystem_AssignMarkerToPlayer::PS' has a wrong offset!");

// Function G01.GzServerMarkerSubsystem.AssignMarkerToPlayerId
// 0x0008 (0x0008 - 0x0000)
struct GzServerMarkerSubsystem_AssignMarkerToPlayerId final
{
public:
	int32                                         MarkerId;                                          // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         PlayerId;                                          // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzServerMarkerSubsystem_AssignMarkerToPlayerId) == 0x000004, "Wrong alignment on GzServerMarkerSubsystem_AssignMarkerToPlayerId");
static_assert(sizeof(GzServerMarkerSubsystem_AssignMarkerToPlayerId) == 0x000008, "Wrong size on GzServerMarkerSubsystem_AssignMarkerToPlayerId");
static_assert(offsetof(GzServerMarkerSubsystem_AssignMarkerToPlayerId, MarkerId) == 0x000000, "Member 'GzServerMarkerSubsystem_AssignMarkerToPlayerId::MarkerId' has a wrong offset!");
static_assert(offsetof(GzServerMarkerSubsystem_AssignMarkerToPlayerId, PlayerId) == 0x000004, "Member 'GzServerMarkerSubsystem_AssignMarkerToPlayerId::PlayerId' has a wrong offset!");

// Function G01.GzServerMarkerSubsystem.AssignMarkerToTeam
// 0x0010 (0x0010 - 0x0000)
struct GzServerMarkerSubsystem_AssignMarkerToTeam final
{
public:
	int32                                         MarkerId;                                          // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_34E0[0x4];                                     // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class AGzTeam*                                Team;                                              // 0x0008(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzServerMarkerSubsystem_AssignMarkerToTeam) == 0x000008, "Wrong alignment on GzServerMarkerSubsystem_AssignMarkerToTeam");
static_assert(sizeof(GzServerMarkerSubsystem_AssignMarkerToTeam) == 0x000010, "Wrong size on GzServerMarkerSubsystem_AssignMarkerToTeam");
static_assert(offsetof(GzServerMarkerSubsystem_AssignMarkerToTeam, MarkerId) == 0x000000, "Member 'GzServerMarkerSubsystem_AssignMarkerToTeam::MarkerId' has a wrong offset!");
static_assert(offsetof(GzServerMarkerSubsystem_AssignMarkerToTeam, Team) == 0x000008, "Member 'GzServerMarkerSubsystem_AssignMarkerToTeam::Team' has a wrong offset!");

// Function G01.GzServerMarkerSubsystem.AssignMarkerToTeamId
// 0x0008 (0x0008 - 0x0000)
struct GzServerMarkerSubsystem_AssignMarkerToTeamId final
{
public:
	int32                                         MarkerId;                                          // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         TeamID;                                            // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzServerMarkerSubsystem_AssignMarkerToTeamId) == 0x000004, "Wrong alignment on GzServerMarkerSubsystem_AssignMarkerToTeamId");
static_assert(sizeof(GzServerMarkerSubsystem_AssignMarkerToTeamId) == 0x000008, "Wrong size on GzServerMarkerSubsystem_AssignMarkerToTeamId");
static_assert(offsetof(GzServerMarkerSubsystem_AssignMarkerToTeamId, MarkerId) == 0x000000, "Member 'GzServerMarkerSubsystem_AssignMarkerToTeamId::MarkerId' has a wrong offset!");
static_assert(offsetof(GzServerMarkerSubsystem_AssignMarkerToTeamId, TeamID) == 0x000004, "Member 'GzServerMarkerSubsystem_AssignMarkerToTeamId::TeamID' has a wrong offset!");

// Function G01.GzServerMarkerSubsystem.CreateMarkerAtLocation
// 0x0060 (0x0060 - 0x0000)
struct GzServerMarkerSubsystem_CreateMarkerAtLocation final
{
public:
	struct FGzServerMarkerBuildDataLocation       BuildData;                                         // 0x0000(0x0058)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	int32                                         ReturnValue;                                       // 0x0058(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_34E1[0x4];                                     // 0x005C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GzServerMarkerSubsystem_CreateMarkerAtLocation) == 0x000008, "Wrong alignment on GzServerMarkerSubsystem_CreateMarkerAtLocation");
static_assert(sizeof(GzServerMarkerSubsystem_CreateMarkerAtLocation) == 0x000060, "Wrong size on GzServerMarkerSubsystem_CreateMarkerAtLocation");
static_assert(offsetof(GzServerMarkerSubsystem_CreateMarkerAtLocation, BuildData) == 0x000000, "Member 'GzServerMarkerSubsystem_CreateMarkerAtLocation::BuildData' has a wrong offset!");
static_assert(offsetof(GzServerMarkerSubsystem_CreateMarkerAtLocation, ReturnValue) == 0x000058, "Member 'GzServerMarkerSubsystem_CreateMarkerAtLocation::ReturnValue' has a wrong offset!");

// Function G01.GzServerMarkerSubsystem.CreateMarkerForActor
// 0x0058 (0x0058 - 0x0000)
struct GzServerMarkerSubsystem_CreateMarkerForActor final
{
public:
	struct FGzServerMarkerBuildDataActor          BuildData;                                         // 0x0000(0x0050)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	int32                                         ReturnValue;                                       // 0x0050(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_34E2[0x4];                                     // 0x0054(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GzServerMarkerSubsystem_CreateMarkerForActor) == 0x000008, "Wrong alignment on GzServerMarkerSubsystem_CreateMarkerForActor");
static_assert(sizeof(GzServerMarkerSubsystem_CreateMarkerForActor) == 0x000058, "Wrong size on GzServerMarkerSubsystem_CreateMarkerForActor");
static_assert(offsetof(GzServerMarkerSubsystem_CreateMarkerForActor, BuildData) == 0x000000, "Member 'GzServerMarkerSubsystem_CreateMarkerForActor::BuildData' has a wrong offset!");
static_assert(offsetof(GzServerMarkerSubsystem_CreateMarkerForActor, ReturnValue) == 0x000050, "Member 'GzServerMarkerSubsystem_CreateMarkerForActor::ReturnValue' has a wrong offset!");

// Function G01.GzServerMarkerSubsystem.DestroyMarker
// 0x0004 (0x0004 - 0x0000)
struct GzServerMarkerSubsystem_DestroyMarker final
{
public:
	int32                                         MarkerId;                                          // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzServerMarkerSubsystem_DestroyMarker) == 0x000004, "Wrong alignment on GzServerMarkerSubsystem_DestroyMarker");
static_assert(sizeof(GzServerMarkerSubsystem_DestroyMarker) == 0x000004, "Wrong size on GzServerMarkerSubsystem_DestroyMarker");
static_assert(offsetof(GzServerMarkerSubsystem_DestroyMarker, MarkerId) == 0x000000, "Member 'GzServerMarkerSubsystem_DestroyMarker::MarkerId' has a wrong offset!");

// Function G01.GzServerMarkerSubsystem.UnassignMarkerFromPlayer
// 0x0018 (0x0018 - 0x0000)
struct GzServerMarkerSubsystem_UnassignMarkerFromPlayer final
{
public:
	int32                                         MarkerId;                                          // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_34E3[0x4];                                     // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class AGzPlayerState*                         PS;                                                // 0x0008(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0010(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_34E4[0x7];                                     // 0x0011(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GzServerMarkerSubsystem_UnassignMarkerFromPlayer) == 0x000008, "Wrong alignment on GzServerMarkerSubsystem_UnassignMarkerFromPlayer");
static_assert(sizeof(GzServerMarkerSubsystem_UnassignMarkerFromPlayer) == 0x000018, "Wrong size on GzServerMarkerSubsystem_UnassignMarkerFromPlayer");
static_assert(offsetof(GzServerMarkerSubsystem_UnassignMarkerFromPlayer, MarkerId) == 0x000000, "Member 'GzServerMarkerSubsystem_UnassignMarkerFromPlayer::MarkerId' has a wrong offset!");
static_assert(offsetof(GzServerMarkerSubsystem_UnassignMarkerFromPlayer, PS) == 0x000008, "Member 'GzServerMarkerSubsystem_UnassignMarkerFromPlayer::PS' has a wrong offset!");
static_assert(offsetof(GzServerMarkerSubsystem_UnassignMarkerFromPlayer, ReturnValue) == 0x000010, "Member 'GzServerMarkerSubsystem_UnassignMarkerFromPlayer::ReturnValue' has a wrong offset!");

// Function G01.GzServerMarkerSubsystem.UnassignMarkerFromPlayerId
// 0x000C (0x000C - 0x0000)
struct GzServerMarkerSubsystem_UnassignMarkerFromPlayerId final
{
public:
	int32                                         MarkerId;                                          // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         PlayerId;                                          // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_34E5[0x3];                                     // 0x0009(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GzServerMarkerSubsystem_UnassignMarkerFromPlayerId) == 0x000004, "Wrong alignment on GzServerMarkerSubsystem_UnassignMarkerFromPlayerId");
static_assert(sizeof(GzServerMarkerSubsystem_UnassignMarkerFromPlayerId) == 0x00000C, "Wrong size on GzServerMarkerSubsystem_UnassignMarkerFromPlayerId");
static_assert(offsetof(GzServerMarkerSubsystem_UnassignMarkerFromPlayerId, MarkerId) == 0x000000, "Member 'GzServerMarkerSubsystem_UnassignMarkerFromPlayerId::MarkerId' has a wrong offset!");
static_assert(offsetof(GzServerMarkerSubsystem_UnassignMarkerFromPlayerId, PlayerId) == 0x000004, "Member 'GzServerMarkerSubsystem_UnassignMarkerFromPlayerId::PlayerId' has a wrong offset!");
static_assert(offsetof(GzServerMarkerSubsystem_UnassignMarkerFromPlayerId, ReturnValue) == 0x000008, "Member 'GzServerMarkerSubsystem_UnassignMarkerFromPlayerId::ReturnValue' has a wrong offset!");

// Function G01.GzServerMarkerSubsystem.UnassignMarkerFromTeam
// 0x0018 (0x0018 - 0x0000)
struct GzServerMarkerSubsystem_UnassignMarkerFromTeam final
{
public:
	int32                                         MarkerId;                                          // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_34E6[0x4];                                     // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class AGzTeam*                                Team;                                              // 0x0008(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0010(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_34E7[0x7];                                     // 0x0011(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GzServerMarkerSubsystem_UnassignMarkerFromTeam) == 0x000008, "Wrong alignment on GzServerMarkerSubsystem_UnassignMarkerFromTeam");
static_assert(sizeof(GzServerMarkerSubsystem_UnassignMarkerFromTeam) == 0x000018, "Wrong size on GzServerMarkerSubsystem_UnassignMarkerFromTeam");
static_assert(offsetof(GzServerMarkerSubsystem_UnassignMarkerFromTeam, MarkerId) == 0x000000, "Member 'GzServerMarkerSubsystem_UnassignMarkerFromTeam::MarkerId' has a wrong offset!");
static_assert(offsetof(GzServerMarkerSubsystem_UnassignMarkerFromTeam, Team) == 0x000008, "Member 'GzServerMarkerSubsystem_UnassignMarkerFromTeam::Team' has a wrong offset!");
static_assert(offsetof(GzServerMarkerSubsystem_UnassignMarkerFromTeam, ReturnValue) == 0x000010, "Member 'GzServerMarkerSubsystem_UnassignMarkerFromTeam::ReturnValue' has a wrong offset!");

// Function G01.GzServerMarkerSubsystem.UnassignMarkerFromTeamId
// 0x000C (0x000C - 0x0000)
struct GzServerMarkerSubsystem_UnassignMarkerFromTeamId final
{
public:
	int32                                         MarkerId;                                          // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         TeamID;                                            // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_34E8[0x3];                                     // 0x0009(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GzServerMarkerSubsystem_UnassignMarkerFromTeamId) == 0x000004, "Wrong alignment on GzServerMarkerSubsystem_UnassignMarkerFromTeamId");
static_assert(sizeof(GzServerMarkerSubsystem_UnassignMarkerFromTeamId) == 0x00000C, "Wrong size on GzServerMarkerSubsystem_UnassignMarkerFromTeamId");
static_assert(offsetof(GzServerMarkerSubsystem_UnassignMarkerFromTeamId, MarkerId) == 0x000000, "Member 'GzServerMarkerSubsystem_UnassignMarkerFromTeamId::MarkerId' has a wrong offset!");
static_assert(offsetof(GzServerMarkerSubsystem_UnassignMarkerFromTeamId, TeamID) == 0x000004, "Member 'GzServerMarkerSubsystem_UnassignMarkerFromTeamId::TeamID' has a wrong offset!");
static_assert(offsetof(GzServerMarkerSubsystem_UnassignMarkerFromTeamId, ReturnValue) == 0x000008, "Member 'GzServerMarkerSubsystem_UnassignMarkerFromTeamId::ReturnValue' has a wrong offset!");

// Function G01.GzSettingsEntryActionRemapping.HandlePrimaryKeyRightClicked
// 0x0008 (0x0008 - 0x0000)
struct GzSettingsEntryActionRemapping_HandlePrimaryKeyRightClicked final
{
public:
	class UCommonButtonBase*                      Button;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzSettingsEntryActionRemapping_HandlePrimaryKeyRightClicked) == 0x000008, "Wrong alignment on GzSettingsEntryActionRemapping_HandlePrimaryKeyRightClicked");
static_assert(sizeof(GzSettingsEntryActionRemapping_HandlePrimaryKeyRightClicked) == 0x000008, "Wrong size on GzSettingsEntryActionRemapping_HandlePrimaryKeyRightClicked");
static_assert(offsetof(GzSettingsEntryActionRemapping_HandlePrimaryKeyRightClicked, Button) == 0x000000, "Member 'GzSettingsEntryActionRemapping_HandlePrimaryKeyRightClicked::Button' has a wrong offset!");

// Function G01.GzSettingsEntryActionRemapping.HandleSecondaryKeyRightClicked
// 0x0008 (0x0008 - 0x0000)
struct GzSettingsEntryActionRemapping_HandleSecondaryKeyRightClicked final
{
public:
	class UCommonButtonBase*                      Button;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzSettingsEntryActionRemapping_HandleSecondaryKeyRightClicked) == 0x000008, "Wrong alignment on GzSettingsEntryActionRemapping_HandleSecondaryKeyRightClicked");
static_assert(sizeof(GzSettingsEntryActionRemapping_HandleSecondaryKeyRightClicked) == 0x000008, "Wrong size on GzSettingsEntryActionRemapping_HandleSecondaryKeyRightClicked");
static_assert(offsetof(GzSettingsEntryActionRemapping_HandleSecondaryKeyRightClicked, Button) == 0x000000, "Member 'GzSettingsEntryActionRemapping_HandleSecondaryKeyRightClicked::Button' has a wrong offset!");

// Function G01.GzSettingsEntryActionRemapping.OnPressAnyKeyPanelAdded
// 0x0008 (0x0008 - 0x0000)
struct GzSettingsEntryActionRemapping_OnPressAnyKeyPanelAdded final
{
public:
	class UGzNavigationWidget*                    NavigationWidget;                                  // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzSettingsEntryActionRemapping_OnPressAnyKeyPanelAdded) == 0x000008, "Wrong alignment on GzSettingsEntryActionRemapping_OnPressAnyKeyPanelAdded");
static_assert(sizeof(GzSettingsEntryActionRemapping_OnPressAnyKeyPanelAdded) == 0x000008, "Wrong size on GzSettingsEntryActionRemapping_OnPressAnyKeyPanelAdded");
static_assert(offsetof(GzSettingsEntryActionRemapping_OnPressAnyKeyPanelAdded, NavigationWidget) == 0x000000, "Member 'GzSettingsEntryActionRemapping_OnPressAnyKeyPanelAdded::NavigationWidget' has a wrong offset!");

// Function G01.GzSettingsEntryActionRemapping.GetInputBrushFromKeySlot
// 0x00F0 (0x00F0 - 0x0000)
struct GzSettingsEntryActionRemapping_GetInputBrushFromKeySlot final
{
public:
	EPlayerMappableKeySlot                        KeySlot;                                           // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_34F0[0xF];                                     // 0x0001(0x000F)(Fixing Size After Last Property [ Dumper-7 ])
	struct FSlateBrush                            OutBrush;                                          // 0x0010(0x00D0)(Parm, OutParm, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x00E0(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_34F1[0xF];                                     // 0x00E1(0x000F)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GzSettingsEntryActionRemapping_GetInputBrushFromKeySlot) == 0x000010, "Wrong alignment on GzSettingsEntryActionRemapping_GetInputBrushFromKeySlot");
static_assert(sizeof(GzSettingsEntryActionRemapping_GetInputBrushFromKeySlot) == 0x0000F0, "Wrong size on GzSettingsEntryActionRemapping_GetInputBrushFromKeySlot");
static_assert(offsetof(GzSettingsEntryActionRemapping_GetInputBrushFromKeySlot, KeySlot) == 0x000000, "Member 'GzSettingsEntryActionRemapping_GetInputBrushFromKeySlot::KeySlot' has a wrong offset!");
static_assert(offsetof(GzSettingsEntryActionRemapping_GetInputBrushFromKeySlot, OutBrush) == 0x000010, "Member 'GzSettingsEntryActionRemapping_GetInputBrushFromKeySlot::OutBrush' has a wrong offset!");
static_assert(offsetof(GzSettingsEntryActionRemapping_GetInputBrushFromKeySlot, ReturnValue) == 0x0000E0, "Member 'GzSettingsEntryActionRemapping_GetInputBrushFromKeySlot::ReturnValue' has a wrong offset!");

// Function G01.GzShadowBot.SimulateKeyPressed
// 0x0018 (0x0018 - 0x0000)
struct GzShadowBot_SimulateKeyPressed final
{
public:
	struct FKey                                   Key;                                               // 0x0000(0x0018)(Parm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzShadowBot_SimulateKeyPressed) == 0x000008, "Wrong alignment on GzShadowBot_SimulateKeyPressed");
static_assert(sizeof(GzShadowBot_SimulateKeyPressed) == 0x000018, "Wrong size on GzShadowBot_SimulateKeyPressed");
static_assert(offsetof(GzShadowBot_SimulateKeyPressed, Key) == 0x000000, "Member 'GzShadowBot_SimulateKeyPressed::Key' has a wrong offset!");

// Function G01.GzShadowBot.SimulateKeyPressedAndReleased
// 0x0020 (0x0020 - 0x0000)
struct GzShadowBot_SimulateKeyPressedAndReleased final
{
public:
	struct FKey                                   Key;                                               // 0x0000(0x0018)(Parm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Delay;                                             // 0x0018(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_34F5[0x4];                                     // 0x001C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GzShadowBot_SimulateKeyPressedAndReleased) == 0x000008, "Wrong alignment on GzShadowBot_SimulateKeyPressedAndReleased");
static_assert(sizeof(GzShadowBot_SimulateKeyPressedAndReleased) == 0x000020, "Wrong size on GzShadowBot_SimulateKeyPressedAndReleased");
static_assert(offsetof(GzShadowBot_SimulateKeyPressedAndReleased, Key) == 0x000000, "Member 'GzShadowBot_SimulateKeyPressedAndReleased::Key' has a wrong offset!");
static_assert(offsetof(GzShadowBot_SimulateKeyPressedAndReleased, Delay) == 0x000018, "Member 'GzShadowBot_SimulateKeyPressedAndReleased::Delay' has a wrong offset!");

// Function G01.GzShadowBot.SimulateKeyReleased
// 0x0018 (0x0018 - 0x0000)
struct GzShadowBot_SimulateKeyReleased final
{
public:
	struct FKey                                   Key;                                               // 0x0000(0x0018)(Parm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzShadowBot_SimulateKeyReleased) == 0x000008, "Wrong alignment on GzShadowBot_SimulateKeyReleased");
static_assert(sizeof(GzShadowBot_SimulateKeyReleased) == 0x000018, "Wrong size on GzShadowBot_SimulateKeyReleased");
static_assert(offsetof(GzShadowBot_SimulateKeyReleased, Key) == 0x000000, "Member 'GzShadowBot_SimulateKeyReleased::Key' has a wrong offset!");

// Function G01.GzShadowBot.GetCheatManager
// 0x0008 (0x0008 - 0x0000)
struct GzShadowBot_GetCheatManager final
{
public:
	class UGzCheatManager*                        ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzShadowBot_GetCheatManager) == 0x000008, "Wrong alignment on GzShadowBot_GetCheatManager");
static_assert(sizeof(GzShadowBot_GetCheatManager) == 0x000008, "Wrong size on GzShadowBot_GetCheatManager");
static_assert(offsetof(GzShadowBot_GetCheatManager, ReturnValue) == 0x000000, "Member 'GzShadowBot_GetCheatManager::ReturnValue' has a wrong offset!");

// Function G01.GzShadowBot.GetControlledPawn
// 0x0008 (0x0008 - 0x0000)
struct GzShadowBot_GetControlledPawn final
{
public:
	const class APawn*                            ReturnValue;                                       // 0x0000(0x0008)(ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzShadowBot_GetControlledPawn) == 0x000008, "Wrong alignment on GzShadowBot_GetControlledPawn");
static_assert(sizeof(GzShadowBot_GetControlledPawn) == 0x000008, "Wrong size on GzShadowBot_GetControlledPawn");
static_assert(offsetof(GzShadowBot_GetControlledPawn, ReturnValue) == 0x000000, "Member 'GzShadowBot_GetControlledPawn::ReturnValue' has a wrong offset!");

// Function G01.GzShadowBot.GetPlayerController
// 0x0008 (0x0008 - 0x0000)
struct GzShadowBot_GetPlayerController final
{
public:
	class AGzPlayerController*                    ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzShadowBot_GetPlayerController) == 0x000008, "Wrong alignment on GzShadowBot_GetPlayerController");
static_assert(sizeof(GzShadowBot_GetPlayerController) == 0x000008, "Wrong size on GzShadowBot_GetPlayerController");
static_assert(offsetof(GzShadowBot_GetPlayerController, ReturnValue) == 0x000000, "Member 'GzShadowBot_GetPlayerController::ReturnValue' has a wrong offset!");

// Function G01.GzShootStatCollector.PlayerShoot
// 0x0010 (0x0010 - 0x0000)
struct GzShootStatCollector_PlayerShoot final
{
public:
	const class APawn*                            Instigator;                                        // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   WeaponName;                                        // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzShootStatCollector_PlayerShoot) == 0x000008, "Wrong alignment on GzShootStatCollector_PlayerShoot");
static_assert(sizeof(GzShootStatCollector_PlayerShoot) == 0x000010, "Wrong size on GzShootStatCollector_PlayerShoot");
static_assert(offsetof(GzShootStatCollector_PlayerShoot, Instigator) == 0x000000, "Member 'GzShootStatCollector_PlayerShoot::Instigator' has a wrong offset!");
static_assert(offsetof(GzShootStatCollector_PlayerShoot, WeaponName) == 0x000008, "Member 'GzShootStatCollector_PlayerShoot::WeaponName' has a wrong offset!");

// Function G01.LocomotionStateSwitcherWidget.CycleState
// 0x0001 (0x0001 - 0x0000)
struct LocomotionStateSwitcherWidget_CycleState final
{
public:
	bool                                          Up;                                                // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LocomotionStateSwitcherWidget_CycleState) == 0x000001, "Wrong alignment on LocomotionStateSwitcherWidget_CycleState");
static_assert(sizeof(LocomotionStateSwitcherWidget_CycleState) == 0x000001, "Wrong size on LocomotionStateSwitcherWidget_CycleState");
static_assert(offsetof(LocomotionStateSwitcherWidget_CycleState, Up) == 0x000000, "Member 'LocomotionStateSwitcherWidget_CycleState::Up' has a wrong offset!");

// Function G01.LocomotionStateSwitcherWidget.InitializeWidget
// 0x0008 (0x0008 - 0x0000)
struct LocomotionStateSwitcherWidget_InitializeWidget final
{
public:
	class UCanvasPanel*                           MovablePanel;                                      // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LocomotionStateSwitcherWidget_InitializeWidget) == 0x000008, "Wrong alignment on LocomotionStateSwitcherWidget_InitializeWidget");
static_assert(sizeof(LocomotionStateSwitcherWidget_InitializeWidget) == 0x000008, "Wrong size on LocomotionStateSwitcherWidget_InitializeWidget");
static_assert(offsetof(LocomotionStateSwitcherWidget_InitializeWidget, MovablePanel) == 0x000000, "Member 'LocomotionStateSwitcherWidget_InitializeWidget::MovablePanel' has a wrong offset!");

// Function G01.GzSimplePickable.IsAvailableToAutoPickUp
// 0x0001 (0x0001 - 0x0000)
struct GzSimplePickable_IsAvailableToAutoPickUp final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzSimplePickable_IsAvailableToAutoPickUp) == 0x000001, "Wrong alignment on GzSimplePickable_IsAvailableToAutoPickUp");
static_assert(sizeof(GzSimplePickable_IsAvailableToAutoPickUp) == 0x000001, "Wrong size on GzSimplePickable_IsAvailableToAutoPickUp");
static_assert(offsetof(GzSimplePickable_IsAvailableToAutoPickUp, ReturnValue) == 0x000000, "Member 'GzSimplePickable_IsAvailableToAutoPickUp::ReturnValue' has a wrong offset!");

// Function G01.GzSmokePropagationActor.ApplySmokeEffect
// 0x0010 (0x0010 - 0x0000)
struct GzSmokePropagationActor_ApplySmokeEffect final
{
public:
	class UAbilitySystemComponent*                TargetASC;                                         // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FActiveGameplayEffectHandle            ReturnValue;                                       // 0x0008(0x0008)(Parm, OutParm, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzSmokePropagationActor_ApplySmokeEffect) == 0x000008, "Wrong alignment on GzSmokePropagationActor_ApplySmokeEffect");
static_assert(sizeof(GzSmokePropagationActor_ApplySmokeEffect) == 0x000010, "Wrong size on GzSmokePropagationActor_ApplySmokeEffect");
static_assert(offsetof(GzSmokePropagationActor_ApplySmokeEffect, TargetASC) == 0x000000, "Member 'GzSmokePropagationActor_ApplySmokeEffect::TargetASC' has a wrong offset!");
static_assert(offsetof(GzSmokePropagationActor_ApplySmokeEffect, ReturnValue) == 0x000008, "Member 'GzSmokePropagationActor_ApplySmokeEffect::ReturnValue' has a wrong offset!");

// Function G01.GzSpiderMine.OnBeginOverlap
// 0x0118 (0x0118 - 0x0000)
struct GzSpiderMine_OnBeginOverlap final
{
public:
	class UPrimitiveComponent*                    OverlappedComp;                                    // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 Other;                                             // 0x0008(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UPrimitiveComponent*                    OtherComp;                                         // 0x0010(0x0008)(Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         OtherBodyIndex;                                    // 0x0018(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bFromSweep;                                        // 0x001C(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3508[0x3];                                     // 0x001D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FHitResult                             SweepResult;                                       // 0x0020(0x00F8)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzSpiderMine_OnBeginOverlap) == 0x000008, "Wrong alignment on GzSpiderMine_OnBeginOverlap");
static_assert(sizeof(GzSpiderMine_OnBeginOverlap) == 0x000118, "Wrong size on GzSpiderMine_OnBeginOverlap");
static_assert(offsetof(GzSpiderMine_OnBeginOverlap, OverlappedComp) == 0x000000, "Member 'GzSpiderMine_OnBeginOverlap::OverlappedComp' has a wrong offset!");
static_assert(offsetof(GzSpiderMine_OnBeginOverlap, Other) == 0x000008, "Member 'GzSpiderMine_OnBeginOverlap::Other' has a wrong offset!");
static_assert(offsetof(GzSpiderMine_OnBeginOverlap, OtherComp) == 0x000010, "Member 'GzSpiderMine_OnBeginOverlap::OtherComp' has a wrong offset!");
static_assert(offsetof(GzSpiderMine_OnBeginOverlap, OtherBodyIndex) == 0x000018, "Member 'GzSpiderMine_OnBeginOverlap::OtherBodyIndex' has a wrong offset!");
static_assert(offsetof(GzSpiderMine_OnBeginOverlap, bFromSweep) == 0x00001C, "Member 'GzSpiderMine_OnBeginOverlap::bFromSweep' has a wrong offset!");
static_assert(offsetof(GzSpiderMine_OnBeginOverlap, SweepResult) == 0x000020, "Member 'GzSpiderMine_OnBeginOverlap::SweepResult' has a wrong offset!");

// Function G01.GzSpiderMine.OnOwnerDestroyed
// 0x0008 (0x0008 - 0x0000)
struct GzSpiderMine_OnOwnerDestroyed final
{
public:
	class AActor*                                 Actor;                                             // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzSpiderMine_OnOwnerDestroyed) == 0x000008, "Wrong alignment on GzSpiderMine_OnOwnerDestroyed");
static_assert(sizeof(GzSpiderMine_OnOwnerDestroyed) == 0x000008, "Wrong size on GzSpiderMine_OnOwnerDestroyed");
static_assert(offsetof(GzSpiderMine_OnOwnerDestroyed, Actor) == 0x000000, "Member 'GzSpiderMine_OnOwnerDestroyed::Actor' has a wrong offset!");

// Function G01.GzSpiderMine.OnOwnerKilled
// 0x0004 (0x0004 - 0x0000)
struct GzSpiderMine_OnOwnerKilled final
{
public:
	int32                                         KillerId;                                          // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzSpiderMine_OnOwnerKilled) == 0x000004, "Wrong alignment on GzSpiderMine_OnOwnerKilled");
static_assert(sizeof(GzSpiderMine_OnOwnerKilled) == 0x000004, "Wrong size on GzSpiderMine_OnOwnerKilled");
static_assert(offsetof(GzSpiderMine_OnOwnerKilled, KillerId) == 0x000000, "Member 'GzSpiderMine_OnOwnerKilled::KillerId' has a wrong offset!");

// Function G01.GzSpiderMine.SetItemData
// 0x0008 (0x0008 - 0x0000)
struct GzSpiderMine_SetItemData final
{
public:
	class UGzItemData*                            InItemData;                                        // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzSpiderMine_SetItemData) == 0x000008, "Wrong alignment on GzSpiderMine_SetItemData");
static_assert(sizeof(GzSpiderMine_SetItemData) == 0x000008, "Wrong size on GzSpiderMine_SetItemData");
static_assert(offsetof(GzSpiderMine_SetItemData, InItemData) == 0x000000, "Member 'GzSpiderMine_SetItemData::InItemData' has a wrong offset!");

// Function G01.GzStageDecorator.MakeStageObjective
// 0x0038 (0x0038 - 0x0000)
struct GzStageDecorator_MakeStageObjective final
{
public:
	class AGzAdvancedMission*                     Mission;                                           // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UGzObjective*                           Objective;                                         // 0x0008(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   Param_Name;                                        // 0x0010(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	class FText                                   Description;                                       // 0x0020(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	class UGzObjective*                           ReturnValue;                                       // 0x0030(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzStageDecorator_MakeStageObjective) == 0x000008, "Wrong alignment on GzStageDecorator_MakeStageObjective");
static_assert(sizeof(GzStageDecorator_MakeStageObjective) == 0x000038, "Wrong size on GzStageDecorator_MakeStageObjective");
static_assert(offsetof(GzStageDecorator_MakeStageObjective, Mission) == 0x000000, "Member 'GzStageDecorator_MakeStageObjective::Mission' has a wrong offset!");
static_assert(offsetof(GzStageDecorator_MakeStageObjective, Objective) == 0x000008, "Member 'GzStageDecorator_MakeStageObjective::Objective' has a wrong offset!");
static_assert(offsetof(GzStageDecorator_MakeStageObjective, Param_Name) == 0x000010, "Member 'GzStageDecorator_MakeStageObjective::Param_Name' has a wrong offset!");
static_assert(offsetof(GzStageDecorator_MakeStageObjective, Description) == 0x000020, "Member 'GzStageDecorator_MakeStageObjective::Description' has a wrong offset!");
static_assert(offsetof(GzStageDecorator_MakeStageObjective, ReturnValue) == 0x000030, "Member 'GzStageDecorator_MakeStageObjective::ReturnValue' has a wrong offset!");

// Function G01.GzStandTurret.OnWeaponReady
// 0x0018 (0x0018 - 0x0000)
struct GzStandTurret_OnWeaponReady final
{
public:
	struct FGzInvPocketId                         InvPocketId;                                       // 0x0000(0x0008)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	const class AGzWeaponActor*                   WeaponActor;                                       // 0x0008(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEquipped;                                         // 0x0010(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_350D[0x7];                                     // 0x0011(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GzStandTurret_OnWeaponReady) == 0x000008, "Wrong alignment on GzStandTurret_OnWeaponReady");
static_assert(sizeof(GzStandTurret_OnWeaponReady) == 0x000018, "Wrong size on GzStandTurret_OnWeaponReady");
static_assert(offsetof(GzStandTurret_OnWeaponReady, InvPocketId) == 0x000000, "Member 'GzStandTurret_OnWeaponReady::InvPocketId' has a wrong offset!");
static_assert(offsetof(GzStandTurret_OnWeaponReady, WeaponActor) == 0x000008, "Member 'GzStandTurret_OnWeaponReady::WeaponActor' has a wrong offset!");
static_assert(offsetof(GzStandTurret_OnWeaponReady, bEquipped) == 0x000010, "Member 'GzStandTurret_OnWeaponReady::bEquipped' has a wrong offset!");

// Function G01.GzStandTurret.GetTargetBodyPart
// 0x0018 (0x0018 - 0x0000)
struct GzStandTurret_GetTargetBodyPart final
{
public:
	struct FVector                                CurrentBodyPartRef;                                // 0x0000(0x0018)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzStandTurret_GetTargetBodyPart) == 0x000008, "Wrong alignment on GzStandTurret_GetTargetBodyPart");
static_assert(sizeof(GzStandTurret_GetTargetBodyPart) == 0x000018, "Wrong size on GzStandTurret_GetTargetBodyPart");
static_assert(offsetof(GzStandTurret_GetTargetBodyPart, CurrentBodyPartRef) == 0x000000, "Member 'GzStandTurret_GetTargetBodyPart::CurrentBodyPartRef' has a wrong offset!");

// Function G01.GzStandTurret.GetTargetEnemy
// 0x0008 (0x0008 - 0x0000)
struct GzStandTurret_GetTargetEnemy final
{
public:
	class AActor*                                 ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzStandTurret_GetTargetEnemy) == 0x000008, "Wrong alignment on GzStandTurret_GetTargetEnemy");
static_assert(sizeof(GzStandTurret_GetTargetEnemy) == 0x000008, "Wrong size on GzStandTurret_GetTargetEnemy");
static_assert(offsetof(GzStandTurret_GetTargetEnemy, ReturnValue) == 0x000000, "Member 'GzStandTurret_GetTargetEnemy::ReturnValue' has a wrong offset!");

// Function G01.GzStateChangedDecorator.MakeStageObjective
// 0x0028 (0x0028 - 0x0000)
struct GzStateChangedDecorator_MakeStageObjective final
{
public:
	class AGzAdvancedMission*                     Mission;                                           // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UGzObjective*                           Objective;                                         // 0x0008(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TDelegate<void(EGzObjectiveState NewState)>   StateChanged;                                      // 0x0010(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UGzObjective*                           ReturnValue;                                       // 0x0020(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzStateChangedDecorator_MakeStageObjective) == 0x000008, "Wrong alignment on GzStateChangedDecorator_MakeStageObjective");
static_assert(sizeof(GzStateChangedDecorator_MakeStageObjective) == 0x000028, "Wrong size on GzStateChangedDecorator_MakeStageObjective");
static_assert(offsetof(GzStateChangedDecorator_MakeStageObjective, Mission) == 0x000000, "Member 'GzStateChangedDecorator_MakeStageObjective::Mission' has a wrong offset!");
static_assert(offsetof(GzStateChangedDecorator_MakeStageObjective, Objective) == 0x000008, "Member 'GzStateChangedDecorator_MakeStageObjective::Objective' has a wrong offset!");
static_assert(offsetof(GzStateChangedDecorator_MakeStageObjective, StateChanged) == 0x000010, "Member 'GzStateChangedDecorator_MakeStageObjective::StateChanged' has a wrong offset!");
static_assert(offsetof(GzStateChangedDecorator_MakeStageObjective, ReturnValue) == 0x000020, "Member 'GzStateChangedDecorator_MakeStageObjective::ReturnValue' has a wrong offset!");

// Function G01.GzStatsHolderComponent.OnOwnerChangeTeam
// 0x0008 (0x0008 - 0x0000)
struct GzStatsHolderComponent_OnOwnerChangeTeam final
{
public:
	class AGzPlayerState*                         PlayerState;                                       // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzStatsHolderComponent_OnOwnerChangeTeam) == 0x000008, "Wrong alignment on GzStatsHolderComponent_OnOwnerChangeTeam");
static_assert(sizeof(GzStatsHolderComponent_OnOwnerChangeTeam) == 0x000008, "Wrong size on GzStatsHolderComponent_OnOwnerChangeTeam");
static_assert(offsetof(GzStatsHolderComponent_OnOwnerChangeTeam, PlayerState) == 0x000000, "Member 'GzStatsHolderComponent_OnOwnerChangeTeam::PlayerState' has a wrong offset!");

// Function G01.GzStickyGooProjectile.OnProjectileBounce
// 0x0110 (0x0110 - 0x0000)
struct GzStickyGooProjectile_OnProjectileBounce final
{
public:
	struct FHitResult                             ImpactResult;                                      // 0x0000(0x00F8)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FVector                                ImpactVelocity;                                    // 0x00F8(0x0018)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzStickyGooProjectile_OnProjectileBounce) == 0x000008, "Wrong alignment on GzStickyGooProjectile_OnProjectileBounce");
static_assert(sizeof(GzStickyGooProjectile_OnProjectileBounce) == 0x000110, "Wrong size on GzStickyGooProjectile_OnProjectileBounce");
static_assert(offsetof(GzStickyGooProjectile_OnProjectileBounce, ImpactResult) == 0x000000, "Member 'GzStickyGooProjectile_OnProjectileBounce::ImpactResult' has a wrong offset!");
static_assert(offsetof(GzStickyGooProjectile_OnProjectileBounce, ImpactVelocity) == 0x0000F8, "Member 'GzStickyGooProjectile_OnProjectileBounce::ImpactVelocity' has a wrong offset!");

// Function G01.GzStickyGooProjectile.OnProjectileStop
// 0x00F8 (0x00F8 - 0x0000)
struct GzStickyGooProjectile_OnProjectileStop final
{
public:
	struct FHitResult                             ImpactResult;                                      // 0x0000(0x00F8)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzStickyGooProjectile_OnProjectileStop) == 0x000008, "Wrong alignment on GzStickyGooProjectile_OnProjectileStop");
static_assert(sizeof(GzStickyGooProjectile_OnProjectileStop) == 0x0000F8, "Wrong size on GzStickyGooProjectile_OnProjectileStop");
static_assert(offsetof(GzStickyGooProjectile_OnProjectileStop, ImpactResult) == 0x000000, "Member 'GzStickyGooProjectile_OnProjectileStop::ImpactResult' has a wrong offset!");

// DelegateFunction G01.GzSuperSprintComponent.GzSprintConditionsChangedEvent__DelegateSignature
// 0x0001 (0x0001 - 0x0000)
struct GzSuperSprintComponent_GzSprintConditionsChangedEvent__DelegateSignature final
{
public:
	bool                                          bConditionsMet;                                    // 0x0000(0x0001)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzSuperSprintComponent_GzSprintConditionsChangedEvent__DelegateSignature) == 0x000001, "Wrong alignment on GzSuperSprintComponent_GzSprintConditionsChangedEvent__DelegateSignature");
static_assert(sizeof(GzSuperSprintComponent_GzSprintConditionsChangedEvent__DelegateSignature) == 0x000001, "Wrong size on GzSuperSprintComponent_GzSprintConditionsChangedEvent__DelegateSignature");
static_assert(offsetof(GzSuperSprintComponent_GzSprintConditionsChangedEvent__DelegateSignature, bConditionsMet) == 0x000000, "Member 'GzSuperSprintComponent_GzSprintConditionsChangedEvent__DelegateSignature::bConditionsMet' has a wrong offset!");

// DelegateFunction G01.GzSuperSprintComponent.GzSuperSprintActivationEvent__DelegateSignature
// 0x0001 (0x0001 - 0x0000)
struct GzSuperSprintComponent_GzSuperSprintActivationEvent__DelegateSignature final
{
public:
	bool                                          Param_bIsActive;                                   // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzSuperSprintComponent_GzSuperSprintActivationEvent__DelegateSignature) == 0x000001, "Wrong alignment on GzSuperSprintComponent_GzSuperSprintActivationEvent__DelegateSignature");
static_assert(sizeof(GzSuperSprintComponent_GzSuperSprintActivationEvent__DelegateSignature) == 0x000001, "Wrong size on GzSuperSprintComponent_GzSuperSprintActivationEvent__DelegateSignature");
static_assert(offsetof(GzSuperSprintComponent_GzSuperSprintActivationEvent__DelegateSignature, Param_bIsActive) == 0x000000, "Member 'GzSuperSprintComponent_GzSuperSprintActivationEvent__DelegateSignature::Param_bIsActive' has a wrong offset!");

// Function G01.GzSuperSprintTrailActor.OnTrailTouched
// 0x0118 (0x0118 - 0x0000)
struct GzSuperSprintTrailActor_OnTrailTouched final
{
public:
	class UPrimitiveComponent*                    OverlappedComp;                                    // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 Other;                                             // 0x0008(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UPrimitiveComponent*                    OtherComp;                                         // 0x0010(0x0008)(Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         OtherBodyIndex;                                    // 0x0018(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bFromSweep;                                        // 0x001C(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_351F[0x3];                                     // 0x001D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FHitResult                             OverlapInfo;                                       // 0x0020(0x00F8)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzSuperSprintTrailActor_OnTrailTouched) == 0x000008, "Wrong alignment on GzSuperSprintTrailActor_OnTrailTouched");
static_assert(sizeof(GzSuperSprintTrailActor_OnTrailTouched) == 0x000118, "Wrong size on GzSuperSprintTrailActor_OnTrailTouched");
static_assert(offsetof(GzSuperSprintTrailActor_OnTrailTouched, OverlappedComp) == 0x000000, "Member 'GzSuperSprintTrailActor_OnTrailTouched::OverlappedComp' has a wrong offset!");
static_assert(offsetof(GzSuperSprintTrailActor_OnTrailTouched, Other) == 0x000008, "Member 'GzSuperSprintTrailActor_OnTrailTouched::Other' has a wrong offset!");
static_assert(offsetof(GzSuperSprintTrailActor_OnTrailTouched, OtherComp) == 0x000010, "Member 'GzSuperSprintTrailActor_OnTrailTouched::OtherComp' has a wrong offset!");
static_assert(offsetof(GzSuperSprintTrailActor_OnTrailTouched, OtherBodyIndex) == 0x000018, "Member 'GzSuperSprintTrailActor_OnTrailTouched::OtherBodyIndex' has a wrong offset!");
static_assert(offsetof(GzSuperSprintTrailActor_OnTrailTouched, bFromSweep) == 0x00001C, "Member 'GzSuperSprintTrailActor_OnTrailTouched::bFromSweep' has a wrong offset!");
static_assert(offsetof(GzSuperSprintTrailActor_OnTrailTouched, OverlapInfo) == 0x000020, "Member 'GzSuperSprintTrailActor_OnTrailTouched::OverlapInfo' has a wrong offset!");

// Function G01.GzSurfacePropagationController.StartPropagation
// 0x0018 (0x0018 - 0x0000)
struct GzSurfacePropagationController_StartPropagation final
{
public:
	class UGzPropagationConfiguration*            PropagationData;                                   // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Level;                                             // 0x0008(0x0004)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3521[0x4];                                     // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UDataAsset*                             Param_OptionalDataAsset;                           // 0x0010(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzSurfacePropagationController_StartPropagation) == 0x000008, "Wrong alignment on GzSurfacePropagationController_StartPropagation");
static_assert(sizeof(GzSurfacePropagationController_StartPropagation) == 0x000018, "Wrong size on GzSurfacePropagationController_StartPropagation");
static_assert(offsetof(GzSurfacePropagationController_StartPropagation, PropagationData) == 0x000000, "Member 'GzSurfacePropagationController_StartPropagation::PropagationData' has a wrong offset!");
static_assert(offsetof(GzSurfacePropagationController_StartPropagation, Level) == 0x000008, "Member 'GzSurfacePropagationController_StartPropagation::Level' has a wrong offset!");
static_assert(offsetof(GzSurfacePropagationController_StartPropagation, Param_OptionalDataAsset) == 0x000010, "Member 'GzSurfacePropagationController_StartPropagation::Param_OptionalDataAsset' has a wrong offset!");

// Function G01.GzSurfacePropagationController.GetDamageSourceDataAsset
// 0x0008 (0x0008 - 0x0000)
struct GzSurfacePropagationController_GetDamageSourceDataAsset final
{
public:
	class UDataAsset*                             ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzSurfacePropagationController_GetDamageSourceDataAsset) == 0x000008, "Wrong alignment on GzSurfacePropagationController_GetDamageSourceDataAsset");
static_assert(sizeof(GzSurfacePropagationController_GetDamageSourceDataAsset) == 0x000008, "Wrong size on GzSurfacePropagationController_GetDamageSourceDataAsset");
static_assert(offsetof(GzSurfacePropagationController_GetDamageSourceDataAsset, ReturnValue) == 0x000000, "Member 'GzSurfacePropagationController_GetDamageSourceDataAsset::ReturnValue' has a wrong offset!");

// Function G01.GzSurfacePropagationController.GetOptionalDataAsset
// 0x0008 (0x0008 - 0x0000)
struct GzSurfacePropagationController_GetOptionalDataAsset final
{
public:
	class UDataAsset*                             ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzSurfacePropagationController_GetOptionalDataAsset) == 0x000008, "Wrong alignment on GzSurfacePropagationController_GetOptionalDataAsset");
static_assert(sizeof(GzSurfacePropagationController_GetOptionalDataAsset) == 0x000008, "Wrong size on GzSurfacePropagationController_GetOptionalDataAsset");
static_assert(offsetof(GzSurfacePropagationController_GetOptionalDataAsset, ReturnValue) == 0x000000, "Member 'GzSurfacePropagationController_GetOptionalDataAsset::ReturnValue' has a wrong offset!");

// Function G01.GzTagSwitcherVertical.InitializedTag
// 0x0060 (0x0060 - 0x0000)
struct GzTagSwitcherVertical_InitializedTag final
{
public:
	class UUserWidget*                            InParentWidget;                                    // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bResetTagSettings;                                 // 0x0008(0x0001)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3522[0x7];                                     // 0x0009(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGzTagVisibilitySettings               InTagSettings;                                     // 0x0010(0x0050)(ConstParm, Parm, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzTagSwitcherVertical_InitializedTag) == 0x000008, "Wrong alignment on GzTagSwitcherVertical_InitializedTag");
static_assert(sizeof(GzTagSwitcherVertical_InitializedTag) == 0x000060, "Wrong size on GzTagSwitcherVertical_InitializedTag");
static_assert(offsetof(GzTagSwitcherVertical_InitializedTag, InParentWidget) == 0x000000, "Member 'GzTagSwitcherVertical_InitializedTag::InParentWidget' has a wrong offset!");
static_assert(offsetof(GzTagSwitcherVertical_InitializedTag, bResetTagSettings) == 0x000008, "Member 'GzTagSwitcherVertical_InitializedTag::bResetTagSettings' has a wrong offset!");
static_assert(offsetof(GzTagSwitcherVertical_InitializedTag, InTagSettings) == 0x000010, "Member 'GzTagSwitcherVertical_InitializedTag::InTagSettings' has a wrong offset!");

// Function G01.GzTagSwitcherVertical.SetTagVisibility
// 0x0001 (0x0001 - 0x0000)
struct GzTagSwitcherVertical_SetTagVisibility final
{
public:
	EGzTargetUITagsState                          TagsState;                                         // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzTagSwitcherVertical_SetTagVisibility) == 0x000001, "Wrong alignment on GzTagSwitcherVertical_SetTagVisibility");
static_assert(sizeof(GzTagSwitcherVertical_SetTagVisibility) == 0x000001, "Wrong size on GzTagSwitcherVertical_SetTagVisibility");
static_assert(offsetof(GzTagSwitcherVertical_SetTagVisibility, TagsState) == 0x000000, "Member 'GzTagSwitcherVertical_SetTagVisibility::TagsState' has a wrong offset!");

// Function G01.GzTeam.OnPlayerAliveStateChanged
// 0x0008 (0x0008 - 0x0000)
struct GzTeam_OnPlayerAliveStateChanged final
{
public:
	class AGzPlayerState*                         PlayerState;                                       // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzTeam_OnPlayerAliveStateChanged) == 0x000008, "Wrong alignment on GzTeam_OnPlayerAliveStateChanged");
static_assert(sizeof(GzTeam_OnPlayerAliveStateChanged) == 0x000008, "Wrong size on GzTeam_OnPlayerAliveStateChanged");
static_assert(offsetof(GzTeam_OnPlayerAliveStateChanged, PlayerState) == 0x000000, "Member 'GzTeam_OnPlayerAliveStateChanged::PlayerState' has a wrong offset!");

// Function G01.GzTeam.OnTeammatePawnChanged
// 0x0018 (0x0018 - 0x0000)
struct GzTeam_OnTeammatePawnChanged final
{
public:
	class APlayerState*                           Player;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class APawn*                                  NewPawn;                                           // 0x0008(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class APawn*                                  OldPawn;                                           // 0x0010(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzTeam_OnTeammatePawnChanged) == 0x000008, "Wrong alignment on GzTeam_OnTeammatePawnChanged");
static_assert(sizeof(GzTeam_OnTeammatePawnChanged) == 0x000018, "Wrong size on GzTeam_OnTeammatePawnChanged");
static_assert(offsetof(GzTeam_OnTeammatePawnChanged, Player) == 0x000000, "Member 'GzTeam_OnTeammatePawnChanged::Player' has a wrong offset!");
static_assert(offsetof(GzTeam_OnTeammatePawnChanged, NewPawn) == 0x000008, "Member 'GzTeam_OnTeammatePawnChanged::NewPawn' has a wrong offset!");
static_assert(offsetof(GzTeam_OnTeammatePawnChanged, OldPawn) == 0x000010, "Member 'GzTeam_OnTeammatePawnChanged::OldPawn' has a wrong offset!");

// Function G01.GzTeam.CanAddPlayer
// 0x0010 (0x0010 - 0x0000)
struct GzTeam_CanAddPlayer final
{
public:
	const class AGzPlayerState*                   Player;                                            // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3526[0x7];                                     // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GzTeam_CanAddPlayer) == 0x000008, "Wrong alignment on GzTeam_CanAddPlayer");
static_assert(sizeof(GzTeam_CanAddPlayer) == 0x000010, "Wrong size on GzTeam_CanAddPlayer");
static_assert(offsetof(GzTeam_CanAddPlayer, Player) == 0x000000, "Member 'GzTeam_CanAddPlayer::Player' has a wrong offset!");
static_assert(offsetof(GzTeam_CanAddPlayer, ReturnValue) == 0x000008, "Member 'GzTeam_CanAddPlayer::ReturnValue' has a wrong offset!");

// Function G01.GzTeam.GetCapacity
// 0x0004 (0x0004 - 0x0000)
struct GzTeam_GetCapacity final
{
public:
	int32                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzTeam_GetCapacity) == 0x000004, "Wrong alignment on GzTeam_GetCapacity");
static_assert(sizeof(GzTeam_GetCapacity) == 0x000004, "Wrong size on GzTeam_GetCapacity");
static_assert(offsetof(GzTeam_GetCapacity, ReturnValue) == 0x000000, "Member 'GzTeam_GetCapacity::ReturnValue' has a wrong offset!");

// Function G01.GzTeam.GetEmptySlots
// 0x0004 (0x0004 - 0x0000)
struct GzTeam_GetEmptySlots final
{
public:
	int32                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzTeam_GetEmptySlots) == 0x000004, "Wrong alignment on GzTeam_GetEmptySlots");
static_assert(sizeof(GzTeam_GetEmptySlots) == 0x000004, "Wrong size on GzTeam_GetEmptySlots");
static_assert(offsetof(GzTeam_GetEmptySlots, ReturnValue) == 0x000000, "Member 'GzTeam_GetEmptySlots::ReturnValue' has a wrong offset!");

// Function G01.GzTeam.GetPlayers
// 0x0010 (0x0010 - 0x0000)
struct GzTeam_GetPlayers final
{
public:
	TArray<class APlayerState*>                   ReturnValue;                                       // 0x0000(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzTeam_GetPlayers) == 0x000008, "Wrong alignment on GzTeam_GetPlayers");
static_assert(sizeof(GzTeam_GetPlayers) == 0x000010, "Wrong size on GzTeam_GetPlayers");
static_assert(offsetof(GzTeam_GetPlayers, ReturnValue) == 0x000000, "Member 'GzTeam_GetPlayers::ReturnValue' has a wrong offset!");

// Function G01.GzTeam.GetSessionId
// 0x0010 (0x0010 - 0x0000)
struct GzTeam_GetSessionId final
{
public:
	class FString                                 ReturnValue;                                       // 0x0000(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzTeam_GetSessionId) == 0x000008, "Wrong alignment on GzTeam_GetSessionId");
static_assert(sizeof(GzTeam_GetSessionId) == 0x000010, "Wrong size on GzTeam_GetSessionId");
static_assert(offsetof(GzTeam_GetSessionId, ReturnValue) == 0x000000, "Member 'GzTeam_GetSessionId::ReturnValue' has a wrong offset!");

// Function G01.GzTeam.GetTeamId
// 0x0004 (0x0004 - 0x0000)
struct GzTeam_GetTeamId final
{
public:
	int32                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzTeam_GetTeamId) == 0x000004, "Wrong alignment on GzTeam_GetTeamId");
static_assert(sizeof(GzTeam_GetTeamId) == 0x000004, "Wrong size on GzTeam_GetTeamId");
static_assert(offsetof(GzTeam_GetTeamId, ReturnValue) == 0x000000, "Member 'GzTeam_GetTeamId::ReturnValue' has a wrong offset!");

// Function G01.GzTeam.GetTeamLeader
// 0x0008 (0x0008 - 0x0000)
struct GzTeam_GetTeamLeader final
{
public:
	const class AGzPlayerState*                   ReturnValue;                                       // 0x0000(0x0008)(ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzTeam_GetTeamLeader) == 0x000008, "Wrong alignment on GzTeam_GetTeamLeader");
static_assert(sizeof(GzTeam_GetTeamLeader) == 0x000008, "Wrong size on GzTeam_GetTeamLeader");
static_assert(offsetof(GzTeam_GetTeamLeader, ReturnValue) == 0x000000, "Member 'GzTeam_GetTeamLeader::ReturnValue' has a wrong offset!");

// Function G01.GzTeam.GetTeamLeaderFaction
// 0x0048 (0x0048 - 0x0000)
struct GzTeam_GetTeamLeaderFaction final
{
public:
	struct FGzFaction                             ReturnValue;                                       // 0x0000(0x0048)(ConstParm, Parm, OutParm, ReturnParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzTeam_GetTeamLeaderFaction) == 0x000008, "Wrong alignment on GzTeam_GetTeamLeaderFaction");
static_assert(sizeof(GzTeam_GetTeamLeaderFaction) == 0x000048, "Wrong size on GzTeam_GetTeamLeaderFaction");
static_assert(offsetof(GzTeam_GetTeamLeaderFaction, ReturnValue) == 0x000000, "Member 'GzTeam_GetTeamLeaderFaction::ReturnValue' has a wrong offset!");

// Function G01.GzTeam.GetTeamMembers
// 0x0010 (0x0010 - 0x0000)
struct GzTeam_GetTeamMembers final
{
public:
	TArray<struct FGzTeamMember>                  ReturnValue;                                       // 0x0000(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzTeam_GetTeamMembers) == 0x000008, "Wrong alignment on GzTeam_GetTeamMembers");
static_assert(sizeof(GzTeam_GetTeamMembers) == 0x000010, "Wrong size on GzTeam_GetTeamMembers");
static_assert(offsetof(GzTeam_GetTeamMembers, ReturnValue) == 0x000000, "Member 'GzTeam_GetTeamMembers::ReturnValue' has a wrong offset!");

// Function G01.GzTeam.GetTeamRank
// 0x0004 (0x0004 - 0x0000)
struct GzTeam_GetTeamRank final
{
public:
	int32                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzTeam_GetTeamRank) == 0x000004, "Wrong alignment on GzTeam_GetTeamRank");
static_assert(sizeof(GzTeam_GetTeamRank) == 0x000004, "Wrong size on GzTeam_GetTeamRank");
static_assert(offsetof(GzTeam_GetTeamRank, ReturnValue) == 0x000000, "Member 'GzTeam_GetTeamRank::ReturnValue' has a wrong offset!");

// Function G01.GzTeam.GetTeamSize
// 0x0004 (0x0004 - 0x0000)
struct GzTeam_GetTeamSize final
{
public:
	int32                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzTeam_GetTeamSize) == 0x000004, "Wrong alignment on GzTeam_GetTeamSize");
static_assert(sizeof(GzTeam_GetTeamSize) == 0x000004, "Wrong size on GzTeam_GetTeamSize");
static_assert(offsetof(GzTeam_GetTeamSize, ReturnValue) == 0x000000, "Member 'GzTeam_GetTeamSize::ReturnValue' has a wrong offset!");

// Function G01.GzTeam.GetVoiceChatRoomId
// 0x0010 (0x0010 - 0x0000)
struct GzTeam_GetVoiceChatRoomId final
{
public:
	struct FGuid                                  ReturnValue;                                       // 0x0000(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzTeam_GetVoiceChatRoomId) == 0x000004, "Wrong alignment on GzTeam_GetVoiceChatRoomId");
static_assert(sizeof(GzTeam_GetVoiceChatRoomId) == 0x000010, "Wrong size on GzTeam_GetVoiceChatRoomId");
static_assert(offsetof(GzTeam_GetVoiceChatRoomId, ReturnValue) == 0x000000, "Member 'GzTeam_GetVoiceChatRoomId::ReturnValue' has a wrong offset!");

// Function G01.GzTeam.HasLimitedCapacity
// 0x0001 (0x0001 - 0x0000)
struct GzTeam_HasLimitedCapacity final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzTeam_HasLimitedCapacity) == 0x000001, "Wrong alignment on GzTeam_HasLimitedCapacity");
static_assert(sizeof(GzTeam_HasLimitedCapacity) == 0x000001, "Wrong size on GzTeam_HasLimitedCapacity");
static_assert(offsetof(GzTeam_HasLimitedCapacity, ReturnValue) == 0x000000, "Member 'GzTeam_HasLimitedCapacity::ReturnValue' has a wrong offset!");

// Function G01.GzTeam.HasPlayersInMatch
// 0x0001 (0x0001 - 0x0000)
struct GzTeam_HasPlayersInMatch final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzTeam_HasPlayersInMatch) == 0x000001, "Wrong alignment on GzTeam_HasPlayersInMatch");
static_assert(sizeof(GzTeam_HasPlayersInMatch) == 0x000001, "Wrong size on GzTeam_HasPlayersInMatch");
static_assert(offsetof(GzTeam_HasPlayersInMatch, ReturnValue) == 0x000000, "Member 'GzTeam_HasPlayersInMatch::ReturnValue' has a wrong offset!");

// Function G01.GzTeam.HasTeamLeader
// 0x0001 (0x0001 - 0x0000)
struct GzTeam_HasTeamLeader final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzTeam_HasTeamLeader) == 0x000001, "Wrong alignment on GzTeam_HasTeamLeader");
static_assert(sizeof(GzTeam_HasTeamLeader) == 0x000001, "Wrong size on GzTeam_HasTeamLeader");
static_assert(offsetof(GzTeam_HasTeamLeader, ReturnValue) == 0x000000, "Member 'GzTeam_HasTeamLeader::ReturnValue' has a wrong offset!");

// Function G01.GzTeam.IsAnyoneAlive
// 0x0001 (0x0001 - 0x0000)
struct GzTeam_IsAnyoneAlive final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzTeam_IsAnyoneAlive) == 0x000001, "Wrong alignment on GzTeam_IsAnyoneAlive");
static_assert(sizeof(GzTeam_IsAnyoneAlive) == 0x000001, "Wrong size on GzTeam_IsAnyoneAlive");
static_assert(offsetof(GzTeam_IsAnyoneAlive, ReturnValue) == 0x000000, "Member 'GzTeam_IsAnyoneAlive::ReturnValue' has a wrong offset!");

// Function G01.GzTeam.IsDefeated
// 0x0001 (0x0001 - 0x0000)
struct GzTeam_IsDefeated final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzTeam_IsDefeated) == 0x000001, "Wrong alignment on GzTeam_IsDefeated");
static_assert(sizeof(GzTeam_IsDefeated) == 0x000001, "Wrong size on GzTeam_IsDefeated");
static_assert(offsetof(GzTeam_IsDefeated, ReturnValue) == 0x000000, "Member 'GzTeam_IsDefeated::ReturnValue' has a wrong offset!");

// Function G01.GzTeam.IsEmpty
// 0x0001 (0x0001 - 0x0000)
struct GzTeam_IsEmpty final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzTeam_IsEmpty) == 0x000001, "Wrong alignment on GzTeam_IsEmpty");
static_assert(sizeof(GzTeam_IsEmpty) == 0x000001, "Wrong size on GzTeam_IsEmpty");
static_assert(offsetof(GzTeam_IsEmpty, ReturnValue) == 0x000000, "Member 'GzTeam_IsEmpty::ReturnValue' has a wrong offset!");

// Function G01.GzTeam.IsFull
// 0x0001 (0x0001 - 0x0000)
struct GzTeam_IsFull final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzTeam_IsFull) == 0x000001, "Wrong alignment on GzTeam_IsFull");
static_assert(sizeof(GzTeam_IsFull) == 0x000001, "Wrong size on GzTeam_IsFull");
static_assert(offsetof(GzTeam_IsFull, ReturnValue) == 0x000000, "Member 'GzTeam_IsFull::ReturnValue' has a wrong offset!");

// Function G01.GzTeam.IsTeamAlive
// 0x0001 (0x0001 - 0x0000)
struct GzTeam_IsTeamAlive final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzTeam_IsTeamAlive) == 0x000001, "Wrong alignment on GzTeam_IsTeamAlive");
static_assert(sizeof(GzTeam_IsTeamAlive) == 0x000001, "Wrong size on GzTeam_IsTeamAlive");
static_assert(offsetof(GzTeam_IsTeamAlive, ReturnValue) == 0x000000, "Member 'GzTeam_IsTeamAlive::ReturnValue' has a wrong offset!");

// Function G01.GzTetherPreviewComponent.OnTetherDestroyed
// 0x0008 (0x0008 - 0x0000)
struct GzTetherPreviewComponent_OnTetherDestroyed final
{
public:
	class AActor*                                 DestroyedActor;                                    // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzTetherPreviewComponent_OnTetherDestroyed) == 0x000008, "Wrong alignment on GzTetherPreviewComponent_OnTetherDestroyed");
static_assert(sizeof(GzTetherPreviewComponent_OnTetherDestroyed) == 0x000008, "Wrong size on GzTetherPreviewComponent_OnTetherDestroyed");
static_assert(offsetof(GzTetherPreviewComponent_OnTetherDestroyed, DestroyedActor) == 0x000000, "Member 'GzTetherPreviewComponent_OnTetherDestroyed::DestroyedActor' has a wrong offset!");

// Function G01.GzTetherPreviewComponent.RegisterTetherPair
// 0x0018 (0x0018 - 0x0000)
struct GzTetherPreviewComponent_RegisterTetherPair final
{
public:
	class AActor*                                 FirstTether;                                       // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 SecondTether;                                      // 0x0008(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 TetherLink;                                        // 0x0010(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzTetherPreviewComponent_RegisterTetherPair) == 0x000008, "Wrong alignment on GzTetherPreviewComponent_RegisterTetherPair");
static_assert(sizeof(GzTetherPreviewComponent_RegisterTetherPair) == 0x000018, "Wrong size on GzTetherPreviewComponent_RegisterTetherPair");
static_assert(offsetof(GzTetherPreviewComponent_RegisterTetherPair, FirstTether) == 0x000000, "Member 'GzTetherPreviewComponent_RegisterTetherPair::FirstTether' has a wrong offset!");
static_assert(offsetof(GzTetherPreviewComponent_RegisterTetherPair, SecondTether) == 0x000008, "Member 'GzTetherPreviewComponent_RegisterTetherPair::SecondTether' has a wrong offset!");
static_assert(offsetof(GzTetherPreviewComponent_RegisterTetherPair, TetherLink) == 0x000010, "Member 'GzTetherPreviewComponent_RegisterTetherPair::TetherLink' has a wrong offset!");

// Function G01.GzTetherPreviewComponent.GetTetherLimit
// 0x0004 (0x0004 - 0x0000)
struct GzTetherPreviewComponent_GetTetherLimit final
{
public:
	int32                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzTetherPreviewComponent_GetTetherLimit) == 0x000004, "Wrong alignment on GzTetherPreviewComponent_GetTetherLimit");
static_assert(sizeof(GzTetherPreviewComponent_GetTetherLimit) == 0x000004, "Wrong size on GzTetherPreviewComponent_GetTetherLimit");
static_assert(offsetof(GzTetherPreviewComponent_GetTetherLimit, ReturnValue) == 0x000000, "Member 'GzTetherPreviewComponent_GetTetherLimit::ReturnValue' has a wrong offset!");

// Function G01.GzTextBlock.GetTextColorNames
// 0x0010 (0x0010 - 0x0000)
struct GzTextBlock_GetTextColorNames final
{
public:
	TArray<class FString>                         ReturnValue;                                       // 0x0000(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzTextBlock_GetTextColorNames) == 0x000008, "Wrong alignment on GzTextBlock_GetTextColorNames");
static_assert(sizeof(GzTextBlock_GetTextColorNames) == 0x000010, "Wrong size on GzTextBlock_GetTextColorNames");
static_assert(offsetof(GzTextBlock_GetTextColorNames, ReturnValue) == 0x000000, "Member 'GzTextBlock_GetTextColorNames::ReturnValue' has a wrong offset!");

// Function G01.GzTextBlock.SetColorOverrideName
// 0x0008 (0x0008 - 0x0000)
struct GzTextBlock_SetColorOverrideName final
{
public:
	class FName                                   ColorName;                                         // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzTextBlock_SetColorOverrideName) == 0x000004, "Wrong alignment on GzTextBlock_SetColorOverrideName");
static_assert(sizeof(GzTextBlock_SetColorOverrideName) == 0x000008, "Wrong size on GzTextBlock_SetColorOverrideName");
static_assert(offsetof(GzTextBlock_SetColorOverrideName, ColorName) == 0x000000, "Member 'GzTextBlock_SetColorOverrideName::ColorName' has a wrong offset!");

// Function G01.GzTextBlock.SetFontTag
// 0x0008 (0x0008 - 0x0000)
struct GzTextBlock_SetFontTag final
{
public:
	struct FGameplayTag                           InFontTag;                                         // 0x0000(0x0008)(Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzTextBlock_SetFontTag) == 0x000004, "Wrong alignment on GzTextBlock_SetFontTag");
static_assert(sizeof(GzTextBlock_SetFontTag) == 0x000008, "Wrong size on GzTextBlock_SetFontTag");
static_assert(offsetof(GzTextBlock_SetFontTag, InFontTag) == 0x000000, "Member 'GzTextBlock_SetFontTag::InFontTag' has a wrong offset!");

// Function G01.GzThrowableShieldComponent.IsShieldActive
// 0x0001 (0x0001 - 0x0000)
struct GzThrowableShieldComponent_IsShieldActive final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzThrowableShieldComponent_IsShieldActive) == 0x000001, "Wrong alignment on GzThrowableShieldComponent_IsShieldActive");
static_assert(sizeof(GzThrowableShieldComponent_IsShieldActive) == 0x000001, "Wrong size on GzThrowableShieldComponent_IsShieldActive");
static_assert(offsetof(GzThrowableShieldComponent_IsShieldActive, ReturnValue) == 0x000000, "Member 'GzThrowableShieldComponent_IsShieldActive::ReturnValue' has a wrong offset!");

// Function G01.GzThrowableShieldComponent.IsShieldLaunched
// 0x0001 (0x0001 - 0x0000)
struct GzThrowableShieldComponent_IsShieldLaunched final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzThrowableShieldComponent_IsShieldLaunched) == 0x000001, "Wrong alignment on GzThrowableShieldComponent_IsShieldLaunched");
static_assert(sizeof(GzThrowableShieldComponent_IsShieldLaunched) == 0x000001, "Wrong size on GzThrowableShieldComponent_IsShieldLaunched");
static_assert(offsetof(GzThrowableShieldComponent_IsShieldLaunched, ReturnValue) == 0x000000, "Member 'GzThrowableShieldComponent_IsShieldLaunched::ReturnValue' has a wrong offset!");

// Function G01.GzThrowPathActor.GetSourceLocationAndDirection
// 0x0030 (0x0030 - 0x0000)
struct GzThrowPathActor_GetSourceLocationAndDirection final
{
public:
	struct FVector                                OutLocation;                                       // 0x0000(0x0018)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                OutDirection;                                      // 0x0018(0x0018)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzThrowPathActor_GetSourceLocationAndDirection) == 0x000008, "Wrong alignment on GzThrowPathActor_GetSourceLocationAndDirection");
static_assert(sizeof(GzThrowPathActor_GetSourceLocationAndDirection) == 0x000030, "Wrong size on GzThrowPathActor_GetSourceLocationAndDirection");
static_assert(offsetof(GzThrowPathActor_GetSourceLocationAndDirection, OutLocation) == 0x000000, "Member 'GzThrowPathActor_GetSourceLocationAndDirection::OutLocation' has a wrong offset!");
static_assert(offsetof(GzThrowPathActor_GetSourceLocationAndDirection, OutDirection) == 0x000018, "Member 'GzThrowPathActor_GetSourceLocationAndDirection::OutDirection' has a wrong offset!");

// Function G01.GzThrowPathActor.GetSourceTransform
// 0x0060 (0x0060 - 0x0000)
struct GzThrowPathActor_GetSourceTransform final
{
public:
	struct FTransform                             OutTransform;                                      // 0x0000(0x0060)(Parm, OutParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzThrowPathActor_GetSourceTransform) == 0x000010, "Wrong alignment on GzThrowPathActor_GetSourceTransform");
static_assert(sizeof(GzThrowPathActor_GetSourceTransform) == 0x000060, "Wrong size on GzThrowPathActor_GetSourceTransform");
static_assert(offsetof(GzThrowPathActor_GetSourceTransform, OutTransform) == 0x000000, "Member 'GzThrowPathActor_GetSourceTransform::OutTransform' has a wrong offset!");

// Function G01.GzThrowPathActor.Initialize
// 0x0020 (0x0020 - 0x0000)
struct GzThrowPathActor_Initialize final
{
public:
	const class UGzProjectileData*                InProjectileData;                                  // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InTargetThrowDistance;                             // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InThrowCurveAddedAngle;                            // 0x000C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InMaxThrowAngle;                                   // 0x0010(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   InAttachSocketName;                                // 0x0014(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3533[0x4];                                     // 0x001C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GzThrowPathActor_Initialize) == 0x000008, "Wrong alignment on GzThrowPathActor_Initialize");
static_assert(sizeof(GzThrowPathActor_Initialize) == 0x000020, "Wrong size on GzThrowPathActor_Initialize");
static_assert(offsetof(GzThrowPathActor_Initialize, InProjectileData) == 0x000000, "Member 'GzThrowPathActor_Initialize::InProjectileData' has a wrong offset!");
static_assert(offsetof(GzThrowPathActor_Initialize, InTargetThrowDistance) == 0x000008, "Member 'GzThrowPathActor_Initialize::InTargetThrowDistance' has a wrong offset!");
static_assert(offsetof(GzThrowPathActor_Initialize, InThrowCurveAddedAngle) == 0x00000C, "Member 'GzThrowPathActor_Initialize::InThrowCurveAddedAngle' has a wrong offset!");
static_assert(offsetof(GzThrowPathActor_Initialize, InMaxThrowAngle) == 0x000010, "Member 'GzThrowPathActor_Initialize::InMaxThrowAngle' has a wrong offset!");
static_assert(offsetof(GzThrowPathActor_Initialize, InAttachSocketName) == 0x000014, "Member 'GzThrowPathActor_Initialize::InAttachSocketName' has a wrong offset!");

// Function G01.GzTimerCondition.GetDuration
// 0x0004 (0x0004 - 0x0000)
struct GzTimerCondition_GetDuration final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzTimerCondition_GetDuration) == 0x000004, "Wrong alignment on GzTimerCondition_GetDuration");
static_assert(sizeof(GzTimerCondition_GetDuration) == 0x000004, "Wrong size on GzTimerCondition_GetDuration");
static_assert(offsetof(GzTimerCondition_GetDuration, ReturnValue) == 0x000000, "Member 'GzTimerCondition_GetDuration::ReturnValue' has a wrong offset!");

// Function G01.GzToxicSmokePropagation.ApplyDamageEffect
// 0x0010 (0x0010 - 0x0000)
struct GzToxicSmokePropagation_ApplyDamageEffect final
{
public:
	class UAbilitySystemComponent*                TargetASC;                                         // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FActiveGameplayEffectHandle            ReturnValue;                                       // 0x0008(0x0008)(Parm, OutParm, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzToxicSmokePropagation_ApplyDamageEffect) == 0x000008, "Wrong alignment on GzToxicSmokePropagation_ApplyDamageEffect");
static_assert(sizeof(GzToxicSmokePropagation_ApplyDamageEffect) == 0x000010, "Wrong size on GzToxicSmokePropagation_ApplyDamageEffect");
static_assert(offsetof(GzToxicSmokePropagation_ApplyDamageEffect, TargetASC) == 0x000000, "Member 'GzToxicSmokePropagation_ApplyDamageEffect::TargetASC' has a wrong offset!");
static_assert(offsetof(GzToxicSmokePropagation_ApplyDamageEffect, ReturnValue) == 0x000008, "Member 'GzToxicSmokePropagation_ApplyDamageEffect::ReturnValue' has a wrong offset!");

// Function G01.GzTrialSubsystemCheatExtension.AddTrialProgress
// 0x000C (0x000C - 0x0000)
struct GzTrialSubsystemCheatExtension_AddTrialProgress final
{
public:
	class FName                                   TrialId;                                           // 0x0000(0x0008)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ProgressToAdd;                                     // 0x0008(0x0004)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzTrialSubsystemCheatExtension_AddTrialProgress) == 0x000004, "Wrong alignment on GzTrialSubsystemCheatExtension_AddTrialProgress");
static_assert(sizeof(GzTrialSubsystemCheatExtension_AddTrialProgress) == 0x00000C, "Wrong size on GzTrialSubsystemCheatExtension_AddTrialProgress");
static_assert(offsetof(GzTrialSubsystemCheatExtension_AddTrialProgress, TrialId) == 0x000000, "Member 'GzTrialSubsystemCheatExtension_AddTrialProgress::TrialId' has a wrong offset!");
static_assert(offsetof(GzTrialSubsystemCheatExtension_AddTrialProgress, ProgressToAdd) == 0x000008, "Member 'GzTrialSubsystemCheatExtension_AddTrialProgress::ProgressToAdd' has a wrong offset!");

// Function G01.GzTrialSubsystemCheatExtension.EnableDebugTrialTracking
// 0x0008 (0x0008 - 0x0000)
struct GzTrialSubsystemCheatExtension_EnableDebugTrialTracking final
{
public:
	class FName                                   TrialId;                                           // 0x0000(0x0008)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzTrialSubsystemCheatExtension_EnableDebugTrialTracking) == 0x000004, "Wrong alignment on GzTrialSubsystemCheatExtension_EnableDebugTrialTracking");
static_assert(sizeof(GzTrialSubsystemCheatExtension_EnableDebugTrialTracking) == 0x000008, "Wrong size on GzTrialSubsystemCheatExtension_EnableDebugTrialTracking");
static_assert(offsetof(GzTrialSubsystemCheatExtension_EnableDebugTrialTracking, TrialId) == 0x000000, "Member 'GzTrialSubsystemCheatExtension_EnableDebugTrialTracking::TrialId' has a wrong offset!");

// DelegateFunction G01.GzTurretWeaponActor.GzTurretOwnerChanged__DelegateSignature
// 0x0008 (0x0008 - 0x0000)
struct GzTurretWeaponActor_GzTurretOwnerChanged__DelegateSignature final
{
public:
	class AActor*                                 NewActor;                                          // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzTurretWeaponActor_GzTurretOwnerChanged__DelegateSignature) == 0x000008, "Wrong alignment on GzTurretWeaponActor_GzTurretOwnerChanged__DelegateSignature");
static_assert(sizeof(GzTurretWeaponActor_GzTurretOwnerChanged__DelegateSignature) == 0x000008, "Wrong size on GzTurretWeaponActor_GzTurretOwnerChanged__DelegateSignature");
static_assert(offsetof(GzTurretWeaponActor_GzTurretOwnerChanged__DelegateSignature, NewActor) == 0x000000, "Member 'GzTurretWeaponActor_GzTurretOwnerChanged__DelegateSignature::NewActor' has a wrong offset!");

// Function G01.GzUIBlueprintFunctionLibrary.FindFontSettingsInRichTextBox
// 0x0360 (0x0360 - 0x0000)
struct GzUIBlueprintFunctionLibrary_FindFontSettingsInRichTextBox final
{
public:
	class URichTextBlock*                         Rich;                                              // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   FontID;                                            // 0x0008(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          OutSuccessful;                                     // 0x0010(0x0001)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3541[0xF];                                     // 0x0011(0x000F)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTextBlockStyle                        ReturnValue;                                       // 0x0020(0x0340)(Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzUIBlueprintFunctionLibrary_FindFontSettingsInRichTextBox) == 0x000010, "Wrong alignment on GzUIBlueprintFunctionLibrary_FindFontSettingsInRichTextBox");
static_assert(sizeof(GzUIBlueprintFunctionLibrary_FindFontSettingsInRichTextBox) == 0x000360, "Wrong size on GzUIBlueprintFunctionLibrary_FindFontSettingsInRichTextBox");
static_assert(offsetof(GzUIBlueprintFunctionLibrary_FindFontSettingsInRichTextBox, Rich) == 0x000000, "Member 'GzUIBlueprintFunctionLibrary_FindFontSettingsInRichTextBox::Rich' has a wrong offset!");
static_assert(offsetof(GzUIBlueprintFunctionLibrary_FindFontSettingsInRichTextBox, FontID) == 0x000008, "Member 'GzUIBlueprintFunctionLibrary_FindFontSettingsInRichTextBox::FontID' has a wrong offset!");
static_assert(offsetof(GzUIBlueprintFunctionLibrary_FindFontSettingsInRichTextBox, OutSuccessful) == 0x000010, "Member 'GzUIBlueprintFunctionLibrary_FindFontSettingsInRichTextBox::OutSuccessful' has a wrong offset!");
static_assert(offsetof(GzUIBlueprintFunctionLibrary_FindFontSettingsInRichTextBox, ReturnValue) == 0x000020, "Member 'GzUIBlueprintFunctionLibrary_FindFontSettingsInRichTextBox::ReturnValue' has a wrong offset!");

// Function G01.GzUIBlueprintFunctionLibrary.GetColorById
// 0x0018 (0x0018 - 0x0000)
struct GzUIBlueprintFunctionLibrary_GetColorById final
{
public:
	class FName                                   ColorID;                                           // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           ReturnValue;                                       // 0x0008(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzUIBlueprintFunctionLibrary_GetColorById) == 0x000004, "Wrong alignment on GzUIBlueprintFunctionLibrary_GetColorById");
static_assert(sizeof(GzUIBlueprintFunctionLibrary_GetColorById) == 0x000018, "Wrong size on GzUIBlueprintFunctionLibrary_GetColorById");
static_assert(offsetof(GzUIBlueprintFunctionLibrary_GetColorById, ColorID) == 0x000000, "Member 'GzUIBlueprintFunctionLibrary_GetColorById::ColorID' has a wrong offset!");
static_assert(offsetof(GzUIBlueprintFunctionLibrary_GetColorById, ReturnValue) == 0x000008, "Member 'GzUIBlueprintFunctionLibrary_GetColorById::ReturnValue' has a wrong offset!");

// Function G01.GzUIBlueprintFunctionLibrary.GetDefaultErrorColor
// 0x0010 (0x0010 - 0x0000)
struct GzUIBlueprintFunctionLibrary_GetDefaultErrorColor final
{
public:
	struct FLinearColor                           ReturnValue;                                       // 0x0000(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzUIBlueprintFunctionLibrary_GetDefaultErrorColor) == 0x000004, "Wrong alignment on GzUIBlueprintFunctionLibrary_GetDefaultErrorColor");
static_assert(sizeof(GzUIBlueprintFunctionLibrary_GetDefaultErrorColor) == 0x000010, "Wrong size on GzUIBlueprintFunctionLibrary_GetDefaultErrorColor");
static_assert(offsetof(GzUIBlueprintFunctionLibrary_GetDefaultErrorColor, ReturnValue) == 0x000000, "Member 'GzUIBlueprintFunctionLibrary_GetDefaultErrorColor::ReturnValue' has a wrong offset!");

// Function G01.GzUIBlueprintFunctionLibrary.GetFocusedUMGWidget
// 0x0008 (0x0008 - 0x0000)
struct GzUIBlueprintFunctionLibrary_GetFocusedUMGWidget final
{
public:
	class UWidget*                                ReturnValue;                                       // 0x0000(0x0008)(ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzUIBlueprintFunctionLibrary_GetFocusedUMGWidget) == 0x000008, "Wrong alignment on GzUIBlueprintFunctionLibrary_GetFocusedUMGWidget");
static_assert(sizeof(GzUIBlueprintFunctionLibrary_GetFocusedUMGWidget) == 0x000008, "Wrong size on GzUIBlueprintFunctionLibrary_GetFocusedUMGWidget");
static_assert(offsetof(GzUIBlueprintFunctionLibrary_GetFocusedUMGWidget, ReturnValue) == 0x000000, "Member 'GzUIBlueprintFunctionLibrary_GetFocusedUMGWidget::ReturnValue' has a wrong offset!");

// Function G01.GzUIBlueprintFunctionLibrary.GetGeometryCenter
// 0x0050 (0x0050 - 0x0000)
struct GzUIBlueprintFunctionLibrary_GetGeometryCenter final
{
public:
	class UObject*                                WorldContextObject;                                // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGeometry                              Geometry;                                          // 0x0008(0x0038)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FVector2D                              ReturnValue;                                       // 0x0040(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzUIBlueprintFunctionLibrary_GetGeometryCenter) == 0x000008, "Wrong alignment on GzUIBlueprintFunctionLibrary_GetGeometryCenter");
static_assert(sizeof(GzUIBlueprintFunctionLibrary_GetGeometryCenter) == 0x000050, "Wrong size on GzUIBlueprintFunctionLibrary_GetGeometryCenter");
static_assert(offsetof(GzUIBlueprintFunctionLibrary_GetGeometryCenter, WorldContextObject) == 0x000000, "Member 'GzUIBlueprintFunctionLibrary_GetGeometryCenter::WorldContextObject' has a wrong offset!");
static_assert(offsetof(GzUIBlueprintFunctionLibrary_GetGeometryCenter, Geometry) == 0x000008, "Member 'GzUIBlueprintFunctionLibrary_GetGeometryCenter::Geometry' has a wrong offset!");
static_assert(offsetof(GzUIBlueprintFunctionLibrary_GetGeometryCenter, ReturnValue) == 0x000040, "Member 'GzUIBlueprintFunctionLibrary_GetGeometryCenter::ReturnValue' has a wrong offset!");

// Function G01.GzUIBlueprintFunctionLibrary.GetKeyBrush
// 0x0100 (0x0100 - 0x0000)
struct GzUIBlueprintFunctionLibrary_GetKeyBrush final
{
public:
	const class UObject*                          WorldContextObject;                                // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3542[0x8];                                     // 0x0008(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FSlateBrush                            OutBrush;                                          // 0x0010(0x00D0)(Parm, OutParm, NativeAccessSpecifierPublic)
	struct FKey                                   Key;                                               // 0x00E0(0x0018)(ConstParm, Parm, OutParm, ReferenceParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x00F8(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3543[0x7];                                     // 0x00F9(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GzUIBlueprintFunctionLibrary_GetKeyBrush) == 0x000010, "Wrong alignment on GzUIBlueprintFunctionLibrary_GetKeyBrush");
static_assert(sizeof(GzUIBlueprintFunctionLibrary_GetKeyBrush) == 0x000100, "Wrong size on GzUIBlueprintFunctionLibrary_GetKeyBrush");
static_assert(offsetof(GzUIBlueprintFunctionLibrary_GetKeyBrush, WorldContextObject) == 0x000000, "Member 'GzUIBlueprintFunctionLibrary_GetKeyBrush::WorldContextObject' has a wrong offset!");
static_assert(offsetof(GzUIBlueprintFunctionLibrary_GetKeyBrush, OutBrush) == 0x000010, "Member 'GzUIBlueprintFunctionLibrary_GetKeyBrush::OutBrush' has a wrong offset!");
static_assert(offsetof(GzUIBlueprintFunctionLibrary_GetKeyBrush, Key) == 0x0000E0, "Member 'GzUIBlueprintFunctionLibrary_GetKeyBrush::Key' has a wrong offset!");
static_assert(offsetof(GzUIBlueprintFunctionLibrary_GetKeyBrush, ReturnValue) == 0x0000F8, "Member 'GzUIBlueprintFunctionLibrary_GetKeyBrush::ReturnValue' has a wrong offset!");

// Function G01.GzUIBlueprintFunctionLibrary.GetLoadedHUDComponents
// 0x0010 (0x0010 - 0x0000)
struct GzUIBlueprintFunctionLibrary_GetLoadedHUDComponents final
{
public:
	TArray<class UClass*>                         ReturnValue;                                       // 0x0000(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzUIBlueprintFunctionLibrary_GetLoadedHUDComponents) == 0x000008, "Wrong alignment on GzUIBlueprintFunctionLibrary_GetLoadedHUDComponents");
static_assert(sizeof(GzUIBlueprintFunctionLibrary_GetLoadedHUDComponents) == 0x000010, "Wrong size on GzUIBlueprintFunctionLibrary_GetLoadedHUDComponents");
static_assert(offsetof(GzUIBlueprintFunctionLibrary_GetLoadedHUDComponents, ReturnValue) == 0x000000, "Member 'GzUIBlueprintFunctionLibrary_GetLoadedHUDComponents::ReturnValue' has a wrong offset!");

// Function G01.GzUIBlueprintFunctionLibrary.GetTeammateColorFromIndex
// 0x0014 (0x0014 - 0x0000)
struct GzUIBlueprintFunctionLibrary_GetTeammateColorFromIndex final
{
public:
	int32                                         InPlayerIndex;                                     // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           ReturnValue;                                       // 0x0004(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzUIBlueprintFunctionLibrary_GetTeammateColorFromIndex) == 0x000004, "Wrong alignment on GzUIBlueprintFunctionLibrary_GetTeammateColorFromIndex");
static_assert(sizeof(GzUIBlueprintFunctionLibrary_GetTeammateColorFromIndex) == 0x000014, "Wrong size on GzUIBlueprintFunctionLibrary_GetTeammateColorFromIndex");
static_assert(offsetof(GzUIBlueprintFunctionLibrary_GetTeammateColorFromIndex, InPlayerIndex) == 0x000000, "Member 'GzUIBlueprintFunctionLibrary_GetTeammateColorFromIndex::InPlayerIndex' has a wrong offset!");
static_assert(offsetof(GzUIBlueprintFunctionLibrary_GetTeammateColorFromIndex, ReturnValue) == 0x000004, "Member 'GzUIBlueprintFunctionLibrary_GetTeammateColorFromIndex::ReturnValue' has a wrong offset!");

// Function G01.GzUIBlueprintFunctionLibrary.GetWatermarkTextTemplate
// 0x0010 (0x0010 - 0x0000)
struct GzUIBlueprintFunctionLibrary_GetWatermarkTextTemplate final
{
public:
	class FString                                 ReturnValue;                                       // 0x0000(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzUIBlueprintFunctionLibrary_GetWatermarkTextTemplate) == 0x000008, "Wrong alignment on GzUIBlueprintFunctionLibrary_GetWatermarkTextTemplate");
static_assert(sizeof(GzUIBlueprintFunctionLibrary_GetWatermarkTextTemplate) == 0x000010, "Wrong size on GzUIBlueprintFunctionLibrary_GetWatermarkTextTemplate");
static_assert(offsetof(GzUIBlueprintFunctionLibrary_GetWatermarkTextTemplate, ReturnValue) == 0x000000, "Member 'GzUIBlueprintFunctionLibrary_GetWatermarkTextTemplate::ReturnValue' has a wrong offset!");

// Function G01.GzUIBlueprintFunctionLibrary.IsVisibleInHierarchy
// 0x0010 (0x0010 - 0x0000)
struct GzUIBlueprintFunctionLibrary_IsVisibleInHierarchy final
{
public:
	class UWidget*                                Widget;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3544[0x7];                                     // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GzUIBlueprintFunctionLibrary_IsVisibleInHierarchy) == 0x000008, "Wrong alignment on GzUIBlueprintFunctionLibrary_IsVisibleInHierarchy");
static_assert(sizeof(GzUIBlueprintFunctionLibrary_IsVisibleInHierarchy) == 0x000010, "Wrong size on GzUIBlueprintFunctionLibrary_IsVisibleInHierarchy");
static_assert(offsetof(GzUIBlueprintFunctionLibrary_IsVisibleInHierarchy, Widget) == 0x000000, "Member 'GzUIBlueprintFunctionLibrary_IsVisibleInHierarchy::Widget' has a wrong offset!");
static_assert(offsetof(GzUIBlueprintFunctionLibrary_IsVisibleInHierarchy, ReturnValue) == 0x000008, "Member 'GzUIBlueprintFunctionLibrary_IsVisibleInHierarchy::ReturnValue' has a wrong offset!");

// Function G01.GzUIBlueprintFunctionLibrary.SetCanvasSlotPosition
// 0x0018 (0x0018 - 0x0000)
struct GzUIBlueprintFunctionLibrary_SetCanvasSlotPosition final
{
public:
	class UCanvasPanelSlot*                       Slot;                                              // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              Position;                                          // 0x0008(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzUIBlueprintFunctionLibrary_SetCanvasSlotPosition) == 0x000008, "Wrong alignment on GzUIBlueprintFunctionLibrary_SetCanvasSlotPosition");
static_assert(sizeof(GzUIBlueprintFunctionLibrary_SetCanvasSlotPosition) == 0x000018, "Wrong size on GzUIBlueprintFunctionLibrary_SetCanvasSlotPosition");
static_assert(offsetof(GzUIBlueprintFunctionLibrary_SetCanvasSlotPosition, Slot) == 0x000000, "Member 'GzUIBlueprintFunctionLibrary_SetCanvasSlotPosition::Slot' has a wrong offset!");
static_assert(offsetof(GzUIBlueprintFunctionLibrary_SetCanvasSlotPosition, Position) == 0x000008, "Member 'GzUIBlueprintFunctionLibrary_SetCanvasSlotPosition::Position' has a wrong offset!");

// Function G01.GzUIBlueprintFunctionLibrary.SetRenderAngle
// 0x0010 (0x0010 - 0x0000)
struct GzUIBlueprintFunctionLibrary_SetRenderAngle final
{
public:
	class UWidget*                                Widget;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Angle;                                             // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3545[0x4];                                     // 0x000C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GzUIBlueprintFunctionLibrary_SetRenderAngle) == 0x000008, "Wrong alignment on GzUIBlueprintFunctionLibrary_SetRenderAngle");
static_assert(sizeof(GzUIBlueprintFunctionLibrary_SetRenderAngle) == 0x000010, "Wrong size on GzUIBlueprintFunctionLibrary_SetRenderAngle");
static_assert(offsetof(GzUIBlueprintFunctionLibrary_SetRenderAngle, Widget) == 0x000000, "Member 'GzUIBlueprintFunctionLibrary_SetRenderAngle::Widget' has a wrong offset!");
static_assert(offsetof(GzUIBlueprintFunctionLibrary_SetRenderAngle, Angle) == 0x000008, "Member 'GzUIBlueprintFunctionLibrary_SetRenderAngle::Angle' has a wrong offset!");

// Function G01.GzUIBlueprintFunctionLibrary.SetRenderScale
// 0x0018 (0x0018 - 0x0000)
struct GzUIBlueprintFunctionLibrary_SetRenderScale final
{
public:
	class UWidget*                                Widget;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              Scale;                                             // 0x0008(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzUIBlueprintFunctionLibrary_SetRenderScale) == 0x000008, "Wrong alignment on GzUIBlueprintFunctionLibrary_SetRenderScale");
static_assert(sizeof(GzUIBlueprintFunctionLibrary_SetRenderScale) == 0x000018, "Wrong size on GzUIBlueprintFunctionLibrary_SetRenderScale");
static_assert(offsetof(GzUIBlueprintFunctionLibrary_SetRenderScale, Widget) == 0x000000, "Member 'GzUIBlueprintFunctionLibrary_SetRenderScale::Widget' has a wrong offset!");
static_assert(offsetof(GzUIBlueprintFunctionLibrary_SetRenderScale, Scale) == 0x000008, "Member 'GzUIBlueprintFunctionLibrary_SetRenderScale::Scale' has a wrong offset!");

// Function G01.GzUIBlueprintFunctionLibrary.SetRenderTranslation
// 0x0018 (0x0018 - 0x0000)
struct GzUIBlueprintFunctionLibrary_SetRenderTranslation final
{
public:
	class UWidget*                                Widget;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              Translation;                                       // 0x0008(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzUIBlueprintFunctionLibrary_SetRenderTranslation) == 0x000008, "Wrong alignment on GzUIBlueprintFunctionLibrary_SetRenderTranslation");
static_assert(sizeof(GzUIBlueprintFunctionLibrary_SetRenderTranslation) == 0x000018, "Wrong size on GzUIBlueprintFunctionLibrary_SetRenderTranslation");
static_assert(offsetof(GzUIBlueprintFunctionLibrary_SetRenderTranslation, Widget) == 0x000000, "Member 'GzUIBlueprintFunctionLibrary_SetRenderTranslation::Widget' has a wrong offset!");
static_assert(offsetof(GzUIBlueprintFunctionLibrary_SetRenderTranslation, Translation) == 0x000008, "Member 'GzUIBlueprintFunctionLibrary_SetRenderTranslation::Translation' has a wrong offset!");

// Function G01.GzUIBlueprintFunctionLibrary.SetVisibility
// 0x0010 (0x0010 - 0x0000)
struct GzUIBlueprintFunctionLibrary_SetVisibility final
{
public:
	class UWidget*                                Widget;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESlateVisibility                              InVisibility;                                      // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3546[0x7];                                     // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GzUIBlueprintFunctionLibrary_SetVisibility) == 0x000008, "Wrong alignment on GzUIBlueprintFunctionLibrary_SetVisibility");
static_assert(sizeof(GzUIBlueprintFunctionLibrary_SetVisibility) == 0x000010, "Wrong size on GzUIBlueprintFunctionLibrary_SetVisibility");
static_assert(offsetof(GzUIBlueprintFunctionLibrary_SetVisibility, Widget) == 0x000000, "Member 'GzUIBlueprintFunctionLibrary_SetVisibility::Widget' has a wrong offset!");
static_assert(offsetof(GzUIBlueprintFunctionLibrary_SetVisibility, InVisibility) == 0x000008, "Member 'GzUIBlueprintFunctionLibrary_SetVisibility::InVisibility' has a wrong offset!");

// Function G01.GzUIBlueprintFunctionLibrary.ShouldDisplayPlayerIdEncoding
// 0x0001 (0x0001 - 0x0000)
struct GzUIBlueprintFunctionLibrary_ShouldDisplayPlayerIdEncoding final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzUIBlueprintFunctionLibrary_ShouldDisplayPlayerIdEncoding) == 0x000001, "Wrong alignment on GzUIBlueprintFunctionLibrary_ShouldDisplayPlayerIdEncoding");
static_assert(sizeof(GzUIBlueprintFunctionLibrary_ShouldDisplayPlayerIdEncoding) == 0x000001, "Wrong size on GzUIBlueprintFunctionLibrary_ShouldDisplayPlayerIdEncoding");
static_assert(offsetof(GzUIBlueprintFunctionLibrary_ShouldDisplayPlayerIdEncoding, ReturnValue) == 0x000000, "Member 'GzUIBlueprintFunctionLibrary_ShouldDisplayPlayerIdEncoding::ReturnValue' has a wrong offset!");

// Function G01.GzUnityMatchmakingServiceStatePollingTicket.OnTicketStatusRequestError
// 0x0038 (0x0038 - 0x0000)
struct GzUnityMatchmakingServiceStatePollingTicket_OnTicketStatusRequestError final
{
public:
	struct FUnityTicketStatusError                Error;                                             // 0x0000(0x0038)(Parm, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzUnityMatchmakingServiceStatePollingTicket_OnTicketStatusRequestError) == 0x000008, "Wrong alignment on GzUnityMatchmakingServiceStatePollingTicket_OnTicketStatusRequestError");
static_assert(sizeof(GzUnityMatchmakingServiceStatePollingTicket_OnTicketStatusRequestError) == 0x000038, "Wrong size on GzUnityMatchmakingServiceStatePollingTicket_OnTicketStatusRequestError");
static_assert(offsetof(GzUnityMatchmakingServiceStatePollingTicket_OnTicketStatusRequestError, Error) == 0x000000, "Member 'GzUnityMatchmakingServiceStatePollingTicket_OnTicketStatusRequestError::Error' has a wrong offset!");

// Function G01.GzUnityMatchmakingServiceStatePollingTicket.OnTicketStatusUpdate
// 0x0040 (0x0040 - 0x0000)
struct GzUnityMatchmakingServiceStatePollingTicket_OnTicketStatusUpdate final
{
public:
	struct FUnityTicketStatusResult               Result;                                            // 0x0000(0x0040)(Parm, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzUnityMatchmakingServiceStatePollingTicket_OnTicketStatusUpdate) == 0x000008, "Wrong alignment on GzUnityMatchmakingServiceStatePollingTicket_OnTicketStatusUpdate");
static_assert(sizeof(GzUnityMatchmakingServiceStatePollingTicket_OnTicketStatusUpdate) == 0x000040, "Wrong size on GzUnityMatchmakingServiceStatePollingTicket_OnTicketStatusUpdate");
static_assert(offsetof(GzUnityMatchmakingServiceStatePollingTicket_OnTicketStatusUpdate, Result) == 0x000000, "Member 'GzUnityMatchmakingServiceStatePollingTicket_OnTicketStatusUpdate::Result' has a wrong offset!");

// Function G01.GzVehicle.AssignSeat
// 0x0010 (0x0010 - 0x0000)
struct GzVehicle_AssignSeat final
{
public:
	class AGzCharacter*                           Character;                                         // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EGzVehicleSeatType                            Seat;                                              // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0009(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3555[0x6];                                     // 0x000A(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GzVehicle_AssignSeat) == 0x000008, "Wrong alignment on GzVehicle_AssignSeat");
static_assert(sizeof(GzVehicle_AssignSeat) == 0x000010, "Wrong size on GzVehicle_AssignSeat");
static_assert(offsetof(GzVehicle_AssignSeat, Character) == 0x000000, "Member 'GzVehicle_AssignSeat::Character' has a wrong offset!");
static_assert(offsetof(GzVehicle_AssignSeat, Seat) == 0x000008, "Member 'GzVehicle_AssignSeat::Seat' has a wrong offset!");
static_assert(offsetof(GzVehicle_AssignSeat, ReturnValue) == 0x000009, "Member 'GzVehicle_AssignSeat::ReturnValue' has a wrong offset!");

// Function G01.GzVehicle.BP_ClientOnVehicleHitEvent
// 0x0130 (0x0130 - 0x0000)
struct GzVehicle_BP_ClientOnVehicleHitEvent final
{
public:
	class UPrimitiveComponent*                    HitComponent;                                      // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 OtherActor;                                        // 0x0008(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UPrimitiveComponent*                    OtherComp;                                         // 0x0010(0x0008)(Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                NormalImpulse;                                     // 0x0018(0x0018)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FHitResult                             Hit;                                               // 0x0030(0x00F8)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	float                                         CurrentVehicleSpeed;                               // 0x0128(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3556[0x4];                                     // 0x012C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GzVehicle_BP_ClientOnVehicleHitEvent) == 0x000008, "Wrong alignment on GzVehicle_BP_ClientOnVehicleHitEvent");
static_assert(sizeof(GzVehicle_BP_ClientOnVehicleHitEvent) == 0x000130, "Wrong size on GzVehicle_BP_ClientOnVehicleHitEvent");
static_assert(offsetof(GzVehicle_BP_ClientOnVehicleHitEvent, HitComponent) == 0x000000, "Member 'GzVehicle_BP_ClientOnVehicleHitEvent::HitComponent' has a wrong offset!");
static_assert(offsetof(GzVehicle_BP_ClientOnVehicleHitEvent, OtherActor) == 0x000008, "Member 'GzVehicle_BP_ClientOnVehicleHitEvent::OtherActor' has a wrong offset!");
static_assert(offsetof(GzVehicle_BP_ClientOnVehicleHitEvent, OtherComp) == 0x000010, "Member 'GzVehicle_BP_ClientOnVehicleHitEvent::OtherComp' has a wrong offset!");
static_assert(offsetof(GzVehicle_BP_ClientOnVehicleHitEvent, NormalImpulse) == 0x000018, "Member 'GzVehicle_BP_ClientOnVehicleHitEvent::NormalImpulse' has a wrong offset!");
static_assert(offsetof(GzVehicle_BP_ClientOnVehicleHitEvent, Hit) == 0x000030, "Member 'GzVehicle_BP_ClientOnVehicleHitEvent::Hit' has a wrong offset!");
static_assert(offsetof(GzVehicle_BP_ClientOnVehicleHitEvent, CurrentVehicleSpeed) == 0x000128, "Member 'GzVehicle_BP_ClientOnVehicleHitEvent::CurrentVehicleSpeed' has a wrong offset!");

// Function G01.GzVehicle.EjectCharacter
// 0x0008 (0x0008 - 0x0000)
struct GzVehicle_EjectCharacter final
{
public:
	class AGzCharacter*                           Character;                                         // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzVehicle_EjectCharacter) == 0x000008, "Wrong alignment on GzVehicle_EjectCharacter");
static_assert(sizeof(GzVehicle_EjectCharacter) == 0x000008, "Wrong size on GzVehicle_EjectCharacter");
static_assert(offsetof(GzVehicle_EjectCharacter, Character) == 0x000000, "Member 'GzVehicle_EjectCharacter::Character' has a wrong offset!");

// Function G01.GzVehicle.EjectSeat
// 0x0001 (0x0001 - 0x0000)
struct GzVehicle_EjectSeat final
{
public:
	EGzVehicleSeatType                            Seat;                                              // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzVehicle_EjectSeat) == 0x000001, "Wrong alignment on GzVehicle_EjectSeat");
static_assert(sizeof(GzVehicle_EjectSeat) == 0x000001, "Wrong size on GzVehicle_EjectSeat");
static_assert(offsetof(GzVehicle_EjectSeat, Seat) == 0x000000, "Member 'GzVehicle_EjectSeat::Seat' has a wrong offset!");

// Function G01.GzVehicle.EnterClosestFreeSeat
// 0x0008 (0x0008 - 0x0000)
struct GzVehicle_EnterClosestFreeSeat final
{
public:
	class AGzCharacter*                           Character;                                         // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzVehicle_EnterClosestFreeSeat) == 0x000008, "Wrong alignment on GzVehicle_EnterClosestFreeSeat");
static_assert(sizeof(GzVehicle_EnterClosestFreeSeat) == 0x000008, "Wrong size on GzVehicle_EnterClosestFreeSeat");
static_assert(offsetof(GzVehicle_EnterClosestFreeSeat, Character) == 0x000000, "Member 'GzVehicle_EnterClosestFreeSeat::Character' has a wrong offset!");

// Function G01.GzVehicle.EnterNextFreeSeat
// 0x0008 (0x0008 - 0x0000)
struct GzVehicle_EnterNextFreeSeat final
{
public:
	class AGzCharacter*                           Character;                                         // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzVehicle_EnterNextFreeSeat) == 0x000008, "Wrong alignment on GzVehicle_EnterNextFreeSeat");
static_assert(sizeof(GzVehicle_EnterNextFreeSeat) == 0x000008, "Wrong size on GzVehicle_EnterNextFreeSeat");
static_assert(offsetof(GzVehicle_EnterNextFreeSeat, Character) == 0x000000, "Member 'GzVehicle_EnterNextFreeSeat::Character' has a wrong offset!");

// Function G01.GzVehicle.OnCharacterBeginCollision
// 0x0008 (0x0008 - 0x0000)
struct GzVehicle_OnCharacterBeginCollision final
{
public:
	class AGzCharacter*                           Character;                                         // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzVehicle_OnCharacterBeginCollision) == 0x000008, "Wrong alignment on GzVehicle_OnCharacterBeginCollision");
static_assert(sizeof(GzVehicle_OnCharacterBeginCollision) == 0x000008, "Wrong size on GzVehicle_OnCharacterBeginCollision");
static_assert(offsetof(GzVehicle_OnCharacterBeginCollision, Character) == 0x000000, "Member 'GzVehicle_OnCharacterBeginCollision::Character' has a wrong offset!");

// Function G01.GzVehicle.OnCharacterCollisionBeginOverlap
// 0x0118 (0x0118 - 0x0000)
struct GzVehicle_OnCharacterCollisionBeginOverlap final
{
public:
	class UPrimitiveComponent*                    OverlappedComponent;                               // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 OtherActor;                                        // 0x0008(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UPrimitiveComponent*                    OtherComp;                                         // 0x0010(0x0008)(Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         OtherBodyIndex;                                    // 0x0018(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bFromSweep;                                        // 0x001C(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3557[0x3];                                     // 0x001D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FHitResult                             SweepResult;                                       // 0x0020(0x00F8)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzVehicle_OnCharacterCollisionBeginOverlap) == 0x000008, "Wrong alignment on GzVehicle_OnCharacterCollisionBeginOverlap");
static_assert(sizeof(GzVehicle_OnCharacterCollisionBeginOverlap) == 0x000118, "Wrong size on GzVehicle_OnCharacterCollisionBeginOverlap");
static_assert(offsetof(GzVehicle_OnCharacterCollisionBeginOverlap, OverlappedComponent) == 0x000000, "Member 'GzVehicle_OnCharacterCollisionBeginOverlap::OverlappedComponent' has a wrong offset!");
static_assert(offsetof(GzVehicle_OnCharacterCollisionBeginOverlap, OtherActor) == 0x000008, "Member 'GzVehicle_OnCharacterCollisionBeginOverlap::OtherActor' has a wrong offset!");
static_assert(offsetof(GzVehicle_OnCharacterCollisionBeginOverlap, OtherComp) == 0x000010, "Member 'GzVehicle_OnCharacterCollisionBeginOverlap::OtherComp' has a wrong offset!");
static_assert(offsetof(GzVehicle_OnCharacterCollisionBeginOverlap, OtherBodyIndex) == 0x000018, "Member 'GzVehicle_OnCharacterCollisionBeginOverlap::OtherBodyIndex' has a wrong offset!");
static_assert(offsetof(GzVehicle_OnCharacterCollisionBeginOverlap, bFromSweep) == 0x00001C, "Member 'GzVehicle_OnCharacterCollisionBeginOverlap::bFromSweep' has a wrong offset!");
static_assert(offsetof(GzVehicle_OnCharacterCollisionBeginOverlap, SweepResult) == 0x000020, "Member 'GzVehicle_OnCharacterCollisionBeginOverlap::SweepResult' has a wrong offset!");

// Function G01.GzVehicle.OnCharacterConnectionStateChanged
// 0x0008 (0x0008 - 0x0000)
struct GzVehicle_OnCharacterConnectionStateChanged final
{
public:
	class AGzPlayerState*                         CharacterPlayerState;                              // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzVehicle_OnCharacterConnectionStateChanged) == 0x000008, "Wrong alignment on GzVehicle_OnCharacterConnectionStateChanged");
static_assert(sizeof(GzVehicle_OnCharacterConnectionStateChanged) == 0x000008, "Wrong size on GzVehicle_OnCharacterConnectionStateChanged");
static_assert(offsetof(GzVehicle_OnCharacterConnectionStateChanged, CharacterPlayerState) == 0x000000, "Member 'GzVehicle_OnCharacterConnectionStateChanged::CharacterPlayerState' has a wrong offset!");

// Function G01.GzVehicle.OnCharacterEndCollision
// 0x0008 (0x0008 - 0x0000)
struct GzVehicle_OnCharacterEndCollision final
{
public:
	class AGzCharacter*                           Character;                                         // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzVehicle_OnCharacterEndCollision) == 0x000008, "Wrong alignment on GzVehicle_OnCharacterEndCollision");
static_assert(sizeof(GzVehicle_OnCharacterEndCollision) == 0x000008, "Wrong size on GzVehicle_OnCharacterEndCollision");
static_assert(offsetof(GzVehicle_OnCharacterEndCollision, Character) == 0x000000, "Member 'GzVehicle_OnCharacterEndCollision::Character' has a wrong offset!");

// Function G01.GzVehicle.OnCharacterSeatChange
// 0x0010 (0x0010 - 0x0000)
struct GzVehicle_OnCharacterSeatChange final
{
public:
	class AGzCharacter*                           Character;                                         // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EGzVehicleSeatType                            NewSeat;                                           // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EGzVehicleSeatType                            OldSeat;                                           // 0x0009(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3558[0x6];                                     // 0x000A(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GzVehicle_OnCharacterSeatChange) == 0x000008, "Wrong alignment on GzVehicle_OnCharacterSeatChange");
static_assert(sizeof(GzVehicle_OnCharacterSeatChange) == 0x000010, "Wrong size on GzVehicle_OnCharacterSeatChange");
static_assert(offsetof(GzVehicle_OnCharacterSeatChange, Character) == 0x000000, "Member 'GzVehicle_OnCharacterSeatChange::Character' has a wrong offset!");
static_assert(offsetof(GzVehicle_OnCharacterSeatChange, NewSeat) == 0x000008, "Member 'GzVehicle_OnCharacterSeatChange::NewSeat' has a wrong offset!");
static_assert(offsetof(GzVehicle_OnCharacterSeatChange, OldSeat) == 0x000009, "Member 'GzVehicle_OnCharacterSeatChange::OldSeat' has a wrong offset!");

// Function G01.GzVehicle.OnInteractedBy
// 0x0010 (0x0010 - 0x0000)
struct GzVehicle_OnInteractedBy final
{
public:
	class AActor*                                 InteractedBy;                                      // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	const class UGzInteractableComponent*         Interactable;                                      // 0x0008(0x0008)(ConstParm, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzVehicle_OnInteractedBy) == 0x000008, "Wrong alignment on GzVehicle_OnInteractedBy");
static_assert(sizeof(GzVehicle_OnInteractedBy) == 0x000010, "Wrong size on GzVehicle_OnInteractedBy");
static_assert(offsetof(GzVehicle_OnInteractedBy, InteractedBy) == 0x000000, "Member 'GzVehicle_OnInteractedBy::InteractedBy' has a wrong offset!");
static_assert(offsetof(GzVehicle_OnInteractedBy, Interactable) == 0x000008, "Member 'GzVehicle_OnInteractedBy::Interactable' has a wrong offset!");

// Function G01.GzVehicle.OnPassengerRestarted
// 0x0008 (0x0008 - 0x0000)
struct GzVehicle_OnPassengerRestarted final
{
public:
	class APawn*                                  PassengerPawn;                                     // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzVehicle_OnPassengerRestarted) == 0x000008, "Wrong alignment on GzVehicle_OnPassengerRestarted");
static_assert(sizeof(GzVehicle_OnPassengerRestarted) == 0x000008, "Wrong size on GzVehicle_OnPassengerRestarted");
static_assert(offsetof(GzVehicle_OnPassengerRestarted, PassengerPawn) == 0x000000, "Member 'GzVehicle_OnPassengerRestarted::PassengerPawn' has a wrong offset!");

// Function G01.GzVehicle.OnRep_AttachedCharacters
// 0x0010 (0x0010 - 0x0000)
struct GzVehicle_OnRep_AttachedCharacters final
{
public:
	TArray<class AGzCharacter*>                   PreviousAttachedCharacters;                        // 0x0000(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzVehicle_OnRep_AttachedCharacters) == 0x000008, "Wrong alignment on GzVehicle_OnRep_AttachedCharacters");
static_assert(sizeof(GzVehicle_OnRep_AttachedCharacters) == 0x000010, "Wrong size on GzVehicle_OnRep_AttachedCharacters");
static_assert(offsetof(GzVehicle_OnRep_AttachedCharacters, PreviousAttachedCharacters) == 0x000000, "Member 'GzVehicle_OnRep_AttachedCharacters::PreviousAttachedCharacters' has a wrong offset!");

// Function G01.GzVehicle.OnRep_CharactersInVehicle
// 0x0010 (0x0010 - 0x0000)
struct GzVehicle_OnRep_CharactersInVehicle final
{
public:
	TArray<class AGzCharacter*>                   PreviousCharactersInVehicle;                       // 0x0000(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzVehicle_OnRep_CharactersInVehicle) == 0x000008, "Wrong alignment on GzVehicle_OnRep_CharactersInVehicle");
static_assert(sizeof(GzVehicle_OnRep_CharactersInVehicle) == 0x000010, "Wrong size on GzVehicle_OnRep_CharactersInVehicle");
static_assert(offsetof(GzVehicle_OnRep_CharactersInVehicle, PreviousCharactersInVehicle) == 0x000000, "Member 'GzVehicle_OnRep_CharactersInVehicle::PreviousCharactersInVehicle' has a wrong offset!");

// Function G01.GzVehicle.OnRep_HornPressed
// 0x0001 (0x0001 - 0x0000)
struct GzVehicle_OnRep_HornPressed final
{
public:
	bool                                          bOldHornPressedValue;                              // 0x0000(0x0001)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzVehicle_OnRep_HornPressed) == 0x000001, "Wrong alignment on GzVehicle_OnRep_HornPressed");
static_assert(sizeof(GzVehicle_OnRep_HornPressed) == 0x000001, "Wrong size on GzVehicle_OnRep_HornPressed");
static_assert(offsetof(GzVehicle_OnRep_HornPressed, bOldHornPressedValue) == 0x000000, "Member 'GzVehicle_OnRep_HornPressed::bOldHornPressedValue' has a wrong offset!");

// Function G01.GzVehicle.OnVehicleHitEvent
// 0x0128 (0x0128 - 0x0000)
struct GzVehicle_OnVehicleHitEvent final
{
public:
	class UPrimitiveComponent*                    HitComponent;                                      // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 OtherActor;                                        // 0x0008(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UPrimitiveComponent*                    OtherComp;                                         // 0x0010(0x0008)(Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                NormalImpulse;                                     // 0x0018(0x0018)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FHitResult                             Hit;                                               // 0x0030(0x00F8)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzVehicle_OnVehicleHitEvent) == 0x000008, "Wrong alignment on GzVehicle_OnVehicleHitEvent");
static_assert(sizeof(GzVehicle_OnVehicleHitEvent) == 0x000128, "Wrong size on GzVehicle_OnVehicleHitEvent");
static_assert(offsetof(GzVehicle_OnVehicleHitEvent, HitComponent) == 0x000000, "Member 'GzVehicle_OnVehicleHitEvent::HitComponent' has a wrong offset!");
static_assert(offsetof(GzVehicle_OnVehicleHitEvent, OtherActor) == 0x000008, "Member 'GzVehicle_OnVehicleHitEvent::OtherActor' has a wrong offset!");
static_assert(offsetof(GzVehicle_OnVehicleHitEvent, OtherComp) == 0x000010, "Member 'GzVehicle_OnVehicleHitEvent::OtherComp' has a wrong offset!");
static_assert(offsetof(GzVehicle_OnVehicleHitEvent, NormalImpulse) == 0x000018, "Member 'GzVehicle_OnVehicleHitEvent::NormalImpulse' has a wrong offset!");
static_assert(offsetof(GzVehicle_OnVehicleHitEvent, Hit) == 0x000030, "Member 'GzVehicle_OnVehicleHitEvent::Hit' has a wrong offset!");

// Function G01.GzVehicle.SetHornState
// 0x0001 (0x0001 - 0x0000)
struct GzVehicle_SetHornState final
{
public:
	bool                                          bIsHornpressed;                                    // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzVehicle_SetHornState) == 0x000001, "Wrong alignment on GzVehicle_SetHornState");
static_assert(sizeof(GzVehicle_SetHornState) == 0x000001, "Wrong size on GzVehicle_SetHornState");
static_assert(offsetof(GzVehicle_SetHornState, bIsHornpressed) == 0x000000, "Member 'GzVehicle_SetHornState::bIsHornpressed' has a wrong offset!");

// Function G01.GzVehicle.SwitchSeat
// 0x0010 (0x0010 - 0x0000)
struct GzVehicle_SwitchSeat final
{
public:
	class AGzCharacter*                           Character;                                         // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3559[0x7];                                     // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GzVehicle_SwitchSeat) == 0x000008, "Wrong alignment on GzVehicle_SwitchSeat");
static_assert(sizeof(GzVehicle_SwitchSeat) == 0x000010, "Wrong size on GzVehicle_SwitchSeat");
static_assert(offsetof(GzVehicle_SwitchSeat, Character) == 0x000000, "Member 'GzVehicle_SwitchSeat::Character' has a wrong offset!");
static_assert(offsetof(GzVehicle_SwitchSeat, ReturnValue) == 0x000008, "Member 'GzVehicle_SwitchSeat::ReturnValue' has a wrong offset!");

// Function G01.GzVehicle.GetCharacterInSeat
// 0x0010 (0x0010 - 0x0000)
struct GzVehicle_GetCharacterInSeat final
{
public:
	EGzVehicleSeatType                            Seat;                                              // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_355A[0x7];                                     // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class AGzCharacter*                           ReturnValue;                                       // 0x0008(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzVehicle_GetCharacterInSeat) == 0x000008, "Wrong alignment on GzVehicle_GetCharacterInSeat");
static_assert(sizeof(GzVehicle_GetCharacterInSeat) == 0x000010, "Wrong size on GzVehicle_GetCharacterInSeat");
static_assert(offsetof(GzVehicle_GetCharacterInSeat, Seat) == 0x000000, "Member 'GzVehicle_GetCharacterInSeat::Seat' has a wrong offset!");
static_assert(offsetof(GzVehicle_GetCharacterInSeat, ReturnValue) == 0x000008, "Member 'GzVehicle_GetCharacterInSeat::ReturnValue' has a wrong offset!");

// Function G01.GzVehicle.GetDriver
// 0x0008 (0x0008 - 0x0000)
struct GzVehicle_GetDriver final
{
public:
	class AGzCharacter*                           ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzVehicle_GetDriver) == 0x000008, "Wrong alignment on GzVehicle_GetDriver");
static_assert(sizeof(GzVehicle_GetDriver) == 0x000008, "Wrong size on GzVehicle_GetDriver");
static_assert(offsetof(GzVehicle_GetDriver, ReturnValue) == 0x000000, "Member 'GzVehicle_GetDriver::ReturnValue' has a wrong offset!");

// Function G01.GzVehicle.GetGzVehicleMovementComponent
// 0x0008 (0x0008 - 0x0000)
struct GzVehicle_GetGzVehicleMovementComponent final
{
public:
	class UGzChaosWheeledVehicleMovementComponent* ReturnValue;                                       // 0x0000(0x0008)(ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzVehicle_GetGzVehicleMovementComponent) == 0x000008, "Wrong alignment on GzVehicle_GetGzVehicleMovementComponent");
static_assert(sizeof(GzVehicle_GetGzVehicleMovementComponent) == 0x000008, "Wrong size on GzVehicle_GetGzVehicleMovementComponent");
static_assert(offsetof(GzVehicle_GetGzVehicleMovementComponent, ReturnValue) == 0x000000, "Member 'GzVehicle_GetGzVehicleMovementComponent::ReturnValue' has a wrong offset!");

// Function G01.GzVehicle.GetSeatOfCharacter
// 0x0010 (0x0010 - 0x0000)
struct GzVehicle_GetSeatOfCharacter final
{
public:
	const class AGzCharacter*                     Character;                                         // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EGzVehicleSeatType                            ReturnValue;                                       // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_355B[0x7];                                     // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GzVehicle_GetSeatOfCharacter) == 0x000008, "Wrong alignment on GzVehicle_GetSeatOfCharacter");
static_assert(sizeof(GzVehicle_GetSeatOfCharacter) == 0x000010, "Wrong size on GzVehicle_GetSeatOfCharacter");
static_assert(offsetof(GzVehicle_GetSeatOfCharacter, Character) == 0x000000, "Member 'GzVehicle_GetSeatOfCharacter::Character' has a wrong offset!");
static_assert(offsetof(GzVehicle_GetSeatOfCharacter, ReturnValue) == 0x000008, "Member 'GzVehicle_GetSeatOfCharacter::ReturnValue' has a wrong offset!");

// Function G01.GzVehicle.GetTurretComponent
// 0x0008 (0x0008 - 0x0000)
struct GzVehicle_GetTurretComponent final
{
public:
	class UGzTurretComponent*                     ReturnValue;                                       // 0x0000(0x0008)(ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzVehicle_GetTurretComponent) == 0x000008, "Wrong alignment on GzVehicle_GetTurretComponent");
static_assert(sizeof(GzVehicle_GetTurretComponent) == 0x000008, "Wrong size on GzVehicle_GetTurretComponent");
static_assert(offsetof(GzVehicle_GetTurretComponent, ReturnValue) == 0x000000, "Member 'GzVehicle_GetTurretComponent::ReturnValue' has a wrong offset!");

// Function G01.GzVehicle.GetVehicleConfig
// 0x0008 (0x0008 - 0x0000)
struct GzVehicle_GetVehicleConfig final
{
public:
	const class UGzVehicleConfig*                 ReturnValue;                                       // 0x0000(0x0008)(ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzVehicle_GetVehicleConfig) == 0x000008, "Wrong alignment on GzVehicle_GetVehicleConfig");
static_assert(sizeof(GzVehicle_GetVehicleConfig) == 0x000008, "Wrong size on GzVehicle_GetVehicleConfig");
static_assert(offsetof(GzVehicle_GetVehicleConfig, ReturnValue) == 0x000000, "Member 'GzVehicle_GetVehicleConfig::ReturnValue' has a wrong offset!");

// Function G01.GzVehicle.GetVehicleState
// 0x0014 (0x0014 - 0x0000)
struct GzVehicle_GetVehicleState final
{
public:
	struct FGzVehicleState                        ReturnValue;                                       // 0x0000(0x0014)(ConstParm, Parm, OutParm, ReturnParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzVehicle_GetVehicleState) == 0x000004, "Wrong alignment on GzVehicle_GetVehicleState");
static_assert(sizeof(GzVehicle_GetVehicleState) == 0x000014, "Wrong size on GzVehicle_GetVehicleState");
static_assert(offsetof(GzVehicle_GetVehicleState, ReturnValue) == 0x000000, "Member 'GzVehicle_GetVehicleState::ReturnValue' has a wrong offset!");

// Function G01.GzVehicle.HasEmptySeats
// 0x0001 (0x0001 - 0x0000)
struct GzVehicle_HasEmptySeats final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzVehicle_HasEmptySeats) == 0x000001, "Wrong alignment on GzVehicle_HasEmptySeats");
static_assert(sizeof(GzVehicle_HasEmptySeats) == 0x000001, "Wrong size on GzVehicle_HasEmptySeats");
static_assert(offsetof(GzVehicle_HasEmptySeats, ReturnValue) == 0x000000, "Member 'GzVehicle_HasEmptySeats::ReturnValue' has a wrong offset!");

// Function G01.GzVehicleEffectSettings.GetSurfaceEffectsForType
// 0x0038 (0x0038 - 0x0000)
struct GzVehicleEffectSettings_GetSurfaceEffectsForType final
{
public:
	EPhysicalSurface                              Surface;                                           // 0x0000(0x0001)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_355C[0x7];                                     // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGzVehicleSurfaceEffects               ReturnValue;                                       // 0x0008(0x0030)(ConstParm, Parm, OutParm, ReturnParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzVehicleEffectSettings_GetSurfaceEffectsForType) == 0x000008, "Wrong alignment on GzVehicleEffectSettings_GetSurfaceEffectsForType");
static_assert(sizeof(GzVehicleEffectSettings_GetSurfaceEffectsForType) == 0x000038, "Wrong size on GzVehicleEffectSettings_GetSurfaceEffectsForType");
static_assert(offsetof(GzVehicleEffectSettings_GetSurfaceEffectsForType, Surface) == 0x000000, "Member 'GzVehicleEffectSettings_GetSurfaceEffectsForType::Surface' has a wrong offset!");
static_assert(offsetof(GzVehicleEffectSettings_GetSurfaceEffectsForType, ReturnValue) == 0x000008, "Member 'GzVehicleEffectSettings_GetSurfaceEffectsForType::ReturnValue' has a wrong offset!");

// Function G01.GzVehicleControlsComponent.HandleAccelerateBrake
// 0x0020 (0x0020 - 0x0000)
struct GzVehicleControlsComponent_HandleAccelerateBrake final
{
public:
	struct FInputActionValue                      InputValue;                                        // 0x0000(0x0020)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzVehicleControlsComponent_HandleAccelerateBrake) == 0x000008, "Wrong alignment on GzVehicleControlsComponent_HandleAccelerateBrake");
static_assert(sizeof(GzVehicleControlsComponent_HandleAccelerateBrake) == 0x000020, "Wrong size on GzVehicleControlsComponent_HandleAccelerateBrake");
static_assert(offsetof(GzVehicleControlsComponent_HandleAccelerateBrake, InputValue) == 0x000000, "Member 'GzVehicleControlsComponent_HandleAccelerateBrake::InputValue' has a wrong offset!");

// Function G01.GzVehicleControlsComponent.HandleGetOut
// 0x0020 (0x0020 - 0x0000)
struct GzVehicleControlsComponent_HandleGetOut final
{
public:
	struct FInputActionValue                      InputValue;                                        // 0x0000(0x0020)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzVehicleControlsComponent_HandleGetOut) == 0x000008, "Wrong alignment on GzVehicleControlsComponent_HandleGetOut");
static_assert(sizeof(GzVehicleControlsComponent_HandleGetOut) == 0x000020, "Wrong size on GzVehicleControlsComponent_HandleGetOut");
static_assert(offsetof(GzVehicleControlsComponent_HandleGetOut, InputValue) == 0x000000, "Member 'GzVehicleControlsComponent_HandleGetOut::InputValue' has a wrong offset!");

// Function G01.GzVehicleControlsComponent.HandleHandBrake
// 0x0020 (0x0020 - 0x0000)
struct GzVehicleControlsComponent_HandleHandBrake final
{
public:
	struct FInputActionValue                      InputValue;                                        // 0x0000(0x0020)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzVehicleControlsComponent_HandleHandBrake) == 0x000008, "Wrong alignment on GzVehicleControlsComponent_HandleHandBrake");
static_assert(sizeof(GzVehicleControlsComponent_HandleHandBrake) == 0x000020, "Wrong size on GzVehicleControlsComponent_HandleHandBrake");
static_assert(offsetof(GzVehicleControlsComponent_HandleHandBrake, InputValue) == 0x000000, "Member 'GzVehicleControlsComponent_HandleHandBrake::InputValue' has a wrong offset!");

// Function G01.GzVehicleControlsComponent.HandleHorn
// 0x0020 (0x0020 - 0x0000)
struct GzVehicleControlsComponent_HandleHorn final
{
public:
	struct FInputActionValue                      InputValue;                                        // 0x0000(0x0020)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzVehicleControlsComponent_HandleHorn) == 0x000008, "Wrong alignment on GzVehicleControlsComponent_HandleHorn");
static_assert(sizeof(GzVehicleControlsComponent_HandleHorn) == 0x000020, "Wrong size on GzVehicleControlsComponent_HandleHorn");
static_assert(offsetof(GzVehicleControlsComponent_HandleHorn, InputValue) == 0x000000, "Member 'GzVehicleControlsComponent_HandleHorn::InputValue' has a wrong offset!");

// Function G01.GzVehicleControlsComponent.HandleLookPitch
// 0x0020 (0x0020 - 0x0000)
struct GzVehicleControlsComponent_HandleLookPitch final
{
public:
	struct FInputActionValue                      InputValue;                                        // 0x0000(0x0020)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzVehicleControlsComponent_HandleLookPitch) == 0x000008, "Wrong alignment on GzVehicleControlsComponent_HandleLookPitch");
static_assert(sizeof(GzVehicleControlsComponent_HandleLookPitch) == 0x000020, "Wrong size on GzVehicleControlsComponent_HandleLookPitch");
static_assert(offsetof(GzVehicleControlsComponent_HandleLookPitch, InputValue) == 0x000000, "Member 'GzVehicleControlsComponent_HandleLookPitch::InputValue' has a wrong offset!");

// Function G01.GzVehicleControlsComponent.HandleLookYaw
// 0x0020 (0x0020 - 0x0000)
struct GzVehicleControlsComponent_HandleLookYaw final
{
public:
	struct FInputActionValue                      InputValue;                                        // 0x0000(0x0020)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzVehicleControlsComponent_HandleLookYaw) == 0x000008, "Wrong alignment on GzVehicleControlsComponent_HandleLookYaw");
static_assert(sizeof(GzVehicleControlsComponent_HandleLookYaw) == 0x000020, "Wrong size on GzVehicleControlsComponent_HandleLookYaw");
static_assert(offsetof(GzVehicleControlsComponent_HandleLookYaw, InputValue) == 0x000000, "Member 'GzVehicleControlsComponent_HandleLookYaw::InputValue' has a wrong offset!");

// Function G01.GzVehicleControlsComponent.HandleSeatSwitch
// 0x0020 (0x0020 - 0x0000)
struct GzVehicleControlsComponent_HandleSeatSwitch final
{
public:
	struct FInputActionValue                      InputValue;                                        // 0x0000(0x0020)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzVehicleControlsComponent_HandleSeatSwitch) == 0x000008, "Wrong alignment on GzVehicleControlsComponent_HandleSeatSwitch");
static_assert(sizeof(GzVehicleControlsComponent_HandleSeatSwitch) == 0x000020, "Wrong size on GzVehicleControlsComponent_HandleSeatSwitch");
static_assert(offsetof(GzVehicleControlsComponent_HandleSeatSwitch, InputValue) == 0x000000, "Member 'GzVehicleControlsComponent_HandleSeatSwitch::InputValue' has a wrong offset!");

// Function G01.GzVehicleControlsComponent.HandleSteering
// 0x0020 (0x0020 - 0x0000)
struct GzVehicleControlsComponent_HandleSteering final
{
public:
	struct FInputActionValue                      InputValue;                                        // 0x0000(0x0020)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzVehicleControlsComponent_HandleSteering) == 0x000008, "Wrong alignment on GzVehicleControlsComponent_HandleSteering");
static_assert(sizeof(GzVehicleControlsComponent_HandleSteering) == 0x000020, "Wrong size on GzVehicleControlsComponent_HandleSteering");
static_assert(offsetof(GzVehicleControlsComponent_HandleSteering, InputValue) == 0x000000, "Member 'GzVehicleControlsComponent_HandleSteering::InputValue' has a wrong offset!");

// DelegateFunction G01.GzVehicleControlsComponent.OnInputAxisChanged__DelegateSignature
// 0x0004 (0x0004 - 0x0000)
struct GzVehicleControlsComponent_OnInputAxisChanged__DelegateSignature final
{
public:
	float                                         Value;                                             // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzVehicleControlsComponent_OnInputAxisChanged__DelegateSignature) == 0x000004, "Wrong alignment on GzVehicleControlsComponent_OnInputAxisChanged__DelegateSignature");
static_assert(sizeof(GzVehicleControlsComponent_OnInputAxisChanged__DelegateSignature) == 0x000004, "Wrong size on GzVehicleControlsComponent_OnInputAxisChanged__DelegateSignature");
static_assert(offsetof(GzVehicleControlsComponent_OnInputAxisChanged__DelegateSignature, Value) == 0x000000, "Member 'GzVehicleControlsComponent_OnInputAxisChanged__DelegateSignature::Value' has a wrong offset!");

// DelegateFunction G01.GzVehicleControlsComponent.OnInputButtonChanged__DelegateSignature
// 0x0001 (0x0001 - 0x0000)
struct GzVehicleControlsComponent_OnInputButtonChanged__DelegateSignature final
{
public:
	bool                                          Value;                                             // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzVehicleControlsComponent_OnInputButtonChanged__DelegateSignature) == 0x000001, "Wrong alignment on GzVehicleControlsComponent_OnInputButtonChanged__DelegateSignature");
static_assert(sizeof(GzVehicleControlsComponent_OnInputButtonChanged__DelegateSignature) == 0x000001, "Wrong size on GzVehicleControlsComponent_OnInputButtonChanged__DelegateSignature");
static_assert(offsetof(GzVehicleControlsComponent_OnInputButtonChanged__DelegateSignature, Value) == 0x000000, "Member 'GzVehicleControlsComponent_OnInputButtonChanged__DelegateSignature::Value' has a wrong offset!");

// Function G01.GzVehicleControlsComponent.ServerSetHornState
// 0x0001 (0x0001 - 0x0000)
struct GzVehicleControlsComponent_ServerSetHornState final
{
public:
	bool                                          bIsHornpressed;                                    // 0x0000(0x0001)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzVehicleControlsComponent_ServerSetHornState) == 0x000001, "Wrong alignment on GzVehicleControlsComponent_ServerSetHornState");
static_assert(sizeof(GzVehicleControlsComponent_ServerSetHornState) == 0x000001, "Wrong size on GzVehicleControlsComponent_ServerSetHornState");
static_assert(offsetof(GzVehicleControlsComponent_ServerSetHornState, bIsHornpressed) == 0x000000, "Member 'GzVehicleControlsComponent_ServerSetHornState::bIsHornpressed' has a wrong offset!");

// Function G01.GzVehicleControlsComponent.GetDriverCharacter
// 0x0008 (0x0008 - 0x0000)
struct GzVehicleControlsComponent_GetDriverCharacter final
{
public:
	class AGzMultiPartCharacter*                  ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzVehicleControlsComponent_GetDriverCharacter) == 0x000008, "Wrong alignment on GzVehicleControlsComponent_GetDriverCharacter");
static_assert(sizeof(GzVehicleControlsComponent_GetDriverCharacter) == 0x000008, "Wrong size on GzVehicleControlsComponent_GetDriverCharacter");
static_assert(offsetof(GzVehicleControlsComponent_GetDriverCharacter, ReturnValue) == 0x000000, "Member 'GzVehicleControlsComponent_GetDriverCharacter::ReturnValue' has a wrong offset!");

// DelegateFunction G01.GzVehicleEffectsComponent.ActiveBrakeStateChangedDelegate__DelegateSignature
// 0x0002 (0x0002 - 0x0000)
struct GzVehicleEffectsComponent_ActiveBrakeStateChangedDelegate__DelegateSignature final
{
public:
	bool                                          bIsBraking;                                        // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsAnyWheelInContact;                              // 0x0001(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzVehicleEffectsComponent_ActiveBrakeStateChangedDelegate__DelegateSignature) == 0x000001, "Wrong alignment on GzVehicleEffectsComponent_ActiveBrakeStateChangedDelegate__DelegateSignature");
static_assert(sizeof(GzVehicleEffectsComponent_ActiveBrakeStateChangedDelegate__DelegateSignature) == 0x000002, "Wrong size on GzVehicleEffectsComponent_ActiveBrakeStateChangedDelegate__DelegateSignature");
static_assert(offsetof(GzVehicleEffectsComponent_ActiveBrakeStateChangedDelegate__DelegateSignature, bIsBraking) == 0x000000, "Member 'GzVehicleEffectsComponent_ActiveBrakeStateChangedDelegate__DelegateSignature::bIsBraking' has a wrong offset!");
static_assert(offsetof(GzVehicleEffectsComponent_ActiveBrakeStateChangedDelegate__DelegateSignature, bIsAnyWheelInContact) == 0x000001, "Member 'GzVehicleEffectsComponent_ActiveBrakeStateChangedDelegate__DelegateSignature::bIsAnyWheelInContact' has a wrong offset!");

// DelegateFunction G01.GzVehicleEffectsComponent.AxleGroundStaetChangedDelegate__DelegateSignature
// 0x0002 (0x0002 - 0x0000)
struct GzVehicleEffectsComponent_AxleGroundStaetChangedDelegate__DelegateSignature final
{
public:
	EGzVehicleAxle                                Axle;                                              // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsOnGround;                                       // 0x0001(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzVehicleEffectsComponent_AxleGroundStaetChangedDelegate__DelegateSignature) == 0x000001, "Wrong alignment on GzVehicleEffectsComponent_AxleGroundStaetChangedDelegate__DelegateSignature");
static_assert(sizeof(GzVehicleEffectsComponent_AxleGroundStaetChangedDelegate__DelegateSignature) == 0x000002, "Wrong size on GzVehicleEffectsComponent_AxleGroundStaetChangedDelegate__DelegateSignature");
static_assert(offsetof(GzVehicleEffectsComponent_AxleGroundStaetChangedDelegate__DelegateSignature, Axle) == 0x000000, "Member 'GzVehicleEffectsComponent_AxleGroundStaetChangedDelegate__DelegateSignature::Axle' has a wrong offset!");
static_assert(offsetof(GzVehicleEffectsComponent_AxleGroundStaetChangedDelegate__DelegateSignature, bIsOnGround) == 0x000001, "Member 'GzVehicleEffectsComponent_AxleGroundStaetChangedDelegate__DelegateSignature::bIsOnGround' has a wrong offset!");

// Function G01.GzVehicleEffectsComponent.CreateAudioComponent
// 0x0080 (0x0080 - 0x0000)
struct GzVehicleEffectsComponent_CreateAudioComponent final
{
public:
	struct FGzVehicleAudioEvent                   AudioEvent;                                        // 0x0000(0x0078)(Parm, OutParm, ReferenceParm, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	bool                                          bPlayEvent;                                        // 0x0078(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_355E[0x7];                                     // 0x0079(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GzVehicleEffectsComponent_CreateAudioComponent) == 0x000008, "Wrong alignment on GzVehicleEffectsComponent_CreateAudioComponent");
static_assert(sizeof(GzVehicleEffectsComponent_CreateAudioComponent) == 0x000080, "Wrong size on GzVehicleEffectsComponent_CreateAudioComponent");
static_assert(offsetof(GzVehicleEffectsComponent_CreateAudioComponent, AudioEvent) == 0x000000, "Member 'GzVehicleEffectsComponent_CreateAudioComponent::AudioEvent' has a wrong offset!");
static_assert(offsetof(GzVehicleEffectsComponent_CreateAudioComponent, bPlayEvent) == 0x000078, "Member 'GzVehicleEffectsComponent_CreateAudioComponent::bPlayEvent' has a wrong offset!");

// DelegateFunction G01.GzVehicleEffectsComponent.HandbrakeStateChangedDelegate__DelegateSignature
// 0x0001 (0x0001 - 0x0000)
struct GzVehicleEffectsComponent_HandbrakeStateChangedDelegate__DelegateSignature final
{
public:
	bool                                          bIsPullingHandbrake;                               // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzVehicleEffectsComponent_HandbrakeStateChangedDelegate__DelegateSignature) == 0x000001, "Wrong alignment on GzVehicleEffectsComponent_HandbrakeStateChangedDelegate__DelegateSignature");
static_assert(sizeof(GzVehicleEffectsComponent_HandbrakeStateChangedDelegate__DelegateSignature) == 0x000001, "Wrong size on GzVehicleEffectsComponent_HandbrakeStateChangedDelegate__DelegateSignature");
static_assert(offsetof(GzVehicleEffectsComponent_HandbrakeStateChangedDelegate__DelegateSignature, bIsPullingHandbrake) == 0x000000, "Member 'GzVehicleEffectsComponent_HandbrakeStateChangedDelegate__DelegateSignature::bIsPullingHandbrake' has a wrong offset!");

// Function G01.GzVehicleEffectsComponent.OnVehicleAxlePhysMaterialChanged
// 0x0010 (0x0010 - 0x0000)
struct GzVehicleEffectsComponent_OnVehicleAxlePhysMaterialChanged final
{
public:
	EGzVehicleAxle                                VehicleAxle;                                       // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_355F[0x7];                                     // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UPhysicalMaterial*                      PhysMaterial;                                      // 0x0008(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzVehicleEffectsComponent_OnVehicleAxlePhysMaterialChanged) == 0x000008, "Wrong alignment on GzVehicleEffectsComponent_OnVehicleAxlePhysMaterialChanged");
static_assert(sizeof(GzVehicleEffectsComponent_OnVehicleAxlePhysMaterialChanged) == 0x000010, "Wrong size on GzVehicleEffectsComponent_OnVehicleAxlePhysMaterialChanged");
static_assert(offsetof(GzVehicleEffectsComponent_OnVehicleAxlePhysMaterialChanged, VehicleAxle) == 0x000000, "Member 'GzVehicleEffectsComponent_OnVehicleAxlePhysMaterialChanged::VehicleAxle' has a wrong offset!");
static_assert(offsetof(GzVehicleEffectsComponent_OnVehicleAxlePhysMaterialChanged, PhysMaterial) == 0x000008, "Member 'GzVehicleEffectsComponent_OnVehicleAxlePhysMaterialChanged::PhysMaterial' has a wrong offset!");

// Function G01.GzVehicleEffectsComponent.PlayEvent
// 0x0078 (0x0078 - 0x0000)
struct GzVehicleEffectsComponent_PlayEvent final
{
public:
	struct FGzVehicleAudioEvent                   AudioEvent;                                        // 0x0000(0x0078)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzVehicleEffectsComponent_PlayEvent) == 0x000008, "Wrong alignment on GzVehicleEffectsComponent_PlayEvent");
static_assert(sizeof(GzVehicleEffectsComponent_PlayEvent) == 0x000078, "Wrong size on GzVehicleEffectsComponent_PlayEvent");
static_assert(offsetof(GzVehicleEffectsComponent_PlayEvent, AudioEvent) == 0x000000, "Member 'GzVehicleEffectsComponent_PlayEvent::AudioEvent' has a wrong offset!");

// Function G01.GzVehicleEffectsComponent.SetCustomRtpcValue
// 0x0088 (0x0088 - 0x0000)
struct GzVehicleEffectsComponent_SetCustomRtpcValue final
{
public:
	struct FGzVehicleAudioEvent                   AudioEvent;                                        // 0x0000(0x0078)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	class UAkRtpc*                                AkRtpc;                                            // 0x0078(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Value;                                             // 0x0080(0x0004)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3560[0x4];                                     // 0x0084(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GzVehicleEffectsComponent_SetCustomRtpcValue) == 0x000008, "Wrong alignment on GzVehicleEffectsComponent_SetCustomRtpcValue");
static_assert(sizeof(GzVehicleEffectsComponent_SetCustomRtpcValue) == 0x000088, "Wrong size on GzVehicleEffectsComponent_SetCustomRtpcValue");
static_assert(offsetof(GzVehicleEffectsComponent_SetCustomRtpcValue, AudioEvent) == 0x000000, "Member 'GzVehicleEffectsComponent_SetCustomRtpcValue::AudioEvent' has a wrong offset!");
static_assert(offsetof(GzVehicleEffectsComponent_SetCustomRtpcValue, AkRtpc) == 0x000078, "Member 'GzVehicleEffectsComponent_SetCustomRtpcValue::AkRtpc' has a wrong offset!");
static_assert(offsetof(GzVehicleEffectsComponent_SetCustomRtpcValue, Value) == 0x000080, "Member 'GzVehicleEffectsComponent_SetCustomRtpcValue::Value' has a wrong offset!");

// Function G01.GzVehicleEffectsComponent.StopEvent
// 0x0078 (0x0078 - 0x0000)
struct GzVehicleEffectsComponent_StopEvent final
{
public:
	struct FGzVehicleAudioEvent                   AudioEvent;                                        // 0x0000(0x0078)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzVehicleEffectsComponent_StopEvent) == 0x000008, "Wrong alignment on GzVehicleEffectsComponent_StopEvent");
static_assert(sizeof(GzVehicleEffectsComponent_StopEvent) == 0x000078, "Wrong size on GzVehicleEffectsComponent_StopEvent");
static_assert(offsetof(GzVehicleEffectsComponent_StopEvent, AudioEvent) == 0x000000, "Member 'GzVehicleEffectsComponent_StopEvent::AudioEvent' has a wrong offset!");

// DelegateFunction G01.GzVehicleEffectsComponent.SuspensionPercentageThresholdDelegate__DelegateSignature
// 0x0008 (0x0008 - 0x0000)
struct GzVehicleEffectsComponent_SuspensionPercentageThresholdDelegate__DelegateSignature final
{
public:
	float                                         SuspensionValue;                                   // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         WheelIndex;                                        // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzVehicleEffectsComponent_SuspensionPercentageThresholdDelegate__DelegateSignature) == 0x000004, "Wrong alignment on GzVehicleEffectsComponent_SuspensionPercentageThresholdDelegate__DelegateSignature");
static_assert(sizeof(GzVehicleEffectsComponent_SuspensionPercentageThresholdDelegate__DelegateSignature) == 0x000008, "Wrong size on GzVehicleEffectsComponent_SuspensionPercentageThresholdDelegate__DelegateSignature");
static_assert(offsetof(GzVehicleEffectsComponent_SuspensionPercentageThresholdDelegate__DelegateSignature, SuspensionValue) == 0x000000, "Member 'GzVehicleEffectsComponent_SuspensionPercentageThresholdDelegate__DelegateSignature::SuspensionValue' has a wrong offset!");
static_assert(offsetof(GzVehicleEffectsComponent_SuspensionPercentageThresholdDelegate__DelegateSignature, WheelIndex) == 0x000004, "Member 'GzVehicleEffectsComponent_SuspensionPercentageThresholdDelegate__DelegateSignature::WheelIndex' has a wrong offset!");

// DelegateFunction G01.GzVehicleEffectsComponent.TurretRotationStateChangedDelegate__DelegateSignature
// 0x0001 (0x0001 - 0x0000)
struct GzVehicleEffectsComponent_TurretRotationStateChangedDelegate__DelegateSignature final
{
public:
	bool                                          bIsTurretRotating;                                 // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzVehicleEffectsComponent_TurretRotationStateChangedDelegate__DelegateSignature) == 0x000001, "Wrong alignment on GzVehicleEffectsComponent_TurretRotationStateChangedDelegate__DelegateSignature");
static_assert(sizeof(GzVehicleEffectsComponent_TurretRotationStateChangedDelegate__DelegateSignature) == 0x000001, "Wrong size on GzVehicleEffectsComponent_TurretRotationStateChangedDelegate__DelegateSignature");
static_assert(offsetof(GzVehicleEffectsComponent_TurretRotationStateChangedDelegate__DelegateSignature, bIsTurretRotating) == 0x000000, "Member 'GzVehicleEffectsComponent_TurretRotationStateChangedDelegate__DelegateSignature::bIsTurretRotating' has a wrong offset!");

// DelegateFunction G01.GzVehicleEffectsComponent.WheelSkiddingOrSlippingDelegate__DelegateSignature
// 0x0008 (0x0008 - 0x0000)
struct GzVehicleEffectsComponent_WheelSkiddingOrSlippingDelegate__DelegateSignature final
{
public:
	int32                                         WheelIndex;                                        // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsSkiddingOrSlipping;                             // 0x0004(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3561[0x3];                                     // 0x0005(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GzVehicleEffectsComponent_WheelSkiddingOrSlippingDelegate__DelegateSignature) == 0x000004, "Wrong alignment on GzVehicleEffectsComponent_WheelSkiddingOrSlippingDelegate__DelegateSignature");
static_assert(sizeof(GzVehicleEffectsComponent_WheelSkiddingOrSlippingDelegate__DelegateSignature) == 0x000008, "Wrong size on GzVehicleEffectsComponent_WheelSkiddingOrSlippingDelegate__DelegateSignature");
static_assert(offsetof(GzVehicleEffectsComponent_WheelSkiddingOrSlippingDelegate__DelegateSignature, WheelIndex) == 0x000000, "Member 'GzVehicleEffectsComponent_WheelSkiddingOrSlippingDelegate__DelegateSignature::WheelIndex' has a wrong offset!");
static_assert(offsetof(GzVehicleEffectsComponent_WheelSkiddingOrSlippingDelegate__DelegateSignature, bIsSkiddingOrSlipping) == 0x000004, "Member 'GzVehicleEffectsComponent_WheelSkiddingOrSlippingDelegate__DelegateSignature::bIsSkiddingOrSlipping' has a wrong offset!");

// DelegateFunction G01.GzVehicleEffectsComponent.WheelSteeringStateChangedDelegate__DelegateSignature
// 0x000C (0x000C - 0x0000)
struct GzVehicleEffectsComponent_WheelSteeringStateChangedDelegate__DelegateSignature final
{
public:
	int32                                         WheelIndex;                                        // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SteeringValue;                                     // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsInContact;                                      // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3562[0x3];                                     // 0x0009(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GzVehicleEffectsComponent_WheelSteeringStateChangedDelegate__DelegateSignature) == 0x000004, "Wrong alignment on GzVehicleEffectsComponent_WheelSteeringStateChangedDelegate__DelegateSignature");
static_assert(sizeof(GzVehicleEffectsComponent_WheelSteeringStateChangedDelegate__DelegateSignature) == 0x00000C, "Wrong size on GzVehicleEffectsComponent_WheelSteeringStateChangedDelegate__DelegateSignature");
static_assert(offsetof(GzVehicleEffectsComponent_WheelSteeringStateChangedDelegate__DelegateSignature, WheelIndex) == 0x000000, "Member 'GzVehicleEffectsComponent_WheelSteeringStateChangedDelegate__DelegateSignature::WheelIndex' has a wrong offset!");
static_assert(offsetof(GzVehicleEffectsComponent_WheelSteeringStateChangedDelegate__DelegateSignature, SteeringValue) == 0x000004, "Member 'GzVehicleEffectsComponent_WheelSteeringStateChangedDelegate__DelegateSignature::SteeringValue' has a wrong offset!");
static_assert(offsetof(GzVehicleEffectsComponent_WheelSteeringStateChangedDelegate__DelegateSignature, bIsInContact) == 0x000008, "Member 'GzVehicleEffectsComponent_WheelSteeringStateChangedDelegate__DelegateSignature::bIsInContact' has a wrong offset!");

// Function G01.GzVehicleMapMarkerWidget.OnVehicleSeatChanged
// 0x0010 (0x0010 - 0x0000)
struct GzVehicleMapMarkerWidget_OnVehicleSeatChanged final
{
public:
	class AGzCharacter*                           Character;                                         // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EGzVehicleSeatType                            NewSeat;                                           // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EGzVehicleSeatType                            OldSeat;                                           // 0x0009(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3564[0x6];                                     // 0x000A(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GzVehicleMapMarkerWidget_OnVehicleSeatChanged) == 0x000008, "Wrong alignment on GzVehicleMapMarkerWidget_OnVehicleSeatChanged");
static_assert(sizeof(GzVehicleMapMarkerWidget_OnVehicleSeatChanged) == 0x000010, "Wrong size on GzVehicleMapMarkerWidget_OnVehicleSeatChanged");
static_assert(offsetof(GzVehicleMapMarkerWidget_OnVehicleSeatChanged, Character) == 0x000000, "Member 'GzVehicleMapMarkerWidget_OnVehicleSeatChanged::Character' has a wrong offset!");
static_assert(offsetof(GzVehicleMapMarkerWidget_OnVehicleSeatChanged, NewSeat) == 0x000008, "Member 'GzVehicleMapMarkerWidget_OnVehicleSeatChanged::NewSeat' has a wrong offset!");
static_assert(offsetof(GzVehicleMapMarkerWidget_OnVehicleSeatChanged, OldSeat) == 0x000009, "Member 'GzVehicleMapMarkerWidget_OnVehicleSeatChanged::OldSeat' has a wrong offset!");

// Function G01.GzVehicleMapMarkerWidget.SetSeatPosition
// 0x0050 (0x0050 - 0x0000)
struct GzVehicleMapMarkerWidget_SetSeatPosition final
{
public:
	TMap<EGzVehicleSeatType, class UWidget*>      InSeatPositionMap;                                 // 0x0000(0x0050)(Parm, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzVehicleMapMarkerWidget_SetSeatPosition) == 0x000008, "Wrong alignment on GzVehicleMapMarkerWidget_SetSeatPosition");
static_assert(sizeof(GzVehicleMapMarkerWidget_SetSeatPosition) == 0x000050, "Wrong size on GzVehicleMapMarkerWidget_SetSeatPosition");
static_assert(offsetof(GzVehicleMapMarkerWidget_SetSeatPosition, InSeatPositionMap) == 0x000000, "Member 'GzVehicleMapMarkerWidget_SetSeatPosition::InSeatPositionMap' has a wrong offset!");

// Function G01.GzVehicleMapMarkerWidget.SetTeamColor
// 0x0010 (0x0010 - 0x0000)
struct GzVehicleMapMarkerWidget_SetTeamColor final
{
public:
	int32                                         TeamMemberIndex;                                   // 0x0000(0x0004)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3565[0x4];                                     // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UWidget*                                Point;                                             // 0x0008(0x0008)(Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzVehicleMapMarkerWidget_SetTeamColor) == 0x000008, "Wrong alignment on GzVehicleMapMarkerWidget_SetTeamColor");
static_assert(sizeof(GzVehicleMapMarkerWidget_SetTeamColor) == 0x000010, "Wrong size on GzVehicleMapMarkerWidget_SetTeamColor");
static_assert(offsetof(GzVehicleMapMarkerWidget_SetTeamColor, TeamMemberIndex) == 0x000000, "Member 'GzVehicleMapMarkerWidget_SetTeamColor::TeamMemberIndex' has a wrong offset!");
static_assert(offsetof(GzVehicleMapMarkerWidget_SetTeamColor, Point) == 0x000008, "Member 'GzVehicleMapMarkerWidget_SetTeamColor::Point' has a wrong offset!");

// Function G01.GzVehicleMapMarkerWidget.HasGunnerSeat
// 0x0001 (0x0001 - 0x0000)
struct GzVehicleMapMarkerWidget_HasGunnerSeat final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzVehicleMapMarkerWidget_HasGunnerSeat) == 0x000001, "Wrong alignment on GzVehicleMapMarkerWidget_HasGunnerSeat");
static_assert(sizeof(GzVehicleMapMarkerWidget_HasGunnerSeat) == 0x000001, "Wrong size on GzVehicleMapMarkerWidget_HasGunnerSeat");
static_assert(offsetof(GzVehicleMapMarkerWidget_HasGunnerSeat, ReturnValue) == 0x000000, "Member 'GzVehicleMapMarkerWidget_HasGunnerSeat::ReturnValue' has a wrong offset!");

// Function G01.GzVehicleSpawner.CanSpawn
// 0x0001 (0x0001 - 0x0000)
struct GzVehicleSpawner_CanSpawn final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzVehicleSpawner_CanSpawn) == 0x000001, "Wrong alignment on GzVehicleSpawner_CanSpawn");
static_assert(sizeof(GzVehicleSpawner_CanSpawn) == 0x000001, "Wrong size on GzVehicleSpawner_CanSpawn");
static_assert(offsetof(GzVehicleSpawner_CanSpawn, ReturnValue) == 0x000000, "Member 'GzVehicleSpawner_CanSpawn::ReturnValue' has a wrong offset!");

// Function G01.GzVoiceableObject.GetPingVoiceLineData
// 0x0010 (0x0010 - 0x0000)
struct GzVoiceableObject_GetPingVoiceLineData final
{
public:
	struct FGzPingVoiceLineData                   ReturnValue;                                       // 0x0000(0x0010)(ConstParm, Parm, OutParm, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzVoiceableObject_GetPingVoiceLineData) == 0x000008, "Wrong alignment on GzVoiceableObject_GetPingVoiceLineData");
static_assert(sizeof(GzVoiceableObject_GetPingVoiceLineData) == 0x000010, "Wrong size on GzVoiceableObject_GetPingVoiceLineData");
static_assert(offsetof(GzVoiceableObject_GetPingVoiceLineData, ReturnValue) == 0x000000, "Member 'GzVoiceableObject_GetPingVoiceLineData::ReturnValue' has a wrong offset!");

// Function G01.GzWatermarkWidget.SetWaterMarkRepeatWord
// 0x0010 (0x0010 - 0x0000)
struct GzWatermarkWidget_SetWaterMarkRepeatWord final
{
public:
	class FString                                 InWord;                                            // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzWatermarkWidget_SetWaterMarkRepeatWord) == 0x000008, "Wrong alignment on GzWatermarkWidget_SetWaterMarkRepeatWord");
static_assert(sizeof(GzWatermarkWidget_SetWaterMarkRepeatWord) == 0x000010, "Wrong size on GzWatermarkWidget_SetWaterMarkRepeatWord");
static_assert(offsetof(GzWatermarkWidget_SetWaterMarkRepeatWord, InWord) == 0x000000, "Member 'GzWatermarkWidget_SetWaterMarkRepeatWord::InWord' has a wrong offset!");

// Function G01.GzWeaponAnimInstance.GetOwnerIKCurveValue
// 0x0004 (0x0004 - 0x0000)
struct GzWeaponAnimInstance_GetOwnerIKCurveValue final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzWeaponAnimInstance_GetOwnerIKCurveValue) == 0x000004, "Wrong alignment on GzWeaponAnimInstance_GetOwnerIKCurveValue");
static_assert(sizeof(GzWeaponAnimInstance_GetOwnerIKCurveValue) == 0x000004, "Wrong size on GzWeaponAnimInstance_GetOwnerIKCurveValue");
static_assert(offsetof(GzWeaponAnimInstance_GetOwnerIKCurveValue, ReturnValue) == 0x000000, "Member 'GzWeaponAnimInstance_GetOwnerIKCurveValue::ReturnValue' has a wrong offset!");

// Function G01.GzWeaponArchetype.GetAssetId
// 0x0008 (0x0008 - 0x0000)
struct GzWeaponArchetype_GetAssetId final
{
public:
	class FName                                   ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzWeaponArchetype_GetAssetId) == 0x000004, "Wrong alignment on GzWeaponArchetype_GetAssetId");
static_assert(sizeof(GzWeaponArchetype_GetAssetId) == 0x000008, "Wrong size on GzWeaponArchetype_GetAssetId");
static_assert(offsetof(GzWeaponArchetype_GetAssetId, ReturnValue) == 0x000000, "Member 'GzWeaponArchetype_GetAssetId::ReturnValue' has a wrong offset!");

// Function G01.GzWeaponArchetype.GetDefaultAttachments
// 0x0010 (0x0010 - 0x0000)
struct GzWeaponArchetype_GetDefaultAttachments final
{
public:
	TArray<class UGzWeaponAttachmentItemData*>    ReturnValue;                                       // 0x0000(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzWeaponArchetype_GetDefaultAttachments) == 0x000008, "Wrong alignment on GzWeaponArchetype_GetDefaultAttachments");
static_assert(sizeof(GzWeaponArchetype_GetDefaultAttachments) == 0x000010, "Wrong size on GzWeaponArchetype_GetDefaultAttachments");
static_assert(offsetof(GzWeaponArchetype_GetDefaultAttachments, ReturnValue) == 0x000000, "Member 'GzWeaponArchetype_GetDefaultAttachments::ReturnValue' has a wrong offset!");

// Function G01.GzWeaponArchetype.GetSuitableAttachmentIDsOfType
// 0x0018 (0x0018 - 0x0000)
struct GzWeaponArchetype_GetSuitableAttachmentIDsOfType final
{
public:
	EGzWeaponAttachmentType                       AttachmentType;                                    // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3572[0x7];                                     // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FName>                           ReturnValue;                                       // 0x0008(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzWeaponArchetype_GetSuitableAttachmentIDsOfType) == 0x000008, "Wrong alignment on GzWeaponArchetype_GetSuitableAttachmentIDsOfType");
static_assert(sizeof(GzWeaponArchetype_GetSuitableAttachmentIDsOfType) == 0x000018, "Wrong size on GzWeaponArchetype_GetSuitableAttachmentIDsOfType");
static_assert(offsetof(GzWeaponArchetype_GetSuitableAttachmentIDsOfType, AttachmentType) == 0x000000, "Member 'GzWeaponArchetype_GetSuitableAttachmentIDsOfType::AttachmentType' has a wrong offset!");
static_assert(offsetof(GzWeaponArchetype_GetSuitableAttachmentIDsOfType, ReturnValue) == 0x000008, "Member 'GzWeaponArchetype_GetSuitableAttachmentIDsOfType::ReturnValue' has a wrong offset!");

// Function G01.GzWeaponArchetype.GetSuitableSkinNames
// 0x0010 (0x0010 - 0x0000)
struct GzWeaponArchetype_GetSuitableSkinNames final
{
public:
	TArray<class FName>                           ReturnValue;                                       // 0x0000(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzWeaponArchetype_GetSuitableSkinNames) == 0x000008, "Wrong alignment on GzWeaponArchetype_GetSuitableSkinNames");
static_assert(sizeof(GzWeaponArchetype_GetSuitableSkinNames) == 0x000010, "Wrong size on GzWeaponArchetype_GetSuitableSkinNames");
static_assert(offsetof(GzWeaponArchetype_GetSuitableSkinNames, ReturnValue) == 0x000000, "Member 'GzWeaponArchetype_GetSuitableSkinNames::ReturnValue' has a wrong offset!");

// Function G01.GzWeaponAttachmentComponent.PlayWeaponAttachmentMontage
// 0x0008 (0x0008 - 0x0000)
struct GzWeaponAttachmentComponent_PlayWeaponAttachmentMontage final
{
public:
	struct FGameplayTag                           AnimationTag;                                      // 0x0000(0x0008)(Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzWeaponAttachmentComponent_PlayWeaponAttachmentMontage) == 0x000004, "Wrong alignment on GzWeaponAttachmentComponent_PlayWeaponAttachmentMontage");
static_assert(sizeof(GzWeaponAttachmentComponent_PlayWeaponAttachmentMontage) == 0x000008, "Wrong size on GzWeaponAttachmentComponent_PlayWeaponAttachmentMontage");
static_assert(offsetof(GzWeaponAttachmentComponent_PlayWeaponAttachmentMontage, AnimationTag) == 0x000000, "Member 'GzWeaponAttachmentComponent_PlayWeaponAttachmentMontage::AnimationTag' has a wrong offset!");

// Function G01.GzWeaponAttachmentComponent.StopWeaponAttachmentMontage
// 0x0008 (0x0008 - 0x0000)
struct GzWeaponAttachmentComponent_StopWeaponAttachmentMontage final
{
public:
	struct FGameplayTag                           AnimationTag;                                      // 0x0000(0x0008)(Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzWeaponAttachmentComponent_StopWeaponAttachmentMontage) == 0x000004, "Wrong alignment on GzWeaponAttachmentComponent_StopWeaponAttachmentMontage");
static_assert(sizeof(GzWeaponAttachmentComponent_StopWeaponAttachmentMontage) == 0x000008, "Wrong size on GzWeaponAttachmentComponent_StopWeaponAttachmentMontage");
static_assert(offsetof(GzWeaponAttachmentComponent_StopWeaponAttachmentMontage, AnimationTag) == 0x000000, "Member 'GzWeaponAttachmentComponent_StopWeaponAttachmentMontage::AnimationTag' has a wrong offset!");

// Function G01.GzWeaponAttachmentComponent.GetWeaponAttachmentItemData
// 0x0008 (0x0008 - 0x0000)
struct GzWeaponAttachmentComponent_GetWeaponAttachmentItemData final
{
public:
	const class UGzWeaponAttachmentItemData*      ReturnValue;                                       // 0x0000(0x0008)(ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzWeaponAttachmentComponent_GetWeaponAttachmentItemData) == 0x000008, "Wrong alignment on GzWeaponAttachmentComponent_GetWeaponAttachmentItemData");
static_assert(sizeof(GzWeaponAttachmentComponent_GetWeaponAttachmentItemData) == 0x000008, "Wrong size on GzWeaponAttachmentComponent_GetWeaponAttachmentItemData");
static_assert(offsetof(GzWeaponAttachmentComponent_GetWeaponAttachmentItemData, ReturnValue) == 0x000000, "Member 'GzWeaponAttachmentComponent_GetWeaponAttachmentItemData::ReturnValue' has a wrong offset!");

// Function G01.GzWeaponCrosshair.OnUpdatedMaxPrecisionStateBP
// 0x0001 (0x0001 - 0x0000)
struct GzWeaponCrosshair_OnUpdatedMaxPrecisionStateBP final
{
public:
	bool                                          bEnable;                                           // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzWeaponCrosshair_OnUpdatedMaxPrecisionStateBP) == 0x000001, "Wrong alignment on GzWeaponCrosshair_OnUpdatedMaxPrecisionStateBP");
static_assert(sizeof(GzWeaponCrosshair_OnUpdatedMaxPrecisionStateBP) == 0x000001, "Wrong size on GzWeaponCrosshair_OnUpdatedMaxPrecisionStateBP");
static_assert(offsetof(GzWeaponCrosshair_OnUpdatedMaxPrecisionStateBP, bEnable) == 0x000000, "Member 'GzWeaponCrosshair_OnUpdatedMaxPrecisionStateBP::bEnable' has a wrong offset!");

// Function G01.GzWeaponStatics.AttachComponentToWeapon
// 0x0020 (0x0020 - 0x0000)
struct GzWeaponStatics_AttachComponentToWeapon final
{
public:
	class USceneComponent*                        ComponentToAttach;                                 // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	const class AActor*                           WeaponActor;                                       // 0x0008(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   SocketName;                                        // 0x0010(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bNeedCheck;                                        // 0x0018(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_357A[0x7];                                     // 0x0019(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GzWeaponStatics_AttachComponentToWeapon) == 0x000008, "Wrong alignment on GzWeaponStatics_AttachComponentToWeapon");
static_assert(sizeof(GzWeaponStatics_AttachComponentToWeapon) == 0x000020, "Wrong size on GzWeaponStatics_AttachComponentToWeapon");
static_assert(offsetof(GzWeaponStatics_AttachComponentToWeapon, ComponentToAttach) == 0x000000, "Member 'GzWeaponStatics_AttachComponentToWeapon::ComponentToAttach' has a wrong offset!");
static_assert(offsetof(GzWeaponStatics_AttachComponentToWeapon, WeaponActor) == 0x000008, "Member 'GzWeaponStatics_AttachComponentToWeapon::WeaponActor' has a wrong offset!");
static_assert(offsetof(GzWeaponStatics_AttachComponentToWeapon, SocketName) == 0x000010, "Member 'GzWeaponStatics_AttachComponentToWeapon::SocketName' has a wrong offset!");
static_assert(offsetof(GzWeaponStatics_AttachComponentToWeapon, bNeedCheck) == 0x000018, "Member 'GzWeaponStatics_AttachComponentToWeapon::bNeedCheck' has a wrong offset!");

// Function G01.GzWeaponStatics.GetAllArchetypeCombinations
// 0x0018 (0x0018 - 0x0000)
struct GzWeaponStatics_GetAllArchetypeCombinations final
{
public:
	class UGzWeaponItemData*                      WeaponItemData;                                    // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FGzInventoryItemContent>        ReturnValue;                                       // 0x0008(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzWeaponStatics_GetAllArchetypeCombinations) == 0x000008, "Wrong alignment on GzWeaponStatics_GetAllArchetypeCombinations");
static_assert(sizeof(GzWeaponStatics_GetAllArchetypeCombinations) == 0x000018, "Wrong size on GzWeaponStatics_GetAllArchetypeCombinations");
static_assert(offsetof(GzWeaponStatics_GetAllArchetypeCombinations, WeaponItemData) == 0x000000, "Member 'GzWeaponStatics_GetAllArchetypeCombinations::WeaponItemData' has a wrong offset!");
static_assert(offsetof(GzWeaponStatics_GetAllArchetypeCombinations, ReturnValue) == 0x000008, "Member 'GzWeaponStatics_GetAllArchetypeCombinations::ReturnValue' has a wrong offset!");

// Function G01.GzWeaponStatics.GetAmmoCount
// 0x0010 (0x0010 - 0x0000)
struct GzWeaponStatics_GetAmmoCount final
{
public:
	class UGzWeaponComponent*                     WeaponComponent;                                   // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bInClip;                                           // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bInStock;                                          // 0x0009(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_357B[0x2];                                     // 0x000A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         ReturnValue;                                       // 0x000C(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzWeaponStatics_GetAmmoCount) == 0x000008, "Wrong alignment on GzWeaponStatics_GetAmmoCount");
static_assert(sizeof(GzWeaponStatics_GetAmmoCount) == 0x000010, "Wrong size on GzWeaponStatics_GetAmmoCount");
static_assert(offsetof(GzWeaponStatics_GetAmmoCount, WeaponComponent) == 0x000000, "Member 'GzWeaponStatics_GetAmmoCount::WeaponComponent' has a wrong offset!");
static_assert(offsetof(GzWeaponStatics_GetAmmoCount, bInClip) == 0x000008, "Member 'GzWeaponStatics_GetAmmoCount::bInClip' has a wrong offset!");
static_assert(offsetof(GzWeaponStatics_GetAmmoCount, bInStock) == 0x000009, "Member 'GzWeaponStatics_GetAmmoCount::bInStock' has a wrong offset!");
static_assert(offsetof(GzWeaponStatics_GetAmmoCount, ReturnValue) == 0x00000C, "Member 'GzWeaponStatics_GetAmmoCount::ReturnValue' has a wrong offset!");

// Function G01.GzWeaponStatics.GetAmmoCountForWeaponPocket
// 0x0018 (0x0018 - 0x0000)
struct GzWeaponStatics_GetAmmoCountForWeaponPocket final
{
public:
	const class APawn*                            Char;                                              // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGzInvPocketId                         DedicatedPocketID;                                 // 0x0008(0x0008)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bInClip;                                           // 0x0010(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bInStock;                                          // 0x0011(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_357C[0x2];                                     // 0x0012(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         ReturnValue;                                       // 0x0014(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzWeaponStatics_GetAmmoCountForWeaponPocket) == 0x000008, "Wrong alignment on GzWeaponStatics_GetAmmoCountForWeaponPocket");
static_assert(sizeof(GzWeaponStatics_GetAmmoCountForWeaponPocket) == 0x000018, "Wrong size on GzWeaponStatics_GetAmmoCountForWeaponPocket");
static_assert(offsetof(GzWeaponStatics_GetAmmoCountForWeaponPocket, Char) == 0x000000, "Member 'GzWeaponStatics_GetAmmoCountForWeaponPocket::Char' has a wrong offset!");
static_assert(offsetof(GzWeaponStatics_GetAmmoCountForWeaponPocket, DedicatedPocketID) == 0x000008, "Member 'GzWeaponStatics_GetAmmoCountForWeaponPocket::DedicatedPocketID' has a wrong offset!");
static_assert(offsetof(GzWeaponStatics_GetAmmoCountForWeaponPocket, bInClip) == 0x000010, "Member 'GzWeaponStatics_GetAmmoCountForWeaponPocket::bInClip' has a wrong offset!");
static_assert(offsetof(GzWeaponStatics_GetAmmoCountForWeaponPocket, bInStock) == 0x000011, "Member 'GzWeaponStatics_GetAmmoCountForWeaponPocket::bInStock' has a wrong offset!");
static_assert(offsetof(GzWeaponStatics_GetAmmoCountForWeaponPocket, ReturnValue) == 0x000014, "Member 'GzWeaponStatics_GetAmmoCountForWeaponPocket::ReturnValue' has a wrong offset!");

// Function G01.GzWeaponStatics.GetAmmoItemDataForWeaponData
// 0x0010 (0x0010 - 0x0000)
struct GzWeaponStatics_GetAmmoItemDataForWeaponData final
{
public:
	const class UGzWeaponData*                    WeaponData;                                        // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UGzAmmoItemData*                        ReturnValue;                                       // 0x0008(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzWeaponStatics_GetAmmoItemDataForWeaponData) == 0x000008, "Wrong alignment on GzWeaponStatics_GetAmmoItemDataForWeaponData");
static_assert(sizeof(GzWeaponStatics_GetAmmoItemDataForWeaponData) == 0x000010, "Wrong size on GzWeaponStatics_GetAmmoItemDataForWeaponData");
static_assert(offsetof(GzWeaponStatics_GetAmmoItemDataForWeaponData, WeaponData) == 0x000000, "Member 'GzWeaponStatics_GetAmmoItemDataForWeaponData::WeaponData' has a wrong offset!");
static_assert(offsetof(GzWeaponStatics_GetAmmoItemDataForWeaponData, ReturnValue) == 0x000008, "Member 'GzWeaponStatics_GetAmmoItemDataForWeaponData::ReturnValue' has a wrong offset!");

// Function G01.GzWeaponStatics.GetAmmoType
// 0x0010 (0x0010 - 0x0000)
struct GzWeaponStatics_GetAmmoType final
{
public:
	class UGzWeaponComponent*                     WeaponComponent;                                   // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           ReturnValue;                                       // 0x0008(0x0008)(Parm, OutParm, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzWeaponStatics_GetAmmoType) == 0x000008, "Wrong alignment on GzWeaponStatics_GetAmmoType");
static_assert(sizeof(GzWeaponStatics_GetAmmoType) == 0x000010, "Wrong size on GzWeaponStatics_GetAmmoType");
static_assert(offsetof(GzWeaponStatics_GetAmmoType, WeaponComponent) == 0x000000, "Member 'GzWeaponStatics_GetAmmoType::WeaponComponent' has a wrong offset!");
static_assert(offsetof(GzWeaponStatics_GetAmmoType, ReturnValue) == 0x000008, "Member 'GzWeaponStatics_GetAmmoType::ReturnValue' has a wrong offset!");

// Function G01.GzWeaponStatics.GetUIAccuracy
// 0x0020 (0x0020 - 0x0000)
struct GzWeaponStatics_GetUIAccuracy final
{
public:
	class UGzWeaponItemData*                      WeaponItemData;                                    // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class UGzWeaponAttachmentItemData*>    AttachmentsData;                                   // 0x0008(0x0010)(Parm, ZeroConstructor, NativeAccessSpecifierPublic)
	float                                         ReturnValue;                                       // 0x0018(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_357D[0x4];                                     // 0x001C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GzWeaponStatics_GetUIAccuracy) == 0x000008, "Wrong alignment on GzWeaponStatics_GetUIAccuracy");
static_assert(sizeof(GzWeaponStatics_GetUIAccuracy) == 0x000020, "Wrong size on GzWeaponStatics_GetUIAccuracy");
static_assert(offsetof(GzWeaponStatics_GetUIAccuracy, WeaponItemData) == 0x000000, "Member 'GzWeaponStatics_GetUIAccuracy::WeaponItemData' has a wrong offset!");
static_assert(offsetof(GzWeaponStatics_GetUIAccuracy, AttachmentsData) == 0x000008, "Member 'GzWeaponStatics_GetUIAccuracy::AttachmentsData' has a wrong offset!");
static_assert(offsetof(GzWeaponStatics_GetUIAccuracy, ReturnValue) == 0x000018, "Member 'GzWeaponStatics_GetUIAccuracy::ReturnValue' has a wrong offset!");

// Function G01.GzWeaponStatics.GetUIClipSize
// 0x0020 (0x0020 - 0x0000)
struct GzWeaponStatics_GetUIClipSize final
{
public:
	class UGzWeaponItemData*                      WeaponItemData;                                    // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class UGzWeaponAttachmentItemData*>    AttachmentsData;                                   // 0x0008(0x0010)(Parm, ZeroConstructor, NativeAccessSpecifierPublic)
	float                                         ReturnValue;                                       // 0x0018(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_357E[0x4];                                     // 0x001C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GzWeaponStatics_GetUIClipSize) == 0x000008, "Wrong alignment on GzWeaponStatics_GetUIClipSize");
static_assert(sizeof(GzWeaponStatics_GetUIClipSize) == 0x000020, "Wrong size on GzWeaponStatics_GetUIClipSize");
static_assert(offsetof(GzWeaponStatics_GetUIClipSize, WeaponItemData) == 0x000000, "Member 'GzWeaponStatics_GetUIClipSize::WeaponItemData' has a wrong offset!");
static_assert(offsetof(GzWeaponStatics_GetUIClipSize, AttachmentsData) == 0x000008, "Member 'GzWeaponStatics_GetUIClipSize::AttachmentsData' has a wrong offset!");
static_assert(offsetof(GzWeaponStatics_GetUIClipSize, ReturnValue) == 0x000018, "Member 'GzWeaponStatics_GetUIClipSize::ReturnValue' has a wrong offset!");

// Function G01.GzWeaponStatics.GetUIDamage
// 0x0020 (0x0020 - 0x0000)
struct GzWeaponStatics_GetUIDamage final
{
public:
	class UGzWeaponItemData*                      WeaponItemData;                                    // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class UGzWeaponAttachmentItemData*>    AttachmentsData;                                   // 0x0008(0x0010)(Parm, ZeroConstructor, NativeAccessSpecifierPublic)
	float                                         ReturnValue;                                       // 0x0018(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_357F[0x4];                                     // 0x001C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GzWeaponStatics_GetUIDamage) == 0x000008, "Wrong alignment on GzWeaponStatics_GetUIDamage");
static_assert(sizeof(GzWeaponStatics_GetUIDamage) == 0x000020, "Wrong size on GzWeaponStatics_GetUIDamage");
static_assert(offsetof(GzWeaponStatics_GetUIDamage, WeaponItemData) == 0x000000, "Member 'GzWeaponStatics_GetUIDamage::WeaponItemData' has a wrong offset!");
static_assert(offsetof(GzWeaponStatics_GetUIDamage, AttachmentsData) == 0x000008, "Member 'GzWeaponStatics_GetUIDamage::AttachmentsData' has a wrong offset!");
static_assert(offsetof(GzWeaponStatics_GetUIDamage, ReturnValue) == 0x000018, "Member 'GzWeaponStatics_GetUIDamage::ReturnValue' has a wrong offset!");

// Function G01.GzWeaponStatics.GetUIFireRate
// 0x0020 (0x0020 - 0x0000)
struct GzWeaponStatics_GetUIFireRate final
{
public:
	class UGzWeaponItemData*                      WeaponItemData;                                    // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class UGzWeaponAttachmentItemData*>    AttachmentsData;                                   // 0x0008(0x0010)(Parm, ZeroConstructor, NativeAccessSpecifierPublic)
	float                                         ReturnValue;                                       // 0x0018(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3580[0x4];                                     // 0x001C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GzWeaponStatics_GetUIFireRate) == 0x000008, "Wrong alignment on GzWeaponStatics_GetUIFireRate");
static_assert(sizeof(GzWeaponStatics_GetUIFireRate) == 0x000020, "Wrong size on GzWeaponStatics_GetUIFireRate");
static_assert(offsetof(GzWeaponStatics_GetUIFireRate, WeaponItemData) == 0x000000, "Member 'GzWeaponStatics_GetUIFireRate::WeaponItemData' has a wrong offset!");
static_assert(offsetof(GzWeaponStatics_GetUIFireRate, AttachmentsData) == 0x000008, "Member 'GzWeaponStatics_GetUIFireRate::AttachmentsData' has a wrong offset!");
static_assert(offsetof(GzWeaponStatics_GetUIFireRate, ReturnValue) == 0x000018, "Member 'GzWeaponStatics_GetUIFireRate::ReturnValue' has a wrong offset!");

// Function G01.GzWeaponStatics.GetUIHandling
// 0x0020 (0x0020 - 0x0000)
struct GzWeaponStatics_GetUIHandling final
{
public:
	class UGzWeaponItemData*                      WeaponItemData;                                    // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class UGzWeaponAttachmentItemData*>    AttachmentsData;                                   // 0x0008(0x0010)(Parm, ZeroConstructor, NativeAccessSpecifierPublic)
	float                                         ReturnValue;                                       // 0x0018(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3581[0x4];                                     // 0x001C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GzWeaponStatics_GetUIHandling) == 0x000008, "Wrong alignment on GzWeaponStatics_GetUIHandling");
static_assert(sizeof(GzWeaponStatics_GetUIHandling) == 0x000020, "Wrong size on GzWeaponStatics_GetUIHandling");
static_assert(offsetof(GzWeaponStatics_GetUIHandling, WeaponItemData) == 0x000000, "Member 'GzWeaponStatics_GetUIHandling::WeaponItemData' has a wrong offset!");
static_assert(offsetof(GzWeaponStatics_GetUIHandling, AttachmentsData) == 0x000008, "Member 'GzWeaponStatics_GetUIHandling::AttachmentsData' has a wrong offset!");
static_assert(offsetof(GzWeaponStatics_GetUIHandling, ReturnValue) == 0x000018, "Member 'GzWeaponStatics_GetUIHandling::ReturnValue' has a wrong offset!");

// Function G01.GzWeaponStatics.GetUIMobility
// 0x0020 (0x0020 - 0x0000)
struct GzWeaponStatics_GetUIMobility final
{
public:
	class UGzWeaponItemData*                      WeaponItemData;                                    // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class UGzWeaponAttachmentItemData*>    AttachmentsData;                                   // 0x0008(0x0010)(Parm, ZeroConstructor, NativeAccessSpecifierPublic)
	float                                         ReturnValue;                                       // 0x0018(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3582[0x4];                                     // 0x001C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GzWeaponStatics_GetUIMobility) == 0x000008, "Wrong alignment on GzWeaponStatics_GetUIMobility");
static_assert(sizeof(GzWeaponStatics_GetUIMobility) == 0x000020, "Wrong size on GzWeaponStatics_GetUIMobility");
static_assert(offsetof(GzWeaponStatics_GetUIMobility, WeaponItemData) == 0x000000, "Member 'GzWeaponStatics_GetUIMobility::WeaponItemData' has a wrong offset!");
static_assert(offsetof(GzWeaponStatics_GetUIMobility, AttachmentsData) == 0x000008, "Member 'GzWeaponStatics_GetUIMobility::AttachmentsData' has a wrong offset!");
static_assert(offsetof(GzWeaponStatics_GetUIMobility, ReturnValue) == 0x000018, "Member 'GzWeaponStatics_GetUIMobility::ReturnValue' has a wrong offset!");

// Function G01.GzWeaponStatics.GetUIRange
// 0x0020 (0x0020 - 0x0000)
struct GzWeaponStatics_GetUIRange final
{
public:
	class UGzWeaponItemData*                      WeaponItemData;                                    // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class UGzWeaponAttachmentItemData*>    AttachmentsData;                                   // 0x0008(0x0010)(Parm, ZeroConstructor, NativeAccessSpecifierPublic)
	float                                         ReturnValue;                                       // 0x0018(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3583[0x4];                                     // 0x001C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GzWeaponStatics_GetUIRange) == 0x000008, "Wrong alignment on GzWeaponStatics_GetUIRange");
static_assert(sizeof(GzWeaponStatics_GetUIRange) == 0x000020, "Wrong size on GzWeaponStatics_GetUIRange");
static_assert(offsetof(GzWeaponStatics_GetUIRange, WeaponItemData) == 0x000000, "Member 'GzWeaponStatics_GetUIRange::WeaponItemData' has a wrong offset!");
static_assert(offsetof(GzWeaponStatics_GetUIRange, AttachmentsData) == 0x000008, "Member 'GzWeaponStatics_GetUIRange::AttachmentsData' has a wrong offset!");
static_assert(offsetof(GzWeaponStatics_GetUIRange, ReturnValue) == 0x000018, "Member 'GzWeaponStatics_GetUIRange::ReturnValue' has a wrong offset!");

// Function G01.GzWeaponStatics.GetUIRecoil
// 0x0020 (0x0020 - 0x0000)
struct GzWeaponStatics_GetUIRecoil final
{
public:
	class UGzWeaponItemData*                      WeaponItemData;                                    // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class UGzWeaponAttachmentItemData*>    AttachmentsData;                                   // 0x0008(0x0010)(Parm, ZeroConstructor, NativeAccessSpecifierPublic)
	float                                         ReturnValue;                                       // 0x0018(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3584[0x4];                                     // 0x001C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GzWeaponStatics_GetUIRecoil) == 0x000008, "Wrong alignment on GzWeaponStatics_GetUIRecoil");
static_assert(sizeof(GzWeaponStatics_GetUIRecoil) == 0x000020, "Wrong size on GzWeaponStatics_GetUIRecoil");
static_assert(offsetof(GzWeaponStatics_GetUIRecoil, WeaponItemData) == 0x000000, "Member 'GzWeaponStatics_GetUIRecoil::WeaponItemData' has a wrong offset!");
static_assert(offsetof(GzWeaponStatics_GetUIRecoil, AttachmentsData) == 0x000008, "Member 'GzWeaponStatics_GetUIRecoil::AttachmentsData' has a wrong offset!");
static_assert(offsetof(GzWeaponStatics_GetUIRecoil, ReturnValue) == 0x000018, "Member 'GzWeaponStatics_GetUIRecoil::ReturnValue' has a wrong offset!");

// Function G01.GzWeaponStatics.IsActiveWeaponClipEmpty
// 0x0010 (0x0010 - 0x0000)
struct GzWeaponStatics_IsActiveWeaponClipEmpty final
{
public:
	class APawn*                                  Char;                                              // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3585[0x7];                                     // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GzWeaponStatics_IsActiveWeaponClipEmpty) == 0x000008, "Wrong alignment on GzWeaponStatics_IsActiveWeaponClipEmpty");
static_assert(sizeof(GzWeaponStatics_IsActiveWeaponClipEmpty) == 0x000010, "Wrong size on GzWeaponStatics_IsActiveWeaponClipEmpty");
static_assert(offsetof(GzWeaponStatics_IsActiveWeaponClipEmpty, Char) == 0x000000, "Member 'GzWeaponStatics_IsActiveWeaponClipEmpty::Char' has a wrong offset!");
static_assert(offsetof(GzWeaponStatics_IsActiveWeaponClipEmpty, ReturnValue) == 0x000008, "Member 'GzWeaponStatics_IsActiveWeaponClipEmpty::ReturnValue' has a wrong offset!");

// Function G01.GzWeaponStatics.IsActiveWeaponClipFull
// 0x0010 (0x0010 - 0x0000)
struct GzWeaponStatics_IsActiveWeaponClipFull final
{
public:
	class APawn*                                  Char;                                              // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3586[0x7];                                     // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GzWeaponStatics_IsActiveWeaponClipFull) == 0x000008, "Wrong alignment on GzWeaponStatics_IsActiveWeaponClipFull");
static_assert(sizeof(GzWeaponStatics_IsActiveWeaponClipFull) == 0x000010, "Wrong size on GzWeaponStatics_IsActiveWeaponClipFull");
static_assert(offsetof(GzWeaponStatics_IsActiveWeaponClipFull, Char) == 0x000000, "Member 'GzWeaponStatics_IsActiveWeaponClipFull::Char' has a wrong offset!");
static_assert(offsetof(GzWeaponStatics_IsActiveWeaponClipFull, ReturnValue) == 0x000008, "Member 'GzWeaponStatics_IsActiveWeaponClipFull::ReturnValue' has a wrong offset!");

// Function G01.GzWeaponOverheatSystem.GetOverheatPercentage
// 0x0004 (0x0004 - 0x0000)
struct GzWeaponOverheatSystem_GetOverheatPercentage final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzWeaponOverheatSystem_GetOverheatPercentage) == 0x000004, "Wrong alignment on GzWeaponOverheatSystem_GetOverheatPercentage");
static_assert(sizeof(GzWeaponOverheatSystem_GetOverheatPercentage) == 0x000004, "Wrong size on GzWeaponOverheatSystem_GetOverheatPercentage");
static_assert(offsetof(GzWeaponOverheatSystem_GetOverheatPercentage, ReturnValue) == 0x000000, "Member 'GzWeaponOverheatSystem_GetOverheatPercentage::ReturnValue' has a wrong offset!");

// Function G01.GzWeaponPocketWidget.OnOwnerLimbChanged
// 0x0001 (0x0001 - 0x0000)
struct GzWeaponPocketWidget_OnOwnerLimbChanged final
{
public:
	EGzLimbType                                   Limb;                                              // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzWeaponPocketWidget_OnOwnerLimbChanged) == 0x000001, "Wrong alignment on GzWeaponPocketWidget_OnOwnerLimbChanged");
static_assert(sizeof(GzWeaponPocketWidget_OnOwnerLimbChanged) == 0x000001, "Wrong size on GzWeaponPocketWidget_OnOwnerLimbChanged");
static_assert(offsetof(GzWeaponPocketWidget_OnOwnerLimbChanged, Limb) == 0x000000, "Member 'GzWeaponPocketWidget_OnOwnerLimbChanged::Limb' has a wrong offset!");

// Function G01.GzWeaponPocketWidget.OnWeaponEquipped
// 0x0018 (0x0018 - 0x0000)
struct GzWeaponPocketWidget_OnWeaponEquipped final
{
public:
	struct FGzInvPocketId                         InvPocketId;                                       // 0x0000(0x0008)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	const class AGzWeaponActor*                   WeaponActor;                                       // 0x0008(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEquipped;                                         // 0x0010(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_358F[0x7];                                     // 0x0011(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GzWeaponPocketWidget_OnWeaponEquipped) == 0x000008, "Wrong alignment on GzWeaponPocketWidget_OnWeaponEquipped");
static_assert(sizeof(GzWeaponPocketWidget_OnWeaponEquipped) == 0x000018, "Wrong size on GzWeaponPocketWidget_OnWeaponEquipped");
static_assert(offsetof(GzWeaponPocketWidget_OnWeaponEquipped, InvPocketId) == 0x000000, "Member 'GzWeaponPocketWidget_OnWeaponEquipped::InvPocketId' has a wrong offset!");
static_assert(offsetof(GzWeaponPocketWidget_OnWeaponEquipped, WeaponActor) == 0x000008, "Member 'GzWeaponPocketWidget_OnWeaponEquipped::WeaponActor' has a wrong offset!");
static_assert(offsetof(GzWeaponPocketWidget_OnWeaponEquipped, bEquipped) == 0x000010, "Member 'GzWeaponPocketWidget_OnWeaponEquipped::bEquipped' has a wrong offset!");

// Function G01.GzWeaponPocketWidget.RefreshEquipCondition
// 0x0001 (0x0001 - 0x0000)
struct GzWeaponPocketWidget_RefreshEquipCondition final
{
public:
	bool                                          bCanEquip;                                         // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzWeaponPocketWidget_RefreshEquipCondition) == 0x000001, "Wrong alignment on GzWeaponPocketWidget_RefreshEquipCondition");
static_assert(sizeof(GzWeaponPocketWidget_RefreshEquipCondition) == 0x000001, "Wrong size on GzWeaponPocketWidget_RefreshEquipCondition");
static_assert(offsetof(GzWeaponPocketWidget_RefreshEquipCondition, bCanEquip) == 0x000000, "Member 'GzWeaponPocketWidget_RefreshEquipCondition::bCanEquip' has a wrong offset!");

// Function G01.GzWeaponPocketWidget.UpdateEquipped
// 0x0001 (0x0001 - 0x0000)
struct GzWeaponPocketWidget_UpdateEquipped final
{
public:
	bool                                          bEquipped;                                         // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzWeaponPocketWidget_UpdateEquipped) == 0x000001, "Wrong alignment on GzWeaponPocketWidget_UpdateEquipped");
static_assert(sizeof(GzWeaponPocketWidget_UpdateEquipped) == 0x000001, "Wrong size on GzWeaponPocketWidget_UpdateEquipped");
static_assert(offsetof(GzWeaponPocketWidget_UpdateEquipped, bEquipped) == 0x000000, "Member 'GzWeaponPocketWidget_UpdateEquipped::bEquipped' has a wrong offset!");

// Function G01.GzZipline.GetEndEdgeSegmentMeshComponent
// 0x0008 (0x0008 - 0x0000)
struct GzZipline_GetEndEdgeSegmentMeshComponent final
{
public:
	class UStaticMeshComponent*                   ReturnValue;                                       // 0x0000(0x0008)(ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzZipline_GetEndEdgeSegmentMeshComponent) == 0x000008, "Wrong alignment on GzZipline_GetEndEdgeSegmentMeshComponent");
static_assert(sizeof(GzZipline_GetEndEdgeSegmentMeshComponent) == 0x000008, "Wrong size on GzZipline_GetEndEdgeSegmentMeshComponent");
static_assert(offsetof(GzZipline_GetEndEdgeSegmentMeshComponent, ReturnValue) == 0x000000, "Member 'GzZipline_GetEndEdgeSegmentMeshComponent::ReturnValue' has a wrong offset!");

// Function G01.GzZipline.GetEndMeshComponent
// 0x0008 (0x0008 - 0x0000)
struct GzZipline_GetEndMeshComponent final
{
public:
	class UMeshComponent*                         ReturnValue;                                       // 0x0000(0x0008)(ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzZipline_GetEndMeshComponent) == 0x000008, "Wrong alignment on GzZipline_GetEndMeshComponent");
static_assert(sizeof(GzZipline_GetEndMeshComponent) == 0x000008, "Wrong size on GzZipline_GetEndMeshComponent");
static_assert(offsetof(GzZipline_GetEndMeshComponent, ReturnValue) == 0x000000, "Member 'GzZipline_GetEndMeshComponent::ReturnValue' has a wrong offset!");

// Function G01.GzZipline.GetStartEdgeSegmentMeshComponent
// 0x0008 (0x0008 - 0x0000)
struct GzZipline_GetStartEdgeSegmentMeshComponent final
{
public:
	class UStaticMeshComponent*                   ReturnValue;                                       // 0x0000(0x0008)(ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzZipline_GetStartEdgeSegmentMeshComponent) == 0x000008, "Wrong alignment on GzZipline_GetStartEdgeSegmentMeshComponent");
static_assert(sizeof(GzZipline_GetStartEdgeSegmentMeshComponent) == 0x000008, "Wrong size on GzZipline_GetStartEdgeSegmentMeshComponent");
static_assert(offsetof(GzZipline_GetStartEdgeSegmentMeshComponent, ReturnValue) == 0x000000, "Member 'GzZipline_GetStartEdgeSegmentMeshComponent::ReturnValue' has a wrong offset!");

// Function G01.GzZipline.GetStartMeshComponent
// 0x0008 (0x0008 - 0x0000)
struct GzZipline_GetStartMeshComponent final
{
public:
	class UMeshComponent*                         ReturnValue;                                       // 0x0000(0x0008)(ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzZipline_GetStartMeshComponent) == 0x000008, "Wrong alignment on GzZipline_GetStartMeshComponent");
static_assert(sizeof(GzZipline_GetStartMeshComponent) == 0x000008, "Wrong size on GzZipline_GetStartMeshComponent");
static_assert(offsetof(GzZipline_GetStartMeshComponent, ReturnValue) == 0x000000, "Member 'GzZipline_GetStartMeshComponent::ReturnValue' has a wrong offset!");

// Function G01.GzZipline.OnInteract
// 0x0010 (0x0010 - 0x0000)
struct GzZipline_OnInteract final
{
public:
	class AActor*                                 InteractedBy;                                      // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	const class UGzInteractableComponent*         Interactable;                                      // 0x0008(0x0008)(ConstParm, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzZipline_OnInteract) == 0x000008, "Wrong alignment on GzZipline_OnInteract");
static_assert(sizeof(GzZipline_OnInteract) == 0x000010, "Wrong size on GzZipline_OnInteract");
static_assert(offsetof(GzZipline_OnInteract, InteractedBy) == 0x000000, "Member 'GzZipline_OnInteract::InteractedBy' has a wrong offset!");
static_assert(offsetof(GzZipline_OnInteract, Interactable) == 0x000008, "Member 'GzZipline_OnInteract::Interactable' has a wrong offset!");

// Function G01.GzZipline.GetLocationAtMovementAlongZiplineProgressOnSpline
// 0x0078 (0x0078 - 0x0000)
struct GzZipline_GetLocationAtMovementAlongZiplineProgressOnSpline final
{
public:
	struct FGzZiplineMovementRuntimeData          ZiplineData;                                       // 0x0000(0x0058)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	ESplineCoordinateSpace                        CoordinateSpace;                                   // 0x0058(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3599[0x7];                                     // 0x0059(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                ReturnValue;                                       // 0x0060(0x0018)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzZipline_GetLocationAtMovementAlongZiplineProgressOnSpline) == 0x000008, "Wrong alignment on GzZipline_GetLocationAtMovementAlongZiplineProgressOnSpline");
static_assert(sizeof(GzZipline_GetLocationAtMovementAlongZiplineProgressOnSpline) == 0x000078, "Wrong size on GzZipline_GetLocationAtMovementAlongZiplineProgressOnSpline");
static_assert(offsetof(GzZipline_GetLocationAtMovementAlongZiplineProgressOnSpline, ZiplineData) == 0x000000, "Member 'GzZipline_GetLocationAtMovementAlongZiplineProgressOnSpline::ZiplineData' has a wrong offset!");
static_assert(offsetof(GzZipline_GetLocationAtMovementAlongZiplineProgressOnSpline, CoordinateSpace) == 0x000058, "Member 'GzZipline_GetLocationAtMovementAlongZiplineProgressOnSpline::CoordinateSpace' has a wrong offset!");
static_assert(offsetof(GzZipline_GetLocationAtMovementAlongZiplineProgressOnSpline, ReturnValue) == 0x000060, "Member 'GzZipline_GetLocationAtMovementAlongZiplineProgressOnSpline::ReturnValue' has a wrong offset!");

// Function G01.GzZipline.IsVertical
// 0x0001 (0x0001 - 0x0000)
struct GzZipline_IsVertical final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzZipline_IsVertical) == 0x000001, "Wrong alignment on GzZipline_IsVertical");
static_assert(sizeof(GzZipline_IsVertical) == 0x000001, "Wrong size on GzZipline_IsVertical");
static_assert(offsetof(GzZipline_IsVertical, ReturnValue) == 0x000000, "Member 'GzZipline_IsVertical::ReturnValue' has a wrong offset!");

// Function G01.GzWeaponRecoilCompensatingChecker.OnPlayerInputRotatationReceived
// 0x0010 (0x0010 - 0x0000)
struct GzWeaponRecoilCompensatingChecker_OnPlayerInputRotatationReceived final
{
public:
	const class AGzPlayerCharacter*               Player;                                            // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EGzPlayerInputRotatationType                  ViewInputType;                                     // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_359C[0x3];                                     // 0x0009(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Value;                                             // 0x000C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzWeaponRecoilCompensatingChecker_OnPlayerInputRotatationReceived) == 0x000008, "Wrong alignment on GzWeaponRecoilCompensatingChecker_OnPlayerInputRotatationReceived");
static_assert(sizeof(GzWeaponRecoilCompensatingChecker_OnPlayerInputRotatationReceived) == 0x000010, "Wrong size on GzWeaponRecoilCompensatingChecker_OnPlayerInputRotatationReceived");
static_assert(offsetof(GzWeaponRecoilCompensatingChecker_OnPlayerInputRotatationReceived, Player) == 0x000000, "Member 'GzWeaponRecoilCompensatingChecker_OnPlayerInputRotatationReceived::Player' has a wrong offset!");
static_assert(offsetof(GzWeaponRecoilCompensatingChecker_OnPlayerInputRotatationReceived, ViewInputType) == 0x000008, "Member 'GzWeaponRecoilCompensatingChecker_OnPlayerInputRotatationReceived::ViewInputType' has a wrong offset!");
static_assert(offsetof(GzWeaponRecoilCompensatingChecker_OnPlayerInputRotatationReceived, Value) == 0x00000C, "Member 'GzWeaponRecoilCompensatingChecker_OnPlayerInputRotatationReceived::Value' has a wrong offset!");

// Function G01.GzWeaponResourcesSystem.OnPawnOwnerGameplayTagChanged
// 0x000C (0x000C - 0x0000)
struct GzWeaponResourcesSystem_OnPawnOwnerGameplayTagChanged final
{
public:
	struct FGameplayTag                           GameplayTag;                                       // 0x0000(0x0008)(ConstParm, Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Count;                                             // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzWeaponResourcesSystem_OnPawnOwnerGameplayTagChanged) == 0x000004, "Wrong alignment on GzWeaponResourcesSystem_OnPawnOwnerGameplayTagChanged");
static_assert(sizeof(GzWeaponResourcesSystem_OnPawnOwnerGameplayTagChanged) == 0x00000C, "Wrong size on GzWeaponResourcesSystem_OnPawnOwnerGameplayTagChanged");
static_assert(offsetof(GzWeaponResourcesSystem_OnPawnOwnerGameplayTagChanged, GameplayTag) == 0x000000, "Member 'GzWeaponResourcesSystem_OnPawnOwnerGameplayTagChanged::GameplayTag' has a wrong offset!");
static_assert(offsetof(GzWeaponResourcesSystem_OnPawnOwnerGameplayTagChanged, Count) == 0x000008, "Member 'GzWeaponResourcesSystem_OnPawnOwnerGameplayTagChanged::Count' has a wrong offset!");

// Function G01.GzWE_UITagsAware.NotifyOnTagAdded
// 0x0028 (0x0028 - 0x0000)
struct GzWE_UITagsAware_NotifyOnTagAdded final
{
public:
	struct FGameplayTag                           NewTag;                                            // 0x0000(0x0008)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTagContainer                  CurrentTags;                                       // 0x0008(0x0020)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzWE_UITagsAware_NotifyOnTagAdded) == 0x000008, "Wrong alignment on GzWE_UITagsAware_NotifyOnTagAdded");
static_assert(sizeof(GzWE_UITagsAware_NotifyOnTagAdded) == 0x000028, "Wrong size on GzWE_UITagsAware_NotifyOnTagAdded");
static_assert(offsetof(GzWE_UITagsAware_NotifyOnTagAdded, NewTag) == 0x000000, "Member 'GzWE_UITagsAware_NotifyOnTagAdded::NewTag' has a wrong offset!");
static_assert(offsetof(GzWE_UITagsAware_NotifyOnTagAdded, CurrentTags) == 0x000008, "Member 'GzWE_UITagsAware_NotifyOnTagAdded::CurrentTags' has a wrong offset!");

// Function G01.GzWE_UITagsAware.NotifyOnTagRemoved
// 0x0028 (0x0028 - 0x0000)
struct GzWE_UITagsAware_NotifyOnTagRemoved final
{
public:
	struct FGameplayTag                           RemovedTag;                                        // 0x0000(0x0008)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTagContainer                  CurrentTags;                                       // 0x0008(0x0020)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzWE_UITagsAware_NotifyOnTagRemoved) == 0x000008, "Wrong alignment on GzWE_UITagsAware_NotifyOnTagRemoved");
static_assert(sizeof(GzWE_UITagsAware_NotifyOnTagRemoved) == 0x000028, "Wrong size on GzWE_UITagsAware_NotifyOnTagRemoved");
static_assert(offsetof(GzWE_UITagsAware_NotifyOnTagRemoved, RemovedTag) == 0x000000, "Member 'GzWE_UITagsAware_NotifyOnTagRemoved::RemovedTag' has a wrong offset!");
static_assert(offsetof(GzWE_UITagsAware_NotifyOnTagRemoved, CurrentTags) == 0x000008, "Member 'GzWE_UITagsAware_NotifyOnTagRemoved::CurrentTags' has a wrong offset!");

// Function G01.GzWE_UITagsAware.OnTagsApplicable
// 0x0028 (0x0028 - 0x0000)
struct GzWE_UITagsAware_OnTagsApplicable final
{
public:
	struct FGameplayTagContainer                  CurrentTags;                                       // 0x0000(0x0020)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	class UUserWidget*                            Widget;                                            // 0x0020(0x0008)(Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzWE_UITagsAware_OnTagsApplicable) == 0x000008, "Wrong alignment on GzWE_UITagsAware_OnTagsApplicable");
static_assert(sizeof(GzWE_UITagsAware_OnTagsApplicable) == 0x000028, "Wrong size on GzWE_UITagsAware_OnTagsApplicable");
static_assert(offsetof(GzWE_UITagsAware_OnTagsApplicable, CurrentTags) == 0x000000, "Member 'GzWE_UITagsAware_OnTagsApplicable::CurrentTags' has a wrong offset!");
static_assert(offsetof(GzWE_UITagsAware_OnTagsApplicable, Widget) == 0x000020, "Member 'GzWE_UITagsAware_OnTagsApplicable::Widget' has a wrong offset!");

// Function G01.GzWE_UITagsAware.OnTagsNotApplicable
// 0x0028 (0x0028 - 0x0000)
struct GzWE_UITagsAware_OnTagsNotApplicable final
{
public:
	struct FGameplayTagContainer                  CurrentTags;                                       // 0x0000(0x0020)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	class UUserWidget*                            Widget;                                            // 0x0020(0x0008)(Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzWE_UITagsAware_OnTagsNotApplicable) == 0x000008, "Wrong alignment on GzWE_UITagsAware_OnTagsNotApplicable");
static_assert(sizeof(GzWE_UITagsAware_OnTagsNotApplicable) == 0x000028, "Wrong size on GzWE_UITagsAware_OnTagsNotApplicable");
static_assert(offsetof(GzWE_UITagsAware_OnTagsNotApplicable, CurrentTags) == 0x000000, "Member 'GzWE_UITagsAware_OnTagsNotApplicable::CurrentTags' has a wrong offset!");
static_assert(offsetof(GzWE_UITagsAware_OnTagsNotApplicable, Widget) == 0x000020, "Member 'GzWE_UITagsAware_OnTagsNotApplicable::Widget' has a wrong offset!");

// Function G01.GzWhenObjective.MakeWhenAnyObjective
// 0x0018 (0x0018 - 0x0000)
struct GzWhenObjective_MakeWhenAnyObjective final
{
public:
	class AGzAdvancedMission*                     Mission;                                           // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UGzCondition*                           Param_Condition;                                   // 0x0008(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UGzObjective*                           ReturnValue;                                       // 0x0010(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzWhenObjective_MakeWhenAnyObjective) == 0x000008, "Wrong alignment on GzWhenObjective_MakeWhenAnyObjective");
static_assert(sizeof(GzWhenObjective_MakeWhenAnyObjective) == 0x000018, "Wrong size on GzWhenObjective_MakeWhenAnyObjective");
static_assert(offsetof(GzWhenObjective_MakeWhenAnyObjective, Mission) == 0x000000, "Member 'GzWhenObjective_MakeWhenAnyObjective::Mission' has a wrong offset!");
static_assert(offsetof(GzWhenObjective_MakeWhenAnyObjective, Param_Condition) == 0x000008, "Member 'GzWhenObjective_MakeWhenAnyObjective::Param_Condition' has a wrong offset!");
static_assert(offsetof(GzWhenObjective_MakeWhenAnyObjective, ReturnValue) == 0x000010, "Member 'GzWhenObjective_MakeWhenAnyObjective::ReturnValue' has a wrong offset!");

// Function G01.GzWhenObjective.MakeWhenNegativeObjective
// 0x0018 (0x0018 - 0x0000)
struct GzWhenObjective_MakeWhenNegativeObjective final
{
public:
	class AGzAdvancedMission*                     Mission;                                           // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UGzCondition*                           Param_Condition;                                   // 0x0008(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UGzObjective*                           ReturnValue;                                       // 0x0010(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzWhenObjective_MakeWhenNegativeObjective) == 0x000008, "Wrong alignment on GzWhenObjective_MakeWhenNegativeObjective");
static_assert(sizeof(GzWhenObjective_MakeWhenNegativeObjective) == 0x000018, "Wrong size on GzWhenObjective_MakeWhenNegativeObjective");
static_assert(offsetof(GzWhenObjective_MakeWhenNegativeObjective, Mission) == 0x000000, "Member 'GzWhenObjective_MakeWhenNegativeObjective::Mission' has a wrong offset!");
static_assert(offsetof(GzWhenObjective_MakeWhenNegativeObjective, Param_Condition) == 0x000008, "Member 'GzWhenObjective_MakeWhenNegativeObjective::Param_Condition' has a wrong offset!");
static_assert(offsetof(GzWhenObjective_MakeWhenNegativeObjective, ReturnValue) == 0x000010, "Member 'GzWhenObjective_MakeWhenNegativeObjective::ReturnValue' has a wrong offset!");

// Function G01.GzWhenObjective.MakeWhenPositiveObjective
// 0x0018 (0x0018 - 0x0000)
struct GzWhenObjective_MakeWhenPositiveObjective final
{
public:
	class AGzAdvancedMission*                     Mission;                                           // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UGzCondition*                           Param_Condition;                                   // 0x0008(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UGzObjective*                           ReturnValue;                                       // 0x0010(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzWhenObjective_MakeWhenPositiveObjective) == 0x000008, "Wrong alignment on GzWhenObjective_MakeWhenPositiveObjective");
static_assert(sizeof(GzWhenObjective_MakeWhenPositiveObjective) == 0x000018, "Wrong size on GzWhenObjective_MakeWhenPositiveObjective");
static_assert(offsetof(GzWhenObjective_MakeWhenPositiveObjective, Mission) == 0x000000, "Member 'GzWhenObjective_MakeWhenPositiveObjective::Mission' has a wrong offset!");
static_assert(offsetof(GzWhenObjective_MakeWhenPositiveObjective, Param_Condition) == 0x000008, "Member 'GzWhenObjective_MakeWhenPositiveObjective::Param_Condition' has a wrong offset!");
static_assert(offsetof(GzWhenObjective_MakeWhenPositiveObjective, ReturnValue) == 0x000010, "Member 'GzWhenObjective_MakeWhenPositiveObjective::ReturnValue' has a wrong offset!");

// Function G01.GzWingsuitMeshActor.GetOwnerCharacter
// 0x0008 (0x0008 - 0x0000)
struct GzWingsuitMeshActor_GetOwnerCharacter final
{
public:
	class AGzMultiPartCharacter*                  ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzWingsuitMeshActor_GetOwnerCharacter) == 0x000008, "Wrong alignment on GzWingsuitMeshActor_GetOwnerCharacter");
static_assert(sizeof(GzWingsuitMeshActor_GetOwnerCharacter) == 0x000008, "Wrong size on GzWingsuitMeshActor_GetOwnerCharacter");
static_assert(offsetof(GzWingsuitMeshActor_GetOwnerCharacter, ReturnValue) == 0x000000, "Member 'GzWingsuitMeshActor_GetOwnerCharacter::ReturnValue' has a wrong offset!");

// Function G01.GzWingsuitMeshActor.SetJetpackBoostVisual
// 0x0010 (0x0010 - 0x0000)
struct GzWingsuitMeshActor_SetJetpackBoostVisual final
{
public:
	class UStaticMesh*                            JetpackBoostVisual;                                // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShow;                                             // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_35AB[0x7];                                     // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GzWingsuitMeshActor_SetJetpackBoostVisual) == 0x000008, "Wrong alignment on GzWingsuitMeshActor_SetJetpackBoostVisual");
static_assert(sizeof(GzWingsuitMeshActor_SetJetpackBoostVisual) == 0x000010, "Wrong size on GzWingsuitMeshActor_SetJetpackBoostVisual");
static_assert(offsetof(GzWingsuitMeshActor_SetJetpackBoostVisual, JetpackBoostVisual) == 0x000000, "Member 'GzWingsuitMeshActor_SetJetpackBoostVisual::JetpackBoostVisual' has a wrong offset!");
static_assert(offsetof(GzWingsuitMeshActor_SetJetpackBoostVisual, bShow) == 0x000008, "Member 'GzWingsuitMeshActor_SetJetpackBoostVisual::bShow' has a wrong offset!");

// Function G01.GzWorldVisibilityBlendActor.SetState
// 0x0001 (0x0001 - 0x0000)
struct GzWorldVisibilityBlendActor_SetState final
{
public:
	EDepthStencilValue                            Value;                                             // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzWorldVisibilityBlendActor_SetState) == 0x000001, "Wrong alignment on GzWorldVisibilityBlendActor_SetState");
static_assert(sizeof(GzWorldVisibilityBlendActor_SetState) == 0x000001, "Wrong size on GzWorldVisibilityBlendActor_SetState");
static_assert(offsetof(GzWorldVisibilityBlendActor_SetState, Value) == 0x000000, "Member 'GzWorldVisibilityBlendActor_SetState::Value' has a wrong offset!");

// Function G01.GzWorldVisibilityBlendActor.SetStateSeparateForLimb
// 0x0002 (0x0002 - 0x0000)
struct GzWorldVisibilityBlendActor_SetStateSeparateForLimb final
{
public:
	EDepthStencilValue                            Value;                                             // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EDepthStencilValue                            ValueForLimbs;                                     // 0x0001(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzWorldVisibilityBlendActor_SetStateSeparateForLimb) == 0x000001, "Wrong alignment on GzWorldVisibilityBlendActor_SetStateSeparateForLimb");
static_assert(sizeof(GzWorldVisibilityBlendActor_SetStateSeparateForLimb) == 0x000002, "Wrong size on GzWorldVisibilityBlendActor_SetStateSeparateForLimb");
static_assert(offsetof(GzWorldVisibilityBlendActor_SetStateSeparateForLimb, Value) == 0x000000, "Member 'GzWorldVisibilityBlendActor_SetStateSeparateForLimb::Value' has a wrong offset!");
static_assert(offsetof(GzWorldVisibilityBlendActor_SetStateSeparateForLimb, ValueForLimbs) == 0x000001, "Member 'GzWorldVisibilityBlendActor_SetStateSeparateForLimb::ValueForLimbs' has a wrong offset!");

// Function G01.GzWorldZone.GetMetaDataByClass
// 0x0010 (0x0010 - 0x0000)
struct GzWorldZone_GetMetaDataByClass final
{
public:
	TSubclassOf<class UGzWorldZoneMetadata>       MetaDataClass;                                     // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UGzWorldZoneMetadata*                   ReturnValue;                                       // 0x0008(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzWorldZone_GetMetaDataByClass) == 0x000008, "Wrong alignment on GzWorldZone_GetMetaDataByClass");
static_assert(sizeof(GzWorldZone_GetMetaDataByClass) == 0x000010, "Wrong size on GzWorldZone_GetMetaDataByClass");
static_assert(offsetof(GzWorldZone_GetMetaDataByClass, MetaDataClass) == 0x000000, "Member 'GzWorldZone_GetMetaDataByClass::MetaDataClass' has a wrong offset!");
static_assert(offsetof(GzWorldZone_GetMetaDataByClass, ReturnValue) == 0x000008, "Member 'GzWorldZone_GetMetaDataByClass::ReturnValue' has a wrong offset!");

// Function G01.GzWorldZone.IsInBorders
// 0x0018 (0x0018 - 0x0000)
struct GzWorldZone_IsInBorders final
{
public:
	struct FVector2D                              Position;                                          // 0x0000(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0010(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_35AD[0x7];                                     // 0x0011(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GzWorldZone_IsInBorders) == 0x000008, "Wrong alignment on GzWorldZone_IsInBorders");
static_assert(sizeof(GzWorldZone_IsInBorders) == 0x000018, "Wrong size on GzWorldZone_IsInBorders");
static_assert(offsetof(GzWorldZone_IsInBorders, Position) == 0x000000, "Member 'GzWorldZone_IsInBorders::Position' has a wrong offset!");
static_assert(offsetof(GzWorldZone_IsInBorders, ReturnValue) == 0x000010, "Member 'GzWorldZone_IsInBorders::ReturnValue' has a wrong offset!");

// Function G01.GzWorldZoneTrackingComponent.GetTrackedWorldZone
// 0x0010 (0x0010 - 0x0000)
struct GzWorldZoneTrackingComponent_GetTrackedWorldZone final
{
public:
	class FName                                   Layer;                                             // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	const class UGzWorldZone*                     ReturnValue;                                       // 0x0008(0x0008)(ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzWorldZoneTrackingComponent_GetTrackedWorldZone) == 0x000008, "Wrong alignment on GzWorldZoneTrackingComponent_GetTrackedWorldZone");
static_assert(sizeof(GzWorldZoneTrackingComponent_GetTrackedWorldZone) == 0x000010, "Wrong size on GzWorldZoneTrackingComponent_GetTrackedWorldZone");
static_assert(offsetof(GzWorldZoneTrackingComponent_GetTrackedWorldZone, Layer) == 0x000000, "Member 'GzWorldZoneTrackingComponent_GetTrackedWorldZone::Layer' has a wrong offset!");
static_assert(offsetof(GzWorldZoneTrackingComponent_GetTrackedWorldZone, ReturnValue) == 0x000008, "Member 'GzWorldZoneTrackingComponent_GetTrackedWorldZone::ReturnValue' has a wrong offset!");

// Function G01.GzWorldZoneType.GetAssetId
// 0x0008 (0x0008 - 0x0000)
struct GzWorldZoneType_GetAssetId final
{
public:
	class FName                                   ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzWorldZoneType_GetAssetId) == 0x000004, "Wrong alignment on GzWorldZoneType_GetAssetId");
static_assert(sizeof(GzWorldZoneType_GetAssetId) == 0x000008, "Wrong size on GzWorldZoneType_GetAssetId");
static_assert(offsetof(GzWorldZoneType_GetAssetId, ReturnValue) == 0x000000, "Member 'GzWorldZoneType_GetAssetId::ReturnValue' has a wrong offset!");

// Function G01.GzXR_MissionCompleteRedeployModifier.OnMissionStateChanged
// 0x0020 (0x0020 - 0x0000)
struct GzXR_MissionCompleteRedeployModifier_OnMissionStateChanged final
{
public:
	class AGzMission*                             Mission;                                           // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGzMissionState                        OldState;                                          // 0x0008(0x000C)(Parm, NoDestructor, NativeAccessSpecifierPublic)
	struct FGzMissionState                        MissionState;                                      // 0x0014(0x000C)(Parm, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzXR_MissionCompleteRedeployModifier_OnMissionStateChanged) == 0x000008, "Wrong alignment on GzXR_MissionCompleteRedeployModifier_OnMissionStateChanged");
static_assert(sizeof(GzXR_MissionCompleteRedeployModifier_OnMissionStateChanged) == 0x000020, "Wrong size on GzXR_MissionCompleteRedeployModifier_OnMissionStateChanged");
static_assert(offsetof(GzXR_MissionCompleteRedeployModifier_OnMissionStateChanged, Mission) == 0x000000, "Member 'GzXR_MissionCompleteRedeployModifier_OnMissionStateChanged::Mission' has a wrong offset!");
static_assert(offsetof(GzXR_MissionCompleteRedeployModifier_OnMissionStateChanged, OldState) == 0x000008, "Member 'GzXR_MissionCompleteRedeployModifier_OnMissionStateChanged::OldState' has a wrong offset!");
static_assert(offsetof(GzXR_MissionCompleteRedeployModifier_OnMissionStateChanged, MissionState) == 0x000014, "Member 'GzXR_MissionCompleteRedeployModifier_OnMissionStateChanged::MissionState' has a wrong offset!");

// Function G01.GzZoneTrackingComponent.OnOverloadStageChanged
// 0x0004 (0x0004 - 0x0000)
struct GzZoneTrackingComponent_OnOverloadStageChanged final
{
public:
	int32                                         NewStageIndex;                                     // 0x0000(0x0004)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzZoneTrackingComponent_OnOverloadStageChanged) == 0x000004, "Wrong alignment on GzZoneTrackingComponent_OnOverloadStageChanged");
static_assert(sizeof(GzZoneTrackingComponent_OnOverloadStageChanged) == 0x000004, "Wrong size on GzZoneTrackingComponent_OnOverloadStageChanged");
static_assert(offsetof(GzZoneTrackingComponent_OnOverloadStageChanged, NewStageIndex) == 0x000000, "Member 'GzZoneTrackingComponent_OnOverloadStageChanged::NewStageIndex' has a wrong offset!");

// Function G01.GzZoneTrackingComponent.GetClosestPointToSafety
// 0x0018 (0x0018 - 0x0000)
struct GzZoneTrackingComponent_GetClosestPointToSafety final
{
public:
	struct FVector2D                              OutPosition;                                       // 0x0000(0x0010)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0010(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_35BF[0x7];                                     // 0x0011(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GzZoneTrackingComponent_GetClosestPointToSafety) == 0x000008, "Wrong alignment on GzZoneTrackingComponent_GetClosestPointToSafety");
static_assert(sizeof(GzZoneTrackingComponent_GetClosestPointToSafety) == 0x000018, "Wrong size on GzZoneTrackingComponent_GetClosestPointToSafety");
static_assert(offsetof(GzZoneTrackingComponent_GetClosestPointToSafety, OutPosition) == 0x000000, "Member 'GzZoneTrackingComponent_GetClosestPointToSafety::OutPosition' has a wrong offset!");
static_assert(offsetof(GzZoneTrackingComponent_GetClosestPointToSafety, ReturnValue) == 0x000010, "Member 'GzZoneTrackingComponent_GetClosestPointToSafety::ReturnValue' has a wrong offset!");

// Function G01.GzZoneTrackingComponent.GetClosestZoneCenter
// 0x0018 (0x0018 - 0x0000)
struct GzZoneTrackingComponent_GetClosestZoneCenter final
{
public:
	struct FVector2D                              OutCenter;                                         // 0x0000(0x0010)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0010(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_35C0[0x7];                                     // 0x0011(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GzZoneTrackingComponent_GetClosestZoneCenter) == 0x000008, "Wrong alignment on GzZoneTrackingComponent_GetClosestZoneCenter");
static_assert(sizeof(GzZoneTrackingComponent_GetClosestZoneCenter) == 0x000018, "Wrong size on GzZoneTrackingComponent_GetClosestZoneCenter");
static_assert(offsetof(GzZoneTrackingComponent_GetClosestZoneCenter, OutCenter) == 0x000000, "Member 'GzZoneTrackingComponent_GetClosestZoneCenter::OutCenter' has a wrong offset!");
static_assert(offsetof(GzZoneTrackingComponent_GetClosestZoneCenter, ReturnValue) == 0x000010, "Member 'GzZoneTrackingComponent_GetClosestZoneCenter::ReturnValue' has a wrong offset!");

// Function G01.GzZoneTrackingComponent.GetDistanceToZoneEdge
// 0x0004 (0x0004 - 0x0000)
struct GzZoneTrackingComponent_GetDistanceToZoneEdge final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzZoneTrackingComponent_GetDistanceToZoneEdge) == 0x000004, "Wrong alignment on GzZoneTrackingComponent_GetDistanceToZoneEdge");
static_assert(sizeof(GzZoneTrackingComponent_GetDistanceToZoneEdge) == 0x000004, "Wrong size on GzZoneTrackingComponent_GetDistanceToZoneEdge");
static_assert(offsetof(GzZoneTrackingComponent_GetDistanceToZoneEdge, ReturnValue) == 0x000000, "Member 'GzZoneTrackingComponent_GetDistanceToZoneEdge::ReturnValue' has a wrong offset!");

// Function G01.GzZoneTrackingComponent.GetTrackedPosition
// 0x0018 (0x0018 - 0x0000)
struct GzZoneTrackingComponent_GetTrackedPosition final
{
public:
	struct FVector                                ReturnValue;                                       // 0x0000(0x0018)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzZoneTrackingComponent_GetTrackedPosition) == 0x000008, "Wrong alignment on GzZoneTrackingComponent_GetTrackedPosition");
static_assert(sizeof(GzZoneTrackingComponent_GetTrackedPosition) == 0x000018, "Wrong size on GzZoneTrackingComponent_GetTrackedPosition");
static_assert(offsetof(GzZoneTrackingComponent_GetTrackedPosition, ReturnValue) == 0x000000, "Member 'GzZoneTrackingComponent_GetTrackedPosition::ReturnValue' has a wrong offset!");

// Function G01.GzZoneTriangulationTaskRunner.OnZoneStartOverload
// 0x0008 (0x0008 - 0x0000)
struct GzZoneTriangulationTaskRunner_OnZoneStartOverload final
{
public:
	class AGzBattleRoyaleZone*                    Zone;                                              // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzZoneTriangulationTaskRunner_OnZoneStartOverload) == 0x000008, "Wrong alignment on GzZoneTriangulationTaskRunner_OnZoneStartOverload");
static_assert(sizeof(GzZoneTriangulationTaskRunner_OnZoneStartOverload) == 0x000008, "Wrong size on GzZoneTriangulationTaskRunner_OnZoneStartOverload");
static_assert(offsetof(GzZoneTriangulationTaskRunner_OnZoneStartOverload, Zone) == 0x000000, "Member 'GzZoneTriangulationTaskRunner_OnZoneStartOverload::Zone' has a wrong offset!");

// Function G01.Gz_BTService_CheckTargetDistance.GetBlackboardComponent
// 0x0008 (0x0008 - 0x0000)
struct Gz_BTService_CheckTargetDistance_GetBlackboardComponent final
{
public:
	class UBlackboardComponent*                   ReturnValue;                                       // 0x0000(0x0008)(ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(Gz_BTService_CheckTargetDistance_GetBlackboardComponent) == 0x000008, "Wrong alignment on Gz_BTService_CheckTargetDistance_GetBlackboardComponent");
static_assert(sizeof(Gz_BTService_CheckTargetDistance_GetBlackboardComponent) == 0x000008, "Wrong size on Gz_BTService_CheckTargetDistance_GetBlackboardComponent");
static_assert(offsetof(Gz_BTService_CheckTargetDistance_GetBlackboardComponent, ReturnValue) == 0x000000, "Member 'Gz_BTService_CheckTargetDistance_GetBlackboardComponent::ReturnValue' has a wrong offset!");

// Function G01.Gz_BTService_CheckTargetDistance.GetGzAIController
// 0x0008 (0x0008 - 0x0000)
struct Gz_BTService_CheckTargetDistance_GetGzAIController final
{
public:
	class AGzAIController*                        ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(Gz_BTService_CheckTargetDistance_GetGzAIController) == 0x000008, "Wrong alignment on Gz_BTService_CheckTargetDistance_GetGzAIController");
static_assert(sizeof(Gz_BTService_CheckTargetDistance_GetGzAIController) == 0x000008, "Wrong size on Gz_BTService_CheckTargetDistance_GetGzAIController");
static_assert(offsetof(Gz_BTService_CheckTargetDistance_GetGzAIController, ReturnValue) == 0x000000, "Member 'Gz_BTService_CheckTargetDistance_GetGzAIController::ReturnValue' has a wrong offset!");

// Function G01.Gz_BTTask_FlyTo.FindFlightPath
// 0x0020 (0x0020 - 0x0000)
struct Gz_BTTask_FlyTo_FindFlightPath final
{
public:
	const class AGzAICharacter*                   TargetAI;                                          // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	const class AActor*                           DestinationActor;                                  // 0x0008(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FVector>                        ReturnValue;                                       // 0x0010(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(Gz_BTTask_FlyTo_FindFlightPath) == 0x000008, "Wrong alignment on Gz_BTTask_FlyTo_FindFlightPath");
static_assert(sizeof(Gz_BTTask_FlyTo_FindFlightPath) == 0x000020, "Wrong size on Gz_BTTask_FlyTo_FindFlightPath");
static_assert(offsetof(Gz_BTTask_FlyTo_FindFlightPath, TargetAI) == 0x000000, "Member 'Gz_BTTask_FlyTo_FindFlightPath::TargetAI' has a wrong offset!");
static_assert(offsetof(Gz_BTTask_FlyTo_FindFlightPath, DestinationActor) == 0x000008, "Member 'Gz_BTTask_FlyTo_FindFlightPath::DestinationActor' has a wrong offset!");
static_assert(offsetof(Gz_BTTask_FlyTo_FindFlightPath, ReturnValue) == 0x000010, "Member 'Gz_BTTask_FlyTo_FindFlightPath::ReturnValue' has a wrong offset!");

// Function G01.InterestPoint.SetPointFree
// 0x0001 (0x0001 - 0x0000)
struct InterestPoint_SetPointFree final
{
public:
	bool                                          NewFree;                                           // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(InterestPoint_SetPointFree) == 0x000001, "Wrong alignment on InterestPoint_SetPointFree");
static_assert(sizeof(InterestPoint_SetPointFree) == 0x000001, "Wrong size on InterestPoint_SetPointFree");
static_assert(offsetof(InterestPoint_SetPointFree, NewFree) == 0x000000, "Member 'InterestPoint_SetPointFree::NewFree' has a wrong offset!");

// Function G01.LocomotionCharacterInterface.SetMovementAction
// 0x0001 (0x0001 - 0x0000)
struct LocomotionCharacterInterface_SetMovementAction final
{
public:
	ELocomotionMovementAction                     MovementAction;                                    // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LocomotionCharacterInterface_SetMovementAction) == 0x000001, "Wrong alignment on LocomotionCharacterInterface_SetMovementAction");
static_assert(sizeof(LocomotionCharacterInterface_SetMovementAction) == 0x000001, "Wrong size on LocomotionCharacterInterface_SetMovementAction");
static_assert(offsetof(LocomotionCharacterInterface_SetMovementAction, MovementAction) == 0x000000, "Member 'LocomotionCharacterInterface_SetMovementAction::MovementAction' has a wrong offset!");

// Function G01.LocomotionCharacterInterface.SetOverlayState
// 0x0001 (0x0001 - 0x0000)
struct LocomotionCharacterInterface_SetOverlayState final
{
public:
	ELocomotionOverlayState                       OverlayState;                                      // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LocomotionCharacterInterface_SetOverlayState) == 0x000001, "Wrong alignment on LocomotionCharacterInterface_SetOverlayState");
static_assert(sizeof(LocomotionCharacterInterface_SetOverlayState) == 0x000001, "Wrong size on LocomotionCharacterInterface_SetOverlayState");
static_assert(offsetof(LocomotionCharacterInterface_SetOverlayState, OverlayState) == 0x000000, "Member 'LocomotionCharacterInterface_SetOverlayState::OverlayState' has a wrong offset!");

// Function G01.LocomotionCharacterInterface.GetCapsule
// 0x0008 (0x0008 - 0x0000)
struct LocomotionCharacterInterface_GetCapsule final
{
public:
	class UCapsuleComponent*                      ReturnValue;                                       // 0x0000(0x0008)(ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LocomotionCharacterInterface_GetCapsule) == 0x000008, "Wrong alignment on LocomotionCharacterInterface_GetCapsule");
static_assert(sizeof(LocomotionCharacterInterface_GetCapsule) == 0x000008, "Wrong size on LocomotionCharacterInterface_GetCapsule");
static_assert(offsetof(LocomotionCharacterInterface_GetCapsule, ReturnValue) == 0x000000, "Member 'LocomotionCharacterInterface_GetCapsule::ReturnValue' has a wrong offset!");

// Function G01.LocomotionCharacterInterface.GetCurrentStates
// 0x0009 (0x0009 - 0x0000)
struct LocomotionCharacterInterface_GetCurrentStates final
{
public:
	struct FLocomotionCurrentStates               States;                                            // 0x0000(0x0009)(Parm, OutParm, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(LocomotionCharacterInterface_GetCurrentStates) == 0x000001, "Wrong alignment on LocomotionCharacterInterface_GetCurrentStates");
static_assert(sizeof(LocomotionCharacterInterface_GetCurrentStates) == 0x000009, "Wrong size on LocomotionCharacterInterface_GetCurrentStates");
static_assert(offsetof(LocomotionCharacterInterface_GetCurrentStates, States) == 0x000000, "Member 'LocomotionCharacterInterface_GetCurrentStates::States' has a wrong offset!");

// Function G01.LocomotionCharacterInterface.GetEssentialValues
// 0x0078 (0x0078 - 0x0000)
struct LocomotionCharacterInterface_GetEssentialValues final
{
public:
	struct FLocomotionEssentialValues             Values;                                            // 0x0000(0x0078)(Parm, OutParm, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(LocomotionCharacterInterface_GetEssentialValues) == 0x000008, "Wrong alignment on LocomotionCharacterInterface_GetEssentialValues");
static_assert(sizeof(LocomotionCharacterInterface_GetEssentialValues) == 0x000078, "Wrong size on LocomotionCharacterInterface_GetEssentialValues");
static_assert(offsetof(LocomotionCharacterInterface_GetEssentialValues, Values) == 0x000000, "Member 'LocomotionCharacterInterface_GetEssentialValues::Values' has a wrong offset!");

// Function G01.LocomotionCharacterInterface.GetHeldObjectMesh
// 0x0008 (0x0008 - 0x0000)
struct LocomotionCharacterInterface_GetHeldObjectMesh final
{
public:
	class UStaticMeshComponent*                   ReturnValue;                                       // 0x0000(0x0008)(ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LocomotionCharacterInterface_GetHeldObjectMesh) == 0x000008, "Wrong alignment on LocomotionCharacterInterface_GetHeldObjectMesh");
static_assert(sizeof(LocomotionCharacterInterface_GetHeldObjectMesh) == 0x000008, "Wrong size on LocomotionCharacterInterface_GetHeldObjectMesh");
static_assert(offsetof(LocomotionCharacterInterface_GetHeldObjectMesh, ReturnValue) == 0x000000, "Member 'LocomotionCharacterInterface_GetHeldObjectMesh::ReturnValue' has a wrong offset!");

// Function G01.LocomotionCharacterInterface.GetHeldObjectRoot
// 0x0008 (0x0008 - 0x0000)
struct LocomotionCharacterInterface_GetHeldObjectRoot final
{
public:
	class USceneComponent*                        ReturnValue;                                       // 0x0000(0x0008)(ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LocomotionCharacterInterface_GetHeldObjectRoot) == 0x000008, "Wrong alignment on LocomotionCharacterInterface_GetHeldObjectRoot");
static_assert(sizeof(LocomotionCharacterInterface_GetHeldObjectRoot) == 0x000008, "Wrong size on LocomotionCharacterInterface_GetHeldObjectRoot");
static_assert(offsetof(LocomotionCharacterInterface_GetHeldObjectRoot, ReturnValue) == 0x000000, "Member 'LocomotionCharacterInterface_GetHeldObjectRoot::ReturnValue' has a wrong offset!");

// Function G01.LocomotionCharacterInterface.GetHeldObjectSkeletalMesh
// 0x0008 (0x0008 - 0x0000)
struct LocomotionCharacterInterface_GetHeldObjectSkeletalMesh final
{
public:
	class USkeletalMeshComponent*                 ReturnValue;                                       // 0x0000(0x0008)(ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LocomotionCharacterInterface_GetHeldObjectSkeletalMesh) == 0x000008, "Wrong alignment on LocomotionCharacterInterface_GetHeldObjectSkeletalMesh");
static_assert(sizeof(LocomotionCharacterInterface_GetHeldObjectSkeletalMesh) == 0x000008, "Wrong size on LocomotionCharacterInterface_GetHeldObjectSkeletalMesh");
static_assert(offsetof(LocomotionCharacterInterface_GetHeldObjectSkeletalMesh, ReturnValue) == 0x000000, "Member 'LocomotionCharacterInterface_GetHeldObjectSkeletalMesh::ReturnValue' has a wrong offset!");

// Function G01.LocomotionCharacterInterface.GetMovement
// 0x0008 (0x0008 - 0x0000)
struct LocomotionCharacterInterface_GetMovement final
{
public:
	class UCharacterMovementComponent*            ReturnValue;                                       // 0x0000(0x0008)(ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LocomotionCharacterInterface_GetMovement) == 0x000008, "Wrong alignment on LocomotionCharacterInterface_GetMovement");
static_assert(sizeof(LocomotionCharacterInterface_GetMovement) == 0x000008, "Wrong size on LocomotionCharacterInterface_GetMovement");
static_assert(offsetof(LocomotionCharacterInterface_GetMovement, ReturnValue) == 0x000000, "Member 'LocomotionCharacterInterface_GetMovement::ReturnValue' has a wrong offset!");

// Function G01.LocomotionCharacterInterface.GetPawnMesh
// 0x0008 (0x0008 - 0x0000)
struct LocomotionCharacterInterface_GetPawnMesh final
{
public:
	class USkeletalMeshComponent*                 ReturnValue;                                       // 0x0000(0x0008)(ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LocomotionCharacterInterface_GetPawnMesh) == 0x000008, "Wrong alignment on LocomotionCharacterInterface_GetPawnMesh");
static_assert(sizeof(LocomotionCharacterInterface_GetPawnMesh) == 0x000008, "Wrong size on LocomotionCharacterInterface_GetPawnMesh");
static_assert(offsetof(LocomotionCharacterInterface_GetPawnMesh, ReturnValue) == 0x000000, "Member 'LocomotionCharacterInterface_GetPawnMesh::ReturnValue' has a wrong offset!");

// Function G01.LocomotionComponent.AttachToHand
// 0x0038 (0x0038 - 0x0000)
struct LocomotionComponent_AttachToHand final
{
public:
	class UStaticMesh*                            NewStaticMesh;                                     // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USkeletalMesh*                          NewSkeletalMesh;                                   // 0x0008(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UClass*                                 AnimInstanceClass;                                 // 0x0010(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bLeftHand;                                         // 0x0018(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_35CF[0x7];                                     // 0x0019(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                Offset;                                            // 0x0020(0x0018)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LocomotionComponent_AttachToHand) == 0x000008, "Wrong alignment on LocomotionComponent_AttachToHand");
static_assert(sizeof(LocomotionComponent_AttachToHand) == 0x000038, "Wrong size on LocomotionComponent_AttachToHand");
static_assert(offsetof(LocomotionComponent_AttachToHand, NewStaticMesh) == 0x000000, "Member 'LocomotionComponent_AttachToHand::NewStaticMesh' has a wrong offset!");
static_assert(offsetof(LocomotionComponent_AttachToHand, NewSkeletalMesh) == 0x000008, "Member 'LocomotionComponent_AttachToHand::NewSkeletalMesh' has a wrong offset!");
static_assert(offsetof(LocomotionComponent_AttachToHand, AnimInstanceClass) == 0x000010, "Member 'LocomotionComponent_AttachToHand::AnimInstanceClass' has a wrong offset!");
static_assert(offsetof(LocomotionComponent_AttachToHand, bLeftHand) == 0x000018, "Member 'LocomotionComponent_AttachToHand::bLeftHand' has a wrong offset!");
static_assert(offsetof(LocomotionComponent_AttachToHand, Offset) == 0x000020, "Member 'LocomotionComponent_AttachToHand::Offset' has a wrong offset!");

// Function G01.LocomotionComponent.GetRotationMode
// 0x0001 (0x0001 - 0x0000)
struct LocomotionComponent_GetRotationMode final
{
public:
	ELocomotionRotationMode                       ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LocomotionComponent_GetRotationMode) == 0x000001, "Wrong alignment on LocomotionComponent_GetRotationMode");
static_assert(sizeof(LocomotionComponent_GetRotationMode) == 0x000001, "Wrong size on LocomotionComponent_GetRotationMode");
static_assert(offsetof(LocomotionComponent_GetRotationMode, ReturnValue) == 0x000000, "Member 'LocomotionComponent_GetRotationMode::ReturnValue' has a wrong offset!");

// Function G01.LocomotionComponent.GetStance
// 0x0001 (0x0001 - 0x0000)
struct LocomotionComponent_GetStance final
{
public:
	ELocomotionStance                             ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LocomotionComponent_GetStance) == 0x000001, "Wrong alignment on LocomotionComponent_GetStance");
static_assert(sizeof(LocomotionComponent_GetStance) == 0x000001, "Wrong size on LocomotionComponent_GetStance");
static_assert(offsetof(LocomotionComponent_GetStance, ReturnValue) == 0x000000, "Member 'LocomotionComponent_GetStance::ReturnValue' has a wrong offset!");

// Function G01.LocomotionComponent.Initialize
// 0x0010 (0x0010 - 0x0000)
struct LocomotionComponent_Initialize final
{
public:
	const class AActor*                           LocomotionCharacter;                               // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_35D0[0x7];                                     // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(LocomotionComponent_Initialize) == 0x000008, "Wrong alignment on LocomotionComponent_Initialize");
static_assert(sizeof(LocomotionComponent_Initialize) == 0x000010, "Wrong size on LocomotionComponent_Initialize");
static_assert(offsetof(LocomotionComponent_Initialize, LocomotionCharacter) == 0x000000, "Member 'LocomotionComponent_Initialize::LocomotionCharacter' has a wrong offset!");
static_assert(offsetof(LocomotionComponent_Initialize, ReturnValue) == 0x000008, "Member 'LocomotionComponent_Initialize::ReturnValue' has a wrong offset!");

// Function G01.LocomotionComponent.OnMovementActionChanged
// 0x0001 (0x0001 - 0x0000)
struct LocomotionComponent_OnMovementActionChanged final
{
public:
	ELocomotionMovementAction                     PreviousAction;                                    // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LocomotionComponent_OnMovementActionChanged) == 0x000001, "Wrong alignment on LocomotionComponent_OnMovementActionChanged");
static_assert(sizeof(LocomotionComponent_OnMovementActionChanged) == 0x000001, "Wrong size on LocomotionComponent_OnMovementActionChanged");
static_assert(offsetof(LocomotionComponent_OnMovementActionChanged, PreviousAction) == 0x000000, "Member 'LocomotionComponent_OnMovementActionChanged::PreviousAction' has a wrong offset!");

// Function G01.LocomotionComponent.OnMovementModeChanged
// 0x0010 (0x0010 - 0x0000)
struct LocomotionComponent_OnMovementModeChanged final
{
public:
	class ACharacter*                             C;                                                 // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EMovementMode                                 PrevMovementMode;                                  // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         PreviousCustomMode;                                // 0x0009(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_35D1[0x6];                                     // 0x000A(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(LocomotionComponent_OnMovementModeChanged) == 0x000008, "Wrong alignment on LocomotionComponent_OnMovementModeChanged");
static_assert(sizeof(LocomotionComponent_OnMovementModeChanged) == 0x000010, "Wrong size on LocomotionComponent_OnMovementModeChanged");
static_assert(offsetof(LocomotionComponent_OnMovementModeChanged, C) == 0x000000, "Member 'LocomotionComponent_OnMovementModeChanged::C' has a wrong offset!");
static_assert(offsetof(LocomotionComponent_OnMovementModeChanged, PrevMovementMode) == 0x000008, "Member 'LocomotionComponent_OnMovementModeChanged::PrevMovementMode' has a wrong offset!");
static_assert(offsetof(LocomotionComponent_OnMovementModeChanged, PreviousCustomMode) == 0x000009, "Member 'LocomotionComponent_OnMovementModeChanged::PreviousCustomMode' has a wrong offset!");

// Function G01.LocomotionComponent.Roll
// 0x0004 (0x0004 - 0x0000)
struct LocomotionComponent_Roll final
{
public:
	float                                         PlayRate;                                          // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LocomotionComponent_Roll) == 0x000004, "Wrong alignment on LocomotionComponent_Roll");
static_assert(sizeof(LocomotionComponent_Roll) == 0x000004, "Wrong size on LocomotionComponent_Roll");
static_assert(offsetof(LocomotionComponent_Roll, PlayRate) == 0x000000, "Member 'LocomotionComponent_Roll::PlayRate' has a wrong offset!");

// Function G01.LocomotionComponent.SetEssentialValues
// 0x0004 (0x0004 - 0x0000)
struct LocomotionComponent_SetEssentialValues final
{
public:
	float                                         DeltaTime;                                         // 0x0000(0x0004)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LocomotionComponent_SetEssentialValues) == 0x000004, "Wrong alignment on LocomotionComponent_SetEssentialValues");
static_assert(sizeof(LocomotionComponent_SetEssentialValues) == 0x000004, "Wrong size on LocomotionComponent_SetEssentialValues");
static_assert(offsetof(LocomotionComponent_SetEssentialValues, DeltaTime) == 0x000000, "Member 'LocomotionComponent_SetEssentialValues::DeltaTime' has a wrong offset!");

// Function G01.LocomotionComponent.SetHeldObjectVariables
// 0x0018 (0x0018 - 0x0000)
struct LocomotionComponent_SetHeldObjectVariables final
{
public:
	struct FLocomotionHeldObjectVariables         Variables;                                         // 0x0000(0x0018)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(LocomotionComponent_SetHeldObjectVariables) == 0x000008, "Wrong alignment on LocomotionComponent_SetHeldObjectVariables");
static_assert(sizeof(LocomotionComponent_SetHeldObjectVariables) == 0x000018, "Wrong size on LocomotionComponent_SetHeldObjectVariables");
static_assert(offsetof(LocomotionComponent_SetHeldObjectVariables, Variables) == 0x000000, "Member 'LocomotionComponent_SetHeldObjectVariables::Variables' has a wrong offset!");

// Function G01.LocomotionComponent.SetMovementState
// 0x0001 (0x0001 - 0x0000)
struct LocomotionComponent_SetMovementState final
{
public:
	ELocomotionMovementState                      NewMovementState;                                  // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LocomotionComponent_SetMovementState) == 0x000001, "Wrong alignment on LocomotionComponent_SetMovementState");
static_assert(sizeof(LocomotionComponent_SetMovementState) == 0x000001, "Wrong size on LocomotionComponent_SetMovementState");
static_assert(offsetof(LocomotionComponent_SetMovementState, NewMovementState) == 0x000000, "Member 'LocomotionComponent_SetMovementState::NewMovementState' has a wrong offset!");

// Function G01.LocomotionComponent.SetOverlayState
// 0x0001 (0x0001 - 0x0000)
struct LocomotionComponent_SetOverlayState final
{
public:
	ELocomotionOverlayState                       NewOverlayState;                                   // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LocomotionComponent_SetOverlayState) == 0x000001, "Wrong alignment on LocomotionComponent_SetOverlayState");
static_assert(sizeof(LocomotionComponent_SetOverlayState) == 0x000001, "Wrong size on LocomotionComponent_SetOverlayState");
static_assert(offsetof(LocomotionComponent_SetOverlayState, NewOverlayState) == 0x000000, "Member 'LocomotionComponent_SetOverlayState::NewOverlayState' has a wrong offset!");

// Function G01.LocomotionComponent.SetStance
// 0x0001 (0x0001 - 0x0000)
struct LocomotionComponent_SetStance final
{
public:
	ELocomotionStance                             NewStance;                                         // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LocomotionComponent_SetStance) == 0x000001, "Wrong alignment on LocomotionComponent_SetStance");
static_assert(sizeof(LocomotionComponent_SetStance) == 0x000001, "Wrong size on LocomotionComponent_SetStance");
static_assert(offsetof(LocomotionComponent_SetStance, NewStance) == 0x000000, "Member 'LocomotionComponent_SetStance::NewStance' has a wrong offset!");

// Function G01.LocomotionComponent.SetViewMode
// 0x0001 (0x0001 - 0x0000)
struct LocomotionComponent_SetViewMode final
{
public:
	ELocomotionViewMode                           NewViewMode;                                       // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LocomotionComponent_SetViewMode) == 0x000001, "Wrong alignment on LocomotionComponent_SetViewMode");
static_assert(sizeof(LocomotionComponent_SetViewMode) == 0x000001, "Wrong size on LocomotionComponent_SetViewMode");
static_assert(offsetof(LocomotionComponent_SetViewMode, NewViewMode) == 0x000000, "Member 'LocomotionComponent_SetViewMode::NewViewMode' has a wrong offset!");

// Function G01.LocomotionComponent.UpdateGroundedRotation
// 0x0020 (0x0020 - 0x0000)
struct LocomotionComponent_UpdateGroundedRotation final
{
public:
	float                                         DeltaTime;                                         // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bLocallyControlled;                                // 0x0004(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_35D2[0x3];                                     // 0x0005(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRotator                               ReturnValue;                                       // 0x0008(0x0018)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(LocomotionComponent_UpdateGroundedRotation) == 0x000008, "Wrong alignment on LocomotionComponent_UpdateGroundedRotation");
static_assert(sizeof(LocomotionComponent_UpdateGroundedRotation) == 0x000020, "Wrong size on LocomotionComponent_UpdateGroundedRotation");
static_assert(offsetof(LocomotionComponent_UpdateGroundedRotation, DeltaTime) == 0x000000, "Member 'LocomotionComponent_UpdateGroundedRotation::DeltaTime' has a wrong offset!");
static_assert(offsetof(LocomotionComponent_UpdateGroundedRotation, bLocallyControlled) == 0x000004, "Member 'LocomotionComponent_UpdateGroundedRotation::bLocallyControlled' has a wrong offset!");
static_assert(offsetof(LocomotionComponent_UpdateGroundedRotation, ReturnValue) == 0x000008, "Member 'LocomotionComponent_UpdateGroundedRotation::ReturnValue' has a wrong offset!");

// Function G01.LocomotionComponent.UpdateInAirRotation
// 0x0008 (0x0008 - 0x0000)
struct LocomotionComponent_UpdateInAirRotation final
{
public:
	float                                         DeltaTime;                                         // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bLocallyControlled;                                // 0x0004(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_35D3[0x3];                                     // 0x0005(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(LocomotionComponent_UpdateInAirRotation) == 0x000004, "Wrong alignment on LocomotionComponent_UpdateInAirRotation");
static_assert(sizeof(LocomotionComponent_UpdateInAirRotation) == 0x000008, "Wrong size on LocomotionComponent_UpdateInAirRotation");
static_assert(offsetof(LocomotionComponent_UpdateInAirRotation, DeltaTime) == 0x000000, "Member 'LocomotionComponent_UpdateInAirRotation::DeltaTime' has a wrong offset!");
static_assert(offsetof(LocomotionComponent_UpdateInAirRotation, bLocallyControlled) == 0x000004, "Member 'LocomotionComponent_UpdateInAirRotation::bLocallyControlled' has a wrong offset!");

// Function G01.LocomotionComponent.GetControlRotation
// 0x0018 (0x0018 - 0x0000)
struct LocomotionComponent_GetControlRotation final
{
public:
	struct FRotator                               ReturnValue;                                       // 0x0000(0x0018)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(LocomotionComponent_GetControlRotation) == 0x000008, "Wrong alignment on LocomotionComponent_GetControlRotation");
static_assert(sizeof(LocomotionComponent_GetControlRotation) == 0x000018, "Wrong size on LocomotionComponent_GetControlRotation");
static_assert(offsetof(LocomotionComponent_GetControlRotation, ReturnValue) == 0x000000, "Member 'LocomotionComponent_GetControlRotation::ReturnValue' has a wrong offset!");

// Function G01.LocomotionComponent.GetGetUpAnimation
// 0x0008 (0x0008 - 0x0000)
struct LocomotionComponent_GetGetUpAnimation final
{
public:
	class UAnimMontage*                           ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LocomotionComponent_GetGetUpAnimation) == 0x000008, "Wrong alignment on LocomotionComponent_GetGetUpAnimation");
static_assert(sizeof(LocomotionComponent_GetGetUpAnimation) == 0x000008, "Wrong size on LocomotionComponent_GetGetUpAnimation");
static_assert(offsetof(LocomotionComponent_GetGetUpAnimation, ReturnValue) == 0x000000, "Member 'LocomotionComponent_GetGetUpAnimation::ReturnValue' has a wrong offset!");

// Function G01.LocomotionComponent.GetRollAnimation
// 0x0008 (0x0008 - 0x0000)
struct LocomotionComponent_GetRollAnimation final
{
public:
	class UAnimMontage*                           ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LocomotionComponent_GetRollAnimation) == 0x000008, "Wrong alignment on LocomotionComponent_GetRollAnimation");
static_assert(sizeof(LocomotionComponent_GetRollAnimation) == 0x000008, "Wrong size on LocomotionComponent_GetRollAnimation");
static_assert(offsetof(LocomotionComponent_GetRollAnimation, ReturnValue) == 0x000000, "Member 'LocomotionComponent_GetRollAnimation::ReturnValue' has a wrong offset!");

// Function G01.LocomotionControllerInterface.GetDebugInfo
// 0x0007 (0x0007 - 0x0000)
struct LocomotionControllerInterface_GetDebugInfo final
{
public:
	bool                                          DebugView;                                         // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ShowHUD;                                           // 0x0001(0x0001)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ShowTraces;                                        // 0x0002(0x0001)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ShowDebugShapes;                                   // 0x0003(0x0001)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ShowLayerColors;                                   // 0x0004(0x0001)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Slomo;                                             // 0x0005(0x0001)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ShowCharacterInfo;                                 // 0x0006(0x0001)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LocomotionControllerInterface_GetDebugInfo) == 0x000001, "Wrong alignment on LocomotionControllerInterface_GetDebugInfo");
static_assert(sizeof(LocomotionControllerInterface_GetDebugInfo) == 0x000007, "Wrong size on LocomotionControllerInterface_GetDebugInfo");
static_assert(offsetof(LocomotionControllerInterface_GetDebugInfo, DebugView) == 0x000000, "Member 'LocomotionControllerInterface_GetDebugInfo::DebugView' has a wrong offset!");
static_assert(offsetof(LocomotionControllerInterface_GetDebugInfo, ShowHUD) == 0x000001, "Member 'LocomotionControllerInterface_GetDebugInfo::ShowHUD' has a wrong offset!");
static_assert(offsetof(LocomotionControllerInterface_GetDebugInfo, ShowTraces) == 0x000002, "Member 'LocomotionControllerInterface_GetDebugInfo::ShowTraces' has a wrong offset!");
static_assert(offsetof(LocomotionControllerInterface_GetDebugInfo, ShowDebugShapes) == 0x000003, "Member 'LocomotionControllerInterface_GetDebugInfo::ShowDebugShapes' has a wrong offset!");
static_assert(offsetof(LocomotionControllerInterface_GetDebugInfo, ShowLayerColors) == 0x000004, "Member 'LocomotionControllerInterface_GetDebugInfo::ShowLayerColors' has a wrong offset!");
static_assert(offsetof(LocomotionControllerInterface_GetDebugInfo, Slomo) == 0x000005, "Member 'LocomotionControllerInterface_GetDebugInfo::Slomo' has a wrong offset!");
static_assert(offsetof(LocomotionControllerInterface_GetDebugInfo, ShowCharacterInfo) == 0x000006, "Member 'LocomotionControllerInterface_GetDebugInfo::ShowCharacterInfo' has a wrong offset!");

// Function G01.LocomotionHUDWidget.InitializeWidget
// 0x0010 (0x0010 - 0x0000)
struct LocomotionHUDWidget_InitializeWidget final
{
public:
	class UCanvasPanel*                           MovablePanels;                                     // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UImage*                                 Arrow;                                             // 0x0008(0x0008)(Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LocomotionHUDWidget_InitializeWidget) == 0x000008, "Wrong alignment on LocomotionHUDWidget_InitializeWidget");
static_assert(sizeof(LocomotionHUDWidget_InitializeWidget) == 0x000010, "Wrong size on LocomotionHUDWidget_InitializeWidget");
static_assert(offsetof(LocomotionHUDWidget_InitializeWidget, MovablePanels) == 0x000000, "Member 'LocomotionHUDWidget_InitializeWidget::MovablePanels' has a wrong offset!");
static_assert(offsetof(LocomotionHUDWidget_InitializeWidget, Arrow) == 0x000008, "Member 'LocomotionHUDWidget_InitializeWidget::Arrow' has a wrong offset!");

// Function G01.LocomotionHUDWidget.GetCharacterInfoVisibility
// 0x0001 (0x0001 - 0x0000)
struct LocomotionHUDWidget_GetCharacterInfoVisibility final
{
public:
	ESlateVisibility                              ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LocomotionHUDWidget_GetCharacterInfoVisibility) == 0x000001, "Wrong alignment on LocomotionHUDWidget_GetCharacterInfoVisibility");
static_assert(sizeof(LocomotionHUDWidget_GetCharacterInfoVisibility) == 0x000001, "Wrong size on LocomotionHUDWidget_GetCharacterInfoVisibility");
static_assert(offsetof(LocomotionHUDWidget_GetCharacterInfoVisibility, ReturnValue) == 0x000000, "Member 'LocomotionHUDWidget_GetCharacterInfoVisibility::ReturnValue' has a wrong offset!");

// Function G01.LocomotionHUDWidget.GetCharacterStates
// 0x0010 (0x0010 - 0x0000)
struct LocomotionHUDWidget_GetCharacterStates final
{
public:
	class FText                                   ReturnValue;                                       // 0x0000(0x0010)(Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(LocomotionHUDWidget_GetCharacterStates) == 0x000008, "Wrong alignment on LocomotionHUDWidget_GetCharacterStates");
static_assert(sizeof(LocomotionHUDWidget_GetCharacterStates) == 0x000010, "Wrong size on LocomotionHUDWidget_GetCharacterStates");
static_assert(offsetof(LocomotionHUDWidget_GetCharacterStates, ReturnValue) == 0x000000, "Member 'LocomotionHUDWidget_GetCharacterStates::ReturnValue' has a wrong offset!");

// Function G01.LocomotionHUDWidget.GetDebugViewKey
// 0x0010 (0x0010 - 0x0000)
struct LocomotionHUDWidget_GetDebugViewKey final
{
public:
	class FText                                   ReturnValue;                                       // 0x0000(0x0010)(Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(LocomotionHUDWidget_GetDebugViewKey) == 0x000008, "Wrong alignment on LocomotionHUDWidget_GetDebugViewKey");
static_assert(sizeof(LocomotionHUDWidget_GetDebugViewKey) == 0x000010, "Wrong size on LocomotionHUDWidget_GetDebugViewKey");
static_assert(offsetof(LocomotionHUDWidget_GetDebugViewKey, ReturnValue) == 0x000000, "Member 'LocomotionHUDWidget_GetDebugViewKey::ReturnValue' has a wrong offset!");

// Function G01.LocomotionHUDWidget.GetShowCharacterInfoKey
// 0x0010 (0x0010 - 0x0000)
struct LocomotionHUDWidget_GetShowCharacterInfoKey final
{
public:
	class FText                                   ReturnValue;                                       // 0x0000(0x0010)(Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(LocomotionHUDWidget_GetShowCharacterInfoKey) == 0x000008, "Wrong alignment on LocomotionHUDWidget_GetShowCharacterInfoKey");
static_assert(sizeof(LocomotionHUDWidget_GetShowCharacterInfoKey) == 0x000010, "Wrong size on LocomotionHUDWidget_GetShowCharacterInfoKey");
static_assert(offsetof(LocomotionHUDWidget_GetShowCharacterInfoKey, ReturnValue) == 0x000000, "Member 'LocomotionHUDWidget_GetShowCharacterInfoKey::ReturnValue' has a wrong offset!");

// Function G01.LocomotionHUDWidget.GetShowDebugShapesKey
// 0x0010 (0x0010 - 0x0000)
struct LocomotionHUDWidget_GetShowDebugShapesKey final
{
public:
	class FText                                   ReturnValue;                                       // 0x0000(0x0010)(Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(LocomotionHUDWidget_GetShowDebugShapesKey) == 0x000008, "Wrong alignment on LocomotionHUDWidget_GetShowDebugShapesKey");
static_assert(sizeof(LocomotionHUDWidget_GetShowDebugShapesKey) == 0x000010, "Wrong size on LocomotionHUDWidget_GetShowDebugShapesKey");
static_assert(offsetof(LocomotionHUDWidget_GetShowDebugShapesKey, ReturnValue) == 0x000000, "Member 'LocomotionHUDWidget_GetShowDebugShapesKey::ReturnValue' has a wrong offset!");

// Function G01.LocomotionHUDWidget.GetShowHUDKey
// 0x0010 (0x0010 - 0x0000)
struct LocomotionHUDWidget_GetShowHUDKey final
{
public:
	class FText                                   ReturnValue;                                       // 0x0000(0x0010)(Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(LocomotionHUDWidget_GetShowHUDKey) == 0x000008, "Wrong alignment on LocomotionHUDWidget_GetShowHUDKey");
static_assert(sizeof(LocomotionHUDWidget_GetShowHUDKey) == 0x000010, "Wrong size on LocomotionHUDWidget_GetShowHUDKey");
static_assert(offsetof(LocomotionHUDWidget_GetShowHUDKey, ReturnValue) == 0x000000, "Member 'LocomotionHUDWidget_GetShowHUDKey::ReturnValue' has a wrong offset!");

// Function G01.LocomotionHUDWidget.GetShowLayerColorsKey
// 0x0010 (0x0010 - 0x0000)
struct LocomotionHUDWidget_GetShowLayerColorsKey final
{
public:
	class FText                                   ReturnValue;                                       // 0x0000(0x0010)(Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(LocomotionHUDWidget_GetShowLayerColorsKey) == 0x000008, "Wrong alignment on LocomotionHUDWidget_GetShowLayerColorsKey");
static_assert(sizeof(LocomotionHUDWidget_GetShowLayerColorsKey) == 0x000010, "Wrong size on LocomotionHUDWidget_GetShowLayerColorsKey");
static_assert(offsetof(LocomotionHUDWidget_GetShowLayerColorsKey, ReturnValue) == 0x000000, "Member 'LocomotionHUDWidget_GetShowLayerColorsKey::ReturnValue' has a wrong offset!");

// Function G01.LocomotionHUDWidget.GetShowTracesKey
// 0x0010 (0x0010 - 0x0000)
struct LocomotionHUDWidget_GetShowTracesKey final
{
public:
	class FText                                   ReturnValue;                                       // 0x0000(0x0010)(Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(LocomotionHUDWidget_GetShowTracesKey) == 0x000008, "Wrong alignment on LocomotionHUDWidget_GetShowTracesKey");
static_assert(sizeof(LocomotionHUDWidget_GetShowTracesKey) == 0x000010, "Wrong size on LocomotionHUDWidget_GetShowTracesKey");
static_assert(offsetof(LocomotionHUDWidget_GetShowTracesKey, ReturnValue) == 0x000000, "Member 'LocomotionHUDWidget_GetShowTracesKey::ReturnValue' has a wrong offset!");

// Function G01.LocomotionHUDWidget.GetSlomoKey
// 0x0010 (0x0010 - 0x0000)
struct LocomotionHUDWidget_GetSlomoKey final
{
public:
	class FText                                   ReturnValue;                                       // 0x0000(0x0010)(Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(LocomotionHUDWidget_GetSlomoKey) == 0x000008, "Wrong alignment on LocomotionHUDWidget_GetSlomoKey");
static_assert(sizeof(LocomotionHUDWidget_GetSlomoKey) == 0x000010, "Wrong size on LocomotionHUDWidget_GetSlomoKey");
static_assert(offsetof(LocomotionHUDWidget_GetSlomoKey, ReturnValue) == 0x000000, "Member 'LocomotionHUDWidget_GetSlomoKey::ReturnValue' has a wrong offset!");

// Function G01.GzAT_WaitSlideEndConditionsMeet.CreateWaitSlideEndConditionsMeet
// 0x0018 (0x0018 - 0x0000)
struct GzAT_WaitSlideEndConditionsMeet_CreateWaitSlideEndConditionsMeet final
{
public:
	class UGameplayAbility*                       OwningAbility;                                     // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SpeedThreshold;                                    // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_35D7[0x4];                                     // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UGzAT_WaitSlideEndConditionsMeet*       ReturnValue;                                       // 0x0010(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GzAT_WaitSlideEndConditionsMeet_CreateWaitSlideEndConditionsMeet) == 0x000008, "Wrong alignment on GzAT_WaitSlideEndConditionsMeet_CreateWaitSlideEndConditionsMeet");
static_assert(sizeof(GzAT_WaitSlideEndConditionsMeet_CreateWaitSlideEndConditionsMeet) == 0x000018, "Wrong size on GzAT_WaitSlideEndConditionsMeet_CreateWaitSlideEndConditionsMeet");
static_assert(offsetof(GzAT_WaitSlideEndConditionsMeet_CreateWaitSlideEndConditionsMeet, OwningAbility) == 0x000000, "Member 'GzAT_WaitSlideEndConditionsMeet_CreateWaitSlideEndConditionsMeet::OwningAbility' has a wrong offset!");
static_assert(offsetof(GzAT_WaitSlideEndConditionsMeet_CreateWaitSlideEndConditionsMeet, SpeedThreshold) == 0x000008, "Member 'GzAT_WaitSlideEndConditionsMeet_CreateWaitSlideEndConditionsMeet::SpeedThreshold' has a wrong offset!");
static_assert(offsetof(GzAT_WaitSlideEndConditionsMeet_CreateWaitSlideEndConditionsMeet, ReturnValue) == 0x000010, "Member 'GzAT_WaitSlideEndConditionsMeet_CreateWaitSlideEndConditionsMeet::ReturnValue' has a wrong offset!");

}

