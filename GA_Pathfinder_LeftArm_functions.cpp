#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: GA_Pathfinder_LeftArm

#include "Basic.hpp"

#include "GA_Pathfinder_LeftArm_classes.hpp"
#include "GA_Pathfinder_LeftArm_parameters.hpp"


namespace SDK
{

// Function GA_Pathfinder_LeftArm.GA_Pathfinder_LeftArm_C.ActivateLimb
// (Public, BlueprintCallable, BlueprintEvent)

void UGA_Pathfinder_LeftArm_C::ActivateLimb()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GA_Pathfinder_LeftArm_C", "ActivateLimb");

	UObject::ProcessEvent(Func, nullptr);
}


// Function GA_Pathfinder_LeftArm.GA_Pathfinder_LeftArm_C.AddCharge
// (Public, BlueprintCallable, BlueprintEvent)

void UGA_Pathfinder_LeftArm_C::AddCharge()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GA_Pathfinder_LeftArm_C", "AddCharge");

	UObject::ProcessEvent(Func, nullptr);
}


// Function GA_Pathfinder_LeftArm.GA_Pathfinder_LeftArm_C.ChargeCompleteFeddback
// (Public, BlueprintCallable, BlueprintEvent)

void UGA_Pathfinder_LeftArm_C::ChargeCompleteFeddback()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GA_Pathfinder_LeftArm_C", "ChargeCompleteFeddback");

	UObject::ProcessEvent(Func, nullptr);
}


// Function GA_Pathfinder_LeftArm.GA_Pathfinder_LeftArm_C.ChargeCompleteSound
// (Public, BlueprintCallable, BlueprintEvent)

void UGA_Pathfinder_LeftArm_C::ChargeCompleteSound()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GA_Pathfinder_LeftArm_C", "ChargeCompleteSound");

	UObject::ProcessEvent(Func, nullptr);
}


// Function GA_Pathfinder_LeftArm.GA_Pathfinder_LeftArm_C.ChargeInterruptedSound
// (Public, BlueprintCallable, BlueprintEvent)

void UGA_Pathfinder_LeftArm_C::ChargeInterruptedSound()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GA_Pathfinder_LeftArm_C", "ChargeInterruptedSound");

	UObject::ProcessEvent(Func, nullptr);
}


// Function GA_Pathfinder_LeftArm.GA_Pathfinder_LeftArm_C.ChargeLoadedSound
// (Public, BlueprintCallable, BlueprintEvent)

void UGA_Pathfinder_LeftArm_C::ChargeLoadedSound()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GA_Pathfinder_LeftArm_C", "ChargeLoadedSound");

	UObject::ProcessEvent(Func, nullptr);
}


// Function GA_Pathfinder_LeftArm.GA_Pathfinder_LeftArm_C.ClampCharges
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

int32 UGA_Pathfinder_LeftArm_C::ClampCharges()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GA_Pathfinder_LeftArm_C", "ClampCharges");

	Params::GA_Pathfinder_LeftArm_C_ClampCharges Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function GA_Pathfinder_LeftArm.GA_Pathfinder_LeftArm_C.ConsumeCharge
// (BlueprintCallable, BlueprintEvent)

void UGA_Pathfinder_LeftArm_C::ConsumeCharge()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GA_Pathfinder_LeftArm_C", "ConsumeCharge");

	UObject::ProcessEvent(Func, nullptr);
}


// Function GA_Pathfinder_LeftArm.GA_Pathfinder_LeftArm_C.ConsumeCharge_Event
// (BlueprintCallable, BlueprintEvent)

void UGA_Pathfinder_LeftArm_C::ConsumeCharge_Event()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GA_Pathfinder_LeftArm_C", "ConsumeCharge_Event");

	UObject::ProcessEvent(Func, nullptr);
}


// Function GA_Pathfinder_LeftArm.GA_Pathfinder_LeftArm_C.DeactivateRemoteIfAllExploded
// (Public, BlueprintCallable, BlueprintEvent)

void UGA_Pathfinder_LeftArm_C::DeactivateRemoteIfAllExploded()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GA_Pathfinder_LeftArm_C", "DeactivateRemoteIfAllExploded");

	UObject::ProcessEvent(Func, nullptr);
}


// Function GA_Pathfinder_LeftArm.GA_Pathfinder_LeftArm_C.ExecuteMultishot
// (BlueprintCallable, BlueprintEvent)

void UGA_Pathfinder_LeftArm_C::ExecuteMultishot()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GA_Pathfinder_LeftArm_C", "ExecuteMultishot");

	UObject::ProcessEvent(Func, nullptr);
}


// Function GA_Pathfinder_LeftArm.GA_Pathfinder_LeftArm_C.ExecuteUbergraph_GA_Pathfinder_LeftArm
// (Final, UbergraphFunction, HasDefaults)
// Parameters:
// int32                                   EntryPoint                                             (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UGA_Pathfinder_LeftArm_C::ExecuteUbergraph_GA_Pathfinder_LeftArm(int32 EntryPoint)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GA_Pathfinder_LeftArm_C", "ExecuteUbergraph_GA_Pathfinder_LeftArm");

	Params::GA_Pathfinder_LeftArm_C_ExecuteUbergraph_GA_Pathfinder_LeftArm Parms{};

	Parms.EntryPoint = EntryPoint;

	UObject::ProcessEvent(Func, &Parms);
}


// Function GA_Pathfinder_LeftArm.GA_Pathfinder_LeftArm_C.GetLaunchData
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// struct FGameplayAbilityTargetDataHandle HitResult                                              (ConstParm, BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm)
// struct FVector                          Launch_Position                                        (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// struct FVector                          Launch_Direction                                       (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// int32                                   Param_ChargesToShoot                                   (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// double                                  Param_LaunchSpeed                                      (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UGA_Pathfinder_LeftArm_C::GetLaunchData(const struct FGameplayAbilityTargetDataHandle& HitResult, struct FVector* Launch_Position, struct FVector* Launch_Direction, int32* Param_ChargesToShoot, double* Param_LaunchSpeed)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GA_Pathfinder_LeftArm_C", "GetLaunchData");

	Params::GA_Pathfinder_LeftArm_C_GetLaunchData Parms{};

	Parms.HitResult = std::move(HitResult);

	UObject::ProcessEvent(Func, &Parms);

	if (Launch_Position != nullptr)
		*Launch_Position = std::move(Parms.Launch_Position);

	if (Launch_Direction != nullptr)
		*Launch_Direction = std::move(Parms.Launch_Direction);

	if (Param_ChargesToShoot != nullptr)
		*Param_ChargesToShoot = Parms.Param_ChargesToShoot;

	if (Param_LaunchSpeed != nullptr)
		*Param_LaunchSpeed = Parms.Param_LaunchSpeed;
}


// Function GA_Pathfinder_LeftArm.GA_Pathfinder_LeftArm_C.HasCharges
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

bool UGA_Pathfinder_LeftArm_C::HasCharges()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GA_Pathfinder_LeftArm_C", "HasCharges");

	Params::GA_Pathfinder_LeftArm_C_HasCharges Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function GA_Pathfinder_LeftArm.GA_Pathfinder_LeftArm_C.InputActionBySlot
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// class UInputAction*                     Output                                                 (Parm, OutParm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)

void UGA_Pathfinder_LeftArm_C::InputActionBySlot(class UInputAction** Output)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GA_Pathfinder_LeftArm_C", "InputActionBySlot");

	Params::GA_Pathfinder_LeftArm_C_InputActionBySlot Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (Output != nullptr)
		*Output = Parms.Output;
}


// Function GA_Pathfinder_LeftArm.GA_Pathfinder_LeftArm_C.K2_ActivateAbility
// (Event, Protected, BlueprintEvent)

void UGA_Pathfinder_LeftArm_C::K2_ActivateAbility()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GA_Pathfinder_LeftArm_C", "K2_ActivateAbility");

	UObject::ProcessEvent(Func, nullptr);
}


// Function GA_Pathfinder_LeftArm.GA_Pathfinder_LeftArm_C.K2_OnEndAbility
// (Event, Protected, BlueprintEvent)
// Parameters:
// bool                                    bWasCancelled                                          (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UGA_Pathfinder_LeftArm_C::K2_OnEndAbility(bool bWasCancelled)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GA_Pathfinder_LeftArm_C", "K2_OnEndAbility");

	Params::GA_Pathfinder_LeftArm_C_K2_OnEndAbility Parms{};

	Parms.bWasCancelled = bWasCancelled;

	UObject::ProcessEvent(Func, &Parms);
}


// Function GA_Pathfinder_LeftArm.GA_Pathfinder_LeftArm_C.LastCharge
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

bool UGA_Pathfinder_LeftArm_C::LastCharge()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GA_Pathfinder_LeftArm_C", "LastCharge");

	Params::GA_Pathfinder_LeftArm_C_LastCharge Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function GA_Pathfinder_LeftArm.GA_Pathfinder_LeftArm_C.Launch Projectile
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// struct FVector                          LaunchPosition                                         (ConstParm, BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// struct FVector                          LaunchDirection                                        (ConstParm, BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// double                                  Param_LaunchSpeed                                      (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UGA_Pathfinder_LeftArm_C::Launch_Projectile(const struct FVector& LaunchPosition, const struct FVector& LaunchDirection, double Param_LaunchSpeed)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GA_Pathfinder_LeftArm_C", "Launch Projectile");

	Params::GA_Pathfinder_LeftArm_C_Launch_Projectile Parms{};

	Parms.LaunchPosition = std::move(LaunchPosition);
	Parms.LaunchDirection = std::move(LaunchDirection);
	Parms.Param_LaunchSpeed = Param_LaunchSpeed;

	UObject::ProcessEvent(Func, &Parms);
}


// Function GA_Pathfinder_LeftArm.GA_Pathfinder_LeftArm_C.LockLimbAbility
// (Public, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// class FString                           NewParam                                               (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, HasGetValueTypeHash)

void UGA_Pathfinder_LeftArm_C::LockLimbAbility(const class FString& NewParam)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GA_Pathfinder_LeftArm_C", "LockLimbAbility");

	Params::GA_Pathfinder_LeftArm_C_LockLimbAbility Parms{};

	Parms.NewParam = std::move(NewParam);

	UObject::ProcessEvent(Func, &Parms);
}


// Function GA_Pathfinder_LeftArm.GA_Pathfinder_LeftArm_C.MakeAndSendData
// (Public, HasDefaults, BlueprintCallable, BlueprintEvent)

void UGA_Pathfinder_LeftArm_C::MakeAndSendData()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GA_Pathfinder_LeftArm_C", "MakeAndSendData");

	UObject::ProcessEvent(Func, nullptr);
}


// Function GA_Pathfinder_LeftArm.GA_Pathfinder_LeftArm_C.MakeLaunchData
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// struct FGameplayAbilityTargetDataHandle ReturnValue                                            (Parm, OutParm, ReturnParm)

struct FGameplayAbilityTargetDataHandle UGA_Pathfinder_LeftArm_C::MakeLaunchData()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GA_Pathfinder_LeftArm_C", "MakeLaunchData");

	Params::GA_Pathfinder_LeftArm_C_MakeLaunchData Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function GA_Pathfinder_LeftArm.GA_Pathfinder_LeftArm_C.MaxCharge_Event
// (BlueprintCallable, BlueprintEvent)

void UGA_Pathfinder_LeftArm_C::MaxCharge_Event()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GA_Pathfinder_LeftArm_C", "MaxCharge_Event");

	UObject::ProcessEvent(Func, nullptr);
}


// Function GA_Pathfinder_LeftArm.GA_Pathfinder_LeftArm_C.OnEndPlay_Event_0
// (BlueprintCallable, BlueprintEvent)
// Parameters:
// class AActor*                           Actor                                                  (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)
// EEndPlayReason                          EndPlayReason                                          (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UGA_Pathfinder_LeftArm_C::OnEndPlay_Event_0(class AActor* Actor, EEndPlayReason EndPlayReason)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GA_Pathfinder_LeftArm_C", "OnEndPlay_Event_0");

	Params::GA_Pathfinder_LeftArm_C_OnEndPlay_Event_0 Parms{};

	Parms.Actor = Actor;
	Parms.EndPlayReason = EndPlayReason;

	UObject::ProcessEvent(Func, &Parms);
}


// Function GA_Pathfinder_LeftArm.GA_Pathfinder_LeftArm_C.OnFinished_586C039045E083BE4EB562BCB04DF2EF
// (BlueprintCallable, BlueprintEvent)
// Parameters:
// int32                                   ActionNumber                                           (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UGA_Pathfinder_LeftArm_C::OnFinished_586C039045E083BE4EB562BCB04DF2EF(int32 ActionNumber)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GA_Pathfinder_LeftArm_C", "OnFinished_586C039045E083BE4EB562BCB04DF2EF");

	Params::GA_Pathfinder_LeftArm_C_OnFinished_586C039045E083BE4EB562BCB04DF2EF Parms{};

	Parms.ActionNumber = ActionNumber;

	UObject::ProcessEvent(Func, &Parms);
}


// Function GA_Pathfinder_LeftArm.GA_Pathfinder_LeftArm_C.OnInput_4C91C24341FFC8B0E3FC8AA0BA4D1B53
// (BlueprintCallable, BlueprintEvent)
// Parameters:
// float                                   Time                                                   (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UGA_Pathfinder_LeftArm_C::OnInput_4C91C24341FFC8B0E3FC8AA0BA4D1B53(float Time)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GA_Pathfinder_LeftArm_C", "OnInput_4C91C24341FFC8B0E3FC8AA0BA4D1B53");

	Params::GA_Pathfinder_LeftArm_C_OnInput_4C91C24341FFC8B0E3FC8AA0BA4D1B53 Parms{};

	Parms.Time = Time;

	UObject::ProcessEvent(Func, &Parms);
}


// Function GA_Pathfinder_LeftArm.GA_Pathfinder_LeftArm_C.OnOvercharge
// (BlueprintCallable, BlueprintEvent)

void UGA_Pathfinder_LeftArm_C::OnOvercharge()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GA_Pathfinder_LeftArm_C", "OnOvercharge");

	UObject::ProcessEvent(Func, nullptr);
}


// Function GA_Pathfinder_LeftArm.GA_Pathfinder_LeftArm_C.OnPerformAction_586C039045E083BE4EB562BCB04DF2EF
// (BlueprintCallable, BlueprintEvent)
// Parameters:
// int32                                   ActionNumber                                           (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UGA_Pathfinder_LeftArm_C::OnPerformAction_586C039045E083BE4EB562BCB04DF2EF(int32 ActionNumber)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GA_Pathfinder_LeftArm_C", "OnPerformAction_586C039045E083BE4EB562BCB04DF2EF");

	Params::GA_Pathfinder_LeftArm_C_OnPerformAction_586C039045E083BE4EB562BCB04DF2EF Parms{};

	Parms.ActionNumber = ActionNumber;

	UObject::ProcessEvent(Func, &Parms);
}


// Function GA_Pathfinder_LeftArm.GA_Pathfinder_LeftArm_C.OverchargeInterruptedSound
// (Public, BlueprintCallable, BlueprintEvent)

void UGA_Pathfinder_LeftArm_C::OverchargeInterruptedSound()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GA_Pathfinder_LeftArm_C", "OverchargeInterruptedSound");

	UObject::ProcessEvent(Func, nullptr);
}


// Function GA_Pathfinder_LeftArm.GA_Pathfinder_LeftArm_C.PreDelay
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// double                                  Param_PreDelay                                         (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UGA_Pathfinder_LeftArm_C::PreDelay(double* Param_PreDelay)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GA_Pathfinder_LeftArm_C", "PreDelay");

	Params::GA_Pathfinder_LeftArm_C_PreDelay Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (Param_PreDelay != nullptr)
		*Param_PreDelay = Parms.Param_PreDelay;
}


// Function GA_Pathfinder_LeftArm.GA_Pathfinder_LeftArm_C.QuickSingleShot
// (Public, BlueprintCallable, BlueprintEvent)

void UGA_Pathfinder_LeftArm_C::QuickSingleShot()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GA_Pathfinder_LeftArm_C", "QuickSingleShot");

	UObject::ProcessEvent(Func, nullptr);
}


// Function GA_Pathfinder_LeftArm.GA_Pathfinder_LeftArm_C.RemoteActivated_Event
// (BlueprintCallable, BlueprintEvent)

void UGA_Pathfinder_LeftArm_C::RemoteActivated_Event()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GA_Pathfinder_LeftArm_C", "RemoteActivated_Event");

	UObject::ProcessEvent(Func, nullptr);
}


// Function GA_Pathfinder_LeftArm.GA_Pathfinder_LeftArm_C.RemoteUnavailable
// (BlueprintCallable, BlueprintEvent)

void UGA_Pathfinder_LeftArm_C::RemoteUnavailable()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GA_Pathfinder_LeftArm_C", "RemoteUnavailable");

	UObject::ProcessEvent(Func, nullptr);
}


// Function GA_Pathfinder_LeftArm.GA_Pathfinder_LeftArm_C.RemoveExplodedGrenade
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// TArray<class AActor*>                   Param_GrenadesFired                                    (Parm, OutParm)

void UGA_Pathfinder_LeftArm_C::RemoveExplodedGrenade(TArray<class AActor*>* Param_GrenadesFired)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GA_Pathfinder_LeftArm_C", "RemoveExplodedGrenade");

	Params::GA_Pathfinder_LeftArm_C_RemoveExplodedGrenade Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (Param_GrenadesFired != nullptr)
		*Param_GrenadesFired = std::move(Parms.Param_GrenadesFired);
}


// Function GA_Pathfinder_LeftArm.GA_Pathfinder_LeftArm_C.SetInitialVariables
// (Public, BlueprintCallable, BlueprintEvent)

void UGA_Pathfinder_LeftArm_C::SetInitialVariables()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GA_Pathfinder_LeftArm_C", "SetInitialVariables");

	UObject::ProcessEvent(Func, nullptr);
}


// Function GA_Pathfinder_LeftArm.GA_Pathfinder_LeftArm_C.StartAim
// (Public, BlueprintCallable, BlueprintEvent)

void UGA_Pathfinder_LeftArm_C::StartAim()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GA_Pathfinder_LeftArm_C", "StartAim");

	UObject::ProcessEvent(Func, nullptr);
}


// Function GA_Pathfinder_LeftArm.GA_Pathfinder_LeftArm_C.StartChargeSound
// (Public, BlueprintCallable, BlueprintEvent)

void UGA_Pathfinder_LeftArm_C::StartChargeSound()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GA_Pathfinder_LeftArm_C", "StartChargeSound");

	UObject::ProcessEvent(Func, nullptr);
}


// Function GA_Pathfinder_LeftArm.GA_Pathfinder_LeftArm_C.StartOverChargeSound
// (Public, BlueprintCallable, BlueprintEvent)

void UGA_Pathfinder_LeftArm_C::StartOverChargeSound()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GA_Pathfinder_LeftArm_C", "StartOverChargeSound");

	UObject::ProcessEvent(Func, nullptr);
}


// Function GA_Pathfinder_LeftArm.GA_Pathfinder_LeftArm_C.StopAim
// (Public, BlueprintCallable, BlueprintEvent)

void UGA_Pathfinder_LeftArm_C::StopAim()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GA_Pathfinder_LeftArm_C", "StopAim");

	UObject::ProcessEvent(Func, nullptr);
}


// Function GA_Pathfinder_LeftArm.GA_Pathfinder_LeftArm_C.SubtractCharge
// (Public, BlueprintCallable, BlueprintEvent)

void UGA_Pathfinder_LeftArm_C::SubtractCharge()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GA_Pathfinder_LeftArm_C", "SubtractCharge");

	UObject::ProcessEvent(Func, nullptr);
}


// Function GA_Pathfinder_LeftArm.GA_Pathfinder_LeftArm_C.ToggleTagAndCommit
// (Public, BlueprintCallable, BlueprintEvent)

void UGA_Pathfinder_LeftArm_C::ToggleTagAndCommit()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GA_Pathfinder_LeftArm_C", "ToggleTagAndCommit");

	UObject::ProcessEvent(Func, nullptr);
}


// Function GA_Pathfinder_LeftArm.GA_Pathfinder_LeftArm_C.ValidData_A8C4D0B84F9CC642725A3592FFB278B7
// (HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// struct FGameplayAbilityTargetDataHandle Data                                                   (ConstParm, BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm)

void UGA_Pathfinder_LeftArm_C::ValidData_A8C4D0B84F9CC642725A3592FFB278B7(const struct FGameplayAbilityTargetDataHandle& Data)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GA_Pathfinder_LeftArm_C", "ValidData_A8C4D0B84F9CC642725A3592FFB278B7");

	Params::GA_Pathfinder_LeftArm_C_ValidData_A8C4D0B84F9CC642725A3592FFB278B7 Parms{};

	Parms.Data = std::move(Data);

	UObject::ProcessEvent(Func, &Parms);
}


// Function GA_Pathfinder_LeftArm.GA_Pathfinder_LeftArm_C.WaitForClientData
// (BlueprintCallable, BlueprintEvent)

void UGA_Pathfinder_LeftArm_C::WaitForClientData()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GA_Pathfinder_LeftArm_C", "WaitForClientData");

	UObject::ProcessEvent(Func, nullptr);
}


// Function GA_Pathfinder_LeftArm.GA_Pathfinder_LeftArm_C.WaitForPress
// (BlueprintCallable, BlueprintEvent)

void UGA_Pathfinder_LeftArm_C::WaitForPress()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GA_Pathfinder_LeftArm_C", "WaitForPress");

	UObject::ProcessEvent(Func, nullptr);
}


// Function GA_Pathfinder_LeftArm.GA_Pathfinder_LeftArm_C.WaitForRelease
// (BlueprintCallable, BlueprintEvent)

void UGA_Pathfinder_LeftArm_C::WaitForRelease()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GA_Pathfinder_LeftArm_C", "WaitForRelease");

	UObject::ProcessEvent(Func, nullptr);
}

}

