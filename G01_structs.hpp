#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: G01

#include "Basic.hpp"

#include "AkAudio_structs.hpp"
#include "CoreUObject_structs.hpp"
#include "NetCore_structs.hpp"
#include "PhysicsCore_structs.hpp"
#include "StructUtils_structs.hpp"
#include "Engine_structs.hpp"
#include "CommonInput_structs.hpp"
#include "GameplayTags_structs.hpp"
#include "GameplayAbilities_structs.hpp"
#include "CohtmlPlugin_structs.hpp"
#include "UnityMatchmaking_structs.hpp"
#include "InputCore_structs.hpp"
#include "SlateCore_structs.hpp"
#include "IrisCore_structs.hpp"
#include "EnhancedInput_structs.hpp"


namespace SDK
{

// Enum G01.EGzZoneOverloadState
// NumValues: 0x0006
enum class EGzZoneOverloadState : uint8
{
	Inactive                                 = 0,
	Expanding                                = 1,
	Shrinking                                = 2,
	Expanded                                 = 3,
	Shrinked                                 = 4,
	EGzZoneOverloadState_MAX                 = 5,
};

// Enum G01.ELocomotionMovementAction
// NumValues: 0x0006
enum class ELocomotionMovementAction : uint8
{
	None                                     = 0,
	LowMantle                                = 1,
	HighMantle                               = 2,
	Rolling                                  = 3,
	GettingUp                                = 4,
	ELocomotionMovementAction_MAX            = 5,
};

// Enum G01.EGzWeaponResourceType
// NumValues: 0x0007
enum class EGzWeaponResourceType : uint8
{
	LightAmmo                                = 0,
	MediumAmmo                               = 1,
	HeavyAmmo                                = 2,
	ShotgunShellAmmo                         = 3,
	ExplosiveAmmo                            = 4,
	Energy                                   = 5,
	EGzWeaponResourceType_MAX                = 6,
};

// Enum G01.EGzInvPocketSource
// NumValues: 0x0004
enum class EGzInvPocketSource : uint8
{
	None                                     = 0,
	Default                                  = 1,
	Backpack                                 = 2,
	EGzInvPocketSource_MAX                   = 3,
};

// Enum G01.EGzBodyGender
// NumValues: 0x0004
enum class EGzBodyGender : uint8
{
	Undefined                                = 0,
	Male                                     = 1,
	Female                                   = 2,
	EGzBodyGender_MAX                        = 3,
};

// Enum G01.EGzZiplineMovementState
// NumValues: 0x0004
enum class EGzZiplineMovementState : uint8
{
	None                                     = 0,
	ToZipline                                = 1,
	AlongZipline                             = 2,
	EGzZiplineMovementState_MAX              = 3,
};

// Enum G01.EGzInvChangeEvent
// NumValues: 0x0003
enum class EGzInvChangeEvent : uint8
{
	Removed                                  = 0,
	Added                                    = 1,
	EGzInvChangeEvent_MAX                    = 2,
};

// Enum G01.EGzVehicleSeatType
// NumValues: 0x0008
enum class EGzVehicleSeatType : uint8
{
	None                                     = 0,
	Driver                                   = 1,
	Passenger_Front                          = 2,
	Passenger_Back_Right                     = 3,
	Passenger_Back_Left                      = 4,
	Gunner                                   = 5,
	NUM_Seats                                = 6,
	EGzVehicleSeatType_MAX                   = 7,
};

// Enum G01.EGzWeaponAttachmentType
// NumValues: 0x000A
enum class EGzWeaponAttachmentType : uint8
{
	Barrel                                   = 0,
	UnderBarrel                              = 1,
	Muzzle                                   = 2,
	Sight                                    = 3,
	Magazine                                 = 4,
	Stock                                    = 5,
	Tactical                                 = 6,
	PistolGrip                               = 7,
	_LAST                                    = 8,
	EGzWeaponAttachmentType_MAX              = 9,
};

// Enum G01.EGzWeaponSupportHoldType
// NumValues: 0x0008
enum class EGzWeaponSupportHoldType : uint8
{
	None                                     = 0,
	VerticalGrip                             = 1,
	VerticalAngledGrip                       = 2,
	AngledGrip                               = 3,
	HorizontalGrip                           = 4,
	SideGrip                                 = 5,
	_LAST                                    = 6,
	EGzWeaponSupportHoldType_MAX             = 7,
};

// Enum G01.EGzExtractionState
// NumValues: 0x0004
enum class EGzExtractionState : uint8
{
	None                                     = 0,
	Extracting                               = 1,
	Hacked                                   = 2,
	EGzExtractionState_MAX                   = 3,
};

// Enum G01.EGzConditionState
// NumValues: 0x0006
enum class EGzConditionState : uint8
{
	None                                     = 0,
	Inactive                                 = 1,
	Pending                                  = 2,
	Positive                                 = 3,
	Negative                                 = 4,
	EGzConditionState_MAX                    = 5,
};

// Enum G01.EGzDamageIndicatorType
// NumValues: 0x0008
enum class EGzDamageIndicatorType : uint8
{
	None                                     = 0,
	Body                                     = 1,
	Armor                                    = 2,
	Limb                                     = 3,
	LimbProjectile                           = 4,
	BulletFlyby                              = 5,
	LimbFlyby                                = 6,
	EGzDamageIndicatorType_MAX               = 7,
};

// Enum G01.EGzInvPocketType
// NumValues: 0x0004
enum class EGzInvPocketType : uint8
{
	Default                                  = 0,
	Equipment                                = 1,
	Virtual                                  = 2,
	EGzInvPocketType_MAX                     = 3,
};

// Enum G01.EGzSubscriptionType
// NumValues: 0x0003
enum class EGzSubscriptionType : uint8
{
	None                                     = 0,
	OtgPro                                   = 1,
	EGzSubscriptionType_MAX                  = 2,
};

// Enum G01.EGzLimbType
// NumValues: 0x0006
enum class EGzLimbType : uint8
{
	LT_LeftArm                               = 0,
	LT_RightArm                              = 1,
	LT_Legs                                  = 2,
	LT_Count                                 = 3,
	LT_Invalid                               = 4,
	LT_MAX                                   = 5,
};

// Enum G01.EGzMissionState
// NumValues: 0x0005
enum class EGzMissionState : uint8
{
	Inactive                                 = 0,
	InProgress                               = 1,
	Completed                                = 2,
	Failed                                   = 3,
	EGzMissionState_MAX                      = 4,
};

// Enum G01.EGzObjectiveState
// NumValues: 0x0006
enum class EGzObjectiveState : uint8
{
	None                                     = 0,
	Inactive                                 = 1,
	InProgress                               = 2,
	Completed                                = 3,
	Failed                                   = 4,
	EGzObjectiveState_MAX                    = 5,
};

// Enum G01.EGzMarkerActiveState
// NumValues: 0x0005
enum class EGzMarkerActiveState : uint8
{
	None                                     = 0,
	Active                                   = 1,
	Disabled                                 = 2,
	Hidden                                   = 3,
	EGzMarkerActiveState_MAX                 = 4,
};

// Enum G01.EGzDoorState
// NumValues: 0x0005
enum class EGzDoorState : uint8
{
	Closed                                   = 0,
	Closing                                  = 1,
	Opening                                  = 2,
	Opened                                   = 3,
	EGzDoorState_MAX                         = 4,
};

// Enum G01.EGzLoadoutSlots
// NumValues: 0x000B
enum class EGzLoadoutSlots : uint8
{
	PrimaryWeapon                            = 0,
	SecondaryWeapon                          = 1,
	Sidearm                                  = 2,
	LeftArm                                  = 3,
	RightArm                                 = 4,
	Legs                                     = 5,
	Grenades                                 = 6,
	Consumables                              = 7,
	Backpack                                 = 8,
	NUM_LoadoutSlots                         = 9,
	EGzLoadoutSlots_MAX                      = 10,
};

// Enum G01.EGzPingTarget
// NumValues: 0x0008
enum class EGzPingTarget : uint8
{
	Location                                 = 0,
	Enemy                                    = 1,
	Item                                     = 2,
	WorldObject                              = 3,
	Marker                                   = 4,
	AttachedMarker                           = 5,
	LootContainer                            = 6,
	EGzPingTarget_MAX                        = 7,
};

// Enum G01.EGzRadialMenuButtonState
// NumValues: 0x0006
enum class EGzRadialMenuButtonState : uint8
{
	None                                     = 0,
	Hovered                                  = 1,
	Normal                                   = 2,
	Pressed                                  = 3,
	Disabled                                 = 4,
	MAX                                      = 5,
};

// Enum G01.EGzTargetUITagsState
// NumValues: 0x0004
enum class EGzTargetUITagsState : uint8
{
	None                                     = 0,
	Activated                                = 1,
	Deactivated                              = 2,
	EGzTargetUITagsState_MAX                 = 3,
};

// Enum G01.EGzWorldVisibilityState
// NumValues: 0x0012
enum class EGzWorldVisibilityState : uint8
{
	None                                     = 0,
	Dead                                     = 1,
	AnotherWorld                             = 2,
	InsideYourVehicle                        = 3,
	PossesVehicle                            = 4,
	ControlledLocally                        = 5,
	Visible                                  = 6,
	VisibleAsTeammate                        = 7,
	VisibleAsNeutral                         = 8,
	Revealed                                 = 9,
	VisibleVehicle                           = 10,
	HideVehicleAsTeammate                    = 11,
	VisibleEnemy                             = 12,
	VisibleFromDefiler                       = 13,
	VisibleFromShooting                      = 14,
	VisibleFromReconeDrone                   = 15,
	TransparentState                         = 16,
	EGzWorldVisibilityState_MAX              = 17,
};

// Enum G01.EGzPlayerInputRotatationType
// NumValues: 0x0004
enum class EGzPlayerInputRotatationType : uint8
{
	RT_Turn                                  = 1,
	RT_LookUp                                = 2,
	RT_Roll                                  = 4,
	RT_MAX                                   = 5,
};

// Enum G01.EMissionState
// NumValues: 0x0005
enum class EMissionState : uint8
{
	Inactive                                 = 0,
	InProgress                               = 1,
	Completed                                = 2,
	Failed                                   = 3,
	EMissionState_MAX                        = 4,
};

// Enum G01.EGzMissionType
// NumValues: 0x0006
enum class EGzMissionType : uint8
{
	Unknown                                  = 0,
	Narrative                                = 1,
	Opportunity                              = 2,
	EnclaveOps                               = 3,
	Supplemental                             = 4,
	EGzMissionType_MAX                       = 5,
};

// Enum G01.EGzNotificationStageType
// NumValues: 0x0005
enum class EGzNotificationStageType : uint8
{
	Show                                     = 0,
	HideEnd                                  = 1,
	HideForce                                = 2,
	ConditionFinished                        = 3,
	EGzNotificationStageType_MAX             = 4,
};

// Enum G01.EGzMentalState
// NumValues: 0x0005
enum class EGzMentalState : uint8
{
	Free                                     = 0,
	Alert                                    = 1,
	Combat                                   = 2,
	MoveToPoint                              = 3,
	EGzMentalState_MAX                       = 4,
};

// Enum G01.EGzCharacterDamageAreaType
// NumValues: 0x0009
enum class EGzCharacterDamageAreaType : uint8
{
	CDA_None                                 = 0,
	CDA_Torso                                = 1,
	CDA_Head                                 = 2,
	CDA_LeftArm                              = 3,
	CDA_RightArm                             = 4,
	CDA_Legs                                 = 5,
	CDA_Jetpack                              = 6,
	CDA_Count                                = 7,
	CDA_MAX                                  = 8,
};

// Enum G01.EGzHitResponseType
// NumValues: 0x0010
enum class EGzHitResponseType : uint8
{
	None                                     = 0,
	GenericHit                               = 1,
	BodyHit                                  = 2,
	LimbHit                                  = 3,
	LimbDestroy                              = 4,
	Armor                                    = 5,
	ArmorBreak                               = 6,
	Knockdown                                = 7,
	Headshot                                 = 8,
	Jetpack                                  = 9,
	JetpackDisable                           = 10,
	Kill                                     = 11,
	VehicleHit                               = 12,
	DamageableDestroyed                      = 13,
	HitRejected                              = 14,
	EGzHitResponseType_MAX                   = 15,
};

// Enum G01.EGzWeaponMode
// NumValues: 0x0006
enum class EGzWeaponMode : uint8
{
	Manual                                   = 0,
	SemiAutomatic                            = 1,
	Automatic                                = 2,
	BurstFire                                = 3,
	RepeaterAction                           = 4,
	EGzWeaponMode_MAX                        = 5,
};

// Enum G01.EGzMicroMissileValidationStatus
// NumValues: 0x0006
enum class EGzMicroMissileValidationStatus : uint8
{
	None                                     = 0,
	ValidationRequested                      = 1,
	Validated                                = 2,
	ValidationFailed                         = 3,
	ValidationTimeout                        = 4,
	EGzMicroMissileValidationStatus_MAX      = 5,
};

// Enum G01.EGzAnimationActionType
// NumValues: 0x0008
enum class EGzAnimationActionType : uint8
{
	Idle                                     = 0,
	IdleToLoadout                            = 1,
	LoadoutToLeftArm                         = 2,
	LoadoutToRightArm                        = 3,
	LeftArmToLoadout                         = 4,
	RightArmToLoadout                        = 5,
	LoadoutToIdle                            = 6,
	EGzAnimationActionType_MAX               = 7,
};

// Enum G01.EGzVehicleAxle
// NumValues: 0x0005
enum class EGzVehicleAxle : uint8
{
	Axle_0                                   = 0,
	Axle_1                                   = 1,
	Axle_2                                   = 2,
	Axle_3                                   = 3,
	Axle_MAX                                 = 4,
};

// Enum G01.ELocomotionRotationMode
// NumValues: 0x0004
enum class ELocomotionRotationMode : uint8
{
	Velocity                                 = 0,
	Looking                                  = 1,
	Aiming                                   = 2,
	ELocomotionRotationMode_MAX              = 3,
};

// Enum G01.ELocomotionStance
// NumValues: 0x0007
enum class ELocomotionStance : uint8
{
	Standing                                 = 0,
	Crouching                                = 1,
	Sliding                                  = 2,
	Crawling                                 = 3,
	Grappling                                = 4,
	Legless                                  = 5,
	ELocomotionStance_MAX                    = 6,
};

// Enum G01.ELocomotionMovementState
// NumValues: 0x0009
enum class ELocomotionMovementState : uint8
{
	None                                     = 0,
	Grounded                                 = 1,
	InAir                                    = 2,
	Wingsuit                                 = 3,
	Ragdoll                                  = 4,
	Driving                                  = 5,
	Lean                                     = 6,
	Legless                                  = 7,
	ELocomotionMovementState_MAX             = 8,
};

// Enum G01.ELocomotionOverlayState
// NumValues: 0x0010
enum class ELocomotionOverlayState : uint8
{
	Default                                  = 0,
	Masculine                                = 1,
	Feminine                                 = 2,
	Injured                                  = 3,
	HandsTied                                = 4,
	Rifle                                    = 5,
	Pistol1H                                 = 6,
	Pistol2H                                 = 7,
	Bow                                      = 8,
	Torch                                    = 9,
	Binoculars                               = 10,
	Box                                      = 11,
	Barrel                                   = 12,
	Shield                                   = 13,
	SMG                                      = 14,
	ELocomotionOverlayState_MAX              = 15,
};

// Enum G01.ELocomotionViewMode
// NumValues: 0x0003
enum class ELocomotionViewMode : uint8
{
	FirstPerson                              = 0,
	ThirdPerson                              = 1,
	ELocomotionViewMode_MAX                  = 2,
};

// Enum G01.ELocomotionGait
// NumValues: 0x0004
enum class ELocomotionGait : uint8
{
	Walking                                  = 0,
	Running                                  = 1,
	Sprinting                                = 2,
	ELocomotionGait_MAX                      = 3,
};

// Enum G01.EGzNpcActionStates
// NumValues: 0x0006
enum class EGzNpcActionStates : uint8
{
	Idle                                     = 0,
	Patrolling                               = 1,
	Peer                                     = 2,
	CheckStimulus                            = 3,
	Attack                                   = 4,
	EGzNpcActionStates_MAX                   = 5,
};

// Enum G01.EGzAutotestComponentState
// NumValues: 0x0007
enum class EGzAutotestComponentState : uint8
{
	Invalid                                  = 0,
	Failed                                   = 1,
	Succeeded                                = 2,
	Running                                  = 4,
	Stopped                                  = 8,
	NotStarted                               = 16,
	EGzAutotestComponentState_MAX            = 17,
};

// Enum G01.ERootYawOffsetType
// NumValues: 0x0004
enum class ERootYawOffsetType : uint8
{
	BlendOut                                 = 0,
	Hold                                     = 1,
	Accumulate                               = 2,
	ERootYawOffsetType_MAX                   = 3,
};

// Enum G01.ECardinalDirectionType
// NumValues: 0x0005
enum class ECardinalDirectionType : uint8
{
	Forward                                  = 0,
	Backward                                 = 1,
	Left                                     = 2,
	Right                                    = 3,
	ECardinalDirectionType_MAX               = 4,
};

// Enum G01.ELeanType
// NumValues: 0x0006
enum class ELeanType : uint8
{
	None                                     = 0,
	Idle                                     = 1,
	Left                                     = 2,
	Right                                    = 3,
	Top                                      = 4,
	ELeanType_MAX                            = 5,
};

// Enum G01.EAnimStances
// NumValues: 0x0004
enum class EAnimStances : uint8
{
	RelaxedStance                            = 0,
	Hipfire                                  = 1,
	Aiming                                   = 2,
	EAnimStances_MAX                         = 3,
};

// Enum G01.EGzGA_ActivationState
// NumValues: 0x0006
enum class EGzGA_ActivationState : uint8
{
	OnPreActivate                            = 0,
	OnPostActivate                           = 1,
	OnPreEnd                                 = 2,
	OnPostEnd                                = 3,
	OnAny                                    = 4,
	EGzGA_MAX                                = 5,
};

// Enum G01.EGzActionNetExecution
// NumValues: 0x0004
enum class EGzActionNetExecution : uint8
{
	None                                     = 0,
	Authority                                = 1,
	LocalControlled                          = 2,
	EGzActionNetExecution_MAX                = 3,
};

// Enum G01.EGzAsyncTraceType
// NumValues: 0x0004
enum class EGzAsyncTraceType : uint8
{
	Test                                     = 0,
	Single                                   = 1,
	Multi                                    = 2,
	EGzAsyncTraceType_MAX                    = 3,
};

// Enum G01.ENPCType
// NumValues: 0x0007
enum class ENPCType : uint8
{
	None                                     = 0,
	Common                                   = 1,
	Turrel                                   = 2,
	Camera                                   = 3,
	MirrorBreaker                            = 4,
	Drone                                    = 5,
	ENPCType_MAX                             = 6,
};

// Enum G01.EGzNPCMentalState
// NumValues: 0x0004
enum class EGzNPCMentalState : uint8
{
	Free                                     = 0,
	Alert                                    = 1,
	Combat                                   = 2,
	EGzNPCMentalState_MAX                    = 3,
};

// Enum G01.EGzAssetCacheType
// NumValues: 0x000C
enum class EGzAssetCacheType : uint8
{
	Items                                    = 0,
	Missions                                 = 1,
	Assignments                              = 2,
	Challenges                               = 3,
	Achievements                             = 4,
	BattlePasses                             = 5,
	BattlePassUiDatas                        = 6,
	Seasons                                  = 7,
	Goals                                    = 8,
	Rewards                                  = 9,
	Count                                    = 10,
	EGzAssetCacheType_MAX                    = 11,
};

// Enum G01.EGzCustomInputEvent
// NumValues: 0x0008
enum class EGzCustomInputEvent : uint8
{
	CUSTOM_Invalid                           = 0,
	CUSTOM_Press_DefaultEvent                = 6,
	CUSTOM_Press_OptionalEvent1              = 7,
	CUSTOM_Press_OptionalEvent2              = 8,
	CUSTOM_Release_DefaultEvent              = 9,
	CUSTOM_Release_OptionalEvent1            = 10,
	CUSTOM_Release_OptionalEvent2            = 11,
	CUSTOM_MAX                               = 12,
};

// Enum G01.EGzEquipTaskType
// NumValues: 0x0003
enum class EGzEquipTaskType : uint8
{
	Holster                                  = 0,
	Unholster                                = 1,
	EGzEquipTaskType_MAX                     = 2,
};

// Enum G01.EGzCustomCheckingState
// NumValues: 0x0004
enum class EGzCustomCheckingState : uint8
{
	Passed                                   = 0,
	Failed                                   = 1,
	CheckNext                                = 2,
	EGzCustomCheckingState_MAX               = 3,
};

// Enum G01.EGzServerHostingStatus
// NumValues: 0x0005
enum class EGzServerHostingStatus : uint8
{
	Active                                   = 0,
	Pending                                  = 1,
	Starting                                 = 2,
	Failed                                   = 3,
	EGzServerHostingStatus_MAX               = 4,
};

// Enum G01.EGzBattlePassPageContentType
// NumValues: 0x0003
enum class EGzBattlePassPageContentType : uint8
{
	Customization                            = 0,
	Loadout                                  = 1,
	EGzBattlePassPageContentType_MAX         = 2,
};

// Enum G01.EGzBattlePassSlotRewardTypeV2
// NumValues: 0x0003
enum class EGzBattlePassSlotRewardTypeV2 : uint32
{
	DirectHex                                = 0,
	Currency                                 = 1,
	EGzBattlePassSlotRewardTypeV2_MAX        = 2,
};

// Enum G01.EGzBattleRoyaleMatchState
// NumValues: 0x000B
enum class EGzBattleRoyaleMatchState : uint8
{
	EnteringMap                              = 0,
	BackendSetup                             = 1,
	WaitingForPlayers                        = 2,
	StartCountdown                           = 3,
	PrepareForStart                          = 4,
	InProgress                               = 5,
	WaitingPostMatch                         = 6,
	LeavingMap                               = 7,
	Aborted                                  = 8,
	LAST                                     = 9,
	EGzBattleRoyaleMatchState_MAX            = 10,
};

// Enum G01.EDepthStencilValue
// NumValues: 0x0018
enum class EDepthStencilValue : uint8
{
	None                                     = 0,
	ControlledPlayer                         = 1,
	Teammates                                = 2,
	Revealed                                 = 3,
	SelectionOutlineGeneral                  = 4,
	PickupOutlineCommon                      = 5,
	PickupOutlineRare                        = 6,
	PickupOutlineEpic                        = 7,
	PickupOutlineExotic                      = 8,
	PickupOutlineLegendary                   = 9,
	DefilerBody                              = 10,
	DefilerLimb                              = 11,
	DefilerLootBox                           = 12,
	DefilerLimbFriend                        = 13,
	DefilerBodyFriend                        = 14,
	DefilerMissionTarget                     = 15,
	DefilerRedeploymentTerminal              = 16,
	DefilerExtractor                         = 17,
	RevealedByReconeDrone                    = 18,
	DefilerLootBoxType1                      = 19,
	DefilerLootBoxType2                      = 20,
	Transparent                              = 21,
	Count                                    = 22,
	EDepthStencilValue_MAX                   = 23,
};

// Enum G01.EGzInputMode
// NumValues: 0x0004
enum class EGzInputMode : uint8
{
	GameOnly                                 = 0,
	UIOnly                                   = 1,
	GameAndUI                                = 2,
	EGzInputMode_MAX                         = 3,
};

// Enum G01.EGzAbilityInputModifier
// NumValues: 0x0005
enum class EGzAbilityInputModifier : uint8
{
	None                                     = 0,
	Press                                    = 1,
	Release                                  = 2,
	Hold                                     = 3,
	EGzAbilityInputModifier_MAX              = 4,
};

// Enum G01.EGzCameraModeOverlay
// NumValues: 0x0003
enum class EGzCameraModeOverlay : uint8
{
	Overlay                                  = 0,
	Additive                                 = 1,
	EGzCameraModeOverlay_MAX                 = 2,
};

// Enum G01.EGzWheelGroup
// NumValues: 0x0005
enum class EGzWheelGroup : uint8
{
	FrontLeft                                = 0,
	FrontRight                               = 1,
	RearLeft                                 = 2,
	RearRight                                = 3,
	EGzWheelGroup_MAX                        = 4,
};

// Enum G01.EGzSchedulingType
// NumValues: 0x0006
enum class EGzSchedulingType : uint8
{
	ScheduleUndefined                        = 0,
	ScheduleDaily                            = 1,
	ScheduleWeekly                           = 2,
	ScheduleMonthly                          = 3,
	ScheduleCount                            = 4,
	EGzSchedulingType_MAX                    = 5,
};

// Enum G01.EGzZiplineEventType
// NumValues: 0x0005
enum class EGzZiplineEventType : uint8
{
	Start                                    = 0,
	Loop                                     = 1,
	End                                      = 2,
	Cancel                                   = 3,
	EGzZiplineEventType_MAX                  = 4,
};

// Enum G01.EGzCharacterCustomizationBodyMaskType
// NumValues: 0x0008
enum class EGzCharacterCustomizationBodyMaskType : uint8
{
	Head                                     = 0,
	Torso                                    = 1,
	LeftArm                                  = 2,
	RightArm                                 = 3,
	Legs                                     = 4,
	Jetpack                                  = 5,
	Count                                    = 6,
	EGzCharacterCustomizationBodyMaskType_MAX = 7,
};

// Enum G01.EGzCustomizationModifierType
// NumValues: 0x0009
enum class EGzCustomizationModifierType : uint8
{
	None                                     = 0,
	MaterialScalar                           = 1,
	MaterialVector                           = 2,
	Scale                                    = 3,
	MaterialColor                            = 4,
	MaterialAsset                            = 5,
	MaterialColorPalette                     = 6,
	TextureAsset                             = 7,
	EGzCustomizationModifierType_MAX         = 8,
};

// Enum G01.EGzRootMotionSourceType
// NumValues: 0x0006
enum class EGzRootMotionSourceType : uint8
{
	Invalid                                  = 0,
	JetpackLandingRollName                   = 1,
	ZiplineMotionName                        = 2,
	ZiplineJumpOffMotionName                 = 3,
	SmashLandingJumpName                     = 4,
	EGzRootMotionSourceType_MAX              = 5,
};

// Enum G01.EGzCharacterAliveState
// NumValues: 0x0003
enum class EGzCharacterAliveState : uint8
{
	Alive                                    = 0,
	KnockedDown                              = 1,
	EGzCharacterAliveState_MAX               = 2,
};

// Enum G01.EGzAdvancedLocomotionState
// NumValues: 0x0005
enum class EGzAdvancedLocomotionState : uint8
{
	Standing                                 = 0,
	Crouching                                = 1,
	Aiming                                   = 2,
	CrouchingAndAiming                       = 3,
	EGzAdvancedLocomotionState_MAX           = 4,
};

// Enum G01.EGzCustomMovementMode
// NumValues: 0x000E
enum class EGzCustomMovementMode : uint8
{
	CMOVE_Sliding                            = 0,
	CMOVE_Grappling                          = 1,
	CMOVE_Wingsuit                           = 2,
	CMOVE_Driving                            = 3,
	CMOVE_Sprint                             = 4,
	CMOVE_SuperSprint                        = 5,
	CMOVE_Jumping                            = 6,
	CMOVE_Dashing                            = 7,
	CMOVE_Leaning                            = 8,
	CMOVE_Legless_Move                       = 9,
	CMOVE_Legless_Aim                        = 10,
	CMOVE_Mantling                           = 11,
	CMOVE_Hover                              = 12,
	CMOVE_MAX                                = 13,
};

// Enum G01.EGzItemChangeState
// NumValues: 0x0003
enum class EGzItemChangeState : uint8
{
	Added                                    = 0,
	Removed                                  = 1,
	EGzItemChangeState_MAX                   = 2,
};

// Enum G01.EGzClientTelemetryMetricsType
// NumValues: 0x0004
enum class EGzClientTelemetryMetricsType : uint8
{
	Unknown                                  = 0,
	FPS                                      = 1,
	Latency                                  = 2,
	EGzClientTelemetryMetricsType_MAX        = 3,
};

// Enum G01.EGzUserTokenType
// NumValues: 0x0006
enum class EGzUserTokenType : uint8
{
	Email                                    = 0,
	PlayFabId                                = 1,
	TitleUserName                            = 2,
	Username                                 = 3,
	EpicAccountId                            = 4,
	EGzUserTokenType_MAX                     = 5,
};

// Enum G01.EGzCohtmlBattlePassPageLockReasonV2
// NumValues: 0x0005
enum class EGzCohtmlBattlePassPageLockReasonV2 : uint32
{
	Undefined                                = 0,
	Loyalty                                  = 1,
	Subscription                             = 2,
	Level                                    = 3,
	EGzCohtmlBattlePassPageLockReasonV2_MAX  = 4,
};

// Enum G01.EGzCohtmlCriticalMessageType
// NumValues: 0x0017
enum class EGzCohtmlCriticalMessageType : uint8
{
	Unknown                                  = 0,
	UnsupportedNetMode                       = 1,
	GrantItemsStarted                        = 2,
	GrantItemsEnded                          = 3,
	RevokeItemsStarted                       = 4,
	RevokeItemsEnded                         = 5,
	VersionOutdated                          = 6,
	InventoryEmptyCollections                = 7,
	InventoryCoinsItemMissing                = 8,
	BackendRequestFailed                     = 9,
	EpicLoginFailed                          = 10,
	EpicProductMissing                       = 11,
	EpicAutologinWrongArgs                   = 12,
	InventoryCatalogAccessChanged            = 13,
	ClientDisabled                           = 14,
	AccountBanned                            = 15,
	CrucialPlayerDataChanged                 = 16,
	DiscoveryFailed                          = 17,
	LoginFailed                              = 18,
	ConsoleNetworkFailure                    = 19,
	ServerNotAccessible                      = 20,
	ConfirmSigningAgreementsFailed           = 21,
	EGzCohtmlCriticalMessageType_MAX         = 22,
};

// Enum G01.EGzCohtmlCriticalMessageButton
// NumValues: 0x0006
enum class EGzCohtmlCriticalMessageButton : uint32
{
	None                                     = 18446744073709551615,
	Ok                                       = 0,
	Cancel                                   = 1,
	Retry                                    = 2,
	Discard                                  = 3,
	EGzCohtmlCriticalMessageButton_MAX       = 4,
};

// Enum G01.EGzCohtmlCriticalMessageAction
// NumValues: 0x0004
enum class EGzCohtmlCriticalMessageAction : uint32
{
	None                                     = 18446744073709551615,
	Default                                  = 0,
	ReloadMetagame                           = 1,
	EGzCohtmlCriticalMessageAction_MAX       = 2,
};

// Enum G01.EGzCohtmlFriendOnlineStatus
// NumValues: 0x0005
enum class EGzCohtmlFriendOnlineStatus : uint32
{
	Unknown                                  = 0,
	Offline                                  = 1,
	Online                                   = 2,
	Custom                                   = 3,
	EGzCohtmlFriendOnlineStatus_MAX          = 4,
};

// Enum G01.EGzCohtmlGameModeAvailability
// NumValues: 0x0005
enum class EGzCohtmlGameModeAvailability : uint8
{
	Available                                = 0,
	Disabled                                 = 1,
	PartySizeOverLimit                       = 2,
	ComingSoon                               = 3,
	EGzCohtmlGameModeAvailability_MAX        = 4,
};

// Enum G01.EGzCohtmlListMarketOrder
// NumValues: 0x0003
enum class EGzCohtmlListMarketOrder : uint8
{
	Ascending                                = 0,
	Descending                               = 1,
	EGzCohtmlListMarketOrder_MAX             = 2,
};

// Enum G01.EGzCohtmlListMarketOrderType
// NumValues: 0x0003
enum class EGzCohtmlListMarketOrderType : uint8
{
	Price                                    = 0,
	Time                                     = 1,
	EGzCohtmlListMarketOrderType_MAX         = 2,
};

// Enum G01.EGzCohtmlSettingType
// NumValues: 0x0004
enum class EGzCohtmlSettingType : uint8
{
	Scalar                                   = 0,
	Discrete                                 = 1,
	KeyboardInput                            = 2,
	EGzCohtmlSettingType_MAX                 = 3,
};

// Enum G01.EGzCohtmlSubscriptionType
// NumValues: 0x0003
enum class EGzCohtmlSubscriptionType : uint8
{
	None                                     = 0,
	OtgPro                                   = 1,
	EGzCohtmlSubscriptionType_MAX            = 2,
};

// Enum G01.EGzCohtmlMarketplaceTransactionStatus
// NumValues: 0x0004
enum class EGzCohtmlMarketplaceTransactionStatus : uint8
{
	Pending                                  = 0,
	Completed                                = 1,
	Failed                                   = 2,
	EGzCohtmlMarketplaceTransactionStatus_MAX = 3,
};

// Enum G01.EGzRewardSource
// NumValues: 0x0009
enum class EGzRewardSource : uint32
{
	Other                                    = 0,
	Kills                                    = 1,
	Assists                                  = 2,
	Knockdowns                               = 3,
	CommonHexes                              = 4,
	RareHexes                                = 5,
	EpicHexes                                = 6,
	Placement                                = 7,
	EGzRewardSource_MAX                      = 8,
};

// Enum G01.EGzComebackArenaAvailability
// NumValues: 0x0004
enum class EGzComebackArenaAvailability : uint8
{
	BattleRoyale                             = 0,
	Deathmatch                               = 1,
	Everywhere                               = 2,
	EGzComebackArenaAvailability_MAX         = 3,
};

// Enum G01.EGzComebackArenaCandidateState
// NumValues: 0x0004
enum class EGzComebackArenaCandidateState : uint8
{
	None                                     = 0,
	InQueue                                  = 1,
	InMatch                                  = 2,
	EGzComebackArenaCandidateState_MAX       = 3,
};

// Enum G01.EGzChallengeScope
// NumValues: 0x0006
enum class EGzChallengeScope : uint8
{
	None                                     = 0,
	Daily                                    = 1,
	Weekly                                   = 2,
	Monthly                                  = 3,
	Count                                    = 4,
	EGzChallengeScope_MAX                    = 5,
};

// Enum G01.EGzSatisfyPolicy
// NumValues: 0x0003
enum class EGzSatisfyPolicy : uint8
{
	Retrigger                                = 0,
	NonRetrigger                             = 1,
	EGzSatisfyPolicy_MAX                     = 2,
};

// Enum G01.EGzConnectionState
// NumValues: 0x0006
enum class EGzConnectionState : uint8
{
	None                                     = 0,
	Connected                                = 1,
	PendingReconnect                         = 2,
	LeftMatch                                = 3,
	Disconnected                             = 4,
	EGzConnectionState_MAX                   = 5,
};

// Enum G01.EGzConsoleCreateMatchType
// NumValues: 0x0004
enum class EGzConsoleCreateMatchType : uint8
{
	None                                     = 0,
	ExtractionRoyale                         = 1,
	BattleRoyale                             = 2,
	EGzConsoleCreateMatchType_MAX            = 3,
};

// Enum G01.EGzCoverSide
// NumValues: 0x0004
enum class EGzCoverSide : uint8
{
	Left                                     = 0,
	Right                                    = 1,
	Top                                      = 2,
	EGzCoverSide_MAX                         = 3,
};

// Enum G01.EGzCrossHairState
// NumValues: 0x0006
enum class EGzCrossHairState : uint8
{
	None                                     = 0,
	Unarmed                                  = 1,
	Weapon                                   = 2,
	Limb                                     = 3,
	OperableObject                           = 4,
	MAX                                      = 5,
};

// Enum G01.EGzLimbWidgetFlags
// NumValues: 0x0008
enum class EGzLimbWidgetFlags : uint8
{
	Invalid                                  = 0,
	LimbValid                                = 1,
	LimbAbilityValid                         = 2,
	HaveMaxCharges                           = 4,
	Recharging                               = 8,
	OnCooldown                               = 16,
	LimbAbilityComponentValid                = 32,
	EGzLimbWidgetFlags_MAX                   = 33,
};

// Enum G01.EGzLimbWidgetState
// NumValues: 0x0006
enum class EGzLimbWidgetState : uint8
{
	Default                                  = 0,
	Empty                                    = 1,
	Active                                   = 2,
	Disabled                                 = 3,
	Cooldown                                 = 4,
	EGzLimbWidgetState_MAX                   = 5,
};

// Enum G01.EGzDamageIndicatorTempType
// NumValues: 0x0004
enum class EGzDamageIndicatorTempType : uint8
{
	Default                                  = 0,
	Directionless                            = 1,
	Critical                                 = 2,
	EGzDamageIndicatorTempType_MAX           = 3,
};

// Enum G01.EGzArmorProtectionMask
// NumValues: 0x0006
enum class EGzArmorProtectionMask : uint8
{
	None                                     = 0,
	Torso                                    = 1,
	Head                                     = 2,
	Arms                                     = 4,
	Legs                                     = 8,
	EGzArmorProtectionMask_MAX               = 9,
};

// Enum G01.EGzDashType
// NumValues: 0x0005
enum class EGzDashType : uint8
{
	None                                     = 0,
	Katana                                   = 1,
	Gorilla                                  = 2,
	SmashLanding                             = 3,
	EGzDashType_MAX                          = 4,
};

// Enum G01.EGzDebugMenuVariableType
// NumValues: 0x0005
enum class EGzDebugMenuVariableType : uint8
{
	Bool                                     = 0,
	Int                                      = 1,
	Float                                    = 2,
	String                                   = 3,
	EGzDebugMenuVariableType_MAX             = 4,
};

// Enum G01.EGzDefilerTargetType
// NumValues: 0x000B
enum class EGzDefilerTargetType : uint8
{
	Invalid                                  = 0,
	Character                                = 1,
	LootContainer                            = 2,
	Vehicle                                  = 3,
	MissionObject                            = 4,
	RedeploymentTerminal                     = 5,
	Extractor                                = 6,
	EnemyObject                              = 7,
	LootContainerType1                       = 8,
	LootContainerType2                       = 9,
	EGzDefilerTargetType_MAX                 = 10,
};

// Enum G01.EGzDestructibleHitType
// NumValues: 0x0007
enum class EGzDestructibleHitType : uint8
{
	None                                     = 0,
	Character                                = 1,
	Vehicle                                  = 2,
	Bullet                                   = 4,
	Explosion                                = 8,
	All                                      = 15,
	EGzDestructibleHitType_MAX               = 16,
};

// Enum G01.EGzEffectPropagationType
// NumValues: 0x0003
enum class EGzEffectPropagationType : uint8
{
	None                                     = 0,
	Fire                                     = 1,
	EGzEffectPropagationType_MAX             = 2,
};

// Enum G01.EGzEpicPartyState
// NumValues: 0x0006
enum class EGzEpicPartyState : uint8
{
	None                                     = 0,
	Creating                                 = 1,
	Joining                                  = 2,
	Joined                                   = 3,
	Leaving                                  = 4,
	EGzEpicPartyState_MAX                    = 5,
};

// Enum G01.EGzEquipState
// NumValues: 0x0004
enum class EGzEquipState : uint8
{
	None                                     = 0,
	EEquipMonatge                            = 1,
	EUnEquipMonatge                          = 2,
	MAX                                      = 3,
};

// Enum G01.EGzExecResult
// NumValues: 0x0003
enum class EGzExecResult : uint8
{
	Valid                                    = 1,
	NotValid                                 = 0,
	EGzExecResult_MAX                        = 2,
};

// Enum G01.EGzFlowState
// NumValues: 0x001B
enum class EGzFlowState : uint8
{
	Undefined                                = 0,
	PreInit                                  = 1,
	Init                                     = 2,
	PlatformLogin                            = 3,
	PreLogin                                 = 4,
	Login                                    = 5,
	LoginQueue                               = 6,
	PostLogin                                = 7,
	InitialSetupController                   = 8,
	LegalDocs                                = 9,
	InitialSettingsConfiguration             = 10,
	CharacterCreation                        = 11,
	PlayerDataLoading                        = 12,
	PlayerDataSetup                          = 13,
	LobbyGate                                = 14,
	Onboarding                               = 15,
	Hideout                                  = 16,
	OfflineSessionPreTravel                  = 17,
	OfflineSessionTravel                     = 18,
	OfflineSession                           = 19,
	PreTravelToOnlineSession                 = 20,
	TravelToOnlineSession                    = 21,
	OnlineSession                            = 22,
	TravelFromOnlineSession                  = 23,
	PostmatchLoading                         = 24,
	Postmatch                                = 25,
	EGzFlowState_MAX                         = 26,
};

// Enum G01.EGzGadgetMovementState
// NumValues: 0x0004
enum class EGzGadgetMovementState : uint8
{
	None                                     = 0,
	InMove                                   = 1,
	OnPosition                               = 2,
	EGzGadgetMovementState_MAX               = 3,
};

// Enum G01.EGzCohtmlUrl
// NumValues: 0x0005
enum class EGzCohtmlUrl : uint32
{
	Production                               = 0,
	Local                                    = 1,
	ApiTest                                  = 2,
	Custom                                   = 3,
	EGzCohtmlUrl_MAX                         = 4,
};

// Enum G01.EGzGameModeVariation
// NumValues: 0x0005
enum class EGzGameModeVariation : uint8
{
	Unset                                    = 0,
	Solo                                     = 1,
	Duos                                     = 2,
	Trios                                    = 3,
	EGzGameModeVariation_MAX                 = 4,
};

// Enum G01.EGzNotificationGroupType
// NumValues: 0x0008
enum class EGzNotificationGroupType : uint8
{
	Default                                  = 0,
	Success                                  = 1,
	Error                                    = 2,
	Warning                                  = 3,
	Mission                                  = 4,
	MissionFailed                            = 5,
	MissionSuccess                           = 6,
	EGzNotificationGroupType_MAX             = 7,
};

// Enum G01.EGzNotificationBodyIconSizeType
// NumValues: 0x0004
enum class EGzNotificationBodyIconSizeType : uint8
{
	Default                                  = 0,
	Small                                    = 1,
	Big                                      = 2,
	EGzNotificationBodyIconSizeType_MAX      = 3,
};

// Enum G01.EGzNotificationTextType
// NumValues: 0x0007
enum class EGzNotificationTextType : uint8
{
	Default                                  = 0,
	MissionReward                            = 1,
	DoubleText                               = 2,
	StageTime                                = 3,
	NotCompositeText                         = 4,
	DeploymentCounter                        = 5,
	EGzNotificationTextType_MAX              = 6,
};

// Enum G01.EGzNotificationTimerType
// NumValues: 0x0004
enum class EGzNotificationTimerType : uint8
{
	Disabled                                 = 0,
	Time                                     = 1,
	Counter                                  = 2,
	EGzNotificationTimerType_MAX             = 3,
};

// Enum G01.EGzGameNotificationType
// NumValues: 0x0003
enum class EGzGameNotificationType : uint8
{
	Primary                                  = 0,
	Secondary                                = 1,
	EGzGameNotificationType_MAX              = 2,
};

// Enum G01.EGzGameNotificationBodyType
// NumValues: 0x0006
enum class EGzGameNotificationBodyType : uint8
{
	None                                     = 0,
	Icon                                     = 1,
	Timer                                    = 2,
	IconAndTimer                             = 3,
	Counter                                  = 4,
	EGzGameNotificationBodyType_MAX          = 5,
};

// Enum G01.EGzInputEvent
// NumValues: 0x0003
enum class EGzInputEvent : uint8
{
	Pressed                                  = 0,
	Released                                 = 1,
	EGzInputEvent_MAX                        = 2,
};

// Enum G01.EGzGetSubsystemResult
// NumValues: 0x0003
enum class EGzGetSubsystemResult : uint8
{
	Success                                  = 1,
	Failed                                   = 0,
	EGzGetSubsystemResult_MAX                = 2,
};

// Enum G01.ETagHandlerRole
// NumValues: 0x0005
enum class ETagHandlerRole : uint8
{
	None                                     = 0,
	Authority                                = 1,
	AutonomousProxy                          = 2,
	SimulatedProxy                           = 4,
	ETagHandlerRole_MAX                      = 5,
};

// Enum G01.EGzSettingsPresence
// NumValues: 0x0005
enum class EGzSettingsPresence : uint8
{
	None                                     = 0,
	Lobby                                    = 1,
	Game                                     = 2,
	All                                      = 3,
	EGzSettingsPresence_MAX                  = 4,
};

// Enum G01.EGzGameStatCollectionStage
// NumValues: 0x0006
enum class EGzGameStatCollectionStage : uint8
{
	Undefined                                = 0,
	PreMatch                                 = 1,
	InMatch                                  = 2,
	PostMatch                                = 4,
	FullGame                                 = 3,
	EGzGameStatCollectionStage_MAX           = 5,
};

// Enum G01.EGzStatSharingType
// NumValues: 0x0005
enum class EGzStatSharingType : uint8
{
	None                                     = 0,
	Personal                                 = 1,
	Team                                     = 2,
	Global                                   = 3,
	EGzStatSharingType_MAX                   = 4,
};

// Enum G01.EGzAudioSettingsChangeType
// NumValues: 0x0011
enum class EGzAudioSettingsChangeType : uint8
{
	None                                     = 0,
	MainVolume                               = 1,
	MusicVolume                              = 2,
	SfxVolume                                = 3,
	DialogueVolume                           = 4,
	MatchStateAnnouncerVolume                = 5,
	PersonalAssistantVolume                  = 6,
	CharacterVoiceVolume                     = 7,
	VoiceChatVolume                          = 8,
	VoiceChatState                           = 9,
	VoiceCharInputDeviceId                   = 10,
	VoiceCharOutputDeviceId                  = 11,
	MicrophoneSensitivity                    = 12,
	AudioPreset                              = 13,
	PersonalAssistantVoiceType               = 14,
	EnableControllerVibration                = 15,
	EGzAudioSettingsChangeType_MAX           = 16,
};

// Enum G01.EGzKatanaArmAttackType
// NumValues: 0x0005
enum class EGzKatanaArmAttackType : uint8
{
	None                                     = 0,
	Ground_Horizontal                        = 1,
	Air_Vertical                             = 2,
	Air_MidAir                               = 3,
	EGzKatanaArmAttackType_MAX               = 4,
};

// Enum G01.EQuickMeleeAttackType
// NumValues: 0x000B
enum class EQuickMeleeAttackType : uint8
{
	None                                     = 0,
	RifleTwoHanded                           = 1,
	RifleLeftHanded                          = 2,
	RifleRightHanded                         = 3,
	PistolTwoHanded                          = 4,
	PistolLeftHanded                         = 5,
	PistolRightHanded                        = 6,
	NoWeaponTwoHanded                        = 7,
	NoWeaponLeftHanded                       = 8,
	NoWeaponRightHanded                      = 9,
	EQuickMeleeAttackType_MAX                = 10,
};

// Enum G01.EGzGA_WeaponAttack_CustomEvents
// NumValues: 0x000E
enum class EGzGA_WeaponAttack_CustomEvents : uint8
{
	None                                     = 0,
	HitResponse_Hit                          = 1,
	HitResponse_Body_Hit                     = 2,
	HitResponse_Hit_Armor                    = 3,
	HitResponse_ArmorBreak                   = 4,
	HitResponse_LimbDestroy                  = 5,
	HitResponse_JetpackDisable               = 6,
	HitResponse_JetpackHit                   = 7,
	HitResponse_Knockdown                    = 8,
	HitResponse_Kill                         = 9,
	HitResponse_VehicleHit                   = 10,
	HitResponse_DamageableDestroyed          = 11,
	HitResponse_HitRejected                  = 12,
	EGzGA_WeaponAttack_MAX                   = 13,
};

// Enum G01.EGzGA_Wingsuit_CustomEvents
// NumValues: 0x0004
enum class EGzGA_Wingsuit_CustomEvents : uint8
{
	Start                                    = 0,
	BounceOff                                = 1,
	AboutToLand                              = 2,
	EGzGA_Wingsuit_MAX                       = 3,
};

// Enum G01.EGzGrappleHookState
// NumValues: 0x0006
enum class EGzGrappleHookState : uint8
{
	Detached                                 = 0,
	Aiming                                   = 1,
	HookFlyingToTarget                       = 2,
	HookFlyingBack                           = 3,
	Pulling                                  = 4,
	EGzGrappleHookState_MAX                  = 5,
};

// Enum G01.EGzHitmarkCategory
// NumValues: 0x0004
enum class EGzHitmarkCategory : uint8
{
	Hit                                      = 0,
	Event                                    = 1,
	Debug                                    = 2,
	EGzHitmarkCategory_MAX                   = 3,
};

// Enum G01.EGzInteractableHighlightState
// NumValues: 0x0004
enum class EGzInteractableHighlightState : uint8
{
	None                                     = 0,
	Focused                                  = 1,
	Defilered                                = 2,
	EGzInteractableHighlightState_MAX        = 3,
};

// Enum G01.EGzInteractionType
// NumValues: 0x0004
enum class EGzInteractionType : uint8
{
	PressInstant                             = 0,
	PressWithTimer                           = 1,
	Hold                                     = 2,
	EGzInteractionType_MAX                   = 3,
};

// Enum G01.EGzInteractionStageType
// NumValues: 0x0005
enum class EGzInteractionStageType : uint8
{
	None                                     = 0,
	PreInteraction                           = 1,
	Interaction                              = 2,
	PostInteraction                          = 3,
	EGzInteractionStageType_MAX              = 4,
};

// Enum G01.EGzInteractionTriggerType
// NumValues: 0x0003
enum class EGzInteractionTriggerType : uint8
{
	Instant                                  = 0,
	Hold                                     = 1,
	EGzInteractionTriggerType_MAX            = 2,
};

// Enum G01.EGzInteractionProcessType
// NumValues: 0x0004
enum class EGzInteractionProcessType : uint8
{
	MontageBased                             = 0,
	DurationBased                            = 1,
	UserInputBased                           = 2,
	EGzInteractionProcessType_MAX            = 3,
};

// Enum G01.EGzInventoryItemUser
// NumValues: 0x0006
enum class EGzInventoryItemUser : uint8
{
	None                                     = 0,
	Appearance                               = 1,
	Emote                                    = 2,
	Loadouts                                 = 3,
	WeaponConfiguration                      = 4,
	EGzInventoryItemUser_MAX                 = 5,
};

// Enum G01.EGzItemRarity
// NumValues: 0x0008
enum class EGzItemRarity : uint8
{
	None                                     = 0,
	Common                                   = 1,
	Rare                                     = 2,
	Epic                                     = 3,
	Exotic                                   = 4,
	Legendary                                = 5,
	_Last                                    = 6,
	EGzItemRarity_MAX                        = 7,
};

// Enum G01.EGzItemAccessPermission
// NumValues: 0x0004
enum class EGzItemAccessPermission : uint8
{
	None                                     = 0,
	Player                                   = 1,
	NPC                                      = 2,
	EGzItemAccessPermission_MAX              = 3,
};

// Enum G01.EGzHexType
// NumValues: 0x000A
enum class EGzHexType : uint8
{
	Undefined                                = 0,
	BodyPart                                 = 1,
	Consumable                               = 2,
	Weapon                                   = 3,
	WeaponSkin                               = 4,
	WeaponAttachment                         = 5,
	Customization                            = 6,
	Pro                                      = 7,
	LastItemType                             = 8,
	EGzHexType_MAX                           = 9,
};

// Enum G01.EGzPartItemType
// NumValues: 0x0006
enum class EGzPartItemType : uint8
{
	PartItem1                                = 0,
	PartItem2                                = 1,
	PartItem3                                = 2,
	PartItem4                                = 3,
	Num                                      = 4,
	EGzPartItemType_MAX                      = 5,
};

// Enum G01.EGzItemMeshType
// NumValues: 0x0004
enum class EGzItemMeshType : uint8
{
	None                                     = 0,
	Static                                   = 1,
	Skeletal                                 = 2,
	EGzItemMeshType_MAX                      = 3,
};

// Enum G01.EGzItemType
// NumValues: 0x0010
enum class EGzItemType : uint8
{
	BodyPart                                 = 0,
	BodyPartSkin                             = 1,
	Consumable                               = 2,
	Weapon                                   = 3,
	WeaponSkin                               = 4,
	WeaponAttachment                         = 5,
	WeaponAttachmentSkin                     = 6,
	Ammo                                     = 7,
	Misc                                     = 8,
	Container                                = 9,
	Bundle                                   = 10,
	CustomizationItemTemplate                = 11,
	Backpack                                 = 12,
	Currency                                 = 13,
	LastItemType                             = 14,
	EGzItemType_MAX                          = 15,
};

// Enum G01.EGzLayerItemType
// NumValues: 0x000B
enum class EGzLayerItemType : uint8
{
	UnarmedALayer                            = 0,
	PistolALayer                             = 1,
	ShotgunALayer                            = 2,
	SMGALayer                                = 3,
	AssaultRifleALayer                       = 4,
	SniperRifleALayer                        = 5,
	MarksmanRifleALayer                      = 6,
	LMGALayer                                = 7,
	TetherLayer                              = 8,
	LastLayer                                = 9,
	EGzLayerItemType_MAX                     = 10,
};

// Enum G01.EGzItemCollectionType
// NumValues: 0x0008
enum class EGzItemCollectionType : uint8
{
	Avalanche                                = 0,
	OpenSea                                  = 1,
	SuperVerse                               = 2,
	Paid                                     = 3,
	LayerZero                                = 4,
	NeoTokyo                                 = 5,
	LastCollectionType                       = 6,
	EGzItemCollectionType_MAX                = 7,
};

// Enum G01.EGzLimbAttachingProxyState
// NumValues: 0x0006
enum class EGzLimbAttachingProxyState : uint32
{
	None                                     = 0,
	InitializingAndSettingUp                 = 1,
	Flying                                   = 2,
	StillFlyingButPendingCancel              = 3,
	WaitingForDestroy                        = 4,
	EGzLimbAttachingProxyState_MAX           = 5,
};

// Enum G01.EGzSoundSourceBodyPart
// NumValues: 0x0007
enum class EGzSoundSourceBodyPart : uint8
{
	None                                     = 0,
	LeftArm                                  = 1,
	RightArm                                 = 2,
	LeftLeg                                  = 3,
	RightLeg                                 = 4,
	Torso                                    = 5,
	EGzSoundSourceBodyPart_MAX               = 6,
};

// Enum G01.EGzCharacterSoundAction
// NumValues: 0x000C
enum class EGzCharacterSoundAction : uint8
{
	Step                                     = 0,
	WalkOrRun                                = 1,
	Jump                                     = 2,
	Land                                     = 3,
	Crouch                                   = 4,
	Sprint                                   = 5,
	SlideIn                                  = 6,
	SlideLoop                                = 7,
	SlideOut                                 = 8,
	Raise                                    = 9,
	Lay                                      = 10,
	EGzCharacterSoundAction_MAX              = 11,
};

// Enum G01.EGzLimbTypeFlags
// NumValues: 0x0005
enum class EGzLimbTypeFlags : uint8
{
	None                                     = 0,
	LeftArm                                  = 1,
	RightArm                                 = 2,
	Legs                                     = 4,
	Max                                      = 8,
};

// Enum G01.EGzLimbTypeAsEnumClass
// NumValues: 0x0006
enum class EGzLimbTypeAsEnumClass : uint8
{
	LeftArm                                  = 0,
	RightArm                                 = 1,
	Legs                                     = 2,
	Num                                      = 3,
	Invalid                                  = 4,
	EGzLimbTypeAsEnumClass_MAX               = 5,
};

// Enum G01.EGzLoadingInputType
// NumValues: 0x0005
enum class EGzLoadingInputType : uint8
{
	Invalid                                  = 0,
	Keyboard                                 = 1,
	Playstation                              = 2,
	Xbox                                     = 3,
	EGzLoadingInputType_MAX                  = 4,
};

// Enum G01.EGzLoadoutSelectionType
// NumValues: 0x0004
enum class EGzLoadoutSelectionType : uint8
{
	Default                                  = 0,
	CustomContainerLoadouts                  = 1,
	SharedContainerLoutouts                  = 2,
	EGzLoadoutSelectionType_MAX              = 3,
};

// Enum G01.EGzLoadoutListTabOptions
// NumValues: 0x0004
enum class EGzLoadoutListTabOptions : uint8
{
	None                                     = 0,
	Custom                                   = 1,
	PremadePresets                           = 2,
	EGzLoadoutListTabOptions_MAX             = 3,
};

// Enum G01.EGzQuickOrderCallValidationFailReason
// NumValues: 0x0004
enum class EGzQuickOrderCallValidationFailReason : uint8
{
	Guid                                     = 0,
	DroneCooldown                            = 1,
	CashLack                                 = 2,
	EGzQuickOrderCallValidationFailReason_MAX = 3,
};

// Enum G01.EGzMapMarkerLocation
// NumValues: 0x0005
enum class EGzMapMarkerLocation : uint8
{
	None                                     = 0,
	OnMap                                    = 1,
	OffMap                                   = 2,
	All                                      = 3,
	EGzMapMarkerLocation_MAX                 = 4,
};

// Enum G01.EGzMapZonesUpdateMode
// NumValues: 0x0004
enum class EGzMapZonesUpdateMode : uint8
{
	None                                     = 0,
	ZoneWidget                               = 1,
	RenderTargetMask                         = 2,
	EGzMapZonesUpdateMode_MAX                = 3,
};

// Enum G01.EGzMarkerActiveStateFilterType
// NumValues: 0x0005
enum class EGzMarkerActiveStateFilterType : uint8
{
	None                                     = 0,
	Spawn                                    = 1,
	Tick                                     = 2,
	ManualCall                               = 3,
	EGzMarkerActiveStateFilterType_MAX       = 4,
};

// Enum G01.EGzMarkerContainerType
// NumValues: 0x0006
enum class EGzMarkerContainerType : uint8
{
	None                                     = 0,
	Map                                      = 1,
	Minimap                                  = 2,
	Compass                                  = 3,
	Viewport                                 = 4,
	EGzMarkerContainerType_MAX               = 5,
};

// Enum G01.EGzMarketplaceRequestStatus
// NumValues: 0x0004
enum class EGzMarketplaceRequestStatus : uint8
{
	Ready                                    = 0,
	Pending                                  = 1,
	Error                                    = 2,
	EGzMarketplaceRequestStatus_MAX          = 3,
};

// Enum G01.EGzMarketplaceTransactionStatus
// NumValues: 0x0004
enum class EGzMarketplaceTransactionStatus : uint32
{
	Pending                                  = 0,
	Completed                                = 1,
	Failed                                   = 2,
	EGzMarketplaceTransactionStatus_MAX      = 3,
};

// Enum G01.EGzBanType
// NumValues: 0x0004
enum class EGzBanType : uint8
{
	Invalid                                  = 0,
	MarketplaceSell                          = 1,
	MarketplaceBuy                           = 2,
	EGzBanType_MAX                           = 3,
};

// Enum G01.EGzMetaBattlePassPageLockReasonV2
// NumValues: 0x0006
enum class EGzMetaBattlePassPageLockReasonV2 : uint8
{
	None                                     = 0,
	Loyalty                                  = 1,
	Level                                    = 2,
	BlockingSlot                             = 4,
	Subscription                             = 8,
	EGzMetaBattlePassPageLockReasonV2_MAX    = 9,
};

// Enum G01.EGzBattlePassSlotStateV2
// NumValues: 0x0006
enum class EGzBattlePassSlotStateV2 : uint8
{
	Available                                = 0,
	Locked                                   = 1,
	Purchased                                = 2,
	SoldOut                                  = 3,
	PurchaseInProgress                       = 4,
	EGzBattlePassSlotStateV2_MAX             = 5,
};

// Enum G01.EGzSignalrChallengeType
// NumValues: 0x0006
enum class EGzSignalrChallengeType : uint32
{
	None                                     = 0,
	Daily                                    = 1,
	Weekly                                   = 2,
	Monthly                                  = 3,
	Count                                    = 4,
	EGzSignalrChallengeType_MAX              = 5,
};

// Enum G01.EGzEventType
// NumValues: 0x0007
enum class EGzEventType : uint16
{
	Undefined                                = 18446744073709551615,
	InitData                                 = 0,
	AcceptFriendInvitation                   = 1,
	SendFriendInvitation                     = 2,
	ReceivedFriendRequest                    = 3,
	RequestLogin                             = 4,
	EGzEventType_MAX                         = 5,
};

// Enum G01.EGzMetaListMarketOrder
// NumValues: 0x0003
enum class EGzMetaListMarketOrder : uint8
{
	Ascending                                = 0,
	Descending                               = 1,
	EGzMetaListMarketOrder_MAX               = 2,
};

// Enum G01.EGzMetaListMarketOrderType
// NumValues: 0x0003
enum class EGzMetaListMarketOrderType : uint8
{
	Price                                    = 0,
	Time                                     = 1,
	EGzMetaListMarketOrderType_MAX           = 2,
};

// Enum G01.EGzMetaLiveFeatureMatchmakingQueueAvailability
// NumValues: 0x0005
enum class EGzMetaLiveFeatureMatchmakingQueueAvailability : uint8
{
	Enabled                                  = 0,
	Disabled                                 = 1,
	ComingSoon                               = 2,
	Count                                    = 3,
	EGzMetaLiveFeatureMatchmakingQueueAvailability_MAX = 4,
};

// Enum G01.EGzMetaLiveFeatureHiddenAssetMode
// NumValues: 0x0004
enum class EGzMetaLiveFeatureHiddenAssetMode : uint8
{
	UICatalog                                = 0,
	Game                                     = 1,
	Num                                      = 2,
	EGzMetaLiveFeatureHiddenAssetMode_MAX    = 3,
};

// Enum G01.EGzNewsType
// NumValues: 0x0003
enum class EGzNewsType : uint8
{
	Undefined                                = 0,
	News                                     = 1,
	EGzNewsType_MAX                          = 2,
};

// Enum G01.EGzMissionConditionProgressSharingRule
// NumValues: 0x0004
enum class EGzMissionConditionProgressSharingRule : uint8
{
	All                                      = 0,
	One                                      = 1,
	Shared                                   = 2,
	EGzMissionConditionProgressSharingRule_MAX = 3,
};

// Enum G01.EGzMissionSearchZoneGrantType
// NumValues: 0x0005
enum class EGzMissionSearchZoneGrantType : uint8
{
	None                                     = 0,
	MissionOwner                             = 1,
	NonMissionOwner                          = 2,
	All                                      = 3,
	EGzMissionSearchZoneGrantType_MAX        = 4,
};

// Enum G01.EGzMissionGroupType
// NumValues: 0x0003
enum class EGzMissionGroupType : uint8
{
	Personal                                 = 0,
	Team                                     = 1,
	EGzMissionGroupType_MAX                  = 2,
};

// Enum G01.EGzAnimationUpdateState
// NumValues: 0x0005
enum class EGzAnimationUpdateState : uint8
{
	NoUpdate                                 = 0,
	UpdateRequested                          = 1,
	PrepareForUpdate                         = 2,
	Updating                                 = 3,
	EGzAnimationUpdateState_MAX              = 4,
};

// Enum G01.EGzGrantMissionTarget
// NumValues: 0x0004
enum class EGzGrantMissionTarget : uint8
{
	Owner                                    = 0,
	EveryoneButOwner                         = 1,
	Everyone                                 = 2,
	EGzGrantMissionTarget_MAX                = 3,
};

// Enum G01.EGzMissionDuplicationPolicy
// NumValues: 0x0004
enum class EGzMissionDuplicationPolicy : uint8
{
	Always                                   = 0,
	Type                                     = 1,
	Instance                                 = 2,
	EGzMissionDuplicationPolicy_MAX          = 3,
};

// Enum G01.EGzMovementAction
// NumValues: 0x0006
enum class EGzMovementAction : uint8
{
	Crouch                                   = 0,
	Mantle                                   = 1,
	SprintEnabled                            = 2,
	WalkEnabled                              = 3,
	Jump                                     = 4,
	EGzMovementAction_MAX                    = 5,
};

// Enum G01.EGzSweepMoveOnSimulated
// NumValues: 0x0004
enum class EGzSweepMoveOnSimulated : uint8
{
	AlwaysSweep                              = 0,
	SweepWhenRendered                        = 1,
	NeverSweep                               = 2,
	EGzSweepMoveOnSimulated_MAX              = 3,
};

// Enum G01.EGzClientMode
// NumValues: 0x0004
enum class EGzClientMode : uint8
{
	Undefined                                = 0,
	Coordinator                              = 1,
	Worker                                   = 2,
	EGzClientMode_MAX                        = 3,
};

// Enum G01.EGzAddToQueueType
// NumValues: 0x0005
enum class EGzAddToQueueType : uint8
{
	Fail                                     = 0,
	AddToEnd                                 = 1,
	AddToStart                               = 2,
	AddToMiddle                              = 3,
	EGzAddToQueueType_MAX                    = 4,
};

// Enum G01.EGzNotificationsSource
// NumValues: 0x001D
enum class EGzNotificationsSource : uint32
{
	Undefined                                = 18446744073709551615,
	Invalid                                  = 0,
	Reward                                   = 1,
	Achievement                              = 2,
	BattlePassLevelUp                        = 3,
	Challenge                                = 4,
	Job                                      = 5,
	ServerBrowserServerHostingStatusChanged  = 6,
	PlayerLevelUp                            = 7,
	BlockchainMintItemV2                     = 8,
	BlockchainDecodeV2                       = 9,
	BlockchainMarketLotCreated               = 10,
	BlockchainMarketLotRemoved               = 11,
	BlockchainMarketLotBought                = 12,
	BlockchainMarketLotSold                  = 13,
	MarketLotExpired                         = 14,
	Extract                                  = 15,
	Error                                    = 16,
	DailyRewardNotification                  = 17,
	PlinkRewardNotification                  = 18,
	SubscriptionCreated                      = 19,
	SubscriptionUpdated                      = 20,
	SubscriptionCanceled                     = 21,
	SubscriptionLoyaltyRewardsGranted        = 22,
	SubscriptionContentPackRewardsGranted    = 23,
	SubscriptionRenewCanceled                = 24,
	MatchResult                              = 25,
	PromoCodeRedeemed                        = 26,
	EGzNotificationsSource_MAX               = 27,
};

// Enum G01.ENPCTeamAttitude
// NumValues: 0x0004
enum class ENPCTeamAttitude : uint8
{
	Hostile                                  = 0,
	Friendly                                 = 1,
	Neutral                                  = 2,
	ENPCTeamAttitude_MAX                     = 3,
};

// Enum G01.EGzMarketplaceState
// NumValues: 0x0005
enum class EGzMarketplaceState : uint8
{
	NotListed                                = 0,
	ListRequested                            = 1,
	Listed                                   = 2,
	UnlistRequested                          = 3,
	EGzMarketplaceState_MAX                  = 4,
};

// Enum G01.EGzGetChallengesResultChallengeScope
// NumValues: 0x0006
enum class EGzGetChallengesResultChallengeScope : uint8
{
	None                                     = 0,
	Daily                                    = 1,
	Weekly                                   = 2,
	Monthly                                  = 3,
	Count                                    = 4,
	EGzGetChallengesResultChallengeScope_MAX = 5,
};

// Enum G01.EGzPackageItemType
// NumValues: 0x0006
enum class EGzPackageItemType : uint8
{
	BodyPart                                 = 0,
	Weapon                                   = 1,
	WeaponSkin                               = 2,
	WeaponAttachment                         = 3,
	CustomizationItemTemplate                = 4,
	EGzPackageItemType_MAX                   = 5,
};

// Enum G01.EGzPackageListMarketOrder
// NumValues: 0x0003
enum class EGzPackageListMarketOrder : uint8
{
	Asc                                      = 0,
	Desc                                     = 1,
	EGzPackageListMarketOrder_MAX            = 2,
};

// Enum G01.EGzPackageListMarketOrderType
// NumValues: 0x0004
enum class EGzPackageListMarketOrderType : uint8
{
	Price                                    = 0,
	Time                                     = 1,
	Expiration                               = 2,
	EGzPackageListMarketOrderType_MAX        = 3,
};

// Enum G01.EGzPartyMemberDisplaySlotType
// NumValues: 0x0004
enum class EGzPartyMemberDisplaySlotType : uint8
{
	MainCharacter                            = 0,
	Teammate_1                               = 1,
	Teammate_2                               = 2,
	EGzPartyMemberDisplaySlotType_MAX        = 3,
};

// Enum G01.EGzPcPaymentProviders
// NumValues: 0x0003
enum class EGzPcPaymentProviders : uint8
{
	Xsolla                                   = 0,
	Stripe                                   = 1,
	EGzPcPaymentProviders_MAX                = 2,
};

// Enum G01.EGzPhysicsSimulationStateType
// NumValues: 0x0004
enum class EGzPhysicsSimulationStateType : uint8
{
	NotInitialized                           = 0,
	Simulating                               = 1,
	Sleeping                                 = 2,
	EGzPhysicsSimulationStateType_MAX        = 3,
};

// Enum G01.EGzEndSimulationBehaviorType
// NumValues: 0x0006
enum class EGzEndSimulationBehaviorType : uint8
{
	Undefined                                = 0,
	DisablePhysicsSimulation                 = 1,
	SetBodiesToKinematic                     = 2,
	CollisionSetPhysics                      = 4,
	CollisionSetQuery                        = 8,
	EGzEndSimulationBehaviorType_MAX         = 9,
};

// Enum G01.EGzPickablePhysicsType
// NumValues: 0x0003
enum class EGzPickablePhysicsType : uint8
{
	Kinematic                                = 0,
	FullSimulation                           = 1,
	EGzPickablePhysicsType_MAX               = 2,
};

// Enum G01.EGzPingChannels
// NumValues: 0x0006
enum class EGzPingChannels : uint8
{
	None                                     = 0,
	Viewport                                 = 1,
	Map                                      = 2,
	All                                      = 3,
	Any                                      = 128,
	EGzPingChannels_MAX                      = 129,
};

// Enum G01.EGzPlatformType
// NumValues: 0x0006
enum class EGzPlatformType : uint8
{
	Windows                                  = 0,
	Mac                                      = 1,
	Xbox                                     = 2,
	PlayStation                              = 3,
	Num                                      = 4,
	EGzPlatformType_MAX                      = 5,
};

// Enum G01.EGzAimingSensitivityState
// NumValues: 0x0004
enum class EGzAimingSensitivityState : uint8
{
	Looking                                  = 0,
	Aiming                                   = 1,
	SniperScope                              = 2,
	EGzAimingSensitivityState_MAX            = 3,
};

// Enum G01.EGzItemSource
// NumValues: 0x000D
enum class EGzItemSource : uint8
{
	Undefined                                = 0,
	StarterBundle                            = 1,
	DataStore                                = 2,
	DatacubeDecode                           = 3,
	Marketplace                              = 4,
	CheatNotMintable                         = 5,
	Cheat                                    = 6,
	DatacubeExtract                          = 7,
	BattlePass                               = 8,
	Rewards                                  = 9,
	StarterNFTItems                          = 10,
	ContentPack                              = 11,
	EGzItemSource_MAX                        = 12,
};

// Enum G01.EGzPlayerOnlineStatus
// NumValues: 0x0005
enum class EGzPlayerOnlineStatus : uint32
{
	Unknown                                  = 18446744073709551615,
	Offline                                  = 0,
	Online                                   = 1,
	Custom                                   = 2,
	EGzPlayerOnlineStatus_MAX                = 3,
};

// Enum G01.EGzPlayerSatisfactionRating
// NumValues: 0x0007
enum class EGzPlayerSatisfactionRating : uint8
{
	None                                     = 0,
	VeryLow                                  = 1,
	Low                                      = 2,
	Mid                                      = 3,
	High                                     = 4,
	VeryHigh                                 = 5,
	EGzPlayerSatisfactionRating_MAX          = 6,
};

// Enum G01.EGzAliveState
// NumValues: 0x0004
enum class EGzAliveState : uint8
{
	Alive                                    = 0,
	Dead                                     = 1,
	Defeated                                 = 2,
	EGzAliveState_MAX                        = 3,
};

// Enum G01.EGzPlayFabStatusCodes
// NumValues: 0x008A
enum class EGzPlayFabStatusCodes : uint32
{
	Unknown                                  = 0,
	Success                                  = 1000,
	UnauthorizedCallSource                   = 1050,
	TokenMissing                             = 1051,
	TokenInvalid                             = 1052,
	TokenUnexpectedEntity                    = 1053,
	IncompatibleFunctionVersion              = 1100,
	FunctionVersionNotProvided               = 1101,
	FeatureDisabled                          = 1500,
	FeatureDisabledClient                    = 1555,
	PlayFab                                  = 2000,
	PlayFabRepeatable                        = 2001,
	PlayFabCritical                          = 2002,
	PlayFabIdNotFound                        = 2600,
	PlayerSessionIdNotFound                  = 2601,
	InvalidPlayerSessionId                   = 2602,
	SaveCompletedAchievements                = 3001,
	PurchaseBattlePassItem                   = 3200,
	PurchaseBattlePassTier                   = 3201,
	SeasonTimeFrameConflict                  = 3202,
	Scheduling                               = 3203,
	BattlePassPurchaseNoSubscription         = 3210,
	BattlePassSlotAlreadyPurchased           = 3211,
	BattlePassPurchaseSlotRewardIdNotFound   = 3212,
	BattlePassSlotPurchasePreConditionFailed = 3213,
	BattlePassSlotPurchasePageLocked         = 3214,
	BattlePassSlotRewardDepleted             = 3215,
	CompletedJobMismatch                     = 3300,
	JobsNotAvailable                         = 3301,
	NoSelectedJob                            = 3302,
	JobEntityIsAlreadyCompleted              = 3303,
	LoadoutItemNotFoundInInventory           = 3401,
	LoadoutItemSlot                          = 3402,
	LoadoutsCount                            = 3403,
	LoadoutsNameLength                       = 3404,
	LoadoutItemNotFoundInCatalog             = 3405,
	IncreaseMaxLoadoutCount                  = 3406,
	LoadoutItemAssetIdMismatch               = 3407,
	LoadoutItemUsedOnMarketplace             = 3408,
	WeaponConfigurationsNotFound             = 3409,
	WeaponConfigurationsWrongItemClass       = 3410,
	ProgressionBrokenData                    = 3500,
	BadClanTag                               = 3502,
	InvalidWeaponTypeException               = 3550,
	CurrentCharacterNotFound                 = 3605,
	MissingCharacter                         = 3606,
	TooManyCharacters                        = 3607,
	CharacterNoDisplayName                   = 3608,
	CustomizationSlotUsedOnMarket            = 3651,
	CustomizationInvalidItemType             = 3652,
	CustomizationWrongAssetId                = 3653,
	CustomizationActivePresetNotFound        = 3655,
	CustomizationFullUpdateRequired          = 3656,
	CustomizationWrongLogicalSlot            = 3657,
	CustomizationWrongItemClass              = 3658,
	CustomizationBrokenCatalogItemLogicalSlots = 3659,
	CustomizationNonRemovableSlotsMissing    = 3660,
	SeasonNotFound                           = 3701,
	BattlePassNotFound                       = 3703,
	ItemMintingError                         = 3704,
	ItemAlreadyMintedAsDifferentNft          = 3706,
	DecodeNotEnoughCoins                     = 3707,
	DecodeAlreadyDecoding                    = 3708,
	DecodeItemIsNotDatacube                  = 3709,
	StartMatchmaking                         = 3800,
	CancelMatchMaking                        = 3801,
	QueueNotAllowed                          = 3802,
	InvalidCurrencyAmount                    = 4000,
	NotEnoughCurrency                        = 4001,
	UnknownFaction                           = 4100,
	InvalidChallengeType                     = 4201,
	SaveCompletedChallenge                   = 4202,
	MissingInventoryItem                     = 4301,
	MissingInventoryItemNftId                = 4304,
	MissingLiveDataCatalog                   = 4306,
	MissingLiveDataCatalogItem               = 4307,
	InvalidGrantItemType                     = 4308,
	CatalogDatacubeNoLootTablePool           = 4309,
	InventoryNoValidationRequired            = 4310,
	MissingLiveData                          = 4311,
	UnexpectedInventoryEntryType             = 4312,
	CatalogDatacubeNoDecodePrice             = 4313,
	DropTableInvalid                         = 4500,
	DropTableMissing                         = 4501,
	LootTableNotFound                        = 4520,
	LootTableEmpty                           = 4521,
	CouldNotDrawItemFromLootTable            = 4522,
	LootTablePoolNotFound                    = 4530,
	LootTablePoolEmpty                       = 4531,
	TitleDataMissing                         = 4600,
	MarketplaceAuthError                     = 4701,
	ListingItemWhenItIsAlreadyListed         = 4704,
	UnlistingItemWhenItIsNotListed           = 4705,
	MarketplaceItemNotFound                  = 4706,
	MarketplaceBuyInvalidOwner               = 4707,
	MarketplaceOverTheLimit                  = 4708,
	MarketplaceNotEnoughCoins                = 4709,
	UnknownBattlePassFee                     = 4710,
	DatacubeIsNotTradableException           = 4711,
	MarketplaceBuyInvalidPrice               = 4712,
	MarketplaceBuyHiddenItem                 = 4713,
	MarketplaceBuyExpiredItem                = 4714,
	FraudPreventionPriceRangeValidationFailed = 4716,
	FraudPreventionItemCooldownValidationFailed = 4717,
	FraudPreventionTradeRateValidationFailed = 4718,
	SignalRNegotiate                         = 4800,
	BlockchainItemMintedErrorNotification    = 4901,
	BlockchainItemGrantedErrorNotification   = 4902,
	BlockchainDatacubeDecodeErrorNotification = 4903,
	BlockchainChangeBalanceErrorNotification = 4904,
	BlockchainMarketLotCreateError           = 4907,
	BlockchainMarketLotRemoveError           = 4908,
	BlockchainMarketLotBuyError              = 4909,
	TitlePlayerAccountIdNotFound             = 5000,
	ServerAlreadyLaunched                    = 5100,
	ServerStartFailed                        = 5101,
	ServerAlreadyRunning                     = 5102,
	ServerRegistrationNotFound               = 5103,
	PlayerMasterAccountIdNotFound            = 5200,
	EosIdNotFound                            = 5201,
	GitHubApiException                       = 6000,
	GitHubWebhookAuthException               = 6001,
	XSollaWebhookAuthException               = 6250,
	XSollaRequestFormatException             = 6251,
	XSollaApiException                       = 6252,
	XSollaInvalidUserException               = 6253,
	CosmosDbException                        = 6500,
	EosLinkedAccountNotFound                 = 6600,
	PromoCodeNotFound                        = 6900,
	PromoCodeNotRedeemable                   = 6901,
	PromoCodeAlreadyRedeemed                 = 6902,
	PromoCodeRedeemLimitReached              = 6903,
	ModelValidationError                     = 10000,
	DeserializationException                 = 20001,
	SerializationException                   = 20002,
	Auth0Exception                           = 25000,
	PlayFabCppError                          = 4294967295,
	EGzPlayFabStatusCodes_MAX                = 4294967296,
};

// Enum G01.EGzRichPresenceType
// NumValues: 0x0005
enum class EGzRichPresenceType : uint8
{
	Lobby                                    = 0,
	Queue                                    = 1,
	PreMatch                                 = 2,
	Match                                    = 3,
	EGzRichPresenceType_MAX                  = 4,
};

// Enum G01.EGzPropagationPointStatus
// NumValues: 0x0004
enum class EGzPropagationPointStatus : uint8
{
	None                                     = 0,
	Active                                   = 1,
	Inactive                                 = 2,
	EGzPropagationPointStatus_MAX            = 3,
};

// Enum G01.EGzPropagationSphereRadiusLimit
// NumValues: 0x0005
enum class EGzPropagationSphereRadiusLimit : uint8
{
	Longest                                  = 0,
	Length                                   = 1,
	Width                                    = 2,
	Height                                   = 3,
	EGzPropagationSphereRadiusLimit_MAX      = 4,
};

// Enum G01.EGzCenterLocation
// NumValues: 0x0005
enum class EGzCenterLocation : uint8
{
	None                                     = 0,
	CenterWidth                              = 1,
	CenterLength                             = 2,
	CenterHeight                             = 4,
	EGzCenterLocation_MAX                    = 5,
};

// Enum G01.EGzReconDestroyReason
// NumValues: 0x0005
enum class EGzReconDestroyReason : uint8
{
	None                                     = 0,
	AutoDestroy                              = 1,
	Killed                                   = 2,
	Defilered                                = 3,
	EGzReconDestroyReason_MAX                = 4,
};

// Enum G01.EGzClassRepNodeMapping
// NumValues: 0x0006
enum class EGzClassRepNodeMapping : uint8
{
	NotRouted                                = 0,
	RelevantAllConnections                   = 1,
	Spatialize_Static                        = 2,
	Spatialize_Dynamic                       = 3,
	Spatialize_Dormancy                      = 4,
	EGzClassRepNodeMapping_MAX               = 5,
};

// Enum G01.EGzReportReason
// NumValues: 0x0008
enum class EGzReportReason : uint8
{
	VoiceChatHarassment                      = 0,
	Cheating                                 = 1,
	InappropriatePlayerName                  = 2,
	InappropriateClanName                    = 3,
	Griefing                                 = 4,
	GameRigging                              = 5,
	Idle                                     = 6,
	EGzReportReason_MAX                      = 7,
};

// Enum G01.EGzMatchMode
// NumValues: 0x0005
enum class EGzMatchMode : uint8
{
	MODE_None                                = 0,
	Solo                                     = 1,
	Duo                                      = 2,
	Trio                                     = 3,
	EGzMatchMode_MAX                         = 4,
};

// Enum G01.EGzAbilityGameplayCueActivation
// NumValues: 0x0004
enum class EGzAbilityGameplayCueActivation : uint8
{
	OnBegin                                  = 0,
	AbilityLifetime                          = 1,
	OnEvent                                  = 2,
	EGzAbilityGameplayCueActivation_MAX      = 3,
};

// Enum G01.EGzActionOnTag
// NumValues: 0x0003
enum class EGzActionOnTag : uint8
{
	OnAdded                                  = 0,
	OnRemoved                                = 1,
	EGzActionOnTag_MAX                       = 2,
};

// Enum G01.EGzHolsterType
// NumValues: 0x0003
enum class EGzHolsterType : uint8
{
	Holster                                  = 0,
	Unholster                                = 1,
	EGzHolsterType_MAX                       = 2,
};

// Enum G01.EGzSceneSpawnpointType
// NumValues: 0x0003
enum class EGzSceneSpawnpointType : uint8
{
	Static                                   = 0,
	Skeletal                                 = 1,
	EGzSceneSpawnpointType_MAX               = 2,
};

// Enum G01.EGzSearchZoneGroupType
// NumValues: 0x0004
enum class EGzSearchZoneGroupType : uint8
{
	None                                     = 0,
	Personal                                 = 1,
	Team                                     = 2,
	EGzSearchZoneGroupType_MAX               = 3,
};

// Enum G01.EGzServerConnectionAvailability
// NumValues: 0x0004
enum class EGzServerConnectionAvailability : uint8
{
	Unavailable                              = 0,
	Pending                                  = 1,
	Available                                = 2,
	EGzServerConnectionAvailability_MAX      = 3,
};

// Enum G01.EGzServerUnavailabilityReason
// NumValues: 0x0005
enum class EGzServerUnavailabilityReason : uint8
{
	Undefined                                = 0,
	CanNotAcceptNewPlayers                   = 1,
	ChangelistMismatch                       = 2,
	PlayerCountLimit                         = 3,
	EGzServerUnavailabilityReason_MAX        = 4,
};

// Enum G01.EGzServerLaunchOptionSelectionType
// NumValues: 0x0003
enum class EGzServerLaunchOptionSelectionType : uint8
{
	Radiobutton                              = 0,
	Checkboxes                               = 1,
	EGzServerLaunchOptionSelectionType_MAX   = 2,
};

// Enum G01.EGzMatchmakingType
// NumValues: 0x0005
enum class EGzMatchmakingType : uint8
{
	NONE                                     = 0,
	Azure                                    = 1,
	Unity                                    = 2,
	Local                                    = 3,
	EGzMatchmakingType_MAX                   = 4,
};

// Enum G01.EGzPlayerLogoutReason
// NumValues: 0x0003
enum class EGzPlayerLogoutReason : uint8
{
	LeftMatch                                = 0,
	Disconnected                             = 1,
	EGzPlayerLogoutReason_MAX                = 2,
};

// Enum G01.EGzPlatformMasks
// NumValues: 0x0007
enum class EGzPlatformMasks : uint8
{
	None                                     = 0,
	Windows                                  = 1,
	Mac                                      = 2,
	Xbox                                     = 4,
	PlayStation                              = 8,
	All                                      = 15,
	EGzPlatformMasks_MAX                     = 16,
};

// Enum G01.EGzDiscreteSettingDataType
// NumValues: 0x0004
enum class EGzDiscreteSettingDataType : uint8
{
	String                                   = 0,
	Number                                   = 1,
	Bool                                     = 2,
	EGzDiscreteSettingDataType_MAX           = 3,
};

// Enum G01.EGzScalarFormat
// NumValues: 0x0009
enum class EGzScalarFormat : uint8
{
	Raw                                      = 0,
	RawOneDecimal                            = 1,
	RawTwoDecimals                           = 2,
	ZeroToOnePercent                         = 3,
	ZeroToOnePercent_OneDecimal              = 4,
	SourceAsPercent1                         = 5,
	SourceAsPercent100                       = 6,
	SourceAsInteger                          = 7,
	EGzScalarFormat_MAX                      = 8,
};

// Enum G01.EGzFSRQualityMode
// NumValues: 0x0007
enum class EGzFSRQualityMode : uint8
{
	NativeAA                                 = 0,
	Quality                                  = 1,
	Balanced                                 = 2,
	Performance                              = 3,
	UltraPerformance                         = 4,
	Count                                    = 5,
	EGzFSRQualityMode_MAX                    = 6,
};

// Enum G01.EGzMetalFxQualityMode
// NumValues: 0x0004
enum class EGzMetalFxQualityMode : uint8
{
	Off                                      = 0,
	Quality                                  = 1,
	Performance                              = 2,
	MAX                                      = 3,
};

// Enum G01.EGzDisableSettingType
// NumValues: 0x0004
enum class EGzDisableSettingType : uint8
{
	Active                                   = 0,
	Hide                                     = 1,
	Disable                                  = 2,
	EGzDisableSettingType_MAX                = 3,
};

// Enum G01.EGzSieRegion
// NumValues: 0x0007
enum class EGzSieRegion : uint8
{
	SIE_A                                    = 0,
	SIE_E                                    = 1,
	SIE_Asia                                 = 2,
	SIE_J                                    = 3,
	SIE_K                                    = 4,
	Num                                      = 5,
	EGzSieRegion_MAX                         = 6,
};

// Enum G01.EGzSkelMeshAnimPoseBehavior
// NumValues: 0x0004
enum class EGzSkelMeshAnimPoseBehavior : uint8
{
	AlwaysUseLeaderPose                      = 0,
	UsePostProcessIfPresentOtherwiseLeaderPose = 1,
	UsePostProcessIfPresentNeverUseLeaderPose = 2,
	EGzSkelMeshAnimPoseBehavior_MAX          = 3,
};

// Enum G01.EGzTagVisibilityTargetType
// NumValues: 0x0005
enum class EGzTagVisibilityTargetType : uint8
{
	None                                     = 0,
	Self                                     = 2,
	Parent                                   = 4,
	All                                      = 6,
	EGzTagVisibilityTargetType_MAX           = 7,
};

// Enum G01.EGzTeamDistributionPolicy
// NumValues: 0x0004
enum class EGzTeamDistributionPolicy : uint8
{
	Fill                                     = 0,
	Spread                                   = 1,
	Random                                   = 2,
	EGzTeamDistributionPolicy_MAX            = 3,
};

// Enum G01.EGzTelemetryPlayerDisconnectType
// NumValues: 0x0003
enum class EGzTelemetryPlayerDisconnectType : uint8
{
	LeftMatch                                = 0,
	Disconnected                             = 1,
	EGzTelemetryPlayerDisconnectType_MAX     = 2,
};

// Enum G01.EGzThrowableShieldState
// NumValues: 0x0005
enum class EGzThrowableShieldState : uint8
{
	None                                     = 0,
	Deployed                                 = 1,
	Launched                                 = 2,
	Returning                                = 3,
	EGzThrowableShieldState_MAX              = 4,
};

// Enum G01.EGzTransactionType
// NumValues: 0x0004
enum class EGzTransactionType : uint32
{
	Undefined                                = 18446744073709551615,
	BlockchainMarketLotCreated               = 10,
	BlockchainMarketLotBought                = 12,
	EGzTransactionType_MAX                   = 13,
};

// Enum G01.EGzTraversalFootPhase
// NumValues: 0x0003
enum class EGzTraversalFootPhase : uint8
{
	LeftToRight                              = 0,
	RightToLeft                              = 1,
	EGzTraversalFootPhase_MAX                = 2,
};

// Enum G01.EGzTraversalMovementState
// NumValues: 0x0003
enum class EGzTraversalMovementState : uint8
{
	Stand                                    = 0,
	Jog                                      = 1,
	EGzTraversalMovementState_MAX            = 2,
};

// Enum G01.EGzTraversalType
// NumValues: 0x0003
enum class EGzTraversalType : uint8
{
	Climb                                    = 0,
	Vault                                    = 1,
	EGzTraversalType_MAX                     = 2,
};

// Enum G01.EGzTrialType
// NumValues: 0x0004
enum class EGzTrialType : uint8
{
	Unknown                                  = 0,
	Challenge                                = 1,
	Achievement                              = 2,
	EGzTrialType_MAX                         = 3,
};

// Enum G01.EGzTrackerCategory
// NumValues: 0x0003
enum class EGzTrackerCategory : uint8
{
	Meta                                     = 0,
	Gameplay                                 = 1,
	EGzTrackerCategory_MAX                   = 2,
};

// Enum G01.EGzMetaTrackerType
// NumValues: 0x0009
enum class EGzMetaTrackerType : uint8
{
	None                                     = 0,
	Decode                                   = 1,
	CreateMarketLot                          = 2,
	BuyMarketLot                             = 3,
	UnlistMarketlot                          = 4,
	ChangeCustomization                      = 5,
	ChangeLoadouts                           = 6,
	ChangeWeaponConfiguration                = 7,
	EGzMetaTrackerType_MAX                   = 8,
};

// Enum G01.EGzUIChannels
// NumValues: 0x000A
enum class EGzUIChannels : uint8
{
	None                                     = 0,
	HUD_Default                              = 1,
	HUD_Settings                             = 2,
	HUD_Cutscene                             = 4,
	NavRoot                                  = 8,
	Debug                                    = 16,
	LoadingScreen                            = 32,
	All                                      = 63,
	DefaultTurnedOn                          = 47,
	EGzUIChannels_MAX                        = 64,
};

// Enum G01.EGzUnityMatchmakingErrorType
// NumValues: 0x000A
enum class EGzUnityMatchmakingErrorType : uint8
{
	Unknown                                  = 0,
	BadRequest                               = 1,
	NotFound                                 = 2,
	TooManyRequests                          = 3,
	InvalidStatus                            = 4,
	RequestTimeout                           = 5,
	RequestFailed                            = 6,
	BadQoS                                   = 7,
	Other                                    = 8,
	EGzUnityMatchmakingErrorType_MAX         = 9,
};

// Enum G01.EGzViewportMarkerLocation
// NumValues: 0x0005
enum class EGzViewportMarkerLocation : uint8
{
	None                                     = 0,
	OnScreen                                 = 1,
	OffScreen                                = 2,
	All                                      = 3,
	EGzViewportMarkerLocation_MAX            = 4,
};

// Enum G01.EGzVirtualCurrencyType
// NumValues: 0x0003
enum class EGzVirtualCurrencyType : uint8
{
	BP                                       = 0,
	NUM_CURRENCIES                           = 1,
	EGzVirtualCurrencyType_MAX               = 2,
};

// Enum G01.EGzBlockchainCoinType
// NumValues: 0x0003
enum class EGzBlockchainCoinType : uint8
{
	GUN                                      = 0,
	NUM_COINS                                = 1,
	EGzBlockchainCoinType_MAX                = 2,
};

// Enum G01.EGzVoiceChatState
// NumValues: 0x0004
enum class EGzVoiceChatState : uint8
{
	Disabled                                 = 0,
	AlwaysActive                             = 1,
	PushToTalk                               = 2,
	EGzVoiceChatState_MAX                    = 3,
};

// Enum G01.EGzVoiceLinePriority
// NumValues: 0x0006
enum class EGzVoiceLinePriority : uint8
{
	Low                                      = 0,
	Medium                                   = 25,
	High                                     = 50,
	Critical                                 = 75,
	Immediate                                = 200,
	EGzVoiceLinePriority_MAX                 = 201,
};

// Enum G01.ECameraShoulderState
// NumValues: 0x0004
enum class ECameraShoulderState : uint8
{
	IgnoreShoulder                           = 0,
	LeftShoulder                             = 1,
	RightShoulder                            = 2,
	ECameraShoulderState_MAX                 = 3,
};

// Enum G01.EGzBufferedShotState
// NumValues: 0x0004
enum class EGzBufferedShotState : uint8
{
	Inactive                                 = 0,
	ShotBuffered                             = 1,
	ShotBufferedAndInputReleased             = 2,
	EGzBufferedShotState_MAX                 = 3,
};

// Enum G01.EGzMovementSpreadPenaltyMode
// NumValues: 0x0008
enum class EGzMovementSpreadPenaltyMode : uint8
{
	NONE                                     = 0,
	Walking                                  = 1,
	Sprinting                                = 2,
	Crouching                                = 3,
	Sliding                                  = 4,
	Grappling                                = 5,
	Falling                                  = 6,
	MAX                                      = 7,
};

// Enum G01.EGzAttachNodeName
// NumValues: 0x0004
enum class EGzAttachNodeName : uint8
{
	None                                     = 0,
	ERightHandSocket                         = 1,
	ELeftHandSocket                          = 2,
	MAX                                      = 3,
};

// Enum G01.EGzWeaponType
// NumValues: 0x000A
enum class EGzWeaponType : uint8
{
	None                                     = 0,
	Pistol                                   = 1,
	Assault                                  = 2,
	SMG                                      = 3,
	Shotgun                                  = 4,
	LMG                                      = 5,
	Sniper                                   = 6,
	DMR                                      = 7,
	_LAST                                    = 8,
	EGzWeaponType_MAX                        = 9,
};

// Enum G01.EGzWeaponSupplementAttachmentType
// NumValues: 0x0007
enum class EGzWeaponSupplementAttachmentType : uint8
{
	Slide                                    = 0,
	FrontSight                               = 1,
	BackSight                                = 2,
	StockBridge                              = 3,
	BarrelBridge                             = 4,
	_LAST                                    = 5,
	EGzWeaponSupplementAttachmentType_MAX    = 6,
};

// Enum G01.EGzWingsuitCollisionCrashBehaviour
// NumValues: 0x0003
enum class EGzWingsuitCollisionCrashBehaviour : uint8
{
	BounceOff                                = 0,
	CancelJetpack                            = 1,
	EGzWingsuitCollisionCrashBehaviour_MAX   = 2,
};

// Enum G01.EGzXRPreMatchState
// NumValues: 0x0004
enum class EGzXRPreMatchState : uint8
{
	RegularDurationInProgress                = 0,
	ReducedDurationInProgress                = 1,
	CountdownInProgress                      = 2,
	EGzXRPreMatchState_MAX                   = 3,
};

// Enum G01.EGzZoneTrackingType
// NumValues: 0x0003
enum class EGzZoneTrackingType : uint8
{
	Dynamic                                  = 0,
	Static                                   = 1,
	EGzZoneTrackingType_MAX                  = 2,
};

// Enum G01.EGzZoneInclusionMode
// NumValues: 0x0003
enum class EGzZoneInclusionMode : uint8
{
	OverlapAny                               = 0,
	OverlapAll                               = 1,
	EGzZoneInclusionMode_MAX                 = 2,
};

// Enum G01.EGzNpcDistanceToTarget
// NumValues: 0x0006
enum class EGzNpcDistanceToTarget : uint8
{
	Invalid                                  = 0,
	Short                                    = 1,
	Middle                                   = 2,
	Long                                     = 3,
	Melee                                    = 4,
	EGzNpcDistanceToTarget_MAX               = 5,
};

// Enum G01.ELocomotionGroundedEntryState
// NumValues: 0x0003
enum class ELocomotionGroundedEntryState : uint8
{
	None                                     = 0,
	Roll                                     = 1,
	ELocomotionGroundedEntryState_MAX        = 2,
};

// Enum G01.ELocomotionMantleType
// NumValues: 0x0005
enum class ELocomotionMantleType : uint8
{
	MantleFromGround                         = 0,
	MantleFromAir                            = 1,
	VaultFromGround                          = 2,
	MantleFailedFromGround                   = 3,
	ELocomotionMantleType_MAX                = 4,
};

// Enum G01.ELeglessLocoSubState
// NumValues: 0x0003
enum class ELeglessLocoSubState : uint8
{
	Legless_Movement                         = 0,
	Legless_Aiming                           = 1,
	Legless_MAX                              = 2,
};

// Enum G01.ELeglessLocoState
// NumValues: 0x0005
enum class ELeglessLocoState : uint8
{
	None                                     = 0,
	Enter                                    = 1,
	Update                                   = 2,
	Exiting                                  = 3,
	ELeglessLocoState_MAX                    = 4,
};

// ScriptStruct G01.GzOverloadData
// 0x000C (0x000C - 0x0000)
struct FGzOverloadData final
{
public:
	EGzZoneOverloadState                          State;                                             // 0x0000(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2A0C[0x3];                                     // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Radius;                                            // 0x0004(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bPaused;                                           // 0x0008(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2A0D[0x3];                                     // 0x0009(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGzOverloadData) == 0x000004, "Wrong alignment on FGzOverloadData");
static_assert(sizeof(FGzOverloadData) == 0x00000C, "Wrong size on FGzOverloadData");
static_assert(offsetof(FGzOverloadData, State) == 0x000000, "Member 'FGzOverloadData::State' has a wrong offset!");
static_assert(offsetof(FGzOverloadData, Radius) == 0x000004, "Member 'FGzOverloadData::Radius' has a wrong offset!");
static_assert(offsetof(FGzOverloadData, bPaused) == 0x000008, "Member 'FGzOverloadData::bPaused' has a wrong offset!");

// ScriptStruct G01.GzRootMotionSource_Interactable
// 0x0130 (0x0210 - 0x00E0)
struct FGzRootMotionSource_Interactable final : public FRootMotionSource
{
public:
	class UGzInteractableTransitionSettings*      TransitionSettings;                                // 0x00D8(0x0008)(ZeroConstructor, Transient, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2A0E[0x130];                                   // 0x00E0(0x0130)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGzRootMotionSource_Interactable) == 0x000010, "Wrong alignment on FGzRootMotionSource_Interactable");
static_assert(sizeof(FGzRootMotionSource_Interactable) == 0x000210, "Wrong size on FGzRootMotionSource_Interactable");
static_assert(offsetof(FGzRootMotionSource_Interactable, TransitionSettings) == 0x0000D8, "Member 'FGzRootMotionSource_Interactable::TransitionSettings' has a wrong offset!");

// ScriptStruct G01.GzExtractionProgressData
// 0x0010 (0x0010 - 0x0000)
struct FGzExtractionProgressData final
{
public:
	float                                         ProgressWhenStateChanged;                          // 0x0000(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ServerTimeWhenStateChanged;                        // 0x0004(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TotalExtractionTime;                               // 0x0008(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ProgressSpeed;                                     // 0x000C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzExtractionProgressData) == 0x000004, "Wrong alignment on FGzExtractionProgressData");
static_assert(sizeof(FGzExtractionProgressData) == 0x000010, "Wrong size on FGzExtractionProgressData");
static_assert(offsetof(FGzExtractionProgressData, ProgressWhenStateChanged) == 0x000000, "Member 'FGzExtractionProgressData::ProgressWhenStateChanged' has a wrong offset!");
static_assert(offsetof(FGzExtractionProgressData, ServerTimeWhenStateChanged) == 0x000004, "Member 'FGzExtractionProgressData::ServerTimeWhenStateChanged' has a wrong offset!");
static_assert(offsetof(FGzExtractionProgressData, TotalExtractionTime) == 0x000008, "Member 'FGzExtractionProgressData::TotalExtractionTime' has a wrong offset!");
static_assert(offsetof(FGzExtractionProgressData, ProgressSpeed) == 0x00000C, "Member 'FGzExtractionProgressData::ProgressSpeed' has a wrong offset!");

// ScriptStruct G01.GzExtractionData
// 0x0040 (0x0040 - 0x0000)
struct FGzExtractionData final
{
public:
	int32                                         ExtractionId;                                      // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2A0F[0x4];                                     // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UGzItemData*                            ItemData;                                          // 0x0008(0x0008)(BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AGzPlayerState*                         Player;                                            // 0x0010(0x0008)(BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AGzPlayerState*                         Hacker;                                            // 0x0018(0x0008)(BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EGzExtractionState                            State;                                             // 0x0020(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bPaused;                                           // 0x0021(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2A10[0x6];                                     // 0x0022(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class AGzItemExtractor*                       Extractor;                                         // 0x0028(0x0008)(BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGzExtractionProgressData              ProgressData;                                      // 0x0030(0x0010)(BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzExtractionData) == 0x000008, "Wrong alignment on FGzExtractionData");
static_assert(sizeof(FGzExtractionData) == 0x000040, "Wrong size on FGzExtractionData");
static_assert(offsetof(FGzExtractionData, ExtractionId) == 0x000000, "Member 'FGzExtractionData::ExtractionId' has a wrong offset!");
static_assert(offsetof(FGzExtractionData, ItemData) == 0x000008, "Member 'FGzExtractionData::ItemData' has a wrong offset!");
static_assert(offsetof(FGzExtractionData, Player) == 0x000010, "Member 'FGzExtractionData::Player' has a wrong offset!");
static_assert(offsetof(FGzExtractionData, Hacker) == 0x000018, "Member 'FGzExtractionData::Hacker' has a wrong offset!");
static_assert(offsetof(FGzExtractionData, State) == 0x000020, "Member 'FGzExtractionData::State' has a wrong offset!");
static_assert(offsetof(FGzExtractionData, bPaused) == 0x000021, "Member 'FGzExtractionData::bPaused' has a wrong offset!");
static_assert(offsetof(FGzExtractionData, Extractor) == 0x000028, "Member 'FGzExtractionData::Extractor' has a wrong offset!");
static_assert(offsetof(FGzExtractionData, ProgressData) == 0x000030, "Member 'FGzExtractionData::ProgressData' has a wrong offset!");

// ScriptStruct G01.GzPackageCustomizationAppearanceBody
// 0x0010 (0x0010 - 0x0000)
struct FGzPackageCustomizationAppearanceBody final
{
public:
	class FString                                 Gender;                                            // 0x0000(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzPackageCustomizationAppearanceBody) == 0x000008, "Wrong alignment on FGzPackageCustomizationAppearanceBody");
static_assert(sizeof(FGzPackageCustomizationAppearanceBody) == 0x000010, "Wrong size on FGzPackageCustomizationAppearanceBody");
static_assert(offsetof(FGzPackageCustomizationAppearanceBody, Gender) == 0x000000, "Member 'FGzPackageCustomizationAppearanceBody::Gender' has a wrong offset!");

// ScriptStruct G01.GzPackageCustomizationAppearanceSlot
// 0x0030 (0x0030 - 0x0000)
struct FGzPackageCustomizationAppearanceSlot final
{
public:
	class FString                                 ItemInstanceId;                                    // 0x0000(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 AssetId;                                           // 0x0010(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 PrimaryLogicalSlot;                                // 0x0020(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzPackageCustomizationAppearanceSlot) == 0x000008, "Wrong alignment on FGzPackageCustomizationAppearanceSlot");
static_assert(sizeof(FGzPackageCustomizationAppearanceSlot) == 0x000030, "Wrong size on FGzPackageCustomizationAppearanceSlot");
static_assert(offsetof(FGzPackageCustomizationAppearanceSlot, ItemInstanceId) == 0x000000, "Member 'FGzPackageCustomizationAppearanceSlot::ItemInstanceId' has a wrong offset!");
static_assert(offsetof(FGzPackageCustomizationAppearanceSlot, AssetId) == 0x000010, "Member 'FGzPackageCustomizationAppearanceSlot::AssetId' has a wrong offset!");
static_assert(offsetof(FGzPackageCustomizationAppearanceSlot, PrimaryLogicalSlot) == 0x000020, "Member 'FGzPackageCustomizationAppearanceSlot::PrimaryLogicalSlot' has a wrong offset!");

// ScriptStruct G01.GzPackageCustomizationAppearancePreset
// 0x0040 (0x0040 - 0x0000)
struct FGzPackageCustomizationAppearancePreset final
{
public:
	class FString                                 ID;                                                // 0x0000(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Name;                                              // 0x0010(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGzPackageCustomizationAppearanceBody  Body;                                              // 0x0020(0x0010)(NativeAccessSpecifierPublic)
	TArray<struct FGzPackageCustomizationAppearanceSlot> Slots;                                             // 0x0030(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzPackageCustomizationAppearancePreset) == 0x000008, "Wrong alignment on FGzPackageCustomizationAppearancePreset");
static_assert(sizeof(FGzPackageCustomizationAppearancePreset) == 0x000040, "Wrong size on FGzPackageCustomizationAppearancePreset");
static_assert(offsetof(FGzPackageCustomizationAppearancePreset, ID) == 0x000000, "Member 'FGzPackageCustomizationAppearancePreset::ID' has a wrong offset!");
static_assert(offsetof(FGzPackageCustomizationAppearancePreset, Name) == 0x000010, "Member 'FGzPackageCustomizationAppearancePreset::Name' has a wrong offset!");
static_assert(offsetof(FGzPackageCustomizationAppearancePreset, Body) == 0x000020, "Member 'FGzPackageCustomizationAppearancePreset::Body' has a wrong offset!");
static_assert(offsetof(FGzPackageCustomizationAppearancePreset, Slots) == 0x000030, "Member 'FGzPackageCustomizationAppearancePreset::Slots' has a wrong offset!");

// ScriptStruct G01.GzPackageCustomizationAppearanceCollection
// 0x0020 (0x0020 - 0x0000)
struct FGzPackageCustomizationAppearanceCollection final
{
public:
	TArray<struct FGzPackageCustomizationAppearancePreset> Presets;                                           // 0x0000(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	class FString                                 ActivePresetId;                                    // 0x0010(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzPackageCustomizationAppearanceCollection) == 0x000008, "Wrong alignment on FGzPackageCustomizationAppearanceCollection");
static_assert(sizeof(FGzPackageCustomizationAppearanceCollection) == 0x000020, "Wrong size on FGzPackageCustomizationAppearanceCollection");
static_assert(offsetof(FGzPackageCustomizationAppearanceCollection, Presets) == 0x000000, "Member 'FGzPackageCustomizationAppearanceCollection::Presets' has a wrong offset!");
static_assert(offsetof(FGzPackageCustomizationAppearanceCollection, ActivePresetId) == 0x000010, "Member 'FGzPackageCustomizationAppearanceCollection::ActivePresetId' has a wrong offset!");

// ScriptStruct G01.GzVoiceLineData
// 0x0018 (0x0018 - 0x0000)
struct FGzVoiceLineData final
{
public:
	class UAkAudioEvent*                          Event;                                             // 0x0000(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2A11[0x10];                                    // 0x0008(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGzVoiceLineData) == 0x000008, "Wrong alignment on FGzVoiceLineData");
static_assert(sizeof(FGzVoiceLineData) == 0x000018, "Wrong size on FGzVoiceLineData");
static_assert(offsetof(FGzVoiceLineData, Event) == 0x000000, "Member 'FGzVoiceLineData::Event' has a wrong offset!");

// ScriptStruct G01.GzVoiceLineDataArray
// 0x0010 (0x0010 - 0x0000)
struct FGzVoiceLineDataArray final
{
public:
	TArray<struct FGzVoiceLineData>               Array;                                             // 0x0000(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzVoiceLineDataArray) == 0x000008, "Wrong alignment on FGzVoiceLineDataArray");
static_assert(sizeof(FGzVoiceLineDataArray) == 0x000010, "Wrong size on FGzVoiceLineDataArray");
static_assert(offsetof(FGzVoiceLineDataArray, Array) == 0x000000, "Member 'FGzVoiceLineDataArray::Array' has a wrong offset!");

// ScriptStruct G01.GzMeshDataBase
// 0x0040 (0x0040 - 0x0000)
struct FGzMeshDataBase
{
public:
	bool                                          bNoMesh;                                           // 0x0000(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2A12[0x7];                                     // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftObjectPtr<class UObject>                 MeshAsset;                                         // 0x0008(0x0028)(Edit, BlueprintVisible, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EGzSkelMeshAnimPoseBehavior                   AnimPoseBehavior;                                  // 0x0030(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2A13[0x3];                                     // 0x0031(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   CollisionProfileName;                              // 0x0034(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAppendHeadMorphs;                                 // 0x003C(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2A14[0x3];                                     // 0x003D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGzMeshDataBase) == 0x000008, "Wrong alignment on FGzMeshDataBase");
static_assert(sizeof(FGzMeshDataBase) == 0x000040, "Wrong size on FGzMeshDataBase");
static_assert(offsetof(FGzMeshDataBase, bNoMesh) == 0x000000, "Member 'FGzMeshDataBase::bNoMesh' has a wrong offset!");
static_assert(offsetof(FGzMeshDataBase, MeshAsset) == 0x000008, "Member 'FGzMeshDataBase::MeshAsset' has a wrong offset!");
static_assert(offsetof(FGzMeshDataBase, AnimPoseBehavior) == 0x000030, "Member 'FGzMeshDataBase::AnimPoseBehavior' has a wrong offset!");
static_assert(offsetof(FGzMeshDataBase, CollisionProfileName) == 0x000034, "Member 'FGzMeshDataBase::CollisionProfileName' has a wrong offset!");
static_assert(offsetof(FGzMeshDataBase, bAppendHeadMorphs) == 0x00003C, "Member 'FGzMeshDataBase::bAppendHeadMorphs' has a wrong offset!");

// ScriptStruct G01.GzMorphData
// 0x0050 (0x0050 - 0x0000)
struct FGzMorphData final
{
public:
	TMap<class FName, float>                      MorphTargets;                                      // 0x0000(0x0050)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzMorphData) == 0x000008, "Wrong alignment on FGzMorphData");
static_assert(sizeof(FGzMorphData) == 0x000050, "Wrong size on FGzMorphData");
static_assert(offsetof(FGzMorphData, MorphTargets) == 0x000000, "Member 'FGzMorphData::MorphTargets' has a wrong offset!");

// ScriptStruct G01.GzVariationMeshData
// 0x0058 (0x0098 - 0x0040)
struct FGzVariationMeshData final : public FGzMeshDataBase
{
public:
	class FName                                   InternalSlotName;                                  // 0x0040(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGzMorphData                           MorphData;                                         // 0x0048(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzVariationMeshData) == 0x000008, "Wrong alignment on FGzVariationMeshData");
static_assert(sizeof(FGzVariationMeshData) == 0x000098, "Wrong size on FGzVariationMeshData");
static_assert(offsetof(FGzVariationMeshData, InternalSlotName) == 0x000040, "Member 'FGzVariationMeshData::InternalSlotName' has a wrong offset!");
static_assert(offsetof(FGzVariationMeshData, MorphData) == 0x000048, "Member 'FGzVariationMeshData::MorphData' has a wrong offset!");

// ScriptStruct G01.GzCustomizationItemVariation
// 0x0038 (0x0038 - 0x0000)
struct FGzCustomizationItemVariation final
{
public:
	bool                                          bAnyGender;                                        // 0x0000(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EGzBodyGender                                 Gender;                                            // 0x0001(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bHideAllMeshes;                                    // 0x0002(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2A15[0x5];                                     // 0x0003(0x0005)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FGzVariationMeshData>           MeshVariationContainer;                            // 0x0008(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FGameplayTagContainer                  RequiredVisualTags;                                // 0x0018(0x0020)(Edit, BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)
};
static_assert(alignof(FGzCustomizationItemVariation) == 0x000008, "Wrong alignment on FGzCustomizationItemVariation");
static_assert(sizeof(FGzCustomizationItemVariation) == 0x000038, "Wrong size on FGzCustomizationItemVariation");
static_assert(offsetof(FGzCustomizationItemVariation, bAnyGender) == 0x000000, "Member 'FGzCustomizationItemVariation::bAnyGender' has a wrong offset!");
static_assert(offsetof(FGzCustomizationItemVariation, Gender) == 0x000001, "Member 'FGzCustomizationItemVariation::Gender' has a wrong offset!");
static_assert(offsetof(FGzCustomizationItemVariation, bHideAllMeshes) == 0x000002, "Member 'FGzCustomizationItemVariation::bHideAllMeshes' has a wrong offset!");
static_assert(offsetof(FGzCustomizationItemVariation, MeshVariationContainer) == 0x000008, "Member 'FGzCustomizationItemVariation::MeshVariationContainer' has a wrong offset!");
static_assert(offsetof(FGzCustomizationItemVariation, RequiredVisualTags) == 0x000018, "Member 'FGzCustomizationItemVariation::RequiredVisualTags' has a wrong offset!");

// ScriptStruct G01.GzCohtmlGamefaceMovieData
// 0x0020 (0x0020 - 0x0000)
struct FGzCohtmlGamefaceMovieData final
{
public:
	class FString                                 Thumbnail;                                         // 0x0000(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Movie;                                             // 0x0010(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzCohtmlGamefaceMovieData) == 0x000008, "Wrong alignment on FGzCohtmlGamefaceMovieData");
static_assert(sizeof(FGzCohtmlGamefaceMovieData) == 0x000020, "Wrong size on FGzCohtmlGamefaceMovieData");
static_assert(offsetof(FGzCohtmlGamefaceMovieData, Thumbnail) == 0x000000, "Member 'FGzCohtmlGamefaceMovieData::Thumbnail' has a wrong offset!");
static_assert(offsetof(FGzCohtmlGamefaceMovieData, Movie) == 0x000010, "Member 'FGzCohtmlGamefaceMovieData::Movie' has a wrong offset!");

// ScriptStruct G01.GzLimbStatusData
// 0x0018 (0x0018 - 0x0000)
struct FGzLimbStatusData final
{
public:
	int32                                         Charges;                                           // 0x0000(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaxCharges;                                        // 0x0004(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RemainingCooldownOrRecharge;                       // 0x0008(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RechargeDurationPerCharge;                         // 0x000C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bOnlyRechargeWhenEmpty;                            // 0x0010(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2A16[0x3];                                     // 0x0011(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         OptionalValue1;                                    // 0x0014(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzLimbStatusData) == 0x000004, "Wrong alignment on FGzLimbStatusData");
static_assert(sizeof(FGzLimbStatusData) == 0x000018, "Wrong size on FGzLimbStatusData");
static_assert(offsetof(FGzLimbStatusData, Charges) == 0x000000, "Member 'FGzLimbStatusData::Charges' has a wrong offset!");
static_assert(offsetof(FGzLimbStatusData, MaxCharges) == 0x000004, "Member 'FGzLimbStatusData::MaxCharges' has a wrong offset!");
static_assert(offsetof(FGzLimbStatusData, RemainingCooldownOrRecharge) == 0x000008, "Member 'FGzLimbStatusData::RemainingCooldownOrRecharge' has a wrong offset!");
static_assert(offsetof(FGzLimbStatusData, RechargeDurationPerCharge) == 0x00000C, "Member 'FGzLimbStatusData::RechargeDurationPerCharge' has a wrong offset!");
static_assert(offsetof(FGzLimbStatusData, bOnlyRechargeWhenEmpty) == 0x000010, "Member 'FGzLimbStatusData::bOnlyRechargeWhenEmpty' has a wrong offset!");
static_assert(offsetof(FGzLimbStatusData, OptionalValue1) == 0x000014, "Member 'FGzLimbStatusData::OptionalValue1' has a wrong offset!");

// ScriptStruct G01.GzInventoryItemContent
// 0x0048 (0x0048 - 0x0000)
struct FGzInventoryItemContent final
{
public:
	class UGzItemData*                            ItemData;                                          // 0x0000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UGzSkinItemData*                        SkinItemData;                                      // 0x0008(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class UGzItemData*>                    AttachmentItems;                                   // 0x0010(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	int32                                         Quantity;                                          // 0x0020(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         AmmoCount;                                         // 0x0024(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, RepSkip, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LimbHealth;                                        // 0x0028(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, RepSkip, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGzLimbStatusData                      LimbStatus;                                        // 0x002C(0x0018)(BlueprintVisible, RepSkip, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_2A17[0x4];                                     // 0x0044(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGzInventoryItemContent) == 0x000008, "Wrong alignment on FGzInventoryItemContent");
static_assert(sizeof(FGzInventoryItemContent) == 0x000048, "Wrong size on FGzInventoryItemContent");
static_assert(offsetof(FGzInventoryItemContent, ItemData) == 0x000000, "Member 'FGzInventoryItemContent::ItemData' has a wrong offset!");
static_assert(offsetof(FGzInventoryItemContent, SkinItemData) == 0x000008, "Member 'FGzInventoryItemContent::SkinItemData' has a wrong offset!");
static_assert(offsetof(FGzInventoryItemContent, AttachmentItems) == 0x000010, "Member 'FGzInventoryItemContent::AttachmentItems' has a wrong offset!");
static_assert(offsetof(FGzInventoryItemContent, Quantity) == 0x000020, "Member 'FGzInventoryItemContent::Quantity' has a wrong offset!");
static_assert(offsetof(FGzInventoryItemContent, AmmoCount) == 0x000024, "Member 'FGzInventoryItemContent::AmmoCount' has a wrong offset!");
static_assert(offsetof(FGzInventoryItemContent, LimbHealth) == 0x000028, "Member 'FGzInventoryItemContent::LimbHealth' has a wrong offset!");
static_assert(offsetof(FGzInventoryItemContent, LimbStatus) == 0x00002C, "Member 'FGzInventoryItemContent::LimbStatus' has a wrong offset!");

// ScriptStruct G01.GzBackendBattlePassBlockingSlotV2
// 0x0020 (0x0020 - 0x0000)
struct FGzBackendBattlePassBlockingSlotV2 final
{
public:
	class FString                                 P;                                                 // 0x0000(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 S;                                                 // 0x0010(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzBackendBattlePassBlockingSlotV2) == 0x000008, "Wrong alignment on FGzBackendBattlePassBlockingSlotV2");
static_assert(sizeof(FGzBackendBattlePassBlockingSlotV2) == 0x000020, "Wrong size on FGzBackendBattlePassBlockingSlotV2");
static_assert(offsetof(FGzBackendBattlePassBlockingSlotV2, P) == 0x000000, "Member 'FGzBackendBattlePassBlockingSlotV2::P' has a wrong offset!");
static_assert(offsetof(FGzBackendBattlePassBlockingSlotV2, S) == 0x000010, "Member 'FGzBackendBattlePassBlockingSlotV2::S' has a wrong offset!");

// ScriptStruct G01.GzBackendBattlePassSlotPreConditionsV2
// 0x0010 (0x0010 - 0x0000)
struct FGzBackendBattlePassSlotPreConditionsV2 final
{
public:
	TArray<struct FGzBackendBattlePassBlockingSlotV2> bs;                                                // 0x0000(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzBackendBattlePassSlotPreConditionsV2) == 0x000008, "Wrong alignment on FGzBackendBattlePassSlotPreConditionsV2");
static_assert(sizeof(FGzBackendBattlePassSlotPreConditionsV2) == 0x000010, "Wrong size on FGzBackendBattlePassSlotPreConditionsV2");
static_assert(offsetof(FGzBackendBattlePassSlotPreConditionsV2, bs) == 0x000000, "Member 'FGzBackendBattlePassSlotPreConditionsV2::bs' has a wrong offset!");

// ScriptStruct G01.GzHitResponseData
// 0x0038 (0x0038 - 0x0000)
struct FGzHitResponseData final
{
public:
	EGzHitResponseType                            ResponseType;                                      // 0x0000(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bPlayer;                                           // 0x0001(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2A18[0x2];                                     // 0x0002(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTag                           DamageSource;                                      // 0x0004(0x0008)(BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2A19[0x4];                                     // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class AActor*                                 Target;                                            // 0x0010(0x0008)(BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector_NetQuantize                    HitLocation;                                       // 0x0018(0x0018)(BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EGzCharacterDamageAreaType                    DamageArea;                                        // 0x0030(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2A1A[0x7];                                     // 0x0031(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGzHitResponseData) == 0x000008, "Wrong alignment on FGzHitResponseData");
static_assert(sizeof(FGzHitResponseData) == 0x000038, "Wrong size on FGzHitResponseData");
static_assert(offsetof(FGzHitResponseData, ResponseType) == 0x000000, "Member 'FGzHitResponseData::ResponseType' has a wrong offset!");
static_assert(offsetof(FGzHitResponseData, bPlayer) == 0x000001, "Member 'FGzHitResponseData::bPlayer' has a wrong offset!");
static_assert(offsetof(FGzHitResponseData, DamageSource) == 0x000004, "Member 'FGzHitResponseData::DamageSource' has a wrong offset!");
static_assert(offsetof(FGzHitResponseData, Target) == 0x000010, "Member 'FGzHitResponseData::Target' has a wrong offset!");
static_assert(offsetof(FGzHitResponseData, HitLocation) == 0x000018, "Member 'FGzHitResponseData::HitLocation' has a wrong offset!");
static_assert(offsetof(FGzHitResponseData, DamageArea) == 0x000030, "Member 'FGzHitResponseData::DamageArea' has a wrong offset!");

// ScriptStruct G01.GzMetaCompletedAchievementStage
// 0x0010 (0x0010 - 0x0000)
struct FGzMetaCompletedAchievementStage final
{
public:
	class FString                                 CompletedAt;                                       // 0x0000(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzMetaCompletedAchievementStage) == 0x000008, "Wrong alignment on FGzMetaCompletedAchievementStage");
static_assert(sizeof(FGzMetaCompletedAchievementStage) == 0x000010, "Wrong size on FGzMetaCompletedAchievementStage");
static_assert(offsetof(FGzMetaCompletedAchievementStage, CompletedAt) == 0x000000, "Member 'FGzMetaCompletedAchievementStage::CompletedAt' has a wrong offset!");

// ScriptStruct G01.GzMetaCompletedAchievementStagesCollection
// 0x0018 (0x0018 - 0x0000)
struct FGzMetaCompletedAchievementStagesCollection final
{
public:
	class FName                                   AchievementAssetId;                                // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FGzMetaCompletedAchievementStage> CompletedStages;                                   // 0x0008(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzMetaCompletedAchievementStagesCollection) == 0x000008, "Wrong alignment on FGzMetaCompletedAchievementStagesCollection");
static_assert(sizeof(FGzMetaCompletedAchievementStagesCollection) == 0x000018, "Wrong size on FGzMetaCompletedAchievementStagesCollection");
static_assert(offsetof(FGzMetaCompletedAchievementStagesCollection, AchievementAssetId) == 0x000000, "Member 'FGzMetaCompletedAchievementStagesCollection::AchievementAssetId' has a wrong offset!");
static_assert(offsetof(FGzMetaCompletedAchievementStagesCollection, CompletedStages) == 0x000008, "Member 'FGzMetaCompletedAchievementStagesCollection::CompletedStages' has a wrong offset!");

// ScriptStruct G01.GzMetaCompletedAchievementsCollection
// 0x0010 (0x0010 - 0x0000)
struct FGzMetaCompletedAchievementsCollection final
{
public:
	TArray<struct FGzMetaCompletedAchievementStagesCollection> Achievements;                                      // 0x0000(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzMetaCompletedAchievementsCollection) == 0x000008, "Wrong alignment on FGzMetaCompletedAchievementsCollection");
static_assert(sizeof(FGzMetaCompletedAchievementsCollection) == 0x000010, "Wrong size on FGzMetaCompletedAchievementsCollection");
static_assert(offsetof(FGzMetaCompletedAchievementsCollection, Achievements) == 0x000000, "Member 'FGzMetaCompletedAchievementsCollection::Achievements' has a wrong offset!");

// ScriptStruct G01.GzEventNotificationData
// 0x0010 (0x0010 - 0x0000)
struct FGzEventNotificationData final
{
public:
	struct FGameplayTag                           EventTag;                                          // 0x0000(0x0008)(Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bPersistant;                                       // 0x0008(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2A1B[0x3];                                     // 0x0009(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ExpireTime;                                        // 0x000C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzEventNotificationData) == 0x000004, "Wrong alignment on FGzEventNotificationData");
static_assert(sizeof(FGzEventNotificationData) == 0x000010, "Wrong size on FGzEventNotificationData");
static_assert(offsetof(FGzEventNotificationData, EventTag) == 0x000000, "Member 'FGzEventNotificationData::EventTag' has a wrong offset!");
static_assert(offsetof(FGzEventNotificationData, bPersistant) == 0x000008, "Member 'FGzEventNotificationData::bPersistant' has a wrong offset!");
static_assert(offsetof(FGzEventNotificationData, ExpireTime) == 0x00000C, "Member 'FGzEventNotificationData::ExpireTime' has a wrong offset!");

// ScriptStruct G01.GzBackendOnlineInventoryItemDisplayProperties
// 0x00A0 (0x00A0 - 0x0000)
struct FGzBackendOnlineInventoryItemDisplayProperties final
{
public:
	class FString                                 Fo;                                                // 0x0000(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 S;                                                 // 0x0010(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FDateTime                              U;                                                 // 0x0020(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Bp;                                                // 0x0028(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 N;                                                 // 0x0038(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Dc;                                                // 0x0048(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2A1C[0x7];                                     // 0x0049(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 Ms;                                                // 0x0050(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 A;                                                 // 0x0060(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Is;                                                // 0x0070(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FDateTime                              Ca;                                                // 0x0080(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Sn;                                                // 0x0088(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FDateTime                              Ltt;                                               // 0x0098(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzBackendOnlineInventoryItemDisplayProperties) == 0x000008, "Wrong alignment on FGzBackendOnlineInventoryItemDisplayProperties");
static_assert(sizeof(FGzBackendOnlineInventoryItemDisplayProperties) == 0x0000A0, "Wrong size on FGzBackendOnlineInventoryItemDisplayProperties");
static_assert(offsetof(FGzBackendOnlineInventoryItemDisplayProperties, Fo) == 0x000000, "Member 'FGzBackendOnlineInventoryItemDisplayProperties::Fo' has a wrong offset!");
static_assert(offsetof(FGzBackendOnlineInventoryItemDisplayProperties, S) == 0x000010, "Member 'FGzBackendOnlineInventoryItemDisplayProperties::S' has a wrong offset!");
static_assert(offsetof(FGzBackendOnlineInventoryItemDisplayProperties, U) == 0x000020, "Member 'FGzBackendOnlineInventoryItemDisplayProperties::U' has a wrong offset!");
static_assert(offsetof(FGzBackendOnlineInventoryItemDisplayProperties, Bp) == 0x000028, "Member 'FGzBackendOnlineInventoryItemDisplayProperties::Bp' has a wrong offset!");
static_assert(offsetof(FGzBackendOnlineInventoryItemDisplayProperties, N) == 0x000038, "Member 'FGzBackendOnlineInventoryItemDisplayProperties::N' has a wrong offset!");
static_assert(offsetof(FGzBackendOnlineInventoryItemDisplayProperties, Dc) == 0x000048, "Member 'FGzBackendOnlineInventoryItemDisplayProperties::Dc' has a wrong offset!");
static_assert(offsetof(FGzBackendOnlineInventoryItemDisplayProperties, Ms) == 0x000050, "Member 'FGzBackendOnlineInventoryItemDisplayProperties::Ms' has a wrong offset!");
static_assert(offsetof(FGzBackendOnlineInventoryItemDisplayProperties, A) == 0x000060, "Member 'FGzBackendOnlineInventoryItemDisplayProperties::A' has a wrong offset!");
static_assert(offsetof(FGzBackendOnlineInventoryItemDisplayProperties, Is) == 0x000070, "Member 'FGzBackendOnlineInventoryItemDisplayProperties::Is' has a wrong offset!");
static_assert(offsetof(FGzBackendOnlineInventoryItemDisplayProperties, Ca) == 0x000080, "Member 'FGzBackendOnlineInventoryItemDisplayProperties::Ca' has a wrong offset!");
static_assert(offsetof(FGzBackendOnlineInventoryItemDisplayProperties, Sn) == 0x000088, "Member 'FGzBackendOnlineInventoryItemDisplayProperties::Sn' has a wrong offset!");
static_assert(offsetof(FGzBackendOnlineInventoryItemDisplayProperties, Ltt) == 0x000098, "Member 'FGzBackendOnlineInventoryItemDisplayProperties::Ltt' has a wrong offset!");

// ScriptStruct G01.GzBackendInventoryItem
// 0x00B0 (0x00B0 - 0x0000)
struct FGzBackendInventoryItem final
{
public:
	class FString                                 ID;                                                // 0x0000(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGzBackendOnlineInventoryItemDisplayProperties Dp;                                                // 0x0010(0x00A0)(NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzBackendInventoryItem) == 0x000008, "Wrong alignment on FGzBackendInventoryItem");
static_assert(sizeof(FGzBackendInventoryItem) == 0x0000B0, "Wrong size on FGzBackendInventoryItem");
static_assert(offsetof(FGzBackendInventoryItem, ID) == 0x000000, "Member 'FGzBackendInventoryItem::ID' has a wrong offset!");
static_assert(offsetof(FGzBackendInventoryItem, Dp) == 0x000010, "Member 'FGzBackendInventoryItem::Dp' has a wrong offset!");

// ScriptStruct G01.GzPlayFabResultErrorDetails
// 0x0010 (0x0010 - 0x0000)
struct FGzPlayFabResultErrorDetails final
{
public:
	class FString                                 FeatureName;                                       // 0x0000(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzPlayFabResultErrorDetails) == 0x000008, "Wrong alignment on FGzPlayFabResultErrorDetails");
static_assert(sizeof(FGzPlayFabResultErrorDetails) == 0x000010, "Wrong size on FGzPlayFabResultErrorDetails");
static_assert(offsetof(FGzPlayFabResultErrorDetails, FeatureName) == 0x000000, "Member 'FGzPlayFabResultErrorDetails::FeatureName' has a wrong offset!");

// ScriptStruct G01.GzPlayFabResultBase
// 0x00E0 (0x00E0 - 0x0000)
struct FGzPlayFabResultBase
{
public:
	uint32                                        Code;                                              // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2A1D[0x4];                                     // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 ErrorMessage;                                      // 0x0008(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 OperationId;                                       // 0x0018(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGzPlayFabResultErrorDetails           ErrorDetails;                                      // 0x0028(0x0010)(NativeAccessSpecifierPublic)
	uint8                                         Pad_2A1E[0xA8];                                    // 0x0038(0x00A8)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGzPlayFabResultBase) == 0x000008, "Wrong alignment on FGzPlayFabResultBase");
static_assert(sizeof(FGzPlayFabResultBase) == 0x0000E0, "Wrong size on FGzPlayFabResultBase");
static_assert(offsetof(FGzPlayFabResultBase, Code) == 0x000000, "Member 'FGzPlayFabResultBase::Code' has a wrong offset!");
static_assert(offsetof(FGzPlayFabResultBase, ErrorMessage) == 0x000008, "Member 'FGzPlayFabResultBase::ErrorMessage' has a wrong offset!");
static_assert(offsetof(FGzPlayFabResultBase, OperationId) == 0x000018, "Member 'FGzPlayFabResultBase::OperationId' has a wrong offset!");
static_assert(offsetof(FGzPlayFabResultBase, ErrorDetails) == 0x000028, "Member 'FGzPlayFabResultBase::ErrorDetails' has a wrong offset!");

// ScriptStruct G01.GzPurchaseBattlePassItemResultV2
// 0x0010 (0x00F0 - 0x00E0)
struct FGzPurchaseBattlePassItemResultV2 final : public FGzPlayFabResultBase
{
public:
	TArray<struct FGzBackendInventoryItem>        InventoryItemsSimplified;                          // 0x00E0(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzPurchaseBattlePassItemResultV2) == 0x000008, "Wrong alignment on FGzPurchaseBattlePassItemResultV2");
static_assert(sizeof(FGzPurchaseBattlePassItemResultV2) == 0x0000F0, "Wrong size on FGzPurchaseBattlePassItemResultV2");
static_assert(offsetof(FGzPurchaseBattlePassItemResultV2, InventoryItemsSimplified) == 0x0000E0, "Member 'FGzPurchaseBattlePassItemResultV2::InventoryItemsSimplified' has a wrong offset!");

// ScriptStruct G01.DistanceBasedScore
// 0x000C (0x000C - 0x0000)
struct FDistanceBasedScore final
{
public:
	float                                         MinDistance;                                       // 0x0000(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxDistance;                                       // 0x0004(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Score;                                             // 0x0008(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDistanceBasedScore) == 0x000004, "Wrong alignment on FDistanceBasedScore");
static_assert(sizeof(FDistanceBasedScore) == 0x00000C, "Wrong size on FDistanceBasedScore");
static_assert(offsetof(FDistanceBasedScore, MinDistance) == 0x000000, "Member 'FDistanceBasedScore::MinDistance' has a wrong offset!");
static_assert(offsetof(FDistanceBasedScore, MaxDistance) == 0x000004, "Member 'FDistanceBasedScore::MaxDistance' has a wrong offset!");
static_assert(offsetof(FDistanceBasedScore, Score) == 0x000008, "Member 'FDistanceBasedScore::Score' has a wrong offset!");

// ScriptStruct G01.GzCoverExitData
// 0x0030 (0x0030 - 0x0000)
struct FGzCoverExitData final
{
public:
	struct FVector                                PointLoc;                                          // 0x0000(0x0018)(Edit, BlueprintVisible, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Direction;                                         // 0x0018(0x0018)(Edit, BlueprintVisible, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzCoverExitData) == 0x000008, "Wrong alignment on FGzCoverExitData");
static_assert(sizeof(FGzCoverExitData) == 0x000030, "Wrong size on FGzCoverExitData");
static_assert(offsetof(FGzCoverExitData, PointLoc) == 0x000000, "Member 'FGzCoverExitData::PointLoc' has a wrong offset!");
static_assert(offsetof(FGzCoverExitData, Direction) == 0x000018, "Member 'FGzCoverExitData::Direction' has a wrong offset!");

// ScriptStruct G01.GzCoverData
// 0x0088 (0x0088 - 0x0000)
struct FGzCoverData final
{
public:
	struct FVector                                Position;                                          // 0x0000(0x0018)(Edit, BlueprintVisible, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                CoverNormal;                                       // 0x0018(0x0018)(Edit, BlueprintVisible, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          StandingCover;                                     // 0x0030(0x0001)(Edit, BlueprintVisible, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2A1F[0x3];                                     // 0x0031(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         CoverHeight;                                       // 0x0034(0x0004)(Edit, BlueprintVisible, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMap<EGzCoverSide, struct FGzCoverExitData>   ExitPoints;                                        // 0x0038(0x0050)(Edit, BlueprintVisible, EditConst, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzCoverData) == 0x000008, "Wrong alignment on FGzCoverData");
static_assert(sizeof(FGzCoverData) == 0x000088, "Wrong size on FGzCoverData");
static_assert(offsetof(FGzCoverData, Position) == 0x000000, "Member 'FGzCoverData::Position' has a wrong offset!");
static_assert(offsetof(FGzCoverData, CoverNormal) == 0x000018, "Member 'FGzCoverData::CoverNormal' has a wrong offset!");
static_assert(offsetof(FGzCoverData, StandingCover) == 0x000030, "Member 'FGzCoverData::StandingCover' has a wrong offset!");
static_assert(offsetof(FGzCoverData, CoverHeight) == 0x000034, "Member 'FGzCoverData::CoverHeight' has a wrong offset!");
static_assert(offsetof(FGzCoverData, ExitPoints) == 0x000038, "Member 'FGzCoverData::ExitPoints' has a wrong offset!");

// ScriptStruct G01.GzDamageIndicatorKey
// 0x0008 (0x0008 - 0x0000)
struct FGzDamageIndicatorKey final
{
public:
	class FName                                   Name;                                              // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzDamageIndicatorKey) == 0x000004, "Wrong alignment on FGzDamageIndicatorKey");
static_assert(sizeof(FGzDamageIndicatorKey) == 0x000008, "Wrong size on FGzDamageIndicatorKey");
static_assert(offsetof(FGzDamageIndicatorKey, Name) == 0x000000, "Member 'FGzDamageIndicatorKey::Name' has a wrong offset!");

// ScriptStruct G01.GzMissionState
// 0x000C (0x000C - 0x0000)
struct FGzMissionState final
{
public:
	EMissionState                                 State;                                             // 0x0000(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2A20[0x3];                                     // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTag                           StateTag;                                          // 0x0004(0x0008)(BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzMissionState) == 0x000004, "Wrong alignment on FGzMissionState");
static_assert(sizeof(FGzMissionState) == 0x00000C, "Wrong size on FGzMissionState");
static_assert(offsetof(FGzMissionState, State) == 0x000000, "Member 'FGzMissionState::State' has a wrong offset!");
static_assert(offsetof(FGzMissionState, StateTag) == 0x000004, "Member 'FGzMissionState::StateTag' has a wrong offset!");

// ScriptStruct G01.GzCohtmlListMarketFilters
// 0x0060 (0x0060 - 0x0000)
struct FGzCohtmlListMarketFilters final
{
public:
	uint32                                        Offset;                                            // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Limit;                                             // 0x0004(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2A21[0x3];                                     // 0x0005(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FString>                         QualityFilters;                                    // 0x0008(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class FString>                         TypeFilters;                                       // 0x0018(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	class FString                                 Name;                                              // 0x0028(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class FString>                         AssetIds;                                          // 0x0038(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	double                                        MinPrice;                                          // 0x0048(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	double                                        MaxPrice;                                          // 0x0050(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EGzCohtmlListMarketOrder                      OrderBy;                                           // 0x0058(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EGzCohtmlListMarketOrderType                  OrderType;                                         // 0x0059(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2A22[0x6];                                     // 0x005A(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGzCohtmlListMarketFilters) == 0x000008, "Wrong alignment on FGzCohtmlListMarketFilters");
static_assert(sizeof(FGzCohtmlListMarketFilters) == 0x000060, "Wrong size on FGzCohtmlListMarketFilters");
static_assert(offsetof(FGzCohtmlListMarketFilters, Offset) == 0x000000, "Member 'FGzCohtmlListMarketFilters::Offset' has a wrong offset!");
static_assert(offsetof(FGzCohtmlListMarketFilters, Limit) == 0x000004, "Member 'FGzCohtmlListMarketFilters::Limit' has a wrong offset!");
static_assert(offsetof(FGzCohtmlListMarketFilters, QualityFilters) == 0x000008, "Member 'FGzCohtmlListMarketFilters::QualityFilters' has a wrong offset!");
static_assert(offsetof(FGzCohtmlListMarketFilters, TypeFilters) == 0x000018, "Member 'FGzCohtmlListMarketFilters::TypeFilters' has a wrong offset!");
static_assert(offsetof(FGzCohtmlListMarketFilters, Name) == 0x000028, "Member 'FGzCohtmlListMarketFilters::Name' has a wrong offset!");
static_assert(offsetof(FGzCohtmlListMarketFilters, AssetIds) == 0x000038, "Member 'FGzCohtmlListMarketFilters::AssetIds' has a wrong offset!");
static_assert(offsetof(FGzCohtmlListMarketFilters, MinPrice) == 0x000048, "Member 'FGzCohtmlListMarketFilters::MinPrice' has a wrong offset!");
static_assert(offsetof(FGzCohtmlListMarketFilters, MaxPrice) == 0x000050, "Member 'FGzCohtmlListMarketFilters::MaxPrice' has a wrong offset!");
static_assert(offsetof(FGzCohtmlListMarketFilters, OrderBy) == 0x000058, "Member 'FGzCohtmlListMarketFilters::OrderBy' has a wrong offset!");
static_assert(offsetof(FGzCohtmlListMarketFilters, OrderType) == 0x000059, "Member 'FGzCohtmlListMarketFilters::OrderType' has a wrong offset!");

// ScriptStruct G01.GzCohtmlScheduledChallenge
// 0x0090 (0x0090 - 0x0000)
struct FGzCohtmlScheduledChallenge final
{
public:
	class FText                                   Title;                                             // 0x0000(0x0010)(NativeAccessSpecifierPublic)
	class FText                                   Description;                                       // 0x0010(0x0010)(NativeAccessSpecifierPublic)
	float                                         CurrentProgress;                                   // 0x0020(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxProgress;                                       // 0x0024(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class FString>                         ItemRewards;                                       // 0x0028(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TMap<class FString, double>                   CoinRewards;                                       // 0x0038(0x0050)(NativeAccessSpecifierPublic)
	bool                                          IsCompleted;                                       // 0x0088(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2A23[0x7];                                     // 0x0089(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGzCohtmlScheduledChallenge) == 0x000008, "Wrong alignment on FGzCohtmlScheduledChallenge");
static_assert(sizeof(FGzCohtmlScheduledChallenge) == 0x000090, "Wrong size on FGzCohtmlScheduledChallenge");
static_assert(offsetof(FGzCohtmlScheduledChallenge, Title) == 0x000000, "Member 'FGzCohtmlScheduledChallenge::Title' has a wrong offset!");
static_assert(offsetof(FGzCohtmlScheduledChallenge, Description) == 0x000010, "Member 'FGzCohtmlScheduledChallenge::Description' has a wrong offset!");
static_assert(offsetof(FGzCohtmlScheduledChallenge, CurrentProgress) == 0x000020, "Member 'FGzCohtmlScheduledChallenge::CurrentProgress' has a wrong offset!");
static_assert(offsetof(FGzCohtmlScheduledChallenge, MaxProgress) == 0x000024, "Member 'FGzCohtmlScheduledChallenge::MaxProgress' has a wrong offset!");
static_assert(offsetof(FGzCohtmlScheduledChallenge, ItemRewards) == 0x000028, "Member 'FGzCohtmlScheduledChallenge::ItemRewards' has a wrong offset!");
static_assert(offsetof(FGzCohtmlScheduledChallenge, CoinRewards) == 0x000038, "Member 'FGzCohtmlScheduledChallenge::CoinRewards' has a wrong offset!");
static_assert(offsetof(FGzCohtmlScheduledChallenge, IsCompleted) == 0x000088, "Member 'FGzCohtmlScheduledChallenge::IsCompleted' has a wrong offset!");

// ScriptStruct G01.GzCohtmlChallengeList
// 0x0020 (0x0020 - 0x0000)
struct FGzCohtmlChallengeList final
{
public:
	class FString                                 ExpirationUtcTimeDate;                             // 0x0000(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FGzCohtmlScheduledChallenge>    Challenges;                                        // 0x0010(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzCohtmlChallengeList) == 0x000008, "Wrong alignment on FGzCohtmlChallengeList");
static_assert(sizeof(FGzCohtmlChallengeList) == 0x000020, "Wrong size on FGzCohtmlChallengeList");
static_assert(offsetof(FGzCohtmlChallengeList, ExpirationUtcTimeDate) == 0x000000, "Member 'FGzCohtmlChallengeList::ExpirationUtcTimeDate' has a wrong offset!");
static_assert(offsetof(FGzCohtmlChallengeList, Challenges) == 0x000010, "Member 'FGzCohtmlChallengeList::Challenges' has a wrong offset!");

// ScriptStruct G01.GzInvPocketId
// 0x0008 (0x0008 - 0x0000)
struct FGzInvPocketId final
{
public:
	EGzInvPocketSource                            Source;                                            // 0x0000(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2A24[0x3];                                     // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         Index;                                             // 0x0004(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzInvPocketId) == 0x000004, "Wrong alignment on FGzInvPocketId");
static_assert(sizeof(FGzInvPocketId) == 0x000008, "Wrong size on FGzInvPocketId");
static_assert(offsetof(FGzInvPocketId, Source) == 0x000000, "Member 'FGzInvPocketId::Source' has a wrong offset!");
static_assert(offsetof(FGzInvPocketId, Index) == 0x000004, "Member 'FGzInvPocketId::Index' has a wrong offset!");

// ScriptStruct G01.GzResultCollectOtgProButtonClicked
// 0x0000 (0x00E0 - 0x00E0)
struct FGzResultCollectOtgProButtonClicked final : public FGzPlayFabResultBase
{
};
static_assert(alignof(FGzResultCollectOtgProButtonClicked) == 0x000008, "Wrong alignment on FGzResultCollectOtgProButtonClicked");
static_assert(sizeof(FGzResultCollectOtgProButtonClicked) == 0x0000E0, "Wrong size on FGzResultCollectOtgProButtonClicked");

// ScriptStruct G01.GzDepthOfFieldCameraSettings
// 0x0018 (0x0018 - 0x0000)
struct FGzDepthOfFieldCameraSettings final
{
public:
	bool                                          bShouldUseDynamicFocusDistance;                    // 0x0000(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2A25[0x3];                                     // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ManualFocusDistance;                               // 0x0004(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FStop;                                             // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FocalLength;                                       // 0x000C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2A26[0x8];                                     // 0x0010(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGzDepthOfFieldCameraSettings) == 0x000004, "Wrong alignment on FGzDepthOfFieldCameraSettings");
static_assert(sizeof(FGzDepthOfFieldCameraSettings) == 0x000018, "Wrong size on FGzDepthOfFieldCameraSettings");
static_assert(offsetof(FGzDepthOfFieldCameraSettings, bShouldUseDynamicFocusDistance) == 0x000000, "Member 'FGzDepthOfFieldCameraSettings::bShouldUseDynamicFocusDistance' has a wrong offset!");
static_assert(offsetof(FGzDepthOfFieldCameraSettings, ManualFocusDistance) == 0x000004, "Member 'FGzDepthOfFieldCameraSettings::ManualFocusDistance' has a wrong offset!");
static_assert(offsetof(FGzDepthOfFieldCameraSettings, FStop) == 0x000008, "Member 'FGzDepthOfFieldCameraSettings::FStop' has a wrong offset!");
static_assert(offsetof(FGzDepthOfFieldCameraSettings, FocalLength) == 0x00000C, "Member 'FGzDepthOfFieldCameraSettings::FocalLength' has a wrong offset!");

// ScriptStruct G01.LyraReplicatedAcceleration
// 0x0003 (0x0003 - 0x0000)
struct FLyraReplicatedAcceleration final
{
public:
	uint8                                         AccelXYRadians;                                    // 0x0000(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         AccelXYMagnitude;                                  // 0x0001(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int8                                          AccelZ;                                            // 0x0002(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FLyraReplicatedAcceleration) == 0x000001, "Wrong alignment on FLyraReplicatedAcceleration");
static_assert(sizeof(FLyraReplicatedAcceleration) == 0x000003, "Wrong size on FLyraReplicatedAcceleration");
static_assert(offsetof(FLyraReplicatedAcceleration, AccelXYRadians) == 0x000000, "Member 'FLyraReplicatedAcceleration::AccelXYRadians' has a wrong offset!");
static_assert(offsetof(FLyraReplicatedAcceleration, AccelXYMagnitude) == 0x000001, "Member 'FLyraReplicatedAcceleration::AccelXYMagnitude' has a wrong offset!");
static_assert(offsetof(FLyraReplicatedAcceleration, AccelZ) == 0x000002, "Member 'FLyraReplicatedAcceleration::AccelZ' has a wrong offset!");

// ScriptStruct G01.GzCohtmlGameStatTemplate
// 0x0010 (0x0010 - 0x0000)
struct FGzCohtmlGameStatTemplate final
{
public:
	class FText                                   PostMatchDisplayName;                              // 0x0000(0x0010)(NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzCohtmlGameStatTemplate) == 0x000008, "Wrong alignment on FGzCohtmlGameStatTemplate");
static_assert(sizeof(FGzCohtmlGameStatTemplate) == 0x000010, "Wrong size on FGzCohtmlGameStatTemplate");
static_assert(offsetof(FGzCohtmlGameStatTemplate, PostMatchDisplayName) == 0x000000, "Member 'FGzCohtmlGameStatTemplate::PostMatchDisplayName' has a wrong offset!");

// ScriptStruct G01.GzMatchmakingTelemetryData
// 0x0038 (0x0038 - 0x0000)
struct FGzMatchmakingTelemetryData
{
public:
	class FString                                 MatchID;                                           // 0x0000(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 TicketId;                                          // 0x0010(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FDateTime                              StartTime;                                         // 0x0020(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FDateTime                              TicketReceivedTime;                                // 0x0028(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FDateTime                              MatchFoundTime;                                    // 0x0030(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzMatchmakingTelemetryData) == 0x000008, "Wrong alignment on FGzMatchmakingTelemetryData");
static_assert(sizeof(FGzMatchmakingTelemetryData) == 0x000038, "Wrong size on FGzMatchmakingTelemetryData");
static_assert(offsetof(FGzMatchmakingTelemetryData, MatchID) == 0x000000, "Member 'FGzMatchmakingTelemetryData::MatchID' has a wrong offset!");
static_assert(offsetof(FGzMatchmakingTelemetryData, TicketId) == 0x000010, "Member 'FGzMatchmakingTelemetryData::TicketId' has a wrong offset!");
static_assert(offsetof(FGzMatchmakingTelemetryData, StartTime) == 0x000020, "Member 'FGzMatchmakingTelemetryData::StartTime' has a wrong offset!");
static_assert(offsetof(FGzMatchmakingTelemetryData, TicketReceivedTime) == 0x000028, "Member 'FGzMatchmakingTelemetryData::TicketReceivedTime' has a wrong offset!");
static_assert(offsetof(FGzMatchmakingTelemetryData, MatchFoundTime) == 0x000030, "Member 'FGzMatchmakingTelemetryData::MatchFoundTime' has a wrong offset!");

// ScriptStruct G01.GzUnityMatchPartyShareData
// 0x0018 (0x0050 - 0x0038)
struct FGzUnityMatchPartyShareData final : public FGzMatchmakingTelemetryData
{
public:
	class FString                                 Ip;                                                // 0x0038(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint32                                        Port;                                              // 0x0048(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2A27[0x4];                                     // 0x004C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGzUnityMatchPartyShareData) == 0x000008, "Wrong alignment on FGzUnityMatchPartyShareData");
static_assert(sizeof(FGzUnityMatchPartyShareData) == 0x000050, "Wrong size on FGzUnityMatchPartyShareData");
static_assert(offsetof(FGzUnityMatchPartyShareData, Ip) == 0x000038, "Member 'FGzUnityMatchPartyShareData::Ip' has a wrong offset!");
static_assert(offsetof(FGzUnityMatchPartyShareData, Port) == 0x000048, "Member 'FGzUnityMatchPartyShareData::Port' has a wrong offset!");

// ScriptStruct G01.GzInvItem
// 0x0010 (0x0010 - 0x0000)
struct FGzInvItem final
{
public:
	struct FInstancedStruct                       Content;                                           // 0x0000(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)
};
static_assert(alignof(FGzInvItem) == 0x000008, "Wrong alignment on FGzInvItem");
static_assert(sizeof(FGzInvItem) == 0x000010, "Wrong size on FGzInvItem");
static_assert(offsetof(FGzInvItem, Content) == 0x000000, "Member 'FGzInvItem::Content' has a wrong offset!");

// ScriptStruct G01.GzCreateCharacterResult
// 0x0050 (0x0130 - 0x00E0)
struct FGzCreateCharacterResult final : public FGzPlayFabResultBase
{
public:
	class FString                                 PlayFabId;                                         // 0x00E0(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 CharacterId;                                       // 0x00F0(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 CharacterName;                                     // 0x0100(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 CharacterType;                                     // 0x0110(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Faction;                                           // 0x0120(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzCreateCharacterResult) == 0x000008, "Wrong alignment on FGzCreateCharacterResult");
static_assert(sizeof(FGzCreateCharacterResult) == 0x000130, "Wrong size on FGzCreateCharacterResult");
static_assert(offsetof(FGzCreateCharacterResult, PlayFabId) == 0x0000E0, "Member 'FGzCreateCharacterResult::PlayFabId' has a wrong offset!");
static_assert(offsetof(FGzCreateCharacterResult, CharacterId) == 0x0000F0, "Member 'FGzCreateCharacterResult::CharacterId' has a wrong offset!");
static_assert(offsetof(FGzCreateCharacterResult, CharacterName) == 0x000100, "Member 'FGzCreateCharacterResult::CharacterName' has a wrong offset!");
static_assert(offsetof(FGzCreateCharacterResult, CharacterType) == 0x000110, "Member 'FGzCreateCharacterResult::CharacterType' has a wrong offset!");
static_assert(offsetof(FGzCreateCharacterResult, Faction) == 0x000120, "Member 'FGzCreateCharacterResult::Faction' has a wrong offset!");

// ScriptStruct G01.GzDefaultItemViewmakerSetupBase
// 0x0008 (0x0008 - 0x0000)
struct alignas(0x08) FGzDefaultItemViewmakerSetupBase
{
public:
	uint8                                         Pad_2A28[0x8];                                     // 0x0000(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGzDefaultItemViewmakerSetupBase) == 0x000008, "Wrong alignment on FGzDefaultItemViewmakerSetupBase");
static_assert(sizeof(FGzDefaultItemViewmakerSetupBase) == 0x000008, "Wrong size on FGzDefaultItemViewmakerSetupBase");

// ScriptStruct G01.GzViewemakerSetup
// 0x0020 (0x0028 - 0x0008)
struct FGzViewemakerSetup : public FGzDefaultItemViewmakerSetupBase
{
public:
	class AGzSceneViewpoint*                      ViewPoint;                                         // 0x0008(0x0008)(Edit, ZeroConstructor, DisableEditOnTemplate, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AGzSceneSpawnpoint*                     Spawnpoint;                                        // 0x0010(0x0008)(Edit, ZeroConstructor, DisableEditOnTemplate, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           SequenceTag;                                       // 0x0018(0x0008)(Edit, DisableEditOnTemplate, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           PoseTag;                                           // 0x0020(0x0008)(Edit, DisableEditOnTemplate, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzViewemakerSetup) == 0x000008, "Wrong alignment on FGzViewemakerSetup");
static_assert(sizeof(FGzViewemakerSetup) == 0x000028, "Wrong size on FGzViewemakerSetup");
static_assert(offsetof(FGzViewemakerSetup, ViewPoint) == 0x000008, "Member 'FGzViewemakerSetup::ViewPoint' has a wrong offset!");
static_assert(offsetof(FGzViewemakerSetup, Spawnpoint) == 0x000010, "Member 'FGzViewemakerSetup::Spawnpoint' has a wrong offset!");
static_assert(offsetof(FGzViewemakerSetup, SequenceTag) == 0x000018, "Member 'FGzViewemakerSetup::SequenceTag' has a wrong offset!");
static_assert(offsetof(FGzViewemakerSetup, PoseTag) == 0x000020, "Member 'FGzViewemakerSetup::PoseTag' has a wrong offset!");

// ScriptStruct G01.GzLoadoutViewmakerSetup
// 0x00C0 (0x00C8 - 0x0008)
struct FGzLoadoutViewmakerSetup final : public FGzDefaultItemViewmakerSetupBase
{
public:
	struct FInstancedStruct                       PerSlot[0x9];                                      // 0x0008(0x0010)(Edit, DisableEditOnTemplate, NativeAccessSpecifierPublic)
	class AGzSceneSpawnpoint*                     LegsAlternative;                                   // 0x0098(0x0008)(Edit, ZeroConstructor, DisableEditOnTemplate, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGzViewemakerSetup                     Default;                                           // 0x00A0(0x0028)(Edit, DisableEditOnTemplate, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzLoadoutViewmakerSetup) == 0x000008, "Wrong alignment on FGzLoadoutViewmakerSetup");
static_assert(sizeof(FGzLoadoutViewmakerSetup) == 0x0000C8, "Wrong size on FGzLoadoutViewmakerSetup");
static_assert(offsetof(FGzLoadoutViewmakerSetup, PerSlot) == 0x000008, "Member 'FGzLoadoutViewmakerSetup::PerSlot' has a wrong offset!");
static_assert(offsetof(FGzLoadoutViewmakerSetup, LegsAlternative) == 0x000098, "Member 'FGzLoadoutViewmakerSetup::LegsAlternative' has a wrong offset!");
static_assert(offsetof(FGzLoadoutViewmakerSetup, Default) == 0x0000A0, "Member 'FGzLoadoutViewmakerSetup::Default' has a wrong offset!");

// ScriptStruct G01.GzMicroMissiles_LockOnTarget
// 0x0120 (0x0120 - 0x0000)
struct FGzMicroMissiles_LockOnTarget final
{
public:
	struct FHitResult                             HitResult;                                         // 0x0000(0x00F8)(BlueprintVisible, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	bool                                          bUseTargetLocation;                                // 0x00F8(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EGzMicroMissileValidationStatus               ValidationStatus;                                  // 0x00F9(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, RepSkip, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2A29[0x6];                                     // 0x00FA(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTimerHandle                           ValidationTimeoutTimerHandle;                      // 0x0100(0x0008)(BlueprintVisible, BlueprintReadOnly, Transient, RepSkip, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsLockingOn;                                      // 0x0108(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, RepSkip, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2A2A[0x3];                                     // 0x0109(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TWeakObjectPtr<class AGzMicroMissilesLockOnIndicator> LockOnWidgetActor;                                 // 0x010C(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, RepSkip, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LockOnProgress;                                    // 0x0114(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, RepSkip, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UGzTargetableComponent*                 TargetableComponent;                               // 0x0118(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, Transient, InstancedReference, RepSkip, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzMicroMissiles_LockOnTarget) == 0x000008, "Wrong alignment on FGzMicroMissiles_LockOnTarget");
static_assert(sizeof(FGzMicroMissiles_LockOnTarget) == 0x000120, "Wrong size on FGzMicroMissiles_LockOnTarget");
static_assert(offsetof(FGzMicroMissiles_LockOnTarget, HitResult) == 0x000000, "Member 'FGzMicroMissiles_LockOnTarget::HitResult' has a wrong offset!");
static_assert(offsetof(FGzMicroMissiles_LockOnTarget, bUseTargetLocation) == 0x0000F8, "Member 'FGzMicroMissiles_LockOnTarget::bUseTargetLocation' has a wrong offset!");
static_assert(offsetof(FGzMicroMissiles_LockOnTarget, ValidationStatus) == 0x0000F9, "Member 'FGzMicroMissiles_LockOnTarget::ValidationStatus' has a wrong offset!");
static_assert(offsetof(FGzMicroMissiles_LockOnTarget, ValidationTimeoutTimerHandle) == 0x000100, "Member 'FGzMicroMissiles_LockOnTarget::ValidationTimeoutTimerHandle' has a wrong offset!");
static_assert(offsetof(FGzMicroMissiles_LockOnTarget, bIsLockingOn) == 0x000108, "Member 'FGzMicroMissiles_LockOnTarget::bIsLockingOn' has a wrong offset!");
static_assert(offsetof(FGzMicroMissiles_LockOnTarget, LockOnWidgetActor) == 0x00010C, "Member 'FGzMicroMissiles_LockOnTarget::LockOnWidgetActor' has a wrong offset!");
static_assert(offsetof(FGzMicroMissiles_LockOnTarget, LockOnProgress) == 0x000114, "Member 'FGzMicroMissiles_LockOnTarget::LockOnProgress' has a wrong offset!");
static_assert(offsetof(FGzMicroMissiles_LockOnTarget, TargetableComponent) == 0x000118, "Member 'FGzMicroMissiles_LockOnTarget::TargetableComponent' has a wrong offset!");

// ScriptStruct G01.GzGameNotificationAvailabilitySettings
// 0x0050 (0x0050 - 0x0000)
struct FGzGameNotificationAvailabilitySettings final
{
public:
	bool                                          bGlobalEnableNotification;                         // 0x0000(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEnableGameRules;                                  // 0x0001(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2A2B[0x6];                                     // 0x0002(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTagContainer                  AvailabilityGameRules;                             // 0x0008(0x0020)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	bool                                          bEnableBlockingStates;                             // 0x0028(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2A2C[0x7];                                     // 0x0029(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTagContainer                  BlockingGameStates;                                // 0x0030(0x0020)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzGameNotificationAvailabilitySettings) == 0x000008, "Wrong alignment on FGzGameNotificationAvailabilitySettings");
static_assert(sizeof(FGzGameNotificationAvailabilitySettings) == 0x000050, "Wrong size on FGzGameNotificationAvailabilitySettings");
static_assert(offsetof(FGzGameNotificationAvailabilitySettings, bGlobalEnableNotification) == 0x000000, "Member 'FGzGameNotificationAvailabilitySettings::bGlobalEnableNotification' has a wrong offset!");
static_assert(offsetof(FGzGameNotificationAvailabilitySettings, bEnableGameRules) == 0x000001, "Member 'FGzGameNotificationAvailabilitySettings::bEnableGameRules' has a wrong offset!");
static_assert(offsetof(FGzGameNotificationAvailabilitySettings, AvailabilityGameRules) == 0x000008, "Member 'FGzGameNotificationAvailabilitySettings::AvailabilityGameRules' has a wrong offset!");
static_assert(offsetof(FGzGameNotificationAvailabilitySettings, bEnableBlockingStates) == 0x000028, "Member 'FGzGameNotificationAvailabilitySettings::bEnableBlockingStates' has a wrong offset!");
static_assert(offsetof(FGzGameNotificationAvailabilitySettings, BlockingGameStates) == 0x000030, "Member 'FGzGameNotificationAvailabilitySettings::BlockingGameStates' has a wrong offset!");

// ScriptStruct G01.GzPlayFabPackageBase
// 0x0058 (0x0058 - 0x0000)
struct FGzPlayFabPackageBase
{
public:
	int64                                         V;                                                 // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TMap<class FString, bool>                     FeatureSwitches;                                   // 0x0008(0x0050)(NativeAccessSpecifierPrivate)
};
static_assert(alignof(FGzPlayFabPackageBase) == 0x000008, "Wrong alignment on FGzPlayFabPackageBase");
static_assert(sizeof(FGzPlayFabPackageBase) == 0x000058, "Wrong size on FGzPlayFabPackageBase");
static_assert(offsetof(FGzPlayFabPackageBase, V) == 0x000000, "Member 'FGzPlayFabPackageBase::V' has a wrong offset!");
static_assert(offsetof(FGzPlayFabPackageBase, FeatureSwitches) == 0x000008, "Member 'FGzPlayFabPackageBase::FeatureSwitches' has a wrong offset!");

// ScriptStruct G01.GzPlayFabClientPackage
// 0x0010 (0x0068 - 0x0058)
struct FGzPlayFabClientPackage : public FGzPlayFabPackageBase
{
public:
	class FString                                 SessionId;                                         // 0x0058(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
};
static_assert(alignof(FGzPlayFabClientPackage) == 0x000008, "Wrong alignment on FGzPlayFabClientPackage");
static_assert(sizeof(FGzPlayFabClientPackage) == 0x000068, "Wrong size on FGzPlayFabClientPackage");
static_assert(offsetof(FGzPlayFabClientPackage, SessionId) == 0x000058, "Member 'FGzPlayFabClientPackage::SessionId' has a wrong offset!");

// ScriptStruct G01.GzPackageCheatResetAllJobs
// 0x0010 (0x0078 - 0x0068)
struct FGzPackageCheatResetAllJobs final : public FGzPlayFabClientPackage
{
public:
	class FString                                 CharacterId;                                       // 0x0068(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzPackageCheatResetAllJobs) == 0x000008, "Wrong alignment on FGzPackageCheatResetAllJobs");
static_assert(sizeof(FGzPackageCheatResetAllJobs) == 0x000078, "Wrong size on FGzPackageCheatResetAllJobs");
static_assert(offsetof(FGzPackageCheatResetAllJobs, CharacterId) == 0x000068, "Member 'FGzPackageCheatResetAllJobs::CharacterId' has a wrong offset!");

// ScriptStruct G01.GzDebugCustomizationProfile
// 0x00B0 (0x00B0 - 0x0000)
struct FGzDebugCustomizationProfile final
{
public:
	class FString                                 BodyArchetypeName;                                 // 0x0000(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 HeadName;                                          // 0x0010(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 HairName;                                          // 0x0020(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 BeardName;                                         // 0x0030(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 EyebrowsName;                                      // 0x0040(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 LeftEyeName;                                       // 0x0050(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 RightEyeName;                                      // 0x0060(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 FaceImplantName;                                   // 0x0070(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 NeckImplantName;                                   // 0x0080(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 TorsoName;                                         // 0x0090(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 ProfileName;                                       // 0x00A0(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzDebugCustomizationProfile) == 0x000008, "Wrong alignment on FGzDebugCustomizationProfile");
static_assert(sizeof(FGzDebugCustomizationProfile) == 0x0000B0, "Wrong size on FGzDebugCustomizationProfile");
static_assert(offsetof(FGzDebugCustomizationProfile, BodyArchetypeName) == 0x000000, "Member 'FGzDebugCustomizationProfile::BodyArchetypeName' has a wrong offset!");
static_assert(offsetof(FGzDebugCustomizationProfile, HeadName) == 0x000010, "Member 'FGzDebugCustomizationProfile::HeadName' has a wrong offset!");
static_assert(offsetof(FGzDebugCustomizationProfile, HairName) == 0x000020, "Member 'FGzDebugCustomizationProfile::HairName' has a wrong offset!");
static_assert(offsetof(FGzDebugCustomizationProfile, BeardName) == 0x000030, "Member 'FGzDebugCustomizationProfile::BeardName' has a wrong offset!");
static_assert(offsetof(FGzDebugCustomizationProfile, EyebrowsName) == 0x000040, "Member 'FGzDebugCustomizationProfile::EyebrowsName' has a wrong offset!");
static_assert(offsetof(FGzDebugCustomizationProfile, LeftEyeName) == 0x000050, "Member 'FGzDebugCustomizationProfile::LeftEyeName' has a wrong offset!");
static_assert(offsetof(FGzDebugCustomizationProfile, RightEyeName) == 0x000060, "Member 'FGzDebugCustomizationProfile::RightEyeName' has a wrong offset!");
static_assert(offsetof(FGzDebugCustomizationProfile, FaceImplantName) == 0x000070, "Member 'FGzDebugCustomizationProfile::FaceImplantName' has a wrong offset!");
static_assert(offsetof(FGzDebugCustomizationProfile, NeckImplantName) == 0x000080, "Member 'FGzDebugCustomizationProfile::NeckImplantName' has a wrong offset!");
static_assert(offsetof(FGzDebugCustomizationProfile, TorsoName) == 0x000090, "Member 'FGzDebugCustomizationProfile::TorsoName' has a wrong offset!");
static_assert(offsetof(FGzDebugCustomizationProfile, ProfileName) == 0x0000A0, "Member 'FGzDebugCustomizationProfile::ProfileName' has a wrong offset!");

// ScriptStruct G01.GzTransformNoScale
// 0x0050 (0x0050 - 0x0000)
struct FGzTransformNoScale final
{
public:
	struct FVector_NetQuantize10                  Location;                                          // 0x0000(0x0018)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2A2D[0x8];                                     // 0x0018(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FQuat                                  Quaternion;                                        // 0x0020(0x0020)(IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsLocalTransform;                                 // 0x0040(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2A2E[0xF];                                     // 0x0041(0x000F)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGzTransformNoScale) == 0x000010, "Wrong alignment on FGzTransformNoScale");
static_assert(sizeof(FGzTransformNoScale) == 0x000050, "Wrong size on FGzTransformNoScale");
static_assert(offsetof(FGzTransformNoScale, Location) == 0x000000, "Member 'FGzTransformNoScale::Location' has a wrong offset!");
static_assert(offsetof(FGzTransformNoScale, Quaternion) == 0x000020, "Member 'FGzTransformNoScale::Quaternion' has a wrong offset!");
static_assert(offsetof(FGzTransformNoScale, bIsLocalTransform) == 0x000040, "Member 'FGzTransformNoScale::bIsLocalTransform' has a wrong offset!");

// ScriptStruct G01.GzBoneTransform
// 0x0060 (0x0060 - 0x0000)
struct FGzBoneTransform final
{
public:
	class FName                                   BoneName;                                          // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2A2F[0x8];                                     // 0x0008(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGzTransformNoScale                    Transform;                                         // 0x0010(0x0050)(NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzBoneTransform) == 0x000010, "Wrong alignment on FGzBoneTransform");
static_assert(sizeof(FGzBoneTransform) == 0x000060, "Wrong size on FGzBoneTransform");
static_assert(offsetof(FGzBoneTransform, BoneName) == 0x000000, "Member 'FGzBoneTransform::BoneName' has a wrong offset!");
static_assert(offsetof(FGzBoneTransform, Transform) == 0x000010, "Member 'FGzBoneTransform::Transform' has a wrong offset!");

// ScriptStruct G01.GzNativeCharacterComponentSpec
// 0x0080 (0x0080 - 0x0000)
struct FGzNativeCharacterComponentSpec final
{
public:
	TSubclassOf<class USceneComponent>            ComponentClass;                                    // 0x0000(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2A30[0x8];                                     // 0x0008(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             RelativeTransform;                                 // 0x0010(0x0060)(Edit, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   SkeletonSocketName;                                // 0x0070(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2A31[0x8];                                     // 0x0078(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGzNativeCharacterComponentSpec) == 0x000010, "Wrong alignment on FGzNativeCharacterComponentSpec");
static_assert(sizeof(FGzNativeCharacterComponentSpec) == 0x000080, "Wrong size on FGzNativeCharacterComponentSpec");
static_assert(offsetof(FGzNativeCharacterComponentSpec, ComponentClass) == 0x000000, "Member 'FGzNativeCharacterComponentSpec::ComponentClass' has a wrong offset!");
static_assert(offsetof(FGzNativeCharacterComponentSpec, RelativeTransform) == 0x000010, "Member 'FGzNativeCharacterComponentSpec::RelativeTransform' has a wrong offset!");
static_assert(offsetof(FGzNativeCharacterComponentSpec, SkeletonSocketName) == 0x000070, "Member 'FGzNativeCharacterComponentSpec::SkeletonSocketName' has a wrong offset!");

// ScriptStruct G01.GzResultLiveFeatureMatchmakingQueue
// 0x0028 (0x0028 - 0x0000)
struct FGzResultLiveFeatureMatchmakingQueue final
{
public:
	class FString                                 Name;                                              // 0x0000(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Availability;                                      // 0x0010(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint32                                        PartySizeLimit;                                    // 0x0020(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2A32[0x4];                                     // 0x0024(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGzResultLiveFeatureMatchmakingQueue) == 0x000008, "Wrong alignment on FGzResultLiveFeatureMatchmakingQueue");
static_assert(sizeof(FGzResultLiveFeatureMatchmakingQueue) == 0x000028, "Wrong size on FGzResultLiveFeatureMatchmakingQueue");
static_assert(offsetof(FGzResultLiveFeatureMatchmakingQueue, Name) == 0x000000, "Member 'FGzResultLiveFeatureMatchmakingQueue::Name' has a wrong offset!");
static_assert(offsetof(FGzResultLiveFeatureMatchmakingQueue, Availability) == 0x000010, "Member 'FGzResultLiveFeatureMatchmakingQueue::Availability' has a wrong offset!");
static_assert(offsetof(FGzResultLiveFeatureMatchmakingQueue, PartySizeLimit) == 0x000020, "Member 'FGzResultLiveFeatureMatchmakingQueue::PartySizeLimit' has a wrong offset!");

// ScriptStruct G01.LocomotionHeldObjectVariables
// 0x0018 (0x0018 - 0x0000)
struct FLocomotionHeldObjectVariables final
{
public:
	class UStaticMeshComponent*                   HeldObjectMesh;                                    // 0x0000(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USkeletalMeshComponent*                 HeldObjectSkeleton;                                // 0x0008(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USceneComponent*                        HeldObjectRoot;                                    // 0x0010(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FLocomotionHeldObjectVariables) == 0x000008, "Wrong alignment on FLocomotionHeldObjectVariables");
static_assert(sizeof(FLocomotionHeldObjectVariables) == 0x000018, "Wrong size on FLocomotionHeldObjectVariables");
static_assert(offsetof(FLocomotionHeldObjectVariables, HeldObjectMesh) == 0x000000, "Member 'FLocomotionHeldObjectVariables::HeldObjectMesh' has a wrong offset!");
static_assert(offsetof(FLocomotionHeldObjectVariables, HeldObjectSkeleton) == 0x000008, "Member 'FLocomotionHeldObjectVariables::HeldObjectSkeleton' has a wrong offset!");
static_assert(offsetof(FLocomotionHeldObjectVariables, HeldObjectRoot) == 0x000010, "Member 'FLocomotionHeldObjectVariables::HeldObjectRoot' has a wrong offset!");

// ScriptStruct G01.GzInputConfigBindingHandle
// 0x000C (0x000C - 0x0000)
struct alignas(0x04) FGzInputConfigBindingHandle final
{
public:
	uint8                                         Pad_2A33[0xC];                                     // 0x0000(0x000C)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGzInputConfigBindingHandle) == 0x000004, "Wrong alignment on FGzInputConfigBindingHandle");
static_assert(sizeof(FGzInputConfigBindingHandle) == 0x00000C, "Wrong size on FGzInputConfigBindingHandle");

// ScriptStruct G01.GzPackageCollectClientMetricsSingleMetric
// 0x0028 (0x0028 - 0x0000)
struct FGzPackageCollectClientMetricsSingleMetric final
{
public:
	float                                         Min;                                               // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Max;                                               // 0x0004(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Avg;                                               // 0x0008(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         P1;                                                // 0x000C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         P5;                                                // 0x0010(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         P25;                                               // 0x0014(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         P50;                                               // 0x0018(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         P75;                                               // 0x001C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         P95;                                               // 0x0020(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         P99;                                               // 0x0024(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzPackageCollectClientMetricsSingleMetric) == 0x000004, "Wrong alignment on FGzPackageCollectClientMetricsSingleMetric");
static_assert(sizeof(FGzPackageCollectClientMetricsSingleMetric) == 0x000028, "Wrong size on FGzPackageCollectClientMetricsSingleMetric");
static_assert(offsetof(FGzPackageCollectClientMetricsSingleMetric, Min) == 0x000000, "Member 'FGzPackageCollectClientMetricsSingleMetric::Min' has a wrong offset!");
static_assert(offsetof(FGzPackageCollectClientMetricsSingleMetric, Max) == 0x000004, "Member 'FGzPackageCollectClientMetricsSingleMetric::Max' has a wrong offset!");
static_assert(offsetof(FGzPackageCollectClientMetricsSingleMetric, Avg) == 0x000008, "Member 'FGzPackageCollectClientMetricsSingleMetric::Avg' has a wrong offset!");
static_assert(offsetof(FGzPackageCollectClientMetricsSingleMetric, P1) == 0x00000C, "Member 'FGzPackageCollectClientMetricsSingleMetric::P1' has a wrong offset!");
static_assert(offsetof(FGzPackageCollectClientMetricsSingleMetric, P5) == 0x000010, "Member 'FGzPackageCollectClientMetricsSingleMetric::P5' has a wrong offset!");
static_assert(offsetof(FGzPackageCollectClientMetricsSingleMetric, P25) == 0x000014, "Member 'FGzPackageCollectClientMetricsSingleMetric::P25' has a wrong offset!");
static_assert(offsetof(FGzPackageCollectClientMetricsSingleMetric, P50) == 0x000018, "Member 'FGzPackageCollectClientMetricsSingleMetric::P50' has a wrong offset!");
static_assert(offsetof(FGzPackageCollectClientMetricsSingleMetric, P75) == 0x00001C, "Member 'FGzPackageCollectClientMetricsSingleMetric::P75' has a wrong offset!");
static_assert(offsetof(FGzPackageCollectClientMetricsSingleMetric, P95) == 0x000020, "Member 'FGzPackageCollectClientMetricsSingleMetric::P95' has a wrong offset!");
static_assert(offsetof(FGzPackageCollectClientMetricsSingleMetric, P99) == 0x000024, "Member 'FGzPackageCollectClientMetricsSingleMetric::P99' has a wrong offset!");

// ScriptStruct G01.GzPackageCollectClientMetrics
// 0x0050 (0x00B8 - 0x0068)
struct FGzPackageCollectClientMetrics final : public FGzPlayFabClientPackage
{
public:
	TMap<class FString, struct FGzPackageCollectClientMetricsSingleMetric> Metrics;                                           // 0x0068(0x0050)(NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzPackageCollectClientMetrics) == 0x000008, "Wrong alignment on FGzPackageCollectClientMetrics");
static_assert(sizeof(FGzPackageCollectClientMetrics) == 0x0000B8, "Wrong size on FGzPackageCollectClientMetrics");
static_assert(offsetof(FGzPackageCollectClientMetrics, Metrics) == 0x000068, "Member 'FGzPackageCollectClientMetrics::Metrics' has a wrong offset!");

// ScriptStruct G01.GzGrantedItemId
// 0x0020 (0x0020 - 0x0000)
struct FGzGrantedItemId final
{
public:
	class FString                                 AssetId;                                           // 0x0000(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 ItemInstanceId;                                    // 0x0010(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzGrantedItemId) == 0x000008, "Wrong alignment on FGzGrantedItemId");
static_assert(sizeof(FGzGrantedItemId) == 0x000020, "Wrong size on FGzGrantedItemId");
static_assert(offsetof(FGzGrantedItemId, AssetId) == 0x000000, "Member 'FGzGrantedItemId::AssetId' has a wrong offset!");
static_assert(offsetof(FGzGrantedItemId, ItemInstanceId) == 0x000010, "Member 'FGzGrantedItemId::ItemInstanceId' has a wrong offset!");

// ScriptStruct G01.GzCombinedReward
// 0x00D0 (0x00D0 - 0x0000)
struct FGzCombinedReward final
{
public:
	EGzRewardSource                               Source;                                            // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2A34[0x4];                                     // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FString>                         RewardIds;                                         // 0x0008(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	int32                                         PlayerXp;                                          // 0x0018(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         BattlePassXp;                                      // 0x001C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMap<EGzVirtualCurrencyType, int32>           VirtualCurrencies;                                 // 0x0020(0x0050)(NativeAccessSpecifierPublic)
	TMap<EGzBlockchainCoinType, double>           Coins;                                             // 0x0070(0x0050)(NativeAccessSpecifierPublic)
	TArray<struct FGzGrantedItemId>               GrantedItemIds;                                    // 0x00C0(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzCombinedReward) == 0x000008, "Wrong alignment on FGzCombinedReward");
static_assert(sizeof(FGzCombinedReward) == 0x0000D0, "Wrong size on FGzCombinedReward");
static_assert(offsetof(FGzCombinedReward, Source) == 0x000000, "Member 'FGzCombinedReward::Source' has a wrong offset!");
static_assert(offsetof(FGzCombinedReward, RewardIds) == 0x000008, "Member 'FGzCombinedReward::RewardIds' has a wrong offset!");
static_assert(offsetof(FGzCombinedReward, PlayerXp) == 0x000018, "Member 'FGzCombinedReward::PlayerXp' has a wrong offset!");
static_assert(offsetof(FGzCombinedReward, BattlePassXp) == 0x00001C, "Member 'FGzCombinedReward::BattlePassXp' has a wrong offset!");
static_assert(offsetof(FGzCombinedReward, VirtualCurrencies) == 0x000020, "Member 'FGzCombinedReward::VirtualCurrencies' has a wrong offset!");
static_assert(offsetof(FGzCombinedReward, Coins) == 0x000070, "Member 'FGzCombinedReward::Coins' has a wrong offset!");
static_assert(offsetof(FGzCombinedReward, GrantedItemIds) == 0x0000C0, "Member 'FGzCombinedReward::GrantedItemIds' has a wrong offset!");

// ScriptStruct G01.GzBodyCustomizationArchetypeKey
// 0x0001 (0x0001 - 0x0000)
struct FGzBodyCustomizationArchetypeKey final
{
public:
	EGzBodyGender                                 Gender;                                            // 0x0000(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzBodyCustomizationArchetypeKey) == 0x000001, "Wrong alignment on FGzBodyCustomizationArchetypeKey");
static_assert(sizeof(FGzBodyCustomizationArchetypeKey) == 0x000001, "Wrong size on FGzBodyCustomizationArchetypeKey");
static_assert(offsetof(FGzBodyCustomizationArchetypeKey, Gender) == 0x000000, "Member 'FGzBodyCustomizationArchetypeKey::Gender' has a wrong offset!");

// ScriptStruct G01.GzCharacterCustomizationItem
// 0x0018 (0x0018 - 0x0000)
struct FGzCharacterCustomizationItem final
{
public:
	uint8                                         Pad_2A35[0x10];                                    // 0x0000(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class UGzCustomizationItemTemplate*           CustomizationItemTemplate;                         // 0x0010(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
};
static_assert(alignof(FGzCharacterCustomizationItem) == 0x000008, "Wrong alignment on FGzCharacterCustomizationItem");
static_assert(sizeof(FGzCharacterCustomizationItem) == 0x000018, "Wrong size on FGzCharacterCustomizationItem");
static_assert(offsetof(FGzCharacterCustomizationItem, CustomizationItemTemplate) == 0x000010, "Member 'FGzCharacterCustomizationItem::CustomizationItemTemplate' has a wrong offset!");

// ScriptStruct G01.GzHeadCustomizationProfile
// 0x00C0 (0x00C0 - 0x0000)
struct FGzHeadCustomizationProfile final
{
public:
	struct FGzCharacterCustomizationItem          Head;                                              // 0x0000(0x0018)(Edit, BlueprintVisible, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FGzCharacterCustomizationItem          LeftEye;                                           // 0x0018(0x0018)(Edit, BlueprintVisible, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FGzCharacterCustomizationItem          RightEye;                                          // 0x0030(0x0018)(Edit, BlueprintVisible, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FGzCharacterCustomizationItem          Beard;                                             // 0x0048(0x0018)(Edit, BlueprintVisible, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FGzCharacterCustomizationItem          EyeBrows;                                          // 0x0060(0x0018)(Edit, BlueprintVisible, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FGzCharacterCustomizationItem          Hair;                                              // 0x0078(0x0018)(Edit, BlueprintVisible, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FGzCharacterCustomizationItem          FaceImplant;                                       // 0x0090(0x0018)(Edit, BlueprintVisible, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FGzCharacterCustomizationItem          NeckImplant;                                       // 0x00A8(0x0018)(Edit, BlueprintVisible, DisableEditOnInstance, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzHeadCustomizationProfile) == 0x000008, "Wrong alignment on FGzHeadCustomizationProfile");
static_assert(sizeof(FGzHeadCustomizationProfile) == 0x0000C0, "Wrong size on FGzHeadCustomizationProfile");
static_assert(offsetof(FGzHeadCustomizationProfile, Head) == 0x000000, "Member 'FGzHeadCustomizationProfile::Head' has a wrong offset!");
static_assert(offsetof(FGzHeadCustomizationProfile, LeftEye) == 0x000018, "Member 'FGzHeadCustomizationProfile::LeftEye' has a wrong offset!");
static_assert(offsetof(FGzHeadCustomizationProfile, RightEye) == 0x000030, "Member 'FGzHeadCustomizationProfile::RightEye' has a wrong offset!");
static_assert(offsetof(FGzHeadCustomizationProfile, Beard) == 0x000048, "Member 'FGzHeadCustomizationProfile::Beard' has a wrong offset!");
static_assert(offsetof(FGzHeadCustomizationProfile, EyeBrows) == 0x000060, "Member 'FGzHeadCustomizationProfile::EyeBrows' has a wrong offset!");
static_assert(offsetof(FGzHeadCustomizationProfile, Hair) == 0x000078, "Member 'FGzHeadCustomizationProfile::Hair' has a wrong offset!");
static_assert(offsetof(FGzHeadCustomizationProfile, FaceImplant) == 0x000090, "Member 'FGzHeadCustomizationProfile::FaceImplant' has a wrong offset!");
static_assert(offsetof(FGzHeadCustomizationProfile, NeckImplant) == 0x0000A8, "Member 'FGzHeadCustomizationProfile::NeckImplant' has a wrong offset!");

// ScriptStruct G01.GzTorsoCustomizationProfile
// 0x0018 (0x0018 - 0x0000)
struct FGzTorsoCustomizationProfile final
{
public:
	struct FGzCharacterCustomizationItem          Torso;                                             // 0x0000(0x0018)(Edit, BlueprintVisible, DisableEditOnInstance, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzTorsoCustomizationProfile) == 0x000008, "Wrong alignment on FGzTorsoCustomizationProfile");
static_assert(sizeof(FGzTorsoCustomizationProfile) == 0x000018, "Wrong size on FGzTorsoCustomizationProfile");
static_assert(offsetof(FGzTorsoCustomizationProfile, Torso) == 0x000000, "Member 'FGzTorsoCustomizationProfile::Torso' has a wrong offset!");

// ScriptStruct G01.GzBodyCustomizationProfile
// 0x0110 (0x0110 - 0x0000)
struct FGzBodyCustomizationProfile final
{
public:
	struct FGzBodyCustomizationArchetypeKey       BodyArchetypeKey;                                  // 0x0000(0x0001)(Edit, BlueprintVisible, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2A36[0x7];                                     // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UGzBodyCustomizationArchetype*          OverrideBodyArchetype;                             // 0x0008(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGzHeadCustomizationProfile            HeadCustomization;                                 // 0x0010(0x00C0)(Edit, BlueprintVisible, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FGzTorsoCustomizationProfile           TorsoCustomization;                                // 0x00D0(0x0018)(Edit, BlueprintVisible, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FGzCharacterCustomizationItem          SkinCustomization;                                 // 0x00E8(0x0018)(Edit, BlueprintVisible, DisableEditOnInstance, NativeAccessSpecifierPublic)
	uint8                                         Pad_2A37[0x10];                                    // 0x0100(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGzBodyCustomizationProfile) == 0x000008, "Wrong alignment on FGzBodyCustomizationProfile");
static_assert(sizeof(FGzBodyCustomizationProfile) == 0x000110, "Wrong size on FGzBodyCustomizationProfile");
static_assert(offsetof(FGzBodyCustomizationProfile, BodyArchetypeKey) == 0x000000, "Member 'FGzBodyCustomizationProfile::BodyArchetypeKey' has a wrong offset!");
static_assert(offsetof(FGzBodyCustomizationProfile, OverrideBodyArchetype) == 0x000008, "Member 'FGzBodyCustomizationProfile::OverrideBodyArchetype' has a wrong offset!");
static_assert(offsetof(FGzBodyCustomizationProfile, HeadCustomization) == 0x000010, "Member 'FGzBodyCustomizationProfile::HeadCustomization' has a wrong offset!");
static_assert(offsetof(FGzBodyCustomizationProfile, TorsoCustomization) == 0x0000D0, "Member 'FGzBodyCustomizationProfile::TorsoCustomization' has a wrong offset!");
static_assert(offsetof(FGzBodyCustomizationProfile, SkinCustomization) == 0x0000E8, "Member 'FGzBodyCustomizationProfile::SkinCustomization' has a wrong offset!");

// ScriptStruct G01.GzVoiceCustomizationData
// 0x0018 (0x0018 - 0x0000)
struct FGzVoiceCustomizationData final
{
public:
	struct FGzCharacterCustomizationItem          CharacterVoice;                                    // 0x0000(0x0018)(Edit, BlueprintVisible, DisableEditOnInstance, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzVoiceCustomizationData) == 0x000008, "Wrong alignment on FGzVoiceCustomizationData");
static_assert(sizeof(FGzVoiceCustomizationData) == 0x000018, "Wrong size on FGzVoiceCustomizationData");
static_assert(offsetof(FGzVoiceCustomizationData, CharacterVoice) == 0x000000, "Member 'FGzVoiceCustomizationData::CharacterVoice' has a wrong offset!");

// ScriptStruct G01.GzEmoteCustomizationData
// 0x0028 (0x0028 - 0x0000)
struct FGzEmoteCustomizationData final
{
public:
	struct FGzCharacterCustomizationItem          CharacterEmote;                                    // 0x0000(0x0018)(Edit, BlueprintVisible, DisableEditOnInstance, NativeAccessSpecifierPublic)
	int32                                         SlotIndex;                                         // 0x0018(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2A38[0x4];                                     // 0x001C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UAnimMontage*                           EmoteMontageLoaded;                                // 0x0020(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzEmoteCustomizationData) == 0x000008, "Wrong alignment on FGzEmoteCustomizationData");
static_assert(sizeof(FGzEmoteCustomizationData) == 0x000028, "Wrong size on FGzEmoteCustomizationData");
static_assert(offsetof(FGzEmoteCustomizationData, CharacterEmote) == 0x000000, "Member 'FGzEmoteCustomizationData::CharacterEmote' has a wrong offset!");
static_assert(offsetof(FGzEmoteCustomizationData, SlotIndex) == 0x000018, "Member 'FGzEmoteCustomizationData::SlotIndex' has a wrong offset!");
static_assert(offsetof(FGzEmoteCustomizationData, EmoteMontageLoaded) == 0x000020, "Member 'FGzEmoteCustomizationData::EmoteMontageLoaded' has a wrong offset!");

// ScriptStruct G01.GzCharacterCustomizationProfile
// 0x0150 (0x0150 - 0x0000)
struct FGzCharacterCustomizationProfile final
{
public:
	struct FGzBodyCustomizationProfile            BodyCustomization;                                 // 0x0000(0x0110)(Edit, NativeAccessSpecifierPublic)
	TArray<struct FGzCharacterCustomizationItem>  CustomizationItems;                                // 0x0110(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	struct FGzVoiceCustomizationData              VoiceCustomization;                                // 0x0120(0x0018)(Edit, NativeAccessSpecifierPublic)
	TArray<struct FGzEmoteCustomizationData>      CustomizationEmotes;                               // 0x0138(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          bIsPredefined;                                     // 0x0148(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2A39[0x7];                                     // 0x0149(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGzCharacterCustomizationProfile) == 0x000008, "Wrong alignment on FGzCharacterCustomizationProfile");
static_assert(sizeof(FGzCharacterCustomizationProfile) == 0x000150, "Wrong size on FGzCharacterCustomizationProfile");
static_assert(offsetof(FGzCharacterCustomizationProfile, BodyCustomization) == 0x000000, "Member 'FGzCharacterCustomizationProfile::BodyCustomization' has a wrong offset!");
static_assert(offsetof(FGzCharacterCustomizationProfile, CustomizationItems) == 0x000110, "Member 'FGzCharacterCustomizationProfile::CustomizationItems' has a wrong offset!");
static_assert(offsetof(FGzCharacterCustomizationProfile, VoiceCustomization) == 0x000120, "Member 'FGzCharacterCustomizationProfile::VoiceCustomization' has a wrong offset!");
static_assert(offsetof(FGzCharacterCustomizationProfile, CustomizationEmotes) == 0x000138, "Member 'FGzCharacterCustomizationProfile::CustomizationEmotes' has a wrong offset!");
static_assert(offsetof(FGzCharacterCustomizationProfile, bIsPredefined) == 0x000148, "Member 'FGzCharacterCustomizationProfile::bIsPredefined' has a wrong offset!");

// ScriptStruct G01.GzCohtmlDebuggingUtils
// 0x0001 (0x0001 - 0x0000)
struct FGzCohtmlDebuggingUtils final
{
public:
	uint8                                         Pad_2A3A[0x1];                                     // 0x0000(0x0001)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGzCohtmlDebuggingUtils) == 0x000001, "Wrong alignment on FGzCohtmlDebuggingUtils");
static_assert(sizeof(FGzCohtmlDebuggingUtils) == 0x000001, "Wrong size on FGzCohtmlDebuggingUtils");

// ScriptStruct G01.GzInvPocketDef
// 0x0060 (0x0060 - 0x0000)
struct FGzInvPocketDef final
{
public:
	EGzInvPocketType                              PocketType;                                        // 0x0000(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2A3B[0x3];                                     // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTag                           Slot;                                              // 0x0004(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2A3C[0x4];                                     // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTagContainer                  AllowedItemTypes;                                  // 0x0010(0x0020)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FGameplayTagContainer                  BlockedItemTypes;                                  // 0x0030(0x0020)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	bool                                          bAutoSwap;                                         // 0x0050(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2A3D[0x3];                                     // 0x0051(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         Priority;                                          // 0x0054(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGzInvPocketId                         PocketId;                                          // 0x0058(0x0008)(BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzInvPocketDef) == 0x000008, "Wrong alignment on FGzInvPocketDef");
static_assert(sizeof(FGzInvPocketDef) == 0x000060, "Wrong size on FGzInvPocketDef");
static_assert(offsetof(FGzInvPocketDef, PocketType) == 0x000000, "Member 'FGzInvPocketDef::PocketType' has a wrong offset!");
static_assert(offsetof(FGzInvPocketDef, Slot) == 0x000004, "Member 'FGzInvPocketDef::Slot' has a wrong offset!");
static_assert(offsetof(FGzInvPocketDef, AllowedItemTypes) == 0x000010, "Member 'FGzInvPocketDef::AllowedItemTypes' has a wrong offset!");
static_assert(offsetof(FGzInvPocketDef, BlockedItemTypes) == 0x000030, "Member 'FGzInvPocketDef::BlockedItemTypes' has a wrong offset!");
static_assert(offsetof(FGzInvPocketDef, bAutoSwap) == 0x000050, "Member 'FGzInvPocketDef::bAutoSwap' has a wrong offset!");
static_assert(offsetof(FGzInvPocketDef, Priority) == 0x000054, "Member 'FGzInvPocketDef::Priority' has a wrong offset!");
static_assert(offsetof(FGzInvPocketDef, PocketId) == 0x000058, "Member 'FGzInvPocketDef::PocketId' has a wrong offset!");

// ScriptStruct G01.GzInvPocketChangeData
// 0x0080 (0x0080 - 0x0000)
struct FGzInvPocketChangeData final
{
public:
	struct FGzInvPocketDef                        PocketDef;                                         // 0x0000(0x0060)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FGzInvItem                             PrevItem;                                          // 0x0060(0x0010)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FGzInvItem                             NewItem;                                           // 0x0070(0x0010)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzInvPocketChangeData) == 0x000008, "Wrong alignment on FGzInvPocketChangeData");
static_assert(sizeof(FGzInvPocketChangeData) == 0x000080, "Wrong size on FGzInvPocketChangeData");
static_assert(offsetof(FGzInvPocketChangeData, PocketDef) == 0x000000, "Member 'FGzInvPocketChangeData::PocketDef' has a wrong offset!");
static_assert(offsetof(FGzInvPocketChangeData, PrevItem) == 0x000060, "Member 'FGzInvPocketChangeData::PrevItem' has a wrong offset!");
static_assert(offsetof(FGzInvPocketChangeData, NewItem) == 0x000070, "Member 'FGzInvPocketChangeData::NewItem' has a wrong offset!");

// ScriptStruct G01.GzCohtmlSlotItem
// 0x0020 (0x0020 - 0x0000)
struct FGzCohtmlSlotItem final
{
public:
	class FString                                 ItemId;                                            // 0x0000(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 AssetId;                                           // 0x0010(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzCohtmlSlotItem) == 0x000008, "Wrong alignment on FGzCohtmlSlotItem");
static_assert(sizeof(FGzCohtmlSlotItem) == 0x000020, "Wrong size on FGzCohtmlSlotItem");
static_assert(offsetof(FGzCohtmlSlotItem, ItemId) == 0x000000, "Member 'FGzCohtmlSlotItem::ItemId' has a wrong offset!");
static_assert(offsetof(FGzCohtmlSlotItem, AssetId) == 0x000010, "Member 'FGzCohtmlSlotItem::AssetId' has a wrong offset!");

// ScriptStruct G01.GzCohtmlLoadoutItemSlot
// 0x0030 (0x0030 - 0x0000)
struct FGzCohtmlLoadoutItemSlot final
{
public:
	EGzLoadoutSlots                               SlotType;                                          // 0x0000(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2A3E[0x3];                                     // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         SlotCost;                                          // 0x0004(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Quantity;                                          // 0x0008(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2A3F[0x4];                                     // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGzCohtmlSlotItem                      Item;                                              // 0x0010(0x0020)(NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzCohtmlLoadoutItemSlot) == 0x000008, "Wrong alignment on FGzCohtmlLoadoutItemSlot");
static_assert(sizeof(FGzCohtmlLoadoutItemSlot) == 0x000030, "Wrong size on FGzCohtmlLoadoutItemSlot");
static_assert(offsetof(FGzCohtmlLoadoutItemSlot, SlotType) == 0x000000, "Member 'FGzCohtmlLoadoutItemSlot::SlotType' has a wrong offset!");
static_assert(offsetof(FGzCohtmlLoadoutItemSlot, SlotCost) == 0x000004, "Member 'FGzCohtmlLoadoutItemSlot::SlotCost' has a wrong offset!");
static_assert(offsetof(FGzCohtmlLoadoutItemSlot, Quantity) == 0x000008, "Member 'FGzCohtmlLoadoutItemSlot::Quantity' has a wrong offset!");
static_assert(offsetof(FGzCohtmlLoadoutItemSlot, Item) == 0x000010, "Member 'FGzCohtmlLoadoutItemSlot::Item' has a wrong offset!");

// ScriptStruct G01.GzCohtmlLoadoutInfo
// 0x0078 (0x0078 - 0x0000)
struct FGzCohtmlLoadoutInfo final
{
public:
	class FString                                 LoadoutName;                                       // 0x0000(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Guid;                                              // 0x0010(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMap<class FString, struct FGzCohtmlLoadoutItemSlot> Slots;                                             // 0x0020(0x0050)(NativeAccessSpecifierPublic)
	int32                                         LoadoutCost;                                       // 0x0070(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2A40[0x4];                                     // 0x0074(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGzCohtmlLoadoutInfo) == 0x000008, "Wrong alignment on FGzCohtmlLoadoutInfo");
static_assert(sizeof(FGzCohtmlLoadoutInfo) == 0x000078, "Wrong size on FGzCohtmlLoadoutInfo");
static_assert(offsetof(FGzCohtmlLoadoutInfo, LoadoutName) == 0x000000, "Member 'FGzCohtmlLoadoutInfo::LoadoutName' has a wrong offset!");
static_assert(offsetof(FGzCohtmlLoadoutInfo, Guid) == 0x000010, "Member 'FGzCohtmlLoadoutInfo::Guid' has a wrong offset!");
static_assert(offsetof(FGzCohtmlLoadoutInfo, Slots) == 0x000020, "Member 'FGzCohtmlLoadoutInfo::Slots' has a wrong offset!");
static_assert(offsetof(FGzCohtmlLoadoutInfo, LoadoutCost) == 0x000070, "Member 'FGzCohtmlLoadoutInfo::LoadoutCost' has a wrong offset!");

// ScriptStruct G01.GzCohtmlLoadoutCollection
// 0x0050 (0x0050 - 0x0000)
struct FGzCohtmlLoadoutCollection final
{
public:
	TMap<class FString, struct FGzCohtmlLoadoutInfo> Loadouts;                                          // 0x0000(0x0050)(NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzCohtmlLoadoutCollection) == 0x000008, "Wrong alignment on FGzCohtmlLoadoutCollection");
static_assert(sizeof(FGzCohtmlLoadoutCollection) == 0x000050, "Wrong size on FGzCohtmlLoadoutCollection");
static_assert(offsetof(FGzCohtmlLoadoutCollection, Loadouts) == 0x000000, "Member 'FGzCohtmlLoadoutCollection::Loadouts' has a wrong offset!");

// ScriptStruct G01.GzMetaBan
// 0x0028 (0x0028 - 0x0000)
struct FGzMetaBan final
{
public:
	EGzBanType                                    Type;                                              // 0x0000(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2A41[0x7];                                     // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 Reason;                                            // 0x0008(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FDateTime                              Created;                                           // 0x0018(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FDateTime                              ExpiresAt;                                         // 0x0020(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzMetaBan) == 0x000008, "Wrong alignment on FGzMetaBan");
static_assert(sizeof(FGzMetaBan) == 0x000028, "Wrong size on FGzMetaBan");
static_assert(offsetof(FGzMetaBan, Type) == 0x000000, "Member 'FGzMetaBan::Type' has a wrong offset!");
static_assert(offsetof(FGzMetaBan, Reason) == 0x000008, "Member 'FGzMetaBan::Reason' has a wrong offset!");
static_assert(offsetof(FGzMetaBan, Created) == 0x000018, "Member 'FGzMetaBan::Created' has a wrong offset!");
static_assert(offsetof(FGzMetaBan, ExpiresAt) == 0x000020, "Member 'FGzMetaBan::ExpiresAt' has a wrong offset!");

// ScriptStruct G01.GzSceneTransitionParameters
// 0x000C (0x000C - 0x0000)
struct FGzSceneTransitionParameters final
{
public:
	float                                         TransitionDuration;                                // 0x0000(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EViewTargetBlendFunction                      BlendFunction;                                     // 0x0004(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2A42[0x3];                                     // 0x0005(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         BlendExponent;                                     // 0x0008(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzSceneTransitionParameters) == 0x000004, "Wrong alignment on FGzSceneTransitionParameters");
static_assert(sizeof(FGzSceneTransitionParameters) == 0x00000C, "Wrong size on FGzSceneTransitionParameters");
static_assert(offsetof(FGzSceneTransitionParameters, TransitionDuration) == 0x000000, "Member 'FGzSceneTransitionParameters::TransitionDuration' has a wrong offset!");
static_assert(offsetof(FGzSceneTransitionParameters, BlendFunction) == 0x000004, "Member 'FGzSceneTransitionParameters::BlendFunction' has a wrong offset!");
static_assert(offsetof(FGzSceneTransitionParameters, BlendExponent) == 0x000008, "Member 'FGzSceneTransitionParameters::BlendExponent' has a wrong offset!");

// ScriptStruct G01.AudioData
// 0x000C (0x000C - 0x0000)
struct FAudioData final
{
public:
	float                                         MaxDurationTime;                                   // 0x0000(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           AudioEventTag;                                     // 0x0004(0x0008)(Edit, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAudioData) == 0x000004, "Wrong alignment on FAudioData");
static_assert(sizeof(FAudioData) == 0x00000C, "Wrong size on FAudioData");
static_assert(offsetof(FAudioData, MaxDurationTime) == 0x000000, "Member 'FAudioData::MaxDurationTime' has a wrong offset!");
static_assert(offsetof(FAudioData, AudioEventTag) == 0x000004, "Member 'FAudioData::AudioEventTag' has a wrong offset!");

// ScriptStruct G01.GzNavLinksGenerationConfig
// 0x0010 (0x0010 - 0x0000)
struct FGzNavLinksGenerationConfig final
{
public:
	struct FActorDataLayer                        NavLinksDataLayer;                                 // 0x0000(0x0008)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ALevelInstance*                         NavLinksLevelInstance;                             // 0x0008(0x0008)(Edit, ZeroConstructor, DisableEditOnTemplate, EditConst, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzNavLinksGenerationConfig) == 0x000008, "Wrong alignment on FGzNavLinksGenerationConfig");
static_assert(sizeof(FGzNavLinksGenerationConfig) == 0x000010, "Wrong size on FGzNavLinksGenerationConfig");
static_assert(offsetof(FGzNavLinksGenerationConfig, NavLinksDataLayer) == 0x000000, "Member 'FGzNavLinksGenerationConfig::NavLinksDataLayer' has a wrong offset!");
static_assert(offsetof(FGzNavLinksGenerationConfig, NavLinksLevelInstance) == 0x000008, "Member 'FGzNavLinksGenerationConfig::NavLinksLevelInstance' has a wrong offset!");

// ScriptStruct G01.GzPackageGetMarketTradesPaging
// 0x0008 (0x0008 - 0x0000)
struct FGzPackageGetMarketTradesPaging final
{
public:
	int32                                         Offset;                                            // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Limit;                                             // 0x0004(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzPackageGetMarketTradesPaging) == 0x000004, "Wrong alignment on FGzPackageGetMarketTradesPaging");
static_assert(sizeof(FGzPackageGetMarketTradesPaging) == 0x000008, "Wrong size on FGzPackageGetMarketTradesPaging");
static_assert(offsetof(FGzPackageGetMarketTradesPaging, Offset) == 0x000000, "Member 'FGzPackageGetMarketTradesPaging::Offset' has a wrong offset!");
static_assert(offsetof(FGzPackageGetMarketTradesPaging, Limit) == 0x000004, "Member 'FGzPackageGetMarketTradesPaging::Limit' has a wrong offset!");

// ScriptStruct G01.GzPackageGetTradeHistory
// 0x0008 (0x0070 - 0x0068)
struct FGzPackageGetTradeHistory final : public FGzPlayFabClientPackage
{
public:
	struct FGzPackageGetMarketTradesPaging        PagingParameters;                                  // 0x0068(0x0008)(NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzPackageGetTradeHistory) == 0x000008, "Wrong alignment on FGzPackageGetTradeHistory");
static_assert(sizeof(FGzPackageGetTradeHistory) == 0x000070, "Wrong size on FGzPackageGetTradeHistory");
static_assert(offsetof(FGzPackageGetTradeHistory, PagingParameters) == 0x000068, "Member 'FGzPackageGetTradeHistory::PagingParameters' has a wrong offset!");

// ScriptStruct G01.GzPlayFabPlayerIdContainer
// 0x0020 (0x0020 - 0x0000)
struct FGzPlayFabPlayerIdContainer final
{
public:
	class FString                                 PlayFabId;                                         // 0x0000(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 TitlePlayerId;                                     // 0x0010(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzPlayFabPlayerIdContainer) == 0x000008, "Wrong alignment on FGzPlayFabPlayerIdContainer");
static_assert(sizeof(FGzPlayFabPlayerIdContainer) == 0x000020, "Wrong size on FGzPlayFabPlayerIdContainer");
static_assert(offsetof(FGzPlayFabPlayerIdContainer, PlayFabId) == 0x000000, "Member 'FGzPlayFabPlayerIdContainer::PlayFabId' has a wrong offset!");
static_assert(offsetof(FGzPlayFabPlayerIdContainer, TitlePlayerId) == 0x000010, "Member 'FGzPlayFabPlayerIdContainer::TitlePlayerId' has a wrong offset!");

// ScriptStruct G01.GzResultMarketTrade
// 0x00A0 (0x00A0 - 0x0000)
struct FGzResultMarketTrade final
{
public:
	struct FGzPlayFabPlayerIdContainer            SellerPlayerId;                                    // 0x0000(0x0020)(NativeAccessSpecifierPublic)
	struct FGzPlayFabPlayerIdContainer            BuyerPlayerId;                                     // 0x0020(0x0020)(NativeAccessSpecifierPublic)
	class FString                                 NftId;                                             // 0x0040(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 AssetId;                                           // 0x0050(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 TradeTime;                                         // 0x0060(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Price;                                             // 0x0070(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 State;                                             // 0x0080(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 SellerFeeAmount;                                   // 0x0090(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzResultMarketTrade) == 0x000008, "Wrong alignment on FGzResultMarketTrade");
static_assert(sizeof(FGzResultMarketTrade) == 0x0000A0, "Wrong size on FGzResultMarketTrade");
static_assert(offsetof(FGzResultMarketTrade, SellerPlayerId) == 0x000000, "Member 'FGzResultMarketTrade::SellerPlayerId' has a wrong offset!");
static_assert(offsetof(FGzResultMarketTrade, BuyerPlayerId) == 0x000020, "Member 'FGzResultMarketTrade::BuyerPlayerId' has a wrong offset!");
static_assert(offsetof(FGzResultMarketTrade, NftId) == 0x000040, "Member 'FGzResultMarketTrade::NftId' has a wrong offset!");
static_assert(offsetof(FGzResultMarketTrade, AssetId) == 0x000050, "Member 'FGzResultMarketTrade::AssetId' has a wrong offset!");
static_assert(offsetof(FGzResultMarketTrade, TradeTime) == 0x000060, "Member 'FGzResultMarketTrade::TradeTime' has a wrong offset!");
static_assert(offsetof(FGzResultMarketTrade, Price) == 0x000070, "Member 'FGzResultMarketTrade::Price' has a wrong offset!");
static_assert(offsetof(FGzResultMarketTrade, State) == 0x000080, "Member 'FGzResultMarketTrade::State' has a wrong offset!");
static_assert(offsetof(FGzResultMarketTrade, SellerFeeAmount) == 0x000090, "Member 'FGzResultMarketTrade::SellerFeeAmount' has a wrong offset!");

// ScriptStruct G01.GzSceneChangedEventData
// 0x0010 (0x0010 - 0x0000)
struct FGzSceneChangedEventData final
{
public:
	struct FGameplayTag                           SequenceTag;                                       // 0x0000(0x0008)(BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           CharacterPoseTag;                                  // 0x0008(0x0008)(BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzSceneChangedEventData) == 0x000004, "Wrong alignment on FGzSceneChangedEventData");
static_assert(sizeof(FGzSceneChangedEventData) == 0x000010, "Wrong size on FGzSceneChangedEventData");
static_assert(offsetof(FGzSceneChangedEventData, SequenceTag) == 0x000000, "Member 'FGzSceneChangedEventData::SequenceTag' has a wrong offset!");
static_assert(offsetof(FGzSceneChangedEventData, CharacterPoseTag) == 0x000008, "Member 'FGzSceneChangedEventData::CharacterPoseTag' has a wrong offset!");

// ScriptStruct G01.MetaXsollaPrice
// 0x0030 (0x0030 - 0x0000)
struct FMetaXsollaPrice final
{
public:
	class FString                                 Amount;                                            // 0x0000(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 AmountWithoutDiscount;                             // 0x0010(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Currency;                                          // 0x0020(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMetaXsollaPrice) == 0x000008, "Wrong alignment on FMetaXsollaPrice");
static_assert(sizeof(FMetaXsollaPrice) == 0x000030, "Wrong size on FMetaXsollaPrice");
static_assert(offsetof(FMetaXsollaPrice, Amount) == 0x000000, "Member 'FMetaXsollaPrice::Amount' has a wrong offset!");
static_assert(offsetof(FMetaXsollaPrice, AmountWithoutDiscount) == 0x000010, "Member 'FMetaXsollaPrice::AmountWithoutDiscount' has a wrong offset!");
static_assert(offsetof(FMetaXsollaPrice, Currency) == 0x000020, "Member 'FMetaXsollaPrice::Currency' has a wrong offset!");

// ScriptStruct G01.MetaVirtualCurrencyPackageContent
// 0x0058 (0x0058 - 0x0000)
struct FMetaVirtualCurrencyPackageContent final
{
public:
	class FString                                 Sku;                                               // 0x0000(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Name;                                              // 0x0010(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Type;                                              // 0x0020(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Description;                                       // 0x0030(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 ImageUrl;                                          // 0x0040(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Quantity;                                          // 0x0050(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2A43[0x4];                                     // 0x0054(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FMetaVirtualCurrencyPackageContent) == 0x000008, "Wrong alignment on FMetaVirtualCurrencyPackageContent");
static_assert(sizeof(FMetaVirtualCurrencyPackageContent) == 0x000058, "Wrong size on FMetaVirtualCurrencyPackageContent");
static_assert(offsetof(FMetaVirtualCurrencyPackageContent, Sku) == 0x000000, "Member 'FMetaVirtualCurrencyPackageContent::Sku' has a wrong offset!");
static_assert(offsetof(FMetaVirtualCurrencyPackageContent, Name) == 0x000010, "Member 'FMetaVirtualCurrencyPackageContent::Name' has a wrong offset!");
static_assert(offsetof(FMetaVirtualCurrencyPackageContent, Type) == 0x000020, "Member 'FMetaVirtualCurrencyPackageContent::Type' has a wrong offset!");
static_assert(offsetof(FMetaVirtualCurrencyPackageContent, Description) == 0x000030, "Member 'FMetaVirtualCurrencyPackageContent::Description' has a wrong offset!");
static_assert(offsetof(FMetaVirtualCurrencyPackageContent, ImageUrl) == 0x000040, "Member 'FMetaVirtualCurrencyPackageContent::ImageUrl' has a wrong offset!");
static_assert(offsetof(FMetaVirtualCurrencyPackageContent, Quantity) == 0x000050, "Member 'FMetaVirtualCurrencyPackageContent::Quantity' has a wrong offset!");

// ScriptStruct G01.MetaVirtualCurrencyPackage
// 0x0108 (0x0108 - 0x0000)
struct FMetaVirtualCurrencyPackage final
{
public:
	class FString                                 Sku;                                               // 0x0000(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Name;                                              // 0x0010(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Type;                                              // 0x0020(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Description;                                       // 0x0030(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 ImageUrl;                                          // 0x0040(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 BundleType;                                        // 0x0050(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsFree;                                           // 0x0060(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2A44[0x7];                                     // 0x0061(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FMetaXsollaPrice                       Price;                                             // 0x0068(0x0030)(NativeAccessSpecifierPublic)
	struct FMetaVirtualCurrencyPackageContent     Content;                                           // 0x0098(0x0058)(NativeAccessSpecifierPublic)
	class FString                                 LongDescription;                                   // 0x00F0(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Order;                                             // 0x0100(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2A45[0x4];                                     // 0x0104(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FMetaVirtualCurrencyPackage) == 0x000008, "Wrong alignment on FMetaVirtualCurrencyPackage");
static_assert(sizeof(FMetaVirtualCurrencyPackage) == 0x000108, "Wrong size on FMetaVirtualCurrencyPackage");
static_assert(offsetof(FMetaVirtualCurrencyPackage, Sku) == 0x000000, "Member 'FMetaVirtualCurrencyPackage::Sku' has a wrong offset!");
static_assert(offsetof(FMetaVirtualCurrencyPackage, Name) == 0x000010, "Member 'FMetaVirtualCurrencyPackage::Name' has a wrong offset!");
static_assert(offsetof(FMetaVirtualCurrencyPackage, Type) == 0x000020, "Member 'FMetaVirtualCurrencyPackage::Type' has a wrong offset!");
static_assert(offsetof(FMetaVirtualCurrencyPackage, Description) == 0x000030, "Member 'FMetaVirtualCurrencyPackage::Description' has a wrong offset!");
static_assert(offsetof(FMetaVirtualCurrencyPackage, ImageUrl) == 0x000040, "Member 'FMetaVirtualCurrencyPackage::ImageUrl' has a wrong offset!");
static_assert(offsetof(FMetaVirtualCurrencyPackage, BundleType) == 0x000050, "Member 'FMetaVirtualCurrencyPackage::BundleType' has a wrong offset!");
static_assert(offsetof(FMetaVirtualCurrencyPackage, bIsFree) == 0x000060, "Member 'FMetaVirtualCurrencyPackage::bIsFree' has a wrong offset!");
static_assert(offsetof(FMetaVirtualCurrencyPackage, Price) == 0x000068, "Member 'FMetaVirtualCurrencyPackage::Price' has a wrong offset!");
static_assert(offsetof(FMetaVirtualCurrencyPackage, Content) == 0x000098, "Member 'FMetaVirtualCurrencyPackage::Content' has a wrong offset!");
static_assert(offsetof(FMetaVirtualCurrencyPackage, LongDescription) == 0x0000F0, "Member 'FMetaVirtualCurrencyPackage::LongDescription' has a wrong offset!");
static_assert(offsetof(FMetaVirtualCurrencyPackage, Order) == 0x000100, "Member 'FMetaVirtualCurrencyPackage::Order' has a wrong offset!");

// ScriptStruct G01.MetaVirtualCurrencyPackagesData
// 0x0010 (0x0010 - 0x0000)
struct FMetaVirtualCurrencyPackagesData final
{
public:
	TArray<struct FMetaVirtualCurrencyPackage>    Items;                                             // 0x0000(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMetaVirtualCurrencyPackagesData) == 0x000008, "Wrong alignment on FMetaVirtualCurrencyPackagesData");
static_assert(sizeof(FMetaVirtualCurrencyPackagesData) == 0x000010, "Wrong size on FMetaVirtualCurrencyPackagesData");
static_assert(offsetof(FMetaVirtualCurrencyPackagesData, Items) == 0x000000, "Member 'FMetaVirtualCurrencyPackagesData::Items' has a wrong offset!");

// ScriptStruct G01.GzWorldVisibilityData
// 0x0070 (0x0070 - 0x0000)
struct FGzWorldVisibilityData final
{
public:
	EDepthStencilValue                            StencilValue;                                      // 0x0000(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bOverrideMarker;                                   // 0x0001(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2A46[0x6];                                     // 0x0002(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftClassPtr<class UClass>                   MarkerCompClass;                                   // 0x0008(0x0028)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                MarkerOffset;                                      // 0x0030(0x0018)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UGzCharacterNameComponent>  NameComponentClass;                                // 0x0048(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                NameOffset;                                        // 0x0050(0x0018)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         StatePriority;                                     // 0x0068(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2A47[0x4];                                     // 0x006C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGzWorldVisibilityData) == 0x000008, "Wrong alignment on FGzWorldVisibilityData");
static_assert(sizeof(FGzWorldVisibilityData) == 0x000070, "Wrong size on FGzWorldVisibilityData");
static_assert(offsetof(FGzWorldVisibilityData, StencilValue) == 0x000000, "Member 'FGzWorldVisibilityData::StencilValue' has a wrong offset!");
static_assert(offsetof(FGzWorldVisibilityData, bOverrideMarker) == 0x000001, "Member 'FGzWorldVisibilityData::bOverrideMarker' has a wrong offset!");
static_assert(offsetof(FGzWorldVisibilityData, MarkerCompClass) == 0x000008, "Member 'FGzWorldVisibilityData::MarkerCompClass' has a wrong offset!");
static_assert(offsetof(FGzWorldVisibilityData, MarkerOffset) == 0x000030, "Member 'FGzWorldVisibilityData::MarkerOffset' has a wrong offset!");
static_assert(offsetof(FGzWorldVisibilityData, NameComponentClass) == 0x000048, "Member 'FGzWorldVisibilityData::NameComponentClass' has a wrong offset!");
static_assert(offsetof(FGzWorldVisibilityData, NameOffset) == 0x000050, "Member 'FGzWorldVisibilityData::NameOffset' has a wrong offset!");
static_assert(offsetof(FGzWorldVisibilityData, StatePriority) == 0x000068, "Member 'FGzWorldVisibilityData::StatePriority' has a wrong offset!");

// ScriptStruct G01.GzMetaCharacterAvatarLoadoutWeapon
// 0x0020 (0x0020 - 0x0000)
struct FGzMetaCharacterAvatarLoadoutWeapon final
{
public:
	class UGzWeaponItemData*                      Weapon;                                            // 0x0000(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UGzWeaponSkinItemData*                  Skin;                                              // 0x0008(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class UGzWeaponAttachmentItemData*>    Attachments;                                       // 0x0010(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, UObjectWrapper, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzMetaCharacterAvatarLoadoutWeapon) == 0x000008, "Wrong alignment on FGzMetaCharacterAvatarLoadoutWeapon");
static_assert(sizeof(FGzMetaCharacterAvatarLoadoutWeapon) == 0x000020, "Wrong size on FGzMetaCharacterAvatarLoadoutWeapon");
static_assert(offsetof(FGzMetaCharacterAvatarLoadoutWeapon, Weapon) == 0x000000, "Member 'FGzMetaCharacterAvatarLoadoutWeapon::Weapon' has a wrong offset!");
static_assert(offsetof(FGzMetaCharacterAvatarLoadoutWeapon, Skin) == 0x000008, "Member 'FGzMetaCharacterAvatarLoadoutWeapon::Skin' has a wrong offset!");
static_assert(offsetof(FGzMetaCharacterAvatarLoadoutWeapon, Attachments) == 0x000010, "Member 'FGzMetaCharacterAvatarLoadoutWeapon::Attachments' has a wrong offset!");

// ScriptStruct G01.GzBlockPlayerResult
// 0x0000 (0x00E0 - 0x00E0)
struct FGzBlockPlayerResult final : public FGzPlayFabResultBase
{
};
static_assert(alignof(FGzBlockPlayerResult) == 0x000008, "Wrong alignment on FGzBlockPlayerResult");
static_assert(sizeof(FGzBlockPlayerResult) == 0x0000E0, "Wrong size on FGzBlockPlayerResult");

// ScriptStruct G01.GzInvPocket
// 0x001C (0x0028 - 0x000C)
struct FGzInvPocket final : public FFastArraySerializerItem
{
public:
	struct FGzInvPocketId                         PocketId;                                          // 0x000C(0x0008)(BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Priority;                                          // 0x0014(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGzInvItem                             Item;                                              // 0x0018(0x0010)(BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)
};
static_assert(alignof(FGzInvPocket) == 0x000008, "Wrong alignment on FGzInvPocket");
static_assert(sizeof(FGzInvPocket) == 0x000028, "Wrong size on FGzInvPocket");
static_assert(offsetof(FGzInvPocket, PocketId) == 0x00000C, "Member 'FGzInvPocket::PocketId' has a wrong offset!");
static_assert(offsetof(FGzInvPocket, Priority) == 0x000014, "Member 'FGzInvPocket::Priority' has a wrong offset!");
static_assert(offsetof(FGzInvPocket, Item) == 0x000018, "Member 'FGzInvPocket::Item' has a wrong offset!");

// ScriptStruct G01.GzPackageServerDetails
// 0x0098 (0x0100 - 0x0068)
struct FGzPackageServerDetails final : public FGzPlayFabClientPackage
{
public:
	class FString                                 IpAndPort;                                         // 0x0068(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Name;                                              // 0x0078(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 GameRegisterArgs;                                  // 0x0088(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Platform;                                          // 0x0098(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 BranchName;                                        // 0x00A8(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint32                                        CL;                                                // 0x00B8(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2A48[0x4];                                     // 0x00BC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 Map;                                               // 0x00C0(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 GameMode;                                          // 0x00D0(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 MatchState;                                        // 0x00E0(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint32                                        PlayerCount;                                       // 0x00F0(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint32                                        MaxPlayerCount;                                    // 0x00F4(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          CanAcceptNewPlayers;                               // 0x00F8(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2A49[0x7];                                     // 0x00F9(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGzPackageServerDetails) == 0x000008, "Wrong alignment on FGzPackageServerDetails");
static_assert(sizeof(FGzPackageServerDetails) == 0x000100, "Wrong size on FGzPackageServerDetails");
static_assert(offsetof(FGzPackageServerDetails, IpAndPort) == 0x000068, "Member 'FGzPackageServerDetails::IpAndPort' has a wrong offset!");
static_assert(offsetof(FGzPackageServerDetails, Name) == 0x000078, "Member 'FGzPackageServerDetails::Name' has a wrong offset!");
static_assert(offsetof(FGzPackageServerDetails, GameRegisterArgs) == 0x000088, "Member 'FGzPackageServerDetails::GameRegisterArgs' has a wrong offset!");
static_assert(offsetof(FGzPackageServerDetails, Platform) == 0x000098, "Member 'FGzPackageServerDetails::Platform' has a wrong offset!");
static_assert(offsetof(FGzPackageServerDetails, BranchName) == 0x0000A8, "Member 'FGzPackageServerDetails::BranchName' has a wrong offset!");
static_assert(offsetof(FGzPackageServerDetails, CL) == 0x0000B8, "Member 'FGzPackageServerDetails::CL' has a wrong offset!");
static_assert(offsetof(FGzPackageServerDetails, Map) == 0x0000C0, "Member 'FGzPackageServerDetails::Map' has a wrong offset!");
static_assert(offsetof(FGzPackageServerDetails, GameMode) == 0x0000D0, "Member 'FGzPackageServerDetails::GameMode' has a wrong offset!");
static_assert(offsetof(FGzPackageServerDetails, MatchState) == 0x0000E0, "Member 'FGzPackageServerDetails::MatchState' has a wrong offset!");
static_assert(offsetof(FGzPackageServerDetails, PlayerCount) == 0x0000F0, "Member 'FGzPackageServerDetails::PlayerCount' has a wrong offset!");
static_assert(offsetof(FGzPackageServerDetails, MaxPlayerCount) == 0x0000F4, "Member 'FGzPackageServerDetails::MaxPlayerCount' has a wrong offset!");
static_assert(offsetof(FGzPackageServerDetails, CanAcceptNewPlayers) == 0x0000F8, "Member 'FGzPackageServerDetails::CanAcceptNewPlayers' has a wrong offset!");

// ScriptStruct G01.GzSceneTransitionSetup
// 0x0050 (0x0050 - 0x0000)
struct FGzSceneTransitionSetup final
{
public:
	struct FGameplayTagContainer                  From;                                              // 0x0000(0x0020)(Edit, DisableEditOnTemplate, NativeAccessSpecifierPublic)
	struct FGameplayTagContainer                  To;                                                // 0x0020(0x0020)(Edit, DisableEditOnTemplate, NativeAccessSpecifierPublic)
	bool                                          Immediate;                                         // 0x0040(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2A4A[0x3];                                     // 0x0041(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGzSceneTransitionParameters           Parameters;                                        // 0x0044(0x000C)(Edit, DisableEditOnTemplate, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzSceneTransitionSetup) == 0x000008, "Wrong alignment on FGzSceneTransitionSetup");
static_assert(sizeof(FGzSceneTransitionSetup) == 0x000050, "Wrong size on FGzSceneTransitionSetup");
static_assert(offsetof(FGzSceneTransitionSetup, From) == 0x000000, "Member 'FGzSceneTransitionSetup::From' has a wrong offset!");
static_assert(offsetof(FGzSceneTransitionSetup, To) == 0x000020, "Member 'FGzSceneTransitionSetup::To' has a wrong offset!");
static_assert(offsetof(FGzSceneTransitionSetup, Immediate) == 0x000040, "Member 'FGzSceneTransitionSetup::Immediate' has a wrong offset!");
static_assert(offsetof(FGzSceneTransitionSetup, Parameters) == 0x000044, "Member 'FGzSceneTransitionSetup::Parameters' has a wrong offset!");

// ScriptStruct G01.GzMetaCharacterAvatarLoadout
// 0x0080 (0x0080 - 0x0000)
struct FGzMetaCharacterAvatarLoadout final
{
public:
	struct FGzMetaCharacterAvatarLoadoutWeapon    PrimaryWeapon;                                     // 0x0000(0x0020)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FGzMetaCharacterAvatarLoadoutWeapon    SecondaryWeapon;                                   // 0x0020(0x0020)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FGzMetaCharacterAvatarLoadoutWeapon    Sidearm;                                           // 0x0040(0x0020)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	class UGzBodyPartItemData*                    LeftArm;                                           // 0x0060(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UGzBodyPartItemData*                    RightArm;                                          // 0x0068(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UGzBodyPartItemData*                    Legs;                                              // 0x0070(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UGzBackpackItemData*                    Backpack;                                          // 0x0078(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzMetaCharacterAvatarLoadout) == 0x000008, "Wrong alignment on FGzMetaCharacterAvatarLoadout");
static_assert(sizeof(FGzMetaCharacterAvatarLoadout) == 0x000080, "Wrong size on FGzMetaCharacterAvatarLoadout");
static_assert(offsetof(FGzMetaCharacterAvatarLoadout, PrimaryWeapon) == 0x000000, "Member 'FGzMetaCharacterAvatarLoadout::PrimaryWeapon' has a wrong offset!");
static_assert(offsetof(FGzMetaCharacterAvatarLoadout, SecondaryWeapon) == 0x000020, "Member 'FGzMetaCharacterAvatarLoadout::SecondaryWeapon' has a wrong offset!");
static_assert(offsetof(FGzMetaCharacterAvatarLoadout, Sidearm) == 0x000040, "Member 'FGzMetaCharacterAvatarLoadout::Sidearm' has a wrong offset!");
static_assert(offsetof(FGzMetaCharacterAvatarLoadout, LeftArm) == 0x000060, "Member 'FGzMetaCharacterAvatarLoadout::LeftArm' has a wrong offset!");
static_assert(offsetof(FGzMetaCharacterAvatarLoadout, RightArm) == 0x000068, "Member 'FGzMetaCharacterAvatarLoadout::RightArm' has a wrong offset!");
static_assert(offsetof(FGzMetaCharacterAvatarLoadout, Legs) == 0x000070, "Member 'FGzMetaCharacterAvatarLoadout::Legs' has a wrong offset!");
static_assert(offsetof(FGzMetaCharacterAvatarLoadout, Backpack) == 0x000078, "Member 'FGzMetaCharacterAvatarLoadout::Backpack' has a wrong offset!");

// ScriptStruct G01.GzCohtmlAvatar
// 0x0018 (0x0018 - 0x0000)
struct FGzCohtmlAvatar final
{
public:
	class FName                                   ID;                                                // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 ImagePath;                                         // 0x0008(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzCohtmlAvatar) == 0x000008, "Wrong alignment on FGzCohtmlAvatar");
static_assert(sizeof(FGzCohtmlAvatar) == 0x000018, "Wrong size on FGzCohtmlAvatar");
static_assert(offsetof(FGzCohtmlAvatar, ID) == 0x000000, "Member 'FGzCohtmlAvatar::ID' has a wrong offset!");
static_assert(offsetof(FGzCohtmlAvatar, ImagePath) == 0x000008, "Member 'FGzCohtmlAvatar::ImagePath' has a wrong offset!");

// ScriptStruct G01.GzBackendPlayerOnlineStatus
// 0x0030 (0x0030 - 0x0000)
struct FGzBackendPlayerOnlineStatus final
{
public:
	class FString                                 PlayFabId;                                         // 0x0000(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Status;                                            // 0x0010(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 CustomStatus;                                      // 0x0020(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzBackendPlayerOnlineStatus) == 0x000008, "Wrong alignment on FGzBackendPlayerOnlineStatus");
static_assert(sizeof(FGzBackendPlayerOnlineStatus) == 0x000030, "Wrong size on FGzBackendPlayerOnlineStatus");
static_assert(offsetof(FGzBackendPlayerOnlineStatus, PlayFabId) == 0x000000, "Member 'FGzBackendPlayerOnlineStatus::PlayFabId' has a wrong offset!");
static_assert(offsetof(FGzBackendPlayerOnlineStatus, Status) == 0x000010, "Member 'FGzBackendPlayerOnlineStatus::Status' has a wrong offset!");
static_assert(offsetof(FGzBackendPlayerOnlineStatus, CustomStatus) == 0x000020, "Member 'FGzBackendPlayerOnlineStatus::CustomStatus' has a wrong offset!");

// ScriptStruct G01.GzGetFriendsStatusResult
// 0x0010 (0x00F0 - 0x00E0)
struct FGzGetFriendsStatusResult final : public FGzPlayFabResultBase
{
public:
	TArray<struct FGzBackendPlayerOnlineStatus>   List;                                              // 0x00E0(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzGetFriendsStatusResult) == 0x000008, "Wrong alignment on FGzGetFriendsStatusResult");
static_assert(sizeof(FGzGetFriendsStatusResult) == 0x0000F0, "Wrong size on FGzGetFriendsStatusResult");
static_assert(offsetof(FGzGetFriendsStatusResult, List) == 0x0000E0, "Member 'FGzGetFriendsStatusResult::List' has a wrong offset!");

// ScriptStruct G01.MantleLedgeInfo
// 0x0060 (0x0060 - 0x0000)
struct FMantleLedgeInfo final
{
public:
	bool                                          bUsingComponent;                                   // 0x0000(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2A4B[0x7];                                     // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UPrimitiveComponent*                    LedgeComponent;                                    // 0x0008(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGzTransformNoScale                    LedgeTransform;                                    // 0x0010(0x0050)(NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMantleLedgeInfo) == 0x000010, "Wrong alignment on FMantleLedgeInfo");
static_assert(sizeof(FMantleLedgeInfo) == 0x000060, "Wrong size on FMantleLedgeInfo");
static_assert(offsetof(FMantleLedgeInfo, bUsingComponent) == 0x000000, "Member 'FMantleLedgeInfo::bUsingComponent' has a wrong offset!");
static_assert(offsetof(FMantleLedgeInfo, LedgeComponent) == 0x000008, "Member 'FMantleLedgeInfo::LedgeComponent' has a wrong offset!");
static_assert(offsetof(FMantleLedgeInfo, LedgeTransform) == 0x000010, "Member 'FMantleLedgeInfo::LedgeTransform' has a wrong offset!");

// ScriptStruct G01.GzModifiersPresetOverrideProperties
// 0x0020 (0x0020 - 0x0000)
struct FGzModifiersPresetOverrideProperties final
{
public:
	class UGzCustomizationModifierTemplate*       ModifierTemplatePreview;                           // 0x0000(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, NoDestructor, PersistentInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bExcludeModifier;                                  // 0x0008(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2A4C[0x7];                                     // 0x0009(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FName>                           MaterialSlotNamesOverride;                         // 0x0010(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzModifiersPresetOverrideProperties) == 0x000008, "Wrong alignment on FGzModifiersPresetOverrideProperties");
static_assert(sizeof(FGzModifiersPresetOverrideProperties) == 0x000020, "Wrong size on FGzModifiersPresetOverrideProperties");
static_assert(offsetof(FGzModifiersPresetOverrideProperties, ModifierTemplatePreview) == 0x000000, "Member 'FGzModifiersPresetOverrideProperties::ModifierTemplatePreview' has a wrong offset!");
static_assert(offsetof(FGzModifiersPresetOverrideProperties, bExcludeModifier) == 0x000008, "Member 'FGzModifiersPresetOverrideProperties::bExcludeModifier' has a wrong offset!");
static_assert(offsetof(FGzModifiersPresetOverrideProperties, MaterialSlotNamesOverride) == 0x000010, "Member 'FGzModifiersPresetOverrideProperties::MaterialSlotNamesOverride' has a wrong offset!");

// ScriptStruct G01.GzAbilityTaskConfigContainer
// 0x0048 (0x0048 - 0x0000)
struct FGzAbilityTaskConfigContainer final
{
public:
	FMulticastInlineDelegateProperty_             OnContainerCanceledOrInterrupted;                  // 0x0000(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnContainerCompleted;                              // 0x0010(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TArray<class UGzAbilityTaskConfig*>           SequentialAbilityTaskConfigs;                      // 0x0020(0x0010)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	TArray<class UGzAbilityTaskBase*>             PendingAbilityTasks;                               // 0x0030(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2A4D[0x8];                                     // 0x0040(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGzAbilityTaskConfigContainer) == 0x000008, "Wrong alignment on FGzAbilityTaskConfigContainer");
static_assert(sizeof(FGzAbilityTaskConfigContainer) == 0x000048, "Wrong size on FGzAbilityTaskConfigContainer");
static_assert(offsetof(FGzAbilityTaskConfigContainer, OnContainerCanceledOrInterrupted) == 0x000000, "Member 'FGzAbilityTaskConfigContainer::OnContainerCanceledOrInterrupted' has a wrong offset!");
static_assert(offsetof(FGzAbilityTaskConfigContainer, OnContainerCompleted) == 0x000010, "Member 'FGzAbilityTaskConfigContainer::OnContainerCompleted' has a wrong offset!");
static_assert(offsetof(FGzAbilityTaskConfigContainer, SequentialAbilityTaskConfigs) == 0x000020, "Member 'FGzAbilityTaskConfigContainer::SequentialAbilityTaskConfigs' has a wrong offset!");
static_assert(offsetof(FGzAbilityTaskConfigContainer, PendingAbilityTasks) == 0x000030, "Member 'FGzAbilityTaskConfigContainer::PendingAbilityTasks' has a wrong offset!");

// ScriptStruct G01.GzMetaMarketplaceTransaction
// 0x0098 (0x0098 - 0x0000)
struct FGzMetaMarketplaceTransaction final
{
public:
	struct FGzPlayFabPlayerIdContainer            SellerPlayerId;                                    // 0x0000(0x0020)(NativeAccessSpecifierPublic)
	struct FGzPlayFabPlayerIdContainer            BuyerPlayerId;                                     // 0x0020(0x0020)(NativeAccessSpecifierPublic)
	class FString                                 NftId;                                             // 0x0040(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 AssetId;                                           // 0x0050(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 TradeTime;                                         // 0x0060(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Price;                                             // 0x0070(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EGzMarketplaceTransactionStatus               Status;                                            // 0x0080(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2A4E[0x4];                                     // 0x0084(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 PaidFee;                                           // 0x0088(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzMetaMarketplaceTransaction) == 0x000008, "Wrong alignment on FGzMetaMarketplaceTransaction");
static_assert(sizeof(FGzMetaMarketplaceTransaction) == 0x000098, "Wrong size on FGzMetaMarketplaceTransaction");
static_assert(offsetof(FGzMetaMarketplaceTransaction, SellerPlayerId) == 0x000000, "Member 'FGzMetaMarketplaceTransaction::SellerPlayerId' has a wrong offset!");
static_assert(offsetof(FGzMetaMarketplaceTransaction, BuyerPlayerId) == 0x000020, "Member 'FGzMetaMarketplaceTransaction::BuyerPlayerId' has a wrong offset!");
static_assert(offsetof(FGzMetaMarketplaceTransaction, NftId) == 0x000040, "Member 'FGzMetaMarketplaceTransaction::NftId' has a wrong offset!");
static_assert(offsetof(FGzMetaMarketplaceTransaction, AssetId) == 0x000050, "Member 'FGzMetaMarketplaceTransaction::AssetId' has a wrong offset!");
static_assert(offsetof(FGzMetaMarketplaceTransaction, TradeTime) == 0x000060, "Member 'FGzMetaMarketplaceTransaction::TradeTime' has a wrong offset!");
static_assert(offsetof(FGzMetaMarketplaceTransaction, Price) == 0x000070, "Member 'FGzMetaMarketplaceTransaction::Price' has a wrong offset!");
static_assert(offsetof(FGzMetaMarketplaceTransaction, Status) == 0x000080, "Member 'FGzMetaMarketplaceTransaction::Status' has a wrong offset!");
static_assert(offsetof(FGzMetaMarketplaceTransaction, PaidFee) == 0x000088, "Member 'FGzMetaMarketplaceTransaction::PaidFee' has a wrong offset!");

// ScriptStruct G01.GzGameStat
// 0x0010 (0x0010 - 0x0000)
struct FGzGameStat final
{
public:
	class UGzGameStatTemplate*                    Template;                                          // 0x0000(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Value;                                             // 0x0008(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2A4F[0x4];                                     // 0x000C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGzGameStat) == 0x000008, "Wrong alignment on FGzGameStat");
static_assert(sizeof(FGzGameStat) == 0x000010, "Wrong size on FGzGameStat");
static_assert(offsetof(FGzGameStat, Template) == 0x000000, "Member 'FGzGameStat::Template' has a wrong offset!");
static_assert(offsetof(FGzGameStat, Value) == 0x000008, "Member 'FGzGameStat::Value' has a wrong offset!");

// ScriptStruct G01.GzTeamMemberResult
// 0x0038 (0x0038 - 0x0000)
struct FGzTeamMemberResult final
{
public:
	class FText                                   ClanTag;                                           // 0x0000(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	class FText                                   PlayerDisplayName;                                 // 0x0010(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	EGzSubscriptionType                           SubscriptionType;                                  // 0x0020(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2A50[0x3];                                     // 0x0021(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         PlayerId;                                          // 0x0024(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FGzGameStat>                    Stats;                                             // 0x0028(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzTeamMemberResult) == 0x000008, "Wrong alignment on FGzTeamMemberResult");
static_assert(sizeof(FGzTeamMemberResult) == 0x000038, "Wrong size on FGzTeamMemberResult");
static_assert(offsetof(FGzTeamMemberResult, ClanTag) == 0x000000, "Member 'FGzTeamMemberResult::ClanTag' has a wrong offset!");
static_assert(offsetof(FGzTeamMemberResult, PlayerDisplayName) == 0x000010, "Member 'FGzTeamMemberResult::PlayerDisplayName' has a wrong offset!");
static_assert(offsetof(FGzTeamMemberResult, SubscriptionType) == 0x000020, "Member 'FGzTeamMemberResult::SubscriptionType' has a wrong offset!");
static_assert(offsetof(FGzTeamMemberResult, PlayerId) == 0x000024, "Member 'FGzTeamMemberResult::PlayerId' has a wrong offset!");
static_assert(offsetof(FGzTeamMemberResult, Stats) == 0x000028, "Member 'FGzTeamMemberResult::Stats' has a wrong offset!");

// ScriptStruct G01.GzJobZeroMatchResult
// 0x0018 (0x0018 - 0x0000)
struct FGzJobZeroMatchResult final
{
public:
	bool                                          bWinner;                                           // 0x0000(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2A51[0x7];                                     // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FGzTeamMemberResult>            TeamResult;                                        // 0x0008(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzJobZeroMatchResult) == 0x000008, "Wrong alignment on FGzJobZeroMatchResult");
static_assert(sizeof(FGzJobZeroMatchResult) == 0x000018, "Wrong size on FGzJobZeroMatchResult");
static_assert(offsetof(FGzJobZeroMatchResult, bWinner) == 0x000000, "Member 'FGzJobZeroMatchResult::bWinner' has a wrong offset!");
static_assert(offsetof(FGzJobZeroMatchResult, TeamResult) == 0x000008, "Member 'FGzJobZeroMatchResult::TeamResult' has a wrong offset!");

// ScriptStruct G01.GzBackendScheduledChallenge
// 0x0010 (0x0010 - 0x0000)
struct FGzBackendScheduledChallenge final
{
public:
	class FName                                   ID;                                                // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Progress;                                          // 0x0008(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsCompleted;                                       // 0x000C(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2A52[0x3];                                     // 0x000D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGzBackendScheduledChallenge) == 0x000004, "Wrong alignment on FGzBackendScheduledChallenge");
static_assert(sizeof(FGzBackendScheduledChallenge) == 0x000010, "Wrong size on FGzBackendScheduledChallenge");
static_assert(offsetof(FGzBackendScheduledChallenge, ID) == 0x000000, "Member 'FGzBackendScheduledChallenge::ID' has a wrong offset!");
static_assert(offsetof(FGzBackendScheduledChallenge, Progress) == 0x000008, "Member 'FGzBackendScheduledChallenge::Progress' has a wrong offset!");
static_assert(offsetof(FGzBackendScheduledChallenge, IsCompleted) == 0x00000C, "Member 'FGzBackendScheduledChallenge::IsCompleted' has a wrong offset!");

// ScriptStruct G01.GzBackendChallengeList
// 0x0020 (0x0020 - 0x0000)
struct FGzBackendChallengeList final
{
public:
	class FString                                 Expire;                                            // 0x0000(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FGzBackendScheduledChallenge>   Challenges;                                        // 0x0010(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzBackendChallengeList) == 0x000008, "Wrong alignment on FGzBackendChallengeList");
static_assert(sizeof(FGzBackendChallengeList) == 0x000020, "Wrong size on FGzBackendChallengeList");
static_assert(offsetof(FGzBackendChallengeList, Expire) == 0x000000, "Member 'FGzBackendChallengeList::Expire' has a wrong offset!");
static_assert(offsetof(FGzBackendChallengeList, Challenges) == 0x000010, "Member 'FGzBackendChallengeList::Challenges' has a wrong offset!");

// ScriptStruct G01.GzDamageInstigatorData
// 0x0038 (0x0038 - 0x0000)
struct FGzDamageInstigatorData final
{
public:
	class AActor*                                 Instigator;                                        // 0x0000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UObject*                                Source;                                            // 0x0008(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Origin;                                            // 0x0010(0x0018)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FPredictionKey                         PredictionKey;                                     // 0x0028(0x0010)(RepSkip, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzDamageInstigatorData) == 0x000008, "Wrong alignment on FGzDamageInstigatorData");
static_assert(sizeof(FGzDamageInstigatorData) == 0x000038, "Wrong size on FGzDamageInstigatorData");
static_assert(offsetof(FGzDamageInstigatorData, Instigator) == 0x000000, "Member 'FGzDamageInstigatorData::Instigator' has a wrong offset!");
static_assert(offsetof(FGzDamageInstigatorData, Source) == 0x000008, "Member 'FGzDamageInstigatorData::Source' has a wrong offset!");
static_assert(offsetof(FGzDamageInstigatorData, Origin) == 0x000010, "Member 'FGzDamageInstigatorData::Origin' has a wrong offset!");
static_assert(offsetof(FGzDamageInstigatorData, PredictionKey) == 0x000028, "Member 'FGzDamageInstigatorData::PredictionKey' has a wrong offset!");

// ScriptStruct G01.GzDamageHit
// 0x01B8 (0x01B8 - 0x0000)
struct FGzDamageHit final
{
public:
	struct FHitResult                             Hit;                                               // 0x0000(0x00F8)(Edit, BlueprintVisible, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	float                                         Distance;                                          // 0x00F8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2A53[0x4];                                     // 0x00FC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UGzGE_BaseDamage>           DamageEffect;                                      // 0x0100(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<TSubclassOf<class UGameplayEffect>>    AdditionalEffects;                                 // 0x0108(0x0010)(Edit, BlueprintVisible, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
	TMap<struct FGameplayTag, float>              DamageEffectMultipliers;                           // 0x0118(0x0050)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	TMap<struct FGameplayTag, float>              OverrideMagnitudes;                                // 0x0168(0x0050)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzDamageHit) == 0x000008, "Wrong alignment on FGzDamageHit");
static_assert(sizeof(FGzDamageHit) == 0x0001B8, "Wrong size on FGzDamageHit");
static_assert(offsetof(FGzDamageHit, Hit) == 0x000000, "Member 'FGzDamageHit::Hit' has a wrong offset!");
static_assert(offsetof(FGzDamageHit, Distance) == 0x0000F8, "Member 'FGzDamageHit::Distance' has a wrong offset!");
static_assert(offsetof(FGzDamageHit, DamageEffect) == 0x000100, "Member 'FGzDamageHit::DamageEffect' has a wrong offset!");
static_assert(offsetof(FGzDamageHit, AdditionalEffects) == 0x000108, "Member 'FGzDamageHit::AdditionalEffects' has a wrong offset!");
static_assert(offsetof(FGzDamageHit, DamageEffectMultipliers) == 0x000118, "Member 'FGzDamageHit::DamageEffectMultipliers' has a wrong offset!");
static_assert(offsetof(FGzDamageHit, OverrideMagnitudes) == 0x000168, "Member 'FGzDamageHit::OverrideMagnitudes' has a wrong offset!");

// ScriptStruct G01.GzTargetAttackParams
// 0x0200 (0x0200 - 0x0000)
struct FGzTargetAttackParams final
{
public:
	class AActor*                                 Target;                                            // 0x0000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGzDamageInstigatorData                InstigatorData;                                    // 0x0008(0x0038)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	struct FGzDamageHit                           DamageHit;                                         // 0x0040(0x01B8)(Edit, BlueprintVisible, ContainsInstancedReference, NativeAccessSpecifierPublic)
	bool                                          bAllowFriendlyFire;                                // 0x01F8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDrawDebug;                                        // 0x01F9(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2A54[0x6];                                     // 0x01FA(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGzTargetAttackParams) == 0x000008, "Wrong alignment on FGzTargetAttackParams");
static_assert(sizeof(FGzTargetAttackParams) == 0x000200, "Wrong size on FGzTargetAttackParams");
static_assert(offsetof(FGzTargetAttackParams, Target) == 0x000000, "Member 'FGzTargetAttackParams::Target' has a wrong offset!");
static_assert(offsetof(FGzTargetAttackParams, InstigatorData) == 0x000008, "Member 'FGzTargetAttackParams::InstigatorData' has a wrong offset!");
static_assert(offsetof(FGzTargetAttackParams, DamageHit) == 0x000040, "Member 'FGzTargetAttackParams::DamageHit' has a wrong offset!");
static_assert(offsetof(FGzTargetAttackParams, bAllowFriendlyFire) == 0x0001F8, "Member 'FGzTargetAttackParams::bAllowFriendlyFire' has a wrong offset!");
static_assert(offsetof(FGzTargetAttackParams, bDrawDebug) == 0x0001F9, "Member 'FGzTargetAttackParams::bDrawDebug' has a wrong offset!");

// ScriptStruct G01.GzPingVoiceLineData
// 0x0010 (0x0010 - 0x0000)
struct FGzPingVoiceLineData final
{
public:
	class UAkAudioEvent*                          Event;                                             // 0x0000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EGzVoiceLinePriority                          Priority;                                          // 0x0008(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2A55[0x7];                                     // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGzPingVoiceLineData) == 0x000008, "Wrong alignment on FGzPingVoiceLineData");
static_assert(sizeof(FGzPingVoiceLineData) == 0x000010, "Wrong size on FGzPingVoiceLineData");
static_assert(offsetof(FGzPingVoiceLineData, Event) == 0x000000, "Member 'FGzPingVoiceLineData::Event' has a wrong offset!");
static_assert(offsetof(FGzPingVoiceLineData, Priority) == 0x000008, "Member 'FGzPingVoiceLineData::Priority' has a wrong offset!");

// ScriptStruct G01.GzSingleHitDamage
// 0x01F0 (0x01F0 - 0x0000)
struct FGzSingleHitDamage final
{
public:
	struct FGzDamageInstigatorData                InstigatorData;                                    // 0x0000(0x0038)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	struct FGzDamageHit                           DamageHit;                                         // 0x0038(0x01B8)(Edit, BlueprintVisible, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzSingleHitDamage) == 0x000008, "Wrong alignment on FGzSingleHitDamage");
static_assert(sizeof(FGzSingleHitDamage) == 0x0001F0, "Wrong size on FGzSingleHitDamage");
static_assert(offsetof(FGzSingleHitDamage, InstigatorData) == 0x000000, "Member 'FGzSingleHitDamage::InstigatorData' has a wrong offset!");
static_assert(offsetof(FGzSingleHitDamage, DamageHit) == 0x000038, "Member 'FGzSingleHitDamage::DamageHit' has a wrong offset!");

// ScriptStruct G01.GzCohtmlLiveFeatureFraudItemTradeCooldownValidation
// 0x0018 (0x0018 - 0x0000)
struct FGzCohtmlLiveFeatureFraudItemTradeCooldownValidation final
{
public:
	bool                                          Enabled;                                           // 0x0000(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2A56[0x7];                                     // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 TradeCooldown;                                     // 0x0008(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzCohtmlLiveFeatureFraudItemTradeCooldownValidation) == 0x000008, "Wrong alignment on FGzCohtmlLiveFeatureFraudItemTradeCooldownValidation");
static_assert(sizeof(FGzCohtmlLiveFeatureFraudItemTradeCooldownValidation) == 0x000018, "Wrong size on FGzCohtmlLiveFeatureFraudItemTradeCooldownValidation");
static_assert(offsetof(FGzCohtmlLiveFeatureFraudItemTradeCooldownValidation, Enabled) == 0x000000, "Member 'FGzCohtmlLiveFeatureFraudItemTradeCooldownValidation::Enabled' has a wrong offset!");
static_assert(offsetof(FGzCohtmlLiveFeatureFraudItemTradeCooldownValidation, TradeCooldown) == 0x000008, "Member 'FGzCohtmlLiveFeatureFraudItemTradeCooldownValidation::TradeCooldown' has a wrong offset!");

// ScriptStruct G01.GzMatchEndPlayerResult
// 0x0048 (0x0048 - 0x0000)
struct FGzMatchEndPlayerResult final
{
public:
	class FText                                   DisplayName;                                       // 0x0000(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	class FString                                 PlayFabId;                                         // 0x0010(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 ClanTag;                                           // 0x0020(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bHasSubscription;                                  // 0x0030(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2A57[0x7];                                     // 0x0031(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FGzGameStat>                    Stats;                                             // 0x0038(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzMatchEndPlayerResult) == 0x000008, "Wrong alignment on FGzMatchEndPlayerResult");
static_assert(sizeof(FGzMatchEndPlayerResult) == 0x000048, "Wrong size on FGzMatchEndPlayerResult");
static_assert(offsetof(FGzMatchEndPlayerResult, DisplayName) == 0x000000, "Member 'FGzMatchEndPlayerResult::DisplayName' has a wrong offset!");
static_assert(offsetof(FGzMatchEndPlayerResult, PlayFabId) == 0x000010, "Member 'FGzMatchEndPlayerResult::PlayFabId' has a wrong offset!");
static_assert(offsetof(FGzMatchEndPlayerResult, ClanTag) == 0x000020, "Member 'FGzMatchEndPlayerResult::ClanTag' has a wrong offset!");
static_assert(offsetof(FGzMatchEndPlayerResult, bHasSubscription) == 0x000030, "Member 'FGzMatchEndPlayerResult::bHasSubscription' has a wrong offset!");
static_assert(offsetof(FGzMatchEndPlayerResult, Stats) == 0x000038, "Member 'FGzMatchEndPlayerResult::Stats' has a wrong offset!");

// ScriptStruct G01.GzCircle2D
// 0x0018 (0x0018 - 0x0000)
struct FGzCircle2D final
{
public:
	double                                        Radius;                                            // 0x0000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              Center;                                            // 0x0008(0x0010)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzCircle2D) == 0x000008, "Wrong alignment on FGzCircle2D");
static_assert(sizeof(FGzCircle2D) == 0x000018, "Wrong size on FGzCircle2D");
static_assert(offsetof(FGzCircle2D, Radius) == 0x000000, "Member 'FGzCircle2D::Radius' has a wrong offset!");
static_assert(offsetof(FGzCircle2D, Center) == 0x000008, "Member 'FGzCircle2D::Center' has a wrong offset!");

// ScriptStruct G01.GzMovementActionData
// 0x0030 (0x0030 - 0x0000)
struct FGzMovementActionData final
{
public:
	struct FGameplayTag                           MovementTag;                                       // 0x0000(0x0008)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           StateTag;                                          // 0x0008(0x0008)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTagContainer                  BlockingMovementTags;                              // 0x0010(0x0020)(Edit, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzMovementActionData) == 0x000008, "Wrong alignment on FGzMovementActionData");
static_assert(sizeof(FGzMovementActionData) == 0x000030, "Wrong size on FGzMovementActionData");
static_assert(offsetof(FGzMovementActionData, MovementTag) == 0x000000, "Member 'FGzMovementActionData::MovementTag' has a wrong offset!");
static_assert(offsetof(FGzMovementActionData, StateTag) == 0x000008, "Member 'FGzMovementActionData::StateTag' has a wrong offset!");
static_assert(offsetof(FGzMovementActionData, BlockingMovementTags) == 0x000010, "Member 'FGzMovementActionData::BlockingMovementTags' has a wrong offset!");

// ScriptStruct G01.GzCharacterViewpointData
// 0x0038 (0x0038 - 0x0000)
struct FGzCharacterViewpointData final
{
public:
	float                                         TransitionDuration;                                // 0x0000(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2A58[0x4];                                     // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRotator                               Rotation;                                          // 0x0008(0x0018)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FVector                                Location;                                          // 0x0020(0x0018)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzCharacterViewpointData) == 0x000008, "Wrong alignment on FGzCharacterViewpointData");
static_assert(sizeof(FGzCharacterViewpointData) == 0x000038, "Wrong size on FGzCharacterViewpointData");
static_assert(offsetof(FGzCharacterViewpointData, TransitionDuration) == 0x000000, "Member 'FGzCharacterViewpointData::TransitionDuration' has a wrong offset!");
static_assert(offsetof(FGzCharacterViewpointData, Rotation) == 0x000008, "Member 'FGzCharacterViewpointData::Rotation' has a wrong offset!");
static_assert(offsetof(FGzCharacterViewpointData, Location) == 0x000020, "Member 'FGzCharacterViewpointData::Location' has a wrong offset!");

// ScriptStruct G01.GzBackendBattlePassLevelProgressionV2
// 0x000C (0x000C - 0x0000)
struct FGzBackendBattlePassLevelProgressionV2 final
{
public:
	int32                                         Level;                                             // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Xp;                                                // 0x0004(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         XpToNextLevel;                                     // 0x0008(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzBackendBattlePassLevelProgressionV2) == 0x000004, "Wrong alignment on FGzBackendBattlePassLevelProgressionV2");
static_assert(sizeof(FGzBackendBattlePassLevelProgressionV2) == 0x00000C, "Wrong size on FGzBackendBattlePassLevelProgressionV2");
static_assert(offsetof(FGzBackendBattlePassLevelProgressionV2, Level) == 0x000000, "Member 'FGzBackendBattlePassLevelProgressionV2::Level' has a wrong offset!");
static_assert(offsetof(FGzBackendBattlePassLevelProgressionV2, Xp) == 0x000004, "Member 'FGzBackendBattlePassLevelProgressionV2::Xp' has a wrong offset!");
static_assert(offsetof(FGzBackendBattlePassLevelProgressionV2, XpToNextLevel) == 0x000008, "Member 'FGzBackendBattlePassLevelProgressionV2::XpToNextLevel' has a wrong offset!");

// ScriptStruct G01.GzRetargetedModifiersContainer
// 0x0050 (0x0050 - 0x0000)
struct alignas(0x08) FGzRetargetedModifiersContainer final
{
public:
	uint8                                         Pad_2A59[0x50];                                    // 0x0000(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGzRetargetedModifiersContainer) == 0x000008, "Wrong alignment on FGzRetargetedModifiersContainer");
static_assert(sizeof(FGzRetargetedModifiersContainer) == 0x000050, "Wrong size on FGzRetargetedModifiersContainer");

// ScriptStruct G01.GzBrushKeys
// 0x0010 (0x0010 - 0x0000)
struct FGzBrushKeys final
{
public:
	TArray<struct FCommonInputKeyBrushConfiguration> Brushes;                                           // 0x0000(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzBrushKeys) == 0x000008, "Wrong alignment on FGzBrushKeys");
static_assert(sizeof(FGzBrushKeys) == 0x000010, "Wrong size on FGzBrushKeys");
static_assert(offsetof(FGzBrushKeys, Brushes) == 0x000000, "Member 'FGzBrushKeys::Brushes' has a wrong offset!");

// ScriptStruct G01.GzItemSkinMaterials
// 0x0010 (0x0010 - 0x0000)
struct FGzItemSkinMaterials final
{
public:
	TArray<class UGzItemSkinMaterial*>            ItemSkinMaterials;                                 // 0x0000(0x0010)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, ContainsInstancedReference, UObjectWrapper, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzItemSkinMaterials) == 0x000008, "Wrong alignment on FGzItemSkinMaterials");
static_assert(sizeof(FGzItemSkinMaterials) == 0x000010, "Wrong size on FGzItemSkinMaterials");
static_assert(offsetof(FGzItemSkinMaterials, ItemSkinMaterials) == 0x000000, "Member 'FGzItemSkinMaterials::ItemSkinMaterials' has a wrong offset!");

// ScriptStruct G01.GzHitReaction
// 0x0040 (0x0040 - 0x0000)
struct FGzHitReaction final
{
public:
	TArray<class UAnimMontage*>                   FrontHitMontages;                                  // 0x0000(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TArray<class UAnimMontage*>                   RightHitMontages;                                  // 0x0010(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TArray<class UAnimMontage*>                   BackHitMontages;                                   // 0x0020(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TArray<class UAnimMontage*>                   LeftHitMontages;                                   // 0x0030(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzHitReaction) == 0x000008, "Wrong alignment on FGzHitReaction");
static_assert(sizeof(FGzHitReaction) == 0x000040, "Wrong size on FGzHitReaction");
static_assert(offsetof(FGzHitReaction, FrontHitMontages) == 0x000000, "Member 'FGzHitReaction::FrontHitMontages' has a wrong offset!");
static_assert(offsetof(FGzHitReaction, RightHitMontages) == 0x000010, "Member 'FGzHitReaction::RightHitMontages' has a wrong offset!");
static_assert(offsetof(FGzHitReaction, BackHitMontages) == 0x000020, "Member 'FGzHitReaction::BackHitMontages' has a wrong offset!");
static_assert(offsetof(FGzHitReaction, LeftHitMontages) == 0x000030, "Member 'FGzHitReaction::LeftHitMontages' has a wrong offset!");

// ScriptStruct G01.GzResultAvailableTask
// 0x0018 (0x0018 - 0x0000)
struct FGzResultAvailableTask
{
public:
	class FString                                 ID;                                                // 0x0000(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsCompleted;                                       // 0x0010(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2A5A[0x7];                                     // 0x0011(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGzResultAvailableTask) == 0x000008, "Wrong alignment on FGzResultAvailableTask");
static_assert(sizeof(FGzResultAvailableTask) == 0x000018, "Wrong size on FGzResultAvailableTask");
static_assert(offsetof(FGzResultAvailableTask, ID) == 0x000000, "Member 'FGzResultAvailableTask::ID' has a wrong offset!");
static_assert(offsetof(FGzResultAvailableTask, IsCompleted) == 0x000010, "Member 'FGzResultAvailableTask::IsCompleted' has a wrong offset!");

// ScriptStruct G01.GzResultAvailableJob
// 0x0000 (0x0018 - 0x0018)
struct FGzResultAvailableJob final : public FGzResultAvailableTask
{
};
static_assert(alignof(FGzResultAvailableJob) == 0x000008, "Wrong alignment on FGzResultAvailableJob");
static_assert(sizeof(FGzResultAvailableJob) == 0x000018, "Wrong size on FGzResultAvailableJob");

// ScriptStruct G01.GzInvItemContentBase
// 0x0028 (0x0028 - 0x0000)
struct alignas(0x08) FGzInvItemContentBase
{
public:
	uint8                                         Pad_2A5B[0x28];                                    // 0x0000(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGzInvItemContentBase) == 0x000008, "Wrong alignment on FGzInvItemContentBase");
static_assert(sizeof(FGzInvItemContentBase) == 0x000028, "Wrong size on FGzInvItemContentBase");

// ScriptStruct G01.GzWeaponInvItem
// 0x0028 (0x0050 - 0x0028)
struct FGzWeaponInvItem final : public FGzInvItemContentBase
{
public:
	class UGzWeaponItemData*                      ItemData;                                          // 0x0028(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UGzWeaponSkinItemData*                  SkinItemData;                                      // 0x0030(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class UGzWeaponAttachmentItemData*>    Attachments;                                       // 0x0038(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	int32                                         Ammo;                                              // 0x0048(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, RepSkip, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2A5C[0x4];                                     // 0x004C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGzWeaponInvItem) == 0x000008, "Wrong alignment on FGzWeaponInvItem");
static_assert(sizeof(FGzWeaponInvItem) == 0x000050, "Wrong size on FGzWeaponInvItem");
static_assert(offsetof(FGzWeaponInvItem, ItemData) == 0x000028, "Member 'FGzWeaponInvItem::ItemData' has a wrong offset!");
static_assert(offsetof(FGzWeaponInvItem, SkinItemData) == 0x000030, "Member 'FGzWeaponInvItem::SkinItemData' has a wrong offset!");
static_assert(offsetof(FGzWeaponInvItem, Attachments) == 0x000038, "Member 'FGzWeaponInvItem::Attachments' has a wrong offset!");
static_assert(offsetof(FGzWeaponInvItem, Ammo) == 0x000048, "Member 'FGzWeaponInvItem::Ammo' has a wrong offset!");

// ScriptStruct G01.GzWeaponConstructionInfo
// 0x0058 (0x0058 - 0x0000)
struct FGzWeaponConstructionInfo final
{
public:
	struct FGzWeaponInvItem                       Item;                                              // 0x0000(0x0050)(NativeAccessSpecifierPublic)
	struct FGzInvPocketId                         Pocket;                                            // 0x0050(0x0008)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzWeaponConstructionInfo) == 0x000008, "Wrong alignment on FGzWeaponConstructionInfo");
static_assert(sizeof(FGzWeaponConstructionInfo) == 0x000058, "Wrong size on FGzWeaponConstructionInfo");
static_assert(offsetof(FGzWeaponConstructionInfo, Item) == 0x000000, "Member 'FGzWeaponConstructionInfo::Item' has a wrong offset!");
static_assert(offsetof(FGzWeaponConstructionInfo, Pocket) == 0x000050, "Member 'FGzWeaponConstructionInfo::Pocket' has a wrong offset!");

// ScriptStruct G01.GzDefaultViewerSetup
// 0x0010 (0x0010 - 0x0000)
struct FGzDefaultViewerSetup
{
public:
	uint8                                         Pad_2A5D[0x8];                                     // 0x0000(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class AGzSceneViewpoint*                      DefaultViewpoint;                                  // 0x0008(0x0008)(Edit, ZeroConstructor, DisableEditOnTemplate, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzDefaultViewerSetup) == 0x000008, "Wrong alignment on FGzDefaultViewerSetup");
static_assert(sizeof(FGzDefaultViewerSetup) == 0x000010, "Wrong size on FGzDefaultViewerSetup");
static_assert(offsetof(FGzDefaultViewerSetup, DefaultViewpoint) == 0x000008, "Member 'FGzDefaultViewerSetup::DefaultViewpoint' has a wrong offset!");

// ScriptStruct G01.GzResultCollectClientMetrics
// 0x0000 (0x00E0 - 0x00E0)
struct FGzResultCollectClientMetrics final : public FGzPlayFabResultBase
{
};
static_assert(alignof(FGzResultCollectClientMetrics) == 0x000008, "Wrong alignment on FGzResultCollectClientMetrics");
static_assert(sizeof(FGzResultCollectClientMetrics) == 0x0000E0, "Wrong size on FGzResultCollectClientMetrics");

// ScriptStruct G01.GzZiplineMovementRuntimeData
// 0x0058 (0x0058 - 0x0000)
struct FGzZiplineMovementRuntimeData final
{
public:
	class AGzZipline*                             Zipline;                                           // 0x0000(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, RepSkip, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector_NetQuantize                    StartPosition;                                     // 0x0008(0x0018)(BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector_NetQuantize                    SplineStartPoint;                                  // 0x0020(0x0018)(BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MovementToZiplineProgress;                         // 0x0038(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MovementAlongZiplineProgress;                      // 0x003C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MoveDirection;                                     // 0x0040(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DistanceToMoveAlongZipline;                        // 0x0044(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MovingAlongZiplineTime;                            // 0x0048(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TotalMovementDuration;                             // 0x004C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EGzZiplineMovementState                       CurrentState;                                      // 0x0050(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2A5E[0x7];                                     // 0x0051(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGzZiplineMovementRuntimeData) == 0x000008, "Wrong alignment on FGzZiplineMovementRuntimeData");
static_assert(sizeof(FGzZiplineMovementRuntimeData) == 0x000058, "Wrong size on FGzZiplineMovementRuntimeData");
static_assert(offsetof(FGzZiplineMovementRuntimeData, Zipline) == 0x000000, "Member 'FGzZiplineMovementRuntimeData::Zipline' has a wrong offset!");
static_assert(offsetof(FGzZiplineMovementRuntimeData, StartPosition) == 0x000008, "Member 'FGzZiplineMovementRuntimeData::StartPosition' has a wrong offset!");
static_assert(offsetof(FGzZiplineMovementRuntimeData, SplineStartPoint) == 0x000020, "Member 'FGzZiplineMovementRuntimeData::SplineStartPoint' has a wrong offset!");
static_assert(offsetof(FGzZiplineMovementRuntimeData, MovementToZiplineProgress) == 0x000038, "Member 'FGzZiplineMovementRuntimeData::MovementToZiplineProgress' has a wrong offset!");
static_assert(offsetof(FGzZiplineMovementRuntimeData, MovementAlongZiplineProgress) == 0x00003C, "Member 'FGzZiplineMovementRuntimeData::MovementAlongZiplineProgress' has a wrong offset!");
static_assert(offsetof(FGzZiplineMovementRuntimeData, MoveDirection) == 0x000040, "Member 'FGzZiplineMovementRuntimeData::MoveDirection' has a wrong offset!");
static_assert(offsetof(FGzZiplineMovementRuntimeData, DistanceToMoveAlongZipline) == 0x000044, "Member 'FGzZiplineMovementRuntimeData::DistanceToMoveAlongZipline' has a wrong offset!");
static_assert(offsetof(FGzZiplineMovementRuntimeData, MovingAlongZiplineTime) == 0x000048, "Member 'FGzZiplineMovementRuntimeData::MovingAlongZiplineTime' has a wrong offset!");
static_assert(offsetof(FGzZiplineMovementRuntimeData, TotalMovementDuration) == 0x00004C, "Member 'FGzZiplineMovementRuntimeData::TotalMovementDuration' has a wrong offset!");
static_assert(offsetof(FGzZiplineMovementRuntimeData, CurrentState) == 0x000050, "Member 'FGzZiplineMovementRuntimeData::CurrentState' has a wrong offset!");

// ScriptStruct G01.GzPartyAttributesContainer
// 0x0050 (0x0050 - 0x0000)
struct FGzPartyAttributesContainer final
{
public:
	TMap<class FName, class FString>              Attributes;                                        // 0x0000(0x0050)(NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzPartyAttributesContainer) == 0x000008, "Wrong alignment on FGzPartyAttributesContainer");
static_assert(sizeof(FGzPartyAttributesContainer) == 0x000050, "Wrong size on FGzPartyAttributesContainer");
static_assert(offsetof(FGzPartyAttributesContainer, Attributes) == 0x000000, "Member 'FGzPartyAttributesContainer::Attributes' has a wrong offset!");

// ScriptStruct G01.GzCreateCharacterPackage
// 0x0050 (0x00B8 - 0x0068)
struct FGzCreateCharacterPackage final : public FGzPlayFabClientPackage
{
public:
	class FString                                 FactionKey;                                        // 0x0068(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGzPackageCustomizationAppearancePreset CustomizationPreset;                               // 0x0078(0x0040)(NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzCreateCharacterPackage) == 0x000008, "Wrong alignment on FGzCreateCharacterPackage");
static_assert(sizeof(FGzCreateCharacterPackage) == 0x0000B8, "Wrong size on FGzCreateCharacterPackage");
static_assert(offsetof(FGzCreateCharacterPackage, FactionKey) == 0x000068, "Member 'FGzCreateCharacterPackage::FactionKey' has a wrong offset!");
static_assert(offsetof(FGzCreateCharacterPackage, CustomizationPreset) == 0x000078, "Member 'FGzCreateCharacterPackage::CustomizationPreset' has a wrong offset!");

// ScriptStruct G01.GzCohtmlPromotionBanner
// 0x0020 (0x0020 - 0x0000)
struct FGzCohtmlPromotionBanner final
{
public:
	class FString                                 Image;                                             // 0x0000(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 URL;                                               // 0x0010(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzCohtmlPromotionBanner) == 0x000008, "Wrong alignment on FGzCohtmlPromotionBanner");
static_assert(sizeof(FGzCohtmlPromotionBanner) == 0x000020, "Wrong size on FGzCohtmlPromotionBanner");
static_assert(offsetof(FGzCohtmlPromotionBanner, Image) == 0x000000, "Member 'FGzCohtmlPromotionBanner::Image' has a wrong offset!");
static_assert(offsetof(FGzCohtmlPromotionBanner, URL) == 0x000010, "Member 'FGzCohtmlPromotionBanner::URL' has a wrong offset!");

// ScriptStruct G01.GzCohtmlGameMode
// 0x0080 (0x0080 - 0x0000)
struct FGzCohtmlGameMode final
{
public:
	class FString                                 Name;                                              // 0x0000(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Availability;                                      // 0x0010(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Variation;                                         // 0x0020(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   DisplayName;                                       // 0x0030(0x0010)(NativeAccessSpecifierPublic)
	class FText                                   Description;                                       // 0x0040(0x0010)(NativeAccessSpecifierPublic)
	TArray<class FText>                           Tags;                                              // 0x0050(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FGzCohtmlPromotionBanner>       PromotionBanners;                                  // 0x0060(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	class FString                                 IntroductionVideo;                                 // 0x0070(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzCohtmlGameMode) == 0x000008, "Wrong alignment on FGzCohtmlGameMode");
static_assert(sizeof(FGzCohtmlGameMode) == 0x000080, "Wrong size on FGzCohtmlGameMode");
static_assert(offsetof(FGzCohtmlGameMode, Name) == 0x000000, "Member 'FGzCohtmlGameMode::Name' has a wrong offset!");
static_assert(offsetof(FGzCohtmlGameMode, Availability) == 0x000010, "Member 'FGzCohtmlGameMode::Availability' has a wrong offset!");
static_assert(offsetof(FGzCohtmlGameMode, Variation) == 0x000020, "Member 'FGzCohtmlGameMode::Variation' has a wrong offset!");
static_assert(offsetof(FGzCohtmlGameMode, DisplayName) == 0x000030, "Member 'FGzCohtmlGameMode::DisplayName' has a wrong offset!");
static_assert(offsetof(FGzCohtmlGameMode, Description) == 0x000040, "Member 'FGzCohtmlGameMode::Description' has a wrong offset!");
static_assert(offsetof(FGzCohtmlGameMode, Tags) == 0x000050, "Member 'FGzCohtmlGameMode::Tags' has a wrong offset!");
static_assert(offsetof(FGzCohtmlGameMode, PromotionBanners) == 0x000060, "Member 'FGzCohtmlGameMode::PromotionBanners' has a wrong offset!");
static_assert(offsetof(FGzCohtmlGameMode, IntroductionVideo) == 0x000070, "Member 'FGzCohtmlGameMode::IntroductionVideo' has a wrong offset!");

// ScriptStruct G01.GzSlideParams
// 0x0038 (0x0038 - 0x0000)
struct FGzSlideParams final
{
public:
	float                                         SlideableFloorTresholdAngle;                       // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2A5F[0x4];                                     // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         StartSpeedCoeff;                                   // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TurnSpeed;                                         // 0x000C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TurnThresholdMinDotAngle;                          // 0x0010(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BrakeThresholdMaxDotAngle;                         // 0x0014(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TimeToMeasureDistanceToMaintainSlide;              // 0x0018(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinimumDistanceToMaintainSlide;                    // 0x001C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCurveFloat*                            AngleToAcceleration;                               // 0x0020(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         GroundFriction;                                    // 0x0028(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PlayerDeceleration;                                // 0x002C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseSeparateBrakingFriction;                       // 0x0030(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2A60[0x7];                                     // 0x0031(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGzSlideParams) == 0x000008, "Wrong alignment on FGzSlideParams");
static_assert(sizeof(FGzSlideParams) == 0x000038, "Wrong size on FGzSlideParams");
static_assert(offsetof(FGzSlideParams, SlideableFloorTresholdAngle) == 0x000000, "Member 'FGzSlideParams::SlideableFloorTresholdAngle' has a wrong offset!");
static_assert(offsetof(FGzSlideParams, StartSpeedCoeff) == 0x000008, "Member 'FGzSlideParams::StartSpeedCoeff' has a wrong offset!");
static_assert(offsetof(FGzSlideParams, TurnSpeed) == 0x00000C, "Member 'FGzSlideParams::TurnSpeed' has a wrong offset!");
static_assert(offsetof(FGzSlideParams, TurnThresholdMinDotAngle) == 0x000010, "Member 'FGzSlideParams::TurnThresholdMinDotAngle' has a wrong offset!");
static_assert(offsetof(FGzSlideParams, BrakeThresholdMaxDotAngle) == 0x000014, "Member 'FGzSlideParams::BrakeThresholdMaxDotAngle' has a wrong offset!");
static_assert(offsetof(FGzSlideParams, TimeToMeasureDistanceToMaintainSlide) == 0x000018, "Member 'FGzSlideParams::TimeToMeasureDistanceToMaintainSlide' has a wrong offset!");
static_assert(offsetof(FGzSlideParams, MinimumDistanceToMaintainSlide) == 0x00001C, "Member 'FGzSlideParams::MinimumDistanceToMaintainSlide' has a wrong offset!");
static_assert(offsetof(FGzSlideParams, AngleToAcceleration) == 0x000020, "Member 'FGzSlideParams::AngleToAcceleration' has a wrong offset!");
static_assert(offsetof(FGzSlideParams, GroundFriction) == 0x000028, "Member 'FGzSlideParams::GroundFriction' has a wrong offset!");
static_assert(offsetof(FGzSlideParams, PlayerDeceleration) == 0x00002C, "Member 'FGzSlideParams::PlayerDeceleration' has a wrong offset!");
static_assert(offsetof(FGzSlideParams, bUseSeparateBrakingFriction) == 0x000030, "Member 'FGzSlideParams::bUseSeparateBrakingFriction' has a wrong offset!");

// ScriptStruct G01.GzGetPrimaryBalanceResult
// 0x0010 (0x00F0 - 0x00E0)
struct FGzGetPrimaryBalanceResult final : public FGzPlayFabResultBase
{
public:
	class FString                                 BalanceString;                                     // 0x00E0(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzGetPrimaryBalanceResult) == 0x000008, "Wrong alignment on FGzGetPrimaryBalanceResult");
static_assert(sizeof(FGzGetPrimaryBalanceResult) == 0x0000F0, "Wrong size on FGzGetPrimaryBalanceResult");
static_assert(offsetof(FGzGetPrimaryBalanceResult, BalanceString) == 0x0000E0, "Member 'FGzGetPrimaryBalanceResult::BalanceString' has a wrong offset!");

// ScriptStruct G01.GzEquipStateData
// 0x0038 (0x0038 - 0x0000)
struct FGzEquipStateData final
{
public:
	struct FGameplayTag                           StateTag;                                          // 0x0000(0x0008)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           AutoEquipStateTag;                                 // 0x0008(0x0008)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           EquipStateEvent;                                   // 0x0010(0x0008)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimMontage*                           EquipMontageRightArm;                              // 0x0018(0x0008)(Edit, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimMontage*                           UnEquipMontageRightArm;                            // 0x0020(0x0008)(Edit, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimMontage*                           EquipMontageLeftArm;                               // 0x0028(0x0008)(Edit, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimMontage*                           UnEquipMontageLeftArm;                             // 0x0030(0x0008)(Edit, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzEquipStateData) == 0x000008, "Wrong alignment on FGzEquipStateData");
static_assert(sizeof(FGzEquipStateData) == 0x000038, "Wrong size on FGzEquipStateData");
static_assert(offsetof(FGzEquipStateData, StateTag) == 0x000000, "Member 'FGzEquipStateData::StateTag' has a wrong offset!");
static_assert(offsetof(FGzEquipStateData, AutoEquipStateTag) == 0x000008, "Member 'FGzEquipStateData::AutoEquipStateTag' has a wrong offset!");
static_assert(offsetof(FGzEquipStateData, EquipStateEvent) == 0x000010, "Member 'FGzEquipStateData::EquipStateEvent' has a wrong offset!");
static_assert(offsetof(FGzEquipStateData, EquipMontageRightArm) == 0x000018, "Member 'FGzEquipStateData::EquipMontageRightArm' has a wrong offset!");
static_assert(offsetof(FGzEquipStateData, UnEquipMontageRightArm) == 0x000020, "Member 'FGzEquipStateData::UnEquipMontageRightArm' has a wrong offset!");
static_assert(offsetof(FGzEquipStateData, EquipMontageLeftArm) == 0x000028, "Member 'FGzEquipStateData::EquipMontageLeftArm' has a wrong offset!");
static_assert(offsetof(FGzEquipStateData, UnEquipMontageLeftArm) == 0x000030, "Member 'FGzEquipStateData::UnEquipMontageLeftArm' has a wrong offset!");

// ScriptStruct G01.GzVehicleSurfaceEffects
// 0x0030 (0x0030 - 0x0000)
struct FGzVehicleSurfaceEffects final
{
public:
	class UAkSwitchValue*                         TireSkidAkSwitch;                                  // 0x0000(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAkSwitchValue*                         TireSurfaceAkSwitch;                               // 0x0008(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAkSwitchValue*                         TireTurnAkSwitch;                                  // 0x0010(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UNiagaraSystem*                         TireTrackNiagaraSystem;                            // 0x0018(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UNiagaraSystem*                         TireDustNiagaraSystem;                             // 0x0020(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UNiagaraSystem*                         EnvironmentCollisionNiagaraSystem;                 // 0x0028(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzVehicleSurfaceEffects) == 0x000008, "Wrong alignment on FGzVehicleSurfaceEffects");
static_assert(sizeof(FGzVehicleSurfaceEffects) == 0x000030, "Wrong size on FGzVehicleSurfaceEffects");
static_assert(offsetof(FGzVehicleSurfaceEffects, TireSkidAkSwitch) == 0x000000, "Member 'FGzVehicleSurfaceEffects::TireSkidAkSwitch' has a wrong offset!");
static_assert(offsetof(FGzVehicleSurfaceEffects, TireSurfaceAkSwitch) == 0x000008, "Member 'FGzVehicleSurfaceEffects::TireSurfaceAkSwitch' has a wrong offset!");
static_assert(offsetof(FGzVehicleSurfaceEffects, TireTurnAkSwitch) == 0x000010, "Member 'FGzVehicleSurfaceEffects::TireTurnAkSwitch' has a wrong offset!");
static_assert(offsetof(FGzVehicleSurfaceEffects, TireTrackNiagaraSystem) == 0x000018, "Member 'FGzVehicleSurfaceEffects::TireTrackNiagaraSystem' has a wrong offset!");
static_assert(offsetof(FGzVehicleSurfaceEffects, TireDustNiagaraSystem) == 0x000020, "Member 'FGzVehicleSurfaceEffects::TireDustNiagaraSystem' has a wrong offset!");
static_assert(offsetof(FGzVehicleSurfaceEffects, EnvironmentCollisionNiagaraSystem) == 0x000028, "Member 'FGzVehicleSurfaceEffects::EnvironmentCollisionNiagaraSystem' has a wrong offset!");

// ScriptStruct G01.GzCohtmlWeaponStats
// 0x0020 (0x0020 - 0x0000)
struct FGzCohtmlWeaponStats final
{
public:
	float                                         Accuracy;                                          // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Handling;                                          // 0x0004(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Recoil;                                            // 0x0008(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Damage;                                            // 0x000C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FireRate;                                          // 0x0010(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Range;                                             // 0x0014(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Mobility;                                          // 0x0018(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ClipSize;                                          // 0x001C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzCohtmlWeaponStats) == 0x000004, "Wrong alignment on FGzCohtmlWeaponStats");
static_assert(sizeof(FGzCohtmlWeaponStats) == 0x000020, "Wrong size on FGzCohtmlWeaponStats");
static_assert(offsetof(FGzCohtmlWeaponStats, Accuracy) == 0x000000, "Member 'FGzCohtmlWeaponStats::Accuracy' has a wrong offset!");
static_assert(offsetof(FGzCohtmlWeaponStats, Handling) == 0x000004, "Member 'FGzCohtmlWeaponStats::Handling' has a wrong offset!");
static_assert(offsetof(FGzCohtmlWeaponStats, Recoil) == 0x000008, "Member 'FGzCohtmlWeaponStats::Recoil' has a wrong offset!");
static_assert(offsetof(FGzCohtmlWeaponStats, Damage) == 0x00000C, "Member 'FGzCohtmlWeaponStats::Damage' has a wrong offset!");
static_assert(offsetof(FGzCohtmlWeaponStats, FireRate) == 0x000010, "Member 'FGzCohtmlWeaponStats::FireRate' has a wrong offset!");
static_assert(offsetof(FGzCohtmlWeaponStats, Range) == 0x000014, "Member 'FGzCohtmlWeaponStats::Range' has a wrong offset!");
static_assert(offsetof(FGzCohtmlWeaponStats, Mobility) == 0x000018, "Member 'FGzCohtmlWeaponStats::Mobility' has a wrong offset!");
static_assert(offsetof(FGzCohtmlWeaponStats, ClipSize) == 0x00001C, "Member 'FGzCohtmlWeaponStats::ClipSize' has a wrong offset!");

// ScriptStruct G01.GzPartyMemberMiscData
// 0x0020 (0x0020 - 0x0000)
struct FGzPartyMemberMiscData final
{
public:
	class FString                                 ClanTag;                                           // 0x0000(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bHasOtgPro;                                        // 0x0010(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2A61[0x3];                                     // 0x0011(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         Level;                                             // 0x0014(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int64                                         Timestamp;                                         // 0x0018(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzPartyMemberMiscData) == 0x000008, "Wrong alignment on FGzPartyMemberMiscData");
static_assert(sizeof(FGzPartyMemberMiscData) == 0x000020, "Wrong size on FGzPartyMemberMiscData");
static_assert(offsetof(FGzPartyMemberMiscData, ClanTag) == 0x000000, "Member 'FGzPartyMemberMiscData::ClanTag' has a wrong offset!");
static_assert(offsetof(FGzPartyMemberMiscData, bHasOtgPro) == 0x000010, "Member 'FGzPartyMemberMiscData::bHasOtgPro' has a wrong offset!");
static_assert(offsetof(FGzPartyMemberMiscData, Level) == 0x000014, "Member 'FGzPartyMemberMiscData::Level' has a wrong offset!");
static_assert(offsetof(FGzPartyMemberMiscData, Timestamp) == 0x000018, "Member 'FGzPartyMemberMiscData::Timestamp' has a wrong offset!");

// ScriptStruct G01.NavLinksArrayWrapper
// 0x0010 (0x0010 - 0x0000)
struct FNavLinksArrayWrapper final
{
public:
	TArray<class AActor*>                         NavLinks;                                          // 0x0000(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPublic)
};
static_assert(alignof(FNavLinksArrayWrapper) == 0x000008, "Wrong alignment on FNavLinksArrayWrapper");
static_assert(sizeof(FNavLinksArrayWrapper) == 0x000010, "Wrong size on FNavLinksArrayWrapper");
static_assert(offsetof(FNavLinksArrayWrapper, NavLinks) == 0x000000, "Member 'FNavLinksArrayWrapper::NavLinks' has a wrong offset!");

// ScriptStruct G01.GzMultiHitDamage
// 0x0048 (0x0048 - 0x0000)
struct FGzMultiHitDamage final
{
public:
	struct FGzDamageInstigatorData                InstigatorData;                                    // 0x0000(0x0038)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	TArray<struct FGzDamageHit>                   DamageHits;                                        // 0x0038(0x0010)(Edit, BlueprintVisible, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzMultiHitDamage) == 0x000008, "Wrong alignment on FGzMultiHitDamage");
static_assert(sizeof(FGzMultiHitDamage) == 0x000048, "Wrong size on FGzMultiHitDamage");
static_assert(offsetof(FGzMultiHitDamage, InstigatorData) == 0x000000, "Member 'FGzMultiHitDamage::InstigatorData' has a wrong offset!");
static_assert(offsetof(FGzMultiHitDamage, DamageHits) == 0x000038, "Member 'FGzMultiHitDamage::DamageHits' has a wrong offset!");

// ScriptStruct G01.GzLevelProgression
// 0x0008 (0x0008 - 0x0000)
struct FGzLevelProgression final
{
public:
	int32                                         Xp;                                                // 0x0000(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Level;                                             // 0x0004(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzLevelProgression) == 0x000004, "Wrong alignment on FGzLevelProgression");
static_assert(sizeof(FGzLevelProgression) == 0x000008, "Wrong size on FGzLevelProgression");
static_assert(offsetof(FGzLevelProgression, Xp) == 0x000000, "Member 'FGzLevelProgression::Xp' has a wrong offset!");
static_assert(offsetof(FGzLevelProgression, Level) == 0x000004, "Member 'FGzLevelProgression::Level' has a wrong offset!");

// ScriptStruct G01.GzCohtmlGameModeGroup
// 0x0040 (0x0040 - 0x0000)
struct FGzCohtmlGameModeGroup final
{
public:
	class FString                                 Name;                                              // 0x0000(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   DisplayName;                                       // 0x0010(0x0010)(NativeAccessSpecifierPublic)
	class FString                                 Image;                                             // 0x0020(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FGzCohtmlGameMode>              GameModes;                                         // 0x0030(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzCohtmlGameModeGroup) == 0x000008, "Wrong alignment on FGzCohtmlGameModeGroup");
static_assert(sizeof(FGzCohtmlGameModeGroup) == 0x000040, "Wrong size on FGzCohtmlGameModeGroup");
static_assert(offsetof(FGzCohtmlGameModeGroup, Name) == 0x000000, "Member 'FGzCohtmlGameModeGroup::Name' has a wrong offset!");
static_assert(offsetof(FGzCohtmlGameModeGroup, DisplayName) == 0x000010, "Member 'FGzCohtmlGameModeGroup::DisplayName' has a wrong offset!");
static_assert(offsetof(FGzCohtmlGameModeGroup, Image) == 0x000020, "Member 'FGzCohtmlGameModeGroup::Image' has a wrong offset!");
static_assert(offsetof(FGzCohtmlGameModeGroup, GameModes) == 0x000030, "Member 'FGzCohtmlGameModeGroup::GameModes' has a wrong offset!");

// ScriptStruct G01.GzResultMarketplaceListedItem
// 0x00A0 (0x00A0 - 0x0000)
struct FGzResultMarketplaceListedItem final
{
public:
	class FString                                 ID;                                                // 0x0000(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Name;                                              // 0x0010(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Rarity;                                            // 0x0020(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Type;                                              // 0x0030(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	double                                        Price;                                             // 0x0040(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FDateTime                              Expiration;                                        // 0x0048(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 OwnerId;                                           // 0x0050(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 ItemInstanceId;                                    // 0x0060(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 AssetId;                                           // 0x0070(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 NftId;                                             // 0x0080(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsV3;                                              // 0x0090(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2A62[0x7];                                     // 0x0091(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	int64                                         SerialNumber;                                      // 0x0098(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzResultMarketplaceListedItem) == 0x000008, "Wrong alignment on FGzResultMarketplaceListedItem");
static_assert(sizeof(FGzResultMarketplaceListedItem) == 0x0000A0, "Wrong size on FGzResultMarketplaceListedItem");
static_assert(offsetof(FGzResultMarketplaceListedItem, ID) == 0x000000, "Member 'FGzResultMarketplaceListedItem::ID' has a wrong offset!");
static_assert(offsetof(FGzResultMarketplaceListedItem, Name) == 0x000010, "Member 'FGzResultMarketplaceListedItem::Name' has a wrong offset!");
static_assert(offsetof(FGzResultMarketplaceListedItem, Rarity) == 0x000020, "Member 'FGzResultMarketplaceListedItem::Rarity' has a wrong offset!");
static_assert(offsetof(FGzResultMarketplaceListedItem, Type) == 0x000030, "Member 'FGzResultMarketplaceListedItem::Type' has a wrong offset!");
static_assert(offsetof(FGzResultMarketplaceListedItem, Price) == 0x000040, "Member 'FGzResultMarketplaceListedItem::Price' has a wrong offset!");
static_assert(offsetof(FGzResultMarketplaceListedItem, Expiration) == 0x000048, "Member 'FGzResultMarketplaceListedItem::Expiration' has a wrong offset!");
static_assert(offsetof(FGzResultMarketplaceListedItem, OwnerId) == 0x000050, "Member 'FGzResultMarketplaceListedItem::OwnerId' has a wrong offset!");
static_assert(offsetof(FGzResultMarketplaceListedItem, ItemInstanceId) == 0x000060, "Member 'FGzResultMarketplaceListedItem::ItemInstanceId' has a wrong offset!");
static_assert(offsetof(FGzResultMarketplaceListedItem, AssetId) == 0x000070, "Member 'FGzResultMarketplaceListedItem::AssetId' has a wrong offset!");
static_assert(offsetof(FGzResultMarketplaceListedItem, NftId) == 0x000080, "Member 'FGzResultMarketplaceListedItem::NftId' has a wrong offset!");
static_assert(offsetof(FGzResultMarketplaceListedItem, IsV3) == 0x000090, "Member 'FGzResultMarketplaceListedItem::IsV3' has a wrong offset!");
static_assert(offsetof(FGzResultMarketplaceListedItem, SerialNumber) == 0x000098, "Member 'FGzResultMarketplaceListedItem::SerialNumber' has a wrong offset!");

// ScriptStruct G01.GzResultGetMarketplaceItem
// 0x00A0 (0x0180 - 0x00E0)
struct FGzResultGetMarketplaceItem final : public FGzPlayFabResultBase
{
public:
	struct FGzResultMarketplaceListedItem         MarketplaceItem;                                   // 0x00E0(0x00A0)(NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzResultGetMarketplaceItem) == 0x000008, "Wrong alignment on FGzResultGetMarketplaceItem");
static_assert(sizeof(FGzResultGetMarketplaceItem) == 0x000180, "Wrong size on FGzResultGetMarketplaceItem");
static_assert(offsetof(FGzResultGetMarketplaceItem, MarketplaceItem) == 0x0000E0, "Member 'FGzResultGetMarketplaceItem::MarketplaceItem' has a wrong offset!");

// ScriptStruct G01.GzCharacterIdAccess
// 0x0010 (0x0010 - 0x0000)
struct alignas(0x08) FGzCharacterIdAccess final
{
public:
	uint8                                         Pad_2A63[0x10];                                    // 0x0000(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGzCharacterIdAccess) == 0x000008, "Wrong alignment on FGzCharacterIdAccess");
static_assert(sizeof(FGzCharacterIdAccess) == 0x000010, "Wrong size on FGzCharacterIdAccess");

// ScriptStruct G01.GzPingData
// 0x0060 (0x0060 - 0x0000)
struct FGzPingData final
{
public:
	class AActor*                                 HitActor;                                          // 0x0000(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Position;                                          // 0x0008(0x0018)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class APlayerState*                           PingSource;                                        // 0x0020(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           PingType;                                          // 0x0028(0x0008)(BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EGzPingTarget                                 PingTargetType;                                    // 0x0030(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2A64[0x7];                                     // 0x0031(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UGzItemData*                            PingedItemData;                                    // 0x0038(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	double                                        ApplicationTime;                                   // 0x0040(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           MarkerType;                                        // 0x0048(0x0008)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class APlayerState*>                   Agreements;                                        // 0x0050(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzPingData) == 0x000008, "Wrong alignment on FGzPingData");
static_assert(sizeof(FGzPingData) == 0x000060, "Wrong size on FGzPingData");
static_assert(offsetof(FGzPingData, HitActor) == 0x000000, "Member 'FGzPingData::HitActor' has a wrong offset!");
static_assert(offsetof(FGzPingData, Position) == 0x000008, "Member 'FGzPingData::Position' has a wrong offset!");
static_assert(offsetof(FGzPingData, PingSource) == 0x000020, "Member 'FGzPingData::PingSource' has a wrong offset!");
static_assert(offsetof(FGzPingData, PingType) == 0x000028, "Member 'FGzPingData::PingType' has a wrong offset!");
static_assert(offsetof(FGzPingData, PingTargetType) == 0x000030, "Member 'FGzPingData::PingTargetType' has a wrong offset!");
static_assert(offsetof(FGzPingData, PingedItemData) == 0x000038, "Member 'FGzPingData::PingedItemData' has a wrong offset!");
static_assert(offsetof(FGzPingData, ApplicationTime) == 0x000040, "Member 'FGzPingData::ApplicationTime' has a wrong offset!");
static_assert(offsetof(FGzPingData, MarkerType) == 0x000048, "Member 'FGzPingData::MarkerType' has a wrong offset!");
static_assert(offsetof(FGzPingData, Agreements) == 0x000050, "Member 'FGzPingData::Agreements' has a wrong offset!");

// ScriptStruct G01.GzPackageCustomizationAppearanceActivePresetId
// 0x0010 (0x0010 - 0x0000)
struct FGzPackageCustomizationAppearanceActivePresetId final
{
public:
	class FString                                 ActivePresetId;                                    // 0x0000(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzPackageCustomizationAppearanceActivePresetId) == 0x000008, "Wrong alignment on FGzPackageCustomizationAppearanceActivePresetId");
static_assert(sizeof(FGzPackageCustomizationAppearanceActivePresetId) == 0x000010, "Wrong size on FGzPackageCustomizationAppearanceActivePresetId");
static_assert(offsetof(FGzPackageCustomizationAppearanceActivePresetId, ActivePresetId) == 0x000000, "Member 'FGzPackageCustomizationAppearanceActivePresetId::ActivePresetId' has a wrong offset!");

// ScriptStruct G01.GzInventoryItemAttachmentContent
// 0x0018 (0x0018 - 0x0000)
struct FGzInventoryItemAttachmentContent final
{
public:
	class UGzItemData*                            AttachmentItemData;                                // 0x0000(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGzItemSkinMaterials                   MaterialsOverride;                                 // 0x0008(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzInventoryItemAttachmentContent) == 0x000008, "Wrong alignment on FGzInventoryItemAttachmentContent");
static_assert(sizeof(FGzInventoryItemAttachmentContent) == 0x000018, "Wrong size on FGzInventoryItemAttachmentContent");
static_assert(offsetof(FGzInventoryItemAttachmentContent, AttachmentItemData) == 0x000000, "Member 'FGzInventoryItemAttachmentContent::AttachmentItemData' has a wrong offset!");
static_assert(offsetof(FGzInventoryItemAttachmentContent, MaterialsOverride) == 0x000008, "Member 'FGzInventoryItemAttachmentContent::MaterialsOverride' has a wrong offset!");

// ScriptStruct G01.GzChangeDisplayedProfileNameResult
// 0x0010 (0x00F0 - 0x00E0)
struct FGzChangeDisplayedProfileNameResult final : public FGzPlayFabResultBase
{
public:
	class FString                                 NewDisplayedName;                                  // 0x00E0(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzChangeDisplayedProfileNameResult) == 0x000008, "Wrong alignment on FGzChangeDisplayedProfileNameResult");
static_assert(sizeof(FGzChangeDisplayedProfileNameResult) == 0x0000F0, "Wrong size on FGzChangeDisplayedProfileNameResult");
static_assert(offsetof(FGzChangeDisplayedProfileNameResult, NewDisplayedName) == 0x0000E0, "Member 'FGzChangeDisplayedProfileNameResult::NewDisplayedName' has a wrong offset!");

// ScriptStruct G01.GzPackageReportPlayerInMatch
// 0x0038 (0x00A0 - 0x0068)
struct FGzPackageReportPlayerInMatch final : public FGzPlayFabClientPackage
{
public:
	struct FGzPlayFabPlayerIdContainer            PlayerId;                                          // 0x0068(0x0020)(NativeAccessSpecifierPublic)
	class FString                                 MatchID;                                           // 0x0088(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ReasonMask;                                        // 0x0098(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2A65[0x4];                                     // 0x009C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGzPackageReportPlayerInMatch) == 0x000008, "Wrong alignment on FGzPackageReportPlayerInMatch");
static_assert(sizeof(FGzPackageReportPlayerInMatch) == 0x0000A0, "Wrong size on FGzPackageReportPlayerInMatch");
static_assert(offsetof(FGzPackageReportPlayerInMatch, PlayerId) == 0x000068, "Member 'FGzPackageReportPlayerInMatch::PlayerId' has a wrong offset!");
static_assert(offsetof(FGzPackageReportPlayerInMatch, MatchID) == 0x000088, "Member 'FGzPackageReportPlayerInMatch::MatchID' has a wrong offset!");
static_assert(offsetof(FGzPackageReportPlayerInMatch, ReasonMask) == 0x000098, "Member 'FGzPackageReportPlayerInMatch::ReasonMask' has a wrong offset!");

// ScriptStruct G01.GzWeaponFireMode
// 0x0020 (0x0020 - 0x0000)
struct FGzWeaponFireMode final
{
public:
	EGzWeaponMode                                 WeaponType;                                        // 0x0000(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2A66[0x7];                                     // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UGzGA_WeaponAttack>         WeaponAttackAbility;                               // 0x0008(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         BurstFireNumberOfSequenceShots;                    // 0x0010(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BurstFireSequenceCooldown;                         // 0x0014(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RpmBasic;                                          // 0x0018(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RpmHipfireMultiplier;                              // 0x001C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzWeaponFireMode) == 0x000008, "Wrong alignment on FGzWeaponFireMode");
static_assert(sizeof(FGzWeaponFireMode) == 0x000020, "Wrong size on FGzWeaponFireMode");
static_assert(offsetof(FGzWeaponFireMode, WeaponType) == 0x000000, "Member 'FGzWeaponFireMode::WeaponType' has a wrong offset!");
static_assert(offsetof(FGzWeaponFireMode, WeaponAttackAbility) == 0x000008, "Member 'FGzWeaponFireMode::WeaponAttackAbility' has a wrong offset!");
static_assert(offsetof(FGzWeaponFireMode, BurstFireNumberOfSequenceShots) == 0x000010, "Member 'FGzWeaponFireMode::BurstFireNumberOfSequenceShots' has a wrong offset!");
static_assert(offsetof(FGzWeaponFireMode, BurstFireSequenceCooldown) == 0x000014, "Member 'FGzWeaponFireMode::BurstFireSequenceCooldown' has a wrong offset!");
static_assert(offsetof(FGzWeaponFireMode, RpmBasic) == 0x000018, "Member 'FGzWeaponFireMode::RpmBasic' has a wrong offset!");
static_assert(offsetof(FGzWeaponFireMode, RpmHipfireMultiplier) == 0x00001C, "Member 'FGzWeaponFireMode::RpmHipfireMultiplier' has a wrong offset!");

// ScriptStruct G01.GzCohtmlBattlePassPageLockReasonV2
// 0x0028 (0x0028 - 0x0000)
struct FGzCohtmlBattlePassPageLockReasonV2 final
{
public:
	class FText                                   Title;                                             // 0x0000(0x0010)(NativeAccessSpecifierPublic)
	class FText                                   Description;                                       // 0x0010(0x0010)(NativeAccessSpecifierPublic)
	EGzCohtmlBattlePassPageLockReasonV2           Type;                                              // 0x0020(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2A67[0x4];                                     // 0x0024(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGzCohtmlBattlePassPageLockReasonV2) == 0x000008, "Wrong alignment on FGzCohtmlBattlePassPageLockReasonV2");
static_assert(sizeof(FGzCohtmlBattlePassPageLockReasonV2) == 0x000028, "Wrong size on FGzCohtmlBattlePassPageLockReasonV2");
static_assert(offsetof(FGzCohtmlBattlePassPageLockReasonV2, Title) == 0x000000, "Member 'FGzCohtmlBattlePassPageLockReasonV2::Title' has a wrong offset!");
static_assert(offsetof(FGzCohtmlBattlePassPageLockReasonV2, Description) == 0x000010, "Member 'FGzCohtmlBattlePassPageLockReasonV2::Description' has a wrong offset!");
static_assert(offsetof(FGzCohtmlBattlePassPageLockReasonV2, Type) == 0x000020, "Member 'FGzCohtmlBattlePassPageLockReasonV2::Type' has a wrong offset!");

// ScriptStruct G01.GzStartServerPackage
// 0x0058 (0x00C0 - 0x0068)
struct FGzStartServerPackage final : public FGzPlayFabClientPackage
{
public:
	int32                                         CL;                                                // 0x0068(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2A68[0x4];                                     // 0x006C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 ServerName;                                        // 0x0070(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 HostingType;                                       // 0x0080(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 MapName;                                           // 0x0090(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 BuildConfiguration;                                // 0x00A0(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 ServerOptions;                                     // 0x00B0(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzStartServerPackage) == 0x000008, "Wrong alignment on FGzStartServerPackage");
static_assert(sizeof(FGzStartServerPackage) == 0x0000C0, "Wrong size on FGzStartServerPackage");
static_assert(offsetof(FGzStartServerPackage, CL) == 0x000068, "Member 'FGzStartServerPackage::CL' has a wrong offset!");
static_assert(offsetof(FGzStartServerPackage, ServerName) == 0x000070, "Member 'FGzStartServerPackage::ServerName' has a wrong offset!");
static_assert(offsetof(FGzStartServerPackage, HostingType) == 0x000080, "Member 'FGzStartServerPackage::HostingType' has a wrong offset!");
static_assert(offsetof(FGzStartServerPackage, MapName) == 0x000090, "Member 'FGzStartServerPackage::MapName' has a wrong offset!");
static_assert(offsetof(FGzStartServerPackage, BuildConfiguration) == 0x0000A0, "Member 'FGzStartServerPackage::BuildConfiguration' has a wrong offset!");
static_assert(offsetof(FGzStartServerPackage, ServerOptions) == 0x0000B0, "Member 'FGzStartServerPackage::ServerOptions' has a wrong offset!");

// ScriptStruct G01.GzSelectedZoneData
// 0x0008 (0x0008 - 0x0000)
struct FGzSelectedZoneData final
{
public:
	int32                                         LastZoneIndex;                                     // 0x0000(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         LandingZoneIndex;                                  // 0x0004(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzSelectedZoneData) == 0x000004, "Wrong alignment on FGzSelectedZoneData");
static_assert(sizeof(FGzSelectedZoneData) == 0x000008, "Wrong size on FGzSelectedZoneData");
static_assert(offsetof(FGzSelectedZoneData, LastZoneIndex) == 0x000000, "Member 'FGzSelectedZoneData::LastZoneIndex' has a wrong offset!");
static_assert(offsetof(FGzSelectedZoneData, LandingZoneIndex) == 0x000004, "Member 'FGzSelectedZoneData::LandingZoneIndex' has a wrong offset!");

// ScriptStruct G01.GzEnvironmentZoneWithName
// 0x0018 (0x0018 - 0x0000)
struct FGzEnvironmentZoneWithName final
{
public:
	uint8                                         Pad_2A69[0x10];                                    // 0x0000(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class UGzEnvironmentZoneComponent*            EnvironmentZone;                                   // 0x0010(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzEnvironmentZoneWithName) == 0x000008, "Wrong alignment on FGzEnvironmentZoneWithName");
static_assert(sizeof(FGzEnvironmentZoneWithName) == 0x000018, "Wrong size on FGzEnvironmentZoneWithName");
static_assert(offsetof(FGzEnvironmentZoneWithName, EnvironmentZone) == 0x000010, "Member 'FGzEnvironmentZoneWithName::EnvironmentZone' has a wrong offset!");

// ScriptStruct G01.GzPlayFabNotification
// 0x0020 (0x0020 - 0x0000)
struct FGzPlayFabNotification
{
public:
	class FName                                   ID;                                                // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EGzNotificationsSource                        Type;                                              // 0x0008(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2A6A[0x4];                                     // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FDateTime                              Created;                                           // 0x0010(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2A6B[0x8];                                     // 0x0018(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGzPlayFabNotification) == 0x000008, "Wrong alignment on FGzPlayFabNotification");
static_assert(sizeof(FGzPlayFabNotification) == 0x000020, "Wrong size on FGzPlayFabNotification");
static_assert(offsetof(FGzPlayFabNotification, ID) == 0x000000, "Member 'FGzPlayFabNotification::ID' has a wrong offset!");
static_assert(offsetof(FGzPlayFabNotification, Type) == 0x000008, "Member 'FGzPlayFabNotification::Type' has a wrong offset!");
static_assert(offsetof(FGzPlayFabNotification, Created) == 0x000010, "Member 'FGzPlayFabNotification::Created' has a wrong offset!");

// ScriptStruct G01.GzPlayFabPlayerLevelNotification
// 0x00D8 (0x00F8 - 0x0020)
struct FGzPlayFabPlayerLevelNotification final : public FGzPlayFabNotification
{
public:
	struct FGzLevelProgression                    LevelProgression;                                  // 0x0020(0x0008)(NoDestructor, NativeAccessSpecifierPublic)
	struct FGzCombinedReward                      Reward;                                            // 0x0028(0x00D0)(NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzPlayFabPlayerLevelNotification) == 0x000008, "Wrong alignment on FGzPlayFabPlayerLevelNotification");
static_assert(sizeof(FGzPlayFabPlayerLevelNotification) == 0x0000F8, "Wrong size on FGzPlayFabPlayerLevelNotification");
static_assert(offsetof(FGzPlayFabPlayerLevelNotification, LevelProgression) == 0x000020, "Member 'FGzPlayFabPlayerLevelNotification::LevelProgression' has a wrong offset!");
static_assert(offsetof(FGzPlayFabPlayerLevelNotification, Reward) == 0x000028, "Member 'FGzPlayFabPlayerLevelNotification::Reward' has a wrong offset!");

// ScriptStruct G01.GzVehicleState
// 0x0014 (0x0014 - 0x0000)
struct FGzVehicleState final
{
public:
	float                                         SteeringInput;                                     // 0x0000(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ThrottleInput;                                     // 0x0004(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BrakeInput;                                        // 0x0008(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bHandbrakeInput;                                   // 0x000C(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2A6C[0x3];                                     // 0x000D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         TargetGear;                                        // 0x0010(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzVehicleState) == 0x000004, "Wrong alignment on FGzVehicleState");
static_assert(sizeof(FGzVehicleState) == 0x000014, "Wrong size on FGzVehicleState");
static_assert(offsetof(FGzVehicleState, SteeringInput) == 0x000000, "Member 'FGzVehicleState::SteeringInput' has a wrong offset!");
static_assert(offsetof(FGzVehicleState, ThrottleInput) == 0x000004, "Member 'FGzVehicleState::ThrottleInput' has a wrong offset!");
static_assert(offsetof(FGzVehicleState, BrakeInput) == 0x000008, "Member 'FGzVehicleState::BrakeInput' has a wrong offset!");
static_assert(offsetof(FGzVehicleState, bHandbrakeInput) == 0x00000C, "Member 'FGzVehicleState::bHandbrakeInput' has a wrong offset!");
static_assert(offsetof(FGzVehicleState, TargetGear) == 0x000010, "Member 'FGzVehicleState::TargetGear' has a wrong offset!");

// ScriptStruct G01.GzGameplayTrial
// 0x0014 (0x0020 - 0x000C)
struct FGzGameplayTrial final : public FFastArraySerializerItem
{
public:
	uint8                                         Pad_2A6D[0x4];                                     // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UGzTrialTemplate*                       TrialTemplate;                                     // 0x0010(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CurrentValue;                                      // 0x0018(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2A6E[0x4];                                     // 0x001C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGzGameplayTrial) == 0x000008, "Wrong alignment on FGzGameplayTrial");
static_assert(sizeof(FGzGameplayTrial) == 0x000020, "Wrong size on FGzGameplayTrial");
static_assert(offsetof(FGzGameplayTrial, TrialTemplate) == 0x000010, "Member 'FGzGameplayTrial::TrialTemplate' has a wrong offset!");
static_assert(offsetof(FGzGameplayTrial, CurrentValue) == 0x000018, "Member 'FGzGameplayTrial::CurrentValue' has a wrong offset!");

// ScriptStruct G01.GzPlayerOnlineStatusInfo
// 0x0018 (0x0018 - 0x0000)
struct FGzPlayerOnlineStatusInfo final
{
public:
	EGzPlayerOnlineStatus                         Status;                                            // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2A6F[0x4];                                     // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 CustomStatus;                                      // 0x0008(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzPlayerOnlineStatusInfo) == 0x000008, "Wrong alignment on FGzPlayerOnlineStatusInfo");
static_assert(sizeof(FGzPlayerOnlineStatusInfo) == 0x000018, "Wrong size on FGzPlayerOnlineStatusInfo");
static_assert(offsetof(FGzPlayerOnlineStatusInfo, Status) == 0x000000, "Member 'FGzPlayerOnlineStatusInfo::Status' has a wrong offset!");
static_assert(offsetof(FGzPlayerOnlineStatusInfo, CustomStatus) == 0x000008, "Member 'FGzPlayerOnlineStatusInfo::CustomStatus' has a wrong offset!");

// ScriptStruct G01.GzMessageNetData
// 0x0018 (0x0018 - 0x0000)
struct FGzMessageNetData final
{
public:
	TSubclassOf<class UGzGameMessage>             MessageClass;                                      // 0x0000(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<uint8>                                 MessageData;                                       // 0x0008(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzMessageNetData) == 0x000008, "Wrong alignment on FGzMessageNetData");
static_assert(sizeof(FGzMessageNetData) == 0x000018, "Wrong size on FGzMessageNetData");
static_assert(offsetof(FGzMessageNetData, MessageClass) == 0x000000, "Member 'FGzMessageNetData::MessageClass' has a wrong offset!");
static_assert(offsetof(FGzMessageNetData, MessageData) == 0x000008, "Member 'FGzMessageNetData::MessageData' has a wrong offset!");

// ScriptStruct G01.GzPackageBuyMarketLot
// 0x0020 (0x0088 - 0x0068)
struct FGzPackageBuyMarketLot final : public FGzPlayFabClientPackage
{
public:
	class FString                                 NftId;                                             // 0x0068(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 ExpectedPrice;                                     // 0x0078(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzPackageBuyMarketLot) == 0x000008, "Wrong alignment on FGzPackageBuyMarketLot");
static_assert(sizeof(FGzPackageBuyMarketLot) == 0x000088, "Wrong size on FGzPackageBuyMarketLot");
static_assert(offsetof(FGzPackageBuyMarketLot, NftId) == 0x000068, "Member 'FGzPackageBuyMarketLot::NftId' has a wrong offset!");
static_assert(offsetof(FGzPackageBuyMarketLot, ExpectedPrice) == 0x000078, "Member 'FGzPackageBuyMarketLot::ExpectedPrice' has a wrong offset!");

// ScriptStruct G01.GzAdvancedIdType
// 0x0008 (0x0008 - 0x0000)
struct FGzAdvancedIdType final
{
public:
	int32                                         ID;                                                // 0x0000(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsPlayerState;                                     // 0x0004(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2A70[0x3];                                     // 0x0005(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGzAdvancedIdType) == 0x000004, "Wrong alignment on FGzAdvancedIdType");
static_assert(sizeof(FGzAdvancedIdType) == 0x000008, "Wrong size on FGzAdvancedIdType");
static_assert(offsetof(FGzAdvancedIdType, ID) == 0x000000, "Member 'FGzAdvancedIdType::ID' has a wrong offset!");
static_assert(offsetof(FGzAdvancedIdType, IsPlayerState) == 0x000004, "Member 'FGzAdvancedIdType::IsPlayerState' has a wrong offset!");

// ScriptStruct G01.GzDamageRecord
// 0x0070 (0x0070 - 0x0000)
struct FGzDamageRecord final
{
public:
	struct FGzAdvancedIdType                      InstigatorId;                                      // 0x0000(0x0008)(BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGzAdvancedIdType                      VictimId;                                          // 0x0008(0x0008)(BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DamageValue;                                       // 0x0010(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2A71[0x4];                                     // 0x0014(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	double                                        ApplicationTime;                                   // 0x0018(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayAttribute                     Attribute;                                         // 0x0020(0x0038)(BlueprintVisible, BlueprintReadOnly, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   WeaponArchetype;                                   // 0x0058(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UObject*                                SourceObject;                                      // 0x0060(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UGameplayEffect*                        GameplayEffect;                                    // 0x0068(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzDamageRecord) == 0x000008, "Wrong alignment on FGzDamageRecord");
static_assert(sizeof(FGzDamageRecord) == 0x000070, "Wrong size on FGzDamageRecord");
static_assert(offsetof(FGzDamageRecord, InstigatorId) == 0x000000, "Member 'FGzDamageRecord::InstigatorId' has a wrong offset!");
static_assert(offsetof(FGzDamageRecord, VictimId) == 0x000008, "Member 'FGzDamageRecord::VictimId' has a wrong offset!");
static_assert(offsetof(FGzDamageRecord, DamageValue) == 0x000010, "Member 'FGzDamageRecord::DamageValue' has a wrong offset!");
static_assert(offsetof(FGzDamageRecord, ApplicationTime) == 0x000018, "Member 'FGzDamageRecord::ApplicationTime' has a wrong offset!");
static_assert(offsetof(FGzDamageRecord, Attribute) == 0x000020, "Member 'FGzDamageRecord::Attribute' has a wrong offset!");
static_assert(offsetof(FGzDamageRecord, WeaponArchetype) == 0x000058, "Member 'FGzDamageRecord::WeaponArchetype' has a wrong offset!");
static_assert(offsetof(FGzDamageRecord, SourceObject) == 0x000060, "Member 'FGzDamageRecord::SourceObject' has a wrong offset!");
static_assert(offsetof(FGzDamageRecord, GameplayEffect) == 0x000068, "Member 'FGzDamageRecord::GameplayEffect' has a wrong offset!");

// ScriptStruct G01.GzCohtmlVideo
// 0x0010 (0x0010 - 0x0000)
struct FGzCohtmlVideo final
{
public:
	struct FFilePath                              VideoFilePath;                                     // 0x0000(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzCohtmlVideo) == 0x000008, "Wrong alignment on FGzCohtmlVideo");
static_assert(sizeof(FGzCohtmlVideo) == 0x000010, "Wrong size on FGzCohtmlVideo");
static_assert(offsetof(FGzCohtmlVideo, VideoFilePath) == 0x000000, "Member 'FGzCohtmlVideo::VideoFilePath' has a wrong offset!");

// ScriptStruct G01.GzGamefaceMovieData
// 0x0060 (0x0060 - 0x0000)
struct FGzGamefaceMovieData final
{
public:
	TSoftObjectPtr<class UTexture2D>              Thumbnail;                                         // 0x0000(0x0028)(Edit, Config, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGzCohtmlVideo                         Movie;                                             // 0x0028(0x0010)(Edit, Config, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UAkAudioEvent>           Audio;                                             // 0x0038(0x0028)(Edit, Config, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzGamefaceMovieData) == 0x000008, "Wrong alignment on FGzGamefaceMovieData");
static_assert(sizeof(FGzGamefaceMovieData) == 0x000060, "Wrong size on FGzGamefaceMovieData");
static_assert(offsetof(FGzGamefaceMovieData, Thumbnail) == 0x000000, "Member 'FGzGamefaceMovieData::Thumbnail' has a wrong offset!");
static_assert(offsetof(FGzGamefaceMovieData, Movie) == 0x000028, "Member 'FGzGamefaceMovieData::Movie' has a wrong offset!");
static_assert(offsetof(FGzGamefaceMovieData, Audio) == 0x000038, "Member 'FGzGamefaceMovieData::Audio' has a wrong offset!");

// ScriptStruct G01.GzCohtmlNotification
// 0x0020 (0x0020 - 0x0000)
struct FGzCohtmlNotification
{
public:
	class FName                                   ID;                                                // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EGzNotificationsSource                        Type;                                              // 0x0008(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2A72[0x4];                                     // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 CreatedAt;                                         // 0x0010(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzCohtmlNotification) == 0x000008, "Wrong alignment on FGzCohtmlNotification");
static_assert(sizeof(FGzCohtmlNotification) == 0x000020, "Wrong size on FGzCohtmlNotification");
static_assert(offsetof(FGzCohtmlNotification, ID) == 0x000000, "Member 'FGzCohtmlNotification::ID' has a wrong offset!");
static_assert(offsetof(FGzCohtmlNotification, Type) == 0x000008, "Member 'FGzCohtmlNotification::Type' has a wrong offset!");
static_assert(offsetof(FGzCohtmlNotification, CreatedAt) == 0x000010, "Member 'FGzCohtmlNotification::CreatedAt' has a wrong offset!");

// ScriptStruct G01.GzCohtmlBlockchainMarketLotRemovedNotification
// 0x0020 (0x0040 - 0x0020)
struct FGzCohtmlBlockchainMarketLotRemovedNotification final : public FGzCohtmlNotification
{
public:
	class FString                                 AssetId;                                           // 0x0020(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 ItemInstanceId;                                    // 0x0030(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzCohtmlBlockchainMarketLotRemovedNotification) == 0x000008, "Wrong alignment on FGzCohtmlBlockchainMarketLotRemovedNotification");
static_assert(sizeof(FGzCohtmlBlockchainMarketLotRemovedNotification) == 0x000040, "Wrong size on FGzCohtmlBlockchainMarketLotRemovedNotification");
static_assert(offsetof(FGzCohtmlBlockchainMarketLotRemovedNotification, AssetId) == 0x000020, "Member 'FGzCohtmlBlockchainMarketLotRemovedNotification::AssetId' has a wrong offset!");
static_assert(offsetof(FGzCohtmlBlockchainMarketLotRemovedNotification, ItemInstanceId) == 0x000030, "Member 'FGzCohtmlBlockchainMarketLotRemovedNotification::ItemInstanceId' has a wrong offset!");

// ScriptStruct G01.GzCustomSpawnRotation
// 0x0030 (0x0030 - 0x0000)
struct FGzCustomSpawnRotation final
{
public:
	struct FFloatRange                            YawRandomRange;                                    // 0x0000(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FFloatRange                            PitchRandomRange;                                  // 0x0010(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FFloatRange                            RollRandomRange;                                   // 0x0020(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzCustomSpawnRotation) == 0x000004, "Wrong alignment on FGzCustomSpawnRotation");
static_assert(sizeof(FGzCustomSpawnRotation) == 0x000030, "Wrong size on FGzCustomSpawnRotation");
static_assert(offsetof(FGzCustomSpawnRotation, YawRandomRange) == 0x000000, "Member 'FGzCustomSpawnRotation::YawRandomRange' has a wrong offset!");
static_assert(offsetof(FGzCustomSpawnRotation, PitchRandomRange) == 0x000010, "Member 'FGzCustomSpawnRotation::PitchRandomRange' has a wrong offset!");
static_assert(offsetof(FGzCustomSpawnRotation, RollRandomRange) == 0x000020, "Member 'FGzCustomSpawnRotation::RollRandomRange' has a wrong offset!");

// ScriptStruct G01.GzPvpStats
// 0x000C (0x000C - 0x0000)
struct FGzPvpStats final
{
public:
	uint32                                        Kills;                                             // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint32                                        Knockdowns;                                        // 0x0004(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint32                                        Deaths;                                            // 0x0008(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzPvpStats) == 0x000004, "Wrong alignment on FGzPvpStats");
static_assert(sizeof(FGzPvpStats) == 0x00000C, "Wrong size on FGzPvpStats");
static_assert(offsetof(FGzPvpStats, Kills) == 0x000000, "Member 'FGzPvpStats::Kills' has a wrong offset!");
static_assert(offsetof(FGzPvpStats, Knockdowns) == 0x000004, "Member 'FGzPvpStats::Knockdowns' has a wrong offset!");
static_assert(offsetof(FGzPvpStats, Deaths) == 0x000008, "Member 'FGzPvpStats::Deaths' has a wrong offset!");

// ScriptStruct G01.GzMatchGeneralStats
// 0x000C (0x000C - 0x0000)
struct FGzMatchGeneralStats final
{
public:
	int32                                         Mode;                                              // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint32                                        Placement;                                         // 0x0004(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint32                                        SurvivalTime;                                      // 0x0008(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzMatchGeneralStats) == 0x000004, "Wrong alignment on FGzMatchGeneralStats");
static_assert(sizeof(FGzMatchGeneralStats) == 0x00000C, "Wrong size on FGzMatchGeneralStats");
static_assert(offsetof(FGzMatchGeneralStats, Mode) == 0x000000, "Member 'FGzMatchGeneralStats::Mode' has a wrong offset!");
static_assert(offsetof(FGzMatchGeneralStats, Placement) == 0x000004, "Member 'FGzMatchGeneralStats::Placement' has a wrong offset!");
static_assert(offsetof(FGzMatchGeneralStats, SurvivalTime) == 0x000008, "Member 'FGzMatchGeneralStats::SurvivalTime' has a wrong offset!");

// ScriptStruct G01.GzInteractionStats
// 0x0004 (0x0004 - 0x0000)
struct FGzInteractionStats final
{
public:
	uint32                                        DatacubesExtracted;                                // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzInteractionStats) == 0x000004, "Wrong alignment on FGzInteractionStats");
static_assert(sizeof(FGzInteractionStats) == 0x000004, "Wrong size on FGzInteractionStats");
static_assert(offsetof(FGzInteractionStats, DatacubesExtracted) == 0x000000, "Member 'FGzInteractionStats::DatacubesExtracted' has a wrong offset!");

// ScriptStruct G01.GzMatchStatistics
// 0x001C (0x001C - 0x0000)
struct FGzMatchStatistics final
{
public:
	struct FGzPvpStats                            Pvp;                                               // 0x0000(0x000C)(NoDestructor, NativeAccessSpecifierPublic)
	struct FGzMatchGeneralStats                   MatchGeneral;                                      // 0x000C(0x000C)(NoDestructor, NativeAccessSpecifierPublic)
	struct FGzInteractionStats                    Interaction;                                       // 0x0018(0x0004)(NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzMatchStatistics) == 0x000004, "Wrong alignment on FGzMatchStatistics");
static_assert(sizeof(FGzMatchStatistics) == 0x00001C, "Wrong size on FGzMatchStatistics");
static_assert(offsetof(FGzMatchStatistics, Pvp) == 0x000000, "Member 'FGzMatchStatistics::Pvp' has a wrong offset!");
static_assert(offsetof(FGzMatchStatistics, MatchGeneral) == 0x00000C, "Member 'FGzMatchStatistics::MatchGeneral' has a wrong offset!");
static_assert(offsetof(FGzMatchStatistics, Interaction) == 0x000018, "Member 'FGzMatchStatistics::Interaction' has a wrong offset!");

// ScriptStruct G01.GzCohtmlBattlePassPageEntranceV2
// 0x0038 (0x0038 - 0x0000)
struct FGzCohtmlBattlePassPageEntranceV2 final
{
public:
	TArray<struct FGzCohtmlString>                From;                                              // 0x0000(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	struct FGzCohtmlString                        To;                                                // 0x0010(0x0020)(NativeAccessSpecifierPublic)
	bool                                          State;                                             // 0x0030(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2A73[0x7];                                     // 0x0031(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGzCohtmlBattlePassPageEntranceV2) == 0x000008, "Wrong alignment on FGzCohtmlBattlePassPageEntranceV2");
static_assert(sizeof(FGzCohtmlBattlePassPageEntranceV2) == 0x000038, "Wrong size on FGzCohtmlBattlePassPageEntranceV2");
static_assert(offsetof(FGzCohtmlBattlePassPageEntranceV2, From) == 0x000000, "Member 'FGzCohtmlBattlePassPageEntranceV2::From' has a wrong offset!");
static_assert(offsetof(FGzCohtmlBattlePassPageEntranceV2, To) == 0x000010, "Member 'FGzCohtmlBattlePassPageEntranceV2::To' has a wrong offset!");
static_assert(offsetof(FGzCohtmlBattlePassPageEntranceV2, State) == 0x000030, "Member 'FGzCohtmlBattlePassPageEntranceV2::State' has a wrong offset!");

// ScriptStruct G01.GzKillerInfo
// 0x0030 (0x0030 - 0x0000)
struct FGzKillerInfo final
{
public:
	struct FGameplayTag                           DamageSource;                                      // 0x0000(0x0008)(BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UTexture2D>              Icon;                                              // 0x0008(0x0028)(BlueprintVisible, BlueprintReadOnly, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzKillerInfo) == 0x000008, "Wrong alignment on FGzKillerInfo");
static_assert(sizeof(FGzKillerInfo) == 0x000030, "Wrong size on FGzKillerInfo");
static_assert(offsetof(FGzKillerInfo, DamageSource) == 0x000000, "Member 'FGzKillerInfo::DamageSource' has a wrong offset!");
static_assert(offsetof(FGzKillerInfo, Icon) == 0x000008, "Member 'FGzKillerInfo::Icon' has a wrong offset!");

// ScriptStruct G01.GzPartyInfo
// 0x0020 (0x0020 - 0x0000)
struct alignas(0x08) FGzPartyInfo final
{
public:
	uint8                                         Pad_2A74[0x20];                                    // 0x0000(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGzPartyInfo) == 0x000008, "Wrong alignment on FGzPartyInfo");
static_assert(sizeof(FGzPartyInfo) == 0x000020, "Wrong size on FGzPartyInfo");

// ScriptStruct G01.GzMarkerServerData
// 0x0044 (0x0050 - 0x000C)
struct FGzMarkerServerData final : public FFastArraySerializerItem
{
public:
	uint8                                         Pad_2A75[0x4];                                     // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector_NetQuantize                    Location;                                          // 0x0010(0x0018)(BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RotationDegrees;                                   // 0x0028(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MarkerId;                                          // 0x002C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint64                                        ActorId;                                           // 0x0030(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int8                                          MarkerClassId;                                     // 0x0038(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bNeedsAutoAttach;                                  // 0x0039(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2A76[0x6];                                     // 0x003A(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   Text;                                              // 0x0040(0x0010)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzMarkerServerData) == 0x000008, "Wrong alignment on FGzMarkerServerData");
static_assert(sizeof(FGzMarkerServerData) == 0x000050, "Wrong size on FGzMarkerServerData");
static_assert(offsetof(FGzMarkerServerData, Location) == 0x000010, "Member 'FGzMarkerServerData::Location' has a wrong offset!");
static_assert(offsetof(FGzMarkerServerData, RotationDegrees) == 0x000028, "Member 'FGzMarkerServerData::RotationDegrees' has a wrong offset!");
static_assert(offsetof(FGzMarkerServerData, MarkerId) == 0x00002C, "Member 'FGzMarkerServerData::MarkerId' has a wrong offset!");
static_assert(offsetof(FGzMarkerServerData, ActorId) == 0x000030, "Member 'FGzMarkerServerData::ActorId' has a wrong offset!");
static_assert(offsetof(FGzMarkerServerData, MarkerClassId) == 0x000038, "Member 'FGzMarkerServerData::MarkerClassId' has a wrong offset!");
static_assert(offsetof(FGzMarkerServerData, bNeedsAutoAttach) == 0x000039, "Member 'FGzMarkerServerData::bNeedsAutoAttach' has a wrong offset!");
static_assert(offsetof(FGzMarkerServerData, Text) == 0x000040, "Member 'FGzMarkerServerData::Text' has a wrong offset!");

// ScriptStruct G01.GzSearchZoneWorldData
// 0x002C (0x0038 - 0x000C)
struct FGzSearchZoneWorldData final : public FFastArraySerializerItem
{
public:
	uint8                                         Pad_2A77[0x4];                                     // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                Position;                                          // 0x0010(0x0018)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Radius;                                            // 0x0028(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SearchZoneTypeId;                                  // 0x002C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SearchZoneId;                                      // 0x0030(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2A78[0x4];                                     // 0x0034(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGzSearchZoneWorldData) == 0x000008, "Wrong alignment on FGzSearchZoneWorldData");
static_assert(sizeof(FGzSearchZoneWorldData) == 0x000038, "Wrong size on FGzSearchZoneWorldData");
static_assert(offsetof(FGzSearchZoneWorldData, Position) == 0x000010, "Member 'FGzSearchZoneWorldData::Position' has a wrong offset!");
static_assert(offsetof(FGzSearchZoneWorldData, Radius) == 0x000028, "Member 'FGzSearchZoneWorldData::Radius' has a wrong offset!");
static_assert(offsetof(FGzSearchZoneWorldData, SearchZoneTypeId) == 0x00002C, "Member 'FGzSearchZoneWorldData::SearchZoneTypeId' has a wrong offset!");
static_assert(offsetof(FGzSearchZoneWorldData, SearchZoneId) == 0x000030, "Member 'FGzSearchZoneWorldData::SearchZoneId' has a wrong offset!");

// ScriptStruct G01.GzServerDiscoveryResultPlayFabInfo
// 0x0020 (0x0020 - 0x0000)
struct FGzServerDiscoveryResultPlayFabInfo final
{
public:
	class FString                                 TitleId;                                           // 0x0000(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 SecretKey;                                         // 0x0010(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzServerDiscoveryResultPlayFabInfo) == 0x000008, "Wrong alignment on FGzServerDiscoveryResultPlayFabInfo");
static_assert(sizeof(FGzServerDiscoveryResultPlayFabInfo) == 0x000020, "Wrong size on FGzServerDiscoveryResultPlayFabInfo");
static_assert(offsetof(FGzServerDiscoveryResultPlayFabInfo, TitleId) == 0x000000, "Member 'FGzServerDiscoveryResultPlayFabInfo::TitleId' has a wrong offset!");
static_assert(offsetof(FGzServerDiscoveryResultPlayFabInfo, SecretKey) == 0x000010, "Member 'FGzServerDiscoveryResultPlayFabInfo::SecretKey' has a wrong offset!");

// ScriptStruct G01.GzMatchEndResult
// 0x0018 (0x0018 - 0x0000)
struct FGzMatchEndResult final
{
public:
	int32                                         WinnerTeamId;                                      // 0x0000(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2A79[0x4];                                     // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FGzMatchEndPlayerResult>        PlayerResults;                                     // 0x0008(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzMatchEndResult) == 0x000008, "Wrong alignment on FGzMatchEndResult");
static_assert(sizeof(FGzMatchEndResult) == 0x000018, "Wrong size on FGzMatchEndResult");
static_assert(offsetof(FGzMatchEndResult, WinnerTeamId) == 0x000000, "Member 'FGzMatchEndResult::WinnerTeamId' has a wrong offset!");
static_assert(offsetof(FGzMatchEndResult, PlayerResults) == 0x000008, "Member 'FGzMatchEndResult::PlayerResults' has a wrong offset!");

// ScriptStruct G01.GzLimbGaugeData
// 0x0028 (0x0028 - 0x0000)
struct FGzLimbGaugeData final
{
public:
	float                                         InitialValue;                                      // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxValue;                                          // 0x0004(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CurrentValue;                                      // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PreviousValue;                                     // 0x000C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FinalValue;                                        // 0x0010(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2A7A[0x4];                                     // 0x0014(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UGzGA_BaseLimbAbility*                  LimbAbility;                                       // 0x0018(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2A7B[0x8];                                     // 0x0020(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGzLimbGaugeData) == 0x000008, "Wrong alignment on FGzLimbGaugeData");
static_assert(sizeof(FGzLimbGaugeData) == 0x000028, "Wrong size on FGzLimbGaugeData");
static_assert(offsetof(FGzLimbGaugeData, InitialValue) == 0x000000, "Member 'FGzLimbGaugeData::InitialValue' has a wrong offset!");
static_assert(offsetof(FGzLimbGaugeData, MaxValue) == 0x000004, "Member 'FGzLimbGaugeData::MaxValue' has a wrong offset!");
static_assert(offsetof(FGzLimbGaugeData, CurrentValue) == 0x000008, "Member 'FGzLimbGaugeData::CurrentValue' has a wrong offset!");
static_assert(offsetof(FGzLimbGaugeData, PreviousValue) == 0x00000C, "Member 'FGzLimbGaugeData::PreviousValue' has a wrong offset!");
static_assert(offsetof(FGzLimbGaugeData, FinalValue) == 0x000010, "Member 'FGzLimbGaugeData::FinalValue' has a wrong offset!");
static_assert(offsetof(FGzLimbGaugeData, LimbAbility) == 0x000018, "Member 'FGzLimbGaugeData::LimbAbility' has a wrong offset!");

// ScriptStruct G01.GzBoundaryZoneParams
// 0x0018 (0x0018 - 0x0000)
struct FGzBoundaryZoneParams final
{
public:
	float                                         MinHeight;                                         // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxHeight;                                         // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMaterialInterface*                     Material;                                          // 0x0008(0x0008)(Edit, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCreateCollision;                                  // 0x0010(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2A7C[0x7];                                     // 0x0011(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGzBoundaryZoneParams) == 0x000008, "Wrong alignment on FGzBoundaryZoneParams");
static_assert(sizeof(FGzBoundaryZoneParams) == 0x000018, "Wrong size on FGzBoundaryZoneParams");
static_assert(offsetof(FGzBoundaryZoneParams, MinHeight) == 0x000000, "Member 'FGzBoundaryZoneParams::MinHeight' has a wrong offset!");
static_assert(offsetof(FGzBoundaryZoneParams, MaxHeight) == 0x000004, "Member 'FGzBoundaryZoneParams::MaxHeight' has a wrong offset!");
static_assert(offsetof(FGzBoundaryZoneParams, Material) == 0x000008, "Member 'FGzBoundaryZoneParams::Material' has a wrong offset!");
static_assert(offsetof(FGzBoundaryZoneParams, bCreateCollision) == 0x000010, "Member 'FGzBoundaryZoneParams::bCreateCollision' has a wrong offset!");

// ScriptStruct G01.GzShootNotificationInfo
// 0x0040 (0x0040 - 0x0000)
struct FGzShootNotificationInfo final
{
public:
	struct FVector_NetQuantize                    ShootingLocation;                                  // 0x0000(0x0018)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UGzGE_BaseDamage>           AttackDamageEffect;                                // 0x0018(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FActorInstanceHandle>           DestructiblesActorHandlers;                        // 0x0020(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FVector_NetQuantize>            DestructiblesPoints;                               // 0x0030(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzShootNotificationInfo) == 0x000008, "Wrong alignment on FGzShootNotificationInfo");
static_assert(sizeof(FGzShootNotificationInfo) == 0x000040, "Wrong size on FGzShootNotificationInfo");
static_assert(offsetof(FGzShootNotificationInfo, ShootingLocation) == 0x000000, "Member 'FGzShootNotificationInfo::ShootingLocation' has a wrong offset!");
static_assert(offsetof(FGzShootNotificationInfo, AttackDamageEffect) == 0x000018, "Member 'FGzShootNotificationInfo::AttackDamageEffect' has a wrong offset!");
static_assert(offsetof(FGzShootNotificationInfo, DestructiblesActorHandlers) == 0x000020, "Member 'FGzShootNotificationInfo::DestructiblesActorHandlers' has a wrong offset!");
static_assert(offsetof(FGzShootNotificationInfo, DestructiblesPoints) == 0x000030, "Member 'FGzShootNotificationInfo::DestructiblesPoints' has a wrong offset!");

// ScriptStruct G01.GzSetVirtualCurrencyResult
// 0x0008 (0x00E8 - 0x00E0)
struct FGzSetVirtualCurrencyResult final : public FGzPlayFabResultBase
{
public:
	uint32                                        CurrencyAmount;                                    // 0x00E0(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         CurrencyType;                                      // 0x00E4(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2A7D[0x3];                                     // 0x00E5(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGzSetVirtualCurrencyResult) == 0x000008, "Wrong alignment on FGzSetVirtualCurrencyResult");
static_assert(sizeof(FGzSetVirtualCurrencyResult) == 0x0000E8, "Wrong size on FGzSetVirtualCurrencyResult");
static_assert(offsetof(FGzSetVirtualCurrencyResult, CurrencyAmount) == 0x0000E0, "Member 'FGzSetVirtualCurrencyResult::CurrencyAmount' has a wrong offset!");
static_assert(offsetof(FGzSetVirtualCurrencyResult, CurrencyType) == 0x0000E4, "Member 'FGzSetVirtualCurrencyResult::CurrencyType' has a wrong offset!");

// ScriptStruct G01.AbilityInputActionBinding
// 0x0004 (0x0004 - 0x0000)
struct alignas(0x04) FAbilityInputActionBinding final
{
public:
	uint8                                         Pad_2A7E[0x4];                                     // 0x0000(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FAbilityInputActionBinding) == 0x000004, "Wrong alignment on FAbilityInputActionBinding");
static_assert(sizeof(FAbilityInputActionBinding) == 0x000004, "Wrong size on FAbilityInputActionBinding");

// ScriptStruct G01.GzLeftHandIKInfo
// 0x0090 (0x0090 - 0x0000)
struct FGzLeftHandIKInfo final
{
public:
	struct FTransform                             LeftHandIKTransform;                               // 0x0000(0x0060)(IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LeftHandIKBlendValue;                              // 0x0060(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2A7F[0x4];                                     // 0x0064(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                JointTargetLocation;                               // 0x0068(0x0018)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LeftHandIKoffsetXValue;                            // 0x0080(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LeftHandIKoffsetYValue;                            // 0x0084(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LeftHandIKoffsetZValue;                            // 0x0088(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2A80[0x4];                                     // 0x008C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGzLeftHandIKInfo) == 0x000010, "Wrong alignment on FGzLeftHandIKInfo");
static_assert(sizeof(FGzLeftHandIKInfo) == 0x000090, "Wrong size on FGzLeftHandIKInfo");
static_assert(offsetof(FGzLeftHandIKInfo, LeftHandIKTransform) == 0x000000, "Member 'FGzLeftHandIKInfo::LeftHandIKTransform' has a wrong offset!");
static_assert(offsetof(FGzLeftHandIKInfo, LeftHandIKBlendValue) == 0x000060, "Member 'FGzLeftHandIKInfo::LeftHandIKBlendValue' has a wrong offset!");
static_assert(offsetof(FGzLeftHandIKInfo, JointTargetLocation) == 0x000068, "Member 'FGzLeftHandIKInfo::JointTargetLocation' has a wrong offset!");
static_assert(offsetof(FGzLeftHandIKInfo, LeftHandIKoffsetXValue) == 0x000080, "Member 'FGzLeftHandIKInfo::LeftHandIKoffsetXValue' has a wrong offset!");
static_assert(offsetof(FGzLeftHandIKInfo, LeftHandIKoffsetYValue) == 0x000084, "Member 'FGzLeftHandIKInfo::LeftHandIKoffsetYValue' has a wrong offset!");
static_assert(offsetof(FGzLeftHandIKInfo, LeftHandIKoffsetZValue) == 0x000088, "Member 'FGzLeftHandIKInfo::LeftHandIKoffsetZValue' has a wrong offset!");

// ScriptStruct G01.GzLoadoutPresetData
// 0x0058 (0x0058 - 0x0000)
struct FGzLoadoutPresetData final
{
public:
	TMap<EGzLoadoutSlots, struct FGzInvItem>      LoadoutSlotDatas;                                  // 0x0000(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	class FName                                   LoadoutName;                                       // 0x0050(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzLoadoutPresetData) == 0x000008, "Wrong alignment on FGzLoadoutPresetData");
static_assert(sizeof(FGzLoadoutPresetData) == 0x000058, "Wrong size on FGzLoadoutPresetData");
static_assert(offsetof(FGzLoadoutPresetData, LoadoutSlotDatas) == 0x000000, "Member 'FGzLoadoutPresetData::LoadoutSlotDatas' has a wrong offset!");
static_assert(offsetof(FGzLoadoutPresetData, LoadoutName) == 0x000050, "Member 'FGzLoadoutPresetData::LoadoutName' has a wrong offset!");

// ScriptStruct G01.GzLoadoutDataConfig
// 0x0070 (0x0070 - 0x0000)
struct FGzLoadoutDataConfig final
{
public:
	struct FGuid                                  LoadoutGuid;                                       // 0x0000(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGzLoadoutPresetData                   PresetData;                                        // 0x0010(0x0058)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	class UGzLoadoutListBase*                     LoadoutList;                                       // 0x0068(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
};
static_assert(alignof(FGzLoadoutDataConfig) == 0x000008, "Wrong alignment on FGzLoadoutDataConfig");
static_assert(sizeof(FGzLoadoutDataConfig) == 0x000070, "Wrong size on FGzLoadoutDataConfig");
static_assert(offsetof(FGzLoadoutDataConfig, LoadoutGuid) == 0x000000, "Member 'FGzLoadoutDataConfig::LoadoutGuid' has a wrong offset!");
static_assert(offsetof(FGzLoadoutDataConfig, PresetData) == 0x000010, "Member 'FGzLoadoutDataConfig::PresetData' has a wrong offset!");
static_assert(offsetof(FGzLoadoutDataConfig, LoadoutList) == 0x000068, "Member 'FGzLoadoutDataConfig::LoadoutList' has a wrong offset!");

// ScriptStruct G01.GzBlockchainMarketLotRemovedNotification
// 0x0020 (0x0040 - 0x0020)
struct FGzBlockchainMarketLotRemovedNotification final : public FGzPlayFabNotification
{
public:
	class FString                                 AssetId;                                           // 0x0020(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 ItemInstanceId;                                    // 0x0030(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzBlockchainMarketLotRemovedNotification) == 0x000008, "Wrong alignment on FGzBlockchainMarketLotRemovedNotification");
static_assert(sizeof(FGzBlockchainMarketLotRemovedNotification) == 0x000040, "Wrong size on FGzBlockchainMarketLotRemovedNotification");
static_assert(offsetof(FGzBlockchainMarketLotRemovedNotification, AssetId) == 0x000020, "Member 'FGzBlockchainMarketLotRemovedNotification::AssetId' has a wrong offset!");
static_assert(offsetof(FGzBlockchainMarketLotRemovedNotification, ItemInstanceId) == 0x000030, "Member 'FGzBlockchainMarketLotRemovedNotification::ItemInstanceId' has a wrong offset!");

// ScriptStruct G01.GzTransformComponent
// 0x0060 (0x0060 - 0x0000)
struct FGzTransformComponent final
{
public:
	struct FTransform                             Transform;                                         // 0x0000(0x0060)(Edit, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzTransformComponent) == 0x000010, "Wrong alignment on FGzTransformComponent");
static_assert(sizeof(FGzTransformComponent) == 0x000060, "Wrong size on FGzTransformComponent");
static_assert(offsetof(FGzTransformComponent, Transform) == 0x000000, "Member 'FGzTransformComponent::Transform' has a wrong offset!");

// ScriptStruct G01.GzVehicleAudioEvent
// 0x0078 (0x0078 - 0x0000)
struct FGzVehicleAudioEvent final
{
public:
	bool                                          bIsEnabled;                                        // 0x0000(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2A81[0x7];                                     // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UAkAudioEvent*                          AkAudioEvent_Start;                                // 0x0008(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAkAudioEvent*                          AkAudioEvent_Stop;                                 // 0x0010(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Socket;                                            // 0x0018(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                LocationOffset;                                    // 0x0020(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bPreventDuplicatePlaying;                          // 0x0038(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bListenToWheelSurfaceSwitch;                       // 0x0039(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bListenToWheelSkidSwitch;                          // 0x003A(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bListenToWheelTurnSwitch;                          // 0x003B(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EGzVehicleAxle                                VehicleAxleSurfaceSource;                          // 0x003C(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUpdateRTPC_RPM;                                   // 0x003D(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2A82[0x2];                                     // 0x003E(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	class UAkRtpc*                                AkRtpc_RPM;                                        // 0x0040(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUpdateRTPC_Speed;                                 // 0x0048(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2A83[0x7];                                     // 0x0049(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UAkRtpc*                                AkRtpc_Speed;                                      // 0x0050(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUpdateRTPC_WheelAngle;                            // 0x0058(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2A84[0x7];                                     // 0x0059(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UAkRtpc*                                AkRtpc_WheelAngle;                                 // 0x0060(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAkComponent*                           AkComponent;                                       // 0x0068(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAkSwitchValue*                         CurrentSwitchValue;                                // 0x0070(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzVehicleAudioEvent) == 0x000008, "Wrong alignment on FGzVehicleAudioEvent");
static_assert(sizeof(FGzVehicleAudioEvent) == 0x000078, "Wrong size on FGzVehicleAudioEvent");
static_assert(offsetof(FGzVehicleAudioEvent, bIsEnabled) == 0x000000, "Member 'FGzVehicleAudioEvent::bIsEnabled' has a wrong offset!");
static_assert(offsetof(FGzVehicleAudioEvent, AkAudioEvent_Start) == 0x000008, "Member 'FGzVehicleAudioEvent::AkAudioEvent_Start' has a wrong offset!");
static_assert(offsetof(FGzVehicleAudioEvent, AkAudioEvent_Stop) == 0x000010, "Member 'FGzVehicleAudioEvent::AkAudioEvent_Stop' has a wrong offset!");
static_assert(offsetof(FGzVehicleAudioEvent, Socket) == 0x000018, "Member 'FGzVehicleAudioEvent::Socket' has a wrong offset!");
static_assert(offsetof(FGzVehicleAudioEvent, LocationOffset) == 0x000020, "Member 'FGzVehicleAudioEvent::LocationOffset' has a wrong offset!");
static_assert(offsetof(FGzVehicleAudioEvent, bPreventDuplicatePlaying) == 0x000038, "Member 'FGzVehicleAudioEvent::bPreventDuplicatePlaying' has a wrong offset!");
static_assert(offsetof(FGzVehicleAudioEvent, bListenToWheelSurfaceSwitch) == 0x000039, "Member 'FGzVehicleAudioEvent::bListenToWheelSurfaceSwitch' has a wrong offset!");
static_assert(offsetof(FGzVehicleAudioEvent, bListenToWheelSkidSwitch) == 0x00003A, "Member 'FGzVehicleAudioEvent::bListenToWheelSkidSwitch' has a wrong offset!");
static_assert(offsetof(FGzVehicleAudioEvent, bListenToWheelTurnSwitch) == 0x00003B, "Member 'FGzVehicleAudioEvent::bListenToWheelTurnSwitch' has a wrong offset!");
static_assert(offsetof(FGzVehicleAudioEvent, VehicleAxleSurfaceSource) == 0x00003C, "Member 'FGzVehicleAudioEvent::VehicleAxleSurfaceSource' has a wrong offset!");
static_assert(offsetof(FGzVehicleAudioEvent, bUpdateRTPC_RPM) == 0x00003D, "Member 'FGzVehicleAudioEvent::bUpdateRTPC_RPM' has a wrong offset!");
static_assert(offsetof(FGzVehicleAudioEvent, AkRtpc_RPM) == 0x000040, "Member 'FGzVehicleAudioEvent::AkRtpc_RPM' has a wrong offset!");
static_assert(offsetof(FGzVehicleAudioEvent, bUpdateRTPC_Speed) == 0x000048, "Member 'FGzVehicleAudioEvent::bUpdateRTPC_Speed' has a wrong offset!");
static_assert(offsetof(FGzVehicleAudioEvent, AkRtpc_Speed) == 0x000050, "Member 'FGzVehicleAudioEvent::AkRtpc_Speed' has a wrong offset!");
static_assert(offsetof(FGzVehicleAudioEvent, bUpdateRTPC_WheelAngle) == 0x000058, "Member 'FGzVehicleAudioEvent::bUpdateRTPC_WheelAngle' has a wrong offset!");
static_assert(offsetof(FGzVehicleAudioEvent, AkRtpc_WheelAngle) == 0x000060, "Member 'FGzVehicleAudioEvent::AkRtpc_WheelAngle' has a wrong offset!");
static_assert(offsetof(FGzVehicleAudioEvent, AkComponent) == 0x000068, "Member 'FGzVehicleAudioEvent::AkComponent' has a wrong offset!");
static_assert(offsetof(FGzVehicleAudioEvent, CurrentSwitchValue) == 0x000070, "Member 'FGzVehicleAudioEvent::CurrentSwitchValue' has a wrong offset!");

// ScriptStruct G01.GzCohtmlBenefitTileInfo
// 0x0030 (0x0030 - 0x0000)
struct FGzCohtmlBenefitTileInfo final
{
public:
	class FString                                 Image;                                             // 0x0000(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   UpperText;                                         // 0x0010(0x0010)(NativeAccessSpecifierPublic)
	class FText                                   LowerText;                                         // 0x0020(0x0010)(NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzCohtmlBenefitTileInfo) == 0x000008, "Wrong alignment on FGzCohtmlBenefitTileInfo");
static_assert(sizeof(FGzCohtmlBenefitTileInfo) == 0x000030, "Wrong size on FGzCohtmlBenefitTileInfo");
static_assert(offsetof(FGzCohtmlBenefitTileInfo, Image) == 0x000000, "Member 'FGzCohtmlBenefitTileInfo::Image' has a wrong offset!");
static_assert(offsetof(FGzCohtmlBenefitTileInfo, UpperText) == 0x000010, "Member 'FGzCohtmlBenefitTileInfo::UpperText' has a wrong offset!");
static_assert(offsetof(FGzCohtmlBenefitTileInfo, LowerText) == 0x000020, "Member 'FGzCohtmlBenefitTileInfo::LowerText' has a wrong offset!");

// ScriptStruct G01.GzCohtmlAccountTypesPreviewInfo
// 0x0030 (0x0030 - 0x0000)
struct FGzCohtmlAccountTypesPreviewInfo final
{
public:
	class FText                                   Summary;                                           // 0x0000(0x0010)(NativeAccessSpecifierPublic)
	class FString                                 BackgroundImage;                                   // 0x0010(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FGzCohtmlBenefitTileInfo>       UpgradeBenefits;                                   // 0x0020(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzCohtmlAccountTypesPreviewInfo) == 0x000008, "Wrong alignment on FGzCohtmlAccountTypesPreviewInfo");
static_assert(sizeof(FGzCohtmlAccountTypesPreviewInfo) == 0x000030, "Wrong size on FGzCohtmlAccountTypesPreviewInfo");
static_assert(offsetof(FGzCohtmlAccountTypesPreviewInfo, Summary) == 0x000000, "Member 'FGzCohtmlAccountTypesPreviewInfo::Summary' has a wrong offset!");
static_assert(offsetof(FGzCohtmlAccountTypesPreviewInfo, BackgroundImage) == 0x000010, "Member 'FGzCohtmlAccountTypesPreviewInfo::BackgroundImage' has a wrong offset!");
static_assert(offsetof(FGzCohtmlAccountTypesPreviewInfo, UpgradeBenefits) == 0x000020, "Member 'FGzCohtmlAccountTypesPreviewInfo::UpgradeBenefits' has a wrong offset!");

// ScriptStruct G01.GzCohtmlAvailableTask
// 0x0018 (0x0018 - 0x0000)
struct FGzCohtmlAvailableTask
{
public:
	class FString                                 ID;                                                // 0x0000(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsCompleted;                                       // 0x0010(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2A85[0x7];                                     // 0x0011(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGzCohtmlAvailableTask) == 0x000008, "Wrong alignment on FGzCohtmlAvailableTask");
static_assert(sizeof(FGzCohtmlAvailableTask) == 0x000018, "Wrong size on FGzCohtmlAvailableTask");
static_assert(offsetof(FGzCohtmlAvailableTask, ID) == 0x000000, "Member 'FGzCohtmlAvailableTask::ID' has a wrong offset!");
static_assert(offsetof(FGzCohtmlAvailableTask, IsCompleted) == 0x000010, "Member 'FGzCohtmlAvailableTask::IsCompleted' has a wrong offset!");

// ScriptStruct G01.GzCohtmlAvailableJob
// 0x0000 (0x0018 - 0x0018)
struct FGzCohtmlAvailableJob final : public FGzCohtmlAvailableTask
{
};
static_assert(alignof(FGzCohtmlAvailableJob) == 0x000008, "Wrong alignment on FGzCohtmlAvailableJob");
static_assert(sizeof(FGzCohtmlAvailableJob) == 0x000018, "Wrong size on FGzCohtmlAvailableJob");

// ScriptStruct G01.GzCohtmlAvailableGoal
// 0x0010 (0x0028 - 0x0018)
struct FGzCohtmlAvailableGoal final : public FGzCohtmlAvailableTask
{
public:
	TArray<struct FGzCohtmlAvailableJob>          Jobs;                                              // 0x0018(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzCohtmlAvailableGoal) == 0x000008, "Wrong alignment on FGzCohtmlAvailableGoal");
static_assert(sizeof(FGzCohtmlAvailableGoal) == 0x000028, "Wrong size on FGzCohtmlAvailableGoal");
static_assert(offsetof(FGzCohtmlAvailableGoal, Jobs) == 0x000018, "Member 'FGzCohtmlAvailableGoal::Jobs' has a wrong offset!");

// ScriptStruct G01.GzShrinkingStageCircle
// 0x0028 (0x0028 - 0x0000)
struct FGzShrinkingStageCircle final
{
public:
	int32                                         StageIndex;                                        // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2A86[0x4];                                     // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGzCircle2D                            Circle;                                            // 0x0008(0x0018)(NoDestructor, NativeAccessSpecifierPublic)
	struct FGameplayTag                           ZoneRevealSourceTag;                               // 0x0020(0x0008)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzShrinkingStageCircle) == 0x000008, "Wrong alignment on FGzShrinkingStageCircle");
static_assert(sizeof(FGzShrinkingStageCircle) == 0x000028, "Wrong size on FGzShrinkingStageCircle");
static_assert(offsetof(FGzShrinkingStageCircle, StageIndex) == 0x000000, "Member 'FGzShrinkingStageCircle::StageIndex' has a wrong offset!");
static_assert(offsetof(FGzShrinkingStageCircle, Circle) == 0x000008, "Member 'FGzShrinkingStageCircle::Circle' has a wrong offset!");
static_assert(offsetof(FGzShrinkingStageCircle, ZoneRevealSourceTag) == 0x000020, "Member 'FGzShrinkingStageCircle::ZoneRevealSourceTag' has a wrong offset!");

// ScriptStruct G01.GzAILOD
// 0x0040 (0x0040 - 0x0000)
struct FGzAILOD final
{
public:
	float                                         Distance;                                          // 0x0000(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ChooseTargetTime;                                  // 0x0004(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinTimeForStandOnPatrolPoints;                     // 0x0008(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          SenseSightEnabled;                                 // 0x000C(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          SenseDamageEnabled;                                // 0x000D(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          SenseHearingEnabled;                               // 0x000E(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          SenseTeamEnabled;                                  // 0x000F(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          SensePredictionEnabled;                            // 0x0010(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          SenseTouchEnabled;                                 // 0x0011(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2A87[0x2];                                     // 0x0012(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ControllerTickInterval;                            // 0x0014(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PathFollowingTickInterval;                         // 0x0018(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PawnTickInterval;                                  // 0x001C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PawnNetUpdateFrequency;                            // 0x0020(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MovementComponentTickInterval;                     // 0x0024(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          MovementModeFly;                                   // 0x0028(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2A88[0x7];                                     // 0x0029(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	double                                        DistanceSqr;                                       // 0x0030(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         ID;                                                // 0x0038(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2A89[0x7];                                     // 0x0039(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGzAILOD) == 0x000008, "Wrong alignment on FGzAILOD");
static_assert(sizeof(FGzAILOD) == 0x000040, "Wrong size on FGzAILOD");
static_assert(offsetof(FGzAILOD, Distance) == 0x000000, "Member 'FGzAILOD::Distance' has a wrong offset!");
static_assert(offsetof(FGzAILOD, ChooseTargetTime) == 0x000004, "Member 'FGzAILOD::ChooseTargetTime' has a wrong offset!");
static_assert(offsetof(FGzAILOD, MinTimeForStandOnPatrolPoints) == 0x000008, "Member 'FGzAILOD::MinTimeForStandOnPatrolPoints' has a wrong offset!");
static_assert(offsetof(FGzAILOD, SenseSightEnabled) == 0x00000C, "Member 'FGzAILOD::SenseSightEnabled' has a wrong offset!");
static_assert(offsetof(FGzAILOD, SenseDamageEnabled) == 0x00000D, "Member 'FGzAILOD::SenseDamageEnabled' has a wrong offset!");
static_assert(offsetof(FGzAILOD, SenseHearingEnabled) == 0x00000E, "Member 'FGzAILOD::SenseHearingEnabled' has a wrong offset!");
static_assert(offsetof(FGzAILOD, SenseTeamEnabled) == 0x00000F, "Member 'FGzAILOD::SenseTeamEnabled' has a wrong offset!");
static_assert(offsetof(FGzAILOD, SensePredictionEnabled) == 0x000010, "Member 'FGzAILOD::SensePredictionEnabled' has a wrong offset!");
static_assert(offsetof(FGzAILOD, SenseTouchEnabled) == 0x000011, "Member 'FGzAILOD::SenseTouchEnabled' has a wrong offset!");
static_assert(offsetof(FGzAILOD, ControllerTickInterval) == 0x000014, "Member 'FGzAILOD::ControllerTickInterval' has a wrong offset!");
static_assert(offsetof(FGzAILOD, PathFollowingTickInterval) == 0x000018, "Member 'FGzAILOD::PathFollowingTickInterval' has a wrong offset!");
static_assert(offsetof(FGzAILOD, PawnTickInterval) == 0x00001C, "Member 'FGzAILOD::PawnTickInterval' has a wrong offset!");
static_assert(offsetof(FGzAILOD, PawnNetUpdateFrequency) == 0x000020, "Member 'FGzAILOD::PawnNetUpdateFrequency' has a wrong offset!");
static_assert(offsetof(FGzAILOD, MovementComponentTickInterval) == 0x000024, "Member 'FGzAILOD::MovementComponentTickInterval' has a wrong offset!");
static_assert(offsetof(FGzAILOD, MovementModeFly) == 0x000028, "Member 'FGzAILOD::MovementModeFly' has a wrong offset!");
static_assert(offsetof(FGzAILOD, DistanceSqr) == 0x000030, "Member 'FGzAILOD::DistanceSqr' has a wrong offset!");
static_assert(offsetof(FGzAILOD, ID) == 0x000038, "Member 'FGzAILOD::ID' has a wrong offset!");

// ScriptStruct G01.GzUnityMatchmakingError
// 0x0018 (0x0018 - 0x0000)
struct FGzUnityMatchmakingError final
{
public:
	EGzUnityMatchmakingErrorType                  Type;                                              // 0x0000(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2A8A[0x7];                                     // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 Description;                                       // 0x0008(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzUnityMatchmakingError) == 0x000008, "Wrong alignment on FGzUnityMatchmakingError");
static_assert(sizeof(FGzUnityMatchmakingError) == 0x000018, "Wrong size on FGzUnityMatchmakingError");
static_assert(offsetof(FGzUnityMatchmakingError, Type) == 0x000000, "Member 'FGzUnityMatchmakingError::Type' has a wrong offset!");
static_assert(offsetof(FGzUnityMatchmakingError, Description) == 0x000008, "Member 'FGzUnityMatchmakingError::Description' has a wrong offset!");

// ScriptStruct G01.GzCohtmlWeaponFamily
// 0x0040 (0x0040 - 0x0000)
struct FGzCohtmlWeaponFamily final
{
public:
	class FString                                 ID;                                                // 0x0000(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   DisplayName;                                       // 0x0010(0x0010)(NativeAccessSpecifierPublic)
	class FText                                   Description;                                       // 0x0020(0x0010)(NativeAccessSpecifierPublic)
	TArray<class FString>                         WeaponIds;                                         // 0x0030(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzCohtmlWeaponFamily) == 0x000008, "Wrong alignment on FGzCohtmlWeaponFamily");
static_assert(sizeof(FGzCohtmlWeaponFamily) == 0x000040, "Wrong size on FGzCohtmlWeaponFamily");
static_assert(offsetof(FGzCohtmlWeaponFamily, ID) == 0x000000, "Member 'FGzCohtmlWeaponFamily::ID' has a wrong offset!");
static_assert(offsetof(FGzCohtmlWeaponFamily, DisplayName) == 0x000010, "Member 'FGzCohtmlWeaponFamily::DisplayName' has a wrong offset!");
static_assert(offsetof(FGzCohtmlWeaponFamily, Description) == 0x000020, "Member 'FGzCohtmlWeaponFamily::Description' has a wrong offset!");
static_assert(offsetof(FGzCohtmlWeaponFamily, WeaponIds) == 0x000030, "Member 'FGzCohtmlWeaponFamily::WeaponIds' has a wrong offset!");

// ScriptStruct G01.GzCohtmlWeaponTypeFamilies
// 0x0050 (0x0050 - 0x0000)
struct FGzCohtmlWeaponTypeFamilies final
{
public:
	TMap<class FString, struct FGzCohtmlWeaponFamily> WeaponFamilies;                                    // 0x0000(0x0050)(NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzCohtmlWeaponTypeFamilies) == 0x000008, "Wrong alignment on FGzCohtmlWeaponTypeFamilies");
static_assert(sizeof(FGzCohtmlWeaponTypeFamilies) == 0x000050, "Wrong size on FGzCohtmlWeaponTypeFamilies");
static_assert(offsetof(FGzCohtmlWeaponTypeFamilies, WeaponFamilies) == 0x000000, "Member 'FGzCohtmlWeaponTypeFamilies::WeaponFamilies' has a wrong offset!");

// ScriptStruct G01.GzIntervalTimer
// 0x0014 (0x0014 - 0x0000)
struct FGzIntervalTimer final
{
public:
	float                                         Interval;                                          // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RandomDeviation;                                   // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2A8B[0xC];                                     // 0x0008(0x000C)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGzIntervalTimer) == 0x000004, "Wrong alignment on FGzIntervalTimer");
static_assert(sizeof(FGzIntervalTimer) == 0x000014, "Wrong size on FGzIntervalTimer");
static_assert(offsetof(FGzIntervalTimer, Interval) == 0x000000, "Member 'FGzIntervalTimer::Interval' has a wrong offset!");
static_assert(offsetof(FGzIntervalTimer, RandomDeviation) == 0x000004, "Member 'FGzIntervalTimer::RandomDeviation' has a wrong offset!");

// ScriptStruct G01.GzCohtmlCriticalMessageButton
// 0x0008 (0x0008 - 0x0000)
struct FGzCohtmlCriticalMessageButton final
{
public:
	EGzCohtmlCriticalMessageButton                Button;                                            // 0x0000(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EGzCohtmlCriticalMessageAction                Action;                                            // 0x0004(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzCohtmlCriticalMessageButton) == 0x000004, "Wrong alignment on FGzCohtmlCriticalMessageButton");
static_assert(sizeof(FGzCohtmlCriticalMessageButton) == 0x000008, "Wrong size on FGzCohtmlCriticalMessageButton");
static_assert(offsetof(FGzCohtmlCriticalMessageButton, Button) == 0x000000, "Member 'FGzCohtmlCriticalMessageButton::Button' has a wrong offset!");
static_assert(offsetof(FGzCohtmlCriticalMessageButton, Action) == 0x000004, "Member 'FGzCohtmlCriticalMessageButton::Action' has a wrong offset!");

// ScriptStruct G01.GzCohtmlCriticalMessageActionConfig
// 0x0010 (0x0010 - 0x0000)
struct FGzCohtmlCriticalMessageActionConfig final
{
public:
	struct FGzCohtmlCriticalMessageButton         PositiveButton;                                    // 0x0000(0x0008)(Edit, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	struct FGzCohtmlCriticalMessageButton         NegativeButton;                                    // 0x0008(0x0008)(Edit, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzCohtmlCriticalMessageActionConfig) == 0x000004, "Wrong alignment on FGzCohtmlCriticalMessageActionConfig");
static_assert(sizeof(FGzCohtmlCriticalMessageActionConfig) == 0x000010, "Wrong size on FGzCohtmlCriticalMessageActionConfig");
static_assert(offsetof(FGzCohtmlCriticalMessageActionConfig, PositiveButton) == 0x000000, "Member 'FGzCohtmlCriticalMessageActionConfig::PositiveButton' has a wrong offset!");
static_assert(offsetof(FGzCohtmlCriticalMessageActionConfig, NegativeButton) == 0x000008, "Member 'FGzCohtmlCriticalMessageActionConfig::NegativeButton' has a wrong offset!");

// ScriptStruct G01.DebugTargetSelection
// 0x0024 (0x0024 - 0x0000)
struct FDebugTargetSelection final
{
public:
	float                                         DistToTarget;                                      // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DamagePerMin;                                      // 0x0004(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DistanceWeight;                                    // 0x0008(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DamageWeight;                                      // 0x000C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         WeaponWeight;                                      // 0x0010(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RatioWeight;                                       // 0x0014(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          HasToken;                                          // 0x0018(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2A8C[0x3];                                     // 0x0019(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         NumAttackers;                                      // 0x001C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CommonWeight;                                      // 0x0020(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDebugTargetSelection) == 0x000004, "Wrong alignment on FDebugTargetSelection");
static_assert(sizeof(FDebugTargetSelection) == 0x000024, "Wrong size on FDebugTargetSelection");
static_assert(offsetof(FDebugTargetSelection, DistToTarget) == 0x000000, "Member 'FDebugTargetSelection::DistToTarget' has a wrong offset!");
static_assert(offsetof(FDebugTargetSelection, DamagePerMin) == 0x000004, "Member 'FDebugTargetSelection::DamagePerMin' has a wrong offset!");
static_assert(offsetof(FDebugTargetSelection, DistanceWeight) == 0x000008, "Member 'FDebugTargetSelection::DistanceWeight' has a wrong offset!");
static_assert(offsetof(FDebugTargetSelection, DamageWeight) == 0x00000C, "Member 'FDebugTargetSelection::DamageWeight' has a wrong offset!");
static_assert(offsetof(FDebugTargetSelection, WeaponWeight) == 0x000010, "Member 'FDebugTargetSelection::WeaponWeight' has a wrong offset!");
static_assert(offsetof(FDebugTargetSelection, RatioWeight) == 0x000014, "Member 'FDebugTargetSelection::RatioWeight' has a wrong offset!");
static_assert(offsetof(FDebugTargetSelection, HasToken) == 0x000018, "Member 'FDebugTargetSelection::HasToken' has a wrong offset!");
static_assert(offsetof(FDebugTargetSelection, NumAttackers) == 0x00001C, "Member 'FDebugTargetSelection::NumAttackers' has a wrong offset!");
static_assert(offsetof(FDebugTargetSelection, CommonWeight) == 0x000020, "Member 'FDebugTargetSelection::CommonWeight' has a wrong offset!");

// ScriptStruct G01.LeglessStanceData
// 0x0001 (0x0001 - 0x0000)
struct FLeglessStanceData final
{
public:
	bool                                          IsAiming;                                          // 0x0000(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FLeglessStanceData) == 0x000001, "Wrong alignment on FLeglessStanceData");
static_assert(sizeof(FLeglessStanceData) == 0x000001, "Wrong size on FLeglessStanceData");
static_assert(offsetof(FLeglessStanceData, IsAiming) == 0x000000, "Member 'FLeglessStanceData::IsAiming' has a wrong offset!");

// ScriptStruct G01.GzMetaMarketplacePagingInfo
// 0x000C (0x000C - 0x0000)
struct FGzMetaMarketplacePagingInfo final
{
public:
	int32                                         CurrentPage;                                       // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         PageSize;                                          // 0x0004(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bHasNextPage;                                      // 0x0008(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2A8D[0x3];                                     // 0x0009(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGzMetaMarketplacePagingInfo) == 0x000004, "Wrong alignment on FGzMetaMarketplacePagingInfo");
static_assert(sizeof(FGzMetaMarketplacePagingInfo) == 0x00000C, "Wrong size on FGzMetaMarketplacePagingInfo");
static_assert(offsetof(FGzMetaMarketplacePagingInfo, CurrentPage) == 0x000000, "Member 'FGzMetaMarketplacePagingInfo::CurrentPage' has a wrong offset!");
static_assert(offsetof(FGzMetaMarketplacePagingInfo, PageSize) == 0x000004, "Member 'FGzMetaMarketplacePagingInfo::PageSize' has a wrong offset!");
static_assert(offsetof(FGzMetaMarketplacePagingInfo, bHasNextPage) == 0x000008, "Member 'FGzMetaMarketplacePagingInfo::bHasNextPage' has a wrong offset!");

// ScriptStruct G01.GzResultPublishWeaponConfigurations
// 0x0000 (0x00E0 - 0x00E0)
struct FGzResultPublishWeaponConfigurations final : public FGzPlayFabResultBase
{
};
static_assert(alignof(FGzResultPublishWeaponConfigurations) == 0x000008, "Wrong alignment on FGzResultPublishWeaponConfigurations");
static_assert(sizeof(FGzResultPublishWeaponConfigurations) == 0x0000E0, "Wrong size on FGzResultPublishWeaponConfigurations");

// ScriptStruct G01.AnimCache
// 0x0218 (0x0218 - 0x0000)
struct FAnimCache final
{
public:
	struct FRotator                               WorldRotation;                                     // 0x0000(0x0018)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	float                                         YawDeltaSinceLastUpdate;                           // 0x0018(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AdditiveLeanAngle;                                 // 0x001C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         YawDeltaSpeed;                                     // 0x0020(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2A8E[0x4];                                     // 0x0024(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                WorldLocation;                                     // 0x0028(0x0018)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                MeshWorldLocation;                                 // 0x0040(0x0018)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsSimulatedProxy;                                  // 0x0058(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2A8F[0x3];                                     // 0x0059(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         DisplacementSinceLastUpdate;                       // 0x005C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DisplacementSpeed;                                 // 0x0060(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2A90[0x4];                                     // 0x0064(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                WorldVelocity;                                     // 0x0068(0x0018)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                LocalVelocity2D;                                   // 0x0080(0x0018)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LocalVelocityDirectionAngle;                       // 0x0098(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LocalVelocityDirectionAngleWithOffset;             // 0x009C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECardinalDirectionType                        LocalVelocityDirection;                            // 0x00A0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECardinalDirectionType                        LocalVelocityDirectionNoOffset;                    // 0x00A1(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          HasVelocity;                                       // 0x00A2(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2A91[0x5];                                     // 0x00A3(0x0005)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                LocalAcceleration2D;                               // 0x00A8(0x0018)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          HasAcceleration;                                   // 0x00C0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          WasMovingLastUpdate;                               // 0x00C1(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2A92[0x6];                                     // 0x00C2(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                PivotDirection2D;                                  // 0x00C8(0x0018)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsOnGround;                                        // 0x00E0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsKnockDown;                                       // 0x00E1(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsCrouching;                                       // 0x00E2(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          CrouchStateChange;                                 // 0x00E3(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          SlidingStateChange;                                // 0x00E4(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ADSStateChanged;                                   // 0x00E5(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          WasADSLastUpdate;                                  // 0x00E6(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2A93[0x1];                                     // 0x00E7(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         TimeSinceFiredWeapon;                              // 0x00E8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsJumping;                                         // 0x00EC(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsFalling;                                         // 0x00ED(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsParaFalling;                                     // 0x00EE(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsSprinting;                                       // 0x00EF(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsSliding;                                         // 0x00F0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2A94[0x3];                                     // 0x00F1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         TimeToJumpApex;                                    // 0x00F4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsRunningIntoWall;                                 // 0x00F8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsSuperSprinting;                                  // 0x00F9(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EGzGrappleHookState                           GrappleHookState;                                  // 0x00FA(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2A95[0x5];                                     // 0x00FB(0x0005)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                GrapplePullTargetLocation;                         // 0x0100(0x0018)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                GrapplePullTargetNormal;                           // 0x0118(0x0018)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                CharacterToPullTargetDirection;                    // 0x0130(0x0018)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         GrappleDistanceToHook;                             // 0x0148(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         GrapplePullTravelProgress;                         // 0x014C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EGzLimbTypeFlags                              ActiveGrappleLimbType;                             // 0x0150(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECardinalDirectionType                        StartDirection;                                    // 0x0151(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECardinalDirectionType                        PivotInitialDirection;                             // 0x0152(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2A96[0x1];                                     // 0x0153(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         LastPivotTime;                                     // 0x0154(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECardinalDirectionType                        CardinalDirectionFromAcceleration;                 // 0x0158(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2A97[0x3];                                     // 0x0159(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         UpperbodyDynamicAdditiveWeight;                    // 0x015C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AimPitch;                                          // 0x0160(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AimYaw;                                            // 0x0164(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CardinalDirectionDeadZone;                         // 0x0168(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          LinkedLayerChanged;                                // 0x016C(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2A98[0x3];                                     // 0x016D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class UAnimInstance*                          LastLinkedLayer;                                   // 0x0170(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RootYawOffset;                                     // 0x0178(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FFloatSpringState                      RootYawOffsetSpringState;                          // 0x017C(0x000C)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	float                                         TurnYawCurveValue;                                 // 0x0188(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PreviousTurnYawCurveValue;                         // 0x018C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ERootYawOffsetType                            RootYawOffsetMode;                                 // 0x0190(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2A99[0x7];                                     // 0x0191(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector2D                              RootYawOffsetAngleClamp;                           // 0x0198(0x0010)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              RootYawOffsetAngleClampCrouched;                   // 0x01A8(0x0010)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              RootYawOffsetAngleClampLegless;                    // 0x01B8(0x0010)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsFirstUpdate;                                     // 0x01C8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          EnableControlRig;                                  // 0x01C9(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          UseFootPlacement;                                  // 0x01CA(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          EnableRootYawOffset;                               // 0x01CB(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          UseRightShoulderAim;                               // 0x01CC(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          RightArmExists;                                    // 0x01CD(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EAnimStances                                  AnimStance;                                        // 0x01CE(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EAnimStances                                  PrevAnimStance;                                    // 0x01CF(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AnimStanceBlendValue;                              // 0x01D0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         WingsuitPitch;                                     // 0x01D4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         WingsuitPitchTarget;                               // 0x01D8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ELeanType                                     LeanMode;                                          // 0x01DC(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLeglessStanceData                     LeglessStanceData;                                 // 0x01DD(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, NoDestructor, NativeAccessSpecifierPublic)
	EGzWeaponSupportHoldType                      WeaponGripType;                                    // 0x01DE(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2A9A[0x1];                                     // 0x01DF(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         LimbStateFlags;                                    // 0x01E0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EGzLimbType                                   ActiveLimbType;                                    // 0x01E4(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2A9B[0x3];                                     // 0x01E5(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                TargetPoint;                                       // 0x01E8(0x0018)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                TargetPointWithoutCorrection;                      // 0x0200(0x0018)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAnimCache) == 0x000008, "Wrong alignment on FAnimCache");
static_assert(sizeof(FAnimCache) == 0x000218, "Wrong size on FAnimCache");
static_assert(offsetof(FAnimCache, WorldRotation) == 0x000000, "Member 'FAnimCache::WorldRotation' has a wrong offset!");
static_assert(offsetof(FAnimCache, YawDeltaSinceLastUpdate) == 0x000018, "Member 'FAnimCache::YawDeltaSinceLastUpdate' has a wrong offset!");
static_assert(offsetof(FAnimCache, AdditiveLeanAngle) == 0x00001C, "Member 'FAnimCache::AdditiveLeanAngle' has a wrong offset!");
static_assert(offsetof(FAnimCache, YawDeltaSpeed) == 0x000020, "Member 'FAnimCache::YawDeltaSpeed' has a wrong offset!");
static_assert(offsetof(FAnimCache, WorldLocation) == 0x000028, "Member 'FAnimCache::WorldLocation' has a wrong offset!");
static_assert(offsetof(FAnimCache, MeshWorldLocation) == 0x000040, "Member 'FAnimCache::MeshWorldLocation' has a wrong offset!");
static_assert(offsetof(FAnimCache, IsSimulatedProxy) == 0x000058, "Member 'FAnimCache::IsSimulatedProxy' has a wrong offset!");
static_assert(offsetof(FAnimCache, DisplacementSinceLastUpdate) == 0x00005C, "Member 'FAnimCache::DisplacementSinceLastUpdate' has a wrong offset!");
static_assert(offsetof(FAnimCache, DisplacementSpeed) == 0x000060, "Member 'FAnimCache::DisplacementSpeed' has a wrong offset!");
static_assert(offsetof(FAnimCache, WorldVelocity) == 0x000068, "Member 'FAnimCache::WorldVelocity' has a wrong offset!");
static_assert(offsetof(FAnimCache, LocalVelocity2D) == 0x000080, "Member 'FAnimCache::LocalVelocity2D' has a wrong offset!");
static_assert(offsetof(FAnimCache, LocalVelocityDirectionAngle) == 0x000098, "Member 'FAnimCache::LocalVelocityDirectionAngle' has a wrong offset!");
static_assert(offsetof(FAnimCache, LocalVelocityDirectionAngleWithOffset) == 0x00009C, "Member 'FAnimCache::LocalVelocityDirectionAngleWithOffset' has a wrong offset!");
static_assert(offsetof(FAnimCache, LocalVelocityDirection) == 0x0000A0, "Member 'FAnimCache::LocalVelocityDirection' has a wrong offset!");
static_assert(offsetof(FAnimCache, LocalVelocityDirectionNoOffset) == 0x0000A1, "Member 'FAnimCache::LocalVelocityDirectionNoOffset' has a wrong offset!");
static_assert(offsetof(FAnimCache, HasVelocity) == 0x0000A2, "Member 'FAnimCache::HasVelocity' has a wrong offset!");
static_assert(offsetof(FAnimCache, LocalAcceleration2D) == 0x0000A8, "Member 'FAnimCache::LocalAcceleration2D' has a wrong offset!");
static_assert(offsetof(FAnimCache, HasAcceleration) == 0x0000C0, "Member 'FAnimCache::HasAcceleration' has a wrong offset!");
static_assert(offsetof(FAnimCache, WasMovingLastUpdate) == 0x0000C1, "Member 'FAnimCache::WasMovingLastUpdate' has a wrong offset!");
static_assert(offsetof(FAnimCache, PivotDirection2D) == 0x0000C8, "Member 'FAnimCache::PivotDirection2D' has a wrong offset!");
static_assert(offsetof(FAnimCache, IsOnGround) == 0x0000E0, "Member 'FAnimCache::IsOnGround' has a wrong offset!");
static_assert(offsetof(FAnimCache, IsKnockDown) == 0x0000E1, "Member 'FAnimCache::IsKnockDown' has a wrong offset!");
static_assert(offsetof(FAnimCache, IsCrouching) == 0x0000E2, "Member 'FAnimCache::IsCrouching' has a wrong offset!");
static_assert(offsetof(FAnimCache, CrouchStateChange) == 0x0000E3, "Member 'FAnimCache::CrouchStateChange' has a wrong offset!");
static_assert(offsetof(FAnimCache, SlidingStateChange) == 0x0000E4, "Member 'FAnimCache::SlidingStateChange' has a wrong offset!");
static_assert(offsetof(FAnimCache, ADSStateChanged) == 0x0000E5, "Member 'FAnimCache::ADSStateChanged' has a wrong offset!");
static_assert(offsetof(FAnimCache, WasADSLastUpdate) == 0x0000E6, "Member 'FAnimCache::WasADSLastUpdate' has a wrong offset!");
static_assert(offsetof(FAnimCache, TimeSinceFiredWeapon) == 0x0000E8, "Member 'FAnimCache::TimeSinceFiredWeapon' has a wrong offset!");
static_assert(offsetof(FAnimCache, IsJumping) == 0x0000EC, "Member 'FAnimCache::IsJumping' has a wrong offset!");
static_assert(offsetof(FAnimCache, IsFalling) == 0x0000ED, "Member 'FAnimCache::IsFalling' has a wrong offset!");
static_assert(offsetof(FAnimCache, IsParaFalling) == 0x0000EE, "Member 'FAnimCache::IsParaFalling' has a wrong offset!");
static_assert(offsetof(FAnimCache, IsSprinting) == 0x0000EF, "Member 'FAnimCache::IsSprinting' has a wrong offset!");
static_assert(offsetof(FAnimCache, IsSliding) == 0x0000F0, "Member 'FAnimCache::IsSliding' has a wrong offset!");
static_assert(offsetof(FAnimCache, TimeToJumpApex) == 0x0000F4, "Member 'FAnimCache::TimeToJumpApex' has a wrong offset!");
static_assert(offsetof(FAnimCache, IsRunningIntoWall) == 0x0000F8, "Member 'FAnimCache::IsRunningIntoWall' has a wrong offset!");
static_assert(offsetof(FAnimCache, IsSuperSprinting) == 0x0000F9, "Member 'FAnimCache::IsSuperSprinting' has a wrong offset!");
static_assert(offsetof(FAnimCache, GrappleHookState) == 0x0000FA, "Member 'FAnimCache::GrappleHookState' has a wrong offset!");
static_assert(offsetof(FAnimCache, GrapplePullTargetLocation) == 0x000100, "Member 'FAnimCache::GrapplePullTargetLocation' has a wrong offset!");
static_assert(offsetof(FAnimCache, GrapplePullTargetNormal) == 0x000118, "Member 'FAnimCache::GrapplePullTargetNormal' has a wrong offset!");
static_assert(offsetof(FAnimCache, CharacterToPullTargetDirection) == 0x000130, "Member 'FAnimCache::CharacterToPullTargetDirection' has a wrong offset!");
static_assert(offsetof(FAnimCache, GrappleDistanceToHook) == 0x000148, "Member 'FAnimCache::GrappleDistanceToHook' has a wrong offset!");
static_assert(offsetof(FAnimCache, GrapplePullTravelProgress) == 0x00014C, "Member 'FAnimCache::GrapplePullTravelProgress' has a wrong offset!");
static_assert(offsetof(FAnimCache, ActiveGrappleLimbType) == 0x000150, "Member 'FAnimCache::ActiveGrappleLimbType' has a wrong offset!");
static_assert(offsetof(FAnimCache, StartDirection) == 0x000151, "Member 'FAnimCache::StartDirection' has a wrong offset!");
static_assert(offsetof(FAnimCache, PivotInitialDirection) == 0x000152, "Member 'FAnimCache::PivotInitialDirection' has a wrong offset!");
static_assert(offsetof(FAnimCache, LastPivotTime) == 0x000154, "Member 'FAnimCache::LastPivotTime' has a wrong offset!");
static_assert(offsetof(FAnimCache, CardinalDirectionFromAcceleration) == 0x000158, "Member 'FAnimCache::CardinalDirectionFromAcceleration' has a wrong offset!");
static_assert(offsetof(FAnimCache, UpperbodyDynamicAdditiveWeight) == 0x00015C, "Member 'FAnimCache::UpperbodyDynamicAdditiveWeight' has a wrong offset!");
static_assert(offsetof(FAnimCache, AimPitch) == 0x000160, "Member 'FAnimCache::AimPitch' has a wrong offset!");
static_assert(offsetof(FAnimCache, AimYaw) == 0x000164, "Member 'FAnimCache::AimYaw' has a wrong offset!");
static_assert(offsetof(FAnimCache, CardinalDirectionDeadZone) == 0x000168, "Member 'FAnimCache::CardinalDirectionDeadZone' has a wrong offset!");
static_assert(offsetof(FAnimCache, LinkedLayerChanged) == 0x00016C, "Member 'FAnimCache::LinkedLayerChanged' has a wrong offset!");
static_assert(offsetof(FAnimCache, LastLinkedLayer) == 0x000170, "Member 'FAnimCache::LastLinkedLayer' has a wrong offset!");
static_assert(offsetof(FAnimCache, RootYawOffset) == 0x000178, "Member 'FAnimCache::RootYawOffset' has a wrong offset!");
static_assert(offsetof(FAnimCache, RootYawOffsetSpringState) == 0x00017C, "Member 'FAnimCache::RootYawOffsetSpringState' has a wrong offset!");
static_assert(offsetof(FAnimCache, TurnYawCurveValue) == 0x000188, "Member 'FAnimCache::TurnYawCurveValue' has a wrong offset!");
static_assert(offsetof(FAnimCache, PreviousTurnYawCurveValue) == 0x00018C, "Member 'FAnimCache::PreviousTurnYawCurveValue' has a wrong offset!");
static_assert(offsetof(FAnimCache, RootYawOffsetMode) == 0x000190, "Member 'FAnimCache::RootYawOffsetMode' has a wrong offset!");
static_assert(offsetof(FAnimCache, RootYawOffsetAngleClamp) == 0x000198, "Member 'FAnimCache::RootYawOffsetAngleClamp' has a wrong offset!");
static_assert(offsetof(FAnimCache, RootYawOffsetAngleClampCrouched) == 0x0001A8, "Member 'FAnimCache::RootYawOffsetAngleClampCrouched' has a wrong offset!");
static_assert(offsetof(FAnimCache, RootYawOffsetAngleClampLegless) == 0x0001B8, "Member 'FAnimCache::RootYawOffsetAngleClampLegless' has a wrong offset!");
static_assert(offsetof(FAnimCache, IsFirstUpdate) == 0x0001C8, "Member 'FAnimCache::IsFirstUpdate' has a wrong offset!");
static_assert(offsetof(FAnimCache, EnableControlRig) == 0x0001C9, "Member 'FAnimCache::EnableControlRig' has a wrong offset!");
static_assert(offsetof(FAnimCache, UseFootPlacement) == 0x0001CA, "Member 'FAnimCache::UseFootPlacement' has a wrong offset!");
static_assert(offsetof(FAnimCache, EnableRootYawOffset) == 0x0001CB, "Member 'FAnimCache::EnableRootYawOffset' has a wrong offset!");
static_assert(offsetof(FAnimCache, UseRightShoulderAim) == 0x0001CC, "Member 'FAnimCache::UseRightShoulderAim' has a wrong offset!");
static_assert(offsetof(FAnimCache, RightArmExists) == 0x0001CD, "Member 'FAnimCache::RightArmExists' has a wrong offset!");
static_assert(offsetof(FAnimCache, AnimStance) == 0x0001CE, "Member 'FAnimCache::AnimStance' has a wrong offset!");
static_assert(offsetof(FAnimCache, PrevAnimStance) == 0x0001CF, "Member 'FAnimCache::PrevAnimStance' has a wrong offset!");
static_assert(offsetof(FAnimCache, AnimStanceBlendValue) == 0x0001D0, "Member 'FAnimCache::AnimStanceBlendValue' has a wrong offset!");
static_assert(offsetof(FAnimCache, WingsuitPitch) == 0x0001D4, "Member 'FAnimCache::WingsuitPitch' has a wrong offset!");
static_assert(offsetof(FAnimCache, WingsuitPitchTarget) == 0x0001D8, "Member 'FAnimCache::WingsuitPitchTarget' has a wrong offset!");
static_assert(offsetof(FAnimCache, LeanMode) == 0x0001DC, "Member 'FAnimCache::LeanMode' has a wrong offset!");
static_assert(offsetof(FAnimCache, LeglessStanceData) == 0x0001DD, "Member 'FAnimCache::LeglessStanceData' has a wrong offset!");
static_assert(offsetof(FAnimCache, WeaponGripType) == 0x0001DE, "Member 'FAnimCache::WeaponGripType' has a wrong offset!");
static_assert(offsetof(FAnimCache, LimbStateFlags) == 0x0001E0, "Member 'FAnimCache::LimbStateFlags' has a wrong offset!");
static_assert(offsetof(FAnimCache, ActiveLimbType) == 0x0001E4, "Member 'FAnimCache::ActiveLimbType' has a wrong offset!");
static_assert(offsetof(FAnimCache, TargetPoint) == 0x0001E8, "Member 'FAnimCache::TargetPoint' has a wrong offset!");
static_assert(offsetof(FAnimCache, TargetPointWithoutCorrection) == 0x000200, "Member 'FAnimCache::TargetPointWithoutCorrection' has a wrong offset!");

// ScriptStruct G01.AnimAbilityData
// 0x0040 (0x0040 - 0x0000)
struct FAnimAbilityData final
{
public:
	bool                                          IsActive;                                          // 0x0000(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2A9C[0x7];                                     // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftClassPtr<class UClass>                   AnimInstance;                                      // 0x0008(0x0028)(BlueprintVisible, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BlendWeight;                                       // 0x0030(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BlendInSpeed;                                      // 0x0034(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BlendOutSpeed;                                     // 0x0038(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2A9D[0x4];                                     // 0x003C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FAnimAbilityData) == 0x000008, "Wrong alignment on FAnimAbilityData");
static_assert(sizeof(FAnimAbilityData) == 0x000040, "Wrong size on FAnimAbilityData");
static_assert(offsetof(FAnimAbilityData, IsActive) == 0x000000, "Member 'FAnimAbilityData::IsActive' has a wrong offset!");
static_assert(offsetof(FAnimAbilityData, AnimInstance) == 0x000008, "Member 'FAnimAbilityData::AnimInstance' has a wrong offset!");
static_assert(offsetof(FAnimAbilityData, BlendWeight) == 0x000030, "Member 'FAnimAbilityData::BlendWeight' has a wrong offset!");
static_assert(offsetof(FAnimAbilityData, BlendInSpeed) == 0x000034, "Member 'FAnimAbilityData::BlendInSpeed' has a wrong offset!");
static_assert(offsetof(FAnimAbilityData, BlendOutSpeed) == 0x000038, "Member 'FAnimAbilityData::BlendOutSpeed' has a wrong offset!");

// ScriptStruct G01.GzCheatGrantXpPackage
// 0x0008 (0x0070 - 0x0068)
struct FGzCheatGrantXpPackage final : public FGzPlayFabClientPackage
{
public:
	int32                                         PlayerXp;                                          // 0x0068(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         BattlePassXp;                                      // 0x006C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzCheatGrantXpPackage) == 0x000008, "Wrong alignment on FGzCheatGrantXpPackage");
static_assert(sizeof(FGzCheatGrantXpPackage) == 0x000070, "Wrong size on FGzCheatGrantXpPackage");
static_assert(offsetof(FGzCheatGrantXpPackage, PlayerXp) == 0x000068, "Member 'FGzCheatGrantXpPackage::PlayerXp' has a wrong offset!");
static_assert(offsetof(FGzCheatGrantXpPackage, BattlePassXp) == 0x00006C, "Member 'FGzCheatGrantXpPackage::BattlePassXp' has a wrong offset!");

// ScriptStruct G01.GzAnimHitReactionData
// 0x0028 (0x0028 - 0x0000)
struct FGzAnimHitReactionData final
{
public:
	struct FVector                                HitDirection;                                      // 0x0000(0x0018)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HitPowerValue;                                     // 0x0018(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EGzCharacterDamageAreaType                    HitAreaType;                                       // 0x001C(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2A9E[0x3];                                     // 0x001D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Timer;                                             // 0x0020(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2A9F[0x4];                                     // 0x0024(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGzAnimHitReactionData) == 0x000008, "Wrong alignment on FGzAnimHitReactionData");
static_assert(sizeof(FGzAnimHitReactionData) == 0x000028, "Wrong size on FGzAnimHitReactionData");
static_assert(offsetof(FGzAnimHitReactionData, HitDirection) == 0x000000, "Member 'FGzAnimHitReactionData::HitDirection' has a wrong offset!");
static_assert(offsetof(FGzAnimHitReactionData, HitPowerValue) == 0x000018, "Member 'FGzAnimHitReactionData::HitPowerValue' has a wrong offset!");
static_assert(offsetof(FGzAnimHitReactionData, HitAreaType) == 0x00001C, "Member 'FGzAnimHitReactionData::HitAreaType' has a wrong offset!");
static_assert(offsetof(FGzAnimHitReactionData, Timer) == 0x000020, "Member 'FGzAnimHitReactionData::Timer' has a wrong offset!");

// ScriptStruct G01.GzBodyPartType
// 0x0008 (0x0008 - 0x0000)
struct FGzBodyPartType final
{
public:
	int32                                         Mask;                                              // 0x0000(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAnyState;                                         // 0x0004(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2AA0[0x3];                                     // 0x0005(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGzBodyPartType) == 0x000004, "Wrong alignment on FGzBodyPartType");
static_assert(sizeof(FGzBodyPartType) == 0x000008, "Wrong size on FGzBodyPartType");
static_assert(offsetof(FGzBodyPartType, Mask) == 0x000000, "Member 'FGzBodyPartType::Mask' has a wrong offset!");
static_assert(offsetof(FGzBodyPartType, bAnyState) == 0x000004, "Member 'FGzBodyPartType::bAnyState' has a wrong offset!");

// ScriptStruct G01.GzMovementManagerCharacterStateData
// 0x0040 (0x0040 - 0x0000)
struct FGzMovementManagerCharacterStateData final
{
public:
	struct FGzBodyPartType                        LimbState;                                         // 0x0000(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	EGzCharacterAliveState                        AliveState;                                        // 0x0008(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EGzAdvancedLocomotionState                    AdvancedState;                                     // 0x0009(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2AA1[0x2];                                     // 0x000A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MaxSpeed;                                          // 0x000C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCurveFloat*                            MaxSpeedCurve;                                     // 0x0010(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseCurveForStrafe;                                // 0x0018(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2AA2[0x7];                                     // 0x0019(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UCurveFloat*                            MaxSpeedOnStrafeCurve;                             // 0x0020(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxSpeedOnStrafe;                                  // 0x0028(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxBackwardSpeed;                                  // 0x002C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BreakingVelocity;                                  // 0x0030(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2AA3[0x4];                                     // 0x0034(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UCurveFloat*                            AccelerationRateCurve;                             // 0x0038(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzMovementManagerCharacterStateData) == 0x000008, "Wrong alignment on FGzMovementManagerCharacterStateData");
static_assert(sizeof(FGzMovementManagerCharacterStateData) == 0x000040, "Wrong size on FGzMovementManagerCharacterStateData");
static_assert(offsetof(FGzMovementManagerCharacterStateData, LimbState) == 0x000000, "Member 'FGzMovementManagerCharacterStateData::LimbState' has a wrong offset!");
static_assert(offsetof(FGzMovementManagerCharacterStateData, AliveState) == 0x000008, "Member 'FGzMovementManagerCharacterStateData::AliveState' has a wrong offset!");
static_assert(offsetof(FGzMovementManagerCharacterStateData, AdvancedState) == 0x000009, "Member 'FGzMovementManagerCharacterStateData::AdvancedState' has a wrong offset!");
static_assert(offsetof(FGzMovementManagerCharacterStateData, MaxSpeed) == 0x00000C, "Member 'FGzMovementManagerCharacterStateData::MaxSpeed' has a wrong offset!");
static_assert(offsetof(FGzMovementManagerCharacterStateData, MaxSpeedCurve) == 0x000010, "Member 'FGzMovementManagerCharacterStateData::MaxSpeedCurve' has a wrong offset!");
static_assert(offsetof(FGzMovementManagerCharacterStateData, bUseCurveForStrafe) == 0x000018, "Member 'FGzMovementManagerCharacterStateData::bUseCurveForStrafe' has a wrong offset!");
static_assert(offsetof(FGzMovementManagerCharacterStateData, MaxSpeedOnStrafeCurve) == 0x000020, "Member 'FGzMovementManagerCharacterStateData::MaxSpeedOnStrafeCurve' has a wrong offset!");
static_assert(offsetof(FGzMovementManagerCharacterStateData, MaxSpeedOnStrafe) == 0x000028, "Member 'FGzMovementManagerCharacterStateData::MaxSpeedOnStrafe' has a wrong offset!");
static_assert(offsetof(FGzMovementManagerCharacterStateData, MaxBackwardSpeed) == 0x00002C, "Member 'FGzMovementManagerCharacterStateData::MaxBackwardSpeed' has a wrong offset!");
static_assert(offsetof(FGzMovementManagerCharacterStateData, BreakingVelocity) == 0x000030, "Member 'FGzMovementManagerCharacterStateData::BreakingVelocity' has a wrong offset!");
static_assert(offsetof(FGzMovementManagerCharacterStateData, AccelerationRateCurve) == 0x000038, "Member 'FGzMovementManagerCharacterStateData::AccelerationRateCurve' has a wrong offset!");

// ScriptStruct G01.GzMovementManagerLocomotionState
// 0x0018 (0x0018 - 0x0000)
struct FGzMovementManagerLocomotionState final
{
public:
	TSubclassOf<class UGzGameplayAbility>         Ability;                                           // 0x0000(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FGzMovementManagerCharacterStateData> Data;                                              // 0x0008(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzMovementManagerLocomotionState) == 0x000008, "Wrong alignment on FGzMovementManagerLocomotionState");
static_assert(sizeof(FGzMovementManagerLocomotionState) == 0x000018, "Wrong size on FGzMovementManagerLocomotionState");
static_assert(offsetof(FGzMovementManagerLocomotionState, Ability) == 0x000000, "Member 'FGzMovementManagerLocomotionState::Ability' has a wrong offset!");
static_assert(offsetof(FGzMovementManagerLocomotionState, Data) == 0x000008, "Member 'FGzMovementManagerLocomotionState::Data' has a wrong offset!");

// ScriptStruct G01.GzIKTransformInfo
// 0x0050 (0x0050 - 0x0000)
struct FGzIKTransformInfo final
{
public:
	struct FVector                                IKGroundLocation;                                  // 0x0000(0x0018)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                IKGroundNormal;                                    // 0x0018(0x0018)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FQuat                                  IKRotation;                                        // 0x0030(0x0020)(BlueprintVisible, BlueprintReadOnly, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzIKTransformInfo) == 0x000010, "Wrong alignment on FGzIKTransformInfo");
static_assert(sizeof(FGzIKTransformInfo) == 0x000050, "Wrong size on FGzIKTransformInfo");
static_assert(offsetof(FGzIKTransformInfo, IKGroundLocation) == 0x000000, "Member 'FGzIKTransformInfo::IKGroundLocation' has a wrong offset!");
static_assert(offsetof(FGzIKTransformInfo, IKGroundNormal) == 0x000018, "Member 'FGzIKTransformInfo::IKGroundNormal' has a wrong offset!");
static_assert(offsetof(FGzIKTransformInfo, IKRotation) == 0x000030, "Member 'FGzIKTransformInfo::IKRotation' has a wrong offset!");

// ScriptStruct G01.GzMannequinSetupInstance
// 0x0030 (0x0030 - 0x0000)
struct FGzMannequinSetupInstance final
{
public:
	TSoftObjectPtr<class USkeletalMesh>           Mesh;                                              // 0x0000(0x0028)(Edit, DisableEditOnTemplate, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShowOnPreview;                                    // 0x0028(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2AA4[0x7];                                     // 0x0029(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGzMannequinSetupInstance) == 0x000008, "Wrong alignment on FGzMannequinSetupInstance");
static_assert(sizeof(FGzMannequinSetupInstance) == 0x000030, "Wrong size on FGzMannequinSetupInstance");
static_assert(offsetof(FGzMannequinSetupInstance, Mesh) == 0x000000, "Member 'FGzMannequinSetupInstance::Mesh' has a wrong offset!");
static_assert(offsetof(FGzMannequinSetupInstance, bShowOnPreview) == 0x000028, "Member 'FGzMannequinSetupInstance::bShowOnPreview' has a wrong offset!");

// ScriptStruct G01.GzViewemakerSetupWithMannequin
// 0x0030 (0x0058 - 0x0028)
struct FGzViewemakerSetupWithMannequin final : public FGzViewemakerSetup
{
public:
	struct FGzMannequinSetupInstance              Mannequin;                                         // 0x0028(0x0030)(Edit, DisableEditOnTemplate, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzViewemakerSetupWithMannequin) == 0x000008, "Wrong alignment on FGzViewemakerSetupWithMannequin");
static_assert(sizeof(FGzViewemakerSetupWithMannequin) == 0x000058, "Wrong size on FGzViewemakerSetupWithMannequin");
static_assert(offsetof(FGzViewemakerSetupWithMannequin, Mannequin) == 0x000028, "Member 'FGzViewemakerSetupWithMannequin::Mannequin' has a wrong offset!");

// ScriptStruct G01.GzCardinalDirection
// 0x0020 (0x0020 - 0x0000)
struct FGzCardinalDirection final
{
public:
	class UAnimSequence*                          Forward;                                           // 0x0000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          Backward;                                          // 0x0008(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          Left;                                              // 0x0010(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          Right;                                             // 0x0018(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzCardinalDirection) == 0x000008, "Wrong alignment on FGzCardinalDirection");
static_assert(sizeof(FGzCardinalDirection) == 0x000020, "Wrong size on FGzCardinalDirection");
static_assert(offsetof(FGzCardinalDirection, Forward) == 0x000000, "Member 'FGzCardinalDirection::Forward' has a wrong offset!");
static_assert(offsetof(FGzCardinalDirection, Backward) == 0x000008, "Member 'FGzCardinalDirection::Backward' has a wrong offset!");
static_assert(offsetof(FGzCardinalDirection, Left) == 0x000010, "Member 'FGzCardinalDirection::Left' has a wrong offset!");
static_assert(offsetof(FGzCardinalDirection, Right) == 0x000018, "Member 'FGzCardinalDirection::Right' has a wrong offset!");

// ScriptStruct G01.GzPlayerMissionCacheEntry
// 0x0010 (0x0010 - 0x0000)
struct FGzPlayerMissionCacheEntry final
{
public:
	TArray<class AGzMission*>                     Missions;                                          // 0x0000(0x0010)(BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzPlayerMissionCacheEntry) == 0x000008, "Wrong alignment on FGzPlayerMissionCacheEntry");
static_assert(sizeof(FGzPlayerMissionCacheEntry) == 0x000010, "Wrong size on FGzPlayerMissionCacheEntry");
static_assert(offsetof(FGzPlayerMissionCacheEntry, Missions) == 0x000000, "Member 'FGzPlayerMissionCacheEntry::Missions' has a wrong offset!");

// ScriptStruct G01.GzGameplayEffectContainer
// 0x0018 (0x0018 - 0x0000)
struct FGzGameplayEffectContainer final
{
public:
	TSubclassOf<class UGzTargetType>              TargetType;                                        // 0x0000(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<TSubclassOf<class UGameplayEffect>>    TargetGameplayEffectClasses;                       // 0x0008(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzGameplayEffectContainer) == 0x000008, "Wrong alignment on FGzGameplayEffectContainer");
static_assert(sizeof(FGzGameplayEffectContainer) == 0x000018, "Wrong size on FGzGameplayEffectContainer");
static_assert(offsetof(FGzGameplayEffectContainer, TargetType) == 0x000000, "Member 'FGzGameplayEffectContainer::TargetType' has a wrong offset!");
static_assert(offsetof(FGzGameplayEffectContainer, TargetGameplayEffectClasses) == 0x000008, "Member 'FGzGameplayEffectContainer::TargetGameplayEffectClasses' has a wrong offset!");

// ScriptStruct G01.GzRefreshXsollaTokenResult
// 0x0018 (0x00F8 - 0x00E0)
struct FGzRefreshXsollaTokenResult final : public FGzPlayFabResultBase
{
public:
	class FString                                 Token;                                             // 0x00E0(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FDateTime                              ExpiresAt;                                         // 0x00F0(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzRefreshXsollaTokenResult) == 0x000008, "Wrong alignment on FGzRefreshXsollaTokenResult");
static_assert(sizeof(FGzRefreshXsollaTokenResult) == 0x0000F8, "Wrong size on FGzRefreshXsollaTokenResult");
static_assert(offsetof(FGzRefreshXsollaTokenResult, Token) == 0x0000E0, "Member 'FGzRefreshXsollaTokenResult::Token' has a wrong offset!");
static_assert(offsetof(FGzRefreshXsollaTokenResult, ExpiresAt) == 0x0000F0, "Member 'FGzRefreshXsollaTokenResult::ExpiresAt' has a wrong offset!");

// ScriptStruct G01.GzDamageAreaParameters
// 0x0018 (0x0018 - 0x0000)
struct FGzDamageAreaParameters final
{
public:
	class UPhysicalMaterial*                      PhysicalMaterial;                                  // 0x0000(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class FName>                           Bones;                                             // 0x0008(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzDamageAreaParameters) == 0x000008, "Wrong alignment on FGzDamageAreaParameters");
static_assert(sizeof(FGzDamageAreaParameters) == 0x000018, "Wrong size on FGzDamageAreaParameters");
static_assert(offsetof(FGzDamageAreaParameters, PhysicalMaterial) == 0x000000, "Member 'FGzDamageAreaParameters::PhysicalMaterial' has a wrong offset!");
static_assert(offsetof(FGzDamageAreaParameters, Bones) == 0x000008, "Member 'FGzDamageAreaParameters::Bones' has a wrong offset!");

// ScriptStruct G01.GzGameplayEffectContainerSpec
// 0x0038 (0x0038 - 0x0000)
struct FGzGameplayEffectContainerSpec final
{
public:
	struct FGameplayAbilityTargetDataHandle       TargetData;                                        // 0x0000(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	TArray<struct FGameplayEffectSpecHandle>      TargetGameplayEffectSpecs;                         // 0x0028(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzGameplayEffectContainerSpec) == 0x000008, "Wrong alignment on FGzGameplayEffectContainerSpec");
static_assert(sizeof(FGzGameplayEffectContainerSpec) == 0x000038, "Wrong size on FGzGameplayEffectContainerSpec");
static_assert(offsetof(FGzGameplayEffectContainerSpec, TargetData) == 0x000000, "Member 'FGzGameplayEffectContainerSpec::TargetData' has a wrong offset!");
static_assert(offsetof(FGzGameplayEffectContainerSpec, TargetGameplayEffectSpecs) == 0x000028, "Member 'FGzGameplayEffectContainerSpec::TargetGameplayEffectSpecs' has a wrong offset!");

// ScriptStruct G01.GzCohtmlBattlePassSlotDirectHexRewardV2
// 0x0028 (0x0028 - 0x0000)
struct FGzCohtmlBattlePassSlotDirectHexRewardV2 final
{
public:
	struct FGzCohtmlString                        AssetId;                                           // 0x0000(0x0020)(NativeAccessSpecifierPublic)
	int32                                         Limit;                                             // 0x0020(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         AlreadyBought;                                     // 0x0024(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzCohtmlBattlePassSlotDirectHexRewardV2) == 0x000008, "Wrong alignment on FGzCohtmlBattlePassSlotDirectHexRewardV2");
static_assert(sizeof(FGzCohtmlBattlePassSlotDirectHexRewardV2) == 0x000028, "Wrong size on FGzCohtmlBattlePassSlotDirectHexRewardV2");
static_assert(offsetof(FGzCohtmlBattlePassSlotDirectHexRewardV2, AssetId) == 0x000000, "Member 'FGzCohtmlBattlePassSlotDirectHexRewardV2::AssetId' has a wrong offset!");
static_assert(offsetof(FGzCohtmlBattlePassSlotDirectHexRewardV2, Limit) == 0x000020, "Member 'FGzCohtmlBattlePassSlotDirectHexRewardV2::Limit' has a wrong offset!");
static_assert(offsetof(FGzCohtmlBattlePassSlotDirectHexRewardV2, AlreadyBought) == 0x000024, "Member 'FGzCohtmlBattlePassSlotDirectHexRewardV2::AlreadyBought' has a wrong offset!");

// ScriptStruct G01.GzAccelerationSegmentDetails
// 0x0008 (0x0008 - 0x0000)
struct FGzAccelerationSegmentDetails final
{
public:
	int32                                         SplinePoint;                                       // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SpeedFactor;                                       // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzAccelerationSegmentDetails) == 0x000004, "Wrong alignment on FGzAccelerationSegmentDetails");
static_assert(sizeof(FGzAccelerationSegmentDetails) == 0x000008, "Wrong size on FGzAccelerationSegmentDetails");
static_assert(offsetof(FGzAccelerationSegmentDetails, SplinePoint) == 0x000000, "Member 'FGzAccelerationSegmentDetails::SplinePoint' has a wrong offset!");
static_assert(offsetof(FGzAccelerationSegmentDetails, SpeedFactor) == 0x000004, "Member 'FGzAccelerationSegmentDetails::SpeedFactor' has a wrong offset!");

// ScriptStruct G01.GzAccelerationSegment
// 0x0010 (0x0010 - 0x0000)
struct FGzAccelerationSegment final
{
public:
	double                                        StartDistance;                                     // 0x0000(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SpeedFactor;                                       // 0x0008(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2AA5[0x4];                                     // 0x000C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGzAccelerationSegment) == 0x000008, "Wrong alignment on FGzAccelerationSegment");
static_assert(sizeof(FGzAccelerationSegment) == 0x000010, "Wrong size on FGzAccelerationSegment");
static_assert(offsetof(FGzAccelerationSegment, StartDistance) == 0x000000, "Member 'FGzAccelerationSegment::StartDistance' has a wrong offset!");
static_assert(offsetof(FGzAccelerationSegment, SpeedFactor) == 0x000008, "Member 'FGzAccelerationSegment::SpeedFactor' has a wrong offset!");

// ScriptStruct G01.GzPackageGetAvailableAssignments
// 0x0010 (0x0078 - 0x0068)
struct FGzPackageGetAvailableAssignments final : public FGzPlayFabClientPackage
{
public:
	class FString                                 CharacterId;                                       // 0x0068(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzPackageGetAvailableAssignments) == 0x000008, "Wrong alignment on FGzPackageGetAvailableAssignments");
static_assert(sizeof(FGzPackageGetAvailableAssignments) == 0x000078, "Wrong size on FGzPackageGetAvailableAssignments");
static_assert(offsetof(FGzPackageGetAvailableAssignments, CharacterId) == 0x000068, "Member 'FGzPackageGetAvailableAssignments::CharacterId' has a wrong offset!");

// ScriptStruct G01.GzCheatResetPlayerProgressionPackage
// 0x0000 (0x0068 - 0x0068)
struct FGzCheatResetPlayerProgressionPackage final : public FGzPlayFabClientPackage
{
};
static_assert(alignof(FGzCheatResetPlayerProgressionPackage) == 0x000008, "Wrong alignment on FGzCheatResetPlayerProgressionPackage");
static_assert(sizeof(FGzCheatResetPlayerProgressionPackage) == 0x000068, "Wrong size on FGzCheatResetPlayerProgressionPackage");

// ScriptStruct G01.GzCohtmlItemData
// 0x0148 (0x0148 - 0x0000)
struct FGzCohtmlItemData
{
public:
	struct FGzCohtmlString                        ID;                                                // 0x0000(0x0020)(NativeAccessSpecifierPublic)
	struct FGzCohtmlString                        Type;                                              // 0x0020(0x0020)(NativeAccessSpecifierPublic)
	struct FGzCohtmlString                        Tag;                                               // 0x0040(0x0020)(NativeAccessSpecifierPublic)
	struct FGzCohtmlString                        InventoryItemType;                                 // 0x0060(0x0020)(NativeAccessSpecifierPublic)
	class FText                                   DisplayName;                                       // 0x0080(0x0010)(NativeAccessSpecifierPublic)
	class FText                                   Description;                                       // 0x0090(0x0010)(NativeAccessSpecifierPublic)
	class FText                                   DetailedDescription;                               // 0x00A0(0x0010)(NativeAccessSpecifierPublic)
	struct FGzCohtmlString                        DisplayImage;                                      // 0x00B0(0x0020)(NativeAccessSpecifierPublic)
	struct FGzCohtmlString                        PreviewImage;                                      // 0x00D0(0x0020)(NativeAccessSpecifierPublic)
	struct FGzCohtmlString                        Thumbnail;                                         // 0x00F0(0x0020)(NativeAccessSpecifierPublic)
	struct FGzCohtmlString                        Rarity;                                            // 0x0110(0x0020)(NativeAccessSpecifierPublic)
	int32                                         Price;                                             // 0x0130(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsTradable;                                        // 0x0134(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsEnabled;                                         // 0x0135(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2AA6[0x2];                                     // 0x0136(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	int64                                         ItemLimit;                                         // 0x0138(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint32                                        MinPrice;                                          // 0x0140(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint32                                        MaxPrice;                                          // 0x0144(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzCohtmlItemData) == 0x000008, "Wrong alignment on FGzCohtmlItemData");
static_assert(sizeof(FGzCohtmlItemData) == 0x000148, "Wrong size on FGzCohtmlItemData");
static_assert(offsetof(FGzCohtmlItemData, ID) == 0x000000, "Member 'FGzCohtmlItemData::ID' has a wrong offset!");
static_assert(offsetof(FGzCohtmlItemData, Type) == 0x000020, "Member 'FGzCohtmlItemData::Type' has a wrong offset!");
static_assert(offsetof(FGzCohtmlItemData, Tag) == 0x000040, "Member 'FGzCohtmlItemData::Tag' has a wrong offset!");
static_assert(offsetof(FGzCohtmlItemData, InventoryItemType) == 0x000060, "Member 'FGzCohtmlItemData::InventoryItemType' has a wrong offset!");
static_assert(offsetof(FGzCohtmlItemData, DisplayName) == 0x000080, "Member 'FGzCohtmlItemData::DisplayName' has a wrong offset!");
static_assert(offsetof(FGzCohtmlItemData, Description) == 0x000090, "Member 'FGzCohtmlItemData::Description' has a wrong offset!");
static_assert(offsetof(FGzCohtmlItemData, DetailedDescription) == 0x0000A0, "Member 'FGzCohtmlItemData::DetailedDescription' has a wrong offset!");
static_assert(offsetof(FGzCohtmlItemData, DisplayImage) == 0x0000B0, "Member 'FGzCohtmlItemData::DisplayImage' has a wrong offset!");
static_assert(offsetof(FGzCohtmlItemData, PreviewImage) == 0x0000D0, "Member 'FGzCohtmlItemData::PreviewImage' has a wrong offset!");
static_assert(offsetof(FGzCohtmlItemData, Thumbnail) == 0x0000F0, "Member 'FGzCohtmlItemData::Thumbnail' has a wrong offset!");
static_assert(offsetof(FGzCohtmlItemData, Rarity) == 0x000110, "Member 'FGzCohtmlItemData::Rarity' has a wrong offset!");
static_assert(offsetof(FGzCohtmlItemData, Price) == 0x000130, "Member 'FGzCohtmlItemData::Price' has a wrong offset!");
static_assert(offsetof(FGzCohtmlItemData, IsTradable) == 0x000134, "Member 'FGzCohtmlItemData::IsTradable' has a wrong offset!");
static_assert(offsetof(FGzCohtmlItemData, IsEnabled) == 0x000135, "Member 'FGzCohtmlItemData::IsEnabled' has a wrong offset!");
static_assert(offsetof(FGzCohtmlItemData, ItemLimit) == 0x000138, "Member 'FGzCohtmlItemData::ItemLimit' has a wrong offset!");
static_assert(offsetof(FGzCohtmlItemData, MinPrice) == 0x000140, "Member 'FGzCohtmlItemData::MinPrice' has a wrong offset!");
static_assert(offsetof(FGzCohtmlItemData, MaxPrice) == 0x000144, "Member 'FGzCohtmlItemData::MaxPrice' has a wrong offset!");

// ScriptStruct G01.GzCohtmlBodyPartItemData
// 0x0020 (0x0168 - 0x0148)
struct FGzCohtmlBodyPartItemData final : public FGzCohtmlItemData
{
public:
	class FString                                 LimbType;                                          // 0x0148(0x0010)(ZeroConstructor, Transient, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 LimbArchetypeName;                                 // 0x0158(0x0010)(ZeroConstructor, Transient, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzCohtmlBodyPartItemData) == 0x000008, "Wrong alignment on FGzCohtmlBodyPartItemData");
static_assert(sizeof(FGzCohtmlBodyPartItemData) == 0x000168, "Wrong size on FGzCohtmlBodyPartItemData");
static_assert(offsetof(FGzCohtmlBodyPartItemData, LimbType) == 0x000148, "Member 'FGzCohtmlBodyPartItemData::LimbType' has a wrong offset!");
static_assert(offsetof(FGzCohtmlBodyPartItemData, LimbArchetypeName) == 0x000158, "Member 'FGzCohtmlBodyPartItemData::LimbArchetypeName' has a wrong offset!");

// ScriptStruct G01.GzAcceptFriendInvitationPackage
// 0x0010 (0x0078 - 0x0068)
struct FGzAcceptFriendInvitationPackage final : public FGzPlayFabClientPackage
{
public:
	class FString                                 FriendPlayFabId;                                   // 0x0068(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzAcceptFriendInvitationPackage) == 0x000008, "Wrong alignment on FGzAcceptFriendInvitationPackage");
static_assert(sizeof(FGzAcceptFriendInvitationPackage) == 0x000078, "Wrong size on FGzAcceptFriendInvitationPackage");
static_assert(offsetof(FGzAcceptFriendInvitationPackage, FriendPlayFabId) == 0x000068, "Member 'FGzAcceptFriendInvitationPackage::FriendPlayFabId' has a wrong offset!");

// ScriptStruct G01.GzInputModeConfig
// 0x0002 (0x0002 - 0x0000)
struct FGzInputModeConfig final
{
public:
	ECommonInputMode                              InputMode;                                         // 0x0000(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EMouseCaptureMode                             MouseCaptureMode;                                  // 0x0001(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzInputModeConfig) == 0x000001, "Wrong alignment on FGzInputModeConfig");
static_assert(sizeof(FGzInputModeConfig) == 0x000002, "Wrong size on FGzInputModeConfig");
static_assert(offsetof(FGzInputModeConfig, InputMode) == 0x000000, "Member 'FGzInputModeConfig::InputMode' has a wrong offset!");
static_assert(offsetof(FGzInputModeConfig, MouseCaptureMode) == 0x000001, "Member 'FGzInputModeConfig::MouseCaptureMode' has a wrong offset!");

// ScriptStruct G01.GzStripeExtendSubscriptionWithGunResult
// 0x0000 (0x00E0 - 0x00E0)
struct FGzStripeExtendSubscriptionWithGunResult final : public FGzPlayFabResultBase
{
};
static_assert(alignof(FGzStripeExtendSubscriptionWithGunResult) == 0x000008, "Wrong alignment on FGzStripeExtendSubscriptionWithGunResult");
static_assert(sizeof(FGzStripeExtendSubscriptionWithGunResult) == 0x0000E0, "Wrong size on FGzStripeExtendSubscriptionWithGunResult");

// ScriptStruct G01.GzResultCheatUpdateChallengesProgress
// 0x0000 (0x00E0 - 0x00E0)
struct FGzResultCheatUpdateChallengesProgress final : public FGzPlayFabResultBase
{
};
static_assert(alignof(FGzResultCheatUpdateChallengesProgress) == 0x000008, "Wrong alignment on FGzResultCheatUpdateChallengesProgress");
static_assert(sizeof(FGzResultCheatUpdateChallengesProgress) == 0x0000E0, "Wrong size on FGzResultCheatUpdateChallengesProgress");

// ScriptStruct G01.GzOnLoginResult
// 0x0040 (0x0120 - 0x00E0)
struct FGzOnLoginResult final : public FGzPlayFabResultBase
{
public:
	class FString                                 SessionId;                                         // 0x00E0(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsPlayerWhitelisted;                               // 0x00F0(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2AA7[0x7];                                     // 0x00F1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 LiveDataVersion;                                   // 0x00F8(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint64                                        PlaceInQueue;                                      // 0x0108(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 EstTime;                                           // 0x0110(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzOnLoginResult) == 0x000008, "Wrong alignment on FGzOnLoginResult");
static_assert(sizeof(FGzOnLoginResult) == 0x000120, "Wrong size on FGzOnLoginResult");
static_assert(offsetof(FGzOnLoginResult, SessionId) == 0x0000E0, "Member 'FGzOnLoginResult::SessionId' has a wrong offset!");
static_assert(offsetof(FGzOnLoginResult, IsPlayerWhitelisted) == 0x0000F0, "Member 'FGzOnLoginResult::IsPlayerWhitelisted' has a wrong offset!");
static_assert(offsetof(FGzOnLoginResult, LiveDataVersion) == 0x0000F8, "Member 'FGzOnLoginResult::LiveDataVersion' has a wrong offset!");
static_assert(offsetof(FGzOnLoginResult, PlaceInQueue) == 0x000108, "Member 'FGzOnLoginResult::PlaceInQueue' has a wrong offset!");
static_assert(offsetof(FGzOnLoginResult, EstTime) == 0x000110, "Member 'FGzOnLoginResult::EstTime' has a wrong offset!");

// ScriptStruct G01.GzPackageCustomizationEmoteSlot
// 0x0020 (0x0020 - 0x0000)
struct FGzPackageCustomizationEmoteSlot final
{
public:
	class FString                                 ItemId;                                            // 0x0000(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 AssetId;                                           // 0x0010(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzPackageCustomizationEmoteSlot) == 0x000008, "Wrong alignment on FGzPackageCustomizationEmoteSlot");
static_assert(sizeof(FGzPackageCustomizationEmoteSlot) == 0x000020, "Wrong size on FGzPackageCustomizationEmoteSlot");
static_assert(offsetof(FGzPackageCustomizationEmoteSlot, ItemId) == 0x000000, "Member 'FGzPackageCustomizationEmoteSlot::ItemId' has a wrong offset!");
static_assert(offsetof(FGzPackageCustomizationEmoteSlot, AssetId) == 0x000010, "Member 'FGzPackageCustomizationEmoteSlot::AssetId' has a wrong offset!");

// ScriptStruct G01.GzPackageCustomizationEmoteCollection
// 0x0010 (0x0010 - 0x0000)
struct FGzPackageCustomizationEmoteCollection final
{
public:
	TArray<struct FGzPackageCustomizationEmoteSlot> Emotes;                                            // 0x0000(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzPackageCustomizationEmoteCollection) == 0x000008, "Wrong alignment on FGzPackageCustomizationEmoteCollection");
static_assert(sizeof(FGzPackageCustomizationEmoteCollection) == 0x000010, "Wrong size on FGzPackageCustomizationEmoteCollection");
static_assert(offsetof(FGzPackageCustomizationEmoteCollection, Emotes) == 0x000000, "Member 'FGzPackageCustomizationEmoteCollection::Emotes' has a wrong offset!");

// ScriptStruct G01.GzCohtmlWeaponAttachmentItemData
// 0x0010 (0x0158 - 0x0148)
struct FGzCohtmlWeaponAttachmentItemData final : public FGzCohtmlItemData
{
public:
	class FString                                 AttachmentType;                                    // 0x0148(0x0010)(ZeroConstructor, Transient, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzCohtmlWeaponAttachmentItemData) == 0x000008, "Wrong alignment on FGzCohtmlWeaponAttachmentItemData");
static_assert(sizeof(FGzCohtmlWeaponAttachmentItemData) == 0x000158, "Wrong size on FGzCohtmlWeaponAttachmentItemData");
static_assert(offsetof(FGzCohtmlWeaponAttachmentItemData, AttachmentType) == 0x000148, "Member 'FGzCohtmlWeaponAttachmentItemData::AttachmentType' has a wrong offset!");

// ScriptStruct G01.GzCohtmlSuitableAttachment
// 0x0160 (0x0160 - 0x0000)
struct FGzCohtmlSuitableAttachment final
{
public:
	struct FGzCohtmlWeaponAttachmentItemData      AttachmentData;                                    // 0x0000(0x0158)(Transient, NativeAccessSpecifierPublic)
	bool                                          bIsDefault;                                        // 0x0158(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2AA8[0x7];                                     // 0x0159(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGzCohtmlSuitableAttachment) == 0x000008, "Wrong alignment on FGzCohtmlSuitableAttachment");
static_assert(sizeof(FGzCohtmlSuitableAttachment) == 0x000160, "Wrong size on FGzCohtmlSuitableAttachment");
static_assert(offsetof(FGzCohtmlSuitableAttachment, AttachmentData) == 0x000000, "Member 'FGzCohtmlSuitableAttachment::AttachmentData' has a wrong offset!");
static_assert(offsetof(FGzCohtmlSuitableAttachment, bIsDefault) == 0x000158, "Member 'FGzCohtmlSuitableAttachment::bIsDefault' has a wrong offset!");

// ScriptStruct G01.GzCohtmlSuitableAttachmentsCategory
// 0x0028 (0x0028 - 0x0000)
struct FGzCohtmlSuitableAttachmentsCategory final
{
public:
	TArray<struct FGzCohtmlSuitableAttachment>    Attachments;                                       // 0x0000(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPublic)
	class FString                                 RequiredUnlockRarity;                              // 0x0010(0x0010)(ZeroConstructor, Transient, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsModifiableByPlayer;                             // 0x0020(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2AA9[0x7];                                     // 0x0021(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGzCohtmlSuitableAttachmentsCategory) == 0x000008, "Wrong alignment on FGzCohtmlSuitableAttachmentsCategory");
static_assert(sizeof(FGzCohtmlSuitableAttachmentsCategory) == 0x000028, "Wrong size on FGzCohtmlSuitableAttachmentsCategory");
static_assert(offsetof(FGzCohtmlSuitableAttachmentsCategory, Attachments) == 0x000000, "Member 'FGzCohtmlSuitableAttachmentsCategory::Attachments' has a wrong offset!");
static_assert(offsetof(FGzCohtmlSuitableAttachmentsCategory, RequiredUnlockRarity) == 0x000010, "Member 'FGzCohtmlSuitableAttachmentsCategory::RequiredUnlockRarity' has a wrong offset!");
static_assert(offsetof(FGzCohtmlSuitableAttachmentsCategory, bIsModifiableByPlayer) == 0x000020, "Member 'FGzCohtmlSuitableAttachmentsCategory::bIsModifiableByPlayer' has a wrong offset!");

// ScriptStruct G01.GzCohtmlDecodePayment
// 0x0018 (0x0018 - 0x0000)
struct FGzCohtmlDecodePayment final
{
public:
	class FString                                 Currency;                                          // 0x0000(0x0010)(ZeroConstructor, Transient, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	double                                        Price;                                             // 0x0010(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzCohtmlDecodePayment) == 0x000008, "Wrong alignment on FGzCohtmlDecodePayment");
static_assert(sizeof(FGzCohtmlDecodePayment) == 0x000018, "Wrong size on FGzCohtmlDecodePayment");
static_assert(offsetof(FGzCohtmlDecodePayment, Currency) == 0x000000, "Member 'FGzCohtmlDecodePayment::Currency' has a wrong offset!");
static_assert(offsetof(FGzCohtmlDecodePayment, Price) == 0x000010, "Member 'FGzCohtmlDecodePayment::Price' has a wrong offset!");

// ScriptStruct G01.GzCohtmlContainerItemData
// 0x0030 (0x0178 - 0x0148)
struct FGzCohtmlContainerItemData final : public FGzCohtmlItemData
{
public:
	EGzHexType                                    HexType;                                           // 0x0148(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2AAA[0x7];                                     // 0x0149(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGzCohtmlDecodePayment                 DecodePayment;                                     // 0x0150(0x0018)(Transient, NativeAccessSpecifierPublic)
	class FString                                 DirectReward;                                      // 0x0168(0x0010)(ZeroConstructor, Transient, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzCohtmlContainerItemData) == 0x000008, "Wrong alignment on FGzCohtmlContainerItemData");
static_assert(sizeof(FGzCohtmlContainerItemData) == 0x000178, "Wrong size on FGzCohtmlContainerItemData");
static_assert(offsetof(FGzCohtmlContainerItemData, HexType) == 0x000148, "Member 'FGzCohtmlContainerItemData::HexType' has a wrong offset!");
static_assert(offsetof(FGzCohtmlContainerItemData, DecodePayment) == 0x000150, "Member 'FGzCohtmlContainerItemData::DecodePayment' has a wrong offset!");
static_assert(offsetof(FGzCohtmlContainerItemData, DirectReward) == 0x000168, "Member 'FGzCohtmlContainerItemData::DirectReward' has a wrong offset!");

// ScriptStruct G01.GzResetPlayerAccountResult
// 0x0000 (0x00E0 - 0x00E0)
struct FGzResetPlayerAccountResult final : public FGzPlayFabResultBase
{
};
static_assert(alignof(FGzResetPlayerAccountResult) == 0x000008, "Wrong alignment on FGzResetPlayerAccountResult");
static_assert(sizeof(FGzResetPlayerAccountResult) == 0x0000E0, "Wrong size on FGzResetPlayerAccountResult");

// ScriptStruct G01.GzAddBlockchainCoinsPackage
// 0x0010 (0x0078 - 0x0068)
struct FGzAddBlockchainCoinsPackage final : public FGzPlayFabClientPackage
{
public:
	class FString                                 AmountString;                                      // 0x0068(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzAddBlockchainCoinsPackage) == 0x000008, "Wrong alignment on FGzAddBlockchainCoinsPackage");
static_assert(sizeof(FGzAddBlockchainCoinsPackage) == 0x000078, "Wrong size on FGzAddBlockchainCoinsPackage");
static_assert(offsetof(FGzAddBlockchainCoinsPackage, AmountString) == 0x000068, "Member 'FGzAddBlockchainCoinsPackage::AmountString' has a wrong offset!");

// ScriptStruct G01.GzBackendBattlePassSlotRewardV2
// 0x0048 (0x0048 - 0x0000)
struct FGzBackendBattlePassSlotRewardV2 final
{
public:
	class FString                                 R;                                                 // 0x0000(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 T;                                                 // 0x0010(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 A;                                                 // 0x0020(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	double                                        G;                                                 // 0x0030(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	double                                        P;                                                 // 0x0038(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         C;                                                 // 0x0040(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         L;                                                 // 0x0044(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzBackendBattlePassSlotRewardV2) == 0x000008, "Wrong alignment on FGzBackendBattlePassSlotRewardV2");
static_assert(sizeof(FGzBackendBattlePassSlotRewardV2) == 0x000048, "Wrong size on FGzBackendBattlePassSlotRewardV2");
static_assert(offsetof(FGzBackendBattlePassSlotRewardV2, R) == 0x000000, "Member 'FGzBackendBattlePassSlotRewardV2::R' has a wrong offset!");
static_assert(offsetof(FGzBackendBattlePassSlotRewardV2, T) == 0x000010, "Member 'FGzBackendBattlePassSlotRewardV2::T' has a wrong offset!");
static_assert(offsetof(FGzBackendBattlePassSlotRewardV2, A) == 0x000020, "Member 'FGzBackendBattlePassSlotRewardV2::A' has a wrong offset!");
static_assert(offsetof(FGzBackendBattlePassSlotRewardV2, G) == 0x000030, "Member 'FGzBackendBattlePassSlotRewardV2::G' has a wrong offset!");
static_assert(offsetof(FGzBackendBattlePassSlotRewardV2, P) == 0x000038, "Member 'FGzBackendBattlePassSlotRewardV2::P' has a wrong offset!");
static_assert(offsetof(FGzBackendBattlePassSlotRewardV2, C) == 0x000040, "Member 'FGzBackendBattlePassSlotRewardV2::C' has a wrong offset!");
static_assert(offsetof(FGzBackendBattlePassSlotRewardV2, L) == 0x000044, "Member 'FGzBackendBattlePassSlotRewardV2::L' has a wrong offset!");

// ScriptStruct G01.GzBackendBattlePassSlotV2
// 0x0068 (0x0068 - 0x0000)
struct FGzBackendBattlePassSlotV2 final
{
public:
	class FString                                 ID;                                                // 0x0000(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGzBackendBattlePassSlotRewardV2       Cr;                                                // 0x0010(0x0048)(NativeAccessSpecifierPublic)
	struct FGzBackendBattlePassSlotPreConditionsV2 PC;                                                // 0x0058(0x0010)(NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzBackendBattlePassSlotV2) == 0x000008, "Wrong alignment on FGzBackendBattlePassSlotV2");
static_assert(sizeof(FGzBackendBattlePassSlotV2) == 0x000068, "Wrong size on FGzBackendBattlePassSlotV2");
static_assert(offsetof(FGzBackendBattlePassSlotV2, ID) == 0x000000, "Member 'FGzBackendBattlePassSlotV2::ID' has a wrong offset!");
static_assert(offsetof(FGzBackendBattlePassSlotV2, Cr) == 0x000010, "Member 'FGzBackendBattlePassSlotV2::Cr' has a wrong offset!");
static_assert(offsetof(FGzBackendBattlePassSlotV2, PC) == 0x000058, "Member 'FGzBackendBattlePassSlotV2::PC' has a wrong offset!");

// ScriptStruct G01.GzBackendBattlePassPageV2
// 0x0018 (0x0018 - 0x0000)
struct FGzBackendBattlePassPageV2 final
{
public:
	int32                                         EntryLevel;                                        // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         EntryLoyaltyLevel;                                 // 0x0004(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FGzBackendBattlePassSlotV2>     Slots;                                             // 0x0008(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzBackendBattlePassPageV2) == 0x000008, "Wrong alignment on FGzBackendBattlePassPageV2");
static_assert(sizeof(FGzBackendBattlePassPageV2) == 0x000018, "Wrong size on FGzBackendBattlePassPageV2");
static_assert(offsetof(FGzBackendBattlePassPageV2, EntryLevel) == 0x000000, "Member 'FGzBackendBattlePassPageV2::EntryLevel' has a wrong offset!");
static_assert(offsetof(FGzBackendBattlePassPageV2, EntryLoyaltyLevel) == 0x000004, "Member 'FGzBackendBattlePassPageV2::EntryLoyaltyLevel' has a wrong offset!");
static_assert(offsetof(FGzBackendBattlePassPageV2, Slots) == 0x000008, "Member 'FGzBackendBattlePassPageV2::Slots' has a wrong offset!");

// ScriptStruct G01.GzBackendBattlePassDataV2
// 0x0080 (0x0080 - 0x0000)
struct FGzBackendBattlePassDataV2 final
{
public:
	class FString                                 ID;                                                // 0x0000(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FDateTime                              StartDate;                                         // 0x0010(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FDateTime                              EndDate;                                           // 0x0018(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 ExpiresAt;                                         // 0x0020(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMap<class FString, struct FGzBackendBattlePassPageV2> Pages;                                             // 0x0030(0x0050)(NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzBackendBattlePassDataV2) == 0x000008, "Wrong alignment on FGzBackendBattlePassDataV2");
static_assert(sizeof(FGzBackendBattlePassDataV2) == 0x000080, "Wrong size on FGzBackendBattlePassDataV2");
static_assert(offsetof(FGzBackendBattlePassDataV2, ID) == 0x000000, "Member 'FGzBackendBattlePassDataV2::ID' has a wrong offset!");
static_assert(offsetof(FGzBackendBattlePassDataV2, StartDate) == 0x000010, "Member 'FGzBackendBattlePassDataV2::StartDate' has a wrong offset!");
static_assert(offsetof(FGzBackendBattlePassDataV2, EndDate) == 0x000018, "Member 'FGzBackendBattlePassDataV2::EndDate' has a wrong offset!");
static_assert(offsetof(FGzBackendBattlePassDataV2, ExpiresAt) == 0x000020, "Member 'FGzBackendBattlePassDataV2::ExpiresAt' has a wrong offset!");
static_assert(offsetof(FGzBackendBattlePassDataV2, Pages) == 0x000030, "Member 'FGzBackendBattlePassDataV2::Pages' has a wrong offset!");

// ScriptStruct G01.GzGetCurrentBattlePassResult
// 0x0080 (0x0160 - 0x00E0)
struct FGzGetCurrentBattlePassResult final : public FGzPlayFabResultBase
{
public:
	struct FGzBackendBattlePassDataV2             CurrentBattlePass;                                 // 0x00E0(0x0080)(NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzGetCurrentBattlePassResult) == 0x000008, "Wrong alignment on FGzGetCurrentBattlePassResult");
static_assert(sizeof(FGzGetCurrentBattlePassResult) == 0x000160, "Wrong size on FGzGetCurrentBattlePassResult");
static_assert(offsetof(FGzGetCurrentBattlePassResult, CurrentBattlePass) == 0x0000E0, "Member 'FGzGetCurrentBattlePassResult::CurrentBattlePass' has a wrong offset!");

// ScriptStruct G01.GzAIFastId
// 0x0004 (0x0010 - 0x000C)
struct FGzAIFastId final : public FFastArraySerializerItem
{
public:
	int32                                         NpcId;                                             // 0x000C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzAIFastId) == 0x000004, "Wrong alignment on FGzAIFastId");
static_assert(sizeof(FGzAIFastId) == 0x000010, "Wrong size on FGzAIFastId");
static_assert(offsetof(FGzAIFastId, NpcId) == 0x00000C, "Member 'FGzAIFastId::NpcId' has a wrong offset!");

// ScriptStruct G01.GzQrCodeRecord
// 0x0018 (0x0018 - 0x0000)
struct FGzQrCodeRecord final
{
public:
	uint8                                         Pad_2AAB[0x10];                                    // 0x0000(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class UTexture2D*                             Texture;                                           // 0x0010(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzQrCodeRecord) == 0x000008, "Wrong alignment on FGzQrCodeRecord");
static_assert(sizeof(FGzQrCodeRecord) == 0x000018, "Wrong size on FGzQrCodeRecord");
static_assert(offsetof(FGzQrCodeRecord, Texture) == 0x000010, "Member 'FGzQrCodeRecord::Texture' has a wrong offset!");

// ScriptStruct G01.GzMetaChallengeProgressSirnalrArgs
// 0x0020 (0x0020 - 0x0000)
struct FGzMetaChallengeProgressSirnalrArgs final
{
public:
	class FString                                 I;                                                 // 0x0000(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EGzSignalrChallengeType                       T;                                                 // 0x0010(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         P;                                                 // 0x0014(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          C;                                                 // 0x0018(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2AAC[0x7];                                     // 0x0019(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGzMetaChallengeProgressSirnalrArgs) == 0x000008, "Wrong alignment on FGzMetaChallengeProgressSirnalrArgs");
static_assert(sizeof(FGzMetaChallengeProgressSirnalrArgs) == 0x000020, "Wrong size on FGzMetaChallengeProgressSirnalrArgs");
static_assert(offsetof(FGzMetaChallengeProgressSirnalrArgs, I) == 0x000000, "Member 'FGzMetaChallengeProgressSirnalrArgs::I' has a wrong offset!");
static_assert(offsetof(FGzMetaChallengeProgressSirnalrArgs, T) == 0x000010, "Member 'FGzMetaChallengeProgressSirnalrArgs::T' has a wrong offset!");
static_assert(offsetof(FGzMetaChallengeProgressSirnalrArgs, P) == 0x000014, "Member 'FGzMetaChallengeProgressSirnalrArgs::P' has a wrong offset!");
static_assert(offsetof(FGzMetaChallengeProgressSirnalrArgs, C) == 0x000018, "Member 'FGzMetaChallengeProgressSirnalrArgs::C' has a wrong offset!");

// ScriptStruct G01.GzAIFastArray
// 0x0058 (0x0168 - 0x0110)
struct FGzAIFastArray final : public FFastArraySerializer
{
public:
	uint8                                         Pad_2AAD[0x48];                                    // 0x0110(0x0048)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FGzAIFastId>                    NpcIds;                                            // 0x0158(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzAIFastArray) == 0x000008, "Wrong alignment on FGzAIFastArray");
static_assert(sizeof(FGzAIFastArray) == 0x000168, "Wrong size on FGzAIFastArray");
static_assert(offsetof(FGzAIFastArray, NpcIds) == 0x000158, "Member 'FGzAIFastArray::NpcIds' has a wrong offset!");

// ScriptStruct G01.GzNotificationQueue
// 0x0028 (0x0028 - 0x0000)
struct FGzNotificationQueue final
{
public:
	uint8                                         Pad_2AAE[0x10];                                    // 0x0000(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UGzNotificationConditionBase*>   ShowCondition;                                     // 0x0010(0x0010)(ZeroConstructor, Transient, UObjectWrapper, NativeAccessSpecifierPublic)
	class UGzNotificationDisplayData*             DisplayData;                                       // 0x0020(0x0008)(ZeroConstructor, Transient, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzNotificationQueue) == 0x000008, "Wrong alignment on FGzNotificationQueue");
static_assert(sizeof(FGzNotificationQueue) == 0x000028, "Wrong size on FGzNotificationQueue");
static_assert(offsetof(FGzNotificationQueue, ShowCondition) == 0x000010, "Member 'FGzNotificationQueue::ShowCondition' has a wrong offset!");
static_assert(offsetof(FGzNotificationQueue, DisplayData) == 0x000020, "Member 'FGzNotificationQueue::DisplayData' has a wrong offset!");

// ScriptStruct G01.GzNotificationQueueSlot
// 0x0020 (0x0020 - 0x0000)
struct FGzNotificationQueueSlot final
{
public:
	TArray<struct FGzNotificationQueue>           NotificationQueue;                                 // 0x0000(0x0010)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	class UGzNotificationSlotBase*                NotificationSlot;                                  // 0x0010(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2AAF[0x8];                                     // 0x0018(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGzNotificationQueueSlot) == 0x000008, "Wrong alignment on FGzNotificationQueueSlot");
static_assert(sizeof(FGzNotificationQueueSlot) == 0x000020, "Wrong size on FGzNotificationQueueSlot");
static_assert(offsetof(FGzNotificationQueueSlot, NotificationQueue) == 0x000000, "Member 'FGzNotificationQueueSlot::NotificationQueue' has a wrong offset!");
static_assert(offsetof(FGzNotificationQueueSlot, NotificationSlot) == 0x000010, "Member 'FGzNotificationQueueSlot::NotificationSlot' has a wrong offset!");

// ScriptStruct G01.DrawCovers
// 0x0038 (0x0038 - 0x0000)
struct FDrawCovers final
{
public:
	struct FVector_NetQuantize                    CapsuleCenter;                                     // 0x0000(0x0018)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector_NetQuantize                    CoverNormal;                                       // 0x0018(0x0018)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          HalfHeight;                                        // 0x0030(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCoverTaken;                                       // 0x0031(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2AB0[0x6];                                     // 0x0032(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FDrawCovers) == 0x000008, "Wrong alignment on FDrawCovers");
static_assert(sizeof(FDrawCovers) == 0x000038, "Wrong size on FDrawCovers");
static_assert(offsetof(FDrawCovers, CapsuleCenter) == 0x000000, "Member 'FDrawCovers::CapsuleCenter' has a wrong offset!");
static_assert(offsetof(FDrawCovers, CoverNormal) == 0x000018, "Member 'FDrawCovers::CoverNormal' has a wrong offset!");
static_assert(offsetof(FDrawCovers, HalfHeight) == 0x000030, "Member 'FDrawCovers::HalfHeight' has a wrong offset!");
static_assert(offsetof(FDrawCovers, bCoverTaken) == 0x000031, "Member 'FDrawCovers::bCoverTaken' has a wrong offset!");

// ScriptStruct G01.GzUnityMatchmakingStartPackagePlayer
// 0x0010 (0x0010 - 0x0000)
struct FGzUnityMatchmakingStartPackagePlayer final
{
public:
	TArray<struct FGzUnityPingResult>             QosResults;                                        // 0x0000(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzUnityMatchmakingStartPackagePlayer) == 0x000008, "Wrong alignment on FGzUnityMatchmakingStartPackagePlayer");
static_assert(sizeof(FGzUnityMatchmakingStartPackagePlayer) == 0x000010, "Wrong size on FGzUnityMatchmakingStartPackagePlayer");
static_assert(offsetof(FGzUnityMatchmakingStartPackagePlayer, QosResults) == 0x000000, "Member 'FGzUnityMatchmakingStartPackagePlayer::QosResults' has a wrong offset!");

// ScriptStruct G01.GzUnityMatchmakingStartPackage
// 0x0070 (0x00D8 - 0x0068)
struct FGzUnityMatchmakingStartPackage final : public FGzPlayFabClientPackage
{
public:
	class FString                                 QueueName;                                         // 0x0068(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMap<class FString, struct FGzUnityMatchmakingStartPackagePlayer> Players;                                           // 0x0078(0x0050)(NativeAccessSpecifierPublic)
	class FString                                 UnityUserId;                                       // 0x00C8(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzUnityMatchmakingStartPackage) == 0x000008, "Wrong alignment on FGzUnityMatchmakingStartPackage");
static_assert(sizeof(FGzUnityMatchmakingStartPackage) == 0x0000D8, "Wrong size on FGzUnityMatchmakingStartPackage");
static_assert(offsetof(FGzUnityMatchmakingStartPackage, QueueName) == 0x000068, "Member 'FGzUnityMatchmakingStartPackage::QueueName' has a wrong offset!");
static_assert(offsetof(FGzUnityMatchmakingStartPackage, Players) == 0x000078, "Member 'FGzUnityMatchmakingStartPackage::Players' has a wrong offset!");
static_assert(offsetof(FGzUnityMatchmakingStartPackage, UnityUserId) == 0x0000C8, "Member 'FGzUnityMatchmakingStartPackage::UnityUserId' has a wrong offset!");

// ScriptStruct G01.GzSubtractBlockchainCoinsResult
// 0x0010 (0x00F0 - 0x00E0)
struct FGzSubtractBlockchainCoinsResult final : public FGzPlayFabResultBase
{
public:
	class FString                                 BalanceString;                                     // 0x00E0(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzSubtractBlockchainCoinsResult) == 0x000008, "Wrong alignment on FGzSubtractBlockchainCoinsResult");
static_assert(sizeof(FGzSubtractBlockchainCoinsResult) == 0x0000F0, "Wrong size on FGzSubtractBlockchainCoinsResult");
static_assert(offsetof(FGzSubtractBlockchainCoinsResult, BalanceString) == 0x0000E0, "Member 'FGzSubtractBlockchainCoinsResult::BalanceString' has a wrong offset!");

// ScriptStruct G01.AILODArray
// 0x0010 (0x0010 - 0x0000)
struct FAILODArray final
{
public:
	TArray<struct FGzAILOD>                       AILODArray;                                        // 0x0000(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAILODArray) == 0x000008, "Wrong alignment on FAILODArray");
static_assert(sizeof(FAILODArray) == 0x000010, "Wrong size on FAILODArray");
static_assert(offsetof(FAILODArray, AILODArray) == 0x000000, "Member 'FAILODArray::AILODArray' has a wrong offset!");

// ScriptStruct G01.GzNavMeshSettings
// 0x0001 (0x0001 - 0x0000)
struct FGzNavMeshSettings final
{
public:
	uint8                                         Pad_2AB1[0x1];                                     // 0x0000(0x0001)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGzNavMeshSettings) == 0x000001, "Wrong alignment on FGzNavMeshSettings");
static_assert(sizeof(FGzNavMeshSettings) == 0x000001, "Wrong size on FGzNavMeshSettings");

// ScriptStruct G01.GzPackageGetNotifications
// 0x0010 (0x0078 - 0x0068)
struct FGzPackageGetNotifications final : public FGzPlayFabClientPackage
{
public:
	class FString                                 ContinuationToken;                                 // 0x0068(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzPackageGetNotifications) == 0x000008, "Wrong alignment on FGzPackageGetNotifications");
static_assert(sizeof(FGzPackageGetNotifications) == 0x000078, "Wrong size on FGzPackageGetNotifications");
static_assert(offsetof(FGzPackageGetNotifications, ContinuationToken) == 0x000068, "Member 'FGzPackageGetNotifications::ContinuationToken' has a wrong offset!");

// ScriptStruct G01.AITokenData
// 0x000C (0x000C - 0x0000)
struct FAITokenData final
{
public:
	TWeakObjectPtr<class APawn>                   Attacker;                                          // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TimeToExpired;                                     // 0x0008(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAITokenData) == 0x000004, "Wrong alignment on FAITokenData");
static_assert(sizeof(FAITokenData) == 0x00000C, "Wrong size on FAITokenData");
static_assert(offsetof(FAITokenData, Attacker) == 0x000000, "Member 'FAITokenData::Attacker' has a wrong offset!");
static_assert(offsetof(FAITokenData, TimeToExpired) == 0x000008, "Member 'FAITokenData::TimeToExpired' has a wrong offset!");

// ScriptStruct G01.GzResultCustomizationEmoteUpdate
// 0x0000 (0x00E0 - 0x00E0)
struct FGzResultCustomizationEmoteUpdate final : public FGzPlayFabResultBase
{
};
static_assert(alignof(FGzResultCustomizationEmoteUpdate) == 0x000008, "Wrong alignment on FGzResultCustomizationEmoteUpdate");
static_assert(sizeof(FGzResultCustomizationEmoteUpdate) == 0x0000E0, "Wrong size on FGzResultCustomizationEmoteUpdate");

// ScriptStruct G01.BarkData
// 0x0028 (0x0028 - 0x0000)
struct FBarkData final
{
public:
	float                                         CooldownTime;                                      // 0x0000(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CooldownTimeRandomDeviation;                       // 0x0004(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CooldownGlobalTime;                                // 0x0008(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CooldownGlobalTimeRandomDeviation;                 // 0x000C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CooldownGlobalRadius;                              // 0x0010(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2AB2[0x4];                                     // 0x0014(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FAudioData>                     AudioEventDataArray;                               // 0x0018(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
};
static_assert(alignof(FBarkData) == 0x000008, "Wrong alignment on FBarkData");
static_assert(sizeof(FBarkData) == 0x000028, "Wrong size on FBarkData");
static_assert(offsetof(FBarkData, CooldownTime) == 0x000000, "Member 'FBarkData::CooldownTime' has a wrong offset!");
static_assert(offsetof(FBarkData, CooldownTimeRandomDeviation) == 0x000004, "Member 'FBarkData::CooldownTimeRandomDeviation' has a wrong offset!");
static_assert(offsetof(FBarkData, CooldownGlobalTime) == 0x000008, "Member 'FBarkData::CooldownGlobalTime' has a wrong offset!");
static_assert(offsetof(FBarkData, CooldownGlobalTimeRandomDeviation) == 0x00000C, "Member 'FBarkData::CooldownGlobalTimeRandomDeviation' has a wrong offset!");
static_assert(offsetof(FBarkData, CooldownGlobalRadius) == 0x000010, "Member 'FBarkData::CooldownGlobalRadius' has a wrong offset!");
static_assert(offsetof(FBarkData, AudioEventDataArray) == 0x000018, "Member 'FBarkData::AudioEventDataArray' has a wrong offset!");

// ScriptStruct G01.GzSpawnParameters
// 0x0008 (0x0008 - 0x0000)
struct FGzSpawnParameters final
{
public:
	float                                         SpawnAngle;                                        // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SpawnForceMultiplier;                              // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzSpawnParameters) == 0x000004, "Wrong alignment on FGzSpawnParameters");
static_assert(sizeof(FGzSpawnParameters) == 0x000008, "Wrong size on FGzSpawnParameters");
static_assert(offsetof(FGzSpawnParameters, SpawnAngle) == 0x000000, "Member 'FGzSpawnParameters::SpawnAngle' has a wrong offset!");
static_assert(offsetof(FGzSpawnParameters, SpawnForceMultiplier) == 0x000004, "Member 'FGzSpawnParameters::SpawnForceMultiplier' has a wrong offset!");

// ScriptStruct G01.GzItemsGroup
// 0x0010 (0x0010 - 0x0000)
struct FGzItemsGroup final
{
public:
	TArray<class UGzItemData*>                    ItemsList;                                         // 0x0000(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzItemsGroup) == 0x000008, "Wrong alignment on FGzItemsGroup");
static_assert(sizeof(FGzItemsGroup) == 0x000010, "Wrong size on FGzItemsGroup");
static_assert(offsetof(FGzItemsGroup, ItemsList) == 0x000000, "Member 'FGzItemsGroup::ItemsList' has a wrong offset!");

// ScriptStruct G01.GzResultSelectJob
// 0x0000 (0x00E0 - 0x00E0)
struct FGzResultSelectJob final : public FGzPlayFabResultBase
{
};
static_assert(alignof(FGzResultSelectJob) == 0x000008, "Wrong alignment on FGzResultSelectJob");
static_assert(sizeof(FGzResultSelectJob) == 0x0000E0, "Wrong size on FGzResultSelectJob");

// ScriptStruct G01.GzAttachmentButtonCoordinates
// 0x0010 (0x0010 - 0x0000)
struct FGzAttachmentButtonCoordinates final
{
public:
	double                                        X;                                                 // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	double                                        Y;                                                 // 0x0008(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzAttachmentButtonCoordinates) == 0x000008, "Wrong alignment on FGzAttachmentButtonCoordinates");
static_assert(sizeof(FGzAttachmentButtonCoordinates) == 0x000010, "Wrong size on FGzAttachmentButtonCoordinates");
static_assert(offsetof(FGzAttachmentButtonCoordinates, X) == 0x000000, "Member 'FGzAttachmentButtonCoordinates::X' has a wrong offset!");
static_assert(offsetof(FGzAttachmentButtonCoordinates, Y) == 0x000008, "Member 'FGzAttachmentButtonCoordinates::Y' has a wrong offset!");

// ScriptStruct G01.GzLoadoutSelectionInitializeData
// 0x0020 (0x0020 - 0x0000)
struct FGzLoadoutSelectionInitializeData final
{
public:
	class FText                                   LoadoutSelectionCaption;                           // 0x0000(0x0010)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	class FText                                   ScreenDescription;                                 // 0x0010(0x0010)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzLoadoutSelectionInitializeData) == 0x000008, "Wrong alignment on FGzLoadoutSelectionInitializeData");
static_assert(sizeof(FGzLoadoutSelectionInitializeData) == 0x000020, "Wrong size on FGzLoadoutSelectionInitializeData");
static_assert(offsetof(FGzLoadoutSelectionInitializeData, LoadoutSelectionCaption) == 0x000000, "Member 'FGzLoadoutSelectionInitializeData::LoadoutSelectionCaption' has a wrong offset!");
static_assert(offsetof(FGzLoadoutSelectionInitializeData, ScreenDescription) == 0x000010, "Member 'FGzLoadoutSelectionInitializeData::ScreenDescription' has a wrong offset!");

// ScriptStruct G01.GzAttachmentButtonsCoordinates
// 0x0050 (0x0050 - 0x0000)
struct FGzAttachmentButtonsCoordinates final
{
public:
	TMap<EGzWeaponAttachmentType, struct FGzAttachmentButtonCoordinates> Coordinates;                                       // 0x0000(0x0050)(NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzAttachmentButtonsCoordinates) == 0x000008, "Wrong alignment on FGzAttachmentButtonsCoordinates");
static_assert(sizeof(FGzAttachmentButtonsCoordinates) == 0x000050, "Wrong size on FGzAttachmentButtonsCoordinates");
static_assert(offsetof(FGzAttachmentButtonsCoordinates, Coordinates) == 0x000000, "Member 'FGzAttachmentButtonsCoordinates::Coordinates' has a wrong offset!");

// ScriptStruct G01.GzTelemetryEventPayload
// 0x0010 (0x0010 - 0x0000)
struct FGzTelemetryEventPayload
{
public:
	class FString                                 MatchID;                                           // 0x0000(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
};
static_assert(alignof(FGzTelemetryEventPayload) == 0x000008, "Wrong alignment on FGzTelemetryEventPayload");
static_assert(sizeof(FGzTelemetryEventPayload) == 0x000010, "Wrong size on FGzTelemetryEventPayload");
static_assert(offsetof(FGzTelemetryEventPayload, MatchID) == 0x000000, "Member 'FGzTelemetryEventPayload::MatchID' has a wrong offset!");

// ScriptStruct G01.GzPlayerTelemetryEventPayload
// 0x0010 (0x0020 - 0x0010)
struct FGzPlayerTelemetryEventPayload : public FGzTelemetryEventPayload
{
public:
	class FString                                 PlayerSessionId;                                   // 0x0010(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
};
static_assert(alignof(FGzPlayerTelemetryEventPayload) == 0x000008, "Wrong alignment on FGzPlayerTelemetryEventPayload");
static_assert(sizeof(FGzPlayerTelemetryEventPayload) == 0x000020, "Wrong size on FGzPlayerTelemetryEventPayload");
static_assert(offsetof(FGzPlayerTelemetryEventPayload, PlayerSessionId) == 0x000010, "Member 'FGzPlayerTelemetryEventPayload::PlayerSessionId' has a wrong offset!");

// ScriptStruct G01.GzBattlePassSlotBaseRewardV2
// 0x0014 (0x0014 - 0x0000)
struct FGzBattlePassSlotBaseRewardV2
{
public:
	struct FGuid                                  ID;                                                // 0x0000(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2AB3[0x4];                                     // 0x0010(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGzBattlePassSlotBaseRewardV2) == 0x000004, "Wrong alignment on FGzBattlePassSlotBaseRewardV2");
static_assert(sizeof(FGzBattlePassSlotBaseRewardV2) == 0x000014, "Wrong size on FGzBattlePassSlotBaseRewardV2");
static_assert(offsetof(FGzBattlePassSlotBaseRewardV2, ID) == 0x000000, "Member 'FGzBattlePassSlotBaseRewardV2::ID' has a wrong offset!");

// ScriptStruct G01.GzAttachmentButtonsCoordinatesCollection
// 0x00A0 (0x00A0 - 0x0000)
struct FGzAttachmentButtonsCoordinatesCollection final
{
public:
	TMap<class FString, struct FGzAttachmentButtonsCoordinates> Overrides;                                         // 0x0000(0x0050)(NativeAccessSpecifierPublic)
	TMap<EGzWeaponAttachmentType, struct FGzAttachmentButtonCoordinates> Defaults;                                          // 0x0050(0x0050)(NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzAttachmentButtonsCoordinatesCollection) == 0x000008, "Wrong alignment on FGzAttachmentButtonsCoordinatesCollection");
static_assert(sizeof(FGzAttachmentButtonsCoordinatesCollection) == 0x0000A0, "Wrong size on FGzAttachmentButtonsCoordinatesCollection");
static_assert(offsetof(FGzAttachmentButtonsCoordinatesCollection, Overrides) == 0x000000, "Member 'FGzAttachmentButtonsCoordinatesCollection::Overrides' has a wrong offset!");
static_assert(offsetof(FGzAttachmentButtonsCoordinatesCollection, Defaults) == 0x000050, "Member 'FGzAttachmentButtonsCoordinatesCollection::Defaults' has a wrong offset!");

// ScriptStruct G01.GzPingSoundData
// 0x0020 (0x0020 - 0x0000)
struct FGzPingSoundData final
{
public:
	class UAkAudioEvent*                          AddedEvent;                                        // 0x0000(0x0008)(Edit, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAkAudioEvent*                          RemovedEvent;                                      // 0x0008(0x0008)(Edit, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAkAudioEvent*                          AgreeEvent;                                        // 0x0010(0x0008)(Edit, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAkAudioEvent*                          DisagreeEvent;                                     // 0x0018(0x0008)(Edit, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzPingSoundData) == 0x000008, "Wrong alignment on FGzPingSoundData");
static_assert(sizeof(FGzPingSoundData) == 0x000020, "Wrong size on FGzPingSoundData");
static_assert(offsetof(FGzPingSoundData, AddedEvent) == 0x000000, "Member 'FGzPingSoundData::AddedEvent' has a wrong offset!");
static_assert(offsetof(FGzPingSoundData, RemovedEvent) == 0x000008, "Member 'FGzPingSoundData::RemovedEvent' has a wrong offset!");
static_assert(offsetof(FGzPingSoundData, AgreeEvent) == 0x000010, "Member 'FGzPingSoundData::AgreeEvent' has a wrong offset!");
static_assert(offsetof(FGzPingSoundData, DisagreeEvent) == 0x000018, "Member 'FGzPingSoundData::DisagreeEvent' has a wrong offset!");

// ScriptStruct G01.GzNavLinkTraceConfig
// 0x0020 (0x0020 - 0x0000)
struct FGzNavLinkTraceConfig final
{
public:
	struct FRotator                               Rotation;                                          // 0x0000(0x0018)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	float                                         TraceDistance;                                     // 0x0018(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2AB4[0x4];                                     // 0x001C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGzNavLinkTraceConfig) == 0x000008, "Wrong alignment on FGzNavLinkTraceConfig");
static_assert(sizeof(FGzNavLinkTraceConfig) == 0x000020, "Wrong size on FGzNavLinkTraceConfig");
static_assert(offsetof(FGzNavLinkTraceConfig, Rotation) == 0x000000, "Member 'FGzNavLinkTraceConfig::Rotation' has a wrong offset!");
static_assert(offsetof(FGzNavLinkTraceConfig, TraceDistance) == 0x000018, "Member 'FGzNavLinkTraceConfig::TraceDistance' has a wrong offset!");

// ScriptStruct G01.GzSetCurrentCharacterResult
// 0x0020 (0x0100 - 0x00E0)
struct FGzSetCurrentCharacterResult final : public FGzPlayFabResultBase
{
public:
	class FString                                 PlayFabId;                                         // 0x00E0(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 CharacterId;                                       // 0x00F0(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzSetCurrentCharacterResult) == 0x000008, "Wrong alignment on FGzSetCurrentCharacterResult");
static_assert(sizeof(FGzSetCurrentCharacterResult) == 0x000100, "Wrong size on FGzSetCurrentCharacterResult");
static_assert(offsetof(FGzSetCurrentCharacterResult, PlayFabId) == 0x0000E0, "Member 'FGzSetCurrentCharacterResult::PlayFabId' has a wrong offset!");
static_assert(offsetof(FGzSetCurrentCharacterResult, CharacterId) == 0x0000F0, "Member 'FGzSetCurrentCharacterResult::CharacterId' has a wrong offset!");

// ScriptStruct G01.GzAudioHintData
// 0x0060 (0x0060 - 0x0000)
struct FGzAudioHintData final
{
public:
	class UGzMultiPositionAkComponent*            AkComponent;                                       // 0x0000(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSet<class UGzAudioHintComponent*>            AudioHintComponents;                               // 0x0008(0x0050)(ExportObject, ContainsInstancedReference, NativeAccessSpecifierPublic)
	uint8                                         Pad_2AB5[0x8];                                     // 0x0058(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGzAudioHintData) == 0x000008, "Wrong alignment on FGzAudioHintData");
static_assert(sizeof(FGzAudioHintData) == 0x000060, "Wrong size on FGzAudioHintData");
static_assert(offsetof(FGzAudioHintData, AkComponent) == 0x000000, "Member 'FGzAudioHintData::AkComponent' has a wrong offset!");
static_assert(offsetof(FGzAudioHintData, AudioHintComponents) == 0x000008, "Member 'FGzAudioHintData::AudioHintComponents' has a wrong offset!");

// ScriptStruct G01.GzBackendActiveAchievementStage
// 0x0010 (0x0010 - 0x0000)
struct FGzBackendActiveAchievementStage final
{
public:
	TArray<class FName>                           Rewards;                                           // 0x0000(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzBackendActiveAchievementStage) == 0x000008, "Wrong alignment on FGzBackendActiveAchievementStage");
static_assert(sizeof(FGzBackendActiveAchievementStage) == 0x000010, "Wrong size on FGzBackendActiveAchievementStage");
static_assert(offsetof(FGzBackendActiveAchievementStage, Rewards) == 0x000000, "Member 'FGzBackendActiveAchievementStage::Rewards' has a wrong offset!");

// ScriptStruct G01.GzNPCTeamAttitude
// 0x0008 (0x0008 - 0x0000)
struct FGzNPCTeamAttitude final
{
public:
	int32                                         TeamID;                                            // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ENPCTeamAttitude                              TeamAttitude;                                      // 0x0004(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2AB6[0x3];                                     // 0x0005(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGzNPCTeamAttitude) == 0x000004, "Wrong alignment on FGzNPCTeamAttitude");
static_assert(sizeof(FGzNPCTeamAttitude) == 0x000008, "Wrong size on FGzNPCTeamAttitude");
static_assert(offsetof(FGzNPCTeamAttitude, TeamID) == 0x000000, "Member 'FGzNPCTeamAttitude::TeamID' has a wrong offset!");
static_assert(offsetof(FGzNPCTeamAttitude, TeamAttitude) == 0x000004, "Member 'FGzNPCTeamAttitude::TeamAttitude' has a wrong offset!");

// ScriptStruct G01.GzPackageLoadoutSlotItem
// 0x0038 (0x0038 - 0x0000)
struct FGzPackageLoadoutSlotItem final
{
public:
	class FString                                 InstanceId;                                        // 0x0000(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 AssetId;                                           // 0x0010(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Quantity;                                          // 0x0020(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2AB7[0x4];                                     // 0x0024(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 WeaponConfigurationId;                             // 0x0028(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzPackageLoadoutSlotItem) == 0x000008, "Wrong alignment on FGzPackageLoadoutSlotItem");
static_assert(sizeof(FGzPackageLoadoutSlotItem) == 0x000038, "Wrong size on FGzPackageLoadoutSlotItem");
static_assert(offsetof(FGzPackageLoadoutSlotItem, InstanceId) == 0x000000, "Member 'FGzPackageLoadoutSlotItem::InstanceId' has a wrong offset!");
static_assert(offsetof(FGzPackageLoadoutSlotItem, AssetId) == 0x000010, "Member 'FGzPackageLoadoutSlotItem::AssetId' has a wrong offset!");
static_assert(offsetof(FGzPackageLoadoutSlotItem, Quantity) == 0x000020, "Member 'FGzPackageLoadoutSlotItem::Quantity' has a wrong offset!");
static_assert(offsetof(FGzPackageLoadoutSlotItem, WeaponConfigurationId) == 0x000028, "Member 'FGzPackageLoadoutSlotItem::WeaponConfigurationId' has a wrong offset!");

// ScriptStruct G01.GzBackendActiveAchievement
// 0x0018 (0x0018 - 0x0000)
struct FGzBackendActiveAchievement final
{
public:
	class FName                                   ID;                                                // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FGzBackendActiveAchievementStage> Stages;                                            // 0x0008(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzBackendActiveAchievement) == 0x000008, "Wrong alignment on FGzBackendActiveAchievement");
static_assert(sizeof(FGzBackendActiveAchievement) == 0x000018, "Wrong size on FGzBackendActiveAchievement");
static_assert(offsetof(FGzBackendActiveAchievement, ID) == 0x000000, "Member 'FGzBackendActiveAchievement::ID' has a wrong offset!");
static_assert(offsetof(FGzBackendActiveAchievement, Stages) == 0x000008, "Member 'FGzBackendActiveAchievement::Stages' has a wrong offset!");

// ScriptStruct G01.GzMarkerServerDataArray
// 0x0058 (0x0168 - 0x0110)
struct FGzMarkerServerDataArray final : public FFastArraySerializer
{
public:
	uint8                                         Pad_2AB8[0x48];                                    // 0x0110(0x0048)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FGzMarkerServerData>            Markers;                                           // 0x0158(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzMarkerServerDataArray) == 0x000008, "Wrong alignment on FGzMarkerServerDataArray");
static_assert(sizeof(FGzMarkerServerDataArray) == 0x000168, "Wrong size on FGzMarkerServerDataArray");
static_assert(offsetof(FGzMarkerServerDataArray, Markers) == 0x000158, "Member 'FGzMarkerServerDataArray::Markers' has a wrong offset!");

// ScriptStruct G01.GzBackendActiveAchievementsCollection
// 0x0010 (0x0010 - 0x0000)
struct FGzBackendActiveAchievementsCollection final
{
public:
	TArray<struct FGzBackendActiveAchievement>    Values;                                            // 0x0000(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzBackendActiveAchievementsCollection) == 0x000008, "Wrong alignment on FGzBackendActiveAchievementsCollection");
static_assert(sizeof(FGzBackendActiveAchievementsCollection) == 0x000010, "Wrong size on FGzBackendActiveAchievementsCollection");
static_assert(offsetof(FGzBackendActiveAchievementsCollection, Values) == 0x000000, "Member 'FGzBackendActiveAchievementsCollection::Values' has a wrong offset!");

// ScriptStruct G01.GzGetSignalrConnectionInfoResult
// 0x0020 (0x0100 - 0x00E0)
struct FGzGetSignalrConnectionInfoResult final : public FGzPlayFabResultBase
{
public:
	class FString                                 URL;                                               // 0x00E0(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 AccessToken;                                       // 0x00F0(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzGetSignalrConnectionInfoResult) == 0x000008, "Wrong alignment on FGzGetSignalrConnectionInfoResult");
static_assert(sizeof(FGzGetSignalrConnectionInfoResult) == 0x000100, "Wrong size on FGzGetSignalrConnectionInfoResult");
static_assert(offsetof(FGzGetSignalrConnectionInfoResult, URL) == 0x0000E0, "Member 'FGzGetSignalrConnectionInfoResult::URL' has a wrong offset!");
static_assert(offsetof(FGzGetSignalrConnectionInfoResult, AccessToken) == 0x0000F0, "Member 'FGzGetSignalrConnectionInfoResult::AccessToken' has a wrong offset!");

// ScriptStruct G01.GzBackendBan
// 0x0030 (0x0030 - 0x0000)
struct FGzBackendBan final
{
public:
	class FString                                 Type;                                              // 0x0000(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Reason;                                            // 0x0010(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FDateTime                              Created;                                           // 0x0020(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FDateTime                              ExpiresAt;                                         // 0x0028(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzBackendBan) == 0x000008, "Wrong alignment on FGzBackendBan");
static_assert(sizeof(FGzBackendBan) == 0x000030, "Wrong size on FGzBackendBan");
static_assert(offsetof(FGzBackendBan, Type) == 0x000000, "Member 'FGzBackendBan::Type' has a wrong offset!");
static_assert(offsetof(FGzBackendBan, Reason) == 0x000010, "Member 'FGzBackendBan::Reason' has a wrong offset!");
static_assert(offsetof(FGzBackendBan, Created) == 0x000020, "Member 'FGzBackendBan::Created' has a wrong offset!");
static_assert(offsetof(FGzBackendBan, ExpiresAt) == 0x000028, "Member 'FGzBackendBan::ExpiresAt' has a wrong offset!");

// ScriptStruct G01.GzMapMaterialNameParams
// 0x0050 (0x0050 - 0x0000)
struct FGzMapMaterialNameParams final
{
public:
	class FName                                   MapRotationAngle;                                  // 0x0000(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   MapScale;                                          // 0x0008(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   MapOffset;                                         // 0x0010(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   MapBlendingOffset;                                 // 0x0018(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   MapBlendingRange;                                  // 0x0020(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   MapBlendingColor;                                  // 0x0028(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   MapTexture;                                        // 0x0030(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   ZoneMask;                                          // 0x0038(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   ZoneParamsPacked;                                  // 0x0040(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   ZoneRadius;                                        // 0x0048(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzMapMaterialNameParams) == 0x000004, "Wrong alignment on FGzMapMaterialNameParams");
static_assert(sizeof(FGzMapMaterialNameParams) == 0x000050, "Wrong size on FGzMapMaterialNameParams");
static_assert(offsetof(FGzMapMaterialNameParams, MapRotationAngle) == 0x000000, "Member 'FGzMapMaterialNameParams::MapRotationAngle' has a wrong offset!");
static_assert(offsetof(FGzMapMaterialNameParams, MapScale) == 0x000008, "Member 'FGzMapMaterialNameParams::MapScale' has a wrong offset!");
static_assert(offsetof(FGzMapMaterialNameParams, MapOffset) == 0x000010, "Member 'FGzMapMaterialNameParams::MapOffset' has a wrong offset!");
static_assert(offsetof(FGzMapMaterialNameParams, MapBlendingOffset) == 0x000018, "Member 'FGzMapMaterialNameParams::MapBlendingOffset' has a wrong offset!");
static_assert(offsetof(FGzMapMaterialNameParams, MapBlendingRange) == 0x000020, "Member 'FGzMapMaterialNameParams::MapBlendingRange' has a wrong offset!");
static_assert(offsetof(FGzMapMaterialNameParams, MapBlendingColor) == 0x000028, "Member 'FGzMapMaterialNameParams::MapBlendingColor' has a wrong offset!");
static_assert(offsetof(FGzMapMaterialNameParams, MapTexture) == 0x000030, "Member 'FGzMapMaterialNameParams::MapTexture' has a wrong offset!");
static_assert(offsetof(FGzMapMaterialNameParams, ZoneMask) == 0x000038, "Member 'FGzMapMaterialNameParams::ZoneMask' has a wrong offset!");
static_assert(offsetof(FGzMapMaterialNameParams, ZoneParamsPacked) == 0x000040, "Member 'FGzMapMaterialNameParams::ZoneParamsPacked' has a wrong offset!");
static_assert(offsetof(FGzMapMaterialNameParams, ZoneRadius) == 0x000048, "Member 'FGzMapMaterialNameParams::ZoneRadius' has a wrong offset!");

// ScriptStruct G01.GzBackendBans
// 0x0010 (0x0010 - 0x0000)
struct FGzBackendBans final
{
public:
	TArray<struct FGzBackendBan>                  Values;                                            // 0x0000(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzBackendBans) == 0x000008, "Wrong alignment on FGzBackendBans");
static_assert(sizeof(FGzBackendBans) == 0x000010, "Wrong size on FGzBackendBans");
static_assert(offsetof(FGzBackendBans, Values) == 0x000000, "Member 'FGzBackendBans::Values' has a wrong offset!");

// ScriptStruct G01.GzTitleTelemetryEventPayload
// 0x0000 (0x0010 - 0x0010)
struct FGzTitleTelemetryEventPayload : public FGzTelemetryEventPayload
{
};
static_assert(alignof(FGzTitleTelemetryEventPayload) == 0x000008, "Wrong alignment on FGzTitleTelemetryEventPayload");
static_assert(sizeof(FGzTitleTelemetryEventPayload) == 0x000010, "Wrong size on FGzTitleTelemetryEventPayload");

// ScriptStruct G01.GzMatchStartedTelemetryEventPayload
// 0x0028 (0x0038 - 0x0010)
struct FGzMatchStartedTelemetryEventPayload final : public FGzTitleTelemetryEventPayload
{
public:
	class FString                                 GameMode;                                          // 0x0010(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Address;                                           // 0x0020(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaxTeamCapacity;                                   // 0x0030(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaxTeamCount;                                      // 0x0034(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzMatchStartedTelemetryEventPayload) == 0x000008, "Wrong alignment on FGzMatchStartedTelemetryEventPayload");
static_assert(sizeof(FGzMatchStartedTelemetryEventPayload) == 0x000038, "Wrong size on FGzMatchStartedTelemetryEventPayload");
static_assert(offsetof(FGzMatchStartedTelemetryEventPayload, GameMode) == 0x000010, "Member 'FGzMatchStartedTelemetryEventPayload::GameMode' has a wrong offset!");
static_assert(offsetof(FGzMatchStartedTelemetryEventPayload, Address) == 0x000020, "Member 'FGzMatchStartedTelemetryEventPayload::Address' has a wrong offset!");
static_assert(offsetof(FGzMatchStartedTelemetryEventPayload, MaxTeamCapacity) == 0x000030, "Member 'FGzMatchStartedTelemetryEventPayload::MaxTeamCapacity' has a wrong offset!");
static_assert(offsetof(FGzMatchStartedTelemetryEventPayload, MaxTeamCount) == 0x000034, "Member 'FGzMatchStartedTelemetryEventPayload::MaxTeamCount' has a wrong offset!");

// ScriptStruct G01.GzGetChallengesResultChallenge
// 0x0018 (0x0018 - 0x0000)
struct FGzGetChallengesResultChallenge final
{
public:
	class FString                                 ID;                                                // 0x0000(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Progress;                                          // 0x0010(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsCompleted;                                       // 0x0014(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2AB9[0x3];                                     // 0x0015(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGzGetChallengesResultChallenge) == 0x000008, "Wrong alignment on FGzGetChallengesResultChallenge");
static_assert(sizeof(FGzGetChallengesResultChallenge) == 0x000018, "Wrong size on FGzGetChallengesResultChallenge");
static_assert(offsetof(FGzGetChallengesResultChallenge, ID) == 0x000000, "Member 'FGzGetChallengesResultChallenge::ID' has a wrong offset!");
static_assert(offsetof(FGzGetChallengesResultChallenge, Progress) == 0x000010, "Member 'FGzGetChallengesResultChallenge::Progress' has a wrong offset!");
static_assert(offsetof(FGzGetChallengesResultChallenge, IsCompleted) == 0x000014, "Member 'FGzGetChallengesResultChallenge::IsCompleted' has a wrong offset!");

// ScriptStruct G01.GzGetChallengesResultChallengesPack
// 0x0020 (0x0020 - 0x0000)
struct FGzGetChallengesResultChallengesPack final
{
public:
	TArray<struct FGzGetChallengesResultChallenge> List;                                              // 0x0000(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	class FString                                 ExpireIn;                                          // 0x0010(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzGetChallengesResultChallengesPack) == 0x000008, "Wrong alignment on FGzGetChallengesResultChallengesPack");
static_assert(sizeof(FGzGetChallengesResultChallengesPack) == 0x000020, "Wrong size on FGzGetChallengesResultChallengesPack");
static_assert(offsetof(FGzGetChallengesResultChallengesPack, List) == 0x000000, "Member 'FGzGetChallengesResultChallengesPack::List' has a wrong offset!");
static_assert(offsetof(FGzGetChallengesResultChallengesPack, ExpireIn) == 0x000010, "Member 'FGzGetChallengesResultChallengesPack::ExpireIn' has a wrong offset!");

// ScriptStruct G01.GzNotificationDisposeRequest
// 0x000C (0x000C - 0x0000)
struct FGzNotificationDisposeRequest final
{
public:
	bool                                          bNotify;                                           // 0x0000(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bRequestRunning;                                   // 0x0001(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2ABA[0x2];                                     // 0x0002(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   ID;                                                // 0x0004(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzNotificationDisposeRequest) == 0x000004, "Wrong alignment on FGzNotificationDisposeRequest");
static_assert(sizeof(FGzNotificationDisposeRequest) == 0x00000C, "Wrong size on FGzNotificationDisposeRequest");
static_assert(offsetof(FGzNotificationDisposeRequest, bNotify) == 0x000000, "Member 'FGzNotificationDisposeRequest::bNotify' has a wrong offset!");
static_assert(offsetof(FGzNotificationDisposeRequest, bRequestRunning) == 0x000001, "Member 'FGzNotificationDisposeRequest::bRequestRunning' has a wrong offset!");
static_assert(offsetof(FGzNotificationDisposeRequest, ID) == 0x000004, "Member 'FGzNotificationDisposeRequest::ID' has a wrong offset!");

// ScriptStruct G01.GzHoverParams
// 0x001C (0x001C - 0x0000)
struct FGzHoverParams final
{
public:
	float                                         HoverTimeSeconds;                                  // 0x0000(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HoverHorizontalDecelerationFriction;               // 0x0004(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HoverHorizontalDecelerationStrength;               // 0x0008(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HoverVerticalDecelerationFriction;                 // 0x000C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HoverVerticalDecelerationStrength;                 // 0x0010(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HoverUpVerticalDecelerationFriction;               // 0x0014(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HoverUpVerticalDecelerationStrength;               // 0x0018(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzHoverParams) == 0x000004, "Wrong alignment on FGzHoverParams");
static_assert(sizeof(FGzHoverParams) == 0x00001C, "Wrong size on FGzHoverParams");
static_assert(offsetof(FGzHoverParams, HoverTimeSeconds) == 0x000000, "Member 'FGzHoverParams::HoverTimeSeconds' has a wrong offset!");
static_assert(offsetof(FGzHoverParams, HoverHorizontalDecelerationFriction) == 0x000004, "Member 'FGzHoverParams::HoverHorizontalDecelerationFriction' has a wrong offset!");
static_assert(offsetof(FGzHoverParams, HoverHorizontalDecelerationStrength) == 0x000008, "Member 'FGzHoverParams::HoverHorizontalDecelerationStrength' has a wrong offset!");
static_assert(offsetof(FGzHoverParams, HoverVerticalDecelerationFriction) == 0x00000C, "Member 'FGzHoverParams::HoverVerticalDecelerationFriction' has a wrong offset!");
static_assert(offsetof(FGzHoverParams, HoverVerticalDecelerationStrength) == 0x000010, "Member 'FGzHoverParams::HoverVerticalDecelerationStrength' has a wrong offset!");
static_assert(offsetof(FGzHoverParams, HoverUpVerticalDecelerationFriction) == 0x000014, "Member 'FGzHoverParams::HoverUpVerticalDecelerationFriction' has a wrong offset!");
static_assert(offsetof(FGzHoverParams, HoverUpVerticalDecelerationStrength) == 0x000018, "Member 'FGzHoverParams::HoverUpVerticalDecelerationStrength' has a wrong offset!");

// ScriptStruct G01.GzDeleteCharacterResult
// 0x0020 (0x0100 - 0x00E0)
struct FGzDeleteCharacterResult final : public FGzPlayFabResultBase
{
public:
	class FString                                 PlayFabId;                                         // 0x00E0(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 CharacterId;                                       // 0x00F0(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzDeleteCharacterResult) == 0x000008, "Wrong alignment on FGzDeleteCharacterResult");
static_assert(sizeof(FGzDeleteCharacterResult) == 0x000100, "Wrong size on FGzDeleteCharacterResult");
static_assert(offsetof(FGzDeleteCharacterResult, PlayFabId) == 0x0000E0, "Member 'FGzDeleteCharacterResult::PlayFabId' has a wrong offset!");
static_assert(offsetof(FGzDeleteCharacterResult, CharacterId) == 0x0000F0, "Member 'FGzDeleteCharacterResult::CharacterId' has a wrong offset!");

// ScriptStruct G01.GzMarkerClassSettings
// 0x0078 (0x0078 - 0x0000)
struct FGzMarkerClassSettings final
{
public:
	TSoftClassPtr<class UClass>                   MapMarkerWidgetClass;                              // 0x0000(0x0028)(Edit, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftClassPtr<class UClass>                   CompassMarkerWidgetClass;                          // 0x0028(0x0028)(Edit, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftClassPtr<class UClass>                   ViewportMarkerWidgetClass;                         // 0x0050(0x0028)(Edit, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzMarkerClassSettings) == 0x000008, "Wrong alignment on FGzMarkerClassSettings");
static_assert(sizeof(FGzMarkerClassSettings) == 0x000078, "Wrong size on FGzMarkerClassSettings");
static_assert(offsetof(FGzMarkerClassSettings, MapMarkerWidgetClass) == 0x000000, "Member 'FGzMarkerClassSettings::MapMarkerWidgetClass' has a wrong offset!");
static_assert(offsetof(FGzMarkerClassSettings, CompassMarkerWidgetClass) == 0x000028, "Member 'FGzMarkerClassSettings::CompassMarkerWidgetClass' has a wrong offset!");
static_assert(offsetof(FGzMarkerClassSettings, ViewportMarkerWidgetClass) == 0x000050, "Member 'FGzMarkerClassSettings::ViewportMarkerWidgetClass' has a wrong offset!");

// ScriptStruct G01.GzMarkerSettings
// 0x0090 (0x0090 - 0x0000)
struct FGzMarkerSettings final
{
public:
	bool                                          bStickCompassMarkerToEdges;                        // 0x0000(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2ABB[0x3];                                     // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         Priority;                                          // 0x0004(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUse3DRange;                                       // 0x0008(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2ABC[0x7];                                     // 0x0009(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGzMarkerClassSettings                 ClassSettings;                                     // 0x0010(0x0078)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	class UGzMarkerRadiusSettingAsset*            RadiusSettings;                                    // 0x0088(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
};
static_assert(alignof(FGzMarkerSettings) == 0x000008, "Wrong alignment on FGzMarkerSettings");
static_assert(sizeof(FGzMarkerSettings) == 0x000090, "Wrong size on FGzMarkerSettings");
static_assert(offsetof(FGzMarkerSettings, bStickCompassMarkerToEdges) == 0x000000, "Member 'FGzMarkerSettings::bStickCompassMarkerToEdges' has a wrong offset!");
static_assert(offsetof(FGzMarkerSettings, Priority) == 0x000004, "Member 'FGzMarkerSettings::Priority' has a wrong offset!");
static_assert(offsetof(FGzMarkerSettings, bUse3DRange) == 0x000008, "Member 'FGzMarkerSettings::bUse3DRange' has a wrong offset!");
static_assert(offsetof(FGzMarkerSettings, ClassSettings) == 0x000010, "Member 'FGzMarkerSettings::ClassSettings' has a wrong offset!");
static_assert(offsetof(FGzMarkerSettings, RadiusSettings) == 0x000088, "Member 'FGzMarkerSettings::RadiusSettings' has a wrong offset!");

// ScriptStruct G01.GzBackendBattlePassBoughtSlotV2
// 0x0048 (0x0048 - 0x0000)
struct FGzBackendBattlePassBoughtSlotV2 final
{
public:
	class FString                                 SlotID;                                            // 0x0000(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 SlotRewardId;                                      // 0x0010(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 AssetId;                                           // 0x0020(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Price;                                             // 0x0030(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FDateTime                              BoughtAt;                                          // 0x0040(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzBackendBattlePassBoughtSlotV2) == 0x000008, "Wrong alignment on FGzBackendBattlePassBoughtSlotV2");
static_assert(sizeof(FGzBackendBattlePassBoughtSlotV2) == 0x000048, "Wrong size on FGzBackendBattlePassBoughtSlotV2");
static_assert(offsetof(FGzBackendBattlePassBoughtSlotV2, SlotID) == 0x000000, "Member 'FGzBackendBattlePassBoughtSlotV2::SlotID' has a wrong offset!");
static_assert(offsetof(FGzBackendBattlePassBoughtSlotV2, SlotRewardId) == 0x000010, "Member 'FGzBackendBattlePassBoughtSlotV2::SlotRewardId' has a wrong offset!");
static_assert(offsetof(FGzBackendBattlePassBoughtSlotV2, AssetId) == 0x000020, "Member 'FGzBackendBattlePassBoughtSlotV2::AssetId' has a wrong offset!");
static_assert(offsetof(FGzBackendBattlePassBoughtSlotV2, Price) == 0x000030, "Member 'FGzBackendBattlePassBoughtSlotV2::Price' has a wrong offset!");
static_assert(offsetof(FGzBackendBattlePassBoughtSlotV2, BoughtAt) == 0x000040, "Member 'FGzBackendBattlePassBoughtSlotV2::BoughtAt' has a wrong offset!");

// ScriptStruct G01.GzTelemetryTeamInfo
// 0x0018 (0x0018 - 0x0000)
struct FGzTelemetryTeamInfo final
{
public:
	int32                                         TeamID;                                            // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2ABD[0x4];                                     // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FString>                         TeamTitlePlayerIds;                                // 0x0008(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzTelemetryTeamInfo) == 0x000008, "Wrong alignment on FGzTelemetryTeamInfo");
static_assert(sizeof(FGzTelemetryTeamInfo) == 0x000018, "Wrong size on FGzTelemetryTeamInfo");
static_assert(offsetof(FGzTelemetryTeamInfo, TeamID) == 0x000000, "Member 'FGzTelemetryTeamInfo::TeamID' has a wrong offset!");
static_assert(offsetof(FGzTelemetryTeamInfo, TeamTitlePlayerIds) == 0x000008, "Member 'FGzTelemetryTeamInfo::TeamTitlePlayerIds' has a wrong offset!");

// ScriptStruct G01.GzTeamsEstablishedTelemetryEventPayload
// 0x0010 (0x0020 - 0x0010)
struct FGzTeamsEstablishedTelemetryEventPayload final : public FGzTitleTelemetryEventPayload
{
public:
	TArray<struct FGzTelemetryTeamInfo>           Teams;                                             // 0x0010(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzTeamsEstablishedTelemetryEventPayload) == 0x000008, "Wrong alignment on FGzTeamsEstablishedTelemetryEventPayload");
static_assert(sizeof(FGzTeamsEstablishedTelemetryEventPayload) == 0x000020, "Wrong size on FGzTeamsEstablishedTelemetryEventPayload");
static_assert(offsetof(FGzTeamsEstablishedTelemetryEventPayload, Teams) == 0x000010, "Member 'FGzTeamsEstablishedTelemetryEventPayload::Teams' has a wrong offset!");

// ScriptStruct G01.GzDiscoveryResultNewsInfo
// 0x0020 (0x0020 - 0x0000)
struct FGzDiscoveryResultNewsInfo final
{
public:
	class FString                                 CdnUrl;                                            // 0x0000(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 NewsUrlTemplate;                                   // 0x0010(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzDiscoveryResultNewsInfo) == 0x000008, "Wrong alignment on FGzDiscoveryResultNewsInfo");
static_assert(sizeof(FGzDiscoveryResultNewsInfo) == 0x000020, "Wrong size on FGzDiscoveryResultNewsInfo");
static_assert(offsetof(FGzDiscoveryResultNewsInfo, CdnUrl) == 0x000000, "Member 'FGzDiscoveryResultNewsInfo::CdnUrl' has a wrong offset!");
static_assert(offsetof(FGzDiscoveryResultNewsInfo, NewsUrlTemplate) == 0x000010, "Member 'FGzDiscoveryResultNewsInfo::NewsUrlTemplate' has a wrong offset!");

// ScriptStruct G01.GzBackendBattlePassProgressionV2
// 0x0020 (0x0020 - 0x0000)
struct FGzBackendBattlePassProgressionV2 final
{
public:
	TArray<struct FGzBackendBattlePassBoughtSlotV2> BoughtSlots;                                       // 0x0000(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	struct FGzBackendBattlePassLevelProgressionV2 LevelProgression;                                  // 0x0010(0x000C)(NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_2ABE[0x4];                                     // 0x001C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGzBackendBattlePassProgressionV2) == 0x000008, "Wrong alignment on FGzBackendBattlePassProgressionV2");
static_assert(sizeof(FGzBackendBattlePassProgressionV2) == 0x000020, "Wrong size on FGzBackendBattlePassProgressionV2");
static_assert(offsetof(FGzBackendBattlePassProgressionV2, BoughtSlots) == 0x000000, "Member 'FGzBackendBattlePassProgressionV2::BoughtSlots' has a wrong offset!");
static_assert(offsetof(FGzBackendBattlePassProgressionV2, LevelProgression) == 0x000010, "Member 'FGzBackendBattlePassProgressionV2::LevelProgression' has a wrong offset!");

// ScriptStruct G01.GzBackendCompletedAchievementStage
// 0x0010 (0x0010 - 0x0000)
struct FGzBackendCompletedAchievementStage final
{
public:
	class FString                                 CompletedAt;                                       // 0x0000(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzBackendCompletedAchievementStage) == 0x000008, "Wrong alignment on FGzBackendCompletedAchievementStage");
static_assert(sizeof(FGzBackendCompletedAchievementStage) == 0x000010, "Wrong size on FGzBackendCompletedAchievementStage");
static_assert(offsetof(FGzBackendCompletedAchievementStage, CompletedAt) == 0x000000, "Member 'FGzBackendCompletedAchievementStage::CompletedAt' has a wrong offset!");

// ScriptStruct G01.GzResultCheatResetAllAchievements
// 0x0000 (0x00E0 - 0x00E0)
struct FGzResultCheatResetAllAchievements final : public FGzPlayFabResultBase
{
};
static_assert(alignof(FGzResultCheatResetAllAchievements) == 0x000008, "Wrong alignment on FGzResultCheatResetAllAchievements");
static_assert(sizeof(FGzResultCheatResetAllAchievements) == 0x0000E0, "Wrong size on FGzResultCheatResetAllAchievements");

// ScriptStruct G01.GzBackendCompletedAchievementStagesCollection
// 0x0018 (0x0018 - 0x0000)
struct FGzBackendCompletedAchievementStagesCollection final
{
public:
	class FName                                   ID;                                                // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FGzBackendCompletedAchievementStage> CompletedStages;                                   // 0x0008(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzBackendCompletedAchievementStagesCollection) == 0x000008, "Wrong alignment on FGzBackendCompletedAchievementStagesCollection");
static_assert(sizeof(FGzBackendCompletedAchievementStagesCollection) == 0x000018, "Wrong size on FGzBackendCompletedAchievementStagesCollection");
static_assert(offsetof(FGzBackendCompletedAchievementStagesCollection, ID) == 0x000000, "Member 'FGzBackendCompletedAchievementStagesCollection::ID' has a wrong offset!");
static_assert(offsetof(FGzBackendCompletedAchievementStagesCollection, CompletedStages) == 0x000008, "Member 'FGzBackendCompletedAchievementStagesCollection::CompletedStages' has a wrong offset!");

// ScriptStruct G01.GzBackendCompletedAchievementsCollection
// 0x0010 (0x0010 - 0x0000)
struct FGzBackendCompletedAchievementsCollection final
{
public:
	TArray<struct FGzBackendCompletedAchievementStagesCollection> Values;                                            // 0x0000(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzBackendCompletedAchievementsCollection) == 0x000008, "Wrong alignment on FGzBackendCompletedAchievementsCollection");
static_assert(sizeof(FGzBackendCompletedAchievementsCollection) == 0x000010, "Wrong size on FGzBackendCompletedAchievementsCollection");
static_assert(offsetof(FGzBackendCompletedAchievementsCollection, Values) == 0x000000, "Member 'FGzBackendCompletedAchievementsCollection::Values' has a wrong offset!");

// ScriptStruct G01.GzMetaListMarketOrderParameters
// 0x0002 (0x0002 - 0x0000)
struct FGzMetaListMarketOrderParameters final
{
public:
	EGzMetaListMarketOrder                        Order;                                             // 0x0000(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EGzMetaListMarketOrderType                    OrderType;                                         // 0x0001(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzMetaListMarketOrderParameters) == 0x000001, "Wrong alignment on FGzMetaListMarketOrderParameters");
static_assert(sizeof(FGzMetaListMarketOrderParameters) == 0x000002, "Wrong size on FGzMetaListMarketOrderParameters");
static_assert(offsetof(FGzMetaListMarketOrderParameters, Order) == 0x000000, "Member 'FGzMetaListMarketOrderParameters::Order' has a wrong offset!");
static_assert(offsetof(FGzMetaListMarketOrderParameters, OrderType) == 0x000001, "Member 'FGzMetaListMarketOrderParameters::OrderType' has a wrong offset!");

// ScriptStruct G01.GzResultCollectPlayerSatisfaction
// 0x0000 (0x00E0 - 0x00E0)
struct FGzResultCollectPlayerSatisfaction final : public FGzPlayFabResultBase
{
};
static_assert(alignof(FGzResultCollectPlayerSatisfaction) == 0x000008, "Wrong alignment on FGzResultCollectPlayerSatisfaction");
static_assert(sizeof(FGzResultCollectPlayerSatisfaction) == 0x0000E0, "Wrong size on FGzResultCollectPlayerSatisfaction");

// ScriptStruct G01.GzCharacterDataContainer
// 0x0050 (0x0050 - 0x0000)
struct alignas(0x08) FGzCharacterDataContainer final
{
public:
	uint8                                         Pad_2ABF[0x50];                                    // 0x0000(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGzCharacterDataContainer) == 0x000008, "Wrong alignment on FGzCharacterDataContainer");
static_assert(sizeof(FGzCharacterDataContainer) == 0x000050, "Wrong size on FGzCharacterDataContainer");

// ScriptStruct G01.GzResultCheatRegenerateChallenges
// 0x0000 (0x00E0 - 0x00E0)
struct FGzResultCheatRegenerateChallenges final : public FGzPlayFabResultBase
{
};
static_assert(alignof(FGzResultCheatRegenerateChallenges) == 0x000008, "Wrong alignment on FGzResultCheatRegenerateChallenges");
static_assert(sizeof(FGzResultCheatRegenerateChallenges) == 0x0000E0, "Wrong size on FGzResultCheatRegenerateChallenges");

// ScriptStruct G01.GzResultMarketplaceQuickBuyItemInfo
// 0x0018 (0x00F8 - 0x00E0)
struct FGzResultMarketplaceQuickBuyItemInfo final : public FGzPlayFabResultBase
{
public:
	int32                                         Count;                                             // 0x00E0(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2AC0[0x4];                                     // 0x00E4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 MinPrice;                                          // 0x00E8(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzResultMarketplaceQuickBuyItemInfo) == 0x000008, "Wrong alignment on FGzResultMarketplaceQuickBuyItemInfo");
static_assert(sizeof(FGzResultMarketplaceQuickBuyItemInfo) == 0x0000F8, "Wrong size on FGzResultMarketplaceQuickBuyItemInfo");
static_assert(offsetof(FGzResultMarketplaceQuickBuyItemInfo, Count) == 0x0000E0, "Member 'FGzResultMarketplaceQuickBuyItemInfo::Count' has a wrong offset!");
static_assert(offsetof(FGzResultMarketplaceQuickBuyItemInfo, MinPrice) == 0x0000E8, "Member 'FGzResultMarketplaceQuickBuyItemInfo::MinPrice' has a wrong offset!");

// ScriptStruct G01.GzBackendNews
// 0x0060 (0x0060 - 0x0000)
struct FGzBackendNews final
{
public:
	class FString                                 ID;                                                // 0x0000(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Lang;                                              // 0x0010(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EGzNewsType                                   Type;                                              // 0x0020(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2AC1[0x7];                                     // 0x0021(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 Title;                                             // 0x0028(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Subtitle;                                          // 0x0038(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FDateTime                              Time;                                              // 0x0048(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Body;                                              // 0x0050(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzBackendNews) == 0x000008, "Wrong alignment on FGzBackendNews");
static_assert(sizeof(FGzBackendNews) == 0x000060, "Wrong size on FGzBackendNews");
static_assert(offsetof(FGzBackendNews, ID) == 0x000000, "Member 'FGzBackendNews::ID' has a wrong offset!");
static_assert(offsetof(FGzBackendNews, Lang) == 0x000010, "Member 'FGzBackendNews::Lang' has a wrong offset!");
static_assert(offsetof(FGzBackendNews, Type) == 0x000020, "Member 'FGzBackendNews::Type' has a wrong offset!");
static_assert(offsetof(FGzBackendNews, Title) == 0x000028, "Member 'FGzBackendNews::Title' has a wrong offset!");
static_assert(offsetof(FGzBackendNews, Subtitle) == 0x000038, "Member 'FGzBackendNews::Subtitle' has a wrong offset!");
static_assert(offsetof(FGzBackendNews, Time) == 0x000048, "Member 'FGzBackendNews::Time' has a wrong offset!");
static_assert(offsetof(FGzBackendNews, Body) == 0x000050, "Member 'FGzBackendNews::Body' has a wrong offset!");

// ScriptStruct G01.GzRecoilTime
// 0x0018 (0x0018 - 0x0000)
struct alignas(0x08) FGzRecoilTime final
{
public:
	uint8                                         Pad_2AC2[0x18];                                    // 0x0000(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGzRecoilTime) == 0x000008, "Wrong alignment on FGzRecoilTime");
static_assert(sizeof(FGzRecoilTime) == 0x000018, "Wrong size on FGzRecoilTime");

// ScriptStruct G01.GzResultAvailableGoal
// 0x0010 (0x0028 - 0x0018)
struct FGzResultAvailableGoal final : public FGzResultAvailableTask
{
public:
	TArray<struct FGzResultAvailableJob>          Jobs;                                              // 0x0018(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzResultAvailableGoal) == 0x000008, "Wrong alignment on FGzResultAvailableGoal");
static_assert(sizeof(FGzResultAvailableGoal) == 0x000028, "Wrong size on FGzResultAvailableGoal");
static_assert(offsetof(FGzResultAvailableGoal, Jobs) == 0x000018, "Member 'FGzResultAvailableGoal::Jobs' has a wrong offset!");

// ScriptStruct G01.GzBackendNewsInfo
// 0x0020 (0x0020 - 0x0000)
struct FGzBackendNewsInfo final
{
public:
	class FString                                 Name;                                              // 0x0000(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class FString>                         Lang;                                              // 0x0010(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzBackendNewsInfo) == 0x000008, "Wrong alignment on FGzBackendNewsInfo");
static_assert(sizeof(FGzBackendNewsInfo) == 0x000020, "Wrong size on FGzBackendNewsInfo");
static_assert(offsetof(FGzBackendNewsInfo, Name) == 0x000000, "Member 'FGzBackendNewsInfo::Name' has a wrong offset!");
static_assert(offsetof(FGzBackendNewsInfo, Lang) == 0x000010, "Member 'FGzBackendNewsInfo::Lang' has a wrong offset!");

// ScriptStruct G01.GzBackendNewsInfoList
// 0x0020 (0x0020 - 0x0000)
struct FGzBackendNewsInfoList final
{
public:
	class FString                                 URL;                                               // 0x0000(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FGzBackendNewsInfo>             List;                                              // 0x0010(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzBackendNewsInfoList) == 0x000008, "Wrong alignment on FGzBackendNewsInfoList");
static_assert(sizeof(FGzBackendNewsInfoList) == 0x000020, "Wrong size on FGzBackendNewsInfoList");
static_assert(offsetof(FGzBackendNewsInfoList, URL) == 0x000000, "Member 'FGzBackendNewsInfoList::URL' has a wrong offset!");
static_assert(offsetof(FGzBackendNewsInfoList, List) == 0x000010, "Member 'FGzBackendNewsInfoList::List' has a wrong offset!");

// ScriptStruct G01.GzMetaPriceRange
// 0x0010 (0x0010 - 0x0000)
struct FGzMetaPriceRange final
{
public:
	double                                        MinPrice;                                          // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	double                                        MaxPrice;                                          // 0x0008(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzMetaPriceRange) == 0x000008, "Wrong alignment on FGzMetaPriceRange");
static_assert(sizeof(FGzMetaPriceRange) == 0x000010, "Wrong size on FGzMetaPriceRange");
static_assert(offsetof(FGzMetaPriceRange, MinPrice) == 0x000000, "Member 'FGzMetaPriceRange::MinPrice' has a wrong offset!");
static_assert(offsetof(FGzMetaPriceRange, MaxPrice) == 0x000008, "Member 'FGzMetaPriceRange::MaxPrice' has a wrong offset!");

// ScriptStruct G01.GzBackendLoyaltyReward
// 0x0018 (0x0018 - 0x0000)
struct FGzBackendLoyaltyReward final
{
public:
	double                                        GunsAmount;                                        // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         LoyaltyLevel;                                      // 0x0008(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2AC3[0x7];                                     // 0x0009(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FDateTime                              GrantedAt;                                         // 0x0010(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzBackendLoyaltyReward) == 0x000008, "Wrong alignment on FGzBackendLoyaltyReward");
static_assert(sizeof(FGzBackendLoyaltyReward) == 0x000018, "Wrong size on FGzBackendLoyaltyReward");
static_assert(offsetof(FGzBackendLoyaltyReward, GunsAmount) == 0x000000, "Member 'FGzBackendLoyaltyReward::GunsAmount' has a wrong offset!");
static_assert(offsetof(FGzBackendLoyaltyReward, LoyaltyLevel) == 0x000008, "Member 'FGzBackendLoyaltyReward::LoyaltyLevel' has a wrong offset!");
static_assert(offsetof(FGzBackendLoyaltyReward, GrantedAt) == 0x000010, "Member 'FGzBackendLoyaltyReward::GrantedAt' has a wrong offset!");

// ScriptStruct G01.GzBackendGrantedContentPack
// 0x0028 (0x0028 - 0x0000)
struct FGzBackendGrantedContentPack final
{
public:
	struct FDateTime                              GrantedAt;                                         // 0x0000(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 ContentPackId;                                     // 0x0008(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FGzGrantedItemId>               GrantedHexes;                                      // 0x0018(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzBackendGrantedContentPack) == 0x000008, "Wrong alignment on FGzBackendGrantedContentPack");
static_assert(sizeof(FGzBackendGrantedContentPack) == 0x000028, "Wrong size on FGzBackendGrantedContentPack");
static_assert(offsetof(FGzBackendGrantedContentPack, GrantedAt) == 0x000000, "Member 'FGzBackendGrantedContentPack::GrantedAt' has a wrong offset!");
static_assert(offsetof(FGzBackendGrantedContentPack, ContentPackId) == 0x000008, "Member 'FGzBackendGrantedContentPack::ContentPackId' has a wrong offset!");
static_assert(offsetof(FGzBackendGrantedContentPack, GrantedHexes) == 0x000018, "Member 'FGzBackendGrantedContentPack::GrantedHexes' has a wrong offset!");

// ScriptStruct G01.GzBasicTransaction
// 0x0018 (0x0018 - 0x0000)
struct FGzBasicTransaction final
{
public:
	EGzTransactionType                            Type;                                              // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2AC4[0x4];                                     // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FDateTime                              Created;                                           // 0x0008(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   ID;                                                // 0x0010(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzBasicTransaction) == 0x000008, "Wrong alignment on FGzBasicTransaction");
static_assert(sizeof(FGzBasicTransaction) == 0x000018, "Wrong size on FGzBasicTransaction");
static_assert(offsetof(FGzBasicTransaction, Type) == 0x000000, "Member 'FGzBasicTransaction::Type' has a wrong offset!");
static_assert(offsetof(FGzBasicTransaction, Created) == 0x000008, "Member 'FGzBasicTransaction::Created' has a wrong offset!");
static_assert(offsetof(FGzBasicTransaction, ID) == 0x000010, "Member 'FGzBasicTransaction::ID' has a wrong offset!");

// ScriptStruct G01.ReplicativeHitResult
// 0x0078 (0x0078 - 0x0000)
struct FReplicativeHitResult final
{
public:
	uint8                                         bBlockingHit : 1;                                  // 0x0000(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_2AC5[0x7];                                     // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector_NetQuantize                    Location;                                          // 0x0008(0x0018)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector_NetQuantize                    TraceStart;                                        // 0x0020(0x0018)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector_NetQuantize                    TraceEnd;                                          // 0x0038(0x0018)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector_NetQuantizeNormal              ImpactNormal;                                      // 0x0050(0x0018)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TWeakObjectPtr<class UPrimitiveComponent>     Component;                                         // 0x0068(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         BoneIndex;                                         // 0x0070(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2AC6[0x4];                                     // 0x0074(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FReplicativeHitResult) == 0x000008, "Wrong alignment on FReplicativeHitResult");
static_assert(sizeof(FReplicativeHitResult) == 0x000078, "Wrong size on FReplicativeHitResult");
static_assert(offsetof(FReplicativeHitResult, Location) == 0x000008, "Member 'FReplicativeHitResult::Location' has a wrong offset!");
static_assert(offsetof(FReplicativeHitResult, TraceStart) == 0x000020, "Member 'FReplicativeHitResult::TraceStart' has a wrong offset!");
static_assert(offsetof(FReplicativeHitResult, TraceEnd) == 0x000038, "Member 'FReplicativeHitResult::TraceEnd' has a wrong offset!");
static_assert(offsetof(FReplicativeHitResult, ImpactNormal) == 0x000050, "Member 'FReplicativeHitResult::ImpactNormal' has a wrong offset!");
static_assert(offsetof(FReplicativeHitResult, Component) == 0x000068, "Member 'FReplicativeHitResult::Component' has a wrong offset!");
static_assert(offsetof(FReplicativeHitResult, BoneIndex) == 0x000070, "Member 'FReplicativeHitResult::BoneIndex' has a wrong offset!");

// ScriptStruct G01.GzBackendSubscriptionState
// 0x0088 (0x0088 - 0x0000)
struct FGzBackendSubscriptionState final
{
public:
	class FString                                 SubscriptionId;                                    // 0x0000(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FDateTime                              CreatedAt;                                         // 0x0010(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FDateTime                              EndAt;                                             // 0x0018(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         TrialDays;                                         // 0x0020(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsRenewable;                                       // 0x0021(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2AC7[0x6];                                     // 0x0022(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FGzBackendLoyaltyReward>        LoyaltyRewards;                                    // 0x0028(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TMap<class FString, struct FGzBackendGrantedContentPack> ContentPackRewards;                                // 0x0038(0x0050)(NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzBackendSubscriptionState) == 0x000008, "Wrong alignment on FGzBackendSubscriptionState");
static_assert(sizeof(FGzBackendSubscriptionState) == 0x000088, "Wrong size on FGzBackendSubscriptionState");
static_assert(offsetof(FGzBackendSubscriptionState, SubscriptionId) == 0x000000, "Member 'FGzBackendSubscriptionState::SubscriptionId' has a wrong offset!");
static_assert(offsetof(FGzBackendSubscriptionState, CreatedAt) == 0x000010, "Member 'FGzBackendSubscriptionState::CreatedAt' has a wrong offset!");
static_assert(offsetof(FGzBackendSubscriptionState, EndAt) == 0x000018, "Member 'FGzBackendSubscriptionState::EndAt' has a wrong offset!");
static_assert(offsetof(FGzBackendSubscriptionState, TrialDays) == 0x000020, "Member 'FGzBackendSubscriptionState::TrialDays' has a wrong offset!");
static_assert(offsetof(FGzBackendSubscriptionState, IsRenewable) == 0x000021, "Member 'FGzBackendSubscriptionState::IsRenewable' has a wrong offset!");
static_assert(offsetof(FGzBackendSubscriptionState, LoyaltyRewards) == 0x000028, "Member 'FGzBackendSubscriptionState::LoyaltyRewards' has a wrong offset!");
static_assert(offsetof(FGzBackendSubscriptionState, ContentPackRewards) == 0x000038, "Member 'FGzBackendSubscriptionState::ContentPackRewards' has a wrong offset!");

// ScriptStruct G01.GzBackendTrialInfo
// 0x0010 (0x0010 - 0x0000)
struct FGzBackendTrialInfo final
{
public:
	uint16                                        UsageCount;                                        // 0x0000(0x0002)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2AC8[0x6];                                     // 0x0002(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	struct FDateTime                              UsedAt;                                            // 0x0008(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzBackendTrialInfo) == 0x000008, "Wrong alignment on FGzBackendTrialInfo");
static_assert(sizeof(FGzBackendTrialInfo) == 0x000010, "Wrong size on FGzBackendTrialInfo");
static_assert(offsetof(FGzBackendTrialInfo, UsageCount) == 0x000000, "Member 'FGzBackendTrialInfo::UsageCount' has a wrong offset!");
static_assert(offsetof(FGzBackendTrialInfo, UsedAt) == 0x000008, "Member 'FGzBackendTrialInfo::UsedAt' has a wrong offset!");

// ScriptStruct G01.GzBackendPlayerSubscriptionState
// 0x00B0 (0x00B0 - 0x0000)
struct FGzBackendPlayerSubscriptionState final
{
public:
	bool                                          ProlongationSubscriptionActivated;                 // 0x0000(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2AC9[0x7];                                     // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGzBackendSubscriptionState            Subscription;                                      // 0x0008(0x0088)(NativeAccessSpecifierPublic)
	struct FGzBackendTrialInfo                    Trial;                                             // 0x0090(0x0010)(NoDestructor, NativeAccessSpecifierPublic)
	bool                                          HasActiveSubscription;                             // 0x00A0(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2ACA[0x7];                                     // 0x00A1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FDateTime                              UpdatedAt;                                         // 0x00A8(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzBackendPlayerSubscriptionState) == 0x000008, "Wrong alignment on FGzBackendPlayerSubscriptionState");
static_assert(sizeof(FGzBackendPlayerSubscriptionState) == 0x0000B0, "Wrong size on FGzBackendPlayerSubscriptionState");
static_assert(offsetof(FGzBackendPlayerSubscriptionState, ProlongationSubscriptionActivated) == 0x000000, "Member 'FGzBackendPlayerSubscriptionState::ProlongationSubscriptionActivated' has a wrong offset!");
static_assert(offsetof(FGzBackendPlayerSubscriptionState, Subscription) == 0x000008, "Member 'FGzBackendPlayerSubscriptionState::Subscription' has a wrong offset!");
static_assert(offsetof(FGzBackendPlayerSubscriptionState, Trial) == 0x000090, "Member 'FGzBackendPlayerSubscriptionState::Trial' has a wrong offset!");
static_assert(offsetof(FGzBackendPlayerSubscriptionState, HasActiveSubscription) == 0x0000A0, "Member 'FGzBackendPlayerSubscriptionState::HasActiveSubscription' has a wrong offset!");
static_assert(offsetof(FGzBackendPlayerSubscriptionState, UpdatedAt) == 0x0000A8, "Member 'FGzBackendPlayerSubscriptionState::UpdatedAt' has a wrong offset!");

// ScriptStruct G01.GzBackendSavedAchievementProgress
// 0x000C (0x000C - 0x0000)
struct FGzBackendSavedAchievementProgress final
{
public:
	float                                         Progress;                                          // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   ID;                                                // 0x0004(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzBackendSavedAchievementProgress) == 0x000004, "Wrong alignment on FGzBackendSavedAchievementProgress");
static_assert(sizeof(FGzBackendSavedAchievementProgress) == 0x00000C, "Wrong size on FGzBackendSavedAchievementProgress");
static_assert(offsetof(FGzBackendSavedAchievementProgress, Progress) == 0x000000, "Member 'FGzBackendSavedAchievementProgress::Progress' has a wrong offset!");
static_assert(offsetof(FGzBackendSavedAchievementProgress, ID) == 0x000004, "Member 'FGzBackendSavedAchievementProgress::ID' has a wrong offset!");

// ScriptStruct G01.GzBackendSavedAchievementsProgressCollection
// 0x0010 (0x0010 - 0x0000)
struct FGzBackendSavedAchievementsProgressCollection final
{
public:
	TArray<struct FGzBackendSavedAchievementProgress> Values;                                            // 0x0000(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzBackendSavedAchievementsProgressCollection) == 0x000008, "Wrong alignment on FGzBackendSavedAchievementsProgressCollection");
static_assert(sizeof(FGzBackendSavedAchievementsProgressCollection) == 0x000010, "Wrong size on FGzBackendSavedAchievementsProgressCollection");
static_assert(offsetof(FGzBackendSavedAchievementsProgressCollection, Values) == 0x000000, "Member 'FGzBackendSavedAchievementsProgressCollection::Values' has a wrong offset!");

// ScriptStruct G01.GzMatchmakingTicketInfo
// 0x0010 (0x0010 - 0x0000)
struct FGzMatchmakingTicketInfo final
{
public:
	class FString                                 TicketId;                                          // 0x0000(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzMatchmakingTicketInfo) == 0x000008, "Wrong alignment on FGzMatchmakingTicketInfo");
static_assert(sizeof(FGzMatchmakingTicketInfo) == 0x000010, "Wrong size on FGzMatchmakingTicketInfo");
static_assert(offsetof(FGzMatchmakingTicketInfo, TicketId) == 0x000000, "Member 'FGzMatchmakingTicketInfo::TicketId' has a wrong offset!");

// ScriptStruct G01.GzBackendServerDetails
// 0x0098 (0x0098 - 0x0000)
struct FGzBackendServerDetails final
{
public:
	class FString                                 IpAndPort;                                         // 0x0000(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Name;                                              // 0x0010(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Platform;                                          // 0x0020(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 BranchName;                                        // 0x0030(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint32                                        CL;                                                // 0x0040(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2ACB[0x4];                                     // 0x0044(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 Map;                                               // 0x0048(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 GameMode;                                          // 0x0058(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 MatchState;                                        // 0x0068(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint32                                        PlayerCount;                                       // 0x0078(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint32                                        MaxPlayerCount;                                    // 0x007C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          CanAcceptNewPlayers;                               // 0x0080(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2ACC[0x7];                                     // 0x0081(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 ServerHostingStatus;                               // 0x0088(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzBackendServerDetails) == 0x000008, "Wrong alignment on FGzBackendServerDetails");
static_assert(sizeof(FGzBackendServerDetails) == 0x000098, "Wrong size on FGzBackendServerDetails");
static_assert(offsetof(FGzBackendServerDetails, IpAndPort) == 0x000000, "Member 'FGzBackendServerDetails::IpAndPort' has a wrong offset!");
static_assert(offsetof(FGzBackendServerDetails, Name) == 0x000010, "Member 'FGzBackendServerDetails::Name' has a wrong offset!");
static_assert(offsetof(FGzBackendServerDetails, Platform) == 0x000020, "Member 'FGzBackendServerDetails::Platform' has a wrong offset!");
static_assert(offsetof(FGzBackendServerDetails, BranchName) == 0x000030, "Member 'FGzBackendServerDetails::BranchName' has a wrong offset!");
static_assert(offsetof(FGzBackendServerDetails, CL) == 0x000040, "Member 'FGzBackendServerDetails::CL' has a wrong offset!");
static_assert(offsetof(FGzBackendServerDetails, Map) == 0x000048, "Member 'FGzBackendServerDetails::Map' has a wrong offset!");
static_assert(offsetof(FGzBackendServerDetails, GameMode) == 0x000058, "Member 'FGzBackendServerDetails::GameMode' has a wrong offset!");
static_assert(offsetof(FGzBackendServerDetails, MatchState) == 0x000068, "Member 'FGzBackendServerDetails::MatchState' has a wrong offset!");
static_assert(offsetof(FGzBackendServerDetails, PlayerCount) == 0x000078, "Member 'FGzBackendServerDetails::PlayerCount' has a wrong offset!");
static_assert(offsetof(FGzBackendServerDetails, MaxPlayerCount) == 0x00007C, "Member 'FGzBackendServerDetails::MaxPlayerCount' has a wrong offset!");
static_assert(offsetof(FGzBackendServerDetails, CanAcceptNewPlayers) == 0x000080, "Member 'FGzBackendServerDetails::CanAcceptNewPlayers' has a wrong offset!");
static_assert(offsetof(FGzBackendServerDetails, ServerHostingStatus) == 0x000088, "Member 'FGzBackendServerDetails::ServerHostingStatus' has a wrong offset!");

// ScriptStruct G01.GzBackendStatistics
// 0x0010 (0x0010 - 0x0000)
struct FGzBackendStatistics final
{
public:
	TArray<int32>                                 Statistics;                                        // 0x0000(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzBackendStatistics) == 0x000008, "Wrong alignment on FGzBackendStatistics");
static_assert(sizeof(FGzBackendStatistics) == 0x000010, "Wrong size on FGzBackendStatistics");
static_assert(offsetof(FGzBackendStatistics, Statistics) == 0x000000, "Member 'FGzBackendStatistics::Statistics' has a wrong offset!");

// ScriptStruct G01.GzBackendStatisticsEntry
// 0x0020 (0x0020 - 0x0000)
struct FGzBackendStatisticsEntry final
{
public:
	class FString                                 S;                                                 // 0x0000(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 A;                                                 // 0x0010(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzBackendStatisticsEntry) == 0x000008, "Wrong alignment on FGzBackendStatisticsEntry");
static_assert(sizeof(FGzBackendStatisticsEntry) == 0x000020, "Wrong size on FGzBackendStatisticsEntry");
static_assert(offsetof(FGzBackendStatisticsEntry, S) == 0x000000, "Member 'FGzBackendStatisticsEntry::S' has a wrong offset!");
static_assert(offsetof(FGzBackendStatisticsEntry, A) == 0x000010, "Member 'FGzBackendStatisticsEntry::A' has a wrong offset!");

// ScriptStruct G01.GzBackendStatisticsDefinition
// 0x0010 (0x0010 - 0x0000)
struct FGzBackendStatisticsDefinition final
{
public:
	TArray<struct FGzBackendStatisticsEntry>      GameplayStatistics;                                // 0x0000(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzBackendStatisticsDefinition) == 0x000008, "Wrong alignment on FGzBackendStatisticsDefinition");
static_assert(sizeof(FGzBackendStatisticsDefinition) == 0x000010, "Wrong size on FGzBackendStatisticsDefinition");
static_assert(offsetof(FGzBackendStatisticsDefinition, GameplayStatistics) == 0x000000, "Member 'FGzBackendStatisticsDefinition::GameplayStatistics' has a wrong offset!");

// ScriptStruct G01.GzBackendUserOwnedFlags
// 0x0002 (0x0002 - 0x0000)
struct FGzBackendUserOwnedFlags final
{
public:
	bool                                          bWelcomeMessageSeen;                               // 0x0000(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bInitialSettingsConfigurationDone;                 // 0x0001(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzBackendUserOwnedFlags) == 0x000001, "Wrong alignment on FGzBackendUserOwnedFlags");
static_assert(sizeof(FGzBackendUserOwnedFlags) == 0x000002, "Wrong size on FGzBackendUserOwnedFlags");
static_assert(offsetof(FGzBackendUserOwnedFlags, bWelcomeMessageSeen) == 0x000000, "Member 'FGzBackendUserOwnedFlags::bWelcomeMessageSeen' has a wrong offset!");
static_assert(offsetof(FGzBackendUserOwnedFlags, bInitialSettingsConfigurationDone) == 0x000001, "Member 'FGzBackendUserOwnedFlags::bInitialSettingsConfigurationDone' has a wrong offset!");

// ScriptStruct G01.GzMarkerWidgets
// 0x0010 (0x0010 - 0x0000)
struct FGzMarkerWidgets final
{
public:
	TArray<class UGzMarkerWidget*>                MarkerWidgets;                                     // 0x0000(0x0010)(ExportObject, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzMarkerWidgets) == 0x000008, "Wrong alignment on FGzMarkerWidgets");
static_assert(sizeof(FGzMarkerWidgets) == 0x000010, "Wrong size on FGzMarkerWidgets");
static_assert(offsetof(FGzMarkerWidgets, MarkerWidgets) == 0x000000, "Member 'FGzMarkerWidgets::MarkerWidgets' has a wrong offset!");

// ScriptStruct G01.GzTerminalDistanceCache
// 0x0010 (0x0010 - 0x0000)
struct FGzTerminalDistanceCache final
{
public:
	class AGzBaseTerminal*                        Terminal;                                          // 0x0000(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	double                                        DistanceToLocalPlayerSquared;                      // 0x0008(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzTerminalDistanceCache) == 0x000008, "Wrong alignment on FGzTerminalDistanceCache");
static_assert(sizeof(FGzTerminalDistanceCache) == 0x000010, "Wrong size on FGzTerminalDistanceCache");
static_assert(offsetof(FGzTerminalDistanceCache, Terminal) == 0x000000, "Member 'FGzTerminalDistanceCache::Terminal' has a wrong offset!");
static_assert(offsetof(FGzTerminalDistanceCache, DistanceToLocalPlayerSquared) == 0x000008, "Member 'FGzTerminalDistanceCache::DistanceToLocalPlayerSquared' has a wrong offset!");

// ScriptStruct G01.GzBattlePassBlockingSlotV2
// 0x0020 (0x0020 - 0x0000)
struct FGzBattlePassBlockingSlotV2 final
{
public:
	struct FGuid                                  PageId;                                            // 0x0000(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGuid                                  SlotID;                                            // 0x0010(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzBattlePassBlockingSlotV2) == 0x000004, "Wrong alignment on FGzBattlePassBlockingSlotV2");
static_assert(sizeof(FGzBattlePassBlockingSlotV2) == 0x000020, "Wrong size on FGzBattlePassBlockingSlotV2");
static_assert(offsetof(FGzBattlePassBlockingSlotV2, PageId) == 0x000000, "Member 'FGzBattlePassBlockingSlotV2::PageId' has a wrong offset!");
static_assert(offsetof(FGzBattlePassBlockingSlotV2, SlotID) == 0x000010, "Member 'FGzBattlePassBlockingSlotV2::SlotID' has a wrong offset!");

// ScriptStruct G01.GzBattlePassSlotPreConditionsV2
// 0x0010 (0x0010 - 0x0000)
struct FGzBattlePassSlotPreConditionsV2 final
{
public:
	TArray<struct FGzBattlePassBlockingSlotV2>    BlockingSlots;                                     // 0x0000(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzBattlePassSlotPreConditionsV2) == 0x000008, "Wrong alignment on FGzBattlePassSlotPreConditionsV2");
static_assert(sizeof(FGzBattlePassSlotPreConditionsV2) == 0x000010, "Wrong size on FGzBattlePassSlotPreConditionsV2");
static_assert(offsetof(FGzBattlePassSlotPreConditionsV2, BlockingSlots) == 0x000000, "Member 'FGzBattlePassSlotPreConditionsV2::BlockingSlots' has a wrong offset!");

// ScriptStruct G01.GzBattlePassSlotDataV2
// 0x0030 (0x0030 - 0x0000)
struct FGzBattlePassSlotDataV2 final
{
public:
	struct FGuid                                  ID;                                                // 0x0000(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FInstancedStruct>               Rewards;                                           // 0x0010(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FGzBattlePassSlotPreConditionsV2       PreConditions;                                     // 0x0020(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzBattlePassSlotDataV2) == 0x000008, "Wrong alignment on FGzBattlePassSlotDataV2");
static_assert(sizeof(FGzBattlePassSlotDataV2) == 0x000030, "Wrong size on FGzBattlePassSlotDataV2");
static_assert(offsetof(FGzBattlePassSlotDataV2, ID) == 0x000000, "Member 'FGzBattlePassSlotDataV2::ID' has a wrong offset!");
static_assert(offsetof(FGzBattlePassSlotDataV2, Rewards) == 0x000010, "Member 'FGzBattlePassSlotDataV2::Rewards' has a wrong offset!");
static_assert(offsetof(FGzBattlePassSlotDataV2, PreConditions) == 0x000020, "Member 'FGzBattlePassSlotDataV2::PreConditions' has a wrong offset!");

// ScriptStruct G01.GzBattlePassPageDataV2
// 0x0018 (0x0018 - 0x0000)
struct FGzBattlePassPageDataV2 final
{
public:
	int32                                         EntryLevel;                                        // 0x0000(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         EntryLoyaltyLevel;                                 // 0x0004(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FGzBattlePassSlotDataV2>        Slots;                                             // 0x0008(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzBattlePassPageDataV2) == 0x000008, "Wrong alignment on FGzBattlePassPageDataV2");
static_assert(sizeof(FGzBattlePassPageDataV2) == 0x000018, "Wrong size on FGzBattlePassPageDataV2");
static_assert(offsetof(FGzBattlePassPageDataV2, EntryLevel) == 0x000000, "Member 'FGzBattlePassPageDataV2::EntryLevel' has a wrong offset!");
static_assert(offsetof(FGzBattlePassPageDataV2, EntryLoyaltyLevel) == 0x000004, "Member 'FGzBattlePassPageDataV2::EntryLoyaltyLevel' has a wrong offset!");
static_assert(offsetof(FGzBattlePassPageDataV2, Slots) == 0x000008, "Member 'FGzBattlePassPageDataV2::Slots' has a wrong offset!");

// ScriptStruct G01.GzTagVisibilitySettings
// 0x0050 (0x0050 - 0x0000)
struct FGzTagVisibilitySettings final
{
public:
	struct FGameplayTagContainer                  RequiredTags;                                      // 0x0000(0x0020)(Edit, NativeAccessSpecifierPublic)
	struct FGameplayTagContainer                  BlockingTags;                                      // 0x0020(0x0020)(Edit, NativeAccessSpecifierPublic)
	bool                                          bOverrideVisibilityChanges;                        // 0x0040(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bListenToTags;                                     // 0x0041(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2ACD[0x2];                                     // 0x0042(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         VisibilityTarget;                                  // 0x0044(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UGzWE_UITagsAware>          TagsAwareExtensionClass;                           // 0x0048(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzTagVisibilitySettings) == 0x000008, "Wrong alignment on FGzTagVisibilitySettings");
static_assert(sizeof(FGzTagVisibilitySettings) == 0x000050, "Wrong size on FGzTagVisibilitySettings");
static_assert(offsetof(FGzTagVisibilitySettings, RequiredTags) == 0x000000, "Member 'FGzTagVisibilitySettings::RequiredTags' has a wrong offset!");
static_assert(offsetof(FGzTagVisibilitySettings, BlockingTags) == 0x000020, "Member 'FGzTagVisibilitySettings::BlockingTags' has a wrong offset!");
static_assert(offsetof(FGzTagVisibilitySettings, bOverrideVisibilityChanges) == 0x000040, "Member 'FGzTagVisibilitySettings::bOverrideVisibilityChanges' has a wrong offset!");
static_assert(offsetof(FGzTagVisibilitySettings, bListenToTags) == 0x000041, "Member 'FGzTagVisibilitySettings::bListenToTags' has a wrong offset!");
static_assert(offsetof(FGzTagVisibilitySettings, VisibilityTarget) == 0x000044, "Member 'FGzTagVisibilitySettings::VisibilityTarget' has a wrong offset!");
static_assert(offsetof(FGzTagVisibilitySettings, TagsAwareExtensionClass) == 0x000048, "Member 'FGzTagVisibilitySettings::TagsAwareExtensionClass' has a wrong offset!");

// ScriptStruct G01.GzBattlePassGridVectorV2
// 0x0008 (0x0008 - 0x0000)
struct FGzBattlePassGridVectorV2 final
{
public:
	int32                                         X;                                                 // 0x0000(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Y;                                                 // 0x0004(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzBattlePassGridVectorV2) == 0x000004, "Wrong alignment on FGzBattlePassGridVectorV2");
static_assert(sizeof(FGzBattlePassGridVectorV2) == 0x000008, "Wrong size on FGzBattlePassGridVectorV2");
static_assert(offsetof(FGzBattlePassGridVectorV2, X) == 0x000000, "Member 'FGzBattlePassGridVectorV2::X' has a wrong offset!");
static_assert(offsetof(FGzBattlePassGridVectorV2, Y) == 0x000004, "Member 'FGzBattlePassGridVectorV2::Y' has a wrong offset!");

// ScriptStruct G01.GzBattlePassSlotRewardUiDataV2
// 0x0001 (0x0001 - 0x0000)
struct FGzBattlePassSlotRewardUiDataV2 final
{
public:
	bool                                          ShowOnPreview;                                     // 0x0000(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzBattlePassSlotRewardUiDataV2) == 0x000001, "Wrong alignment on FGzBattlePassSlotRewardUiDataV2");
static_assert(sizeof(FGzBattlePassSlotRewardUiDataV2) == 0x000001, "Wrong size on FGzBattlePassSlotRewardUiDataV2");
static_assert(offsetof(FGzBattlePassSlotRewardUiDataV2, ShowOnPreview) == 0x000000, "Member 'FGzBattlePassSlotRewardUiDataV2::ShowOnPreview' has a wrong offset!");

// ScriptStruct G01.GzBattlePassSlotUiDataV2
// 0x0060 (0x0060 - 0x0000)
struct FGzBattlePassSlotUiDataV2 final
{
public:
	struct FGzBattlePassGridVectorV2              Position;                                          // 0x0000(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	struct FGzBattlePassGridVectorV2              Size;                                              // 0x0008(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	TMap<struct FGuid, struct FGzBattlePassSlotRewardUiDataV2> RewardsUi;                                         // 0x0010(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzBattlePassSlotUiDataV2) == 0x000008, "Wrong alignment on FGzBattlePassSlotUiDataV2");
static_assert(sizeof(FGzBattlePassSlotUiDataV2) == 0x000060, "Wrong size on FGzBattlePassSlotUiDataV2");
static_assert(offsetof(FGzBattlePassSlotUiDataV2, Position) == 0x000000, "Member 'FGzBattlePassSlotUiDataV2::Position' has a wrong offset!");
static_assert(offsetof(FGzBattlePassSlotUiDataV2, Size) == 0x000008, "Member 'FGzBattlePassSlotUiDataV2::Size' has a wrong offset!");
static_assert(offsetof(FGzBattlePassSlotUiDataV2, RewardsUi) == 0x000010, "Member 'FGzBattlePassSlotUiDataV2::RewardsUi' has a wrong offset!");

// ScriptStruct G01.GzBattlePassPageUiDataV2
// 0x0090 (0x0090 - 0x0000)
struct FGzBattlePassPageUiDataV2 final
{
public:
	class FText                                   PageName;                                          // 0x0000(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TMap<struct FGuid, struct FGzBattlePassSlotUiDataV2> SlotsUi;                                           // 0x0010(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	EGzBattlePassPageContentType                  RewardContentType;                                 // 0x0060(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2ACE[0x7];                                     // 0x0061(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftObjectPtr<class UTexture2D>              PreviewBanner;                                     // 0x0068(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzBattlePassPageUiDataV2) == 0x000008, "Wrong alignment on FGzBattlePassPageUiDataV2");
static_assert(sizeof(FGzBattlePassPageUiDataV2) == 0x000090, "Wrong size on FGzBattlePassPageUiDataV2");
static_assert(offsetof(FGzBattlePassPageUiDataV2, PageName) == 0x000000, "Member 'FGzBattlePassPageUiDataV2::PageName' has a wrong offset!");
static_assert(offsetof(FGzBattlePassPageUiDataV2, SlotsUi) == 0x000010, "Member 'FGzBattlePassPageUiDataV2::SlotsUi' has a wrong offset!");
static_assert(offsetof(FGzBattlePassPageUiDataV2, RewardContentType) == 0x000060, "Member 'FGzBattlePassPageUiDataV2::RewardContentType' has a wrong offset!");
static_assert(offsetof(FGzBattlePassPageUiDataV2, PreviewBanner) == 0x000068, "Member 'FGzBattlePassPageUiDataV2::PreviewBanner' has a wrong offset!");

// ScriptStruct G01.GzBattlePassPageLockTemplate
// 0x0020 (0x0020 - 0x0000)
struct FGzBattlePassPageLockTemplate final
{
public:
	class FText                                   TitleTemplate;                                     // 0x0000(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	class FText                                   DescriptionTemplate;                               // 0x0010(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzBattlePassPageLockTemplate) == 0x000008, "Wrong alignment on FGzBattlePassPageLockTemplate");
static_assert(sizeof(FGzBattlePassPageLockTemplate) == 0x000020, "Wrong size on FGzBattlePassPageLockTemplate");
static_assert(offsetof(FGzBattlePassPageLockTemplate, TitleTemplate) == 0x000000, "Member 'FGzBattlePassPageLockTemplate::TitleTemplate' has a wrong offset!");
static_assert(offsetof(FGzBattlePassPageLockTemplate, DescriptionTemplate) == 0x000010, "Member 'FGzBattlePassPageLockTemplate::DescriptionTemplate' has a wrong offset!");

// ScriptStruct G01.GzBattlePassSlotDirectHexRewardV2
// 0x003C (0x0050 - 0x0014)
struct FGzBattlePassSlotDirectHexRewardV2 final : public FGzBattlePassSlotBaseRewardV2
{
public:
	uint8                                         Pad_2ACF[0x4];                                     // 0x0014(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftObjectPtr<class UGzContainerItemData>    ItemData;                                          // 0x0018(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	double                                        Price;                                             // 0x0040(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Limit;                                             // 0x0048(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2AD0[0x4];                                     // 0x004C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGzBattlePassSlotDirectHexRewardV2) == 0x000008, "Wrong alignment on FGzBattlePassSlotDirectHexRewardV2");
static_assert(sizeof(FGzBattlePassSlotDirectHexRewardV2) == 0x000050, "Wrong size on FGzBattlePassSlotDirectHexRewardV2");
static_assert(offsetof(FGzBattlePassSlotDirectHexRewardV2, ItemData) == 0x000018, "Member 'FGzBattlePassSlotDirectHexRewardV2::ItemData' has a wrong offset!");
static_assert(offsetof(FGzBattlePassSlotDirectHexRewardV2, Price) == 0x000040, "Member 'FGzBattlePassSlotDirectHexRewardV2::Price' has a wrong offset!");
static_assert(offsetof(FGzBattlePassSlotDirectHexRewardV2, Limit) == 0x000048, "Member 'FGzBattlePassSlotDirectHexRewardV2::Limit' has a wrong offset!");

// ScriptStruct G01.GzBattlePassSlotCurrencyRewardV2
// 0x000C (0x0020 - 0x0014)
struct FGzBattlePassSlotCurrencyRewardV2 final : public FGzBattlePassSlotBaseRewardV2
{
public:
	uint8                                         Pad_2AD1[0x4];                                     // 0x0014(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	double                                        GunAmount;                                         // 0x0018(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzBattlePassSlotCurrencyRewardV2) == 0x000008, "Wrong alignment on FGzBattlePassSlotCurrencyRewardV2");
static_assert(sizeof(FGzBattlePassSlotCurrencyRewardV2) == 0x000020, "Wrong size on FGzBattlePassSlotCurrencyRewardV2");
static_assert(offsetof(FGzBattlePassSlotCurrencyRewardV2, GunAmount) == 0x000018, "Member 'FGzBattlePassSlotCurrencyRewardV2::GunAmount' has a wrong offset!");

// ScriptStruct G01.GzBattlePassSlotRewardV2
// 0x0048 (0x0048 - 0x0000)
struct FGzBattlePassSlotRewardV2 final
{
public:
	struct FGuid                                  ID;                                                // 0x0000(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UGzContainerItemData>    ItemData;                                          // 0x0010(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	double                                        Price;                                             // 0x0038(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Limit;                                             // 0x0040(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2AD2[0x4];                                     // 0x0044(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGzBattlePassSlotRewardV2) == 0x000008, "Wrong alignment on FGzBattlePassSlotRewardV2");
static_assert(sizeof(FGzBattlePassSlotRewardV2) == 0x000048, "Wrong size on FGzBattlePassSlotRewardV2");
static_assert(offsetof(FGzBattlePassSlotRewardV2, ID) == 0x000000, "Member 'FGzBattlePassSlotRewardV2::ID' has a wrong offset!");
static_assert(offsetof(FGzBattlePassSlotRewardV2, ItemData) == 0x000010, "Member 'FGzBattlePassSlotRewardV2::ItemData' has a wrong offset!");
static_assert(offsetof(FGzBattlePassSlotRewardV2, Price) == 0x000038, "Member 'FGzBattlePassSlotRewardV2::Price' has a wrong offset!");
static_assert(offsetof(FGzBattlePassSlotRewardV2, Limit) == 0x000040, "Member 'FGzBattlePassSlotRewardV2::Limit' has a wrong offset!");

// ScriptStruct G01.GzBattlePassThemeSectionUiDataV2
// 0x0028 (0x0028 - 0x0000)
struct FGzBattlePassThemeSectionUiDataV2 final
{
public:
	class FText                                   SectionName;                                       // 0x0000(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TArray<struct FGuid>                          PageIds;                                           // 0x0010(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	class UGzMetaCharacterAvatarData*             Preview;                                           // 0x0020(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzBattlePassThemeSectionUiDataV2) == 0x000008, "Wrong alignment on FGzBattlePassThemeSectionUiDataV2");
static_assert(sizeof(FGzBattlePassThemeSectionUiDataV2) == 0x000028, "Wrong size on FGzBattlePassThemeSectionUiDataV2");
static_assert(offsetof(FGzBattlePassThemeSectionUiDataV2, SectionName) == 0x000000, "Member 'FGzBattlePassThemeSectionUiDataV2::SectionName' has a wrong offset!");
static_assert(offsetof(FGzBattlePassThemeSectionUiDataV2, PageIds) == 0x000010, "Member 'FGzBattlePassThemeSectionUiDataV2::PageIds' has a wrong offset!");
static_assert(offsetof(FGzBattlePassThemeSectionUiDataV2, Preview) == 0x000020, "Member 'FGzBattlePassThemeSectionUiDataV2::Preview' has a wrong offset!");

// ScriptStruct G01.GzZoneSelectionData
// 0x0018 (0x0018 - 0x0000)
struct FGzZoneSelectionData final
{
public:
	class AGzBattleRoyaleZone*                    Zone;                                              // 0x0000(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<int32>                                 LandingZones;                                      // 0x0008(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzZoneSelectionData) == 0x000008, "Wrong alignment on FGzZoneSelectionData");
static_assert(sizeof(FGzZoneSelectionData) == 0x000018, "Wrong size on FGzZoneSelectionData");
static_assert(offsetof(FGzZoneSelectionData, Zone) == 0x000000, "Member 'FGzZoneSelectionData::Zone' has a wrong offset!");
static_assert(offsetof(FGzZoneSelectionData, LandingZones) == 0x000008, "Member 'FGzZoneSelectionData::LandingZones' has a wrong offset!");

// ScriptStruct G01.GzOverloadStageData
// 0x0008 (0x0008 - 0x0000)
struct FGzOverloadStageData final
{
public:
	int32                                         StageIndex;                                        // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         StartTime;                                         // 0x0004(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzOverloadStageData) == 0x000004, "Wrong alignment on FGzOverloadStageData");
static_assert(sizeof(FGzOverloadStageData) == 0x000008, "Wrong size on FGzOverloadStageData");
static_assert(offsetof(FGzOverloadStageData, StageIndex) == 0x000000, "Member 'FGzOverloadStageData::StageIndex' has a wrong offset!");
static_assert(offsetof(FGzOverloadStageData, StartTime) == 0x000004, "Member 'FGzOverloadStageData::StartTime' has a wrong offset!");

// ScriptStruct G01.GzTrackingComponentCache
// 0x0010 (0x0010 - 0x0000)
struct FGzTrackingComponentCache final
{
public:
	TArray<class UGzZoneTrackingComponent*>       TrackedComponents;                                 // 0x0000(0x0010)(ExportObject, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzTrackingComponentCache) == 0x000008, "Wrong alignment on FGzTrackingComponentCache");
static_assert(sizeof(FGzTrackingComponentCache) == 0x000010, "Wrong size on FGzTrackingComponentCache");
static_assert(offsetof(FGzTrackingComponentCache, TrackedComponents) == 0x000000, "Member 'FGzTrackingComponentCache::TrackedComponents' has a wrong offset!");

// ScriptStruct G01.GzBlockPlayerPackage
// 0x0010 (0x0078 - 0x0068)
struct FGzBlockPlayerPackage final : public FGzPlayFabClientPackage
{
public:
	class FString                                 BlockedPlayerPlayFabId;                            // 0x0068(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzBlockPlayerPackage) == 0x000008, "Wrong alignment on FGzBlockPlayerPackage");
static_assert(sizeof(FGzBlockPlayerPackage) == 0x000078, "Wrong size on FGzBlockPlayerPackage");
static_assert(offsetof(FGzBlockPlayerPackage, BlockedPlayerPlayFabId) == 0x000068, "Member 'FGzBlockPlayerPackage::BlockedPlayerPlayFabId' has a wrong offset!");

// ScriptStruct G01.GzReportServerAliveResult
// 0x0000 (0x00E0 - 0x00E0)
struct FGzReportServerAliveResult final : public FGzPlayFabResultBase
{
};
static_assert(alignof(FGzReportServerAliveResult) == 0x000008, "Wrong alignment on FGzReportServerAliveResult");
static_assert(sizeof(FGzReportServerAliveResult) == 0x0000E0, "Wrong size on FGzReportServerAliveResult");

// ScriptStruct G01.GzAttachmentPoint
// 0x0028 (0x0028 - 0x0000)
struct FGzAttachmentPoint final
{
public:
	class USceneComponent*                        ComponentToAttach;                                 // 0x0000(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   BoneName;                                          // 0x0008(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Offset;                                            // 0x0010(0x0018)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzAttachmentPoint) == 0x000008, "Wrong alignment on FGzAttachmentPoint");
static_assert(sizeof(FGzAttachmentPoint) == 0x000028, "Wrong size on FGzAttachmentPoint");
static_assert(offsetof(FGzAttachmentPoint, ComponentToAttach) == 0x000000, "Member 'FGzAttachmentPoint::ComponentToAttach' has a wrong offset!");
static_assert(offsetof(FGzAttachmentPoint, BoneName) == 0x000008, "Member 'FGzAttachmentPoint::BoneName' has a wrong offset!");
static_assert(offsetof(FGzAttachmentPoint, Offset) == 0x000010, "Member 'FGzAttachmentPoint::Offset' has a wrong offset!");

// ScriptStruct G01.GzBodyPartAbilityInputEntry
// 0x0018 (0x0018 - 0x0000)
struct FGzBodyPartAbilityInputEntry final
{
public:
	class UInputAction*                           InputActionOverride;                               // 0x0000(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   Text;                                              // 0x0008(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzBodyPartAbilityInputEntry) == 0x000008, "Wrong alignment on FGzBodyPartAbilityInputEntry");
static_assert(sizeof(FGzBodyPartAbilityInputEntry) == 0x000018, "Wrong size on FGzBodyPartAbilityInputEntry");
static_assert(offsetof(FGzBodyPartAbilityInputEntry, InputActionOverride) == 0x000000, "Member 'FGzBodyPartAbilityInputEntry::InputActionOverride' has a wrong offset!");
static_assert(offsetof(FGzBodyPartAbilityInputEntry, Text) == 0x000008, "Member 'FGzBodyPartAbilityInputEntry::Text' has a wrong offset!");

// ScriptStruct G01.GzPackageWeaponConfigurationItem
// 0x0020 (0x0020 - 0x0000)
struct FGzPackageWeaponConfigurationItem final
{
public:
	class FString                                 ItemId;                                            // 0x0000(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 AssetId;                                           // 0x0010(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzPackageWeaponConfigurationItem) == 0x000008, "Wrong alignment on FGzPackageWeaponConfigurationItem");
static_assert(sizeof(FGzPackageWeaponConfigurationItem) == 0x000020, "Wrong size on FGzPackageWeaponConfigurationItem");
static_assert(offsetof(FGzPackageWeaponConfigurationItem, ItemId) == 0x000000, "Member 'FGzPackageWeaponConfigurationItem::ItemId' has a wrong offset!");
static_assert(offsetof(FGzPackageWeaponConfigurationItem, AssetId) == 0x000010, "Member 'FGzPackageWeaponConfigurationItem::AssetId' has a wrong offset!");

// ScriptStruct G01.GzPackageWeaponConfiguration
// 0x0090 (0x0090 - 0x0000)
struct FGzPackageWeaponConfiguration final
{
public:
	struct FGzPackageWeaponConfigurationItem      Weapon;                                            // 0x0000(0x0020)(NativeAccessSpecifierPublic)
	struct FGzPackageWeaponConfigurationItem      Skin;                                              // 0x0020(0x0020)(NativeAccessSpecifierPublic)
	TMap<class FString, struct FGzPackageWeaponConfigurationItem> Attachments;                                       // 0x0040(0x0050)(NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzPackageWeaponConfiguration) == 0x000008, "Wrong alignment on FGzPackageWeaponConfiguration");
static_assert(sizeof(FGzPackageWeaponConfiguration) == 0x000090, "Wrong size on FGzPackageWeaponConfiguration");
static_assert(offsetof(FGzPackageWeaponConfiguration, Weapon) == 0x000000, "Member 'FGzPackageWeaponConfiguration::Weapon' has a wrong offset!");
static_assert(offsetof(FGzPackageWeaponConfiguration, Skin) == 0x000020, "Member 'FGzPackageWeaponConfiguration::Skin' has a wrong offset!");
static_assert(offsetof(FGzPackageWeaponConfiguration, Attachments) == 0x000040, "Member 'FGzPackageWeaponConfiguration::Attachments' has a wrong offset!");

// ScriptStruct G01.GzPackageWeaponConfigurationsUpdate
// 0x0060 (0x00C8 - 0x0068)
struct FGzPackageWeaponConfigurationsUpdate final : public FGzPlayFabClientPackage
{
public:
	class FString                                 CharacterId;                                       // 0x0068(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMap<class FString, struct FGzPackageWeaponConfiguration> Configurations;                                    // 0x0078(0x0050)(NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzPackageWeaponConfigurationsUpdate) == 0x000008, "Wrong alignment on FGzPackageWeaponConfigurationsUpdate");
static_assert(sizeof(FGzPackageWeaponConfigurationsUpdate) == 0x0000C8, "Wrong size on FGzPackageWeaponConfigurationsUpdate");
static_assert(offsetof(FGzPackageWeaponConfigurationsUpdate, CharacterId) == 0x000068, "Member 'FGzPackageWeaponConfigurationsUpdate::CharacterId' has a wrong offset!");
static_assert(offsetof(FGzPackageWeaponConfigurationsUpdate, Configurations) == 0x000078, "Member 'FGzPackageWeaponConfigurationsUpdate::Configurations' has a wrong offset!");

// ScriptStruct G01.GzTeamSpawnPoints
// 0x0010 (0x0010 - 0x0000)
struct FGzTeamSpawnPoints final
{
public:
	TArray<struct FVector>                        TeamSpawnPoints;                                   // 0x0000(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzTeamSpawnPoints) == 0x000008, "Wrong alignment on FGzTeamSpawnPoints");
static_assert(sizeof(FGzTeamSpawnPoints) == 0x000010, "Wrong size on FGzTeamSpawnPoints");
static_assert(offsetof(FGzTeamSpawnPoints, TeamSpawnPoints) == 0x000000, "Member 'FGzTeamSpawnPoints::TeamSpawnPoints' has a wrong offset!");

// ScriptStruct G01.GzPlayFabServerPackage
// 0x0030 (0x0088 - 0x0058)
struct FGzPlayFabServerPackage : public FGzPlayFabPackageBase
{
public:
	struct FGzPlayFabPlayerIdContainer            PlayerId;                                          // 0x0058(0x0020)(NativeAccessSpecifierPublic)
	class FString                                 MatchID;                                           // 0x0078(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
};
static_assert(alignof(FGzPlayFabServerPackage) == 0x000008, "Wrong alignment on FGzPlayFabServerPackage");
static_assert(sizeof(FGzPlayFabServerPackage) == 0x000088, "Wrong size on FGzPlayFabServerPackage");
static_assert(offsetof(FGzPlayFabServerPackage, PlayerId) == 0x000058, "Member 'FGzPlayFabServerPackage::PlayerId' has a wrong offset!");
static_assert(offsetof(FGzPlayFabServerPackage, MatchID) == 0x000078, "Member 'FGzPlayFabServerPackage::MatchID' has a wrong offset!");

// ScriptStruct G01.GzPackageProgressedChallenge
// 0x0028 (0x0028 - 0x0000)
struct FGzPackageProgressedChallenge final
{
public:
	class FString                                 ID;                                                // 0x0000(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 ChallengeType;                                     // 0x0010(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Progress;                                          // 0x0020(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2AD3[0x4];                                     // 0x0024(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGzPackageProgressedChallenge) == 0x000008, "Wrong alignment on FGzPackageProgressedChallenge");
static_assert(sizeof(FGzPackageProgressedChallenge) == 0x000028, "Wrong size on FGzPackageProgressedChallenge");
static_assert(offsetof(FGzPackageProgressedChallenge, ID) == 0x000000, "Member 'FGzPackageProgressedChallenge::ID' has a wrong offset!");
static_assert(offsetof(FGzPackageProgressedChallenge, ChallengeType) == 0x000010, "Member 'FGzPackageProgressedChallenge::ChallengeType' has a wrong offset!");
static_assert(offsetof(FGzPackageProgressedChallenge, Progress) == 0x000020, "Member 'FGzPackageProgressedChallenge::Progress' has a wrong offset!");

// ScriptStruct G01.GzPackageSaveProgressedChallenges
// 0x0010 (0x0098 - 0x0088)
struct FGzPackageSaveProgressedChallenges final : public FGzPlayFabServerPackage
{
public:
	TArray<struct FGzPackageProgressedChallenge>  ChallengesProgress;                                // 0x0088(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzPackageSaveProgressedChallenges) == 0x000008, "Wrong alignment on FGzPackageSaveProgressedChallenges");
static_assert(sizeof(FGzPackageSaveProgressedChallenges) == 0x000098, "Wrong size on FGzPackageSaveProgressedChallenges");
static_assert(offsetof(FGzPackageSaveProgressedChallenges, ChallengesProgress) == 0x000088, "Member 'FGzPackageSaveProgressedChallenges::ChallengesProgress' has a wrong offset!");

// ScriptStruct G01.GzBulletID
// 0x000C (0x000C - 0x0000)
struct FGzBulletID final
{
public:
	struct FGzAdvancedIdType                      CharacterId;                                       // 0x0000(0x0008)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         LocalID;                                           // 0x0008(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2AD4[0x3];                                     // 0x0009(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGzBulletID) == 0x000004, "Wrong alignment on FGzBulletID");
static_assert(sizeof(FGzBulletID) == 0x00000C, "Wrong size on FGzBulletID");
static_assert(offsetof(FGzBulletID, CharacterId) == 0x000000, "Member 'FGzBulletID::CharacterId' has a wrong offset!");
static_assert(offsetof(FGzBulletID, LocalID) == 0x000008, "Member 'FGzBulletID::LocalID' has a wrong offset!");

// ScriptStruct G01.GzBulletNetData
// 0x00A8 (0x00A8 - 0x0000)
struct FGzBulletNetData final
{
public:
	class UGzWeaponItemData*                      WeaponItemData;                                    // 0x0000(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGzBulletID                            BulletID;                                          // 0x0008(0x000C)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         BulletSeed;                                        // 0x0014(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CreationTimestamp;                                 // 0x0018(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2AD5[0x4];                                     // 0x001C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector_NetQuantize                    StartPosition;                                     // 0x0020(0x0018)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector_NetQuantizeNormal              StartRotation;                                     // 0x0038(0x0018)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGzInvPocketId                         WeaponPocketId;                                    // 0x0050(0x0008)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGzWeaponInvItem                       WeaponItem;                                        // 0x0058(0x0050)(NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzBulletNetData) == 0x000008, "Wrong alignment on FGzBulletNetData");
static_assert(sizeof(FGzBulletNetData) == 0x0000A8, "Wrong size on FGzBulletNetData");
static_assert(offsetof(FGzBulletNetData, WeaponItemData) == 0x000000, "Member 'FGzBulletNetData::WeaponItemData' has a wrong offset!");
static_assert(offsetof(FGzBulletNetData, BulletID) == 0x000008, "Member 'FGzBulletNetData::BulletID' has a wrong offset!");
static_assert(offsetof(FGzBulletNetData, BulletSeed) == 0x000014, "Member 'FGzBulletNetData::BulletSeed' has a wrong offset!");
static_assert(offsetof(FGzBulletNetData, CreationTimestamp) == 0x000018, "Member 'FGzBulletNetData::CreationTimestamp' has a wrong offset!");
static_assert(offsetof(FGzBulletNetData, StartPosition) == 0x000020, "Member 'FGzBulletNetData::StartPosition' has a wrong offset!");
static_assert(offsetof(FGzBulletNetData, StartRotation) == 0x000038, "Member 'FGzBulletNetData::StartRotation' has a wrong offset!");
static_assert(offsetof(FGzBulletNetData, WeaponPocketId) == 0x000050, "Member 'FGzBulletNetData::WeaponPocketId' has a wrong offset!");
static_assert(offsetof(FGzBulletNetData, WeaponItem) == 0x000058, "Member 'FGzBulletNetData::WeaponItem' has a wrong offset!");

// ScriptStruct G01.GzBullet
// 0x0260 (0x0260 - 0x0000)
struct FGzBullet final
{
public:
	float                                         CreationTimestamp;                                 // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2AD6[0x4];                                     // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                Position;                                          // 0x0008(0x0018)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Rotation;                                          // 0x0020(0x0018)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Direction;                                         // 0x0038(0x0018)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                LastMove;                                          // 0x0050(0x0018)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FHitResult                             FinalHit;                                          // 0x0068(0x00F8)(IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	float                                         FalloffSpeed;                                      // 0x0160(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TotalDistance;                                     // 0x0164(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGzBulletID                            BulletID;                                          // 0x0168(0x000C)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Seed;                                              // 0x0174(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGzInvPocketId                         WeaponPocketId;                                    // 0x0178(0x0008)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGzWeaponInvItem                       WeaponItem;                                        // 0x0180(0x0050)(NativeAccessSpecifierPublic)
	uint8                                         Pad_2AD7[0x8];                                     // 0x01D0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UNiagaraSystem*                         BulletNiagaraSystem;                               // 0x01D8(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2AD8[0x8];                                     // 0x01E0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<struct FGameplayTag, float>              EffectMultipliers;                                 // 0x01E8(0x0050)(NativeAccessSpecifierPublic)
	uint8                                         Pad_2AD9[0x20];                                    // 0x0238(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	class UGzWeaponItemData*                      WeaponItemData;                                    // 0x0258(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
};
static_assert(alignof(FGzBullet) == 0x000008, "Wrong alignment on FGzBullet");
static_assert(sizeof(FGzBullet) == 0x000260, "Wrong size on FGzBullet");
static_assert(offsetof(FGzBullet, CreationTimestamp) == 0x000000, "Member 'FGzBullet::CreationTimestamp' has a wrong offset!");
static_assert(offsetof(FGzBullet, Position) == 0x000008, "Member 'FGzBullet::Position' has a wrong offset!");
static_assert(offsetof(FGzBullet, Rotation) == 0x000020, "Member 'FGzBullet::Rotation' has a wrong offset!");
static_assert(offsetof(FGzBullet, Direction) == 0x000038, "Member 'FGzBullet::Direction' has a wrong offset!");
static_assert(offsetof(FGzBullet, LastMove) == 0x000050, "Member 'FGzBullet::LastMove' has a wrong offset!");
static_assert(offsetof(FGzBullet, FinalHit) == 0x000068, "Member 'FGzBullet::FinalHit' has a wrong offset!");
static_assert(offsetof(FGzBullet, FalloffSpeed) == 0x000160, "Member 'FGzBullet::FalloffSpeed' has a wrong offset!");
static_assert(offsetof(FGzBullet, TotalDistance) == 0x000164, "Member 'FGzBullet::TotalDistance' has a wrong offset!");
static_assert(offsetof(FGzBullet, BulletID) == 0x000168, "Member 'FGzBullet::BulletID' has a wrong offset!");
static_assert(offsetof(FGzBullet, Seed) == 0x000174, "Member 'FGzBullet::Seed' has a wrong offset!");
static_assert(offsetof(FGzBullet, WeaponPocketId) == 0x000178, "Member 'FGzBullet::WeaponPocketId' has a wrong offset!");
static_assert(offsetof(FGzBullet, WeaponItem) == 0x000180, "Member 'FGzBullet::WeaponItem' has a wrong offset!");
static_assert(offsetof(FGzBullet, BulletNiagaraSystem) == 0x0001D8, "Member 'FGzBullet::BulletNiagaraSystem' has a wrong offset!");
static_assert(offsetof(FGzBullet, EffectMultipliers) == 0x0001E8, "Member 'FGzBullet::EffectMultipliers' has a wrong offset!");
static_assert(offsetof(FGzBullet, WeaponItemData) == 0x000258, "Member 'FGzBullet::WeaponItemData' has a wrong offset!");

// ScriptStruct G01.GzCachedAssetList
// 0x0060 (0x0060 - 0x0000)
struct FGzCachedAssetList final
{
public:
	uint8                                         Pad_2ADA[0x10];                                    // 0x0000(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<class FName, class UObject*>             Objects;                                           // 0x0010(0x0050)(NativeAccessSpecifierPrivate)
};
static_assert(alignof(FGzCachedAssetList) == 0x000008, "Wrong alignment on FGzCachedAssetList");
static_assert(sizeof(FGzCachedAssetList) == 0x000060, "Wrong size on FGzCachedAssetList");
static_assert(offsetof(FGzCachedAssetList, Objects) == 0x000010, "Member 'FGzCachedAssetList::Objects' has a wrong offset!");

// ScriptStruct G01.GzServerLaunchCommandOptionItem
// 0x0030 (0x0030 - 0x0000)
struct FGzServerLaunchCommandOptionItem final
{
public:
	class FText                                   DisplayName;                                       // 0x0000(0x0010)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	class FString                                 Value;                                             // 0x0010(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 AdditionalCommandOptions;                          // 0x0020(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzServerLaunchCommandOptionItem) == 0x000008, "Wrong alignment on FGzServerLaunchCommandOptionItem");
static_assert(sizeof(FGzServerLaunchCommandOptionItem) == 0x000030, "Wrong size on FGzServerLaunchCommandOptionItem");
static_assert(offsetof(FGzServerLaunchCommandOptionItem, DisplayName) == 0x000000, "Member 'FGzServerLaunchCommandOptionItem::DisplayName' has a wrong offset!");
static_assert(offsetof(FGzServerLaunchCommandOptionItem, Value) == 0x000010, "Member 'FGzServerLaunchCommandOptionItem::Value' has a wrong offset!");
static_assert(offsetof(FGzServerLaunchCommandOptionItem, AdditionalCommandOptions) == 0x000020, "Member 'FGzServerLaunchCommandOptionItem::AdditionalCommandOptions' has a wrong offset!");

// ScriptStruct G01.GzServerLaunchCommandOptionGroup
// 0x0028 (0x0028 - 0x0000)
struct FGzServerLaunchCommandOptionGroup final
{
public:
	class FText                                   DisplayName;                                       // 0x0000(0x0010)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	EGzServerLaunchOptionSelectionType            SelectionType;                                     // 0x0010(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2ADB[0x7];                                     // 0x0011(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FGzServerLaunchCommandOptionItem> Items;                                             // 0x0018(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzServerLaunchCommandOptionGroup) == 0x000008, "Wrong alignment on FGzServerLaunchCommandOptionGroup");
static_assert(sizeof(FGzServerLaunchCommandOptionGroup) == 0x000028, "Wrong size on FGzServerLaunchCommandOptionGroup");
static_assert(offsetof(FGzServerLaunchCommandOptionGroup, DisplayName) == 0x000000, "Member 'FGzServerLaunchCommandOptionGroup::DisplayName' has a wrong offset!");
static_assert(offsetof(FGzServerLaunchCommandOptionGroup, SelectionType) == 0x000010, "Member 'FGzServerLaunchCommandOptionGroup::SelectionType' has a wrong offset!");
static_assert(offsetof(FGzServerLaunchCommandOptionGroup, Items) == 0x000018, "Member 'FGzServerLaunchCommandOptionGroup::Items' has a wrong offset!");

// ScriptStruct G01.GzServerLaunchOptionItem
// 0x0080 (0x0080 - 0x0000)
struct FGzServerLaunchOptionItem final
{
public:
	class FText                                   DisplayName;                                       // 0x0000(0x0010)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	class FString                                 Value;                                             // 0x0010(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 AdditionalCommandOptions;                          // 0x0020(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMap<class FString, struct FGzServerLaunchCommandOptionGroup> Children;                                          // 0x0030(0x0050)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzServerLaunchOptionItem) == 0x000008, "Wrong alignment on FGzServerLaunchOptionItem");
static_assert(sizeof(FGzServerLaunchOptionItem) == 0x000080, "Wrong size on FGzServerLaunchOptionItem");
static_assert(offsetof(FGzServerLaunchOptionItem, DisplayName) == 0x000000, "Member 'FGzServerLaunchOptionItem::DisplayName' has a wrong offset!");
static_assert(offsetof(FGzServerLaunchOptionItem, Value) == 0x000010, "Member 'FGzServerLaunchOptionItem::Value' has a wrong offset!");
static_assert(offsetof(FGzServerLaunchOptionItem, AdditionalCommandOptions) == 0x000020, "Member 'FGzServerLaunchOptionItem::AdditionalCommandOptions' has a wrong offset!");
static_assert(offsetof(FGzServerLaunchOptionItem, Children) == 0x000030, "Member 'FGzServerLaunchOptionItem::Children' has a wrong offset!");

// ScriptStruct G01.GzServerLaunchOptionGroup
// 0x0020 (0x0020 - 0x0000)
struct FGzServerLaunchOptionGroup final
{
public:
	class FText                                   DisplayName;                                       // 0x0000(0x0010)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TArray<struct FGzServerLaunchOptionItem>      Items;                                             // 0x0010(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzServerLaunchOptionGroup) == 0x000008, "Wrong alignment on FGzServerLaunchOptionGroup");
static_assert(sizeof(FGzServerLaunchOptionGroup) == 0x000020, "Wrong size on FGzServerLaunchOptionGroup");
static_assert(offsetof(FGzServerLaunchOptionGroup, DisplayName) == 0x000000, "Member 'FGzServerLaunchOptionGroup::DisplayName' has a wrong offset!");
static_assert(offsetof(FGzServerLaunchOptionGroup, Items) == 0x000010, "Member 'FGzServerLaunchOptionGroup::Items' has a wrong offset!");

// ScriptStruct G01.GzServerLaunchOptions
// 0x0058 (0x0058 - 0x0000)
struct FGzServerLaunchOptions final
{
public:
	bool                                          EnableTraces;                                      // 0x0000(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2ADC[0x3];                                     // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	uint32                                        InactivityTimout;                                  // 0x0004(0x0004)(Edit, ZeroConstructor, Config, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 AdditionalOptions;                                 // 0x0008(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGzServerLaunchOptionGroup             HostingType;                                       // 0x0018(0x0020)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FGzServerLaunchOptionGroup             GameMode;                                          // 0x0038(0x0020)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzServerLaunchOptions) == 0x000008, "Wrong alignment on FGzServerLaunchOptions");
static_assert(sizeof(FGzServerLaunchOptions) == 0x000058, "Wrong size on FGzServerLaunchOptions");
static_assert(offsetof(FGzServerLaunchOptions, EnableTraces) == 0x000000, "Member 'FGzServerLaunchOptions::EnableTraces' has a wrong offset!");
static_assert(offsetof(FGzServerLaunchOptions, InactivityTimout) == 0x000004, "Member 'FGzServerLaunchOptions::InactivityTimout' has a wrong offset!");
static_assert(offsetof(FGzServerLaunchOptions, AdditionalOptions) == 0x000008, "Member 'FGzServerLaunchOptions::AdditionalOptions' has a wrong offset!");
static_assert(offsetof(FGzServerLaunchOptions, HostingType) == 0x000018, "Member 'FGzServerLaunchOptions::HostingType' has a wrong offset!");
static_assert(offsetof(FGzServerLaunchOptions, GameMode) == 0x000038, "Member 'FGzServerLaunchOptions::GameMode' has a wrong offset!");

// ScriptStruct G01.CameraTransitionSettings
// 0x0040 (0x0040 - 0x0000)
struct FCameraTransitionSettings final
{
public:
	struct FVector                                StartCameraLocation;                               // 0x0000(0x0018)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                TargetCameraLocation;                              // 0x0018(0x0018)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InterpolationSpeed;                                // 0x0030(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Alpha;                                             // 0x0034(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCanMoveCamera;                                    // 0x0038(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2ADD[0x7];                                     // 0x0039(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCameraTransitionSettings) == 0x000008, "Wrong alignment on FCameraTransitionSettings");
static_assert(sizeof(FCameraTransitionSettings) == 0x000040, "Wrong size on FCameraTransitionSettings");
static_assert(offsetof(FCameraTransitionSettings, StartCameraLocation) == 0x000000, "Member 'FCameraTransitionSettings::StartCameraLocation' has a wrong offset!");
static_assert(offsetof(FCameraTransitionSettings, TargetCameraLocation) == 0x000018, "Member 'FCameraTransitionSettings::TargetCameraLocation' has a wrong offset!");
static_assert(offsetof(FCameraTransitionSettings, InterpolationSpeed) == 0x000030, "Member 'FCameraTransitionSettings::InterpolationSpeed' has a wrong offset!");
static_assert(offsetof(FCameraTransitionSettings, Alpha) == 0x000034, "Member 'FCameraTransitionSettings::Alpha' has a wrong offset!");
static_assert(offsetof(FCameraTransitionSettings, bCanMoveCamera) == 0x000038, "Member 'FCameraTransitionSettings::bCanMoveCamera' has a wrong offset!");

// ScriptStruct G01.GzCameraOffset
// 0x0038 (0x0038 - 0x0000)
struct FGzCameraOffset final
{
public:
	int32                                         State;                                             // 0x0000(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2ADE[0x4];                                     // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                Offset;                                            // 0x0008(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                AddedTargetOffset;                                 // 0x0020(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzCameraOffset) == 0x000008, "Wrong alignment on FGzCameraOffset");
static_assert(sizeof(FGzCameraOffset) == 0x000038, "Wrong size on FGzCameraOffset");
static_assert(offsetof(FGzCameraOffset, State) == 0x000000, "Member 'FGzCameraOffset::State' has a wrong offset!");
static_assert(offsetof(FGzCameraOffset, Offset) == 0x000008, "Member 'FGzCameraOffset::Offset' has a wrong offset!");
static_assert(offsetof(FGzCameraOffset, AddedTargetOffset) == 0x000020, "Member 'FGzCameraOffset::AddedTargetOffset' has a wrong offset!");

// ScriptStruct G01.GzImpulseInfo
// 0x0028 (0x0028 - 0x0000)
struct FGzImpulseInfo final
{
public:
	struct FVector                                Impulse;                                           // 0x0000(0x0018)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   ImpulseBoneName;                                   // 0x0018(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bVelocityChange;                                   // 0x0020(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseImpulse;                                       // 0x0021(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2ADF[0x6];                                     // 0x0022(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGzImpulseInfo) == 0x000008, "Wrong alignment on FGzImpulseInfo");
static_assert(sizeof(FGzImpulseInfo) == 0x000028, "Wrong size on FGzImpulseInfo");
static_assert(offsetof(FGzImpulseInfo, Impulse) == 0x000000, "Member 'FGzImpulseInfo::Impulse' has a wrong offset!");
static_assert(offsetof(FGzImpulseInfo, ImpulseBoneName) == 0x000018, "Member 'FGzImpulseInfo::ImpulseBoneName' has a wrong offset!");
static_assert(offsetof(FGzImpulseInfo, bVelocityChange) == 0x000020, "Member 'FGzImpulseInfo::bVelocityChange' has a wrong offset!");
static_assert(offsetof(FGzImpulseInfo, bUseImpulse) == 0x000021, "Member 'FGzImpulseInfo::bUseImpulse' has a wrong offset!");

// ScriptStruct G01.GzPickableSpawnInfo
// 0x00D0 (0x00D0 - 0x0000)
struct FGzPickableSpawnInfo final
{
public:
	EGzPickablePhysicsType                        PhysicsType;                                       // 0x0000(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2AE0[0xF];                                     // 0x0001(0x000F)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             Transform;                                         // 0x0010(0x0060)(Edit, BlueprintVisible, IsPlainOldData, RepSkip, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGzImpulseInfo                         ImpulseInfo;                                       // 0x0070(0x0028)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	TArray<struct FGzBoneTransform>               SourcePose;                                        // 0x0098(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          bSimplified;                                       // 0x00A8(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2AE1[0x3];                                     // 0x00A9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         InitialHealth;                                     // 0x00AC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 LastOwner;                                         // 0x00B0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<ECollisionChannel>                     AdditionalCollisionChannelsToBlock;                // 0x00B8(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_2AE2[0x8];                                     // 0x00C8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGzPickableSpawnInfo) == 0x000010, "Wrong alignment on FGzPickableSpawnInfo");
static_assert(sizeof(FGzPickableSpawnInfo) == 0x0000D0, "Wrong size on FGzPickableSpawnInfo");
static_assert(offsetof(FGzPickableSpawnInfo, PhysicsType) == 0x000000, "Member 'FGzPickableSpawnInfo::PhysicsType' has a wrong offset!");
static_assert(offsetof(FGzPickableSpawnInfo, Transform) == 0x000010, "Member 'FGzPickableSpawnInfo::Transform' has a wrong offset!");
static_assert(offsetof(FGzPickableSpawnInfo, ImpulseInfo) == 0x000070, "Member 'FGzPickableSpawnInfo::ImpulseInfo' has a wrong offset!");
static_assert(offsetof(FGzPickableSpawnInfo, SourcePose) == 0x000098, "Member 'FGzPickableSpawnInfo::SourcePose' has a wrong offset!");
static_assert(offsetof(FGzPickableSpawnInfo, bSimplified) == 0x0000A8, "Member 'FGzPickableSpawnInfo::bSimplified' has a wrong offset!");
static_assert(offsetof(FGzPickableSpawnInfo, InitialHealth) == 0x0000AC, "Member 'FGzPickableSpawnInfo::InitialHealth' has a wrong offset!");
static_assert(offsetof(FGzPickableSpawnInfo, LastOwner) == 0x0000B0, "Member 'FGzPickableSpawnInfo::LastOwner' has a wrong offset!");
static_assert(offsetof(FGzPickableSpawnInfo, AdditionalCollisionChannelsToBlock) == 0x0000B8, "Member 'FGzPickableSpawnInfo::AdditionalCollisionChannelsToBlock' has a wrong offset!");

// ScriptStruct G01.GzWheelData
// 0x0090 (0x0090 - 0x0000)
struct FGzWheelData final
{
public:
	EGzWheelGroup                                 WheelGroup;                                        // 0x0000(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseSkeletalMesh;                                  // 0x0001(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2AE3[0x2];                                     // 0x0002(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   BoneName;                                          // 0x0004(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2AE4[0x4];                                     // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                InitialPosition;                                   // 0x0010(0x0018)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2AE5[0x8];                                     // 0x0028(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             CalculatedTransform;                               // 0x0030(0x0060)(Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzWheelData) == 0x000010, "Wrong alignment on FGzWheelData");
static_assert(sizeof(FGzWheelData) == 0x000090, "Wrong size on FGzWheelData");
static_assert(offsetof(FGzWheelData, WheelGroup) == 0x000000, "Member 'FGzWheelData::WheelGroup' has a wrong offset!");
static_assert(offsetof(FGzWheelData, bUseSkeletalMesh) == 0x000001, "Member 'FGzWheelData::bUseSkeletalMesh' has a wrong offset!");
static_assert(offsetof(FGzWheelData, BoneName) == 0x000004, "Member 'FGzWheelData::BoneName' has a wrong offset!");
static_assert(offsetof(FGzWheelData, InitialPosition) == 0x000010, "Member 'FGzWheelData::InitialPosition' has a wrong offset!");
static_assert(offsetof(FGzWheelData, CalculatedTransform) == 0x000030, "Member 'FGzWheelData::CalculatedTransform' has a wrong offset!");

// ScriptStruct G01.GzPartyMemberCharacterData
// 0x0058 (0x0058 - 0x0000)
struct FGzPartyMemberCharacterData final
{
public:
	class FString                                 PlayFabId;                                         // 0x0000(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 ProductUserId;                                     // 0x0010(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 CharacterId;                                       // 0x0020(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 FavoriteLoadoutId;                                 // 0x0030(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int64                                         Timestamp;                                         // 0x0040(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 UserId;                                            // 0x0048(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzPartyMemberCharacterData) == 0x000008, "Wrong alignment on FGzPartyMemberCharacterData");
static_assert(sizeof(FGzPartyMemberCharacterData) == 0x000058, "Wrong size on FGzPartyMemberCharacterData");
static_assert(offsetof(FGzPartyMemberCharacterData, PlayFabId) == 0x000000, "Member 'FGzPartyMemberCharacterData::PlayFabId' has a wrong offset!");
static_assert(offsetof(FGzPartyMemberCharacterData, ProductUserId) == 0x000010, "Member 'FGzPartyMemberCharacterData::ProductUserId' has a wrong offset!");
static_assert(offsetof(FGzPartyMemberCharacterData, CharacterId) == 0x000020, "Member 'FGzPartyMemberCharacterData::CharacterId' has a wrong offset!");
static_assert(offsetof(FGzPartyMemberCharacterData, FavoriteLoadoutId) == 0x000030, "Member 'FGzPartyMemberCharacterData::FavoriteLoadoutId' has a wrong offset!");
static_assert(offsetof(FGzPartyMemberCharacterData, Timestamp) == 0x000040, "Member 'FGzPartyMemberCharacterData::Timestamp' has a wrong offset!");
static_assert(offsetof(FGzPartyMemberCharacterData, UserId) == 0x000048, "Member 'FGzPartyMemberCharacterData::UserId' has a wrong offset!");

// ScriptStruct G01.GzCarTrackTransportDebugger
// 0x0001 (0x0001 - 0x0000)
struct FGzCarTrackTransportDebugger final
{
public:
	uint8                                         Pad_2AE6[0x1];                                     // 0x0000(0x0001)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGzCarTrackTransportDebugger) == 0x000001, "Wrong alignment on FGzCarTrackTransportDebugger");
static_assert(sizeof(FGzCarTrackTransportDebugger) == 0x000001, "Wrong size on FGzCarTrackTransportDebugger");

// ScriptStruct G01.GzChangeDisplayedProfileNamePackage
// 0x0020 (0x0088 - 0x0068)
struct FGzChangeDisplayedProfileNamePackage final : public FGzPlayFabClientPackage
{
public:
	class FString                                 ProfileName;                                       // 0x0068(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Tag;                                               // 0x0078(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzChangeDisplayedProfileNamePackage) == 0x000008, "Wrong alignment on FGzChangeDisplayedProfileNamePackage");
static_assert(sizeof(FGzChangeDisplayedProfileNamePackage) == 0x000088, "Wrong size on FGzChangeDisplayedProfileNamePackage");
static_assert(offsetof(FGzChangeDisplayedProfileNamePackage, ProfileName) == 0x000068, "Member 'FGzChangeDisplayedProfileNamePackage::ProfileName' has a wrong offset!");
static_assert(offsetof(FGzChangeDisplayedProfileNamePackage, Tag) == 0x000078, "Member 'FGzChangeDisplayedProfileNamePackage::Tag' has a wrong offset!");

// ScriptStruct G01.GzGrantedFromItemAbilityInfo
// 0x0018 (0x0018 - 0x0000)
struct FGzGrantedFromItemAbilityInfo final
{
public:
	class UGzItemData*                            ItemData;                                          // 0x0000(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UGzGameplayAbility>         AbilityClass;                                      // 0x0008(0x0008)(ZeroConstructor, Transient, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2AE7[0x8];                                     // 0x0010(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGzGrantedFromItemAbilityInfo) == 0x000008, "Wrong alignment on FGzGrantedFromItemAbilityInfo");
static_assert(sizeof(FGzGrantedFromItemAbilityInfo) == 0x000018, "Wrong size on FGzGrantedFromItemAbilityInfo");
static_assert(offsetof(FGzGrantedFromItemAbilityInfo, ItemData) == 0x000000, "Member 'FGzGrantedFromItemAbilityInfo::ItemData' has a wrong offset!");
static_assert(offsetof(FGzGrantedFromItemAbilityInfo, AbilityClass) == 0x000008, "Member 'FGzGrantedFromItemAbilityInfo::AbilityClass' has a wrong offset!");

// ScriptStruct G01.GzGrantedFromItemEffectInfo
// 0x0020 (0x0020 - 0x0000)
struct FGzGrantedFromItemEffectInfo final
{
public:
	class UGzItemData*                            ItemData;                                          // 0x0000(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UGameplayEffect>            EffectClass;                                       // 0x0008(0x0008)(ZeroConstructor, Transient, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FActiveGameplayEffectHandle            EffectHandle;                                      // 0x0010(0x0008)(Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2AE8[0x8];                                     // 0x0018(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGzGrantedFromItemEffectInfo) == 0x000008, "Wrong alignment on FGzGrantedFromItemEffectInfo");
static_assert(sizeof(FGzGrantedFromItemEffectInfo) == 0x000020, "Wrong size on FGzGrantedFromItemEffectInfo");
static_assert(offsetof(FGzGrantedFromItemEffectInfo, ItemData) == 0x000000, "Member 'FGzGrantedFromItemEffectInfo::ItemData' has a wrong offset!");
static_assert(offsetof(FGzGrantedFromItemEffectInfo, EffectClass) == 0x000008, "Member 'FGzGrantedFromItemEffectInfo::EffectClass' has a wrong offset!");
static_assert(offsetof(FGzGrantedFromItemEffectInfo, EffectHandle) == 0x000010, "Member 'FGzGrantedFromItemEffectInfo::EffectHandle' has a wrong offset!");

// ScriptStruct G01.GzThrowableShieldReturnParameters
// 0x0010 (0x0010 - 0x0000)
struct alignas(0x04) FGzThrowableShieldReturnParameters final
{
public:
	uint8                                         Pad_2AE9[0x10];                                    // 0x0000(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGzThrowableShieldReturnParameters) == 0x000004, "Wrong alignment on FGzThrowableShieldReturnParameters");
static_assert(sizeof(FGzThrowableShieldReturnParameters) == 0x000010, "Wrong size on FGzThrowableShieldReturnParameters");

// ScriptStruct G01.GzMeshesInLogicalSlotsContainer
// 0x0010 (0x0010 - 0x0000)
struct FGzMeshesInLogicalSlotsContainer final
{
public:
	TArray<class UMeshComponent*>                 MeshArray;                                         // 0x0000(0x0010)(Edit, ExportObject, ZeroConstructor, EditConst, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzMeshesInLogicalSlotsContainer) == 0x000008, "Wrong alignment on FGzMeshesInLogicalSlotsContainer");
static_assert(sizeof(FGzMeshesInLogicalSlotsContainer) == 0x000010, "Wrong size on FGzMeshesInLogicalSlotsContainer");
static_assert(offsetof(FGzMeshesInLogicalSlotsContainer, MeshArray) == 0x000000, "Member 'FGzMeshesInLogicalSlotsContainer::MeshArray' has a wrong offset!");

// ScriptStruct G01.GzCharacterCustomizationDebugger
// 0x0200 (0x0200 - 0x0000)
struct FGzCharacterCustomizationDebugger final
{
public:
	TSoftClassPtr<class UClass>                   VisualizerClass;                                   // 0x0000(0x0028)(Edit, DisableEditOnInstance, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2AEA[0x8];                                     // 0x0028(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             WidgetRelativeTransform;                           // 0x0030(0x0060)(Edit, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetComponent*                       VisualizerWidgetComponent;                         // 0x0090(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UGzCharacterCustomizationComponent*     CustomizationComponent;                            // 0x0098(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FGzDebugCustomizationProfile           CachedExpectedDebugProfile;                        // 0x00A0(0x00B0)(Protected, NativeAccessSpecifierProtected)
	struct FGzDebugCustomizationProfile           CachedAppliedDebugProfile;                         // 0x0150(0x00B0)(Protected, NativeAccessSpecifierProtected)
};
static_assert(alignof(FGzCharacterCustomizationDebugger) == 0x000010, "Wrong alignment on FGzCharacterCustomizationDebugger");
static_assert(sizeof(FGzCharacterCustomizationDebugger) == 0x000200, "Wrong size on FGzCharacterCustomizationDebugger");
static_assert(offsetof(FGzCharacterCustomizationDebugger, VisualizerClass) == 0x000000, "Member 'FGzCharacterCustomizationDebugger::VisualizerClass' has a wrong offset!");
static_assert(offsetof(FGzCharacterCustomizationDebugger, WidgetRelativeTransform) == 0x000030, "Member 'FGzCharacterCustomizationDebugger::WidgetRelativeTransform' has a wrong offset!");
static_assert(offsetof(FGzCharacterCustomizationDebugger, VisualizerWidgetComponent) == 0x000090, "Member 'FGzCharacterCustomizationDebugger::VisualizerWidgetComponent' has a wrong offset!");
static_assert(offsetof(FGzCharacterCustomizationDebugger, CustomizationComponent) == 0x000098, "Member 'FGzCharacterCustomizationDebugger::CustomizationComponent' has a wrong offset!");
static_assert(offsetof(FGzCharacterCustomizationDebugger, CachedExpectedDebugProfile) == 0x0000A0, "Member 'FGzCharacterCustomizationDebugger::CachedExpectedDebugProfile' has a wrong offset!");
static_assert(offsetof(FGzCharacterCustomizationDebugger, CachedAppliedDebugProfile) == 0x000150, "Member 'FGzCharacterCustomizationDebugger::CachedAppliedDebugProfile' has a wrong offset!");

// ScriptStruct G01.GzDeathLocationReveal
// 0x0010 (0x0010 - 0x0000)
struct FGzDeathLocationReveal final
{
public:
	int32                                         MarkerId;                                          // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2AEB[0x4];                                     // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTimerHandle                           DurationHandle;                                    // 0x0008(0x0008)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzDeathLocationReveal) == 0x000008, "Wrong alignment on FGzDeathLocationReveal");
static_assert(sizeof(FGzDeathLocationReveal) == 0x000010, "Wrong size on FGzDeathLocationReveal");
static_assert(offsetof(FGzDeathLocationReveal, MarkerId) == 0x000000, "Member 'FGzDeathLocationReveal::MarkerId' has a wrong offset!");
static_assert(offsetof(FGzDeathLocationReveal, DurationHandle) == 0x000008, "Member 'FGzDeathLocationReveal::DurationHandle' has a wrong offset!");

// ScriptStruct G01.GzCharacterSkinMaterial
// 0x0030 (0x0030 - 0x0000)
struct FGzCharacterSkinMaterial final
{
public:
	TSoftObjectPtr<class UMaterialInterface>      MaterialAsset;                                     // 0x0000(0x0028)(Edit, BlueprintVisible, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   SlotName;                                          // 0x0028(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzCharacterSkinMaterial) == 0x000008, "Wrong alignment on FGzCharacterSkinMaterial");
static_assert(sizeof(FGzCharacterSkinMaterial) == 0x000030, "Wrong size on FGzCharacterSkinMaterial");
static_assert(offsetof(FGzCharacterSkinMaterial, MaterialAsset) == 0x000000, "Member 'FGzCharacterSkinMaterial::MaterialAsset' has a wrong offset!");
static_assert(offsetof(FGzCharacterSkinMaterial, SlotName) == 0x000028, "Member 'FGzCharacterSkinMaterial::SlotName' has a wrong offset!");

// ScriptStruct G01.GzGenderedBodyOpacityMasks
// 0x00A0 (0x00A0 - 0x0000)
struct FGzGenderedBodyOpacityMasks final
{
public:
	TMap<EGzCharacterCustomizationBodyMaskType, class UTexture2D*> MaleBodyOpacityMasks;                              // 0x0000(0x0050)(Edit, BlueprintVisible, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TMap<EGzCharacterCustomizationBodyMaskType, class UTexture2D*> FemaleBodyOpacityMasks;                            // 0x0050(0x0050)(Edit, BlueprintVisible, DisableEditOnInstance, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzGenderedBodyOpacityMasks) == 0x000008, "Wrong alignment on FGzGenderedBodyOpacityMasks");
static_assert(sizeof(FGzGenderedBodyOpacityMasks) == 0x0000A0, "Wrong size on FGzGenderedBodyOpacityMasks");
static_assert(offsetof(FGzGenderedBodyOpacityMasks, MaleBodyOpacityMasks) == 0x000000, "Member 'FGzGenderedBodyOpacityMasks::MaleBodyOpacityMasks' has a wrong offset!");
static_assert(offsetof(FGzGenderedBodyOpacityMasks, FemaleBodyOpacityMasks) == 0x000050, "Member 'FGzGenderedBodyOpacityMasks::FemaleBodyOpacityMasks' has a wrong offset!");

// ScriptStruct G01.GzGamepadProfileInfo
// 0x00B8 (0x00B8 - 0x0000)
struct FGzGamepadProfileInfo final
{
public:
	struct FGameplayTag                           Tag;                                               // 0x0000(0x0008)(Edit, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   DisplayName;                                       // 0x0008(0x0010)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TMap<class FName, TSoftObjectPtr<class UTexture2D>> ProfileImages;                                     // 0x0018(0x0050)(Edit, DisableEditOnInstance, UObjectWrapper, NativeAccessSpecifierPublic)
	TMap<class UInputAction*, struct FKey>        Mappings;                                          // 0x0068(0x0050)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzGamepadProfileInfo) == 0x000008, "Wrong alignment on FGzGamepadProfileInfo");
static_assert(sizeof(FGzGamepadProfileInfo) == 0x0000B8, "Wrong size on FGzGamepadProfileInfo");
static_assert(offsetof(FGzGamepadProfileInfo, Tag) == 0x000000, "Member 'FGzGamepadProfileInfo::Tag' has a wrong offset!");
static_assert(offsetof(FGzGamepadProfileInfo, DisplayName) == 0x000008, "Member 'FGzGamepadProfileInfo::DisplayName' has a wrong offset!");
static_assert(offsetof(FGzGamepadProfileInfo, ProfileImages) == 0x000018, "Member 'FGzGamepadProfileInfo::ProfileImages' has a wrong offset!");
static_assert(offsetof(FGzGamepadProfileInfo, Mappings) == 0x000068, "Member 'FGzGamepadProfileInfo::Mappings' has a wrong offset!");

// ScriptStruct G01.GzAttributeSetting
// 0x0080 (0x0080 - 0x0000)
struct FGzAttributeSetting final
{
public:
	struct FGameplayAttribute                     Attribute;                                         // 0x0000(0x0038)(Edit, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayAttribute                     MaxAttribute;                                      // 0x0038(0x0038)(Edit, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxAttributeValue;                                 // 0x0070(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           MaxValueTag;                                       // 0x0074(0x0008)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2AEC[0x4];                                     // 0x007C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGzAttributeSetting) == 0x000008, "Wrong alignment on FGzAttributeSetting");
static_assert(sizeof(FGzAttributeSetting) == 0x000080, "Wrong size on FGzAttributeSetting");
static_assert(offsetof(FGzAttributeSetting, Attribute) == 0x000000, "Member 'FGzAttributeSetting::Attribute' has a wrong offset!");
static_assert(offsetof(FGzAttributeSetting, MaxAttribute) == 0x000038, "Member 'FGzAttributeSetting::MaxAttribute' has a wrong offset!");
static_assert(offsetof(FGzAttributeSetting, MaxAttributeValue) == 0x000070, "Member 'FGzAttributeSetting::MaxAttributeValue' has a wrong offset!");
static_assert(offsetof(FGzAttributeSetting, MaxValueTag) == 0x000074, "Member 'FGzAttributeSetting::MaxValueTag' has a wrong offset!");

// ScriptStruct G01.GzTrackEventsSegment
// 0x0020 (0x0020 - 0x0000)
struct FGzTrackEventsSegment final
{
public:
	class UGzTrackEventBase*                      StartEvent;                                        // 0x0000(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UGzTrackEventBase*                      EndEvent;                                          // 0x0008(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2AED[0x10];                                    // 0x0010(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGzTrackEventsSegment) == 0x000008, "Wrong alignment on FGzTrackEventsSegment");
static_assert(sizeof(FGzTrackEventsSegment) == 0x000020, "Wrong size on FGzTrackEventsSegment");
static_assert(offsetof(FGzTrackEventsSegment, StartEvent) == 0x000000, "Member 'FGzTrackEventsSegment::StartEvent' has a wrong offset!");
static_assert(offsetof(FGzTrackEventsSegment, EndEvent) == 0x000008, "Member 'FGzTrackEventsSegment::EndEvent' has a wrong offset!");

// ScriptStruct G01.GzAimAssistPresetSettings
// 0x0018 (0x0018 - 0x0000)
struct FGzAimAssistPresetSettings final
{
public:
	class FString                                 PresetName;                                        // 0x0000(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShouldDisableAimAssist;                           // 0x0010(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2AEE[0x3];                                     // 0x0011(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         SensitivityAimAssistStrength;                      // 0x0014(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzAimAssistPresetSettings) == 0x000008, "Wrong alignment on FGzAimAssistPresetSettings");
static_assert(sizeof(FGzAimAssistPresetSettings) == 0x000018, "Wrong size on FGzAimAssistPresetSettings");
static_assert(offsetof(FGzAimAssistPresetSettings, PresetName) == 0x000000, "Member 'FGzAimAssistPresetSettings::PresetName' has a wrong offset!");
static_assert(offsetof(FGzAimAssistPresetSettings, bShouldDisableAimAssist) == 0x000010, "Member 'FGzAimAssistPresetSettings::bShouldDisableAimAssist' has a wrong offset!");
static_assert(offsetof(FGzAimAssistPresetSettings, SensitivityAimAssistStrength) == 0x000014, "Member 'FGzAimAssistPresetSettings::SensitivityAimAssistStrength' has a wrong offset!");

// ScriptStruct G01.GzFaction
// 0x0048 (0x0048 - 0x0000)
struct FGzFaction final
{
public:
	class FName                                   Key;                                               // 0x0000(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   DisplayName;                                       // 0x0008(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, Config, AdvancedDisplay, NativeAccessSpecifierPublic)
	bool                                          bIsPlayerSelectable;                               // 0x0018(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, DisableEditOnInstance, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2AEF[0x7];                                     // 0x0019(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftObjectPtr<class USkeletalMesh>           FactionTransportMesh;                              // 0x0020(0x0028)(Edit, Config, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzFaction) == 0x000008, "Wrong alignment on FGzFaction");
static_assert(sizeof(FGzFaction) == 0x000048, "Wrong size on FGzFaction");
static_assert(offsetof(FGzFaction, Key) == 0x000000, "Member 'FGzFaction::Key' has a wrong offset!");
static_assert(offsetof(FGzFaction, DisplayName) == 0x000008, "Member 'FGzFaction::DisplayName' has a wrong offset!");
static_assert(offsetof(FGzFaction, bIsPlayerSelectable) == 0x000018, "Member 'FGzFaction::bIsPlayerSelectable' has a wrong offset!");
static_assert(offsetof(FGzFaction, FactionTransportMesh) == 0x000020, "Member 'FGzFaction::FactionTransportMesh' has a wrong offset!");

// ScriptStruct G01.GzCharacterInfo
// 0x0068 (0x0068 - 0x0000)
struct FGzCharacterInfo final
{
public:
	class FString                                 CharacterId;                                       // 0x0000(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 CharacterName;                                     // 0x0010(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGzFaction                             CharacterFaction;                                  // 0x0020(0x0048)(NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzCharacterInfo) == 0x000008, "Wrong alignment on FGzCharacterInfo");
static_assert(sizeof(FGzCharacterInfo) == 0x000068, "Wrong size on FGzCharacterInfo");
static_assert(offsetof(FGzCharacterInfo, CharacterId) == 0x000000, "Member 'FGzCharacterInfo::CharacterId' has a wrong offset!");
static_assert(offsetof(FGzCharacterInfo, CharacterName) == 0x000010, "Member 'FGzCharacterInfo::CharacterName' has a wrong offset!");
static_assert(offsetof(FGzCharacterInfo, CharacterFaction) == 0x000020, "Member 'FGzCharacterInfo::CharacterFaction' has a wrong offset!");

// ScriptStruct G01.GzPlayerLoadoutsSet
// 0x0010 (0x0010 - 0x0000)
struct FGzPlayerLoadoutsSet final
{
public:
	TArray<class UGzPlayerLoadout*>               Loadouts;                                          // 0x0000(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzPlayerLoadoutsSet) == 0x000008, "Wrong alignment on FGzPlayerLoadoutsSet");
static_assert(sizeof(FGzPlayerLoadoutsSet) == 0x000010, "Wrong size on FGzPlayerLoadoutsSet");
static_assert(offsetof(FGzPlayerLoadoutsSet, Loadouts) == 0x000000, "Member 'FGzPlayerLoadoutsSet::Loadouts' has a wrong offset!");

// ScriptStruct G01.LyraCharacterGroundInfo
// 0x0108 (0x0108 - 0x0000)
struct FLyraCharacterGroundInfo final
{
public:
	uint8                                         Pad_2AF0[0x8];                                     // 0x0000(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FHitResult                             GroundHitResult;                                   // 0x0008(0x00F8)(BlueprintVisible, BlueprintReadOnly, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	float                                         GroundDistance;                                    // 0x0100(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2AF1[0x4];                                     // 0x0104(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FLyraCharacterGroundInfo) == 0x000008, "Wrong alignment on FLyraCharacterGroundInfo");
static_assert(sizeof(FLyraCharacterGroundInfo) == 0x000108, "Wrong size on FLyraCharacterGroundInfo");
static_assert(offsetof(FLyraCharacterGroundInfo, GroundHitResult) == 0x000008, "Member 'FLyraCharacterGroundInfo::GroundHitResult' has a wrong offset!");
static_assert(offsetof(FLyraCharacterGroundInfo, GroundDistance) == 0x000100, "Member 'FLyraCharacterGroundInfo::GroundDistance' has a wrong offset!");

// ScriptStruct G01.GzValidateItemResult
// 0x0018 (0x00F8 - 0x00E0)
struct FGzValidateItemResult final : public FGzPlayFabResultBase
{
public:
	class FString                                 ItemInstanceId;                                    // 0x00E0(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FDateTime                              Updated;                                           // 0x00F0(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzValidateItemResult) == 0x000008, "Wrong alignment on FGzValidateItemResult");
static_assert(sizeof(FGzValidateItemResult) == 0x0000F8, "Wrong size on FGzValidateItemResult");
static_assert(offsetof(FGzValidateItemResult, ItemInstanceId) == 0x0000E0, "Member 'FGzValidateItemResult::ItemInstanceId' has a wrong offset!");
static_assert(offsetof(FGzValidateItemResult, Updated) == 0x0000F0, "Member 'FGzValidateItemResult::Updated' has a wrong offset!");

// ScriptStruct G01.GzLocomotionState
// 0x0002 (0x0002 - 0x0000)
struct FGzLocomotionState final
{
public:
	uint8                                         BaseMode;                                          // 0x0000(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EGzCustomMovementMode                         CustomMode;                                        // 0x0001(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzLocomotionState) == 0x000001, "Wrong alignment on FGzLocomotionState");
static_assert(sizeof(FGzLocomotionState) == 0x000002, "Wrong size on FGzLocomotionState");
static_assert(offsetof(FGzLocomotionState, BaseMode) == 0x000000, "Member 'FGzLocomotionState::BaseMode' has a wrong offset!");
static_assert(offsetof(FGzLocomotionState, CustomMode) == 0x000001, "Member 'FGzLocomotionState::CustomMode' has a wrong offset!");

// ScriptStruct G01.GzDashParams
// 0x0028 (0x0028 - 0x0000)
struct FGzDashParams final
{
public:
	float                                         DashingMaxDistance;                                // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DashingMaxSpeed;                                   // 0x0004(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DashingStopMaxSpeed;                               // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEnableGravity;                                    // 0x000C(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2AF2[0x3];                                     // 0x000D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class UCurveFloat*                            GravityMultiplierCurve;                            // 0x0010(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCurveFloat*                            DashingAccelerationCurve;                          // 0x0018(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bRedirectDashOnWalkableCollision;                  // 0x0020(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bResetVelocityOnFloorOnNoHit;                      // 0x0021(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2AF3[0x6];                                     // 0x0022(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGzDashParams) == 0x000008, "Wrong alignment on FGzDashParams");
static_assert(sizeof(FGzDashParams) == 0x000028, "Wrong size on FGzDashParams");
static_assert(offsetof(FGzDashParams, DashingMaxDistance) == 0x000000, "Member 'FGzDashParams::DashingMaxDistance' has a wrong offset!");
static_assert(offsetof(FGzDashParams, DashingMaxSpeed) == 0x000004, "Member 'FGzDashParams::DashingMaxSpeed' has a wrong offset!");
static_assert(offsetof(FGzDashParams, DashingStopMaxSpeed) == 0x000008, "Member 'FGzDashParams::DashingStopMaxSpeed' has a wrong offset!");
static_assert(offsetof(FGzDashParams, bEnableGravity) == 0x00000C, "Member 'FGzDashParams::bEnableGravity' has a wrong offset!");
static_assert(offsetof(FGzDashParams, GravityMultiplierCurve) == 0x000010, "Member 'FGzDashParams::GravityMultiplierCurve' has a wrong offset!");
static_assert(offsetof(FGzDashParams, DashingAccelerationCurve) == 0x000018, "Member 'FGzDashParams::DashingAccelerationCurve' has a wrong offset!");
static_assert(offsetof(FGzDashParams, bRedirectDashOnWalkableCollision) == 0x000020, "Member 'FGzDashParams::bRedirectDashOnWalkableCollision' has a wrong offset!");
static_assert(offsetof(FGzDashParams, bResetVelocityOnFloorOnNoHit) == 0x000021, "Member 'FGzDashParams::bResetVelocityOnFloorOnNoHit' has a wrong offset!");

// ScriptStruct G01.GzAntiStuckParams
// 0x0024 (0x0024 - 0x0000)
struct FGzAntiStuckParams final
{
public:
	float                                         InitialImpulse;                                    // 0x0000(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AdditionalImpulse;                                 // 0x0004(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DistanceCheckThreshold;                            // 0x0008(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         StuckTimeNeededToApplyImpulse;                     // 0x000C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinTimeBetweenUnstuckAttempts;                     // 0x0010(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2AF4[0x10];                                    // 0x0014(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGzAntiStuckParams) == 0x000004, "Wrong alignment on FGzAntiStuckParams");
static_assert(sizeof(FGzAntiStuckParams) == 0x000024, "Wrong size on FGzAntiStuckParams");
static_assert(offsetof(FGzAntiStuckParams, InitialImpulse) == 0x000000, "Member 'FGzAntiStuckParams::InitialImpulse' has a wrong offset!");
static_assert(offsetof(FGzAntiStuckParams, AdditionalImpulse) == 0x000004, "Member 'FGzAntiStuckParams::AdditionalImpulse' has a wrong offset!");
static_assert(offsetof(FGzAntiStuckParams, DistanceCheckThreshold) == 0x000008, "Member 'FGzAntiStuckParams::DistanceCheckThreshold' has a wrong offset!");
static_assert(offsetof(FGzAntiStuckParams, StuckTimeNeededToApplyImpulse) == 0x00000C, "Member 'FGzAntiStuckParams::StuckTimeNeededToApplyImpulse' has a wrong offset!");
static_assert(offsetof(FGzAntiStuckParams, MinTimeBetweenUnstuckAttempts) == 0x000010, "Member 'FGzAntiStuckParams::MinTimeBetweenUnstuckAttempts' has a wrong offset!");

// ScriptStruct G01.GzCharacterSetup
// 0x0008 (0x0008 - 0x0000)
struct FGzCharacterSetup final
{
public:
	struct FGameplayTag                           PoseTag;                                           // 0x0000(0x0008)(Edit, DisableEditOnTemplate, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzCharacterSetup) == 0x000004, "Wrong alignment on FGzCharacterSetup");
static_assert(sizeof(FGzCharacterSetup) == 0x000008, "Wrong size on FGzCharacterSetup");
static_assert(offsetof(FGzCharacterSetup, PoseTag) == 0x000000, "Member 'FGzCharacterSetup::PoseTag' has a wrong offset!");

// ScriptStruct G01.GzTagToVisibilityState
// 0x000C (0x000C - 0x0000)
struct FGzTagToVisibilityState final
{
public:
	struct FGameplayTag                           Tag;                                               // 0x0000(0x0008)(Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EGzWorldVisibilityState                       State;                                             // 0x0008(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2AF5[0x3];                                     // 0x0009(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGzTagToVisibilityState) == 0x000004, "Wrong alignment on FGzTagToVisibilityState");
static_assert(sizeof(FGzTagToVisibilityState) == 0x00000C, "Wrong size on FGzTagToVisibilityState");
static_assert(offsetof(FGzTagToVisibilityState, Tag) == 0x000000, "Member 'FGzTagToVisibilityState::Tag' has a wrong offset!");
static_assert(offsetof(FGzTagToVisibilityState, State) == 0x000008, "Member 'FGzTagToVisibilityState::State' has a wrong offset!");

// ScriptStruct G01.GzResultCheatUpdateAchievementsProgress
// 0x0000 (0x00E0 - 0x00E0)
struct FGzResultCheatUpdateAchievementsProgress final : public FGzPlayFabResultBase
{
};
static_assert(alignof(FGzResultCheatUpdateAchievementsProgress) == 0x000008, "Wrong alignment on FGzResultCheatUpdateAchievementsProgress");
static_assert(sizeof(FGzResultCheatUpdateAchievementsProgress) == 0x0000E0, "Wrong size on FGzResultCheatUpdateAchievementsProgress");

// ScriptStruct G01.GzResultCheatCompleteAchievementStage
// 0x0000 (0x00E0 - 0x00E0)
struct FGzResultCheatCompleteAchievementStage final : public FGzPlayFabResultBase
{
};
static_assert(alignof(FGzResultCheatCompleteAchievementStage) == 0x000008, "Wrong alignment on FGzResultCheatCompleteAchievementStage");
static_assert(sizeof(FGzResultCheatCompleteAchievementStage) == 0x0000E0, "Wrong size on FGzResultCheatCompleteAchievementStage");

// ScriptStruct G01.GzResultCheatCompleteChallenge
// 0x0000 (0x00E0 - 0x00E0)
struct FGzResultCheatCompleteChallenge final : public FGzPlayFabResultBase
{
};
static_assert(alignof(FGzResultCheatCompleteChallenge) == 0x000008, "Wrong alignment on FGzResultCheatCompleteChallenge");
static_assert(sizeof(FGzResultCheatCompleteChallenge) == 0x0000E0, "Wrong size on FGzResultCheatCompleteChallenge");

// ScriptStruct G01.GzResultCheatResetAllChallenges
// 0x0000 (0x00E0 - 0x00E0)
struct FGzResultCheatResetAllChallenges final : public FGzPlayFabResultBase
{
};
static_assert(alignof(FGzResultCheatResetAllChallenges) == 0x000008, "Wrong alignment on FGzResultCheatResetAllChallenges");
static_assert(sizeof(FGzResultCheatResetAllChallenges) == 0x0000E0, "Wrong size on FGzResultCheatResetAllChallenges");

// ScriptStruct G01.GzCheatStartServerResult
// 0x0000 (0x00E0 - 0x00E0)
struct FGzCheatStartServerResult final : public FGzPlayFabResultBase
{
};
static_assert(alignof(FGzCheatStartServerResult) == 0x000008, "Wrong alignment on FGzCheatStartServerResult");
static_assert(sizeof(FGzCheatStartServerResult) == 0x0000E0, "Wrong size on FGzCheatStartServerResult");

// ScriptStruct G01.GzResultCheatCompleteJob
// 0x0000 (0x00E0 - 0x00E0)
struct FGzResultCheatCompleteJob final : public FGzPlayFabResultBase
{
};
static_assert(alignof(FGzResultCheatCompleteJob) == 0x000008, "Wrong alignment on FGzResultCheatCompleteJob");
static_assert(sizeof(FGzResultCheatCompleteJob) == 0x0000E0, "Wrong size on FGzResultCheatCompleteJob");

// ScriptStruct G01.GzResultCheatResetAllJobs
// 0x0000 (0x00E0 - 0x00E0)
struct FGzResultCheatResetAllJobs final : public FGzPlayFabResultBase
{
};
static_assert(alignof(FGzResultCheatResetAllJobs) == 0x000008, "Wrong alignment on FGzResultCheatResetAllJobs");
static_assert(sizeof(FGzResultCheatResetAllJobs) == 0x0000E0, "Wrong size on FGzResultCheatResetAllJobs");

// ScriptStruct G01.GzAddBlockchainCoinsResult
// 0x0010 (0x00F0 - 0x00E0)
struct FGzAddBlockchainCoinsResult final : public FGzPlayFabResultBase
{
public:
	class FString                                 BalanceString;                                     // 0x00E0(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzAddBlockchainCoinsResult) == 0x000008, "Wrong alignment on FGzAddBlockchainCoinsResult");
static_assert(sizeof(FGzAddBlockchainCoinsResult) == 0x0000F0, "Wrong size on FGzAddBlockchainCoinsResult");
static_assert(offsetof(FGzAddBlockchainCoinsResult, BalanceString) == 0x0000E0, "Member 'FGzAddBlockchainCoinsResult::BalanceString' has a wrong offset!");

// ScriptStruct G01.GzReportServerAlivePackage
// 0x0010 (0x0078 - 0x0068)
struct FGzReportServerAlivePackage final : public FGzPlayFabClientPackage
{
public:
	class FString                                 Name;                                              // 0x0068(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzReportServerAlivePackage) == 0x000008, "Wrong alignment on FGzReportServerAlivePackage");
static_assert(sizeof(FGzReportServerAlivePackage) == 0x000078, "Wrong size on FGzReportServerAlivePackage");
static_assert(offsetof(FGzReportServerAlivePackage, Name) == 0x000068, "Member 'FGzReportServerAlivePackage::Name' has a wrong offset!");

// ScriptStruct G01.GzCheatGrantXpResult
// 0x0010 (0x00F0 - 0x00E0)
struct FGzCheatGrantXpResult final : public FGzPlayFabResultBase
{
public:
	struct FGzLevelProgression                    PlayerProgression;                                 // 0x00E0(0x0008)(NoDestructor, NativeAccessSpecifierPublic)
	struct FGzLevelProgression                    BattlePassProgression;                             // 0x00E8(0x0008)(NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzCheatGrantXpResult) == 0x000008, "Wrong alignment on FGzCheatGrantXpResult");
static_assert(sizeof(FGzCheatGrantXpResult) == 0x0000F0, "Wrong size on FGzCheatGrantXpResult");
static_assert(offsetof(FGzCheatGrantXpResult, PlayerProgression) == 0x0000E0, "Member 'FGzCheatGrantXpResult::PlayerProgression' has a wrong offset!");
static_assert(offsetof(FGzCheatGrantXpResult, BattlePassProgression) == 0x0000E8, "Member 'FGzCheatGrantXpResult::BattlePassProgression' has a wrong offset!");

// ScriptStruct G01.GzCheatResetPlayerProgressionResult
// 0x0000 (0x00E0 - 0x00E0)
struct FGzCheatResetPlayerProgressionResult final : public FGzPlayFabResultBase
{
};
static_assert(alignof(FGzCheatResetPlayerProgressionResult) == 0x000008, "Wrong alignment on FGzCheatResetPlayerProgressionResult");
static_assert(sizeof(FGzCheatResetPlayerProgressionResult) == 0x0000E0, "Wrong size on FGzCheatResetPlayerProgressionResult");

// ScriptStruct G01.GzResultPublishLoadouts
// 0x0000 (0x00E0 - 0x00E0)
struct FGzResultPublishLoadouts final : public FGzPlayFabResultBase
{
};
static_assert(alignof(FGzResultPublishLoadouts) == 0x000008, "Wrong alignment on FGzResultPublishLoadouts");
static_assert(sizeof(FGzResultPublishLoadouts) == 0x0000E0, "Wrong size on FGzResultPublishLoadouts");

// ScriptStruct G01.GzTextChunk
// 0x0020 (0x0020 - 0x0000)
struct FGzTextChunk final
{
public:
	class FString                                 Font;                                              // 0x0000(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   Text;                                              // 0x0010(0x0010)(Edit, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzTextChunk) == 0x000008, "Wrong alignment on FGzTextChunk");
static_assert(sizeof(FGzTextChunk) == 0x000020, "Wrong size on FGzTextChunk");
static_assert(offsetof(FGzTextChunk, Font) == 0x000000, "Member 'FGzTextChunk::Font' has a wrong offset!");
static_assert(offsetof(FGzTextChunk, Text) == 0x000010, "Member 'FGzTextChunk::Text' has a wrong offset!");

// ScriptStruct G01.GzViewpoint
// 0x0010 (0x0010 - 0x0000)
struct FGzViewpoint final
{
public:
	class AGzViewpointCamera*                     Camera;                                            // 0x0000(0x0008)(Edit, ZeroConstructor, DisableEditOnTemplate, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2AF6[0x8];                                     // 0x0008(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGzViewpoint) == 0x000008, "Wrong alignment on FGzViewpoint");
static_assert(sizeof(FGzViewpoint) == 0x000010, "Wrong size on FGzViewpoint");
static_assert(offsetof(FGzViewpoint, Camera) == 0x000000, "Member 'FGzViewpoint::Camera' has a wrong offset!");

// ScriptStruct G01.GzCITViewmakerSetup
// 0x00A8 (0x00B0 - 0x0008)
struct FGzCITViewmakerSetup final : public FGzDefaultItemViewmakerSetupBase
{
public:
	TMap<struct FGameplayTag, struct FGzViewemakerSetupWithMannequin> PerLogicalSlot;                                    // 0x0008(0x0050)(Edit, DisableEditOnTemplate, NativeAccessSpecifierPrivate)
	struct FGzViewemakerSetupWithMannequin        Default;                                           // 0x0058(0x0058)(Edit, DisableEditOnTemplate, NativeAccessSpecifierPrivate)
};
static_assert(alignof(FGzCITViewmakerSetup) == 0x000008, "Wrong alignment on FGzCITViewmakerSetup");
static_assert(sizeof(FGzCITViewmakerSetup) == 0x0000B0, "Wrong size on FGzCITViewmakerSetup");
static_assert(offsetof(FGzCITViewmakerSetup, PerLogicalSlot) == 0x000008, "Member 'FGzCITViewmakerSetup::PerLogicalSlot' has a wrong offset!");
static_assert(offsetof(FGzCITViewmakerSetup, Default) == 0x000058, "Member 'FGzCITViewmakerSetup::Default' has a wrong offset!");

// ScriptStruct G01.GzResultUpdateChallenges
// 0x0010 (0x00F0 - 0x00E0)
struct FGzResultUpdateChallenges final : public FGzPlayFabResultBase
{
public:
	TArray<class FString>                         List;                                              // 0x00E0(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzResultUpdateChallenges) == 0x000008, "Wrong alignment on FGzResultUpdateChallenges");
static_assert(sizeof(FGzResultUpdateChallenges) == 0x0000F0, "Wrong size on FGzResultUpdateChallenges");
static_assert(offsetof(FGzResultUpdateChallenges, List) == 0x0000E0, "Member 'FGzResultUpdateChallenges::List' has a wrong offset!");

// ScriptStruct G01.GzResultGetChallenges
// 0x0050 (0x0130 - 0x00E0)
struct FGzResultGetChallenges final : public FGzPlayFabResultBase
{
public:
	TMap<EGzGetChallengesResultChallengeScope, struct FGzGetChallengesResultChallengesPack> Challenges;                                        // 0x00E0(0x0050)(NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzResultGetChallenges) == 0x000008, "Wrong alignment on FGzResultGetChallenges");
static_assert(sizeof(FGzResultGetChallenges) == 0x000130, "Wrong size on FGzResultGetChallenges");
static_assert(offsetof(FGzResultGetChallenges, Challenges) == 0x0000E0, "Member 'FGzResultGetChallenges::Challenges' has a wrong offset!");

// ScriptStruct G01.GzResultCustomizationAppearanceUpdate
// 0x0000 (0x00E0 - 0x00E0)
struct FGzResultCustomizationAppearanceUpdate final : public FGzPlayFabResultBase
{
};
static_assert(alignof(FGzResultCustomizationAppearanceUpdate) == 0x000008, "Wrong alignment on FGzResultCustomizationAppearanceUpdate");
static_assert(sizeof(FGzResultCustomizationAppearanceUpdate) == 0x0000E0, "Wrong size on FGzResultCustomizationAppearanceUpdate");

// ScriptStruct G01.GzResultCustomizationAppearanceSetActivePresetId
// 0x0000 (0x00E0 - 0x00E0)
struct FGzResultCustomizationAppearanceSetActivePresetId final : public FGzPlayFabResultBase
{
};
static_assert(alignof(FGzResultCustomizationAppearanceSetActivePresetId) == 0x000008, "Wrong alignment on FGzResultCustomizationAppearanceSetActivePresetId");
static_assert(sizeof(FGzResultCustomizationAppearanceSetActivePresetId) == 0x0000E0, "Wrong size on FGzResultCustomizationAppearanceSetActivePresetId");

// ScriptStruct G01.GzDecodeResult
// 0x00B0 (0x0190 - 0x00E0)
struct FGzDecodeResult final : public FGzPlayFabResultBase
{
public:
	struct FGzBackendInventoryItem                ItemSimplified;                                    // 0x00E0(0x00B0)(NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzDecodeResult) == 0x000008, "Wrong alignment on FGzDecodeResult");
static_assert(sizeof(FGzDecodeResult) == 0x000190, "Wrong size on FGzDecodeResult");
static_assert(offsetof(FGzDecodeResult, ItemSimplified) == 0x0000E0, "Member 'FGzDecodeResult::ItemSimplified' has a wrong offset!");

// ScriptStruct G01.GzDiscoveryResultPlayFabInfo
// 0x0010 (0x0010 - 0x0000)
struct FGzDiscoveryResultPlayFabInfo final
{
public:
	class FString                                 TitleId;                                           // 0x0000(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzDiscoveryResultPlayFabInfo) == 0x000008, "Wrong alignment on FGzDiscoveryResultPlayFabInfo");
static_assert(sizeof(FGzDiscoveryResultPlayFabInfo) == 0x000010, "Wrong size on FGzDiscoveryResultPlayFabInfo");
static_assert(offsetof(FGzDiscoveryResultPlayFabInfo, TitleId) == 0x000000, "Member 'FGzDiscoveryResultPlayFabInfo::TitleId' has a wrong offset!");

// ScriptStruct G01.GzDiscoveryResultUnityInfo
// 0x0020 (0x0020 - 0x0000)
struct FGzDiscoveryResultUnityInfo final
{
public:
	class FString                                 ProjectID;                                         // 0x0000(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 EnvironmentName;                                   // 0x0010(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzDiscoveryResultUnityInfo) == 0x000008, "Wrong alignment on FGzDiscoveryResultUnityInfo");
static_assert(sizeof(FGzDiscoveryResultUnityInfo) == 0x000020, "Wrong size on FGzDiscoveryResultUnityInfo");
static_assert(offsetof(FGzDiscoveryResultUnityInfo, ProjectID) == 0x000000, "Member 'FGzDiscoveryResultUnityInfo::ProjectID' has a wrong offset!");
static_assert(offsetof(FGzDiscoveryResultUnityInfo, EnvironmentName) == 0x000010, "Member 'FGzDiscoveryResultUnityInfo::EnvironmentName' has a wrong offset!");

// ScriptStruct G01.GzDiscoveryResult
// 0x0060 (0x0060 - 0x0000)
struct FGzDiscoveryResult final
{
public:
	struct FGzDiscoveryResultPlayFabInfo          PlayFab;                                           // 0x0000(0x0010)(NativeAccessSpecifierPublic)
	struct FGzDiscoveryResultUnityInfo            Unity;                                             // 0x0010(0x0020)(NativeAccessSpecifierPublic)
	struct FGzDiscoveryResultNewsInfo             News;                                              // 0x0030(0x0020)(NativeAccessSpecifierPublic)
	class FString                                 LiveDataCdnUrl;                                    // 0x0050(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzDiscoveryResult) == 0x000008, "Wrong alignment on FGzDiscoveryResult");
static_assert(sizeof(FGzDiscoveryResult) == 0x000060, "Wrong size on FGzDiscoveryResult");
static_assert(offsetof(FGzDiscoveryResult, PlayFab) == 0x000000, "Member 'FGzDiscoveryResult::PlayFab' has a wrong offset!");
static_assert(offsetof(FGzDiscoveryResult, Unity) == 0x000010, "Member 'FGzDiscoveryResult::Unity' has a wrong offset!");
static_assert(offsetof(FGzDiscoveryResult, News) == 0x000030, "Member 'FGzDiscoveryResult::News' has a wrong offset!");
static_assert(offsetof(FGzDiscoveryResult, LiveDataCdnUrl) == 0x000050, "Member 'FGzDiscoveryResult::LiveDataCdnUrl' has a wrong offset!");

// ScriptStruct G01.GzPackageLoadout
// 0x0060 (0x0060 - 0x0000)
struct FGzPackageLoadout final
{
public:
	class FString                                 LoadoutName;                                       // 0x0000(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMap<EGzLoadoutSlots, struct FGzPackageLoadoutSlotItem> Slots;                                             // 0x0010(0x0050)(NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzPackageLoadout) == 0x000008, "Wrong alignment on FGzPackageLoadout");
static_assert(sizeof(FGzPackageLoadout) == 0x000060, "Wrong size on FGzPackageLoadout");
static_assert(offsetof(FGzPackageLoadout, LoadoutName) == 0x000000, "Member 'FGzPackageLoadout::LoadoutName' has a wrong offset!");
static_assert(offsetof(FGzPackageLoadout, Slots) == 0x000010, "Member 'FGzPackageLoadout::Slots' has a wrong offset!");

// ScriptStruct G01.GzUpdateLoadoutsResult
// 0x0050 (0x0130 - 0x00E0)
struct FGzUpdateLoadoutsResult final : public FGzPlayFabResultBase
{
public:
	TMap<class FString, struct FGzPackageLoadout> Loadouts;                                          // 0x00E0(0x0050)(NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzUpdateLoadoutsResult) == 0x000008, "Wrong alignment on FGzUpdateLoadoutsResult");
static_assert(sizeof(FGzUpdateLoadoutsResult) == 0x000130, "Wrong size on FGzUpdateLoadoutsResult");
static_assert(offsetof(FGzUpdateLoadoutsResult, Loadouts) == 0x0000E0, "Member 'FGzUpdateLoadoutsResult::Loadouts' has a wrong offset!");

// ScriptStruct G01.GzResultAvailableAssignment
// 0x0010 (0x0028 - 0x0018)
struct FGzResultAvailableAssignment final : public FGzResultAvailableTask
{
public:
	TArray<struct FGzResultAvailableGoal>         Goals;                                             // 0x0018(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzResultAvailableAssignment) == 0x000008, "Wrong alignment on FGzResultAvailableAssignment");
static_assert(sizeof(FGzResultAvailableAssignment) == 0x000028, "Wrong size on FGzResultAvailableAssignment");
static_assert(offsetof(FGzResultAvailableAssignment, Goals) == 0x000018, "Member 'FGzResultAvailableAssignment::Goals' has a wrong offset!");

// ScriptStruct G01.GzResultGetAvailableAssignments
// 0x0010 (0x00F0 - 0x00E0)
struct FGzResultGetAvailableAssignments final : public FGzPlayFabResultBase
{
public:
	TArray<struct FGzResultAvailableAssignment>   Assignments;                                       // 0x00E0(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzResultGetAvailableAssignments) == 0x000008, "Wrong alignment on FGzResultGetAvailableAssignments");
static_assert(sizeof(FGzResultGetAvailableAssignments) == 0x0000F0, "Wrong size on FGzResultGetAvailableAssignments");
static_assert(offsetof(FGzResultGetAvailableAssignments, Assignments) == 0x0000E0, "Member 'FGzResultGetAvailableAssignments::Assignments' has a wrong offset!");

// ScriptStruct G01.GzRenameCharacterResult
// 0x0030 (0x0110 - 0x00E0)
struct FGzRenameCharacterResult final : public FGzPlayFabResultBase
{
public:
	class FString                                 PlayFabId;                                         // 0x00E0(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 CharacterName;                                     // 0x00F0(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 CharacterId;                                       // 0x0100(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzRenameCharacterResult) == 0x000008, "Wrong alignment on FGzRenameCharacterResult");
static_assert(sizeof(FGzRenameCharacterResult) == 0x000110, "Wrong size on FGzRenameCharacterResult");
static_assert(offsetof(FGzRenameCharacterResult, PlayFabId) == 0x0000E0, "Member 'FGzRenameCharacterResult::PlayFabId' has a wrong offset!");
static_assert(offsetof(FGzRenameCharacterResult, CharacterName) == 0x0000F0, "Member 'FGzRenameCharacterResult::CharacterName' has a wrong offset!");
static_assert(offsetof(FGzRenameCharacterResult, CharacterId) == 0x000100, "Member 'FGzRenameCharacterResult::CharacterId' has a wrong offset!");

// ScriptStruct G01.GzGetPlayFabIdFromTitlePlayerAccountIdResult
// 0x0010 (0x00F0 - 0x00E0)
struct FGzGetPlayFabIdFromTitlePlayerAccountIdResult final : public FGzPlayFabResultBase
{
public:
	class FString                                 PlayFabId;                                         // 0x00E0(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzGetPlayFabIdFromTitlePlayerAccountIdResult) == 0x000008, "Wrong alignment on FGzGetPlayFabIdFromTitlePlayerAccountIdResult");
static_assert(sizeof(FGzGetPlayFabIdFromTitlePlayerAccountIdResult) == 0x0000F0, "Wrong size on FGzGetPlayFabIdFromTitlePlayerAccountIdResult");
static_assert(offsetof(FGzGetPlayFabIdFromTitlePlayerAccountIdResult, PlayFabId) == 0x0000E0, "Member 'FGzGetPlayFabIdFromTitlePlayerAccountIdResult::PlayFabId' has a wrong offset!");

// ScriptStruct G01.GzResultGetNotifications
// 0x0020 (0x0100 - 0x00E0)
struct FGzResultGetNotifications final : public FGzPlayFabResultBase
{
public:
	class FString                                 ContinuationToken;                                 // 0x00E0(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 NotificationsJson;                                 // 0x00F0(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzResultGetNotifications) == 0x000008, "Wrong alignment on FGzResultGetNotifications");
static_assert(sizeof(FGzResultGetNotifications) == 0x000100, "Wrong size on FGzResultGetNotifications");
static_assert(offsetof(FGzResultGetNotifications, ContinuationToken) == 0x0000E0, "Member 'FGzResultGetNotifications::ContinuationToken' has a wrong offset!");
static_assert(offsetof(FGzResultGetNotifications, NotificationsJson) == 0x0000F0, "Member 'FGzResultGetNotifications::NotificationsJson' has a wrong offset!");

// ScriptStruct G01.GzResultReportPlayerInMatch
// 0x0000 (0x00E0 - 0x00E0)
struct FGzResultReportPlayerInMatch final : public FGzPlayFabResultBase
{
};
static_assert(alignof(FGzResultReportPlayerInMatch) == 0x000008, "Wrong alignment on FGzResultReportPlayerInMatch");
static_assert(sizeof(FGzResultReportPlayerInMatch) == 0x0000E0, "Wrong size on FGzResultReportPlayerInMatch");

// ScriptStruct G01.GzResultCollectClientSettingsStatistics
// 0x0000 (0x00E0 - 0x00E0)
struct FGzResultCollectClientSettingsStatistics final : public FGzPlayFabResultBase
{
};
static_assert(alignof(FGzResultCollectClientSettingsStatistics) == 0x000008, "Wrong alignment on FGzResultCollectClientSettingsStatistics");
static_assert(sizeof(FGzResultCollectClientSettingsStatistics) == 0x0000E0, "Wrong size on FGzResultCollectClientSettingsStatistics");

// ScriptStruct G01.GzResultCollectPlayerSpec
// 0x0000 (0x00E0 - 0x00E0)
struct FGzResultCollectPlayerSpec final : public FGzPlayFabResultBase
{
};
static_assert(alignof(FGzResultCollectPlayerSpec) == 0x000008, "Wrong alignment on FGzResultCollectPlayerSpec");
static_assert(sizeof(FGzResultCollectPlayerSpec) == 0x0000E0, "Wrong size on FGzResultCollectPlayerSpec");

// ScriptStruct G01.GzPurchaseBattlePassItemPackageV2
// 0x0010 (0x0078 - 0x0068)
struct FGzPurchaseBattlePassItemPackageV2 final : public FGzPlayFabClientPackage
{
public:
	class FString                                 SlotRewardId;                                      // 0x0068(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzPurchaseBattlePassItemPackageV2) == 0x000008, "Wrong alignment on FGzPurchaseBattlePassItemPackageV2");
static_assert(sizeof(FGzPurchaseBattlePassItemPackageV2) == 0x000078, "Wrong size on FGzPurchaseBattlePassItemPackageV2");
static_assert(offsetof(FGzPurchaseBattlePassItemPackageV2, SlotRewardId) == 0x000068, "Member 'FGzPurchaseBattlePassItemPackageV2::SlotRewardId' has a wrong offset!");

// ScriptStruct G01.GzClientUserInfo
// 0x0110 (0x0110 - 0x0000)
struct FGzClientUserInfo final
{
public:
	class FString                                 PlayFabId;                                         // 0x0000(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   TitleAccountId;                                    // 0x0010(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 EpicAccountId;                                     // 0x0018(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 LoginTime;                                         // 0x0028(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Username;                                          // 0x0038(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 DisplayName;                                       // 0x0048(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 ClanTag;                                           // 0x0058(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   AvatarId;                                          // 0x0068(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMap<class FString, int32>                    VirtualCurrencies;                                 // 0x0070(0x0050)(NativeAccessSpecifierPublic)
	TMap<class FString, double>                   CoinCurrencies;                                    // 0x00C0(0x0050)(NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzClientUserInfo) == 0x000008, "Wrong alignment on FGzClientUserInfo");
static_assert(sizeof(FGzClientUserInfo) == 0x000110, "Wrong size on FGzClientUserInfo");
static_assert(offsetof(FGzClientUserInfo, PlayFabId) == 0x000000, "Member 'FGzClientUserInfo::PlayFabId' has a wrong offset!");
static_assert(offsetof(FGzClientUserInfo, TitleAccountId) == 0x000010, "Member 'FGzClientUserInfo::TitleAccountId' has a wrong offset!");
static_assert(offsetof(FGzClientUserInfo, EpicAccountId) == 0x000018, "Member 'FGzClientUserInfo::EpicAccountId' has a wrong offset!");
static_assert(offsetof(FGzClientUserInfo, LoginTime) == 0x000028, "Member 'FGzClientUserInfo::LoginTime' has a wrong offset!");
static_assert(offsetof(FGzClientUserInfo, Username) == 0x000038, "Member 'FGzClientUserInfo::Username' has a wrong offset!");
static_assert(offsetof(FGzClientUserInfo, DisplayName) == 0x000048, "Member 'FGzClientUserInfo::DisplayName' has a wrong offset!");
static_assert(offsetof(FGzClientUserInfo, ClanTag) == 0x000058, "Member 'FGzClientUserInfo::ClanTag' has a wrong offset!");
static_assert(offsetof(FGzClientUserInfo, AvatarId) == 0x000068, "Member 'FGzClientUserInfo::AvatarId' has a wrong offset!");
static_assert(offsetof(FGzClientUserInfo, VirtualCurrencies) == 0x000070, "Member 'FGzClientUserInfo::VirtualCurrencies' has a wrong offset!");
static_assert(offsetof(FGzClientUserInfo, CoinCurrencies) == 0x0000C0, "Member 'FGzClientUserInfo::CoinCurrencies' has a wrong offset!");

// ScriptStruct G01.GzWeaponAttachmentAnimations
// 0x0018 (0x0018 - 0x0000)
struct FGzWeaponAttachmentAnimations final
{
public:
	int32                                         LimbState;                                         // 0x0000(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2AF7[0x4];                                     // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UAnimMontage*                           AttachmentMontage;                                 // 0x0008(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShouldEndOnTagLoss;                               // 0x0010(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2AF8[0x7];                                     // 0x0011(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGzWeaponAttachmentAnimations) == 0x000008, "Wrong alignment on FGzWeaponAttachmentAnimations");
static_assert(sizeof(FGzWeaponAttachmentAnimations) == 0x000018, "Wrong size on FGzWeaponAttachmentAnimations");
static_assert(offsetof(FGzWeaponAttachmentAnimations, LimbState) == 0x000000, "Member 'FGzWeaponAttachmentAnimations::LimbState' has a wrong offset!");
static_assert(offsetof(FGzWeaponAttachmentAnimations, AttachmentMontage) == 0x000008, "Member 'FGzWeaponAttachmentAnimations::AttachmentMontage' has a wrong offset!");
static_assert(offsetof(FGzWeaponAttachmentAnimations, bShouldEndOnTagLoss) == 0x000010, "Member 'FGzWeaponAttachmentAnimations::bShouldEndOnTagLoss' has a wrong offset!");

// ScriptStruct G01.GzDamageableStaticMeshConfig
// 0x0020 (0x0020 - 0x0000)
struct FGzDamageableStaticMeshConfig final
{
public:
	class UStaticMesh*                            DamagedStaticMesh;                                 // 0x0000(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UNiagaraSystem*                         DamageParticleEffect;                              // 0x0008(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAkAudioEvent*                          AudioEvent;                                        // 0x0010(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   VFXAttachSocket;                                   // 0x0018(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzDamageableStaticMeshConfig) == 0x000008, "Wrong alignment on FGzDamageableStaticMeshConfig");
static_assert(sizeof(FGzDamageableStaticMeshConfig) == 0x000020, "Wrong size on FGzDamageableStaticMeshConfig");
static_assert(offsetof(FGzDamageableStaticMeshConfig, DamagedStaticMesh) == 0x000000, "Member 'FGzDamageableStaticMeshConfig::DamagedStaticMesh' has a wrong offset!");
static_assert(offsetof(FGzDamageableStaticMeshConfig, DamageParticleEffect) == 0x000008, "Member 'FGzDamageableStaticMeshConfig::DamageParticleEffect' has a wrong offset!");
static_assert(offsetof(FGzDamageableStaticMeshConfig, AudioEvent) == 0x000010, "Member 'FGzDamageableStaticMeshConfig::AudioEvent' has a wrong offset!");
static_assert(offsetof(FGzDamageableStaticMeshConfig, VFXAttachSocket) == 0x000018, "Member 'FGzDamageableStaticMeshConfig::VFXAttachSocket' has a wrong offset!");

// ScriptStruct G01.GzResultWeaponConfigurationsUpdate
// 0x0000 (0x00E0 - 0x00E0)
struct FGzResultWeaponConfigurationsUpdate final : public FGzPlayFabResultBase
{
};
static_assert(alignof(FGzResultWeaponConfigurationsUpdate) == 0x000008, "Wrong alignment on FGzResultWeaponConfigurationsUpdate");
static_assert(sizeof(FGzResultWeaponConfigurationsUpdate) == 0x0000E0, "Wrong size on FGzResultWeaponConfigurationsUpdate");

// ScriptStruct G01.GzRootMotionSource_Dash
// 0x0020 (0x0160 - 0x0140)
struct FGzRootMotionSource_Dash final : public FRootMotionSource_MoveToDynamicForce
{
public:
	bool                                          bHasOverrideStartLocation;                         // 0x0138(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2AF9[0x7];                                     // 0x0139(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                OverrideStartLocation;                             // 0x0140(0x0018)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2AFA[0x8];                                     // 0x0158(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGzRootMotionSource_Dash) == 0x000010, "Wrong alignment on FGzRootMotionSource_Dash");
static_assert(sizeof(FGzRootMotionSource_Dash) == 0x000160, "Wrong size on FGzRootMotionSource_Dash");
static_assert(offsetof(FGzRootMotionSource_Dash, bHasOverrideStartLocation) == 0x000138, "Member 'FGzRootMotionSource_Dash::bHasOverrideStartLocation' has a wrong offset!");
static_assert(offsetof(FGzRootMotionSource_Dash, OverrideStartLocation) == 0x000140, "Member 'FGzRootMotionSource_Dash::OverrideStartLocation' has a wrong offset!");

// ScriptStruct G01.GzMeshCachedMaterials
// 0x0020 (0x0020 - 0x0000)
struct FGzMeshCachedMaterials final
{
public:
	TWeakObjectPtr<class UMeshComponent>          Mesh;                                              // 0x0000(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class UMaterialInterface*>             CachedMaterials;                                   // 0x0008(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_2AFB[0x8];                                     // 0x0018(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGzMeshCachedMaterials) == 0x000008, "Wrong alignment on FGzMeshCachedMaterials");
static_assert(sizeof(FGzMeshCachedMaterials) == 0x000020, "Wrong size on FGzMeshCachedMaterials");
static_assert(offsetof(FGzMeshCachedMaterials, Mesh) == 0x000000, "Member 'FGzMeshCachedMaterials::Mesh' has a wrong offset!");
static_assert(offsetof(FGzMeshCachedMaterials, CachedMaterials) == 0x000008, "Member 'FGzMeshCachedMaterials::CachedMaterials' has a wrong offset!");

// ScriptStruct G01.GzWeaponCachedMeshes
// 0x0018 (0x0018 - 0x0000)
struct FGzWeaponCachedMeshes final
{
public:
	TWeakObjectPtr<class AActor>                  Weapon;                                            // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FGzMeshCachedMaterials>         Meshes;                                            // 0x0008(0x0010)(ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzWeaponCachedMeshes) == 0x000008, "Wrong alignment on FGzWeaponCachedMeshes");
static_assert(sizeof(FGzWeaponCachedMeshes) == 0x000018, "Wrong size on FGzWeaponCachedMeshes");
static_assert(offsetof(FGzWeaponCachedMeshes, Weapon) == 0x000000, "Member 'FGzWeaponCachedMeshes::Weapon' has a wrong offset!");
static_assert(offsetof(FGzWeaponCachedMeshes, Meshes) == 0x000008, "Member 'FGzWeaponCachedMeshes::Meshes' has a wrong offset!");

// ScriptStruct G01.GzCloak_Gadget_InitInfo
// 0x0058 (0x0058 - 0x0000)
struct FGzCloak_Gadget_InitInfo final
{
public:
	TSubclassOf<class UGameplayEffect>            SpeedBoostEffect;                                  // 0x0000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CloakChargeMaxSpeed;                               // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CloakChargeMinOnMaxSpeed;                          // 0x000C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BlendTime;                                         // 0x0010(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxHP;                                             // 0x0014(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         GadgetLifeTime;                                    // 0x0018(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CloakDamageCoef;                                   // 0x001C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         GadgetFieldRadius;                                 // 0x0020(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2AFC[0x4];                                     // 0x0024(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                HitNormal;                                         // 0x0028(0x0018)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                TargetLocation;                                    // 0x0040(0x0018)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzCloak_Gadget_InitInfo) == 0x000008, "Wrong alignment on FGzCloak_Gadget_InitInfo");
static_assert(sizeof(FGzCloak_Gadget_InitInfo) == 0x000058, "Wrong size on FGzCloak_Gadget_InitInfo");
static_assert(offsetof(FGzCloak_Gadget_InitInfo, SpeedBoostEffect) == 0x000000, "Member 'FGzCloak_Gadget_InitInfo::SpeedBoostEffect' has a wrong offset!");
static_assert(offsetof(FGzCloak_Gadget_InitInfo, CloakChargeMaxSpeed) == 0x000008, "Member 'FGzCloak_Gadget_InitInfo::CloakChargeMaxSpeed' has a wrong offset!");
static_assert(offsetof(FGzCloak_Gadget_InitInfo, CloakChargeMinOnMaxSpeed) == 0x00000C, "Member 'FGzCloak_Gadget_InitInfo::CloakChargeMinOnMaxSpeed' has a wrong offset!");
static_assert(offsetof(FGzCloak_Gadget_InitInfo, BlendTime) == 0x000010, "Member 'FGzCloak_Gadget_InitInfo::BlendTime' has a wrong offset!");
static_assert(offsetof(FGzCloak_Gadget_InitInfo, MaxHP) == 0x000014, "Member 'FGzCloak_Gadget_InitInfo::MaxHP' has a wrong offset!");
static_assert(offsetof(FGzCloak_Gadget_InitInfo, GadgetLifeTime) == 0x000018, "Member 'FGzCloak_Gadget_InitInfo::GadgetLifeTime' has a wrong offset!");
static_assert(offsetof(FGzCloak_Gadget_InitInfo, CloakDamageCoef) == 0x00001C, "Member 'FGzCloak_Gadget_InitInfo::CloakDamageCoef' has a wrong offset!");
static_assert(offsetof(FGzCloak_Gadget_InitInfo, GadgetFieldRadius) == 0x000020, "Member 'FGzCloak_Gadget_InitInfo::GadgetFieldRadius' has a wrong offset!");
static_assert(offsetof(FGzCloak_Gadget_InitInfo, HitNormal) == 0x000028, "Member 'FGzCloak_Gadget_InitInfo::HitNormal' has a wrong offset!");
static_assert(offsetof(FGzCloak_Gadget_InitInfo, TargetLocation) == 0x000040, "Member 'FGzCloak_Gadget_InitInfo::TargetLocation' has a wrong offset!");

// ScriptStruct G01.GzCohtmlRewardData
// 0x0080 (0x0080 - 0x0000)
struct FGzCohtmlRewardData final
{
public:
	class FText                                   Description;                                       // 0x0000(0x0010)(NativeAccessSpecifierPublic)
	TMap<class FString, double>                   Coins;                                             // 0x0010(0x0050)(NativeAccessSpecifierPublic)
	int32                                         ProgressXp;                                        // 0x0060(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PlayerXpModifier;                                  // 0x0064(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BattlePassXpModifier;                              // 0x0068(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2AFD[0x4];                                     // 0x006C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FString>                         GrantItems;                                        // 0x0070(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzCohtmlRewardData) == 0x000008, "Wrong alignment on FGzCohtmlRewardData");
static_assert(sizeof(FGzCohtmlRewardData) == 0x000080, "Wrong size on FGzCohtmlRewardData");
static_assert(offsetof(FGzCohtmlRewardData, Description) == 0x000000, "Member 'FGzCohtmlRewardData::Description' has a wrong offset!");
static_assert(offsetof(FGzCohtmlRewardData, Coins) == 0x000010, "Member 'FGzCohtmlRewardData::Coins' has a wrong offset!");
static_assert(offsetof(FGzCohtmlRewardData, ProgressXp) == 0x000060, "Member 'FGzCohtmlRewardData::ProgressXp' has a wrong offset!");
static_assert(offsetof(FGzCohtmlRewardData, PlayerXpModifier) == 0x000064, "Member 'FGzCohtmlRewardData::PlayerXpModifier' has a wrong offset!");
static_assert(offsetof(FGzCohtmlRewardData, BattlePassXpModifier) == 0x000068, "Member 'FGzCohtmlRewardData::BattlePassXpModifier' has a wrong offset!");
static_assert(offsetof(FGzCohtmlRewardData, GrantItems) == 0x000070, "Member 'FGzCohtmlRewardData::GrantItems' has a wrong offset!");

// ScriptStruct G01.GzCohtmlAchievementStage
// 0x0038 (0x0038 - 0x0000)
struct FGzCohtmlAchievementStage final
{
public:
	class FText                                   Name;                                              // 0x0000(0x0010)(NativeAccessSpecifierPublic)
	class FText                                   Description;                                       // 0x0010(0x0010)(NativeAccessSpecifierPublic)
	float                                         MaxProgress;                                       // 0x0020(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2AFE[0x4];                                     // 0x0024(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FText>                           Rewards;                                           // 0x0028(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzCohtmlAchievementStage) == 0x000008, "Wrong alignment on FGzCohtmlAchievementStage");
static_assert(sizeof(FGzCohtmlAchievementStage) == 0x000038, "Wrong size on FGzCohtmlAchievementStage");
static_assert(offsetof(FGzCohtmlAchievementStage, Name) == 0x000000, "Member 'FGzCohtmlAchievementStage::Name' has a wrong offset!");
static_assert(offsetof(FGzCohtmlAchievementStage, Description) == 0x000010, "Member 'FGzCohtmlAchievementStage::Description' has a wrong offset!");
static_assert(offsetof(FGzCohtmlAchievementStage, MaxProgress) == 0x000020, "Member 'FGzCohtmlAchievementStage::MaxProgress' has a wrong offset!");
static_assert(offsetof(FGzCohtmlAchievementStage, Rewards) == 0x000028, "Member 'FGzCohtmlAchievementStage::Rewards' has a wrong offset!");

// ScriptStruct G01.GzCohtmlAchievement
// 0x0018 (0x0018 - 0x0000)
struct FGzCohtmlAchievement final
{
public:
	float                                         CurrentProgress;                                   // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         CurrentStageIndex;                                 // 0x0004(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FGzCohtmlAchievementStage>      Stages;                                            // 0x0008(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzCohtmlAchievement) == 0x000008, "Wrong alignment on FGzCohtmlAchievement");
static_assert(sizeof(FGzCohtmlAchievement) == 0x000018, "Wrong size on FGzCohtmlAchievement");
static_assert(offsetof(FGzCohtmlAchievement, CurrentProgress) == 0x000000, "Member 'FGzCohtmlAchievement::CurrentProgress' has a wrong offset!");
static_assert(offsetof(FGzCohtmlAchievement, CurrentStageIndex) == 0x000004, "Member 'FGzCohtmlAchievement::CurrentStageIndex' has a wrong offset!");
static_assert(offsetof(FGzCohtmlAchievement, Stages) == 0x000008, "Member 'FGzCohtmlAchievement::Stages' has a wrong offset!");

// ScriptStruct G01.GzRefreshXsollaTokenPackage
// 0x0000 (0x0068 - 0x0068)
struct FGzRefreshXsollaTokenPackage final : public FGzPlayFabClientPackage
{
};
static_assert(alignof(FGzRefreshXsollaTokenPackage) == 0x000008, "Wrong alignment on FGzRefreshXsollaTokenPackage");
static_assert(sizeof(FGzRefreshXsollaTokenPackage) == 0x000068, "Wrong size on FGzRefreshXsollaTokenPackage");

// ScriptStruct G01.GzCohtmlStackTrace
// 0x0030 (0x0030 - 0x0000)
struct FGzCohtmlStackTrace final
{
public:
	class FString                                 TypeName;                                          // 0x0000(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 FieldName;                                         // 0x0010(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class FString>                         Frames;                                            // 0x0020(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzCohtmlStackTrace) == 0x000008, "Wrong alignment on FGzCohtmlStackTrace");
static_assert(sizeof(FGzCohtmlStackTrace) == 0x000030, "Wrong size on FGzCohtmlStackTrace");
static_assert(offsetof(FGzCohtmlStackTrace, TypeName) == 0x000000, "Member 'FGzCohtmlStackTrace::TypeName' has a wrong offset!");
static_assert(offsetof(FGzCohtmlStackTrace, FieldName) == 0x000010, "Member 'FGzCohtmlStackTrace::FieldName' has a wrong offset!");
static_assert(offsetof(FGzCohtmlStackTrace, Frames) == 0x000020, "Member 'FGzCohtmlStackTrace::Frames' has a wrong offset!");

// ScriptStruct G01.GzCohtmlAchievementsGroup
// 0x0040 (0x0040 - 0x0000)
struct FGzCohtmlAchievementsGroup final
{
public:
	class FText                                   Title;                                             // 0x0000(0x0010)(NativeAccessSpecifierPublic)
	class FString                                 Icon;                                              // 0x0010(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   Description;                                       // 0x0020(0x0010)(NativeAccessSpecifierPublic)
	TArray<struct FGzCohtmlAchievement>           Achievements;                                      // 0x0030(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzCohtmlAchievementsGroup) == 0x000008, "Wrong alignment on FGzCohtmlAchievementsGroup");
static_assert(sizeof(FGzCohtmlAchievementsGroup) == 0x000040, "Wrong size on FGzCohtmlAchievementsGroup");
static_assert(offsetof(FGzCohtmlAchievementsGroup, Title) == 0x000000, "Member 'FGzCohtmlAchievementsGroup::Title' has a wrong offset!");
static_assert(offsetof(FGzCohtmlAchievementsGroup, Icon) == 0x000010, "Member 'FGzCohtmlAchievementsGroup::Icon' has a wrong offset!");
static_assert(offsetof(FGzCohtmlAchievementsGroup, Description) == 0x000020, "Member 'FGzCohtmlAchievementsGroup::Description' has a wrong offset!");
static_assert(offsetof(FGzCohtmlAchievementsGroup, Achievements) == 0x000030, "Member 'FGzCohtmlAchievementsGroup::Achievements' has a wrong offset!");

// ScriptStruct G01.GzCohtmlJobArchetype
// 0x0020 (0x0020 - 0x0000)
struct FGzCohtmlJobArchetype final
{
public:
	class FText                                   DisplayName;                                       // 0x0000(0x0010)(NativeAccessSpecifierPublic)
	class FString                                 CohtmlImage;                                       // 0x0010(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzCohtmlJobArchetype) == 0x000008, "Wrong alignment on FGzCohtmlJobArchetype");
static_assert(sizeof(FGzCohtmlJobArchetype) == 0x000020, "Wrong size on FGzCohtmlJobArchetype");
static_assert(offsetof(FGzCohtmlJobArchetype, DisplayName) == 0x000000, "Member 'FGzCohtmlJobArchetype::DisplayName' has a wrong offset!");
static_assert(offsetof(FGzCohtmlJobArchetype, CohtmlImage) == 0x000010, "Member 'FGzCohtmlJobArchetype::CohtmlImage' has a wrong offset!");

// ScriptStruct G01.GzCohtmlSettingValueDiscrete
// 0x0018 (0x0018 - 0x0000)
struct FGzCohtmlSettingValueDiscrete final
{
public:
	TArray<class FText>                           OPTIONS;                                           // 0x0000(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	int32                                         OptionIndex;                                       // 0x0010(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2AFF[0x4];                                     // 0x0014(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGzCohtmlSettingValueDiscrete) == 0x000008, "Wrong alignment on FGzCohtmlSettingValueDiscrete");
static_assert(sizeof(FGzCohtmlSettingValueDiscrete) == 0x000018, "Wrong size on FGzCohtmlSettingValueDiscrete");
static_assert(offsetof(FGzCohtmlSettingValueDiscrete, OPTIONS) == 0x000000, "Member 'FGzCohtmlSettingValueDiscrete::OPTIONS' has a wrong offset!");
static_assert(offsetof(FGzCohtmlSettingValueDiscrete, OptionIndex) == 0x000010, "Member 'FGzCohtmlSettingValueDiscrete::OptionIndex' has a wrong offset!");

// ScriptStruct G01.GzCohtmlJobData
// 0x0060 (0x0060 - 0x0000)
struct FGzCohtmlJobData final
{
public:
	class FText                                   DisplayName;                                       // 0x0000(0x0010)(NativeAccessSpecifierPublic)
	class FText                                   Description;                                       // 0x0010(0x0010)(NativeAccessSpecifierPublic)
	struct FGzCohtmlJobArchetype                  Archetype;                                         // 0x0020(0x0020)(NativeAccessSpecifierPublic)
	class FText                                   Handler;                                           // 0x0040(0x0010)(NativeAccessSpecifierPublic)
	TArray<class UGzRewardData*>                  Rewards;                                           // 0x0050(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzCohtmlJobData) == 0x000008, "Wrong alignment on FGzCohtmlJobData");
static_assert(sizeof(FGzCohtmlJobData) == 0x000060, "Wrong size on FGzCohtmlJobData");
static_assert(offsetof(FGzCohtmlJobData, DisplayName) == 0x000000, "Member 'FGzCohtmlJobData::DisplayName' has a wrong offset!");
static_assert(offsetof(FGzCohtmlJobData, Description) == 0x000010, "Member 'FGzCohtmlJobData::Description' has a wrong offset!");
static_assert(offsetof(FGzCohtmlJobData, Archetype) == 0x000020, "Member 'FGzCohtmlJobData::Archetype' has a wrong offset!");
static_assert(offsetof(FGzCohtmlJobData, Handler) == 0x000040, "Member 'FGzCohtmlJobData::Handler' has a wrong offset!");
static_assert(offsetof(FGzCohtmlJobData, Rewards) == 0x000050, "Member 'FGzCohtmlJobData::Rewards' has a wrong offset!");

// ScriptStruct G01.GzSaveStatisticsPackage
// 0x0030 (0x0098 - 0x0068)
struct FGzSaveStatisticsPackage final : public FGzPlayFabClientPackage
{
public:
	class FString                                 CharacterId;                                       // 0x0068(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGzMatchStatistics                     Statistics;                                        // 0x0078(0x001C)(NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_2B00[0x4];                                     // 0x0094(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGzSaveStatisticsPackage) == 0x000008, "Wrong alignment on FGzSaveStatisticsPackage");
static_assert(sizeof(FGzSaveStatisticsPackage) == 0x000098, "Wrong size on FGzSaveStatisticsPackage");
static_assert(offsetof(FGzSaveStatisticsPackage, CharacterId) == 0x000068, "Member 'FGzSaveStatisticsPackage::CharacterId' has a wrong offset!");
static_assert(offsetof(FGzSaveStatisticsPackage, Statistics) == 0x000078, "Member 'FGzSaveStatisticsPackage::Statistics' has a wrong offset!");

// ScriptStruct G01.GzCohtmlGoalData
// 0x0030 (0x0030 - 0x0000)
struct FGzCohtmlGoalData final
{
public:
	class FText                                   Name;                                              // 0x0000(0x0010)(NativeAccessSpecifierPublic)
	class FText                                   Description;                                       // 0x0010(0x0010)(NativeAccessSpecifierPublic)
	TArray<class UGzRewardData*>                  Rewards;                                           // 0x0020(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzCohtmlGoalData) == 0x000008, "Wrong alignment on FGzCohtmlGoalData");
static_assert(sizeof(FGzCohtmlGoalData) == 0x000030, "Wrong size on FGzCohtmlGoalData");
static_assert(offsetof(FGzCohtmlGoalData, Name) == 0x000000, "Member 'FGzCohtmlGoalData::Name' has a wrong offset!");
static_assert(offsetof(FGzCohtmlGoalData, Description) == 0x000010, "Member 'FGzCohtmlGoalData::Description' has a wrong offset!");
static_assert(offsetof(FGzCohtmlGoalData, Rewards) == 0x000020, "Member 'FGzCohtmlGoalData::Rewards' has a wrong offset!");

// ScriptStruct G01.GzCohtmlMarketplaceQuickBuyItemInfo
// 0x000C (0x000C - 0x0000)
struct FGzCohtmlMarketplaceQuickBuyItemInfo final
{
public:
	bool                                          bFound;                                            // 0x0000(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2B01[0x3];                                     // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         Count;                                             // 0x0004(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinPrice;                                          // 0x0008(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzCohtmlMarketplaceQuickBuyItemInfo) == 0x000004, "Wrong alignment on FGzCohtmlMarketplaceQuickBuyItemInfo");
static_assert(sizeof(FGzCohtmlMarketplaceQuickBuyItemInfo) == 0x00000C, "Wrong size on FGzCohtmlMarketplaceQuickBuyItemInfo");
static_assert(offsetof(FGzCohtmlMarketplaceQuickBuyItemInfo, bFound) == 0x000000, "Member 'FGzCohtmlMarketplaceQuickBuyItemInfo::bFound' has a wrong offset!");
static_assert(offsetof(FGzCohtmlMarketplaceQuickBuyItemInfo, Count) == 0x000004, "Member 'FGzCohtmlMarketplaceQuickBuyItemInfo::Count' has a wrong offset!");
static_assert(offsetof(FGzCohtmlMarketplaceQuickBuyItemInfo, MinPrice) == 0x000008, "Member 'FGzCohtmlMarketplaceQuickBuyItemInfo::MinPrice' has a wrong offset!");

// ScriptStruct G01.GzCohtmlAssignmentData
// 0x0040 (0x0040 - 0x0000)
struct FGzCohtmlAssignmentData final
{
public:
	class FText                                   Name;                                              // 0x0000(0x0010)(NativeAccessSpecifierPublic)
	class FText                                   Description;                                       // 0x0010(0x0010)(NativeAccessSpecifierPublic)
	class FText                                   Faction;                                           // 0x0020(0x0010)(NativeAccessSpecifierPublic)
	TArray<class UGzRewardData*>                  Rewards;                                           // 0x0030(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzCohtmlAssignmentData) == 0x000008, "Wrong alignment on FGzCohtmlAssignmentData");
static_assert(sizeof(FGzCohtmlAssignmentData) == 0x000040, "Wrong size on FGzCohtmlAssignmentData");
static_assert(offsetof(FGzCohtmlAssignmentData, Name) == 0x000000, "Member 'FGzCohtmlAssignmentData::Name' has a wrong offset!");
static_assert(offsetof(FGzCohtmlAssignmentData, Description) == 0x000010, "Member 'FGzCohtmlAssignmentData::Description' has a wrong offset!");
static_assert(offsetof(FGzCohtmlAssignmentData, Faction) == 0x000020, "Member 'FGzCohtmlAssignmentData::Faction' has a wrong offset!");
static_assert(offsetof(FGzCohtmlAssignmentData, Rewards) == 0x000030, "Member 'FGzCohtmlAssignmentData::Rewards' has a wrong offset!");

// ScriptStruct G01.GzCohtmlSettingValueScalar
// 0x0020 (0x0020 - 0x0000)
struct FGzCohtmlSettingValueScalar final
{
public:
	double                                        LowerBound;                                        // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	double                                        UpperBound;                                        // 0x0008(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	double                                        Step;                                              // 0x0010(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	double                                        CurrentValue;                                      // 0x0018(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzCohtmlSettingValueScalar) == 0x000008, "Wrong alignment on FGzCohtmlSettingValueScalar");
static_assert(sizeof(FGzCohtmlSettingValueScalar) == 0x000020, "Wrong size on FGzCohtmlSettingValueScalar");
static_assert(offsetof(FGzCohtmlSettingValueScalar, LowerBound) == 0x000000, "Member 'FGzCohtmlSettingValueScalar::LowerBound' has a wrong offset!");
static_assert(offsetof(FGzCohtmlSettingValueScalar, UpperBound) == 0x000008, "Member 'FGzCohtmlSettingValueScalar::UpperBound' has a wrong offset!");
static_assert(offsetof(FGzCohtmlSettingValueScalar, Step) == 0x000010, "Member 'FGzCohtmlSettingValueScalar::Step' has a wrong offset!");
static_assert(offsetof(FGzCohtmlSettingValueScalar, CurrentValue) == 0x000018, "Member 'FGzCohtmlSettingValueScalar::CurrentValue' has a wrong offset!");

// ScriptStruct G01.GzCohtmlSettingValueKeyboardInput
// 0x0050 (0x0050 - 0x0000)
struct FGzCohtmlSettingValueKeyboardInput final
{
public:
	TMap<class FString, class FString>            BoundInputs;                                       // 0x0000(0x0050)(NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzCohtmlSettingValueKeyboardInput) == 0x000008, "Wrong alignment on FGzCohtmlSettingValueKeyboardInput");
static_assert(sizeof(FGzCohtmlSettingValueKeyboardInput) == 0x000050, "Wrong size on FGzCohtmlSettingValueKeyboardInput");
static_assert(offsetof(FGzCohtmlSettingValueKeyboardInput, BoundInputs) == 0x000000, "Member 'FGzCohtmlSettingValueKeyboardInput::BoundInputs' has a wrong offset!");

// ScriptStruct G01.GzCohtmlSettingEditState
// 0x0030 (0x0030 - 0x0000)
struct FGzCohtmlSettingEditState final
{
public:
	bool                                          bIsVisible;                                        // 0x0000(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2B02[0x7];                                     // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FString>                         HiddenReasons;                                     // 0x0008(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          bIsEnabled;                                        // 0x0018(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2B03[0x7];                                     // 0x0019(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FText>                           DisabledReasons;                                   // 0x0020(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzCohtmlSettingEditState) == 0x000008, "Wrong alignment on FGzCohtmlSettingEditState");
static_assert(sizeof(FGzCohtmlSettingEditState) == 0x000030, "Wrong size on FGzCohtmlSettingEditState");
static_assert(offsetof(FGzCohtmlSettingEditState, bIsVisible) == 0x000000, "Member 'FGzCohtmlSettingEditState::bIsVisible' has a wrong offset!");
static_assert(offsetof(FGzCohtmlSettingEditState, HiddenReasons) == 0x000008, "Member 'FGzCohtmlSettingEditState::HiddenReasons' has a wrong offset!");
static_assert(offsetof(FGzCohtmlSettingEditState, bIsEnabled) == 0x000018, "Member 'FGzCohtmlSettingEditState::bIsEnabled' has a wrong offset!");
static_assert(offsetof(FGzCohtmlSettingEditState, DisabledReasons) == 0x000020, "Member 'FGzCohtmlSettingEditState::DisabledReasons' has a wrong offset!");

// ScriptStruct G01.GzCohtmlSetting
// 0x00F0 (0x00F0 - 0x0000)
struct FGzCohtmlSetting final
{
public:
	EGzCohtmlSettingType                          Type;                                              // 0x0000(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2B04[0x7];                                     // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 DevName;                                           // 0x0008(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   Description;                                       // 0x0018(0x0010)(NativeAccessSpecifierPublic)
	class FText                                   DisplayName;                                       // 0x0028(0x0010)(NativeAccessSpecifierPublic)
	struct FGzCohtmlSettingValueDiscrete          DiscreteValue;                                     // 0x0038(0x0018)(NativeAccessSpecifierPublic)
	struct FGzCohtmlSettingValueScalar            ScalarValue;                                       // 0x0050(0x0020)(NoDestructor, NativeAccessSpecifierPublic)
	struct FGzCohtmlSettingValueKeyboardInput     KeyboardInputValue;                                // 0x0070(0x0050)(NativeAccessSpecifierPublic)
	struct FGzCohtmlSettingEditState              EditState;                                         // 0x00C0(0x0030)(NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzCohtmlSetting) == 0x000008, "Wrong alignment on FGzCohtmlSetting");
static_assert(sizeof(FGzCohtmlSetting) == 0x0000F0, "Wrong size on FGzCohtmlSetting");
static_assert(offsetof(FGzCohtmlSetting, Type) == 0x000000, "Member 'FGzCohtmlSetting::Type' has a wrong offset!");
static_assert(offsetof(FGzCohtmlSetting, DevName) == 0x000008, "Member 'FGzCohtmlSetting::DevName' has a wrong offset!");
static_assert(offsetof(FGzCohtmlSetting, Description) == 0x000018, "Member 'FGzCohtmlSetting::Description' has a wrong offset!");
static_assert(offsetof(FGzCohtmlSetting, DisplayName) == 0x000028, "Member 'FGzCohtmlSetting::DisplayName' has a wrong offset!");
static_assert(offsetof(FGzCohtmlSetting, DiscreteValue) == 0x000038, "Member 'FGzCohtmlSetting::DiscreteValue' has a wrong offset!");
static_assert(offsetof(FGzCohtmlSetting, ScalarValue) == 0x000050, "Member 'FGzCohtmlSetting::ScalarValue' has a wrong offset!");
static_assert(offsetof(FGzCohtmlSetting, KeyboardInputValue) == 0x000070, "Member 'FGzCohtmlSetting::KeyboardInputValue' has a wrong offset!");
static_assert(offsetof(FGzCohtmlSetting, EditState) == 0x0000C0, "Member 'FGzCohtmlSetting::EditState' has a wrong offset!");

// ScriptStruct G01.GzCohtmlSettingCategory
// 0x0020 (0x0020 - 0x0000)
struct FGzCohtmlSettingCategory final
{
public:
	class FText                                   DisplayName;                                       // 0x0000(0x0010)(NativeAccessSpecifierPublic)
	TArray<struct FGzCohtmlSetting>               Settings;                                          // 0x0010(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzCohtmlSettingCategory) == 0x000008, "Wrong alignment on FGzCohtmlSettingCategory");
static_assert(sizeof(FGzCohtmlSettingCategory) == 0x000020, "Wrong size on FGzCohtmlSettingCategory");
static_assert(offsetof(FGzCohtmlSettingCategory, DisplayName) == 0x000000, "Member 'FGzCohtmlSettingCategory::DisplayName' has a wrong offset!");
static_assert(offsetof(FGzCohtmlSettingCategory, Settings) == 0x000010, "Member 'FGzCohtmlSettingCategory::Settings' has a wrong offset!");

// ScriptStruct G01.GzCohtmlAccountBenefits
// 0x0028 (0x0028 - 0x0000)
struct FGzCohtmlAccountBenefits final
{
public:
	class FText                                   AccountType;                                       // 0x0000(0x0010)(NativeAccessSpecifierPublic)
	int32                                         BenefitsInFirstRow;                                // 0x0010(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2B05[0x4];                                     // 0x0014(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FGzCohtmlBenefitTileInfo>       AccountBenefits;                                   // 0x0018(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzCohtmlAccountBenefits) == 0x000008, "Wrong alignment on FGzCohtmlAccountBenefits");
static_assert(sizeof(FGzCohtmlAccountBenefits) == 0x000028, "Wrong size on FGzCohtmlAccountBenefits");
static_assert(offsetof(FGzCohtmlAccountBenefits, AccountType) == 0x000000, "Member 'FGzCohtmlAccountBenefits::AccountType' has a wrong offset!");
static_assert(offsetof(FGzCohtmlAccountBenefits, BenefitsInFirstRow) == 0x000010, "Member 'FGzCohtmlAccountBenefits::BenefitsInFirstRow' has a wrong offset!");
static_assert(offsetof(FGzCohtmlAccountBenefits, AccountBenefits) == 0x000018, "Member 'FGzCohtmlAccountBenefits::AccountBenefits' has a wrong offset!");

// ScriptStruct G01.GzCohtmlAccountTypesBenefits
// 0x0050 (0x0050 - 0x0000)
struct FGzCohtmlAccountTypesBenefits final
{
public:
	TMap<class FString, struct FGzCohtmlAccountBenefits> AvailableSubscriptions;                            // 0x0000(0x0050)(NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzCohtmlAccountTypesBenefits) == 0x000008, "Wrong alignment on FGzCohtmlAccountTypesBenefits");
static_assert(sizeof(FGzCohtmlAccountTypesBenefits) == 0x000050, "Wrong size on FGzCohtmlAccountTypesBenefits");
static_assert(offsetof(FGzCohtmlAccountTypesBenefits, AvailableSubscriptions) == 0x000000, "Member 'FGzCohtmlAccountTypesBenefits::AvailableSubscriptions' has a wrong offset!");

// ScriptStruct G01.GzCohtmlAvailableAssignment
// 0x0010 (0x0028 - 0x0018)
struct FGzCohtmlAvailableAssignment final : public FGzCohtmlAvailableTask
{
public:
	TArray<struct FGzCohtmlAvailableGoal>         Goals;                                             // 0x0018(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzCohtmlAvailableAssignment) == 0x000008, "Wrong alignment on FGzCohtmlAvailableAssignment");
static_assert(sizeof(FGzCohtmlAvailableAssignment) == 0x000028, "Wrong size on FGzCohtmlAvailableAssignment");
static_assert(offsetof(FGzCohtmlAvailableAssignment, Goals) == 0x000018, "Member 'FGzCohtmlAvailableAssignment::Goals' has a wrong offset!");

// ScriptStruct G01.GzCohtmlServerOptionValue
// 0x0010 (0x0010 - 0x0000)
struct FGzCohtmlServerOptionValue final
{
public:
	TArray<class FString>                         Values;                                            // 0x0000(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzCohtmlServerOptionValue) == 0x000008, "Wrong alignment on FGzCohtmlServerOptionValue");
static_assert(sizeof(FGzCohtmlServerOptionValue) == 0x000010, "Wrong size on FGzCohtmlServerOptionValue");
static_assert(offsetof(FGzCohtmlServerOptionValue, Values) == 0x000000, "Member 'FGzCohtmlServerOptionValue::Values' has a wrong offset!");

// ScriptStruct G01.GzCohtmlBan
// 0x0040 (0x0040 - 0x0000)
struct FGzCohtmlBan final
{
public:
	class FString                                 Type;                                              // 0x0000(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Reason;                                            // 0x0010(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 CreatedAt;                                         // 0x0020(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 ExpiresAt;                                         // 0x0030(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzCohtmlBan) == 0x000008, "Wrong alignment on FGzCohtmlBan");
static_assert(sizeof(FGzCohtmlBan) == 0x000040, "Wrong size on FGzCohtmlBan");
static_assert(offsetof(FGzCohtmlBan, Type) == 0x000000, "Member 'FGzCohtmlBan::Type' has a wrong offset!");
static_assert(offsetof(FGzCohtmlBan, Reason) == 0x000010, "Member 'FGzCohtmlBan::Reason' has a wrong offset!");
static_assert(offsetof(FGzCohtmlBan, CreatedAt) == 0x000020, "Member 'FGzCohtmlBan::CreatedAt' has a wrong offset!");
static_assert(offsetof(FGzCohtmlBan, ExpiresAt) == 0x000030, "Member 'FGzCohtmlBan::ExpiresAt' has a wrong offset!");

// ScriptStruct G01.GzTransitionEventParameters
// 0x0004 (0x0004 - 0x0000)
struct FGzTransitionEventParameters final
{
public:
	float                                         TransitionDuration;                                // 0x0000(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzTransitionEventParameters) == 0x000004, "Wrong alignment on FGzTransitionEventParameters");
static_assert(sizeof(FGzTransitionEventParameters) == 0x000004, "Wrong size on FGzTransitionEventParameters");
static_assert(offsetof(FGzTransitionEventParameters, TransitionDuration) == 0x000000, "Member 'FGzTransitionEventParameters::TransitionDuration' has a wrong offset!");

// ScriptStruct G01.GzCohtmlBattlePassLevelProgressionV2
// 0x000C (0x000C - 0x0000)
struct FGzCohtmlBattlePassLevelProgressionV2 final
{
public:
	int32                                         Level;                                             // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Xp;                                                // 0x0004(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         XpToNextLevel;                                     // 0x0008(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzCohtmlBattlePassLevelProgressionV2) == 0x000004, "Wrong alignment on FGzCohtmlBattlePassLevelProgressionV2");
static_assert(sizeof(FGzCohtmlBattlePassLevelProgressionV2) == 0x00000C, "Wrong size on FGzCohtmlBattlePassLevelProgressionV2");
static_assert(offsetof(FGzCohtmlBattlePassLevelProgressionV2, Level) == 0x000000, "Member 'FGzCohtmlBattlePassLevelProgressionV2::Level' has a wrong offset!");
static_assert(offsetof(FGzCohtmlBattlePassLevelProgressionV2, Xp) == 0x000004, "Member 'FGzCohtmlBattlePassLevelProgressionV2::Xp' has a wrong offset!");
static_assert(offsetof(FGzCohtmlBattlePassLevelProgressionV2, XpToNextLevel) == 0x000008, "Member 'FGzCohtmlBattlePassLevelProgressionV2::XpToNextLevel' has a wrong offset!");

// ScriptStruct G01.GzCohtmlBattlePassNodeConnectionV2
// 0x0048 (0x0048 - 0x0000)
struct FGzCohtmlBattlePassNodeConnectionV2 final
{
public:
	struct FGzCohtmlString                        PointA;                                            // 0x0000(0x0020)(NativeAccessSpecifierPublic)
	struct FGzCohtmlString                        PointB;                                            // 0x0020(0x0020)(NativeAccessSpecifierPublic)
	bool                                          State;                                             // 0x0040(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2B06[0x7];                                     // 0x0041(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGzCohtmlBattlePassNodeConnectionV2) == 0x000008, "Wrong alignment on FGzCohtmlBattlePassNodeConnectionV2");
static_assert(sizeof(FGzCohtmlBattlePassNodeConnectionV2) == 0x000048, "Wrong size on FGzCohtmlBattlePassNodeConnectionV2");
static_assert(offsetof(FGzCohtmlBattlePassNodeConnectionV2, PointA) == 0x000000, "Member 'FGzCohtmlBattlePassNodeConnectionV2::PointA' has a wrong offset!");
static_assert(offsetof(FGzCohtmlBattlePassNodeConnectionV2, PointB) == 0x000020, "Member 'FGzCohtmlBattlePassNodeConnectionV2::PointB' has a wrong offset!");
static_assert(offsetof(FGzCohtmlBattlePassNodeConnectionV2, State) == 0x000040, "Member 'FGzCohtmlBattlePassNodeConnectionV2::State' has a wrong offset!");

// ScriptStruct G01.GzCohtmlBattlePassPageExitV2
// 0x0038 (0x0038 - 0x0000)
struct FGzCohtmlBattlePassPageExitV2 final
{
public:
	struct FGzCohtmlString                        From;                                              // 0x0000(0x0020)(NativeAccessSpecifierPublic)
	TArray<struct FGzCohtmlString>                To;                                                // 0x0020(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          State;                                             // 0x0030(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2B07[0x7];                                     // 0x0031(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGzCohtmlBattlePassPageExitV2) == 0x000008, "Wrong alignment on FGzCohtmlBattlePassPageExitV2");
static_assert(sizeof(FGzCohtmlBattlePassPageExitV2) == 0x000038, "Wrong size on FGzCohtmlBattlePassPageExitV2");
static_assert(offsetof(FGzCohtmlBattlePassPageExitV2, From) == 0x000000, "Member 'FGzCohtmlBattlePassPageExitV2::From' has a wrong offset!");
static_assert(offsetof(FGzCohtmlBattlePassPageExitV2, To) == 0x000020, "Member 'FGzCohtmlBattlePassPageExitV2::To' has a wrong offset!");
static_assert(offsetof(FGzCohtmlBattlePassPageExitV2, State) == 0x000030, "Member 'FGzCohtmlBattlePassPageExitV2::State' has a wrong offset!");

// ScriptStruct G01.GzCohtmlBattlePassSlotCurrencyRewardV2
// 0x0020 (0x0020 - 0x0000)
struct FGzCohtmlBattlePassSlotCurrencyRewardV2 final
{
public:
	struct FGzCohtmlString                        CurrencyAssetId;                                   // 0x0000(0x0020)(NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzCohtmlBattlePassSlotCurrencyRewardV2) == 0x000008, "Wrong alignment on FGzCohtmlBattlePassSlotCurrencyRewardV2");
static_assert(sizeof(FGzCohtmlBattlePassSlotCurrencyRewardV2) == 0x000020, "Wrong size on FGzCohtmlBattlePassSlotCurrencyRewardV2");
static_assert(offsetof(FGzCohtmlBattlePassSlotCurrencyRewardV2, CurrencyAssetId) == 0x000000, "Member 'FGzCohtmlBattlePassSlotCurrencyRewardV2::CurrencyAssetId' has a wrong offset!");

// ScriptStruct G01.GzCohtmlBattlePassSlotRewardV2
// 0x0070 (0x0070 - 0x0000)
struct FGzCohtmlBattlePassSlotRewardV2 final
{
public:
	struct FGzCohtmlString                        ID;                                                // 0x0000(0x0020)(NativeAccessSpecifierPublic)
	EGzBattlePassSlotRewardTypeV2                 RewardType;                                        // 0x0020(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2B08[0x4];                                     // 0x0024(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGzCohtmlBattlePassSlotDirectHexRewardV2 DirectHexReward;                                   // 0x0028(0x0028)(NativeAccessSpecifierPublic)
	struct FGzCohtmlBattlePassSlotCurrencyRewardV2 CurrencyReward;                                    // 0x0050(0x0020)(NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzCohtmlBattlePassSlotRewardV2) == 0x000008, "Wrong alignment on FGzCohtmlBattlePassSlotRewardV2");
static_assert(sizeof(FGzCohtmlBattlePassSlotRewardV2) == 0x000070, "Wrong size on FGzCohtmlBattlePassSlotRewardV2");
static_assert(offsetof(FGzCohtmlBattlePassSlotRewardV2, ID) == 0x000000, "Member 'FGzCohtmlBattlePassSlotRewardV2::ID' has a wrong offset!");
static_assert(offsetof(FGzCohtmlBattlePassSlotRewardV2, RewardType) == 0x000020, "Member 'FGzCohtmlBattlePassSlotRewardV2::RewardType' has a wrong offset!");
static_assert(offsetof(FGzCohtmlBattlePassSlotRewardV2, DirectHexReward) == 0x000028, "Member 'FGzCohtmlBattlePassSlotRewardV2::DirectHexReward' has a wrong offset!");
static_assert(offsetof(FGzCohtmlBattlePassSlotRewardV2, CurrencyReward) == 0x000050, "Member 'FGzCohtmlBattlePassSlotRewardV2::CurrencyReward' has a wrong offset!");

// ScriptStruct G01.GzCohtmlBattlePassGridVectorV2
// 0x0008 (0x0008 - 0x0000)
struct FGzCohtmlBattlePassGridVectorV2 final
{
public:
	int32                                         X;                                                 // 0x0000(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Y;                                                 // 0x0004(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzCohtmlBattlePassGridVectorV2) == 0x000004, "Wrong alignment on FGzCohtmlBattlePassGridVectorV2");
static_assert(sizeof(FGzCohtmlBattlePassGridVectorV2) == 0x000008, "Wrong size on FGzCohtmlBattlePassGridVectorV2");
static_assert(offsetof(FGzCohtmlBattlePassGridVectorV2, X) == 0x000000, "Member 'FGzCohtmlBattlePassGridVectorV2::X' has a wrong offset!");
static_assert(offsetof(FGzCohtmlBattlePassGridVectorV2, Y) == 0x000004, "Member 'FGzCohtmlBattlePassGridVectorV2::Y' has a wrong offset!");

// ScriptStruct G01.GzCohtmlBattlePassSlotUiInfoV2
// 0x0010 (0x0010 - 0x0000)
struct FGzCohtmlBattlePassSlotUiInfoV2 final
{
public:
	struct FGzCohtmlBattlePassGridVectorV2        Position;                                          // 0x0000(0x0008)(NoDestructor, NativeAccessSpecifierPublic)
	struct FGzCohtmlBattlePassGridVectorV2        Size;                                              // 0x0008(0x0008)(NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzCohtmlBattlePassSlotUiInfoV2) == 0x000004, "Wrong alignment on FGzCohtmlBattlePassSlotUiInfoV2");
static_assert(sizeof(FGzCohtmlBattlePassSlotUiInfoV2) == 0x000010, "Wrong size on FGzCohtmlBattlePassSlotUiInfoV2");
static_assert(offsetof(FGzCohtmlBattlePassSlotUiInfoV2, Position) == 0x000000, "Member 'FGzCohtmlBattlePassSlotUiInfoV2::Position' has a wrong offset!");
static_assert(offsetof(FGzCohtmlBattlePassSlotUiInfoV2, Size) == 0x000008, "Member 'FGzCohtmlBattlePassSlotUiInfoV2::Size' has a wrong offset!");

// ScriptStruct G01.GzCohtmlBattlePassSlotV2
// 0x00B0 (0x00B0 - 0x0000)
struct FGzCohtmlBattlePassSlotV2 final
{
public:
	struct FGzCohtmlString                        ID;                                                // 0x0000(0x0020)(NativeAccessSpecifierPublic)
	struct FGzCohtmlBattlePassSlotRewardV2        Reward;                                            // 0x0020(0x0070)(NativeAccessSpecifierPublic)
	double                                        Price;                                             // 0x0090(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EGzBattlePassSlotStateV2                      State;                                             // 0x0098(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2B09[0x3];                                     // 0x0099(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGzCohtmlBattlePassSlotUiInfoV2        UiInfo;                                            // 0x009C(0x0010)(NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_2B0A[0x4];                                     // 0x00AC(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGzCohtmlBattlePassSlotV2) == 0x000008, "Wrong alignment on FGzCohtmlBattlePassSlotV2");
static_assert(sizeof(FGzCohtmlBattlePassSlotV2) == 0x0000B0, "Wrong size on FGzCohtmlBattlePassSlotV2");
static_assert(offsetof(FGzCohtmlBattlePassSlotV2, ID) == 0x000000, "Member 'FGzCohtmlBattlePassSlotV2::ID' has a wrong offset!");
static_assert(offsetof(FGzCohtmlBattlePassSlotV2, Reward) == 0x000020, "Member 'FGzCohtmlBattlePassSlotV2::Reward' has a wrong offset!");
static_assert(offsetof(FGzCohtmlBattlePassSlotV2, Price) == 0x000090, "Member 'FGzCohtmlBattlePassSlotV2::Price' has a wrong offset!");
static_assert(offsetof(FGzCohtmlBattlePassSlotV2, State) == 0x000098, "Member 'FGzCohtmlBattlePassSlotV2::State' has a wrong offset!");
static_assert(offsetof(FGzCohtmlBattlePassSlotV2, UiInfo) == 0x00009C, "Member 'FGzCohtmlBattlePassSlotV2::UiInfo' has a wrong offset!");

// ScriptStruct G01.GzCohtmlBattlePassPageV2
// 0x0098 (0x0098 - 0x0000)
struct FGzCohtmlBattlePassPageV2 final
{
public:
	struct FGzCohtmlString                        ID;                                                // 0x0000(0x0020)(NativeAccessSpecifierPublic)
	class FText                                   Name;                                              // 0x0020(0x0010)(NativeAccessSpecifierPublic)
	bool                                          IsAvailable;                                       // 0x0030(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2B0B[0x7];                                     // 0x0031(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FGzCohtmlBattlePassSlotV2>      Slots;                                             // 0x0038(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FGzCohtmlBattlePassPageLockReasonV2> LockReasons;                                       // 0x0048(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FGzCohtmlBattlePassPageEntranceV2> Entrances;                                         // 0x0058(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FGzCohtmlBattlePassPageExitV2>  Exits;                                             // 0x0068(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FGzCohtmlBattlePassNodeConnectionV2> Connections;                                       // 0x0078(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	class FString                                 PreviewBanner;                                     // 0x0088(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzCohtmlBattlePassPageV2) == 0x000008, "Wrong alignment on FGzCohtmlBattlePassPageV2");
static_assert(sizeof(FGzCohtmlBattlePassPageV2) == 0x000098, "Wrong size on FGzCohtmlBattlePassPageV2");
static_assert(offsetof(FGzCohtmlBattlePassPageV2, ID) == 0x000000, "Member 'FGzCohtmlBattlePassPageV2::ID' has a wrong offset!");
static_assert(offsetof(FGzCohtmlBattlePassPageV2, Name) == 0x000020, "Member 'FGzCohtmlBattlePassPageV2::Name' has a wrong offset!");
static_assert(offsetof(FGzCohtmlBattlePassPageV2, IsAvailable) == 0x000030, "Member 'FGzCohtmlBattlePassPageV2::IsAvailable' has a wrong offset!");
static_assert(offsetof(FGzCohtmlBattlePassPageV2, Slots) == 0x000038, "Member 'FGzCohtmlBattlePassPageV2::Slots' has a wrong offset!");
static_assert(offsetof(FGzCohtmlBattlePassPageV2, LockReasons) == 0x000048, "Member 'FGzCohtmlBattlePassPageV2::LockReasons' has a wrong offset!");
static_assert(offsetof(FGzCohtmlBattlePassPageV2, Entrances) == 0x000058, "Member 'FGzCohtmlBattlePassPageV2::Entrances' has a wrong offset!");
static_assert(offsetof(FGzCohtmlBattlePassPageV2, Exits) == 0x000068, "Member 'FGzCohtmlBattlePassPageV2::Exits' has a wrong offset!");
static_assert(offsetof(FGzCohtmlBattlePassPageV2, Connections) == 0x000078, "Member 'FGzCohtmlBattlePassPageV2::Connections' has a wrong offset!");
static_assert(offsetof(FGzCohtmlBattlePassPageV2, PreviewBanner) == 0x000088, "Member 'FGzCohtmlBattlePassPageV2::PreviewBanner' has a wrong offset!");

// ScriptStruct G01.GzCohtmlBattlePassPreviewInfo
// 0x0030 (0x0030 - 0x0000)
struct FGzCohtmlBattlePassPreviewInfo final
{
public:
	class FText                                   Summary;                                           // 0x0000(0x0010)(NativeAccessSpecifierPublic)
	class FString                                 Video;                                             // 0x0010(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 RewardsPreviewImage;                               // 0x0020(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzCohtmlBattlePassPreviewInfo) == 0x000008, "Wrong alignment on FGzCohtmlBattlePassPreviewInfo");
static_assert(sizeof(FGzCohtmlBattlePassPreviewInfo) == 0x000030, "Wrong size on FGzCohtmlBattlePassPreviewInfo");
static_assert(offsetof(FGzCohtmlBattlePassPreviewInfo, Summary) == 0x000000, "Member 'FGzCohtmlBattlePassPreviewInfo::Summary' has a wrong offset!");
static_assert(offsetof(FGzCohtmlBattlePassPreviewInfo, Video) == 0x000010, "Member 'FGzCohtmlBattlePassPreviewInfo::Video' has a wrong offset!");
static_assert(offsetof(FGzCohtmlBattlePassPreviewInfo, RewardsPreviewImage) == 0x000020, "Member 'FGzCohtmlBattlePassPreviewInfo::RewardsPreviewImage' has a wrong offset!");

// ScriptStruct G01.GzAttributePPConfig
// 0x0018 (0x0018 - 0x0000)
struct FGzAttributePPConfig final
{
public:
	EWaitAttributeChangeComparison                ComparisonType;                                    // 0x0000(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2B0C[0x3];                                     // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ComparisonValue;                                   // 0x0004(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UGzPostProcessFX*                       PostProcessFX;                                     // 0x0008(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, PersistentInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bPlayOnViewTargetChange;                           // 0x0010(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bThreshold;                                        // 0x0011(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2B0D[0x6];                                     // 0x0012(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGzAttributePPConfig) == 0x000008, "Wrong alignment on FGzAttributePPConfig");
static_assert(sizeof(FGzAttributePPConfig) == 0x000018, "Wrong size on FGzAttributePPConfig");
static_assert(offsetof(FGzAttributePPConfig, ComparisonType) == 0x000000, "Member 'FGzAttributePPConfig::ComparisonType' has a wrong offset!");
static_assert(offsetof(FGzAttributePPConfig, ComparisonValue) == 0x000004, "Member 'FGzAttributePPConfig::ComparisonValue' has a wrong offset!");
static_assert(offsetof(FGzAttributePPConfig, PostProcessFX) == 0x000008, "Member 'FGzAttributePPConfig::PostProcessFX' has a wrong offset!");
static_assert(offsetof(FGzAttributePPConfig, bPlayOnViewTargetChange) == 0x000010, "Member 'FGzAttributePPConfig::bPlayOnViewTargetChange' has a wrong offset!");
static_assert(offsetof(FGzAttributePPConfig, bThreshold) == 0x000011, "Member 'FGzAttributePPConfig::bThreshold' has a wrong offset!");

// ScriptStruct G01.GzAttributePostProcessConfigs
// 0x0020 (0x0020 - 0x0000)
struct FGzAttributePostProcessConfigs final
{
public:
	TArray<struct FGzAttributePPConfig>           AttributeFxConfigs;                                // 0x0000(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, ContainsInstancedReference, NativeAccessSpecifierPublic)
	TArray<TSubclassOf<class APawn>>              AllowedViewTargets;                                // 0x0010(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, UObjectWrapper, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzAttributePostProcessConfigs) == 0x000008, "Wrong alignment on FGzAttributePostProcessConfigs");
static_assert(sizeof(FGzAttributePostProcessConfigs) == 0x000020, "Wrong size on FGzAttributePostProcessConfigs");
static_assert(offsetof(FGzAttributePostProcessConfigs, AttributeFxConfigs) == 0x000000, "Member 'FGzAttributePostProcessConfigs::AttributeFxConfigs' has a wrong offset!");
static_assert(offsetof(FGzAttributePostProcessConfigs, AllowedViewTargets) == 0x000010, "Member 'FGzAttributePostProcessConfigs::AllowedViewTargets' has a wrong offset!");

// ScriptStruct G01.GzCohtmlStat
// 0x0028 (0x0028 - 0x0000)
struct FGzCohtmlStat final
{
public:
	struct FGzCohtmlString                        Name;                                              // 0x0000(0x0020)(NativeAccessSpecifierPublic)
	int32                                         Value;                                             // 0x0020(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2B0E[0x4];                                     // 0x0024(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGzCohtmlStat) == 0x000008, "Wrong alignment on FGzCohtmlStat");
static_assert(sizeof(FGzCohtmlStat) == 0x000028, "Wrong size on FGzCohtmlStat");
static_assert(offsetof(FGzCohtmlStat, Name) == 0x000000, "Member 'FGzCohtmlStat::Name' has a wrong offset!");
static_assert(offsetof(FGzCohtmlStat, Value) == 0x000020, "Member 'FGzCohtmlStat::Value' has a wrong offset!");

// ScriptStruct G01.GzCohtmlBattlePassThemeSectionV2
// 0x0040 (0x0040 - 0x0000)
struct FGzCohtmlBattlePassThemeSectionV2 final
{
public:
	struct FGzCohtmlString                        ID;                                                // 0x0000(0x0020)(NativeAccessSpecifierPublic)
	class FText                                   Name;                                              // 0x0020(0x0010)(NativeAccessSpecifierPublic)
	TArray<class FString>                         PageIds;                                           // 0x0030(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzCohtmlBattlePassThemeSectionV2) == 0x000008, "Wrong alignment on FGzCohtmlBattlePassThemeSectionV2");
static_assert(sizeof(FGzCohtmlBattlePassThemeSectionV2) == 0x000040, "Wrong size on FGzCohtmlBattlePassThemeSectionV2");
static_assert(offsetof(FGzCohtmlBattlePassThemeSectionV2, ID) == 0x000000, "Member 'FGzCohtmlBattlePassThemeSectionV2::ID' has a wrong offset!");
static_assert(offsetof(FGzCohtmlBattlePassThemeSectionV2, Name) == 0x000020, "Member 'FGzCohtmlBattlePassThemeSectionV2::Name' has a wrong offset!");
static_assert(offsetof(FGzCohtmlBattlePassThemeSectionV2, PageIds) == 0x000030, "Member 'FGzCohtmlBattlePassThemeSectionV2::PageIds' has a wrong offset!");

// ScriptStruct G01.GzCohtmlWeaponSkinItemData
// 0x0000 (0x0148 - 0x0148)
struct FGzCohtmlWeaponSkinItemData final : public FGzCohtmlItemData
{
};
static_assert(alignof(FGzCohtmlWeaponSkinItemData) == 0x000008, "Wrong alignment on FGzCohtmlWeaponSkinItemData");
static_assert(sizeof(FGzCohtmlWeaponSkinItemData) == 0x000148, "Wrong size on FGzCohtmlWeaponSkinItemData");

// ScriptStruct G01.GzWeaponModeAIData
// 0x0018 (0x0018 - 0x0000)
struct FGzWeaponModeAIData final
{
public:
	class UCurveFloat*                            DistanceProbabilityCurve;                          // 0x0000(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AttackTime;                                        // 0x0008(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AttackTimeDeviation;                               // 0x000C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DelayAttackTime;                                   // 0x0010(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DelayAttackTimeDeviation;                          // 0x0014(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzWeaponModeAIData) == 0x000008, "Wrong alignment on FGzWeaponModeAIData");
static_assert(sizeof(FGzWeaponModeAIData) == 0x000018, "Wrong size on FGzWeaponModeAIData");
static_assert(offsetof(FGzWeaponModeAIData, DistanceProbabilityCurve) == 0x000000, "Member 'FGzWeaponModeAIData::DistanceProbabilityCurve' has a wrong offset!");
static_assert(offsetof(FGzWeaponModeAIData, AttackTime) == 0x000008, "Member 'FGzWeaponModeAIData::AttackTime' has a wrong offset!");
static_assert(offsetof(FGzWeaponModeAIData, AttackTimeDeviation) == 0x00000C, "Member 'FGzWeaponModeAIData::AttackTimeDeviation' has a wrong offset!");
static_assert(offsetof(FGzWeaponModeAIData, DelayAttackTime) == 0x000010, "Member 'FGzWeaponModeAIData::DelayAttackTime' has a wrong offset!");
static_assert(offsetof(FGzWeaponModeAIData, DelayAttackTimeDeviation) == 0x000014, "Member 'FGzWeaponModeAIData::DelayAttackTimeDeviation' has a wrong offset!");

// ScriptStruct G01.GzCohtmlBodyPartFamily
// 0x0040 (0x0040 - 0x0000)
struct FGzCohtmlBodyPartFamily final
{
public:
	class FString                                 ID;                                                // 0x0000(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   DisplayName;                                       // 0x0010(0x0010)(NativeAccessSpecifierPublic)
	class FText                                   Description;                                       // 0x0020(0x0010)(NativeAccessSpecifierPublic)
	TArray<class FString>                         BodyPartIds;                                       // 0x0030(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzCohtmlBodyPartFamily) == 0x000008, "Wrong alignment on FGzCohtmlBodyPartFamily");
static_assert(sizeof(FGzCohtmlBodyPartFamily) == 0x000040, "Wrong size on FGzCohtmlBodyPartFamily");
static_assert(offsetof(FGzCohtmlBodyPartFamily, ID) == 0x000000, "Member 'FGzCohtmlBodyPartFamily::ID' has a wrong offset!");
static_assert(offsetof(FGzCohtmlBodyPartFamily, DisplayName) == 0x000010, "Member 'FGzCohtmlBodyPartFamily::DisplayName' has a wrong offset!");
static_assert(offsetof(FGzCohtmlBodyPartFamily, Description) == 0x000020, "Member 'FGzCohtmlBodyPartFamily::Description' has a wrong offset!");
static_assert(offsetof(FGzCohtmlBodyPartFamily, BodyPartIds) == 0x000030, "Member 'FGzCohtmlBodyPartFamily::BodyPartIds' has a wrong offset!");

// ScriptStruct G01.GzCohtmlBodyPartTypeFamilies
// 0x0050 (0x0050 - 0x0000)
struct FGzCohtmlBodyPartTypeFamilies final
{
public:
	TMap<class FString, struct FGzCohtmlBodyPartFamily> BodyPartFamilies;                                  // 0x0000(0x0050)(NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzCohtmlBodyPartTypeFamilies) == 0x000008, "Wrong alignment on FGzCohtmlBodyPartTypeFamilies");
static_assert(sizeof(FGzCohtmlBodyPartTypeFamilies) == 0x000050, "Wrong size on FGzCohtmlBodyPartTypeFamilies");
static_assert(offsetof(FGzCohtmlBodyPartTypeFamilies, BodyPartFamilies) == 0x000000, "Member 'FGzCohtmlBodyPartTypeFamilies::BodyPartFamilies' has a wrong offset!");

// ScriptStruct G01.GzCohtmlCheatManageItemsFilters
// 0x0030 (0x0030 - 0x0000)
struct FGzCohtmlCheatManageItemsFilters final
{
public:
	class FString                                 TypeFilter;                                        // 0x0000(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 RarityFilter;                                      // 0x0010(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 InventoryTypeFilter;                               // 0x0020(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzCohtmlCheatManageItemsFilters) == 0x000008, "Wrong alignment on FGzCohtmlCheatManageItemsFilters");
static_assert(sizeof(FGzCohtmlCheatManageItemsFilters) == 0x000030, "Wrong size on FGzCohtmlCheatManageItemsFilters");
static_assert(offsetof(FGzCohtmlCheatManageItemsFilters, TypeFilter) == 0x000000, "Member 'FGzCohtmlCheatManageItemsFilters::TypeFilter' has a wrong offset!");
static_assert(offsetof(FGzCohtmlCheatManageItemsFilters, RarityFilter) == 0x000010, "Member 'FGzCohtmlCheatManageItemsFilters::RarityFilter' has a wrong offset!");
static_assert(offsetof(FGzCohtmlCheatManageItemsFilters, InventoryTypeFilter) == 0x000020, "Member 'FGzCohtmlCheatManageItemsFilters::InventoryTypeFilter' has a wrong offset!");

// ScriptStruct G01.GzCohtmlContainerData
// 0x01B0 (0x01B0 - 0x0000)
struct FGzCohtmlContainerData final
{
public:
	struct FGzCohtmlContainerItemData             ContainerData;                                     // 0x0000(0x0178)(NativeAccessSpecifierPublic)
	bool                                          IsDecoding;                                        // 0x0178(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2B0F[0x7];                                     // 0x0179(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 InstanceItemId;                                    // 0x0180(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 NftItemId;                                         // 0x0190(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int64                                         CreatedAt;                                         // 0x01A0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsReviewed;                                        // 0x01A8(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2B10[0x7];                                     // 0x01A9(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGzCohtmlContainerData) == 0x000008, "Wrong alignment on FGzCohtmlContainerData");
static_assert(sizeof(FGzCohtmlContainerData) == 0x0001B0, "Wrong size on FGzCohtmlContainerData");
static_assert(offsetof(FGzCohtmlContainerData, ContainerData) == 0x000000, "Member 'FGzCohtmlContainerData::ContainerData' has a wrong offset!");
static_assert(offsetof(FGzCohtmlContainerData, IsDecoding) == 0x000178, "Member 'FGzCohtmlContainerData::IsDecoding' has a wrong offset!");
static_assert(offsetof(FGzCohtmlContainerData, InstanceItemId) == 0x000180, "Member 'FGzCohtmlContainerData::InstanceItemId' has a wrong offset!");
static_assert(offsetof(FGzCohtmlContainerData, NftItemId) == 0x000190, "Member 'FGzCohtmlContainerData::NftItemId' has a wrong offset!");
static_assert(offsetof(FGzCohtmlContainerData, CreatedAt) == 0x0001A0, "Member 'FGzCohtmlContainerData::CreatedAt' has a wrong offset!");
static_assert(offsetof(FGzCohtmlContainerData, IsReviewed) == 0x0001A8, "Member 'FGzCohtmlContainerData::IsReviewed' has a wrong offset!");

// ScriptStruct G01.GzSceneSetupBase
// 0x0008 (0x0008 - 0x0000)
struct alignas(0x08) FGzSceneSetupBase
{
public:
	uint8                                         Pad_2B11[0x8];                                     // 0x0000(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGzSceneSetupBase) == 0x000008, "Wrong alignment on FGzSceneSetupBase");
static_assert(sizeof(FGzSceneSetupBase) == 0x000008, "Wrong size on FGzSceneSetupBase");

// ScriptStruct G01.GzCustomizationViewerSetup
// 0x0050 (0x0060 - 0x0010)
struct FGzCustomizationViewerSetup final : public FGzDefaultViewerSetup
{
public:
	TMap<struct FGameplayTag, class AGzSceneViewpoint*> PerLogicalSlot;                                    // 0x0010(0x0050)(Edit, DisableEditOnTemplate, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzCustomizationViewerSetup) == 0x000008, "Wrong alignment on FGzCustomizationViewerSetup");
static_assert(sizeof(FGzCustomizationViewerSetup) == 0x000060, "Wrong size on FGzCustomizationViewerSetup");
static_assert(offsetof(FGzCustomizationViewerSetup, PerLogicalSlot) == 0x000010, "Member 'FGzCustomizationViewerSetup::PerLogicalSlot' has a wrong offset!");

// ScriptStruct G01.GzCustomizationViewerSceneSetup
// 0x0060 (0x0068 - 0x0008)
struct FGzCustomizationViewerSceneSetup final : public FGzSceneSetupBase
{
public:
	struct FGzCustomizationViewerSetup            Viewer;                                            // 0x0008(0x0060)(Edit, DisableEditOnTemplate, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzCustomizationViewerSceneSetup) == 0x000008, "Wrong alignment on FGzCustomizationViewerSceneSetup");
static_assert(sizeof(FGzCustomizationViewerSceneSetup) == 0x000068, "Wrong size on FGzCustomizationViewerSceneSetup");
static_assert(offsetof(FGzCustomizationViewerSceneSetup, Viewer) == 0x000008, "Member 'FGzCustomizationViewerSceneSetup::Viewer' has a wrong offset!");

// ScriptStruct G01.GzDecodePayment
// 0x0010 (0x0010 - 0x0000)
struct FGzDecodePayment final
{
public:
	EGzBlockchainCoinType                         Currency;                                          // 0x0000(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2B12[0x7];                                     // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	double                                        Price;                                             // 0x0008(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzDecodePayment) == 0x000008, "Wrong alignment on FGzDecodePayment");
static_assert(sizeof(FGzDecodePayment) == 0x000010, "Wrong size on FGzDecodePayment");
static_assert(offsetof(FGzDecodePayment, Currency) == 0x000000, "Member 'FGzDecodePayment::Currency' has a wrong offset!");
static_assert(offsetof(FGzDecodePayment, Price) == 0x000008, "Member 'FGzDecodePayment::Price' has a wrong offset!");

// ScriptStruct G01.GzWeaponAttachmentAnimGroup
// 0x0010 (0x0010 - 0x0000)
struct FGzWeaponAttachmentAnimGroup final
{
public:
	int32                                         LimbState;                                         // 0x0000(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2B13[0x4];                                     // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UAnimMontage*                           AttachmentMontage;                                 // 0x0008(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzWeaponAttachmentAnimGroup) == 0x000008, "Wrong alignment on FGzWeaponAttachmentAnimGroup");
static_assert(sizeof(FGzWeaponAttachmentAnimGroup) == 0x000010, "Wrong size on FGzWeaponAttachmentAnimGroup");
static_assert(offsetof(FGzWeaponAttachmentAnimGroup, LimbState) == 0x000000, "Member 'FGzWeaponAttachmentAnimGroup::LimbState' has a wrong offset!");
static_assert(offsetof(FGzWeaponAttachmentAnimGroup, AttachmentMontage) == 0x000008, "Member 'FGzWeaponAttachmentAnimGroup::AttachmentMontage' has a wrong offset!");

// ScriptStruct G01.GzCohtmlCrashSender
// 0x0001 (0x0001 - 0x0000)
struct FGzCohtmlCrashSender final
{
public:
	uint8                                         Pad_2B14[0x1];                                     // 0x0000(0x0001)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGzCohtmlCrashSender) == 0x000001, "Wrong alignment on FGzCohtmlCrashSender");
static_assert(sizeof(FGzCohtmlCrashSender) == 0x000001, "Wrong size on FGzCohtmlCrashSender");

// ScriptStruct G01.GzCohtmlCriticalMessageData
// 0x0080 (0x0080 - 0x0000)
struct FGzCohtmlCriticalMessageData final
{
public:
	class FText                                   Title;                                             // 0x0000(0x0010)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TArray<class FText>                           Description;                                       // 0x0010(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FGzCohtmlCriticalMessageActionConfig   DefaultActionConfig;                               // 0x0020(0x0010)(Edit, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	TMap<EGzPlatformType, struct FGzCohtmlCriticalMessageActionConfig> ActionPlatformConfigs;                             // 0x0030(0x0050)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzCohtmlCriticalMessageData) == 0x000008, "Wrong alignment on FGzCohtmlCriticalMessageData");
static_assert(sizeof(FGzCohtmlCriticalMessageData) == 0x000080, "Wrong size on FGzCohtmlCriticalMessageData");
static_assert(offsetof(FGzCohtmlCriticalMessageData, Title) == 0x000000, "Member 'FGzCohtmlCriticalMessageData::Title' has a wrong offset!");
static_assert(offsetof(FGzCohtmlCriticalMessageData, Description) == 0x000010, "Member 'FGzCohtmlCriticalMessageData::Description' has a wrong offset!");
static_assert(offsetof(FGzCohtmlCriticalMessageData, DefaultActionConfig) == 0x000020, "Member 'FGzCohtmlCriticalMessageData::DefaultActionConfig' has a wrong offset!");
static_assert(offsetof(FGzCohtmlCriticalMessageData, ActionPlatformConfigs) == 0x000030, "Member 'FGzCohtmlCriticalMessageData::ActionPlatformConfigs' has a wrong offset!");

// ScriptStruct G01.GzCohtmlCurrencyItemData
// 0x0010 (0x0158 - 0x0148)
struct FGzCohtmlCurrencyItemData final : public FGzCohtmlItemData
{
public:
	class FString                                 Amount;                                            // 0x0148(0x0010)(ZeroConstructor, Transient, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzCohtmlCurrencyItemData) == 0x000008, "Wrong alignment on FGzCohtmlCurrencyItemData");
static_assert(sizeof(FGzCohtmlCurrencyItemData) == 0x000158, "Wrong size on FGzCohtmlCurrencyItemData");
static_assert(offsetof(FGzCohtmlCurrencyItemData, Amount) == 0x000148, "Member 'FGzCohtmlCurrencyItemData::Amount' has a wrong offset!");

// ScriptStruct G01.GzCohtmlBlockingSlots
// 0x0010 (0x0010 - 0x0000)
struct FGzCohtmlBlockingSlots final
{
public:
	TArray<class FString>                         BlockingSlots;                                     // 0x0000(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzCohtmlBlockingSlots) == 0x000008, "Wrong alignment on FGzCohtmlBlockingSlots");
static_assert(sizeof(FGzCohtmlBlockingSlots) == 0x000010, "Wrong size on FGzCohtmlBlockingSlots");
static_assert(offsetof(FGzCohtmlBlockingSlots, BlockingSlots) == 0x000000, "Member 'FGzCohtmlBlockingSlots::BlockingSlots' has a wrong offset!");

// ScriptStruct G01.GzConsumableViewmakerSetup
// 0x0028 (0x0030 - 0x0008)
struct FGzConsumableViewmakerSetup final : public FGzDefaultItemViewmakerSetupBase
{
public:
	struct FGzViewemakerSetup                     Default;                                           // 0x0008(0x0028)(Edit, DisableEditOnTemplate, NativeAccessSpecifierPrivate)
};
static_assert(alignof(FGzConsumableViewmakerSetup) == 0x000008, "Wrong alignment on FGzConsumableViewmakerSetup");
static_assert(sizeof(FGzConsumableViewmakerSetup) == 0x000030, "Wrong size on FGzConsumableViewmakerSetup");
static_assert(offsetof(FGzConsumableViewmakerSetup, Default) == 0x000008, "Member 'FGzConsumableViewmakerSetup::Default' has a wrong offset!");

// ScriptStruct G01.GzCohtmlCustomizationAppearanceSlot
// 0x0040 (0x0040 - 0x0000)
struct FGzCohtmlCustomizationAppearanceSlot final
{
public:
	class FString                                 ItemId;                                            // 0x0000(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 AssetId;                                           // 0x0010(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 PrimaryLogicalSlot;                                // 0x0020(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class FString>                         LogicalSlots;                                      // 0x0030(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzCohtmlCustomizationAppearanceSlot) == 0x000008, "Wrong alignment on FGzCohtmlCustomizationAppearanceSlot");
static_assert(sizeof(FGzCohtmlCustomizationAppearanceSlot) == 0x000040, "Wrong size on FGzCohtmlCustomizationAppearanceSlot");
static_assert(offsetof(FGzCohtmlCustomizationAppearanceSlot, ItemId) == 0x000000, "Member 'FGzCohtmlCustomizationAppearanceSlot::ItemId' has a wrong offset!");
static_assert(offsetof(FGzCohtmlCustomizationAppearanceSlot, AssetId) == 0x000010, "Member 'FGzCohtmlCustomizationAppearanceSlot::AssetId' has a wrong offset!");
static_assert(offsetof(FGzCohtmlCustomizationAppearanceSlot, PrimaryLogicalSlot) == 0x000020, "Member 'FGzCohtmlCustomizationAppearanceSlot::PrimaryLogicalSlot' has a wrong offset!");
static_assert(offsetof(FGzCohtmlCustomizationAppearanceSlot, LogicalSlots) == 0x000030, "Member 'FGzCohtmlCustomizationAppearanceSlot::LogicalSlots' has a wrong offset!");

// ScriptStruct G01.GzCohtmlCustomizationAppearancePreset
// 0x00C0 (0x00C0 - 0x0000)
struct FGzCohtmlCustomizationAppearancePreset final
{
public:
	class FString                                 ID;                                                // 0x0000(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Name;                                              // 0x0010(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMap<class FString, struct FGzCohtmlCustomizationAppearanceSlot> Slots;                                             // 0x0020(0x0050)(NativeAccessSpecifierPublic)
	TMap<class FString, struct FGzCohtmlBlockingSlots> BlockedSlots;                                      // 0x0070(0x0050)(NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzCohtmlCustomizationAppearancePreset) == 0x000008, "Wrong alignment on FGzCohtmlCustomizationAppearancePreset");
static_assert(sizeof(FGzCohtmlCustomizationAppearancePreset) == 0x0000C0, "Wrong size on FGzCohtmlCustomizationAppearancePreset");
static_assert(offsetof(FGzCohtmlCustomizationAppearancePreset, ID) == 0x000000, "Member 'FGzCohtmlCustomizationAppearancePreset::ID' has a wrong offset!");
static_assert(offsetof(FGzCohtmlCustomizationAppearancePreset, Name) == 0x000010, "Member 'FGzCohtmlCustomizationAppearancePreset::Name' has a wrong offset!");
static_assert(offsetof(FGzCohtmlCustomizationAppearancePreset, Slots) == 0x000020, "Member 'FGzCohtmlCustomizationAppearancePreset::Slots' has a wrong offset!");
static_assert(offsetof(FGzCohtmlCustomizationAppearancePreset, BlockedSlots) == 0x000070, "Member 'FGzCohtmlCustomizationAppearancePreset::BlockedSlots' has a wrong offset!");

// ScriptStruct G01.GzResultOnlinePresence
// 0x0000 (0x00E0 - 0x00E0)
struct FGzResultOnlinePresence final : public FGzPlayFabResultBase
{
};
static_assert(alignof(FGzResultOnlinePresence) == 0x000008, "Wrong alignment on FGzResultOnlinePresence");
static_assert(sizeof(FGzResultOnlinePresence) == 0x0000E0, "Wrong size on FGzResultOnlinePresence");

// ScriptStruct G01.GzCurrencyEntry
// 0x0020 (0x0020 - 0x0000)
struct FGzCurrencyEntry final
{
public:
	class FName                                   Key;                                               // 0x0000(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SoftCurrencyValue;                                 // 0x0008(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2B15[0x4];                                     // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	double                                        HardCurrencyValue;                                 // 0x0010(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAlreadyGranted;                                   // 0x0018(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, RepSkip, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2B16[0x7];                                     // 0x0019(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGzCurrencyEntry) == 0x000008, "Wrong alignment on FGzCurrencyEntry");
static_assert(sizeof(FGzCurrencyEntry) == 0x000020, "Wrong size on FGzCurrencyEntry");
static_assert(offsetof(FGzCurrencyEntry, Key) == 0x000000, "Member 'FGzCurrencyEntry::Key' has a wrong offset!");
static_assert(offsetof(FGzCurrencyEntry, SoftCurrencyValue) == 0x000008, "Member 'FGzCurrencyEntry::SoftCurrencyValue' has a wrong offset!");
static_assert(offsetof(FGzCurrencyEntry, HardCurrencyValue) == 0x000010, "Member 'FGzCurrencyEntry::HardCurrencyValue' has a wrong offset!");
static_assert(offsetof(FGzCurrencyEntry, bAlreadyGranted) == 0x000018, "Member 'FGzCurrencyEntry::bAlreadyGranted' has a wrong offset!");

// ScriptStruct G01.GzCohtmlCustomizationAppearanceCollection
// 0x0060 (0x0060 - 0x0000)
struct FGzCohtmlCustomizationAppearanceCollection final
{
public:
	TMap<class FString, struct FGzCohtmlCustomizationAppearancePreset> Presets;                                           // 0x0000(0x0050)(NativeAccessSpecifierPublic)
	class FString                                 ActivePresetId;                                    // 0x0050(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzCohtmlCustomizationAppearanceCollection) == 0x000008, "Wrong alignment on FGzCohtmlCustomizationAppearanceCollection");
static_assert(sizeof(FGzCohtmlCustomizationAppearanceCollection) == 0x000060, "Wrong size on FGzCohtmlCustomizationAppearanceCollection");
static_assert(offsetof(FGzCohtmlCustomizationAppearanceCollection, Presets) == 0x000000, "Member 'FGzCohtmlCustomizationAppearanceCollection::Presets' has a wrong offset!");
static_assert(offsetof(FGzCohtmlCustomizationAppearanceCollection, ActivePresetId) == 0x000050, "Member 'FGzCohtmlCustomizationAppearanceCollection::ActivePresetId' has a wrong offset!");

// ScriptStruct G01.GzCohtmlCharacterCustomizationEmoteSlot
// 0x0020 (0x0020 - 0x0000)
struct FGzCohtmlCharacterCustomizationEmoteSlot final
{
public:
	class FString                                 ItemId;                                            // 0x0000(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 AssetId;                                           // 0x0010(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzCohtmlCharacterCustomizationEmoteSlot) == 0x000008, "Wrong alignment on FGzCohtmlCharacterCustomizationEmoteSlot");
static_assert(sizeof(FGzCohtmlCharacterCustomizationEmoteSlot) == 0x000020, "Wrong size on FGzCohtmlCharacterCustomizationEmoteSlot");
static_assert(offsetof(FGzCohtmlCharacterCustomizationEmoteSlot, ItemId) == 0x000000, "Member 'FGzCohtmlCharacterCustomizationEmoteSlot::ItemId' has a wrong offset!");
static_assert(offsetof(FGzCohtmlCharacterCustomizationEmoteSlot, AssetId) == 0x000010, "Member 'FGzCohtmlCharacterCustomizationEmoteSlot::AssetId' has a wrong offset!");

// ScriptStruct G01.GzDelayedSpawnParams
// 0x0038 (0x0038 - 0x0000)
struct FGzDelayedSpawnParams final
{
public:
	float                                         Delay;                                             // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2B17[0x4];                                     // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                Location;                                          // 0x0008(0x0018)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               Rotator;                                           // 0x0020(0x0018)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzDelayedSpawnParams) == 0x000008, "Wrong alignment on FGzDelayedSpawnParams");
static_assert(sizeof(FGzDelayedSpawnParams) == 0x000038, "Wrong size on FGzDelayedSpawnParams");
static_assert(offsetof(FGzDelayedSpawnParams, Delay) == 0x000000, "Member 'FGzDelayedSpawnParams::Delay' has a wrong offset!");
static_assert(offsetof(FGzDelayedSpawnParams, Location) == 0x000008, "Member 'FGzDelayedSpawnParams::Location' has a wrong offset!");
static_assert(offsetof(FGzDelayedSpawnParams, Rotator) == 0x000020, "Member 'FGzDelayedSpawnParams::Rotator' has a wrong offset!");

// ScriptStruct G01.GzCohtmlCustomizationEmoteCollection
// 0x0010 (0x0010 - 0x0000)
struct FGzCohtmlCustomizationEmoteCollection final
{
public:
	TArray<struct FGzCohtmlCharacterCustomizationEmoteSlot> Emotes;                                            // 0x0000(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzCohtmlCustomizationEmoteCollection) == 0x000008, "Wrong alignment on FGzCohtmlCustomizationEmoteCollection");
static_assert(sizeof(FGzCohtmlCustomizationEmoteCollection) == 0x000010, "Wrong size on FGzCohtmlCustomizationEmoteCollection");
static_assert(offsetof(FGzCohtmlCustomizationEmoteCollection, Emotes) == 0x000000, "Member 'FGzCohtmlCustomizationEmoteCollection::Emotes' has a wrong offset!");

// ScriptStruct G01.GzCohtmlCustomizationItemTemplate
// 0x0020 (0x0168 - 0x0148)
struct FGzCohtmlCustomizationItemTemplate final : public FGzCohtmlItemData
{
public:
	class FString                                 PrimaryLogicalSlot;                                // 0x0148(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class FString>                         LogicalSlots;                                      // 0x0158(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzCohtmlCustomizationItemTemplate) == 0x000008, "Wrong alignment on FGzCohtmlCustomizationItemTemplate");
static_assert(sizeof(FGzCohtmlCustomizationItemTemplate) == 0x000168, "Wrong size on FGzCohtmlCustomizationItemTemplate");
static_assert(offsetof(FGzCohtmlCustomizationItemTemplate, PrimaryLogicalSlot) == 0x000148, "Member 'FGzCohtmlCustomizationItemTemplate::PrimaryLogicalSlot' has a wrong offset!");
static_assert(offsetof(FGzCohtmlCustomizationItemTemplate, LogicalSlots) == 0x000158, "Member 'FGzCohtmlCustomizationItemTemplate::LogicalSlots' has a wrong offset!");

// ScriptStruct G01.GzCohtmlErrorNotificationContainer
// 0x0040 (0x0040 - 0x0000)
struct FGzCohtmlErrorNotificationContainer final
{
public:
	uint64                                        ID;                                                // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint32                                        Code;                                              // 0x0008(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2B18[0x4];                                     // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 EncodedError;                                      // 0x0010(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   Message;                                           // 0x0020(0x0010)(NativeAccessSpecifierPublic)
	class FString                                 OperationId;                                       // 0x0030(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzCohtmlErrorNotificationContainer) == 0x000008, "Wrong alignment on FGzCohtmlErrorNotificationContainer");
static_assert(sizeof(FGzCohtmlErrorNotificationContainer) == 0x000040, "Wrong size on FGzCohtmlErrorNotificationContainer");
static_assert(offsetof(FGzCohtmlErrorNotificationContainer, ID) == 0x000000, "Member 'FGzCohtmlErrorNotificationContainer::ID' has a wrong offset!");
static_assert(offsetof(FGzCohtmlErrorNotificationContainer, Code) == 0x000008, "Member 'FGzCohtmlErrorNotificationContainer::Code' has a wrong offset!");
static_assert(offsetof(FGzCohtmlErrorNotificationContainer, EncodedError) == 0x000010, "Member 'FGzCohtmlErrorNotificationContainer::EncodedError' has a wrong offset!");
static_assert(offsetof(FGzCohtmlErrorNotificationContainer, Message) == 0x000020, "Member 'FGzCohtmlErrorNotificationContainer::Message' has a wrong offset!");
static_assert(offsetof(FGzCohtmlErrorNotificationContainer, OperationId) == 0x000030, "Member 'FGzCohtmlErrorNotificationContainer::OperationId' has a wrong offset!");

// ScriptStruct G01.GzCohtmlFaction
// 0x0018 (0x0018 - 0x0000)
struct FGzCohtmlFaction final
{
public:
	class FName                                   Key;                                               // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   DisplayName;                                       // 0x0008(0x0010)(NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzCohtmlFaction) == 0x000008, "Wrong alignment on FGzCohtmlFaction");
static_assert(sizeof(FGzCohtmlFaction) == 0x000018, "Wrong size on FGzCohtmlFaction");
static_assert(offsetof(FGzCohtmlFaction, Key) == 0x000000, "Member 'FGzCohtmlFaction::Key' has a wrong offset!");
static_assert(offsetof(FGzCohtmlFaction, DisplayName) == 0x000008, "Member 'FGzCohtmlFaction::DisplayName' has a wrong offset!");

// ScriptStruct G01.GzCohtmlFriendOnlineInfo
// 0x0018 (0x0018 - 0x0000)
struct FGzCohtmlFriendOnlineInfo final
{
public:
	EGzCohtmlFriendOnlineStatus                   Status;                                            // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2B19[0x4];                                     // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 CustomStatus;                                      // 0x0008(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzCohtmlFriendOnlineInfo) == 0x000008, "Wrong alignment on FGzCohtmlFriendOnlineInfo");
static_assert(sizeof(FGzCohtmlFriendOnlineInfo) == 0x000018, "Wrong size on FGzCohtmlFriendOnlineInfo");
static_assert(offsetof(FGzCohtmlFriendOnlineInfo, Status) == 0x000000, "Member 'FGzCohtmlFriendOnlineInfo::Status' has a wrong offset!");
static_assert(offsetof(FGzCohtmlFriendOnlineInfo, CustomStatus) == 0x000008, "Member 'FGzCohtmlFriendOnlineInfo::CustomStatus' has a wrong offset!");

// ScriptStruct G01.GzTrackSpawnData
// 0x0030 (0x0030 - 0x0000)
struct FGzTrackSpawnData final
{
public:
	struct FVector                                Start;                                             // 0x0000(0x0018)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                End;                                               // 0x0018(0x0018)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzTrackSpawnData) == 0x000008, "Wrong alignment on FGzTrackSpawnData");
static_assert(sizeof(FGzTrackSpawnData) == 0x000030, "Wrong size on FGzTrackSpawnData");
static_assert(offsetof(FGzTrackSpawnData, Start) == 0x000000, "Member 'FGzTrackSpawnData::Start' has a wrong offset!");
static_assert(offsetof(FGzTrackSpawnData, End) == 0x000018, "Member 'FGzTrackSpawnData::End' has a wrong offset!");

// ScriptStruct G01.GzGetServerListResult
// 0x0010 (0x00F0 - 0x00E0)
struct FGzGetServerListResult final : public FGzPlayFabResultBase
{
public:
	TArray<struct FGzBackendServerDetails>        List;                                              // 0x00E0(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzGetServerListResult) == 0x000008, "Wrong alignment on FGzGetServerListResult");
static_assert(sizeof(FGzGetServerListResult) == 0x0000F0, "Wrong size on FGzGetServerListResult");
static_assert(offsetof(FGzGetServerListResult, List) == 0x0000E0, "Member 'FGzGetServerListResult::List' has a wrong offset!");

// ScriptStruct G01.GzCohtmlFriendUserInfo
// 0x0028 (0x0028 - 0x0000)
struct FGzCohtmlFriendUserInfo final
{
public:
	class FString                                 EpicAccountId;                                     // 0x0000(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 DisplayName;                                       // 0x0010(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   AvatarId;                                          // 0x0020(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzCohtmlFriendUserInfo) == 0x000008, "Wrong alignment on FGzCohtmlFriendUserInfo");
static_assert(sizeof(FGzCohtmlFriendUserInfo) == 0x000028, "Wrong size on FGzCohtmlFriendUserInfo");
static_assert(offsetof(FGzCohtmlFriendUserInfo, EpicAccountId) == 0x000000, "Member 'FGzCohtmlFriendUserInfo::EpicAccountId' has a wrong offset!");
static_assert(offsetof(FGzCohtmlFriendUserInfo, DisplayName) == 0x000010, "Member 'FGzCohtmlFriendUserInfo::DisplayName' has a wrong offset!");
static_assert(offsetof(FGzCohtmlFriendUserInfo, AvatarId) == 0x000020, "Member 'FGzCohtmlFriendUserInfo::AvatarId' has a wrong offset!");

// ScriptStruct G01.GzCohtmlFriendData
// 0x0040 (0x0040 - 0x0000)
struct FGzCohtmlFriendData final
{
public:
	struct FGzCohtmlFriendUserInfo                PlayerInfo;                                        // 0x0000(0x0028)(NativeAccessSpecifierPublic)
	struct FGzCohtmlFriendOnlineInfo              OnlineInfo;                                        // 0x0028(0x0018)(NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzCohtmlFriendData) == 0x000008, "Wrong alignment on FGzCohtmlFriendData");
static_assert(sizeof(FGzCohtmlFriendData) == 0x000040, "Wrong size on FGzCohtmlFriendData");
static_assert(offsetof(FGzCohtmlFriendData, PlayerInfo) == 0x000000, "Member 'FGzCohtmlFriendData::PlayerInfo' has a wrong offset!");
static_assert(offsetof(FGzCohtmlFriendData, OnlineInfo) == 0x000028, "Member 'FGzCohtmlFriendData::OnlineInfo' has a wrong offset!");

// ScriptStruct G01.GzRevealedActorInfo
// 0x0010 (0x0010 - 0x0000)
struct FGzRevealedActorInfo final
{
public:
	struct FGameplayTag                           RevealedTag;                                       // 0x0000(0x0008)(BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 Actor;                                             // 0x0008(0x0008)(BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzRevealedActorInfo) == 0x000008, "Wrong alignment on FGzRevealedActorInfo");
static_assert(sizeof(FGzRevealedActorInfo) == 0x000010, "Wrong size on FGzRevealedActorInfo");
static_assert(offsetof(FGzRevealedActorInfo, RevealedTag) == 0x000000, "Member 'FGzRevealedActorInfo::RevealedTag' has a wrong offset!");
static_assert(offsetof(FGzRevealedActorInfo, Actor) == 0x000008, "Member 'FGzRevealedActorInfo::Actor' has a wrong offset!");

// ScriptStruct G01.GzRevealeInfo
// 0x0018 (0x0018 - 0x0000)
struct FGzRevealeInfo final
{
public:
	class AActor*                                 SourceActor;                                       // 0x0000(0x0008)(BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGzRevealedActorInfo                   ActorInfo;                                         // 0x0008(0x0010)(BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzRevealeInfo) == 0x000008, "Wrong alignment on FGzRevealeInfo");
static_assert(sizeof(FGzRevealeInfo) == 0x000018, "Wrong size on FGzRevealeInfo");
static_assert(offsetof(FGzRevealeInfo, SourceActor) == 0x000000, "Member 'FGzRevealeInfo::SourceActor' has a wrong offset!");
static_assert(offsetof(FGzRevealeInfo, ActorInfo) == 0x000008, "Member 'FGzRevealeInfo::ActorInfo' has a wrong offset!");

// ScriptStruct G01.GzGameNotificationAudio
// 0x0028 (0x0028 - 0x0000)
struct FGzGameNotificationAudio final
{
public:
	bool                                          bNotificationStarted;                              // 0x0000(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2B1A[0x3];                                     // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTag                           AudioAnnouncerTag;                                 // 0x0004(0x0008)(Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           VoiceLineTag;                                      // 0x000C(0x0008)(Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2B1B[0x4];                                     // 0x0014(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UAkAudioEvent*                          MessageAudio;                                      // 0x0018(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAkAudioEvent*                          CancelMessageAudio;                                // 0x0020(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzGameNotificationAudio) == 0x000008, "Wrong alignment on FGzGameNotificationAudio");
static_assert(sizeof(FGzGameNotificationAudio) == 0x000028, "Wrong size on FGzGameNotificationAudio");
static_assert(offsetof(FGzGameNotificationAudio, bNotificationStarted) == 0x000000, "Member 'FGzGameNotificationAudio::bNotificationStarted' has a wrong offset!");
static_assert(offsetof(FGzGameNotificationAudio, AudioAnnouncerTag) == 0x000004, "Member 'FGzGameNotificationAudio::AudioAnnouncerTag' has a wrong offset!");
static_assert(offsetof(FGzGameNotificationAudio, VoiceLineTag) == 0x00000C, "Member 'FGzGameNotificationAudio::VoiceLineTag' has a wrong offset!");
static_assert(offsetof(FGzGameNotificationAudio, MessageAudio) == 0x000018, "Member 'FGzGameNotificationAudio::MessageAudio' has a wrong offset!");
static_assert(offsetof(FGzGameNotificationAudio, CancelMessageAudio) == 0x000020, "Member 'FGzGameNotificationAudio::CancelMessageAudio' has a wrong offset!");

// ScriptStruct G01.GzCohtmlLanguage
// 0x0020 (0x0020 - 0x0000)
struct FGzCohtmlLanguage final
{
public:
	class FString                                 ID;                                                // 0x0000(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Name;                                              // 0x0010(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzCohtmlLanguage) == 0x000008, "Wrong alignment on FGzCohtmlLanguage");
static_assert(sizeof(FGzCohtmlLanguage) == 0x000020, "Wrong size on FGzCohtmlLanguage");
static_assert(offsetof(FGzCohtmlLanguage, ID) == 0x000000, "Member 'FGzCohtmlLanguage::ID' has a wrong offset!");
static_assert(offsetof(FGzCohtmlLanguage, Name) == 0x000010, "Member 'FGzCohtmlLanguage::Name' has a wrong offset!");

// ScriptStruct G01.GzCohtmlLegalDocument
// 0x0020 (0x0020 - 0x0000)
struct FGzCohtmlLegalDocument final
{
public:
	class FText                                   Heading;                                           // 0x0000(0x0010)(NativeAccessSpecifierPublic)
	class FText                                   Content;                                           // 0x0010(0x0010)(NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzCohtmlLegalDocument) == 0x000008, "Wrong alignment on FGzCohtmlLegalDocument");
static_assert(sizeof(FGzCohtmlLegalDocument) == 0x000020, "Wrong size on FGzCohtmlLegalDocument");
static_assert(offsetof(FGzCohtmlLegalDocument, Heading) == 0x000000, "Member 'FGzCohtmlLegalDocument::Heading' has a wrong offset!");
static_assert(offsetof(FGzCohtmlLegalDocument, Content) == 0x000010, "Member 'FGzCohtmlLegalDocument::Content' has a wrong offset!");

// ScriptStruct G01.GzUpdateServerResult
// 0x0000 (0x00E0 - 0x00E0)
struct FGzUpdateServerResult final : public FGzPlayFabResultBase
{
};
static_assert(alignof(FGzUpdateServerResult) == 0x000008, "Wrong alignment on FGzUpdateServerResult");
static_assert(sizeof(FGzUpdateServerResult) == 0x0000E0, "Wrong size on FGzUpdateServerResult");

// ScriptStruct G01.GzCohtmlLiveFeatureMarketplaceConfig
// 0x0008 (0x0008 - 0x0000)
struct FGzCohtmlLiveFeatureMarketplaceConfig final
{
public:
	float                                         GeneralFeePercentage;                              // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         UnlockSellLevel;                                   // 0x0004(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzCohtmlLiveFeatureMarketplaceConfig) == 0x000004, "Wrong alignment on FGzCohtmlLiveFeatureMarketplaceConfig");
static_assert(sizeof(FGzCohtmlLiveFeatureMarketplaceConfig) == 0x000008, "Wrong size on FGzCohtmlLiveFeatureMarketplaceConfig");
static_assert(offsetof(FGzCohtmlLiveFeatureMarketplaceConfig, GeneralFeePercentage) == 0x000000, "Member 'FGzCohtmlLiveFeatureMarketplaceConfig::GeneralFeePercentage' has a wrong offset!");
static_assert(offsetof(FGzCohtmlLiveFeatureMarketplaceConfig, UnlockSellLevel) == 0x000004, "Member 'FGzCohtmlLiveFeatureMarketplaceConfig::UnlockSellLevel' has a wrong offset!");

// ScriptStruct G01.GzGameNotificationAnimation
// 0x000C (0x000C - 0x0000)
struct FGzGameNotificationAnimation final
{
public:
	bool                                          bEnableAnimation;                                  // 0x0000(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2B1C[0x3];                                     // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   AnimationID;                                       // 0x0004(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzGameNotificationAnimation) == 0x000004, "Wrong alignment on FGzGameNotificationAnimation");
static_assert(sizeof(FGzGameNotificationAnimation) == 0x00000C, "Wrong size on FGzGameNotificationAnimation");
static_assert(offsetof(FGzGameNotificationAnimation, bEnableAnimation) == 0x000000, "Member 'FGzGameNotificationAnimation::bEnableAnimation' has a wrong offset!");
static_assert(offsetof(FGzGameNotificationAnimation, AnimationID) == 0x000004, "Member 'FGzGameNotificationAnimation::AnimationID' has a wrong offset!");

// ScriptStruct G01.GzGameNotificationNarrative
// 0x0020 (0x0020 - 0x0000)
struct FGzGameNotificationNarrative final
{
public:
	class FText                                   MessageText;                                       // 0x0000(0x0010)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	TArray<class FText>                           HeaderTexts;                                       // 0x0010(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzGameNotificationNarrative) == 0x000008, "Wrong alignment on FGzGameNotificationNarrative");
static_assert(sizeof(FGzGameNotificationNarrative) == 0x000020, "Wrong size on FGzGameNotificationNarrative");
static_assert(offsetof(FGzGameNotificationNarrative, MessageText) == 0x000000, "Member 'FGzGameNotificationNarrative::MessageText' has a wrong offset!");
static_assert(offsetof(FGzGameNotificationNarrative, HeaderTexts) == 0x000010, "Member 'FGzGameNotificationNarrative::HeaderTexts' has a wrong offset!");

// ScriptStruct G01.GzGameNotificationSpec
// 0x00A0 (0x00A0 - 0x0000)
struct FGzGameNotificationSpec final
{
public:
	EGzGameNotificationType                       NotificationType;                                  // 0x0000(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EGzNotificationGroupType                      NotificationGroup;                                 // 0x0001(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2B1D[0x2];                                     // 0x0002(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ShowTime;                                          // 0x0004(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EGzNotificationTextType                       SpecialHeaderTextType;                             // 0x0008(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEnableMessageIcons;                               // 0x0009(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2B1E[0x6];                                     // 0x000A(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class UTexture2D*                             MessageIcon;                                       // 0x0010(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEnableBody;                                       // 0x0018(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EGzGameNotificationBodyType                   NotificationBodyType;                              // 0x0019(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2B1F[0x6];                                     // 0x001A(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class UTexture2D*                             BodyIcon;                                          // 0x0020(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           BodyIconColor;                                     // 0x0028(0x0010)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEnableRecolorToBodyColor;                         // 0x0038(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EGzNotificationBodyIconSizeType               BodyIconSizeType;                                  // 0x0039(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bPlayBodyAnimation;                                // 0x003A(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EGzNotificationTimerType                      RemainingType;                                     // 0x003B(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RemainingTime;                                     // 0x003C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGzGameNotificationNarrative           NarrativeSetting;                                  // 0x0040(0x0020)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	bool                                          bEnableAudio;                                      // 0x0060(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2B20[0x7];                                     // 0x0061(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGzGameNotificationAudio               AudioSettings;                                     // 0x0068(0x0028)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	struct FGzGameNotificationAnimation           AnimationSettings;                                 // 0x0090(0x000C)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_2B21[0x4];                                     // 0x009C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGzGameNotificationSpec) == 0x000008, "Wrong alignment on FGzGameNotificationSpec");
static_assert(sizeof(FGzGameNotificationSpec) == 0x0000A0, "Wrong size on FGzGameNotificationSpec");
static_assert(offsetof(FGzGameNotificationSpec, NotificationType) == 0x000000, "Member 'FGzGameNotificationSpec::NotificationType' has a wrong offset!");
static_assert(offsetof(FGzGameNotificationSpec, NotificationGroup) == 0x000001, "Member 'FGzGameNotificationSpec::NotificationGroup' has a wrong offset!");
static_assert(offsetof(FGzGameNotificationSpec, ShowTime) == 0x000004, "Member 'FGzGameNotificationSpec::ShowTime' has a wrong offset!");
static_assert(offsetof(FGzGameNotificationSpec, SpecialHeaderTextType) == 0x000008, "Member 'FGzGameNotificationSpec::SpecialHeaderTextType' has a wrong offset!");
static_assert(offsetof(FGzGameNotificationSpec, bEnableMessageIcons) == 0x000009, "Member 'FGzGameNotificationSpec::bEnableMessageIcons' has a wrong offset!");
static_assert(offsetof(FGzGameNotificationSpec, MessageIcon) == 0x000010, "Member 'FGzGameNotificationSpec::MessageIcon' has a wrong offset!");
static_assert(offsetof(FGzGameNotificationSpec, bEnableBody) == 0x000018, "Member 'FGzGameNotificationSpec::bEnableBody' has a wrong offset!");
static_assert(offsetof(FGzGameNotificationSpec, NotificationBodyType) == 0x000019, "Member 'FGzGameNotificationSpec::NotificationBodyType' has a wrong offset!");
static_assert(offsetof(FGzGameNotificationSpec, BodyIcon) == 0x000020, "Member 'FGzGameNotificationSpec::BodyIcon' has a wrong offset!");
static_assert(offsetof(FGzGameNotificationSpec, BodyIconColor) == 0x000028, "Member 'FGzGameNotificationSpec::BodyIconColor' has a wrong offset!");
static_assert(offsetof(FGzGameNotificationSpec, bEnableRecolorToBodyColor) == 0x000038, "Member 'FGzGameNotificationSpec::bEnableRecolorToBodyColor' has a wrong offset!");
static_assert(offsetof(FGzGameNotificationSpec, BodyIconSizeType) == 0x000039, "Member 'FGzGameNotificationSpec::BodyIconSizeType' has a wrong offset!");
static_assert(offsetof(FGzGameNotificationSpec, bPlayBodyAnimation) == 0x00003A, "Member 'FGzGameNotificationSpec::bPlayBodyAnimation' has a wrong offset!");
static_assert(offsetof(FGzGameNotificationSpec, RemainingType) == 0x00003B, "Member 'FGzGameNotificationSpec::RemainingType' has a wrong offset!");
static_assert(offsetof(FGzGameNotificationSpec, RemainingTime) == 0x00003C, "Member 'FGzGameNotificationSpec::RemainingTime' has a wrong offset!");
static_assert(offsetof(FGzGameNotificationSpec, NarrativeSetting) == 0x000040, "Member 'FGzGameNotificationSpec::NarrativeSetting' has a wrong offset!");
static_assert(offsetof(FGzGameNotificationSpec, bEnableAudio) == 0x000060, "Member 'FGzGameNotificationSpec::bEnableAudio' has a wrong offset!");
static_assert(offsetof(FGzGameNotificationSpec, AudioSettings) == 0x000068, "Member 'FGzGameNotificationSpec::AudioSettings' has a wrong offset!");
static_assert(offsetof(FGzGameNotificationSpec, AnimationSettings) == 0x000090, "Member 'FGzGameNotificationSpec::AnimationSettings' has a wrong offset!");

// ScriptStruct G01.GzGameNotificationDT
// 0x00F8 (0x0100 - 0x0008)
struct FGzGameNotificationDT final : public FTableRowBase
{
public:
	struct FGzGameNotificationAvailabilitySettings NotificationAvailabilitySettings;                  // 0x0008(0x0050)(Edit, BlueprintVisible, Protected, NativeAccessSpecifierProtected)
	int32                                         DisplayPrio;                                       // 0x0058(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bEnableNotificationSpec;                           // 0x005C(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2B22[0x3];                                     // 0x005D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGzGameNotificationSpec                NotificationSpec;                                  // 0x0060(0x00A0)(Edit, BlueprintVisible, Protected, NativeAccessSpecifierProtected)
};
static_assert(alignof(FGzGameNotificationDT) == 0x000008, "Wrong alignment on FGzGameNotificationDT");
static_assert(sizeof(FGzGameNotificationDT) == 0x000100, "Wrong size on FGzGameNotificationDT");
static_assert(offsetof(FGzGameNotificationDT, NotificationAvailabilitySettings) == 0x000008, "Member 'FGzGameNotificationDT::NotificationAvailabilitySettings' has a wrong offset!");
static_assert(offsetof(FGzGameNotificationDT, DisplayPrio) == 0x000058, "Member 'FGzGameNotificationDT::DisplayPrio' has a wrong offset!");
static_assert(offsetof(FGzGameNotificationDT, bEnableNotificationSpec) == 0x00005C, "Member 'FGzGameNotificationDT::bEnableNotificationSpec' has a wrong offset!");
static_assert(offsetof(FGzGameNotificationDT, NotificationSpec) == 0x000060, "Member 'FGzGameNotificationDT::NotificationSpec' has a wrong offset!");

// ScriptStruct G01.GzCohtmlLiveFeatureFraudPriceRangeFilter
// 0x0038 (0x0038 - 0x0000)
struct FGzCohtmlLiveFeatureFraudPriceRangeFilter final
{
public:
	class FString                                 ItemClass;                                         // 0x0000(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Rarity;                                            // 0x0010(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 AssetId;                                           // 0x0020(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsValid;                                           // 0x0030(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2B23[0x7];                                     // 0x0031(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGzCohtmlLiveFeatureFraudPriceRangeFilter) == 0x000008, "Wrong alignment on FGzCohtmlLiveFeatureFraudPriceRangeFilter");
static_assert(sizeof(FGzCohtmlLiveFeatureFraudPriceRangeFilter) == 0x000038, "Wrong size on FGzCohtmlLiveFeatureFraudPriceRangeFilter");
static_assert(offsetof(FGzCohtmlLiveFeatureFraudPriceRangeFilter, ItemClass) == 0x000000, "Member 'FGzCohtmlLiveFeatureFraudPriceRangeFilter::ItemClass' has a wrong offset!");
static_assert(offsetof(FGzCohtmlLiveFeatureFraudPriceRangeFilter, Rarity) == 0x000010, "Member 'FGzCohtmlLiveFeatureFraudPriceRangeFilter::Rarity' has a wrong offset!");
static_assert(offsetof(FGzCohtmlLiveFeatureFraudPriceRangeFilter, AssetId) == 0x000020, "Member 'FGzCohtmlLiveFeatureFraudPriceRangeFilter::AssetId' has a wrong offset!");
static_assert(offsetof(FGzCohtmlLiveFeatureFraudPriceRangeFilter, IsValid) == 0x000030, "Member 'FGzCohtmlLiveFeatureFraudPriceRangeFilter::IsValid' has a wrong offset!");

// ScriptStruct G01.GzStatEntry
// 0x0008 (0x0014 - 0x000C)
struct FGzStatEntry final : public FFastArraySerializerItem
{
public:
	uint8                                         PlayerId;                                          // 0x000C(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         StatId;                                            // 0x000D(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2B24[0x2];                                     // 0x000E(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Value;                                             // 0x0010(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzStatEntry) == 0x000004, "Wrong alignment on FGzStatEntry");
static_assert(sizeof(FGzStatEntry) == 0x000014, "Wrong size on FGzStatEntry");
static_assert(offsetof(FGzStatEntry, PlayerId) == 0x00000C, "Member 'FGzStatEntry::PlayerId' has a wrong offset!");
static_assert(offsetof(FGzStatEntry, StatId) == 0x00000D, "Member 'FGzStatEntry::StatId' has a wrong offset!");
static_assert(offsetof(FGzStatEntry, Value) == 0x000010, "Member 'FGzStatEntry::Value' has a wrong offset!");

// ScriptStruct G01.GzCohtmlLiveFeatureFraudPriceRange
// 0x0048 (0x0048 - 0x0000)
struct FGzCohtmlLiveFeatureFraudPriceRange final
{
public:
	struct FGzCohtmlLiveFeatureFraudPriceRangeFilter Filter;                                            // 0x0000(0x0038)(NativeAccessSpecifierPublic)
	uint32                                        Min;                                               // 0x0038(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint32                                        Max;                                               // 0x003C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsValid;                                           // 0x0040(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2B25[0x7];                                     // 0x0041(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGzCohtmlLiveFeatureFraudPriceRange) == 0x000008, "Wrong alignment on FGzCohtmlLiveFeatureFraudPriceRange");
static_assert(sizeof(FGzCohtmlLiveFeatureFraudPriceRange) == 0x000048, "Wrong size on FGzCohtmlLiveFeatureFraudPriceRange");
static_assert(offsetof(FGzCohtmlLiveFeatureFraudPriceRange, Filter) == 0x000000, "Member 'FGzCohtmlLiveFeatureFraudPriceRange::Filter' has a wrong offset!");
static_assert(offsetof(FGzCohtmlLiveFeatureFraudPriceRange, Min) == 0x000038, "Member 'FGzCohtmlLiveFeatureFraudPriceRange::Min' has a wrong offset!");
static_assert(offsetof(FGzCohtmlLiveFeatureFraudPriceRange, Max) == 0x00003C, "Member 'FGzCohtmlLiveFeatureFraudPriceRange::Max' has a wrong offset!");
static_assert(offsetof(FGzCohtmlLiveFeatureFraudPriceRange, IsValid) == 0x000040, "Member 'FGzCohtmlLiveFeatureFraudPriceRange::IsValid' has a wrong offset!");

// ScriptStruct G01.GzRuleSet
// 0x0040 (0x0040 - 0x0000)
struct FGzRuleSet final
{
public:
	struct FGameplayTagContainer                  EnabledRules;                                      // 0x0000(0x0020)(Edit, NativeAccessSpecifierPublic)
	struct FGameplayTagContainer                  DisabledRules;                                     // 0x0020(0x0020)(Edit, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzRuleSet) == 0x000008, "Wrong alignment on FGzRuleSet");
static_assert(sizeof(FGzRuleSet) == 0x000040, "Wrong size on FGzRuleSet");
static_assert(offsetof(FGzRuleSet, EnabledRules) == 0x000000, "Member 'FGzRuleSet::EnabledRules' has a wrong offset!");
static_assert(offsetof(FGzRuleSet, DisabledRules) == 0x000020, "Member 'FGzRuleSet::DisabledRules' has a wrong offset!");

// ScriptStruct G01.GzCohtmlLiveFeatureFraudPriceRangeValidation
// 0x0018 (0x0018 - 0x0000)
struct FGzCohtmlLiveFeatureFraudPriceRangeValidation final
{
public:
	bool                                          Enabled;                                           // 0x0000(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2B26[0x7];                                     // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FGzCohtmlLiveFeatureFraudPriceRange> PriceRanges;                                       // 0x0008(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzCohtmlLiveFeatureFraudPriceRangeValidation) == 0x000008, "Wrong alignment on FGzCohtmlLiveFeatureFraudPriceRangeValidation");
static_assert(sizeof(FGzCohtmlLiveFeatureFraudPriceRangeValidation) == 0x000018, "Wrong size on FGzCohtmlLiveFeatureFraudPriceRangeValidation");
static_assert(offsetof(FGzCohtmlLiveFeatureFraudPriceRangeValidation, Enabled) == 0x000000, "Member 'FGzCohtmlLiveFeatureFraudPriceRangeValidation::Enabled' has a wrong offset!");
static_assert(offsetof(FGzCohtmlLiveFeatureFraudPriceRangeValidation, PriceRanges) == 0x000008, "Member 'FGzCohtmlLiveFeatureFraudPriceRangeValidation::PriceRanges' has a wrong offset!");

// ScriptStruct G01.GzResultReportPlayerMarketplaceLot
// 0x0000 (0x00E0 - 0x00E0)
struct FGzResultReportPlayerMarketplaceLot final : public FGzPlayFabResultBase
{
};
static_assert(alignof(FGzResultReportPlayerMarketplaceLot) == 0x000008, "Wrong alignment on FGzResultReportPlayerMarketplaceLot");
static_assert(sizeof(FGzResultReportPlayerMarketplaceLot) == 0x0000E0, "Wrong size on FGzResultReportPlayerMarketplaceLot");

// ScriptStruct G01.GzLimbDamage
// 0x0048 (0x0048 - 0x0000)
struct FGzLimbDamage final
{
public:
	class FName                                   LimbName;                                          // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Timestamp;                                         // 0x0008(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Distance;                                          // 0x000C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Damage;                                            // 0x0010(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2B27[0x4];                                     // 0x0014(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector2D                              LocationFrom;                                      // 0x0018(0x0010)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              LocationTo;                                        // 0x0028(0x0010)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 InstigatorPlayFabId;                               // 0x0038(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzLimbDamage) == 0x000008, "Wrong alignment on FGzLimbDamage");
static_assert(sizeof(FGzLimbDamage) == 0x000048, "Wrong size on FGzLimbDamage");
static_assert(offsetof(FGzLimbDamage, LimbName) == 0x000000, "Member 'FGzLimbDamage::LimbName' has a wrong offset!");
static_assert(offsetof(FGzLimbDamage, Timestamp) == 0x000008, "Member 'FGzLimbDamage::Timestamp' has a wrong offset!");
static_assert(offsetof(FGzLimbDamage, Distance) == 0x00000C, "Member 'FGzLimbDamage::Distance' has a wrong offset!");
static_assert(offsetof(FGzLimbDamage, Damage) == 0x000010, "Member 'FGzLimbDamage::Damage' has a wrong offset!");
static_assert(offsetof(FGzLimbDamage, LocationFrom) == 0x000018, "Member 'FGzLimbDamage::LocationFrom' has a wrong offset!");
static_assert(offsetof(FGzLimbDamage, LocationTo) == 0x000028, "Member 'FGzLimbDamage::LocationTo' has a wrong offset!");
static_assert(offsetof(FGzLimbDamage, InstigatorPlayFabId) == 0x000038, "Member 'FGzLimbDamage::InstigatorPlayFabId' has a wrong offset!");

// ScriptStruct G01.GzCohtmlLiveFeatureFraudPlayerTradeRules
// 0x0028 (0x0028 - 0x0000)
struct FGzCohtmlLiveFeatureFraudPlayerTradeRules final
{
public:
	bool                                          Enabled;                                           // 0x0000(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2B28[0x3];                                     // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	uint32                                        TradesPerTimeRange;                                // 0x0004(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 TimeRangeHours;                                    // 0x0008(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 OverTheRateCooldown;                               // 0x0018(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzCohtmlLiveFeatureFraudPlayerTradeRules) == 0x000008, "Wrong alignment on FGzCohtmlLiveFeatureFraudPlayerTradeRules");
static_assert(sizeof(FGzCohtmlLiveFeatureFraudPlayerTradeRules) == 0x000028, "Wrong size on FGzCohtmlLiveFeatureFraudPlayerTradeRules");
static_assert(offsetof(FGzCohtmlLiveFeatureFraudPlayerTradeRules, Enabled) == 0x000000, "Member 'FGzCohtmlLiveFeatureFraudPlayerTradeRules::Enabled' has a wrong offset!");
static_assert(offsetof(FGzCohtmlLiveFeatureFraudPlayerTradeRules, TradesPerTimeRange) == 0x000004, "Member 'FGzCohtmlLiveFeatureFraudPlayerTradeRules::TradesPerTimeRange' has a wrong offset!");
static_assert(offsetof(FGzCohtmlLiveFeatureFraudPlayerTradeRules, TimeRangeHours) == 0x000008, "Member 'FGzCohtmlLiveFeatureFraudPlayerTradeRules::TimeRangeHours' has a wrong offset!");
static_assert(offsetof(FGzCohtmlLiveFeatureFraudPlayerTradeRules, OverTheRateCooldown) == 0x000018, "Member 'FGzCohtmlLiveFeatureFraudPlayerTradeRules::OverTheRateCooldown' has a wrong offset!");

// ScriptStruct G01.GzCohtmlLiveFeatureFraudPlayerTradeRateValidation
// 0x0050 (0x0050 - 0x0000)
struct FGzCohtmlLiveFeatureFraudPlayerTradeRateValidation final
{
public:
	struct FGzCohtmlLiveFeatureFraudPlayerTradeRules TradeRateForSelling;                               // 0x0000(0x0028)(NativeAccessSpecifierPublic)
	struct FGzCohtmlLiveFeatureFraudPlayerTradeRules TradeRateForBuying;                                // 0x0028(0x0028)(NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzCohtmlLiveFeatureFraudPlayerTradeRateValidation) == 0x000008, "Wrong alignment on FGzCohtmlLiveFeatureFraudPlayerTradeRateValidation");
static_assert(sizeof(FGzCohtmlLiveFeatureFraudPlayerTradeRateValidation) == 0x000050, "Wrong size on FGzCohtmlLiveFeatureFraudPlayerTradeRateValidation");
static_assert(offsetof(FGzCohtmlLiveFeatureFraudPlayerTradeRateValidation, TradeRateForSelling) == 0x000000, "Member 'FGzCohtmlLiveFeatureFraudPlayerTradeRateValidation::TradeRateForSelling' has a wrong offset!");
static_assert(offsetof(FGzCohtmlLiveFeatureFraudPlayerTradeRateValidation, TradeRateForBuying) == 0x000028, "Member 'FGzCohtmlLiveFeatureFraudPlayerTradeRateValidation::TradeRateForBuying' has a wrong offset!");

// ScriptStruct G01.GzHexExtractionSettings
// 0x0008 (0x0008 - 0x0000)
struct FGzHexExtractionSettings final
{
public:
	float                                         ExtractionTime;                                    // 0x0000(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ExtractionCost;                                    // 0x0004(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzHexExtractionSettings) == 0x000004, "Wrong alignment on FGzHexExtractionSettings");
static_assert(sizeof(FGzHexExtractionSettings) == 0x000008, "Wrong size on FGzHexExtractionSettings");
static_assert(offsetof(FGzHexExtractionSettings, ExtractionTime) == 0x000000, "Member 'FGzHexExtractionSettings::ExtractionTime' has a wrong offset!");
static_assert(offsetof(FGzHexExtractionSettings, ExtractionCost) == 0x000004, "Member 'FGzHexExtractionSettings::ExtractionCost' has a wrong offset!");

// ScriptStruct G01.GzResultSaveAchievementsProgress
// 0x0000 (0x00E0 - 0x00E0)
struct FGzResultSaveAchievementsProgress final : public FGzPlayFabResultBase
{
};
static_assert(alignof(FGzResultSaveAchievementsProgress) == 0x000008, "Wrong alignment on FGzResultSaveAchievementsProgress");
static_assert(sizeof(FGzResultSaveAchievementsProgress) == 0x0000E0, "Wrong size on FGzResultSaveAchievementsProgress");

// ScriptStruct G01.GzCohtmlLiveFeatureFraudPrevention
// 0x0088 (0x0088 - 0x0000)
struct FGzCohtmlLiveFeatureFraudPrevention final
{
public:
	bool                                          Enabled;                                           // 0x0000(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2B29[0x7];                                     // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGzCohtmlLiveFeatureFraudPriceRangeValidation PriceRangeValidation;                              // 0x0008(0x0018)(NativeAccessSpecifierPublic)
	struct FGzCohtmlLiveFeatureFraudItemTradeCooldownValidation ItemTradeCooldownValidation;                       // 0x0020(0x0018)(NativeAccessSpecifierPublic)
	struct FGzCohtmlLiveFeatureFraudPlayerTradeRateValidation PlayerTradeRateValidation;                         // 0x0038(0x0050)(NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzCohtmlLiveFeatureFraudPrevention) == 0x000008, "Wrong alignment on FGzCohtmlLiveFeatureFraudPrevention");
static_assert(sizeof(FGzCohtmlLiveFeatureFraudPrevention) == 0x000088, "Wrong size on FGzCohtmlLiveFeatureFraudPrevention");
static_assert(offsetof(FGzCohtmlLiveFeatureFraudPrevention, Enabled) == 0x000000, "Member 'FGzCohtmlLiveFeatureFraudPrevention::Enabled' has a wrong offset!");
static_assert(offsetof(FGzCohtmlLiveFeatureFraudPrevention, PriceRangeValidation) == 0x000008, "Member 'FGzCohtmlLiveFeatureFraudPrevention::PriceRangeValidation' has a wrong offset!");
static_assert(offsetof(FGzCohtmlLiveFeatureFraudPrevention, ItemTradeCooldownValidation) == 0x000020, "Member 'FGzCohtmlLiveFeatureFraudPrevention::ItemTradeCooldownValidation' has a wrong offset!");
static_assert(offsetof(FGzCohtmlLiveFeatureFraudPrevention, PlayerTradeRateValidation) == 0x000038, "Member 'FGzCohtmlLiveFeatureFraudPrevention::PlayerTradeRateValidation' has a wrong offset!");

// ScriptStruct G01.GzCohtmlLiveFeatures
// 0x00A8 (0x00A8 - 0x0000)
struct FGzCohtmlLiveFeatures final
{
public:
	bool                                          DisableMarketplace;                                // 0x0000(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          DisableBattlePass;                                 // 0x0001(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          DisableDecode;                                     // 0x0002(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          DisableUnityMatchmaking;                           // 0x0003(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          DisableCustomMatchmaking;                          // 0x0004(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          DisableMultiCharacter;                             // 0x0005(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          DisablePaymentProviders;                           // 0x0006(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          DisableLoadouts;                                   // 0x0007(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          DisableCharacterCustomization;                     // 0x0008(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          DisableJobs;                                       // 0x0009(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          CollectPostmatchFeedback;                          // 0x000A(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          DisableCompanionApp;                               // 0x000B(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGzCohtmlLiveFeatureMarketplaceConfig  FeesConfig;                                        // 0x000C(0x0008)(NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_2B2A[0x4];                                     // 0x0014(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGzCohtmlLiveFeatureFraudPrevention    FraudPreventionSettings;                           // 0x0018(0x0088)(NativeAccessSpecifierPublic)
	bool                                          IsUnityMatchmakingEnabled;                         // 0x00A0(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2B2B[0x7];                                     // 0x00A1(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGzCohtmlLiveFeatures) == 0x000008, "Wrong alignment on FGzCohtmlLiveFeatures");
static_assert(sizeof(FGzCohtmlLiveFeatures) == 0x0000A8, "Wrong size on FGzCohtmlLiveFeatures");
static_assert(offsetof(FGzCohtmlLiveFeatures, DisableMarketplace) == 0x000000, "Member 'FGzCohtmlLiveFeatures::DisableMarketplace' has a wrong offset!");
static_assert(offsetof(FGzCohtmlLiveFeatures, DisableBattlePass) == 0x000001, "Member 'FGzCohtmlLiveFeatures::DisableBattlePass' has a wrong offset!");
static_assert(offsetof(FGzCohtmlLiveFeatures, DisableDecode) == 0x000002, "Member 'FGzCohtmlLiveFeatures::DisableDecode' has a wrong offset!");
static_assert(offsetof(FGzCohtmlLiveFeatures, DisableUnityMatchmaking) == 0x000003, "Member 'FGzCohtmlLiveFeatures::DisableUnityMatchmaking' has a wrong offset!");
static_assert(offsetof(FGzCohtmlLiveFeatures, DisableCustomMatchmaking) == 0x000004, "Member 'FGzCohtmlLiveFeatures::DisableCustomMatchmaking' has a wrong offset!");
static_assert(offsetof(FGzCohtmlLiveFeatures, DisableMultiCharacter) == 0x000005, "Member 'FGzCohtmlLiveFeatures::DisableMultiCharacter' has a wrong offset!");
static_assert(offsetof(FGzCohtmlLiveFeatures, DisablePaymentProviders) == 0x000006, "Member 'FGzCohtmlLiveFeatures::DisablePaymentProviders' has a wrong offset!");
static_assert(offsetof(FGzCohtmlLiveFeatures, DisableLoadouts) == 0x000007, "Member 'FGzCohtmlLiveFeatures::DisableLoadouts' has a wrong offset!");
static_assert(offsetof(FGzCohtmlLiveFeatures, DisableCharacterCustomization) == 0x000008, "Member 'FGzCohtmlLiveFeatures::DisableCharacterCustomization' has a wrong offset!");
static_assert(offsetof(FGzCohtmlLiveFeatures, DisableJobs) == 0x000009, "Member 'FGzCohtmlLiveFeatures::DisableJobs' has a wrong offset!");
static_assert(offsetof(FGzCohtmlLiveFeatures, CollectPostmatchFeedback) == 0x00000A, "Member 'FGzCohtmlLiveFeatures::CollectPostmatchFeedback' has a wrong offset!");
static_assert(offsetof(FGzCohtmlLiveFeatures, DisableCompanionApp) == 0x00000B, "Member 'FGzCohtmlLiveFeatures::DisableCompanionApp' has a wrong offset!");
static_assert(offsetof(FGzCohtmlLiveFeatures, FeesConfig) == 0x00000C, "Member 'FGzCohtmlLiveFeatures::FeesConfig' has a wrong offset!");
static_assert(offsetof(FGzCohtmlLiveFeatures, FraudPreventionSettings) == 0x000018, "Member 'FGzCohtmlLiveFeatures::FraudPreventionSettings' has a wrong offset!");
static_assert(offsetof(FGzCohtmlLiveFeatures, IsUnityMatchmakingEnabled) == 0x0000A0, "Member 'FGzCohtmlLiveFeatures::IsUnityMatchmakingEnabled' has a wrong offset!");

// ScriptStruct G01.GzDamageMarkInfo
// 0x0020 (0x0020 - 0x0000)
struct FGzDamageMarkInfo final
{
public:
	struct FGameplayTag                           DamageSource;                                      // 0x0000(0x0008)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UObject*                                DamageSourceObject;                                // 0x0008(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsCrit;                                           // 0x0010(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2B2C[0x7];                                     // 0x0011(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	double                                        ApplicationTime;                                   // 0x0018(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzDamageMarkInfo) == 0x000008, "Wrong alignment on FGzDamageMarkInfo");
static_assert(sizeof(FGzDamageMarkInfo) == 0x000020, "Wrong size on FGzDamageMarkInfo");
static_assert(offsetof(FGzDamageMarkInfo, DamageSource) == 0x000000, "Member 'FGzDamageMarkInfo::DamageSource' has a wrong offset!");
static_assert(offsetof(FGzDamageMarkInfo, DamageSourceObject) == 0x000008, "Member 'FGzDamageMarkInfo::DamageSourceObject' has a wrong offset!");
static_assert(offsetof(FGzDamageMarkInfo, bIsCrit) == 0x000010, "Member 'FGzDamageMarkInfo::bIsCrit' has a wrong offset!");
static_assert(offsetof(FGzDamageMarkInfo, ApplicationTime) == 0x000018, "Member 'FGzDamageMarkInfo::ApplicationTime' has a wrong offset!");

// ScriptStruct G01.GzContentPackPreviewInfo
// 0x00D0 (0x00D0 - 0x0000)
struct FGzContentPackPreviewInfo final
{
public:
	class FText                                   Summary;                                           // 0x0000(0x0010)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TArray<class UGzContainerItemData*>           RewardItems;                                       // 0x0010(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UTexture2D>              BackgroundImage;                                   // 0x0020(0x0028)(Edit, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGzCohtmlVideo                         AnimationVideo;                                    // 0x0048(0x0010)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UTexture2D>              ItemsImage;                                        // 0x0058(0x0028)(Edit, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UTexture2D>              PackPreviewImage;                                  // 0x0080(0x0028)(Edit, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UTexture2D>              PackPreviewSecondaryImage;                         // 0x00A8(0x0028)(Edit, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzContentPackPreviewInfo) == 0x000008, "Wrong alignment on FGzContentPackPreviewInfo");
static_assert(sizeof(FGzContentPackPreviewInfo) == 0x0000D0, "Wrong size on FGzContentPackPreviewInfo");
static_assert(offsetof(FGzContentPackPreviewInfo, Summary) == 0x000000, "Member 'FGzContentPackPreviewInfo::Summary' has a wrong offset!");
static_assert(offsetof(FGzContentPackPreviewInfo, RewardItems) == 0x000010, "Member 'FGzContentPackPreviewInfo::RewardItems' has a wrong offset!");
static_assert(offsetof(FGzContentPackPreviewInfo, BackgroundImage) == 0x000020, "Member 'FGzContentPackPreviewInfo::BackgroundImage' has a wrong offset!");
static_assert(offsetof(FGzContentPackPreviewInfo, AnimationVideo) == 0x000048, "Member 'FGzContentPackPreviewInfo::AnimationVideo' has a wrong offset!");
static_assert(offsetof(FGzContentPackPreviewInfo, ItemsImage) == 0x000058, "Member 'FGzContentPackPreviewInfo::ItemsImage' has a wrong offset!");
static_assert(offsetof(FGzContentPackPreviewInfo, PackPreviewImage) == 0x000080, "Member 'FGzContentPackPreviewInfo::PackPreviewImage' has a wrong offset!");
static_assert(offsetof(FGzContentPackPreviewInfo, PackPreviewSecondaryImage) == 0x0000A8, "Member 'FGzContentPackPreviewInfo::PackPreviewSecondaryImage' has a wrong offset!");

// ScriptStruct G01.GzDecodePackage
// 0x0010 (0x0078 - 0x0068)
struct FGzDecodePackage final : public FGzPlayFabClientPackage
{
public:
	class FString                                 DatacubeInstanceId;                                // 0x0068(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzDecodePackage) == 0x000008, "Wrong alignment on FGzDecodePackage");
static_assert(sizeof(FGzDecodePackage) == 0x000078, "Wrong size on FGzDecodePackage");
static_assert(offsetof(FGzDecodePackage, DatacubeInstanceId) == 0x000068, "Member 'FGzDecodePackage::DatacubeInstanceId' has a wrong offset!");

// ScriptStruct G01.GzCohtmlLoginQueueDetails
// 0x0018 (0x0018 - 0x0000)
struct FGzCohtmlLoginQueueDetails final
{
public:
	bool                                          IsInQueue;                                         // 0x0000(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2B2D[0x7];                                     // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	uint64                                        PlacementInQueue;                                  // 0x0008(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint32                                        EstimatedTimeRemainingSeconds;                     // 0x0010(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2B2E[0x4];                                     // 0x0014(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGzCohtmlLoginQueueDetails) == 0x000008, "Wrong alignment on FGzCohtmlLoginQueueDetails");
static_assert(sizeof(FGzCohtmlLoginQueueDetails) == 0x000018, "Wrong size on FGzCohtmlLoginQueueDetails");
static_assert(offsetof(FGzCohtmlLoginQueueDetails, IsInQueue) == 0x000000, "Member 'FGzCohtmlLoginQueueDetails::IsInQueue' has a wrong offset!");
static_assert(offsetof(FGzCohtmlLoginQueueDetails, PlacementInQueue) == 0x000008, "Member 'FGzCohtmlLoginQueueDetails::PlacementInQueue' has a wrong offset!");
static_assert(offsetof(FGzCohtmlLoginQueueDetails, EstimatedTimeRemainingSeconds) == 0x000010, "Member 'FGzCohtmlLoginQueueDetails::EstimatedTimeRemainingSeconds' has a wrong offset!");

// ScriptStruct G01.GzThrowableShieldMovementParameters
// 0x000C (0x000C - 0x0000)
struct FGzThrowableShieldMovementParameters final
{
public:
	float                                         InitialSpeed;                                      // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HomingAcceleration;                                // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxSpeed;                                          // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzThrowableShieldMovementParameters) == 0x000004, "Wrong alignment on FGzThrowableShieldMovementParameters");
static_assert(sizeof(FGzThrowableShieldMovementParameters) == 0x00000C, "Wrong size on FGzThrowableShieldMovementParameters");
static_assert(offsetof(FGzThrowableShieldMovementParameters, InitialSpeed) == 0x000000, "Member 'FGzThrowableShieldMovementParameters::InitialSpeed' has a wrong offset!");
static_assert(offsetof(FGzThrowableShieldMovementParameters, HomingAcceleration) == 0x000004, "Member 'FGzThrowableShieldMovementParameters::HomingAcceleration' has a wrong offset!");
static_assert(offsetof(FGzThrowableShieldMovementParameters, MaxSpeed) == 0x000008, "Member 'FGzThrowableShieldMovementParameters::MaxSpeed' has a wrong offset!");

// ScriptStruct G01.GzThrowableShieldLaunchParameters
// 0x0060 (0x0060 - 0x0000)
struct FGzThrowableShieldLaunchParameters final
{
public:
	struct FVector                                Location;                                          // 0x0000(0x0018)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               Rotation;                                          // 0x0018(0x0018)(ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FGzThrowableShieldMovementParameters   MovementParams;                                    // 0x0030(0x000C)(NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_2B2F[0x4];                                     // 0x003C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class AActor*                                 TargetActor;                                       // 0x0040(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         BounceCount;                                       // 0x0048(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGzThrowableShieldReturnParameters     ReturnParams;                                      // 0x004C(0x0010)(NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_2B30[0x4];                                     // 0x005C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGzThrowableShieldLaunchParameters) == 0x000008, "Wrong alignment on FGzThrowableShieldLaunchParameters");
static_assert(sizeof(FGzThrowableShieldLaunchParameters) == 0x000060, "Wrong size on FGzThrowableShieldLaunchParameters");
static_assert(offsetof(FGzThrowableShieldLaunchParameters, Location) == 0x000000, "Member 'FGzThrowableShieldLaunchParameters::Location' has a wrong offset!");
static_assert(offsetof(FGzThrowableShieldLaunchParameters, Rotation) == 0x000018, "Member 'FGzThrowableShieldLaunchParameters::Rotation' has a wrong offset!");
static_assert(offsetof(FGzThrowableShieldLaunchParameters, MovementParams) == 0x000030, "Member 'FGzThrowableShieldLaunchParameters::MovementParams' has a wrong offset!");
static_assert(offsetof(FGzThrowableShieldLaunchParameters, TargetActor) == 0x000040, "Member 'FGzThrowableShieldLaunchParameters::TargetActor' has a wrong offset!");
static_assert(offsetof(FGzThrowableShieldLaunchParameters, BounceCount) == 0x000048, "Member 'FGzThrowableShieldLaunchParameters::BounceCount' has a wrong offset!");
static_assert(offsetof(FGzThrowableShieldLaunchParameters, ReturnParams) == 0x00004C, "Member 'FGzThrowableShieldLaunchParameters::ReturnParams' has a wrong offset!");

// ScriptStruct G01.GzCohtmlMarketplacePagingInfo
// 0x0014 (0x0014 - 0x0000)
struct FGzCohtmlMarketplacePagingInfo final
{
public:
	int32                                         CurrentPage;                                       // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ItemsPerPage;                                      // 0x0004(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          HasNextPage;                                       // 0x0008(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2B31[0x3];                                     // 0x0009(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         TotalCount;                                        // 0x000C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         TotalPages;                                        // 0x0010(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzCohtmlMarketplacePagingInfo) == 0x000004, "Wrong alignment on FGzCohtmlMarketplacePagingInfo");
static_assert(sizeof(FGzCohtmlMarketplacePagingInfo) == 0x000014, "Wrong size on FGzCohtmlMarketplacePagingInfo");
static_assert(offsetof(FGzCohtmlMarketplacePagingInfo, CurrentPage) == 0x000000, "Member 'FGzCohtmlMarketplacePagingInfo::CurrentPage' has a wrong offset!");
static_assert(offsetof(FGzCohtmlMarketplacePagingInfo, ItemsPerPage) == 0x000004, "Member 'FGzCohtmlMarketplacePagingInfo::ItemsPerPage' has a wrong offset!");
static_assert(offsetof(FGzCohtmlMarketplacePagingInfo, HasNextPage) == 0x000008, "Member 'FGzCohtmlMarketplacePagingInfo::HasNextPage' has a wrong offset!");
static_assert(offsetof(FGzCohtmlMarketplacePagingInfo, TotalCount) == 0x00000C, "Member 'FGzCohtmlMarketplacePagingInfo::TotalCount' has a wrong offset!");
static_assert(offsetof(FGzCohtmlMarketplacePagingInfo, TotalPages) == 0x000010, "Member 'FGzCohtmlMarketplacePagingInfo::TotalPages' has a wrong offset!");

// ScriptStruct G01.GzUnblockPlayerResult
// 0x0000 (0x00E0 - 0x00E0)
struct FGzUnblockPlayerResult final : public FGzPlayFabResultBase
{
};
static_assert(alignof(FGzUnblockPlayerResult) == 0x000008, "Wrong alignment on FGzUnblockPlayerResult");
static_assert(sizeof(FGzUnblockPlayerResult) == 0x0000E0, "Wrong size on FGzUnblockPlayerResult");

// ScriptStruct G01.GzCohtmlMarketplaceItemOffer
// 0x00A0 (0x00A0 - 0x0000)
struct FGzCohtmlMarketplaceItemOffer final
{
public:
	class FString                                 ExpirationDateTime;                                // 0x0000(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	double                                        HardCurrencyPrice;                                 // 0x0010(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 OfferId;                                           // 0x0018(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   ItemAssetId;                                       // 0x0028(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 OwnerPlayFabId;                                    // 0x0030(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 OwnerTitleAccountId;                               // 0x0040(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 OwnerWalletId;                                     // 0x0050(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 OwnerDisplayName;                                  // 0x0060(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 OwnerAvatarUrl;                                    // 0x0070(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bOwnedByLocalPlayer;                               // 0x0080(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsAvailable;                                       // 0x0081(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2B32[0x6];                                     // 0x0082(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 ItemInstanceId;                                    // 0x0088(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int64                                         SerialNumber;                                      // 0x0098(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzCohtmlMarketplaceItemOffer) == 0x000008, "Wrong alignment on FGzCohtmlMarketplaceItemOffer");
static_assert(sizeof(FGzCohtmlMarketplaceItemOffer) == 0x0000A0, "Wrong size on FGzCohtmlMarketplaceItemOffer");
static_assert(offsetof(FGzCohtmlMarketplaceItemOffer, ExpirationDateTime) == 0x000000, "Member 'FGzCohtmlMarketplaceItemOffer::ExpirationDateTime' has a wrong offset!");
static_assert(offsetof(FGzCohtmlMarketplaceItemOffer, HardCurrencyPrice) == 0x000010, "Member 'FGzCohtmlMarketplaceItemOffer::HardCurrencyPrice' has a wrong offset!");
static_assert(offsetof(FGzCohtmlMarketplaceItemOffer, OfferId) == 0x000018, "Member 'FGzCohtmlMarketplaceItemOffer::OfferId' has a wrong offset!");
static_assert(offsetof(FGzCohtmlMarketplaceItemOffer, ItemAssetId) == 0x000028, "Member 'FGzCohtmlMarketplaceItemOffer::ItemAssetId' has a wrong offset!");
static_assert(offsetof(FGzCohtmlMarketplaceItemOffer, OwnerPlayFabId) == 0x000030, "Member 'FGzCohtmlMarketplaceItemOffer::OwnerPlayFabId' has a wrong offset!");
static_assert(offsetof(FGzCohtmlMarketplaceItemOffer, OwnerTitleAccountId) == 0x000040, "Member 'FGzCohtmlMarketplaceItemOffer::OwnerTitleAccountId' has a wrong offset!");
static_assert(offsetof(FGzCohtmlMarketplaceItemOffer, OwnerWalletId) == 0x000050, "Member 'FGzCohtmlMarketplaceItemOffer::OwnerWalletId' has a wrong offset!");
static_assert(offsetof(FGzCohtmlMarketplaceItemOffer, OwnerDisplayName) == 0x000060, "Member 'FGzCohtmlMarketplaceItemOffer::OwnerDisplayName' has a wrong offset!");
static_assert(offsetof(FGzCohtmlMarketplaceItemOffer, OwnerAvatarUrl) == 0x000070, "Member 'FGzCohtmlMarketplaceItemOffer::OwnerAvatarUrl' has a wrong offset!");
static_assert(offsetof(FGzCohtmlMarketplaceItemOffer, bOwnedByLocalPlayer) == 0x000080, "Member 'FGzCohtmlMarketplaceItemOffer::bOwnedByLocalPlayer' has a wrong offset!");
static_assert(offsetof(FGzCohtmlMarketplaceItemOffer, IsAvailable) == 0x000081, "Member 'FGzCohtmlMarketplaceItemOffer::IsAvailable' has a wrong offset!");
static_assert(offsetof(FGzCohtmlMarketplaceItemOffer, ItemInstanceId) == 0x000088, "Member 'FGzCohtmlMarketplaceItemOffer::ItemInstanceId' has a wrong offset!");
static_assert(offsetof(FGzCohtmlMarketplaceItemOffer, SerialNumber) == 0x000098, "Member 'FGzCohtmlMarketplaceItemOffer::SerialNumber' has a wrong offset!");

// ScriptStruct G01.GzCohtmlListedMarket
// 0x0028 (0x0028 - 0x0000)
struct FGzCohtmlListedMarket final
{
public:
	struct FGzCohtmlMarketplacePagingInfo         PagingInfo;                                        // 0x0000(0x0014)(NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_2B33[0x4];                                     // 0x0014(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FGzCohtmlMarketplaceItemOffer>  OffersList;                                        // 0x0018(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzCohtmlListedMarket) == 0x000008, "Wrong alignment on FGzCohtmlListedMarket");
static_assert(sizeof(FGzCohtmlListedMarket) == 0x000028, "Wrong size on FGzCohtmlListedMarket");
static_assert(offsetof(FGzCohtmlListedMarket, PagingInfo) == 0x000000, "Member 'FGzCohtmlListedMarket::PagingInfo' has a wrong offset!");
static_assert(offsetof(FGzCohtmlListedMarket, OffersList) == 0x000018, "Member 'FGzCohtmlListedMarket::OffersList' has a wrong offset!");

// ScriptStruct G01.GzResultCompleteChallenge
// 0x0000 (0x00E0 - 0x00E0)
struct FGzResultCompleteChallenge final : public FGzPlayFabResultBase
{
};
static_assert(alignof(FGzResultCompleteChallenge) == 0x000008, "Wrong alignment on FGzResultCompleteChallenge");
static_assert(sizeof(FGzResultCompleteChallenge) == 0x0000E0, "Wrong size on FGzResultCompleteChallenge");

// ScriptStruct G01.GzCohtmlMarketplaceItemSale
// 0x0018 (0x0018 - 0x0000)
struct FGzCohtmlMarketplaceItemSale final
{
public:
	float                                         Price;                                             // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2B34[0x4];                                     // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 TradeTime;                                         // 0x0008(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzCohtmlMarketplaceItemSale) == 0x000008, "Wrong alignment on FGzCohtmlMarketplaceItemSale");
static_assert(sizeof(FGzCohtmlMarketplaceItemSale) == 0x000018, "Wrong size on FGzCohtmlMarketplaceItemSale");
static_assert(offsetof(FGzCohtmlMarketplaceItemSale, Price) == 0x000000, "Member 'FGzCohtmlMarketplaceItemSale::Price' has a wrong offset!");
static_assert(offsetof(FGzCohtmlMarketplaceItemSale, TradeTime) == 0x000008, "Member 'FGzCohtmlMarketplaceItemSale::TradeTime' has a wrong offset!");

// ScriptStruct G01.GzContentPackCharacterPreviewWeaponSetup
// 0x0020 (0x0020 - 0x0000)
struct FGzContentPackCharacterPreviewWeaponSetup final
{
public:
	class UGzContainerItemData*                   Weapon;                                            // 0x0000(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UGzContainerItemData*                   Skin;                                              // 0x0008(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class UGzContainerItemData*>           Attachments;                                       // 0x0010(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzContentPackCharacterPreviewWeaponSetup) == 0x000008, "Wrong alignment on FGzContentPackCharacterPreviewWeaponSetup");
static_assert(sizeof(FGzContentPackCharacterPreviewWeaponSetup) == 0x000020, "Wrong size on FGzContentPackCharacterPreviewWeaponSetup");
static_assert(offsetof(FGzContentPackCharacterPreviewWeaponSetup, Weapon) == 0x000000, "Member 'FGzContentPackCharacterPreviewWeaponSetup::Weapon' has a wrong offset!");
static_assert(offsetof(FGzContentPackCharacterPreviewWeaponSetup, Skin) == 0x000008, "Member 'FGzContentPackCharacterPreviewWeaponSetup::Skin' has a wrong offset!");
static_assert(offsetof(FGzContentPackCharacterPreviewWeaponSetup, Attachments) == 0x000010, "Member 'FGzContentPackCharacterPreviewWeaponSetup::Attachments' has a wrong offset!");

// ScriptStruct G01.GzContentPackCharacterPreviewLoadoutSetup
// 0x0080 (0x0080 - 0x0000)
struct FGzContentPackCharacterPreviewLoadoutSetup final
{
public:
	struct FGzContentPackCharacterPreviewWeaponSetup PrimaryWeapon;                                     // 0x0000(0x0020)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FGzContentPackCharacterPreviewWeaponSetup SecondaryWeapon;                                   // 0x0020(0x0020)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FGzContentPackCharacterPreviewWeaponSetup Sidearm;                                           // 0x0040(0x0020)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	class UGzContainerItemData*                   LeftArm;                                           // 0x0060(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UGzContainerItemData*                   RightArm;                                          // 0x0068(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UGzContainerItemData*                   Legs;                                              // 0x0070(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UGzContainerItemData*                   Backpack;                                          // 0x0078(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzContentPackCharacterPreviewLoadoutSetup) == 0x000008, "Wrong alignment on FGzContentPackCharacterPreviewLoadoutSetup");
static_assert(sizeof(FGzContentPackCharacterPreviewLoadoutSetup) == 0x000080, "Wrong size on FGzContentPackCharacterPreviewLoadoutSetup");
static_assert(offsetof(FGzContentPackCharacterPreviewLoadoutSetup, PrimaryWeapon) == 0x000000, "Member 'FGzContentPackCharacterPreviewLoadoutSetup::PrimaryWeapon' has a wrong offset!");
static_assert(offsetof(FGzContentPackCharacterPreviewLoadoutSetup, SecondaryWeapon) == 0x000020, "Member 'FGzContentPackCharacterPreviewLoadoutSetup::SecondaryWeapon' has a wrong offset!");
static_assert(offsetof(FGzContentPackCharacterPreviewLoadoutSetup, Sidearm) == 0x000040, "Member 'FGzContentPackCharacterPreviewLoadoutSetup::Sidearm' has a wrong offset!");
static_assert(offsetof(FGzContentPackCharacterPreviewLoadoutSetup, LeftArm) == 0x000060, "Member 'FGzContentPackCharacterPreviewLoadoutSetup::LeftArm' has a wrong offset!");
static_assert(offsetof(FGzContentPackCharacterPreviewLoadoutSetup, RightArm) == 0x000068, "Member 'FGzContentPackCharacterPreviewLoadoutSetup::RightArm' has a wrong offset!");
static_assert(offsetof(FGzContentPackCharacterPreviewLoadoutSetup, Legs) == 0x000070, "Member 'FGzContentPackCharacterPreviewLoadoutSetup::Legs' has a wrong offset!");
static_assert(offsetof(FGzContentPackCharacterPreviewLoadoutSetup, Backpack) == 0x000078, "Member 'FGzContentPackCharacterPreviewLoadoutSetup::Backpack' has a wrong offset!");

// ScriptStruct G01.GzContentPackCharacterPreviewAppearanceSetup
// 0x0050 (0x0050 - 0x0000)
struct FGzContentPackCharacterPreviewAppearanceSetup final
{
public:
	TMap<struct FGameplayTag, class UGzContainerItemData*> Slots;                                             // 0x0000(0x0050)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzContentPackCharacterPreviewAppearanceSetup) == 0x000008, "Wrong alignment on FGzContentPackCharacterPreviewAppearanceSetup");
static_assert(sizeof(FGzContentPackCharacterPreviewAppearanceSetup) == 0x000050, "Wrong size on FGzContentPackCharacterPreviewAppearanceSetup");
static_assert(offsetof(FGzContentPackCharacterPreviewAppearanceSetup, Slots) == 0x000000, "Member 'FGzContentPackCharacterPreviewAppearanceSetup::Slots' has a wrong offset!");

// ScriptStruct G01.GzContentPackCharacterPreviewSetup
// 0x0120 (0x0120 - 0x0000)
struct FGzContentPackCharacterPreviewSetup final
{
public:
	struct FGzContentPackCharacterPreviewLoadoutSetup Loadout;                                           // 0x0000(0x0080)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FGzContentPackCharacterPreviewAppearanceSetup Appearance;                                        // 0x0080(0x0050)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UAkAudioEvent>           AudioStart;                                        // 0x00D0(0x0028)(Edit, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UAkAudioEvent>           AudioStop;                                         // 0x00F8(0x0028)(Edit, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzContentPackCharacterPreviewSetup) == 0x000008, "Wrong alignment on FGzContentPackCharacterPreviewSetup");
static_assert(sizeof(FGzContentPackCharacterPreviewSetup) == 0x000120, "Wrong size on FGzContentPackCharacterPreviewSetup");
static_assert(offsetof(FGzContentPackCharacterPreviewSetup, Loadout) == 0x000000, "Member 'FGzContentPackCharacterPreviewSetup::Loadout' has a wrong offset!");
static_assert(offsetof(FGzContentPackCharacterPreviewSetup, Appearance) == 0x000080, "Member 'FGzContentPackCharacterPreviewSetup::Appearance' has a wrong offset!");
static_assert(offsetof(FGzContentPackCharacterPreviewSetup, AudioStart) == 0x0000D0, "Member 'FGzContentPackCharacterPreviewSetup::AudioStart' has a wrong offset!");
static_assert(offsetof(FGzContentPackCharacterPreviewSetup, AudioStop) == 0x0000F8, "Member 'FGzContentPackCharacterPreviewSetup::AudioStop' has a wrong offset!");

// ScriptStruct G01.GzCohtmlMarketplaceItemTrends
// 0x0018 (0x0018 - 0x0000)
struct FGzCohtmlMarketplaceItemTrends final
{
public:
	TArray<struct FGzCohtmlMarketplaceItemSale>   Sales;                                             // 0x0000(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          bWasFound;                                         // 0x0010(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2B35[0x7];                                     // 0x0011(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGzCohtmlMarketplaceItemTrends) == 0x000008, "Wrong alignment on FGzCohtmlMarketplaceItemTrends");
static_assert(sizeof(FGzCohtmlMarketplaceItemTrends) == 0x000018, "Wrong size on FGzCohtmlMarketplaceItemTrends");
static_assert(offsetof(FGzCohtmlMarketplaceItemTrends, Sales) == 0x000000, "Member 'FGzCohtmlMarketplaceItemTrends::Sales' has a wrong offset!");
static_assert(offsetof(FGzCohtmlMarketplaceItemTrends, bWasFound) == 0x000010, "Member 'FGzCohtmlMarketplaceItemTrends::bWasFound' has a wrong offset!");

// ScriptStruct G01.GzDebugMenuCategory
// 0x0030 (0x0030 - 0x0000)
struct FGzDebugMenuCategory final
{
public:
	class FString                                 Name;                                              // 0x0000(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class FString>                         Subcategories;                                     // 0x0010(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class FString>                         Variables;                                         // 0x0020(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzDebugMenuCategory) == 0x000008, "Wrong alignment on FGzDebugMenuCategory");
static_assert(sizeof(FGzDebugMenuCategory) == 0x000030, "Wrong size on FGzDebugMenuCategory");
static_assert(offsetof(FGzDebugMenuCategory, Name) == 0x000000, "Member 'FGzDebugMenuCategory::Name' has a wrong offset!");
static_assert(offsetof(FGzDebugMenuCategory, Subcategories) == 0x000010, "Member 'FGzDebugMenuCategory::Subcategories' has a wrong offset!");
static_assert(offsetof(FGzDebugMenuCategory, Variables) == 0x000020, "Member 'FGzDebugMenuCategory::Variables' has a wrong offset!");

// ScriptStruct G01.GzCohtmlMatchmakingPartyMember
// 0x0028 (0x0028 - 0x0000)
struct FGzCohtmlMatchmakingPartyMember final
{
public:
	class FString                                 PlayFabId;                                         // 0x0000(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Username;                                          // 0x0010(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bReadyForMatchmaking;                              // 0x0020(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bLeader;                                           // 0x0021(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bLocalPlayer;                                      // 0x0022(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2B36[0x5];                                     // 0x0023(0x0005)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGzCohtmlMatchmakingPartyMember) == 0x000008, "Wrong alignment on FGzCohtmlMatchmakingPartyMember");
static_assert(sizeof(FGzCohtmlMatchmakingPartyMember) == 0x000028, "Wrong size on FGzCohtmlMatchmakingPartyMember");
static_assert(offsetof(FGzCohtmlMatchmakingPartyMember, PlayFabId) == 0x000000, "Member 'FGzCohtmlMatchmakingPartyMember::PlayFabId' has a wrong offset!");
static_assert(offsetof(FGzCohtmlMatchmakingPartyMember, Username) == 0x000010, "Member 'FGzCohtmlMatchmakingPartyMember::Username' has a wrong offset!");
static_assert(offsetof(FGzCohtmlMatchmakingPartyMember, bReadyForMatchmaking) == 0x000020, "Member 'FGzCohtmlMatchmakingPartyMember::bReadyForMatchmaking' has a wrong offset!");
static_assert(offsetof(FGzCohtmlMatchmakingPartyMember, bLeader) == 0x000021, "Member 'FGzCohtmlMatchmakingPartyMember::bLeader' has a wrong offset!");
static_assert(offsetof(FGzCohtmlMatchmakingPartyMember, bLocalPlayer) == 0x000022, "Member 'FGzCohtmlMatchmakingPartyMember::bLocalPlayer' has a wrong offset!");

// ScriptStruct G01.GzMetaAvailableJob
// 0x0010 (0x0010 - 0x0000)
struct FGzMetaAvailableJob final
{
public:
	class UGzNarrativeMissionData*                JobMissionData;                                    // 0x0000(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsCompleted;                                       // 0x0008(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2B37[0x7];                                     // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGzMetaAvailableJob) == 0x000008, "Wrong alignment on FGzMetaAvailableJob");
static_assert(sizeof(FGzMetaAvailableJob) == 0x000010, "Wrong size on FGzMetaAvailableJob");
static_assert(offsetof(FGzMetaAvailableJob, JobMissionData) == 0x000000, "Member 'FGzMetaAvailableJob::JobMissionData' has a wrong offset!");
static_assert(offsetof(FGzMetaAvailableJob, IsCompleted) == 0x000008, "Member 'FGzMetaAvailableJob::IsCompleted' has a wrong offset!");

// ScriptStruct G01.GzMetaAvailableGoal
// 0x0020 (0x0020 - 0x0000)
struct FGzMetaAvailableGoal final
{
public:
	TArray<struct FGzMetaAvailableJob>            Jobs;                                              // 0x0000(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	class UGzGoalData*                            GoalData;                                          // 0x0010(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsCompleted;                                       // 0x0018(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2B38[0x7];                                     // 0x0019(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGzMetaAvailableGoal) == 0x000008, "Wrong alignment on FGzMetaAvailableGoal");
static_assert(sizeof(FGzMetaAvailableGoal) == 0x000020, "Wrong size on FGzMetaAvailableGoal");
static_assert(offsetof(FGzMetaAvailableGoal, Jobs) == 0x000000, "Member 'FGzMetaAvailableGoal::Jobs' has a wrong offset!");
static_assert(offsetof(FGzMetaAvailableGoal, GoalData) == 0x000010, "Member 'FGzMetaAvailableGoal::GoalData' has a wrong offset!");
static_assert(offsetof(FGzMetaAvailableGoal, IsCompleted) == 0x000018, "Member 'FGzMetaAvailableGoal::IsCompleted' has a wrong offset!");

// ScriptStruct G01.GzMetaAvailableAssignment
// 0x0020 (0x0020 - 0x0000)
struct FGzMetaAvailableAssignment final
{
public:
	TArray<struct FGzMetaAvailableGoal>           Goals;                                             // 0x0000(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	class UGzAssignmentData*                      AssignmentData;                                    // 0x0010(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsCompleted;                                       // 0x0018(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2B39[0x7];                                     // 0x0019(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGzMetaAvailableAssignment) == 0x000008, "Wrong alignment on FGzMetaAvailableAssignment");
static_assert(sizeof(FGzMetaAvailableAssignment) == 0x000020, "Wrong size on FGzMetaAvailableAssignment");
static_assert(offsetof(FGzMetaAvailableAssignment, Goals) == 0x000000, "Member 'FGzMetaAvailableAssignment::Goals' has a wrong offset!");
static_assert(offsetof(FGzMetaAvailableAssignment, AssignmentData) == 0x000010, "Member 'FGzMetaAvailableAssignment::AssignmentData' has a wrong offset!");
static_assert(offsetof(FGzMetaAvailableAssignment, IsCompleted) == 0x000018, "Member 'FGzMetaAvailableAssignment::IsCompleted' has a wrong offset!");

// ScriptStruct G01.GzCohtmlMatchmakingRegion
// 0x0028 (0x0028 - 0x0000)
struct FGzCohtmlMatchmakingRegion final
{
public:
	class FString                                 ID;                                                // 0x0000(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   DisplayName;                                       // 0x0010(0x0010)(NativeAccessSpecifierPublic)
	uint32                                        Latency;                                           // 0x0020(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint32                                        PacketLoss;                                        // 0x0024(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzCohtmlMatchmakingRegion) == 0x000008, "Wrong alignment on FGzCohtmlMatchmakingRegion");
static_assert(sizeof(FGzCohtmlMatchmakingRegion) == 0x000028, "Wrong size on FGzCohtmlMatchmakingRegion");
static_assert(offsetof(FGzCohtmlMatchmakingRegion, ID) == 0x000000, "Member 'FGzCohtmlMatchmakingRegion::ID' has a wrong offset!");
static_assert(offsetof(FGzCohtmlMatchmakingRegion, DisplayName) == 0x000010, "Member 'FGzCohtmlMatchmakingRegion::DisplayName' has a wrong offset!");
static_assert(offsetof(FGzCohtmlMatchmakingRegion, Latency) == 0x000020, "Member 'FGzCohtmlMatchmakingRegion::Latency' has a wrong offset!");
static_assert(offsetof(FGzCohtmlMatchmakingRegion, PacketLoss) == 0x000024, "Member 'FGzCohtmlMatchmakingRegion::PacketLoss' has a wrong offset!");

// ScriptStruct G01.GzMetaBattlePassSlotDirectHexRewardV2
// 0x0010 (0x0010 - 0x0000)
struct FGzMetaBattlePassSlotDirectHexRewardV2 final
{
public:
	class UGzContainerItemData*                   Hex;                                               // 0x0000(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Limit;                                             // 0x0008(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         AlreadyBought;                                     // 0x000C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzMetaBattlePassSlotDirectHexRewardV2) == 0x000008, "Wrong alignment on FGzMetaBattlePassSlotDirectHexRewardV2");
static_assert(sizeof(FGzMetaBattlePassSlotDirectHexRewardV2) == 0x000010, "Wrong size on FGzMetaBattlePassSlotDirectHexRewardV2");
static_assert(offsetof(FGzMetaBattlePassSlotDirectHexRewardV2, Hex) == 0x000000, "Member 'FGzMetaBattlePassSlotDirectHexRewardV2::Hex' has a wrong offset!");
static_assert(offsetof(FGzMetaBattlePassSlotDirectHexRewardV2, Limit) == 0x000008, "Member 'FGzMetaBattlePassSlotDirectHexRewardV2::Limit' has a wrong offset!");
static_assert(offsetof(FGzMetaBattlePassSlotDirectHexRewardV2, AlreadyBought) == 0x00000C, "Member 'FGzMetaBattlePassSlotDirectHexRewardV2::AlreadyBought' has a wrong offset!");

// ScriptStruct G01.GzResultCompleteJob
// 0x0000 (0x00E0 - 0x00E0)
struct FGzResultCompleteJob final : public FGzPlayFabResultBase
{
};
static_assert(alignof(FGzResultCompleteJob) == 0x000008, "Wrong alignment on FGzResultCompleteJob");
static_assert(sizeof(FGzResultCompleteJob) == 0x0000E0, "Wrong size on FGzResultCompleteJob");

// ScriptStruct G01.GzResultMarketplaceItemSale
// 0x0020 (0x0020 - 0x0000)
struct FGzResultMarketplaceItemSale final
{
public:
	class FString                                 Price;                                             // 0x0000(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Date;                                              // 0x0010(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzResultMarketplaceItemSale) == 0x000008, "Wrong alignment on FGzResultMarketplaceItemSale");
static_assert(sizeof(FGzResultMarketplaceItemSale) == 0x000020, "Wrong size on FGzResultMarketplaceItemSale");
static_assert(offsetof(FGzResultMarketplaceItemSale, Price) == 0x000000, "Member 'FGzResultMarketplaceItemSale::Price' has a wrong offset!");
static_assert(offsetof(FGzResultMarketplaceItemSale, Date) == 0x000010, "Member 'FGzResultMarketplaceItemSale::Date' has a wrong offset!");

// ScriptStruct G01.GzCohtmlMatchmakingRegionQos
// 0x0008 (0x0008 - 0x0000)
struct FGzCohtmlMatchmakingRegionQos final
{
public:
	uint32                                        Latency;                                           // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint32                                        PacketLoss;                                        // 0x0004(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzCohtmlMatchmakingRegionQos) == 0x000004, "Wrong alignment on FGzCohtmlMatchmakingRegionQos");
static_assert(sizeof(FGzCohtmlMatchmakingRegionQos) == 0x000008, "Wrong size on FGzCohtmlMatchmakingRegionQos");
static_assert(offsetof(FGzCohtmlMatchmakingRegionQos, Latency) == 0x000000, "Member 'FGzCohtmlMatchmakingRegionQos::Latency' has a wrong offset!");
static_assert(offsetof(FGzCohtmlMatchmakingRegionQos, PacketLoss) == 0x000004, "Member 'FGzCohtmlMatchmakingRegionQos::PacketLoss' has a wrong offset!");

// ScriptStruct G01.GzTrackSet
// 0x0058 (0x0058 - 0x0000)
struct FGzTrackSet final
{
public:
	class FName                                   Name;                                              // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSet<class AGzTrack*>                         Tracks;                                            // 0x0008(0x0050)(Edit, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzTrackSet) == 0x000008, "Wrong alignment on FGzTrackSet");
static_assert(sizeof(FGzTrackSet) == 0x000058, "Wrong size on FGzTrackSet");
static_assert(offsetof(FGzTrackSet, Name) == 0x000000, "Member 'FGzTrackSet::Name' has a wrong offset!");
static_assert(offsetof(FGzTrackSet, Tracks) == 0x000008, "Member 'FGzTrackSet::Tracks' has a wrong offset!");

// ScriptStruct G01.GzCohtmlColor
// 0x0010 (0x0010 - 0x0000)
struct FGzCohtmlColor final
{
public:
	int32                                         R;                                                 // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         G;                                                 // 0x0004(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         B;                                                 // 0x0008(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         A;                                                 // 0x000C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzCohtmlColor) == 0x000004, "Wrong alignment on FGzCohtmlColor");
static_assert(sizeof(FGzCohtmlColor) == 0x000010, "Wrong size on FGzCohtmlColor");
static_assert(offsetof(FGzCohtmlColor, R) == 0x000000, "Member 'FGzCohtmlColor::R' has a wrong offset!");
static_assert(offsetof(FGzCohtmlColor, G) == 0x000004, "Member 'FGzCohtmlColor::G' has a wrong offset!");
static_assert(offsetof(FGzCohtmlColor, B) == 0x000008, "Member 'FGzCohtmlColor::B' has a wrong offset!");
static_assert(offsetof(FGzCohtmlColor, A) == 0x00000C, "Member 'FGzCohtmlColor::A' has a wrong offset!");

// ScriptStruct G01.GzCohtmlGameStat
// 0x0018 (0x0018 - 0x0000)
struct FGzCohtmlGameStat final
{
public:
	struct FGzCohtmlGameStatTemplate              Template;                                          // 0x0000(0x0010)(NativeAccessSpecifierPublic)
	float                                         Value;                                             // 0x0010(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2B3A[0x4];                                     // 0x0014(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGzCohtmlGameStat) == 0x000008, "Wrong alignment on FGzCohtmlGameStat");
static_assert(sizeof(FGzCohtmlGameStat) == 0x000018, "Wrong size on FGzCohtmlGameStat");
static_assert(offsetof(FGzCohtmlGameStat, Template) == 0x000000, "Member 'FGzCohtmlGameStat::Template' has a wrong offset!");
static_assert(offsetof(FGzCohtmlGameStat, Value) == 0x000010, "Member 'FGzCohtmlGameStat::Value' has a wrong offset!");

// ScriptStruct G01.HitDirectionInfo
// 0x0030 (0x0030 - 0x0000)
struct FHitDirectionInfo final
{
public:
	struct FVector                                DirectionWS;                                       // 0x0000(0x0018)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                DirectionLS;                                       // 0x0018(0x0018)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FHitDirectionInfo) == 0x000008, "Wrong alignment on FHitDirectionInfo");
static_assert(sizeof(FHitDirectionInfo) == 0x000030, "Wrong size on FHitDirectionInfo");
static_assert(offsetof(FHitDirectionInfo, DirectionWS) == 0x000000, "Member 'FHitDirectionInfo::DirectionWS' has a wrong offset!");
static_assert(offsetof(FHitDirectionInfo, DirectionLS) == 0x000018, "Member 'FHitDirectionInfo::DirectionLS' has a wrong offset!");

// ScriptStruct G01.GzCohtmlTeamMemberResult
// 0x0048 (0x0048 - 0x0000)
struct FGzCohtmlTeamMemberResult final
{
public:
	bool                                          IsPro;                                             // 0x0000(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2B3B[0x7];                                     // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   ClanTag;                                           // 0x0008(0x0010)(NativeAccessSpecifierPublic)
	class FText                                   PlayerDisplayName;                                 // 0x0018(0x0010)(NativeAccessSpecifierPublic)
	struct FGzCohtmlColor                         Color;                                             // 0x0028(0x0010)(NoDestructor, NativeAccessSpecifierPublic)
	TArray<struct FGzCohtmlGameStat>              Stats;                                             // 0x0038(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzCohtmlTeamMemberResult) == 0x000008, "Wrong alignment on FGzCohtmlTeamMemberResult");
static_assert(sizeof(FGzCohtmlTeamMemberResult) == 0x000048, "Wrong size on FGzCohtmlTeamMemberResult");
static_assert(offsetof(FGzCohtmlTeamMemberResult, IsPro) == 0x000000, "Member 'FGzCohtmlTeamMemberResult::IsPro' has a wrong offset!");
static_assert(offsetof(FGzCohtmlTeamMemberResult, ClanTag) == 0x000008, "Member 'FGzCohtmlTeamMemberResult::ClanTag' has a wrong offset!");
static_assert(offsetof(FGzCohtmlTeamMemberResult, PlayerDisplayName) == 0x000018, "Member 'FGzCohtmlTeamMemberResult::PlayerDisplayName' has a wrong offset!");
static_assert(offsetof(FGzCohtmlTeamMemberResult, Color) == 0x000028, "Member 'FGzCohtmlTeamMemberResult::Color' has a wrong offset!");
static_assert(offsetof(FGzCohtmlTeamMemberResult, Stats) == 0x000038, "Member 'FGzCohtmlTeamMemberResult::Stats' has a wrong offset!");

// ScriptStruct G01.GzConsoleCreateMatchPackage
// 0x0008 (0x0070 - 0x0068)
struct FGzConsoleCreateMatchPackage final : public FGzPlayFabClientPackage
{
public:
	EGzConsoleCreateMatchType                     MatchType;                                         // 0x0068(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2B3C[0x7];                                     // 0x0069(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGzConsoleCreateMatchPackage) == 0x000008, "Wrong alignment on FGzConsoleCreateMatchPackage");
static_assert(sizeof(FGzConsoleCreateMatchPackage) == 0x000070, "Wrong size on FGzConsoleCreateMatchPackage");
static_assert(offsetof(FGzConsoleCreateMatchPackage, MatchType) == 0x000068, "Member 'FGzConsoleCreateMatchPackage::MatchType' has a wrong offset!");

// ScriptStruct G01.GzCohtmlRewardWithSource
// 0x0028 (0x0028 - 0x0000)
struct FGzCohtmlRewardWithSource final
{
public:
	class FString                                 Source;                                            // 0x0000(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	double                                        UnscaledGun;                                       // 0x0010(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	double                                        ScaledGun;                                         // 0x0018(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         PlayerXp;                                          // 0x0020(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         BattlePassXp;                                      // 0x0024(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzCohtmlRewardWithSource) == 0x000008, "Wrong alignment on FGzCohtmlRewardWithSource");
static_assert(sizeof(FGzCohtmlRewardWithSource) == 0x000028, "Wrong size on FGzCohtmlRewardWithSource");
static_assert(offsetof(FGzCohtmlRewardWithSource, Source) == 0x000000, "Member 'FGzCohtmlRewardWithSource::Source' has a wrong offset!");
static_assert(offsetof(FGzCohtmlRewardWithSource, UnscaledGun) == 0x000010, "Member 'FGzCohtmlRewardWithSource::UnscaledGun' has a wrong offset!");
static_assert(offsetof(FGzCohtmlRewardWithSource, ScaledGun) == 0x000018, "Member 'FGzCohtmlRewardWithSource::ScaledGun' has a wrong offset!");
static_assert(offsetof(FGzCohtmlRewardWithSource, PlayerXp) == 0x000020, "Member 'FGzCohtmlRewardWithSource::PlayerXp' has a wrong offset!");
static_assert(offsetof(FGzCohtmlRewardWithSource, BattlePassXp) == 0x000024, "Member 'FGzCohtmlRewardWithSource::BattlePassXp' has a wrong offset!");

// ScriptStruct G01.GzExtractedItems
// 0x0010 (0x0010 - 0x0000)
struct FGzExtractedItems final
{
public:
	TArray<class UGzContainerItemData*>           Items;                                             // 0x0000(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
};
static_assert(alignof(FGzExtractedItems) == 0x000008, "Wrong alignment on FGzExtractedItems");
static_assert(sizeof(FGzExtractedItems) == 0x000010, "Wrong size on FGzExtractedItems");
static_assert(offsetof(FGzExtractedItems, Items) == 0x000000, "Member 'FGzExtractedItems::Items' has a wrong offset!");

// ScriptStruct G01.GzMissionProgressEntry
// 0x0010 (0x0010 - 0x0000)
struct FGzMissionProgressEntry final
{
public:
	class UGzMissionData*                         Mission;                                           // 0x0000(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsMissionCompleted;                               // 0x0008(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2B3D[0x7];                                     // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGzMissionProgressEntry) == 0x000008, "Wrong alignment on FGzMissionProgressEntry");
static_assert(sizeof(FGzMissionProgressEntry) == 0x000010, "Wrong size on FGzMissionProgressEntry");
static_assert(offsetof(FGzMissionProgressEntry, Mission) == 0x000000, "Member 'FGzMissionProgressEntry::Mission' has a wrong offset!");
static_assert(offsetof(FGzMissionProgressEntry, bIsMissionCompleted) == 0x000008, "Member 'FGzMissionProgressEntry::bIsMissionCompleted' has a wrong offset!");

// ScriptStruct G01.GzCohtmlMatchResult
// 0x0060 (0x0060 - 0x0000)
struct FGzCohtmlMatchResult final
{
public:
	class FString                                 MatchID;                                           // 0x0000(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         TeamRank;                                          // 0x0010(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         TotalTeamCount;                                    // 0x0014(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FGzCohtmlTeamMemberResult>      TeamResult;                                        // 0x0018(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FGzMissionProgressEntry>        Missions;                                          // 0x0028(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FGzCohtmlContainerItemData>     ExtractedDataCubes;                                // 0x0038(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FGzCohtmlRewardWithSource>      RewardsWithSource;                                 // 0x0048(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          bEarlyLeave;                                       // 0x0058(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2B3E[0x7];                                     // 0x0059(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGzCohtmlMatchResult) == 0x000008, "Wrong alignment on FGzCohtmlMatchResult");
static_assert(sizeof(FGzCohtmlMatchResult) == 0x000060, "Wrong size on FGzCohtmlMatchResult");
static_assert(offsetof(FGzCohtmlMatchResult, MatchID) == 0x000000, "Member 'FGzCohtmlMatchResult::MatchID' has a wrong offset!");
static_assert(offsetof(FGzCohtmlMatchResult, TeamRank) == 0x000010, "Member 'FGzCohtmlMatchResult::TeamRank' has a wrong offset!");
static_assert(offsetof(FGzCohtmlMatchResult, TotalTeamCount) == 0x000014, "Member 'FGzCohtmlMatchResult::TotalTeamCount' has a wrong offset!");
static_assert(offsetof(FGzCohtmlMatchResult, TeamResult) == 0x000018, "Member 'FGzCohtmlMatchResult::TeamResult' has a wrong offset!");
static_assert(offsetof(FGzCohtmlMatchResult, Missions) == 0x000028, "Member 'FGzCohtmlMatchResult::Missions' has a wrong offset!");
static_assert(offsetof(FGzCohtmlMatchResult, ExtractedDataCubes) == 0x000038, "Member 'FGzCohtmlMatchResult::ExtractedDataCubes' has a wrong offset!");
static_assert(offsetof(FGzCohtmlMatchResult, RewardsWithSource) == 0x000048, "Member 'FGzCohtmlMatchResult::RewardsWithSource' has a wrong offset!");
static_assert(offsetof(FGzCohtmlMatchResult, bEarlyLeave) == 0x000058, "Member 'FGzCohtmlMatchResult::bEarlyLeave' has a wrong offset!");

// ScriptStruct G01.GzMetaBattlePassSlotCurrencyRewardV2
// 0x0010 (0x0010 - 0x0000)
struct FGzMetaBattlePassSlotCurrencyRewardV2 final
{
public:
	class UGzCurrencyItemData*                    CurrencyItemData;                                  // 0x0000(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	double                                        GunAmount;                                         // 0x0008(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzMetaBattlePassSlotCurrencyRewardV2) == 0x000008, "Wrong alignment on FGzMetaBattlePassSlotCurrencyRewardV2");
static_assert(sizeof(FGzMetaBattlePassSlotCurrencyRewardV2) == 0x000010, "Wrong size on FGzMetaBattlePassSlotCurrencyRewardV2");
static_assert(offsetof(FGzMetaBattlePassSlotCurrencyRewardV2, CurrencyItemData) == 0x000000, "Member 'FGzMetaBattlePassSlotCurrencyRewardV2::CurrencyItemData' has a wrong offset!");
static_assert(offsetof(FGzMetaBattlePassSlotCurrencyRewardV2, GunAmount) == 0x000008, "Member 'FGzMetaBattlePassSlotCurrencyRewardV2::GunAmount' has a wrong offset!");

// ScriptStruct G01.CohtmlXsollaPrice
// 0x0030 (0x0030 - 0x0000)
struct FCohtmlXsollaPrice final
{
public:
	class FString                                 Amount;                                            // 0x0000(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 AmountWithoutDiscount;                             // 0x0010(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Currency;                                          // 0x0020(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCohtmlXsollaPrice) == 0x000008, "Wrong alignment on FCohtmlXsollaPrice");
static_assert(sizeof(FCohtmlXsollaPrice) == 0x000030, "Wrong size on FCohtmlXsollaPrice");
static_assert(offsetof(FCohtmlXsollaPrice, Amount) == 0x000000, "Member 'FCohtmlXsollaPrice::Amount' has a wrong offset!");
static_assert(offsetof(FCohtmlXsollaPrice, AmountWithoutDiscount) == 0x000010, "Member 'FCohtmlXsollaPrice::AmountWithoutDiscount' has a wrong offset!");
static_assert(offsetof(FCohtmlXsollaPrice, Currency) == 0x000020, "Member 'FCohtmlXsollaPrice::Currency' has a wrong offset!");

// ScriptStruct G01.GzCohtmlNews
// 0x0060 (0x0060 - 0x0000)
struct FGzCohtmlNews final
{
public:
	class FString                                 ID;                                                // 0x0000(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Lang;                                              // 0x0010(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EGzNewsType                                   Type;                                              // 0x0020(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2B3F[0x7];                                     // 0x0021(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 Title;                                             // 0x0028(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Subtitle;                                          // 0x0038(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int64                                         Time;                                              // 0x0048(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Body;                                              // 0x0050(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzCohtmlNews) == 0x000008, "Wrong alignment on FGzCohtmlNews");
static_assert(sizeof(FGzCohtmlNews) == 0x000060, "Wrong size on FGzCohtmlNews");
static_assert(offsetof(FGzCohtmlNews, ID) == 0x000000, "Member 'FGzCohtmlNews::ID' has a wrong offset!");
static_assert(offsetof(FGzCohtmlNews, Lang) == 0x000010, "Member 'FGzCohtmlNews::Lang' has a wrong offset!");
static_assert(offsetof(FGzCohtmlNews, Type) == 0x000020, "Member 'FGzCohtmlNews::Type' has a wrong offset!");
static_assert(offsetof(FGzCohtmlNews, Title) == 0x000028, "Member 'FGzCohtmlNews::Title' has a wrong offset!");
static_assert(offsetof(FGzCohtmlNews, Subtitle) == 0x000038, "Member 'FGzCohtmlNews::Subtitle' has a wrong offset!");
static_assert(offsetof(FGzCohtmlNews, Time) == 0x000048, "Member 'FGzCohtmlNews::Time' has a wrong offset!");
static_assert(offsetof(FGzCohtmlNews, Body) == 0x000050, "Member 'FGzCohtmlNews::Body' has a wrong offset!");

// ScriptStruct G01.GzCohtmlGrantedItemId
// 0x0020 (0x0020 - 0x0000)
struct FGzCohtmlGrantedItemId final
{
public:
	class FString                                 AssetId;                                           // 0x0000(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 ItemInstanceId;                                    // 0x0010(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzCohtmlGrantedItemId) == 0x000008, "Wrong alignment on FGzCohtmlGrantedItemId");
static_assert(sizeof(FGzCohtmlGrantedItemId) == 0x000020, "Wrong size on FGzCohtmlGrantedItemId");
static_assert(offsetof(FGzCohtmlGrantedItemId, AssetId) == 0x000000, "Member 'FGzCohtmlGrantedItemId::AssetId' has a wrong offset!");
static_assert(offsetof(FGzCohtmlGrantedItemId, ItemInstanceId) == 0x000010, "Member 'FGzCohtmlGrantedItemId::ItemInstanceId' has a wrong offset!");

// ScriptStruct G01.GzStripeCancelSubscriptionPackage
// 0x0000 (0x0068 - 0x0068)
struct FGzStripeCancelSubscriptionPackage final : public FGzPlayFabClientPackage
{
};
static_assert(alignof(FGzStripeCancelSubscriptionPackage) == 0x000008, "Wrong alignment on FGzStripeCancelSubscriptionPackage");
static_assert(sizeof(FGzStripeCancelSubscriptionPackage) == 0x000068, "Wrong size on FGzStripeCancelSubscriptionPackage");

// ScriptStruct G01.GzAudioFadeParams
// 0x000C (0x000C - 0x0000)
struct FGzAudioFadeParams final
{
public:
	float                                         FadeInTimeSeconds;                                 // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FadeOutTimeSeconds;                                // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EAkCurveInterpolation                         FadeCurve;                                         // 0x0008(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2B40[0x3];                                     // 0x0009(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGzAudioFadeParams) == 0x000004, "Wrong alignment on FGzAudioFadeParams");
static_assert(sizeof(FGzAudioFadeParams) == 0x00000C, "Wrong size on FGzAudioFadeParams");
static_assert(offsetof(FGzAudioFadeParams, FadeInTimeSeconds) == 0x000000, "Member 'FGzAudioFadeParams::FadeInTimeSeconds' has a wrong offset!");
static_assert(offsetof(FGzAudioFadeParams, FadeOutTimeSeconds) == 0x000004, "Member 'FGzAudioFadeParams::FadeOutTimeSeconds' has a wrong offset!");
static_assert(offsetof(FGzAudioFadeParams, FadeCurve) == 0x000008, "Member 'FGzAudioFadeParams::FadeCurve' has a wrong offset!");

// ScriptStruct G01.GzEnvironmentZoneType
// 0x0058 (0x0058 - 0x0000)
struct FGzEnvironmentZoneType final
{
public:
	class FString                                 Name;                                              // 0x0000(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGuid                                  Guid;                                              // 0x0010(0x0010)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UAkSwitchValue>          SWITCH;                                            // 0x0020(0x0028)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIndoor;                                           // 0x0048(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2B41[0x3];                                     // 0x0049(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGzAudioFadeParams                     AmbientFadeParams;                                 // 0x004C(0x000C)(Edit, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzEnvironmentZoneType) == 0x000008, "Wrong alignment on FGzEnvironmentZoneType");
static_assert(sizeof(FGzEnvironmentZoneType) == 0x000058, "Wrong size on FGzEnvironmentZoneType");
static_assert(offsetof(FGzEnvironmentZoneType, Name) == 0x000000, "Member 'FGzEnvironmentZoneType::Name' has a wrong offset!");
static_assert(offsetof(FGzEnvironmentZoneType, Guid) == 0x000010, "Member 'FGzEnvironmentZoneType::Guid' has a wrong offset!");
static_assert(offsetof(FGzEnvironmentZoneType, SWITCH) == 0x000020, "Member 'FGzEnvironmentZoneType::SWITCH' has a wrong offset!");
static_assert(offsetof(FGzEnvironmentZoneType, bIndoor) == 0x000048, "Member 'FGzEnvironmentZoneType::bIndoor' has a wrong offset!");
static_assert(offsetof(FGzEnvironmentZoneType, AmbientFadeParams) == 0x00004C, "Member 'FGzEnvironmentZoneType::AmbientFadeParams' has a wrong offset!");

// ScriptStruct G01.GzCohtmlContentPackInfo
// 0x0010 (0x0010 - 0x0000)
struct FGzCohtmlContentPackInfo final
{
public:
	TArray<struct FGzGrantedItemId>               GrantedItems;                                      // 0x0000(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzCohtmlContentPackInfo) == 0x000008, "Wrong alignment on FGzCohtmlContentPackInfo");
static_assert(sizeof(FGzCohtmlContentPackInfo) == 0x000010, "Wrong size on FGzCohtmlContentPackInfo");
static_assert(offsetof(FGzCohtmlContentPackInfo, GrantedItems) == 0x000000, "Member 'FGzCohtmlContentPackInfo::GrantedItems' has a wrong offset!");

// ScriptStruct G01.GzCohtmlWeaponConfigurationItem
// 0x0040 (0x0040 - 0x0000)
struct FGzCohtmlWeaponConfigurationItem final
{
public:
	struct FGzCohtmlString                        ItemId;                                            // 0x0000(0x0020)(NativeAccessSpecifierPublic)
	struct FGzCohtmlString                        AssetId;                                           // 0x0020(0x0020)(NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzCohtmlWeaponConfigurationItem) == 0x000008, "Wrong alignment on FGzCohtmlWeaponConfigurationItem");
static_assert(sizeof(FGzCohtmlWeaponConfigurationItem) == 0x000040, "Wrong size on FGzCohtmlWeaponConfigurationItem");
static_assert(offsetof(FGzCohtmlWeaponConfigurationItem, ItemId) == 0x000000, "Member 'FGzCohtmlWeaponConfigurationItem::ItemId' has a wrong offset!");
static_assert(offsetof(FGzCohtmlWeaponConfigurationItem, AssetId) == 0x000020, "Member 'FGzCohtmlWeaponConfigurationItem::AssetId' has a wrong offset!");

// ScriptStruct G01.GzCohtmlWeaponConfiguration
// 0x00E8 (0x00E8 - 0x0000)
struct FGzCohtmlWeaponConfiguration final
{
public:
	class FString                                 ID;                                                // 0x0000(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGzCohtmlWeaponConfigurationItem       Weapon;                                            // 0x0010(0x0040)(NativeAccessSpecifierPublic)
	struct FGzCohtmlWeaponConfigurationItem       Skin;                                              // 0x0050(0x0040)(NativeAccessSpecifierPublic)
	TMap<class FString, struct FGzCohtmlWeaponConfigurationItem> Attachments;                                       // 0x0090(0x0050)(NativeAccessSpecifierPublic)
	int32                                         Cost;                                              // 0x00E0(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2B42[0x4];                                     // 0x00E4(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGzCohtmlWeaponConfiguration) == 0x000008, "Wrong alignment on FGzCohtmlWeaponConfiguration");
static_assert(sizeof(FGzCohtmlWeaponConfiguration) == 0x0000E8, "Wrong size on FGzCohtmlWeaponConfiguration");
static_assert(offsetof(FGzCohtmlWeaponConfiguration, ID) == 0x000000, "Member 'FGzCohtmlWeaponConfiguration::ID' has a wrong offset!");
static_assert(offsetof(FGzCohtmlWeaponConfiguration, Weapon) == 0x000010, "Member 'FGzCohtmlWeaponConfiguration::Weapon' has a wrong offset!");
static_assert(offsetof(FGzCohtmlWeaponConfiguration, Skin) == 0x000050, "Member 'FGzCohtmlWeaponConfiguration::Skin' has a wrong offset!");
static_assert(offsetof(FGzCohtmlWeaponConfiguration, Attachments) == 0x000090, "Member 'FGzCohtmlWeaponConfiguration::Attachments' has a wrong offset!");
static_assert(offsetof(FGzCohtmlWeaponConfiguration, Cost) == 0x0000E0, "Member 'FGzCohtmlWeaponConfiguration::Cost' has a wrong offset!");

// ScriptStruct G01.GzCohtmlVirtualCurrency
// 0x0008 (0x0008 - 0x0000)
struct FGzCohtmlVirtualCurrency final
{
public:
	EGzVirtualCurrencyType                        Type;                                              // 0x0000(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2B43[0x3];                                     // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         Value;                                             // 0x0004(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzCohtmlVirtualCurrency) == 0x000004, "Wrong alignment on FGzCohtmlVirtualCurrency");
static_assert(sizeof(FGzCohtmlVirtualCurrency) == 0x000008, "Wrong size on FGzCohtmlVirtualCurrency");
static_assert(offsetof(FGzCohtmlVirtualCurrency, Type) == 0x000000, "Member 'FGzCohtmlVirtualCurrency::Type' has a wrong offset!");
static_assert(offsetof(FGzCohtmlVirtualCurrency, Value) == 0x000004, "Member 'FGzCohtmlVirtualCurrency::Value' has a wrong offset!");

// ScriptStruct G01.GzCohtmlCoin
// 0x0010 (0x0010 - 0x0000)
struct FGzCohtmlCoin final
{
public:
	EGzBlockchainCoinType                         Type;                                              // 0x0000(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2B44[0x7];                                     // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	double                                        Value;                                             // 0x0008(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzCohtmlCoin) == 0x000008, "Wrong alignment on FGzCohtmlCoin");
static_assert(sizeof(FGzCohtmlCoin) == 0x000010, "Wrong size on FGzCohtmlCoin");
static_assert(offsetof(FGzCohtmlCoin, Type) == 0x000000, "Member 'FGzCohtmlCoin::Type' has a wrong offset!");
static_assert(offsetof(FGzCohtmlCoin, Value) == 0x000008, "Member 'FGzCohtmlCoin::Value' has a wrong offset!");

// ScriptStruct G01.GzCohtmlCombinedReward
// 0x0048 (0x0048 - 0x0000)
struct FGzCohtmlCombinedReward final
{
public:
	TArray<class FString>                         RewardIds;                                         // 0x0000(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	int32                                         PlayerXp;                                          // 0x0010(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         BattlePassXp;                                      // 0x0014(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FGzCohtmlVirtualCurrency>       VirtualCurrencies;                                 // 0x0018(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FGzCohtmlCoin>                  Coins;                                             // 0x0028(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FGzGrantedItemId>               GrantedItemIds;                                    // 0x0038(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzCohtmlCombinedReward) == 0x000008, "Wrong alignment on FGzCohtmlCombinedReward");
static_assert(sizeof(FGzCohtmlCombinedReward) == 0x000048, "Wrong size on FGzCohtmlCombinedReward");
static_assert(offsetof(FGzCohtmlCombinedReward, RewardIds) == 0x000000, "Member 'FGzCohtmlCombinedReward::RewardIds' has a wrong offset!");
static_assert(offsetof(FGzCohtmlCombinedReward, PlayerXp) == 0x000010, "Member 'FGzCohtmlCombinedReward::PlayerXp' has a wrong offset!");
static_assert(offsetof(FGzCohtmlCombinedReward, BattlePassXp) == 0x000014, "Member 'FGzCohtmlCombinedReward::BattlePassXp' has a wrong offset!");
static_assert(offsetof(FGzCohtmlCombinedReward, VirtualCurrencies) == 0x000018, "Member 'FGzCohtmlCombinedReward::VirtualCurrencies' has a wrong offset!");
static_assert(offsetof(FGzCohtmlCombinedReward, Coins) == 0x000028, "Member 'FGzCohtmlCombinedReward::Coins' has a wrong offset!");
static_assert(offsetof(FGzCohtmlCombinedReward, GrantedItemIds) == 0x000038, "Member 'FGzCohtmlCombinedReward::GrantedItemIds' has a wrong offset!");

// ScriptStruct G01.GzCohtmlAchievementNotification
// 0x0060 (0x0080 - 0x0020)
struct FGzCohtmlAchievementNotification final : public FGzCohtmlNotification
{
public:
	class FString                                 AchievementId;                                     // 0x0020(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Stage;                                             // 0x0030(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2B45[0x4];                                     // 0x0034(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGzCohtmlCombinedReward                Reward;                                            // 0x0038(0x0048)(NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzCohtmlAchievementNotification) == 0x000008, "Wrong alignment on FGzCohtmlAchievementNotification");
static_assert(sizeof(FGzCohtmlAchievementNotification) == 0x000080, "Wrong size on FGzCohtmlAchievementNotification");
static_assert(offsetof(FGzCohtmlAchievementNotification, AchievementId) == 0x000020, "Member 'FGzCohtmlAchievementNotification::AchievementId' has a wrong offset!");
static_assert(offsetof(FGzCohtmlAchievementNotification, Stage) == 0x000030, "Member 'FGzCohtmlAchievementNotification::Stage' has a wrong offset!");
static_assert(offsetof(FGzCohtmlAchievementNotification, Reward) == 0x000038, "Member 'FGzCohtmlAchievementNotification::Reward' has a wrong offset!");

// ScriptStruct G01.GzBattlePassLevelSettings
// 0x0014 (0x0014 - 0x0000)
struct FGzBattlePassLevelSettings final
{
public:
	struct FGuid                                  ID;                                                // 0x0000(0x0010)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         XpForNextLevel;                                    // 0x0010(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzBattlePassLevelSettings) == 0x000004, "Wrong alignment on FGzBattlePassLevelSettings");
static_assert(sizeof(FGzBattlePassLevelSettings) == 0x000014, "Wrong size on FGzBattlePassLevelSettings");
static_assert(offsetof(FGzBattlePassLevelSettings, ID) == 0x000000, "Member 'FGzBattlePassLevelSettings::ID' has a wrong offset!");
static_assert(offsetof(FGzBattlePassLevelSettings, XpForNextLevel) == 0x000010, "Member 'FGzBattlePassLevelSettings::XpForNextLevel' has a wrong offset!");

// ScriptStruct G01.GzCohtmlMarketplaceTransaction
// 0x0090 (0x0090 - 0x0000)
struct FGzCohtmlMarketplaceTransaction final
{
public:
	class FString                                 SellerPlayFabId;                                   // 0x0000(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 SellerTitleAccountId;                              // 0x0010(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 BuyerPlayFabId;                                    // 0x0020(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 BuyerTitleAccountId;                               // 0x0030(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 NftId;                                             // 0x0040(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 AssetId;                                           // 0x0050(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 TradeTime;                                         // 0x0060(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Price;                                             // 0x0070(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2B46[0x4];                                     // 0x0074(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 Status;                                            // 0x0078(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PaidFee;                                           // 0x0088(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2B47[0x4];                                     // 0x008C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGzCohtmlMarketplaceTransaction) == 0x000008, "Wrong alignment on FGzCohtmlMarketplaceTransaction");
static_assert(sizeof(FGzCohtmlMarketplaceTransaction) == 0x000090, "Wrong size on FGzCohtmlMarketplaceTransaction");
static_assert(offsetof(FGzCohtmlMarketplaceTransaction, SellerPlayFabId) == 0x000000, "Member 'FGzCohtmlMarketplaceTransaction::SellerPlayFabId' has a wrong offset!");
static_assert(offsetof(FGzCohtmlMarketplaceTransaction, SellerTitleAccountId) == 0x000010, "Member 'FGzCohtmlMarketplaceTransaction::SellerTitleAccountId' has a wrong offset!");
static_assert(offsetof(FGzCohtmlMarketplaceTransaction, BuyerPlayFabId) == 0x000020, "Member 'FGzCohtmlMarketplaceTransaction::BuyerPlayFabId' has a wrong offset!");
static_assert(offsetof(FGzCohtmlMarketplaceTransaction, BuyerTitleAccountId) == 0x000030, "Member 'FGzCohtmlMarketplaceTransaction::BuyerTitleAccountId' has a wrong offset!");
static_assert(offsetof(FGzCohtmlMarketplaceTransaction, NftId) == 0x000040, "Member 'FGzCohtmlMarketplaceTransaction::NftId' has a wrong offset!");
static_assert(offsetof(FGzCohtmlMarketplaceTransaction, AssetId) == 0x000050, "Member 'FGzCohtmlMarketplaceTransaction::AssetId' has a wrong offset!");
static_assert(offsetof(FGzCohtmlMarketplaceTransaction, TradeTime) == 0x000060, "Member 'FGzCohtmlMarketplaceTransaction::TradeTime' has a wrong offset!");
static_assert(offsetof(FGzCohtmlMarketplaceTransaction, Price) == 0x000070, "Member 'FGzCohtmlMarketplaceTransaction::Price' has a wrong offset!");
static_assert(offsetof(FGzCohtmlMarketplaceTransaction, Status) == 0x000078, "Member 'FGzCohtmlMarketplaceTransaction::Status' has a wrong offset!");
static_assert(offsetof(FGzCohtmlMarketplaceTransaction, PaidFee) == 0x000088, "Member 'FGzCohtmlMarketplaceTransaction::PaidFee' has a wrong offset!");

// ScriptStruct G01.GzEnvironmentZoneKey
// 0x0010 (0x0010 - 0x0000)
struct FGzEnvironmentZoneKey final
{
public:
	struct FGuid                                  Guid;                                              // 0x0000(0x0010)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzEnvironmentZoneKey) == 0x000004, "Wrong alignment on FGzEnvironmentZoneKey");
static_assert(sizeof(FGzEnvironmentZoneKey) == 0x000010, "Wrong size on FGzEnvironmentZoneKey");
static_assert(offsetof(FGzEnvironmentZoneKey, Guid) == 0x000000, "Member 'FGzEnvironmentZoneKey::Guid' has a wrong offset!");

// ScriptStruct G01.GzCohtmlBattlePassLevelUpNotification
// 0x0008 (0x0028 - 0x0020)
struct FGzCohtmlBattlePassLevelUpNotification final : public FGzCohtmlNotification
{
public:
	int32                                         NewLevel;                                          // 0x0020(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2B48[0x4];                                     // 0x0024(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGzCohtmlBattlePassLevelUpNotification) == 0x000008, "Wrong alignment on FGzCohtmlBattlePassLevelUpNotification");
static_assert(sizeof(FGzCohtmlBattlePassLevelUpNotification) == 0x000028, "Wrong size on FGzCohtmlBattlePassLevelUpNotification");
static_assert(offsetof(FGzCohtmlBattlePassLevelUpNotification, NewLevel) == 0x000020, "Member 'FGzCohtmlBattlePassLevelUpNotification::NewLevel' has a wrong offset!");

// ScriptStruct G01.GzCohtmlChallengeNotification
// 0x0058 (0x0078 - 0x0020)
struct FGzCohtmlChallengeNotification final : public FGzCohtmlNotification
{
public:
	class FString                                 ChallengeId;                                       // 0x0020(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGzCohtmlCombinedReward                Reward;                                            // 0x0030(0x0048)(NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzCohtmlChallengeNotification) == 0x000008, "Wrong alignment on FGzCohtmlChallengeNotification");
static_assert(sizeof(FGzCohtmlChallengeNotification) == 0x000078, "Wrong size on FGzCohtmlChallengeNotification");
static_assert(offsetof(FGzCohtmlChallengeNotification, ChallengeId) == 0x000020, "Member 'FGzCohtmlChallengeNotification::ChallengeId' has a wrong offset!");
static_assert(offsetof(FGzCohtmlChallengeNotification, Reward) == 0x000030, "Member 'FGzCohtmlChallengeNotification::Reward' has a wrong offset!");

// ScriptStruct G01.GzBattlePassPreviewInfo
// 0x0048 (0x0048 - 0x0000)
struct FGzBattlePassPreviewInfo final
{
public:
	class FText                                   Summary;                                           // 0x0000(0x0010)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FGzCohtmlVideo                         Video;                                             // 0x0010(0x0010)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UTexture2D>              RewardsPreviewImage;                               // 0x0020(0x0028)(Edit, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzBattlePassPreviewInfo) == 0x000008, "Wrong alignment on FGzBattlePassPreviewInfo");
static_assert(sizeof(FGzBattlePassPreviewInfo) == 0x000048, "Wrong size on FGzBattlePassPreviewInfo");
static_assert(offsetof(FGzBattlePassPreviewInfo, Summary) == 0x000000, "Member 'FGzBattlePassPreviewInfo::Summary' has a wrong offset!");
static_assert(offsetof(FGzBattlePassPreviewInfo, Video) == 0x000010, "Member 'FGzBattlePassPreviewInfo::Video' has a wrong offset!");
static_assert(offsetof(FGzBattlePassPreviewInfo, RewardsPreviewImage) == 0x000020, "Member 'FGzBattlePassPreviewInfo::RewardsPreviewImage' has a wrong offset!");

// ScriptStruct G01.GzExtractPackage
// 0x0018 (0x00A0 - 0x0088)
struct FGzExtractPackage final : public FGzPlayFabServerPackage
{
public:
	TArray<class FString>                         AssetIds;                                          // 0x0088(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	class FName                                   ExtractorId;                                       // 0x0098(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzExtractPackage) == 0x000008, "Wrong alignment on FGzExtractPackage");
static_assert(sizeof(FGzExtractPackage) == 0x0000A0, "Wrong size on FGzExtractPackage");
static_assert(offsetof(FGzExtractPackage, AssetIds) == 0x000088, "Member 'FGzExtractPackage::AssetIds' has a wrong offset!");
static_assert(offsetof(FGzExtractPackage, ExtractorId) == 0x000098, "Member 'FGzExtractPackage::ExtractorId' has a wrong offset!");

// ScriptStruct G01.GzCohtmlGrantRewardNotification
// 0x0048 (0x0068 - 0x0020)
struct FGzCohtmlGrantRewardNotification final : public FGzCohtmlNotification
{
public:
	struct FGzCohtmlCombinedReward                Reward;                                            // 0x0020(0x0048)(NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzCohtmlGrantRewardNotification) == 0x000008, "Wrong alignment on FGzCohtmlGrantRewardNotification");
static_assert(sizeof(FGzCohtmlGrantRewardNotification) == 0x000068, "Wrong size on FGzCohtmlGrantRewardNotification");
static_assert(offsetof(FGzCohtmlGrantRewardNotification, Reward) == 0x000020, "Member 'FGzCohtmlGrantRewardNotification::Reward' has a wrong offset!");

// ScriptStruct G01.GzCohtmlJobNotification
// 0x0068 (0x0088 - 0x0020)
struct FGzCohtmlJobNotification final : public FGzCohtmlNotification
{
public:
	class FString                                 CharacterId;                                       // 0x0020(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 JobId;                                             // 0x0030(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGzCohtmlCombinedReward                Reward;                                            // 0x0040(0x0048)(NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzCohtmlJobNotification) == 0x000008, "Wrong alignment on FGzCohtmlJobNotification");
static_assert(sizeof(FGzCohtmlJobNotification) == 0x000088, "Wrong size on FGzCohtmlJobNotification");
static_assert(offsetof(FGzCohtmlJobNotification, CharacterId) == 0x000020, "Member 'FGzCohtmlJobNotification::CharacterId' has a wrong offset!");
static_assert(offsetof(FGzCohtmlJobNotification, JobId) == 0x000030, "Member 'FGzCohtmlJobNotification::JobId' has a wrong offset!");
static_assert(offsetof(FGzCohtmlJobNotification, Reward) == 0x000040, "Member 'FGzCohtmlJobNotification::Reward' has a wrong offset!");

// ScriptStruct G01.GzEpicLoginOptions
// 0x0030 (0x0030 - 0x0000)
struct alignas(0x08) FGzEpicLoginOptions final
{
public:
	uint8                                         Pad_2B49[0x30];                                    // 0x0000(0x0030)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGzEpicLoginOptions) == 0x000008, "Wrong alignment on FGzEpicLoginOptions");
static_assert(sizeof(FGzEpicLoginOptions) == 0x000030, "Wrong size on FGzEpicLoginOptions");

// ScriptStruct G01.GzCohtmlServerBrowserServerHostingStatusChangedNotification
// 0x0020 (0x0040 - 0x0020)
struct FGzCohtmlServerBrowserServerHostingStatusChangedNotification final : public FGzCohtmlNotification
{
public:
	class FString                                 ServerName;                                        // 0x0020(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Status;                                            // 0x0030(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzCohtmlServerBrowserServerHostingStatusChangedNotification) == 0x000008, "Wrong alignment on FGzCohtmlServerBrowserServerHostingStatusChangedNotification");
static_assert(sizeof(FGzCohtmlServerBrowserServerHostingStatusChangedNotification) == 0x000040, "Wrong size on FGzCohtmlServerBrowserServerHostingStatusChangedNotification");
static_assert(offsetof(FGzCohtmlServerBrowserServerHostingStatusChangedNotification, ServerName) == 0x000020, "Member 'FGzCohtmlServerBrowserServerHostingStatusChangedNotification::ServerName' has a wrong offset!");
static_assert(offsetof(FGzCohtmlServerBrowserServerHostingStatusChangedNotification, Status) == 0x000030, "Member 'FGzCohtmlServerBrowserServerHostingStatusChangedNotification::Status' has a wrong offset!");

// ScriptStruct G01.GzNetHitData
// 0x0050 (0x0050 - 0x0000)
struct FGzNetHitData final
{
public:
	uint8                                         bBlockingHit : 1;                                  // 0x0000(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bStartPenetrating : 1;                             // 0x0000(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_2B4A[0x7];                                     // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector_NetQuantize                    ImpactPoint;                                       // 0x0008(0x0018)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PenetrationDepth;                                  // 0x0020(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2B4B[0x4];                                     // 0x0024(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FActorInstanceHandle                   HitObjectHandle;                                   // 0x0028(0x0020)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   BoneName;                                          // 0x0048(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzNetHitData) == 0x000008, "Wrong alignment on FGzNetHitData");
static_assert(sizeof(FGzNetHitData) == 0x000050, "Wrong size on FGzNetHitData");
static_assert(offsetof(FGzNetHitData, ImpactPoint) == 0x000008, "Member 'FGzNetHitData::ImpactPoint' has a wrong offset!");
static_assert(offsetof(FGzNetHitData, PenetrationDepth) == 0x000020, "Member 'FGzNetHitData::PenetrationDepth' has a wrong offset!");
static_assert(offsetof(FGzNetHitData, HitObjectHandle) == 0x000028, "Member 'FGzNetHitData::HitObjectHandle' has a wrong offset!");
static_assert(offsetof(FGzNetHitData, BoneName) == 0x000048, "Member 'FGzNetHitData::BoneName' has a wrong offset!");

// ScriptStruct G01.GzCohtmlPlayerLevelNotification
// 0x0050 (0x0070 - 0x0020)
struct FGzCohtmlPlayerLevelNotification final : public FGzCohtmlNotification
{
public:
	int32                                         NewLevel;                                          // 0x0020(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2B4C[0x4];                                     // 0x0024(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGzCohtmlCombinedReward                Reward;                                            // 0x0028(0x0048)(NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzCohtmlPlayerLevelNotification) == 0x000008, "Wrong alignment on FGzCohtmlPlayerLevelNotification");
static_assert(sizeof(FGzCohtmlPlayerLevelNotification) == 0x000070, "Wrong size on FGzCohtmlPlayerLevelNotification");
static_assert(offsetof(FGzCohtmlPlayerLevelNotification, NewLevel) == 0x000020, "Member 'FGzCohtmlPlayerLevelNotification::NewLevel' has a wrong offset!");
static_assert(offsetof(FGzCohtmlPlayerLevelNotification, Reward) == 0x000028, "Member 'FGzCohtmlPlayerLevelNotification::Reward' has a wrong offset!");

// ScriptStruct G01.GzBrushData
// 0x0070 (0x0070 - 0x0000)
struct FGzBrushData final
{
public:
	class UBodySetup*                             BodySetup;                                         // 0x0000(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2B4D[0x8];                                     // 0x0008(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             BodyToWorld;                                       // 0x0010(0x0060)(Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzBrushData) == 0x000010, "Wrong alignment on FGzBrushData");
static_assert(sizeof(FGzBrushData) == 0x000070, "Wrong size on FGzBrushData");
static_assert(offsetof(FGzBrushData, BodySetup) == 0x000000, "Member 'FGzBrushData::BodySetup' has a wrong offset!");
static_assert(offsetof(FGzBrushData, BodyToWorld) == 0x000010, "Member 'FGzBrushData::BodyToWorld' has a wrong offset!");

// ScriptStruct G01.GzCohtmlBlockchainMintItemV2Notification
// 0x0030 (0x0050 - 0x0020)
struct FGzCohtmlBlockchainMintItemV2Notification final : public FGzCohtmlNotification
{
public:
	class FString                                 AssetId;                                           // 0x0020(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 ItemInstanceId;                                    // 0x0030(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 NftId;                                             // 0x0040(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzCohtmlBlockchainMintItemV2Notification) == 0x000008, "Wrong alignment on FGzCohtmlBlockchainMintItemV2Notification");
static_assert(sizeof(FGzCohtmlBlockchainMintItemV2Notification) == 0x000050, "Wrong size on FGzCohtmlBlockchainMintItemV2Notification");
static_assert(offsetof(FGzCohtmlBlockchainMintItemV2Notification, AssetId) == 0x000020, "Member 'FGzCohtmlBlockchainMintItemV2Notification::AssetId' has a wrong offset!");
static_assert(offsetof(FGzCohtmlBlockchainMintItemV2Notification, ItemInstanceId) == 0x000030, "Member 'FGzCohtmlBlockchainMintItemV2Notification::ItemInstanceId' has a wrong offset!");
static_assert(offsetof(FGzCohtmlBlockchainMintItemV2Notification, NftId) == 0x000040, "Member 'FGzCohtmlBlockchainMintItemV2Notification::NftId' has a wrong offset!");

// ScriptStruct G01.GzCohtmlBlockchainDecodeV2Notification
// 0x0030 (0x0050 - 0x0020)
struct FGzCohtmlBlockchainDecodeV2Notification final : public FGzCohtmlNotification
{
public:
	class FString                                 AssetId;                                           // 0x0020(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 ItemInstanceId;                                    // 0x0030(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 NftId;                                             // 0x0040(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzCohtmlBlockchainDecodeV2Notification) == 0x000008, "Wrong alignment on FGzCohtmlBlockchainDecodeV2Notification");
static_assert(sizeof(FGzCohtmlBlockchainDecodeV2Notification) == 0x000050, "Wrong size on FGzCohtmlBlockchainDecodeV2Notification");
static_assert(offsetof(FGzCohtmlBlockchainDecodeV2Notification, AssetId) == 0x000020, "Member 'FGzCohtmlBlockchainDecodeV2Notification::AssetId' has a wrong offset!");
static_assert(offsetof(FGzCohtmlBlockchainDecodeV2Notification, ItemInstanceId) == 0x000030, "Member 'FGzCohtmlBlockchainDecodeV2Notification::ItemInstanceId' has a wrong offset!");
static_assert(offsetof(FGzCohtmlBlockchainDecodeV2Notification, NftId) == 0x000040, "Member 'FGzCohtmlBlockchainDecodeV2Notification::NftId' has a wrong offset!");

// ScriptStruct G01.GzCohtmlBlockchainMarketLotBoughtNotification
// 0x0020 (0x0040 - 0x0020)
struct FGzCohtmlBlockchainMarketLotBoughtNotification final : public FGzCohtmlNotification
{
public:
	class FString                                 AssetId;                                           // 0x0020(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 ItemInstanceId;                                    // 0x0030(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzCohtmlBlockchainMarketLotBoughtNotification) == 0x000008, "Wrong alignment on FGzCohtmlBlockchainMarketLotBoughtNotification");
static_assert(sizeof(FGzCohtmlBlockchainMarketLotBoughtNotification) == 0x000040, "Wrong size on FGzCohtmlBlockchainMarketLotBoughtNotification");
static_assert(offsetof(FGzCohtmlBlockchainMarketLotBoughtNotification, AssetId) == 0x000020, "Member 'FGzCohtmlBlockchainMarketLotBoughtNotification::AssetId' has a wrong offset!");
static_assert(offsetof(FGzCohtmlBlockchainMarketLotBoughtNotification, ItemInstanceId) == 0x000030, "Member 'FGzCohtmlBlockchainMarketLotBoughtNotification::ItemInstanceId' has a wrong offset!");

// ScriptStruct G01.GzCohtmlBlockchainMarketLotCreatedNotification
// 0x0020 (0x0040 - 0x0020)
struct FGzCohtmlBlockchainMarketLotCreatedNotification final : public FGzCohtmlNotification
{
public:
	class FString                                 AssetId;                                           // 0x0020(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 ItemInstanceId;                                    // 0x0030(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzCohtmlBlockchainMarketLotCreatedNotification) == 0x000008, "Wrong alignment on FGzCohtmlBlockchainMarketLotCreatedNotification");
static_assert(sizeof(FGzCohtmlBlockchainMarketLotCreatedNotification) == 0x000040, "Wrong size on FGzCohtmlBlockchainMarketLotCreatedNotification");
static_assert(offsetof(FGzCohtmlBlockchainMarketLotCreatedNotification, AssetId) == 0x000020, "Member 'FGzCohtmlBlockchainMarketLotCreatedNotification::AssetId' has a wrong offset!");
static_assert(offsetof(FGzCohtmlBlockchainMarketLotCreatedNotification, ItemInstanceId) == 0x000030, "Member 'FGzCohtmlBlockchainMarketLotCreatedNotification::ItemInstanceId' has a wrong offset!");

// ScriptStruct G01.GzSearchZoneArray
// 0x0058 (0x0168 - 0x0110)
struct FGzSearchZoneArray final : public FFastArraySerializer
{
public:
	uint8                                         Pad_2B4E[0x48];                                    // 0x0110(0x0048)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FGzSearchZoneWorldData>         SearchZones;                                       // 0x0158(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzSearchZoneArray) == 0x000008, "Wrong alignment on FGzSearchZoneArray");
static_assert(sizeof(FGzSearchZoneArray) == 0x000168, "Wrong size on FGzSearchZoneArray");
static_assert(offsetof(FGzSearchZoneArray, SearchZones) == 0x000158, "Member 'FGzSearchZoneArray::SearchZones' has a wrong offset!");

// ScriptStruct G01.GzCohtmlBlockchainMarketLotSoldNotification
// 0x0020 (0x0040 - 0x0020)
struct FGzCohtmlBlockchainMarketLotSoldNotification final : public FGzCohtmlNotification
{
public:
	class FString                                 AssetId;                                           // 0x0020(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 ItemInstanceId;                                    // 0x0030(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzCohtmlBlockchainMarketLotSoldNotification) == 0x000008, "Wrong alignment on FGzCohtmlBlockchainMarketLotSoldNotification");
static_assert(sizeof(FGzCohtmlBlockchainMarketLotSoldNotification) == 0x000040, "Wrong size on FGzCohtmlBlockchainMarketLotSoldNotification");
static_assert(offsetof(FGzCohtmlBlockchainMarketLotSoldNotification, AssetId) == 0x000020, "Member 'FGzCohtmlBlockchainMarketLotSoldNotification::AssetId' has a wrong offset!");
static_assert(offsetof(FGzCohtmlBlockchainMarketLotSoldNotification, ItemInstanceId) == 0x000030, "Member 'FGzCohtmlBlockchainMarketLotSoldNotification::ItemInstanceId' has a wrong offset!");

// ScriptStruct G01.GzPlayerFactionKey
// 0x0008 (0x0008 - 0x0000)
struct FGzPlayerFactionKey final
{
public:
	class FName                                   Key;                                               // 0x0000(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzPlayerFactionKey) == 0x000004, "Wrong alignment on FGzPlayerFactionKey");
static_assert(sizeof(FGzPlayerFactionKey) == 0x000008, "Wrong size on FGzPlayerFactionKey");
static_assert(offsetof(FGzPlayerFactionKey, Key) == 0x000000, "Member 'FGzPlayerFactionKey::Key' has a wrong offset!");

// ScriptStruct G01.GzCohtmlBlockchainMarketLotExpiredNotification
// 0x0020 (0x0040 - 0x0020)
struct FGzCohtmlBlockchainMarketLotExpiredNotification final : public FGzCohtmlNotification
{
public:
	class FString                                 AssetId;                                           // 0x0020(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 ItemInstanceId;                                    // 0x0030(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzCohtmlBlockchainMarketLotExpiredNotification) == 0x000008, "Wrong alignment on FGzCohtmlBlockchainMarketLotExpiredNotification");
static_assert(sizeof(FGzCohtmlBlockchainMarketLotExpiredNotification) == 0x000040, "Wrong size on FGzCohtmlBlockchainMarketLotExpiredNotification");
static_assert(offsetof(FGzCohtmlBlockchainMarketLotExpiredNotification, AssetId) == 0x000020, "Member 'FGzCohtmlBlockchainMarketLotExpiredNotification::AssetId' has a wrong offset!");
static_assert(offsetof(FGzCohtmlBlockchainMarketLotExpiredNotification, ItemInstanceId) == 0x000030, "Member 'FGzCohtmlBlockchainMarketLotExpiredNotification::ItemInstanceId' has a wrong offset!");

// ScriptStruct G01.GzWeaponAttachmentSetting
// 0x0048 (0x0048 - 0x0000)
struct FGzWeaponAttachmentSetting
{
public:
	struct FVector                                AttachmentViewTargetOffset;                        // 0x0000(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                AttachmentPovOffset;                               // 0x0018(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                AttachmentPovDistance;                             // 0x0030(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzWeaponAttachmentSetting) == 0x000008, "Wrong alignment on FGzWeaponAttachmentSetting");
static_assert(sizeof(FGzWeaponAttachmentSetting) == 0x000048, "Wrong size on FGzWeaponAttachmentSetting");
static_assert(offsetof(FGzWeaponAttachmentSetting, AttachmentViewTargetOffset) == 0x000000, "Member 'FGzWeaponAttachmentSetting::AttachmentViewTargetOffset' has a wrong offset!");
static_assert(offsetof(FGzWeaponAttachmentSetting, AttachmentPovOffset) == 0x000018, "Member 'FGzWeaponAttachmentSetting::AttachmentPovOffset' has a wrong offset!");
static_assert(offsetof(FGzWeaponAttachmentSetting, AttachmentPovDistance) == 0x000030, "Member 'FGzWeaponAttachmentSetting::AttachmentPovDistance' has a wrong offset!");

// ScriptStruct G01.GzCohtmlExtractNotification
// 0x0020 (0x0040 - 0x0020)
struct FGzCohtmlExtractNotification final : public FGzCohtmlNotification
{
public:
	class FString                                 AssetId;                                           // 0x0020(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 ItemInstanceId;                                    // 0x0030(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzCohtmlExtractNotification) == 0x000008, "Wrong alignment on FGzCohtmlExtractNotification");
static_assert(sizeof(FGzCohtmlExtractNotification) == 0x000040, "Wrong size on FGzCohtmlExtractNotification");
static_assert(offsetof(FGzCohtmlExtractNotification, AssetId) == 0x000020, "Member 'FGzCohtmlExtractNotification::AssetId' has a wrong offset!");
static_assert(offsetof(FGzCohtmlExtractNotification, ItemInstanceId) == 0x000030, "Member 'FGzCohtmlExtractNotification::ItemInstanceId' has a wrong offset!");

// ScriptStruct G01.GzExplosionParameters
// 0x0060 (0x0060 - 0x0000)
struct FGzExplosionParameters final
{
public:
	class APawn*                                  InstigatorPawn;                                    // 0x0000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 CharacterIdAccessActor;                            // 0x0008(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMap<struct FGameplayTag, float>              DamageEffectMultipliers;                           // 0x0010(0x0050)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzExplosionParameters) == 0x000008, "Wrong alignment on FGzExplosionParameters");
static_assert(sizeof(FGzExplosionParameters) == 0x000060, "Wrong size on FGzExplosionParameters");
static_assert(offsetof(FGzExplosionParameters, InstigatorPawn) == 0x000000, "Member 'FGzExplosionParameters::InstigatorPawn' has a wrong offset!");
static_assert(offsetof(FGzExplosionParameters, CharacterIdAccessActor) == 0x000008, "Member 'FGzExplosionParameters::CharacterIdAccessActor' has a wrong offset!");
static_assert(offsetof(FGzExplosionParameters, DamageEffectMultipliers) == 0x000010, "Member 'FGzExplosionParameters::DamageEffectMultipliers' has a wrong offset!");

// ScriptStruct G01.GzCohtmlDailyRewardNotification
// 0x0050 (0x0070 - 0x0020)
struct FGzCohtmlDailyRewardNotification final : public FGzCohtmlNotification
{
public:
	int32                                         Day;                                               // 0x0020(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2B4F[0x4];                                     // 0x0024(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGzCohtmlCombinedReward                Reward;                                            // 0x0028(0x0048)(NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzCohtmlDailyRewardNotification) == 0x000008, "Wrong alignment on FGzCohtmlDailyRewardNotification");
static_assert(sizeof(FGzCohtmlDailyRewardNotification) == 0x000070, "Wrong size on FGzCohtmlDailyRewardNotification");
static_assert(offsetof(FGzCohtmlDailyRewardNotification, Day) == 0x000020, "Member 'FGzCohtmlDailyRewardNotification::Day' has a wrong offset!");
static_assert(offsetof(FGzCohtmlDailyRewardNotification, Reward) == 0x000028, "Member 'FGzCohtmlDailyRewardNotification::Reward' has a wrong offset!");

// ScriptStruct G01.GzCohtmlPlinkRewardNotification
// 0x0050 (0x0070 - 0x0020)
struct FGzCohtmlPlinkRewardNotification final : public FGzCohtmlNotification
{
public:
	int32                                         Day;                                               // 0x0020(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2B50[0x4];                                     // 0x0024(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGzCohtmlCombinedReward                Reward;                                            // 0x0028(0x0048)(NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzCohtmlPlinkRewardNotification) == 0x000008, "Wrong alignment on FGzCohtmlPlinkRewardNotification");
static_assert(sizeof(FGzCohtmlPlinkRewardNotification) == 0x000070, "Wrong size on FGzCohtmlPlinkRewardNotification");
static_assert(offsetof(FGzCohtmlPlinkRewardNotification, Day) == 0x000020, "Member 'FGzCohtmlPlinkRewardNotification::Day' has a wrong offset!");
static_assert(offsetof(FGzCohtmlPlinkRewardNotification, Reward) == 0x000028, "Member 'FGzCohtmlPlinkRewardNotification::Reward' has a wrong offset!");

// ScriptStruct G01.GzGadgetMoveData
// 0x0090 (0x0090 - 0x0000)
struct FGzGadgetMoveData final
{
public:
	struct FVector                                Velocity;                                          // 0x0000(0x0018)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FlyTime;                                           // 0x0018(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2B51[0x4];                                     // 0x001C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             Transform;                                         // 0x0020(0x0060)(Edit, BlueprintVisible, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bNeedAttach;                                       // 0x0080(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2B52[0xF];                                     // 0x0081(0x000F)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGzGadgetMoveData) == 0x000010, "Wrong alignment on FGzGadgetMoveData");
static_assert(sizeof(FGzGadgetMoveData) == 0x000090, "Wrong size on FGzGadgetMoveData");
static_assert(offsetof(FGzGadgetMoveData, Velocity) == 0x000000, "Member 'FGzGadgetMoveData::Velocity' has a wrong offset!");
static_assert(offsetof(FGzGadgetMoveData, FlyTime) == 0x000018, "Member 'FGzGadgetMoveData::FlyTime' has a wrong offset!");
static_assert(offsetof(FGzGadgetMoveData, Transform) == 0x000020, "Member 'FGzGadgetMoveData::Transform' has a wrong offset!");
static_assert(offsetof(FGzGadgetMoveData, bNeedAttach) == 0x000080, "Member 'FGzGadgetMoveData::bNeedAttach' has a wrong offset!");

// ScriptStruct G01.GzCohtmlSubscriptionCreatedNotification
// 0x0010 (0x0030 - 0x0020)
struct FGzCohtmlSubscriptionCreatedNotification final : public FGzCohtmlNotification
{
public:
	struct FGzCohtmlContentPackInfo               ContentPackInfo;                                   // 0x0020(0x0010)(NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzCohtmlSubscriptionCreatedNotification) == 0x000008, "Wrong alignment on FGzCohtmlSubscriptionCreatedNotification");
static_assert(sizeof(FGzCohtmlSubscriptionCreatedNotification) == 0x000030, "Wrong size on FGzCohtmlSubscriptionCreatedNotification");
static_assert(offsetof(FGzCohtmlSubscriptionCreatedNotification, ContentPackInfo) == 0x000020, "Member 'FGzCohtmlSubscriptionCreatedNotification::ContentPackInfo' has a wrong offset!");

// ScriptStruct G01.GzCohtmlSubscriptionContentPackGrantedNotification
// 0x0010 (0x0030 - 0x0020)
struct FGzCohtmlSubscriptionContentPackGrantedNotification final : public FGzCohtmlNotification
{
public:
	struct FGzCohtmlContentPackInfo               ContentPackInfo;                                   // 0x0020(0x0010)(NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzCohtmlSubscriptionContentPackGrantedNotification) == 0x000008, "Wrong alignment on FGzCohtmlSubscriptionContentPackGrantedNotification");
static_assert(sizeof(FGzCohtmlSubscriptionContentPackGrantedNotification) == 0x000030, "Wrong size on FGzCohtmlSubscriptionContentPackGrantedNotification");
static_assert(offsetof(FGzCohtmlSubscriptionContentPackGrantedNotification, ContentPackInfo) == 0x000020, "Member 'FGzCohtmlSubscriptionContentPackGrantedNotification::ContentPackInfo' has a wrong offset!");

// ScriptStruct G01.GzConsoleCreateMatchResult
// 0x0010 (0x00F0 - 0x00E0)
struct FGzConsoleCreateMatchResult final : public FGzPlayFabResultBase
{
public:
	class FString                                 MatchID;                                           // 0x00E0(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzConsoleCreateMatchResult) == 0x000008, "Wrong alignment on FGzConsoleCreateMatchResult");
static_assert(sizeof(FGzConsoleCreateMatchResult) == 0x0000F0, "Wrong size on FGzConsoleCreateMatchResult");
static_assert(offsetof(FGzConsoleCreateMatchResult, MatchID) == 0x0000E0, "Member 'FGzConsoleCreateMatchResult::MatchID' has a wrong offset!");

// ScriptStruct G01.GzCohtmlSubscriptionMonthlyGunGrantedNotification
// 0x0020 (0x0040 - 0x0020)
struct FGzCohtmlSubscriptionMonthlyGunGrantedNotification final : public FGzCohtmlNotification
{
public:
	struct FGzGrantedItemId                       CoinsItem;                                         // 0x0020(0x0020)(NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzCohtmlSubscriptionMonthlyGunGrantedNotification) == 0x000008, "Wrong alignment on FGzCohtmlSubscriptionMonthlyGunGrantedNotification");
static_assert(sizeof(FGzCohtmlSubscriptionMonthlyGunGrantedNotification) == 0x000040, "Wrong size on FGzCohtmlSubscriptionMonthlyGunGrantedNotification");
static_assert(offsetof(FGzCohtmlSubscriptionMonthlyGunGrantedNotification, CoinsItem) == 0x000020, "Member 'FGzCohtmlSubscriptionMonthlyGunGrantedNotification::CoinsItem' has a wrong offset!");

// ScriptStruct G01.GzCohtmlOnlineInventoryItem
// 0x0220 (0x0220 - 0x0000)
struct FGzCohtmlOnlineInventoryItem final
{
public:
	struct FGzCohtmlItemData                      AssetData;                                         // 0x0000(0x0148)(NativeAccessSpecifierPublic)
	struct FGzCohtmlString                        AssetName;                                         // 0x0148(0x0020)(NativeAccessSpecifierPublic)
	struct FGzCohtmlString                        Type;                                              // 0x0168(0x0020)(NativeAccessSpecifierPublic)
	struct FGzCohtmlString                        Guid;                                              // 0x0188(0x0020)(NativeAccessSpecifierPublic)
	struct FGzCohtmlString                        ItemNftId;                                         // 0x01A8(0x0020)(NativeAccessSpecifierPublic)
	bool                                          bListedOnMarketplace;                              // 0x01C8(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EGzMarketplaceState                           MarketplaceState;                                  // 0x01C9(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2B53[0x6];                                     // 0x01CA(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGzCohtmlString                        ItemSource;                                        // 0x01D0(0x0020)(NativeAccessSpecifierPublic)
	int64                                         CreatedAt;                                         // 0x01F0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsReviewed;                                        // 0x01F8(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2B54[0x7];                                     // 0x01F9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	int64                                         SerialNumber;                                      // 0x0200(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsUsed;                                            // 0x0208(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2B55[0x7];                                     // 0x0209(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 TimeToEnableTrade;                                 // 0x0210(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzCohtmlOnlineInventoryItem) == 0x000008, "Wrong alignment on FGzCohtmlOnlineInventoryItem");
static_assert(sizeof(FGzCohtmlOnlineInventoryItem) == 0x000220, "Wrong size on FGzCohtmlOnlineInventoryItem");
static_assert(offsetof(FGzCohtmlOnlineInventoryItem, AssetData) == 0x000000, "Member 'FGzCohtmlOnlineInventoryItem::AssetData' has a wrong offset!");
static_assert(offsetof(FGzCohtmlOnlineInventoryItem, AssetName) == 0x000148, "Member 'FGzCohtmlOnlineInventoryItem::AssetName' has a wrong offset!");
static_assert(offsetof(FGzCohtmlOnlineInventoryItem, Type) == 0x000168, "Member 'FGzCohtmlOnlineInventoryItem::Type' has a wrong offset!");
static_assert(offsetof(FGzCohtmlOnlineInventoryItem, Guid) == 0x000188, "Member 'FGzCohtmlOnlineInventoryItem::Guid' has a wrong offset!");
static_assert(offsetof(FGzCohtmlOnlineInventoryItem, ItemNftId) == 0x0001A8, "Member 'FGzCohtmlOnlineInventoryItem::ItemNftId' has a wrong offset!");
static_assert(offsetof(FGzCohtmlOnlineInventoryItem, bListedOnMarketplace) == 0x0001C8, "Member 'FGzCohtmlOnlineInventoryItem::bListedOnMarketplace' has a wrong offset!");
static_assert(offsetof(FGzCohtmlOnlineInventoryItem, MarketplaceState) == 0x0001C9, "Member 'FGzCohtmlOnlineInventoryItem::MarketplaceState' has a wrong offset!");
static_assert(offsetof(FGzCohtmlOnlineInventoryItem, ItemSource) == 0x0001D0, "Member 'FGzCohtmlOnlineInventoryItem::ItemSource' has a wrong offset!");
static_assert(offsetof(FGzCohtmlOnlineInventoryItem, CreatedAt) == 0x0001F0, "Member 'FGzCohtmlOnlineInventoryItem::CreatedAt' has a wrong offset!");
static_assert(offsetof(FGzCohtmlOnlineInventoryItem, IsReviewed) == 0x0001F8, "Member 'FGzCohtmlOnlineInventoryItem::IsReviewed' has a wrong offset!");
static_assert(offsetof(FGzCohtmlOnlineInventoryItem, SerialNumber) == 0x000200, "Member 'FGzCohtmlOnlineInventoryItem::SerialNumber' has a wrong offset!");
static_assert(offsetof(FGzCohtmlOnlineInventoryItem, IsUsed) == 0x000208, "Member 'FGzCohtmlOnlineInventoryItem::IsUsed' has a wrong offset!");
static_assert(offsetof(FGzCohtmlOnlineInventoryItem, TimeToEnableTrade) == 0x000210, "Member 'FGzCohtmlOnlineInventoryItem::TimeToEnableTrade' has a wrong offset!");

// ScriptStruct G01.GzPromotionBanner
// 0x0020 (0x0020 - 0x0000)
struct FGzPromotionBanner final
{
public:
	class FString                                 Image;                                             // 0x0000(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 URL;                                               // 0x0010(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzPromotionBanner) == 0x000008, "Wrong alignment on FGzPromotionBanner");
static_assert(sizeof(FGzPromotionBanner) == 0x000020, "Wrong size on FGzPromotionBanner");
static_assert(offsetof(FGzPromotionBanner, Image) == 0x000000, "Member 'FGzPromotionBanner::Image' has a wrong offset!");
static_assert(offsetof(FGzPromotionBanner, URL) == 0x000010, "Member 'FGzPromotionBanner::URL' has a wrong offset!");

// ScriptStruct G01.GzCohtmlPartyMember
// 0x0050 (0x0050 - 0x0000)
struct FGzCohtmlPartyMember final
{
public:
	class FString                                 Username;                                          // 0x0000(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 PlayFabId;                                         // 0x0010(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 TitleAccountId;                                    // 0x0020(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 EpicAccountId;                                     // 0x0030(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   AvatarId;                                          // 0x0040(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsLeader;                                         // 0x0048(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2B56[0x7];                                     // 0x0049(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGzCohtmlPartyMember) == 0x000008, "Wrong alignment on FGzCohtmlPartyMember");
static_assert(sizeof(FGzCohtmlPartyMember) == 0x000050, "Wrong size on FGzCohtmlPartyMember");
static_assert(offsetof(FGzCohtmlPartyMember, Username) == 0x000000, "Member 'FGzCohtmlPartyMember::Username' has a wrong offset!");
static_assert(offsetof(FGzCohtmlPartyMember, PlayFabId) == 0x000010, "Member 'FGzCohtmlPartyMember::PlayFabId' has a wrong offset!");
static_assert(offsetof(FGzCohtmlPartyMember, TitleAccountId) == 0x000020, "Member 'FGzCohtmlPartyMember::TitleAccountId' has a wrong offset!");
static_assert(offsetof(FGzCohtmlPartyMember, EpicAccountId) == 0x000030, "Member 'FGzCohtmlPartyMember::EpicAccountId' has a wrong offset!");
static_assert(offsetof(FGzCohtmlPartyMember, AvatarId) == 0x000040, "Member 'FGzCohtmlPartyMember::AvatarId' has a wrong offset!");
static_assert(offsetof(FGzCohtmlPartyMember, bIsLeader) == 0x000048, "Member 'FGzCohtmlPartyMember::bIsLeader' has a wrong offset!");

// ScriptStruct G01.GzSoundState
// 0x0068 (0x0068 - 0x0000)
struct FGzSoundState final
{
public:
	class FName                                   Key;                                               // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UAkStateValue>           StateValue;                                        // 0x0008(0x0028)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   StateGroup;                                        // 0x0030(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   State;                                             // 0x0038(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UAkAudioEvent>           StateEvent;                                        // 0x0040(0x0028)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzSoundState) == 0x000008, "Wrong alignment on FGzSoundState");
static_assert(sizeof(FGzSoundState) == 0x000068, "Wrong size on FGzSoundState");
static_assert(offsetof(FGzSoundState, Key) == 0x000000, "Member 'FGzSoundState::Key' has a wrong offset!");
static_assert(offsetof(FGzSoundState, StateValue) == 0x000008, "Member 'FGzSoundState::StateValue' has a wrong offset!");
static_assert(offsetof(FGzSoundState, StateGroup) == 0x000030, "Member 'FGzSoundState::StateGroup' has a wrong offset!");
static_assert(offsetof(FGzSoundState, State) == 0x000038, "Member 'FGzSoundState::State' has a wrong offset!");
static_assert(offsetof(FGzSoundState, StateEvent) == 0x000040, "Member 'FGzSoundState::StateEvent' has a wrong offset!");

// ScriptStruct G01.GzCohtmlPartyInvite
// 0x0020 (0x0020 - 0x0000)
struct FGzCohtmlPartyInvite final
{
public:
	class FString                                 UniquePartyInviteId;                               // 0x0000(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 InvitingEpicId;                                    // 0x0010(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzCohtmlPartyInvite) == 0x000008, "Wrong alignment on FGzCohtmlPartyInvite");
static_assert(sizeof(FGzCohtmlPartyInvite) == 0x000020, "Wrong size on FGzCohtmlPartyInvite");
static_assert(offsetof(FGzCohtmlPartyInvite, UniquePartyInviteId) == 0x000000, "Member 'FGzCohtmlPartyInvite::UniquePartyInviteId' has a wrong offset!");
static_assert(offsetof(FGzCohtmlPartyInvite, InvitingEpicId) == 0x000010, "Member 'FGzCohtmlPartyInvite::InvitingEpicId' has a wrong offset!");

// ScriptStruct G01.GzDenyFriendInvitationResult
// 0x0000 (0x00E0 - 0x00E0)
struct FGzDenyFriendInvitationResult final : public FGzPlayFabResultBase
{
};
static_assert(alignof(FGzDenyFriendInvitationResult) == 0x000008, "Wrong alignment on FGzDenyFriendInvitationResult");
static_assert(sizeof(FGzDenyFriendInvitationResult) == 0x0000E0, "Wrong size on FGzDenyFriendInvitationResult");

// ScriptStruct G01.GzCohtmlPreferences
// 0x0010 (0x0010 - 0x0000)
struct FGzCohtmlPreferences final
{
public:
	class FString                                 PreferenceData;                                    // 0x0000(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzCohtmlPreferences) == 0x000008, "Wrong alignment on FGzCohtmlPreferences");
static_assert(sizeof(FGzCohtmlPreferences) == 0x000010, "Wrong size on FGzCohtmlPreferences");
static_assert(offsetof(FGzCohtmlPreferences, PreferenceData) == 0x000000, "Member 'FGzCohtmlPreferences::PreferenceData' has a wrong offset!");

// ScriptStruct G01.GzCohtmlCheapestMarketLotInfo
// 0x00A8 (0x00A8 - 0x0000)
struct FGzCohtmlCheapestMarketLotInfo final
{
public:
	struct FGzCohtmlMarketplaceItemOffer          ItemInfo;                                          // 0x0000(0x00A0)(NativeAccessSpecifierPublic)
	bool                                          bFound;                                            // 0x00A0(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2B57[0x7];                                     // 0x00A1(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGzCohtmlCheapestMarketLotInfo) == 0x000008, "Wrong alignment on FGzCohtmlCheapestMarketLotInfo");
static_assert(sizeof(FGzCohtmlCheapestMarketLotInfo) == 0x0000A8, "Wrong size on FGzCohtmlCheapestMarketLotInfo");
static_assert(offsetof(FGzCohtmlCheapestMarketLotInfo, ItemInfo) == 0x000000, "Member 'FGzCohtmlCheapestMarketLotInfo::ItemInfo' has a wrong offset!");
static_assert(offsetof(FGzCohtmlCheapestMarketLotInfo, bFound) == 0x0000A0, "Member 'FGzCohtmlCheapestMarketLotInfo::bFound' has a wrong offset!");

// ScriptStruct G01.GzPackageListMarketFilterParameters
// 0x0070 (0x0070 - 0x0000)
struct FGzPackageListMarketFilterParameters final
{
public:
	double                                        MinPrice;                                          // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	double                                        MaxPrice;                                          // 0x0008(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGzPlayFabPlayerIdContainer            Seller;                                            // 0x0010(0x0020)(NativeAccessSpecifierPublic)
	TArray<class FString>                         Rarities;                                          // 0x0030(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class FString>                         Types;                                             // 0x0040(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	class FString                                 Name;                                              // 0x0050(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class FString>                         AssetIds;                                          // 0x0060(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzPackageListMarketFilterParameters) == 0x000008, "Wrong alignment on FGzPackageListMarketFilterParameters");
static_assert(sizeof(FGzPackageListMarketFilterParameters) == 0x000070, "Wrong size on FGzPackageListMarketFilterParameters");
static_assert(offsetof(FGzPackageListMarketFilterParameters, MinPrice) == 0x000000, "Member 'FGzPackageListMarketFilterParameters::MinPrice' has a wrong offset!");
static_assert(offsetof(FGzPackageListMarketFilterParameters, MaxPrice) == 0x000008, "Member 'FGzPackageListMarketFilterParameters::MaxPrice' has a wrong offset!");
static_assert(offsetof(FGzPackageListMarketFilterParameters, Seller) == 0x000010, "Member 'FGzPackageListMarketFilterParameters::Seller' has a wrong offset!");
static_assert(offsetof(FGzPackageListMarketFilterParameters, Rarities) == 0x000030, "Member 'FGzPackageListMarketFilterParameters::Rarities' has a wrong offset!");
static_assert(offsetof(FGzPackageListMarketFilterParameters, Types) == 0x000040, "Member 'FGzPackageListMarketFilterParameters::Types' has a wrong offset!");
static_assert(offsetof(FGzPackageListMarketFilterParameters, Name) == 0x000050, "Member 'FGzPackageListMarketFilterParameters::Name' has a wrong offset!");
static_assert(offsetof(FGzPackageListMarketFilterParameters, AssetIds) == 0x000060, "Member 'FGzPackageListMarketFilterParameters::AssetIds' has a wrong offset!");

// ScriptStruct G01.GzPackageCreateMarketLot
// 0x0028 (0x0090 - 0x0068)
struct FGzPackageCreateMarketLot final : public FGzPlayFabClientPackage
{
public:
	class FString                                 ItemInstanceId;                                    // 0x0068(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint16                                        ExpiresInDays;                                     // 0x0078(0x0002)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2B58[0x6];                                     // 0x007A(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 PriceString;                                       // 0x0080(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzPackageCreateMarketLot) == 0x000008, "Wrong alignment on FGzPackageCreateMarketLot");
static_assert(sizeof(FGzPackageCreateMarketLot) == 0x000090, "Wrong size on FGzPackageCreateMarketLot");
static_assert(offsetof(FGzPackageCreateMarketLot, ItemInstanceId) == 0x000068, "Member 'FGzPackageCreateMarketLot::ItemInstanceId' has a wrong offset!");
static_assert(offsetof(FGzPackageCreateMarketLot, ExpiresInDays) == 0x000078, "Member 'FGzPackageCreateMarketLot::ExpiresInDays' has a wrong offset!");
static_assert(offsetof(FGzPackageCreateMarketLot, PriceString) == 0x000080, "Member 'FGzPackageCreateMarketLot::PriceString' has a wrong offset!");

// ScriptStruct G01.GzCohtmlSettingCollection
// 0x0030 (0x0030 - 0x0000)
struct FGzCohtmlSettingCollection final
{
public:
	class FText                                   DisplayName;                                       // 0x0000(0x0010)(NativeAccessSpecifierPublic)
	class FString                                 DevName;                                           // 0x0010(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FGzCohtmlSettingCategory>       Categories;                                        // 0x0020(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzCohtmlSettingCollection) == 0x000008, "Wrong alignment on FGzCohtmlSettingCollection");
static_assert(sizeof(FGzCohtmlSettingCollection) == 0x000030, "Wrong size on FGzCohtmlSettingCollection");
static_assert(offsetof(FGzCohtmlSettingCollection, DisplayName) == 0x000000, "Member 'FGzCohtmlSettingCollection::DisplayName' has a wrong offset!");
static_assert(offsetof(FGzCohtmlSettingCollection, DevName) == 0x000010, "Member 'FGzCohtmlSettingCollection::DevName' has a wrong offset!");
static_assert(offsetof(FGzCohtmlSettingCollection, Categories) == 0x000020, "Member 'FGzCohtmlSettingCollection::Categories' has a wrong offset!");

// ScriptStruct G01.GzPackageRedeemPromoCode
// 0x0010 (0x0078 - 0x0068)
struct FGzPackageRedeemPromoCode final : public FGzPlayFabClientPackage
{
public:
	class FString                                 PromoCode;                                         // 0x0068(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzPackageRedeemPromoCode) == 0x000008, "Wrong alignment on FGzPackageRedeemPromoCode");
static_assert(sizeof(FGzPackageRedeemPromoCode) == 0x000078, "Wrong size on FGzPackageRedeemPromoCode");
static_assert(offsetof(FGzPackageRedeemPromoCode, PromoCode) == 0x000068, "Member 'FGzPackageRedeemPromoCode::PromoCode' has a wrong offset!");

// ScriptStruct G01.GzCohtmlStackParser
// 0x0001 (0x0001 - 0x0000)
struct FGzCohtmlStackParser final
{
public:
	uint8                                         Pad_2B59[0x1];                                     // 0x0000(0x0001)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGzCohtmlStackParser) == 0x000001, "Wrong alignment on FGzCohtmlStackParser");
static_assert(sizeof(FGzCohtmlStackParser) == 0x000001, "Wrong size on FGzCohtmlStackParser");

// ScriptStruct G01.GzPlayFabAchievementNotification
// 0x00E8 (0x0108 - 0x0020)
struct FGzPlayFabAchievementNotification final : public FGzPlayFabNotification
{
public:
	class FString                                 AchievementId;                                     // 0x0020(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Stage;                                             // 0x0030(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2B5A[0x4];                                     // 0x0034(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGzCombinedReward                      Reward;                                            // 0x0038(0x00D0)(NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzPlayFabAchievementNotification) == 0x000008, "Wrong alignment on FGzPlayFabAchievementNotification");
static_assert(sizeof(FGzPlayFabAchievementNotification) == 0x000108, "Wrong size on FGzPlayFabAchievementNotification");
static_assert(offsetof(FGzPlayFabAchievementNotification, AchievementId) == 0x000020, "Member 'FGzPlayFabAchievementNotification::AchievementId' has a wrong offset!");
static_assert(offsetof(FGzPlayFabAchievementNotification, Stage) == 0x000030, "Member 'FGzPlayFabAchievementNotification::Stage' has a wrong offset!");
static_assert(offsetof(FGzPlayFabAchievementNotification, Reward) == 0x000038, "Member 'FGzPlayFabAchievementNotification::Reward' has a wrong offset!");

// ScriptStruct G01.GzCohtmlStartServerParams
// 0x0098 (0x0098 - 0x0000)
struct FGzCohtmlStartServerParams final
{
public:
	class FString                                 HostingType;                                       // 0x0000(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 GameMode;                                          // 0x0010(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 ServerName;                                        // 0x0020(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 AdditionalOptions;                                 // 0x0030(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint32                                        InactivityTimout;                                  // 0x0040(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          EnableTraces;                                      // 0x0044(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2B5B[0x3];                                     // 0x0045(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<class FString, struct FGzCohtmlServerOptionValue> ServerOptions;                                     // 0x0048(0x0050)(NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzCohtmlStartServerParams) == 0x000008, "Wrong alignment on FGzCohtmlStartServerParams");
static_assert(sizeof(FGzCohtmlStartServerParams) == 0x000098, "Wrong size on FGzCohtmlStartServerParams");
static_assert(offsetof(FGzCohtmlStartServerParams, HostingType) == 0x000000, "Member 'FGzCohtmlStartServerParams::HostingType' has a wrong offset!");
static_assert(offsetof(FGzCohtmlStartServerParams, GameMode) == 0x000010, "Member 'FGzCohtmlStartServerParams::GameMode' has a wrong offset!");
static_assert(offsetof(FGzCohtmlStartServerParams, ServerName) == 0x000020, "Member 'FGzCohtmlStartServerParams::ServerName' has a wrong offset!");
static_assert(offsetof(FGzCohtmlStartServerParams, AdditionalOptions) == 0x000030, "Member 'FGzCohtmlStartServerParams::AdditionalOptions' has a wrong offset!");
static_assert(offsetof(FGzCohtmlStartServerParams, InactivityTimout) == 0x000040, "Member 'FGzCohtmlStartServerParams::InactivityTimout' has a wrong offset!");
static_assert(offsetof(FGzCohtmlStartServerParams, EnableTraces) == 0x000044, "Member 'FGzCohtmlStartServerParams::EnableTraces' has a wrong offset!");
static_assert(offsetof(FGzCohtmlStartServerParams, ServerOptions) == 0x000048, "Member 'FGzCohtmlStartServerParams::ServerOptions' has a wrong offset!");

// ScriptStruct G01.GzCohtmlContentPackPreviewInfo
// 0x0070 (0x0070 - 0x0000)
struct FGzCohtmlContentPackPreviewInfo final
{
public:
	class FText                                   Summary;                                           // 0x0000(0x0010)(NativeAccessSpecifierPublic)
	TArray<class FString>                         RewardItems;                                       // 0x0010(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	class FString                                 BackgroundImage;                                   // 0x0020(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 AnimationVideo;                                    // 0x0030(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 ItemsImage;                                        // 0x0040(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 PackPreviewImage;                                  // 0x0050(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 PackPreviewSecondaryImage;                         // 0x0060(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzCohtmlContentPackPreviewInfo) == 0x000008, "Wrong alignment on FGzCohtmlContentPackPreviewInfo");
static_assert(sizeof(FGzCohtmlContentPackPreviewInfo) == 0x000070, "Wrong size on FGzCohtmlContentPackPreviewInfo");
static_assert(offsetof(FGzCohtmlContentPackPreviewInfo, Summary) == 0x000000, "Member 'FGzCohtmlContentPackPreviewInfo::Summary' has a wrong offset!");
static_assert(offsetof(FGzCohtmlContentPackPreviewInfo, RewardItems) == 0x000010, "Member 'FGzCohtmlContentPackPreviewInfo::RewardItems' has a wrong offset!");
static_assert(offsetof(FGzCohtmlContentPackPreviewInfo, BackgroundImage) == 0x000020, "Member 'FGzCohtmlContentPackPreviewInfo::BackgroundImage' has a wrong offset!");
static_assert(offsetof(FGzCohtmlContentPackPreviewInfo, AnimationVideo) == 0x000030, "Member 'FGzCohtmlContentPackPreviewInfo::AnimationVideo' has a wrong offset!");
static_assert(offsetof(FGzCohtmlContentPackPreviewInfo, ItemsImage) == 0x000040, "Member 'FGzCohtmlContentPackPreviewInfo::ItemsImage' has a wrong offset!");
static_assert(offsetof(FGzCohtmlContentPackPreviewInfo, PackPreviewImage) == 0x000050, "Member 'FGzCohtmlContentPackPreviewInfo::PackPreviewImage' has a wrong offset!");
static_assert(offsetof(FGzCohtmlContentPackPreviewInfo, PackPreviewSecondaryImage) == 0x000060, "Member 'FGzCohtmlContentPackPreviewInfo::PackPreviewSecondaryImage' has a wrong offset!");

// ScriptStruct G01.GzMetaBasicOnlineItemDisplayProperties
// 0x0020 (0x0020 - 0x0000)
struct FGzMetaBasicOnlineItemDisplayProperties
{
public:
	class FString                                 AssetId;                                           // 0x0000(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 ItemSource;                                        // 0x0010(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzMetaBasicOnlineItemDisplayProperties) == 0x000008, "Wrong alignment on FGzMetaBasicOnlineItemDisplayProperties");
static_assert(sizeof(FGzMetaBasicOnlineItemDisplayProperties) == 0x000020, "Wrong size on FGzMetaBasicOnlineItemDisplayProperties");
static_assert(offsetof(FGzMetaBasicOnlineItemDisplayProperties, AssetId) == 0x000000, "Member 'FGzMetaBasicOnlineItemDisplayProperties::AssetId' has a wrong offset!");
static_assert(offsetof(FGzMetaBasicOnlineItemDisplayProperties, ItemSource) == 0x000010, "Member 'FGzMetaBasicOnlineItemDisplayProperties::ItemSource' has a wrong offset!");

// ScriptStruct G01.GzOnlineInventoryItemDisplayProperties
// 0x0060 (0x0080 - 0x0020)
struct FGzOnlineInventoryItemDisplayProperties final : public FGzMetaBasicOnlineItemDisplayProperties
{
public:
	class FString                                 NftId;                                             // 0x0020(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsDecoding;                                        // 0x0030(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2B5C[0x7];                                     // 0x0031(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 SeasonId;                                          // 0x0038(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FDateTime                              Updated;                                           // 0x0048(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 BattlePassId;                                      // 0x0050(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsListedOnMarket;                                  // 0x0060(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EGzMarketplaceState                           MarketplaceState;                                  // 0x0061(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2B5D[0x6];                                     // 0x0062(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	struct FDateTime                              CreatedAt;                                         // 0x0068(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int64                                         SerialNumber;                                      // 0x0070(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FDateTime                              LastTradeTimestamp;                                // 0x0078(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzOnlineInventoryItemDisplayProperties) == 0x000008, "Wrong alignment on FGzOnlineInventoryItemDisplayProperties");
static_assert(sizeof(FGzOnlineInventoryItemDisplayProperties) == 0x000080, "Wrong size on FGzOnlineInventoryItemDisplayProperties");
static_assert(offsetof(FGzOnlineInventoryItemDisplayProperties, NftId) == 0x000020, "Member 'FGzOnlineInventoryItemDisplayProperties::NftId' has a wrong offset!");
static_assert(offsetof(FGzOnlineInventoryItemDisplayProperties, IsDecoding) == 0x000030, "Member 'FGzOnlineInventoryItemDisplayProperties::IsDecoding' has a wrong offset!");
static_assert(offsetof(FGzOnlineInventoryItemDisplayProperties, SeasonId) == 0x000038, "Member 'FGzOnlineInventoryItemDisplayProperties::SeasonId' has a wrong offset!");
static_assert(offsetof(FGzOnlineInventoryItemDisplayProperties, Updated) == 0x000048, "Member 'FGzOnlineInventoryItemDisplayProperties::Updated' has a wrong offset!");
static_assert(offsetof(FGzOnlineInventoryItemDisplayProperties, BattlePassId) == 0x000050, "Member 'FGzOnlineInventoryItemDisplayProperties::BattlePassId' has a wrong offset!");
static_assert(offsetof(FGzOnlineInventoryItemDisplayProperties, IsListedOnMarket) == 0x000060, "Member 'FGzOnlineInventoryItemDisplayProperties::IsListedOnMarket' has a wrong offset!");
static_assert(offsetof(FGzOnlineInventoryItemDisplayProperties, MarketplaceState) == 0x000061, "Member 'FGzOnlineInventoryItemDisplayProperties::MarketplaceState' has a wrong offset!");
static_assert(offsetof(FGzOnlineInventoryItemDisplayProperties, CreatedAt) == 0x000068, "Member 'FGzOnlineInventoryItemDisplayProperties::CreatedAt' has a wrong offset!");
static_assert(offsetof(FGzOnlineInventoryItemDisplayProperties, SerialNumber) == 0x000070, "Member 'FGzOnlineInventoryItemDisplayProperties::SerialNumber' has a wrong offset!");
static_assert(offsetof(FGzOnlineInventoryItemDisplayProperties, LastTradeTimestamp) == 0x000078, "Member 'FGzOnlineInventoryItemDisplayProperties::LastTradeTimestamp' has a wrong offset!");

// ScriptStruct G01.GzPlayFabBlockchainDecodeV2Notification
// 0x0038 (0x0058 - 0x0020)
struct FGzPlayFabBlockchainDecodeV2Notification final : public FGzPlayFabNotification
{
public:
	class FString                                 AssetId;                                           // 0x0020(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   ItemInstanceId;                                    // 0x0030(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 NftId;                                             // 0x0038(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 DatacubeInstanceId;                                // 0x0048(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzPlayFabBlockchainDecodeV2Notification) == 0x000008, "Wrong alignment on FGzPlayFabBlockchainDecodeV2Notification");
static_assert(sizeof(FGzPlayFabBlockchainDecodeV2Notification) == 0x000058, "Wrong size on FGzPlayFabBlockchainDecodeV2Notification");
static_assert(offsetof(FGzPlayFabBlockchainDecodeV2Notification, AssetId) == 0x000020, "Member 'FGzPlayFabBlockchainDecodeV2Notification::AssetId' has a wrong offset!");
static_assert(offsetof(FGzPlayFabBlockchainDecodeV2Notification, ItemInstanceId) == 0x000030, "Member 'FGzPlayFabBlockchainDecodeV2Notification::ItemInstanceId' has a wrong offset!");
static_assert(offsetof(FGzPlayFabBlockchainDecodeV2Notification, NftId) == 0x000038, "Member 'FGzPlayFabBlockchainDecodeV2Notification::NftId' has a wrong offset!");
static_assert(offsetof(FGzPlayFabBlockchainDecodeV2Notification, DatacubeInstanceId) == 0x000048, "Member 'FGzPlayFabBlockchainDecodeV2Notification::DatacubeInstanceId' has a wrong offset!");

// ScriptStruct G01.GzCohtmlTradeRateValidation
// 0x0018 (0x0018 - 0x0000)
struct FGzCohtmlTradeRateValidation final
{
public:
	uint32                                        AvailableTrades;                                   // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2B5E[0x4];                                     // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 EndOfCooldownTime;                                 // 0x0008(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzCohtmlTradeRateValidation) == 0x000008, "Wrong alignment on FGzCohtmlTradeRateValidation");
static_assert(sizeof(FGzCohtmlTradeRateValidation) == 0x000018, "Wrong size on FGzCohtmlTradeRateValidation");
static_assert(offsetof(FGzCohtmlTradeRateValidation, AvailableTrades) == 0x000000, "Member 'FGzCohtmlTradeRateValidation::AvailableTrades' has a wrong offset!");
static_assert(offsetof(FGzCohtmlTradeRateValidation, EndOfCooldownTime) == 0x000008, "Member 'FGzCohtmlTradeRateValidation::EndOfCooldownTime' has a wrong offset!");

// ScriptStruct G01.CohtmlVirtualCurrencyPackage
// 0x0068 (0x0068 - 0x0000)
struct FCohtmlVirtualCurrencyPackage final
{
public:
	class FString                                 Sku;                                               // 0x0000(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Name;                                              // 0x0010(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Description;                                       // 0x0020(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         CurrencyQuantity;                                  // 0x0030(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2B5F[0x4];                                     // 0x0034(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FCohtmlXsollaPrice                     Price;                                             // 0x0038(0x0030)(NativeAccessSpecifierPublic)
};
static_assert(alignof(FCohtmlVirtualCurrencyPackage) == 0x000008, "Wrong alignment on FCohtmlVirtualCurrencyPackage");
static_assert(sizeof(FCohtmlVirtualCurrencyPackage) == 0x000068, "Wrong size on FCohtmlVirtualCurrencyPackage");
static_assert(offsetof(FCohtmlVirtualCurrencyPackage, Sku) == 0x000000, "Member 'FCohtmlVirtualCurrencyPackage::Sku' has a wrong offset!");
static_assert(offsetof(FCohtmlVirtualCurrencyPackage, Name) == 0x000010, "Member 'FCohtmlVirtualCurrencyPackage::Name' has a wrong offset!");
static_assert(offsetof(FCohtmlVirtualCurrencyPackage, Description) == 0x000020, "Member 'FCohtmlVirtualCurrencyPackage::Description' has a wrong offset!");
static_assert(offsetof(FCohtmlVirtualCurrencyPackage, CurrencyQuantity) == 0x000030, "Member 'FCohtmlVirtualCurrencyPackage::CurrencyQuantity' has a wrong offset!");
static_assert(offsetof(FCohtmlVirtualCurrencyPackage, Price) == 0x000038, "Member 'FCohtmlVirtualCurrencyPackage::Price' has a wrong offset!");

// ScriptStruct G01.GzPackageCheatCompleteChallenge
// 0x0020 (0x0088 - 0x0068)
struct FGzPackageCheatCompleteChallenge final : public FGzPlayFabClientPackage
{
public:
	class FString                                 ChallengeId;                                       // 0x0068(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 ChallengeType;                                     // 0x0078(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzPackageCheatCompleteChallenge) == 0x000008, "Wrong alignment on FGzPackageCheatCompleteChallenge");
static_assert(sizeof(FGzPackageCheatCompleteChallenge) == 0x000088, "Wrong size on FGzPackageCheatCompleteChallenge");
static_assert(offsetof(FGzPackageCheatCompleteChallenge, ChallengeId) == 0x000068, "Member 'FGzPackageCheatCompleteChallenge::ChallengeId' has a wrong offset!");
static_assert(offsetof(FGzPackageCheatCompleteChallenge, ChallengeType) == 0x000078, "Member 'FGzPackageCheatCompleteChallenge::ChallengeType' has a wrong offset!");

// ScriptStruct G01.GzDailyRewardNotification
// 0x00D8 (0x00F8 - 0x0020)
struct FGzDailyRewardNotification final : public FGzPlayFabNotification
{
public:
	int32                                         Day;                                               // 0x0020(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2B60[0x4];                                     // 0x0024(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGzCombinedReward                      Reward;                                            // 0x0028(0x00D0)(NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzDailyRewardNotification) == 0x000008, "Wrong alignment on FGzDailyRewardNotification");
static_assert(sizeof(FGzDailyRewardNotification) == 0x0000F8, "Wrong size on FGzDailyRewardNotification");
static_assert(offsetof(FGzDailyRewardNotification, Day) == 0x000020, "Member 'FGzDailyRewardNotification::Day' has a wrong offset!");
static_assert(offsetof(FGzDailyRewardNotification, Reward) == 0x000028, "Member 'FGzDailyRewardNotification::Reward' has a wrong offset!");

// ScriptStruct G01.GzCohtmlWeaponConfigurationCollection
// 0x0050 (0x0050 - 0x0000)
struct FGzCohtmlWeaponConfigurationCollection final
{
public:
	TMap<class FString, struct FGzCohtmlWeaponConfiguration> Configurations;                                    // 0x0000(0x0050)(NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzCohtmlWeaponConfigurationCollection) == 0x000008, "Wrong alignment on FGzCohtmlWeaponConfigurationCollection");
static_assert(sizeof(FGzCohtmlWeaponConfigurationCollection) == 0x000050, "Wrong size on FGzCohtmlWeaponConfigurationCollection");
static_assert(offsetof(FGzCohtmlWeaponConfigurationCollection, Configurations) == 0x000000, "Member 'FGzCohtmlWeaponConfigurationCollection::Configurations' has a wrong offset!");

// ScriptStruct G01.GzCohtmlWeaponItemData
// 0x0240 (0x0388 - 0x0148)
struct FGzCohtmlWeaponItemData final : public FGzCohtmlItemData
{
public:
	class FString                                 WeaponType;                                        // 0x0148(0x0010)(ZeroConstructor, Transient, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 WeaponArchetype;                                   // 0x0158(0x0010)(ZeroConstructor, Transient, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMap<class FString, struct FGzCohtmlSuitableAttachmentsCategory> SuitableAndDefaultAttachments;                     // 0x0168(0x0050)(Transient, NativeAccessSpecifierPublic)
	struct FGzCohtmlWeaponSkinItemData            DefaultSkin;                                       // 0x01B8(0x0148)(Transient, NativeAccessSpecifierPublic)
	TArray<struct FGzCohtmlWeaponSkinItemData>    SuitableSkins;                                     // 0x0300(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPublic)
	TMap<class FString, struct FGzCohtmlWeaponAttachmentItemData> DefaultAttachmentsOverrides;                       // 0x0310(0x0050)(Transient, NativeAccessSpecifierPublic)
	TArray<class FString>                         NonModifiableSlots;                                // 0x0360(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPublic)
	class FString                                 WeaponSetup;                                       // 0x0370(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsUnique;                                          // 0x0380(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsSkinChangeAllowed;                               // 0x0381(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2B61[0x6];                                     // 0x0382(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGzCohtmlWeaponItemData) == 0x000008, "Wrong alignment on FGzCohtmlWeaponItemData");
static_assert(sizeof(FGzCohtmlWeaponItemData) == 0x000388, "Wrong size on FGzCohtmlWeaponItemData");
static_assert(offsetof(FGzCohtmlWeaponItemData, WeaponType) == 0x000148, "Member 'FGzCohtmlWeaponItemData::WeaponType' has a wrong offset!");
static_assert(offsetof(FGzCohtmlWeaponItemData, WeaponArchetype) == 0x000158, "Member 'FGzCohtmlWeaponItemData::WeaponArchetype' has a wrong offset!");
static_assert(offsetof(FGzCohtmlWeaponItemData, SuitableAndDefaultAttachments) == 0x000168, "Member 'FGzCohtmlWeaponItemData::SuitableAndDefaultAttachments' has a wrong offset!");
static_assert(offsetof(FGzCohtmlWeaponItemData, DefaultSkin) == 0x0001B8, "Member 'FGzCohtmlWeaponItemData::DefaultSkin' has a wrong offset!");
static_assert(offsetof(FGzCohtmlWeaponItemData, SuitableSkins) == 0x000300, "Member 'FGzCohtmlWeaponItemData::SuitableSkins' has a wrong offset!");
static_assert(offsetof(FGzCohtmlWeaponItemData, DefaultAttachmentsOverrides) == 0x000310, "Member 'FGzCohtmlWeaponItemData::DefaultAttachmentsOverrides' has a wrong offset!");
static_assert(offsetof(FGzCohtmlWeaponItemData, NonModifiableSlots) == 0x000360, "Member 'FGzCohtmlWeaponItemData::NonModifiableSlots' has a wrong offset!");
static_assert(offsetof(FGzCohtmlWeaponItemData, WeaponSetup) == 0x000370, "Member 'FGzCohtmlWeaponItemData::WeaponSetup' has a wrong offset!");
static_assert(offsetof(FGzCohtmlWeaponItemData, IsUnique) == 0x000380, "Member 'FGzCohtmlWeaponItemData::IsUnique' has a wrong offset!");
static_assert(offsetof(FGzCohtmlWeaponItemData, IsSkinChangeAllowed) == 0x000381, "Member 'FGzCohtmlWeaponItemData::IsSkinChangeAllowed' has a wrong offset!");

// ScriptStruct G01.GzMetaMarketplaceItemOfferInfo
// 0x0028 (0x0028 - 0x0000)
struct FGzMetaMarketplaceItemOfferInfo final
{
public:
	class FString                                 ExpirationDateTime;                                // 0x0000(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	double                                        HardCurrencyPrice;                                 // 0x0010(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 NftId;                                             // 0x0018(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzMetaMarketplaceItemOfferInfo) == 0x000008, "Wrong alignment on FGzMetaMarketplaceItemOfferInfo");
static_assert(sizeof(FGzMetaMarketplaceItemOfferInfo) == 0x000028, "Wrong size on FGzMetaMarketplaceItemOfferInfo");
static_assert(offsetof(FGzMetaMarketplaceItemOfferInfo, ExpirationDateTime) == 0x000000, "Member 'FGzMetaMarketplaceItemOfferInfo::ExpirationDateTime' has a wrong offset!");
static_assert(offsetof(FGzMetaMarketplaceItemOfferInfo, HardCurrencyPrice) == 0x000010, "Member 'FGzMetaMarketplaceItemOfferInfo::HardCurrencyPrice' has a wrong offset!");
static_assert(offsetof(FGzMetaMarketplaceItemOfferInfo, NftId) == 0x000018, "Member 'FGzMetaMarketplaceItemOfferInfo::NftId' has a wrong offset!");

// ScriptStruct G01.GzPackageSaveAchievementsProgress
// 0x0010 (0x0098 - 0x0088)
struct FGzPackageSaveAchievementsProgress final : public FGzPlayFabServerPackage
{
public:
	TArray<struct FGzBackendSavedAchievementProgress> AchievementProgresses;                             // 0x0088(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzPackageSaveAchievementsProgress) == 0x000008, "Wrong alignment on FGzPackageSaveAchievementsProgress");
static_assert(sizeof(FGzPackageSaveAchievementsProgress) == 0x000098, "Wrong size on FGzPackageSaveAchievementsProgress");
static_assert(offsetof(FGzPackageSaveAchievementsProgress, AchievementProgresses) == 0x000088, "Member 'FGzPackageSaveAchievementsProgress::AchievementProgresses' has a wrong offset!");

// ScriptStruct G01.GzColorPaletteContainer
// 0x0008 (0x0008 - 0x0000)
struct FGzColorPaletteContainer final
{
public:
	class UGzColorPalette*                        Palette;                                           // 0x0000(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
};
static_assert(alignof(FGzColorPaletteContainer) == 0x000008, "Wrong alignment on FGzColorPaletteContainer");
static_assert(sizeof(FGzColorPaletteContainer) == 0x000008, "Wrong size on FGzColorPaletteContainer");
static_assert(offsetof(FGzColorPaletteContainer, Palette) == 0x000000, "Member 'FGzColorPaletteContainer::Palette' has a wrong offset!");

// ScriptStruct G01.GzPackageConsolePlayerAuth
// 0x0020 (0x0088 - 0x0068)
struct FGzPackageConsolePlayerAuth final : public FGzPlayFabClientPackage
{
public:
	class FString                                 PlayerAccountId;                                   // 0x0068(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 AuthCode;                                          // 0x0078(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzPackageConsolePlayerAuth) == 0x000008, "Wrong alignment on FGzPackageConsolePlayerAuth");
static_assert(sizeof(FGzPackageConsolePlayerAuth) == 0x000088, "Wrong size on FGzPackageConsolePlayerAuth");
static_assert(offsetof(FGzPackageConsolePlayerAuth, PlayerAccountId) == 0x000068, "Member 'FGzPackageConsolePlayerAuth::PlayerAccountId' has a wrong offset!");
static_assert(offsetof(FGzPackageConsolePlayerAuth, AuthCode) == 0x000078, "Member 'FGzPackageConsolePlayerAuth::AuthCode' has a wrong offset!");

// ScriptStruct G01.GzLootTableVariant
// 0x00A0 (0x00A0 - 0x0000)
struct FGzLootTableVariant final
{
public:
	EGzItemType                                   RewardPoolType;                                    // 0x0000(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2B62[0x3];                                     // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTag                           RewardPoolSubtype;                                 // 0x0004(0x0008)(Edit, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2B63[0x4];                                     // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftObjectPtr<class UGzWeaponArchetype>      RewardWeaponArchetype;                             // 0x0010(0x0028)(Edit, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UGzBodyPartArchetype>    RewardBodyPartArchetype;                           // 0x0038(0x0028)(Edit, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UGzItemData>             DirectRewardItem;                                  // 0x0060(0x0028)(Edit, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<EGzItemCollectionType>                 CollectionType;                                    // 0x0088(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	bool                                          bUsePartItems;                                     // 0x0098(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2B64[0x7];                                     // 0x0099(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGzLootTableVariant) == 0x000008, "Wrong alignment on FGzLootTableVariant");
static_assert(sizeof(FGzLootTableVariant) == 0x0000A0, "Wrong size on FGzLootTableVariant");
static_assert(offsetof(FGzLootTableVariant, RewardPoolType) == 0x000000, "Member 'FGzLootTableVariant::RewardPoolType' has a wrong offset!");
static_assert(offsetof(FGzLootTableVariant, RewardPoolSubtype) == 0x000004, "Member 'FGzLootTableVariant::RewardPoolSubtype' has a wrong offset!");
static_assert(offsetof(FGzLootTableVariant, RewardWeaponArchetype) == 0x000010, "Member 'FGzLootTableVariant::RewardWeaponArchetype' has a wrong offset!");
static_assert(offsetof(FGzLootTableVariant, RewardBodyPartArchetype) == 0x000038, "Member 'FGzLootTableVariant::RewardBodyPartArchetype' has a wrong offset!");
static_assert(offsetof(FGzLootTableVariant, DirectRewardItem) == 0x000060, "Member 'FGzLootTableVariant::DirectRewardItem' has a wrong offset!");
static_assert(offsetof(FGzLootTableVariant, CollectionType) == 0x000088, "Member 'FGzLootTableVariant::CollectionType' has a wrong offset!");
static_assert(offsetof(FGzLootTableVariant, bUsePartItems) == 0x000098, "Member 'FGzLootTableVariant::bUsePartItems' has a wrong offset!");

// ScriptStruct G01.GzMetaScheduledChallenge
// 0x0010 (0x0010 - 0x0000)
struct FGzMetaScheduledChallenge final
{
public:
	class UGzChallengeTemplate*                   ChallengeTemplate;                                 // 0x0000(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Progress;                                          // 0x0008(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsCompleted;                                       // 0x000C(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2B65[0x3];                                     // 0x000D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGzMetaScheduledChallenge) == 0x000008, "Wrong alignment on FGzMetaScheduledChallenge");
static_assert(sizeof(FGzMetaScheduledChallenge) == 0x000010, "Wrong size on FGzMetaScheduledChallenge");
static_assert(offsetof(FGzMetaScheduledChallenge, ChallengeTemplate) == 0x000000, "Member 'FGzMetaScheduledChallenge::ChallengeTemplate' has a wrong offset!");
static_assert(offsetof(FGzMetaScheduledChallenge, Progress) == 0x000008, "Member 'FGzMetaScheduledChallenge::Progress' has a wrong offset!");
static_assert(offsetof(FGzMetaScheduledChallenge, IsCompleted) == 0x00000C, "Member 'FGzMetaScheduledChallenge::IsCompleted' has a wrong offset!");

// ScriptStruct G01.GzPackageCustomizationAppearanceSetActivePresetId
// 0x0030 (0x0030 - 0x0000)
struct FGzPackageCustomizationAppearanceSetActivePresetId final
{
public:
	class FString                                 PlayFabId;                                         // 0x0000(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 CharacterId;                                       // 0x0010(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGzPackageCustomizationAppearanceActivePresetId Customization;                                     // 0x0020(0x0010)(NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzPackageCustomizationAppearanceSetActivePresetId) == 0x000008, "Wrong alignment on FGzPackageCustomizationAppearanceSetActivePresetId");
static_assert(sizeof(FGzPackageCustomizationAppearanceSetActivePresetId) == 0x000030, "Wrong size on FGzPackageCustomizationAppearanceSetActivePresetId");
static_assert(offsetof(FGzPackageCustomizationAppearanceSetActivePresetId, PlayFabId) == 0x000000, "Member 'FGzPackageCustomizationAppearanceSetActivePresetId::PlayFabId' has a wrong offset!");
static_assert(offsetof(FGzPackageCustomizationAppearanceSetActivePresetId, CharacterId) == 0x000010, "Member 'FGzPackageCustomizationAppearanceSetActivePresetId::CharacterId' has a wrong offset!");
static_assert(offsetof(FGzPackageCustomizationAppearanceSetActivePresetId, Customization) == 0x000020, "Member 'FGzPackageCustomizationAppearanceSetActivePresetId::Customization' has a wrong offset!");

// ScriptStruct G01.GzWeaponAttachmentVisuals
// 0x0078 (0x0078 - 0x0000)
struct FGzWeaponAttachmentVisuals final
{
public:
	TSoftObjectPtr<class UStaticMesh>             StaticMesh;                                        // 0x0000(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class USkeletalMesh>           SkeletalMesh;                                      // 0x0028(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UMaterialInterface>      Material;                                          // 0x0050(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzWeaponAttachmentVisuals) == 0x000008, "Wrong alignment on FGzWeaponAttachmentVisuals");
static_assert(sizeof(FGzWeaponAttachmentVisuals) == 0x000078, "Wrong size on FGzWeaponAttachmentVisuals");
static_assert(offsetof(FGzWeaponAttachmentVisuals, StaticMesh) == 0x000000, "Member 'FGzWeaponAttachmentVisuals::StaticMesh' has a wrong offset!");
static_assert(offsetof(FGzWeaponAttachmentVisuals, SkeletalMesh) == 0x000028, "Member 'FGzWeaponAttachmentVisuals::SkeletalMesh' has a wrong offset!");
static_assert(offsetof(FGzWeaponAttachmentVisuals, Material) == 0x000050, "Member 'FGzWeaponAttachmentVisuals::Material' has a wrong offset!");

// ScriptStruct G01.GzCustomizationAudioEvents
// 0x0018 (0x0018 - 0x0000)
struct FGzCustomizationAudioEvents final
{
public:
	class UAkAudioEvent*                          PlayEventLong;                                     // 0x0000(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAkAudioEvent*                          StopEventLong;                                     // 0x0008(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAkAudioEvent*                          PlayEventShort;                                    // 0x0010(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzCustomizationAudioEvents) == 0x000008, "Wrong alignment on FGzCustomizationAudioEvents");
static_assert(sizeof(FGzCustomizationAudioEvents) == 0x000018, "Wrong size on FGzCustomizationAudioEvents");
static_assert(offsetof(FGzCustomizationAudioEvents, PlayEventLong) == 0x000000, "Member 'FGzCustomizationAudioEvents::PlayEventLong' has a wrong offset!");
static_assert(offsetof(FGzCustomizationAudioEvents, StopEventLong) == 0x000008, "Member 'FGzCustomizationAudioEvents::StopEventLong' has a wrong offset!");
static_assert(offsetof(FGzCustomizationAudioEvents, PlayEventShort) == 0x000010, "Member 'FGzCustomizationAudioEvents::PlayEventShort' has a wrong offset!");

// ScriptStruct G01.GzPackageCheatChallengeToReset
// 0x0020 (0x0020 - 0x0000)
struct FGzPackageCheatChallengeToReset final
{
public:
	class FString                                 ID;                                                // 0x0000(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 ChallengeType;                                     // 0x0010(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzPackageCheatChallengeToReset) == 0x000008, "Wrong alignment on FGzPackageCheatChallengeToReset");
static_assert(sizeof(FGzPackageCheatChallengeToReset) == 0x000020, "Wrong size on FGzPackageCheatChallengeToReset");
static_assert(offsetof(FGzPackageCheatChallengeToReset, ID) == 0x000000, "Member 'FGzPackageCheatChallengeToReset::ID' has a wrong offset!");
static_assert(offsetof(FGzPackageCheatChallengeToReset, ChallengeType) == 0x000010, "Member 'FGzPackageCheatChallengeToReset::ChallengeType' has a wrong offset!");

// ScriptStruct G01.GzVectorRange
// 0x0030 (0x0030 - 0x0000)
struct FGzVectorRange final
{
public:
	struct FFloatRange                            XValueRange;                                       // 0x0000(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FFloatRange                            YValueRange;                                       // 0x0010(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FFloatRange                            ZValueRange;                                       // 0x0020(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzVectorRange) == 0x000004, "Wrong alignment on FGzVectorRange");
static_assert(sizeof(FGzVectorRange) == 0x000030, "Wrong size on FGzVectorRange");
static_assert(offsetof(FGzVectorRange, XValueRange) == 0x000000, "Member 'FGzVectorRange::XValueRange' has a wrong offset!");
static_assert(offsetof(FGzVectorRange, YValueRange) == 0x000010, "Member 'FGzVectorRange::YValueRange' has a wrong offset!");
static_assert(offsetof(FGzVectorRange, ZValueRange) == 0x000020, "Member 'FGzVectorRange::ZValueRange' has a wrong offset!");

// ScriptStruct G01.GzPackageGetMarketplaceItemsInfo
// 0x0010 (0x0078 - 0x0068)
struct FGzPackageGetMarketplaceItemsInfo final : public FGzPlayFabClientPackage
{
public:
	TArray<class FString>                         AssetIds;                                          // 0x0068(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzPackageGetMarketplaceItemsInfo) == 0x000008, "Wrong alignment on FGzPackageGetMarketplaceItemsInfo");
static_assert(sizeof(FGzPackageGetMarketplaceItemsInfo) == 0x000078, "Wrong size on FGzPackageGetMarketplaceItemsInfo");
static_assert(offsetof(FGzPackageGetMarketplaceItemsInfo, AssetIds) == 0x000068, "Member 'FGzPackageGetMarketplaceItemsInfo::AssetIds' has a wrong offset!");

// ScriptStruct G01.GzScopeGlintConfig
// 0x0020 (0x0020 - 0x0000)
struct FGzScopeGlintConfig final
{
public:
	struct FFloatRange                            ScopeZoomLevel;                                    // 0x0000(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   ScopeGlintSizeParamName;                           // 0x0010(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ScopeGlintScaleSize;                               // 0x0018(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxVisibleDistance;                                // 0x001C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzScopeGlintConfig) == 0x000004, "Wrong alignment on FGzScopeGlintConfig");
static_assert(sizeof(FGzScopeGlintConfig) == 0x000020, "Wrong size on FGzScopeGlintConfig");
static_assert(offsetof(FGzScopeGlintConfig, ScopeZoomLevel) == 0x000000, "Member 'FGzScopeGlintConfig::ScopeZoomLevel' has a wrong offset!");
static_assert(offsetof(FGzScopeGlintConfig, ScopeGlintSizeParamName) == 0x000010, "Member 'FGzScopeGlintConfig::ScopeGlintSizeParamName' has a wrong offset!");
static_assert(offsetof(FGzScopeGlintConfig, ScopeGlintScaleSize) == 0x000018, "Member 'FGzScopeGlintConfig::ScopeGlintScaleSize' has a wrong offset!");
static_assert(offsetof(FGzScopeGlintConfig, MaxVisibleDistance) == 0x00001C, "Member 'FGzScopeGlintConfig::MaxVisibleDistance' has a wrong offset!");

// ScriptStruct G01.GzFastStaticDamageableItem
// 0x0010 (0x0010 - 0x0000)
struct FGzFastStaticDamageableItem final
{
public:
	class UGzDamageableStaticMeshComponent*       StaticDamageableMesh;                              // 0x0000(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsRuined;                                         // 0x0008(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2B66[0x3];                                     // 0x0009(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         ChosenIndex;                                       // 0x000C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzFastStaticDamageableItem) == 0x000008, "Wrong alignment on FGzFastStaticDamageableItem");
static_assert(sizeof(FGzFastStaticDamageableItem) == 0x000010, "Wrong size on FGzFastStaticDamageableItem");
static_assert(offsetof(FGzFastStaticDamageableItem, StaticDamageableMesh) == 0x000000, "Member 'FGzFastStaticDamageableItem::StaticDamageableMesh' has a wrong offset!");
static_assert(offsetof(FGzFastStaticDamageableItem, bIsRuined) == 0x000008, "Member 'FGzFastStaticDamageableItem::bIsRuined' has a wrong offset!");
static_assert(offsetof(FGzFastStaticDamageableItem, ChosenIndex) == 0x00000C, "Member 'FGzFastStaticDamageableItem::ChosenIndex' has a wrong offset!");

// ScriptStruct G01.GzLocalGameSettings
// 0x0168 (0x0168 - 0x0000)
struct FGzLocalGameSettings final
{
public:
	EWindowMode                                   WindowMode;                                        // 0x0000(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2B67[0x3];                                     // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FIntPoint                              ScreenResolution;                                  // 0x0004(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FrameRateLimit;                                    // 0x000C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         DisplayIndex;                                      // 0x0010(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ViewDistanceQuality;                               // 0x0014(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         AntiAliasingQuality;                               // 0x0018(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         TextureQuality;                                    // 0x001C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ShadowQuality;                                     // 0x0020(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         EffectsQuality;                                    // 0x0024(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         GlobalIlluminationQuality;                         // 0x0028(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ReflectionQuality;                                 // 0x002C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         PostProcessQuality;                                // 0x0030(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         FoliageQuality;                                    // 0x0034(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ShadingQuality;                                    // 0x0038(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DisplayGamma;                                      // 0x003C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseVSync;                                         // 0x0040(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2B68[0x7];                                     // 0x0041(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 ResolutionScalingMethod;                           // 0x0048(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ResolutionScaleValue;                              // 0x0058(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         AntiAliasingMethod;                                // 0x005C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         DLSSMode;                                          // 0x0060(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2B69[0x3];                                     // 0x0061(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         FSRQualityMode;                                    // 0x0064(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EGzMetalFxQualityMode                         MetalFxQualityMode;                                // 0x0068(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEnableHDROutput;                                  // 0x0069(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2B6A[0x2];                                     // 0x006A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         HorizontalLookSensitivityScaleFactor;              // 0x006C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         VerticalLookSensitivityScaleFactor;                // 0x0070(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HorizontalAimSensitivityScaleFactor;               // 0x0074(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         VerticalAimSensitivityScaleFactor;                 // 0x0078(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HorizontalSnipeSensitivityScaleFactor;             // 0x007C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         VerticalSnipeSensitivityScaleFactor;               // 0x0080(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         GamepadHorizontalLookSensitivityScale;             // 0x0084(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         GamepadVerticalLookSensitivityScale;               // 0x0088(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         GamepadHorizontalAimSensitivityScale;              // 0x008C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         GamepadVerticalAimSensitivityScale;                // 0x0090(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         GamepadHorizontalSnipeSensitivityScale;            // 0x0094(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         GamepadVerticalSnipeSensitivityScale;              // 0x0098(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DeadZone;                                          // 0x009C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bHorizontalInputInverted;                          // 0x00A0(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bVerticalInputInverted;                            // 0x00A1(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bToggleSprint;                                     // 0x00A2(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bToggleAimingMode;                                 // 0x00A3(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         UIAspectRatio;                                     // 0x00A4(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShowDamageNumbers;                                // 0x00A8(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShowComparisonTooltip;                            // 0x00A9(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShowLobbyOldScreenEffect;                         // 0x00AA(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAlignMinimap;                                     // 0x00AB(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MainVolumeScaleFactor;                             // 0x00AC(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MusicVolumeScaleFactor;                            // 0x00B0(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SfxVolumeScaleFactor;                              // 0x00B4(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         VovVolumeScaleFactor;                              // 0x00B8(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MatchStateAnnouncerVolumeScaleFactor;              // 0x00BC(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PersonalAssistantVolumeScaleFactor;                // 0x00C0(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CharacterVoiceVolumeScaleFactor;                   // 0x00C4(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         VoiceChatVolumeScale;                              // 0x00C8(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MicrophoneSensitivity;                             // 0x00CC(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EGzVoiceChatState                             VoiceChatState;                                    // 0x00D0(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2B6B[0x7];                                     // 0x00D1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 VoiceChatInputDeviceId;                            // 0x00D8(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 VoiceChatOutputDeviceId;                           // 0x00E8(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bMuteAudioWhenUnfocused;                           // 0x00F8(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2B6C[0x7];                                     // 0x00F9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 AudioPresetName;                                   // 0x0100(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 PersonalAssistantVoiceType;                        // 0x0110(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEnableControllerVibration;                        // 0x0120(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEnableAdaptiveTriggers;                           // 0x0121(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsAdvancedInput;                                  // 0x0122(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAutomaticallyConnectToHostHideout;                // 0x0123(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEnableAutologin;                                  // 0x0124(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEnableDevNotifications;                           // 0x0125(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEnableAutoPickUp;                                 // 0x0126(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEnableSidearmAmmoAutoPickUp;                      // 0x0127(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShowLootBeams;                                    // 0x0128(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShowPerformanceStats;                             // 0x0129(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EColorVisionDeficiency                        ColorVisionDeficiency;                             // 0x012A(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2B6D[0x1];                                     // 0x012B(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         HideoutMeshMinLODQuality;                          // 0x012C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         GameMeshMinLODQuality;                             // 0x0130(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bMotionBlurActive;                                 // 0x0134(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsPerformanceMode;                                // 0x0135(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bHardwareRayTracingEnabled;                        // 0x0136(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2B6E[0x1];                                     // 0x0137(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTag                           GamepadProfileIdentifier;                          // 0x0138(0x0008)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 AimAssistPreset;                                   // 0x0140(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinLuminanceLog10;                                 // 0x0150(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MidLuminance;                                      // 0x0154(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         DisplayOutputNits;                                 // 0x0158(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AcesSceneColorMultiplier;                          // 0x015C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         GamutCompression;                                  // 0x0160(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HDRUiLevel;                                        // 0x0164(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzLocalGameSettings) == 0x000008, "Wrong alignment on FGzLocalGameSettings");
static_assert(sizeof(FGzLocalGameSettings) == 0x000168, "Wrong size on FGzLocalGameSettings");
static_assert(offsetof(FGzLocalGameSettings, WindowMode) == 0x000000, "Member 'FGzLocalGameSettings::WindowMode' has a wrong offset!");
static_assert(offsetof(FGzLocalGameSettings, ScreenResolution) == 0x000004, "Member 'FGzLocalGameSettings::ScreenResolution' has a wrong offset!");
static_assert(offsetof(FGzLocalGameSettings, FrameRateLimit) == 0x00000C, "Member 'FGzLocalGameSettings::FrameRateLimit' has a wrong offset!");
static_assert(offsetof(FGzLocalGameSettings, DisplayIndex) == 0x000010, "Member 'FGzLocalGameSettings::DisplayIndex' has a wrong offset!");
static_assert(offsetof(FGzLocalGameSettings, ViewDistanceQuality) == 0x000014, "Member 'FGzLocalGameSettings::ViewDistanceQuality' has a wrong offset!");
static_assert(offsetof(FGzLocalGameSettings, AntiAliasingQuality) == 0x000018, "Member 'FGzLocalGameSettings::AntiAliasingQuality' has a wrong offset!");
static_assert(offsetof(FGzLocalGameSettings, TextureQuality) == 0x00001C, "Member 'FGzLocalGameSettings::TextureQuality' has a wrong offset!");
static_assert(offsetof(FGzLocalGameSettings, ShadowQuality) == 0x000020, "Member 'FGzLocalGameSettings::ShadowQuality' has a wrong offset!");
static_assert(offsetof(FGzLocalGameSettings, EffectsQuality) == 0x000024, "Member 'FGzLocalGameSettings::EffectsQuality' has a wrong offset!");
static_assert(offsetof(FGzLocalGameSettings, GlobalIlluminationQuality) == 0x000028, "Member 'FGzLocalGameSettings::GlobalIlluminationQuality' has a wrong offset!");
static_assert(offsetof(FGzLocalGameSettings, ReflectionQuality) == 0x00002C, "Member 'FGzLocalGameSettings::ReflectionQuality' has a wrong offset!");
static_assert(offsetof(FGzLocalGameSettings, PostProcessQuality) == 0x000030, "Member 'FGzLocalGameSettings::PostProcessQuality' has a wrong offset!");
static_assert(offsetof(FGzLocalGameSettings, FoliageQuality) == 0x000034, "Member 'FGzLocalGameSettings::FoliageQuality' has a wrong offset!");
static_assert(offsetof(FGzLocalGameSettings, ShadingQuality) == 0x000038, "Member 'FGzLocalGameSettings::ShadingQuality' has a wrong offset!");
static_assert(offsetof(FGzLocalGameSettings, DisplayGamma) == 0x00003C, "Member 'FGzLocalGameSettings::DisplayGamma' has a wrong offset!");
static_assert(offsetof(FGzLocalGameSettings, bUseVSync) == 0x000040, "Member 'FGzLocalGameSettings::bUseVSync' has a wrong offset!");
static_assert(offsetof(FGzLocalGameSettings, ResolutionScalingMethod) == 0x000048, "Member 'FGzLocalGameSettings::ResolutionScalingMethod' has a wrong offset!");
static_assert(offsetof(FGzLocalGameSettings, ResolutionScaleValue) == 0x000058, "Member 'FGzLocalGameSettings::ResolutionScaleValue' has a wrong offset!");
static_assert(offsetof(FGzLocalGameSettings, AntiAliasingMethod) == 0x00005C, "Member 'FGzLocalGameSettings::AntiAliasingMethod' has a wrong offset!");
static_assert(offsetof(FGzLocalGameSettings, DLSSMode) == 0x000060, "Member 'FGzLocalGameSettings::DLSSMode' has a wrong offset!");
static_assert(offsetof(FGzLocalGameSettings, FSRQualityMode) == 0x000064, "Member 'FGzLocalGameSettings::FSRQualityMode' has a wrong offset!");
static_assert(offsetof(FGzLocalGameSettings, MetalFxQualityMode) == 0x000068, "Member 'FGzLocalGameSettings::MetalFxQualityMode' has a wrong offset!");
static_assert(offsetof(FGzLocalGameSettings, bEnableHDROutput) == 0x000069, "Member 'FGzLocalGameSettings::bEnableHDROutput' has a wrong offset!");
static_assert(offsetof(FGzLocalGameSettings, HorizontalLookSensitivityScaleFactor) == 0x00006C, "Member 'FGzLocalGameSettings::HorizontalLookSensitivityScaleFactor' has a wrong offset!");
static_assert(offsetof(FGzLocalGameSettings, VerticalLookSensitivityScaleFactor) == 0x000070, "Member 'FGzLocalGameSettings::VerticalLookSensitivityScaleFactor' has a wrong offset!");
static_assert(offsetof(FGzLocalGameSettings, HorizontalAimSensitivityScaleFactor) == 0x000074, "Member 'FGzLocalGameSettings::HorizontalAimSensitivityScaleFactor' has a wrong offset!");
static_assert(offsetof(FGzLocalGameSettings, VerticalAimSensitivityScaleFactor) == 0x000078, "Member 'FGzLocalGameSettings::VerticalAimSensitivityScaleFactor' has a wrong offset!");
static_assert(offsetof(FGzLocalGameSettings, HorizontalSnipeSensitivityScaleFactor) == 0x00007C, "Member 'FGzLocalGameSettings::HorizontalSnipeSensitivityScaleFactor' has a wrong offset!");
static_assert(offsetof(FGzLocalGameSettings, VerticalSnipeSensitivityScaleFactor) == 0x000080, "Member 'FGzLocalGameSettings::VerticalSnipeSensitivityScaleFactor' has a wrong offset!");
static_assert(offsetof(FGzLocalGameSettings, GamepadHorizontalLookSensitivityScale) == 0x000084, "Member 'FGzLocalGameSettings::GamepadHorizontalLookSensitivityScale' has a wrong offset!");
static_assert(offsetof(FGzLocalGameSettings, GamepadVerticalLookSensitivityScale) == 0x000088, "Member 'FGzLocalGameSettings::GamepadVerticalLookSensitivityScale' has a wrong offset!");
static_assert(offsetof(FGzLocalGameSettings, GamepadHorizontalAimSensitivityScale) == 0x00008C, "Member 'FGzLocalGameSettings::GamepadHorizontalAimSensitivityScale' has a wrong offset!");
static_assert(offsetof(FGzLocalGameSettings, GamepadVerticalAimSensitivityScale) == 0x000090, "Member 'FGzLocalGameSettings::GamepadVerticalAimSensitivityScale' has a wrong offset!");
static_assert(offsetof(FGzLocalGameSettings, GamepadHorizontalSnipeSensitivityScale) == 0x000094, "Member 'FGzLocalGameSettings::GamepadHorizontalSnipeSensitivityScale' has a wrong offset!");
static_assert(offsetof(FGzLocalGameSettings, GamepadVerticalSnipeSensitivityScale) == 0x000098, "Member 'FGzLocalGameSettings::GamepadVerticalSnipeSensitivityScale' has a wrong offset!");
static_assert(offsetof(FGzLocalGameSettings, DeadZone) == 0x00009C, "Member 'FGzLocalGameSettings::DeadZone' has a wrong offset!");
static_assert(offsetof(FGzLocalGameSettings, bHorizontalInputInverted) == 0x0000A0, "Member 'FGzLocalGameSettings::bHorizontalInputInverted' has a wrong offset!");
static_assert(offsetof(FGzLocalGameSettings, bVerticalInputInverted) == 0x0000A1, "Member 'FGzLocalGameSettings::bVerticalInputInverted' has a wrong offset!");
static_assert(offsetof(FGzLocalGameSettings, bToggleSprint) == 0x0000A2, "Member 'FGzLocalGameSettings::bToggleSprint' has a wrong offset!");
static_assert(offsetof(FGzLocalGameSettings, bToggleAimingMode) == 0x0000A3, "Member 'FGzLocalGameSettings::bToggleAimingMode' has a wrong offset!");
static_assert(offsetof(FGzLocalGameSettings, UIAspectRatio) == 0x0000A4, "Member 'FGzLocalGameSettings::UIAspectRatio' has a wrong offset!");
static_assert(offsetof(FGzLocalGameSettings, bShowDamageNumbers) == 0x0000A8, "Member 'FGzLocalGameSettings::bShowDamageNumbers' has a wrong offset!");
static_assert(offsetof(FGzLocalGameSettings, bShowComparisonTooltip) == 0x0000A9, "Member 'FGzLocalGameSettings::bShowComparisonTooltip' has a wrong offset!");
static_assert(offsetof(FGzLocalGameSettings, bShowLobbyOldScreenEffect) == 0x0000AA, "Member 'FGzLocalGameSettings::bShowLobbyOldScreenEffect' has a wrong offset!");
static_assert(offsetof(FGzLocalGameSettings, bAlignMinimap) == 0x0000AB, "Member 'FGzLocalGameSettings::bAlignMinimap' has a wrong offset!");
static_assert(offsetof(FGzLocalGameSettings, MainVolumeScaleFactor) == 0x0000AC, "Member 'FGzLocalGameSettings::MainVolumeScaleFactor' has a wrong offset!");
static_assert(offsetof(FGzLocalGameSettings, MusicVolumeScaleFactor) == 0x0000B0, "Member 'FGzLocalGameSettings::MusicVolumeScaleFactor' has a wrong offset!");
static_assert(offsetof(FGzLocalGameSettings, SfxVolumeScaleFactor) == 0x0000B4, "Member 'FGzLocalGameSettings::SfxVolumeScaleFactor' has a wrong offset!");
static_assert(offsetof(FGzLocalGameSettings, VovVolumeScaleFactor) == 0x0000B8, "Member 'FGzLocalGameSettings::VovVolumeScaleFactor' has a wrong offset!");
static_assert(offsetof(FGzLocalGameSettings, MatchStateAnnouncerVolumeScaleFactor) == 0x0000BC, "Member 'FGzLocalGameSettings::MatchStateAnnouncerVolumeScaleFactor' has a wrong offset!");
static_assert(offsetof(FGzLocalGameSettings, PersonalAssistantVolumeScaleFactor) == 0x0000C0, "Member 'FGzLocalGameSettings::PersonalAssistantVolumeScaleFactor' has a wrong offset!");
static_assert(offsetof(FGzLocalGameSettings, CharacterVoiceVolumeScaleFactor) == 0x0000C4, "Member 'FGzLocalGameSettings::CharacterVoiceVolumeScaleFactor' has a wrong offset!");
static_assert(offsetof(FGzLocalGameSettings, VoiceChatVolumeScale) == 0x0000C8, "Member 'FGzLocalGameSettings::VoiceChatVolumeScale' has a wrong offset!");
static_assert(offsetof(FGzLocalGameSettings, MicrophoneSensitivity) == 0x0000CC, "Member 'FGzLocalGameSettings::MicrophoneSensitivity' has a wrong offset!");
static_assert(offsetof(FGzLocalGameSettings, VoiceChatState) == 0x0000D0, "Member 'FGzLocalGameSettings::VoiceChatState' has a wrong offset!");
static_assert(offsetof(FGzLocalGameSettings, VoiceChatInputDeviceId) == 0x0000D8, "Member 'FGzLocalGameSettings::VoiceChatInputDeviceId' has a wrong offset!");
static_assert(offsetof(FGzLocalGameSettings, VoiceChatOutputDeviceId) == 0x0000E8, "Member 'FGzLocalGameSettings::VoiceChatOutputDeviceId' has a wrong offset!");
static_assert(offsetof(FGzLocalGameSettings, bMuteAudioWhenUnfocused) == 0x0000F8, "Member 'FGzLocalGameSettings::bMuteAudioWhenUnfocused' has a wrong offset!");
static_assert(offsetof(FGzLocalGameSettings, AudioPresetName) == 0x000100, "Member 'FGzLocalGameSettings::AudioPresetName' has a wrong offset!");
static_assert(offsetof(FGzLocalGameSettings, PersonalAssistantVoiceType) == 0x000110, "Member 'FGzLocalGameSettings::PersonalAssistantVoiceType' has a wrong offset!");
static_assert(offsetof(FGzLocalGameSettings, bEnableControllerVibration) == 0x000120, "Member 'FGzLocalGameSettings::bEnableControllerVibration' has a wrong offset!");
static_assert(offsetof(FGzLocalGameSettings, bEnableAdaptiveTriggers) == 0x000121, "Member 'FGzLocalGameSettings::bEnableAdaptiveTriggers' has a wrong offset!");
static_assert(offsetof(FGzLocalGameSettings, bIsAdvancedInput) == 0x000122, "Member 'FGzLocalGameSettings::bIsAdvancedInput' has a wrong offset!");
static_assert(offsetof(FGzLocalGameSettings, bAutomaticallyConnectToHostHideout) == 0x000123, "Member 'FGzLocalGameSettings::bAutomaticallyConnectToHostHideout' has a wrong offset!");
static_assert(offsetof(FGzLocalGameSettings, bEnableAutologin) == 0x000124, "Member 'FGzLocalGameSettings::bEnableAutologin' has a wrong offset!");
static_assert(offsetof(FGzLocalGameSettings, bEnableDevNotifications) == 0x000125, "Member 'FGzLocalGameSettings::bEnableDevNotifications' has a wrong offset!");
static_assert(offsetof(FGzLocalGameSettings, bEnableAutoPickUp) == 0x000126, "Member 'FGzLocalGameSettings::bEnableAutoPickUp' has a wrong offset!");
static_assert(offsetof(FGzLocalGameSettings, bEnableSidearmAmmoAutoPickUp) == 0x000127, "Member 'FGzLocalGameSettings::bEnableSidearmAmmoAutoPickUp' has a wrong offset!");
static_assert(offsetof(FGzLocalGameSettings, bShowLootBeams) == 0x000128, "Member 'FGzLocalGameSettings::bShowLootBeams' has a wrong offset!");
static_assert(offsetof(FGzLocalGameSettings, bShowPerformanceStats) == 0x000129, "Member 'FGzLocalGameSettings::bShowPerformanceStats' has a wrong offset!");
static_assert(offsetof(FGzLocalGameSettings, ColorVisionDeficiency) == 0x00012A, "Member 'FGzLocalGameSettings::ColorVisionDeficiency' has a wrong offset!");
static_assert(offsetof(FGzLocalGameSettings, HideoutMeshMinLODQuality) == 0x00012C, "Member 'FGzLocalGameSettings::HideoutMeshMinLODQuality' has a wrong offset!");
static_assert(offsetof(FGzLocalGameSettings, GameMeshMinLODQuality) == 0x000130, "Member 'FGzLocalGameSettings::GameMeshMinLODQuality' has a wrong offset!");
static_assert(offsetof(FGzLocalGameSettings, bMotionBlurActive) == 0x000134, "Member 'FGzLocalGameSettings::bMotionBlurActive' has a wrong offset!");
static_assert(offsetof(FGzLocalGameSettings, bIsPerformanceMode) == 0x000135, "Member 'FGzLocalGameSettings::bIsPerformanceMode' has a wrong offset!");
static_assert(offsetof(FGzLocalGameSettings, bHardwareRayTracingEnabled) == 0x000136, "Member 'FGzLocalGameSettings::bHardwareRayTracingEnabled' has a wrong offset!");
static_assert(offsetof(FGzLocalGameSettings, GamepadProfileIdentifier) == 0x000138, "Member 'FGzLocalGameSettings::GamepadProfileIdentifier' has a wrong offset!");
static_assert(offsetof(FGzLocalGameSettings, AimAssistPreset) == 0x000140, "Member 'FGzLocalGameSettings::AimAssistPreset' has a wrong offset!");
static_assert(offsetof(FGzLocalGameSettings, MinLuminanceLog10) == 0x000150, "Member 'FGzLocalGameSettings::MinLuminanceLog10' has a wrong offset!");
static_assert(offsetof(FGzLocalGameSettings, MidLuminance) == 0x000154, "Member 'FGzLocalGameSettings::MidLuminance' has a wrong offset!");
static_assert(offsetof(FGzLocalGameSettings, DisplayOutputNits) == 0x000158, "Member 'FGzLocalGameSettings::DisplayOutputNits' has a wrong offset!");
static_assert(offsetof(FGzLocalGameSettings, AcesSceneColorMultiplier) == 0x00015C, "Member 'FGzLocalGameSettings::AcesSceneColorMultiplier' has a wrong offset!");
static_assert(offsetof(FGzLocalGameSettings, GamutCompression) == 0x000160, "Member 'FGzLocalGameSettings::GamutCompression' has a wrong offset!");
static_assert(offsetof(FGzLocalGameSettings, HDRUiLevel) == 0x000164, "Member 'FGzLocalGameSettings::HDRUiLevel' has a wrong offset!");

// ScriptStruct G01.GzPackageCollectClientSettingsStatistics
// 0x0168 (0x01D0 - 0x0068)
struct FGzPackageCollectClientSettingsStatistics final : public FGzPlayFabClientPackage
{
public:
	struct FGzLocalGameSettings                   Settings;                                          // 0x0068(0x0168)(NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzPackageCollectClientSettingsStatistics) == 0x000008, "Wrong alignment on FGzPackageCollectClientSettingsStatistics");
static_assert(sizeof(FGzPackageCollectClientSettingsStatistics) == 0x0001D0, "Wrong size on FGzPackageCollectClientSettingsStatistics");
static_assert(offsetof(FGzPackageCollectClientSettingsStatistics, Settings) == 0x000068, "Member 'FGzPackageCollectClientSettingsStatistics::Settings' has a wrong offset!");

// ScriptStruct G01.GzAreaAttackParams
// 0x00E0 (0x00E0 - 0x0000)
struct FGzAreaAttackParams final
{
public:
	struct FGzDamageInstigatorData                InstigatorData;                                    // 0x0000(0x0038)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	TSubclassOf<class UGzGE_BaseDamage>           DamageEffect;                                      // 0x0038(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMap<struct FGameplayTag, float>              DamageEffectMultipliers;                           // 0x0040(0x0050)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	TArray<TSubclassOf<class UGameplayEffect>>    AdditionalEffects;                                 // 0x0090(0x0010)(Edit, BlueprintVisible, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
	TArray<TSubclassOf<class UGameplayEffect>>    AdditionalPerHitEffects;                           // 0x00A0(0x0010)(Edit, BlueprintVisible, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
	TArray<EObjectTypeQuery>                      TraceObjectTypes;                                  // 0x00B0(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class AActor*>                         ActorsToIgnore;                                    // 0x00C0(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          bDistributeDamageBetweenTraces;                    // 0x00D0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2B6F[0x3];                                     // 0x00D1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ExplosionRadius;                                   // 0x00D4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAllowFriendlyFire;                                // 0x00D8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDrawDebug;                                        // 0x00D9(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2B70[0x6];                                     // 0x00DA(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGzAreaAttackParams) == 0x000008, "Wrong alignment on FGzAreaAttackParams");
static_assert(sizeof(FGzAreaAttackParams) == 0x0000E0, "Wrong size on FGzAreaAttackParams");
static_assert(offsetof(FGzAreaAttackParams, InstigatorData) == 0x000000, "Member 'FGzAreaAttackParams::InstigatorData' has a wrong offset!");
static_assert(offsetof(FGzAreaAttackParams, DamageEffect) == 0x000038, "Member 'FGzAreaAttackParams::DamageEffect' has a wrong offset!");
static_assert(offsetof(FGzAreaAttackParams, DamageEffectMultipliers) == 0x000040, "Member 'FGzAreaAttackParams::DamageEffectMultipliers' has a wrong offset!");
static_assert(offsetof(FGzAreaAttackParams, AdditionalEffects) == 0x000090, "Member 'FGzAreaAttackParams::AdditionalEffects' has a wrong offset!");
static_assert(offsetof(FGzAreaAttackParams, AdditionalPerHitEffects) == 0x0000A0, "Member 'FGzAreaAttackParams::AdditionalPerHitEffects' has a wrong offset!");
static_assert(offsetof(FGzAreaAttackParams, TraceObjectTypes) == 0x0000B0, "Member 'FGzAreaAttackParams::TraceObjectTypes' has a wrong offset!");
static_assert(offsetof(FGzAreaAttackParams, ActorsToIgnore) == 0x0000C0, "Member 'FGzAreaAttackParams::ActorsToIgnore' has a wrong offset!");
static_assert(offsetof(FGzAreaAttackParams, bDistributeDamageBetweenTraces) == 0x0000D0, "Member 'FGzAreaAttackParams::bDistributeDamageBetweenTraces' has a wrong offset!");
static_assert(offsetof(FGzAreaAttackParams, ExplosionRadius) == 0x0000D4, "Member 'FGzAreaAttackParams::ExplosionRadius' has a wrong offset!");
static_assert(offsetof(FGzAreaAttackParams, bAllowFriendlyFire) == 0x0000D8, "Member 'FGzAreaAttackParams::bAllowFriendlyFire' has a wrong offset!");
static_assert(offsetof(FGzAreaAttackParams, bDrawDebug) == 0x0000D9, "Member 'FGzAreaAttackParams::bDrawDebug' has a wrong offset!");

// ScriptStruct G01.GzDamageAreaInfo
// 0x000C (0x000C - 0x0000)
struct FGzDamageAreaInfo final
{
public:
	float                                         BodyDamageMultiplier;                              // 0x0000(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SelfDamageMultiplier;                              // 0x0004(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ArmorDamageReductionValue;                         // 0x0008(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzDamageAreaInfo) == 0x000004, "Wrong alignment on FGzDamageAreaInfo");
static_assert(sizeof(FGzDamageAreaInfo) == 0x00000C, "Wrong size on FGzDamageAreaInfo");
static_assert(offsetof(FGzDamageAreaInfo, BodyDamageMultiplier) == 0x000000, "Member 'FGzDamageAreaInfo::BodyDamageMultiplier' has a wrong offset!");
static_assert(offsetof(FGzDamageAreaInfo, SelfDamageMultiplier) == 0x000004, "Member 'FGzDamageAreaInfo::SelfDamageMultiplier' has a wrong offset!");
static_assert(offsetof(FGzDamageAreaInfo, ArmorDamageReductionValue) == 0x000008, "Member 'FGzDamageAreaInfo::ArmorDamageReductionValue' has a wrong offset!");

// ScriptStruct G01.GzDamageKey
// 0x0010 (0x0010 - 0x0000)
struct FGzDamageKey final
{
public:
	int32                                         VictimId;                                          // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         InstigatorId;                                      // 0x0004(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UObject*                                SourceObject;                                      // 0x0008(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzDamageKey) == 0x000008, "Wrong alignment on FGzDamageKey");
static_assert(sizeof(FGzDamageKey) == 0x000010, "Wrong size on FGzDamageKey");
static_assert(offsetof(FGzDamageKey, VictimId) == 0x000000, "Member 'FGzDamageKey::VictimId' has a wrong offset!");
static_assert(offsetof(FGzDamageKey, InstigatorId) == 0x000004, "Member 'FGzDamageKey::InstigatorId' has a wrong offset!");
static_assert(offsetof(FGzDamageKey, SourceObject) == 0x000008, "Member 'FGzDamageKey::SourceObject' has a wrong offset!");

// ScriptStruct G01.GzBlockchainMarketLotSoldNotification
// 0x0038 (0x0058 - 0x0020)
struct FGzBlockchainMarketLotSoldNotification final : public FGzPlayFabNotification
{
public:
	class FString                                 AssetId;                                           // 0x0020(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 ItemInstanceId;                                    // 0x0030(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 BuyerPlayFabId;                                    // 0x0040(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	double                                        Price;                                             // 0x0050(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzBlockchainMarketLotSoldNotification) == 0x000008, "Wrong alignment on FGzBlockchainMarketLotSoldNotification");
static_assert(sizeof(FGzBlockchainMarketLotSoldNotification) == 0x000058, "Wrong size on FGzBlockchainMarketLotSoldNotification");
static_assert(offsetof(FGzBlockchainMarketLotSoldNotification, AssetId) == 0x000020, "Member 'FGzBlockchainMarketLotSoldNotification::AssetId' has a wrong offset!");
static_assert(offsetof(FGzBlockchainMarketLotSoldNotification, ItemInstanceId) == 0x000030, "Member 'FGzBlockchainMarketLotSoldNotification::ItemInstanceId' has a wrong offset!");
static_assert(offsetof(FGzBlockchainMarketLotSoldNotification, BuyerPlayFabId) == 0x000040, "Member 'FGzBlockchainMarketLotSoldNotification::BuyerPlayFabId' has a wrong offset!");
static_assert(offsetof(FGzBlockchainMarketLotSoldNotification, Price) == 0x000050, "Member 'FGzBlockchainMarketLotSoldNotification::Price' has a wrong offset!");

// ScriptStruct G01.GzDamageDirectionData
// 0x0030 (0x0030 - 0x0000)
struct FGzDamageDirectionData final
{
public:
	EGzDamageIndicatorType                        DamageType;                                        // 0x0000(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2B71[0x7];                                     // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                DamageSourceLocation;                              // 0x0008(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 Damager;                                           // 0x0020(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HealthDamage;                                      // 0x0028(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCrit;                                             // 0x002C(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDirectional;                                      // 0x002D(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2B72[0x2];                                     // 0x002E(0x0002)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGzDamageDirectionData) == 0x000008, "Wrong alignment on FGzDamageDirectionData");
static_assert(sizeof(FGzDamageDirectionData) == 0x000030, "Wrong size on FGzDamageDirectionData");
static_assert(offsetof(FGzDamageDirectionData, DamageType) == 0x000000, "Member 'FGzDamageDirectionData::DamageType' has a wrong offset!");
static_assert(offsetof(FGzDamageDirectionData, DamageSourceLocation) == 0x000008, "Member 'FGzDamageDirectionData::DamageSourceLocation' has a wrong offset!");
static_assert(offsetof(FGzDamageDirectionData, Damager) == 0x000020, "Member 'FGzDamageDirectionData::Damager' has a wrong offset!");
static_assert(offsetof(FGzDamageDirectionData, HealthDamage) == 0x000028, "Member 'FGzDamageDirectionData::HealthDamage' has a wrong offset!");
static_assert(offsetof(FGzDamageDirectionData, bCrit) == 0x00002C, "Member 'FGzDamageDirectionData::bCrit' has a wrong offset!");
static_assert(offsetof(FGzDamageDirectionData, bDirectional) == 0x00002D, "Member 'FGzDamageDirectionData::bDirectional' has a wrong offset!");

// ScriptStruct G01.GzLimbInvItem
// 0x0030 (0x0058 - 0x0028)
struct FGzLimbInvItem final : public FGzInvItemContentBase
{
public:
	class UGzBodyPartItemData*                    ItemData;                                          // 0x0028(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UGzBodyPartSkinItemData*                SkinItemData;                                      // 0x0030(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Health;                                            // 0x0038(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, RepSkip, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGzLimbStatusData                      LimbStatus;                                        // 0x003C(0x0018)(BlueprintVisible, RepSkip, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_2B73[0x4];                                     // 0x0054(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGzLimbInvItem) == 0x000008, "Wrong alignment on FGzLimbInvItem");
static_assert(sizeof(FGzLimbInvItem) == 0x000058, "Wrong size on FGzLimbInvItem");
static_assert(offsetof(FGzLimbInvItem, ItemData) == 0x000028, "Member 'FGzLimbInvItem::ItemData' has a wrong offset!");
static_assert(offsetof(FGzLimbInvItem, SkinItemData) == 0x000030, "Member 'FGzLimbInvItem::SkinItemData' has a wrong offset!");
static_assert(offsetof(FGzLimbInvItem, Health) == 0x000038, "Member 'FGzLimbInvItem::Health' has a wrong offset!");
static_assert(offsetof(FGzLimbInvItem, LimbStatus) == 0x00003C, "Member 'FGzLimbInvItem::LimbStatus' has a wrong offset!");

// ScriptStruct G01.GzSimpleInvItem
// 0x0010 (0x0038 - 0x0028)
struct FGzSimpleInvItem final : public FGzInvItemContentBase
{
public:
	class UGzSimpleItemData*                      ItemData;                                          // 0x0028(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Quantity;                                          // 0x0030(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2B74[0x4];                                     // 0x0034(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGzSimpleInvItem) == 0x000008, "Wrong alignment on FGzSimpleInvItem");
static_assert(sizeof(FGzSimpleInvItem) == 0x000038, "Wrong size on FGzSimpleInvItem");
static_assert(offsetof(FGzSimpleInvItem, ItemData) == 0x000028, "Member 'FGzSimpleInvItem::ItemData' has a wrong offset!");
static_assert(offsetof(FGzSimpleInvItem, Quantity) == 0x000030, "Member 'FGzSimpleInvItem::Quantity' has a wrong offset!");

// ScriptStruct G01.GzPlayerLoadoutData
// 0x0240 (0x0240 - 0x0000)
struct FGzPlayerLoadoutData final
{
public:
	struct FGzWeaponInvItem                       PrimaryWeapon;                                     // 0x0000(0x0050)(Edit, NativeAccessSpecifierPublic)
	struct FGzWeaponInvItem                       SecondaryWeapon;                                   // 0x0050(0x0050)(Edit, NativeAccessSpecifierPublic)
	struct FGzWeaponInvItem                       Sidearm;                                           // 0x00A0(0x0050)(Edit, NativeAccessSpecifierPublic)
	struct FGzLimbInvItem                         LeftArm;                                           // 0x00F0(0x0058)(Edit, NativeAccessSpecifierPublic)
	struct FGzLimbInvItem                         RightArm;                                          // 0x0148(0x0058)(Edit, NativeAccessSpecifierPublic)
	struct FGzLimbInvItem                         Legs;                                              // 0x01A0(0x0058)(Edit, NativeAccessSpecifierPublic)
	struct FGzSimpleInvItem                       Backpack;                                          // 0x01F8(0x0038)(Edit, NativeAccessSpecifierPublic)
	TArray<struct FGzSimpleInvItem>               Items;                                             // 0x0230(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzPlayerLoadoutData) == 0x000008, "Wrong alignment on FGzPlayerLoadoutData");
static_assert(sizeof(FGzPlayerLoadoutData) == 0x000240, "Wrong size on FGzPlayerLoadoutData");
static_assert(offsetof(FGzPlayerLoadoutData, PrimaryWeapon) == 0x000000, "Member 'FGzPlayerLoadoutData::PrimaryWeapon' has a wrong offset!");
static_assert(offsetof(FGzPlayerLoadoutData, SecondaryWeapon) == 0x000050, "Member 'FGzPlayerLoadoutData::SecondaryWeapon' has a wrong offset!");
static_assert(offsetof(FGzPlayerLoadoutData, Sidearm) == 0x0000A0, "Member 'FGzPlayerLoadoutData::Sidearm' has a wrong offset!");
static_assert(offsetof(FGzPlayerLoadoutData, LeftArm) == 0x0000F0, "Member 'FGzPlayerLoadoutData::LeftArm' has a wrong offset!");
static_assert(offsetof(FGzPlayerLoadoutData, RightArm) == 0x000148, "Member 'FGzPlayerLoadoutData::RightArm' has a wrong offset!");
static_assert(offsetof(FGzPlayerLoadoutData, Legs) == 0x0001A0, "Member 'FGzPlayerLoadoutData::Legs' has a wrong offset!");
static_assert(offsetof(FGzPlayerLoadoutData, Backpack) == 0x0001F8, "Member 'FGzPlayerLoadoutData::Backpack' has a wrong offset!");
static_assert(offsetof(FGzPlayerLoadoutData, Items) == 0x000230, "Member 'FGzPlayerLoadoutData::Items' has a wrong offset!");

// ScriptStruct G01.GzDamageMark
// 0x0028 (0x0028 - 0x0000)
struct FGzDamageMark final
{
public:
	struct FGzAdvancedIdType                      InstigatorId;                                      // 0x0000(0x0008)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGzDamageMarkInfo                      DamageInfo;                                        // 0x0008(0x0020)(NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzDamageMark) == 0x000008, "Wrong alignment on FGzDamageMark");
static_assert(sizeof(FGzDamageMark) == 0x000028, "Wrong size on FGzDamageMark");
static_assert(offsetof(FGzDamageMark, InstigatorId) == 0x000000, "Member 'FGzDamageMark::InstigatorId' has a wrong offset!");
static_assert(offsetof(FGzDamageMark, DamageInfo) == 0x000008, "Member 'FGzDamageMark::DamageInfo' has a wrong offset!");

// ScriptStruct G01.GzDebugMenuVariableInfo
// 0x0020 (0x0020 - 0x0000)
struct FGzDebugMenuVariableInfo final
{
public:
	EGzDebugMenuVariableType                      Type;                                              // 0x0000(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2B75[0x7];                                     // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 VariableName;                                      // 0x0008(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2B76[0x8];                                     // 0x0018(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGzDebugMenuVariableInfo) == 0x000008, "Wrong alignment on FGzDebugMenuVariableInfo");
static_assert(sizeof(FGzDebugMenuVariableInfo) == 0x000020, "Wrong size on FGzDebugMenuVariableInfo");
static_assert(offsetof(FGzDebugMenuVariableInfo, Type) == 0x000000, "Member 'FGzDebugMenuVariableInfo::Type' has a wrong offset!");
static_assert(offsetof(FGzDebugMenuVariableInfo, VariableName) == 0x000008, "Member 'FGzDebugMenuVariableInfo::VariableName' has a wrong offset!");

// ScriptStruct G01.GzResultSaveCompletedAchievementStage
// 0x0000 (0x00E0 - 0x00E0)
struct FGzResultSaveCompletedAchievementStage final : public FGzPlayFabResultBase
{
};
static_assert(alignof(FGzResultSaveCompletedAchievementStage) == 0x000008, "Wrong alignment on FGzResultSaveCompletedAchievementStage");
static_assert(sizeof(FGzResultSaveCompletedAchievementStage) == 0x0000E0, "Wrong size on FGzResultSaveCompletedAchievementStage");

// ScriptStruct G01.GzSubscriptionCreatedNotification
// 0x0088 (0x00A8 - 0x0020)
struct FGzSubscriptionCreatedNotification final : public FGzPlayFabNotification
{
public:
	struct FGzBackendSubscriptionState            Subscription;                                      // 0x0020(0x0088)(NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzSubscriptionCreatedNotification) == 0x000008, "Wrong alignment on FGzSubscriptionCreatedNotification");
static_assert(sizeof(FGzSubscriptionCreatedNotification) == 0x0000A8, "Wrong size on FGzSubscriptionCreatedNotification");
static_assert(offsetof(FGzSubscriptionCreatedNotification, Subscription) == 0x000020, "Member 'FGzSubscriptionCreatedNotification::Subscription' has a wrong offset!");

// ScriptStruct G01.GzResultSaveProgressedChallenges
// 0x0000 (0x00E0 - 0x00E0)
struct FGzResultSaveProgressedChallenges final : public FGzPlayFabResultBase
{
};
static_assert(alignof(FGzResultSaveProgressedChallenges) == 0x000008, "Wrong alignment on FGzResultSaveProgressedChallenges");
static_assert(sizeof(FGzResultSaveProgressedChallenges) == 0x0000E0, "Wrong size on FGzResultSaveProgressedChallenges");

// ScriptStruct G01.GzExtractResult
// 0x0010 (0x00F0 - 0x00E0)
struct FGzExtractResult final : public FGzPlayFabResultBase
{
public:
	TArray<struct FGzBackendInventoryItem>        ItemsSimplified;                                   // 0x00E0(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzExtractResult) == 0x000008, "Wrong alignment on FGzExtractResult");
static_assert(sizeof(FGzExtractResult) == 0x0000F0, "Wrong size on FGzExtractResult");
static_assert(offsetof(FGzExtractResult, ItemsSimplified) == 0x0000E0, "Member 'FGzExtractResult::ItemsSimplified' has a wrong offset!");

// ScriptStruct G01.GzResultGetServerLiveFeatures
// 0x0050 (0x0130 - 0x00E0)
struct FGzResultGetServerLiveFeatures final : public FGzPlayFabResultBase
{
public:
	TMap<class FString, class FString>            Overrides;                                         // 0x00E0(0x0050)(NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzResultGetServerLiveFeatures) == 0x000008, "Wrong alignment on FGzResultGetServerLiveFeatures");
static_assert(sizeof(FGzResultGetServerLiveFeatures) == 0x000130, "Wrong size on FGzResultGetServerLiveFeatures");
static_assert(offsetof(FGzResultGetServerLiveFeatures, Overrides) == 0x0000E0, "Member 'FGzResultGetServerLiveFeatures::Overrides' has a wrong offset!");

// ScriptStruct G01.GzResultCollectGameStatistics
// 0x0000 (0x00E0 - 0x00E0)
struct FGzResultCollectGameStatistics final : public FGzPlayFabResultBase
{
};
static_assert(alignof(FGzResultCollectGameStatistics) == 0x000008, "Wrong alignment on FGzResultCollectGameStatistics");
static_assert(sizeof(FGzResultCollectGameStatistics) == 0x0000E0, "Wrong size on FGzResultCollectGameStatistics");

// ScriptStruct G01.AnimStanceBlend
// 0x00F0 (0x00F0 - 0x0000)
struct FAnimStanceBlend final
{
public:
	TMap<EAnimStances, float>                     RelaxedBlendValues;                                // 0x0000(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TMap<EAnimStances, float>                     HipFireBlendValues;                                // 0x0050(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TMap<EAnimStances, float>                     AimingBlendValues;                                 // 0x00A0(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAnimStanceBlend) == 0x000008, "Wrong alignment on FAnimStanceBlend");
static_assert(sizeof(FAnimStanceBlend) == 0x0000F0, "Wrong size on FAnimStanceBlend");
static_assert(offsetof(FAnimStanceBlend, RelaxedBlendValues) == 0x000000, "Member 'FAnimStanceBlend::RelaxedBlendValues' has a wrong offset!");
static_assert(offsetof(FAnimStanceBlend, HipFireBlendValues) == 0x000050, "Member 'FAnimStanceBlend::HipFireBlendValues' has a wrong offset!");
static_assert(offsetof(FAnimStanceBlend, AimingBlendValues) == 0x0000A0, "Member 'FAnimStanceBlend::AimingBlendValues' has a wrong offset!");

// ScriptStruct G01.GzDefaultMannequinSetup
// 0x00E8 (0x00E8 - 0x0000)
struct FGzDefaultMannequinSetup final
{
public:
	uint8                                         Pad_2B77[0x8];                                     // 0x0000(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGzMannequinSetupInstance              PerLimbType[0x3];                                  // 0x0008(0x0030)(Edit, DisableEditOnTemplate, NativeAccessSpecifierPublic)
	TMap<struct FGameplayTag, struct FGzMannequinSetupInstance> PerLogicalSlot;                                    // 0x0098(0x0050)(Edit, DisableEditOnTemplate, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzDefaultMannequinSetup) == 0x000008, "Wrong alignment on FGzDefaultMannequinSetup");
static_assert(sizeof(FGzDefaultMannequinSetup) == 0x0000E8, "Wrong size on FGzDefaultMannequinSetup");
static_assert(offsetof(FGzDefaultMannequinSetup, PerLimbType) == 0x000008, "Member 'FGzDefaultMannequinSetup::PerLimbType' has a wrong offset!");
static_assert(offsetof(FGzDefaultMannequinSetup, PerLogicalSlot) == 0x000098, "Member 'FGzDefaultMannequinSetup::PerLogicalSlot' has a wrong offset!");

// ScriptStruct G01.GzDeleteCharacterPackage
// 0x0010 (0x0078 - 0x0068)
struct FGzDeleteCharacterPackage final : public FGzPlayFabClientPackage
{
public:
	class FString                                 CharacterId;                                       // 0x0068(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzDeleteCharacterPackage) == 0x000008, "Wrong alignment on FGzDeleteCharacterPackage");
static_assert(sizeof(FGzDeleteCharacterPackage) == 0x000078, "Wrong size on FGzDeleteCharacterPackage");
static_assert(offsetof(FGzDeleteCharacterPackage, CharacterId) == 0x000068, "Member 'FGzDeleteCharacterPackage::CharacterId' has a wrong offset!");

// ScriptStruct G01.GzDeliveryLocationData
// 0x0020 (0x0020 - 0x0000)
struct FGzDeliveryLocationData final
{
public:
	struct FVector                                TargetLocation;                                    // 0x0000(0x0018)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TrackRotationYaw;                                  // 0x0018(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HeightOffset;                                      // 0x001C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzDeliveryLocationData) == 0x000008, "Wrong alignment on FGzDeliveryLocationData");
static_assert(sizeof(FGzDeliveryLocationData) == 0x000020, "Wrong size on FGzDeliveryLocationData");
static_assert(offsetof(FGzDeliveryLocationData, TargetLocation) == 0x000000, "Member 'FGzDeliveryLocationData::TargetLocation' has a wrong offset!");
static_assert(offsetof(FGzDeliveryLocationData, TrackRotationYaw) == 0x000018, "Member 'FGzDeliveryLocationData::TrackRotationYaw' has a wrong offset!");
static_assert(offsetof(FGzDeliveryLocationData, HeightOffset) == 0x00001C, "Member 'FGzDeliveryLocationData::HeightOffset' has a wrong offset!");

// ScriptStruct G01.GzXpEntry
// 0x0014 (0x0014 - 0x0000)
struct FGzXpEntry final
{
public:
	class FName                                   Key;                                               // 0x0000(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         PlayerXp;                                          // 0x0008(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         BattlePassXp;                                      // 0x000C(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAlreadyGranted;                                   // 0x0010(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, RepSkip, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2B78[0x3];                                     // 0x0011(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGzXpEntry) == 0x000004, "Wrong alignment on FGzXpEntry");
static_assert(sizeof(FGzXpEntry) == 0x000014, "Wrong size on FGzXpEntry");
static_assert(offsetof(FGzXpEntry, Key) == 0x000000, "Member 'FGzXpEntry::Key' has a wrong offset!");
static_assert(offsetof(FGzXpEntry, PlayerXp) == 0x000008, "Member 'FGzXpEntry::PlayerXp' has a wrong offset!");
static_assert(offsetof(FGzXpEntry, BattlePassXp) == 0x00000C, "Member 'FGzXpEntry::BattlePassXp' has a wrong offset!");
static_assert(offsetof(FGzXpEntry, bAlreadyGranted) == 0x000010, "Member 'FGzXpEntry::bAlreadyGranted' has a wrong offset!");

// ScriptStruct G01.GzDenyFriendInvitationPackage
// 0x0010 (0x0078 - 0x0068)
struct FGzDenyFriendInvitationPackage final : public FGzPlayFabClientPackage
{
public:
	class FString                                 FriendPlayFabId;                                   // 0x0068(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzDenyFriendInvitationPackage) == 0x000008, "Wrong alignment on FGzDenyFriendInvitationPackage");
static_assert(sizeof(FGzDenyFriendInvitationPackage) == 0x000078, "Wrong size on FGzDenyFriendInvitationPackage");
static_assert(offsetof(FGzDenyFriendInvitationPackage, FriendPlayFabId) == 0x000068, "Member 'FGzDenyFriendInvitationPackage::FriendPlayFabId' has a wrong offset!");

// ScriptStruct G01.GzPartyMemberData
// 0x00B0 (0x00B0 - 0x0000)
struct FGzPartyMemberData final
{
public:
	class FString                                 Username;                                          // 0x0000(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 PlayFabId;                                         // 0x0010(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 TitleAccountId;                                    // 0x0020(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 EpicAccountId;                                     // 0x0030(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 EpicProductUserId;                                 // 0x0040(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Avatar;                                            // 0x0050(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsLeader;                                         // 0x0058(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2B79[0x57];                                    // 0x0059(0x0057)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGzPartyMemberData) == 0x000008, "Wrong alignment on FGzPartyMemberData");
static_assert(sizeof(FGzPartyMemberData) == 0x0000B0, "Wrong size on FGzPartyMemberData");
static_assert(offsetof(FGzPartyMemberData, Username) == 0x000000, "Member 'FGzPartyMemberData::Username' has a wrong offset!");
static_assert(offsetof(FGzPartyMemberData, PlayFabId) == 0x000010, "Member 'FGzPartyMemberData::PlayFabId' has a wrong offset!");
static_assert(offsetof(FGzPartyMemberData, TitleAccountId) == 0x000020, "Member 'FGzPartyMemberData::TitleAccountId' has a wrong offset!");
static_assert(offsetof(FGzPartyMemberData, EpicAccountId) == 0x000030, "Member 'FGzPartyMemberData::EpicAccountId' has a wrong offset!");
static_assert(offsetof(FGzPartyMemberData, EpicProductUserId) == 0x000040, "Member 'FGzPartyMemberData::EpicProductUserId' has a wrong offset!");
static_assert(offsetof(FGzPartyMemberData, Avatar) == 0x000050, "Member 'FGzPartyMemberData::Avatar' has a wrong offset!");
static_assert(offsetof(FGzPartyMemberData, bIsLeader) == 0x000058, "Member 'FGzPartyMemberData::bIsLeader' has a wrong offset!");

// ScriptStruct G01.GzDisposedNotifications
// 0x0010 (0x0010 - 0x0000)
struct FGzDisposedNotifications final
{
public:
	TArray<class FString>                         List;                                              // 0x0000(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzDisposedNotifications) == 0x000008, "Wrong alignment on FGzDisposedNotifications");
static_assert(sizeof(FGzDisposedNotifications) == 0x000010, "Wrong size on FGzDisposedNotifications");
static_assert(offsetof(FGzDisposedNotifications, List) == 0x000000, "Member 'FGzDisposedNotifications::List' has a wrong offset!");

// ScriptStruct G01.GzDropTableRow
// 0x0030 (0x0030 - 0x0000)
struct FGzDropTableRow final
{
public:
	struct FSoftObjectPath                        Value;                                             // 0x0000(0x0020)(Edit, ZeroConstructor, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Quantity;                                          // 0x0020(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Weight;                                            // 0x0024(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Percentage;                                        // 0x0028(0x0004)(Edit, ZeroConstructor, Transient, DisableEditOnInstance, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2B7A[0x4];                                     // 0x002C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGzDropTableRow) == 0x000008, "Wrong alignment on FGzDropTableRow");
static_assert(sizeof(FGzDropTableRow) == 0x000030, "Wrong size on FGzDropTableRow");
static_assert(offsetof(FGzDropTableRow, Value) == 0x000000, "Member 'FGzDropTableRow::Value' has a wrong offset!");
static_assert(offsetof(FGzDropTableRow, Quantity) == 0x000020, "Member 'FGzDropTableRow::Quantity' has a wrong offset!");
static_assert(offsetof(FGzDropTableRow, Weight) == 0x000024, "Member 'FGzDropTableRow::Weight' has a wrong offset!");
static_assert(offsetof(FGzDropTableRow, Percentage) == 0x000028, "Member 'FGzDropTableRow::Percentage' has a wrong offset!");

// ScriptStruct G01.GzEntityToActorComponent
// 0x0008 (0x0008 - 0x0000)
struct FGzEntityToActorComponent final
{
public:
	class AActor*                                 Actor;                                             // 0x0000(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzEntityToActorComponent) == 0x000008, "Wrong alignment on FGzEntityToActorComponent");
static_assert(sizeof(FGzEntityToActorComponent) == 0x000008, "Wrong size on FGzEntityToActorComponent");
static_assert(offsetof(FGzEntityToActorComponent, Actor) == 0x000000, "Member 'FGzEntityToActorComponent::Actor' has a wrong offset!");

// ScriptStruct G01.GzPackageCheatUpdateChallengesProgress
// 0x0010 (0x0078 - 0x0068)
struct FGzPackageCheatUpdateChallengesProgress final : public FGzPlayFabClientPackage
{
public:
	TArray<struct FGzPackageProgressedChallenge>  ChallengesProgress;                                // 0x0068(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzPackageCheatUpdateChallengesProgress) == 0x000008, "Wrong alignment on FGzPackageCheatUpdateChallengesProgress");
static_assert(sizeof(FGzPackageCheatUpdateChallengesProgress) == 0x000078, "Wrong size on FGzPackageCheatUpdateChallengesProgress");
static_assert(offsetof(FGzPackageCheatUpdateChallengesProgress, ChallengesProgress) == 0x000068, "Member 'FGzPackageCheatUpdateChallengesProgress::ChallengesProgress' has a wrong offset!");

// ScriptStruct G01.GzOpenIdAccountData
// 0x0030 (0x0030 - 0x0000)
struct FGzOpenIdAccountData final
{
public:
	class FString                                 Issuer;                                            // 0x0000(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 AccountId;                                         // 0x0010(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 ProductUserId;                                     // 0x0020(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzOpenIdAccountData) == 0x000008, "Wrong alignment on FGzOpenIdAccountData");
static_assert(sizeof(FGzOpenIdAccountData) == 0x000030, "Wrong size on FGzOpenIdAccountData");
static_assert(offsetof(FGzOpenIdAccountData, Issuer) == 0x000000, "Member 'FGzOpenIdAccountData::Issuer' has a wrong offset!");
static_assert(offsetof(FGzOpenIdAccountData, AccountId) == 0x000010, "Member 'FGzOpenIdAccountData::AccountId' has a wrong offset!");
static_assert(offsetof(FGzOpenIdAccountData, ProductUserId) == 0x000020, "Member 'FGzOpenIdAccountData::ProductUserId' has a wrong offset!");

// ScriptStruct G01.GzSubscriptionContentPackRewardsGrantedNotification
// 0x0050 (0x0070 - 0x0020)
struct FGzSubscriptionContentPackRewardsGrantedNotification final : public FGzPlayFabNotification
{
public:
	TMap<class FString, struct FGzBackendGrantedContentPack> Rewards;                                           // 0x0020(0x0050)(NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzSubscriptionContentPackRewardsGrantedNotification) == 0x000008, "Wrong alignment on FGzSubscriptionContentPackRewardsGrantedNotification");
static_assert(sizeof(FGzSubscriptionContentPackRewardsGrantedNotification) == 0x000070, "Wrong size on FGzSubscriptionContentPackRewardsGrantedNotification");
static_assert(offsetof(FGzSubscriptionContentPackRewardsGrantedNotification, Rewards) == 0x000020, "Member 'FGzSubscriptionContentPackRewardsGrantedNotification::Rewards' has a wrong offset!");

// ScriptStruct G01.GzStatusCodesDescription
// 0x0060 (0x0060 - 0x0000)
struct FGzStatusCodesDescription final
{
public:
	class FText                                   Description;                                       // 0x0000(0x0010)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TSet<EGzPlayFabStatusCodes>                   Codes;                                             // 0x0010(0x0050)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzStatusCodesDescription) == 0x000008, "Wrong alignment on FGzStatusCodesDescription");
static_assert(sizeof(FGzStatusCodesDescription) == 0x000060, "Wrong size on FGzStatusCodesDescription");
static_assert(offsetof(FGzStatusCodesDescription, Description) == 0x000000, "Member 'FGzStatusCodesDescription::Description' has a wrong offset!");
static_assert(offsetof(FGzStatusCodesDescription, Codes) == 0x000010, "Member 'FGzStatusCodesDescription::Codes' has a wrong offset!");

// ScriptStruct G01.GzExtendXsollaSubscriptionPackage
// 0x0010 (0x0078 - 0x0068)
struct FGzExtendXsollaSubscriptionPackage final : public FGzPlayFabClientPackage
{
public:
	class FString                                 PriceString;                                       // 0x0068(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzExtendXsollaSubscriptionPackage) == 0x000008, "Wrong alignment on FGzExtendXsollaSubscriptionPackage");
static_assert(sizeof(FGzExtendXsollaSubscriptionPackage) == 0x000078, "Wrong size on FGzExtendXsollaSubscriptionPackage");
static_assert(offsetof(FGzExtendXsollaSubscriptionPackage, PriceString) == 0x000068, "Member 'FGzExtendXsollaSubscriptionPackage::PriceString' has a wrong offset!");

// ScriptStruct G01.GzPackageCollectPlayerSpec
// 0x0070 (0x00D8 - 0x0068)
struct FGzPackageCollectPlayerSpec final : public FGzPlayFabClientPackage
{
public:
	class FString                                 OS;                                                // 0x0068(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 OsVersion;                                         // 0x0078(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Cpu;                                               // 0x0088(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Gpu;                                               // 0x0098(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Locale;                                            // 0x00A8(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Timezone;                                          // 0x00B8(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Resolution;                                        // 0x00C8(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzPackageCollectPlayerSpec) == 0x000008, "Wrong alignment on FGzPackageCollectPlayerSpec");
static_assert(sizeof(FGzPackageCollectPlayerSpec) == 0x0000D8, "Wrong size on FGzPackageCollectPlayerSpec");
static_assert(offsetof(FGzPackageCollectPlayerSpec, OS) == 0x000068, "Member 'FGzPackageCollectPlayerSpec::OS' has a wrong offset!");
static_assert(offsetof(FGzPackageCollectPlayerSpec, OsVersion) == 0x000078, "Member 'FGzPackageCollectPlayerSpec::OsVersion' has a wrong offset!");
static_assert(offsetof(FGzPackageCollectPlayerSpec, Cpu) == 0x000088, "Member 'FGzPackageCollectPlayerSpec::Cpu' has a wrong offset!");
static_assert(offsetof(FGzPackageCollectPlayerSpec, Gpu) == 0x000098, "Member 'FGzPackageCollectPlayerSpec::Gpu' has a wrong offset!");
static_assert(offsetof(FGzPackageCollectPlayerSpec, Locale) == 0x0000A8, "Member 'FGzPackageCollectPlayerSpec::Locale' has a wrong offset!");
static_assert(offsetof(FGzPackageCollectPlayerSpec, Timezone) == 0x0000B8, "Member 'FGzPackageCollectPlayerSpec::Timezone' has a wrong offset!");
static_assert(offsetof(FGzPackageCollectPlayerSpec, Resolution) == 0x0000C8, "Member 'FGzPackageCollectPlayerSpec::Resolution' has a wrong offset!");

// ScriptStruct G01.GzFactionKey
// 0x0008 (0x0008 - 0x0000)
struct FGzFactionKey final
{
public:
	class FName                                   Key;                                               // 0x0000(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzFactionKey) == 0x000004, "Wrong alignment on FGzFactionKey");
static_assert(sizeof(FGzFactionKey) == 0x000008, "Wrong size on FGzFactionKey");
static_assert(offsetof(FGzFactionKey, Key) == 0x000000, "Member 'FGzFactionKey::Key' has a wrong offset!");

// ScriptStruct G01.GzPackageWeaponConfigurationCollection
// 0x0050 (0x0050 - 0x0000)
struct FGzPackageWeaponConfigurationCollection final
{
public:
	TMap<class FString, struct FGzPackageWeaponConfiguration> Configurations;                                    // 0x0000(0x0050)(NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzPackageWeaponConfigurationCollection) == 0x000008, "Wrong alignment on FGzPackageWeaponConfigurationCollection");
static_assert(sizeof(FGzPackageWeaponConfigurationCollection) == 0x000050, "Wrong size on FGzPackageWeaponConfigurationCollection");
static_assert(offsetof(FGzPackageWeaponConfigurationCollection, Configurations) == 0x000000, "Member 'FGzPackageWeaponConfigurationCollection::Configurations' has a wrong offset!");

// ScriptStruct G01.GzAcceptFriendInvitationResult
// 0x0000 (0x00E0 - 0x00E0)
struct FGzAcceptFriendInvitationResult final : public FGzPlayFabResultBase
{
};
static_assert(alignof(FGzAcceptFriendInvitationResult) == 0x000008, "Wrong alignment on FGzAcceptFriendInvitationResult");
static_assert(sizeof(FGzAcceptFriendInvitationResult) == 0x0000E0, "Wrong size on FGzAcceptFriendInvitationResult");

// ScriptStruct G01.GzSendFriendInvitationResult
// 0x0000 (0x00E0 - 0x00E0)
struct FGzSendFriendInvitationResult final : public FGzPlayFabResultBase
{
};
static_assert(alignof(FGzSendFriendInvitationResult) == 0x000008, "Wrong alignment on FGzSendFriendInvitationResult");
static_assert(sizeof(FGzSendFriendInvitationResult) == 0x0000E0, "Wrong size on FGzSendFriendInvitationResult");

// ScriptStruct G01.GzGadgetMoveDataInternal
// 0x00E0 (0x00E0 - 0x0000)
struct FGzGadgetMoveDataInternal final
{
public:
	struct FGzGadgetMoveData                      MoveData;                                          // 0x0000(0x0090)(BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic)
	EGzGadgetMovementState                        State;                                             // 0x0090(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2B7B[0x7];                                     // 0x0091(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UPrimitiveComponent*                    CollidedComponent;                                 // 0x0098(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   CollidedBone;                                      // 0x00A0(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                TargetLocation;                                    // 0x00A8(0x0018)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               TargetRotation;                                    // 0x00C0(0x0018)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          bEnableBlockingCollision;                          // 0x00D8(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2B7C[0x7];                                     // 0x00D9(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGzGadgetMoveDataInternal) == 0x000010, "Wrong alignment on FGzGadgetMoveDataInternal");
static_assert(sizeof(FGzGadgetMoveDataInternal) == 0x0000E0, "Wrong size on FGzGadgetMoveDataInternal");
static_assert(offsetof(FGzGadgetMoveDataInternal, MoveData) == 0x000000, "Member 'FGzGadgetMoveDataInternal::MoveData' has a wrong offset!");
static_assert(offsetof(FGzGadgetMoveDataInternal, State) == 0x000090, "Member 'FGzGadgetMoveDataInternal::State' has a wrong offset!");
static_assert(offsetof(FGzGadgetMoveDataInternal, CollidedComponent) == 0x000098, "Member 'FGzGadgetMoveDataInternal::CollidedComponent' has a wrong offset!");
static_assert(offsetof(FGzGadgetMoveDataInternal, CollidedBone) == 0x0000A0, "Member 'FGzGadgetMoveDataInternal::CollidedBone' has a wrong offset!");
static_assert(offsetof(FGzGadgetMoveDataInternal, TargetLocation) == 0x0000A8, "Member 'FGzGadgetMoveDataInternal::TargetLocation' has a wrong offset!");
static_assert(offsetof(FGzGadgetMoveDataInternal, TargetRotation) == 0x0000C0, "Member 'FGzGadgetMoveDataInternal::TargetRotation' has a wrong offset!");
static_assert(offsetof(FGzGadgetMoveDataInternal, bEnableBlockingCollision) == 0x0000D8, "Member 'FGzGadgetMoveDataInternal::bEnableBlockingCollision' has a wrong offset!");

// ScriptStruct G01.GzSetClanTagResult
// 0x0000 (0x00E0 - 0x00E0)
struct FGzSetClanTagResult final : public FGzPlayFabResultBase
{
};
static_assert(alignof(FGzSetClanTagResult) == 0x000008, "Wrong alignment on FGzSetClanTagResult");
static_assert(sizeof(FGzSetClanTagResult) == 0x0000E0, "Wrong size on FGzSetClanTagResult");

// ScriptStruct G01.GzPhysicsSimulationParams
// 0x0030 (0x0030 - 0x0000)
struct FGzPhysicsSimulationParams final
{
public:
	uint8                                         EndSimulationBehaviorFlags;                        // 0x0000(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSyncSimulation;                                   // 0x0001(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSyncOnlyRoot;                                     // 0x0002(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2B7D[0x1];                                     // 0x0003(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         PoseReplicationFrequency;                          // 0x0004(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIncludeSpecifiedBones;                            // 0x0008(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2B7E[0x7];                                     // 0x0009(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FName>                           SyncUpToTheseBones;                                // 0x0010(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	float                                         MaxTimeToCatchUpBeforeSleep;                       // 0x0020(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxTimeDifferenceBeforeSpeedUp;                    // 0x0024(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxFinalLocationDifference;                        // 0x0028(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxFinalRotationDifference;                        // 0x002C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzPhysicsSimulationParams) == 0x000008, "Wrong alignment on FGzPhysicsSimulationParams");
static_assert(sizeof(FGzPhysicsSimulationParams) == 0x000030, "Wrong size on FGzPhysicsSimulationParams");
static_assert(offsetof(FGzPhysicsSimulationParams, EndSimulationBehaviorFlags) == 0x000000, "Member 'FGzPhysicsSimulationParams::EndSimulationBehaviorFlags' has a wrong offset!");
static_assert(offsetof(FGzPhysicsSimulationParams, bSyncSimulation) == 0x000001, "Member 'FGzPhysicsSimulationParams::bSyncSimulation' has a wrong offset!");
static_assert(offsetof(FGzPhysicsSimulationParams, bSyncOnlyRoot) == 0x000002, "Member 'FGzPhysicsSimulationParams::bSyncOnlyRoot' has a wrong offset!");
static_assert(offsetof(FGzPhysicsSimulationParams, PoseReplicationFrequency) == 0x000004, "Member 'FGzPhysicsSimulationParams::PoseReplicationFrequency' has a wrong offset!");
static_assert(offsetof(FGzPhysicsSimulationParams, bIncludeSpecifiedBones) == 0x000008, "Member 'FGzPhysicsSimulationParams::bIncludeSpecifiedBones' has a wrong offset!");
static_assert(offsetof(FGzPhysicsSimulationParams, SyncUpToTheseBones) == 0x000010, "Member 'FGzPhysicsSimulationParams::SyncUpToTheseBones' has a wrong offset!");
static_assert(offsetof(FGzPhysicsSimulationParams, MaxTimeToCatchUpBeforeSleep) == 0x000020, "Member 'FGzPhysicsSimulationParams::MaxTimeToCatchUpBeforeSleep' has a wrong offset!");
static_assert(offsetof(FGzPhysicsSimulationParams, MaxTimeDifferenceBeforeSpeedUp) == 0x000024, "Member 'FGzPhysicsSimulationParams::MaxTimeDifferenceBeforeSpeedUp' has a wrong offset!");
static_assert(offsetof(FGzPhysicsSimulationParams, MaxFinalLocationDifference) == 0x000028, "Member 'FGzPhysicsSimulationParams::MaxFinalLocationDifference' has a wrong offset!");
static_assert(offsetof(FGzPhysicsSimulationParams, MaxFinalRotationDifference) == 0x00002C, "Member 'FGzPhysicsSimulationParams::MaxFinalRotationDifference' has a wrong offset!");

// ScriptStruct G01.GzGameModeData
// 0x0070 (0x0070 - 0x0000)
struct FGzGameModeData
{
public:
	class FText                                   DisplayName;                                       // 0x0000(0x0010)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	EGzGameModeVariation                          Variation;                                         // 0x0010(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2B7F[0x7];                                     // 0x0011(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   Description;                                       // 0x0018(0x0010)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TArray<class FText>                           Tags;                                              // 0x0028(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TArray<struct FGzPromotionBanner>             PromotionBanners;                                  // 0x0038(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UMediaSource>            IntroductionVideo;                                 // 0x0048(0x0028)(Edit, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzGameModeData) == 0x000008, "Wrong alignment on FGzGameModeData");
static_assert(sizeof(FGzGameModeData) == 0x000070, "Wrong size on FGzGameModeData");
static_assert(offsetof(FGzGameModeData, DisplayName) == 0x000000, "Member 'FGzGameModeData::DisplayName' has a wrong offset!");
static_assert(offsetof(FGzGameModeData, Variation) == 0x000010, "Member 'FGzGameModeData::Variation' has a wrong offset!");
static_assert(offsetof(FGzGameModeData, Description) == 0x000018, "Member 'FGzGameModeData::Description' has a wrong offset!");
static_assert(offsetof(FGzGameModeData, Tags) == 0x000028, "Member 'FGzGameModeData::Tags' has a wrong offset!");
static_assert(offsetof(FGzGameModeData, PromotionBanners) == 0x000038, "Member 'FGzGameModeData::PromotionBanners' has a wrong offset!");
static_assert(offsetof(FGzGameModeData, IntroductionVideo) == 0x000048, "Member 'FGzGameModeData::IntroductionVideo' has a wrong offset!");

// ScriptStruct G01.GzPlayFabJobNotification
// 0x00F0 (0x0110 - 0x0020)
struct FGzPlayFabJobNotification final : public FGzPlayFabNotification
{
public:
	class FString                                 CharacterId;                                       // 0x0020(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 JobId;                                             // 0x0030(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGzCombinedReward                      Reward;                                            // 0x0040(0x00D0)(NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzPlayFabJobNotification) == 0x000008, "Wrong alignment on FGzPlayFabJobNotification");
static_assert(sizeof(FGzPlayFabJobNotification) == 0x000110, "Wrong size on FGzPlayFabJobNotification");
static_assert(offsetof(FGzPlayFabJobNotification, CharacterId) == 0x000020, "Member 'FGzPlayFabJobNotification::CharacterId' has a wrong offset!");
static_assert(offsetof(FGzPlayFabJobNotification, JobId) == 0x000030, "Member 'FGzPlayFabJobNotification::JobId' has a wrong offset!");
static_assert(offsetof(FGzPlayFabJobNotification, Reward) == 0x000040, "Member 'FGzPlayFabJobNotification::Reward' has a wrong offset!");

// ScriptStruct G01.DamageDisplayData
// 0x0030 (0x0030 - 0x0000)
struct FDamageDisplayData final
{
public:
	float                                         GridArmor;                                         // 0x0000(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Armor;                                             // 0x0004(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Body;                                              // 0x0008(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Limb;                                              // 0x000C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Vehicle;                                           // 0x0010(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Jetpack;                                           // 0x0014(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                DamageLocation;                                    // 0x0018(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDamageDisplayData) == 0x000008, "Wrong alignment on FDamageDisplayData");
static_assert(sizeof(FDamageDisplayData) == 0x000030, "Wrong size on FDamageDisplayData");
static_assert(offsetof(FDamageDisplayData, GridArmor) == 0x000000, "Member 'FDamageDisplayData::GridArmor' has a wrong offset!");
static_assert(offsetof(FDamageDisplayData, Armor) == 0x000004, "Member 'FDamageDisplayData::Armor' has a wrong offset!");
static_assert(offsetof(FDamageDisplayData, Body) == 0x000008, "Member 'FDamageDisplayData::Body' has a wrong offset!");
static_assert(offsetof(FDamageDisplayData, Limb) == 0x00000C, "Member 'FDamageDisplayData::Limb' has a wrong offset!");
static_assert(offsetof(FDamageDisplayData, Vehicle) == 0x000010, "Member 'FDamageDisplayData::Vehicle' has a wrong offset!");
static_assert(offsetof(FDamageDisplayData, Jetpack) == 0x000014, "Member 'FDamageDisplayData::Jetpack' has a wrong offset!");
static_assert(offsetof(FDamageDisplayData, DamageLocation) == 0x000018, "Member 'FDamageDisplayData::DamageLocation' has a wrong offset!");

// ScriptStruct G01.GzGamepadFeedbackSpec
// 0x0018 (0x0018 - 0x0000)
struct FGzGamepadFeedbackSpec final
{
public:
	TSubclassOf<class UInputDeviceProperty>       Property;                                          // 0x0000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Priority;                                          // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Name;                                              // 0x000C(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bLooping;                                          // 0x0014(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2B80[0x3];                                     // 0x0015(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGzGamepadFeedbackSpec) == 0x000008, "Wrong alignment on FGzGamepadFeedbackSpec");
static_assert(sizeof(FGzGamepadFeedbackSpec) == 0x000018, "Wrong size on FGzGamepadFeedbackSpec");
static_assert(offsetof(FGzGamepadFeedbackSpec, Property) == 0x000000, "Member 'FGzGamepadFeedbackSpec::Property' has a wrong offset!");
static_assert(offsetof(FGzGamepadFeedbackSpec, Priority) == 0x000008, "Member 'FGzGamepadFeedbackSpec::Priority' has a wrong offset!");
static_assert(offsetof(FGzGamepadFeedbackSpec, Name) == 0x00000C, "Member 'FGzGamepadFeedbackSpec::Name' has a wrong offset!");
static_assert(offsetof(FGzGamepadFeedbackSpec, bLooping) == 0x000014, "Member 'FGzGamepadFeedbackSpec::bLooping' has a wrong offset!");

// ScriptStruct G01.GzActiveGamepadFeedbacks
// 0x0030 (0x0030 - 0x0000)
struct FGzActiveGamepadFeedbacks final
{
public:
	class UGzGamepadFeedbackController*           Owner;                                             // 0x0000(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<struct FGzGamepadFeedbackSpec>         ActiveSpecs;                                       // 0x0008(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	class UInputDeviceProperty*                   ActiveProperty;                                    // 0x0018(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2B81[0x10];                                    // 0x0020(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGzActiveGamepadFeedbacks) == 0x000008, "Wrong alignment on FGzActiveGamepadFeedbacks");
static_assert(sizeof(FGzActiveGamepadFeedbacks) == 0x000030, "Wrong size on FGzActiveGamepadFeedbacks");
static_assert(offsetof(FGzActiveGamepadFeedbacks, Owner) == 0x000000, "Member 'FGzActiveGamepadFeedbacks::Owner' has a wrong offset!");
static_assert(offsetof(FGzActiveGamepadFeedbacks, ActiveSpecs) == 0x000008, "Member 'FGzActiveGamepadFeedbacks::ActiveSpecs' has a wrong offset!");
static_assert(offsetof(FGzActiveGamepadFeedbacks, ActiveProperty) == 0x000018, "Member 'FGzActiveGamepadFeedbacks::ActiveProperty' has a wrong offset!");

// ScriptStruct G01.GzGameplayAttributeValueRange
// 0x00A8 (0x00A8 - 0x0000)
struct FGzGameplayAttributeValueRange final
{
public:
	struct FGameplayAttribute                     Attribute;                                         // 0x0000(0x0038)(Edit, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayAttribute                     AttributeMax;                                      // 0x0038(0x0038)(Edit, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayAttribute                     AttributeDamage;                                   // 0x0070(0x0038)(Edit, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzGameplayAttributeValueRange) == 0x000008, "Wrong alignment on FGzGameplayAttributeValueRange");
static_assert(sizeof(FGzGameplayAttributeValueRange) == 0x0000A8, "Wrong size on FGzGameplayAttributeValueRange");
static_assert(offsetof(FGzGameplayAttributeValueRange, Attribute) == 0x000000, "Member 'FGzGameplayAttributeValueRange::Attribute' has a wrong offset!");
static_assert(offsetof(FGzGameplayAttributeValueRange, AttributeMax) == 0x000038, "Member 'FGzGameplayAttributeValueRange::AttributeMax' has a wrong offset!");
static_assert(offsetof(FGzGameplayAttributeValueRange, AttributeDamage) == 0x000070, "Member 'FGzGameplayAttributeValueRange::AttributeDamage' has a wrong offset!");

// ScriptStruct G01.GzServerMarkerRuntimeInfo
// 0x0090 (0x0090 - 0x0000)
struct FGzServerMarkerRuntimeInfo final
{
public:
	TArray<uint32>                                PlayerIds;                                         // 0x0000(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	struct FGzMarkerServerData                    ServerData;                                        // 0x0010(0x0050)(NativeAccessSpecifierPublic)
	float                                         PositionUpdateFrequency;                           // 0x0060(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2B82[0x4];                                     // 0x0064(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class AActor*                                 TargetActor;                                       // 0x0068(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Offset;                                            // 0x0070(0x0018)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2B83[0x8];                                     // 0x0088(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGzServerMarkerRuntimeInfo) == 0x000008, "Wrong alignment on FGzServerMarkerRuntimeInfo");
static_assert(sizeof(FGzServerMarkerRuntimeInfo) == 0x000090, "Wrong size on FGzServerMarkerRuntimeInfo");
static_assert(offsetof(FGzServerMarkerRuntimeInfo, PlayerIds) == 0x000000, "Member 'FGzServerMarkerRuntimeInfo::PlayerIds' has a wrong offset!");
static_assert(offsetof(FGzServerMarkerRuntimeInfo, ServerData) == 0x000010, "Member 'FGzServerMarkerRuntimeInfo::ServerData' has a wrong offset!");
static_assert(offsetof(FGzServerMarkerRuntimeInfo, PositionUpdateFrequency) == 0x000060, "Member 'FGzServerMarkerRuntimeInfo::PositionUpdateFrequency' has a wrong offset!");
static_assert(offsetof(FGzServerMarkerRuntimeInfo, TargetActor) == 0x000068, "Member 'FGzServerMarkerRuntimeInfo::TargetActor' has a wrong offset!");
static_assert(offsetof(FGzServerMarkerRuntimeInfo, Offset) == 0x000070, "Member 'FGzServerMarkerRuntimeInfo::Offset' has a wrong offset!");

// ScriptStruct G01.GzPredictProjectilePathParams
// 0x0010 (0x0088 - 0x0078)
struct FGzPredictProjectilePathParams : public FPredictProjectilePathParams
{
public:
	bool                                          bEnableDrag;                                       // 0x0078(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2B84[0x3];                                     // 0x0079(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         DragCoefficient;                                   // 0x007C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DragStartingDistance;                              // 0x0080(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2B85[0x4];                                     // 0x0084(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGzPredictProjectilePathParams) == 0x000008, "Wrong alignment on FGzPredictProjectilePathParams");
static_assert(sizeof(FGzPredictProjectilePathParams) == 0x000088, "Wrong size on FGzPredictProjectilePathParams");
static_assert(offsetof(FGzPredictProjectilePathParams, bEnableDrag) == 0x000078, "Member 'FGzPredictProjectilePathParams::bEnableDrag' has a wrong offset!");
static_assert(offsetof(FGzPredictProjectilePathParams, DragCoefficient) == 0x00007C, "Member 'FGzPredictProjectilePathParams::DragCoefficient' has a wrong offset!");
static_assert(offsetof(FGzPredictProjectilePathParams, DragStartingDistance) == 0x000080, "Member 'FGzPredictProjectilePathParams::DragStartingDistance' has a wrong offset!");

// ScriptStruct G01.GzPredictProjectilePathParams_WithHoming
// 0x0030 (0x00B8 - 0x0088)
struct FGzPredictProjectilePathParams_WithHoming final : public FGzPredictProjectilePathParams
{
public:
	bool                                          bEnableHoming;                                     // 0x0088(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2B86[0x3];                                     // 0x0089(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         HomingAcceleration;                                // 0x008C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ProjectileMaxSpeed;                                // 0x0090(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2B87[0x4];                                     // 0x0094(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                HomingLocation;                                    // 0x0098(0x0018)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEnableGravity;                                    // 0x00B0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2B88[0x7];                                     // 0x00B1(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGzPredictProjectilePathParams_WithHoming) == 0x000008, "Wrong alignment on FGzPredictProjectilePathParams_WithHoming");
static_assert(sizeof(FGzPredictProjectilePathParams_WithHoming) == 0x0000B8, "Wrong size on FGzPredictProjectilePathParams_WithHoming");
static_assert(offsetof(FGzPredictProjectilePathParams_WithHoming, bEnableHoming) == 0x000088, "Member 'FGzPredictProjectilePathParams_WithHoming::bEnableHoming' has a wrong offset!");
static_assert(offsetof(FGzPredictProjectilePathParams_WithHoming, HomingAcceleration) == 0x00008C, "Member 'FGzPredictProjectilePathParams_WithHoming::HomingAcceleration' has a wrong offset!");
static_assert(offsetof(FGzPredictProjectilePathParams_WithHoming, ProjectileMaxSpeed) == 0x000090, "Member 'FGzPredictProjectilePathParams_WithHoming::ProjectileMaxSpeed' has a wrong offset!");
static_assert(offsetof(FGzPredictProjectilePathParams_WithHoming, HomingLocation) == 0x000098, "Member 'FGzPredictProjectilePathParams_WithHoming::HomingLocation' has a wrong offset!");
static_assert(offsetof(FGzPredictProjectilePathParams_WithHoming, bEnableGravity) == 0x0000B0, "Member 'FGzPredictProjectilePathParams_WithHoming::bEnableGravity' has a wrong offset!");

// ScriptStruct G01.GzMeshData
// 0x0090 (0x00D0 - 0x0040)
struct FGzMeshData final : public FGzMeshDataBase
{
public:
	TArray<struct FGzCharacterSkinMaterial>       Materials;                                         // 0x0040(0x0010)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	class FName                                   SkeletonSocketName;                                // 0x0050(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   InternalSlotName;                                  // 0x0058(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FTransform                             ManuallyAdjustedRelativeTransform;                 // 0x0060(0x0060)(Edit, BlueprintVisible, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bManuallyAdjustOffset;                             // 0x00C0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2B89[0xF];                                     // 0x00C1(0x000F)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGzMeshData) == 0x000010, "Wrong alignment on FGzMeshData");
static_assert(sizeof(FGzMeshData) == 0x0000D0, "Wrong size on FGzMeshData");
static_assert(offsetof(FGzMeshData, Materials) == 0x000040, "Member 'FGzMeshData::Materials' has a wrong offset!");
static_assert(offsetof(FGzMeshData, SkeletonSocketName) == 0x000050, "Member 'FGzMeshData::SkeletonSocketName' has a wrong offset!");
static_assert(offsetof(FGzMeshData, InternalSlotName) == 0x000058, "Member 'FGzMeshData::InternalSlotName' has a wrong offset!");
static_assert(offsetof(FGzMeshData, ManuallyAdjustedRelativeTransform) == 0x000060, "Member 'FGzMeshData::ManuallyAdjustedRelativeTransform' has a wrong offset!");
static_assert(offsetof(FGzMeshData, bManuallyAdjustOffset) == 0x0000C0, "Member 'FGzMeshData::bManuallyAdjustOffset' has a wrong offset!");

// ScriptStruct G01.GzComplianceAbilityInteraction
// 0x0018 (0x0018 - 0x0000)
struct FGzComplianceAbilityInteraction final
{
public:
	struct FGameplayTag                           InteractionInstigatorTag;                          // 0x0000(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FGameplayTag>                   InteractionItemTypes;                              // 0x0008(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzComplianceAbilityInteraction) == 0x000008, "Wrong alignment on FGzComplianceAbilityInteraction");
static_assert(sizeof(FGzComplianceAbilityInteraction) == 0x000018, "Wrong size on FGzComplianceAbilityInteraction");
static_assert(offsetof(FGzComplianceAbilityInteraction, InteractionInstigatorTag) == 0x000000, "Member 'FGzComplianceAbilityInteraction::InteractionInstigatorTag' has a wrong offset!");
static_assert(offsetof(FGzComplianceAbilityInteraction, InteractionItemTypes) == 0x000008, "Member 'FGzComplianceAbilityInteraction::InteractionItemTypes' has a wrong offset!");

// ScriptStruct G01.GzTrialsFastArray
// 0x0040 (0x0150 - 0x0110)
struct FGzTrialsFastArray final : public FFastArraySerializer
{
public:
	uint8                                         Pad_2B8A[0x30];                                    // 0x0110(0x0030)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FGzGameplayTrial>               Trials;                                            // 0x0140(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzTrialsFastArray) == 0x000008, "Wrong alignment on FGzTrialsFastArray");
static_assert(sizeof(FGzTrialsFastArray) == 0x000150, "Wrong size on FGzTrialsFastArray");
static_assert(offsetof(FGzTrialsFastArray, Trials) == 0x000140, "Member 'FGzTrialsFastArray::Trials' has a wrong offset!");

// ScriptStruct G01.GzGameplayTrialsCollection
// 0x0018 (0x0018 - 0x0000)
struct FGzGameplayTrialsCollection final
{
public:
	int32                                         PlayerId;                                          // 0x0000(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2B8B[0x4];                                     // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FGzGameplayTrial>               TrialsProgress;                                    // 0x0008(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzGameplayTrialsCollection) == 0x000008, "Wrong alignment on FGzGameplayTrialsCollection");
static_assert(sizeof(FGzGameplayTrialsCollection) == 0x000018, "Wrong size on FGzGameplayTrialsCollection");
static_assert(offsetof(FGzGameplayTrialsCollection, PlayerId) == 0x000000, "Member 'FGzGameplayTrialsCollection::PlayerId' has a wrong offset!");
static_assert(offsetof(FGzGameplayTrialsCollection, TrialsProgress) == 0x000008, "Member 'FGzGameplayTrialsCollection::TrialsProgress' has a wrong offset!");

// ScriptStruct G01.GzGameRestartStageSettings
// 0x0001 (0x0001 - 0x0000)
struct FGzGameRestartStageSettings final
{
public:
	uint8                                         Pad_2B8C[0x1];                                     // 0x0000(0x0001)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGzGameRestartStageSettings) == 0x000001, "Wrong alignment on FGzGameRestartStageSettings");
static_assert(sizeof(FGzGameRestartStageSettings) == 0x000001, "Wrong size on FGzGameRestartStageSettings");

// ScriptStruct G01.GzGameSettingConfig
// 0x00B8 (0x00B8 - 0x0000)
struct FGzGameSettingConfig final
{
public:
	TSubclassOf<class UGameSetting>               GameSettingClass;                                  // 0x0000(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSet<class FName>                             GameSettingDependencies;                           // 0x0008(0x0050)(Edit, NativeAccessSpecifierPublic)
	struct FGameplayTagContainer                  EditConditions;                                    // 0x0058(0x0020)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	bool                                          bAvailableInShipping;                              // 0x0078(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseSettingData;                                   // 0x0079(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2B8D[0x6];                                     // 0x007A(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class UGzSettingData*                         SettingData;                                       // 0x0080(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, PersistentInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   DisplayName;                                       // 0x0088(0x0010)(Edit, NativeAccessSpecifierPublic)
	class FText                                   Description;                                       // 0x0098(0x0010)(Edit, NativeAccessSpecifierPublic)
	class FName                                   DevName;                                           // 0x00A8(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SettingsPresence;                                  // 0x00B0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int8                                          AllowedPlatforms;                                  // 0x00B4(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2B8E[0x3];                                     // 0x00B5(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGzGameSettingConfig) == 0x000008, "Wrong alignment on FGzGameSettingConfig");
static_assert(sizeof(FGzGameSettingConfig) == 0x0000B8, "Wrong size on FGzGameSettingConfig");
static_assert(offsetof(FGzGameSettingConfig, GameSettingClass) == 0x000000, "Member 'FGzGameSettingConfig::GameSettingClass' has a wrong offset!");
static_assert(offsetof(FGzGameSettingConfig, GameSettingDependencies) == 0x000008, "Member 'FGzGameSettingConfig::GameSettingDependencies' has a wrong offset!");
static_assert(offsetof(FGzGameSettingConfig, EditConditions) == 0x000058, "Member 'FGzGameSettingConfig::EditConditions' has a wrong offset!");
static_assert(offsetof(FGzGameSettingConfig, bAvailableInShipping) == 0x000078, "Member 'FGzGameSettingConfig::bAvailableInShipping' has a wrong offset!");
static_assert(offsetof(FGzGameSettingConfig, bUseSettingData) == 0x000079, "Member 'FGzGameSettingConfig::bUseSettingData' has a wrong offset!");
static_assert(offsetof(FGzGameSettingConfig, SettingData) == 0x000080, "Member 'FGzGameSettingConfig::SettingData' has a wrong offset!");
static_assert(offsetof(FGzGameSettingConfig, DisplayName) == 0x000088, "Member 'FGzGameSettingConfig::DisplayName' has a wrong offset!");
static_assert(offsetof(FGzGameSettingConfig, Description) == 0x000098, "Member 'FGzGameSettingConfig::Description' has a wrong offset!");
static_assert(offsetof(FGzGameSettingConfig, DevName) == 0x0000A8, "Member 'FGzGameSettingConfig::DevName' has a wrong offset!");
static_assert(offsetof(FGzGameSettingConfig, SettingsPresence) == 0x0000B0, "Member 'FGzGameSettingConfig::SettingsPresence' has a wrong offset!");
static_assert(offsetof(FGzGameSettingConfig, AllowedPlatforms) == 0x0000B4, "Member 'FGzGameSettingConfig::AllowedPlatforms' has a wrong offset!");

// ScriptStruct G01.GzResultGetMarketplaceItemsInfo
// 0x0050 (0x0130 - 0x00E0)
struct FGzResultGetMarketplaceItemsInfo final : public FGzPlayFabResultBase
{
public:
	TMap<class FString, struct FGzResultMarketplaceQuickBuyItemInfo> ItemsInfo;                                         // 0x00E0(0x0050)(NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzResultGetMarketplaceItemsInfo) == 0x000008, "Wrong alignment on FGzResultGetMarketplaceItemsInfo");
static_assert(sizeof(FGzResultGetMarketplaceItemsInfo) == 0x000130, "Wrong size on FGzResultGetMarketplaceItemsInfo");
static_assert(offsetof(FGzResultGetMarketplaceItemsInfo, ItemsInfo) == 0x0000E0, "Member 'FGzResultGetMarketplaceItemsInfo::ItemsInfo' has a wrong offset!");

// ScriptStruct G01.GzGameSettingCollectionData
// 0x0050 (0x0050 - 0x0000)
struct FGzGameSettingCollectionData final
{
public:
	class FText                                   Name;                                              // 0x0000(0x0010)(Edit, NativeAccessSpecifierPublic)
	class FName                                   DevName;                                           // 0x0010(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAvailableInShipping;                              // 0x0018(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2B8F[0x7];                                     // 0x0019(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UGameSettingCollection>     GameSettingCollectionClass;                        // 0x0020(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   ResetToDefaultTextOverride;                        // 0x0028(0x0010)(Edit, NativeAccessSpecifierPublic)
	TArray<struct FGzGameSettingConfig>           Settings;                                          // 0x0038(0x0010)(Edit, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	int32                                         SettingsPresence;                                  // 0x0048(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int8                                          AllowedPlatforms;                                  // 0x004C(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2B90[0x3];                                     // 0x004D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGzGameSettingCollectionData) == 0x000008, "Wrong alignment on FGzGameSettingCollectionData");
static_assert(sizeof(FGzGameSettingCollectionData) == 0x000050, "Wrong size on FGzGameSettingCollectionData");
static_assert(offsetof(FGzGameSettingCollectionData, Name) == 0x000000, "Member 'FGzGameSettingCollectionData::Name' has a wrong offset!");
static_assert(offsetof(FGzGameSettingCollectionData, DevName) == 0x000010, "Member 'FGzGameSettingCollectionData::DevName' has a wrong offset!");
static_assert(offsetof(FGzGameSettingCollectionData, bAvailableInShipping) == 0x000018, "Member 'FGzGameSettingCollectionData::bAvailableInShipping' has a wrong offset!");
static_assert(offsetof(FGzGameSettingCollectionData, GameSettingCollectionClass) == 0x000020, "Member 'FGzGameSettingCollectionData::GameSettingCollectionClass' has a wrong offset!");
static_assert(offsetof(FGzGameSettingCollectionData, ResetToDefaultTextOverride) == 0x000028, "Member 'FGzGameSettingCollectionData::ResetToDefaultTextOverride' has a wrong offset!");
static_assert(offsetof(FGzGameSettingCollectionData, Settings) == 0x000038, "Member 'FGzGameSettingCollectionData::Settings' has a wrong offset!");
static_assert(offsetof(FGzGameSettingCollectionData, SettingsPresence) == 0x000048, "Member 'FGzGameSettingCollectionData::SettingsPresence' has a wrong offset!");
static_assert(offsetof(FGzGameSettingCollectionData, AllowedPlatforms) == 0x00004C, "Member 'FGzGameSettingCollectionData::AllowedPlatforms' has a wrong offset!");

// ScriptStruct G01.GzControllerRemappingData
// 0x0030 (0x0030 - 0x0000)
struct FGzControllerRemappingData final
{
public:
	class FName                                   CollectionDevName;                                 // 0x0000(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   GamepadProfilesSettingsName;                       // 0x0008(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTagContainer                  EditConditions;                                    // 0x0010(0x0020)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzControllerRemappingData) == 0x000008, "Wrong alignment on FGzControllerRemappingData");
static_assert(sizeof(FGzControllerRemappingData) == 0x000030, "Wrong size on FGzControllerRemappingData");
static_assert(offsetof(FGzControllerRemappingData, CollectionDevName) == 0x000000, "Member 'FGzControllerRemappingData::CollectionDevName' has a wrong offset!");
static_assert(offsetof(FGzControllerRemappingData, GamepadProfilesSettingsName) == 0x000008, "Member 'FGzControllerRemappingData::GamepadProfilesSettingsName' has a wrong offset!");
static_assert(offsetof(FGzControllerRemappingData, EditConditions) == 0x000010, "Member 'FGzControllerRemappingData::EditConditions' has a wrong offset!");

// ScriptStruct G01.GzSubGameStatKey
// 0x0010 (0x0010 - 0x0000)
struct FGzSubGameStatKey final
{
public:
	class FName                                   Key;                                               // 0x0000(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   SubKey;                                            // 0x0008(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzSubGameStatKey) == 0x000004, "Wrong alignment on FGzSubGameStatKey");
static_assert(sizeof(FGzSubGameStatKey) == 0x000010, "Wrong size on FGzSubGameStatKey");
static_assert(offsetof(FGzSubGameStatKey, Key) == 0x000000, "Member 'FGzSubGameStatKey::Key' has a wrong offset!");
static_assert(offsetof(FGzSubGameStatKey, SubKey) == 0x000008, "Member 'FGzSubGameStatKey::SubKey' has a wrong offset!");

// ScriptStruct G01.GzMetaBattlePassSlotRewardV2
// 0x0030 (0x0030 - 0x0000)
struct FGzMetaBattlePassSlotRewardV2 final
{
public:
	class FName                                   ID;                                                // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EGzBattlePassSlotRewardTypeV2                 RewardType;                                        // 0x0008(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2B91[0x4];                                     // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGzMetaBattlePassSlotDirectHexRewardV2 DirectHexReward;                                   // 0x0010(0x0010)(NoDestructor, NativeAccessSpecifierPublic)
	struct FGzMetaBattlePassSlotCurrencyRewardV2  CurrencyReward;                                    // 0x0020(0x0010)(NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzMetaBattlePassSlotRewardV2) == 0x000008, "Wrong alignment on FGzMetaBattlePassSlotRewardV2");
static_assert(sizeof(FGzMetaBattlePassSlotRewardV2) == 0x000030, "Wrong size on FGzMetaBattlePassSlotRewardV2");
static_assert(offsetof(FGzMetaBattlePassSlotRewardV2, ID) == 0x000000, "Member 'FGzMetaBattlePassSlotRewardV2::ID' has a wrong offset!");
static_assert(offsetof(FGzMetaBattlePassSlotRewardV2, RewardType) == 0x000008, "Member 'FGzMetaBattlePassSlotRewardV2::RewardType' has a wrong offset!");
static_assert(offsetof(FGzMetaBattlePassSlotRewardV2, DirectHexReward) == 0x000010, "Member 'FGzMetaBattlePassSlotRewardV2::DirectHexReward' has a wrong offset!");
static_assert(offsetof(FGzMetaBattlePassSlotRewardV2, CurrencyReward) == 0x000020, "Member 'FGzMetaBattlePassSlotRewardV2::CurrencyReward' has a wrong offset!");

// ScriptStruct G01.GzMetaBattlePassBlockingSlotV2
// 0x0010 (0x0010 - 0x0000)
struct FGzMetaBattlePassBlockingSlotV2 final
{
public:
	class FName                                   PageId;                                            // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   SlotID;                                            // 0x0008(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzMetaBattlePassBlockingSlotV2) == 0x000004, "Wrong alignment on FGzMetaBattlePassBlockingSlotV2");
static_assert(sizeof(FGzMetaBattlePassBlockingSlotV2) == 0x000010, "Wrong size on FGzMetaBattlePassBlockingSlotV2");
static_assert(offsetof(FGzMetaBattlePassBlockingSlotV2, PageId) == 0x000000, "Member 'FGzMetaBattlePassBlockingSlotV2::PageId' has a wrong offset!");
static_assert(offsetof(FGzMetaBattlePassBlockingSlotV2, SlotID) == 0x000008, "Member 'FGzMetaBattlePassBlockingSlotV2::SlotID' has a wrong offset!");

// ScriptStruct G01.GzMetaBattlePassSlotPreconditionsV2
// 0x0010 (0x0010 - 0x0000)
struct FGzMetaBattlePassSlotPreconditionsV2 final
{
public:
	TArray<struct FGzMetaBattlePassBlockingSlotV2> BlockingSlots;                                     // 0x0000(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzMetaBattlePassSlotPreconditionsV2) == 0x000008, "Wrong alignment on FGzMetaBattlePassSlotPreconditionsV2");
static_assert(sizeof(FGzMetaBattlePassSlotPreconditionsV2) == 0x000010, "Wrong size on FGzMetaBattlePassSlotPreconditionsV2");
static_assert(offsetof(FGzMetaBattlePassSlotPreconditionsV2, BlockingSlots) == 0x000000, "Member 'FGzMetaBattlePassSlotPreconditionsV2::BlockingSlots' has a wrong offset!");

// ScriptStruct G01.GzMetaBattlePassSlotV2
// 0x0058 (0x0058 - 0x0000)
struct FGzMetaBattlePassSlotV2 final
{
public:
	class FName                                   ID;                                                // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGzMetaBattlePassSlotRewardV2          Reward;                                            // 0x0008(0x0030)(NoDestructor, NativeAccessSpecifierPublic)
	double                                        Price;                                             // 0x0038(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EGzBattlePassSlotStateV2                      State;                                             // 0x0040(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2B92[0x7];                                     // 0x0041(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGzMetaBattlePassSlotPreconditionsV2   PreConditions;                                     // 0x0048(0x0010)(NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzMetaBattlePassSlotV2) == 0x000008, "Wrong alignment on FGzMetaBattlePassSlotV2");
static_assert(sizeof(FGzMetaBattlePassSlotV2) == 0x000058, "Wrong size on FGzMetaBattlePassSlotV2");
static_assert(offsetof(FGzMetaBattlePassSlotV2, ID) == 0x000000, "Member 'FGzMetaBattlePassSlotV2::ID' has a wrong offset!");
static_assert(offsetof(FGzMetaBattlePassSlotV2, Reward) == 0x000008, "Member 'FGzMetaBattlePassSlotV2::Reward' has a wrong offset!");
static_assert(offsetof(FGzMetaBattlePassSlotV2, Price) == 0x000038, "Member 'FGzMetaBattlePassSlotV2::Price' has a wrong offset!");
static_assert(offsetof(FGzMetaBattlePassSlotV2, State) == 0x000040, "Member 'FGzMetaBattlePassSlotV2::State' has a wrong offset!");
static_assert(offsetof(FGzMetaBattlePassSlotV2, PreConditions) == 0x000048, "Member 'FGzMetaBattlePassSlotV2::PreConditions' has a wrong offset!");

// ScriptStruct G01.GzMetaBattlePassPageV2
// 0x0060 (0x0060 - 0x0000)
struct FGzMetaBattlePassPageV2 final
{
public:
	TMap<class FName, struct FGzMetaBattlePassSlotV2> Slots;                                             // 0x0000(0x0050)(NativeAccessSpecifierPublic)
	EGzMetaBattlePassPageLockReasonV2             LockReasons;                                       // 0x0050(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2B93[0x3];                                     // 0x0051(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         EntryLevel;                                        // 0x0054(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         EntryLoyaltyLevel;                                 // 0x0058(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2B94[0x4];                                     // 0x005C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGzMetaBattlePassPageV2) == 0x000008, "Wrong alignment on FGzMetaBattlePassPageV2");
static_assert(sizeof(FGzMetaBattlePassPageV2) == 0x000060, "Wrong size on FGzMetaBattlePassPageV2");
static_assert(offsetof(FGzMetaBattlePassPageV2, Slots) == 0x000000, "Member 'FGzMetaBattlePassPageV2::Slots' has a wrong offset!");
static_assert(offsetof(FGzMetaBattlePassPageV2, LockReasons) == 0x000050, "Member 'FGzMetaBattlePassPageV2::LockReasons' has a wrong offset!");
static_assert(offsetof(FGzMetaBattlePassPageV2, EntryLevel) == 0x000054, "Member 'FGzMetaBattlePassPageV2::EntryLevel' has a wrong offset!");
static_assert(offsetof(FGzMetaBattlePassPageV2, EntryLoyaltyLevel) == 0x000058, "Member 'FGzMetaBattlePassPageV2::EntryLoyaltyLevel' has a wrong offset!");

// ScriptStruct G01.GzMetaBattlePassPagesCollectionV2
// 0x0050 (0x0050 - 0x0000)
struct FGzMetaBattlePassPagesCollectionV2 final
{
public:
	TMap<class FName, struct FGzMetaBattlePassPageV2> Pages;                                             // 0x0000(0x0050)(NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzMetaBattlePassPagesCollectionV2) == 0x000008, "Wrong alignment on FGzMetaBattlePassPagesCollectionV2");
static_assert(sizeof(FGzMetaBattlePassPagesCollectionV2) == 0x000050, "Wrong size on FGzMetaBattlePassPagesCollectionV2");
static_assert(offsetof(FGzMetaBattlePassPagesCollectionV2, Pages) == 0x000000, "Member 'FGzMetaBattlePassPagesCollectionV2::Pages' has a wrong offset!");

// ScriptStruct G01.GzBreakableConnection
// 0x0010 (0x0010 - 0x0000)
struct FGzBreakableConnection final
{
public:
	class AActor*                                 BreakableVisualActor;                              // 0x0000(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 BreakableRepProxyActor;                            // 0x0008(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzBreakableConnection) == 0x000008, "Wrong alignment on FGzBreakableConnection");
static_assert(sizeof(FGzBreakableConnection) == 0x000010, "Wrong size on FGzBreakableConnection");
static_assert(offsetof(FGzBreakableConnection, BreakableVisualActor) == 0x000000, "Member 'FGzBreakableConnection::BreakableVisualActor' has a wrong offset!");
static_assert(offsetof(FGzBreakableConnection, BreakableRepProxyActor) == 0x000008, "Member 'FGzBreakableConnection::BreakableRepProxyActor' has a wrong offset!");

// ScriptStruct G01.GzLimbStateTagsSettings
// 0x0038 (0x0038 - 0x0000)
struct FGzLimbStateTagsSettings final
{
public:
	TSubclassOf<class UGzGE_AbsentLimb>           LimbAbsentEffect;                                  // 0x0000(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UGzGE_PresentLimb>          LimbPresentEffect;                                 // 0x0008(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           LimbAttaching;                                     // 0x0010(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           LimbDetaching;                                     // 0x0018(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           LimbDetachingForced;                               // 0x0020(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           LimbSwapping;                                      // 0x0028(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           LimbMangled;                                       // 0x0030(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzLimbStateTagsSettings) == 0x000008, "Wrong alignment on FGzLimbStateTagsSettings");
static_assert(sizeof(FGzLimbStateTagsSettings) == 0x000038, "Wrong size on FGzLimbStateTagsSettings");
static_assert(offsetof(FGzLimbStateTagsSettings, LimbAbsentEffect) == 0x000000, "Member 'FGzLimbStateTagsSettings::LimbAbsentEffect' has a wrong offset!");
static_assert(offsetof(FGzLimbStateTagsSettings, LimbPresentEffect) == 0x000008, "Member 'FGzLimbStateTagsSettings::LimbPresentEffect' has a wrong offset!");
static_assert(offsetof(FGzLimbStateTagsSettings, LimbAttaching) == 0x000010, "Member 'FGzLimbStateTagsSettings::LimbAttaching' has a wrong offset!");
static_assert(offsetof(FGzLimbStateTagsSettings, LimbDetaching) == 0x000018, "Member 'FGzLimbStateTagsSettings::LimbDetaching' has a wrong offset!");
static_assert(offsetof(FGzLimbStateTagsSettings, LimbDetachingForced) == 0x000020, "Member 'FGzLimbStateTagsSettings::LimbDetachingForced' has a wrong offset!");
static_assert(offsetof(FGzLimbStateTagsSettings, LimbSwapping) == 0x000028, "Member 'FGzLimbStateTagsSettings::LimbSwapping' has a wrong offset!");
static_assert(offsetof(FGzLimbStateTagsSettings, LimbMangled) == 0x000030, "Member 'FGzLimbStateTagsSettings::LimbMangled' has a wrong offset!");

// ScriptStruct G01.GzLimbStateTags
// 0x0014 (0x0014 - 0x0000)
struct FGzLimbStateTags final
{
public:
	int32                                         AnyLimbState;                                      // 0x0000(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           StateActive;                                       // 0x0004(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           StateNotActive;                                    // 0x000C(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzLimbStateTags) == 0x000004, "Wrong alignment on FGzLimbStateTags");
static_assert(sizeof(FGzLimbStateTags) == 0x000014, "Wrong size on FGzLimbStateTags");
static_assert(offsetof(FGzLimbStateTags, AnyLimbState) == 0x000000, "Member 'FGzLimbStateTags::AnyLimbState' has a wrong offset!");
static_assert(offsetof(FGzLimbStateTags, StateActive) == 0x000004, "Member 'FGzLimbStateTags::StateActive' has a wrong offset!");
static_assert(offsetof(FGzLimbStateTags, StateNotActive) == 0x00000C, "Member 'FGzLimbStateTags::StateNotActive' has a wrong offset!");

// ScriptStruct G01.GzLimbAttachingParams
// 0x0040 (0x0040 - 0x0000)
struct FGzLimbAttachingParams final
{
public:
	class FName                                   AttachedMontageNotifyName;                         // 0x0000(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   PointOfNoReturnMontageNotifyName;                  // 0x0008(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bOverrideDuration;                                 // 0x0010(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2B95[0x3];                                     // 0x0011(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         OverridenDuration;                                 // 0x0014(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SecondsToConfirmCancel;                            // 0x0018(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxCharacterRotationDuration;                      // 0x001C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bRotateCharacterCamera;                            // 0x0020(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bChangeLookUpAngle;                                // 0x0021(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2B96[0x2];                                     // 0x0022(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         CharacterTargetLookUpAngle;                        // 0x0024(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class AGzLimbAttachingReplica>    LimbAttachingProxyClass;                           // 0x0028(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AbilityDuration;                                   // 0x0030(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AnimMontageDuration;                               // 0x0034(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LimbAttachingDuration;                             // 0x0038(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LatestCancelTimeNormalized;                        // 0x003C(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzLimbAttachingParams) == 0x000008, "Wrong alignment on FGzLimbAttachingParams");
static_assert(sizeof(FGzLimbAttachingParams) == 0x000040, "Wrong size on FGzLimbAttachingParams");
static_assert(offsetof(FGzLimbAttachingParams, AttachedMontageNotifyName) == 0x000000, "Member 'FGzLimbAttachingParams::AttachedMontageNotifyName' has a wrong offset!");
static_assert(offsetof(FGzLimbAttachingParams, PointOfNoReturnMontageNotifyName) == 0x000008, "Member 'FGzLimbAttachingParams::PointOfNoReturnMontageNotifyName' has a wrong offset!");
static_assert(offsetof(FGzLimbAttachingParams, bOverrideDuration) == 0x000010, "Member 'FGzLimbAttachingParams::bOverrideDuration' has a wrong offset!");
static_assert(offsetof(FGzLimbAttachingParams, OverridenDuration) == 0x000014, "Member 'FGzLimbAttachingParams::OverridenDuration' has a wrong offset!");
static_assert(offsetof(FGzLimbAttachingParams, SecondsToConfirmCancel) == 0x000018, "Member 'FGzLimbAttachingParams::SecondsToConfirmCancel' has a wrong offset!");
static_assert(offsetof(FGzLimbAttachingParams, MaxCharacterRotationDuration) == 0x00001C, "Member 'FGzLimbAttachingParams::MaxCharacterRotationDuration' has a wrong offset!");
static_assert(offsetof(FGzLimbAttachingParams, bRotateCharacterCamera) == 0x000020, "Member 'FGzLimbAttachingParams::bRotateCharacterCamera' has a wrong offset!");
static_assert(offsetof(FGzLimbAttachingParams, bChangeLookUpAngle) == 0x000021, "Member 'FGzLimbAttachingParams::bChangeLookUpAngle' has a wrong offset!");
static_assert(offsetof(FGzLimbAttachingParams, CharacterTargetLookUpAngle) == 0x000024, "Member 'FGzLimbAttachingParams::CharacterTargetLookUpAngle' has a wrong offset!");
static_assert(offsetof(FGzLimbAttachingParams, LimbAttachingProxyClass) == 0x000028, "Member 'FGzLimbAttachingParams::LimbAttachingProxyClass' has a wrong offset!");
static_assert(offsetof(FGzLimbAttachingParams, AbilityDuration) == 0x000030, "Member 'FGzLimbAttachingParams::AbilityDuration' has a wrong offset!");
static_assert(offsetof(FGzLimbAttachingParams, AnimMontageDuration) == 0x000034, "Member 'FGzLimbAttachingParams::AnimMontageDuration' has a wrong offset!");
static_assert(offsetof(FGzLimbAttachingParams, LimbAttachingDuration) == 0x000038, "Member 'FGzLimbAttachingParams::LimbAttachingDuration' has a wrong offset!");
static_assert(offsetof(FGzLimbAttachingParams, LatestCancelTimeNormalized) == 0x00003C, "Member 'FGzLimbAttachingParams::LatestCancelTimeNormalized' has a wrong offset!");

// ScriptStruct G01.GzMissionRewardWidgetData
// 0x0038 (0x0038 - 0x0000)
struct FGzMissionRewardWidgetData final
{
public:
	TSoftObjectPtr<class UTexture2D>              RewardIcon;                                        // 0x0000(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   RewardText;                                        // 0x0028(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzMissionRewardWidgetData) == 0x000008, "Wrong alignment on FGzMissionRewardWidgetData");
static_assert(sizeof(FGzMissionRewardWidgetData) == 0x000038, "Wrong size on FGzMissionRewardWidgetData");
static_assert(offsetof(FGzMissionRewardWidgetData, RewardIcon) == 0x000000, "Member 'FGzMissionRewardWidgetData::RewardIcon' has a wrong offset!");
static_assert(offsetof(FGzMissionRewardWidgetData, RewardText) == 0x000028, "Member 'FGzMissionRewardWidgetData::RewardText' has a wrong offset!");

// ScriptStruct G01.GzLimbDetachingParams
// 0x0060 (0x0060 - 0x0000)
struct FGzLimbDetachingParams final
{
public:
	class FName                                   DetachLimbMontageNotifyName;                       // 0x0000(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ImpulseMagnitudeForArms;                           // 0x0008(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ImpulseMagnitudeForLegs;                           // 0x000C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDisableLegsLooseAnimInKnockDownState;             // 0x0010(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2B97[0x7];                                     // 0x0011(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class APawn*                                  Instigator;                                        // 0x0018(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UGzBodyPartItemData*                    BodyPartItemData;                                  // 0x0020(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2B98[0x38];                                    // 0x0028(0x0038)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGzLimbDetachingParams) == 0x000008, "Wrong alignment on FGzLimbDetachingParams");
static_assert(sizeof(FGzLimbDetachingParams) == 0x000060, "Wrong size on FGzLimbDetachingParams");
static_assert(offsetof(FGzLimbDetachingParams, DetachLimbMontageNotifyName) == 0x000000, "Member 'FGzLimbDetachingParams::DetachLimbMontageNotifyName' has a wrong offset!");
static_assert(offsetof(FGzLimbDetachingParams, ImpulseMagnitudeForArms) == 0x000008, "Member 'FGzLimbDetachingParams::ImpulseMagnitudeForArms' has a wrong offset!");
static_assert(offsetof(FGzLimbDetachingParams, ImpulseMagnitudeForLegs) == 0x00000C, "Member 'FGzLimbDetachingParams::ImpulseMagnitudeForLegs' has a wrong offset!");
static_assert(offsetof(FGzLimbDetachingParams, bDisableLegsLooseAnimInKnockDownState) == 0x000010, "Member 'FGzLimbDetachingParams::bDisableLegsLooseAnimInKnockDownState' has a wrong offset!");
static_assert(offsetof(FGzLimbDetachingParams, Instigator) == 0x000018, "Member 'FGzLimbDetachingParams::Instigator' has a wrong offset!");
static_assert(offsetof(FGzLimbDetachingParams, BodyPartItemData) == 0x000020, "Member 'FGzLimbDetachingParams::BodyPartItemData' has a wrong offset!");

// ScriptStruct G01.GzStateVariant
// 0x0058 (0x0058 - 0x0000)
struct FGzStateVariant final
{
public:
	struct FGameplayTagContainer                  ActivationRequiredTags;                            // 0x0000(0x0020)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FGameplayTagContainer                  ActivationBlockedTags;                             // 0x0020(0x0020)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	bool                                          bUniqueVariant;                                    // 0x0040(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseAbilityTriggerPayloadTags;                     // 0x0041(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2B99[0x6];                                     // 0x0042(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UGzStateAction*>                 StateActions;                                      // 0x0048(0x0010)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzStateVariant) == 0x000008, "Wrong alignment on FGzStateVariant");
static_assert(sizeof(FGzStateVariant) == 0x000058, "Wrong size on FGzStateVariant");
static_assert(offsetof(FGzStateVariant, ActivationRequiredTags) == 0x000000, "Member 'FGzStateVariant::ActivationRequiredTags' has a wrong offset!");
static_assert(offsetof(FGzStateVariant, ActivationBlockedTags) == 0x000020, "Member 'FGzStateVariant::ActivationBlockedTags' has a wrong offset!");
static_assert(offsetof(FGzStateVariant, bUniqueVariant) == 0x000040, "Member 'FGzStateVariant::bUniqueVariant' has a wrong offset!");
static_assert(offsetof(FGzStateVariant, bUseAbilityTriggerPayloadTags) == 0x000041, "Member 'FGzStateVariant::bUseAbilityTriggerPayloadTags' has a wrong offset!");
static_assert(offsetof(FGzStateVariant, StateActions) == 0x000048, "Member 'FGzStateVariant::StateActions' has a wrong offset!");

// ScriptStruct G01.GzConsumeAnimationData
// 0x0010 (0x0010 - 0x0000)
struct FGzConsumeAnimationData final
{
public:
	int32                                         LimbState;                                         // 0x0000(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2B9A[0x4];                                     // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UAnimMontage*                           Montage;                                           // 0x0008(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzConsumeAnimationData) == 0x000008, "Wrong alignment on FGzConsumeAnimationData");
static_assert(sizeof(FGzConsumeAnimationData) == 0x000010, "Wrong size on FGzConsumeAnimationData");
static_assert(offsetof(FGzConsumeAnimationData, LimbState) == 0x000000, "Member 'FGzConsumeAnimationData::LimbState' has a wrong offset!");
static_assert(offsetof(FGzConsumeAnimationData, Montage) == 0x000008, "Member 'FGzConsumeAnimationData::Montage' has a wrong offset!");

// ScriptStruct G01.GzMetaBattlePassLevelProgressionV2
// 0x000C (0x000C - 0x0000)
struct FGzMetaBattlePassLevelProgressionV2 final
{
public:
	int32                                         Level;                                             // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Xp;                                                // 0x0004(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         XpToNextLevel;                                     // 0x0008(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzMetaBattlePassLevelProgressionV2) == 0x000004, "Wrong alignment on FGzMetaBattlePassLevelProgressionV2");
static_assert(sizeof(FGzMetaBattlePassLevelProgressionV2) == 0x00000C, "Wrong size on FGzMetaBattlePassLevelProgressionV2");
static_assert(offsetof(FGzMetaBattlePassLevelProgressionV2, Level) == 0x000000, "Member 'FGzMetaBattlePassLevelProgressionV2::Level' has a wrong offset!");
static_assert(offsetof(FGzMetaBattlePassLevelProgressionV2, Xp) == 0x000004, "Member 'FGzMetaBattlePassLevelProgressionV2::Xp' has a wrong offset!");
static_assert(offsetof(FGzMetaBattlePassLevelProgressionV2, XpToNextLevel) == 0x000008, "Member 'FGzMetaBattlePassLevelProgressionV2::XpToNextLevel' has a wrong offset!");

// ScriptStruct G01.GameplayAbilityTargetData_Mantle
// 0x0060 (0x0068 - 0x0008)
struct FGameplayAbilityTargetData_Mantle final : public FGameplayAbilityTargetData
{
public:
	struct FVector                                AttachLoc;                                         // 0x0008(0x0018)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               AttachRot;                                         // 0x0020(0x0018)(ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          bHasLandLoc;                                       // 0x0038(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2B9B[0x7];                                     // 0x0039(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                LandLoc;                                           // 0x0040(0x0018)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ELocomotionMantleType                         ScenarioType;                                      // 0x0058(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2B9C[0x3];                                     // 0x0059(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         ScenarioId;                                        // 0x005C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          VaultFallCancelScenario;                           // 0x0060(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          VaultFallScenario;                                 // 0x0061(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2B9D[0x6];                                     // 0x0062(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGameplayAbilityTargetData_Mantle) == 0x000008, "Wrong alignment on FGameplayAbilityTargetData_Mantle");
static_assert(sizeof(FGameplayAbilityTargetData_Mantle) == 0x000068, "Wrong size on FGameplayAbilityTargetData_Mantle");
static_assert(offsetof(FGameplayAbilityTargetData_Mantle, AttachLoc) == 0x000008, "Member 'FGameplayAbilityTargetData_Mantle::AttachLoc' has a wrong offset!");
static_assert(offsetof(FGameplayAbilityTargetData_Mantle, AttachRot) == 0x000020, "Member 'FGameplayAbilityTargetData_Mantle::AttachRot' has a wrong offset!");
static_assert(offsetof(FGameplayAbilityTargetData_Mantle, bHasLandLoc) == 0x000038, "Member 'FGameplayAbilityTargetData_Mantle::bHasLandLoc' has a wrong offset!");
static_assert(offsetof(FGameplayAbilityTargetData_Mantle, LandLoc) == 0x000040, "Member 'FGameplayAbilityTargetData_Mantle::LandLoc' has a wrong offset!");
static_assert(offsetof(FGameplayAbilityTargetData_Mantle, ScenarioType) == 0x000058, "Member 'FGameplayAbilityTargetData_Mantle::ScenarioType' has a wrong offset!");
static_assert(offsetof(FGameplayAbilityTargetData_Mantle, ScenarioId) == 0x00005C, "Member 'FGameplayAbilityTargetData_Mantle::ScenarioId' has a wrong offset!");
static_assert(offsetof(FGameplayAbilityTargetData_Mantle, VaultFallCancelScenario) == 0x000060, "Member 'FGameplayAbilityTargetData_Mantle::VaultFallCancelScenario' has a wrong offset!");
static_assert(offsetof(FGameplayAbilityTargetData_Mantle, VaultFallScenario) == 0x000061, "Member 'FGameplayAbilityTargetData_Mantle::VaultFallScenario' has a wrong offset!");

// ScriptStruct G01.GzMantleRulesRelaxationParams
// 0x0003 (0x0003 - 0x0000)
struct FGzMantleRulesRelaxationParams final
{
public:
	bool                                          bIgnoreThickness;                                  // 0x0000(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIgnoreVault;                                      // 0x0001(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIgnoreVerticalAngle;                              // 0x0002(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzMantleRulesRelaxationParams) == 0x000001, "Wrong alignment on FGzMantleRulesRelaxationParams");
static_assert(sizeof(FGzMantleRulesRelaxationParams) == 0x000003, "Wrong size on FGzMantleRulesRelaxationParams");
static_assert(offsetof(FGzMantleRulesRelaxationParams, bIgnoreThickness) == 0x000000, "Member 'FGzMantleRulesRelaxationParams::bIgnoreThickness' has a wrong offset!");
static_assert(offsetof(FGzMantleRulesRelaxationParams, bIgnoreVault) == 0x000001, "Member 'FGzMantleRulesRelaxationParams::bIgnoreVault' has a wrong offset!");
static_assert(offsetof(FGzMantleRulesRelaxationParams, bIgnoreVerticalAngle) == 0x000002, "Member 'FGzMantleRulesRelaxationParams::bIgnoreVerticalAngle' has a wrong offset!");

// ScriptStruct G01.GzBaseMantleNetParams
// 0x0110 (0x0110 - 0x0000)
struct FGzBaseMantleNetParams final
{
public:
	struct FGzTransformNoScale                    MantlingStart;                                     // 0x0000(0x0050)(NoDestructor, NativeAccessSpecifierPublic)
	struct FMantleLedgeInfo                       LedgeInfo;                                         // 0x0050(0x0060)(NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	float                                         MantleHeight;                                      // 0x00B0(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MantleDistance;                                    // 0x00B4(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ELocomotionMovementState                      MovementState;                                     // 0x00B8(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2B9E[0x7];                                     // 0x00B9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector_NetQuantize                    TargetLocation;                                    // 0x00C0(0x0018)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               TargetRotation;                                    // 0x00D8(0x0018)(ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	float                                         LedgeThickness;                                    // 0x00F0(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ApproachVerticalAngle;                             // 0x00F4(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Altitude;                                          // 0x00F8(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Speed;                                             // 0x00FC(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          VaultFallCancelScenario;                           // 0x0100(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          VaultFallScenario;                                 // 0x0101(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2B9F[0x2];                                     // 0x0102(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ExitBlendWeight;                                   // 0x0104(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGzMantleRulesRelaxationParams         RulesRelaxationParams;                             // 0x0108(0x0003)(NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_2BA0[0x5];                                     // 0x010B(0x0005)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGzBaseMantleNetParams) == 0x000010, "Wrong alignment on FGzBaseMantleNetParams");
static_assert(sizeof(FGzBaseMantleNetParams) == 0x000110, "Wrong size on FGzBaseMantleNetParams");
static_assert(offsetof(FGzBaseMantleNetParams, MantlingStart) == 0x000000, "Member 'FGzBaseMantleNetParams::MantlingStart' has a wrong offset!");
static_assert(offsetof(FGzBaseMantleNetParams, LedgeInfo) == 0x000050, "Member 'FGzBaseMantleNetParams::LedgeInfo' has a wrong offset!");
static_assert(offsetof(FGzBaseMantleNetParams, MantleHeight) == 0x0000B0, "Member 'FGzBaseMantleNetParams::MantleHeight' has a wrong offset!");
static_assert(offsetof(FGzBaseMantleNetParams, MantleDistance) == 0x0000B4, "Member 'FGzBaseMantleNetParams::MantleDistance' has a wrong offset!");
static_assert(offsetof(FGzBaseMantleNetParams, MovementState) == 0x0000B8, "Member 'FGzBaseMantleNetParams::MovementState' has a wrong offset!");
static_assert(offsetof(FGzBaseMantleNetParams, TargetLocation) == 0x0000C0, "Member 'FGzBaseMantleNetParams::TargetLocation' has a wrong offset!");
static_assert(offsetof(FGzBaseMantleNetParams, TargetRotation) == 0x0000D8, "Member 'FGzBaseMantleNetParams::TargetRotation' has a wrong offset!");
static_assert(offsetof(FGzBaseMantleNetParams, LedgeThickness) == 0x0000F0, "Member 'FGzBaseMantleNetParams::LedgeThickness' has a wrong offset!");
static_assert(offsetof(FGzBaseMantleNetParams, ApproachVerticalAngle) == 0x0000F4, "Member 'FGzBaseMantleNetParams::ApproachVerticalAngle' has a wrong offset!");
static_assert(offsetof(FGzBaseMantleNetParams, Altitude) == 0x0000F8, "Member 'FGzBaseMantleNetParams::Altitude' has a wrong offset!");
static_assert(offsetof(FGzBaseMantleNetParams, Speed) == 0x0000FC, "Member 'FGzBaseMantleNetParams::Speed' has a wrong offset!");
static_assert(offsetof(FGzBaseMantleNetParams, VaultFallCancelScenario) == 0x000100, "Member 'FGzBaseMantleNetParams::VaultFallCancelScenario' has a wrong offset!");
static_assert(offsetof(FGzBaseMantleNetParams, VaultFallScenario) == 0x000101, "Member 'FGzBaseMantleNetParams::VaultFallScenario' has a wrong offset!");
static_assert(offsetof(FGzBaseMantleNetParams, ExitBlendWeight) == 0x000104, "Member 'FGzBaseMantleNetParams::ExitBlendWeight' has a wrong offset!");
static_assert(offsetof(FGzBaseMantleNetParams, RulesRelaxationParams) == 0x000108, "Member 'FGzBaseMantleNetParams::RulesRelaxationParams' has a wrong offset!");

// ScriptStruct G01.GzMantlingScenarioHolder
// 0x0010 (0x0010 - 0x0000)
struct FGzMantlingScenarioHolder final
{
public:
	ELocomotionMantleType                         ScenarioType;                                      // 0x0000(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2BA1[0x3];                                     // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         ScenarioId;                                        // 0x0004(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ULocomotionMantleAsset*                 CachedAsset;                                       // 0x0008(0x0008)(ZeroConstructor, RepSkip, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzMantlingScenarioHolder) == 0x000008, "Wrong alignment on FGzMantlingScenarioHolder");
static_assert(sizeof(FGzMantlingScenarioHolder) == 0x000010, "Wrong size on FGzMantlingScenarioHolder");
static_assert(offsetof(FGzMantlingScenarioHolder, ScenarioType) == 0x000000, "Member 'FGzMantlingScenarioHolder::ScenarioType' has a wrong offset!");
static_assert(offsetof(FGzMantlingScenarioHolder, ScenarioId) == 0x000004, "Member 'FGzMantlingScenarioHolder::ScenarioId' has a wrong offset!");
static_assert(offsetof(FGzMantlingScenarioHolder, CachedAsset) == 0x000008, "Member 'FGzMantlingScenarioHolder::CachedAsset' has a wrong offset!");

// ScriptStruct G01.MantleAbilityActivationData
// 0x03D0 (0x03D0 - 0x0000)
struct FMantleAbilityActivationData final
{
public:
	struct FVector                                InitialTraceImpactNormal;                          // 0x0000(0x0018)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FHitResult                             InitialTrace;                                      // 0x0018(0x00F8)(IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FHitResult                             TargetSpot;                                        // 0x0110(0x00F8)(IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FVector                                AttachLoc;                                         // 0x0208(0x0018)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bHasLandLoc;                                       // 0x0220(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2BA2[0x7];                                     // 0x0221(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                LandLoc;                                           // 0x0228(0x0018)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FTransform                             OwnerTransform;                                    // 0x0240(0x0060)(IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGzMantlingScenarioHolder              MantlingScenario;                                  // 0x02A0(0x0010)(NoDestructor, NativeAccessSpecifierPublic)
	float                                         DebugAfterObstacleVaultingHeight;                  // 0x02B0(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2BA3[0xC];                                     // 0x02B4(0x000C)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGzBaseMantleNetParams                 BaseParams;                                        // 0x02C0(0x0110)(NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMantleAbilityActivationData) == 0x000010, "Wrong alignment on FMantleAbilityActivationData");
static_assert(sizeof(FMantleAbilityActivationData) == 0x0003D0, "Wrong size on FMantleAbilityActivationData");
static_assert(offsetof(FMantleAbilityActivationData, InitialTraceImpactNormal) == 0x000000, "Member 'FMantleAbilityActivationData::InitialTraceImpactNormal' has a wrong offset!");
static_assert(offsetof(FMantleAbilityActivationData, InitialTrace) == 0x000018, "Member 'FMantleAbilityActivationData::InitialTrace' has a wrong offset!");
static_assert(offsetof(FMantleAbilityActivationData, TargetSpot) == 0x000110, "Member 'FMantleAbilityActivationData::TargetSpot' has a wrong offset!");
static_assert(offsetof(FMantleAbilityActivationData, AttachLoc) == 0x000208, "Member 'FMantleAbilityActivationData::AttachLoc' has a wrong offset!");
static_assert(offsetof(FMantleAbilityActivationData, bHasLandLoc) == 0x000220, "Member 'FMantleAbilityActivationData::bHasLandLoc' has a wrong offset!");
static_assert(offsetof(FMantleAbilityActivationData, LandLoc) == 0x000228, "Member 'FMantleAbilityActivationData::LandLoc' has a wrong offset!");
static_assert(offsetof(FMantleAbilityActivationData, OwnerTransform) == 0x000240, "Member 'FMantleAbilityActivationData::OwnerTransform' has a wrong offset!");
static_assert(offsetof(FMantleAbilityActivationData, MantlingScenario) == 0x0002A0, "Member 'FMantleAbilityActivationData::MantlingScenario' has a wrong offset!");
static_assert(offsetof(FMantleAbilityActivationData, DebugAfterObstacleVaultingHeight) == 0x0002B0, "Member 'FMantleAbilityActivationData::DebugAfterObstacleVaultingHeight' has a wrong offset!");
static_assert(offsetof(FMantleAbilityActivationData, BaseParams) == 0x0002C0, "Member 'FMantleAbilityActivationData::BaseParams' has a wrong offset!");

// ScriptStruct G01.GzSpiderMine_SpawnInfo
// 0x0004 (0x0004 - 0x0000)
struct FGzSpiderMine_SpawnInfo final
{
public:
	float                                         MaxHealth;                                         // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzSpiderMine_SpawnInfo) == 0x000004, "Wrong alignment on FGzSpiderMine_SpawnInfo");
static_assert(sizeof(FGzSpiderMine_SpawnInfo) == 0x000004, "Wrong size on FGzSpiderMine_SpawnInfo");
static_assert(offsetof(FGzSpiderMine_SpawnInfo, MaxHealth) == 0x000000, "Member 'FGzSpiderMine_SpawnInfo::MaxHealth' has a wrong offset!");

// ScriptStruct G01.GzSpawnContentsParameters
// 0x0030 (0x0030 - 0x0000)
struct FGzSpawnContentsParameters final
{
public:
	TArray<struct FGzInvItem>                     InvItems;                                          // 0x0000(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FTransform>                     InitialWorldSpawnTransforms;                       // 0x0010(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<ECollisionChannel>                     AdditionalCollisionChannelsToBlock;                // 0x0020(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzSpawnContentsParameters) == 0x000008, "Wrong alignment on FGzSpawnContentsParameters");
static_assert(sizeof(FGzSpawnContentsParameters) == 0x000030, "Wrong size on FGzSpawnContentsParameters");
static_assert(offsetof(FGzSpawnContentsParameters, InvItems) == 0x000000, "Member 'FGzSpawnContentsParameters::InvItems' has a wrong offset!");
static_assert(offsetof(FGzSpawnContentsParameters, InitialWorldSpawnTransforms) == 0x000010, "Member 'FGzSpawnContentsParameters::InitialWorldSpawnTransforms' has a wrong offset!");
static_assert(offsetof(FGzSpawnContentsParameters, AdditionalCollisionChannelsToBlock) == 0x000020, "Member 'FGzSpawnContentsParameters::AdditionalCollisionChannelsToBlock' has a wrong offset!");

// ScriptStruct G01.GzThrowAnimationData
// 0x0020 (0x0020 - 0x0000)
struct FGzThrowAnimationData final
{
public:
	int32                                         LimbState;                                         // 0x0000(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2BA4[0x4];                                     // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UAnimMontage*                           Montage;                                           // 0x0008(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   ThrowAnimNotificationEventName;                    // 0x0010(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   PredictedPathAnimNotificationEventName;            // 0x0018(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzThrowAnimationData) == 0x000008, "Wrong alignment on FGzThrowAnimationData");
static_assert(sizeof(FGzThrowAnimationData) == 0x000020, "Wrong size on FGzThrowAnimationData");
static_assert(offsetof(FGzThrowAnimationData, LimbState) == 0x000000, "Member 'FGzThrowAnimationData::LimbState' has a wrong offset!");
static_assert(offsetof(FGzThrowAnimationData, Montage) == 0x000008, "Member 'FGzThrowAnimationData::Montage' has a wrong offset!");
static_assert(offsetof(FGzThrowAnimationData, ThrowAnimNotificationEventName) == 0x000010, "Member 'FGzThrowAnimationData::ThrowAnimNotificationEventName' has a wrong offset!");
static_assert(offsetof(FGzThrowAnimationData, PredictedPathAnimNotificationEventName) == 0x000018, "Member 'FGzThrowAnimationData::PredictedPathAnimNotificationEventName' has a wrong offset!");

// ScriptStruct G01.GzSurfaceImpactSoundCell
// 0x0010 (0x0010 - 0x0000)
struct FGzSurfaceImpactSoundCell final
{
public:
	EPhysicalSurface                              Key;                                               // 0x0000(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2BA5[0x7];                                     // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UAkAudioEvent*                          Value;                                             // 0x0008(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzSurfaceImpactSoundCell) == 0x000008, "Wrong alignment on FGzSurfaceImpactSoundCell");
static_assert(sizeof(FGzSurfaceImpactSoundCell) == 0x000010, "Wrong size on FGzSurfaceImpactSoundCell");
static_assert(offsetof(FGzSurfaceImpactSoundCell, Key) == 0x000000, "Member 'FGzSurfaceImpactSoundCell::Key' has a wrong offset!");
static_assert(offsetof(FGzSurfaceImpactSoundCell, Value) == 0x000008, "Member 'FGzSurfaceImpactSoundCell::Value' has a wrong offset!");

// ScriptStruct G01.GzSurfaceImpactSound
// 0x0060 (0x0060 - 0x0000)
struct FGzSurfaceImpactSound final
{
public:
	TArray<struct FGzSurfaceImpactSoundCell>      Light;                                             // 0x0000(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TArray<struct FGzSurfaceImpactSoundCell>      Medium;                                            // 0x0010(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TArray<struct FGzSurfaceImpactSoundCell>      Heavy;                                             // 0x0020(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TArray<struct FGzSurfaceImpactSoundCell>      Shotgun;                                           // 0x0030(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TArray<struct FGzSurfaceImpactSoundCell>      Explosion;                                         // 0x0040(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TArray<struct FGzSurfaceImpactSoundCell>      Energy;                                            // 0x0050(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzSurfaceImpactSound) == 0x000008, "Wrong alignment on FGzSurfaceImpactSound");
static_assert(sizeof(FGzSurfaceImpactSound) == 0x000060, "Wrong size on FGzSurfaceImpactSound");
static_assert(offsetof(FGzSurfaceImpactSound, Light) == 0x000000, "Member 'FGzSurfaceImpactSound::Light' has a wrong offset!");
static_assert(offsetof(FGzSurfaceImpactSound, Medium) == 0x000010, "Member 'FGzSurfaceImpactSound::Medium' has a wrong offset!");
static_assert(offsetof(FGzSurfaceImpactSound, Heavy) == 0x000020, "Member 'FGzSurfaceImpactSound::Heavy' has a wrong offset!");
static_assert(offsetof(FGzSurfaceImpactSound, Shotgun) == 0x000030, "Member 'FGzSurfaceImpactSound::Shotgun' has a wrong offset!");
static_assert(offsetof(FGzSurfaceImpactSound, Explosion) == 0x000040, "Member 'FGzSurfaceImpactSound::Explosion' has a wrong offset!");
static_assert(offsetof(FGzSurfaceImpactSound, Energy) == 0x000050, "Member 'FGzSurfaceImpactSound::Energy' has a wrong offset!");

// ScriptStruct G01.GzSurfaceBulletDecalsCell
// 0x0018 (0x0018 - 0x0000)
struct FGzSurfaceBulletDecalsCell final
{
public:
	EPhysicalSurface                              Key;                                               // 0x0000(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2BA6[0x7];                                     // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UMaterialInterface*>             Value;                                             // 0x0008(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzSurfaceBulletDecalsCell) == 0x000008, "Wrong alignment on FGzSurfaceBulletDecalsCell");
static_assert(sizeof(FGzSurfaceBulletDecalsCell) == 0x000018, "Wrong size on FGzSurfaceBulletDecalsCell");
static_assert(offsetof(FGzSurfaceBulletDecalsCell, Key) == 0x000000, "Member 'FGzSurfaceBulletDecalsCell::Key' has a wrong offset!");
static_assert(offsetof(FGzSurfaceBulletDecalsCell, Value) == 0x000008, "Member 'FGzSurfaceBulletDecalsCell::Value' has a wrong offset!");

// ScriptStruct G01.GzSurfaceBulletDecals
// 0x0060 (0x0060 - 0x0000)
struct FGzSurfaceBulletDecals final
{
public:
	TArray<struct FGzSurfaceBulletDecalsCell>     Light;                                             // 0x0000(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TArray<struct FGzSurfaceBulletDecalsCell>     Medium;                                            // 0x0010(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TArray<struct FGzSurfaceBulletDecalsCell>     Heavy;                                             // 0x0020(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TArray<struct FGzSurfaceBulletDecalsCell>     Shotgun;                                           // 0x0030(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TArray<struct FGzSurfaceBulletDecalsCell>     Explosion;                                         // 0x0040(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TArray<struct FGzSurfaceBulletDecalsCell>     Energy;                                            // 0x0050(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzSurfaceBulletDecals) == 0x000008, "Wrong alignment on FGzSurfaceBulletDecals");
static_assert(sizeof(FGzSurfaceBulletDecals) == 0x000060, "Wrong size on FGzSurfaceBulletDecals");
static_assert(offsetof(FGzSurfaceBulletDecals, Light) == 0x000000, "Member 'FGzSurfaceBulletDecals::Light' has a wrong offset!");
static_assert(offsetof(FGzSurfaceBulletDecals, Medium) == 0x000010, "Member 'FGzSurfaceBulletDecals::Medium' has a wrong offset!");
static_assert(offsetof(FGzSurfaceBulletDecals, Heavy) == 0x000020, "Member 'FGzSurfaceBulletDecals::Heavy' has a wrong offset!");
static_assert(offsetof(FGzSurfaceBulletDecals, Shotgun) == 0x000030, "Member 'FGzSurfaceBulletDecals::Shotgun' has a wrong offset!");
static_assert(offsetof(FGzSurfaceBulletDecals, Explosion) == 0x000040, "Member 'FGzSurfaceBulletDecals::Explosion' has a wrong offset!");
static_assert(offsetof(FGzSurfaceBulletDecals, Energy) == 0x000050, "Member 'FGzSurfaceBulletDecals::Energy' has a wrong offset!");

// ScriptStruct G01.GzSurfaceImpactEffectsCell
// 0x0010 (0x0010 - 0x0000)
struct FGzSurfaceImpactEffectsCell final
{
public:
	EPhysicalSurface                              Key;                                               // 0x0000(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2BA7[0x7];                                     // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UNiagaraSystem*                         Value;                                             // 0x0008(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzSurfaceImpactEffectsCell) == 0x000008, "Wrong alignment on FGzSurfaceImpactEffectsCell");
static_assert(sizeof(FGzSurfaceImpactEffectsCell) == 0x000010, "Wrong size on FGzSurfaceImpactEffectsCell");
static_assert(offsetof(FGzSurfaceImpactEffectsCell, Key) == 0x000000, "Member 'FGzSurfaceImpactEffectsCell::Key' has a wrong offset!");
static_assert(offsetof(FGzSurfaceImpactEffectsCell, Value) == 0x000008, "Member 'FGzSurfaceImpactEffectsCell::Value' has a wrong offset!");

// ScriptStruct G01.GzPickableClassSettings
// 0x0078 (0x0078 - 0x0000)
struct FGzPickableClassSettings final
{
public:
	TSoftClassPtr<class UClass>                   LimbPickableClass;                                 // 0x0000(0x0028)(Edit, DisableEditOnInstance, NoClear, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftClassPtr<class UClass>                   WeaponPickableClass;                               // 0x0028(0x0028)(Edit, DisableEditOnInstance, NoClear, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftClassPtr<class UClass>                   SimplePickableClass;                               // 0x0050(0x0028)(Edit, DisableEditOnInstance, NoClear, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzPickableClassSettings) == 0x000008, "Wrong alignment on FGzPickableClassSettings");
static_assert(sizeof(FGzPickableClassSettings) == 0x000078, "Wrong size on FGzPickableClassSettings");
static_assert(offsetof(FGzPickableClassSettings, LimbPickableClass) == 0x000000, "Member 'FGzPickableClassSettings::LimbPickableClass' has a wrong offset!");
static_assert(offsetof(FGzPickableClassSettings, WeaponPickableClass) == 0x000028, "Member 'FGzPickableClassSettings::WeaponPickableClass' has a wrong offset!");
static_assert(offsetof(FGzPickableClassSettings, SimplePickableClass) == 0x000050, "Member 'FGzPickableClassSettings::SimplePickableClass' has a wrong offset!");

// ScriptStruct G01.GzSurfaceImpactEffects
// 0x0060 (0x0060 - 0x0000)
struct FGzSurfaceImpactEffects final
{
public:
	TArray<struct FGzSurfaceImpactEffectsCell>    Light;                                             // 0x0000(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TArray<struct FGzSurfaceImpactEffectsCell>    Medium;                                            // 0x0010(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TArray<struct FGzSurfaceImpactEffectsCell>    Heavy;                                             // 0x0020(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TArray<struct FGzSurfaceImpactEffectsCell>    Shotgun;                                           // 0x0030(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TArray<struct FGzSurfaceImpactEffectsCell>    Explosion;                                         // 0x0040(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TArray<struct FGzSurfaceImpactEffectsCell>    Energy;                                            // 0x0050(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzSurfaceImpactEffects) == 0x000008, "Wrong alignment on FGzSurfaceImpactEffects");
static_assert(sizeof(FGzSurfaceImpactEffects) == 0x000060, "Wrong size on FGzSurfaceImpactEffects");
static_assert(offsetof(FGzSurfaceImpactEffects, Light) == 0x000000, "Member 'FGzSurfaceImpactEffects::Light' has a wrong offset!");
static_assert(offsetof(FGzSurfaceImpactEffects, Medium) == 0x000010, "Member 'FGzSurfaceImpactEffects::Medium' has a wrong offset!");
static_assert(offsetof(FGzSurfaceImpactEffects, Heavy) == 0x000020, "Member 'FGzSurfaceImpactEffects::Heavy' has a wrong offset!");
static_assert(offsetof(FGzSurfaceImpactEffects, Shotgun) == 0x000030, "Member 'FGzSurfaceImpactEffects::Shotgun' has a wrong offset!");
static_assert(offsetof(FGzSurfaceImpactEffects, Explosion) == 0x000040, "Member 'FGzSurfaceImpactEffects::Explosion' has a wrong offset!");
static_assert(offsetof(FGzSurfaceImpactEffects, Energy) == 0x000050, "Member 'FGzSurfaceImpactEffects::Energy' has a wrong offset!");

// ScriptStruct G01.GzGetCurrentBattlePassPackage
// 0x0000 (0x0068 - 0x0068)
struct FGzGetCurrentBattlePassPackage final : public FGzPlayFabClientPackage
{
};
static_assert(alignof(FGzGetCurrentBattlePassPackage) == 0x000008, "Wrong alignment on FGzGetCurrentBattlePassPackage");
static_assert(sizeof(FGzGetCurrentBattlePassPackage) == 0x000068, "Wrong size on FGzGetCurrentBattlePassPackage");

// ScriptStruct G01.GzGetCurrentContentPackIdPackage
// 0x0000 (0x0068 - 0x0068)
struct FGzGetCurrentContentPackIdPackage final : public FGzPlayFabClientPackage
{
};
static_assert(alignof(FGzGetCurrentContentPackIdPackage) == 0x000008, "Wrong alignment on FGzGetCurrentContentPackIdPackage");
static_assert(sizeof(FGzGetCurrentContentPackIdPackage) == 0x000068, "Wrong size on FGzGetCurrentContentPackIdPackage");

// ScriptStruct G01.GzGetFriendsStatusPackage
// 0x0000 (0x0068 - 0x0068)
struct FGzGetFriendsStatusPackage final : public FGzPlayFabClientPackage
{
};
static_assert(alignof(FGzGetFriendsStatusPackage) == 0x000008, "Wrong alignment on FGzGetFriendsStatusPackage");
static_assert(sizeof(FGzGetFriendsStatusPackage) == 0x000068, "Wrong size on FGzGetFriendsStatusPackage");

// ScriptStruct G01.GzGetInventoryItemPackage
// 0x0010 (0x0078 - 0x0068)
struct FGzGetInventoryItemPackage final : public FGzPlayFabClientPackage
{
public:
	class FString                                 ItemInstanceId;                                    // 0x0068(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzGetInventoryItemPackage) == 0x000008, "Wrong alignment on FGzGetInventoryItemPackage");
static_assert(sizeof(FGzGetInventoryItemPackage) == 0x000078, "Wrong size on FGzGetInventoryItemPackage");
static_assert(offsetof(FGzGetInventoryItemPackage, ItemInstanceId) == 0x000068, "Member 'FGzGetInventoryItemPackage::ItemInstanceId' has a wrong offset!");

// ScriptStruct G01.GzGetInventoryItemsPackage
// 0x0010 (0x0078 - 0x0068)
struct FGzGetInventoryItemsPackage final : public FGzPlayFabClientPackage
{
public:
	class FString                                 ContinuationToken;                                 // 0x0068(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzGetInventoryItemsPackage) == 0x000008, "Wrong alignment on FGzGetInventoryItemsPackage");
static_assert(sizeof(FGzGetInventoryItemsPackage) == 0x000078, "Wrong size on FGzGetInventoryItemsPackage");
static_assert(offsetof(FGzGetInventoryItemsPackage, ContinuationToken) == 0x000068, "Member 'FGzGetInventoryItemsPackage::ContinuationToken' has a wrong offset!");

// ScriptStruct G01.GzGetPrimaryBalancePackage
// 0x0000 (0x0068 - 0x0068)
struct FGzGetPrimaryBalancePackage final : public FGzPlayFabClientPackage
{
};
static_assert(alignof(FGzGetPrimaryBalancePackage) == 0x000008, "Wrong alignment on FGzGetPrimaryBalancePackage");
static_assert(sizeof(FGzGetPrimaryBalancePackage) == 0x000068, "Wrong size on FGzGetPrimaryBalancePackage");

// ScriptStruct G01.GzGetServerListPackage
// 0x0000 (0x0068 - 0x0068)
struct FGzGetServerListPackage final : public FGzPlayFabClientPackage
{
};
static_assert(alignof(FGzGetServerListPackage) == 0x000008, "Wrong alignment on FGzGetServerListPackage");
static_assert(sizeof(FGzGetServerListPackage) == 0x000068, "Wrong size on FGzGetServerListPackage");

// ScriptStruct G01.GzRevokeItemsResult
// 0x0000 (0x00E0 - 0x00E0)
struct FGzRevokeItemsResult final : public FGzPlayFabResultBase
{
};
static_assert(alignof(FGzRevokeItemsResult) == 0x000008, "Wrong alignment on FGzRevokeItemsResult");
static_assert(sizeof(FGzRevokeItemsResult) == 0x0000E0, "Wrong size on FGzRevokeItemsResult");

// ScriptStruct G01.GzGetSignalrConnectionInfoPackage
// 0x0000 (0x0068 - 0x0068)
struct FGzGetSignalrConnectionInfoPackage final : public FGzPlayFabClientPackage
{
};
static_assert(alignof(FGzGetSignalrConnectionInfoPackage) == 0x000008, "Wrong alignment on FGzGetSignalrConnectionInfoPackage");
static_assert(sizeof(FGzGetSignalrConnectionInfoPackage) == 0x000068, "Wrong size on FGzGetSignalrConnectionInfoPackage");

// ScriptStruct G01.GzGetXsollaSubscriptionTokenPackage
// 0x0010 (0x0078 - 0x0068)
struct FGzGetXsollaSubscriptionTokenPackage final : public FGzPlayFabClientPackage
{
public:
	class FString                                 SubscriptionPlanId;                                // 0x0068(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzGetXsollaSubscriptionTokenPackage) == 0x000008, "Wrong alignment on FGzGetXsollaSubscriptionTokenPackage");
static_assert(sizeof(FGzGetXsollaSubscriptionTokenPackage) == 0x000078, "Wrong size on FGzGetXsollaSubscriptionTokenPackage");
static_assert(offsetof(FGzGetXsollaSubscriptionTokenPackage, SubscriptionPlanId) == 0x000068, "Member 'FGzGetXsollaSubscriptionTokenPackage::SubscriptionPlanId' has a wrong offset!");

// ScriptStruct G01.GzGrantItemsPackage
// 0x0018 (0x0080 - 0x0068)
struct FGzGrantItemsPackage final : public FGzPlayFabClientPackage
{
public:
	TArray<class FString>                         AssetIds;                                          // 0x0068(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          LimitAndMint;                                      // 0x0078(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2BA8[0x7];                                     // 0x0079(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGzGrantItemsPackage) == 0x000008, "Wrong alignment on FGzGrantItemsPackage");
static_assert(sizeof(FGzGrantItemsPackage) == 0x000080, "Wrong size on FGzGrantItemsPackage");
static_assert(offsetof(FGzGrantItemsPackage, AssetIds) == 0x000068, "Member 'FGzGrantItemsPackage::AssetIds' has a wrong offset!");
static_assert(offsetof(FGzGrantItemsPackage, LimitAndMint) == 0x000078, "Member 'FGzGrantItemsPackage::LimitAndMint' has a wrong offset!");

// ScriptStruct G01.GzWalletBalancesDisplayProperties
// 0x0008 (0x0008 - 0x0000)
struct FGzWalletBalancesDisplayProperties final
{
public:
	double                                        Gun;                                               // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzWalletBalancesDisplayProperties) == 0x000008, "Wrong alignment on FGzWalletBalancesDisplayProperties");
static_assert(sizeof(FGzWalletBalancesDisplayProperties) == 0x000008, "Wrong size on FGzWalletBalancesDisplayProperties");
static_assert(offsetof(FGzWalletBalancesDisplayProperties, Gun) == 0x000000, "Member 'FGzWalletBalancesDisplayProperties::Gun' has a wrong offset!");

// ScriptStruct G01.GzWalletDisplayProperties
// 0x0038 (0x0038 - 0x0000)
struct FGzWalletDisplayProperties final
{
public:
	class FString                                 ID;                                                // 0x0000(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Label;                                             // 0x0010(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 CreatedAt;                                         // 0x0020(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGzWalletBalancesDisplayProperties     Balances;                                          // 0x0030(0x0008)(NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzWalletDisplayProperties) == 0x000008, "Wrong alignment on FGzWalletDisplayProperties");
static_assert(sizeof(FGzWalletDisplayProperties) == 0x000038, "Wrong size on FGzWalletDisplayProperties");
static_assert(offsetof(FGzWalletDisplayProperties, ID) == 0x000000, "Member 'FGzWalletDisplayProperties::ID' has a wrong offset!");
static_assert(offsetof(FGzWalletDisplayProperties, Label) == 0x000010, "Member 'FGzWalletDisplayProperties::Label' has a wrong offset!");
static_assert(offsetof(FGzWalletDisplayProperties, CreatedAt) == 0x000020, "Member 'FGzWalletDisplayProperties::CreatedAt' has a wrong offset!");
static_assert(offsetof(FGzWalletDisplayProperties, Balances) == 0x000030, "Member 'FGzWalletDisplayProperties::Balances' has a wrong offset!");

// ScriptStruct G01.ModularCharacterAnimInstanceProxy
// 0x0000 (0x0740 - 0x0740)
struct FModularCharacterAnimInstanceProxy final : public FAnimInstanceProxy
{
};
static_assert(alignof(FModularCharacterAnimInstanceProxy) == 0x000010, "Wrong alignment on FModularCharacterAnimInstanceProxy");
static_assert(sizeof(FModularCharacterAnimInstanceProxy) == 0x000740, "Wrong size on FModularCharacterAnimInstanceProxy");

// ScriptStruct G01.GzGunDisplayProperties
// 0x0010 (0x0030 - 0x0020)
struct FGzGunDisplayProperties final : public FGzMetaBasicOnlineItemDisplayProperties
{
public:
	TArray<struct FGzWalletDisplayProperties>     Wallets;                                           // 0x0020(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzGunDisplayProperties) == 0x000008, "Wrong alignment on FGzGunDisplayProperties");
static_assert(sizeof(FGzGunDisplayProperties) == 0x000030, "Wrong size on FGzGunDisplayProperties");
static_assert(offsetof(FGzGunDisplayProperties, Wallets) == 0x000020, "Member 'FGzGunDisplayProperties::Wallets' has a wrong offset!");

// ScriptStruct G01.GzLoadoutSlotViewmakerSetup
// 0x0018 (0x0018 - 0x0000)
struct FGzLoadoutSlotViewmakerSetup final
{
public:
	struct FInstancedStruct                       SetUp;                                             // 0x0000(0x0010)(Edit, DisableEditOnTemplate, NativeAccessSpecifierPublic)
	EGzLoadoutSlots                               Type;                                              // 0x0010(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2BA9[0x7];                                     // 0x0011(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGzLoadoutSlotViewmakerSetup) == 0x000008, "Wrong alignment on FGzLoadoutSlotViewmakerSetup");
static_assert(sizeof(FGzLoadoutSlotViewmakerSetup) == 0x000018, "Wrong size on FGzLoadoutSlotViewmakerSetup");
static_assert(offsetof(FGzLoadoutSlotViewmakerSetup, SetUp) == 0x000000, "Member 'FGzLoadoutSlotViewmakerSetup::SetUp' has a wrong offset!");
static_assert(offsetof(FGzLoadoutSlotViewmakerSetup, Type) == 0x000010, "Member 'FGzLoadoutSlotViewmakerSetup::Type' has a wrong offset!");

// ScriptStruct G01.GzBrushKeySets
// 0x0010 (0x0010 - 0x0000)
struct FGzBrushKeySets final
{
public:
	TArray<struct FCommonInputKeySetBrushConfiguration> Sets;                                              // 0x0000(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzBrushKeySets) == 0x000008, "Wrong alignment on FGzBrushKeySets");
static_assert(sizeof(FGzBrushKeySets) == 0x000010, "Wrong size on FGzBrushKeySets");
static_assert(offsetof(FGzBrushKeySets, Sets) == 0x000000, "Member 'FGzBrushKeySets::Sets' has a wrong offset!");

// ScriptStruct G01.GzInputMappingContextInfo
// 0x0010 (0x0010 - 0x0000)
struct FGzInputMappingContextInfo final
{
public:
	class UInputMappingContext*                   MappingContext;                                    // 0x0000(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUsePriorityOverride;                              // 0x0008(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2BAA[0x3];                                     // 0x0009(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         PriorityOverride;                                  // 0x000C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzInputMappingContextInfo) == 0x000008, "Wrong alignment on FGzInputMappingContextInfo");
static_assert(sizeof(FGzInputMappingContextInfo) == 0x000010, "Wrong size on FGzInputMappingContextInfo");
static_assert(offsetof(FGzInputMappingContextInfo, MappingContext) == 0x000000, "Member 'FGzInputMappingContextInfo::MappingContext' has a wrong offset!");
static_assert(offsetof(FGzInputMappingContextInfo, bUsePriorityOverride) == 0x000008, "Member 'FGzInputMappingContextInfo::bUsePriorityOverride' has a wrong offset!");
static_assert(offsetof(FGzInputMappingContextInfo, PriorityOverride) == 0x00000C, "Member 'FGzInputMappingContextInfo::PriorityOverride' has a wrong offset!");

// ScriptStruct G01.GzInputMappingDecoratorHandle
// 0x0004 (0x0004 - 0x0000)
struct alignas(0x04) FGzInputMappingDecoratorHandle final
{
public:
	uint8                                         Pad_2BAB[0x4];                                     // 0x0000(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGzInputMappingDecoratorHandle) == 0x000004, "Wrong alignment on FGzInputMappingDecoratorHandle");
static_assert(sizeof(FGzInputMappingDecoratorHandle) == 0x000004, "Wrong size on FGzInputMappingDecoratorHandle");

// ScriptStruct G01.LocomotionMovementStateSettings
// 0x0020 (0x0020 - 0x0000)
struct FLocomotionMovementStateSettings final
{
public:
	float                                         WalkSpeed;                                         // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RunSpeed;                                          // 0x0004(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SprintSpeed;                                       // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2BAC[0x4];                                     // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UCurveVector*                           MovementCurve;                                     // 0x0010(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCurveFloat*                            RotationRateCurve;                                 // 0x0018(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FLocomotionMovementStateSettings) == 0x000008, "Wrong alignment on FLocomotionMovementStateSettings");
static_assert(sizeof(FLocomotionMovementStateSettings) == 0x000020, "Wrong size on FLocomotionMovementStateSettings");
static_assert(offsetof(FLocomotionMovementStateSettings, WalkSpeed) == 0x000000, "Member 'FLocomotionMovementStateSettings::WalkSpeed' has a wrong offset!");
static_assert(offsetof(FLocomotionMovementStateSettings, RunSpeed) == 0x000004, "Member 'FLocomotionMovementStateSettings::RunSpeed' has a wrong offset!");
static_assert(offsetof(FLocomotionMovementStateSettings, SprintSpeed) == 0x000008, "Member 'FLocomotionMovementStateSettings::SprintSpeed' has a wrong offset!");
static_assert(offsetof(FLocomotionMovementStateSettings, MovementCurve) == 0x000010, "Member 'FLocomotionMovementStateSettings::MovementCurve' has a wrong offset!");
static_assert(offsetof(FLocomotionMovementStateSettings, RotationRateCurve) == 0x000018, "Member 'FLocomotionMovementStateSettings::RotationRateCurve' has a wrong offset!");

// ScriptStruct G01.LocomotionMovementModel
// 0x00C0 (0x00C8 - 0x0008)
struct FLocomotionMovementModel final : public FTableRowBase
{
public:
	struct FLocomotionMovementStateSettings       VelocityStanding;                                  // 0x0008(0x0020)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	struct FLocomotionMovementStateSettings       VelocityCrouching;                                 // 0x0028(0x0020)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	struct FLocomotionMovementStateSettings       LookingStanding;                                   // 0x0048(0x0020)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	struct FLocomotionMovementStateSettings       LookingCrouching;                                  // 0x0068(0x0020)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	struct FLocomotionMovementStateSettings       AimingStanding;                                    // 0x0088(0x0020)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	struct FLocomotionMovementStateSettings       AimingCrouching;                                   // 0x00A8(0x0020)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FLocomotionMovementModel) == 0x000008, "Wrong alignment on FLocomotionMovementModel");
static_assert(sizeof(FLocomotionMovementModel) == 0x0000C8, "Wrong size on FLocomotionMovementModel");
static_assert(offsetof(FLocomotionMovementModel, VelocityStanding) == 0x000008, "Member 'FLocomotionMovementModel::VelocityStanding' has a wrong offset!");
static_assert(offsetof(FLocomotionMovementModel, VelocityCrouching) == 0x000028, "Member 'FLocomotionMovementModel::VelocityCrouching' has a wrong offset!");
static_assert(offsetof(FLocomotionMovementModel, LookingStanding) == 0x000048, "Member 'FLocomotionMovementModel::LookingStanding' has a wrong offset!");
static_assert(offsetof(FLocomotionMovementModel, LookingCrouching) == 0x000068, "Member 'FLocomotionMovementModel::LookingCrouching' has a wrong offset!");
static_assert(offsetof(FLocomotionMovementModel, AimingStanding) == 0x000088, "Member 'FLocomotionMovementModel::AimingStanding' has a wrong offset!");
static_assert(offsetof(FLocomotionMovementModel, AimingCrouching) == 0x0000A8, "Member 'FLocomotionMovementModel::AimingCrouching' has a wrong offset!");

// ScriptStruct G01.GzInputMappingDecoratorInfo
// 0x0018 (0x0018 - 0x0000)
struct FGzInputMappingDecoratorInfo final
{
public:
	struct FGzInputMappingContextInfo             MappingContextInfo;                                // 0x0000(0x0010)(Transient, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_2BAD[0x8];                                     // 0x0010(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGzInputMappingDecoratorInfo) == 0x000008, "Wrong alignment on FGzInputMappingDecoratorInfo");
static_assert(sizeof(FGzInputMappingDecoratorInfo) == 0x000018, "Wrong size on FGzInputMappingDecoratorInfo");
static_assert(offsetof(FGzInputMappingDecoratorInfo, MappingContextInfo) == 0x000000, "Member 'FGzInputMappingDecoratorInfo::MappingContextInfo' has a wrong offset!");

// ScriptStruct G01.GzIntervalInteractionData
// 0x0008 (0x0008 - 0x0000)
struct FGzIntervalInteractionData final
{
public:
	int32                                         CurrentIntervalStep;                               // 0x0000(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         LastInteractedTeamId;                              // 0x0004(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzIntervalInteractionData) == 0x000004, "Wrong alignment on FGzIntervalInteractionData");
static_assert(sizeof(FGzIntervalInteractionData) == 0x000008, "Wrong size on FGzIntervalInteractionData");
static_assert(offsetof(FGzIntervalInteractionData, CurrentIntervalStep) == 0x000000, "Member 'FGzIntervalInteractionData::CurrentIntervalStep' has a wrong offset!");
static_assert(offsetof(FGzIntervalInteractionData, LastInteractedTeamId) == 0x000004, "Member 'FGzIntervalInteractionData::LastInteractedTeamId' has a wrong offset!");

// ScriptStruct G01.GzInteractableTransitionRuntimeData
// 0x0100 (0x0100 - 0x0000)
struct alignas(0x08) FGzInteractableTransitionRuntimeData final
{
public:
	uint8                                         Pad_2BAE[0x100];                                   // 0x0000(0x0100)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGzInteractableTransitionRuntimeData) == 0x000008, "Wrong alignment on FGzInteractableTransitionRuntimeData");
static_assert(sizeof(FGzInteractableTransitionRuntimeData) == 0x000100, "Wrong size on FGzInteractableTransitionRuntimeData");

// ScriptStruct G01.GzInteractableVisualizationStruct
// 0x0001 (0x0001 - 0x0000)
struct FGzInteractableVisualizationStruct final
{
public:
	uint8                                         Pad_2BAF[0x1];                                     // 0x0000(0x0001)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGzInteractableVisualizationStruct) == 0x000001, "Wrong alignment on FGzInteractableVisualizationStruct");
static_assert(sizeof(FGzInteractableVisualizationStruct) == 0x000001, "Wrong size on FGzInteractableVisualizationStruct");

// ScriptStruct G01.GzLandingZoneUIData
// 0x0018 (0x0018 - 0x0000)
struct FGzLandingZoneUIData final
{
public:
	struct FVector2D                              ScreenPosition;                                    // 0x0000(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         LandingZoneIndex;                                  // 0x0010(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2BB0[0x4];                                     // 0x0014(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGzLandingZoneUIData) == 0x000008, "Wrong alignment on FGzLandingZoneUIData");
static_assert(sizeof(FGzLandingZoneUIData) == 0x000018, "Wrong size on FGzLandingZoneUIData");
static_assert(offsetof(FGzLandingZoneUIData, ScreenPosition) == 0x000000, "Member 'FGzLandingZoneUIData::ScreenPosition' has a wrong offset!");
static_assert(offsetof(FGzLandingZoneUIData, LandingZoneIndex) == 0x000010, "Member 'FGzLandingZoneUIData::LandingZoneIndex' has a wrong offset!");

// ScriptStruct G01.GzInteractionStage
// 0x0030 (0x0030 - 0x0000)
struct FGzInteractionStage final
{
public:
	class FText                                   HoldInteractionTooltip;                            // 0x0000(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	bool                                          bSkipThisStage;                                    // 0x0010(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIntervalInteraction;                              // 0x0011(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bInteractOnNotify;                                 // 0x0012(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCountStageDurationForInteractionDuration;         // 0x0013(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InteractionDuration;                               // 0x0014(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EGzInteractionStageType                       StageType;                                         // 0x0018(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EGzInteractionTriggerType                     TriggerType;                                       // 0x0019(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EGzInteractionProcessType                     ProcessType;                                       // 0x001A(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2BB1[0x5];                                     // 0x001B(0x0005)(Fixing Size After Last Property [ Dumper-7 ])
	class UAnimMontage*                           Montage;                                           // 0x0020(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         NumOfIntervalSteps;                                // 0x0028(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2BB2[0x4];                                     // 0x002C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGzInteractionStage) == 0x000008, "Wrong alignment on FGzInteractionStage");
static_assert(sizeof(FGzInteractionStage) == 0x000030, "Wrong size on FGzInteractionStage");
static_assert(offsetof(FGzInteractionStage, HoldInteractionTooltip) == 0x000000, "Member 'FGzInteractionStage::HoldInteractionTooltip' has a wrong offset!");
static_assert(offsetof(FGzInteractionStage, bSkipThisStage) == 0x000010, "Member 'FGzInteractionStage::bSkipThisStage' has a wrong offset!");
static_assert(offsetof(FGzInteractionStage, bIntervalInteraction) == 0x000011, "Member 'FGzInteractionStage::bIntervalInteraction' has a wrong offset!");
static_assert(offsetof(FGzInteractionStage, bInteractOnNotify) == 0x000012, "Member 'FGzInteractionStage::bInteractOnNotify' has a wrong offset!");
static_assert(offsetof(FGzInteractionStage, bCountStageDurationForInteractionDuration) == 0x000013, "Member 'FGzInteractionStage::bCountStageDurationForInteractionDuration' has a wrong offset!");
static_assert(offsetof(FGzInteractionStage, InteractionDuration) == 0x000014, "Member 'FGzInteractionStage::InteractionDuration' has a wrong offset!");
static_assert(offsetof(FGzInteractionStage, StageType) == 0x000018, "Member 'FGzInteractionStage::StageType' has a wrong offset!");
static_assert(offsetof(FGzInteractionStage, TriggerType) == 0x000019, "Member 'FGzInteractionStage::TriggerType' has a wrong offset!");
static_assert(offsetof(FGzInteractionStage, ProcessType) == 0x00001A, "Member 'FGzInteractionStage::ProcessType' has a wrong offset!");
static_assert(offsetof(FGzInteractionStage, Montage) == 0x000020, "Member 'FGzInteractionStage::Montage' has a wrong offset!");
static_assert(offsetof(FGzInteractionStage, NumOfIntervalSteps) == 0x000028, "Member 'FGzInteractionStage::NumOfIntervalSteps' has a wrong offset!");

// ScriptStruct G01.GzInteractionData
// 0x00F8 (0x00F8 - 0x0000)
struct FGzInteractionData final
{
public:
	class FText                                   DisplayText;                                       // 0x0000(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	bool                                          bIsOneShot;                                        // 0x0010(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bLocationBound;                                    // 0x0011(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseAutoTransition;                                // 0x0012(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EGzInteractionStageType                       StageTypeToAutoTransition;                         // 0x0013(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2BB3[0x4];                                     // 0x0014(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                LocalLocationToStartInteraction;                   // 0x0018(0x0018)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AcceptableInteractionAreaRadius;                   // 0x0030(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LocalYawToStartInteraction;                        // 0x0034(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShouldUsePreInteractionDelay;                     // 0x0038(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bFocusOnInteractionConditionsFail;                 // 0x0039(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bResetProgressBarOnRelease;                        // 0x003A(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseInteractionBehavior;                           // 0x003B(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PreInteractionDelayDuration;                       // 0x003C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGzInteractionStage                    PreInteractionStage;                               // 0x0040(0x0030)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FGzInteractionStage                    InteractionStage;                                  // 0x0070(0x0030)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FGzInteractionStage                    PostInteractionStage;                              // 0x00A0(0x0030)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	EGzInteractionStageType                       InteractionStageTypeToProcessInteraction;          // 0x00D0(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2BB4[0x7];                                     // 0x00D1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UDefaultInteractionBehavior*>    Interactions;                                      // 0x00D8(0x0010)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	TArray<class UGzInteractionCondition*>        InteractionConditions;                             // 0x00E8(0x0010)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzInteractionData) == 0x000008, "Wrong alignment on FGzInteractionData");
static_assert(sizeof(FGzInteractionData) == 0x0000F8, "Wrong size on FGzInteractionData");
static_assert(offsetof(FGzInteractionData, DisplayText) == 0x000000, "Member 'FGzInteractionData::DisplayText' has a wrong offset!");
static_assert(offsetof(FGzInteractionData, bIsOneShot) == 0x000010, "Member 'FGzInteractionData::bIsOneShot' has a wrong offset!");
static_assert(offsetof(FGzInteractionData, bLocationBound) == 0x000011, "Member 'FGzInteractionData::bLocationBound' has a wrong offset!");
static_assert(offsetof(FGzInteractionData, bUseAutoTransition) == 0x000012, "Member 'FGzInteractionData::bUseAutoTransition' has a wrong offset!");
static_assert(offsetof(FGzInteractionData, StageTypeToAutoTransition) == 0x000013, "Member 'FGzInteractionData::StageTypeToAutoTransition' has a wrong offset!");
static_assert(offsetof(FGzInteractionData, LocalLocationToStartInteraction) == 0x000018, "Member 'FGzInteractionData::LocalLocationToStartInteraction' has a wrong offset!");
static_assert(offsetof(FGzInteractionData, AcceptableInteractionAreaRadius) == 0x000030, "Member 'FGzInteractionData::AcceptableInteractionAreaRadius' has a wrong offset!");
static_assert(offsetof(FGzInteractionData, LocalYawToStartInteraction) == 0x000034, "Member 'FGzInteractionData::LocalYawToStartInteraction' has a wrong offset!");
static_assert(offsetof(FGzInteractionData, bShouldUsePreInteractionDelay) == 0x000038, "Member 'FGzInteractionData::bShouldUsePreInteractionDelay' has a wrong offset!");
static_assert(offsetof(FGzInteractionData, bFocusOnInteractionConditionsFail) == 0x000039, "Member 'FGzInteractionData::bFocusOnInteractionConditionsFail' has a wrong offset!");
static_assert(offsetof(FGzInteractionData, bResetProgressBarOnRelease) == 0x00003A, "Member 'FGzInteractionData::bResetProgressBarOnRelease' has a wrong offset!");
static_assert(offsetof(FGzInteractionData, bUseInteractionBehavior) == 0x00003B, "Member 'FGzInteractionData::bUseInteractionBehavior' has a wrong offset!");
static_assert(offsetof(FGzInteractionData, PreInteractionDelayDuration) == 0x00003C, "Member 'FGzInteractionData::PreInteractionDelayDuration' has a wrong offset!");
static_assert(offsetof(FGzInteractionData, PreInteractionStage) == 0x000040, "Member 'FGzInteractionData::PreInteractionStage' has a wrong offset!");
static_assert(offsetof(FGzInteractionData, InteractionStage) == 0x000070, "Member 'FGzInteractionData::InteractionStage' has a wrong offset!");
static_assert(offsetof(FGzInteractionData, PostInteractionStage) == 0x0000A0, "Member 'FGzInteractionData::PostInteractionStage' has a wrong offset!");
static_assert(offsetof(FGzInteractionData, InteractionStageTypeToProcessInteraction) == 0x0000D0, "Member 'FGzInteractionData::InteractionStageTypeToProcessInteraction' has a wrong offset!");
static_assert(offsetof(FGzInteractionData, Interactions) == 0x0000D8, "Member 'FGzInteractionData::Interactions' has a wrong offset!");
static_assert(offsetof(FGzInteractionData, InteractionConditions) == 0x0000E8, "Member 'FGzInteractionData::InteractionConditions' has a wrong offset!");

// ScriptStruct G01.GzInteractionInfo
// 0x0100 (0x0100 - 0x0000)
struct FGzInteractionInfo final
{
public:
	struct FGameplayTag                           Tag;                                               // 0x0000(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGzInteractionData                     InteractionData;                                   // 0x0008(0x00F8)(Edit, BlueprintVisible, BlueprintReadOnly, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzInteractionInfo) == 0x000008, "Wrong alignment on FGzInteractionInfo");
static_assert(sizeof(FGzInteractionInfo) == 0x000100, "Wrong size on FGzInteractionInfo");
static_assert(offsetof(FGzInteractionInfo, Tag) == 0x000000, "Member 'FGzInteractionInfo::Tag' has a wrong offset!");
static_assert(offsetof(FGzInteractionInfo, InteractionData) == 0x000008, "Member 'FGzInteractionInfo::InteractionData' has a wrong offset!");

// ScriptStruct G01.GzMatchmakingQueueGroupData
// 0x0038 (0x0038 - 0x0000)
struct FGzMatchmakingQueueGroupData final
{
public:
	class FText                                   DisplayName;                                       // 0x0000(0x0010)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UTexture2D>              Image;                                             // 0x0010(0x0028)(Edit, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzMatchmakingQueueGroupData) == 0x000008, "Wrong alignment on FGzMatchmakingQueueGroupData");
static_assert(sizeof(FGzMatchmakingQueueGroupData) == 0x000038, "Wrong size on FGzMatchmakingQueueGroupData");
static_assert(offsetof(FGzMatchmakingQueueGroupData, DisplayName) == 0x000000, "Member 'FGzMatchmakingQueueGroupData::DisplayName' has a wrong offset!");
static_assert(offsetof(FGzMatchmakingQueueGroupData, Image) == 0x000010, "Member 'FGzMatchmakingQueueGroupData::Image' has a wrong offset!");

// ScriptStruct G01.GzTitleItemLimits
// 0x0050 (0x0050 - 0x0000)
struct FGzTitleItemLimits final
{
public:
	TMap<class FString, int64>                    Values;                                            // 0x0000(0x0050)(NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzTitleItemLimits) == 0x000008, "Wrong alignment on FGzTitleItemLimits");
static_assert(sizeof(FGzTitleItemLimits) == 0x000050, "Wrong size on FGzTitleItemLimits");
static_assert(offsetof(FGzTitleItemLimits, Values) == 0x000000, "Member 'FGzTitleItemLimits::Values' has a wrong offset!");

// ScriptStruct G01.GzWalletPropertyMapper
// 0x0028 (0x0028 - 0x0000)
struct FGzWalletPropertyMapper final
{
public:
	class FString                                 ID;                                                // 0x0000(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Label;                                             // 0x0010(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FDateTime                              CreatedAt;                                         // 0x0020(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzWalletPropertyMapper) == 0x000008, "Wrong alignment on FGzWalletPropertyMapper");
static_assert(sizeof(FGzWalletPropertyMapper) == 0x000028, "Wrong size on FGzWalletPropertyMapper");
static_assert(offsetof(FGzWalletPropertyMapper, ID) == 0x000000, "Member 'FGzWalletPropertyMapper::ID' has a wrong offset!");
static_assert(offsetof(FGzWalletPropertyMapper, Label) == 0x000010, "Member 'FGzWalletPropertyMapper::Label' has a wrong offset!");
static_assert(offsetof(FGzWalletPropertyMapper, CreatedAt) == 0x000020, "Member 'FGzWalletPropertyMapper::CreatedAt' has a wrong offset!");

// ScriptStruct G01.GzReviewedItems
// 0x0010 (0x0010 - 0x0000)
struct FGzReviewedItems final
{
public:
	TArray<class FString>                         Values;                                            // 0x0000(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzReviewedItems) == 0x000008, "Wrong alignment on FGzReviewedItems");
static_assert(sizeof(FGzReviewedItems) == 0x000010, "Wrong size on FGzReviewedItems");
static_assert(offsetof(FGzReviewedItems, Values) == 0x000000, "Member 'FGzReviewedItems::Values' has a wrong offset!");

// ScriptStruct G01.GzBackendStarterItems
// 0x0010 (0x0010 - 0x0000)
struct FGzBackendStarterItems final
{
public:
	TArray<struct FGzBackendInventoryItem>        Values;                                            // 0x0000(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzBackendStarterItems) == 0x000008, "Wrong alignment on FGzBackendStarterItems");
static_assert(sizeof(FGzBackendStarterItems) == 0x000010, "Wrong size on FGzBackendStarterItems");
static_assert(offsetof(FGzBackendStarterItems, Values) == 0x000000, "Member 'FGzBackendStarterItems::Values' has a wrong offset!");

// ScriptStruct G01.GzLimbItemContent
// 0x0018 (0x0018 - 0x0000)
struct FGzLimbItemContent final
{
public:
	class UGzBodyPartItemData*                    ItemData;                                          // 0x0000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UGzBodyPartSkinItemData*                SkinItemData;                                      // 0x0008(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Health;                                            // 0x0010(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2BB5[0x4];                                     // 0x0014(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGzLimbItemContent) == 0x000008, "Wrong alignment on FGzLimbItemContent");
static_assert(sizeof(FGzLimbItemContent) == 0x000018, "Wrong size on FGzLimbItemContent");
static_assert(offsetof(FGzLimbItemContent, ItemData) == 0x000000, "Member 'FGzLimbItemContent::ItemData' has a wrong offset!");
static_assert(offsetof(FGzLimbItemContent, SkinItemData) == 0x000008, "Member 'FGzLimbItemContent::SkinItemData' has a wrong offset!");
static_assert(offsetof(FGzLimbItemContent, Health) == 0x000010, "Member 'FGzLimbItemContent::Health' has a wrong offset!");

// ScriptStruct G01.GzMetaMarketplaceItemOwnerInfo
// 0x0020 (0x0020 - 0x0000)
struct FGzMetaMarketplaceItemOwnerInfo final
{
public:
	struct FGzPlayFabPlayerIdContainer            PlayerId;                                          // 0x0000(0x0020)(NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzMetaMarketplaceItemOwnerInfo) == 0x000008, "Wrong alignment on FGzMetaMarketplaceItemOwnerInfo");
static_assert(sizeof(FGzMetaMarketplaceItemOwnerInfo) == 0x000020, "Wrong size on FGzMetaMarketplaceItemOwnerInfo");
static_assert(offsetof(FGzMetaMarketplaceItemOwnerInfo, PlayerId) == 0x000000, "Member 'FGzMetaMarketplaceItemOwnerInfo::PlayerId' has a wrong offset!");

// ScriptStruct G01.GzMetaMarketplaceItemInfo
// 0x0050 (0x0050 - 0x0000)
struct FGzMetaMarketplaceItemInfo final
{
public:
	class FName                                   PrimaryAssetId;                                    // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 InstanceId;                                        // 0x0008(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 DisplayName;                                       // 0x0018(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EGzItemType                                   Type;                                              // 0x0028(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EGzItemRarity                                 Quality;                                           // 0x0029(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2BB6[0x6];                                     // 0x002A(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   Description;                                       // 0x0030(0x0010)(NativeAccessSpecifierPublic)
	bool                                          bOwnedByLocalPlayer;                               // 0x0040(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsV3;                                              // 0x0041(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2BB7[0x6];                                     // 0x0042(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	int64                                         SerialNumber;                                      // 0x0048(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzMetaMarketplaceItemInfo) == 0x000008, "Wrong alignment on FGzMetaMarketplaceItemInfo");
static_assert(sizeof(FGzMetaMarketplaceItemInfo) == 0x000050, "Wrong size on FGzMetaMarketplaceItemInfo");
static_assert(offsetof(FGzMetaMarketplaceItemInfo, PrimaryAssetId) == 0x000000, "Member 'FGzMetaMarketplaceItemInfo::PrimaryAssetId' has a wrong offset!");
static_assert(offsetof(FGzMetaMarketplaceItemInfo, InstanceId) == 0x000008, "Member 'FGzMetaMarketplaceItemInfo::InstanceId' has a wrong offset!");
static_assert(offsetof(FGzMetaMarketplaceItemInfo, DisplayName) == 0x000018, "Member 'FGzMetaMarketplaceItemInfo::DisplayName' has a wrong offset!");
static_assert(offsetof(FGzMetaMarketplaceItemInfo, Type) == 0x000028, "Member 'FGzMetaMarketplaceItemInfo::Type' has a wrong offset!");
static_assert(offsetof(FGzMetaMarketplaceItemInfo, Quality) == 0x000029, "Member 'FGzMetaMarketplaceItemInfo::Quality' has a wrong offset!");
static_assert(offsetof(FGzMetaMarketplaceItemInfo, Description) == 0x000030, "Member 'FGzMetaMarketplaceItemInfo::Description' has a wrong offset!");
static_assert(offsetof(FGzMetaMarketplaceItemInfo, bOwnedByLocalPlayer) == 0x000040, "Member 'FGzMetaMarketplaceItemInfo::bOwnedByLocalPlayer' has a wrong offset!");
static_assert(offsetof(FGzMetaMarketplaceItemInfo, IsV3) == 0x000041, "Member 'FGzMetaMarketplaceItemInfo::IsV3' has a wrong offset!");
static_assert(offsetof(FGzMetaMarketplaceItemInfo, SerialNumber) == 0x000048, "Member 'FGzMetaMarketplaceItemInfo::SerialNumber' has a wrong offset!");

// ScriptStruct G01.GzMetaMarketplaceItem
// 0x0098 (0x0098 - 0x0000)
struct FGzMetaMarketplaceItem final
{
public:
	struct FGzMetaMarketplaceItemOwnerInfo        OwnerInfo;                                         // 0x0000(0x0020)(NativeAccessSpecifierPublic)
	struct FGzMetaMarketplaceItemInfo             ItemInfo;                                          // 0x0020(0x0050)(NativeAccessSpecifierPublic)
	struct FGzMetaMarketplaceItemOfferInfo        OfferInfo;                                         // 0x0070(0x0028)(NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzMetaMarketplaceItem) == 0x000008, "Wrong alignment on FGzMetaMarketplaceItem");
static_assert(sizeof(FGzMetaMarketplaceItem) == 0x000098, "Wrong size on FGzMetaMarketplaceItem");
static_assert(offsetof(FGzMetaMarketplaceItem, OwnerInfo) == 0x000000, "Member 'FGzMetaMarketplaceItem::OwnerInfo' has a wrong offset!");
static_assert(offsetof(FGzMetaMarketplaceItem, ItemInfo) == 0x000020, "Member 'FGzMetaMarketplaceItem::ItemInfo' has a wrong offset!");
static_assert(offsetof(FGzMetaMarketplaceItem, OfferInfo) == 0x000070, "Member 'FGzMetaMarketplaceItem::OfferInfo' has a wrong offset!");

// ScriptStruct G01.GzWeaponItemContent
// 0x0028 (0x0028 - 0x0000)
struct FGzWeaponItemContent final
{
public:
	class UGzWeaponItemData*                      ItemData;                                          // 0x0000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UGzWeaponSkinItemData*                  SkinItemData;                                      // 0x0008(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class UGzWeaponAttachmentItemData*>    Attachments;                                       // 0x0010(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	int32                                         Ammo;                                              // 0x0020(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2BB8[0x4];                                     // 0x0024(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGzWeaponItemContent) == 0x000008, "Wrong alignment on FGzWeaponItemContent");
static_assert(sizeof(FGzWeaponItemContent) == 0x000028, "Wrong size on FGzWeaponItemContent");
static_assert(offsetof(FGzWeaponItemContent, ItemData) == 0x000000, "Member 'FGzWeaponItemContent::ItemData' has a wrong offset!");
static_assert(offsetof(FGzWeaponItemContent, SkinItemData) == 0x000008, "Member 'FGzWeaponItemContent::SkinItemData' has a wrong offset!");
static_assert(offsetof(FGzWeaponItemContent, Attachments) == 0x000010, "Member 'FGzWeaponItemContent::Attachments' has a wrong offset!");
static_assert(offsetof(FGzWeaponItemContent, Ammo) == 0x000020, "Member 'FGzWeaponItemContent::Ammo' has a wrong offset!");

// ScriptStruct G01.GzSimpleItemContent
// 0x0010 (0x0010 - 0x0000)
struct FGzSimpleItemContent final
{
public:
	int32                                         Quantity;                                          // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2BB9[0x4];                                     // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UGzSimpleItemData*                      ItemData;                                          // 0x0008(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzSimpleItemContent) == 0x000008, "Wrong alignment on FGzSimpleItemContent");
static_assert(sizeof(FGzSimpleItemContent) == 0x000010, "Wrong size on FGzSimpleItemContent");
static_assert(offsetof(FGzSimpleItemContent, Quantity) == 0x000000, "Member 'FGzSimpleItemContent::Quantity' has a wrong offset!");
static_assert(offsetof(FGzSimpleItemContent, ItemData) == 0x000008, "Member 'FGzSimpleItemContent::ItemData' has a wrong offset!");

// ScriptStruct G01.InstancedStructNetSerializerConfig
// 0x0018 (0x0028 - 0x0010)
struct FInstancedStructNetSerializerConfig : public FNetSerializerConfig
{
public:
	uint8                                         Pad_2BBA[0x18];                                    // 0x0010(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FInstancedStructNetSerializerConfig) == 0x000008, "Wrong alignment on FInstancedStructNetSerializerConfig");
static_assert(sizeof(FInstancedStructNetSerializerConfig) == 0x000028, "Wrong size on FInstancedStructNetSerializerConfig");

// ScriptStruct G01.GzResultEntitlements
// 0x0010 (0x0010 - 0x0000)
struct FGzResultEntitlements final
{
public:
	TArray<class FString>                         List;                                              // 0x0000(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzResultEntitlements) == 0x000008, "Wrong alignment on FGzResultEntitlements");
static_assert(sizeof(FGzResultEntitlements) == 0x000010, "Wrong size on FGzResultEntitlements");
static_assert(offsetof(FGzResultEntitlements, List) == 0x000000, "Member 'FGzResultEntitlements::List' has a wrong offset!");

// ScriptStruct G01.GzInvItemNetSerializerConfig
// 0x0000 (0x0028 - 0x0028)
struct FGzInvItemNetSerializerConfig final : public FInstancedStructNetSerializerConfig
{
};
static_assert(alignof(FGzInvItemNetSerializerConfig) == 0x000008, "Wrong alignment on FGzInvItemNetSerializerConfig");
static_assert(sizeof(FGzInvItemNetSerializerConfig) == 0x000028, "Wrong size on FGzInvItemNetSerializerConfig");

// ScriptStruct G01.GzRootMotionSource
// 0x00C0 (0x01A0 - 0x00E0)
#pragma pack(push, 0x1)
struct alignas(0x10) FGzRootMotionSource : public FRootMotionSource
{
public:
	uint8                                         Pad_2BBB[0xC0];                                    // 0x00D8(0x00C0)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
#pragma pack(pop)
static_assert(alignof(FGzRootMotionSource) == 0x000010, "Wrong alignment on FGzRootMotionSource");
static_assert(sizeof(FGzRootMotionSource) == 0x0001A0, "Wrong size on FGzRootMotionSource");

// ScriptStruct G01.GzRootMotionSource_Zipline
// 0x0090 (0x0230 - 0x01A0)
struct FGzRootMotionSource_Zipline : public FGzRootMotionSource
{
public:
	struct FGzZiplineMovementRuntimeData          ZiplineData;                                       // 0x0198(0x0058)(Transient, NoDestructor, NativeAccessSpecifierPublic)
	class UGzZiplineMovementSettings*             ZiplineSettings;                                   // 0x01F0(0x0008)(ZeroConstructor, Transient, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2BBC[0x38];                                    // 0x01F8(0x0038)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGzRootMotionSource_Zipline) == 0x000010, "Wrong alignment on FGzRootMotionSource_Zipline");
static_assert(sizeof(FGzRootMotionSource_Zipline) == 0x000230, "Wrong size on FGzRootMotionSource_Zipline");
static_assert(offsetof(FGzRootMotionSource_Zipline, ZiplineData) == 0x000198, "Member 'FGzRootMotionSource_Zipline::ZiplineData' has a wrong offset!");
static_assert(offsetof(FGzRootMotionSource_Zipline, ZiplineSettings) == 0x0001F0, "Member 'FGzRootMotionSource_Zipline::ZiplineSettings' has a wrong offset!");

// ScriptStruct G01.GzRootMotionSource_ZiplineJumpOff
// 0x00C0 (0x02F0 - 0x0230)
struct FGzRootMotionSource_ZiplineJumpOff final : public FGzRootMotionSource_Zipline
{
public:
	uint8                                         Pad_2BBD[0xC0];                                    // 0x0230(0x00C0)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGzRootMotionSource_ZiplineJumpOff) == 0x000010, "Wrong alignment on FGzRootMotionSource_ZiplineJumpOff");
static_assert(sizeof(FGzRootMotionSource_ZiplineJumpOff) == 0x0002F0, "Wrong size on FGzRootMotionSource_ZiplineJumpOff");

// ScriptStruct G01.GzInvPocketsArray
// 0x00A0 (0x01B0 - 0x0110)
struct FGzInvPocketsArray final : public FFastArraySerializer
{
public:
	class UGzInvComponent*                        Inventory;                                         // 0x0110(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, RepSkip, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<struct FGzInvPocket>                   PocketsArray;                                      // 0x0118(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	TArray<struct FGzInvPocketDef>                PocketDefs;                                        // 0x0128(0x0010)(ZeroConstructor, Transient, RepSkip, NativeAccessSpecifierPrivate)
	TArray<struct FGzInvPocketDef>                RegisteredPocketDefs;                              // 0x0138(0x0010)(ZeroConstructor, Transient, RepSkip, NativeAccessSpecifierPrivate)
	TArray<struct FGzInvPocket>                   PocketsCache;                                      // 0x0148(0x0010)(ZeroConstructor, Transient, RepSkip, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2BBE[0x58];                                    // 0x0158(0x0058)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGzInvPocketsArray) == 0x000008, "Wrong alignment on FGzInvPocketsArray");
static_assert(sizeof(FGzInvPocketsArray) == 0x0001B0, "Wrong size on FGzInvPocketsArray");
static_assert(offsetof(FGzInvPocketsArray, Inventory) == 0x000110, "Member 'FGzInvPocketsArray::Inventory' has a wrong offset!");
static_assert(offsetof(FGzInvPocketsArray, PocketsArray) == 0x000118, "Member 'FGzInvPocketsArray::PocketsArray' has a wrong offset!");
static_assert(offsetof(FGzInvPocketsArray, PocketDefs) == 0x000128, "Member 'FGzInvPocketsArray::PocketDefs' has a wrong offset!");
static_assert(offsetof(FGzInvPocketsArray, RegisteredPocketDefs) == 0x000138, "Member 'FGzInvPocketsArray::RegisteredPocketDefs' has a wrong offset!");
static_assert(offsetof(FGzInvPocketsArray, PocketsCache) == 0x000148, "Member 'FGzInvPocketsArray::PocketsCache' has a wrong offset!");

// ScriptStruct G01.GzInvSubscriptionHandle
// 0x000C (0x000C - 0x0000)
struct FGzInvSubscriptionHandle
{
public:
	uint8                                         Pad_2BBF[0x8];                                     // 0x0000(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	uint32                                        Handle;                                            // 0x0008(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
};
static_assert(alignof(FGzInvSubscriptionHandle) == 0x000004, "Wrong alignment on FGzInvSubscriptionHandle");
static_assert(sizeof(FGzInvSubscriptionHandle) == 0x00000C, "Wrong size on FGzInvSubscriptionHandle");
static_assert(offsetof(FGzInvSubscriptionHandle, Handle) == 0x000008, "Member 'FGzInvSubscriptionHandle::Handle' has a wrong offset!");

// ScriptStruct G01.GzMetaChallengeList
// 0x0018 (0x0018 - 0x0000)
struct FGzMetaChallengeList final
{
public:
	struct FDateTime                              Expire;                                            // 0x0000(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FGzMetaScheduledChallenge>      Challenges;                                        // 0x0008(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzMetaChallengeList) == 0x000008, "Wrong alignment on FGzMetaChallengeList");
static_assert(sizeof(FGzMetaChallengeList) == 0x000018, "Wrong size on FGzMetaChallengeList");
static_assert(offsetof(FGzMetaChallengeList, Expire) == 0x000000, "Member 'FGzMetaChallengeList::Expire' has a wrong offset!");
static_assert(offsetof(FGzMetaChallengeList, Challenges) == 0x000008, "Member 'FGzMetaChallengeList::Challenges' has a wrong offset!");

// ScriptStruct G01.GzPocketChangeHandle
// 0x0000 (0x000C - 0x000C)
struct FGzPocketChangeHandle final : public FGzInvSubscriptionHandle
{
};
static_assert(alignof(FGzPocketChangeHandle) == 0x000004, "Wrong alignment on FGzPocketChangeHandle");
static_assert(sizeof(FGzPocketChangeHandle) == 0x00000C, "Wrong size on FGzPocketChangeHandle");

// ScriptStruct G01.GzItemChangeHandle
// 0x0000 (0x000C - 0x000C)
struct FGzItemChangeHandle final : public FGzInvSubscriptionHandle
{
};
static_assert(alignof(FGzItemChangeHandle) == 0x000004, "Wrong alignment on FGzItemChangeHandle");
static_assert(sizeof(FGzItemChangeHandle) == 0x00000C, "Wrong size on FGzItemChangeHandle");

// ScriptStruct G01.GzWorldHitmarkEntry
// 0x0010 (0x0010 - 0x0000)
struct FGzWorldHitmarkEntry final
{
public:
	uint8                                         Pad_2BC0[0x8];                                     // 0x0000(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class AGzMarkerSceneContainer*                Marker;                                            // 0x0008(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzWorldHitmarkEntry) == 0x000008, "Wrong alignment on FGzWorldHitmarkEntry");
static_assert(sizeof(FGzWorldHitmarkEntry) == 0x000010, "Wrong size on FGzWorldHitmarkEntry");
static_assert(offsetof(FGzWorldHitmarkEntry, Marker) == 0x000008, "Member 'FGzWorldHitmarkEntry::Marker' has a wrong offset!");

// ScriptStruct G01.GzNavLinkSpawnData
// 0x0098 (0x0098 - 0x0000)
struct alignas(0x08) FGzNavLinkSpawnData final
{
public:
	uint8                                         Pad_2BC1[0x98];                                    // 0x0000(0x0098)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGzNavLinkSpawnData) == 0x000008, "Wrong alignment on FGzNavLinkSpawnData");
static_assert(sizeof(FGzNavLinkSpawnData) == 0x000098, "Wrong size on FGzNavLinkSpawnData");

// ScriptStruct G01.GzIrisGroup
// 0x0004 (0x0004 - 0x0000)
struct alignas(0x04) FGzIrisGroup final
{
public:
	uint8                                         Pad_2BC2[0x4];                                     // 0x0000(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGzIrisGroup) == 0x000004, "Wrong alignment on FGzIrisGroup");
static_assert(sizeof(FGzIrisGroup) == 0x000004, "Wrong size on FGzIrisGroup");

// ScriptStruct G01.GzItemAttribute
// 0x000C (0x000C - 0x0000)
struct FGzItemAttribute final
{
public:
	struct FGameplayTag                           Tag;                                               // 0x0000(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Value;                                             // 0x0008(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzItemAttribute) == 0x000004, "Wrong alignment on FGzItemAttribute");
static_assert(sizeof(FGzItemAttribute) == 0x00000C, "Wrong size on FGzItemAttribute");
static_assert(offsetof(FGzItemAttribute, Tag) == 0x000000, "Member 'FGzItemAttribute::Tag' has a wrong offset!");
static_assert(offsetof(FGzItemAttribute, Value) == 0x000008, "Member 'FGzItemAttribute::Value' has a wrong offset!");

// ScriptStruct G01.GzItemEntry
// 0x0018 (0x0018 - 0x0000)
struct FGzItemEntry final
{
public:
	class FName                                   Key;                                               // 0x0000(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class UGzContainerItemData*>           Items;                                             // 0x0008(0x0010)(BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzItemEntry) == 0x000008, "Wrong alignment on FGzItemEntry");
static_assert(sizeof(FGzItemEntry) == 0x000018, "Wrong size on FGzItemEntry");
static_assert(offsetof(FGzItemEntry, Key) == 0x000000, "Member 'FGzItemEntry::Key' has a wrong offset!");
static_assert(offsetof(FGzItemEntry, Items) == 0x000008, "Member 'FGzItemEntry::Items' has a wrong offset!");

// ScriptStruct G01.GzWeaponViewerSetup
// 0x00E0 (0x00F0 - 0x0010)
struct FGzWeaponViewerSetup final : public FGzDefaultViewerSetup
{
public:
	class AGzSceneViewpoint*                      PerType[0x8];                                      // 0x0010(0x0008)(Edit, ZeroConstructor, DisableEditOnTemplate, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TMap<class UGzWeaponArchetype*, class AGzSceneViewpoint*> PerArchetype;                                      // 0x0050(0x0050)(Edit, DisableEditOnTemplate, NativeAccessSpecifierPrivate)
	TMap<class UGzWeaponItemData*, class AGzSceneViewpoint*> PerWeapon;                                         // 0x00A0(0x0050)(Edit, DisableEditOnTemplate, NativeAccessSpecifierPrivate)
};
static_assert(alignof(FGzWeaponViewerSetup) == 0x000008, "Wrong alignment on FGzWeaponViewerSetup");
static_assert(sizeof(FGzWeaponViewerSetup) == 0x0000F0, "Wrong size on FGzWeaponViewerSetup");
static_assert(offsetof(FGzWeaponViewerSetup, PerType) == 0x000010, "Member 'FGzWeaponViewerSetup::PerType' has a wrong offset!");
static_assert(offsetof(FGzWeaponViewerSetup, PerArchetype) == 0x000050, "Member 'FGzWeaponViewerSetup::PerArchetype' has a wrong offset!");
static_assert(offsetof(FGzWeaponViewerSetup, PerWeapon) == 0x0000A0, "Member 'FGzWeaponViewerSetup::PerWeapon' has a wrong offset!");

// ScriptStruct G01.GzWeaponAttachmentViewerSetup
// 0x00D0 (0x00E0 - 0x0010)
struct FGzWeaponAttachmentViewerSetup final : public FGzDefaultViewerSetup
{
public:
	class AGzSceneViewpoint*                      PerType[0x8];                                      // 0x0010(0x0008)(Edit, ZeroConstructor, DisableEditOnTemplate, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AGzSceneViewpoint*                      PerWeaponType[0x8];                                // 0x0050(0x0008)(Edit, ZeroConstructor, DisableEditOnTemplate, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMap<class UGzWeaponArchetype*, class AGzSceneViewpoint*> PerWeaponArchetype;                                // 0x0090(0x0050)(Edit, DisableEditOnTemplate, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzWeaponAttachmentViewerSetup) == 0x000008, "Wrong alignment on FGzWeaponAttachmentViewerSetup");
static_assert(sizeof(FGzWeaponAttachmentViewerSetup) == 0x0000E0, "Wrong size on FGzWeaponAttachmentViewerSetup");
static_assert(offsetof(FGzWeaponAttachmentViewerSetup, PerType) == 0x000010, "Member 'FGzWeaponAttachmentViewerSetup::PerType' has a wrong offset!");
static_assert(offsetof(FGzWeaponAttachmentViewerSetup, PerWeaponType) == 0x000050, "Member 'FGzWeaponAttachmentViewerSetup::PerWeaponType' has a wrong offset!");
static_assert(offsetof(FGzWeaponAttachmentViewerSetup, PerWeaponArchetype) == 0x000090, "Member 'FGzWeaponAttachmentViewerSetup::PerWeaponArchetype' has a wrong offset!");

// ScriptStruct G01.GzLimbViewerSetup
// 0x0018 (0x0028 - 0x0010)
struct FGzLimbViewerSetup final : public FGzDefaultViewerSetup
{
public:
	class AGzSceneViewpoint*                      PerType[0x3];                                      // 0x0010(0x0008)(Edit, ZeroConstructor, DisableEditOnTemplate, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzLimbViewerSetup) == 0x000008, "Wrong alignment on FGzLimbViewerSetup");
static_assert(sizeof(FGzLimbViewerSetup) == 0x000028, "Wrong size on FGzLimbViewerSetup");
static_assert(offsetof(FGzLimbViewerSetup, PerType) == 0x000010, "Member 'FGzLimbViewerSetup::PerType' has a wrong offset!");

// ScriptStruct G01.GzItemOfTypeViewerSetup
// 0x0260 (0x0270 - 0x0010)
struct FGzItemOfTypeViewerSetup final : public FGzDefaultViewerSetup
{
public:
	struct FGzWeaponViewerSetup                   WeaponViewerSetup;                                 // 0x0010(0x00F0)(Edit, DisableEditOnTemplate, NativeAccessSpecifierPublic)
	struct FGzWeaponAttachmentViewerSetup         WeaponAttachmentViewerSetup;                       // 0x0100(0x00E0)(Edit, DisableEditOnTemplate, NativeAccessSpecifierPublic)
	struct FGzLimbViewerSetup                     LimbViewerSetup;                                   // 0x01E0(0x0028)(Edit, DisableEditOnTemplate, NativeAccessSpecifierPublic)
	struct FGzCustomizationViewerSetup            CustomizationViewerSetup;                          // 0x0208(0x0060)(Edit, DisableEditOnTemplate, NativeAccessSpecifierPublic)
	EGzItemType                                   TargetItemType;                                    // 0x0268(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2BC3[0x7];                                     // 0x0269(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGzItemOfTypeViewerSetup) == 0x000008, "Wrong alignment on FGzItemOfTypeViewerSetup");
static_assert(sizeof(FGzItemOfTypeViewerSetup) == 0x000270, "Wrong size on FGzItemOfTypeViewerSetup");
static_assert(offsetof(FGzItemOfTypeViewerSetup, WeaponViewerSetup) == 0x000010, "Member 'FGzItemOfTypeViewerSetup::WeaponViewerSetup' has a wrong offset!");
static_assert(offsetof(FGzItemOfTypeViewerSetup, WeaponAttachmentViewerSetup) == 0x000100, "Member 'FGzItemOfTypeViewerSetup::WeaponAttachmentViewerSetup' has a wrong offset!");
static_assert(offsetof(FGzItemOfTypeViewerSetup, LimbViewerSetup) == 0x0001E0, "Member 'FGzItemOfTypeViewerSetup::LimbViewerSetup' has a wrong offset!");
static_assert(offsetof(FGzItemOfTypeViewerSetup, CustomizationViewerSetup) == 0x000208, "Member 'FGzItemOfTypeViewerSetup::CustomizationViewerSetup' has a wrong offset!");
static_assert(offsetof(FGzItemOfTypeViewerSetup, TargetItemType) == 0x000268, "Member 'FGzItemOfTypeViewerSetup::TargetItemType' has a wrong offset!");

// ScriptStruct G01.GzOfflineGameModeData
// 0x0020 (0x0090 - 0x0070)
struct FGzOfflineGameModeData final : public FGzGameModeData
{
public:
	struct FSoftObjectPath                        Level;                                             // 0x0070(0x0020)(Edit, ZeroConstructor, Config, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzOfflineGameModeData) == 0x000008, "Wrong alignment on FGzOfflineGameModeData");
static_assert(sizeof(FGzOfflineGameModeData) == 0x000090, "Wrong size on FGzOfflineGameModeData");
static_assert(offsetof(FGzOfflineGameModeData, Level) == 0x000070, "Member 'FGzOfflineGameModeData::Level' has a wrong offset!");

// ScriptStruct G01.GzItemOfTypeViewmakerSetup
// 0x0040 (0x0048 - 0x0008)
struct FGzItemOfTypeViewmakerSetup final : public FGzDefaultItemViewmakerSetupBase
{
public:
	struct FInstancedStruct                       SetUp;                                             // 0x0008(0x0010)(Edit, DisableEditOnTemplate, NativeAccessSpecifierPrivate)
	struct FGzViewemakerSetup                     Default;                                           // 0x0018(0x0028)(Edit, DisableEditOnTemplate, NativeAccessSpecifierPrivate)
	EGzItemType                                   TargetItemType;                                    // 0x0040(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2BC4[0x7];                                     // 0x0041(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGzItemOfTypeViewmakerSetup) == 0x000008, "Wrong alignment on FGzItemOfTypeViewmakerSetup");
static_assert(sizeof(FGzItemOfTypeViewmakerSetup) == 0x000048, "Wrong size on FGzItemOfTypeViewmakerSetup");
static_assert(offsetof(FGzItemOfTypeViewmakerSetup, SetUp) == 0x000008, "Member 'FGzItemOfTypeViewmakerSetup::SetUp' has a wrong offset!");
static_assert(offsetof(FGzItemOfTypeViewmakerSetup, Default) == 0x000018, "Member 'FGzItemOfTypeViewmakerSetup::Default' has a wrong offset!");
static_assert(offsetof(FGzItemOfTypeViewmakerSetup, TargetItemType) == 0x000040, "Member 'FGzItemOfTypeViewmakerSetup::TargetItemType' has a wrong offset!");

// ScriptStruct G01.GzItemViewerSetup
// 0x2220 (0x2230 - 0x0010)
struct FGzItemViewerSetup final : public FGzDefaultViewerSetup
{
public:
	struct FGzItemOfTypeViewerSetup               PerType[0xE];                                      // 0x0010(0x0270)(Edit, DisableEditOnTemplate, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzItemViewerSetup) == 0x000008, "Wrong alignment on FGzItemViewerSetup");
static_assert(sizeof(FGzItemViewerSetup) == 0x002230, "Wrong size on FGzItemViewerSetup");
static_assert(offsetof(FGzItemViewerSetup, PerType) == 0x000010, "Member 'FGzItemViewerSetup::PerType' has a wrong offset!");

// ScriptStruct G01.GzItemViewmakerSetup
// 0x0108 (0x0110 - 0x0008)
struct FGzItemViewmakerSetup final : public FGzDefaultItemViewmakerSetupBase
{
public:
	struct FInstancedStruct                       PerType[0xE];                                      // 0x0008(0x0010)(Edit, DisableEditOnTemplate, NativeAccessSpecifierPrivate)
	struct FGzViewemakerSetup                     Default;                                           // 0x00E8(0x0028)(Edit, DisableEditOnTemplate, NativeAccessSpecifierPrivate)
};
static_assert(alignof(FGzItemViewmakerSetup) == 0x000008, "Wrong alignment on FGzItemViewmakerSetup");
static_assert(sizeof(FGzItemViewmakerSetup) == 0x000110, "Wrong size on FGzItemViewmakerSetup");
static_assert(offsetof(FGzItemViewmakerSetup, PerType) == 0x000008, "Member 'FGzItemViewmakerSetup::PerType' has a wrong offset!");
static_assert(offsetof(FGzItemViewmakerSetup, Default) == 0x0000E8, "Member 'FGzItemViewmakerSetup::Default' has a wrong offset!");

// ScriptStruct G01.GzItemSpawnerSceneSetup
// 0x0110 (0x0118 - 0x0008)
struct FGzItemSpawnerSceneSetup final : public FGzSceneSetupBase
{
public:
	struct FGzItemViewmakerSetup                  Viewmaker;                                         // 0x0008(0x0110)(Edit, DisableEditOnTemplate, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzItemSpawnerSceneSetup) == 0x000008, "Wrong alignment on FGzItemSpawnerSceneSetup");
static_assert(sizeof(FGzItemSpawnerSceneSetup) == 0x000118, "Wrong size on FGzItemSpawnerSceneSetup");
static_assert(offsetof(FGzItemSpawnerSceneSetup, Viewmaker) == 0x000008, "Member 'FGzItemSpawnerSceneSetup::Viewmaker' has a wrong offset!");

// ScriptStruct G01.GzJobSequenceData
// 0x0010 (0x0010 - 0x0000)
struct FGzJobSequenceData final
{
public:
	TArray<class UGzNarrativeMissionData*>        Missions;                                          // 0x0000(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzJobSequenceData) == 0x000008, "Wrong alignment on FGzJobSequenceData");
static_assert(sizeof(FGzJobSequenceData) == 0x000010, "Wrong size on FGzJobSequenceData");
static_assert(offsetof(FGzJobSequenceData, Missions) == 0x000000, "Member 'FGzJobSequenceData::Missions' has a wrong offset!");

// ScriptStruct G01.GzPredefinedPlayerProfile
// 0x0068 (0x0068 - 0x0000)
struct FGzPredefinedPlayerProfile final
{
public:
	class FString                                 PlayerName;                                        // 0x0000(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         PlayerId;                                          // 0x0010(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         TeamID;                                            // 0x0014(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UGzPredefinedPlayerLoadout> Loadout;                                           // 0x0018(0x0028)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UGzCustomizationProfileData> Customization;                                     // 0x0040(0x0028)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzPredefinedPlayerProfile) == 0x000008, "Wrong alignment on FGzPredefinedPlayerProfile");
static_assert(sizeof(FGzPredefinedPlayerProfile) == 0x000068, "Wrong size on FGzPredefinedPlayerProfile");
static_assert(offsetof(FGzPredefinedPlayerProfile, PlayerName) == 0x000000, "Member 'FGzPredefinedPlayerProfile::PlayerName' has a wrong offset!");
static_assert(offsetof(FGzPredefinedPlayerProfile, PlayerId) == 0x000010, "Member 'FGzPredefinedPlayerProfile::PlayerId' has a wrong offset!");
static_assert(offsetof(FGzPredefinedPlayerProfile, TeamID) == 0x000014, "Member 'FGzPredefinedPlayerProfile::TeamID' has a wrong offset!");
static_assert(offsetof(FGzPredefinedPlayerProfile, Loadout) == 0x000018, "Member 'FGzPredefinedPlayerProfile::Loadout' has a wrong offset!");
static_assert(offsetof(FGzPredefinedPlayerProfile, Customization) == 0x000040, "Member 'FGzPredefinedPlayerProfile::Customization' has a wrong offset!");

// ScriptStruct G01.GzPlayerProfileUsage
// 0x0070 (0x0070 - 0x0000)
struct FGzPlayerProfileUsage final
{
public:
	struct FGzPredefinedPlayerProfile             Profile;                                           // 0x0000(0x0068)(NativeAccessSpecifierPublic)
	bool                                          bUsed;                                             // 0x0068(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2BC5[0x7];                                     // 0x0069(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGzPlayerProfileUsage) == 0x000008, "Wrong alignment on FGzPlayerProfileUsage");
static_assert(sizeof(FGzPlayerProfileUsage) == 0x000070, "Wrong size on FGzPlayerProfileUsage");
static_assert(offsetof(FGzPlayerProfileUsage, Profile) == 0x000000, "Member 'FGzPlayerProfileUsage::Profile' has a wrong offset!");
static_assert(offsetof(FGzPlayerProfileUsage, bUsed) == 0x000068, "Member 'FGzPlayerProfileUsage::bUsed' has a wrong offset!");

// ScriptStruct G01.GzPackageGetMarketplaceItemTrends
// 0x0010 (0x0078 - 0x0068)
struct FGzPackageGetMarketplaceItemTrends final : public FGzPlayFabClientPackage
{
public:
	class FString                                 AssetId;                                           // 0x0068(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzPackageGetMarketplaceItemTrends) == 0x000008, "Wrong alignment on FGzPackageGetMarketplaceItemTrends");
static_assert(sizeof(FGzPackageGetMarketplaceItemTrends) == 0x000078, "Wrong size on FGzPackageGetMarketplaceItemTrends");
static_assert(offsetof(FGzPackageGetMarketplaceItemTrends, AssetId) == 0x000068, "Member 'FGzPackageGetMarketplaceItemTrends::AssetId' has a wrong offset!");

// ScriptStruct G01.GzJSKeysActions
// 0x0050 (0x0050 - 0x0000)
struct FGzJSKeysActions final
{
public:
	TMap<class FString, class FString>            KeysActions;                                       // 0x0000(0x0050)(NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzJSKeysActions) == 0x000008, "Wrong alignment on FGzJSKeysActions");
static_assert(sizeof(FGzJSKeysActions) == 0x000050, "Wrong size on FGzJSKeysActions");
static_assert(offsetof(FGzJSKeysActions, KeysActions) == 0x000000, "Member 'FGzJSKeysActions::KeysActions' has a wrong offset!");

// ScriptStruct G01.GzKeysActions
// 0x0050 (0x0050 - 0x0000)
struct FGzKeysActions final
{
public:
	TMap<struct FKey, class FString>              KeysActions;                                       // 0x0000(0x0050)(NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzKeysActions) == 0x000008, "Wrong alignment on FGzKeysActions");
static_assert(sizeof(FGzKeysActions) == 0x000050, "Wrong size on FGzKeysActions");
static_assert(offsetof(FGzKeysActions, KeysActions) == 0x000000, "Member 'FGzKeysActions::KeysActions' has a wrong offset!");

// ScriptStruct G01.GzMetaErrorNotificationContainer
// 0x0048 (0x0048 - 0x0000)
struct FGzMetaErrorNotificationContainer final
{
public:
	uint32                                        ErrorCode;                                         // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2BC6[0x4];                                     // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 EncodedError;                                      // 0x0008(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 OperationId;                                       // 0x0018(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint64                                        NotificationID;                                    // 0x0028(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FText                                   ErrorMessage;                                      // 0x0030(0x0010)(NativeAccessSpecifierPrivate)
	class FName                                   AsyncNotificationId;                               // 0x0040(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
};
static_assert(alignof(FGzMetaErrorNotificationContainer) == 0x000008, "Wrong alignment on FGzMetaErrorNotificationContainer");
static_assert(sizeof(FGzMetaErrorNotificationContainer) == 0x000048, "Wrong size on FGzMetaErrorNotificationContainer");
static_assert(offsetof(FGzMetaErrorNotificationContainer, ErrorCode) == 0x000000, "Member 'FGzMetaErrorNotificationContainer::ErrorCode' has a wrong offset!");
static_assert(offsetof(FGzMetaErrorNotificationContainer, EncodedError) == 0x000008, "Member 'FGzMetaErrorNotificationContainer::EncodedError' has a wrong offset!");
static_assert(offsetof(FGzMetaErrorNotificationContainer, OperationId) == 0x000018, "Member 'FGzMetaErrorNotificationContainer::OperationId' has a wrong offset!");
static_assert(offsetof(FGzMetaErrorNotificationContainer, NotificationID) == 0x000028, "Member 'FGzMetaErrorNotificationContainer::NotificationID' has a wrong offset!");
static_assert(offsetof(FGzMetaErrorNotificationContainer, ErrorMessage) == 0x000030, "Member 'FGzMetaErrorNotificationContainer::ErrorMessage' has a wrong offset!");
static_assert(offsetof(FGzMetaErrorNotificationContainer, AsyncNotificationId) == 0x000040, "Member 'FGzMetaErrorNotificationContainer::AsyncNotificationId' has a wrong offset!");

// ScriptStruct G01.GzSignPlayerAgreementResult
// 0x0000 (0x00E0 - 0x00E0)
struct FGzSignPlayerAgreementResult final : public FGzPlayFabResultBase
{
};
static_assert(alignof(FGzSignPlayerAgreementResult) == 0x000008, "Wrong alignment on FGzSignPlayerAgreementResult");
static_assert(sizeof(FGzSignPlayerAgreementResult) == 0x0000E0, "Wrong size on FGzSignPlayerAgreementResult");

// ScriptStruct G01.GzMetaLegalDocument
// 0x0020 (0x0020 - 0x0000)
struct FGzMetaLegalDocument final
{
public:
	class FText                                   Heading;                                           // 0x0000(0x0010)(Edit, Config, DisableEditOnInstance, NativeAccessSpecifierPublic)
	class FText                                   Content;                                           // 0x0010(0x0010)(Edit, Config, DisableEditOnInstance, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzMetaLegalDocument) == 0x000008, "Wrong alignment on FGzMetaLegalDocument");
static_assert(sizeof(FGzMetaLegalDocument) == 0x000020, "Wrong size on FGzMetaLegalDocument");
static_assert(offsetof(FGzMetaLegalDocument, Heading) == 0x000000, "Member 'FGzMetaLegalDocument::Heading' has a wrong offset!");
static_assert(offsetof(FGzMetaLegalDocument, Content) == 0x000010, "Member 'FGzMetaLegalDocument::Content' has a wrong offset!");

// ScriptStruct G01.GzPlatformLegalDocs
// 0x00D0 (0x00D0 - 0x0000)
struct FGzPlatformLegalDocs final
{
public:
	struct FGzMetaLegalDocument                   Eula;                                              // 0x0000(0x0020)(Edit, Config, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FGzMetaLegalDocument                   Nda;                                               // 0x0020(0x0020)(Edit, Config, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TArray<struct FGzMetaLegalDocument>           NdaOptions;                                        // 0x0040(0x0010)(Edit, ZeroConstructor, Config, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FGzMetaLegalDocument                   TermsOfUse;                                        // 0x0050(0x0020)(Edit, Config, DisableEditOnInstance, NativeAccessSpecifierPublic)
	class FText                                   TouLink;                                           // 0x0070(0x0010)(Edit, Config, DisableEditOnInstance, NativeAccessSpecifierPublic)
	class FText                                   EulaLink;                                          // 0x0080(0x0010)(Edit, Config, DisableEditOnInstance, NativeAccessSpecifierPublic)
	class FText                                   SubscriptionTouLink;                               // 0x0090(0x0010)(Edit, Config, DisableEditOnInstance, NativeAccessSpecifierPublic)
	class FText                                   DropRatesLink;                                     // 0x00A0(0x0010)(Edit, Config, DisableEditOnInstance, NativeAccessSpecifierPublic)
	class FText                                   PrivacyPolicyLink;                                 // 0x00B0(0x0010)(Edit, Config, DisableEditOnInstance, NativeAccessSpecifierPublic)
	class FText                                   NdaLink;                                           // 0x00C0(0x0010)(Edit, Config, DisableEditOnInstance, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzPlatformLegalDocs) == 0x000008, "Wrong alignment on FGzPlatformLegalDocs");
static_assert(sizeof(FGzPlatformLegalDocs) == 0x0000D0, "Wrong size on FGzPlatformLegalDocs");
static_assert(offsetof(FGzPlatformLegalDocs, Eula) == 0x000000, "Member 'FGzPlatformLegalDocs::Eula' has a wrong offset!");
static_assert(offsetof(FGzPlatformLegalDocs, Nda) == 0x000020, "Member 'FGzPlatformLegalDocs::Nda' has a wrong offset!");
static_assert(offsetof(FGzPlatformLegalDocs, NdaOptions) == 0x000040, "Member 'FGzPlatformLegalDocs::NdaOptions' has a wrong offset!");
static_assert(offsetof(FGzPlatformLegalDocs, TermsOfUse) == 0x000050, "Member 'FGzPlatformLegalDocs::TermsOfUse' has a wrong offset!");
static_assert(offsetof(FGzPlatformLegalDocs, TouLink) == 0x000070, "Member 'FGzPlatformLegalDocs::TouLink' has a wrong offset!");
static_assert(offsetof(FGzPlatformLegalDocs, EulaLink) == 0x000080, "Member 'FGzPlatformLegalDocs::EulaLink' has a wrong offset!");
static_assert(offsetof(FGzPlatformLegalDocs, SubscriptionTouLink) == 0x000090, "Member 'FGzPlatformLegalDocs::SubscriptionTouLink' has a wrong offset!");
static_assert(offsetof(FGzPlatformLegalDocs, DropRatesLink) == 0x0000A0, "Member 'FGzPlatformLegalDocs::DropRatesLink' has a wrong offset!");
static_assert(offsetof(FGzPlatformLegalDocs, PrivacyPolicyLink) == 0x0000B0, "Member 'FGzPlatformLegalDocs::PrivacyPolicyLink' has a wrong offset!");
static_assert(offsetof(FGzPlatformLegalDocs, NdaLink) == 0x0000C0, "Member 'FGzPlatformLegalDocs::NdaLink' has a wrong offset!");

// ScriptStruct G01.GzWeaponViewmakerSetup
// 0x0208 (0x0210 - 0x0008)
struct FGzWeaponViewmakerSetup final : public FGzDefaultItemViewmakerSetupBase
{
public:
	struct FGzViewemakerSetup                     PerType[0x8];                                      // 0x0008(0x0028)(Edit, DisableEditOnTemplate, NativeAccessSpecifierPrivate)
	TMap<class UGzWeaponArchetype*, struct FGzViewemakerSetup> PerArchetype;                                      // 0x0148(0x0050)(Edit, DisableEditOnTemplate, NativeAccessSpecifierPrivate)
	TMap<class UGzWeaponItemData*, struct FGzViewemakerSetup> PerWeapon;                                         // 0x0198(0x0050)(Edit, DisableEditOnTemplate, NativeAccessSpecifierPrivate)
	struct FGzViewemakerSetup                     Default;                                           // 0x01E8(0x0028)(Edit, DisableEditOnTemplate, NativeAccessSpecifierPrivate)
};
static_assert(alignof(FGzWeaponViewmakerSetup) == 0x000008, "Wrong alignment on FGzWeaponViewmakerSetup");
static_assert(sizeof(FGzWeaponViewmakerSetup) == 0x000210, "Wrong size on FGzWeaponViewmakerSetup");
static_assert(offsetof(FGzWeaponViewmakerSetup, PerType) == 0x000008, "Member 'FGzWeaponViewmakerSetup::PerType' has a wrong offset!");
static_assert(offsetof(FGzWeaponViewmakerSetup, PerArchetype) == 0x000148, "Member 'FGzWeaponViewmakerSetup::PerArchetype' has a wrong offset!");
static_assert(offsetof(FGzWeaponViewmakerSetup, PerWeapon) == 0x000198, "Member 'FGzWeaponViewmakerSetup::PerWeapon' has a wrong offset!");
static_assert(offsetof(FGzWeaponViewmakerSetup, Default) == 0x0001E8, "Member 'FGzWeaponViewmakerSetup::Default' has a wrong offset!");

// ScriptStruct G01.GzLegalSettingsPerPlatform
// 0x0050 (0x0050 - 0x0000)
struct FGzLegalSettingsPerPlatform final
{
public:
	TMap<EGzPlatformType, struct FGzPlatformLegalDocs> DocsPerPlatform;                                   // 0x0000(0x0050)(NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzLegalSettingsPerPlatform) == 0x000008, "Wrong alignment on FGzLegalSettingsPerPlatform");
static_assert(sizeof(FGzLegalSettingsPerPlatform) == 0x000050, "Wrong size on FGzLegalSettingsPerPlatform");
static_assert(offsetof(FGzLegalSettingsPerPlatform, DocsPerPlatform) == 0x000000, "Member 'FGzLegalSettingsPerPlatform::DocsPerPlatform' has a wrong offset!");

// ScriptStruct G01.GzLegalSettingsLocalizations
// 0x0050 (0x0050 - 0x0000)
struct FGzLegalSettingsLocalizations final
{
public:
	TMap<class FString, struct FGzLegalSettingsPerPlatform> Localizations;                                     // 0x0000(0x0050)(NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzLegalSettingsLocalizations) == 0x000008, "Wrong alignment on FGzLegalSettingsLocalizations");
static_assert(sizeof(FGzLegalSettingsLocalizations) == 0x000050, "Wrong size on FGzLegalSettingsLocalizations");
static_assert(offsetof(FGzLegalSettingsLocalizations, Localizations) == 0x000000, "Member 'FGzLegalSettingsLocalizations::Localizations' has a wrong offset!");

// ScriptStruct G01.GzInputActionBindingHandle
// 0x0004 (0x0004 - 0x0000)
struct alignas(0x04) FGzInputActionBindingHandle final
{
public:
	uint8                                         Pad_2BC7[0x4];                                     // 0x0000(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGzInputActionBindingHandle) == 0x000004, "Wrong alignment on FGzInputActionBindingHandle");
static_assert(sizeof(FGzInputActionBindingHandle) == 0x000004, "Wrong size on FGzInputActionBindingHandle");

// ScriptStruct G01.GzTransformWithoutScale
// 0x0040 (0x0040 - 0x0000)
struct FGzTransformWithoutScale final
{
public:
	struct FVector                                Location;                                          // 0x0000(0x0018)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2BC8[0x8];                                     // 0x0018(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FQuat                                  Quat;                                              // 0x0020(0x0020)(Edit, BlueprintVisible, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzTransformWithoutScale) == 0x000010, "Wrong alignment on FGzTransformWithoutScale");
static_assert(sizeof(FGzTransformWithoutScale) == 0x000040, "Wrong size on FGzTransformWithoutScale");
static_assert(offsetof(FGzTransformWithoutScale, Location) == 0x000000, "Member 'FGzTransformWithoutScale::Location' has a wrong offset!");
static_assert(offsetof(FGzTransformWithoutScale, Quat) == 0x000020, "Member 'FGzTransformWithoutScale::Quat' has a wrong offset!");

// ScriptStruct G01.GzLimbMeshSetupData
// 0x0080 (0x0080 - 0x0000)
struct FGzLimbMeshSetupData final
{
public:
	TArray<struct FGzTransformWithoutScale>       BoneTransforms;                                    // 0x0000(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	struct FTransform                             InitTransform;                                     // 0x0010(0x0060)(Edit, BlueprintVisible, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsInitialized;                                    // 0x0070(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2BC9[0xF];                                     // 0x0071(0x000F)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGzLimbMeshSetupData) == 0x000010, "Wrong alignment on FGzLimbMeshSetupData");
static_assert(sizeof(FGzLimbMeshSetupData) == 0x000080, "Wrong size on FGzLimbMeshSetupData");
static_assert(offsetof(FGzLimbMeshSetupData, BoneTransforms) == 0x000000, "Member 'FGzLimbMeshSetupData::BoneTransforms' has a wrong offset!");
static_assert(offsetof(FGzLimbMeshSetupData, InitTransform) == 0x000010, "Member 'FGzLimbMeshSetupData::InitTransform' has a wrong offset!");
static_assert(offsetof(FGzLimbMeshSetupData, bIsInitialized) == 0x000070, "Member 'FGzLimbMeshSetupData::bIsInitialized' has a wrong offset!");

// ScriptStruct G01.GzMarkerRadiusSetting
// 0x0040 (0x0040 - 0x0000)
struct FGzMarkerRadiusSetting final
{
public:
	bool                                          bEnableVisibilityRadius;                           // 0x0000(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2BCA[0x3];                                     // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MinVisibilityRadius;                               // 0x0004(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxVisibilityRadius;                               // 0x0008(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FFloatRange                            VisibilityRangeSquared;                            // 0x000C(0x0010)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2BCB[0x4];                                     // 0x001C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTagContainer                  IgnoreStates;                                      // 0x0020(0x0020)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzMarkerRadiusSetting) == 0x000008, "Wrong alignment on FGzMarkerRadiusSetting");
static_assert(sizeof(FGzMarkerRadiusSetting) == 0x000040, "Wrong size on FGzMarkerRadiusSetting");
static_assert(offsetof(FGzMarkerRadiusSetting, bEnableVisibilityRadius) == 0x000000, "Member 'FGzMarkerRadiusSetting::bEnableVisibilityRadius' has a wrong offset!");
static_assert(offsetof(FGzMarkerRadiusSetting, MinVisibilityRadius) == 0x000004, "Member 'FGzMarkerRadiusSetting::MinVisibilityRadius' has a wrong offset!");
static_assert(offsetof(FGzMarkerRadiusSetting, MaxVisibilityRadius) == 0x000008, "Member 'FGzMarkerRadiusSetting::MaxVisibilityRadius' has a wrong offset!");
static_assert(offsetof(FGzMarkerRadiusSetting, VisibilityRangeSquared) == 0x00000C, "Member 'FGzMarkerRadiusSetting::VisibilityRangeSquared' has a wrong offset!");
static_assert(offsetof(FGzMarkerRadiusSetting, IgnoreStates) == 0x000020, "Member 'FGzMarkerRadiusSetting::IgnoreStates' has a wrong offset!");

// ScriptStruct G01.GzLimbViewmakerSetup
// 0x0160 (0x0168 - 0x0008)
struct FGzLimbViewmakerSetup final : public FGzDefaultItemViewmakerSetupBase
{
public:
	struct FGzViewemakerSetupWithMannequin        PerType[0x3];                                      // 0x0008(0x0058)(Edit, DisableEditOnTemplate, NativeAccessSpecifierPrivate)
	struct FGzViewemakerSetupWithMannequin        Default;                                           // 0x0110(0x0058)(Edit, DisableEditOnTemplate, NativeAccessSpecifierPrivate)
};
static_assert(alignof(FGzLimbViewmakerSetup) == 0x000008, "Wrong alignment on FGzLimbViewmakerSetup");
static_assert(sizeof(FGzLimbViewmakerSetup) == 0x000168, "Wrong size on FGzLimbViewmakerSetup");
static_assert(offsetof(FGzLimbViewmakerSetup, PerType) == 0x000008, "Member 'FGzLimbViewmakerSetup::PerType' has a wrong offset!");
static_assert(offsetof(FGzLimbViewmakerSetup, Default) == 0x000110, "Member 'FGzLimbViewmakerSetup::Default' has a wrong offset!");

// ScriptStruct G01.GzResultLiveFeatureMarketplaceConfig
// 0x0018 (0x0018 - 0x0000)
struct FGzResultLiveFeatureMarketplaceConfig final
{
public:
	class FString                                 GeneralFeePercentage;                              // 0x0000(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         UnlockSellLevel;                                   // 0x0010(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          RequireSubscriptionToSell;                         // 0x0014(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2BCC[0x3];                                     // 0x0015(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGzResultLiveFeatureMarketplaceConfig) == 0x000008, "Wrong alignment on FGzResultLiveFeatureMarketplaceConfig");
static_assert(sizeof(FGzResultLiveFeatureMarketplaceConfig) == 0x000018, "Wrong size on FGzResultLiveFeatureMarketplaceConfig");
static_assert(offsetof(FGzResultLiveFeatureMarketplaceConfig, GeneralFeePercentage) == 0x000000, "Member 'FGzResultLiveFeatureMarketplaceConfig::GeneralFeePercentage' has a wrong offset!");
static_assert(offsetof(FGzResultLiveFeatureMarketplaceConfig, UnlockSellLevel) == 0x000010, "Member 'FGzResultLiveFeatureMarketplaceConfig::UnlockSellLevel' has a wrong offset!");
static_assert(offsetof(FGzResultLiveFeatureMarketplaceConfig, RequireSubscriptionToSell) == 0x000014, "Member 'FGzResultLiveFeatureMarketplaceConfig::RequireSubscriptionToSell' has a wrong offset!");

// ScriptStruct G01.GzResultLiveFeatureMatchmakingTimeRange
// 0x0020 (0x0020 - 0x0000)
struct FGzResultLiveFeatureMatchmakingTimeRange final
{
public:
	class FString                                 From;                                              // 0x0000(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 To;                                                // 0x0010(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzResultLiveFeatureMatchmakingTimeRange) == 0x000008, "Wrong alignment on FGzResultLiveFeatureMatchmakingTimeRange");
static_assert(sizeof(FGzResultLiveFeatureMatchmakingTimeRange) == 0x000020, "Wrong size on FGzResultLiveFeatureMatchmakingTimeRange");
static_assert(offsetof(FGzResultLiveFeatureMatchmakingTimeRange, From) == 0x000000, "Member 'FGzResultLiveFeatureMatchmakingTimeRange::From' has a wrong offset!");
static_assert(offsetof(FGzResultLiveFeatureMatchmakingTimeRange, To) == 0x000010, "Member 'FGzResultLiveFeatureMatchmakingTimeRange::To' has a wrong offset!");

// ScriptStruct G01.GzResultLiveFeatureUnityMatchmakingTime
// 0x0018 (0x0018 - 0x0000)
struct FGzResultLiveFeatureUnityMatchmakingTime final
{
public:
	bool                                          EnableTime;                                        // 0x0000(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2BCD[0x7];                                     // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FGzResultLiveFeatureMatchmakingTimeRange> Ranges;                                            // 0x0008(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzResultLiveFeatureUnityMatchmakingTime) == 0x000008, "Wrong alignment on FGzResultLiveFeatureUnityMatchmakingTime");
static_assert(sizeof(FGzResultLiveFeatureUnityMatchmakingTime) == 0x000018, "Wrong size on FGzResultLiveFeatureUnityMatchmakingTime");
static_assert(offsetof(FGzResultLiveFeatureUnityMatchmakingTime, EnableTime) == 0x000000, "Member 'FGzResultLiveFeatureUnityMatchmakingTime::EnableTime' has a wrong offset!");
static_assert(offsetof(FGzResultLiveFeatureUnityMatchmakingTime, Ranges) == 0x000008, "Member 'FGzResultLiveFeatureUnityMatchmakingTime::Ranges' has a wrong offset!");

// ScriptStruct G01.GzNotificationDeserializer
// 0x0050 (0x0050 - 0x0000)
struct alignas(0x08) FGzNotificationDeserializer final
{
public:
	uint8                                         Pad_2BCE[0x50];                                    // 0x0000(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGzNotificationDeserializer) == 0x000008, "Wrong alignment on FGzNotificationDeserializer");
static_assert(sizeof(FGzNotificationDeserializer) == 0x000050, "Wrong size on FGzNotificationDeserializer");

// ScriptStruct G01.GzResultLiveFeatureUnityMatchmaking
// 0x0020 (0x0020 - 0x0000)
struct FGzResultLiveFeatureUnityMatchmaking final
{
public:
	bool                                          Enabled;                                           // 0x0000(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2BCF[0x7];                                     // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGzResultLiveFeatureUnityMatchmakingTime Time;                                              // 0x0008(0x0018)(NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzResultLiveFeatureUnityMatchmaking) == 0x000008, "Wrong alignment on FGzResultLiveFeatureUnityMatchmaking");
static_assert(sizeof(FGzResultLiveFeatureUnityMatchmaking) == 0x000020, "Wrong size on FGzResultLiveFeatureUnityMatchmaking");
static_assert(offsetof(FGzResultLiveFeatureUnityMatchmaking, Enabled) == 0x000000, "Member 'FGzResultLiveFeatureUnityMatchmaking::Enabled' has a wrong offset!");
static_assert(offsetof(FGzResultLiveFeatureUnityMatchmaking, Time) == 0x000008, "Member 'FGzResultLiveFeatureUnityMatchmaking::Time' has a wrong offset!");

// ScriptStruct G01.GzResultLiveFeatureMatchmakingQueueGroup
// 0x0020 (0x0020 - 0x0000)
struct FGzResultLiveFeatureMatchmakingQueueGroup final
{
public:
	class FString                                 Name;                                              // 0x0000(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FGzResultLiveFeatureMatchmakingQueue> Queues;                                            // 0x0010(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzResultLiveFeatureMatchmakingQueueGroup) == 0x000008, "Wrong alignment on FGzResultLiveFeatureMatchmakingQueueGroup");
static_assert(sizeof(FGzResultLiveFeatureMatchmakingQueueGroup) == 0x000020, "Wrong size on FGzResultLiveFeatureMatchmakingQueueGroup");
static_assert(offsetof(FGzResultLiveFeatureMatchmakingQueueGroup, Name) == 0x000000, "Member 'FGzResultLiveFeatureMatchmakingQueueGroup::Name' has a wrong offset!");
static_assert(offsetof(FGzResultLiveFeatureMatchmakingQueueGroup, Queues) == 0x000010, "Member 'FGzResultLiveFeatureMatchmakingQueueGroup::Queues' has a wrong offset!");

// ScriptStruct G01.GzResultLiveFeatureMatchmakingConfig
// 0x0030 (0x0030 - 0x0000)
struct FGzResultLiveFeatureMatchmakingConfig final
{
public:
	class FString                                 FleetId;                                           // 0x0000(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 DefaultQueue;                                      // 0x0010(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FGzResultLiveFeatureMatchmakingQueueGroup> AvailableQueues;                                   // 0x0020(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzResultLiveFeatureMatchmakingConfig) == 0x000008, "Wrong alignment on FGzResultLiveFeatureMatchmakingConfig");
static_assert(sizeof(FGzResultLiveFeatureMatchmakingConfig) == 0x000030, "Wrong size on FGzResultLiveFeatureMatchmakingConfig");
static_assert(offsetof(FGzResultLiveFeatureMatchmakingConfig, FleetId) == 0x000000, "Member 'FGzResultLiveFeatureMatchmakingConfig::FleetId' has a wrong offset!");
static_assert(offsetof(FGzResultLiveFeatureMatchmakingConfig, DefaultQueue) == 0x000010, "Member 'FGzResultLiveFeatureMatchmakingConfig::DefaultQueue' has a wrong offset!");
static_assert(offsetof(FGzResultLiveFeatureMatchmakingConfig, AvailableQueues) == 0x000020, "Member 'FGzResultLiveFeatureMatchmakingConfig::AvailableQueues' has a wrong offset!");

// ScriptStruct G01.GzMarketplaceListedMarketPagingInfo
// 0x000C (0x000C - 0x0000)
struct FGzMarketplaceListedMarketPagingInfo final
{
public:
	int32                                         CurrentPage;                                       // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         PageSize;                                          // 0x0004(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          HasNextPage;                                       // 0x0008(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2BD0[0x3];                                     // 0x0009(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGzMarketplaceListedMarketPagingInfo) == 0x000004, "Wrong alignment on FGzMarketplaceListedMarketPagingInfo");
static_assert(sizeof(FGzMarketplaceListedMarketPagingInfo) == 0x00000C, "Wrong size on FGzMarketplaceListedMarketPagingInfo");
static_assert(offsetof(FGzMarketplaceListedMarketPagingInfo, CurrentPage) == 0x000000, "Member 'FGzMarketplaceListedMarketPagingInfo::CurrentPage' has a wrong offset!");
static_assert(offsetof(FGzMarketplaceListedMarketPagingInfo, PageSize) == 0x000004, "Member 'FGzMarketplaceListedMarketPagingInfo::PageSize' has a wrong offset!");
static_assert(offsetof(FGzMarketplaceListedMarketPagingInfo, HasNextPage) == 0x000008, "Member 'FGzMarketplaceListedMarketPagingInfo::HasNextPage' has a wrong offset!");

// ScriptStruct G01.GzResultLiveFeatureFraudPriceRangeFilter
// 0x0038 (0x0038 - 0x0000)
struct FGzResultLiveFeatureFraudPriceRangeFilter final
{
public:
	class FString                                 ItemClass;                                         // 0x0000(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Rarity;                                            // 0x0010(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 AssetId;                                           // 0x0020(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsValid;                                           // 0x0030(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2BD1[0x7];                                     // 0x0031(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGzResultLiveFeatureFraudPriceRangeFilter) == 0x000008, "Wrong alignment on FGzResultLiveFeatureFraudPriceRangeFilter");
static_assert(sizeof(FGzResultLiveFeatureFraudPriceRangeFilter) == 0x000038, "Wrong size on FGzResultLiveFeatureFraudPriceRangeFilter");
static_assert(offsetof(FGzResultLiveFeatureFraudPriceRangeFilter, ItemClass) == 0x000000, "Member 'FGzResultLiveFeatureFraudPriceRangeFilter::ItemClass' has a wrong offset!");
static_assert(offsetof(FGzResultLiveFeatureFraudPriceRangeFilter, Rarity) == 0x000010, "Member 'FGzResultLiveFeatureFraudPriceRangeFilter::Rarity' has a wrong offset!");
static_assert(offsetof(FGzResultLiveFeatureFraudPriceRangeFilter, AssetId) == 0x000020, "Member 'FGzResultLiveFeatureFraudPriceRangeFilter::AssetId' has a wrong offset!");
static_assert(offsetof(FGzResultLiveFeatureFraudPriceRangeFilter, IsValid) == 0x000030, "Member 'FGzResultLiveFeatureFraudPriceRangeFilter::IsValid' has a wrong offset!");

// ScriptStruct G01.GzResultLiveFeatureFraudPriceRange
// 0x0048 (0x0048 - 0x0000)
struct FGzResultLiveFeatureFraudPriceRange final
{
public:
	struct FGzResultLiveFeatureFraudPriceRangeFilter Filter;                                            // 0x0000(0x0038)(NativeAccessSpecifierPublic)
	uint32                                        Min;                                               // 0x0038(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint32                                        Max;                                               // 0x003C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsValid;                                           // 0x0040(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2BD2[0x7];                                     // 0x0041(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGzResultLiveFeatureFraudPriceRange) == 0x000008, "Wrong alignment on FGzResultLiveFeatureFraudPriceRange");
static_assert(sizeof(FGzResultLiveFeatureFraudPriceRange) == 0x000048, "Wrong size on FGzResultLiveFeatureFraudPriceRange");
static_assert(offsetof(FGzResultLiveFeatureFraudPriceRange, Filter) == 0x000000, "Member 'FGzResultLiveFeatureFraudPriceRange::Filter' has a wrong offset!");
static_assert(offsetof(FGzResultLiveFeatureFraudPriceRange, Min) == 0x000038, "Member 'FGzResultLiveFeatureFraudPriceRange::Min' has a wrong offset!");
static_assert(offsetof(FGzResultLiveFeatureFraudPriceRange, Max) == 0x00003C, "Member 'FGzResultLiveFeatureFraudPriceRange::Max' has a wrong offset!");
static_assert(offsetof(FGzResultLiveFeatureFraudPriceRange, IsValid) == 0x000040, "Member 'FGzResultLiveFeatureFraudPriceRange::IsValid' has a wrong offset!");

// ScriptStruct G01.GzResultLiveFeatureFraudPriceRangeValidation
// 0x0018 (0x0018 - 0x0000)
struct FGzResultLiveFeatureFraudPriceRangeValidation final
{
public:
	bool                                          Enabled;                                           // 0x0000(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2BD3[0x7];                                     // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FGzResultLiveFeatureFraudPriceRange> PriceRanges;                                       // 0x0008(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzResultLiveFeatureFraudPriceRangeValidation) == 0x000008, "Wrong alignment on FGzResultLiveFeatureFraudPriceRangeValidation");
static_assert(sizeof(FGzResultLiveFeatureFraudPriceRangeValidation) == 0x000018, "Wrong size on FGzResultLiveFeatureFraudPriceRangeValidation");
static_assert(offsetof(FGzResultLiveFeatureFraudPriceRangeValidation, Enabled) == 0x000000, "Member 'FGzResultLiveFeatureFraudPriceRangeValidation::Enabled' has a wrong offset!");
static_assert(offsetof(FGzResultLiveFeatureFraudPriceRangeValidation, PriceRanges) == 0x000008, "Member 'FGzResultLiveFeatureFraudPriceRangeValidation::PriceRanges' has a wrong offset!");

// ScriptStruct G01.GzResultLiveFeatureFraudItemTradeCooldownValidation
// 0x0018 (0x0018 - 0x0000)
struct FGzResultLiveFeatureFraudItemTradeCooldownValidation final
{
public:
	bool                                          Enabled;                                           // 0x0000(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2BD4[0x7];                                     // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 TradeCooldown;                                     // 0x0008(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzResultLiveFeatureFraudItemTradeCooldownValidation) == 0x000008, "Wrong alignment on FGzResultLiveFeatureFraudItemTradeCooldownValidation");
static_assert(sizeof(FGzResultLiveFeatureFraudItemTradeCooldownValidation) == 0x000018, "Wrong size on FGzResultLiveFeatureFraudItemTradeCooldownValidation");
static_assert(offsetof(FGzResultLiveFeatureFraudItemTradeCooldownValidation, Enabled) == 0x000000, "Member 'FGzResultLiveFeatureFraudItemTradeCooldownValidation::Enabled' has a wrong offset!");
static_assert(offsetof(FGzResultLiveFeatureFraudItemTradeCooldownValidation, TradeCooldown) == 0x000008, "Member 'FGzResultLiveFeatureFraudItemTradeCooldownValidation::TradeCooldown' has a wrong offset!");

// ScriptStruct G01.GzResultLiveFeatureFraudPlayerTradeRules
// 0x0028 (0x0028 - 0x0000)
struct FGzResultLiveFeatureFraudPlayerTradeRules final
{
public:
	bool                                          Enabled;                                           // 0x0000(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2BD5[0x3];                                     // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	uint32                                        TradesPerTimeRange;                                // 0x0004(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 TimeRangeHours;                                    // 0x0008(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 OverTheRateCooldown;                               // 0x0018(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzResultLiveFeatureFraudPlayerTradeRules) == 0x000008, "Wrong alignment on FGzResultLiveFeatureFraudPlayerTradeRules");
static_assert(sizeof(FGzResultLiveFeatureFraudPlayerTradeRules) == 0x000028, "Wrong size on FGzResultLiveFeatureFraudPlayerTradeRules");
static_assert(offsetof(FGzResultLiveFeatureFraudPlayerTradeRules, Enabled) == 0x000000, "Member 'FGzResultLiveFeatureFraudPlayerTradeRules::Enabled' has a wrong offset!");
static_assert(offsetof(FGzResultLiveFeatureFraudPlayerTradeRules, TradesPerTimeRange) == 0x000004, "Member 'FGzResultLiveFeatureFraudPlayerTradeRules::TradesPerTimeRange' has a wrong offset!");
static_assert(offsetof(FGzResultLiveFeatureFraudPlayerTradeRules, TimeRangeHours) == 0x000008, "Member 'FGzResultLiveFeatureFraudPlayerTradeRules::TimeRangeHours' has a wrong offset!");
static_assert(offsetof(FGzResultLiveFeatureFraudPlayerTradeRules, OverTheRateCooldown) == 0x000018, "Member 'FGzResultLiveFeatureFraudPlayerTradeRules::OverTheRateCooldown' has a wrong offset!");

// ScriptStruct G01.GzMetaCharacterAvatarAppearance
// 0x0050 (0x0050 - 0x0000)
struct FGzMetaCharacterAvatarAppearance final
{
public:
	TMap<struct FGameplayTag, class UGzCustomizationItemTemplate*> Slots;                                             // 0x0000(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, UObjectWrapper, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzMetaCharacterAvatarAppearance) == 0x000008, "Wrong alignment on FGzMetaCharacterAvatarAppearance");
static_assert(sizeof(FGzMetaCharacterAvatarAppearance) == 0x000050, "Wrong size on FGzMetaCharacterAvatarAppearance");
static_assert(offsetof(FGzMetaCharacterAvatarAppearance, Slots) == 0x000000, "Member 'FGzMetaCharacterAvatarAppearance::Slots' has a wrong offset!");

// ScriptStruct G01.GzResultLiveFeatureFraudPlayerTradeRateValidation
// 0x0050 (0x0050 - 0x0000)
struct FGzResultLiveFeatureFraudPlayerTradeRateValidation final
{
public:
	struct FGzResultLiveFeatureFraudPlayerTradeRules TradeRateForSelling;                               // 0x0000(0x0028)(NativeAccessSpecifierPublic)
	struct FGzResultLiveFeatureFraudPlayerTradeRules TradeRateForBuying;                                // 0x0028(0x0028)(NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzResultLiveFeatureFraudPlayerTradeRateValidation) == 0x000008, "Wrong alignment on FGzResultLiveFeatureFraudPlayerTradeRateValidation");
static_assert(sizeof(FGzResultLiveFeatureFraudPlayerTradeRateValidation) == 0x000050, "Wrong size on FGzResultLiveFeatureFraudPlayerTradeRateValidation");
static_assert(offsetof(FGzResultLiveFeatureFraudPlayerTradeRateValidation, TradeRateForSelling) == 0x000000, "Member 'FGzResultLiveFeatureFraudPlayerTradeRateValidation::TradeRateForSelling' has a wrong offset!");
static_assert(offsetof(FGzResultLiveFeatureFraudPlayerTradeRateValidation, TradeRateForBuying) == 0x000028, "Member 'FGzResultLiveFeatureFraudPlayerTradeRateValidation::TradeRateForBuying' has a wrong offset!");

// ScriptStruct G01.GzResultLiveFeatureFraudPrevention
// 0x0088 (0x0088 - 0x0000)
struct FGzResultLiveFeatureFraudPrevention final
{
public:
	bool                                          Enabled;                                           // 0x0000(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2BD6[0x7];                                     // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGzResultLiveFeatureFraudPriceRangeValidation PriceRangeValidation;                              // 0x0008(0x0018)(NativeAccessSpecifierPublic)
	struct FGzResultLiveFeatureFraudItemTradeCooldownValidation ItemTradeCooldownValidation;                       // 0x0020(0x0018)(NativeAccessSpecifierPublic)
	struct FGzResultLiveFeatureFraudPlayerTradeRateValidation PlayerTradeRateValidation;                         // 0x0038(0x0050)(NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzResultLiveFeatureFraudPrevention) == 0x000008, "Wrong alignment on FGzResultLiveFeatureFraudPrevention");
static_assert(sizeof(FGzResultLiveFeatureFraudPrevention) == 0x000088, "Wrong size on FGzResultLiveFeatureFraudPrevention");
static_assert(offsetof(FGzResultLiveFeatureFraudPrevention, Enabled) == 0x000000, "Member 'FGzResultLiveFeatureFraudPrevention::Enabled' has a wrong offset!");
static_assert(offsetof(FGzResultLiveFeatureFraudPrevention, PriceRangeValidation) == 0x000008, "Member 'FGzResultLiveFeatureFraudPrevention::PriceRangeValidation' has a wrong offset!");
static_assert(offsetof(FGzResultLiveFeatureFraudPrevention, ItemTradeCooldownValidation) == 0x000020, "Member 'FGzResultLiveFeatureFraudPrevention::ItemTradeCooldownValidation' has a wrong offset!");
static_assert(offsetof(FGzResultLiveFeatureFraudPrevention, PlayerTradeRateValidation) == 0x000038, "Member 'FGzResultLiveFeatureFraudPrevention::PlayerTradeRateValidation' has a wrong offset!");

// ScriptStruct G01.GzResultPaymentProviderSettings
// 0x0002 (0x0002 - 0x0000)
struct FGzResultPaymentProviderSettings final
{
public:
	bool                                          DisableXsollaPaymentProvider;                      // 0x0000(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          DisableStripePaymentProvider;                      // 0x0001(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzResultPaymentProviderSettings) == 0x000001, "Wrong alignment on FGzResultPaymentProviderSettings");
static_assert(sizeof(FGzResultPaymentProviderSettings) == 0x000002, "Wrong size on FGzResultPaymentProviderSettings");
static_assert(offsetof(FGzResultPaymentProviderSettings, DisableXsollaPaymentProvider) == 0x000000, "Member 'FGzResultPaymentProviderSettings::DisableXsollaPaymentProvider' has a wrong offset!");
static_assert(offsetof(FGzResultPaymentProviderSettings, DisableStripePaymentProvider) == 0x000001, "Member 'FGzResultPaymentProviderSettings::DisableStripePaymentProvider' has a wrong offset!");

// ScriptStruct G01.GzResultRemoveMarketLot
// 0x00A0 (0x0180 - 0x00E0)
struct FGzResultRemoveMarketLot final : public FGzPlayFabResultBase
{
public:
	struct FGzBackendOnlineInventoryItemDisplayProperties Dp;                                                // 0x00E0(0x00A0)(NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzResultRemoveMarketLot) == 0x000008, "Wrong alignment on FGzResultRemoveMarketLot");
static_assert(sizeof(FGzResultRemoveMarketLot) == 0x000180, "Wrong size on FGzResultRemoveMarketLot");
static_assert(offsetof(FGzResultRemoveMarketLot, Dp) == 0x0000E0, "Member 'FGzResultRemoveMarketLot::Dp' has a wrong offset!");

// ScriptStruct G01.GzResultLiveFeatureHiddenAsset
// 0x0030 (0x0030 - 0x0000)
struct FGzResultLiveFeatureHiddenAsset final
{
public:
	TArray<class FString>                         AssetIds;                                          // 0x0000(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class FString>                         HiddenModes;                                       // 0x0010(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	class FString                                 Until;                                             // 0x0020(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzResultLiveFeatureHiddenAsset) == 0x000008, "Wrong alignment on FGzResultLiveFeatureHiddenAsset");
static_assert(sizeof(FGzResultLiveFeatureHiddenAsset) == 0x000030, "Wrong size on FGzResultLiveFeatureHiddenAsset");
static_assert(offsetof(FGzResultLiveFeatureHiddenAsset, AssetIds) == 0x000000, "Member 'FGzResultLiveFeatureHiddenAsset::AssetIds' has a wrong offset!");
static_assert(offsetof(FGzResultLiveFeatureHiddenAsset, HiddenModes) == 0x000010, "Member 'FGzResultLiveFeatureHiddenAsset::HiddenModes' has a wrong offset!");
static_assert(offsetof(FGzResultLiveFeatureHiddenAsset, Until) == 0x000020, "Member 'FGzResultLiveFeatureHiddenAsset::Until' has a wrong offset!");

// ScriptStruct G01.GzResultGetClientLiveFeatures
// 0x01D0 (0x02B0 - 0x00E0)
struct FGzResultGetClientLiveFeatures final : public FGzPlayFabResultBase
{
public:
	bool                                          DisableMarketplace;                                // 0x00E0(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          DisableBattlePass;                                 // 0x00E1(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          DisableDecode;                                     // 0x00E2(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          DisableUnityMatchmaking;                           // 0x00E3(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          DisableCustomMatchmaking;                          // 0x00E4(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          DisableMultiCharacter;                             // 0x00E5(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          DisablePaymentProviders;                           // 0x00E6(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          DisableLoadouts;                                   // 0x00E7(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          DisableCharacterCustomization;                     // 0x00E8(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          DisableJobs;                                       // 0x00E9(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          DisablePostmatchFeedback;                          // 0x00EA(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          DisableClientItemValidation;                       // 0x00EB(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          EnableFullStarterItems;                            // 0x00EC(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2BD7[0x3];                                     // 0x00ED(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 ItemValidationTimespan;                            // 0x00F0(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 DisableClientIn;                                   // 0x0100(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGzResultLiveFeatureMarketplaceConfig  MarketplaceFeesConfig;                             // 0x0110(0x0018)(NativeAccessSpecifierPublic)
	struct FGzResultLiveFeatureMatchmakingConfig  MatchmakingConfig;                                 // 0x0128(0x0030)(NativeAccessSpecifierPublic)
	TArray<int32>                                 SuppressedNotifications;                           // 0x0158(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TMap<class FString, class FString>            Overrides;                                         // 0x0168(0x0050)(NativeAccessSpecifierPublic)
	struct FGzResultLiveFeatureUnityMatchmaking   EnableUnityMatchmaking;                            // 0x01B8(0x0020)(NativeAccessSpecifierPublic)
	bool                                          XSollaEnableSandboxMode;                           // 0x01D8(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2BD8[0x7];                                     // 0x01D9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 XSollaProjectId;                                   // 0x01E0(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 PostponeSubscriptionCost;                          // 0x01F0(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 XSollaSubscriptionPlanId;                          // 0x0200(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 XSollaSubscriptionUSDPrice;                        // 0x0210(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGzResultLiveFeatureFraudPrevention    MarketplaceFraudPreventionSettings;                // 0x0220(0x0088)(NativeAccessSpecifierPublic)
	struct FGzResultPaymentProviderSettings       PaymentProviderSettings;                           // 0x02A8(0x0002)(NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_2BD9[0x6];                                     // 0x02AA(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGzResultGetClientLiveFeatures) == 0x000008, "Wrong alignment on FGzResultGetClientLiveFeatures");
static_assert(sizeof(FGzResultGetClientLiveFeatures) == 0x0002B0, "Wrong size on FGzResultGetClientLiveFeatures");
static_assert(offsetof(FGzResultGetClientLiveFeatures, DisableMarketplace) == 0x0000E0, "Member 'FGzResultGetClientLiveFeatures::DisableMarketplace' has a wrong offset!");
static_assert(offsetof(FGzResultGetClientLiveFeatures, DisableBattlePass) == 0x0000E1, "Member 'FGzResultGetClientLiveFeatures::DisableBattlePass' has a wrong offset!");
static_assert(offsetof(FGzResultGetClientLiveFeatures, DisableDecode) == 0x0000E2, "Member 'FGzResultGetClientLiveFeatures::DisableDecode' has a wrong offset!");
static_assert(offsetof(FGzResultGetClientLiveFeatures, DisableUnityMatchmaking) == 0x0000E3, "Member 'FGzResultGetClientLiveFeatures::DisableUnityMatchmaking' has a wrong offset!");
static_assert(offsetof(FGzResultGetClientLiveFeatures, DisableCustomMatchmaking) == 0x0000E4, "Member 'FGzResultGetClientLiveFeatures::DisableCustomMatchmaking' has a wrong offset!");
static_assert(offsetof(FGzResultGetClientLiveFeatures, DisableMultiCharacter) == 0x0000E5, "Member 'FGzResultGetClientLiveFeatures::DisableMultiCharacter' has a wrong offset!");
static_assert(offsetof(FGzResultGetClientLiveFeatures, DisablePaymentProviders) == 0x0000E6, "Member 'FGzResultGetClientLiveFeatures::DisablePaymentProviders' has a wrong offset!");
static_assert(offsetof(FGzResultGetClientLiveFeatures, DisableLoadouts) == 0x0000E7, "Member 'FGzResultGetClientLiveFeatures::DisableLoadouts' has a wrong offset!");
static_assert(offsetof(FGzResultGetClientLiveFeatures, DisableCharacterCustomization) == 0x0000E8, "Member 'FGzResultGetClientLiveFeatures::DisableCharacterCustomization' has a wrong offset!");
static_assert(offsetof(FGzResultGetClientLiveFeatures, DisableJobs) == 0x0000E9, "Member 'FGzResultGetClientLiveFeatures::DisableJobs' has a wrong offset!");
static_assert(offsetof(FGzResultGetClientLiveFeatures, DisablePostmatchFeedback) == 0x0000EA, "Member 'FGzResultGetClientLiveFeatures::DisablePostmatchFeedback' has a wrong offset!");
static_assert(offsetof(FGzResultGetClientLiveFeatures, DisableClientItemValidation) == 0x0000EB, "Member 'FGzResultGetClientLiveFeatures::DisableClientItemValidation' has a wrong offset!");
static_assert(offsetof(FGzResultGetClientLiveFeatures, EnableFullStarterItems) == 0x0000EC, "Member 'FGzResultGetClientLiveFeatures::EnableFullStarterItems' has a wrong offset!");
static_assert(offsetof(FGzResultGetClientLiveFeatures, ItemValidationTimespan) == 0x0000F0, "Member 'FGzResultGetClientLiveFeatures::ItemValidationTimespan' has a wrong offset!");
static_assert(offsetof(FGzResultGetClientLiveFeatures, DisableClientIn) == 0x000100, "Member 'FGzResultGetClientLiveFeatures::DisableClientIn' has a wrong offset!");
static_assert(offsetof(FGzResultGetClientLiveFeatures, MarketplaceFeesConfig) == 0x000110, "Member 'FGzResultGetClientLiveFeatures::MarketplaceFeesConfig' has a wrong offset!");
static_assert(offsetof(FGzResultGetClientLiveFeatures, MatchmakingConfig) == 0x000128, "Member 'FGzResultGetClientLiveFeatures::MatchmakingConfig' has a wrong offset!");
static_assert(offsetof(FGzResultGetClientLiveFeatures, SuppressedNotifications) == 0x000158, "Member 'FGzResultGetClientLiveFeatures::SuppressedNotifications' has a wrong offset!");
static_assert(offsetof(FGzResultGetClientLiveFeatures, Overrides) == 0x000168, "Member 'FGzResultGetClientLiveFeatures::Overrides' has a wrong offset!");
static_assert(offsetof(FGzResultGetClientLiveFeatures, EnableUnityMatchmaking) == 0x0001B8, "Member 'FGzResultGetClientLiveFeatures::EnableUnityMatchmaking' has a wrong offset!");
static_assert(offsetof(FGzResultGetClientLiveFeatures, XSollaEnableSandboxMode) == 0x0001D8, "Member 'FGzResultGetClientLiveFeatures::XSollaEnableSandboxMode' has a wrong offset!");
static_assert(offsetof(FGzResultGetClientLiveFeatures, XSollaProjectId) == 0x0001E0, "Member 'FGzResultGetClientLiveFeatures::XSollaProjectId' has a wrong offset!");
static_assert(offsetof(FGzResultGetClientLiveFeatures, PostponeSubscriptionCost) == 0x0001F0, "Member 'FGzResultGetClientLiveFeatures::PostponeSubscriptionCost' has a wrong offset!");
static_assert(offsetof(FGzResultGetClientLiveFeatures, XSollaSubscriptionPlanId) == 0x000200, "Member 'FGzResultGetClientLiveFeatures::XSollaSubscriptionPlanId' has a wrong offset!");
static_assert(offsetof(FGzResultGetClientLiveFeatures, XSollaSubscriptionUSDPrice) == 0x000210, "Member 'FGzResultGetClientLiveFeatures::XSollaSubscriptionUSDPrice' has a wrong offset!");
static_assert(offsetof(FGzResultGetClientLiveFeatures, MarketplaceFraudPreventionSettings) == 0x000220, "Member 'FGzResultGetClientLiveFeatures::MarketplaceFraudPreventionSettings' has a wrong offset!");
static_assert(offsetof(FGzResultGetClientLiveFeatures, PaymentProviderSettings) == 0x0002A8, "Member 'FGzResultGetClientLiveFeatures::PaymentProviderSettings' has a wrong offset!");

// ScriptStruct G01.GzResultLiveFeatureClientEnabledTimeRange
// 0x0010 (0x0010 - 0x0000)
struct FGzResultLiveFeatureClientEnabledTimeRange final
{
public:
	struct FDateTime                              From;                                              // 0x0000(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FDateTime                              To;                                                // 0x0008(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzResultLiveFeatureClientEnabledTimeRange) == 0x000008, "Wrong alignment on FGzResultLiveFeatureClientEnabledTimeRange");
static_assert(sizeof(FGzResultLiveFeatureClientEnabledTimeRange) == 0x000010, "Wrong size on FGzResultLiveFeatureClientEnabledTimeRange");
static_assert(offsetof(FGzResultLiveFeatureClientEnabledTimeRange, From) == 0x000000, "Member 'FGzResultLiveFeatureClientEnabledTimeRange::From' has a wrong offset!");
static_assert(offsetof(FGzResultLiveFeatureClientEnabledTimeRange, To) == 0x000008, "Member 'FGzResultLiveFeatureClientEnabledTimeRange::To' has a wrong offset!");

// ScriptStruct G01.GzResultLiveFeatureClientEnabledTimeConfig
// 0x0018 (0x0018 - 0x0000)
struct FGzResultLiveFeatureClientEnabledTimeConfig final
{
public:
	bool                                          EnableTime;                                        // 0x0000(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2BDA[0x7];                                     // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FGzResultLiveFeatureClientEnabledTimeRange> Ranges;                                            // 0x0008(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzResultLiveFeatureClientEnabledTimeConfig) == 0x000008, "Wrong alignment on FGzResultLiveFeatureClientEnabledTimeConfig");
static_assert(sizeof(FGzResultLiveFeatureClientEnabledTimeConfig) == 0x000018, "Wrong size on FGzResultLiveFeatureClientEnabledTimeConfig");
static_assert(offsetof(FGzResultLiveFeatureClientEnabledTimeConfig, EnableTime) == 0x000000, "Member 'FGzResultLiveFeatureClientEnabledTimeConfig::EnableTime' has a wrong offset!");
static_assert(offsetof(FGzResultLiveFeatureClientEnabledTimeConfig, Ranges) == 0x000008, "Member 'FGzResultLiveFeatureClientEnabledTimeConfig::Ranges' has a wrong offset!");

// ScriptStruct G01.GzResultLiveFeatureClientEnabled
// 0x0020 (0x0020 - 0x0000)
struct FGzResultLiveFeatureClientEnabled final
{
public:
	bool                                          Enabled;                                           // 0x0000(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2BDB[0x7];                                     // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGzResultLiveFeatureClientEnabledTimeConfig Time;                                              // 0x0008(0x0018)(NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzResultLiveFeatureClientEnabled) == 0x000008, "Wrong alignment on FGzResultLiveFeatureClientEnabled");
static_assert(sizeof(FGzResultLiveFeatureClientEnabled) == 0x000020, "Wrong size on FGzResultLiveFeatureClientEnabled");
static_assert(offsetof(FGzResultLiveFeatureClientEnabled, Enabled) == 0x000000, "Member 'FGzResultLiveFeatureClientEnabled::Enabled' has a wrong offset!");
static_assert(offsetof(FGzResultLiveFeatureClientEnabled, Time) == 0x000008, "Member 'FGzResultLiveFeatureClientEnabled::Time' has a wrong offset!");

// ScriptStruct G01.GzMetaListMarketPagingParameters
// 0x0008 (0x0008 - 0x0000)
struct FGzMetaListMarketPagingParameters final
{
public:
	uint32                                        Offset;                                            // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint32                                        Limit;                                             // 0x0004(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzMetaListMarketPagingParameters) == 0x000004, "Wrong alignment on FGzMetaListMarketPagingParameters");
static_assert(sizeof(FGzMetaListMarketPagingParameters) == 0x000008, "Wrong size on FGzMetaListMarketPagingParameters");
static_assert(offsetof(FGzMetaListMarketPagingParameters, Offset) == 0x000000, "Member 'FGzMetaListMarketPagingParameters::Offset' has a wrong offset!");
static_assert(offsetof(FGzMetaListMarketPagingParameters, Limit) == 0x000004, "Member 'FGzMetaListMarketPagingParameters::Limit' has a wrong offset!");

// ScriptStruct G01.GzLoadoutBoxSceneSetup
// 0x00D8 (0x00E0 - 0x0008)
struct FGzLoadoutBoxSceneSetup final : public FGzSceneSetupBase
{
public:
	struct FGzDefaultViewerSetup                  Viewer;                                            // 0x0008(0x0010)(Edit, DisableEditOnTemplate, NativeAccessSpecifierPublic)
	struct FGzLoadoutViewmakerSetup               Viewmaker;                                         // 0x0018(0x00C8)(Edit, DisableEditOnTemplate, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzLoadoutBoxSceneSetup) == 0x000008, "Wrong alignment on FGzLoadoutBoxSceneSetup");
static_assert(sizeof(FGzLoadoutBoxSceneSetup) == 0x0000E0, "Wrong size on FGzLoadoutBoxSceneSetup");
static_assert(offsetof(FGzLoadoutBoxSceneSetup, Viewer) == 0x000008, "Member 'FGzLoadoutBoxSceneSetup::Viewer' has a wrong offset!");
static_assert(offsetof(FGzLoadoutBoxSceneSetup, Viewmaker) == 0x000018, "Member 'FGzLoadoutBoxSceneSetup::Viewmaker' has a wrong offset!");

// ScriptStruct G01.GzMissionStarterPerStageSpawnParams
// 0x0008 (0x0008 - 0x0000)
struct FGzMissionStarterPerStageSpawnParams final
{
public:
	int32                                         MinAmountOfMissions;                               // 0x0000(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaxAmountOfMissions;                               // 0x0004(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzMissionStarterPerStageSpawnParams) == 0x000004, "Wrong alignment on FGzMissionStarterPerStageSpawnParams");
static_assert(sizeof(FGzMissionStarterPerStageSpawnParams) == 0x000008, "Wrong size on FGzMissionStarterPerStageSpawnParams");
static_assert(offsetof(FGzMissionStarterPerStageSpawnParams, MinAmountOfMissions) == 0x000000, "Member 'FGzMissionStarterPerStageSpawnParams::MinAmountOfMissions' has a wrong offset!");
static_assert(offsetof(FGzMissionStarterPerStageSpawnParams, MaxAmountOfMissions) == 0x000004, "Member 'FGzMissionStarterPerStageSpawnParams::MaxAmountOfMissions' has a wrong offset!");

// ScriptStruct G01.GzLoadoutSelectionTabShowData
// 0x0008 (0x0008 - 0x0000)
struct FGzLoadoutSelectionTabShowData final
{
public:
	class FName                                   TabName;                                           // 0x0000(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzLoadoutSelectionTabShowData) == 0x000004, "Wrong alignment on FGzLoadoutSelectionTabShowData");
static_assert(sizeof(FGzLoadoutSelectionTabShowData) == 0x000008, "Wrong size on FGzLoadoutSelectionTabShowData");
static_assert(offsetof(FGzLoadoutSelectionTabShowData, TabName) == 0x000000, "Member 'FGzLoadoutSelectionTabShowData::TabName' has a wrong offset!");

// ScriptStruct G01.GzLoadoutMultiTabData
// 0x000C (0x000C - 0x0000)
struct FGzLoadoutMultiTabData final
{
public:
	EGzLoadoutListTabOptions                      Option;                                            // 0x0000(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2BDC[0x3];                                     // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGzLoadoutSelectionTabShowData         Data;                                              // 0x0004(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzLoadoutMultiTabData) == 0x000004, "Wrong alignment on FGzLoadoutMultiTabData");
static_assert(sizeof(FGzLoadoutMultiTabData) == 0x00000C, "Wrong size on FGzLoadoutMultiTabData");
static_assert(offsetof(FGzLoadoutMultiTabData, Option) == 0x000000, "Member 'FGzLoadoutMultiTabData::Option' has a wrong offset!");
static_assert(offsetof(FGzLoadoutMultiTabData, Data) == 0x000004, "Member 'FGzLoadoutMultiTabData::Data' has a wrong offset!");

// ScriptStruct G01.GzLoadoutSelectionTabData
// 0x0010 (0x0010 - 0x0000)
struct FGzLoadoutSelectionTabData final
{
public:
	TArray<struct FGzLoadoutDataConfig>           LoadoutConfigs;                                    // 0x0000(0x0010)(ZeroConstructor, Transient, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzLoadoutSelectionTabData) == 0x000008, "Wrong alignment on FGzLoadoutSelectionTabData");
static_assert(sizeof(FGzLoadoutSelectionTabData) == 0x000010, "Wrong size on FGzLoadoutSelectionTabData");
static_assert(offsetof(FGzLoadoutSelectionTabData, LoadoutConfigs) == 0x000000, "Member 'FGzLoadoutSelectionTabData::LoadoutConfigs' has a wrong offset!");

// ScriptStruct G01.GzLoadoutSelectionContext
// 0x00F8 (0x00F8 - 0x0000)
struct FGzLoadoutSelectionContext final
{
public:
	struct FGzLoadoutDataConfig                   SelectedLoadoutData;                               // 0x0000(0x0070)(BlueprintVisible, BlueprintReadOnly, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FGuid                                  RandomLoadoutGuid;                                 // 0x0070(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGzLoadoutSelectionTabData             SingleTabData;                                     // 0x0080(0x0010)(BlueprintVisible, BlueprintReadOnly, ContainsInstancedReference, NativeAccessSpecifierPublic)
	TMap<EGzLoadoutListTabOptions, struct FGzLoadoutSelectionTabData> MultiTabDatas;                                     // 0x0090(0x0050)(BlueprintVisible, BlueprintReadOnly, ContainsInstancedReference, NativeAccessSpecifierPublic)
	class AGzPlayerController*                    OwningController;                                  // 0x00E0(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UGzLoadoutSelectionScreen*              SlotOwningScreen;                                  // 0x00E8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AutoCloseTime;                                     // 0x00F0(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EGzLoadoutListTabOptions                      HotTabCategory;                                    // 0x00F4(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2BDD[0x3];                                     // 0x00F5(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGzLoadoutSelectionContext) == 0x000008, "Wrong alignment on FGzLoadoutSelectionContext");
static_assert(sizeof(FGzLoadoutSelectionContext) == 0x0000F8, "Wrong size on FGzLoadoutSelectionContext");
static_assert(offsetof(FGzLoadoutSelectionContext, SelectedLoadoutData) == 0x000000, "Member 'FGzLoadoutSelectionContext::SelectedLoadoutData' has a wrong offset!");
static_assert(offsetof(FGzLoadoutSelectionContext, RandomLoadoutGuid) == 0x000070, "Member 'FGzLoadoutSelectionContext::RandomLoadoutGuid' has a wrong offset!");
static_assert(offsetof(FGzLoadoutSelectionContext, SingleTabData) == 0x000080, "Member 'FGzLoadoutSelectionContext::SingleTabData' has a wrong offset!");
static_assert(offsetof(FGzLoadoutSelectionContext, MultiTabDatas) == 0x000090, "Member 'FGzLoadoutSelectionContext::MultiTabDatas' has a wrong offset!");
static_assert(offsetof(FGzLoadoutSelectionContext, OwningController) == 0x0000E0, "Member 'FGzLoadoutSelectionContext::OwningController' has a wrong offset!");
static_assert(offsetof(FGzLoadoutSelectionContext, SlotOwningScreen) == 0x0000E8, "Member 'FGzLoadoutSelectionContext::SlotOwningScreen' has a wrong offset!");
static_assert(offsetof(FGzLoadoutSelectionContext, AutoCloseTime) == 0x0000F0, "Member 'FGzLoadoutSelectionContext::AutoCloseTime' has a wrong offset!");
static_assert(offsetof(FGzLoadoutSelectionContext, HotTabCategory) == 0x0000F4, "Member 'FGzLoadoutSelectionContext::HotTabCategory' has a wrong offset!");

// ScriptStruct G01.GzLootArchetypeTableRow
// 0x0030 (0x0030 - 0x0000)
struct FGzLootArchetypeTableRow final
{
public:
	struct FSoftObjectPath                        Value;                                             // 0x0000(0x0020)(Edit, ZeroConstructor, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Quantity;                                          // 0x0020(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Weight;                                            // 0x0024(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Percentage;                                        // 0x0028(0x0004)(Edit, ZeroConstructor, Transient, DisableEditOnInstance, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2BDE[0x4];                                     // 0x002C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGzLootArchetypeTableRow) == 0x000008, "Wrong alignment on FGzLootArchetypeTableRow");
static_assert(sizeof(FGzLootArchetypeTableRow) == 0x000030, "Wrong size on FGzLootArchetypeTableRow");
static_assert(offsetof(FGzLootArchetypeTableRow, Value) == 0x000000, "Member 'FGzLootArchetypeTableRow::Value' has a wrong offset!");
static_assert(offsetof(FGzLootArchetypeTableRow, Quantity) == 0x000020, "Member 'FGzLootArchetypeTableRow::Quantity' has a wrong offset!");
static_assert(offsetof(FGzLootArchetypeTableRow, Weight) == 0x000024, "Member 'FGzLootArchetypeTableRow::Weight' has a wrong offset!");
static_assert(offsetof(FGzLootArchetypeTableRow, Percentage) == 0x000028, "Member 'FGzLootArchetypeTableRow::Percentage' has a wrong offset!");

// ScriptStruct G01.GzLootModifier
// 0x0014 (0x0014 - 0x0000)
struct FGzLootModifier final
{
public:
	class FName                                   ItemToModify;                                      // 0x0000(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bMultiply;                                         // 0x0008(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2BDF[0x3];                                     // 0x0009(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         WeightMultiplier;                                  // 0x000C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         WeightValue;                                       // 0x0010(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzLootModifier) == 0x000004, "Wrong alignment on FGzLootModifier");
static_assert(sizeof(FGzLootModifier) == 0x000014, "Wrong size on FGzLootModifier");
static_assert(offsetof(FGzLootModifier, ItemToModify) == 0x000000, "Member 'FGzLootModifier::ItemToModify' has a wrong offset!");
static_assert(offsetof(FGzLootModifier, bMultiply) == 0x000008, "Member 'FGzLootModifier::bMultiply' has a wrong offset!");
static_assert(offsetof(FGzLootModifier, WeightMultiplier) == 0x00000C, "Member 'FGzLootModifier::WeightMultiplier' has a wrong offset!");
static_assert(offsetof(FGzLootModifier, WeightValue) == 0x000010, "Member 'FGzLootModifier::WeightValue' has a wrong offset!");

// ScriptStruct G01.GzLootRarityTableRow
// 0x0010 (0x0010 - 0x0000)
struct FGzLootRarityTableRow final
{
public:
	EGzItemRarity                                 Value;                                             // 0x0000(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2BE0[0x3];                                     // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         Weight;                                            // 0x0004(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Percentage;                                        // 0x0008(0x0004)(Edit, ZeroConstructor, Transient, DisableEditOnInstance, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2BE1[0x4];                                     // 0x000C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGzLootRarityTableRow) == 0x000004, "Wrong alignment on FGzLootRarityTableRow");
static_assert(sizeof(FGzLootRarityTableRow) == 0x000010, "Wrong size on FGzLootRarityTableRow");
static_assert(offsetof(FGzLootRarityTableRow, Value) == 0x000000, "Member 'FGzLootRarityTableRow::Value' has a wrong offset!");
static_assert(offsetof(FGzLootRarityTableRow, Weight) == 0x000004, "Member 'FGzLootRarityTableRow::Weight' has a wrong offset!");
static_assert(offsetof(FGzLootRarityTableRow, Percentage) == 0x000008, "Member 'FGzLootRarityTableRow::Percentage' has a wrong offset!");

// ScriptStruct G01.GzLootItemVariantionsTableRow
// 0x0058 (0x0058 - 0x0000)
struct FGzLootItemVariantionsTableRow final
{
public:
	struct FGzInventoryItemContent                Value;                                             // 0x0000(0x0048)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	int32                                         Weight;                                            // 0x0048(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Percentage;                                        // 0x004C(0x0004)(Edit, ZeroConstructor, Transient, DisableEditOnInstance, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2BE2[0x8];                                     // 0x0050(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGzLootItemVariantionsTableRow) == 0x000008, "Wrong alignment on FGzLootItemVariantionsTableRow");
static_assert(sizeof(FGzLootItemVariantionsTableRow) == 0x000058, "Wrong size on FGzLootItemVariantionsTableRow");
static_assert(offsetof(FGzLootItemVariantionsTableRow, Value) == 0x000000, "Member 'FGzLootItemVariantionsTableRow::Value' has a wrong offset!");
static_assert(offsetof(FGzLootItemVariantionsTableRow, Weight) == 0x000048, "Member 'FGzLootItemVariantionsTableRow::Weight' has a wrong offset!");
static_assert(offsetof(FGzLootItemVariantionsTableRow, Percentage) == 0x00004C, "Member 'FGzLootItemVariantionsTableRow::Percentage' has a wrong offset!");

// ScriptStruct G01.GzMapZoneInitParams
// 0x0030 (0x0030 - 0x0000)
struct FGzMapZoneInitParams final
{
public:
	class UGzMapWidget*                           ParentWidget;                                      // 0x0000(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AGzBattleRoyaleZone*                    Zone;                                              // 0x0008(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTexture2D*                             ZoneTexture;                                       // 0x0010(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ZoneColorCode;                                     // 0x0018(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2BE3[0x4];                                     // 0x001C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector2D                              ZoneOrigin;                                        // 0x0020(0x0010)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzMapZoneInitParams) == 0x000008, "Wrong alignment on FGzMapZoneInitParams");
static_assert(sizeof(FGzMapZoneInitParams) == 0x000030, "Wrong size on FGzMapZoneInitParams");
static_assert(offsetof(FGzMapZoneInitParams, ParentWidget) == 0x000000, "Member 'FGzMapZoneInitParams::ParentWidget' has a wrong offset!");
static_assert(offsetof(FGzMapZoneInitParams, Zone) == 0x000008, "Member 'FGzMapZoneInitParams::Zone' has a wrong offset!");
static_assert(offsetof(FGzMapZoneInitParams, ZoneTexture) == 0x000010, "Member 'FGzMapZoneInitParams::ZoneTexture' has a wrong offset!");
static_assert(offsetof(FGzMapZoneInitParams, ZoneColorCode) == 0x000018, "Member 'FGzMapZoneInitParams::ZoneColorCode' has a wrong offset!");
static_assert(offsetof(FGzMapZoneInitParams, ZoneOrigin) == 0x000020, "Member 'FGzMapZoneInitParams::ZoneOrigin' has a wrong offset!");

// ScriptStruct G01.GzMarkAttributionResult
// 0x0080 (0x0080 - 0x0000)
struct FGzMarkAttributionResult final
{
public:
	struct FGzAdvancedIdType                      InstigatorId;                                      // 0x0000(0x0008)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGzAdvancedIdType                      VictimId;                                          // 0x0008(0x0008)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGzDamageMarkInfo                      DamageInfo;                                        // 0x0010(0x0020)(NoDestructor, NativeAccessSpecifierPublic)
	TSet<struct FGzAdvancedIdType>                Assists;                                           // 0x0030(0x0050)(NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzMarkAttributionResult) == 0x000008, "Wrong alignment on FGzMarkAttributionResult");
static_assert(sizeof(FGzMarkAttributionResult) == 0x000080, "Wrong size on FGzMarkAttributionResult");
static_assert(offsetof(FGzMarkAttributionResult, InstigatorId) == 0x000000, "Member 'FGzMarkAttributionResult::InstigatorId' has a wrong offset!");
static_assert(offsetof(FGzMarkAttributionResult, VictimId) == 0x000008, "Member 'FGzMarkAttributionResult::VictimId' has a wrong offset!");
static_assert(offsetof(FGzMarkAttributionResult, DamageInfo) == 0x000010, "Member 'FGzMarkAttributionResult::DamageInfo' has a wrong offset!");
static_assert(offsetof(FGzMarkAttributionResult, Assists) == 0x000030, "Member 'FGzMarkAttributionResult::Assists' has a wrong offset!");

// ScriptStruct G01.GzMarkerContainer
// 0x0018 (0x0018 - 0x0000)
struct FGzMarkerContainer final
{
public:
	TArray<class AGzMissionMarker*>               Markers;                                           // 0x0000(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2BE4[0x8];                                     // 0x0010(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGzMarkerContainer) == 0x000008, "Wrong alignment on FGzMarkerContainer");
static_assert(sizeof(FGzMarkerContainer) == 0x000018, "Wrong size on FGzMarkerContainer");
static_assert(offsetof(FGzMarkerContainer, Markers) == 0x000000, "Member 'FGzMarkerContainer::Markers' has a wrong offset!");

// ScriptStruct G01.GzServerMarkerBuildDataLocation
// 0x0058 (0x0058 - 0x0000)
struct FGzServerMarkerBuildDataLocation final
{
public:
	struct FVector                                Location;                                          // 0x0000(0x0018)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftClassPtr<class UClass>                   MarkerActorClass;                                  // 0x0018(0x0028)(Edit, BlueprintVisible, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RotationDegrees;                                   // 0x0040(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2BE5[0x4];                                     // 0x0044(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   Text;                                              // 0x0048(0x0010)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzServerMarkerBuildDataLocation) == 0x000008, "Wrong alignment on FGzServerMarkerBuildDataLocation");
static_assert(sizeof(FGzServerMarkerBuildDataLocation) == 0x000058, "Wrong size on FGzServerMarkerBuildDataLocation");
static_assert(offsetof(FGzServerMarkerBuildDataLocation, Location) == 0x000000, "Member 'FGzServerMarkerBuildDataLocation::Location' has a wrong offset!");
static_assert(offsetof(FGzServerMarkerBuildDataLocation, MarkerActorClass) == 0x000018, "Member 'FGzServerMarkerBuildDataLocation::MarkerActorClass' has a wrong offset!");
static_assert(offsetof(FGzServerMarkerBuildDataLocation, RotationDegrees) == 0x000040, "Member 'FGzServerMarkerBuildDataLocation::RotationDegrees' has a wrong offset!");
static_assert(offsetof(FGzServerMarkerBuildDataLocation, Text) == 0x000048, "Member 'FGzServerMarkerBuildDataLocation::Text' has a wrong offset!");

// ScriptStruct G01.GzServerMarkerBuildDataActor
// 0x0050 (0x0050 - 0x0000)
struct FGzServerMarkerBuildDataActor final
{
public:
	TSoftClassPtr<class UClass>                   MarkerActorClass;                                  // 0x0000(0x0028)(Edit, BlueprintVisible, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 TargetActor;                                       // 0x0028(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bNeedsAutoAttachmentOnStreamedIn;                  // 0x0030(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2BE6[0x3];                                     // 0x0031(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         PositionUpdateFrequency;                           // 0x0034(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   Text;                                              // 0x0038(0x0010)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	bool                                          bUseRandomOffset;                                  // 0x0048(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2BE7[0x3];                                     // 0x0049(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         RandomOffsetExtent;                                // 0x004C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzServerMarkerBuildDataActor) == 0x000008, "Wrong alignment on FGzServerMarkerBuildDataActor");
static_assert(sizeof(FGzServerMarkerBuildDataActor) == 0x000050, "Wrong size on FGzServerMarkerBuildDataActor");
static_assert(offsetof(FGzServerMarkerBuildDataActor, MarkerActorClass) == 0x000000, "Member 'FGzServerMarkerBuildDataActor::MarkerActorClass' has a wrong offset!");
static_assert(offsetof(FGzServerMarkerBuildDataActor, TargetActor) == 0x000028, "Member 'FGzServerMarkerBuildDataActor::TargetActor' has a wrong offset!");
static_assert(offsetof(FGzServerMarkerBuildDataActor, bNeedsAutoAttachmentOnStreamedIn) == 0x000030, "Member 'FGzServerMarkerBuildDataActor::bNeedsAutoAttachmentOnStreamedIn' has a wrong offset!");
static_assert(offsetof(FGzServerMarkerBuildDataActor, PositionUpdateFrequency) == 0x000034, "Member 'FGzServerMarkerBuildDataActor::PositionUpdateFrequency' has a wrong offset!");
static_assert(offsetof(FGzServerMarkerBuildDataActor, Text) == 0x000038, "Member 'FGzServerMarkerBuildDataActor::Text' has a wrong offset!");
static_assert(offsetof(FGzServerMarkerBuildDataActor, bUseRandomOffset) == 0x000048, "Member 'FGzServerMarkerBuildDataActor::bUseRandomOffset' has a wrong offset!");
static_assert(offsetof(FGzServerMarkerBuildDataActor, RandomOffsetExtent) == 0x00004C, "Member 'FGzServerMarkerBuildDataActor::RandomOffsetExtent' has a wrong offset!");

// ScriptStruct G01.GzResultRedeemPromoCode
// 0x00D0 (0x01B0 - 0x00E0)
struct FGzResultRedeemPromoCode final : public FGzPlayFabResultBase
{
public:
	struct FGzCombinedReward                      GrantedReward;                                     // 0x00E0(0x00D0)(NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzResultRedeemPromoCode) == 0x000008, "Wrong alignment on FGzResultRedeemPromoCode");
static_assert(sizeof(FGzResultRedeemPromoCode) == 0x0001B0, "Wrong size on FGzResultRedeemPromoCode");
static_assert(offsetof(FGzResultRedeemPromoCode, GrantedReward) == 0x0000E0, "Member 'FGzResultRedeemPromoCode::GrantedReward' has a wrong offset!");

// ScriptStruct G01.GzResultListMarket
// 0x0020 (0x0100 - 0x00E0)
struct FGzResultListMarket final : public FGzPlayFabResultBase
{
public:
	struct FGzMarketplaceListedMarketPagingInfo   Paging;                                            // 0x00E0(0x000C)(NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_2BE8[0x4];                                     // 0x00EC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FGzResultMarketplaceListedItem> Data;                                              // 0x00F0(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzResultListMarket) == 0x000008, "Wrong alignment on FGzResultListMarket");
static_assert(sizeof(FGzResultListMarket) == 0x000100, "Wrong size on FGzResultListMarket");
static_assert(offsetof(FGzResultListMarket, Paging) == 0x0000E0, "Member 'FGzResultListMarket::Paging' has a wrong offset!");
static_assert(offsetof(FGzResultListMarket, Data) == 0x0000F0, "Member 'FGzResultListMarket::Data' has a wrong offset!");

// ScriptStruct G01.GzResultGetCheapestMarketLot
// 0x00A8 (0x0188 - 0x00E0)
struct FGzResultGetCheapestMarketLot final : public FGzPlayFabResultBase
{
public:
	struct FGzResultMarketplaceListedItem         Item;                                              // 0x00E0(0x00A0)(NativeAccessSpecifierPublic)
	bool                                          Found;                                             // 0x0180(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2BE9[0x7];                                     // 0x0181(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGzResultGetCheapestMarketLot) == 0x000008, "Wrong alignment on FGzResultGetCheapestMarketLot");
static_assert(sizeof(FGzResultGetCheapestMarketLot) == 0x000188, "Wrong size on FGzResultGetCheapestMarketLot");
static_assert(offsetof(FGzResultGetCheapestMarketLot, Item) == 0x0000E0, "Member 'FGzResultGetCheapestMarketLot::Item' has a wrong offset!");
static_assert(offsetof(FGzResultGetCheapestMarketLot, Found) == 0x000180, "Member 'FGzResultGetCheapestMarketLot::Found' has a wrong offset!");

// ScriptStruct G01.GzResultBuyMarketLot
// 0x0000 (0x00E0 - 0x00E0)
struct FGzResultBuyMarketLot final : public FGzPlayFabResultBase
{
};
static_assert(alignof(FGzResultBuyMarketLot) == 0x000008, "Wrong alignment on FGzResultBuyMarketLot");
static_assert(sizeof(FGzResultBuyMarketLot) == 0x0000E0, "Wrong size on FGzResultBuyMarketLot");

// ScriptStruct G01.GzResultCreateMarketLot
// 0x00A0 (0x0180 - 0x00E0)
struct FGzResultCreateMarketLot final : public FGzPlayFabResultBase
{
public:
	struct FGzBackendOnlineInventoryItemDisplayProperties Dp;                                                // 0x00E0(0x00A0)(NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzResultCreateMarketLot) == 0x000008, "Wrong alignment on FGzResultCreateMarketLot");
static_assert(sizeof(FGzResultCreateMarketLot) == 0x000180, "Wrong size on FGzResultCreateMarketLot");
static_assert(offsetof(FGzResultCreateMarketLot, Dp) == 0x0000E0, "Member 'FGzResultCreateMarketLot::Dp' has a wrong offset!");

// ScriptStruct G01.GzResultGetTradeHistory
// 0x0010 (0x00F0 - 0x00E0)
struct FGzResultGetTradeHistory final : public FGzPlayFabResultBase
{
public:
	TArray<struct FGzResultMarketTrade>           Trades;                                            // 0x00E0(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzResultGetTradeHistory) == 0x000008, "Wrong alignment on FGzResultGetTradeHistory");
static_assert(sizeof(FGzResultGetTradeHistory) == 0x0000F0, "Wrong size on FGzResultGetTradeHistory");
static_assert(offsetof(FGzResultGetTradeHistory, Trades) == 0x0000E0, "Member 'FGzResultGetTradeHistory::Trades' has a wrong offset!");

// ScriptStruct G01.GzResultGetTransactionHistory
// 0x0020 (0x0100 - 0x00E0)
struct FGzResultGetTransactionHistory final : public FGzPlayFabResultBase
{
public:
	class FString                                 NotificationsJson;                                 // 0x00E0(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 ContinuationToken;                                 // 0x00F0(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzResultGetTransactionHistory) == 0x000008, "Wrong alignment on FGzResultGetTransactionHistory");
static_assert(sizeof(FGzResultGetTransactionHistory) == 0x000100, "Wrong size on FGzResultGetTransactionHistory");
static_assert(offsetof(FGzResultGetTransactionHistory, NotificationsJson) == 0x0000E0, "Member 'FGzResultGetTransactionHistory::NotificationsJson' has a wrong offset!");
static_assert(offsetof(FGzResultGetTransactionHistory, ContinuationToken) == 0x0000F0, "Member 'FGzResultGetTransactionHistory::ContinuationToken' has a wrong offset!");

// ScriptStruct G01.GzResultGetMarketplaceItemTrends
// 0x0010 (0x00F0 - 0x00E0)
struct FGzResultGetMarketplaceItemTrends final : public FGzPlayFabResultBase
{
public:
	TArray<struct FGzResultMarketplaceItemSale>   PriceTrends;                                       // 0x00E0(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzResultGetMarketplaceItemTrends) == 0x000008, "Wrong alignment on FGzResultGetMarketplaceItemTrends");
static_assert(sizeof(FGzResultGetMarketplaceItemTrends) == 0x0000F0, "Wrong size on FGzResultGetMarketplaceItemTrends");
static_assert(offsetof(FGzResultGetMarketplaceItemTrends, PriceTrends) == 0x0000E0, "Member 'FGzResultGetMarketplaceItemTrends::PriceTrends' has a wrong offset!");

// ScriptStruct G01.GzMatchmakingRegionData
// 0x0010 (0x0010 - 0x0000)
struct FGzMatchmakingRegionData final
{
public:
	class FText                                   DisplayName;                                       // 0x0000(0x0010)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzMatchmakingRegionData) == 0x000008, "Wrong alignment on FGzMatchmakingRegionData");
static_assert(sizeof(FGzMatchmakingRegionData) == 0x000010, "Wrong size on FGzMatchmakingRegionData");
static_assert(offsetof(FGzMatchmakingRegionData, DisplayName) == 0x000000, "Member 'FGzMatchmakingRegionData::DisplayName' has a wrong offset!");

// ScriptStruct G01.GzRewardEntry
// 0x0010 (0x0010 - 0x0000)
struct FGzRewardEntry final
{
public:
	class UGzRewardData*                          Reward;                                            // 0x0000(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAlreadyGranted;                                   // 0x0008(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2BEA[0x7];                                     // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGzRewardEntry) == 0x000008, "Wrong alignment on FGzRewardEntry");
static_assert(sizeof(FGzRewardEntry) == 0x000010, "Wrong size on FGzRewardEntry");
static_assert(offsetof(FGzRewardEntry, Reward) == 0x000000, "Member 'FGzRewardEntry::Reward' has a wrong offset!");
static_assert(offsetof(FGzRewardEntry, bAlreadyGranted) == 0x000008, "Member 'FGzRewardEntry::bAlreadyGranted' has a wrong offset!");

// ScriptStruct G01.GzMatchResult
// 0x0090 (0x0090 - 0x0000)
struct FGzMatchResult final
{
public:
	class FString                                 MatchID;                                           // 0x0000(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         TeamRank;                                          // 0x0010(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         TotalTeamCount;                                    // 0x0014(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FGzXpEntry>                     Xp;                                                // 0x0018(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FGzCurrencyEntry>               Currency;                                          // 0x0028(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FGzItemEntry>                   Items;                                             // 0x0038(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FGzTeamMemberResult>            TeamResult;                                        // 0x0048(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FGzMissionProgressEntry>        Missions;                                          // 0x0058(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class UGzContainerItemData*>           ExtractedDataCubes;                                // 0x0068(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FGzRewardEntry>                 Rewards;                                           // 0x0078(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, RepSkip, NativeAccessSpecifierPublic)
	bool                                          bEarlyLeave;                                       // 0x0088(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2BEB[0x7];                                     // 0x0089(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGzMatchResult) == 0x000008, "Wrong alignment on FGzMatchResult");
static_assert(sizeof(FGzMatchResult) == 0x000090, "Wrong size on FGzMatchResult");
static_assert(offsetof(FGzMatchResult, MatchID) == 0x000000, "Member 'FGzMatchResult::MatchID' has a wrong offset!");
static_assert(offsetof(FGzMatchResult, TeamRank) == 0x000010, "Member 'FGzMatchResult::TeamRank' has a wrong offset!");
static_assert(offsetof(FGzMatchResult, TotalTeamCount) == 0x000014, "Member 'FGzMatchResult::TotalTeamCount' has a wrong offset!");
static_assert(offsetof(FGzMatchResult, Xp) == 0x000018, "Member 'FGzMatchResult::Xp' has a wrong offset!");
static_assert(offsetof(FGzMatchResult, Currency) == 0x000028, "Member 'FGzMatchResult::Currency' has a wrong offset!");
static_assert(offsetof(FGzMatchResult, Items) == 0x000038, "Member 'FGzMatchResult::Items' has a wrong offset!");
static_assert(offsetof(FGzMatchResult, TeamResult) == 0x000048, "Member 'FGzMatchResult::TeamResult' has a wrong offset!");
static_assert(offsetof(FGzMatchResult, Missions) == 0x000058, "Member 'FGzMatchResult::Missions' has a wrong offset!");
static_assert(offsetof(FGzMatchResult, ExtractedDataCubes) == 0x000068, "Member 'FGzMatchResult::ExtractedDataCubes' has a wrong offset!");
static_assert(offsetof(FGzMatchResult, Rewards) == 0x000078, "Member 'FGzMatchResult::Rewards' has a wrong offset!");
static_assert(offsetof(FGzMatchResult, bEarlyLeave) == 0x000088, "Member 'FGzMatchResult::bEarlyLeave' has a wrong offset!");

// ScriptStruct G01.GzStageAudioAnnouncementSettings
// 0x0018 (0x0018 - 0x0000)
struct FGzStageAudioAnnouncementSettings final
{
public:
	struct FGzPingVoiceLineData                   VoiceLineData;                                     // 0x0000(0x0010)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	float                                         MinStageDurationToTrigger;                         // 0x0010(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2BEC[0x4];                                     // 0x0014(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGzStageAudioAnnouncementSettings) == 0x000008, "Wrong alignment on FGzStageAudioAnnouncementSettings");
static_assert(sizeof(FGzStageAudioAnnouncementSettings) == 0x000018, "Wrong size on FGzStageAudioAnnouncementSettings");
static_assert(offsetof(FGzStageAudioAnnouncementSettings, VoiceLineData) == 0x000000, "Member 'FGzStageAudioAnnouncementSettings::VoiceLineData' has a wrong offset!");
static_assert(offsetof(FGzStageAudioAnnouncementSettings, MinStageDurationToTrigger) == 0x000010, "Member 'FGzStageAudioAnnouncementSettings::MinStageDurationToTrigger' has a wrong offset!");

// ScriptStruct G01.GzMeshContainer
// 0x0010 (0x0010 - 0x0000)
struct FGzMeshContainer final
{
public:
	TArray<struct FGzMeshData>                    MeshDatas;                                         // 0x0000(0x0010)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
};
static_assert(alignof(FGzMeshContainer) == 0x000008, "Wrong alignment on FGzMeshContainer");
static_assert(sizeof(FGzMeshContainer) == 0x000010, "Wrong size on FGzMeshContainer");
static_assert(offsetof(FGzMeshContainer, MeshDatas) == 0x000000, "Member 'FGzMeshContainer::MeshDatas' has a wrong offset!");

// ScriptStruct G01.GzMetaAchievementState
// 0x0010 (0x0010 - 0x0000)
struct FGzMetaAchievementState final
{
public:
	class UGzAchievementTemplate*                 AchievementTemplate;                               // 0x0000(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Progress;                                          // 0x0008(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int8                                          StageIndex;                                        // 0x000C(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2BED[0x3];                                     // 0x000D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGzMetaAchievementState) == 0x000008, "Wrong alignment on FGzMetaAchievementState");
static_assert(sizeof(FGzMetaAchievementState) == 0x000010, "Wrong size on FGzMetaAchievementState");
static_assert(offsetof(FGzMetaAchievementState, AchievementTemplate) == 0x000000, "Member 'FGzMetaAchievementState::AchievementTemplate' has a wrong offset!");
static_assert(offsetof(FGzMetaAchievementState, Progress) == 0x000008, "Member 'FGzMetaAchievementState::Progress' has a wrong offset!");
static_assert(offsetof(FGzMetaAchievementState, StageIndex) == 0x00000C, "Member 'FGzMetaAchievementState::StageIndex' has a wrong offset!");

// ScriptStruct G01.GzMetaPlayerAchievements
// 0x0010 (0x0010 - 0x0000)
struct FGzMetaPlayerAchievements final
{
public:
	TArray<struct FGzMetaAchievementState>        Achievements;                                      // 0x0000(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzMetaPlayerAchievements) == 0x000008, "Wrong alignment on FGzMetaPlayerAchievements");
static_assert(sizeof(FGzMetaPlayerAchievements) == 0x000010, "Wrong size on FGzMetaPlayerAchievements");
static_assert(offsetof(FGzMetaPlayerAchievements, Achievements) == 0x000000, "Member 'FGzMetaPlayerAchievements::Achievements' has a wrong offset!");

// ScriptStruct G01.GzMetaEvent
// 0x0008 (0x0008 - 0x0000)
struct alignas(0x04) FGzMetaEvent final
{
public:
	EGzEventType                                  MetaEventType;                                     // 0x0000(0x0002)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2BEE[0x6];                                     // 0x0002(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGzMetaEvent) == 0x000004, "Wrong alignment on FGzMetaEvent");
static_assert(sizeof(FGzMetaEvent) == 0x000008, "Wrong size on FGzMetaEvent");
static_assert(offsetof(FGzMetaEvent, MetaEventType) == 0x000000, "Member 'FGzMetaEvent::MetaEventType' has a wrong offset!");

// ScriptStruct G01.GzMetaEventDeserializer
// 0x0050 (0x0050 - 0x0000)
struct alignas(0x08) FGzMetaEventDeserializer final
{
public:
	uint8                                         Pad_2BEF[0x50];                                    // 0x0000(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGzMetaEventDeserializer) == 0x000008, "Wrong alignment on FGzMetaEventDeserializer");
static_assert(sizeof(FGzMetaEventDeserializer) == 0x000050, "Wrong size on FGzMetaEventDeserializer");

// ScriptStruct G01.GzMetaMarketplaceItemSale
// 0x0020 (0x0020 - 0x0000)
struct FGzMetaMarketplaceItemSale final
{
public:
	class FString                                 Price;                                             // 0x0000(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Date;                                              // 0x0010(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzMetaMarketplaceItemSale) == 0x000008, "Wrong alignment on FGzMetaMarketplaceItemSale");
static_assert(sizeof(FGzMetaMarketplaceItemSale) == 0x000020, "Wrong size on FGzMetaMarketplaceItemSale");
static_assert(offsetof(FGzMetaMarketplaceItemSale, Price) == 0x000000, "Member 'FGzMetaMarketplaceItemSale::Price' has a wrong offset!");
static_assert(offsetof(FGzMetaMarketplaceItemSale, Date) == 0x000010, "Member 'FGzMetaMarketplaceItemSale::Date' has a wrong offset!");

// ScriptStruct G01.GzMetaListMarketFilterParameters
// 0x0070 (0x0070 - 0x0000)
struct FGzMetaListMarketFilterParameters final
{
public:
	TArray<EGzItemRarity>                         QualityFilters;                                    // 0x0000(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<EGzItemType>                           TypeFilters;                                       // 0x0010(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	class FString                                 Name;                                              // 0x0020(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class FString>                         AssetIds;                                          // 0x0030(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	struct FGzMetaPriceRange                      PriceRange;                                        // 0x0040(0x0010)(NoDestructor, NativeAccessSpecifierPublic)
	struct FGzPlayFabPlayerIdContainer            Seller;                                            // 0x0050(0x0020)(NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzMetaListMarketFilterParameters) == 0x000008, "Wrong alignment on FGzMetaListMarketFilterParameters");
static_assert(sizeof(FGzMetaListMarketFilterParameters) == 0x000070, "Wrong size on FGzMetaListMarketFilterParameters");
static_assert(offsetof(FGzMetaListMarketFilterParameters, QualityFilters) == 0x000000, "Member 'FGzMetaListMarketFilterParameters::QualityFilters' has a wrong offset!");
static_assert(offsetof(FGzMetaListMarketFilterParameters, TypeFilters) == 0x000010, "Member 'FGzMetaListMarketFilterParameters::TypeFilters' has a wrong offset!");
static_assert(offsetof(FGzMetaListMarketFilterParameters, Name) == 0x000020, "Member 'FGzMetaListMarketFilterParameters::Name' has a wrong offset!");
static_assert(offsetof(FGzMetaListMarketFilterParameters, AssetIds) == 0x000030, "Member 'FGzMetaListMarketFilterParameters::AssetIds' has a wrong offset!");
static_assert(offsetof(FGzMetaListMarketFilterParameters, PriceRange) == 0x000040, "Member 'FGzMetaListMarketFilterParameters::PriceRange' has a wrong offset!");
static_assert(offsetof(FGzMetaListMarketFilterParameters, Seller) == 0x000050, "Member 'FGzMetaListMarketFilterParameters::Seller' has a wrong offset!");

// ScriptStruct G01.GzMetaListMarketFilters
// 0x0080 (0x0080 - 0x0000)
struct FGzMetaListMarketFilters final
{
public:
	struct FGzMetaListMarketPagingParameters      PagingParameters;                                  // 0x0000(0x0008)(NoDestructor, NativeAccessSpecifierPublic)
	struct FGzMetaListMarketFilterParameters      FilterParameters;                                  // 0x0008(0x0070)(NativeAccessSpecifierPublic)
	struct FGzMetaListMarketOrderParameters       OrderParameters;                                   // 0x0078(0x0002)(NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_2BF0[0x6];                                     // 0x007A(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGzMetaListMarketFilters) == 0x000008, "Wrong alignment on FGzMetaListMarketFilters");
static_assert(sizeof(FGzMetaListMarketFilters) == 0x000080, "Wrong size on FGzMetaListMarketFilters");
static_assert(offsetof(FGzMetaListMarketFilters, PagingParameters) == 0x000000, "Member 'FGzMetaListMarketFilters::PagingParameters' has a wrong offset!");
static_assert(offsetof(FGzMetaListMarketFilters, FilterParameters) == 0x000008, "Member 'FGzMetaListMarketFilters::FilterParameters' has a wrong offset!");
static_assert(offsetof(FGzMetaListMarketFilters, OrderParameters) == 0x000078, "Member 'FGzMetaListMarketFilters::OrderParameters' has a wrong offset!");

// ScriptStruct G01.GzMetaListedMarket
// 0x0020 (0x0020 - 0x0000)
struct FGzMetaListedMarket final
{
public:
	struct FGzMetaMarketplacePagingInfo           PagingInfo;                                        // 0x0000(0x000C)(NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_2BF1[0x4];                                     // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FGzMetaMarketplaceItem>         Items;                                             // 0x0010(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzMetaListedMarket) == 0x000008, "Wrong alignment on FGzMetaListedMarket");
static_assert(sizeof(FGzMetaListedMarket) == 0x000020, "Wrong size on FGzMetaListedMarket");
static_assert(offsetof(FGzMetaListedMarket, PagingInfo) == 0x000000, "Member 'FGzMetaListedMarket::PagingInfo' has a wrong offset!");
static_assert(offsetof(FGzMetaListedMarket, Items) == 0x000010, "Member 'FGzMetaListedMarket::Items' has a wrong offset!");

// ScriptStruct G01.GzMetaNews
// 0x0060 (0x0060 - 0x0000)
struct FGzMetaNews final
{
public:
	class FString                                 ID;                                                // 0x0000(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Lang;                                              // 0x0010(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EGzNewsType                                   Type;                                              // 0x0020(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2BF2[0x7];                                     // 0x0021(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 Title;                                             // 0x0028(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Subtitle;                                          // 0x0038(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FDateTime                              Time;                                              // 0x0048(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Body;                                              // 0x0050(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzMetaNews) == 0x000008, "Wrong alignment on FGzMetaNews");
static_assert(sizeof(FGzMetaNews) == 0x000060, "Wrong size on FGzMetaNews");
static_assert(offsetof(FGzMetaNews, ID) == 0x000000, "Member 'FGzMetaNews::ID' has a wrong offset!");
static_assert(offsetof(FGzMetaNews, Lang) == 0x000010, "Member 'FGzMetaNews::Lang' has a wrong offset!");
static_assert(offsetof(FGzMetaNews, Type) == 0x000020, "Member 'FGzMetaNews::Type' has a wrong offset!");
static_assert(offsetof(FGzMetaNews, Title) == 0x000028, "Member 'FGzMetaNews::Title' has a wrong offset!");
static_assert(offsetof(FGzMetaNews, Subtitle) == 0x000038, "Member 'FGzMetaNews::Subtitle' has a wrong offset!");
static_assert(offsetof(FGzMetaNews, Time) == 0x000048, "Member 'FGzMetaNews::Time' has a wrong offset!");
static_assert(offsetof(FGzMetaNews, Body) == 0x000050, "Member 'FGzMetaNews::Body' has a wrong offset!");

// ScriptStruct G01.GzMetaNewsList
// 0x0050 (0x0050 - 0x0000)
struct FGzMetaNewsList final
{
public:
	TMap<class FString, struct FGzMetaNews>       List;                                              // 0x0000(0x0050)(NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzMetaNewsList) == 0x000008, "Wrong alignment on FGzMetaNewsList");
static_assert(sizeof(FGzMetaNewsList) == 0x000050, "Wrong size on FGzMetaNewsList");
static_assert(offsetof(FGzMetaNewsList, List) == 0x000000, "Member 'FGzMetaNewsList::List' has a wrong offset!");

// ScriptStruct G01.GzMetaSavedAchievementProgress
// 0x000C (0x000C - 0x0000)
struct FGzMetaSavedAchievementProgress final
{
public:
	float                                         ProgressValue;                                     // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   AchievementAssetId;                                // 0x0004(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzMetaSavedAchievementProgress) == 0x000004, "Wrong alignment on FGzMetaSavedAchievementProgress");
static_assert(sizeof(FGzMetaSavedAchievementProgress) == 0x00000C, "Wrong size on FGzMetaSavedAchievementProgress");
static_assert(offsetof(FGzMetaSavedAchievementProgress, ProgressValue) == 0x000000, "Member 'FGzMetaSavedAchievementProgress::ProgressValue' has a wrong offset!");
static_assert(offsetof(FGzMetaSavedAchievementProgress, AchievementAssetId) == 0x000004, "Member 'FGzMetaSavedAchievementProgress::AchievementAssetId' has a wrong offset!");

// ScriptStruct G01.GzMetaSavedAchievementsProgressCollection
// 0x0010 (0x0010 - 0x0000)
struct FGzMetaSavedAchievementsProgressCollection final
{
public:
	TArray<struct FGzMetaSavedAchievementProgress> SavedAchievements;                                 // 0x0000(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzMetaSavedAchievementsProgressCollection) == 0x000008, "Wrong alignment on FGzMetaSavedAchievementsProgressCollection");
static_assert(sizeof(FGzMetaSavedAchievementsProgressCollection) == 0x000010, "Wrong size on FGzMetaSavedAchievementsProgressCollection");
static_assert(offsetof(FGzMetaSavedAchievementsProgressCollection, SavedAchievements) == 0x000000, "Member 'FGzMetaSavedAchievementsProgressCollection::SavedAchievements' has a wrong offset!");

// ScriptStruct G01.GzMinigunPerArmReplicatedData
// 0x0018 (0x0018 - 0x0000)
struct FGzMinigunPerArmReplicatedData final
{
public:
	class FName                                   ShootingSocketName;                                // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   OverheatEffectSocketName;                          // 0x0008(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   ShellEjectEffectSocketName;                        // 0x0010(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzMinigunPerArmReplicatedData) == 0x000004, "Wrong alignment on FGzMinigunPerArmReplicatedData");
static_assert(sizeof(FGzMinigunPerArmReplicatedData) == 0x000018, "Wrong size on FGzMinigunPerArmReplicatedData");
static_assert(offsetof(FGzMinigunPerArmReplicatedData, ShootingSocketName) == 0x000000, "Member 'FGzMinigunPerArmReplicatedData::ShootingSocketName' has a wrong offset!");
static_assert(offsetof(FGzMinigunPerArmReplicatedData, OverheatEffectSocketName) == 0x000008, "Member 'FGzMinigunPerArmReplicatedData::OverheatEffectSocketName' has a wrong offset!");
static_assert(offsetof(FGzMinigunPerArmReplicatedData, ShellEjectEffectSocketName) == 0x000010, "Member 'FGzMinigunPerArmReplicatedData::ShellEjectEffectSocketName' has a wrong offset!");

// ScriptStruct G01.GzMinigunOverheatEffectData
// 0x0048 (0x0048 - 0x0000)
struct FGzMinigunOverheatEffectData final
{
public:
	float                                         NiagaraSpawnThreshold;                             // 0x0000(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2BF3[0x4];                                     // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftObjectPtr<class UNiagaraSystem>          NiagaraSystemSoftRef;                              // 0x0008(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   NiagaraOverheatPercentageParameterName;            // 0x0030(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   MaterialSlotName;                                  // 0x0038(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   MaterialOverheatPercentageParameterName;           // 0x0040(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzMinigunOverheatEffectData) == 0x000008, "Wrong alignment on FGzMinigunOverheatEffectData");
static_assert(sizeof(FGzMinigunOverheatEffectData) == 0x000048, "Wrong size on FGzMinigunOverheatEffectData");
static_assert(offsetof(FGzMinigunOverheatEffectData, NiagaraSpawnThreshold) == 0x000000, "Member 'FGzMinigunOverheatEffectData::NiagaraSpawnThreshold' has a wrong offset!");
static_assert(offsetof(FGzMinigunOverheatEffectData, NiagaraSystemSoftRef) == 0x000008, "Member 'FGzMinigunOverheatEffectData::NiagaraSystemSoftRef' has a wrong offset!");
static_assert(offsetof(FGzMinigunOverheatEffectData, NiagaraOverheatPercentageParameterName) == 0x000030, "Member 'FGzMinigunOverheatEffectData::NiagaraOverheatPercentageParameterName' has a wrong offset!");
static_assert(offsetof(FGzMinigunOverheatEffectData, MaterialSlotName) == 0x000038, "Member 'FGzMinigunOverheatEffectData::MaterialSlotName' has a wrong offset!");
static_assert(offsetof(FGzMinigunOverheatEffectData, MaterialOverheatPercentageParameterName) == 0x000040, "Member 'FGzMinigunOverheatEffectData::MaterialOverheatPercentageParameterName' has a wrong offset!");

// ScriptStruct G01.GzMissionMarkerSettings
// 0x0048 (0x0048 - 0x0000)
struct FGzMissionMarkerSettings final
{
public:
	TSoftObjectPtr<class AActor>                  AttachActor;                                       // 0x0000(0x0028)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAttached;                                         // 0x0028(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2BF4[0x7];                                     // 0x0029(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                AttachLocation;                                    // 0x0030(0x0018)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzMissionMarkerSettings) == 0x000008, "Wrong alignment on FGzMissionMarkerSettings");
static_assert(sizeof(FGzMissionMarkerSettings) == 0x000048, "Wrong size on FGzMissionMarkerSettings");
static_assert(offsetof(FGzMissionMarkerSettings, AttachActor) == 0x000000, "Member 'FGzMissionMarkerSettings::AttachActor' has a wrong offset!");
static_assert(offsetof(FGzMissionMarkerSettings, bAttached) == 0x000028, "Member 'FGzMissionMarkerSettings::bAttached' has a wrong offset!");
static_assert(offsetof(FGzMissionMarkerSettings, AttachLocation) == 0x000030, "Member 'FGzMissionMarkerSettings::AttachLocation' has a wrong offset!");

// ScriptStruct G01.GzMissionGroup
// 0x0020 (0x0020 - 0x0000)
struct FGzMissionGroup final
{
public:
	int32                                         GroupID;                                           // 0x0000(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         OwnerId;                                           // 0x0004(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EGzMissionGroupType                           GroupType;                                         // 0x0008(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2BF5[0x7];                                     // 0x0009(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<int32>                                 Players;                                           // 0x0010(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzMissionGroup) == 0x000008, "Wrong alignment on FGzMissionGroup");
static_assert(sizeof(FGzMissionGroup) == 0x000020, "Wrong size on FGzMissionGroup");
static_assert(offsetof(FGzMissionGroup, GroupID) == 0x000000, "Member 'FGzMissionGroup::GroupID' has a wrong offset!");
static_assert(offsetof(FGzMissionGroup, OwnerId) == 0x000004, "Member 'FGzMissionGroup::OwnerId' has a wrong offset!");
static_assert(offsetof(FGzMissionGroup, GroupType) == 0x000008, "Member 'FGzMissionGroup::GroupType' has a wrong offset!");
static_assert(offsetof(FGzMissionGroup, Players) == 0x000010, "Member 'FGzMissionGroup::Players' has a wrong offset!");

// ScriptStruct G01.GzCharacterInventorySubscription
// 0x0018 (0x0018 - 0x0000)
struct FGzCharacterInventorySubscription final
{
public:
	class AGzPlayerCharacter*                     Character;                                         // 0x0000(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGzItemChangeHandle                    Handle;                                            // 0x0008(0x000C)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2BF6[0x4];                                     // 0x0014(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGzCharacterInventorySubscription) == 0x000008, "Wrong alignment on FGzCharacterInventorySubscription");
static_assert(sizeof(FGzCharacterInventorySubscription) == 0x000018, "Wrong size on FGzCharacterInventorySubscription");
static_assert(offsetof(FGzCharacterInventorySubscription, Character) == 0x000000, "Member 'FGzCharacterInventorySubscription::Character' has a wrong offset!");
static_assert(offsetof(FGzCharacterInventorySubscription, Handle) == 0x000008, "Member 'FGzCharacterInventorySubscription::Handle' has a wrong offset!");

// ScriptStruct G01.GzMissionStarterSpawnParamArray
// 0x0010 (0x0010 - 0x0000)
struct FGzMissionStarterSpawnParamArray final
{
public:
	TArray<struct FGzMissionStarterPerStageSpawnParams> PerStageSpawnParams;                               // 0x0000(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzMissionStarterSpawnParamArray) == 0x000008, "Wrong alignment on FGzMissionStarterSpawnParamArray");
static_assert(sizeof(FGzMissionStarterSpawnParamArray) == 0x000010, "Wrong size on FGzMissionStarterSpawnParamArray");
static_assert(offsetof(FGzMissionStarterSpawnParamArray, PerStageSpawnParams) == 0x000000, "Member 'FGzMissionStarterSpawnParamArray::PerStageSpawnParams' has a wrong offset!");

// ScriptStruct G01.GzMissionDataWeightParams
// 0x0010 (0x0010 - 0x0000)
struct FGzMissionDataWeightParams final
{
public:
	class UGzMissionData*                         MissionData;                                       // 0x0000(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Weight;                                            // 0x0008(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2BF7[0x4];                                     // 0x000C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGzMissionDataWeightParams) == 0x000008, "Wrong alignment on FGzMissionDataWeightParams");
static_assert(sizeof(FGzMissionDataWeightParams) == 0x000010, "Wrong size on FGzMissionDataWeightParams");
static_assert(offsetof(FGzMissionDataWeightParams, MissionData) == 0x000000, "Member 'FGzMissionDataWeightParams::MissionData' has a wrong offset!");
static_assert(offsetof(FGzMissionDataWeightParams, Weight) == 0x000008, "Member 'FGzMissionDataWeightParams::Weight' has a wrong offset!");

// ScriptStruct G01.GzModularEnvObjectVisualVariations
// 0x0010 (0x0010 - 0x0000)
struct FGzModularEnvObjectVisualVariations final
{
public:
	TArray<TSoftObjectPtr<class UStaticMesh>>     Meshes;                                            // 0x0000(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, UObjectWrapper, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzModularEnvObjectVisualVariations) == 0x000008, "Wrong alignment on FGzModularEnvObjectVisualVariations");
static_assert(sizeof(FGzModularEnvObjectVisualVariations) == 0x000010, "Wrong size on FGzModularEnvObjectVisualVariations");
static_assert(offsetof(FGzModularEnvObjectVisualVariations, Meshes) == 0x000000, "Member 'FGzModularEnvObjectVisualVariations::Meshes' has a wrong offset!");

// ScriptStruct G01.GzZoomLevelSettings
// 0x0008 (0x0008 - 0x0000)
struct FGzZoomLevelSettings final
{
public:
	float                                         TargetZoom;                                        // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ZoomInterpolationSpeed;                            // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
};
static_assert(alignof(FGzZoomLevelSettings) == 0x000004, "Wrong alignment on FGzZoomLevelSettings");
static_assert(sizeof(FGzZoomLevelSettings) == 0x000008, "Wrong size on FGzZoomLevelSettings");
static_assert(offsetof(FGzZoomLevelSettings, TargetZoom) == 0x000000, "Member 'FGzZoomLevelSettings::TargetZoom' has a wrong offset!");
static_assert(offsetof(FGzZoomLevelSettings, ZoomInterpolationSpeed) == 0x000004, "Member 'FGzZoomLevelSettings::ZoomInterpolationSpeed' has a wrong offset!");

// ScriptStruct G01.GzNavigationLayerKey
// 0x0008 (0x0008 - 0x0000)
struct FGzNavigationLayerKey final
{
public:
	class FName                                   Key;                                               // 0x0000(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzNavigationLayerKey) == 0x000004, "Wrong alignment on FGzNavigationLayerKey");
static_assert(sizeof(FGzNavigationLayerKey) == 0x000008, "Wrong size on FGzNavigationLayerKey");
static_assert(offsetof(FGzNavigationLayerKey, Key) == 0x000000, "Member 'FGzNavigationLayerKey::Key' has a wrong offset!");

// ScriptStruct G01.GzNavLinkSpawnConfig
// 0x0020 (0x0020 - 0x0000)
struct FGzNavLinkSpawnConfig final
{
public:
	TArray<struct FGzNavLinkTraceConfig>          TraceConfigs;                                      // 0x0000(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	float                                         MinHeightDifference;                               // 0x0010(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CapsuleCheckRadius;                                // 0x0014(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CapsuleCheckHalfHeight;                            // 0x0018(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxPlayerSteepAngle;                               // 0x001C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzNavLinkSpawnConfig) == 0x000008, "Wrong alignment on FGzNavLinkSpawnConfig");
static_assert(sizeof(FGzNavLinkSpawnConfig) == 0x000020, "Wrong size on FGzNavLinkSpawnConfig");
static_assert(offsetof(FGzNavLinkSpawnConfig, TraceConfigs) == 0x000000, "Member 'FGzNavLinkSpawnConfig::TraceConfigs' has a wrong offset!");
static_assert(offsetof(FGzNavLinkSpawnConfig, MinHeightDifference) == 0x000010, "Member 'FGzNavLinkSpawnConfig::MinHeightDifference' has a wrong offset!");
static_assert(offsetof(FGzNavLinkSpawnConfig, CapsuleCheckRadius) == 0x000014, "Member 'FGzNavLinkSpawnConfig::CapsuleCheckRadius' has a wrong offset!");
static_assert(offsetof(FGzNavLinkSpawnConfig, CapsuleCheckHalfHeight) == 0x000018, "Member 'FGzNavLinkSpawnConfig::CapsuleCheckHalfHeight' has a wrong offset!");
static_assert(offsetof(FGzNavLinkSpawnConfig, MaxPlayerSteepAngle) == 0x00001C, "Member 'FGzNavLinkSpawnConfig::MaxPlayerSteepAngle' has a wrong offset!");

// ScriptStruct G01.GzNotificationSettings
// 0x0008 (0x0008 - 0x0000)
struct FGzNotificationSettings final
{
public:
	bool                                          bShowMissionCreateFailNotification;                // 0x0000(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEnablePrematchKillNotification;                   // 0x0001(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2BF8[0x2];                                     // 0x0002(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         PrematchKillNotificationDuration;                  // 0x0004(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzNotificationSettings) == 0x000004, "Wrong alignment on FGzNotificationSettings");
static_assert(sizeof(FGzNotificationSettings) == 0x000008, "Wrong size on FGzNotificationSettings");
static_assert(offsetof(FGzNotificationSettings, bShowMissionCreateFailNotification) == 0x000000, "Member 'FGzNotificationSettings::bShowMissionCreateFailNotification' has a wrong offset!");
static_assert(offsetof(FGzNotificationSettings, bEnablePrematchKillNotification) == 0x000001, "Member 'FGzNotificationSettings::bEnablePrematchKillNotification' has a wrong offset!");
static_assert(offsetof(FGzNotificationSettings, PrematchKillNotificationDuration) == 0x000004, "Member 'FGzNotificationSettings::PrematchKillNotificationDuration' has a wrong offset!");

// ScriptStruct G01.GzStateParameter
// 0x0000 (0x0000 - 0x0000)
#pragma pack(push, 0x1)
struct alignas(0x01) FGzStateParameter
{
};
#pragma pack(pop)
static_assert(alignof(FGzStateParameter) == 0x000001, "Wrong alignment on FGzStateParameter");
static_assert(sizeof(FGzStateParameter) == 0x000001, "Wrong size on FGzStateParameter");

// ScriptStruct G01.GzOfflineTravelStateParameter
// 0x0001 (0x0001 - 0x0000)
struct FGzOfflineTravelStateParameter final : public FGzStateParameter
{
public:
	EGzFlowState                                  NextState;                                         // 0x0000(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzOfflineTravelStateParameter) == 0x000001, "Wrong alignment on FGzOfflineTravelStateParameter");
static_assert(sizeof(FGzOfflineTravelStateParameter) == 0x000001, "Wrong size on FGzOfflineTravelStateParameter");
static_assert(offsetof(FGzOfflineTravelStateParameter, NextState) == 0x000000, "Member 'FGzOfflineTravelStateParameter::NextState' has a wrong offset!");

// ScriptStruct G01.GzOnlineInventoryItemsCollection
// 0x0068 (0x0068 - 0x0000)
struct FGzOnlineInventoryItemsCollection final
{
public:
	uint8                                         Pad_2BF9[0x18];                                    // 0x0000(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<class FName, class UGzOnlineInventoryItem*> Items;                                             // 0x0018(0x0050)(Transient, NativeAccessSpecifierPrivate)
};
static_assert(alignof(FGzOnlineInventoryItemsCollection) == 0x000008, "Wrong alignment on FGzOnlineInventoryItemsCollection");
static_assert(sizeof(FGzOnlineInventoryItemsCollection) == 0x000068, "Wrong size on FGzOnlineInventoryItemsCollection");
static_assert(offsetof(FGzOnlineInventoryItemsCollection, Items) == 0x000018, "Member 'FGzOnlineInventoryItemsCollection::Items' has a wrong offset!");

// ScriptStruct G01.GzOnlineMatchRecoveryData
// 0x0028 (0x0028 - 0x0000)
struct FGzOnlineMatchRecoveryData final
{
public:
	class FString                                 ServerIp;                                          // 0x0000(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint32                                        ServerPort;                                        // 0x0010(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2BFA[0x4];                                     // 0x0014(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 MatchStartTime;                                    // 0x0018(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzOnlineMatchRecoveryData) == 0x000008, "Wrong alignment on FGzOnlineMatchRecoveryData");
static_assert(sizeof(FGzOnlineMatchRecoveryData) == 0x000028, "Wrong size on FGzOnlineMatchRecoveryData");
static_assert(offsetof(FGzOnlineMatchRecoveryData, ServerIp) == 0x000000, "Member 'FGzOnlineMatchRecoveryData::ServerIp' has a wrong offset!");
static_assert(offsetof(FGzOnlineMatchRecoveryData, ServerPort) == 0x000010, "Member 'FGzOnlineMatchRecoveryData::ServerPort' has a wrong offset!");
static_assert(offsetof(FGzOnlineMatchRecoveryData, MatchStartTime) == 0x000018, "Member 'FGzOnlineMatchRecoveryData::MatchStartTime' has a wrong offset!");

// ScriptStruct G01.GzOnLoginPackage
// 0x0000 (0x0058 - 0x0058)
struct FGzOnLoginPackage final : public FGzPlayFabPackageBase
{
};
static_assert(alignof(FGzOnLoginPackage) == 0x000008, "Wrong alignment on FGzOnLoginPackage");
static_assert(sizeof(FGzOnLoginPackage) == 0x000058, "Wrong size on FGzOnLoginPackage");

// ScriptStruct G01.GzOverloadStage
// 0x000C (0x000C - 0x0000)
struct FGzOverloadStage final
{
public:
	float                                         WaitPeriod;                                        // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         StageDuration;                                     // 0x0004(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         StageOverloadSpeed;                                // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzOverloadStage) == 0x000004, "Wrong alignment on FGzOverloadStage");
static_assert(sizeof(FGzOverloadStage) == 0x00000C, "Wrong size on FGzOverloadStage");
static_assert(offsetof(FGzOverloadStage, WaitPeriod) == 0x000000, "Member 'FGzOverloadStage::WaitPeriod' has a wrong offset!");
static_assert(offsetof(FGzOverloadStage, StageDuration) == 0x000004, "Member 'FGzOverloadStage::StageDuration' has a wrong offset!");
static_assert(offsetof(FGzOverloadStage, StageOverloadSpeed) == 0x000008, "Member 'FGzOverloadStage::StageOverloadSpeed' has a wrong offset!");

// ScriptStruct G01.GzPackageCheatCompleteAchievementStage
// 0x0018 (0x0080 - 0x0068)
struct FGzPackageCheatCompleteAchievementStage final : public FGzPlayFabClientPackage
{
public:
	class FString                                 AchievementId;                                     // 0x0068(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int8                                          Stage;                                             // 0x0078(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2BFB[0x7];                                     // 0x0079(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGzPackageCheatCompleteAchievementStage) == 0x000008, "Wrong alignment on FGzPackageCheatCompleteAchievementStage");
static_assert(sizeof(FGzPackageCheatCompleteAchievementStage) == 0x000080, "Wrong size on FGzPackageCheatCompleteAchievementStage");
static_assert(offsetof(FGzPackageCheatCompleteAchievementStage, AchievementId) == 0x000068, "Member 'FGzPackageCheatCompleteAchievementStage::AchievementId' has a wrong offset!");
static_assert(offsetof(FGzPackageCheatCompleteAchievementStage, Stage) == 0x000078, "Member 'FGzPackageCheatCompleteAchievementStage::Stage' has a wrong offset!");

// ScriptStruct G01.GzPackageCheatCompleteJob
// 0x0020 (0x0088 - 0x0068)
struct FGzPackageCheatCompleteJob final : public FGzPlayFabClientPackage
{
public:
	class FString                                 CharacterId;                                       // 0x0068(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 CompletedJobId;                                    // 0x0078(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzPackageCheatCompleteJob) == 0x000008, "Wrong alignment on FGzPackageCheatCompleteJob");
static_assert(sizeof(FGzPackageCheatCompleteJob) == 0x000088, "Wrong size on FGzPackageCheatCompleteJob");
static_assert(offsetof(FGzPackageCheatCompleteJob, CharacterId) == 0x000068, "Member 'FGzPackageCheatCompleteJob::CharacterId' has a wrong offset!");
static_assert(offsetof(FGzPackageCheatCompleteJob, CompletedJobId) == 0x000078, "Member 'FGzPackageCheatCompleteJob::CompletedJobId' has a wrong offset!");

// ScriptStruct G01.GzPackageCheatRegenerateChallenges
// 0x0000 (0x0068 - 0x0068)
struct FGzPackageCheatRegenerateChallenges final : public FGzPlayFabClientPackage
{
};
static_assert(alignof(FGzPackageCheatRegenerateChallenges) == 0x000008, "Wrong alignment on FGzPackageCheatRegenerateChallenges");
static_assert(sizeof(FGzPackageCheatRegenerateChallenges) == 0x000068, "Wrong size on FGzPackageCheatRegenerateChallenges");

// ScriptStruct G01.GzPackageCheatResetAllAchievements
// 0x0010 (0x0078 - 0x0068)
struct FGzPackageCheatResetAllAchievements final : public FGzPlayFabClientPackage
{
public:
	TArray<class FString>                         AchievementIds;                                    // 0x0068(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzPackageCheatResetAllAchievements) == 0x000008, "Wrong alignment on FGzPackageCheatResetAllAchievements");
static_assert(sizeof(FGzPackageCheatResetAllAchievements) == 0x000078, "Wrong size on FGzPackageCheatResetAllAchievements");
static_assert(offsetof(FGzPackageCheatResetAllAchievements, AchievementIds) == 0x000068, "Member 'FGzPackageCheatResetAllAchievements::AchievementIds' has a wrong offset!");

// ScriptStruct G01.GzPackageCheatResetAllChallenges
// 0x0010 (0x0078 - 0x0068)
struct FGzPackageCheatResetAllChallenges final : public FGzPlayFabClientPackage
{
public:
	TArray<struct FGzPackageCheatChallengeToReset> ChallengesProgress;                                // 0x0068(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzPackageCheatResetAllChallenges) == 0x000008, "Wrong alignment on FGzPackageCheatResetAllChallenges");
static_assert(sizeof(FGzPackageCheatResetAllChallenges) == 0x000078, "Wrong size on FGzPackageCheatResetAllChallenges");
static_assert(offsetof(FGzPackageCheatResetAllChallenges, ChallengesProgress) == 0x000068, "Member 'FGzPackageCheatResetAllChallenges::ChallengesProgress' has a wrong offset!");

// ScriptStruct G01.GzPackageCheatUpdateAchievementsProgress
// 0x0010 (0x0078 - 0x0068)
struct FGzPackageCheatUpdateAchievementsProgress final : public FGzPlayFabClientPackage
{
public:
	TArray<struct FGzBackendSavedAchievementProgress> AchievementProgresses;                             // 0x0068(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzPackageCheatUpdateAchievementsProgress) == 0x000008, "Wrong alignment on FGzPackageCheatUpdateAchievementsProgress");
static_assert(sizeof(FGzPackageCheatUpdateAchievementsProgress) == 0x000078, "Wrong size on FGzPackageCheatUpdateAchievementsProgress");
static_assert(offsetof(FGzPackageCheatUpdateAchievementsProgress, AchievementProgresses) == 0x000068, "Member 'FGzPackageCheatUpdateAchievementsProgress::AchievementProgresses' has a wrong offset!");

// ScriptStruct G01.GzPackageCollectGameStatistics
// 0x0060 (0x00E8 - 0x0088)
struct FGzPackageCollectGameStatistics final : public FGzPlayFabServerPackage
{
public:
	class FString                                 CharacterId;                                       // 0x0088(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMap<class FString, int32>                    Stats;                                             // 0x0098(0x0050)(NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzPackageCollectGameStatistics) == 0x000008, "Wrong alignment on FGzPackageCollectGameStatistics");
static_assert(sizeof(FGzPackageCollectGameStatistics) == 0x0000E8, "Wrong size on FGzPackageCollectGameStatistics");
static_assert(offsetof(FGzPackageCollectGameStatistics, CharacterId) == 0x000088, "Member 'FGzPackageCollectGameStatistics::CharacterId' has a wrong offset!");
static_assert(offsetof(FGzPackageCollectGameStatistics, Stats) == 0x000098, "Member 'FGzPackageCollectGameStatistics::Stats' has a wrong offset!");

// ScriptStruct G01.GzPackageCollectOtgProButtonClicked
// 0x0000 (0x0068 - 0x0068)
struct FGzPackageCollectOtgProButtonClicked final : public FGzPlayFabClientPackage
{
};
static_assert(alignof(FGzPackageCollectOtgProButtonClicked) == 0x000008, "Wrong alignment on FGzPackageCollectOtgProButtonClicked");
static_assert(sizeof(FGzPackageCollectOtgProButtonClicked) == 0x000068, "Wrong size on FGzPackageCollectOtgProButtonClicked");

// ScriptStruct G01.GzPackageCollectPlayerSatisfaction
// 0x0018 (0x0080 - 0x0068)
struct FGzPackageCollectPlayerSatisfaction final : public FGzPlayFabClientPackage
{
public:
	class FString                                 MatchID;                                           // 0x0068(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Rating;                                            // 0x0078(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2BFC[0x4];                                     // 0x007C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGzPackageCollectPlayerSatisfaction) == 0x000008, "Wrong alignment on FGzPackageCollectPlayerSatisfaction");
static_assert(sizeof(FGzPackageCollectPlayerSatisfaction) == 0x000080, "Wrong size on FGzPackageCollectPlayerSatisfaction");
static_assert(offsetof(FGzPackageCollectPlayerSatisfaction, MatchID) == 0x000068, "Member 'FGzPackageCollectPlayerSatisfaction::MatchID' has a wrong offset!");
static_assert(offsetof(FGzPackageCollectPlayerSatisfaction, Rating) == 0x000078, "Member 'FGzPackageCollectPlayerSatisfaction::Rating' has a wrong offset!");

// ScriptStruct G01.GzPackageCompleteChallenge
// 0x0020 (0x00A8 - 0x0088)
struct FGzPackageCompleteChallenge final : public FGzPlayFabServerPackage
{
public:
	class FString                                 ChallengeId;                                       // 0x0088(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 ChallengeType;                                     // 0x0098(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzPackageCompleteChallenge) == 0x000008, "Wrong alignment on FGzPackageCompleteChallenge");
static_assert(sizeof(FGzPackageCompleteChallenge) == 0x0000A8, "Wrong size on FGzPackageCompleteChallenge");
static_assert(offsetof(FGzPackageCompleteChallenge, ChallengeId) == 0x000088, "Member 'FGzPackageCompleteChallenge::ChallengeId' has a wrong offset!");
static_assert(offsetof(FGzPackageCompleteChallenge, ChallengeType) == 0x000098, "Member 'FGzPackageCompleteChallenge::ChallengeType' has a wrong offset!");

// ScriptStruct G01.GzPackageCompleteJob
// 0x0020 (0x00A8 - 0x0088)
struct FGzPackageCompleteJob final : public FGzPlayFabServerPackage
{
public:
	class FString                                 CharacterId;                                       // 0x0088(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 CompletedJobId;                                    // 0x0098(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzPackageCompleteJob) == 0x000008, "Wrong alignment on FGzPackageCompleteJob");
static_assert(sizeof(FGzPackageCompleteJob) == 0x0000A8, "Wrong size on FGzPackageCompleteJob");
static_assert(offsetof(FGzPackageCompleteJob, CharacterId) == 0x000088, "Member 'FGzPackageCompleteJob::CharacterId' has a wrong offset!");
static_assert(offsetof(FGzPackageCompleteJob, CompletedJobId) == 0x000098, "Member 'FGzPackageCompleteJob::CompletedJobId' has a wrong offset!");

// ScriptStruct G01.GzPackageConsoleProcessPurchases
// 0x0010 (0x0078 - 0x0068)
struct FGzPackageConsoleProcessPurchases final : public FGzPlayFabClientPackage
{
public:
	class FString                                 PlayerAccountId;                                   // 0x0068(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzPackageConsoleProcessPurchases) == 0x000008, "Wrong alignment on FGzPackageConsoleProcessPurchases");
static_assert(sizeof(FGzPackageConsoleProcessPurchases) == 0x000078, "Wrong size on FGzPackageConsoleProcessPurchases");
static_assert(offsetof(FGzPackageConsoleProcessPurchases, PlayerAccountId) == 0x000068, "Member 'FGzPackageConsoleProcessPurchases::PlayerAccountId' has a wrong offset!");

// ScriptStruct G01.GzPackageCustomizationAppearanceUpdate
// 0x0030 (0x0098 - 0x0068)
struct FGzPackageCustomizationAppearanceUpdate final : public FGzPlayFabClientPackage
{
public:
	class FString                                 CharacterId;                                       // 0x0068(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGzPackageCustomizationAppearanceCollection Customization;                                     // 0x0078(0x0020)(NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzPackageCustomizationAppearanceUpdate) == 0x000008, "Wrong alignment on FGzPackageCustomizationAppearanceUpdate");
static_assert(sizeof(FGzPackageCustomizationAppearanceUpdate) == 0x000098, "Wrong size on FGzPackageCustomizationAppearanceUpdate");
static_assert(offsetof(FGzPackageCustomizationAppearanceUpdate, CharacterId) == 0x000068, "Member 'FGzPackageCustomizationAppearanceUpdate::CharacterId' has a wrong offset!");
static_assert(offsetof(FGzPackageCustomizationAppearanceUpdate, Customization) == 0x000078, "Member 'FGzPackageCustomizationAppearanceUpdate::Customization' has a wrong offset!");

// ScriptStruct G01.GzPackageCustomizationEmoteUpdate
// 0x0010 (0x0078 - 0x0068)
struct FGzPackageCustomizationEmoteUpdate final : public FGzPlayFabClientPackage
{
public:
	TArray<struct FGzPackageCustomizationEmoteSlot> Emotes;                                            // 0x0068(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzPackageCustomizationEmoteUpdate) == 0x000008, "Wrong alignment on FGzPackageCustomizationEmoteUpdate");
static_assert(sizeof(FGzPackageCustomizationEmoteUpdate) == 0x000078, "Wrong size on FGzPackageCustomizationEmoteUpdate");
static_assert(offsetof(FGzPackageCustomizationEmoteUpdate, Emotes) == 0x000068, "Member 'FGzPackageCustomizationEmoteUpdate::Emotes' has a wrong offset!");

// ScriptStruct G01.GzPackageGetCheapestMarketLot
// 0x0010 (0x0078 - 0x0068)
struct FGzPackageGetCheapestMarketLot final : public FGzPlayFabClientPackage
{
public:
	class FString                                 AssetId;                                           // 0x0068(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzPackageGetCheapestMarketLot) == 0x000008, "Wrong alignment on FGzPackageGetCheapestMarketLot");
static_assert(sizeof(FGzPackageGetCheapestMarketLot) == 0x000078, "Wrong size on FGzPackageGetCheapestMarketLot");
static_assert(offsetof(FGzPackageGetCheapestMarketLot, AssetId) == 0x000068, "Member 'FGzPackageGetCheapestMarketLot::AssetId' has a wrong offset!");

// ScriptStruct G01.GzPackageGetClientLiveFeatures
// 0x0000 (0x0068 - 0x0068)
struct FGzPackageGetClientLiveFeatures final : public FGzPlayFabClientPackage
{
};
static_assert(alignof(FGzPackageGetClientLiveFeatures) == 0x000008, "Wrong alignment on FGzPackageGetClientLiveFeatures");
static_assert(sizeof(FGzPackageGetClientLiveFeatures) == 0x000068, "Wrong size on FGzPackageGetClientLiveFeatures");

// ScriptStruct G01.GzPackageGetMarketplaceItem
// 0x0010 (0x0078 - 0x0068)
struct FGzPackageGetMarketplaceItem final : public FGzPlayFabClientPackage
{
public:
	class FString                                 NftId;                                             // 0x0068(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzPackageGetMarketplaceItem) == 0x000008, "Wrong alignment on FGzPackageGetMarketplaceItem");
static_assert(sizeof(FGzPackageGetMarketplaceItem) == 0x000078, "Wrong size on FGzPackageGetMarketplaceItem");
static_assert(offsetof(FGzPackageGetMarketplaceItem, NftId) == 0x000068, "Member 'FGzPackageGetMarketplaceItem::NftId' has a wrong offset!");

// ScriptStruct G01.GzPackageGetServerLiveFeatures
// 0x0000 (0x0088 - 0x0088)
struct FGzPackageGetServerLiveFeatures final : public FGzPlayFabServerPackage
{
};
static_assert(alignof(FGzPackageGetServerLiveFeatures) == 0x000008, "Wrong alignment on FGzPackageGetServerLiveFeatures");
static_assert(sizeof(FGzPackageGetServerLiveFeatures) == 0x000088, "Wrong size on FGzPackageGetServerLiveFeatures");

// ScriptStruct G01.GzPackageGetTransactionHistory
// 0x0010 (0x0078 - 0x0068)
struct FGzPackageGetTransactionHistory final : public FGzPlayFabClientPackage
{
public:
	class FString                                 ContinuationToken;                                 // 0x0068(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzPackageGetTransactionHistory) == 0x000008, "Wrong alignment on FGzPackageGetTransactionHistory");
static_assert(sizeof(FGzPackageGetTransactionHistory) == 0x000078, "Wrong size on FGzPackageGetTransactionHistory");
static_assert(offsetof(FGzPackageGetTransactionHistory, ContinuationToken) == 0x000068, "Member 'FGzPackageGetTransactionHistory::ContinuationToken' has a wrong offset!");

// ScriptStruct G01.GzPackageListMarketPagingParameters
// 0x0008 (0x0008 - 0x0000)
struct FGzPackageListMarketPagingParameters final
{
public:
	uint32                                        Offset;                                            // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Limit;                                             // 0x0004(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2BFD[0x3];                                     // 0x0005(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGzPackageListMarketPagingParameters) == 0x000004, "Wrong alignment on FGzPackageListMarketPagingParameters");
static_assert(sizeof(FGzPackageListMarketPagingParameters) == 0x000008, "Wrong size on FGzPackageListMarketPagingParameters");
static_assert(offsetof(FGzPackageListMarketPagingParameters, Offset) == 0x000000, "Member 'FGzPackageListMarketPagingParameters::Offset' has a wrong offset!");
static_assert(offsetof(FGzPackageListMarketPagingParameters, Limit) == 0x000004, "Member 'FGzPackageListMarketPagingParameters::Limit' has a wrong offset!");

// ScriptStruct G01.GzPackageListMarketOrderParameters
// 0x0020 (0x0020 - 0x0000)
struct FGzPackageListMarketOrderParameters final
{
public:
	class FString                                 OrderDirection;                                    // 0x0000(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 OrderType;                                         // 0x0010(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzPackageListMarketOrderParameters) == 0x000008, "Wrong alignment on FGzPackageListMarketOrderParameters");
static_assert(sizeof(FGzPackageListMarketOrderParameters) == 0x000020, "Wrong size on FGzPackageListMarketOrderParameters");
static_assert(offsetof(FGzPackageListMarketOrderParameters, OrderDirection) == 0x000000, "Member 'FGzPackageListMarketOrderParameters::OrderDirection' has a wrong offset!");
static_assert(offsetof(FGzPackageListMarketOrderParameters, OrderType) == 0x000010, "Member 'FGzPackageListMarketOrderParameters::OrderType' has a wrong offset!");

// ScriptStruct G01.GzPackageListMarket
// 0x0098 (0x0100 - 0x0068)
struct FGzPackageListMarket final : public FGzPlayFabClientPackage
{
public:
	struct FGzPackageListMarketPagingParameters   PagingParameters;                                  // 0x0068(0x0008)(NoDestructor, NativeAccessSpecifierPublic)
	struct FGzPackageListMarketFilterParameters   FilterParameters;                                  // 0x0070(0x0070)(NativeAccessSpecifierPublic)
	struct FGzPackageListMarketOrderParameters    OrderParameters;                                   // 0x00E0(0x0020)(NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzPackageListMarket) == 0x000008, "Wrong alignment on FGzPackageListMarket");
static_assert(sizeof(FGzPackageListMarket) == 0x000100, "Wrong size on FGzPackageListMarket");
static_assert(offsetof(FGzPackageListMarket, PagingParameters) == 0x000068, "Member 'FGzPackageListMarket::PagingParameters' has a wrong offset!");
static_assert(offsetof(FGzPackageListMarket, FilterParameters) == 0x000070, "Member 'FGzPackageListMarket::FilterParameters' has a wrong offset!");
static_assert(offsetof(FGzPackageListMarket, OrderParameters) == 0x0000E0, "Member 'FGzPackageListMarket::OrderParameters' has a wrong offset!");

// ScriptStruct G01.GzPackageLoadoutCollection
// 0x0050 (0x00B8 - 0x0068)
struct FGzPackageLoadoutCollection final : public FGzPlayFabClientPackage
{
public:
	TMap<class FString, struct FGzPackageLoadout> Loadouts;                                          // 0x0068(0x0050)(NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzPackageLoadoutCollection) == 0x000008, "Wrong alignment on FGzPackageLoadoutCollection");
static_assert(sizeof(FGzPackageLoadoutCollection) == 0x0000B8, "Wrong size on FGzPackageLoadoutCollection");
static_assert(offsetof(FGzPackageLoadoutCollection, Loadouts) == 0x000068, "Member 'FGzPackageLoadoutCollection::Loadouts' has a wrong offset!");

// ScriptStruct G01.GzPackageLoadoutUpdate
// 0x0060 (0x00C8 - 0x0068)
struct FGzPackageLoadoutUpdate final : public FGzPlayFabClientPackage
{
public:
	class FString                                 CharacterId;                                       // 0x0068(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMap<class FString, struct FGzPackageLoadout> Loadouts;                                          // 0x0078(0x0050)(NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzPackageLoadoutUpdate) == 0x000008, "Wrong alignment on FGzPackageLoadoutUpdate");
static_assert(sizeof(FGzPackageLoadoutUpdate) == 0x0000C8, "Wrong size on FGzPackageLoadoutUpdate");
static_assert(offsetof(FGzPackageLoadoutUpdate, CharacterId) == 0x000068, "Member 'FGzPackageLoadoutUpdate::CharacterId' has a wrong offset!");
static_assert(offsetof(FGzPackageLoadoutUpdate, Loadouts) == 0x000078, "Member 'FGzPackageLoadoutUpdate::Loadouts' has a wrong offset!");

// ScriptStruct G01.GzPackageOnlinePresence
// 0x0010 (0x0078 - 0x0068)
struct FGzPackageOnlinePresence final : public FGzPlayFabClientPackage
{
public:
	class FString                                 Status;                                            // 0x0068(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzPackageOnlinePresence) == 0x000008, "Wrong alignment on FGzPackageOnlinePresence");
static_assert(sizeof(FGzPackageOnlinePresence) == 0x000078, "Wrong size on FGzPackageOnlinePresence");
static_assert(offsetof(FGzPackageOnlinePresence, Status) == 0x000068, "Member 'FGzPackageOnlinePresence::Status' has a wrong offset!");

// ScriptStruct G01.GzPackagePublishLoadouts
// 0x0010 (0x0078 - 0x0068)
struct FGzPackagePublishLoadouts final : public FGzPlayFabClientPackage
{
public:
	class FString                                 CharacterId;                                       // 0x0068(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzPackagePublishLoadouts) == 0x000008, "Wrong alignment on FGzPackagePublishLoadouts");
static_assert(sizeof(FGzPackagePublishLoadouts) == 0x000078, "Wrong size on FGzPackagePublishLoadouts");
static_assert(offsetof(FGzPackagePublishLoadouts, CharacterId) == 0x000068, "Member 'FGzPackagePublishLoadouts::CharacterId' has a wrong offset!");

// ScriptStruct G01.GzPackagePublishWeaponConfigurations
// 0x0010 (0x0078 - 0x0068)
struct FGzPackagePublishWeaponConfigurations final : public FGzPlayFabClientPackage
{
public:
	class FString                                 CharacterId;                                       // 0x0068(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzPackagePublishWeaponConfigurations) == 0x000008, "Wrong alignment on FGzPackagePublishWeaponConfigurations");
static_assert(sizeof(FGzPackagePublishWeaponConfigurations) == 0x000078, "Wrong size on FGzPackagePublishWeaponConfigurations");
static_assert(offsetof(FGzPackagePublishWeaponConfigurations, CharacterId) == 0x000068, "Member 'FGzPackagePublishWeaponConfigurations::CharacterId' has a wrong offset!");

// ScriptStruct G01.GzPackageRemoveMarketLot
// 0x0010 (0x0078 - 0x0068)
struct FGzPackageRemoveMarketLot final : public FGzPlayFabClientPackage
{
public:
	class FString                                 ItemInstanceId;                                    // 0x0068(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzPackageRemoveMarketLot) == 0x000008, "Wrong alignment on FGzPackageRemoveMarketLot");
static_assert(sizeof(FGzPackageRemoveMarketLot) == 0x000078, "Wrong size on FGzPackageRemoveMarketLot");
static_assert(offsetof(FGzPackageRemoveMarketLot, ItemInstanceId) == 0x000068, "Member 'FGzPackageRemoveMarketLot::ItemInstanceId' has a wrong offset!");

// ScriptStruct G01.GzPackageReportPlayerMarketplaceLot
// 0x0020 (0x0088 - 0x0068)
struct FGzPackageReportPlayerMarketplaceLot final : public FGzPlayFabClientPackage
{
public:
	class FString                                 LotId;                                             // 0x0068(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Reason;                                            // 0x0078(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzPackageReportPlayerMarketplaceLot) == 0x000008, "Wrong alignment on FGzPackageReportPlayerMarketplaceLot");
static_assert(sizeof(FGzPackageReportPlayerMarketplaceLot) == 0x000088, "Wrong size on FGzPackageReportPlayerMarketplaceLot");
static_assert(offsetof(FGzPackageReportPlayerMarketplaceLot, LotId) == 0x000068, "Member 'FGzPackageReportPlayerMarketplaceLot::LotId' has a wrong offset!");
static_assert(offsetof(FGzPackageReportPlayerMarketplaceLot, Reason) == 0x000078, "Member 'FGzPackageReportPlayerMarketplaceLot::Reason' has a wrong offset!");

// ScriptStruct G01.GzPackageSaveCompletedAchievementStage
// 0x0018 (0x00A0 - 0x0088)
struct FGzPackageSaveCompletedAchievementStage final : public FGzPlayFabServerPackage
{
public:
	class FString                                 AchievementId;                                     // 0x0088(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int8                                          Stage;                                             // 0x0098(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2BFE[0x7];                                     // 0x0099(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGzPackageSaveCompletedAchievementStage) == 0x000008, "Wrong alignment on FGzPackageSaveCompletedAchievementStage");
static_assert(sizeof(FGzPackageSaveCompletedAchievementStage) == 0x0000A0, "Wrong size on FGzPackageSaveCompletedAchievementStage");
static_assert(offsetof(FGzPackageSaveCompletedAchievementStage, AchievementId) == 0x000088, "Member 'FGzPackageSaveCompletedAchievementStage::AchievementId' has a wrong offset!");
static_assert(offsetof(FGzPackageSaveCompletedAchievementStage, Stage) == 0x000098, "Member 'FGzPackageSaveCompletedAchievementStage::Stage' has a wrong offset!");

// ScriptStruct G01.GzPackageSelectJob
// 0x0020 (0x0088 - 0x0068)
struct FGzPackageSelectJob final : public FGzPlayFabClientPackage
{
public:
	class FString                                 CharacterId;                                       // 0x0068(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 SelectedJobId;                                     // 0x0078(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzPackageSelectJob) == 0x000008, "Wrong alignment on FGzPackageSelectJob");
static_assert(sizeof(FGzPackageSelectJob) == 0x000088, "Wrong size on FGzPackageSelectJob");
static_assert(offsetof(FGzPackageSelectJob, CharacterId) == 0x000068, "Member 'FGzPackageSelectJob::CharacterId' has a wrong offset!");
static_assert(offsetof(FGzPackageSelectJob, SelectedJobId) == 0x000078, "Member 'FGzPackageSelectJob::SelectedJobId' has a wrong offset!");

// ScriptStruct G01.GzPackageUpdateChallenges
// 0x0000 (0x0068 - 0x0068)
struct FGzPackageUpdateChallenges final : public FGzPlayFabClientPackage
{
};
static_assert(alignof(FGzPackageUpdateChallenges) == 0x000008, "Wrong alignment on FGzPackageUpdateChallenges");
static_assert(sizeof(FGzPackageUpdateChallenges) == 0x000068, "Wrong size on FGzPackageUpdateChallenges");

// ScriptStruct G01.GzPhysicsSimulationState
// 0x0008 (0x0008 - 0x0000)
struct FGzPhysicsSimulationState final
{
public:
	EGzPhysicsSimulationStateType                 StateType;                                         // 0x0000(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2BFF[0x3];                                     // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         TimeSpentInSimulatingState;                        // 0x0004(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzPhysicsSimulationState) == 0x000004, "Wrong alignment on FGzPhysicsSimulationState");
static_assert(sizeof(FGzPhysicsSimulationState) == 0x000008, "Wrong size on FGzPhysicsSimulationState");
static_assert(offsetof(FGzPhysicsSimulationState, StateType) == 0x000000, "Member 'FGzPhysicsSimulationState::StateType' has a wrong offset!");
static_assert(offsetof(FGzPhysicsSimulationState, TimeSpentInSimulatingState) == 0x000004, "Member 'FGzPhysicsSimulationState::TimeSpentInSimulatingState' has a wrong offset!");

// ScriptStruct G01.GzPickableItemContent
// 0x0038 (0x0038 - 0x0000)
struct alignas(0x08) FGzPickableItemContent final
{
public:
	int8                                          DummyVarToForceReplication;                        // 0x0000(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2C00[0x37];                                    // 0x0001(0x0037)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGzPickableItemContent) == 0x000008, "Wrong alignment on FGzPickableItemContent");
static_assert(sizeof(FGzPickableItemContent) == 0x000038, "Wrong size on FGzPickableItemContent");
static_assert(offsetof(FGzPickableItemContent, DummyVarToForceReplication) == 0x000000, "Member 'FGzPickableItemContent::DummyVarToForceReplication' has a wrong offset!");

// ScriptStruct G01.GzPingContextSnapshot
// 0x0110 (0x0110 - 0x0000)
struct FGzPingContextSnapshot final
{
public:
	class AActor*                                 FocusedActor;                                      // 0x0000(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UGzMarkerComponent*                     FocusedMarker;                                     // 0x0008(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EGzPingTarget                                 PingTargetType;                                    // 0x0010(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C01[0x7];                                     // 0x0011(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FHitResult                             PingHit;                                           // 0x0018(0x00F8)(Transient, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzPingContextSnapshot) == 0x000008, "Wrong alignment on FGzPingContextSnapshot");
static_assert(sizeof(FGzPingContextSnapshot) == 0x000110, "Wrong size on FGzPingContextSnapshot");
static_assert(offsetof(FGzPingContextSnapshot, FocusedActor) == 0x000000, "Member 'FGzPingContextSnapshot::FocusedActor' has a wrong offset!");
static_assert(offsetof(FGzPingContextSnapshot, FocusedMarker) == 0x000008, "Member 'FGzPingContextSnapshot::FocusedMarker' has a wrong offset!");
static_assert(offsetof(FGzPingContextSnapshot, PingTargetType) == 0x000010, "Member 'FGzPingContextSnapshot::PingTargetType' has a wrong offset!");
static_assert(offsetof(FGzPingContextSnapshot, PingHit) == 0x000018, "Member 'FGzPingContextSnapshot::PingHit' has a wrong offset!");

// ScriptStruct G01.GzPingLifetimeInfo
// 0x0010 (0x0010 - 0x0000)
struct FGzPingLifetimeInfo final
{
public:
	class AGzPingActor*                           PingActor;                                         // 0x0000(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FTimerHandle                           ExpirationHandle;                                  // 0x0008(0x0008)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzPingLifetimeInfo) == 0x000008, "Wrong alignment on FGzPingLifetimeInfo");
static_assert(sizeof(FGzPingLifetimeInfo) == 0x000010, "Wrong size on FGzPingLifetimeInfo");
static_assert(offsetof(FGzPingLifetimeInfo, PingActor) == 0x000000, "Member 'FGzPingLifetimeInfo::PingActor' has a wrong offset!");
static_assert(offsetof(FGzPingLifetimeInfo, ExpirationHandle) == 0x000008, "Member 'FGzPingLifetimeInfo::ExpirationHandle' has a wrong offset!");

// ScriptStruct G01.GzPlayableAreaData
// 0x0018 (0x0018 - 0x0000)
struct FGzPlayableAreaData final
{
public:
	class FName                                   Layer;                                             // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class FName>                           Zones;                                             // 0x0008(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzPlayableAreaData) == 0x000008, "Wrong alignment on FGzPlayableAreaData");
static_assert(sizeof(FGzPlayableAreaData) == 0x000018, "Wrong size on FGzPlayableAreaData");
static_assert(offsetof(FGzPlayableAreaData, Layer) == 0x000000, "Member 'FGzPlayableAreaData::Layer' has a wrong offset!");
static_assert(offsetof(FGzPlayableAreaData, Zones) == 0x000008, "Member 'FGzPlayableAreaData::Zones' has a wrong offset!");

// ScriptStruct G01.GzGrantItemsResult
// 0x0010 (0x00F0 - 0x00E0)
struct FGzGrantItemsResult final : public FGzPlayFabResultBase
{
public:
	TArray<struct FGzBackendInventoryItem>        ItemsSimplified;                                   // 0x00E0(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzGrantItemsResult) == 0x000008, "Wrong alignment on FGzGrantItemsResult");
static_assert(sizeof(FGzGrantItemsResult) == 0x0000F0, "Wrong size on FGzGrantItemsResult");
static_assert(offsetof(FGzGrantItemsResult, ItemsSimplified) == 0x0000E0, "Member 'FGzGrantItemsResult::ItemsSimplified' has a wrong offset!");

// ScriptStruct G01.GzGetInventoryItemsResult
// 0x0020 (0x0100 - 0x00E0)
struct FGzGetInventoryItemsResult final : public FGzPlayFabResultBase
{
public:
	class FString                                 ContinuationToken;                                 // 0x00E0(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FGzBackendInventoryItem>        ItemsSimplified;                                   // 0x00F0(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzGetInventoryItemsResult) == 0x000008, "Wrong alignment on FGzGetInventoryItemsResult");
static_assert(sizeof(FGzGetInventoryItemsResult) == 0x000100, "Wrong size on FGzGetInventoryItemsResult");
static_assert(offsetof(FGzGetInventoryItemsResult, ContinuationToken) == 0x0000E0, "Member 'FGzGetInventoryItemsResult::ContinuationToken' has a wrong offset!");
static_assert(offsetof(FGzGetInventoryItemsResult, ItemsSimplified) == 0x0000F0, "Member 'FGzGetInventoryItemsResult::ItemsSimplified' has a wrong offset!");

// ScriptStruct G01.GzGetInventoryItemResult
// 0x00B0 (0x0190 - 0x00E0)
struct FGzGetInventoryItemResult final : public FGzPlayFabResultBase
{
public:
	struct FGzBackendInventoryItem                ItemSimplified;                                    // 0x00E0(0x00B0)(NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzGetInventoryItemResult) == 0x000008, "Wrong alignment on FGzGetInventoryItemResult");
static_assert(sizeof(FGzGetInventoryItemResult) == 0x000190, "Wrong size on FGzGetInventoryItemResult");
static_assert(offsetof(FGzGetInventoryItemResult, ItemSimplified) == 0x0000E0, "Member 'FGzGetInventoryItemResult::ItemSimplified' has a wrong offset!");

// ScriptStruct G01.GzMarkerOwnerDistanceCache
// 0x0030 (0x0030 - 0x0000)
struct FGzMarkerOwnerDistanceCache final
{
public:
	class AActor*                                 Owner;                                             // 0x0000(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UGzMarkerComponent*                     CurrentMarker;                                     // 0x0008(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UGzMarkerComponent*                     PreviousMarker;                                    // 0x0010(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 PreviousOwner;                                     // 0x0018(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	double                                        DistanceToLocalPlayerSquared;                      // 0x0020(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C02[0x8];                                     // 0x0028(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGzMarkerOwnerDistanceCache) == 0x000008, "Wrong alignment on FGzMarkerOwnerDistanceCache");
static_assert(sizeof(FGzMarkerOwnerDistanceCache) == 0x000030, "Wrong size on FGzMarkerOwnerDistanceCache");
static_assert(offsetof(FGzMarkerOwnerDistanceCache, Owner) == 0x000000, "Member 'FGzMarkerOwnerDistanceCache::Owner' has a wrong offset!");
static_assert(offsetof(FGzMarkerOwnerDistanceCache, CurrentMarker) == 0x000008, "Member 'FGzMarkerOwnerDistanceCache::CurrentMarker' has a wrong offset!");
static_assert(offsetof(FGzMarkerOwnerDistanceCache, PreviousMarker) == 0x000010, "Member 'FGzMarkerOwnerDistanceCache::PreviousMarker' has a wrong offset!");
static_assert(offsetof(FGzMarkerOwnerDistanceCache, PreviousOwner) == 0x000018, "Member 'FGzMarkerOwnerDistanceCache::PreviousOwner' has a wrong offset!");
static_assert(offsetof(FGzMarkerOwnerDistanceCache, DistanceToLocalPlayerSquared) == 0x000020, "Member 'FGzMarkerOwnerDistanceCache::DistanceToLocalPlayerSquared' has a wrong offset!");

// ScriptStruct G01.GzPlayerStatSet
// 0x0068 (0x0068 - 0x0000)
struct FGzPlayerStatSet final
{
public:
	int32                                         PlayerId;                                          // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C03[0x4];                                     // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FGzGameStat>                    Stats;                                             // 0x0008(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TMap<struct FGzSubGameStatKey, float>         SubStats;                                          // 0x0018(0x0050)(NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzPlayerStatSet) == 0x000008, "Wrong alignment on FGzPlayerStatSet");
static_assert(sizeof(FGzPlayerStatSet) == 0x000068, "Wrong size on FGzPlayerStatSet");
static_assert(offsetof(FGzPlayerStatSet, PlayerId) == 0x000000, "Member 'FGzPlayerStatSet::PlayerId' has a wrong offset!");
static_assert(offsetof(FGzPlayerStatSet, Stats) == 0x000008, "Member 'FGzPlayerStatSet::Stats' has a wrong offset!");
static_assert(offsetof(FGzPlayerStatSet, SubStats) == 0x000018, "Member 'FGzPlayerStatSet::SubStats' has a wrong offset!");

// ScriptStruct G01.GzPlayFabBattlePassLevelUpNotification
// 0x0010 (0x0030 - 0x0020)
struct FGzPlayFabBattlePassLevelUpNotification final : public FGzPlayFabNotification
{
public:
	struct FGzBackendBattlePassLevelProgressionV2 LevelProgression;                                  // 0x0020(0x000C)(NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C04[0x4];                                     // 0x002C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGzPlayFabBattlePassLevelUpNotification) == 0x000008, "Wrong alignment on FGzPlayFabBattlePassLevelUpNotification");
static_assert(sizeof(FGzPlayFabBattlePassLevelUpNotification) == 0x000030, "Wrong size on FGzPlayFabBattlePassLevelUpNotification");
static_assert(offsetof(FGzPlayFabBattlePassLevelUpNotification, LevelProgression) == 0x000020, "Member 'FGzPlayFabBattlePassLevelUpNotification::LevelProgression' has a wrong offset!");

// ScriptStruct G01.GzPlayFabChallengeNotification
// 0x00E0 (0x0100 - 0x0020)
struct FGzPlayFabChallengeNotification final : public FGzPlayFabNotification
{
public:
	class FString                                 ChallengeId;                                       // 0x0020(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGzCombinedReward                      Reward;                                            // 0x0030(0x00D0)(NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzPlayFabChallengeNotification) == 0x000008, "Wrong alignment on FGzPlayFabChallengeNotification");
static_assert(sizeof(FGzPlayFabChallengeNotification) == 0x000100, "Wrong size on FGzPlayFabChallengeNotification");
static_assert(offsetof(FGzPlayFabChallengeNotification, ChallengeId) == 0x000020, "Member 'FGzPlayFabChallengeNotification::ChallengeId' has a wrong offset!");
static_assert(offsetof(FGzPlayFabChallengeNotification, Reward) == 0x000030, "Member 'FGzPlayFabChallengeNotification::Reward' has a wrong offset!");

// ScriptStruct G01.GzPlayFabGrandRewardsNotifications
// 0x00D0 (0x00F0 - 0x0020)
struct FGzPlayFabGrandRewardsNotifications final : public FGzPlayFabNotification
{
public:
	struct FGzCombinedReward                      Reward;                                            // 0x0020(0x00D0)(NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzPlayFabGrandRewardsNotifications) == 0x000008, "Wrong alignment on FGzPlayFabGrandRewardsNotifications");
static_assert(sizeof(FGzPlayFabGrandRewardsNotifications) == 0x0000F0, "Wrong size on FGzPlayFabGrandRewardsNotifications");
static_assert(offsetof(FGzPlayFabGrandRewardsNotifications, Reward) == 0x000020, "Member 'FGzPlayFabGrandRewardsNotifications::Reward' has a wrong offset!");

// ScriptStruct G01.GzPlayFabServerBrowserServerHostingStatusChangedNotification
// 0x0020 (0x0040 - 0x0020)
struct FGzPlayFabServerBrowserServerHostingStatusChangedNotification final : public FGzPlayFabNotification
{
public:
	class FString                                 ServerName;                                        // 0x0020(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Status;                                            // 0x0030(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzPlayFabServerBrowserServerHostingStatusChangedNotification) == 0x000008, "Wrong alignment on FGzPlayFabServerBrowserServerHostingStatusChangedNotification");
static_assert(sizeof(FGzPlayFabServerBrowserServerHostingStatusChangedNotification) == 0x000040, "Wrong size on FGzPlayFabServerBrowserServerHostingStatusChangedNotification");
static_assert(offsetof(FGzPlayFabServerBrowserServerHostingStatusChangedNotification, ServerName) == 0x000020, "Member 'FGzPlayFabServerBrowserServerHostingStatusChangedNotification::ServerName' has a wrong offset!");
static_assert(offsetof(FGzPlayFabServerBrowserServerHostingStatusChangedNotification, Status) == 0x000030, "Member 'FGzPlayFabServerBrowserServerHostingStatusChangedNotification::Status' has a wrong offset!");

// ScriptStruct G01.GzPlayFabBlockchainMintItemV2Notification
// 0x0028 (0x0048 - 0x0020)
struct FGzPlayFabBlockchainMintItemV2Notification final : public FGzPlayFabNotification
{
public:
	class FString                                 AssetId;                                           // 0x0020(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   ItemInstanceId;                                    // 0x0030(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 NftId;                                             // 0x0038(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzPlayFabBlockchainMintItemV2Notification) == 0x000008, "Wrong alignment on FGzPlayFabBlockchainMintItemV2Notification");
static_assert(sizeof(FGzPlayFabBlockchainMintItemV2Notification) == 0x000048, "Wrong size on FGzPlayFabBlockchainMintItemV2Notification");
static_assert(offsetof(FGzPlayFabBlockchainMintItemV2Notification, AssetId) == 0x000020, "Member 'FGzPlayFabBlockchainMintItemV2Notification::AssetId' has a wrong offset!");
static_assert(offsetof(FGzPlayFabBlockchainMintItemV2Notification, ItemInstanceId) == 0x000030, "Member 'FGzPlayFabBlockchainMintItemV2Notification::ItemInstanceId' has a wrong offset!");
static_assert(offsetof(FGzPlayFabBlockchainMintItemV2Notification, NftId) == 0x000038, "Member 'FGzPlayFabBlockchainMintItemV2Notification::NftId' has a wrong offset!");

// ScriptStruct G01.GzErrorNotification
// 0x0008 (0x0028 - 0x0020)
struct FGzErrorNotification final : public FGzPlayFabNotification
{
public:
	int32                                         Code;                                              // 0x0020(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C05[0x4];                                     // 0x0024(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGzErrorNotification) == 0x000008, "Wrong alignment on FGzErrorNotification");
static_assert(sizeof(FGzErrorNotification) == 0x000028, "Wrong size on FGzErrorNotification");
static_assert(offsetof(FGzErrorNotification, Code) == 0x000020, "Member 'FGzErrorNotification::Code' has a wrong offset!");

// ScriptStruct G01.GzBlockchainMarketLotCreatedNotification
// 0x0020 (0x0040 - 0x0020)
struct FGzBlockchainMarketLotCreatedNotification final : public FGzPlayFabNotification
{
public:
	class FString                                 AssetId;                                           // 0x0020(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 ItemInstanceId;                                    // 0x0030(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzBlockchainMarketLotCreatedNotification) == 0x000008, "Wrong alignment on FGzBlockchainMarketLotCreatedNotification");
static_assert(sizeof(FGzBlockchainMarketLotCreatedNotification) == 0x000040, "Wrong size on FGzBlockchainMarketLotCreatedNotification");
static_assert(offsetof(FGzBlockchainMarketLotCreatedNotification, AssetId) == 0x000020, "Member 'FGzBlockchainMarketLotCreatedNotification::AssetId' has a wrong offset!");
static_assert(offsetof(FGzBlockchainMarketLotCreatedNotification, ItemInstanceId) == 0x000030, "Member 'FGzBlockchainMarketLotCreatedNotification::ItemInstanceId' has a wrong offset!");

// ScriptStruct G01.GzBlockchainMarketLotBoughtNotification
// 0x0020 (0x0040 - 0x0020)
struct FGzBlockchainMarketLotBoughtNotification final : public FGzPlayFabNotification
{
public:
	class FString                                 AssetId;                                           // 0x0020(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 ItemInstanceId;                                    // 0x0030(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzBlockchainMarketLotBoughtNotification) == 0x000008, "Wrong alignment on FGzBlockchainMarketLotBoughtNotification");
static_assert(sizeof(FGzBlockchainMarketLotBoughtNotification) == 0x000040, "Wrong size on FGzBlockchainMarketLotBoughtNotification");
static_assert(offsetof(FGzBlockchainMarketLotBoughtNotification, AssetId) == 0x000020, "Member 'FGzBlockchainMarketLotBoughtNotification::AssetId' has a wrong offset!");
static_assert(offsetof(FGzBlockchainMarketLotBoughtNotification, ItemInstanceId) == 0x000030, "Member 'FGzBlockchainMarketLotBoughtNotification::ItemInstanceId' has a wrong offset!");

// ScriptStruct G01.GzMarketLotExpiredNotification
// 0x0020 (0x0040 - 0x0020)
struct FGzMarketLotExpiredNotification final : public FGzPlayFabNotification
{
public:
	class FString                                 AssetId;                                           // 0x0020(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 ItemInstanceId;                                    // 0x0030(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzMarketLotExpiredNotification) == 0x000008, "Wrong alignment on FGzMarketLotExpiredNotification");
static_assert(sizeof(FGzMarketLotExpiredNotification) == 0x000040, "Wrong size on FGzMarketLotExpiredNotification");
static_assert(offsetof(FGzMarketLotExpiredNotification, AssetId) == 0x000020, "Member 'FGzMarketLotExpiredNotification::AssetId' has a wrong offset!");
static_assert(offsetof(FGzMarketLotExpiredNotification, ItemInstanceId) == 0x000030, "Member 'FGzMarketLotExpiredNotification::ItemInstanceId' has a wrong offset!");

// ScriptStruct G01.GzExtractNotification
// 0x0020 (0x0040 - 0x0020)
struct FGzExtractNotification final : public FGzPlayFabNotification
{
public:
	class FString                                 AssetId;                                           // 0x0020(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 ItemInstanceId;                                    // 0x0030(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzExtractNotification) == 0x000008, "Wrong alignment on FGzExtractNotification");
static_assert(sizeof(FGzExtractNotification) == 0x000040, "Wrong size on FGzExtractNotification");
static_assert(offsetof(FGzExtractNotification, AssetId) == 0x000020, "Member 'FGzExtractNotification::AssetId' has a wrong offset!");
static_assert(offsetof(FGzExtractNotification, ItemInstanceId) == 0x000030, "Member 'FGzExtractNotification::ItemInstanceId' has a wrong offset!");

// ScriptStruct G01.GzPlinkRewardNotification
// 0x00D0 (0x00F0 - 0x0020)
struct FGzPlinkRewardNotification final : public FGzPlayFabNotification
{
public:
	struct FGzCombinedReward                      Reward;                                            // 0x0020(0x00D0)(NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzPlinkRewardNotification) == 0x000008, "Wrong alignment on FGzPlinkRewardNotification");
static_assert(sizeof(FGzPlinkRewardNotification) == 0x0000F0, "Wrong size on FGzPlinkRewardNotification");
static_assert(offsetof(FGzPlinkRewardNotification, Reward) == 0x000020, "Member 'FGzPlinkRewardNotification::Reward' has a wrong offset!");

// ScriptStruct G01.GzSubscriptionInfo
// 0x0030 (0x0030 - 0x0000)
struct FGzSubscriptionInfo final
{
public:
	class FString                                 PlanId;                                            // 0x0000(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SubscriptionId;                                    // 0x0010(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C06[0x4];                                     // 0x0014(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FDateTime                              DateCreated;                                       // 0x0018(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FDateTime                              DateNextCharge;                                    // 0x0020(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         TrialDays;                                         // 0x0028(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsGift;                                            // 0x002C(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsCanceled;                                        // 0x002D(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C07[0x2];                                     // 0x002E(0x0002)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGzSubscriptionInfo) == 0x000008, "Wrong alignment on FGzSubscriptionInfo");
static_assert(sizeof(FGzSubscriptionInfo) == 0x000030, "Wrong size on FGzSubscriptionInfo");
static_assert(offsetof(FGzSubscriptionInfo, PlanId) == 0x000000, "Member 'FGzSubscriptionInfo::PlanId' has a wrong offset!");
static_assert(offsetof(FGzSubscriptionInfo, SubscriptionId) == 0x000010, "Member 'FGzSubscriptionInfo::SubscriptionId' has a wrong offset!");
static_assert(offsetof(FGzSubscriptionInfo, DateCreated) == 0x000018, "Member 'FGzSubscriptionInfo::DateCreated' has a wrong offset!");
static_assert(offsetof(FGzSubscriptionInfo, DateNextCharge) == 0x000020, "Member 'FGzSubscriptionInfo::DateNextCharge' has a wrong offset!");
static_assert(offsetof(FGzSubscriptionInfo, TrialDays) == 0x000028, "Member 'FGzSubscriptionInfo::TrialDays' has a wrong offset!");
static_assert(offsetof(FGzSubscriptionInfo, IsGift) == 0x00002C, "Member 'FGzSubscriptionInfo::IsGift' has a wrong offset!");
static_assert(offsetof(FGzSubscriptionInfo, IsCanceled) == 0x00002D, "Member 'FGzSubscriptionInfo::IsCanceled' has a wrong offset!");

// ScriptStruct G01.GzContentPackInfo
// 0x0028 (0x0028 - 0x0000)
struct FGzContentPackInfo final
{
public:
	struct FDateTime                              GrantedOn;                                         // 0x0000(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 ContentPackId;                                     // 0x0008(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FGzGrantedItemId>               GrantedHexes;                                      // 0x0018(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzContentPackInfo) == 0x000008, "Wrong alignment on FGzContentPackInfo");
static_assert(sizeof(FGzContentPackInfo) == 0x000028, "Wrong size on FGzContentPackInfo");
static_assert(offsetof(FGzContentPackInfo, GrantedOn) == 0x000000, "Member 'FGzContentPackInfo::GrantedOn' has a wrong offset!");
static_assert(offsetof(FGzContentPackInfo, ContentPackId) == 0x000008, "Member 'FGzContentPackInfo::ContentPackId' has a wrong offset!");
static_assert(offsetof(FGzContentPackInfo, GrantedHexes) == 0x000018, "Member 'FGzContentPackInfo::GrantedHexes' has a wrong offset!");

// ScriptStruct G01.GzSubscriptionUpdatedNotification
// 0x0000 (0x0020 - 0x0020)
struct FGzSubscriptionUpdatedNotification final : public FGzPlayFabNotification
{
};
static_assert(alignof(FGzSubscriptionUpdatedNotification) == 0x000008, "Wrong alignment on FGzSubscriptionUpdatedNotification");
static_assert(sizeof(FGzSubscriptionUpdatedNotification) == 0x000020, "Wrong size on FGzSubscriptionUpdatedNotification");

// ScriptStruct G01.GzSubscriptionCanceledNotification
// 0x0000 (0x0020 - 0x0020)
struct FGzSubscriptionCanceledNotification final : public FGzPlayFabNotification
{
};
static_assert(alignof(FGzSubscriptionCanceledNotification) == 0x000008, "Wrong alignment on FGzSubscriptionCanceledNotification");
static_assert(sizeof(FGzSubscriptionCanceledNotification) == 0x000020, "Wrong size on FGzSubscriptionCanceledNotification");

// ScriptStruct G01.GzSubscriptionRenewCanceledNotification
// 0x0000 (0x0020 - 0x0020)
struct FGzSubscriptionRenewCanceledNotification final : public FGzPlayFabNotification
{
};
static_assert(alignof(FGzSubscriptionRenewCanceledNotification) == 0x000008, "Wrong alignment on FGzSubscriptionRenewCanceledNotification");
static_assert(sizeof(FGzSubscriptionRenewCanceledNotification) == 0x000020, "Wrong size on FGzSubscriptionRenewCanceledNotification");

// ScriptStruct G01.GzSubscriptionLoyaltyRewardsGrantedNotification
// 0x0010 (0x0030 - 0x0020)
struct FGzSubscriptionLoyaltyRewardsGrantedNotification final : public FGzPlayFabNotification
{
public:
	TArray<struct FGzBackendLoyaltyReward>        Rewards;                                           // 0x0020(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzSubscriptionLoyaltyRewardsGrantedNotification) == 0x000008, "Wrong alignment on FGzSubscriptionLoyaltyRewardsGrantedNotification");
static_assert(sizeof(FGzSubscriptionLoyaltyRewardsGrantedNotification) == 0x000030, "Wrong size on FGzSubscriptionLoyaltyRewardsGrantedNotification");
static_assert(offsetof(FGzSubscriptionLoyaltyRewardsGrantedNotification, Rewards) == 0x000020, "Member 'FGzSubscriptionLoyaltyRewardsGrantedNotification::Rewards' has a wrong offset!");

// ScriptStruct G01.GzMatchResultNotification
// 0x00F8 (0x0118 - 0x0020)
struct FGzMatchResultNotification final : public FGzPlayFabNotification
{
public:
	struct FGzCombinedReward                      Reward;                                            // 0x0020(0x00D0)(NativeAccessSpecifierPublic)
	double                                        PlacementReward;                                   // 0x00F0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 MatchID;                                           // 0x00F8(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FGzCombinedReward>              Rewards;                                           // 0x0108(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzMatchResultNotification) == 0x000008, "Wrong alignment on FGzMatchResultNotification");
static_assert(sizeof(FGzMatchResultNotification) == 0x000118, "Wrong size on FGzMatchResultNotification");
static_assert(offsetof(FGzMatchResultNotification, Reward) == 0x000020, "Member 'FGzMatchResultNotification::Reward' has a wrong offset!");
static_assert(offsetof(FGzMatchResultNotification, PlacementReward) == 0x0000F0, "Member 'FGzMatchResultNotification::PlacementReward' has a wrong offset!");
static_assert(offsetof(FGzMatchResultNotification, MatchID) == 0x0000F8, "Member 'FGzMatchResultNotification::MatchID' has a wrong offset!");
static_assert(offsetof(FGzMatchResultNotification, Rewards) == 0x000108, "Member 'FGzMatchResultNotification::Rewards' has a wrong offset!");

// ScriptStruct G01.GzPromoCodeRedeemedNotification
// 0x00E0 (0x0100 - 0x0020)
struct FGzPromoCodeRedeemedNotification final : public FGzPlayFabNotification
{
public:
	class FString                                 PromoCode;                                         // 0x0020(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGzCombinedReward                      Reward;                                            // 0x0030(0x00D0)(NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzPromoCodeRedeemedNotification) == 0x000008, "Wrong alignment on FGzPromoCodeRedeemedNotification");
static_assert(sizeof(FGzPromoCodeRedeemedNotification) == 0x000100, "Wrong size on FGzPromoCodeRedeemedNotification");
static_assert(offsetof(FGzPromoCodeRedeemedNotification, PromoCode) == 0x000020, "Member 'FGzPromoCodeRedeemedNotification::PromoCode' has a wrong offset!");
static_assert(offsetof(FGzPromoCodeRedeemedNotification, Reward) == 0x000030, "Member 'FGzPromoCodeRedeemedNotification::Reward' has a wrong offset!");

// ScriptStruct G01.GzRetrievePlinkTokenResult
// 0x0020 (0x0100 - 0x00E0)
struct FGzRetrievePlinkTokenResult final : public FGzPlayFabResultBase
{
public:
	class FString                                 Token;                                             // 0x00E0(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 ExpiresIn;                                         // 0x00F0(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzRetrievePlinkTokenResult) == 0x000008, "Wrong alignment on FGzRetrievePlinkTokenResult");
static_assert(sizeof(FGzRetrievePlinkTokenResult) == 0x000100, "Wrong size on FGzRetrievePlinkTokenResult");
static_assert(offsetof(FGzRetrievePlinkTokenResult, Token) == 0x0000E0, "Member 'FGzRetrievePlinkTokenResult::Token' has a wrong offset!");
static_assert(offsetof(FGzRetrievePlinkTokenResult, ExpiresIn) == 0x0000F0, "Member 'FGzRetrievePlinkTokenResult::ExpiresIn' has a wrong offset!");

// ScriptStruct G01.GzPlinkTokenPackage
// 0x0000 (0x0068 - 0x0068)
struct FGzPlinkTokenPackage final : public FGzPlayFabClientPackage
{
};
static_assert(alignof(FGzPlinkTokenPackage) == 0x000008, "Wrong alignment on FGzPlinkTokenPackage");
static_assert(sizeof(FGzPlinkTokenPackage) == 0x000068, "Wrong size on FGzPlinkTokenPackage");

// ScriptStruct G01.GzPlacementRangeRewardSetting
// 0x0018 (0x0018 - 0x0000)
struct FGzPlacementRangeRewardSetting final
{
public:
	int32                                         PlacementFrom;                                     // 0x0000(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         PlacementTo;                                       // 0x0004(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	double                                        GunRewardAmount;                                   // 0x0008(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EGzItemType                                   RewardHexType;                                     // 0x0010(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EGzItemRarity                                 RewardHexRarity;                                   // 0x0011(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C08[0x2];                                     // 0x0012(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         RewardHexesQuantity;                               // 0x0014(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzPlacementRangeRewardSetting) == 0x000008, "Wrong alignment on FGzPlacementRangeRewardSetting");
static_assert(sizeof(FGzPlacementRangeRewardSetting) == 0x000018, "Wrong size on FGzPlacementRangeRewardSetting");
static_assert(offsetof(FGzPlacementRangeRewardSetting, PlacementFrom) == 0x000000, "Member 'FGzPlacementRangeRewardSetting::PlacementFrom' has a wrong offset!");
static_assert(offsetof(FGzPlacementRangeRewardSetting, PlacementTo) == 0x000004, "Member 'FGzPlacementRangeRewardSetting::PlacementTo' has a wrong offset!");
static_assert(offsetof(FGzPlacementRangeRewardSetting, GunRewardAmount) == 0x000008, "Member 'FGzPlacementRangeRewardSetting::GunRewardAmount' has a wrong offset!");
static_assert(offsetof(FGzPlacementRangeRewardSetting, RewardHexType) == 0x000010, "Member 'FGzPlacementRangeRewardSetting::RewardHexType' has a wrong offset!");
static_assert(offsetof(FGzPlacementRangeRewardSetting, RewardHexRarity) == 0x000011, "Member 'FGzPlacementRangeRewardSetting::RewardHexRarity' has a wrong offset!");
static_assert(offsetof(FGzPlacementRangeRewardSetting, RewardHexesQuantity) == 0x000014, "Member 'FGzPlacementRangeRewardSetting::RewardHexesQuantity' has a wrong offset!");

// ScriptStruct G01.GzTagPostProcessConfig
// 0x0018 (0x0018 - 0x0000)
struct FGzTagPostProcessConfig final
{
public:
	class UGzPostProcessFX*                       PostProcessFX;                                     // 0x0000(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, PersistentInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<TSubclassOf<class APawn>>              AllowedViewTargets;                                // 0x0008(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, UObjectWrapper, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzTagPostProcessConfig) == 0x000008, "Wrong alignment on FGzTagPostProcessConfig");
static_assert(sizeof(FGzTagPostProcessConfig) == 0x000018, "Wrong size on FGzTagPostProcessConfig");
static_assert(offsetof(FGzTagPostProcessConfig, PostProcessFX) == 0x000000, "Member 'FGzTagPostProcessConfig::PostProcessFX' has a wrong offset!");
static_assert(offsetof(FGzTagPostProcessConfig, AllowedViewTargets) == 0x000008, "Member 'FGzTagPostProcessConfig::AllowedViewTargets' has a wrong offset!");

// ScriptStruct G01.GzDeploymentTrackSpawnData
// 0x0038 (0x0038 - 0x0000)
struct FGzDeploymentTrackSpawnData final
{
public:
	struct FVector                                Start;                                             // 0x0000(0x0018)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                End;                                               // 0x0018(0x0018)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DeploymentStartOffset;                             // 0x0030(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ForceDeploymentOffset;                             // 0x0034(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzDeploymentTrackSpawnData) == 0x000008, "Wrong alignment on FGzDeploymentTrackSpawnData");
static_assert(sizeof(FGzDeploymentTrackSpawnData) == 0x000038, "Wrong size on FGzDeploymentTrackSpawnData");
static_assert(offsetof(FGzDeploymentTrackSpawnData, Start) == 0x000000, "Member 'FGzDeploymentTrackSpawnData::Start' has a wrong offset!");
static_assert(offsetof(FGzDeploymentTrackSpawnData, End) == 0x000018, "Member 'FGzDeploymentTrackSpawnData::End' has a wrong offset!");
static_assert(offsetof(FGzDeploymentTrackSpawnData, DeploymentStartOffset) == 0x000030, "Member 'FGzDeploymentTrackSpawnData::DeploymentStartOffset' has a wrong offset!");
static_assert(offsetof(FGzDeploymentTrackSpawnData, ForceDeploymentOffset) == 0x000034, "Member 'FGzDeploymentTrackSpawnData::ForceDeploymentOffset' has a wrong offset!");

// ScriptStruct G01.GzProcessPostmatchResultPackage
// 0x0068 (0x00F0 - 0x0088)
struct FGzProcessPostmatchResultPackage final : public FGzPlayFabServerPackage
{
public:
	class FString                                 CharacterId;                                       // 0x0088(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Rank;                                              // 0x0098(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          EarlyLeave;                                        // 0x009C(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C09[0x3];                                     // 0x009D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<class FString, int32>                    Stats;                                             // 0x00A0(0x0050)(NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzProcessPostmatchResultPackage) == 0x000008, "Wrong alignment on FGzProcessPostmatchResultPackage");
static_assert(sizeof(FGzProcessPostmatchResultPackage) == 0x0000F0, "Wrong size on FGzProcessPostmatchResultPackage");
static_assert(offsetof(FGzProcessPostmatchResultPackage, CharacterId) == 0x000088, "Member 'FGzProcessPostmatchResultPackage::CharacterId' has a wrong offset!");
static_assert(offsetof(FGzProcessPostmatchResultPackage, Rank) == 0x000098, "Member 'FGzProcessPostmatchResultPackage::Rank' has a wrong offset!");
static_assert(offsetof(FGzProcessPostmatchResultPackage, EarlyLeave) == 0x00009C, "Member 'FGzProcessPostmatchResultPackage::EarlyLeave' has a wrong offset!");
static_assert(offsetof(FGzProcessPostmatchResultPackage, Stats) == 0x0000A0, "Member 'FGzProcessPostmatchResultPackage::Stats' has a wrong offset!");

// ScriptStruct G01.GzLevelRangeSettings
// 0x0010 (0x0010 - 0x0000)
struct FGzLevelRangeSettings final
{
public:
	int32                                         StartLevel;                                        // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         EndLevel;                                          // 0x0004(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Step;                                              // 0x0008(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         IncrementalStep;                                   // 0x000C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzLevelRangeSettings) == 0x000004, "Wrong alignment on FGzLevelRangeSettings");
static_assert(sizeof(FGzLevelRangeSettings) == 0x000010, "Wrong size on FGzLevelRangeSettings");
static_assert(offsetof(FGzLevelRangeSettings, StartLevel) == 0x000000, "Member 'FGzLevelRangeSettings::StartLevel' has a wrong offset!");
static_assert(offsetof(FGzLevelRangeSettings, EndLevel) == 0x000004, "Member 'FGzLevelRangeSettings::EndLevel' has a wrong offset!");
static_assert(offsetof(FGzLevelRangeSettings, Step) == 0x000008, "Member 'FGzLevelRangeSettings::Step' has a wrong offset!");
static_assert(offsetof(FGzLevelRangeSettings, IncrementalStep) == 0x00000C, "Member 'FGzLevelRangeSettings::IncrementalStep' has a wrong offset!");

// ScriptStruct G01.GzLevelSettings
// 0x0020 (0x0020 - 0x0000)
struct FGzLevelSettings final
{
public:
	struct FGuid                                  ID;                                                // 0x0000(0x0010)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         XpForNextLevel;                                    // 0x0010(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C0A[0x4];                                     // 0x0014(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UGzRewardData*                          Reward;                                            // 0x0018(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzLevelSettings) == 0x000008, "Wrong alignment on FGzLevelSettings");
static_assert(sizeof(FGzLevelSettings) == 0x000020, "Wrong size on FGzLevelSettings");
static_assert(offsetof(FGzLevelSettings, ID) == 0x000000, "Member 'FGzLevelSettings::ID' has a wrong offset!");
static_assert(offsetof(FGzLevelSettings, XpForNextLevel) == 0x000010, "Member 'FGzLevelSettings::XpForNextLevel' has a wrong offset!");
static_assert(offsetof(FGzLevelSettings, Reward) == 0x000018, "Member 'FGzLevelSettings::Reward' has a wrong offset!");

// ScriptStruct G01.GzPropagationPoint
// 0x0074 (0x0080 - 0x000C)
struct FGzPropagationPoint final : public FFastArraySerializerItem
{
public:
	uint8                                         Pad_2C0B[0x4];                                     // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector_NetQuantize                    Location;                                          // 0x0010(0x0018)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector_NetQuantizeNormal              Normal;                                            // 0x0028(0x0018)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EGzPropagationPointStatus                     CurrentStatus;                                     // 0x0040(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EGzPropagationPointStatus                     PreviousStatus;                                    // 0x0041(0x0001)(ZeroConstructor, IsPlainOldData, RepSkip, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C0C[0x6];                                     // 0x0042(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<TWeakObjectPtr<class UPrimitiveComponent>> CollisionComponents;                               // 0x0048(0x0010)(ExportObject, ZeroConstructor, RepSkip, ContainsInstancedReference, UObjectWrapper, NativeAccessSpecifierPublic)
	TArray<TWeakObjectPtr<class USceneComponent>> VisualComponents;                                  // 0x0058(0x0010)(ExportObject, ZeroConstructor, RepSkip, ContainsInstancedReference, UObjectWrapper, NativeAccessSpecifierPublic)
	float                                         LifeSpan;                                          // 0x0068(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C0D[0x14];                                    // 0x006C(0x0014)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGzPropagationPoint) == 0x000008, "Wrong alignment on FGzPropagationPoint");
static_assert(sizeof(FGzPropagationPoint) == 0x000080, "Wrong size on FGzPropagationPoint");
static_assert(offsetof(FGzPropagationPoint, Location) == 0x000010, "Member 'FGzPropagationPoint::Location' has a wrong offset!");
static_assert(offsetof(FGzPropagationPoint, Normal) == 0x000028, "Member 'FGzPropagationPoint::Normal' has a wrong offset!");
static_assert(offsetof(FGzPropagationPoint, CurrentStatus) == 0x000040, "Member 'FGzPropagationPoint::CurrentStatus' has a wrong offset!");
static_assert(offsetof(FGzPropagationPoint, PreviousStatus) == 0x000041, "Member 'FGzPropagationPoint::PreviousStatus' has a wrong offset!");
static_assert(offsetof(FGzPropagationPoint, CollisionComponents) == 0x000048, "Member 'FGzPropagationPoint::CollisionComponents' has a wrong offset!");
static_assert(offsetof(FGzPropagationPoint, VisualComponents) == 0x000058, "Member 'FGzPropagationPoint::VisualComponents' has a wrong offset!");
static_assert(offsetof(FGzPropagationPoint, LifeSpan) == 0x000068, "Member 'FGzPropagationPoint::LifeSpan' has a wrong offset!");

// ScriptStruct G01.GzPropagationPointArray
// 0x0018 (0x0128 - 0x0110)
struct FGzPropagationPointArray final : public FFastArraySerializer
{
public:
	class AGzPropagationActor*                    PropagationParent;                                 // 0x0110(0x0008)(ZeroConstructor, RepSkip, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FGzPropagationPoint>            Items;                                             // 0x0118(0x0010)(ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzPropagationPointArray) == 0x000008, "Wrong alignment on FGzPropagationPointArray");
static_assert(sizeof(FGzPropagationPointArray) == 0x000128, "Wrong size on FGzPropagationPointArray");
static_assert(offsetof(FGzPropagationPointArray, PropagationParent) == 0x000110, "Member 'FGzPropagationPointArray::PropagationParent' has a wrong offset!");
static_assert(offsetof(FGzPropagationPointArray, Items) == 0x000118, "Member 'FGzPropagationPointArray::Items' has a wrong offset!");

// ScriptStruct G01.PropagatedTile
// 0x0038 (0x0038 - 0x0000)
struct FPropagatedTile final
{
public:
	uint8                                         Pad_2C0E[0x8];                                     // 0x0000(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class AActor*                                 Actor;                                             // 0x0008(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C0F[0x28];                                    // 0x0010(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FPropagatedTile) == 0x000008, "Wrong alignment on FPropagatedTile");
static_assert(sizeof(FPropagatedTile) == 0x000038, "Wrong size on FPropagatedTile");
static_assert(offsetof(FPropagatedTile, Actor) == 0x000008, "Member 'FPropagatedTile::Actor' has a wrong offset!");

// ScriptStruct G01.GzQuickOrderArrivalData
// 0x000C (0x000C - 0x0000)
struct FGzQuickOrderArrivalData final
{
public:
	int32                                         MarkerId;                                          // 0x0000(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         TeamID;                                            // 0x0004(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ArrivalTime;                                       // 0x0008(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
};
static_assert(alignof(FGzQuickOrderArrivalData) == 0x000004, "Wrong alignment on FGzQuickOrderArrivalData");
static_assert(sizeof(FGzQuickOrderArrivalData) == 0x00000C, "Wrong size on FGzQuickOrderArrivalData");
static_assert(offsetof(FGzQuickOrderArrivalData, MarkerId) == 0x000000, "Member 'FGzQuickOrderArrivalData::MarkerId' has a wrong offset!");
static_assert(offsetof(FGzQuickOrderArrivalData, TeamID) == 0x000004, "Member 'FGzQuickOrderArrivalData::TeamID' has a wrong offset!");
static_assert(offsetof(FGzQuickOrderArrivalData, ArrivalTime) == 0x000008, "Member 'FGzQuickOrderArrivalData::ArrivalTime' has a wrong offset!");

// ScriptStruct G01.GzHitReport
// 0x0040 (0x0040 - 0x0000)
struct FGzHitReport final
{
public:
	uint8                                         ShotID;                                            // 0x0000(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C10[0x3];                                     // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Time;                                              // 0x0004(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector_NetQuantize                    TraceStart;                                        // 0x0008(0x0018)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FGzNetHitData>                  HitDataList;                                       // 0x0020(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FHitResult>                     NonReplicatedConstructionCache;                    // 0x0030(0x0010)(ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzHitReport) == 0x000008, "Wrong alignment on FGzHitReport");
static_assert(sizeof(FGzHitReport) == 0x000040, "Wrong size on FGzHitReport");
static_assert(offsetof(FGzHitReport, ShotID) == 0x000000, "Member 'FGzHitReport::ShotID' has a wrong offset!");
static_assert(offsetof(FGzHitReport, Time) == 0x000004, "Member 'FGzHitReport::Time' has a wrong offset!");
static_assert(offsetof(FGzHitReport, TraceStart) == 0x000008, "Member 'FGzHitReport::TraceStart' has a wrong offset!");
static_assert(offsetof(FGzHitReport, HitDataList) == 0x000020, "Member 'FGzHitReport::HitDataList' has a wrong offset!");
static_assert(offsetof(FGzHitReport, NonReplicatedConstructionCache) == 0x000030, "Member 'FGzHitReport::NonReplicatedConstructionCache' has a wrong offset!");

// ScriptStruct G01.GzHitImpactData
// 0x0018 (0x0018 - 0x0000)
struct FGzHitImpactData final
{
public:
	TArray<struct FGzHitReport>                   HitReports;                                        // 0x0000(0x0010)(ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	TSubclassOf<class UGzGE_BaseDamage>           AttackDamageEffect;                                // 0x0010(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzHitImpactData) == 0x000008, "Wrong alignment on FGzHitImpactData");
static_assert(sizeof(FGzHitImpactData) == 0x000018, "Wrong size on FGzHitImpactData");
static_assert(offsetof(FGzHitImpactData, HitReports) == 0x000000, "Member 'FGzHitImpactData::HitReports' has a wrong offset!");
static_assert(offsetof(FGzHitImpactData, AttackDamageEffect) == 0x000010, "Member 'FGzHitImpactData::AttackDamageEffect' has a wrong offset!");

// ScriptStruct G01.GzProjectileImpactData
// 0x0028 (0x0028 - 0x0000)
struct FGzProjectileImpactData final
{
public:
	struct FVector                                Location;                                          // 0x0000(0x0018)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ExplosionRadius;                                   // 0x0018(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C11[0x4];                                     // 0x001C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UGzGE_BaseDamage>           AttackDamageEffect;                                // 0x0020(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzProjectileImpactData) == 0x000008, "Wrong alignment on FGzProjectileImpactData");
static_assert(sizeof(FGzProjectileImpactData) == 0x000028, "Wrong size on FGzProjectileImpactData");
static_assert(offsetof(FGzProjectileImpactData, Location) == 0x000000, "Member 'FGzProjectileImpactData::Location' has a wrong offset!");
static_assert(offsetof(FGzProjectileImpactData, ExplosionRadius) == 0x000018, "Member 'FGzProjectileImpactData::ExplosionRadius' has a wrong offset!");
static_assert(offsetof(FGzProjectileImpactData, AttackDamageEffect) == 0x000020, "Member 'FGzProjectileImpactData::AttackDamageEffect' has a wrong offset!");

// ScriptStruct G01.GzReconDrone_Gadjet_InitInfo
// 0x000C (0x000C - 0x0000)
struct FGzReconDrone_Gadjet_InitInfo final
{
public:
	float                                         MaxHP;                                             // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         GadjetLifeTime;                                    // 0x0004(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         GadjetFieldRadius;                                 // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzReconDrone_Gadjet_InitInfo) == 0x000004, "Wrong alignment on FGzReconDrone_Gadjet_InitInfo");
static_assert(sizeof(FGzReconDrone_Gadjet_InitInfo) == 0x00000C, "Wrong size on FGzReconDrone_Gadjet_InitInfo");
static_assert(offsetof(FGzReconDrone_Gadjet_InitInfo, MaxHP) == 0x000000, "Member 'FGzReconDrone_Gadjet_InitInfo::MaxHP' has a wrong offset!");
static_assert(offsetof(FGzReconDrone_Gadjet_InitInfo, GadjetLifeTime) == 0x000004, "Member 'FGzReconDrone_Gadjet_InitInfo::GadjetLifeTime' has a wrong offset!");
static_assert(offsetof(FGzReconDrone_Gadjet_InitInfo, GadjetFieldRadius) == 0x000008, "Member 'FGzReconDrone_Gadjet_InitInfo::GadjetFieldRadius' has a wrong offset!");

// ScriptStruct G01.GzReconDrone_RevealInfo
// 0x0010 (0x0010 - 0x0000)
struct FGzReconDrone_RevealInfo final
{
public:
	int32                                         ReconAffectedActorMarkerId;                        // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FActiveGameplayEffectHandle            CachedRevealEffect;                                // 0x0004(0x0008)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LeftedTime;                                        // 0x000C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzReconDrone_RevealInfo) == 0x000004, "Wrong alignment on FGzReconDrone_RevealInfo");
static_assert(sizeof(FGzReconDrone_RevealInfo) == 0x000010, "Wrong size on FGzReconDrone_RevealInfo");
static_assert(offsetof(FGzReconDrone_RevealInfo, ReconAffectedActorMarkerId) == 0x000000, "Member 'FGzReconDrone_RevealInfo::ReconAffectedActorMarkerId' has a wrong offset!");
static_assert(offsetof(FGzReconDrone_RevealInfo, CachedRevealEffect) == 0x000004, "Member 'FGzReconDrone_RevealInfo::CachedRevealEffect' has a wrong offset!");
static_assert(offsetof(FGzReconDrone_RevealInfo, LeftedTime) == 0x00000C, "Member 'FGzReconDrone_RevealInfo::LeftedTime' has a wrong offset!");

// ScriptStruct G01.GzRemoveServerPackage
// 0x0010 (0x0078 - 0x0068)
struct FGzRemoveServerPackage final : public FGzPlayFabClientPackage
{
public:
	class FString                                 Name;                                              // 0x0068(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzRemoveServerPackage) == 0x000008, "Wrong alignment on FGzRemoveServerPackage");
static_assert(sizeof(FGzRemoveServerPackage) == 0x000078, "Wrong size on FGzRemoveServerPackage");
static_assert(offsetof(FGzRemoveServerPackage, Name) == 0x000068, "Member 'FGzRemoveServerPackage::Name' has a wrong offset!");

// ScriptStruct G01.GzRenameCharacterPackage
// 0x0020 (0x0088 - 0x0068)
struct FGzRenameCharacterPackage final : public FGzPlayFabClientPackage
{
public:
	class FString                                 CharacterId;                                       // 0x0068(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 CharacterName;                                     // 0x0078(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzRenameCharacterPackage) == 0x000008, "Wrong alignment on FGzRenameCharacterPackage");
static_assert(sizeof(FGzRenameCharacterPackage) == 0x000088, "Wrong size on FGzRenameCharacterPackage");
static_assert(offsetof(FGzRenameCharacterPackage, CharacterId) == 0x000068, "Member 'FGzRenameCharacterPackage::CharacterId' has a wrong offset!");
static_assert(offsetof(FGzRenameCharacterPackage, CharacterName) == 0x000078, "Member 'FGzRenameCharacterPackage::CharacterName' has a wrong offset!");

// ScriptStruct G01.GzItemSetting
// 0x0038 (0x0038 - 0x0000)
struct FGzItemSetting final
{
public:
	struct FVector                                Location;                                          // 0x0000(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Rotation;                                          // 0x0018(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	double                                        Size;                                              // 0x0030(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzItemSetting) == 0x000008, "Wrong alignment on FGzItemSetting");
static_assert(sizeof(FGzItemSetting) == 0x000038, "Wrong size on FGzItemSetting");
static_assert(offsetof(FGzItemSetting, Location) == 0x000000, "Member 'FGzItemSetting::Location' has a wrong offset!");
static_assert(offsetof(FGzItemSetting, Rotation) == 0x000018, "Member 'FGzItemSetting::Rotation' has a wrong offset!");
static_assert(offsetof(FGzItemSetting, Size) == 0x000030, "Member 'FGzItemSetting::Size' has a wrong offset!");

// ScriptStruct G01.GzWeaponSetting
// 0x0008 (0x0050 - 0x0048)
struct FGzWeaponSetting final : public FGzWeaponAttachmentSetting
{
public:
	double                                        WeaponSizeMultiplier;                              // 0x0048(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzWeaponSetting) == 0x000008, "Wrong alignment on FGzWeaponSetting");
static_assert(sizeof(FGzWeaponSetting) == 0x000050, "Wrong size on FGzWeaponSetting");
static_assert(offsetof(FGzWeaponSetting, WeaponSizeMultiplier) == 0x000048, "Member 'FGzWeaponSetting::WeaponSizeMultiplier' has a wrong offset!");

// ScriptStruct G01.GzWeaponSetupSetting
// 0x0030 (0x0030 - 0x0000)
struct FGzWeaponSetupSetting final
{
public:
	struct FVector                                WeaponPositionRotation;                            // 0x0000(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                CameraOffset;                                      // 0x0018(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzWeaponSetupSetting) == 0x000008, "Wrong alignment on FGzWeaponSetupSetting");
static_assert(sizeof(FGzWeaponSetupSetting) == 0x000030, "Wrong size on FGzWeaponSetupSetting");
static_assert(offsetof(FGzWeaponSetupSetting, WeaponPositionRotation) == 0x000000, "Member 'FGzWeaponSetupSetting::WeaponPositionRotation' has a wrong offset!");
static_assert(offsetof(FGzWeaponSetupSetting, CameraOffset) == 0x000018, "Member 'FGzWeaponSetupSetting::CameraOffset' has a wrong offset!");

// ScriptStruct G01.GzConnectionAlwaysRelevantNodePair
// 0x0010 (0x0010 - 0x0000)
struct FGzConnectionAlwaysRelevantNodePair final
{
public:
	class UNetConnection*                         NetConnection;                                     // 0x0000(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UReplicationGraphNode_AlwaysRelevant_ForConnection* Node;                                              // 0x0008(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzConnectionAlwaysRelevantNodePair) == 0x000008, "Wrong alignment on FGzConnectionAlwaysRelevantNodePair");
static_assert(sizeof(FGzConnectionAlwaysRelevantNodePair) == 0x000010, "Wrong size on FGzConnectionAlwaysRelevantNodePair");
static_assert(offsetof(FGzConnectionAlwaysRelevantNodePair, NetConnection) == 0x000000, "Member 'FGzConnectionAlwaysRelevantNodePair::NetConnection' has a wrong offset!");
static_assert(offsetof(FGzConnectionAlwaysRelevantNodePair, Node) == 0x000008, "Member 'FGzConnectionAlwaysRelevantNodePair::Node' has a wrong offset!");

// ScriptStruct G01.GzResetPlayerAccountPackage
// 0x0000 (0x0068 - 0x0068)
struct FGzResetPlayerAccountPackage final : public FGzPlayFabClientPackage
{
};
static_assert(alignof(FGzResetPlayerAccountPackage) == 0x000008, "Wrong alignment on FGzResetPlayerAccountPackage");
static_assert(sizeof(FGzResetPlayerAccountPackage) == 0x000068, "Wrong size on FGzResetPlayerAccountPackage");

// ScriptStruct G01.GzRevokeItemsPackage
// 0x0010 (0x0078 - 0x0068)
struct FGzRevokeItemsPackage final : public FGzPlayFabClientPackage
{
public:
	TArray<class FString>                         ItemInstanceIds;                                   // 0x0068(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzRevokeItemsPackage) == 0x000008, "Wrong alignment on FGzRevokeItemsPackage");
static_assert(sizeof(FGzRevokeItemsPackage) == 0x000078, "Wrong size on FGzRevokeItemsPackage");
static_assert(offsetof(FGzRevokeItemsPackage, ItemInstanceIds) == 0x000068, "Member 'FGzRevokeItemsPackage::ItemInstanceIds' has a wrong offset!");

// ScriptStruct G01.GzExpirableItemData
// 0x0018 (0x0018 - 0x0000)
struct FGzExpirableItemData final
{
public:
	bool                                          CanExpire;                                         // 0x0000(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C12[0x3];                                     // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         ExpirationDays;                                    // 0x0004(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ExpirationHours;                                   // 0x0008(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C13[0x4];                                     // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UGzContainerItemData*                   Item;                                              // 0x0010(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzExpirableItemData) == 0x000008, "Wrong alignment on FGzExpirableItemData");
static_assert(sizeof(FGzExpirableItemData) == 0x000018, "Wrong size on FGzExpirableItemData");
static_assert(offsetof(FGzExpirableItemData, CanExpire) == 0x000000, "Member 'FGzExpirableItemData::CanExpire' has a wrong offset!");
static_assert(offsetof(FGzExpirableItemData, ExpirationDays) == 0x000004, "Member 'FGzExpirableItemData::ExpirationDays' has a wrong offset!");
static_assert(offsetof(FGzExpirableItemData, ExpirationHours) == 0x000008, "Member 'FGzExpirableItemData::ExpirationHours' has a wrong offset!");
static_assert(offsetof(FGzExpirableItemData, Item) == 0x000010, "Member 'FGzExpirableItemData::Item' has a wrong offset!");

// ScriptStruct G01.GzProcessPostmatchResultResult
// 0x0000 (0x00E0 - 0x00E0)
struct FGzProcessPostmatchResultResult final : public FGzPlayFabResultBase
{
};
static_assert(alignof(FGzProcessPostmatchResultResult) == 0x000008, "Wrong alignment on FGzProcessPostmatchResultResult");
static_assert(sizeof(FGzProcessPostmatchResultResult) == 0x0000E0, "Wrong size on FGzProcessPostmatchResultResult");

// ScriptStruct G01.GzSessionData
// 0x0048 (0x0048 - 0x0000)
struct FGzSessionData final
{
public:
	class FString                                 SessionTicket;                                     // 0x0000(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 EntityToken;                                       // 0x0010(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int64                                         SessionTicketExpireTime;                           // 0x0020(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 MasterAccountId;                                   // 0x0028(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 TitleAccountId;                                    // 0x0038(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzSessionData) == 0x000008, "Wrong alignment on FGzSessionData");
static_assert(sizeof(FGzSessionData) == 0x000048, "Wrong size on FGzSessionData");
static_assert(offsetof(FGzSessionData, SessionTicket) == 0x000000, "Member 'FGzSessionData::SessionTicket' has a wrong offset!");
static_assert(offsetof(FGzSessionData, EntityToken) == 0x000010, "Member 'FGzSessionData::EntityToken' has a wrong offset!");
static_assert(offsetof(FGzSessionData, SessionTicketExpireTime) == 0x000020, "Member 'FGzSessionData::SessionTicketExpireTime' has a wrong offset!");
static_assert(offsetof(FGzSessionData, MasterAccountId) == 0x000028, "Member 'FGzSessionData::MasterAccountId' has a wrong offset!");
static_assert(offsetof(FGzSessionData, TitleAccountId) == 0x000038, "Member 'FGzSessionData::TitleAccountId' has a wrong offset!");

// ScriptStruct G01.GzSavedCredentials
// 0x00B0 (0x00B0 - 0x0000)
struct FGzSavedCredentials final
{
public:
	class FString                                 PrevLoggedUsername;                                // 0x0000(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMap<class FString, class FString>            SavedCredentials;                                  // 0x0010(0x0050)(NativeAccessSpecifierPublic)
	TMap<class FString, struct FGzSessionData>    UserSessions;                                      // 0x0060(0x0050)(NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzSavedCredentials) == 0x000008, "Wrong alignment on FGzSavedCredentials");
static_assert(sizeof(FGzSavedCredentials) == 0x0000B0, "Wrong size on FGzSavedCredentials");
static_assert(offsetof(FGzSavedCredentials, PrevLoggedUsername) == 0x000000, "Member 'FGzSavedCredentials::PrevLoggedUsername' has a wrong offset!");
static_assert(offsetof(FGzSavedCredentials, SavedCredentials) == 0x000010, "Member 'FGzSavedCredentials::SavedCredentials' has a wrong offset!");
static_assert(offsetof(FGzSavedCredentials, UserSessions) == 0x000060, "Member 'FGzSavedCredentials::UserSessions' has a wrong offset!");

// ScriptStruct G01.GzViewerSceneSetup
// 0x0010 (0x0018 - 0x0008)
struct FGzViewerSceneSetup : public FGzSceneSetupBase
{
public:
	struct FGzDefaultViewerSetup                  Viewer;                                            // 0x0008(0x0010)(Edit, DisableEditOnTemplate, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzViewerSceneSetup) == 0x000008, "Wrong alignment on FGzViewerSceneSetup");
static_assert(sizeof(FGzViewerSceneSetup) == 0x000018, "Wrong size on FGzViewerSceneSetup");
static_assert(offsetof(FGzViewerSceneSetup, Viewer) == 0x000008, "Member 'FGzViewerSceneSetup::Viewer' has a wrong offset!");

// ScriptStruct G01.GzCharacterViewerSceneSetup
// 0x0008 (0x0020 - 0x0018)
struct FGzCharacterViewerSceneSetup final : public FGzViewerSceneSetup
{
public:
	struct FGzCharacterSetup                      Character;                                         // 0x0018(0x0008)(Edit, DisableEditOnTemplate, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzCharacterViewerSceneSetup) == 0x000008, "Wrong alignment on FGzCharacterViewerSceneSetup");
static_assert(sizeof(FGzCharacterViewerSceneSetup) == 0x000020, "Wrong size on FGzCharacterViewerSceneSetup");
static_assert(offsetof(FGzCharacterViewerSceneSetup, Character) == 0x000018, "Member 'FGzCharacterViewerSceneSetup::Character' has a wrong offset!");

// ScriptStruct G01.GzLimbViewerSceneSetup
// 0x0028 (0x0030 - 0x0008)
struct FGzLimbViewerSceneSetup final : public FGzSceneSetupBase
{
public:
	struct FGzLimbViewerSetup                     Viewer;                                            // 0x0008(0x0028)(Edit, DisableEditOnTemplate, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzLimbViewerSceneSetup) == 0x000008, "Wrong alignment on FGzLimbViewerSceneSetup");
static_assert(sizeof(FGzLimbViewerSceneSetup) == 0x000030, "Wrong size on FGzLimbViewerSceneSetup");
static_assert(offsetof(FGzLimbViewerSceneSetup, Viewer) == 0x000008, "Member 'FGzLimbViewerSceneSetup::Viewer' has a wrong offset!");

// ScriptStruct G01.GzWeaponViewmakerSceneSetup
// 0x0210 (0x0218 - 0x0008)
struct FGzWeaponViewmakerSceneSetup final : public FGzSceneSetupBase
{
public:
	struct FGzWeaponViewmakerSetup                Viewmaker;                                         // 0x0008(0x0210)(Edit, DisableEditOnTemplate, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzWeaponViewmakerSceneSetup) == 0x000008, "Wrong alignment on FGzWeaponViewmakerSceneSetup");
static_assert(sizeof(FGzWeaponViewmakerSceneSetup) == 0x000218, "Wrong size on FGzWeaponViewmakerSceneSetup");
static_assert(offsetof(FGzWeaponViewmakerSceneSetup, Viewmaker) == 0x000008, "Member 'FGzWeaponViewmakerSceneSetup::Viewmaker' has a wrong offset!");

// ScriptStruct G01.GzSearchZoneSpec
// 0x0048 (0x0048 - 0x0000)
struct FGzSearchZoneSpec final
{
public:
	float                                         MaxRadius;                                         // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinRadius;                                         // 0x0004(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxRangeSquared;                                   // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinRangeSquared;                                   // 0x000C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftClassPtr<class UClass>                   SearchZoneActorClass;                              // 0x0010(0x0028)(Edit, BlueprintVisible, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EGzSearchZoneGroupType                        GroupType;                                         // 0x0038(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C14[0x3];                                     // 0x0039(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         UpdateFrequency;                                   // 0x003C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEnsureTargetHostile;                              // 0x0040(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAssignByDistance;                                 // 0x0041(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C15[0x6];                                     // 0x0042(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGzSearchZoneSpec) == 0x000008, "Wrong alignment on FGzSearchZoneSpec");
static_assert(sizeof(FGzSearchZoneSpec) == 0x000048, "Wrong size on FGzSearchZoneSpec");
static_assert(offsetof(FGzSearchZoneSpec, MaxRadius) == 0x000000, "Member 'FGzSearchZoneSpec::MaxRadius' has a wrong offset!");
static_assert(offsetof(FGzSearchZoneSpec, MinRadius) == 0x000004, "Member 'FGzSearchZoneSpec::MinRadius' has a wrong offset!");
static_assert(offsetof(FGzSearchZoneSpec, MaxRangeSquared) == 0x000008, "Member 'FGzSearchZoneSpec::MaxRangeSquared' has a wrong offset!");
static_assert(offsetof(FGzSearchZoneSpec, MinRangeSquared) == 0x00000C, "Member 'FGzSearchZoneSpec::MinRangeSquared' has a wrong offset!");
static_assert(offsetof(FGzSearchZoneSpec, SearchZoneActorClass) == 0x000010, "Member 'FGzSearchZoneSpec::SearchZoneActorClass' has a wrong offset!");
static_assert(offsetof(FGzSearchZoneSpec, GroupType) == 0x000038, "Member 'FGzSearchZoneSpec::GroupType' has a wrong offset!");
static_assert(offsetof(FGzSearchZoneSpec, UpdateFrequency) == 0x00003C, "Member 'FGzSearchZoneSpec::UpdateFrequency' has a wrong offset!");
static_assert(offsetof(FGzSearchZoneSpec, bEnsureTargetHostile) == 0x000040, "Member 'FGzSearchZoneSpec::bEnsureTargetHostile' has a wrong offset!");
static_assert(offsetof(FGzSearchZoneSpec, bAssignByDistance) == 0x000041, "Member 'FGzSearchZoneSpec::bAssignByDistance' has a wrong offset!");

// ScriptStruct G01.GzSearchZoneServerRuntimeInfo
// 0x00B0 (0x00B0 - 0x0000)
struct FGzSearchZoneServerRuntimeInfo final
{
public:
	TMap<int32, struct FGzSearchZoneWorldData>    ZoneWatchers;                                      // 0x0000(0x0050)(Transient, NativeAccessSpecifierPublic)
	struct FGzSearchZoneSpec                      SearchZoneSpec;                                    // 0x0050(0x0048)(Transient, NativeAccessSpecifierPublic)
	int32                                         SearchZoneTypeId;                                  // 0x0098(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SearchZoneId;                                      // 0x009C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 TargetActor;                                       // 0x00A0(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C16[0x8];                                     // 0x00A8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGzSearchZoneServerRuntimeInfo) == 0x000008, "Wrong alignment on FGzSearchZoneServerRuntimeInfo");
static_assert(sizeof(FGzSearchZoneServerRuntimeInfo) == 0x0000B0, "Wrong size on FGzSearchZoneServerRuntimeInfo");
static_assert(offsetof(FGzSearchZoneServerRuntimeInfo, ZoneWatchers) == 0x000000, "Member 'FGzSearchZoneServerRuntimeInfo::ZoneWatchers' has a wrong offset!");
static_assert(offsetof(FGzSearchZoneServerRuntimeInfo, SearchZoneSpec) == 0x000050, "Member 'FGzSearchZoneServerRuntimeInfo::SearchZoneSpec' has a wrong offset!");
static_assert(offsetof(FGzSearchZoneServerRuntimeInfo, SearchZoneTypeId) == 0x000098, "Member 'FGzSearchZoneServerRuntimeInfo::SearchZoneTypeId' has a wrong offset!");
static_assert(offsetof(FGzSearchZoneServerRuntimeInfo, SearchZoneId) == 0x00009C, "Member 'FGzSearchZoneServerRuntimeInfo::SearchZoneId' has a wrong offset!");
static_assert(offsetof(FGzSearchZoneServerRuntimeInfo, TargetActor) == 0x0000A0, "Member 'FGzSearchZoneServerRuntimeInfo::TargetActor' has a wrong offset!");

// ScriptStruct G01.GzSendFriendInvitationPackage
// 0x0010 (0x0078 - 0x0068)
struct FGzSendFriendInvitationPackage final : public FGzPlayFabClientPackage
{
public:
	class FString                                 FriendPlayFabId;                                   // 0x0068(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzSendFriendInvitationPackage) == 0x000008, "Wrong alignment on FGzSendFriendInvitationPackage");
static_assert(sizeof(FGzSendFriendInvitationPackage) == 0x000078, "Wrong size on FGzSendFriendInvitationPackage");
static_assert(offsetof(FGzSendFriendInvitationPackage, FriendPlayFabId) == 0x000068, "Member 'FGzSendFriendInvitationPackage::FriendPlayFabId' has a wrong offset!");

// ScriptStruct G01.GzSerializableUserDataFlags
// 0x0003 (0x0003 - 0x0000)
struct FGzSerializableUserDataFlags final
{
public:
	bool                                          bWelcomeMessageSeen;                               // 0x0000(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bInitialSettingsConfigurationDone;                 // 0x0001(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bWasRedirectedToOtgPro;                            // 0x0002(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzSerializableUserDataFlags) == 0x000001, "Wrong alignment on FGzSerializableUserDataFlags");
static_assert(sizeof(FGzSerializableUserDataFlags) == 0x000003, "Wrong size on FGzSerializableUserDataFlags");
static_assert(offsetof(FGzSerializableUserDataFlags, bWelcomeMessageSeen) == 0x000000, "Member 'FGzSerializableUserDataFlags::bWelcomeMessageSeen' has a wrong offset!");
static_assert(offsetof(FGzSerializableUserDataFlags, bInitialSettingsConfigurationDone) == 0x000001, "Member 'FGzSerializableUserDataFlags::bInitialSettingsConfigurationDone' has a wrong offset!");
static_assert(offsetof(FGzSerializableUserDataFlags, bWasRedirectedToOtgPro) == 0x000002, "Member 'FGzSerializableUserDataFlags::bWasRedirectedToOtgPro' has a wrong offset!");

// ScriptStruct G01.GzServerAuthenticationInfo
// 0x0020 (0x0020 - 0x0000)
struct alignas(0x08) FGzServerAuthenticationInfo final
{
public:
	uint8                                         Pad_2C17[0x20];                                    // 0x0000(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGzServerAuthenticationInfo) == 0x000008, "Wrong alignment on FGzServerAuthenticationInfo");
static_assert(sizeof(FGzServerAuthenticationInfo) == 0x000020, "Wrong size on FGzServerAuthenticationInfo");

// ScriptStruct G01.GzConsoleMatchPackage
// 0x0010 (0x0078 - 0x0068)
struct FGzConsoleMatchPackage : public FGzPlayFabClientPackage
{
public:
	class FString                                 MatchID;                                           // 0x0068(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzConsoleMatchPackage) == 0x000008, "Wrong alignment on FGzConsoleMatchPackage");
static_assert(sizeof(FGzConsoleMatchPackage) == 0x000078, "Wrong size on FGzConsoleMatchPackage");
static_assert(offsetof(FGzConsoleMatchPackage, MatchID) == 0x000068, "Member 'FGzConsoleMatchPackage::MatchID' has a wrong offset!");

// ScriptStruct G01.GzConsoleEndMatchPlayerResult
// 0x0018 (0x0018 - 0x0000)
struct FGzConsoleEndMatchPlayerResult final
{
public:
	class FString                                 PlayerId;                                          // 0x0000(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Rank;                                              // 0x0010(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C18[0x4];                                     // 0x0014(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGzConsoleEndMatchPlayerResult) == 0x000008, "Wrong alignment on FGzConsoleEndMatchPlayerResult");
static_assert(sizeof(FGzConsoleEndMatchPlayerResult) == 0x000018, "Wrong size on FGzConsoleEndMatchPlayerResult");
static_assert(offsetof(FGzConsoleEndMatchPlayerResult, PlayerId) == 0x000000, "Member 'FGzConsoleEndMatchPlayerResult::PlayerId' has a wrong offset!");
static_assert(offsetof(FGzConsoleEndMatchPlayerResult, Rank) == 0x000010, "Member 'FGzConsoleEndMatchPlayerResult::Rank' has a wrong offset!");

// ScriptStruct G01.GzConsoleEndMatchPackage
// 0x0010 (0x0088 - 0x0078)
struct FGzConsoleEndMatchPackage final : public FGzConsoleMatchPackage
{
public:
	TArray<struct FGzConsoleEndMatchPlayerResult> PlayerResults;                                     // 0x0078(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzConsoleEndMatchPackage) == 0x000008, "Wrong alignment on FGzConsoleEndMatchPackage");
static_assert(sizeof(FGzConsoleEndMatchPackage) == 0x000088, "Wrong size on FGzConsoleEndMatchPackage");
static_assert(offsetof(FGzConsoleEndMatchPackage, PlayerResults) == 0x000078, "Member 'FGzConsoleEndMatchPackage::PlayerResults' has a wrong offset!");

// ScriptStruct G01.GzConsoleBeginMatchResult
// 0x0000 (0x00E0 - 0x00E0)
struct FGzConsoleBeginMatchResult final : public FGzPlayFabResultBase
{
};
static_assert(alignof(FGzConsoleBeginMatchResult) == 0x000008, "Wrong alignment on FGzConsoleBeginMatchResult");
static_assert(sizeof(FGzConsoleBeginMatchResult) == 0x0000E0, "Wrong size on FGzConsoleBeginMatchResult");

// ScriptStruct G01.GzConsoleEndMatchResult
// 0x0000 (0x00E0 - 0x00E0)
struct FGzConsoleEndMatchResult final : public FGzPlayFabResultBase
{
};
static_assert(alignof(FGzConsoleEndMatchResult) == 0x000008, "Wrong alignment on FGzConsoleEndMatchResult");
static_assert(sizeof(FGzConsoleEndMatchResult) == 0x0000E0, "Wrong size on FGzConsoleEndMatchResult");

// ScriptStruct G01.GzServerDamageInfo
// 0x0018 (0x0018 - 0x0000)
struct FGzServerDamageInfo final
{
public:
	class AActor*                                 Damager;                                           // 0x0000(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EGzDamageIndicatorType                        Type;                                              // 0x0008(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         DamagePercent;                                     // 0x0009(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsCrit;                                           // 0x000A(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsDirectional;                                    // 0x000B(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           DamageSource;                                      // 0x000C(0x0008)(BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EGzCharacterDamageAreaType                    DamagedArea;                                       // 0x0014(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C19[0x3];                                     // 0x0015(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGzServerDamageInfo) == 0x000008, "Wrong alignment on FGzServerDamageInfo");
static_assert(sizeof(FGzServerDamageInfo) == 0x000018, "Wrong size on FGzServerDamageInfo");
static_assert(offsetof(FGzServerDamageInfo, Damager) == 0x000000, "Member 'FGzServerDamageInfo::Damager' has a wrong offset!");
static_assert(offsetof(FGzServerDamageInfo, Type) == 0x000008, "Member 'FGzServerDamageInfo::Type' has a wrong offset!");
static_assert(offsetof(FGzServerDamageInfo, DamagePercent) == 0x000009, "Member 'FGzServerDamageInfo::DamagePercent' has a wrong offset!");
static_assert(offsetof(FGzServerDamageInfo, bIsCrit) == 0x00000A, "Member 'FGzServerDamageInfo::bIsCrit' has a wrong offset!");
static_assert(offsetof(FGzServerDamageInfo, bIsDirectional) == 0x00000B, "Member 'FGzServerDamageInfo::bIsDirectional' has a wrong offset!");
static_assert(offsetof(FGzServerDamageInfo, DamageSource) == 0x00000C, "Member 'FGzServerDamageInfo::DamageSource' has a wrong offset!");
static_assert(offsetof(FGzServerDamageInfo, DamagedArea) == 0x000014, "Member 'FGzServerDamageInfo::DamagedArea' has a wrong offset!");

// ScriptStruct G01.GzServerDetails
// 0x0090 (0x0090 - 0x0000)
struct FGzServerDetails final
{
public:
	class FString                                 ServerName;                                        // 0x0000(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Ip;                                                // 0x0010(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint32                                        Port;                                              // 0x0020(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C1A[0x4];                                     // 0x0024(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 Platform;                                          // 0x0028(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 BranchName;                                        // 0x0038(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint32                                        Changelist;                                        // 0x0048(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C1B[0x4];                                     // 0x004C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 MapName;                                           // 0x0050(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 GameMode;                                          // 0x0060(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 MatchState;                                        // 0x0070(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint32                                        PlayerCount;                                       // 0x0080(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint32                                        MaxPlayerCount;                                    // 0x0084(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCanAcceptNewPlayers;                              // 0x0088(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EGzServerConnectionAvailability               ConnectionAvailability;                            // 0x0089(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EGzServerUnavailabilityReason                 UnavailabilityReason;                              // 0x008A(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C1C[0x5];                                     // 0x008B(0x0005)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGzServerDetails) == 0x000008, "Wrong alignment on FGzServerDetails");
static_assert(sizeof(FGzServerDetails) == 0x000090, "Wrong size on FGzServerDetails");
static_assert(offsetof(FGzServerDetails, ServerName) == 0x000000, "Member 'FGzServerDetails::ServerName' has a wrong offset!");
static_assert(offsetof(FGzServerDetails, Ip) == 0x000010, "Member 'FGzServerDetails::Ip' has a wrong offset!");
static_assert(offsetof(FGzServerDetails, Port) == 0x000020, "Member 'FGzServerDetails::Port' has a wrong offset!");
static_assert(offsetof(FGzServerDetails, Platform) == 0x000028, "Member 'FGzServerDetails::Platform' has a wrong offset!");
static_assert(offsetof(FGzServerDetails, BranchName) == 0x000038, "Member 'FGzServerDetails::BranchName' has a wrong offset!");
static_assert(offsetof(FGzServerDetails, Changelist) == 0x000048, "Member 'FGzServerDetails::Changelist' has a wrong offset!");
static_assert(offsetof(FGzServerDetails, MapName) == 0x000050, "Member 'FGzServerDetails::MapName' has a wrong offset!");
static_assert(offsetof(FGzServerDetails, GameMode) == 0x000060, "Member 'FGzServerDetails::GameMode' has a wrong offset!");
static_assert(offsetof(FGzServerDetails, MatchState) == 0x000070, "Member 'FGzServerDetails::MatchState' has a wrong offset!");
static_assert(offsetof(FGzServerDetails, PlayerCount) == 0x000080, "Member 'FGzServerDetails::PlayerCount' has a wrong offset!");
static_assert(offsetof(FGzServerDetails, MaxPlayerCount) == 0x000084, "Member 'FGzServerDetails::MaxPlayerCount' has a wrong offset!");
static_assert(offsetof(FGzServerDetails, bCanAcceptNewPlayers) == 0x000088, "Member 'FGzServerDetails::bCanAcceptNewPlayers' has a wrong offset!");
static_assert(offsetof(FGzServerDetails, ConnectionAvailability) == 0x000089, "Member 'FGzServerDetails::ConnectionAvailability' has a wrong offset!");
static_assert(offsetof(FGzServerDetails, UnavailabilityReason) == 0x00008A, "Member 'FGzServerDetails::UnavailabilityReason' has a wrong offset!");

// ScriptStruct G01.GzAddServerResult
// 0x0000 (0x00E0 - 0x00E0)
struct FGzAddServerResult final : public FGzPlayFabResultBase
{
};
static_assert(alignof(FGzAddServerResult) == 0x000008, "Wrong alignment on FGzAddServerResult");
static_assert(sizeof(FGzAddServerResult) == 0x0000E0, "Wrong size on FGzAddServerResult");

// ScriptStruct G01.GzRemoveServerResult
// 0x0000 (0x00E0 - 0x00E0)
struct FGzRemoveServerResult final : public FGzPlayFabResultBase
{
};
static_assert(alignof(FGzRemoveServerResult) == 0x000008, "Wrong alignment on FGzRemoveServerResult");
static_assert(sizeof(FGzRemoveServerResult) == 0x0000E0, "Wrong size on FGzRemoveServerResult");

// ScriptStruct G01.GzServerDiscoveryResult
// 0x0020 (0x0020 - 0x0000)
struct FGzServerDiscoveryResult final
{
public:
	struct FGzServerDiscoveryResultPlayFabInfo    PlayFab;                                           // 0x0000(0x0020)(NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzServerDiscoveryResult) == 0x000008, "Wrong alignment on FGzServerDiscoveryResult");
static_assert(sizeof(FGzServerDiscoveryResult) == 0x000020, "Wrong size on FGzServerDiscoveryResult");
static_assert(offsetof(FGzServerDiscoveryResult, PlayFab) == 0x000000, "Member 'FGzServerDiscoveryResult::PlayFab' has a wrong offset!");

// ScriptStruct G01.GzSetClanTagPackage
// 0x0010 (0x0078 - 0x0068)
struct FGzSetClanTagPackage final : public FGzPlayFabClientPackage
{
public:
	class FString                                 Tag;                                               // 0x0068(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzSetClanTagPackage) == 0x000008, "Wrong alignment on FGzSetClanTagPackage");
static_assert(sizeof(FGzSetClanTagPackage) == 0x000078, "Wrong size on FGzSetClanTagPackage");
static_assert(offsetof(FGzSetClanTagPackage, Tag) == 0x000068, "Member 'FGzSetClanTagPackage::Tag' has a wrong offset!");

// ScriptStruct G01.GzSetCurrentCharacterPackage
// 0x0010 (0x0078 - 0x0068)
struct FGzSetCurrentCharacterPackage final : public FGzPlayFabClientPackage
{
public:
	class FString                                 CharacterId;                                       // 0x0068(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzSetCurrentCharacterPackage) == 0x000008, "Wrong alignment on FGzSetCurrentCharacterPackage");
static_assert(sizeof(FGzSetCurrentCharacterPackage) == 0x000078, "Wrong size on FGzSetCurrentCharacterPackage");
static_assert(offsetof(FGzSetCurrentCharacterPackage, CharacterId) == 0x000068, "Member 'FGzSetCurrentCharacterPackage::CharacterId' has a wrong offset!");

// ScriptStruct G01.GzSetProlongFlagPackage
// 0x0008 (0x0070 - 0x0068)
struct FGzSetProlongFlagPackage final : public FGzPlayFabClientPackage
{
public:
	bool                                          Prolong;                                           // 0x0068(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C1D[0x7];                                     // 0x0069(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGzSetProlongFlagPackage) == 0x000008, "Wrong alignment on FGzSetProlongFlagPackage");
static_assert(sizeof(FGzSetProlongFlagPackage) == 0x000070, "Wrong size on FGzSetProlongFlagPackage");
static_assert(offsetof(FGzSetProlongFlagPackage, Prolong) == 0x000068, "Member 'FGzSetProlongFlagPackage::Prolong' has a wrong offset!");

// ScriptStruct G01.GzInputActionMappingChange
// 0x0048 (0x0048 - 0x0000)
struct FGzInputActionMappingChange final
{
public:
	class FText                                   ActionMappingName;                                 // 0x0000(0x0010)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FKey                                   PreviousKey;                                       // 0x0010(0x0018)(BlueprintVisible, BlueprintReadOnly, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FKey                                   NewKey;                                            // 0x0028(0x0018)(BlueprintVisible, BlueprintReadOnly, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EPlayerMappableKeySlot                        Slot;                                              // 0x0040(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C1E[0x7];                                     // 0x0041(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGzInputActionMappingChange) == 0x000008, "Wrong alignment on FGzInputActionMappingChange");
static_assert(sizeof(FGzInputActionMappingChange) == 0x000048, "Wrong size on FGzInputActionMappingChange");
static_assert(offsetof(FGzInputActionMappingChange, ActionMappingName) == 0x000000, "Member 'FGzInputActionMappingChange::ActionMappingName' has a wrong offset!");
static_assert(offsetof(FGzInputActionMappingChange, PreviousKey) == 0x000010, "Member 'FGzInputActionMappingChange::PreviousKey' has a wrong offset!");
static_assert(offsetof(FGzInputActionMappingChange, NewKey) == 0x000028, "Member 'FGzInputActionMappingChange::NewKey' has a wrong offset!");
static_assert(offsetof(FGzInputActionMappingChange, Slot) == 0x000040, "Member 'FGzInputActionMappingChange::Slot' has a wrong offset!");

// ScriptStruct G01.GzSetVirtualCurrencyPackage
// 0x0018 (0x0080 - 0x0068)
struct FGzSetVirtualCurrencyPackage final : public FGzPlayFabClientPackage
{
public:
	uint32                                        CurrencyAmount;                                    // 0x0068(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C1F[0x4];                                     // 0x006C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 CurrencyType;                                      // 0x0070(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzSetVirtualCurrencyPackage) == 0x000008, "Wrong alignment on FGzSetVirtualCurrencyPackage");
static_assert(sizeof(FGzSetVirtualCurrencyPackage) == 0x000080, "Wrong size on FGzSetVirtualCurrencyPackage");
static_assert(offsetof(FGzSetVirtualCurrencyPackage, CurrencyAmount) == 0x000068, "Member 'FGzSetVirtualCurrencyPackage::CurrencyAmount' has a wrong offset!");
static_assert(offsetof(FGzSetVirtualCurrencyPackage, CurrencyType) == 0x000070, "Member 'FGzSetVirtualCurrencyPackage::CurrencyType' has a wrong offset!");

// ScriptStruct G01.GzShrinkingParams
// 0x0038 (0x0038 - 0x0000)
struct FGzShrinkingParams final
{
public:
	struct FGzCircle2D                            InitialCircle;                                     // 0x0000(0x0018)(NoDestructor, NativeAccessSpecifierPublic)
	struct FGzCircle2D                            TargetCircle;                                      // 0x0018(0x0018)(NoDestructor, NativeAccessSpecifierPublic)
	float                                         InitialTime;                                       // 0x0030(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ShrinkingTime;                                     // 0x0034(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzShrinkingParams) == 0x000008, "Wrong alignment on FGzShrinkingParams");
static_assert(sizeof(FGzShrinkingParams) == 0x000038, "Wrong size on FGzShrinkingParams");
static_assert(offsetof(FGzShrinkingParams, InitialCircle) == 0x000000, "Member 'FGzShrinkingParams::InitialCircle' has a wrong offset!");
static_assert(offsetof(FGzShrinkingParams, TargetCircle) == 0x000018, "Member 'FGzShrinkingParams::TargetCircle' has a wrong offset!");
static_assert(offsetof(FGzShrinkingParams, InitialTime) == 0x000030, "Member 'FGzShrinkingParams::InitialTime' has a wrong offset!");
static_assert(offsetof(FGzShrinkingParams, ShrinkingTime) == 0x000034, "Member 'FGzShrinkingParams::ShrinkingTime' has a wrong offset!");

// ScriptStruct G01.GzShrinkingStageData
// 0x0020 (0x0020 - 0x0000)
struct FGzShrinkingStageData final
{
public:
	struct FGzCircle2D                            Circle;                                            // 0x0000(0x0018)(NoDestructor, NativeAccessSpecifierPublic)
	float                                         MaxSpeed;                                          // 0x0018(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C20[0x4];                                     // 0x001C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGzShrinkingStageData) == 0x000008, "Wrong alignment on FGzShrinkingStageData");
static_assert(sizeof(FGzShrinkingStageData) == 0x000020, "Wrong size on FGzShrinkingStageData");
static_assert(offsetof(FGzShrinkingStageData, Circle) == 0x000000, "Member 'FGzShrinkingStageData::Circle' has a wrong offset!");
static_assert(offsetof(FGzShrinkingStageData, MaxSpeed) == 0x000018, "Member 'FGzShrinkingStageData::MaxSpeed' has a wrong offset!");

// ScriptStruct G01.GzSignPlayerAgreementPackage
// 0x0000 (0x0068 - 0x0068)
struct FGzSignPlayerAgreementPackage final : public FGzPlayFabClientPackage
{
};
static_assert(alignof(FGzSignPlayerAgreementPackage) == 0x000008, "Wrong alignment on FGzSignPlayerAgreementPackage");
static_assert(sizeof(FGzSignPlayerAgreementPackage) == 0x000068, "Wrong size on FGzSignPlayerAgreementPackage");

// ScriptStruct G01.GzBodyTransform
// 0x0060 (0x0060 - 0x0000)
struct FGzBodyTransform final
{
public:
	uint8                                         Pad_2C21[0x4];                                     // 0x0000(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	int16                                         BoneIndex;                                         // 0x0004(0x0002)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C22[0xA];                                     // 0x0006(0x000A)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGzTransformNoScale                    Transform;                                         // 0x0010(0x0050)(NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzBodyTransform) == 0x000010, "Wrong alignment on FGzBodyTransform");
static_assert(sizeof(FGzBodyTransform) == 0x000060, "Wrong size on FGzBodyTransform");
static_assert(offsetof(FGzBodyTransform, BoneIndex) == 0x000004, "Member 'FGzBodyTransform::BoneIndex' has a wrong offset!");
static_assert(offsetof(FGzBodyTransform, Transform) == 0x000010, "Member 'FGzBodyTransform::Transform' has a wrong offset!");

// ScriptStruct G01.GzSkeletalPoseSyncData
// 0x0018 (0x0018 - 0x0000)
struct FGzSkeletalPoseSyncData final
{
public:
	float                                         Time;                                              // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C23[0x4];                                     // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FGzBodyTransform>               Transforms;                                        // 0x0008(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzSkeletalPoseSyncData) == 0x000008, "Wrong alignment on FGzSkeletalPoseSyncData");
static_assert(sizeof(FGzSkeletalPoseSyncData) == 0x000018, "Wrong size on FGzSkeletalPoseSyncData");
static_assert(offsetof(FGzSkeletalPoseSyncData, Time) == 0x000000, "Member 'FGzSkeletalPoseSyncData::Time' has a wrong offset!");
static_assert(offsetof(FGzSkeletalPoseSyncData, Transforms) == 0x000008, "Member 'FGzSkeletalPoseSyncData::Transforms' has a wrong offset!");

// ScriptStruct G01.GzSoundStateKey
// 0x0008 (0x0008 - 0x0000)
struct FGzSoundStateKey final
{
public:
	class FName                                   Key;                                               // 0x0000(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzSoundStateKey) == 0x000004, "Wrong alignment on FGzSoundStateKey");
static_assert(sizeof(FGzSoundStateKey) == 0x000008, "Wrong size on FGzSoundStateKey");
static_assert(offsetof(FGzSoundStateKey, Key) == 0x000000, "Member 'FGzSoundStateKey::Key' has a wrong offset!");

// ScriptStruct G01.GzSpawnerVisualizationStruct
// 0x0028 (0x0028 - 0x0000)
struct FGzSpawnerVisualizationStruct final
{
public:
	float                                         SphereRadius;                                      // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxSimTime;                                        // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PredictPathThickness;                              // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ShapesThickness;                                   // 0x000C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FColor                                 InitialSpawnLocationColorFrom;                     // 0x0010(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FColor                                 InitialSpawnLocationColorTo;                       // 0x0014(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FColor                                 FinalSpawnLocationColorFrom;                       // 0x0018(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FColor                                 FinalSpawnLocationColorTo;                         // 0x001C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FColor                                 PredictPathColor;                                  // 0x0020(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FColor                                 RandomFinalSpawnLocationOffsetForSlotColor;        // 0x0024(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzSpawnerVisualizationStruct) == 0x000004, "Wrong alignment on FGzSpawnerVisualizationStruct");
static_assert(sizeof(FGzSpawnerVisualizationStruct) == 0x000028, "Wrong size on FGzSpawnerVisualizationStruct");
static_assert(offsetof(FGzSpawnerVisualizationStruct, SphereRadius) == 0x000000, "Member 'FGzSpawnerVisualizationStruct::SphereRadius' has a wrong offset!");
static_assert(offsetof(FGzSpawnerVisualizationStruct, MaxSimTime) == 0x000004, "Member 'FGzSpawnerVisualizationStruct::MaxSimTime' has a wrong offset!");
static_assert(offsetof(FGzSpawnerVisualizationStruct, PredictPathThickness) == 0x000008, "Member 'FGzSpawnerVisualizationStruct::PredictPathThickness' has a wrong offset!");
static_assert(offsetof(FGzSpawnerVisualizationStruct, ShapesThickness) == 0x00000C, "Member 'FGzSpawnerVisualizationStruct::ShapesThickness' has a wrong offset!");
static_assert(offsetof(FGzSpawnerVisualizationStruct, InitialSpawnLocationColorFrom) == 0x000010, "Member 'FGzSpawnerVisualizationStruct::InitialSpawnLocationColorFrom' has a wrong offset!");
static_assert(offsetof(FGzSpawnerVisualizationStruct, InitialSpawnLocationColorTo) == 0x000014, "Member 'FGzSpawnerVisualizationStruct::InitialSpawnLocationColorTo' has a wrong offset!");
static_assert(offsetof(FGzSpawnerVisualizationStruct, FinalSpawnLocationColorFrom) == 0x000018, "Member 'FGzSpawnerVisualizationStruct::FinalSpawnLocationColorFrom' has a wrong offset!");
static_assert(offsetof(FGzSpawnerVisualizationStruct, FinalSpawnLocationColorTo) == 0x00001C, "Member 'FGzSpawnerVisualizationStruct::FinalSpawnLocationColorTo' has a wrong offset!");
static_assert(offsetof(FGzSpawnerVisualizationStruct, PredictPathColor) == 0x000020, "Member 'FGzSpawnerVisualizationStruct::PredictPathColor' has a wrong offset!");
static_assert(offsetof(FGzSpawnerVisualizationStruct, RandomFinalSpawnLocationOffsetForSlotColor) == 0x000024, "Member 'FGzSpawnerVisualizationStruct::RandomFinalSpawnLocationOffsetForSlotColor' has a wrong offset!");

// ScriptStruct G01.GzSpiderMine_LaunchInfo
// 0x0030 (0x0030 - 0x0000)
struct FGzSpiderMine_LaunchInfo final
{
public:
	struct FVector                                LaunchPosition;                                    // 0x0000(0x0018)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Direction;                                         // 0x0018(0x0018)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzSpiderMine_LaunchInfo) == 0x000008, "Wrong alignment on FGzSpiderMine_LaunchInfo");
static_assert(sizeof(FGzSpiderMine_LaunchInfo) == 0x000030, "Wrong size on FGzSpiderMine_LaunchInfo");
static_assert(offsetof(FGzSpiderMine_LaunchInfo, LaunchPosition) == 0x000000, "Member 'FGzSpiderMine_LaunchInfo::LaunchPosition' has a wrong offset!");
static_assert(offsetof(FGzSpiderMine_LaunchInfo, Direction) == 0x000018, "Member 'FGzSpiderMine_LaunchInfo::Direction' has a wrong offset!");

// ScriptStruct G01.GzStateParameterContainer
// 0x0018 (0x0018 - 0x0000)
struct FGzStateParameterContainer final
{
public:
	struct FInstancedStruct                       Value;                                             // 0x0000(0x0010)(NativeAccessSpecifierPrivate)
	bool                                          bHasValue;                                         // 0x0010(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2C24[0x7];                                     // 0x0011(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGzStateParameterContainer) == 0x000008, "Wrong alignment on FGzStateParameterContainer");
static_assert(sizeof(FGzStateParameterContainer) == 0x000018, "Wrong size on FGzStateParameterContainer");
static_assert(offsetof(FGzStateParameterContainer, Value) == 0x000000, "Member 'FGzStateParameterContainer::Value' has a wrong offset!");
static_assert(offsetof(FGzStateParameterContainer, bHasValue) == 0x000010, "Member 'FGzStateParameterContainer::bHasValue' has a wrong offset!");

// ScriptStruct G01.GzStatistics
// 0x0028 (0x0028 - 0x0000)
struct FGzStatistics final
{
public:
	uint32                                        DatacubesExtracted;                                // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint32                                        Deaths;                                            // 0x0004(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint32                                        Kills;                                             // 0x0008(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint32                                        Knockdowns;                                        // 0x000C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint32                                        TriosAvgPlacement;                                 // 0x0010(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint32                                        TriosMatchesWon;                                   // 0x0014(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint32                                        TriosSurvivalTime;                                 // 0x0018(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint32                                        TriosTop3;                                         // 0x001C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint32                                        TriosTop10;                                        // 0x0020(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint32                                        TriosTop25;                                        // 0x0024(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzStatistics) == 0x000004, "Wrong alignment on FGzStatistics");
static_assert(sizeof(FGzStatistics) == 0x000028, "Wrong size on FGzStatistics");
static_assert(offsetof(FGzStatistics, DatacubesExtracted) == 0x000000, "Member 'FGzStatistics::DatacubesExtracted' has a wrong offset!");
static_assert(offsetof(FGzStatistics, Deaths) == 0x000004, "Member 'FGzStatistics::Deaths' has a wrong offset!");
static_assert(offsetof(FGzStatistics, Kills) == 0x000008, "Member 'FGzStatistics::Kills' has a wrong offset!");
static_assert(offsetof(FGzStatistics, Knockdowns) == 0x00000C, "Member 'FGzStatistics::Knockdowns' has a wrong offset!");
static_assert(offsetof(FGzStatistics, TriosAvgPlacement) == 0x000010, "Member 'FGzStatistics::TriosAvgPlacement' has a wrong offset!");
static_assert(offsetof(FGzStatistics, TriosMatchesWon) == 0x000014, "Member 'FGzStatistics::TriosMatchesWon' has a wrong offset!");
static_assert(offsetof(FGzStatistics, TriosSurvivalTime) == 0x000018, "Member 'FGzStatistics::TriosSurvivalTime' has a wrong offset!");
static_assert(offsetof(FGzStatistics, TriosTop3) == 0x00001C, "Member 'FGzStatistics::TriosTop3' has a wrong offset!");
static_assert(offsetof(FGzStatistics, TriosTop10) == 0x000020, "Member 'FGzStatistics::TriosTop10' has a wrong offset!");
static_assert(offsetof(FGzStatistics, TriosTop25) == 0x000024, "Member 'FGzStatistics::TriosTop25' has a wrong offset!");

// ScriptStruct G01.GzStatRewardGrade
// 0x0010 (0x0010 - 0x0000)
struct FGzStatRewardGrade final
{
public:
	float                                         GradeValue;                                        // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C25[0x4];                                     // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UGzRewardData*                          Reward;                                            // 0x0008(0x0008)(Edit, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzStatRewardGrade) == 0x000008, "Wrong alignment on FGzStatRewardGrade");
static_assert(sizeof(FGzStatRewardGrade) == 0x000010, "Wrong size on FGzStatRewardGrade");
static_assert(offsetof(FGzStatRewardGrade, GradeValue) == 0x000000, "Member 'FGzStatRewardGrade::GradeValue' has a wrong offset!");
static_assert(offsetof(FGzStatRewardGrade, Reward) == 0x000008, "Member 'FGzStatRewardGrade::Reward' has a wrong offset!");

// ScriptStruct G01.GzStatsArray
// 0x0058 (0x0168 - 0x0110)
struct FGzStatsArray final : public FFastArraySerializer
{
public:
	uint8                                         Pad_2C26[0x48];                                    // 0x0110(0x0048)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FGzStatEntry>                   Stats;                                             // 0x0158(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzStatsArray) == 0x000008, "Wrong alignment on FGzStatsArray");
static_assert(sizeof(FGzStatsArray) == 0x000168, "Wrong size on FGzStatsArray");
static_assert(offsetof(FGzStatsArray, Stats) == 0x000158, "Member 'FGzStatsArray::Stats' has a wrong offset!");

// ScriptStruct G01.GzActorStreamHandle
// 0x0028 (0x0028 - 0x0000)
struct alignas(0x08) FGzActorStreamHandle final
{
public:
	uint8                                         Pad_2C27[0x28];                                    // 0x0000(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGzActorStreamHandle) == 0x000008, "Wrong alignment on FGzActorStreamHandle");
static_assert(sizeof(FGzActorStreamHandle) == 0x000028, "Wrong size on FGzActorStreamHandle");

// ScriptStruct G01.GzItemStreamHandleArray
// 0x0010 (0x0010 - 0x0000)
struct FGzItemStreamHandleArray final
{
public:
	TArray<struct FGzActorStreamHandle>           Handles;                                           // 0x0000(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzItemStreamHandleArray) == 0x000008, "Wrong alignment on FGzItemStreamHandleArray");
static_assert(sizeof(FGzItemStreamHandleArray) == 0x000010, "Wrong size on FGzItemStreamHandleArray");
static_assert(offsetof(FGzItemStreamHandleArray, Handles) == 0x000000, "Member 'FGzItemStreamHandleArray::Handles' has a wrong offset!");

// ScriptStruct G01.GzStripeExtendSubscriptionWithGunPackage
// 0x0008 (0x0070 - 0x0068)
struct FGzStripeExtendSubscriptionWithGunPackage final : public FGzPlayFabClientPackage
{
public:
	float                                         Price;                                             // 0x0068(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C28[0x4];                                     // 0x006C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGzStripeExtendSubscriptionWithGunPackage) == 0x000008, "Wrong alignment on FGzStripeExtendSubscriptionWithGunPackage");
static_assert(sizeof(FGzStripeExtendSubscriptionWithGunPackage) == 0x000070, "Wrong size on FGzStripeExtendSubscriptionWithGunPackage");
static_assert(offsetof(FGzStripeExtendSubscriptionWithGunPackage, Price) == 0x000068, "Member 'FGzStripeExtendSubscriptionWithGunPackage::Price' has a wrong offset!");

// ScriptStruct G01.GzStripeGetPaymentLinkPackage
// 0x0000 (0x0068 - 0x0068)
struct FGzStripeGetPaymentLinkPackage final : public FGzPlayFabClientPackage
{
};
static_assert(alignof(FGzStripeGetPaymentLinkPackage) == 0x000008, "Wrong alignment on FGzStripeGetPaymentLinkPackage");
static_assert(sizeof(FGzStripeGetPaymentLinkPackage) == 0x000068, "Wrong size on FGzStripeGetPaymentLinkPackage");

// ScriptStruct G01.GzStripeSubscriptionProductPricesPackage
// 0x0000 (0x0068 - 0x0068)
struct FGzStripeSubscriptionProductPricesPackage final : public FGzPlayFabClientPackage
{
};
static_assert(alignof(FGzStripeSubscriptionProductPricesPackage) == 0x000008, "Wrong alignment on FGzStripeSubscriptionProductPricesPackage");
static_assert(sizeof(FGzStripeSubscriptionProductPricesPackage) == 0x000068, "Wrong size on FGzStripeSubscriptionProductPricesPackage");

// ScriptStruct G01.GzAccountBenefits
// 0x0028 (0x0028 - 0x0000)
struct FGzAccountBenefits final
{
public:
	class FText                                   AccountType;                                       // 0x0000(0x0010)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	int32                                         TilesInFirstRow;                                   // 0x0010(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C29[0x4];                                     // 0x0014(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UGzSubscriptionBenefit*>         AccountBenefits;                                   // 0x0018(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzAccountBenefits) == 0x000008, "Wrong alignment on FGzAccountBenefits");
static_assert(sizeof(FGzAccountBenefits) == 0x000028, "Wrong size on FGzAccountBenefits");
static_assert(offsetof(FGzAccountBenefits, AccountType) == 0x000000, "Member 'FGzAccountBenefits::AccountType' has a wrong offset!");
static_assert(offsetof(FGzAccountBenefits, TilesInFirstRow) == 0x000010, "Member 'FGzAccountBenefits::TilesInFirstRow' has a wrong offset!");
static_assert(offsetof(FGzAccountBenefits, AccountBenefits) == 0x000018, "Member 'FGzAccountBenefits::AccountBenefits' has a wrong offset!");

// ScriptStruct G01.GzAccountTypesBenefits
// 0x0050 (0x0050 - 0x0000)
struct FGzAccountTypesBenefits final
{
public:
	TMap<EGzSubscriptionType, struct FGzAccountBenefits> AvailableSubscriptions;                            // 0x0000(0x0050)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzAccountTypesBenefits) == 0x000008, "Wrong alignment on FGzAccountTypesBenefits");
static_assert(sizeof(FGzAccountTypesBenefits) == 0x000050, "Wrong size on FGzAccountTypesBenefits");
static_assert(offsetof(FGzAccountTypesBenefits, AvailableSubscriptions) == 0x000000, "Member 'FGzAccountTypesBenefits::AvailableSubscriptions' has a wrong offset!");

// ScriptStruct G01.GzAccountTypesPreviewInfo
// 0x0048 (0x0048 - 0x0000)
struct FGzAccountTypesPreviewInfo final
{
public:
	class FText                                   Summary;                                           // 0x0000(0x0010)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UTexture2D>              BackgroundImage;                                   // 0x0010(0x0028)(Edit, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class UGzSubscriptionBenefit*>         UpgradeBenefits;                                   // 0x0038(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzAccountTypesPreviewInfo) == 0x000008, "Wrong alignment on FGzAccountTypesPreviewInfo");
static_assert(sizeof(FGzAccountTypesPreviewInfo) == 0x000048, "Wrong size on FGzAccountTypesPreviewInfo");
static_assert(offsetof(FGzAccountTypesPreviewInfo, Summary) == 0x000000, "Member 'FGzAccountTypesPreviewInfo::Summary' has a wrong offset!");
static_assert(offsetof(FGzAccountTypesPreviewInfo, BackgroundImage) == 0x000010, "Member 'FGzAccountTypesPreviewInfo::BackgroundImage' has a wrong offset!");
static_assert(offsetof(FGzAccountTypesPreviewInfo, UpgradeBenefits) == 0x000038, "Member 'FGzAccountTypesPreviewInfo::UpgradeBenefits' has a wrong offset!");

// ScriptStruct G01.GzSubtractBlockchainCoinsPackage
// 0x0010 (0x0078 - 0x0068)
struct FGzSubtractBlockchainCoinsPackage final : public FGzPlayFabClientPackage
{
public:
	class FString                                 AmountString;                                      // 0x0068(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzSubtractBlockchainCoinsPackage) == 0x000008, "Wrong alignment on FGzSubtractBlockchainCoinsPackage");
static_assert(sizeof(FGzSubtractBlockchainCoinsPackage) == 0x000078, "Wrong size on FGzSubtractBlockchainCoinsPackage");
static_assert(offsetof(FGzSubtractBlockchainCoinsPackage, AmountString) == 0x000068, "Member 'FGzSubtractBlockchainCoinsPackage::AmountString' has a wrong offset!");

// ScriptStruct G01.GzLootlTableSlot
// 0x0018 (0x0018 - 0x0000)
struct FGzLootlTableSlot final
{
public:
	class UGzLootArchetypeTableData*              ArchetypesTable;                                   // 0x0000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Probability;                                       // 0x0008(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MinItems;                                          // 0x000C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaxItems;                                          // 0x0010(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C2A[0x4];                                     // 0x0014(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGzLootlTableSlot) == 0x000008, "Wrong alignment on FGzLootlTableSlot");
static_assert(sizeof(FGzLootlTableSlot) == 0x000018, "Wrong size on FGzLootlTableSlot");
static_assert(offsetof(FGzLootlTableSlot, ArchetypesTable) == 0x000000, "Member 'FGzLootlTableSlot::ArchetypesTable' has a wrong offset!");
static_assert(offsetof(FGzLootlTableSlot, Probability) == 0x000008, "Member 'FGzLootlTableSlot::Probability' has a wrong offset!");
static_assert(offsetof(FGzLootlTableSlot, MinItems) == 0x00000C, "Member 'FGzLootlTableSlot::MinItems' has a wrong offset!");
static_assert(offsetof(FGzLootlTableSlot, MaxItems) == 0x000010, "Member 'FGzLootlTableSlot::MaxItems' has a wrong offset!");

// ScriptStruct G01.GzGameplayAbilityTargetData_Direction
// 0x0018 (0x0020 - 0x0008)
struct FGzGameplayAbilityTargetData_Direction final : public FGameplayAbilityTargetData
{
public:
	struct FVector                                Direction;                                         // 0x0008(0x0018)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzGameplayAbilityTargetData_Direction) == 0x000008, "Wrong alignment on FGzGameplayAbilityTargetData_Direction");
static_assert(sizeof(FGzGameplayAbilityTargetData_Direction) == 0x000020, "Wrong size on FGzGameplayAbilityTargetData_Direction");
static_assert(offsetof(FGzGameplayAbilityTargetData_Direction, Direction) == 0x000008, "Member 'FGzGameplayAbilityTargetData_Direction::Direction' has a wrong offset!");

// ScriptStruct G01.GzGameplayAbilityTargetData_Dash
// 0x0088 (0x0090 - 0x0008)
struct FGzGameplayAbilityTargetData_Dash final : public FGameplayAbilityTargetData
{
public:
	struct FVector_NetQuantize                    TargetLocation;                                    // 0x0008(0x0018)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TWeakObjectPtr<class AActor>                  TargetActor;                                       // 0x0020(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UGzDashParamsData*                      DashParams;                                        // 0x0028(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector_NetQuantize                    ExtraOverlapExtents;                               // 0x0030(0x0018)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector_NetQuantize                    ExtraOverlapOffset;                                // 0x0048(0x0018)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   ExtraOverlapCollisionProfile;                      // 0x0060(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTagContainer                  TagsToApply;                                       // 0x0068(0x0020)(NativeAccessSpecifierPublic)
	bool                                          bResetVelocityAtEnd;                               // 0x0088(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C2B[0x7];                                     // 0x0089(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGzGameplayAbilityTargetData_Dash) == 0x000008, "Wrong alignment on FGzGameplayAbilityTargetData_Dash");
static_assert(sizeof(FGzGameplayAbilityTargetData_Dash) == 0x000090, "Wrong size on FGzGameplayAbilityTargetData_Dash");
static_assert(offsetof(FGzGameplayAbilityTargetData_Dash, TargetLocation) == 0x000008, "Member 'FGzGameplayAbilityTargetData_Dash::TargetLocation' has a wrong offset!");
static_assert(offsetof(FGzGameplayAbilityTargetData_Dash, TargetActor) == 0x000020, "Member 'FGzGameplayAbilityTargetData_Dash::TargetActor' has a wrong offset!");
static_assert(offsetof(FGzGameplayAbilityTargetData_Dash, DashParams) == 0x000028, "Member 'FGzGameplayAbilityTargetData_Dash::DashParams' has a wrong offset!");
static_assert(offsetof(FGzGameplayAbilityTargetData_Dash, ExtraOverlapExtents) == 0x000030, "Member 'FGzGameplayAbilityTargetData_Dash::ExtraOverlapExtents' has a wrong offset!");
static_assert(offsetof(FGzGameplayAbilityTargetData_Dash, ExtraOverlapOffset) == 0x000048, "Member 'FGzGameplayAbilityTargetData_Dash::ExtraOverlapOffset' has a wrong offset!");
static_assert(offsetof(FGzGameplayAbilityTargetData_Dash, ExtraOverlapCollisionProfile) == 0x000060, "Member 'FGzGameplayAbilityTargetData_Dash::ExtraOverlapCollisionProfile' has a wrong offset!");
static_assert(offsetof(FGzGameplayAbilityTargetData_Dash, TagsToApply) == 0x000068, "Member 'FGzGameplayAbilityTargetData_Dash::TagsToApply' has a wrong offset!");
static_assert(offsetof(FGzGameplayAbilityTargetData_Dash, bResetVelocityAtEnd) == 0x000088, "Member 'FGzGameplayAbilityTargetData_Dash::bResetVelocityAtEnd' has a wrong offset!");

// ScriptStruct G01.GzTeamMember
// 0x0008 (0x0008 - 0x0000)
struct FGzTeamMember final
{
public:
	class AGzPlayerState*                         PlayerState;                                       // 0x0000(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzTeamMember) == 0x000008, "Wrong alignment on FGzTeamMember");
static_assert(sizeof(FGzTeamMember) == 0x000008, "Wrong size on FGzTeamMember");
static_assert(offsetof(FGzTeamMember, PlayerState) == 0x000000, "Member 'FGzTeamMember::PlayerState' has a wrong offset!");

// ScriptStruct G01.GzRevealTeamPair
// 0x0008 (0x0008 - 0x0000)
struct FGzRevealTeamPair final
{
public:
	int32                                         InstigatorTeamId;                                  // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         VictimTeamId;                                      // 0x0004(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzRevealTeamPair) == 0x000004, "Wrong alignment on FGzRevealTeamPair");
static_assert(sizeof(FGzRevealTeamPair) == 0x000008, "Wrong size on FGzRevealTeamPair");
static_assert(offsetof(FGzRevealTeamPair, InstigatorTeamId) == 0x000000, "Member 'FGzRevealTeamPair::InstigatorTeamId' has a wrong offset!");
static_assert(offsetof(FGzRevealTeamPair, VictimTeamId) == 0x000004, "Member 'FGzRevealTeamPair::VictimTeamId' has a wrong offset!");

// ScriptStruct G01.GzTeamRevealData
// 0x0018 (0x0018 - 0x0000)
struct FGzTeamRevealData final
{
public:
	TArray<int32>                                 MarkerIds;                                         // 0x0000(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C2C[0x8];                                     // 0x0010(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGzTeamRevealData) == 0x000008, "Wrong alignment on FGzTeamRevealData");
static_assert(sizeof(FGzTeamRevealData) == 0x000018, "Wrong size on FGzTeamRevealData");
static_assert(offsetof(FGzTeamRevealData, MarkerIds) == 0x000000, "Member 'FGzTeamRevealData::MarkerIds' has a wrong offset!");

// ScriptStruct G01.GzTeamSettings
// 0x0010 (0x0010 - 0x0000)
struct FGzTeamSettings final
{
public:
	bool                                          bAssignOnStart;                                    // 0x0000(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAllowTeamChange;                                  // 0x0001(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUnlimitedTeamCapacity;                            // 0x0002(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C2D[0x1];                                     // 0x0003(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         MaxTeamCapacity;                                   // 0x0004(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaxTeamCount;                                      // 0x0008(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EGzTeamDistributionPolicy                     DistributionPolicy;                                // 0x000C(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C2E[0x3];                                     // 0x000D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGzTeamSettings) == 0x000004, "Wrong alignment on FGzTeamSettings");
static_assert(sizeof(FGzTeamSettings) == 0x000010, "Wrong size on FGzTeamSettings");
static_assert(offsetof(FGzTeamSettings, bAssignOnStart) == 0x000000, "Member 'FGzTeamSettings::bAssignOnStart' has a wrong offset!");
static_assert(offsetof(FGzTeamSettings, bAllowTeamChange) == 0x000001, "Member 'FGzTeamSettings::bAllowTeamChange' has a wrong offset!");
static_assert(offsetof(FGzTeamSettings, bUnlimitedTeamCapacity) == 0x000002, "Member 'FGzTeamSettings::bUnlimitedTeamCapacity' has a wrong offset!");
static_assert(offsetof(FGzTeamSettings, MaxTeamCapacity) == 0x000004, "Member 'FGzTeamSettings::MaxTeamCapacity' has a wrong offset!");
static_assert(offsetof(FGzTeamSettings, MaxTeamCount) == 0x000008, "Member 'FGzTeamSettings::MaxTeamCount' has a wrong offset!");
static_assert(offsetof(FGzTeamSettings, DistributionPolicy) == 0x00000C, "Member 'FGzTeamSettings::DistributionPolicy' has a wrong offset!");

// ScriptStruct G01.GzTelemetryAllSpectatingTimeEventPayload
// 0x0008 (0x0028 - 0x0020)
struct FGzTelemetryAllSpectatingTimeEventPayload final : public FGzPlayerTelemetryEventPayload
{
public:
	float                                         Time;                                              // 0x0020(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C2F[0x4];                                     // 0x0024(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGzTelemetryAllSpectatingTimeEventPayload) == 0x000008, "Wrong alignment on FGzTelemetryAllSpectatingTimeEventPayload");
static_assert(sizeof(FGzTelemetryAllSpectatingTimeEventPayload) == 0x000028, "Wrong size on FGzTelemetryAllSpectatingTimeEventPayload");
static_assert(offsetof(FGzTelemetryAllSpectatingTimeEventPayload, Time) == 0x000020, "Member 'FGzTelemetryAllSpectatingTimeEventPayload::Time' has a wrong offset!");

// ScriptStruct G01.GzDamageByLimbsTelemetryEventPayload
// 0x0010 (0x0020 - 0x0010)
struct FGzDamageByLimbsTelemetryEventPayload final : public FGzTitleTelemetryEventPayload
{
public:
	TArray<struct FGzLimbDamage>                  LimbDamages;                                       // 0x0010(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzDamageByLimbsTelemetryEventPayload) == 0x000008, "Wrong alignment on FGzDamageByLimbsTelemetryEventPayload");
static_assert(sizeof(FGzDamageByLimbsTelemetryEventPayload) == 0x000020, "Wrong size on FGzDamageByLimbsTelemetryEventPayload");
static_assert(offsetof(FGzDamageByLimbsTelemetryEventPayload, LimbDamages) == 0x000010, "Member 'FGzDamageByLimbsTelemetryEventPayload::LimbDamages' has a wrong offset!");

// ScriptStruct G01.GzDeathByShrinkingZoneTelemetryEventPayload
// 0x0008 (0x0028 - 0x0020)
struct FGzDeathByShrinkingZoneTelemetryEventPayload final : public FGzPlayerTelemetryEventPayload
{
public:
	float                                         DeathTime;                                         // 0x0020(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C30[0x4];                                     // 0x0024(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGzDeathByShrinkingZoneTelemetryEventPayload) == 0x000008, "Wrong alignment on FGzDeathByShrinkingZoneTelemetryEventPayload");
static_assert(sizeof(FGzDeathByShrinkingZoneTelemetryEventPayload) == 0x000028, "Wrong size on FGzDeathByShrinkingZoneTelemetryEventPayload");
static_assert(offsetof(FGzDeathByShrinkingZoneTelemetryEventPayload, DeathTime) == 0x000020, "Member 'FGzDeathByShrinkingZoneTelemetryEventPayload::DeathTime' has a wrong offset!");

// ScriptStruct G01.GzEquippedWinnerLimbsEventPayload
// 0x0010 (0x0030 - 0x0020)
struct FGzEquippedWinnerLimbsEventPayload final : public FGzPlayerTelemetryEventPayload
{
public:
	TArray<class FName>                           LimbNames;                                         // 0x0020(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzEquippedWinnerLimbsEventPayload) == 0x000008, "Wrong alignment on FGzEquippedWinnerLimbsEventPayload");
static_assert(sizeof(FGzEquippedWinnerLimbsEventPayload) == 0x000030, "Wrong size on FGzEquippedWinnerLimbsEventPayload");
static_assert(offsetof(FGzEquippedWinnerLimbsEventPayload, LimbNames) == 0x000020, "Member 'FGzEquippedWinnerLimbsEventPayload::LimbNames' has a wrong offset!");

// ScriptStruct G01.GzTelemetryFinalDeathSpectatingTimeEventPayload
// 0x0008 (0x0028 - 0x0020)
struct FGzTelemetryFinalDeathSpectatingTimeEventPayload final : public FGzPlayerTelemetryEventPayload
{
public:
	float                                         Time;                                              // 0x0020(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C31[0x4];                                     // 0x0024(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGzTelemetryFinalDeathSpectatingTimeEventPayload) == 0x000008, "Wrong alignment on FGzTelemetryFinalDeathSpectatingTimeEventPayload");
static_assert(sizeof(FGzTelemetryFinalDeathSpectatingTimeEventPayload) == 0x000028, "Wrong size on FGzTelemetryFinalDeathSpectatingTimeEventPayload");
static_assert(offsetof(FGzTelemetryFinalDeathSpectatingTimeEventPayload, Time) == 0x000020, "Member 'FGzTelemetryFinalDeathSpectatingTimeEventPayload::Time' has a wrong offset!");

// ScriptStruct G01.GzKillByLimbTelemetryEventPayload
// 0x0030 (0x0050 - 0x0020)
struct FGzKillByLimbTelemetryEventPayload final : public FGzPlayerTelemetryEventPayload
{
public:
	class FName                                   LimbName;                                          // 0x0020(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DistanceToTarget;                                  // 0x0028(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         KillTime;                                          // 0x002C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              KillerLocation;                                    // 0x0030(0x0010)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              TargetLocation;                                    // 0x0040(0x0010)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzKillByLimbTelemetryEventPayload) == 0x000008, "Wrong alignment on FGzKillByLimbTelemetryEventPayload");
static_assert(sizeof(FGzKillByLimbTelemetryEventPayload) == 0x000050, "Wrong size on FGzKillByLimbTelemetryEventPayload");
static_assert(offsetof(FGzKillByLimbTelemetryEventPayload, LimbName) == 0x000020, "Member 'FGzKillByLimbTelemetryEventPayload::LimbName' has a wrong offset!");
static_assert(offsetof(FGzKillByLimbTelemetryEventPayload, DistanceToTarget) == 0x000028, "Member 'FGzKillByLimbTelemetryEventPayload::DistanceToTarget' has a wrong offset!");
static_assert(offsetof(FGzKillByLimbTelemetryEventPayload, KillTime) == 0x00002C, "Member 'FGzKillByLimbTelemetryEventPayload::KillTime' has a wrong offset!");
static_assert(offsetof(FGzKillByLimbTelemetryEventPayload, KillerLocation) == 0x000030, "Member 'FGzKillByLimbTelemetryEventPayload::KillerLocation' has a wrong offset!");
static_assert(offsetof(FGzKillByLimbTelemetryEventPayload, TargetLocation) == 0x000040, "Member 'FGzKillByLimbTelemetryEventPayload::TargetLocation' has a wrong offset!");

// ScriptStruct G01.GzOpportunityStartedTelemetryEventPayload
// 0x0010 (0x0030 - 0x0020)
struct FGzOpportunityStartedTelemetryEventPayload final : public FGzPlayerTelemetryEventPayload
{
public:
	class FString                                 OpportunityId;                                     // 0x0020(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzOpportunityStartedTelemetryEventPayload) == 0x000008, "Wrong alignment on FGzOpportunityStartedTelemetryEventPayload");
static_assert(sizeof(FGzOpportunityStartedTelemetryEventPayload) == 0x000030, "Wrong size on FGzOpportunityStartedTelemetryEventPayload");
static_assert(offsetof(FGzOpportunityStartedTelemetryEventPayload, OpportunityId) == 0x000020, "Member 'FGzOpportunityStartedTelemetryEventPayload::OpportunityId' has a wrong offset!");

// ScriptStruct G01.GzPlayerConnectedTelemetryEventPayload
// 0x0028 (0x0048 - 0x0020)
struct FGzPlayerConnectedTelemetryEventPayload final : public FGzPlayerTelemetryEventPayload
{
public:
	class FString                                 UnityMatchId;                                      // 0x0020(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 MatchmakingTicketId;                               // 0x0030(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint32                                        MatchmakingTimeToGetTicket;                        // 0x0040(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint32                                        MatchmakingOverallTime;                            // 0x0044(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzPlayerConnectedTelemetryEventPayload) == 0x000008, "Wrong alignment on FGzPlayerConnectedTelemetryEventPayload");
static_assert(sizeof(FGzPlayerConnectedTelemetryEventPayload) == 0x000048, "Wrong size on FGzPlayerConnectedTelemetryEventPayload");
static_assert(offsetof(FGzPlayerConnectedTelemetryEventPayload, UnityMatchId) == 0x000020, "Member 'FGzPlayerConnectedTelemetryEventPayload::UnityMatchId' has a wrong offset!");
static_assert(offsetof(FGzPlayerConnectedTelemetryEventPayload, MatchmakingTicketId) == 0x000030, "Member 'FGzPlayerConnectedTelemetryEventPayload::MatchmakingTicketId' has a wrong offset!");
static_assert(offsetof(FGzPlayerConnectedTelemetryEventPayload, MatchmakingTimeToGetTicket) == 0x000040, "Member 'FGzPlayerConnectedTelemetryEventPayload::MatchmakingTimeToGetTicket' has a wrong offset!");
static_assert(offsetof(FGzPlayerConnectedTelemetryEventPayload, MatchmakingOverallTime) == 0x000044, "Member 'FGzPlayerConnectedTelemetryEventPayload::MatchmakingOverallTime' has a wrong offset!");

// ScriptStruct G01.GzPlayerDisconnectedTelemetryEventPayload
// 0x0008 (0x0028 - 0x0020)
struct FGzPlayerDisconnectedTelemetryEventPayload final : public FGzPlayerTelemetryEventPayload
{
public:
	EGzTelemetryPlayerDisconnectType              DisconnectType;                                    // 0x0020(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C32[0x7];                                     // 0x0021(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGzPlayerDisconnectedTelemetryEventPayload) == 0x000008, "Wrong alignment on FGzPlayerDisconnectedTelemetryEventPayload");
static_assert(sizeof(FGzPlayerDisconnectedTelemetryEventPayload) == 0x000028, "Wrong size on FGzPlayerDisconnectedTelemetryEventPayload");
static_assert(offsetof(FGzPlayerDisconnectedTelemetryEventPayload, DisconnectType) == 0x000020, "Member 'FGzPlayerDisconnectedTelemetryEventPayload::DisconnectType' has a wrong offset!");

// ScriptStruct G01.GzRedeployTerminalUsageEventPayload
// 0x0058 (0x0068 - 0x0010)
struct FGzRedeployTerminalUsageEventPayload final : public FGzTitleTelemetryEventPayload
{
public:
	TMap<class FString, int32>                    Callers;                                           // 0x0010(0x0050)(NativeAccessSpecifierPublic)
	int32                                         Stage;                                             // 0x0060(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C33[0x4];                                     // 0x0064(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGzRedeployTerminalUsageEventPayload) == 0x000008, "Wrong alignment on FGzRedeployTerminalUsageEventPayload");
static_assert(sizeof(FGzRedeployTerminalUsageEventPayload) == 0x000068, "Wrong size on FGzRedeployTerminalUsageEventPayload");
static_assert(offsetof(FGzRedeployTerminalUsageEventPayload, Callers) == 0x000010, "Member 'FGzRedeployTerminalUsageEventPayload::Callers' has a wrong offset!");
static_assert(offsetof(FGzRedeployTerminalUsageEventPayload, Stage) == 0x000060, "Member 'FGzRedeployTerminalUsageEventPayload::Stage' has a wrong offset!");

// ScriptStruct G01.GzPlayerPlacementReceivedTelemetryEventPayload
// 0x0008 (0x0028 - 0x0020)
struct FGzPlayerPlacementReceivedTelemetryEventPayload final : public FGzPlayerTelemetryEventPayload
{
public:
	int32                                         Placement;                                         // 0x0020(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C34[0x4];                                     // 0x0024(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGzPlayerPlacementReceivedTelemetryEventPayload) == 0x000008, "Wrong alignment on FGzPlayerPlacementReceivedTelemetryEventPayload");
static_assert(sizeof(FGzPlayerPlacementReceivedTelemetryEventPayload) == 0x000028, "Wrong size on FGzPlayerPlacementReceivedTelemetryEventPayload");
static_assert(offsetof(FGzPlayerPlacementReceivedTelemetryEventPayload, Placement) == 0x000020, "Member 'FGzPlayerPlacementReceivedTelemetryEventPayload::Placement' has a wrong offset!");

// ScriptStruct G01.GzTeamsAliveOverTheMatchEventPayload
// 0x0008 (0x0018 - 0x0010)
struct FGzTeamsAliveOverTheMatchEventPayload final : public FGzTitleTelemetryEventPayload
{
public:
	float                                         Radius;                                            // 0x0010(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Teams;                                             // 0x0014(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzTeamsAliveOverTheMatchEventPayload) == 0x000008, "Wrong alignment on FGzTeamsAliveOverTheMatchEventPayload");
static_assert(sizeof(FGzTeamsAliveOverTheMatchEventPayload) == 0x000018, "Wrong size on FGzTeamsAliveOverTheMatchEventPayload");
static_assert(offsetof(FGzTeamsAliveOverTheMatchEventPayload, Radius) == 0x000010, "Member 'FGzTeamsAliveOverTheMatchEventPayload::Radius' has a wrong offset!");
static_assert(offsetof(FGzTeamsAliveOverTheMatchEventPayload, Teams) == 0x000014, "Member 'FGzTeamsAliveOverTheMatchEventPayload::Teams' has a wrong offset!");

// ScriptStruct G01.GzTimeBetweenObjectiveStatesEventPayload
// 0x0010 (0x0020 - 0x0010)
struct FGzTimeBetweenObjectiveStatesEventPayload final : public FGzTitleTelemetryEventPayload
{
public:
	class FName                                   MissionName;                                       // 0x0010(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int8                                          InteractionPhase;                                  // 0x0018(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C35[0x3];                                     // 0x0019(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         PhaseTime;                                         // 0x001C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzTimeBetweenObjectiveStatesEventPayload) == 0x000008, "Wrong alignment on FGzTimeBetweenObjectiveStatesEventPayload");
static_assert(sizeof(FGzTimeBetweenObjectiveStatesEventPayload) == 0x000020, "Wrong size on FGzTimeBetweenObjectiveStatesEventPayload");
static_assert(offsetof(FGzTimeBetweenObjectiveStatesEventPayload, MissionName) == 0x000010, "Member 'FGzTimeBetweenObjectiveStatesEventPayload::MissionName' has a wrong offset!");
static_assert(offsetof(FGzTimeBetweenObjectiveStatesEventPayload, InteractionPhase) == 0x000018, "Member 'FGzTimeBetweenObjectiveStatesEventPayload::InteractionPhase' has a wrong offset!");
static_assert(offsetof(FGzTimeBetweenObjectiveStatesEventPayload, PhaseTime) == 0x00001C, "Member 'FGzTimeBetweenObjectiveStatesEventPayload::PhaseTime' has a wrong offset!");

// ScriptStruct G01.GzUnityMatchIdReceivedEventPayload
// 0x0020 (0x0030 - 0x0010)
struct FGzUnityMatchIdReceivedEventPayload final : public FGzTitleTelemetryEventPayload
{
public:
	class FString                                 UnityMatchId;                                      // 0x0010(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Address;                                           // 0x0020(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzUnityMatchIdReceivedEventPayload) == 0x000008, "Wrong alignment on FGzUnityMatchIdReceivedEventPayload");
static_assert(sizeof(FGzUnityMatchIdReceivedEventPayload) == 0x000030, "Wrong size on FGzUnityMatchIdReceivedEventPayload");
static_assert(offsetof(FGzUnityMatchIdReceivedEventPayload, UnityMatchId) == 0x000010, "Member 'FGzUnityMatchIdReceivedEventPayload::UnityMatchId' has a wrong offset!");
static_assert(offsetof(FGzUnityMatchIdReceivedEventPayload, Address) == 0x000020, "Member 'FGzUnityMatchIdReceivedEventPayload::Address' has a wrong offset!");

// ScriptStruct G01.GzZoneFinalStageEventPayload
// 0x0018 (0x0028 - 0x0010)
struct FGzZoneFinalStageEventPayload final : public FGzTitleTelemetryEventPayload
{
public:
	struct FVector2D                              Location;                                          // 0x0010(0x0010)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Stage;                                             // 0x0020(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C36[0x4];                                     // 0x0024(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGzZoneFinalStageEventPayload) == 0x000008, "Wrong alignment on FGzZoneFinalStageEventPayload");
static_assert(sizeof(FGzZoneFinalStageEventPayload) == 0x000028, "Wrong size on FGzZoneFinalStageEventPayload");
static_assert(offsetof(FGzZoneFinalStageEventPayload, Location) == 0x000010, "Member 'FGzZoneFinalStageEventPayload::Location' has a wrong offset!");
static_assert(offsetof(FGzZoneFinalStageEventPayload, Stage) == 0x000020, "Member 'FGzZoneFinalStageEventPayload::Stage' has a wrong offset!");

// ScriptStruct G01.GzTetherPair
// 0x0018 (0x0018 - 0x0000)
struct FGzTetherPair final
{
public:
	class AActor*                                 FirstTether;                                       // 0x0000(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 SecondTether;                                      // 0x0008(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 TetherLink;                                        // 0x0010(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzTetherPair) == 0x000008, "Wrong alignment on FGzTetherPair");
static_assert(sizeof(FGzTetherPair) == 0x000018, "Wrong size on FGzTetherPair");
static_assert(offsetof(FGzTetherPair, FirstTether) == 0x000000, "Member 'FGzTetherPair::FirstTether' has a wrong offset!");
static_assert(offsetof(FGzTetherPair, SecondTether) == 0x000008, "Member 'FGzTetherPair::SecondTether' has a wrong offset!");
static_assert(offsetof(FGzTetherPair, TetherLink) == 0x000010, "Member 'FGzTetherPair::TetherLink' has a wrong offset!");

// ScriptStruct G01.GzThrowableShieldTargetingParameters_User
// 0x0010 (0x0010 - 0x0000)
struct FGzThrowableShieldTargetingParameters_User final
{
public:
	float                                         FocusAngle;                                        // 0x0000(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FocusTimeSec;                                      // 0x0004(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxDistance;                                       // 0x0008(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TargetInvalidationTimeSec;                         // 0x000C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzThrowableShieldTargetingParameters_User) == 0x000004, "Wrong alignment on FGzThrowableShieldTargetingParameters_User");
static_assert(sizeof(FGzThrowableShieldTargetingParameters_User) == 0x000010, "Wrong size on FGzThrowableShieldTargetingParameters_User");
static_assert(offsetof(FGzThrowableShieldTargetingParameters_User, FocusAngle) == 0x000000, "Member 'FGzThrowableShieldTargetingParameters_User::FocusAngle' has a wrong offset!");
static_assert(offsetof(FGzThrowableShieldTargetingParameters_User, FocusTimeSec) == 0x000004, "Member 'FGzThrowableShieldTargetingParameters_User::FocusTimeSec' has a wrong offset!");
static_assert(offsetof(FGzThrowableShieldTargetingParameters_User, MaxDistance) == 0x000008, "Member 'FGzThrowableShieldTargetingParameters_User::MaxDistance' has a wrong offset!");
static_assert(offsetof(FGzThrowableShieldTargetingParameters_User, TargetInvalidationTimeSec) == 0x00000C, "Member 'FGzThrowableShieldTargetingParameters_User::TargetInvalidationTimeSec' has a wrong offset!");

// ScriptStruct G01.GzThrowableShieldTargetingParameters_Shield
// 0x0014 (0x0014 - 0x0000)
struct FGzThrowableShieldTargetingParameters_Shield final
{
public:
	bool                                          bEnableAutoTargetingAfterFirstHit;                 // 0x0000(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C37[0x3];                                     // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         AutoTargetingRadius;                               // 0x0004(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AutoTargetingFocusTimeSec;                         // 0x0008(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bApplyCooldownWhenAutoTargetingDisabled;           // 0x000C(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C38[0x3];                                     // 0x000D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         AutoTargetingCooldownTimeSec;                      // 0x0010(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzThrowableShieldTargetingParameters_Shield) == 0x000004, "Wrong alignment on FGzThrowableShieldTargetingParameters_Shield");
static_assert(sizeof(FGzThrowableShieldTargetingParameters_Shield) == 0x000014, "Wrong size on FGzThrowableShieldTargetingParameters_Shield");
static_assert(offsetof(FGzThrowableShieldTargetingParameters_Shield, bEnableAutoTargetingAfterFirstHit) == 0x000000, "Member 'FGzThrowableShieldTargetingParameters_Shield::bEnableAutoTargetingAfterFirstHit' has a wrong offset!");
static_assert(offsetof(FGzThrowableShieldTargetingParameters_Shield, AutoTargetingRadius) == 0x000004, "Member 'FGzThrowableShieldTargetingParameters_Shield::AutoTargetingRadius' has a wrong offset!");
static_assert(offsetof(FGzThrowableShieldTargetingParameters_Shield, AutoTargetingFocusTimeSec) == 0x000008, "Member 'FGzThrowableShieldTargetingParameters_Shield::AutoTargetingFocusTimeSec' has a wrong offset!");
static_assert(offsetof(FGzThrowableShieldTargetingParameters_Shield, bApplyCooldownWhenAutoTargetingDisabled) == 0x00000C, "Member 'FGzThrowableShieldTargetingParameters_Shield::bApplyCooldownWhenAutoTargetingDisabled' has a wrong offset!");
static_assert(offsetof(FGzThrowableShieldTargetingParameters_Shield, AutoTargetingCooldownTimeSec) == 0x000010, "Member 'FGzThrowableShieldTargetingParameters_Shield::AutoTargetingCooldownTimeSec' has a wrong offset!");

// ScriptStruct G01.GzGameplayAbilityTargetData_ThrowableShield
// 0x0040 (0x0048 - 0x0008)
struct FGzGameplayAbilityTargetData_ThrowableShield final : public FGameplayAbilityTargetData
{
public:
	struct FVector                                Location;                                          // 0x0008(0x0018)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               Rotation;                                          // 0x0020(0x0018)(ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	float                                         ChargeCoefficient;                                 // 0x0038(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C39[0x4];                                     // 0x003C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class AActor*                                 TargetActor;                                       // 0x0040(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzGameplayAbilityTargetData_ThrowableShield) == 0x000008, "Wrong alignment on FGzGameplayAbilityTargetData_ThrowableShield");
static_assert(sizeof(FGzGameplayAbilityTargetData_ThrowableShield) == 0x000048, "Wrong size on FGzGameplayAbilityTargetData_ThrowableShield");
static_assert(offsetof(FGzGameplayAbilityTargetData_ThrowableShield, Location) == 0x000008, "Member 'FGzGameplayAbilityTargetData_ThrowableShield::Location' has a wrong offset!");
static_assert(offsetof(FGzGameplayAbilityTargetData_ThrowableShield, Rotation) == 0x000020, "Member 'FGzGameplayAbilityTargetData_ThrowableShield::Rotation' has a wrong offset!");
static_assert(offsetof(FGzGameplayAbilityTargetData_ThrowableShield, ChargeCoefficient) == 0x000038, "Member 'FGzGameplayAbilityTargetData_ThrowableShield::ChargeCoefficient' has a wrong offset!");
static_assert(offsetof(FGzGameplayAbilityTargetData_ThrowableShield, TargetActor) == 0x000040, "Member 'FGzGameplayAbilityTargetData_ThrowableShield::TargetActor' has a wrong offset!");

// ScriptStruct G01.GzTitleDataWrapper
// 0x0050 (0x0050 - 0x0000)
struct FGzTitleDataWrapper final
{
public:
	TMap<class FString, class FString>            Data;                                              // 0x0000(0x0050)(NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzTitleDataWrapper) == 0x000008, "Wrong alignment on FGzTitleDataWrapper");
static_assert(sizeof(FGzTitleDataWrapper) == 0x000050, "Wrong size on FGzTitleDataWrapper");
static_assert(offsetof(FGzTitleDataWrapper, Data) == 0x000000, "Member 'FGzTitleDataWrapper::Data' has a wrong offset!");

// ScriptStruct G01.GzTitlePlayerAccountIdPackage
// 0x0010 (0x0078 - 0x0068)
struct FGzTitlePlayerAccountIdPackage final : public FGzPlayFabClientPackage
{
public:
	class FString                                 TitleAccountId;                                    // 0x0068(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzTitlePlayerAccountIdPackage) == 0x000008, "Wrong alignment on FGzTitlePlayerAccountIdPackage");
static_assert(sizeof(FGzTitlePlayerAccountIdPackage) == 0x000078, "Wrong size on FGzTitlePlayerAccountIdPackage");
static_assert(offsetof(FGzTitlePlayerAccountIdPackage, TitleAccountId) == 0x000068, "Member 'FGzTitlePlayerAccountIdPackage::TitleAccountId' has a wrong offset!");

// ScriptStruct G01.GzTrackEventPointDetails
// 0x0010 (0x0010 - 0x0000)
struct FGzTrackEventPointDetails final
{
public:
	int32                                         PointIndex;                                        // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C3A[0x4];                                     // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UGzTrackEventBase*                      Event;                                             // 0x0008(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, PersistentInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzTrackEventPointDetails) == 0x000008, "Wrong alignment on FGzTrackEventPointDetails");
static_assert(sizeof(FGzTrackEventPointDetails) == 0x000010, "Wrong size on FGzTrackEventPointDetails");
static_assert(offsetof(FGzTrackEventPointDetails, PointIndex) == 0x000000, "Member 'FGzTrackEventPointDetails::PointIndex' has a wrong offset!");
static_assert(offsetof(FGzTrackEventPointDetails, Event) == 0x000008, "Member 'FGzTrackEventPointDetails::Event' has a wrong offset!");

// ScriptStruct G01.GzTrackEventSegmentDetails
// 0x0018 (0x0018 - 0x0000)
struct FGzTrackEventSegmentDetails final
{
public:
	int32                                         StartPointIndex;                                   // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         EndPointIndex;                                     // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UGzTrackEventBase*                      StartEvent;                                        // 0x0008(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, PersistentInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UGzTrackEventBase*                      EndEvent;                                          // 0x0010(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, PersistentInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzTrackEventSegmentDetails) == 0x000008, "Wrong alignment on FGzTrackEventSegmentDetails");
static_assert(sizeof(FGzTrackEventSegmentDetails) == 0x000018, "Wrong size on FGzTrackEventSegmentDetails");
static_assert(offsetof(FGzTrackEventSegmentDetails, StartPointIndex) == 0x000000, "Member 'FGzTrackEventSegmentDetails::StartPointIndex' has a wrong offset!");
static_assert(offsetof(FGzTrackEventSegmentDetails, EndPointIndex) == 0x000004, "Member 'FGzTrackEventSegmentDetails::EndPointIndex' has a wrong offset!");
static_assert(offsetof(FGzTrackEventSegmentDetails, StartEvent) == 0x000008, "Member 'FGzTrackEventSegmentDetails::StartEvent' has a wrong offset!");
static_assert(offsetof(FGzTrackEventSegmentDetails, EndEvent) == 0x000010, "Member 'FGzTrackEventSegmentDetails::EndEvent' has a wrong offset!");

// ScriptStruct G01.GzTrackEventsPoint
// 0x0018 (0x0018 - 0x0000)
struct FGzTrackEventsPoint final
{
public:
	TArray<class UGzTrackEventBase*>              Events;                                            // 0x0000(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C3B[0x8];                                     // 0x0010(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGzTrackEventsPoint) == 0x000008, "Wrong alignment on FGzTrackEventsPoint");
static_assert(sizeof(FGzTrackEventsPoint) == 0x000018, "Wrong size on FGzTrackEventsPoint");
static_assert(offsetof(FGzTrackEventsPoint, Events) == 0x000000, "Member 'FGzTrackEventsPoint::Events' has a wrong offset!");

// ScriptStruct G01.GzTrackStopDetails
// 0x000C (0x000C - 0x0000)
struct FGzTrackStopDetails final
{
public:
	int32                                         SplinePointIndex;                                  // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bWaitTime;                                         // 0x0004(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C3C[0x3];                                     // 0x0005(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         StopTime;                                          // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzTrackStopDetails) == 0x000004, "Wrong alignment on FGzTrackStopDetails");
static_assert(sizeof(FGzTrackStopDetails) == 0x00000C, "Wrong size on FGzTrackStopDetails");
static_assert(offsetof(FGzTrackStopDetails, SplinePointIndex) == 0x000000, "Member 'FGzTrackStopDetails::SplinePointIndex' has a wrong offset!");
static_assert(offsetof(FGzTrackStopDetails, bWaitTime) == 0x000004, "Member 'FGzTrackStopDetails::bWaitTime' has a wrong offset!");
static_assert(offsetof(FGzTrackStopDetails, StopTime) == 0x000008, "Member 'FGzTrackStopDetails::StopTime' has a wrong offset!");

// ScriptStruct G01.GzTrackStop
// 0x0010 (0x0010 - 0x0000)
struct FGzTrackStop final
{
public:
	double                                        Distance;                                          // 0x0000(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         StopTime;                                          // 0x0008(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C3D[0x4];                                     // 0x000C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGzTrackStop) == 0x000008, "Wrong alignment on FGzTrackStop");
static_assert(sizeof(FGzTrackStop) == 0x000010, "Wrong size on FGzTrackStop");
static_assert(offsetof(FGzTrackStop, Distance) == 0x000000, "Member 'FGzTrackStop::Distance' has a wrong offset!");
static_assert(offsetof(FGzTrackStop, StopTime) == 0x000008, "Member 'FGzTrackStop::StopTime' has a wrong offset!");

// ScriptStruct G01.GzTrackDistance
// 0x0010 (0x0010 - 0x0000)
struct FGzTrackDistance final
{
public:
	int32                                         LoopCount;                                         // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C3E[0x4];                                     // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	double                                        LoopDistance;                                      // 0x0008(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzTrackDistance) == 0x000008, "Wrong alignment on FGzTrackDistance");
static_assert(sizeof(FGzTrackDistance) == 0x000010, "Wrong size on FGzTrackDistance");
static_assert(offsetof(FGzTrackDistance, LoopCount) == 0x000000, "Member 'FGzTrackDistance::LoopCount' has a wrong offset!");
static_assert(offsetof(FGzTrackDistance, LoopDistance) == 0x000008, "Member 'FGzTrackDistance::LoopDistance' has a wrong offset!");

// ScriptStruct G01.GzTurnInclineCalculationSettings
// 0x0010 (0x0010 - 0x0000)
struct FGzTurnInclineCalculationSettings final
{
public:
	float                                         TurnInclineInterpolationTimeSeconds;               // 0x0000(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TurnInclineFactor;                                 // 0x0004(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TurnInclineDegreeConstraint;                       // 0x0008(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TurnLookaheadInclineDistance;                      // 0x000C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzTurnInclineCalculationSettings) == 0x000004, "Wrong alignment on FGzTurnInclineCalculationSettings");
static_assert(sizeof(FGzTurnInclineCalculationSettings) == 0x000010, "Wrong size on FGzTurnInclineCalculationSettings");
static_assert(offsetof(FGzTurnInclineCalculationSettings, TurnInclineInterpolationTimeSeconds) == 0x000000, "Member 'FGzTurnInclineCalculationSettings::TurnInclineInterpolationTimeSeconds' has a wrong offset!");
static_assert(offsetof(FGzTurnInclineCalculationSettings, TurnInclineFactor) == 0x000004, "Member 'FGzTurnInclineCalculationSettings::TurnInclineFactor' has a wrong offset!");
static_assert(offsetof(FGzTurnInclineCalculationSettings, TurnInclineDegreeConstraint) == 0x000008, "Member 'FGzTurnInclineCalculationSettings::TurnInclineDegreeConstraint' has a wrong offset!");
static_assert(offsetof(FGzTurnInclineCalculationSettings, TurnLookaheadInclineDistance) == 0x00000C, "Member 'FGzTurnInclineCalculationSettings::TurnLookaheadInclineDistance' has a wrong offset!");

// ScriptStruct G01.LocomotionCurrentStates
// 0x0009 (0x0009 - 0x0000)
struct FLocomotionCurrentStates final
{
public:
	EMovementMode                                 PawnMovementMode;                                  // 0x0000(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ELocomotionMovementState                      MovementState;                                     // 0x0001(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ELocomotionMovementState                      PrevMovementState;                                 // 0x0002(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ELocomotionMovementAction                     MovementAction;                                    // 0x0003(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ELocomotionRotationMode                       RotationMode;                                      // 0x0004(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ELocomotionGait                               ActualGait;                                        // 0x0005(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ELocomotionStance                             ActualStance;                                      // 0x0006(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ELocomotionViewMode                           ViewMode;                                          // 0x0007(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ELocomotionOverlayState                       OverlayState;                                      // 0x0008(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FLocomotionCurrentStates) == 0x000001, "Wrong alignment on FLocomotionCurrentStates");
static_assert(sizeof(FLocomotionCurrentStates) == 0x000009, "Wrong size on FLocomotionCurrentStates");
static_assert(offsetof(FLocomotionCurrentStates, PawnMovementMode) == 0x000000, "Member 'FLocomotionCurrentStates::PawnMovementMode' has a wrong offset!");
static_assert(offsetof(FLocomotionCurrentStates, MovementState) == 0x000001, "Member 'FLocomotionCurrentStates::MovementState' has a wrong offset!");
static_assert(offsetof(FLocomotionCurrentStates, PrevMovementState) == 0x000002, "Member 'FLocomotionCurrentStates::PrevMovementState' has a wrong offset!");
static_assert(offsetof(FLocomotionCurrentStates, MovementAction) == 0x000003, "Member 'FLocomotionCurrentStates::MovementAction' has a wrong offset!");
static_assert(offsetof(FLocomotionCurrentStates, RotationMode) == 0x000004, "Member 'FLocomotionCurrentStates::RotationMode' has a wrong offset!");
static_assert(offsetof(FLocomotionCurrentStates, ActualGait) == 0x000005, "Member 'FLocomotionCurrentStates::ActualGait' has a wrong offset!");
static_assert(offsetof(FLocomotionCurrentStates, ActualStance) == 0x000006, "Member 'FLocomotionCurrentStates::ActualStance' has a wrong offset!");
static_assert(offsetof(FLocomotionCurrentStates, ViewMode) == 0x000007, "Member 'FLocomotionCurrentStates::ViewMode' has a wrong offset!");
static_assert(offsetof(FLocomotionCurrentStates, OverlayState) == 0x000008, "Member 'FLocomotionCurrentStates::OverlayState' has a wrong offset!");

// ScriptStruct G01.GzBasicTransactionString
// 0x0030 (0x0030 - 0x0000)
struct FGzBasicTransactionString final
{
public:
	class FString                                 Type;                                              // 0x0000(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Created;                                           // 0x0010(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 ID;                                                // 0x0020(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzBasicTransactionString) == 0x000008, "Wrong alignment on FGzBasicTransactionString");
static_assert(sizeof(FGzBasicTransactionString) == 0x000030, "Wrong size on FGzBasicTransactionString");
static_assert(offsetof(FGzBasicTransactionString, Type) == 0x000000, "Member 'FGzBasicTransactionString::Type' has a wrong offset!");
static_assert(offsetof(FGzBasicTransactionString, Created) == 0x000010, "Member 'FGzBasicTransactionString::Created' has a wrong offset!");
static_assert(offsetof(FGzBasicTransactionString, ID) == 0x000020, "Member 'FGzBasicTransactionString::ID' has a wrong offset!");

// ScriptStruct G01.GzBasicTransactionStringObject
// 0x0010 (0x0010 - 0x0000)
struct FGzBasicTransactionStringObject final
{
public:
	TArray<struct FGzBasicTransactionString>      List;                                              // 0x0000(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzBasicTransactionStringObject) == 0x000008, "Wrong alignment on FGzBasicTransactionStringObject");
static_assert(sizeof(FGzBasicTransactionStringObject) == 0x000010, "Wrong size on FGzBasicTransactionStringObject");
static_assert(offsetof(FGzBasicTransactionStringObject, List) == 0x000000, "Member 'FGzBasicTransactionStringObject::List' has a wrong offset!");

// ScriptStruct G01.GzTrialStage
// 0x0038 (0x0038 - 0x0000)
struct FGzTrialStage final
{
public:
	class FText                                   DisplayName;                                       // 0x0000(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	class FText                                   Description;                                       // 0x0010(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TArray<class UGzRewardData*>                  MetagameRewards;                                   // 0x0020(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	float                                         MaxProgress;                                       // 0x0030(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C3F[0x4];                                     // 0x0034(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGzTrialStage) == 0x000008, "Wrong alignment on FGzTrialStage");
static_assert(sizeof(FGzTrialStage) == 0x000038, "Wrong size on FGzTrialStage");
static_assert(offsetof(FGzTrialStage, DisplayName) == 0x000000, "Member 'FGzTrialStage::DisplayName' has a wrong offset!");
static_assert(offsetof(FGzTrialStage, Description) == 0x000010, "Member 'FGzTrialStage::Description' has a wrong offset!");
static_assert(offsetof(FGzTrialStage, MetagameRewards) == 0x000020, "Member 'FGzTrialStage::MetagameRewards' has a wrong offset!");
static_assert(offsetof(FGzTrialStage, MaxProgress) == 0x000030, "Member 'FGzTrialStage::MaxProgress' has a wrong offset!");

// ScriptStruct G01.GzUIBuilderParams
// 0x0050 (0x0050 - 0x0000)
struct FGzUIBuilderParams final
{
public:
	TSubclassOf<class UGzMTW_Condition>           ConditionWidget;                                   // 0x0000(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UGzMTW_Objective>           ObjectiveWidget;                                   // 0x0008(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UGzMTW_Stage>               StageWidget;                                       // 0x0010(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UGzMTW_Timer>               TimerWidget;                                       // 0x0018(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UGzMTW_Container>           ComposeConditionWidget;                            // 0x0020(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UGzMTW_Container>           UnlockConditionWidget;                             // 0x0028(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UGzMTW_Container>           ComposeObjectiveWidget;                            // 0x0030(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UGzMTW_Container>           SequenceObjectiveWidget;                           // 0x0038(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UGzMTW_Container>           GateObjectiveWidget;                               // 0x0040(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UGzMTW_Container>           SelectObjectiveWidget;                             // 0x0048(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzUIBuilderParams) == 0x000008, "Wrong alignment on FGzUIBuilderParams");
static_assert(sizeof(FGzUIBuilderParams) == 0x000050, "Wrong size on FGzUIBuilderParams");
static_assert(offsetof(FGzUIBuilderParams, ConditionWidget) == 0x000000, "Member 'FGzUIBuilderParams::ConditionWidget' has a wrong offset!");
static_assert(offsetof(FGzUIBuilderParams, ObjectiveWidget) == 0x000008, "Member 'FGzUIBuilderParams::ObjectiveWidget' has a wrong offset!");
static_assert(offsetof(FGzUIBuilderParams, StageWidget) == 0x000010, "Member 'FGzUIBuilderParams::StageWidget' has a wrong offset!");
static_assert(offsetof(FGzUIBuilderParams, TimerWidget) == 0x000018, "Member 'FGzUIBuilderParams::TimerWidget' has a wrong offset!");
static_assert(offsetof(FGzUIBuilderParams, ComposeConditionWidget) == 0x000020, "Member 'FGzUIBuilderParams::ComposeConditionWidget' has a wrong offset!");
static_assert(offsetof(FGzUIBuilderParams, UnlockConditionWidget) == 0x000028, "Member 'FGzUIBuilderParams::UnlockConditionWidget' has a wrong offset!");
static_assert(offsetof(FGzUIBuilderParams, ComposeObjectiveWidget) == 0x000030, "Member 'FGzUIBuilderParams::ComposeObjectiveWidget' has a wrong offset!");
static_assert(offsetof(FGzUIBuilderParams, SequenceObjectiveWidget) == 0x000038, "Member 'FGzUIBuilderParams::SequenceObjectiveWidget' has a wrong offset!");
static_assert(offsetof(FGzUIBuilderParams, GateObjectiveWidget) == 0x000040, "Member 'FGzUIBuilderParams::GateObjectiveWidget' has a wrong offset!");
static_assert(offsetof(FGzUIBuilderParams, SelectObjectiveWidget) == 0x000048, "Member 'FGzUIBuilderParams::SelectObjectiveWidget' has a wrong offset!");

// ScriptStruct G01.GzUISoundData
// 0x0008 (0x0010 - 0x0008)
struct FGzUISoundData final : public FTableRowBase
{
public:
	class USoundCue*                              SoundQue;                                          // 0x0008(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzUISoundData) == 0x000008, "Wrong alignment on FGzUISoundData");
static_assert(sizeof(FGzUISoundData) == 0x000010, "Wrong size on FGzUISoundData");
static_assert(offsetof(FGzUISoundData, SoundQue) == 0x000008, "Member 'FGzUISoundData::SoundQue' has a wrong offset!");

// ScriptStruct G01.GzUiStatLimits
// 0x0008 (0x0008 - 0x0000)
struct FGzUiStatLimits final
{
public:
	float                                         MinValue;                                          // 0x0000(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxValue;                                          // 0x0004(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzUiStatLimits) == 0x000004, "Wrong alignment on FGzUiStatLimits");
static_assert(sizeof(FGzUiStatLimits) == 0x000008, "Wrong size on FGzUiStatLimits");
static_assert(offsetof(FGzUiStatLimits, MinValue) == 0x000000, "Member 'FGzUiStatLimits::MinValue' has a wrong offset!");
static_assert(offsetof(FGzUiStatLimits, MaxValue) == 0x000004, "Member 'FGzUiStatLimits::MaxValue' has a wrong offset!");

// ScriptStruct G01.GzMessageNetDataNetSerializerConfig
// 0x0000 (0x0010 - 0x0010)
struct FGzMessageNetDataNetSerializerConfig final : public FNetSerializerConfig
{
};
static_assert(alignof(FGzMessageNetDataNetSerializerConfig) == 0x000008, "Wrong alignment on FGzMessageNetDataNetSerializerConfig");
static_assert(sizeof(FGzMessageNetDataNetSerializerConfig) == 0x000010, "Wrong size on FGzMessageNetDataNetSerializerConfig");

// ScriptStruct G01.GzUnblockPlayerPackage
// 0x0010 (0x0078 - 0x0068)
struct FGzUnblockPlayerPackage final : public FGzPlayFabClientPackage
{
public:
	class FString                                 BlockedPlayerPlayFabId;                            // 0x0068(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzUnblockPlayerPackage) == 0x000008, "Wrong alignment on FGzUnblockPlayerPackage");
static_assert(sizeof(FGzUnblockPlayerPackage) == 0x000078, "Wrong size on FGzUnblockPlayerPackage");
static_assert(offsetof(FGzUnblockPlayerPackage, BlockedPlayerPlayFabId) == 0x000068, "Member 'FGzUnblockPlayerPackage::BlockedPlayerPlayFabId' has a wrong offset!");

// ScriptStruct G01.GzUnityMatchmakingCancelPackage
// 0x0020 (0x0088 - 0x0068)
struct FGzUnityMatchmakingCancelPackage final : public FGzPlayFabClientPackage
{
public:
	class FString                                 TicketId;                                          // 0x0068(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 UnityUserId;                                       // 0x0078(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzUnityMatchmakingCancelPackage) == 0x000008, "Wrong alignment on FGzUnityMatchmakingCancelPackage");
static_assert(sizeof(FGzUnityMatchmakingCancelPackage) == 0x000088, "Wrong size on FGzUnityMatchmakingCancelPackage");
static_assert(offsetof(FGzUnityMatchmakingCancelPackage, TicketId) == 0x000068, "Member 'FGzUnityMatchmakingCancelPackage::TicketId' has a wrong offset!");
static_assert(offsetof(FGzUnityMatchmakingCancelPackage, UnityUserId) == 0x000078, "Member 'FGzUnityMatchmakingCancelPackage::UnityUserId' has a wrong offset!");

// ScriptStruct G01.GzUnityMatchmakingStartResult
// 0x0020 (0x0100 - 0x00E0)
struct FGzUnityMatchmakingStartResult final : public FGzPlayFabResultBase
{
public:
	struct FGzMatchmakingTicketInfo               MatchmakingTicketInfo;                             // 0x00E0(0x0010)(NativeAccessSpecifierPublic)
	class FString                                 PartyId;                                           // 0x00F0(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzUnityMatchmakingStartResult) == 0x000008, "Wrong alignment on FGzUnityMatchmakingStartResult");
static_assert(sizeof(FGzUnityMatchmakingStartResult) == 0x000100, "Wrong size on FGzUnityMatchmakingStartResult");
static_assert(offsetof(FGzUnityMatchmakingStartResult, MatchmakingTicketInfo) == 0x0000E0, "Member 'FGzUnityMatchmakingStartResult::MatchmakingTicketInfo' has a wrong offset!");
static_assert(offsetof(FGzUnityMatchmakingStartResult, PartyId) == 0x0000F0, "Member 'FGzUnityMatchmakingStartResult::PartyId' has a wrong offset!");

// ScriptStruct G01.GzUnityMatchmakingCancelResult
// 0x0000 (0x00E0 - 0x00E0)
struct FGzUnityMatchmakingCancelResult final : public FGzPlayFabResultBase
{
};
static_assert(alignof(FGzUnityMatchmakingCancelResult) == 0x000008, "Wrong alignment on FGzUnityMatchmakingCancelResult");
static_assert(sizeof(FGzUnityMatchmakingCancelResult) == 0x0000E0, "Wrong size on FGzUnityMatchmakingCancelResult");

// ScriptStruct G01.UnityMatchmakingSaveData
// 0x0060 (0x0060 - 0x0000)
struct FUnityMatchmakingSaveData final
{
public:
	class FString                                 Queue;                                             // 0x0000(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSet<class FString>                           RegionIds;                                         // 0x0010(0x0050)(NativeAccessSpecifierPublic)
};
static_assert(alignof(FUnityMatchmakingSaveData) == 0x000008, "Wrong alignment on FUnityMatchmakingSaveData");
static_assert(sizeof(FUnityMatchmakingSaveData) == 0x000060, "Wrong size on FUnityMatchmakingSaveData");
static_assert(offsetof(FUnityMatchmakingSaveData, Queue) == 0x000000, "Member 'FUnityMatchmakingSaveData::Queue' has a wrong offset!");
static_assert(offsetof(FUnityMatchmakingSaveData, RegionIds) == 0x000010, "Member 'FUnityMatchmakingSaveData::RegionIds' has a wrong offset!");

// ScriptStruct G01.GzUnsubscribeXsollaPackage
// 0x0000 (0x0068 - 0x0068)
struct FGzUnsubscribeXsollaPackage final : public FGzPlayFabClientPackage
{
};
static_assert(alignof(FGzUnsubscribeXsollaPackage) == 0x000008, "Wrong alignment on FGzUnsubscribeXsollaPackage");
static_assert(sizeof(FGzUnsubscribeXsollaPackage) == 0x000068, "Wrong size on FGzUnsubscribeXsollaPackage");

// ScriptStruct G01.GzValidateItemPackage
// 0x0010 (0x0078 - 0x0068)
struct FGzValidateItemPackage final : public FGzPlayFabClientPackage
{
public:
	class FString                                 ItemInstanceId;                                    // 0x0068(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzValidateItemPackage) == 0x000008, "Wrong alignment on FGzValidateItemPackage");
static_assert(sizeof(FGzValidateItemPackage) == 0x000078, "Wrong size on FGzValidateItemPackage");
static_assert(offsetof(FGzValidateItemPackage, ItemInstanceId) == 0x000068, "Member 'FGzValidateItemPackage::ItemInstanceId' has a wrong offset!");

// ScriptStruct G01.GzVehicleWheelState
// 0x0002 (0x0002 - 0x0000)
struct FGzVehicleWheelState final
{
public:
	bool                                          bIsInContact;                                      // 0x0000(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsSkidding;                                       // 0x0001(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzVehicleWheelState) == 0x000001, "Wrong alignment on FGzVehicleWheelState");
static_assert(sizeof(FGzVehicleWheelState) == 0x000002, "Wrong size on FGzVehicleWheelState");
static_assert(offsetof(FGzVehicleWheelState, bIsInContact) == 0x000000, "Member 'FGzVehicleWheelState::bIsInContact' has a wrong offset!");
static_assert(offsetof(FGzVehicleWheelState, bIsSkidding) == 0x000001, "Member 'FGzVehicleWheelState::bIsSkidding' has a wrong offset!");

// ScriptStruct G01.GzSeatConfig
// 0x0030 (0x0030 - 0x0000)
struct FGzSeatConfig final
{
public:
	EGzVehicleSeatType                            SeatType;                                          // 0x0000(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C40[0x3];                                     // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   Socket;                                            // 0x0004(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAttachAtBottomOfCapsule;                          // 0x000C(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAllowControllerRotationYaw;                       // 0x000D(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C41[0x2];                                     // 0x000E(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTag                           CameraModeTag;                                     // 0x0010(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           GameplayEventTag;                                  // 0x0018(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDisableVehicleCameraCollision;                    // 0x0020(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C42[0x7];                                     // 0x0021(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UGzPawnInputMappingConfig*              InputMappingConfig;                                // 0x0028(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzSeatConfig) == 0x000008, "Wrong alignment on FGzSeatConfig");
static_assert(sizeof(FGzSeatConfig) == 0x000030, "Wrong size on FGzSeatConfig");
static_assert(offsetof(FGzSeatConfig, SeatType) == 0x000000, "Member 'FGzSeatConfig::SeatType' has a wrong offset!");
static_assert(offsetof(FGzSeatConfig, Socket) == 0x000004, "Member 'FGzSeatConfig::Socket' has a wrong offset!");
static_assert(offsetof(FGzSeatConfig, bAttachAtBottomOfCapsule) == 0x00000C, "Member 'FGzSeatConfig::bAttachAtBottomOfCapsule' has a wrong offset!");
static_assert(offsetof(FGzSeatConfig, bAllowControllerRotationYaw) == 0x00000D, "Member 'FGzSeatConfig::bAllowControllerRotationYaw' has a wrong offset!");
static_assert(offsetof(FGzSeatConfig, CameraModeTag) == 0x000010, "Member 'FGzSeatConfig::CameraModeTag' has a wrong offset!");
static_assert(offsetof(FGzSeatConfig, GameplayEventTag) == 0x000018, "Member 'FGzSeatConfig::GameplayEventTag' has a wrong offset!");
static_assert(offsetof(FGzSeatConfig, bDisableVehicleCameraCollision) == 0x000020, "Member 'FGzSeatConfig::bDisableVehicleCameraCollision' has a wrong offset!");
static_assert(offsetof(FGzSeatConfig, InputMappingConfig) == 0x000028, "Member 'FGzSeatConfig::InputMappingConfig' has a wrong offset!");

// ScriptStruct G01.GzDelayedVFXSpawnData
// 0x0018 (0x0018 - 0x0000)
struct FGzDelayedVFXSpawnData final
{
public:
	class UNiagaraSystem*                         NiagaraSystem;                                     // 0x0000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FGzDelayedSpawnParams>          DelayedSpawnParams;                                // 0x0008(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzDelayedVFXSpawnData) == 0x000008, "Wrong alignment on FGzDelayedVFXSpawnData");
static_assert(sizeof(FGzDelayedVFXSpawnData) == 0x000018, "Wrong size on FGzDelayedVFXSpawnData");
static_assert(offsetof(FGzDelayedVFXSpawnData, NiagaraSystem) == 0x000000, "Member 'FGzDelayedVFXSpawnData::NiagaraSystem' has a wrong offset!");
static_assert(offsetof(FGzDelayedVFXSpawnData, DelayedSpawnParams) == 0x000008, "Member 'FGzDelayedVFXSpawnData::DelayedSpawnParams' has a wrong offset!");

// ScriptStruct G01.GzViewpointTransitionParameters
// 0x0030 (0x0030 - 0x0000)
struct FGzViewpointTransitionParameters final
{
public:
	TArray<class FName>                           From;                                              // 0x0000(0x0010)(Edit, ZeroConstructor, DisableEditOnTemplate, NativeAccessSpecifierPublic)
	TArray<class FName>                           To;                                                // 0x0010(0x0010)(Edit, ZeroConstructor, DisableEditOnTemplate, NativeAccessSpecifierPublic)
	float                                         TransitionDuration;                                // 0x0020(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EViewTargetBlendFunction                      BlendFunction;                                     // 0x0024(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C43[0x3];                                     // 0x0025(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         BlendExponent;                                     // 0x0028(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C44[0x4];                                     // 0x002C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGzViewpointTransitionParameters) == 0x000008, "Wrong alignment on FGzViewpointTransitionParameters");
static_assert(sizeof(FGzViewpointTransitionParameters) == 0x000030, "Wrong size on FGzViewpointTransitionParameters");
static_assert(offsetof(FGzViewpointTransitionParameters, From) == 0x000000, "Member 'FGzViewpointTransitionParameters::From' has a wrong offset!");
static_assert(offsetof(FGzViewpointTransitionParameters, To) == 0x000010, "Member 'FGzViewpointTransitionParameters::To' has a wrong offset!");
static_assert(offsetof(FGzViewpointTransitionParameters, TransitionDuration) == 0x000020, "Member 'FGzViewpointTransitionParameters::TransitionDuration' has a wrong offset!");
static_assert(offsetof(FGzViewpointTransitionParameters, BlendFunction) == 0x000024, "Member 'FGzViewpointTransitionParameters::BlendFunction' has a wrong offset!");
static_assert(offsetof(FGzViewpointTransitionParameters, BlendExponent) == 0x000028, "Member 'FGzViewpointTransitionParameters::BlendExponent' has a wrong offset!");

// ScriptStruct G01.GzVoiceChatAudioDevice
// 0x0020 (0x0020 - 0x0000)
struct FGzVoiceChatAudioDevice final
{
public:
	class FString                                 ID;                                                // 0x0000(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Name;                                              // 0x0010(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzVoiceChatAudioDevice) == 0x000008, "Wrong alignment on FGzVoiceChatAudioDevice");
static_assert(sizeof(FGzVoiceChatAudioDevice) == 0x000020, "Wrong size on FGzVoiceChatAudioDevice");
static_assert(offsetof(FGzVoiceChatAudioDevice, ID) == 0x000000, "Member 'FGzVoiceChatAudioDevice::ID' has a wrong offset!");
static_assert(offsetof(FGzVoiceChatAudioDevice, Name) == 0x000010, "Member 'FGzVoiceChatAudioDevice::Name' has a wrong offset!");

// ScriptStruct G01.GzVoiceChatTalker
// 0x0038 (0x0038 - 0x0000)
struct FGzVoiceChatTalker final
{
public:
	class FString                                 Name;                                              // 0x0000(0x0010)(BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UUserWidget*                            Widget;                                            // 0x0010(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 ClanTag;                                           // 0x0018(0x0010)(BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bPro;                                              // 0x0028(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bLocalPlayer;                                      // 0x0029(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C45[0xE];                                     // 0x002A(0x000E)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGzVoiceChatTalker) == 0x000008, "Wrong alignment on FGzVoiceChatTalker");
static_assert(sizeof(FGzVoiceChatTalker) == 0x000038, "Wrong size on FGzVoiceChatTalker");
static_assert(offsetof(FGzVoiceChatTalker, Name) == 0x000000, "Member 'FGzVoiceChatTalker::Name' has a wrong offset!");
static_assert(offsetof(FGzVoiceChatTalker, Widget) == 0x000010, "Member 'FGzVoiceChatTalker::Widget' has a wrong offset!");
static_assert(offsetof(FGzVoiceChatTalker, ClanTag) == 0x000018, "Member 'FGzVoiceChatTalker::ClanTag' has a wrong offset!");
static_assert(offsetof(FGzVoiceChatTalker, bPro) == 0x000028, "Member 'FGzVoiceChatTalker::bPro' has a wrong offset!");
static_assert(offsetof(FGzVoiceChatTalker, bLocalPlayer) == 0x000029, "Member 'FGzVoiceChatTalker::bLocalPlayer' has a wrong offset!");

// ScriptStruct G01.GzSoftVoiceLineData
// 0x0030 (0x0030 - 0x0000)
struct FGzSoftVoiceLineData final
{
public:
	TSoftObjectPtr<class UAkAudioEvent>           Event;                                             // 0x0000(0x0028)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EGzVoiceLinePriority                          Priority;                                          // 0x0028(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bPlayOnlyForFriendly;                              // 0x0029(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C46[0x6];                                     // 0x002A(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGzSoftVoiceLineData) == 0x000008, "Wrong alignment on FGzSoftVoiceLineData");
static_assert(sizeof(FGzSoftVoiceLineData) == 0x000030, "Wrong size on FGzSoftVoiceLineData");
static_assert(offsetof(FGzSoftVoiceLineData, Event) == 0x000000, "Member 'FGzSoftVoiceLineData::Event' has a wrong offset!");
static_assert(offsetof(FGzSoftVoiceLineData, Priority) == 0x000028, "Member 'FGzSoftVoiceLineData::Priority' has a wrong offset!");
static_assert(offsetof(FGzSoftVoiceLineData, bPlayOnlyForFriendly) == 0x000029, "Member 'FGzSoftVoiceLineData::bPlayOnlyForFriendly' has a wrong offset!");

// ScriptStruct G01.GzVoiceLineTimeoutData
// 0x0050 (0x0050 - 0x0000)
struct FGzVoiceLineTimeoutData final
{
public:
	TSet<class UAkAudioEvent*>                    EventsOnTimeout;                                   // 0x0000(0x0050)(Transient, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzVoiceLineTimeoutData) == 0x000008, "Wrong alignment on FGzVoiceLineTimeoutData");
static_assert(sizeof(FGzVoiceLineTimeoutData) == 0x000050, "Wrong size on FGzVoiceLineTimeoutData");
static_assert(offsetof(FGzVoiceLineTimeoutData, EventsOnTimeout) == 0x000000, "Member 'FGzVoiceLineTimeoutData::EventsOnTimeout' has a wrong offset!");

// ScriptStruct G01.GzDamageAreaAIData
// 0x0038 (0x0038 - 0x0000)
struct FGzDamageAreaAIData final
{
public:
	class UCurveFloat*                            DistanceProbabilityCurve;                          // 0x0000(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              OffsetRangeLeftRight;                              // 0x0008(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              OffsetRangeBottomTop;                              // 0x0018(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCurveFloat*                            OffsetRatioDistanceCurve;                          // 0x0028(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TokenAbsentOffsetRatio;                            // 0x0030(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C47[0x4];                                     // 0x0034(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGzDamageAreaAIData) == 0x000008, "Wrong alignment on FGzDamageAreaAIData");
static_assert(sizeof(FGzDamageAreaAIData) == 0x000038, "Wrong size on FGzDamageAreaAIData");
static_assert(offsetof(FGzDamageAreaAIData, DistanceProbabilityCurve) == 0x000000, "Member 'FGzDamageAreaAIData::DistanceProbabilityCurve' has a wrong offset!");
static_assert(offsetof(FGzDamageAreaAIData, OffsetRangeLeftRight) == 0x000008, "Member 'FGzDamageAreaAIData::OffsetRangeLeftRight' has a wrong offset!");
static_assert(offsetof(FGzDamageAreaAIData, OffsetRangeBottomTop) == 0x000018, "Member 'FGzDamageAreaAIData::OffsetRangeBottomTop' has a wrong offset!");
static_assert(offsetof(FGzDamageAreaAIData, OffsetRatioDistanceCurve) == 0x000028, "Member 'FGzDamageAreaAIData::OffsetRatioDistanceCurve' has a wrong offset!");
static_assert(offsetof(FGzDamageAreaAIData, TokenAbsentOffsetRatio) == 0x000030, "Member 'FGzDamageAreaAIData::TokenAbsentOffsetRatio' has a wrong offset!");

// ScriptStruct G01.GzWeaponReloadAnimationData
// 0x0040 (0x0040 - 0x0000)
struct FGzWeaponReloadAnimationData final
{
public:
	int32                                         LimbState;                                         // 0x0000(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECameraShoulderState                          CameraState;                                       // 0x0004(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShouldPlayMontage;                                // 0x0005(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C48[0x2];                                     // 0x0006(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UAnimMontage*>                   ReloadMontage_Character;                           // 0x0008(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	class UAnimMontage*                           ReloadMontage_Weapon;                              // 0x0018(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class UAnimMontage*>                   ReloadMontage_Character_EmptyMag;                  // 0x0020(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	class UAnimMontage*                           ReloadMontage_Weapon_EmptyMag;                     // 0x0030(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ReloadTimeSeconds;                                 // 0x0038(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ReloadTimeSeconds_EmptyMag;                        // 0x003C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
};
static_assert(alignof(FGzWeaponReloadAnimationData) == 0x000008, "Wrong alignment on FGzWeaponReloadAnimationData");
static_assert(sizeof(FGzWeaponReloadAnimationData) == 0x000040, "Wrong size on FGzWeaponReloadAnimationData");
static_assert(offsetof(FGzWeaponReloadAnimationData, LimbState) == 0x000000, "Member 'FGzWeaponReloadAnimationData::LimbState' has a wrong offset!");
static_assert(offsetof(FGzWeaponReloadAnimationData, CameraState) == 0x000004, "Member 'FGzWeaponReloadAnimationData::CameraState' has a wrong offset!");
static_assert(offsetof(FGzWeaponReloadAnimationData, bShouldPlayMontage) == 0x000005, "Member 'FGzWeaponReloadAnimationData::bShouldPlayMontage' has a wrong offset!");
static_assert(offsetof(FGzWeaponReloadAnimationData, ReloadMontage_Character) == 0x000008, "Member 'FGzWeaponReloadAnimationData::ReloadMontage_Character' has a wrong offset!");
static_assert(offsetof(FGzWeaponReloadAnimationData, ReloadMontage_Weapon) == 0x000018, "Member 'FGzWeaponReloadAnimationData::ReloadMontage_Weapon' has a wrong offset!");
static_assert(offsetof(FGzWeaponReloadAnimationData, ReloadMontage_Character_EmptyMag) == 0x000020, "Member 'FGzWeaponReloadAnimationData::ReloadMontage_Character_EmptyMag' has a wrong offset!");
static_assert(offsetof(FGzWeaponReloadAnimationData, ReloadMontage_Weapon_EmptyMag) == 0x000030, "Member 'FGzWeaponReloadAnimationData::ReloadMontage_Weapon_EmptyMag' has a wrong offset!");
static_assert(offsetof(FGzWeaponReloadAnimationData, ReloadTimeSeconds) == 0x000038, "Member 'FGzWeaponReloadAnimationData::ReloadTimeSeconds' has a wrong offset!");
static_assert(offsetof(FGzWeaponReloadAnimationData, ReloadTimeSeconds_EmptyMag) == 0x00003C, "Member 'FGzWeaponReloadAnimationData::ReloadTimeSeconds_EmptyMag' has a wrong offset!");

// ScriptStruct G01.GzWeaponShootingAnimationData
// 0x0048 (0x0048 - 0x0000)
struct FGzWeaponShootingAnimationData final
{
public:
	int32                                         LimbState;                                         // 0x0000(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C49[0x4];                                     // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UAnimMontage*>                   ShotMontage_Character;                             // 0x0008(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TArray<class UAnimMontage*>                   HipFireMontage_Character;                          // 0x0018(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	class UAnimMontage*                           ShotMontage_Weapon;                                // 0x0028(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimMontage*                           ShotMontage_Scope;                                 // 0x0030(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         NumOfMontagesToLoop;                               // 0x0038(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         NumOfMontagesToLoop_HipFire;                       // 0x003C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShouldPlayMontage;                                // 0x0040(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C4A[0x7];                                     // 0x0041(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGzWeaponShootingAnimationData) == 0x000008, "Wrong alignment on FGzWeaponShootingAnimationData");
static_assert(sizeof(FGzWeaponShootingAnimationData) == 0x000048, "Wrong size on FGzWeaponShootingAnimationData");
static_assert(offsetof(FGzWeaponShootingAnimationData, LimbState) == 0x000000, "Member 'FGzWeaponShootingAnimationData::LimbState' has a wrong offset!");
static_assert(offsetof(FGzWeaponShootingAnimationData, ShotMontage_Character) == 0x000008, "Member 'FGzWeaponShootingAnimationData::ShotMontage_Character' has a wrong offset!");
static_assert(offsetof(FGzWeaponShootingAnimationData, HipFireMontage_Character) == 0x000018, "Member 'FGzWeaponShootingAnimationData::HipFireMontage_Character' has a wrong offset!");
static_assert(offsetof(FGzWeaponShootingAnimationData, ShotMontage_Weapon) == 0x000028, "Member 'FGzWeaponShootingAnimationData::ShotMontage_Weapon' has a wrong offset!");
static_assert(offsetof(FGzWeaponShootingAnimationData, ShotMontage_Scope) == 0x000030, "Member 'FGzWeaponShootingAnimationData::ShotMontage_Scope' has a wrong offset!");
static_assert(offsetof(FGzWeaponShootingAnimationData, NumOfMontagesToLoop) == 0x000038, "Member 'FGzWeaponShootingAnimationData::NumOfMontagesToLoop' has a wrong offset!");
static_assert(offsetof(FGzWeaponShootingAnimationData, NumOfMontagesToLoop_HipFire) == 0x00003C, "Member 'FGzWeaponShootingAnimationData::NumOfMontagesToLoop_HipFire' has a wrong offset!");
static_assert(offsetof(FGzWeaponShootingAnimationData, bShouldPlayMontage) == 0x000040, "Member 'FGzWeaponShootingAnimationData::bShouldPlayMontage' has a wrong offset!");

// ScriptStruct G01.GzWeaponAnimationLayerData
// 0x0030 (0x0030 - 0x0000)
struct FGzWeaponAnimationLayerData final
{
public:
	int32                                         LimbState;                                         // 0x0000(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECameraShoulderState                          CameraState;                                       // 0x0004(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C4B[0x3];                                     // 0x0005(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftClassPtr<class UClass>                   AnimLayer;                                         // 0x0008(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzWeaponAnimationLayerData) == 0x000008, "Wrong alignment on FGzWeaponAnimationLayerData");
static_assert(sizeof(FGzWeaponAnimationLayerData) == 0x000030, "Wrong size on FGzWeaponAnimationLayerData");
static_assert(offsetof(FGzWeaponAnimationLayerData, LimbState) == 0x000000, "Member 'FGzWeaponAnimationLayerData::LimbState' has a wrong offset!");
static_assert(offsetof(FGzWeaponAnimationLayerData, CameraState) == 0x000004, "Member 'FGzWeaponAnimationLayerData::CameraState' has a wrong offset!");
static_assert(offsetof(FGzWeaponAnimationLayerData, AnimLayer) == 0x000008, "Member 'FGzWeaponAnimationLayerData::AnimLayer' has a wrong offset!");

// ScriptStruct G01.GzWeaponAttachmentAnimationsArray
// 0x0010 (0x0010 - 0x0000)
struct FGzWeaponAttachmentAnimationsArray final
{
public:
	TArray<struct FGzWeaponAttachmentAnimations>  MontageVariations;                                 // 0x0000(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzWeaponAttachmentAnimationsArray) == 0x000008, "Wrong alignment on FGzWeaponAttachmentAnimationsArray");
static_assert(sizeof(FGzWeaponAttachmentAnimationsArray) == 0x000010, "Wrong size on FGzWeaponAttachmentAnimationsArray");
static_assert(offsetof(FGzWeaponAttachmentAnimationsArray, MontageVariations) == 0x000000, "Member 'FGzWeaponAttachmentAnimationsArray::MontageVariations' has a wrong offset!");

// ScriptStruct G01.Overrides
// 0x0050 (0x0050 - 0x0000)
struct FOverrides final
{
public:
	TMap<EGzWeaponAttachmentType, TSubclassOf<class AGzSpringArmViewpoint>> Overrides;                                         // 0x0000(0x0050)(Edit, DisableEditOnTemplate, UObjectWrapper, NativeAccessSpecifierPublic)
};
static_assert(alignof(FOverrides) == 0x000008, "Wrong alignment on FOverrides");
static_assert(sizeof(FOverrides) == 0x000050, "Wrong size on FOverrides");
static_assert(offsetof(FOverrides, Overrides) == 0x000000, "Member 'FOverrides::Overrides' has a wrong offset!");

// ScriptStruct G01.GzWeaponAttachmentPerTypeViewmakerSetup
// 0x0168 (0x0170 - 0x0008)
struct FGzWeaponAttachmentPerTypeViewmakerSetup final : public FGzDefaultItemViewmakerSetupBase
{
public:
	struct FGzViewemakerSetup                     PerType[0x8];                                      // 0x0008(0x0028)(Edit, DisableEditOnTemplate, NativeAccessSpecifierPrivate)
	struct FGzViewemakerSetup                     Default;                                           // 0x0148(0x0028)(Edit, DisableEditOnTemplate, NativeAccessSpecifierPrivate)
};
static_assert(alignof(FGzWeaponAttachmentPerTypeViewmakerSetup) == 0x000008, "Wrong alignment on FGzWeaponAttachmentPerTypeViewmakerSetup");
static_assert(sizeof(FGzWeaponAttachmentPerTypeViewmakerSetup) == 0x000170, "Wrong size on FGzWeaponAttachmentPerTypeViewmakerSetup");
static_assert(offsetof(FGzWeaponAttachmentPerTypeViewmakerSetup, PerType) == 0x000008, "Member 'FGzWeaponAttachmentPerTypeViewmakerSetup::PerType' has a wrong offset!");
static_assert(offsetof(FGzWeaponAttachmentPerTypeViewmakerSetup, Default) == 0x000148, "Member 'FGzWeaponAttachmentPerTypeViewmakerSetup::Default' has a wrong offset!");

// ScriptStruct G01.GzWeaponAttachmentViewmakerSetup
// 0x0D68 (0x0D70 - 0x0008)
struct FGzWeaponAttachmentViewmakerSetup final : public FGzDefaultItemViewmakerSetupBase
{
public:
	struct FGzWeaponAttachmentPerTypeViewmakerSetup PerType;                                           // 0x0008(0x0170)(Edit, DisableEditOnTemplate, NativeAccessSpecifierPrivate)
	struct FGzWeaponAttachmentPerTypeViewmakerSetup PerWeaponType[0x8];                                // 0x0178(0x0170)(Edit, DisableEditOnTemplate, NativeAccessSpecifierPrivate)
	TMap<class UGzWeaponArchetype*, struct FGzWeaponAttachmentPerTypeViewmakerSetup> PerWeaponArchetype;                                // 0x0CF8(0x0050)(Edit, DisableEditOnTemplate, NativeAccessSpecifierPrivate)
	struct FGzViewemakerSetup                     Default;                                           // 0x0D48(0x0028)(Edit, DisableEditOnTemplate, NativeAccessSpecifierPrivate)
};
static_assert(alignof(FGzWeaponAttachmentViewmakerSetup) == 0x000008, "Wrong alignment on FGzWeaponAttachmentViewmakerSetup");
static_assert(sizeof(FGzWeaponAttachmentViewmakerSetup) == 0x000D70, "Wrong size on FGzWeaponAttachmentViewmakerSetup");
static_assert(offsetof(FGzWeaponAttachmentViewmakerSetup, PerType) == 0x000008, "Member 'FGzWeaponAttachmentViewmakerSetup::PerType' has a wrong offset!");
static_assert(offsetof(FGzWeaponAttachmentViewmakerSetup, PerWeaponType) == 0x000178, "Member 'FGzWeaponAttachmentViewmakerSetup::PerWeaponType' has a wrong offset!");
static_assert(offsetof(FGzWeaponAttachmentViewmakerSetup, PerWeaponArchetype) == 0x000CF8, "Member 'FGzWeaponAttachmentViewmakerSetup::PerWeaponArchetype' has a wrong offset!");
static_assert(offsetof(FGzWeaponAttachmentViewmakerSetup, Default) == 0x000D48, "Member 'FGzWeaponAttachmentViewmakerSetup::Default' has a wrong offset!");

// ScriptStruct G01.GzShotData
// 0x0002 (0x0002 - 0x0000)
struct FGzShotData final
{
public:
	bool                                          bFirstShot;                                        // 0x0000(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         RemainingAmmoInClip;                               // 0x0001(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzShotData) == 0x000001, "Wrong alignment on FGzShotData");
static_assert(sizeof(FGzShotData) == 0x000002, "Wrong size on FGzShotData");
static_assert(offsetof(FGzShotData, bFirstShot) == 0x000000, "Member 'FGzShotData::bFirstShot' has a wrong offset!");
static_assert(offsetof(FGzShotData, RemainingAmmoInClip) == 0x000001, "Member 'FGzShotData::RemainingAmmoInClip' has a wrong offset!");

// ScriptStruct G01.GzTimedRotation
// 0x0020 (0x0020 - 0x0000)
struct alignas(0x08) FGzTimedRotation final
{
public:
	uint8                                         Pad_2C4C[0x20];                                    // 0x0000(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGzTimedRotation) == 0x000008, "Wrong alignment on FGzTimedRotation");
static_assert(sizeof(FGzTimedRotation) == 0x000020, "Wrong size on FGzTimedRotation");

// ScriptStruct G01.GzWeaponRecoilShotData
// 0x0020 (0x0020 - 0x0000)
struct FGzWeaponRecoilShotData final
{
public:
	struct FRotator                               AimingShiftRotator;                                // 0x0000(0x0018)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	float                                         ShiftDistortionAngle;                              // 0x0018(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C4D[0x4];                                     // 0x001C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGzWeaponRecoilShotData) == 0x000008, "Wrong alignment on FGzWeaponRecoilShotData");
static_assert(sizeof(FGzWeaponRecoilShotData) == 0x000020, "Wrong size on FGzWeaponRecoilShotData");
static_assert(offsetof(FGzWeaponRecoilShotData, AimingShiftRotator) == 0x000000, "Member 'FGzWeaponRecoilShotData::AimingShiftRotator' has a wrong offset!");
static_assert(offsetof(FGzWeaponRecoilShotData, ShiftDistortionAngle) == 0x000018, "Member 'FGzWeaponRecoilShotData::ShiftDistortionAngle' has a wrong offset!");

// ScriptStruct G01.GzSocketInitializationData
// 0x0028 (0x0028 - 0x0000)
struct FGzSocketInitializationData final
{
public:
	EGzAttachNodeName                             WeaponAttachNode;                                  // 0x0000(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C4E[0x7];                                     // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTagContainer                  UsabilityConditions;                               // 0x0008(0x0020)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzSocketInitializationData) == 0x000008, "Wrong alignment on FGzSocketInitializationData");
static_assert(sizeof(FGzSocketInitializationData) == 0x000028, "Wrong size on FGzSocketInitializationData");
static_assert(offsetof(FGzSocketInitializationData, WeaponAttachNode) == 0x000000, "Member 'FGzSocketInitializationData::WeaponAttachNode' has a wrong offset!");
static_assert(offsetof(FGzSocketInitializationData, UsabilityConditions) == 0x000008, "Member 'FGzSocketInitializationData::UsabilityConditions' has a wrong offset!");

// ScriptStruct G01.GzWeaponSocketState
// 0x0028 (0x0028 - 0x0000)
struct FGzWeaponSocketState final
{
public:
	class FName                                   ActiveWeaponSocketName;                            // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FGameplayTagContainer                  UsabilityGameplayTags;                             // 0x0008(0x0020)(NativeAccessSpecifierPrivate)
};
static_assert(alignof(FGzWeaponSocketState) == 0x000008, "Wrong alignment on FGzWeaponSocketState");
static_assert(sizeof(FGzWeaponSocketState) == 0x000028, "Wrong size on FGzWeaponSocketState");
static_assert(offsetof(FGzWeaponSocketState, ActiveWeaponSocketName) == 0x000000, "Member 'FGzWeaponSocketState::ActiveWeaponSocketName' has a wrong offset!");
static_assert(offsetof(FGzWeaponSocketState, UsabilityGameplayTags) == 0x000008, "Member 'FGzWeaponSocketState::UsabilityGameplayTags' has a wrong offset!");

// ScriptStruct G01.GzWeaponAttachmentItemsList
// 0x0010 (0x0010 - 0x0000)
struct FGzWeaponAttachmentItemsList final
{
public:
	TArray<class UGzWeaponAttachmentItemData*>    Attachments;                                       // 0x0000(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzWeaponAttachmentItemsList) == 0x000008, "Wrong alignment on FGzWeaponAttachmentItemsList");
static_assert(sizeof(FGzWeaponAttachmentItemsList) == 0x000010, "Wrong size on FGzWeaponAttachmentItemsList");
static_assert(offsetof(FGzWeaponAttachmentItemsList, Attachments) == 0x000000, "Member 'FGzWeaponAttachmentItemsList::Attachments' has a wrong offset!");

// ScriptStruct G01.GzSuitableAttachment
// 0x0010 (0x0010 - 0x0000)
struct FGzSuitableAttachment final
{
public:
	class UGzWeaponAttachmentItemData*            AttachmentData;                                    // 0x0000(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsDefault;                                        // 0x0008(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C4F[0x7];                                     // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGzSuitableAttachment) == 0x000008, "Wrong alignment on FGzSuitableAttachment");
static_assert(sizeof(FGzSuitableAttachment) == 0x000010, "Wrong size on FGzSuitableAttachment");
static_assert(offsetof(FGzSuitableAttachment, AttachmentData) == 0x000000, "Member 'FGzSuitableAttachment::AttachmentData' has a wrong offset!");
static_assert(offsetof(FGzSuitableAttachment, bIsDefault) == 0x000008, "Member 'FGzSuitableAttachment::bIsDefault' has a wrong offset!");

// ScriptStruct G01.GzSuitableAttachmentsCategory
// 0x0018 (0x0018 - 0x0000)
struct FGzSuitableAttachmentsCategory final
{
public:
	TArray<struct FGzSuitableAttachment>          Attachments;                                       // 0x0000(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	bool                                          bIsModifiableByPlayer;                             // 0x0010(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EGzItemRarity                                 RequiredUnlockRarity;                              // 0x0011(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C50[0x6];                                     // 0x0012(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGzSuitableAttachmentsCategory) == 0x000008, "Wrong alignment on FGzSuitableAttachmentsCategory");
static_assert(sizeof(FGzSuitableAttachmentsCategory) == 0x000018, "Wrong size on FGzSuitableAttachmentsCategory");
static_assert(offsetof(FGzSuitableAttachmentsCategory, Attachments) == 0x000000, "Member 'FGzSuitableAttachmentsCategory::Attachments' has a wrong offset!");
static_assert(offsetof(FGzSuitableAttachmentsCategory, bIsModifiableByPlayer) == 0x000010, "Member 'FGzSuitableAttachmentsCategory::bIsModifiableByPlayer' has a wrong offset!");
static_assert(offsetof(FGzSuitableAttachmentsCategory, RequiredUnlockRarity) == 0x000011, "Member 'FGzSuitableAttachmentsCategory::RequiredUnlockRarity' has a wrong offset!");

// ScriptStruct G01.GzScopeMode
// 0x0080 (0x0080 - 0x0000)
struct FGzScopeMode final
{
public:
	bool                                          bInterpScopeMode;                                  // 0x0000(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseSceneCapture;                                  // 0x0001(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C51[0x2];                                     // 0x0002(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         SC_InterpSpeed;                                    // 0x0004(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SC_FOVAngle;                                       // 0x0008(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C52[0x4];                                     // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                SC_FlashOffset;                                    // 0x0010(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                ScopeActorOffset;                                  // 0x0028(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bInterpScopeActor;                                 // 0x0040(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bInterpConstant;                                   // 0x0041(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C53[0x2];                                     // 0x0042(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ScopeActorInterpSpeed;                             // 0x0044(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMaterialInterface*                     ScopeMaterialInstance;                             // 0x0048(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ScopePostProcessEnableLag;                         // 0x0050(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseCustomOverlayModeInsteadOfGameplayTag;         // 0x0054(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C54[0x3];                                     // 0x0055(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ScopeSensitvityPitchCoefficient;                   // 0x0058(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ScopeSensitvityYawCoefficient;                     // 0x005C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           OverlayCameraModeTagOverride;                      // 0x0060(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UGzCameraOverlayModeDataAsset*          AimingCameraOverlayModeOverride;                   // 0x0068(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bOverrideADSByMultiplying;                         // 0x0070(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C55[0x3];                                     // 0x0071(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         OverrideBaseAngleValue;                            // 0x0074(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         OverrideADSMultiplier;                             // 0x0078(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C56[0x4];                                     // 0x007C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGzScopeMode) == 0x000008, "Wrong alignment on FGzScopeMode");
static_assert(sizeof(FGzScopeMode) == 0x000080, "Wrong size on FGzScopeMode");
static_assert(offsetof(FGzScopeMode, bInterpScopeMode) == 0x000000, "Member 'FGzScopeMode::bInterpScopeMode' has a wrong offset!");
static_assert(offsetof(FGzScopeMode, bUseSceneCapture) == 0x000001, "Member 'FGzScopeMode::bUseSceneCapture' has a wrong offset!");
static_assert(offsetof(FGzScopeMode, SC_InterpSpeed) == 0x000004, "Member 'FGzScopeMode::SC_InterpSpeed' has a wrong offset!");
static_assert(offsetof(FGzScopeMode, SC_FOVAngle) == 0x000008, "Member 'FGzScopeMode::SC_FOVAngle' has a wrong offset!");
static_assert(offsetof(FGzScopeMode, SC_FlashOffset) == 0x000010, "Member 'FGzScopeMode::SC_FlashOffset' has a wrong offset!");
static_assert(offsetof(FGzScopeMode, ScopeActorOffset) == 0x000028, "Member 'FGzScopeMode::ScopeActorOffset' has a wrong offset!");
static_assert(offsetof(FGzScopeMode, bInterpScopeActor) == 0x000040, "Member 'FGzScopeMode::bInterpScopeActor' has a wrong offset!");
static_assert(offsetof(FGzScopeMode, bInterpConstant) == 0x000041, "Member 'FGzScopeMode::bInterpConstant' has a wrong offset!");
static_assert(offsetof(FGzScopeMode, ScopeActorInterpSpeed) == 0x000044, "Member 'FGzScopeMode::ScopeActorInterpSpeed' has a wrong offset!");
static_assert(offsetof(FGzScopeMode, ScopeMaterialInstance) == 0x000048, "Member 'FGzScopeMode::ScopeMaterialInstance' has a wrong offset!");
static_assert(offsetof(FGzScopeMode, ScopePostProcessEnableLag) == 0x000050, "Member 'FGzScopeMode::ScopePostProcessEnableLag' has a wrong offset!");
static_assert(offsetof(FGzScopeMode, bUseCustomOverlayModeInsteadOfGameplayTag) == 0x000054, "Member 'FGzScopeMode::bUseCustomOverlayModeInsteadOfGameplayTag' has a wrong offset!");
static_assert(offsetof(FGzScopeMode, ScopeSensitvityPitchCoefficient) == 0x000058, "Member 'FGzScopeMode::ScopeSensitvityPitchCoefficient' has a wrong offset!");
static_assert(offsetof(FGzScopeMode, ScopeSensitvityYawCoefficient) == 0x00005C, "Member 'FGzScopeMode::ScopeSensitvityYawCoefficient' has a wrong offset!");
static_assert(offsetof(FGzScopeMode, OverlayCameraModeTagOverride) == 0x000060, "Member 'FGzScopeMode::OverlayCameraModeTagOverride' has a wrong offset!");
static_assert(offsetof(FGzScopeMode, AimingCameraOverlayModeOverride) == 0x000068, "Member 'FGzScopeMode::AimingCameraOverlayModeOverride' has a wrong offset!");
static_assert(offsetof(FGzScopeMode, bOverrideADSByMultiplying) == 0x000070, "Member 'FGzScopeMode::bOverrideADSByMultiplying' has a wrong offset!");
static_assert(offsetof(FGzScopeMode, OverrideBaseAngleValue) == 0x000074, "Member 'FGzScopeMode::OverrideBaseAngleValue' has a wrong offset!");
static_assert(offsetof(FGzScopeMode, OverrideADSMultiplier) == 0x000078, "Member 'FGzScopeMode::OverrideADSMultiplier' has a wrong offset!");

// ScriptStruct G01.GzHitValidationInfo
// 0x0008 (0x0008 - 0x0000)
struct FGzHitValidationInfo final
{
public:
	uint8                                         ShotID;                                            // 0x0000(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         NumberOfRequestedHitValidations;                   // 0x0001(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C57[0x2];                                     // 0x0002(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	uint32                                        HitMask;                                           // 0x0004(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzHitValidationInfo) == 0x000004, "Wrong alignment on FGzHitValidationInfo");
static_assert(sizeof(FGzHitValidationInfo) == 0x000008, "Wrong size on FGzHitValidationInfo");
static_assert(offsetof(FGzHitValidationInfo, ShotID) == 0x000000, "Member 'FGzHitValidationInfo::ShotID' has a wrong offset!");
static_assert(offsetof(FGzHitValidationInfo, NumberOfRequestedHitValidations) == 0x000001, "Member 'FGzHitValidationInfo::NumberOfRequestedHitValidations' has a wrong offset!");
static_assert(offsetof(FGzHitValidationInfo, HitMask) == 0x000004, "Member 'FGzHitValidationInfo::HitMask' has a wrong offset!");

// ScriptStruct G01.GzWorldZoneArray
// 0x0010 (0x0010 - 0x0000)
struct FGzWorldZoneArray final
{
public:
	TArray<class UGzWorldZone*>                   Zones;                                             // 0x0000(0x0010)(Edit, ZeroConstructor, EditConst, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzWorldZoneArray) == 0x000008, "Wrong alignment on FGzWorldZoneArray");
static_assert(sizeof(FGzWorldZoneArray) == 0x000010, "Wrong size on FGzWorldZoneArray");
static_assert(offsetof(FGzWorldZoneArray, Zones) == 0x000000, "Member 'FGzWorldZoneArray::Zones' has a wrong offset!");

// ScriptStruct G01.GzWorldZoneSetup
// 0x0030 (0x0030 - 0x0000)
struct FGzWorldZoneSetup final
{
public:
	TArray<class FString>                         PlayableZoneNames;                                 // 0x0000(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	struct FGameplayTagContainer                  ZoneTags;                                          // 0x0010(0x0020)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzWorldZoneSetup) == 0x000008, "Wrong alignment on FGzWorldZoneSetup");
static_assert(sizeof(FGzWorldZoneSetup) == 0x000030, "Wrong size on FGzWorldZoneSetup");
static_assert(offsetof(FGzWorldZoneSetup, PlayableZoneNames) == 0x000000, "Member 'FGzWorldZoneSetup::PlayableZoneNames' has a wrong offset!");
static_assert(offsetof(FGzWorldZoneSetup, ZoneTags) == 0x000010, "Member 'FGzWorldZoneSetup::ZoneTags' has a wrong offset!");

// ScriptStruct G01.GzWorldDataLayerPreset
// 0x0020 (0x0020 - 0x0000)
struct FGzWorldDataLayerPreset final
{
public:
	TArray<class UDataLayerAsset*>                DataLayersToLoad;                                  // 0x0000(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class UDataLayerAsset*>                DataLayersToUnload;                                // 0x0010(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzWorldDataLayerPreset) == 0x000008, "Wrong alignment on FGzWorldDataLayerPreset");
static_assert(sizeof(FGzWorldDataLayerPreset) == 0x000020, "Wrong size on FGzWorldDataLayerPreset");
static_assert(offsetof(FGzWorldDataLayerPreset, DataLayersToLoad) == 0x000000, "Member 'FGzWorldDataLayerPreset::DataLayersToLoad' has a wrong offset!");
static_assert(offsetof(FGzWorldDataLayerPreset, DataLayersToUnload) == 0x000010, "Member 'FGzWorldDataLayerPreset::DataLayersToUnload' has a wrong offset!");

// ScriptStruct G01.GzRarityInstancesSetupData
// 0x0050 (0x0050 - 0x0000)
struct FGzRarityInstancesSetupData final
{
public:
	TMap<struct FGameplayTag, int32>              RarityInstancesSetup;                              // 0x0000(0x0050)(Edit, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzRarityInstancesSetupData) == 0x000008, "Wrong alignment on FGzRarityInstancesSetupData");
static_assert(sizeof(FGzRarityInstancesSetupData) == 0x000050, "Wrong size on FGzRarityInstancesSetupData");
static_assert(offsetof(FGzRarityInstancesSetupData, RarityInstancesSetup) == 0x000000, "Member 'FGzRarityInstancesSetupData::RarityInstancesSetup' has a wrong offset!");

// ScriptStruct G01.GzWorldZoneTrackingArray
// 0x0050 (0x0050 - 0x0000)
struct FGzWorldZoneTrackingArray final
{
public:
	TSet<class UGzWorldZoneTrackingComponent*>    WorldZoneComponents;                               // 0x0000(0x0050)(ExportObject, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzWorldZoneTrackingArray) == 0x000008, "Wrong alignment on FGzWorldZoneTrackingArray");
static_assert(sizeof(FGzWorldZoneTrackingArray) == 0x000050, "Wrong size on FGzWorldZoneTrackingArray");
static_assert(offsetof(FGzWorldZoneTrackingArray, WorldZoneComponents) == 0x000000, "Member 'FGzWorldZoneTrackingArray::WorldZoneComponents' has a wrong offset!");

// ScriptStruct G01.GzLoadoutDropData
// 0x0018 (0x0018 - 0x0000)
struct FGzLoadoutDropData final
{
public:
	TArray<TSubclassOf<class AGzProceduralTrackTransport>> Classes;                                           // 0x0000(0x0010)(Edit, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
	int32                                         NumToDrop;                                         // 0x0010(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C58[0x4];                                     // 0x0014(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGzLoadoutDropData) == 0x000008, "Wrong alignment on FGzLoadoutDropData");
static_assert(sizeof(FGzLoadoutDropData) == 0x000018, "Wrong size on FGzLoadoutDropData");
static_assert(offsetof(FGzLoadoutDropData, Classes) == 0x000000, "Member 'FGzLoadoutDropData::Classes' has a wrong offset!");
static_assert(offsetof(FGzLoadoutDropData, NumToDrop) == 0x000010, "Member 'FGzLoadoutDropData::NumToDrop' has a wrong offset!");

// ScriptStruct G01.GzGetXsollaSubscriptionTokenResult
// 0x0010 (0x00F0 - 0x00E0)
struct FGzGetXsollaSubscriptionTokenResult final : public FGzPlayFabResultBase
{
public:
	class FString                                 PurchaseToken;                                     // 0x00E0(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzGetXsollaSubscriptionTokenResult) == 0x000008, "Wrong alignment on FGzGetXsollaSubscriptionTokenResult");
static_assert(sizeof(FGzGetXsollaSubscriptionTokenResult) == 0x0000F0, "Wrong size on FGzGetXsollaSubscriptionTokenResult");
static_assert(offsetof(FGzGetXsollaSubscriptionTokenResult, PurchaseToken) == 0x0000E0, "Member 'FGzGetXsollaSubscriptionTokenResult::PurchaseToken' has a wrong offset!");

// ScriptStruct G01.GzSetProlongFlagResult
// 0x0000 (0x00E0 - 0x00E0)
struct FGzSetProlongFlagResult final : public FGzPlayFabResultBase
{
};
static_assert(alignof(FGzSetProlongFlagResult) == 0x000008, "Wrong alignment on FGzSetProlongFlagResult");
static_assert(sizeof(FGzSetProlongFlagResult) == 0x0000E0, "Wrong size on FGzSetProlongFlagResult");

// ScriptStruct G01.GzExtendXsollaSubscriptionResult
// 0x0000 (0x00E0 - 0x00E0)
struct FGzExtendXsollaSubscriptionResult final : public FGzPlayFabResultBase
{
};
static_assert(alignof(FGzExtendXsollaSubscriptionResult) == 0x000008, "Wrong alignment on FGzExtendXsollaSubscriptionResult");
static_assert(sizeof(FGzExtendXsollaSubscriptionResult) == 0x0000E0, "Wrong size on FGzExtendXsollaSubscriptionResult");

// ScriptStruct G01.GzUnsubscribeXsollaResult
// 0x0000 (0x00E0 - 0x00E0)
struct FGzUnsubscribeXsollaResult final : public FGzPlayFabResultBase
{
};
static_assert(alignof(FGzUnsubscribeXsollaResult) == 0x000008, "Wrong alignment on FGzUnsubscribeXsollaResult");
static_assert(sizeof(FGzUnsubscribeXsollaResult) == 0x0000E0, "Wrong size on FGzUnsubscribeXsollaResult");

// ScriptStruct G01.GzGetCurrentContentPackIdResult
// 0x0020 (0x0100 - 0x00E0)
struct FGzGetCurrentContentPackIdResult final : public FGzPlayFabResultBase
{
public:
	class FString                                 PackId;                                            // 0x00E0(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 ExpiresIn;                                         // 0x00F0(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzGetCurrentContentPackIdResult) == 0x000008, "Wrong alignment on FGzGetCurrentContentPackIdResult");
static_assert(sizeof(FGzGetCurrentContentPackIdResult) == 0x000100, "Wrong size on FGzGetCurrentContentPackIdResult");
static_assert(offsetof(FGzGetCurrentContentPackIdResult, PackId) == 0x0000E0, "Member 'FGzGetCurrentContentPackIdResult::PackId' has a wrong offset!");
static_assert(offsetof(FGzGetCurrentContentPackIdResult, ExpiresIn) == 0x0000F0, "Member 'FGzGetCurrentContentPackIdResult::ExpiresIn' has a wrong offset!");

// ScriptStruct G01.GzStripeGetPaymentLinkResult
// 0x0010 (0x00F0 - 0x00E0)
struct FGzStripeGetPaymentLinkResult final : public FGzPlayFabResultBase
{
public:
	class FString                                 Value;                                             // 0x00E0(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzStripeGetPaymentLinkResult) == 0x000008, "Wrong alignment on FGzStripeGetPaymentLinkResult");
static_assert(sizeof(FGzStripeGetPaymentLinkResult) == 0x0000F0, "Wrong size on FGzStripeGetPaymentLinkResult");
static_assert(offsetof(FGzStripeGetPaymentLinkResult, Value) == 0x0000E0, "Member 'FGzStripeGetPaymentLinkResult::Value' has a wrong offset!");

// ScriptStruct G01.GzStripeCancelSubscriptionResult
// 0x0000 (0x00E0 - 0x00E0)
struct FGzStripeCancelSubscriptionResult final : public FGzPlayFabResultBase
{
};
static_assert(alignof(FGzStripeCancelSubscriptionResult) == 0x000008, "Wrong alignment on FGzStripeCancelSubscriptionResult");
static_assert(sizeof(FGzStripeCancelSubscriptionResult) == 0x0000E0, "Wrong size on FGzStripeCancelSubscriptionResult");

// ScriptStruct G01.GzStripeSubscriptionProductPricesResult
// 0x0050 (0x0130 - 0x00E0)
struct FGzStripeSubscriptionProductPricesResult final : public FGzPlayFabResultBase
{
public:
	TMap<class FString, int32>                    List;                                              // 0x00E0(0x0050)(NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzStripeSubscriptionProductPricesResult) == 0x000008, "Wrong alignment on FGzStripeSubscriptionProductPricesResult");
static_assert(sizeof(FGzStripeSubscriptionProductPricesResult) == 0x000130, "Wrong size on FGzStripeSubscriptionProductPricesResult");
static_assert(offsetof(FGzStripeSubscriptionProductPricesResult, List) == 0x0000E0, "Member 'FGzStripeSubscriptionProductPricesResult::List' has a wrong offset!");

// ScriptStruct G01.GzResultConsoleProcessPurchases
// 0x0000 (0x00E0 - 0x00E0)
struct FGzResultConsoleProcessPurchases final : public FGzPlayFabResultBase
{
};
static_assert(alignof(FGzResultConsoleProcessPurchases) == 0x000008, "Wrong alignment on FGzResultConsoleProcessPurchases");
static_assert(sizeof(FGzResultConsoleProcessPurchases) == 0x0000E0, "Wrong size on FGzResultConsoleProcessPurchases");

// ScriptStruct G01.GzResultConsolePlayerAuth
// 0x0000 (0x00E0 - 0x00E0)
struct FGzResultConsolePlayerAuth final : public FGzPlayFabResultBase
{
};
static_assert(alignof(FGzResultConsolePlayerAuth) == 0x000008, "Wrong alignment on FGzResultConsolePlayerAuth");
static_assert(sizeof(FGzResultConsolePlayerAuth) == 0x0000E0, "Wrong size on FGzResultConsolePlayerAuth");

// ScriptStruct G01.GzLandingTransformOffsets
// 0x0030 (0x0030 - 0x0000)
struct FGzLandingTransformOffsets final
{
public:
	struct FVector                                LandingTransformOffsetAtLeft;                      // 0x0000(0x0018)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                LandingTransformOffsetAtRight;                     // 0x0018(0x0018)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzLandingTransformOffsets) == 0x000008, "Wrong alignment on FGzLandingTransformOffsets");
static_assert(sizeof(FGzLandingTransformOffsets) == 0x000030, "Wrong size on FGzLandingTransformOffsets");
static_assert(offsetof(FGzLandingTransformOffsets, LandingTransformOffsetAtLeft) == 0x000000, "Member 'FGzLandingTransformOffsets::LandingTransformOffsetAtLeft' has a wrong offset!");
static_assert(offsetof(FGzLandingTransformOffsets, LandingTransformOffsetAtRight) == 0x000018, "Member 'FGzLandingTransformOffsets::LandingTransformOffsetAtRight' has a wrong offset!");

// ScriptStruct G01.GzStagedZone
// 0x0010 (0x0010 - 0x0000)
struct FGzStagedZone final
{
public:
	uint8                                         Pad_2C59[0x8];                                     // 0x0000(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class AGzBattleRoyaleZone*                    Zone;                                              // 0x0008(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzStagedZone) == 0x000008, "Wrong alignment on FGzStagedZone");
static_assert(sizeof(FGzStagedZone) == 0x000010, "Wrong size on FGzStagedZone");
static_assert(offsetof(FGzStagedZone, Zone) == 0x000008, "Member 'FGzStagedZone::Zone' has a wrong offset!");

// ScriptStruct G01.LocomotionEssentialValues
// 0x0078 (0x0078 - 0x0000)
struct alignas(0x08) FLocomotionEssentialValues final
{
public:
	uint8                                         Pad_2C5A[0x78];                                    // 0x0000(0x0078)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FLocomotionEssentialValues) == 0x000008, "Wrong alignment on FLocomotionEssentialValues");
static_assert(sizeof(FLocomotionEssentialValues) == 0x000078, "Wrong size on FLocomotionEssentialValues");

// ScriptStruct G01.GzMantleNetParams
// 0x0120 (0x0120 - 0x0000)
struct FGzMantleNetParams final
{
public:
	struct FGzMantlingScenarioHolder              MantlingScenario;                                  // 0x0000(0x0010)(NoDestructor, NativeAccessSpecifierPublic)
	struct FGzBaseMantleNetParams                 BaseParams;                                        // 0x0010(0x0110)(NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzMantleNetParams) == 0x000010, "Wrong alignment on FGzMantleNetParams");
static_assert(sizeof(FGzMantleNetParams) == 0x000120, "Wrong size on FGzMantleNetParams");
static_assert(offsetof(FGzMantleNetParams, MantlingScenario) == 0x000000, "Member 'FGzMantleNetParams::MantlingScenario' has a wrong offset!");
static_assert(offsetof(FGzMantleNetParams, BaseParams) == 0x000010, "Member 'FGzMantleNetParams::BaseParams' has a wrong offset!");

// ScriptStruct G01.LocomotionMantleTraceSettings
// 0x0020 (0x0020 - 0x0000)
struct FLocomotionMantleTraceSettings final
{
public:
	float                                         MinLedgeHeight;                                    // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         OverrideMantleMaxHeight;                           // 0x0004(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ReachDistance;                                     // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ForwardTraceRadius;                                // 0x000C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DownwardTraceRadius;                               // 0x0010(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PathTraceRadius;                                   // 0x0014(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ThicknessTraceDepth;                               // 0x0018(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ThicknessTraceOffset;                              // 0x001C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FLocomotionMantleTraceSettings) == 0x000004, "Wrong alignment on FLocomotionMantleTraceSettings");
static_assert(sizeof(FLocomotionMantleTraceSettings) == 0x000020, "Wrong size on FLocomotionMantleTraceSettings");
static_assert(offsetof(FLocomotionMantleTraceSettings, MinLedgeHeight) == 0x000000, "Member 'FLocomotionMantleTraceSettings::MinLedgeHeight' has a wrong offset!");
static_assert(offsetof(FLocomotionMantleTraceSettings, OverrideMantleMaxHeight) == 0x000004, "Member 'FLocomotionMantleTraceSettings::OverrideMantleMaxHeight' has a wrong offset!");
static_assert(offsetof(FLocomotionMantleTraceSettings, ReachDistance) == 0x000008, "Member 'FLocomotionMantleTraceSettings::ReachDistance' has a wrong offset!");
static_assert(offsetof(FLocomotionMantleTraceSettings, ForwardTraceRadius) == 0x00000C, "Member 'FLocomotionMantleTraceSettings::ForwardTraceRadius' has a wrong offset!");
static_assert(offsetof(FLocomotionMantleTraceSettings, DownwardTraceRadius) == 0x000010, "Member 'FLocomotionMantleTraceSettings::DownwardTraceRadius' has a wrong offset!");
static_assert(offsetof(FLocomotionMantleTraceSettings, PathTraceRadius) == 0x000014, "Member 'FLocomotionMantleTraceSettings::PathTraceRadius' has a wrong offset!");
static_assert(offsetof(FLocomotionMantleTraceSettings, ThicknessTraceDepth) == 0x000018, "Member 'FLocomotionMantleTraceSettings::ThicknessTraceDepth' has a wrong offset!");
static_assert(offsetof(FLocomotionMantleTraceSettings, ThicknessTraceOffset) == 0x00001C, "Member 'FLocomotionMantleTraceSettings::ThicknessTraceOffset' has a wrong offset!");

// ScriptStruct G01.TeamSpawnPoints
// 0x0020 (0x0020 - 0x0000)
struct FTeamSpawnPoints final
{
public:
	int32                                         TeamID;                                            // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2C5B[0x4];                                     // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class AGzTeamStart*>                   SpawnPoints;                                       // 0x0008(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	int32                                         Next;                                              // 0x0018(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         NextPreMatch;                                      // 0x001C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
};
static_assert(alignof(FTeamSpawnPoints) == 0x000008, "Wrong alignment on FTeamSpawnPoints");
static_assert(sizeof(FTeamSpawnPoints) == 0x000020, "Wrong size on FTeamSpawnPoints");
static_assert(offsetof(FTeamSpawnPoints, TeamID) == 0x000000, "Member 'FTeamSpawnPoints::TeamID' has a wrong offset!");
static_assert(offsetof(FTeamSpawnPoints, SpawnPoints) == 0x000008, "Member 'FTeamSpawnPoints::SpawnPoints' has a wrong offset!");
static_assert(offsetof(FTeamSpawnPoints, Next) == 0x000018, "Member 'FTeamSpawnPoints::Next' has a wrong offset!");
static_assert(offsetof(FTeamSpawnPoints, NextPreMatch) == 0x00001C, "Member 'FTeamSpawnPoints::NextPreMatch' has a wrong offset!");

// ScriptStruct G01.TeamsSpawnPointsInfo
// 0x0030 (0x0030 - 0x0000)
struct FTeamsSpawnPointsInfo final
{
public:
	TArray<class APlayerStart*>                   FreeSpawnPoints;                                   // 0x0000(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	TArray<class APlayerStart*>                   PIESpawnPoints;                                    // 0x0010(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	TArray<struct FTeamSpawnPoints>               SpawnPoints;                                       // 0x0020(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
};
static_assert(alignof(FTeamsSpawnPointsInfo) == 0x000008, "Wrong alignment on FTeamsSpawnPointsInfo");
static_assert(sizeof(FTeamsSpawnPointsInfo) == 0x000030, "Wrong size on FTeamsSpawnPointsInfo");
static_assert(offsetof(FTeamsSpawnPointsInfo, FreeSpawnPoints) == 0x000000, "Member 'FTeamsSpawnPointsInfo::FreeSpawnPoints' has a wrong offset!");
static_assert(offsetof(FTeamsSpawnPointsInfo, PIESpawnPoints) == 0x000010, "Member 'FTeamsSpawnPointsInfo::PIESpawnPoints' has a wrong offset!");
static_assert(offsetof(FTeamsSpawnPointsInfo, SpawnPoints) == 0x000020, "Member 'FTeamsSpawnPointsInfo::SpawnPoints' has a wrong offset!");

// ScriptStruct G01.GzTransformNoScaleSerializerConfig
// 0x0000 (0x0010 - 0x0010)
struct FGzTransformNoScaleSerializerConfig final : public FNetSerializerConfig
{
};
static_assert(alignof(FGzTransformNoScaleSerializerConfig) == 0x000008, "Wrong alignment on FGzTransformNoScaleSerializerConfig");
static_assert(sizeof(FGzTransformNoScaleSerializerConfig) == 0x000010, "Wrong size on FGzTransformNoScaleSerializerConfig");

// ScriptStruct G01.QuaternionNetSerializerConfig
// 0x0000 (0x0010 - 0x0010)
struct FQuaternionNetSerializerConfig final : public FNetSerializerConfig
{
};
static_assert(alignof(FQuaternionNetSerializerConfig) == 0x000008, "Wrong alignment on FQuaternionNetSerializerConfig");
static_assert(sizeof(FQuaternionNetSerializerConfig) == 0x000010, "Wrong size on FQuaternionNetSerializerConfig");

}

