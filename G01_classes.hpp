#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: G01

#include "Basic.hpp"

#include "Engine_structs.hpp"
#include "Engine_classes.hpp"
#include "CohtmlPlugin_classes.hpp"
#include "AIModule_structs.hpp"
#include "AIModule_classes.hpp"
#include "CommonUI_classes.hpp"
#include "G01_structs.hpp"
#include "CommonInput_structs.hpp"
#include "CommonInput_classes.hpp"
#include "GameplayTags_structs.hpp"
#include "DeveloperSettings_classes.hpp"
#include "GameplayAbilities_structs.hpp"
#include "GameplayAbilities_classes.hpp"
#include "CoreUObject_structs.hpp"
#include "CoreUObject_classes.hpp"
#include "GameSettings_classes.hpp"
#include "AdvancedThirdPersonCamera_structs.hpp"
#include "AdvancedThirdPersonCamera_classes.hpp"
#include "ModularGameplay_classes.hpp"
#include "AkAudio_structs.hpp"
#include "AkAudio_classes.hpp"
#include "InputCore_structs.hpp"
#include "StructUtils_structs.hpp"
#include "PhysicsCore_structs.hpp"
#include "UMG_structs.hpp"
#include "UMG_classes.hpp"
#include "OnlineSubsystemUtils_classes.hpp"
#include "GameplayCameras_classes.hpp"
#include "CinematicCamera_structs.hpp"
#include "CinematicCamera_classes.hpp"
#include "ChaosVehicles_classes.hpp"
#include "MissionGraphRuntime_structs.hpp"
#include "MissionGraphRuntime_classes.hpp"
#include "SlateCore_structs.hpp"
#include "GameplayTasks_classes.hpp"
#include "NavigationSystem_classes.hpp"
#include "EnhancedInput_structs.hpp"
#include "EnhancedInput_classes.hpp"
#include "AnimGraphRuntime_classes.hpp"
#include "NetCore_structs.hpp"
#include "ReplicationGraph_classes.hpp"


namespace SDK
{

// Class G01.GzPlayFabObject
// 0x0078 (0x00A0 - 0x0028)
class UGzPlayFabObject : public UObject
{
public:
	uint8                                         Pad_2C5C[0x18];                                    // 0x0028(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	class UGzBackendManager*                      BackendManager;                                    // 0x0040(0x0008)(ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TMap<TSubclassOf<class UGzServiceComponent>, class UGzPlayFabObject*> ServiceComponents;                                 // 0x0048(0x0050)(NativeAccessSpecifierPrivate)
	uint8                                         Pad_2C5D[0x8];                                     // 0x0098(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzPlayFabObject">();
	}
	static class UGzPlayFabObject* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzPlayFabObject>();
	}
};
static_assert(alignof(UGzPlayFabObject) == 0x000008, "Wrong alignment on UGzPlayFabObject");
static_assert(sizeof(UGzPlayFabObject) == 0x0000A0, "Wrong size on UGzPlayFabObject");
static_assert(offsetof(UGzPlayFabObject, BackendManager) == 0x000040, "Member 'UGzPlayFabObject::BackendManager' has a wrong offset!");
static_assert(offsetof(UGzPlayFabObject, ServiceComponents) == 0x000048, "Member 'UGzPlayFabObject::ServiceComponents' has a wrong offset!");

// Class G01.GzClientPFObject
// 0x0000 (0x00A0 - 0x00A0)
class UGzClientPFObject : public UGzPlayFabObject
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzClientPFObject">();
	}
	static class UGzClientPFObject* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzClientPFObject>();
	}
};
static_assert(alignof(UGzClientPFObject) == 0x000008, "Wrong alignment on UGzClientPFObject");
static_assert(sizeof(UGzClientPFObject) == 0x0000A0, "Wrong size on UGzClientPFObject");

// Class G01.GzClientBackendFlagsService
// 0x0008 (0x00A8 - 0x00A0)
class UGzClientBackendFlagsService final : public UGzClientPFObject
{
public:
	uint8                                         Pad_2C5E[0x8];                                     // 0x00A0(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzClientBackendFlagsService">();
	}
	static class UGzClientBackendFlagsService* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzClientBackendFlagsService>();
	}
};
static_assert(alignof(UGzClientBackendFlagsService) == 0x000008, "Wrong alignment on UGzClientBackendFlagsService");
static_assert(sizeof(UGzClientBackendFlagsService) == 0x0000A8, "Wrong size on UGzClientBackendFlagsService");

// Class G01.LocomotionGetUpAnimations
// 0x0040 (0x0070 - 0x0030)
class ULocomotionGetUpAnimations final : public UDataAsset
{
public:
	class UAnimMontage*                           FrontDefault;                                      // 0x0030(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimMontage*                           FrontRightHand;                                    // 0x0038(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimMontage*                           FrontLeftHand;                                     // 0x0040(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimMontage*                           FrontTwoHands;                                     // 0x0048(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimMontage*                           BackDefault;                                       // 0x0050(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimMontage*                           BackRightHand;                                     // 0x0058(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimMontage*                           BackLeftHand;                                      // 0x0060(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimMontage*                           BackTwoHands;                                      // 0x0068(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LocomotionGetUpAnimations">();
	}
	static class ULocomotionGetUpAnimations* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULocomotionGetUpAnimations>();
	}
};
static_assert(alignof(ULocomotionGetUpAnimations) == 0x000008, "Wrong alignment on ULocomotionGetUpAnimations");
static_assert(sizeof(ULocomotionGetUpAnimations) == 0x000070, "Wrong size on ULocomotionGetUpAnimations");
static_assert(offsetof(ULocomotionGetUpAnimations, FrontDefault) == 0x000030, "Member 'ULocomotionGetUpAnimations::FrontDefault' has a wrong offset!");
static_assert(offsetof(ULocomotionGetUpAnimations, FrontRightHand) == 0x000038, "Member 'ULocomotionGetUpAnimations::FrontRightHand' has a wrong offset!");
static_assert(offsetof(ULocomotionGetUpAnimations, FrontLeftHand) == 0x000040, "Member 'ULocomotionGetUpAnimations::FrontLeftHand' has a wrong offset!");
static_assert(offsetof(ULocomotionGetUpAnimations, FrontTwoHands) == 0x000048, "Member 'ULocomotionGetUpAnimations::FrontTwoHands' has a wrong offset!");
static_assert(offsetof(ULocomotionGetUpAnimations, BackDefault) == 0x000050, "Member 'ULocomotionGetUpAnimations::BackDefault' has a wrong offset!");
static_assert(offsetof(ULocomotionGetUpAnimations, BackRightHand) == 0x000058, "Member 'ULocomotionGetUpAnimations::BackRightHand' has a wrong offset!");
static_assert(offsetof(ULocomotionGetUpAnimations, BackLeftHand) == 0x000060, "Member 'ULocomotionGetUpAnimations::BackLeftHand' has a wrong offset!");
static_assert(offsetof(ULocomotionGetUpAnimations, BackTwoHands) == 0x000068, "Member 'ULocomotionGetUpAnimations::BackTwoHands' has a wrong offset!");

// Class G01.LocomotionRollAnimations
// 0x0020 (0x0050 - 0x0030)
class ULocomotionRollAnimations final : public UDataAsset
{
public:
	class UAnimMontage*                           Default;                                           // 0x0030(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimMontage*                           RightHand;                                         // 0x0038(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimMontage*                           LeftHand;                                          // 0x0040(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimMontage*                           TwoHands;                                          // 0x0048(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LocomotionRollAnimations">();
	}
	static class ULocomotionRollAnimations* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULocomotionRollAnimations>();
	}
};
static_assert(alignof(ULocomotionRollAnimations) == 0x000008, "Wrong alignment on ULocomotionRollAnimations");
static_assert(sizeof(ULocomotionRollAnimations) == 0x000050, "Wrong size on ULocomotionRollAnimations");
static_assert(offsetof(ULocomotionRollAnimations, Default) == 0x000030, "Member 'ULocomotionRollAnimations::Default' has a wrong offset!");
static_assert(offsetof(ULocomotionRollAnimations, RightHand) == 0x000038, "Member 'ULocomotionRollAnimations::RightHand' has a wrong offset!");
static_assert(offsetof(ULocomotionRollAnimations, LeftHand) == 0x000040, "Member 'ULocomotionRollAnimations::LeftHand' has a wrong offset!");
static_assert(offsetof(ULocomotionRollAnimations, TwoHands) == 0x000048, "Member 'ULocomotionRollAnimations::TwoHands' has a wrong offset!");

// Class G01.GzIPReaderHelper
// 0x0020 (0x0048 - 0x0028)
class UGzIPReaderHelper final : public UObject
{
public:
	uint8                                         Pad_2C5F[0x20];                                    // 0x0028(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzIPReaderHelper">();
	}
	static class UGzIPReaderHelper* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzIPReaderHelper>();
	}
};
static_assert(alignof(UGzIPReaderHelper) == 0x000008, "Wrong alignment on UGzIPReaderHelper");
static_assert(sizeof(UGzIPReaderHelper) == 0x000048, "Wrong size on UGzIPReaderHelper");

// Class G01.Gz_BTTask_ClearBB
// 0x0000 (0x0070 - 0x0070)
class UGz_BTTask_ClearBB final : public UBTTaskNode
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Gz_BTTask_ClearBB">();
	}
	static class UGz_BTTask_ClearBB* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGz_BTTask_ClearBB>();
	}
};
static_assert(alignof(UGz_BTTask_ClearBB) == 0x000008, "Wrong alignment on UGz_BTTask_ClearBB");
static_assert(sizeof(UGz_BTTask_ClearBB) == 0x000070, "Wrong size on UGz_BTTask_ClearBB");

// Class G01.GzCohtmlDataModel
// 0x0048 (0x0070 - 0x0028)
class UGzCohtmlDataModel : public UObject
{
public:
	class AGzUIDataSystem*                        Owner;                                             // 0x0028(0x0008)(ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2C60[0x40];                                    // 0x0030(0x0040)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzCohtmlDataModel">();
	}
	static class UGzCohtmlDataModel* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzCohtmlDataModel>();
	}
};
static_assert(alignof(UGzCohtmlDataModel) == 0x000008, "Wrong alignment on UGzCohtmlDataModel");
static_assert(sizeof(UGzCohtmlDataModel) == 0x000070, "Wrong size on UGzCohtmlDataModel");
static_assert(offsetof(UGzCohtmlDataModel, Owner) == 0x000028, "Member 'UGzCohtmlDataModel::Owner' has a wrong offset!");

// Class G01.GzBackendModel
// 0x0000 (0x0070 - 0x0070)
class UGzBackendModel : public UGzCohtmlDataModel
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzBackendModel">();
	}
	static class UGzBackendModel* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzBackendModel>();
	}
};
static_assert(alignof(UGzBackendModel) == 0x000008, "Wrong alignment on UGzBackendModel");
static_assert(sizeof(UGzBackendModel) == 0x000070, "Wrong size on UGzBackendModel");

// Class G01.GzMoviePlayerModel
// 0x00C0 (0x0130 - 0x0070)
class UGzMoviePlayerModel final : public UGzBackendModel
{
public:
	uint8                                         Pad_2C61[0x50];                                    // 0x0070(0x0050)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<class FString, class UAkAudioEvent*>     PreloadedMovieSounds;                              // 0x00C0(0x0050)(NativeAccessSpecifierPrivate)
	class UAkAudioEvent*                          PreloadedMovieStopEvent;                           // 0x0110(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2C62[0x18];                                    // 0x0118(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnAkPostEventCallback(EAkCallbackType CallbackType, class UAkCallbackInfo* CallbackInfo);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzMoviePlayerModel">();
	}
	static class UGzMoviePlayerModel* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzMoviePlayerModel>();
	}
};
static_assert(alignof(UGzMoviePlayerModel) == 0x000008, "Wrong alignment on UGzMoviePlayerModel");
static_assert(sizeof(UGzMoviePlayerModel) == 0x000130, "Wrong size on UGzMoviePlayerModel");
static_assert(offsetof(UGzMoviePlayerModel, PreloadedMovieSounds) == 0x0000C0, "Member 'UGzMoviePlayerModel::PreloadedMovieSounds' has a wrong offset!");
static_assert(offsetof(UGzMoviePlayerModel, PreloadedMovieStopEvent) == 0x000110, "Member 'UGzMoviePlayerModel::PreloadedMovieStopEvent' has a wrong offset!");

// Class G01.GzServiceComponent
// 0x0000 (0x00A0 - 0x00A0)
class UGzServiceComponent : public UGzPlayFabObject
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzServiceComponent">();
	}
	static class UGzServiceComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzServiceComponent>();
	}
};
static_assert(alignof(UGzServiceComponent) == 0x000008, "Wrong alignment on UGzServiceComponent");
static_assert(sizeof(UGzServiceComponent) == 0x0000A0, "Wrong size on UGzServiceComponent");

// Class G01.GzCustomizationAppearanceComponent
// 0x0088 (0x0128 - 0x00A0)
class UGzCustomizationAppearanceComponent final : public UGzServiceComponent
{
public:
	uint8                                         Pad_2C64[0x88];                                    // 0x00A0(0x0088)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzCustomizationAppearanceComponent">();
	}
	static class UGzCustomizationAppearanceComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzCustomizationAppearanceComponent>();
	}
};
static_assert(alignof(UGzCustomizationAppearanceComponent) == 0x000008, "Wrong alignment on UGzCustomizationAppearanceComponent");
static_assert(sizeof(UGzCustomizationAppearanceComponent) == 0x000128, "Wrong size on UGzCustomizationAppearanceComponent");

// Class G01.GzAnimRotatorBegin
// 0x0000 (0x0038 - 0x0038)
class UGzAnimRotatorBegin final : public UAnimNotify
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzAnimRotatorBegin">();
	}
	static class UGzAnimRotatorBegin* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzAnimRotatorBegin>();
	}
};
static_assert(alignof(UGzAnimRotatorBegin) == 0x000008, "Wrong alignment on UGzAnimRotatorBegin");
static_assert(sizeof(UGzAnimRotatorBegin) == 0x000038, "Wrong size on UGzAnimRotatorBegin");

// Class G01.GzProjectileData
// 0x0030 (0x0060 - 0x0030)
class UGzProjectileData : public UDataAsset
{
public:
	TSubclassOf<class AGzProjectileBase>          ProjectileActorClass;                              // 0x0030(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class AActor>                     TargetPreviewActorClass;                           // 0x0038(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         GravityScaleOnLaunch;                              // 0x0040(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InitialSpeed;                                      // 0x0044(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CollisionSphereRadius;                             // 0x0048(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShouldBounce;                                     // 0x004C(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bBounceAngleAffectsFriction;                       // 0x004D(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C65[0x2];                                     // 0x004E(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Bounciness;                                        // 0x0050(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Friction;                                          // 0x0054(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BounceVelocityStopSimulatingThreshold;             // 0x0058(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinFrictionFraction;                               // 0x005C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzProjectileData">();
	}
	static class UGzProjectileData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzProjectileData>();
	}
};
static_assert(alignof(UGzProjectileData) == 0x000008, "Wrong alignment on UGzProjectileData");
static_assert(sizeof(UGzProjectileData) == 0x000060, "Wrong size on UGzProjectileData");
static_assert(offsetof(UGzProjectileData, ProjectileActorClass) == 0x000030, "Member 'UGzProjectileData::ProjectileActorClass' has a wrong offset!");
static_assert(offsetof(UGzProjectileData, TargetPreviewActorClass) == 0x000038, "Member 'UGzProjectileData::TargetPreviewActorClass' has a wrong offset!");
static_assert(offsetof(UGzProjectileData, GravityScaleOnLaunch) == 0x000040, "Member 'UGzProjectileData::GravityScaleOnLaunch' has a wrong offset!");
static_assert(offsetof(UGzProjectileData, InitialSpeed) == 0x000044, "Member 'UGzProjectileData::InitialSpeed' has a wrong offset!");
static_assert(offsetof(UGzProjectileData, CollisionSphereRadius) == 0x000048, "Member 'UGzProjectileData::CollisionSphereRadius' has a wrong offset!");
static_assert(offsetof(UGzProjectileData, bShouldBounce) == 0x00004C, "Member 'UGzProjectileData::bShouldBounce' has a wrong offset!");
static_assert(offsetof(UGzProjectileData, bBounceAngleAffectsFriction) == 0x00004D, "Member 'UGzProjectileData::bBounceAngleAffectsFriction' has a wrong offset!");
static_assert(offsetof(UGzProjectileData, Bounciness) == 0x000050, "Member 'UGzProjectileData::Bounciness' has a wrong offset!");
static_assert(offsetof(UGzProjectileData, Friction) == 0x000054, "Member 'UGzProjectileData::Friction' has a wrong offset!");
static_assert(offsetof(UGzProjectileData, BounceVelocityStopSimulatingThreshold) == 0x000058, "Member 'UGzProjectileData::BounceVelocityStopSimulatingThreshold' has a wrong offset!");
static_assert(offsetof(UGzProjectileData, MinFrictionFraction) == 0x00005C, "Member 'UGzProjectileData::MinFrictionFraction' has a wrong offset!");

// Class G01.GzGrenadeProjectileData
// 0x0050 (0x00B0 - 0x0060)
class UGzGrenadeProjectileData final : public UGzProjectileData
{
public:
	class UGzExplosionData*                       ExplosionData;                                     // 0x0060(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bTriggerOnHit;                                     // 0x0068(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C66[0x7];                                     // 0x0069(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<ECollisionChannel>                     TriggerOnHitInteractionChannels;                   // 0x0070(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	bool                                          bTriggerAfterTimer;                                // 0x0080(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bTimerStartsInHand;                                // 0x0081(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C67[0x2];                                     // 0x0082(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         TimerDuration;                                     // 0x0084(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bRandomizeTimer;                                   // 0x0088(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C68[0x3];                                     // 0x0089(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         TimerMax;                                          // 0x008C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TimerMin;                                          // 0x0090(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSticksToSurface;                                  // 0x0094(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C69[0x3];                                     // 0x0095(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<ECollisionChannel>                     IgnoreStickInteractionChannels;                    // 0x0098(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	float                                         MaxStickAngle;                                     // 0x00A8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bTriggerOnStick;                                   // 0x00AC(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bStartTimerOnStick;                                // 0x00AD(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C6A[0x2];                                     // 0x00AE(0x0002)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzGrenadeProjectileData">();
	}
	static class UGzGrenadeProjectileData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzGrenadeProjectileData>();
	}
};
static_assert(alignof(UGzGrenadeProjectileData) == 0x000008, "Wrong alignment on UGzGrenadeProjectileData");
static_assert(sizeof(UGzGrenadeProjectileData) == 0x0000B0, "Wrong size on UGzGrenadeProjectileData");
static_assert(offsetof(UGzGrenadeProjectileData, ExplosionData) == 0x000060, "Member 'UGzGrenadeProjectileData::ExplosionData' has a wrong offset!");
static_assert(offsetof(UGzGrenadeProjectileData, bTriggerOnHit) == 0x000068, "Member 'UGzGrenadeProjectileData::bTriggerOnHit' has a wrong offset!");
static_assert(offsetof(UGzGrenadeProjectileData, TriggerOnHitInteractionChannels) == 0x000070, "Member 'UGzGrenadeProjectileData::TriggerOnHitInteractionChannels' has a wrong offset!");
static_assert(offsetof(UGzGrenadeProjectileData, bTriggerAfterTimer) == 0x000080, "Member 'UGzGrenadeProjectileData::bTriggerAfterTimer' has a wrong offset!");
static_assert(offsetof(UGzGrenadeProjectileData, bTimerStartsInHand) == 0x000081, "Member 'UGzGrenadeProjectileData::bTimerStartsInHand' has a wrong offset!");
static_assert(offsetof(UGzGrenadeProjectileData, TimerDuration) == 0x000084, "Member 'UGzGrenadeProjectileData::TimerDuration' has a wrong offset!");
static_assert(offsetof(UGzGrenadeProjectileData, bRandomizeTimer) == 0x000088, "Member 'UGzGrenadeProjectileData::bRandomizeTimer' has a wrong offset!");
static_assert(offsetof(UGzGrenadeProjectileData, TimerMax) == 0x00008C, "Member 'UGzGrenadeProjectileData::TimerMax' has a wrong offset!");
static_assert(offsetof(UGzGrenadeProjectileData, TimerMin) == 0x000090, "Member 'UGzGrenadeProjectileData::TimerMin' has a wrong offset!");
static_assert(offsetof(UGzGrenadeProjectileData, bSticksToSurface) == 0x000094, "Member 'UGzGrenadeProjectileData::bSticksToSurface' has a wrong offset!");
static_assert(offsetof(UGzGrenadeProjectileData, IgnoreStickInteractionChannels) == 0x000098, "Member 'UGzGrenadeProjectileData::IgnoreStickInteractionChannels' has a wrong offset!");
static_assert(offsetof(UGzGrenadeProjectileData, MaxStickAngle) == 0x0000A8, "Member 'UGzGrenadeProjectileData::MaxStickAngle' has a wrong offset!");
static_assert(offsetof(UGzGrenadeProjectileData, bTriggerOnStick) == 0x0000AC, "Member 'UGzGrenadeProjectileData::bTriggerOnStick' has a wrong offset!");
static_assert(offsetof(UGzGrenadeProjectileData, bStartTimerOnStick) == 0x0000AD, "Member 'UGzGrenadeProjectileData::bStartTimerOnStick' has a wrong offset!");

// Class G01.GzAnimRotatorEnd
// 0x0000 (0x0038 - 0x0038)
class UGzAnimRotatorEnd final : public UAnimNotify
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzAnimRotatorEnd">();
	}
	static class UGzAnimRotatorEnd* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzAnimRotatorEnd>();
	}
};
static_assert(alignof(UGzAnimRotatorEnd) == 0x000008, "Wrong alignment on UGzAnimRotatorEnd");
static_assert(sizeof(UGzAnimRotatorEnd) == 0x000038, "Wrong size on UGzAnimRotatorEnd");

// Class G01.GzClientCustomizationService
// 0x0180 (0x0220 - 0x00A0)
class UGzClientCustomizationService final : public UGzClientPFObject
{
public:
	uint8                                         Pad_2C6B[0x180];                                   // 0x00A0(0x0180)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzClientCustomizationService">();
	}
	static class UGzClientCustomizationService* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzClientCustomizationService>();
	}
};
static_assert(alignof(UGzClientCustomizationService) == 0x000008, "Wrong alignment on UGzClientCustomizationService");
static_assert(sizeof(UGzClientCustomizationService) == 0x000220, "Wrong size on UGzClientCustomizationService");

// Class G01.BlueprintLobbyHelpers
// 0x0000 (0x0028 - 0x0028)
class UBlueprintLobbyHelpers final : public UBlueprintFunctionLibrary
{
public:
	static void GetCVarsThatStartWith(const class FString& StartsWith, TArray<class FString>* CVars);
	static TArray<struct FInputActionKeyMapping> GetInputActions(class APlayerController* PlayerController);
	static class FString GetLocalIpAddress();
	static bool ParseFloat(const class FString& String, float* OutValue);
	static bool ParseInt(const class FString& String, int32* OutValue);
	static bool ParseIpV4(const class FString& String, uint8* A, uint8* B, uint8* C, uint8* D);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BlueprintLobbyHelpers">();
	}
	static class UBlueprintLobbyHelpers* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBlueprintLobbyHelpers>();
	}
};
static_assert(alignof(UBlueprintLobbyHelpers) == 0x000008, "Wrong alignment on UBlueprintLobbyHelpers");
static_assert(sizeof(UBlueprintLobbyHelpers) == 0x000028, "Wrong size on UBlueprintLobbyHelpers");

// Class G01.GzWaterMesh
// 0x0020 (0x02C0 - 0x02A0)
class AGzWaterMesh final : public AActor
{
public:
	class UNiagaraSystem*                         WaterInteractionVFX;                               // 0x02A0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UStaticMeshComponent*                   WaterMeshComp;                                     // 0x02A8(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class ACharacter*>                     OverlappingActors;                                 // 0x02B0(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)

public:
	void OnBeginOverlap(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const struct FHitResult& SweepResult);
	void OnEndOverlap(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzWaterMesh">();
	}
	static class AGzWaterMesh* GetDefaultObj()
	{
		return GetDefaultObjImpl<AGzWaterMesh>();
	}
};
static_assert(alignof(AGzWaterMesh) == 0x000008, "Wrong alignment on AGzWaterMesh");
static_assert(sizeof(AGzWaterMesh) == 0x0002C0, "Wrong size on AGzWaterMesh");
static_assert(offsetof(AGzWaterMesh, WaterInteractionVFX) == 0x0002A0, "Member 'AGzWaterMesh::WaterInteractionVFX' has a wrong offset!");
static_assert(offsetof(AGzWaterMesh, WaterMeshComp) == 0x0002A8, "Member 'AGzWaterMesh::WaterMeshComp' has a wrong offset!");
static_assert(offsetof(AGzWaterMesh, OverlappingActors) == 0x0002B0, "Member 'AGzWaterMesh::OverlappingActors' has a wrong offset!");

// Class G01.GzGameplayAbility
// 0x0150 (0x0508 - 0x03B8)
class UGzGameplayAbility : public UGameplayAbility
{
public:
	bool                                          bEndAbilityOnInputRelease;                         // 0x03B8(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C71[0x3];                                     // 0x03B9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         InputPriority;                                     // 0x03BC(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bBufferizeWhenNeeded;                              // 0x03C0(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEndAbilityOnSpecificInputRelease;                 // 0x03C1(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EGzInputEvent                                 SpecificInputEvent;                                // 0x03C2(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C72[0x5];                                     // 0x03C3(0x0005)(Fixing Size After Last Property [ Dumper-7 ])
	class UInputAction*                           SpecificInput;                                     // 0x03C8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCallClientActivateAbility;                        // 0x03D0(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C73[0x7];                                     // 0x03D1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGzAbilityTaskConfigContainer          PreAcivateAbilityTasks;                            // 0x03D8(0x0048)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	struct FGzAbilityTaskConfigContainer          PostEndAbilityTasks;                               // 0x0420(0x0048)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	bool                                          bApplyAnimLayerOnActivation;                       // 0x0468(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2C74[0x7];                                     // 0x0469(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftClassPtr<class UClass>                   AnimLayer;                                         // 0x0470(0x0028)(Edit, DisableEditOnInstance, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bTreatReleaseAsCancel;                             // 0x0498(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bApplyCustomCameraModeOnActivation;                // 0x0499(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2C75[0x2];                                     // 0x049A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTag                           AbilityCameraModeTag;                              // 0x049C(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bApplyCustomCameraModeWithInterpolation;           // 0x04A4(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bApplyCooldownOnAbilityEnd;                        // 0x04A5(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2C76[0x2];                                     // 0x04A6(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTag                           AbilityStartEvent;                                 // 0x04A8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FGameplayTag                           AbilityEndEvent;                                   // 0x04B0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class UGzStateAction*>                 StateActions;                                      // 0x04B8(0x0010)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	TSubclassOf<class UUserWidget>                Widget;                                            // 0x04C8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<TSubclassOf<class UGzGameplayAbility>> GrantedChildGameplayAbilities;                     // 0x04D0(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	uint8                                         Pad_2C77[0x28];                                    // 0x04E0(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ApplyAbilityCameraMode(const struct FGameplayTag& CameraModeTag, const bool bDeactivatePreviousAbilityCameraMode);
	TArray<struct FActiveGameplayEffectHandle> ApplyEffectContainerSpec(const struct FGzGameplayEffectContainerSpec& ContainerSpec);
	bool BP_CanActivateAbility(const class AGzCharacter* Instigator);
	void CallActivateAbilityOnTasksCompleted();
	void CallEndAbilityOnTasksCompleted();
	bool DoesSatisfyTagRequirements_BP();
	void LinkAbilityAnimLayer();
	struct FGzGameplayEffectContainerSpec MakeEffectContainerSpecFromContainer(const struct FGzGameplayEffectContainer& Container, const struct FGameplayEventData& EventData, int32 OverrideGameplayLevel);
	struct FGameplayAbilityTargetDataHandle MakeGameplayAbilityTargetDataHandleFromActorArray(const TArray<class AActor*>& TargetActors);
	struct FGameplayAbilityTargetDataHandle MakeGameplayAbilityTargetDataHandleFromHitResults(const TArray<struct FHitResult>& HitResults);
	void OnAbilityTaskCanceledOrInterrupted();
	void OnSpecificInputEvent();
	bool ProcessPostEndAbilityTasks();
	void RemoveAbilityCameraMode(const struct FGameplayTag& CameraModeTag);
	void ResetAbilityCameraMode();
	void SendTargetDataToServer(const struct FGameplayAbilityTargetDataHandle& TargetData);

	bool BP_IsActive() const;
	bool CanBindToInputEvents() const;
	TSubclassOf<class UUserWidget> GetAbilityWidgetClass() const;
	const struct FGameplayTagContainer GetActivationOwnedTags() const;
	class FString GetCurrentPredictionKeyStatus() const;
	class UGzAbilitySystemComponent* GetGzAbilitySystemComponentFromActorInfo() const;
	class AGzCharacter* GetOwningCharacter() const;
	void GzApplyCost(const struct FGameplayAbilitySpecHandle& Handle, const struct FGameplayAbilityActorInfo& ActorInfo, const struct FGameplayAbilityActivationInfo& ActivationInfo) const;
	bool GzCheckCost(const struct FGameplayAbilitySpecHandle& Handle, const struct FGameplayAbilityActorInfo& ActorInfo) const;
	bool HasAbilityCameraMode(const struct FGameplayTag& CameraModeTag) const;
	bool IsNotAuthorityOrStandalone() const;
	bool IsPredictionKeyValidForMorePrediction() const;
	class UObject* K2_GetSourceObject(const struct FGameplayAbilitySpecHandle& Handle, const struct FGameplayAbilityActorInfo& ActorInfo) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzGameplayAbility">();
	}
	static class UGzGameplayAbility* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzGameplayAbility>();
	}
};
static_assert(alignof(UGzGameplayAbility) == 0x000008, "Wrong alignment on UGzGameplayAbility");
static_assert(sizeof(UGzGameplayAbility) == 0x000508, "Wrong size on UGzGameplayAbility");
static_assert(offsetof(UGzGameplayAbility, bEndAbilityOnInputRelease) == 0x0003B8, "Member 'UGzGameplayAbility::bEndAbilityOnInputRelease' has a wrong offset!");
static_assert(offsetof(UGzGameplayAbility, InputPriority) == 0x0003BC, "Member 'UGzGameplayAbility::InputPriority' has a wrong offset!");
static_assert(offsetof(UGzGameplayAbility, bBufferizeWhenNeeded) == 0x0003C0, "Member 'UGzGameplayAbility::bBufferizeWhenNeeded' has a wrong offset!");
static_assert(offsetof(UGzGameplayAbility, bEndAbilityOnSpecificInputRelease) == 0x0003C1, "Member 'UGzGameplayAbility::bEndAbilityOnSpecificInputRelease' has a wrong offset!");
static_assert(offsetof(UGzGameplayAbility, SpecificInputEvent) == 0x0003C2, "Member 'UGzGameplayAbility::SpecificInputEvent' has a wrong offset!");
static_assert(offsetof(UGzGameplayAbility, SpecificInput) == 0x0003C8, "Member 'UGzGameplayAbility::SpecificInput' has a wrong offset!");
static_assert(offsetof(UGzGameplayAbility, bCallClientActivateAbility) == 0x0003D0, "Member 'UGzGameplayAbility::bCallClientActivateAbility' has a wrong offset!");
static_assert(offsetof(UGzGameplayAbility, PreAcivateAbilityTasks) == 0x0003D8, "Member 'UGzGameplayAbility::PreAcivateAbilityTasks' has a wrong offset!");
static_assert(offsetof(UGzGameplayAbility, PostEndAbilityTasks) == 0x000420, "Member 'UGzGameplayAbility::PostEndAbilityTasks' has a wrong offset!");
static_assert(offsetof(UGzGameplayAbility, bApplyAnimLayerOnActivation) == 0x000468, "Member 'UGzGameplayAbility::bApplyAnimLayerOnActivation' has a wrong offset!");
static_assert(offsetof(UGzGameplayAbility, AnimLayer) == 0x000470, "Member 'UGzGameplayAbility::AnimLayer' has a wrong offset!");
static_assert(offsetof(UGzGameplayAbility, bTreatReleaseAsCancel) == 0x000498, "Member 'UGzGameplayAbility::bTreatReleaseAsCancel' has a wrong offset!");
static_assert(offsetof(UGzGameplayAbility, bApplyCustomCameraModeOnActivation) == 0x000499, "Member 'UGzGameplayAbility::bApplyCustomCameraModeOnActivation' has a wrong offset!");
static_assert(offsetof(UGzGameplayAbility, AbilityCameraModeTag) == 0x00049C, "Member 'UGzGameplayAbility::AbilityCameraModeTag' has a wrong offset!");
static_assert(offsetof(UGzGameplayAbility, bApplyCustomCameraModeWithInterpolation) == 0x0004A4, "Member 'UGzGameplayAbility::bApplyCustomCameraModeWithInterpolation' has a wrong offset!");
static_assert(offsetof(UGzGameplayAbility, bApplyCooldownOnAbilityEnd) == 0x0004A5, "Member 'UGzGameplayAbility::bApplyCooldownOnAbilityEnd' has a wrong offset!");
static_assert(offsetof(UGzGameplayAbility, AbilityStartEvent) == 0x0004A8, "Member 'UGzGameplayAbility::AbilityStartEvent' has a wrong offset!");
static_assert(offsetof(UGzGameplayAbility, AbilityEndEvent) == 0x0004B0, "Member 'UGzGameplayAbility::AbilityEndEvent' has a wrong offset!");
static_assert(offsetof(UGzGameplayAbility, StateActions) == 0x0004B8, "Member 'UGzGameplayAbility::StateActions' has a wrong offset!");
static_assert(offsetof(UGzGameplayAbility, Widget) == 0x0004C8, "Member 'UGzGameplayAbility::Widget' has a wrong offset!");
static_assert(offsetof(UGzGameplayAbility, GrantedChildGameplayAbilities) == 0x0004D0, "Member 'UGzGameplayAbility::GrantedChildGameplayAbilities' has a wrong offset!");

// Class G01.GzGA_CharacterState
// 0x0048 (0x0550 - 0x0508)
class UGzGA_CharacterState : public UGzGameplayAbility
{
public:
	bool                                          bCommitAutomaticallyOnActivate;                    // 0x0508(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bEndOnCharacterStop;                               // 0x0509(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bRequireMovementMode;                              // 0x050A(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bActiveWhileMovementMode;                          // 0x050B(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EMovementMode                                 MovementMode;                                      // 0x050C(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EGzCustomMovementMode                         CustomMovementMode;                                // 0x050D(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bSetGait;                                          // 0x050E(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	ELocomotionGait                               LocomotionGait;                                    // 0x050F(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bSetRotationMode;                                  // 0x0510(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	ELocomotionRotationMode                       RotationMode;                                      // 0x0511(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bFixedStateDuration;                               // 0x0512(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2C80[0x1];                                     // 0x0513(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         StateDuration;                                     // 0x0514(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FTimerHandle                           WaitStateActiveTimer;                              // 0x0518(0x0008)(Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<TSubclassOf<class UGameplayEffect>>    GameplayEffects;                                   // 0x0520(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	TArray<struct FActiveGameplayEffectHandle>    EffectHandles;                                     // 0x0530(0x0010)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	TArray<struct FGzStateVariant>                StateVariants;                                     // 0x0540(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)

public:
	void OnMovementModeChange(class ACharacter* Character, EMovementMode PrevMovementMode, uint8 PreviousCustomMode);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzGA_CharacterState">();
	}
	static class UGzGA_CharacterState* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzGA_CharacterState>();
	}
};
static_assert(alignof(UGzGA_CharacterState) == 0x000008, "Wrong alignment on UGzGA_CharacterState");
static_assert(sizeof(UGzGA_CharacterState) == 0x000550, "Wrong size on UGzGA_CharacterState");
static_assert(offsetof(UGzGA_CharacterState, bCommitAutomaticallyOnActivate) == 0x000508, "Member 'UGzGA_CharacterState::bCommitAutomaticallyOnActivate' has a wrong offset!");
static_assert(offsetof(UGzGA_CharacterState, bEndOnCharacterStop) == 0x000509, "Member 'UGzGA_CharacterState::bEndOnCharacterStop' has a wrong offset!");
static_assert(offsetof(UGzGA_CharacterState, bRequireMovementMode) == 0x00050A, "Member 'UGzGA_CharacterState::bRequireMovementMode' has a wrong offset!");
static_assert(offsetof(UGzGA_CharacterState, bActiveWhileMovementMode) == 0x00050B, "Member 'UGzGA_CharacterState::bActiveWhileMovementMode' has a wrong offset!");
static_assert(offsetof(UGzGA_CharacterState, MovementMode) == 0x00050C, "Member 'UGzGA_CharacterState::MovementMode' has a wrong offset!");
static_assert(offsetof(UGzGA_CharacterState, CustomMovementMode) == 0x00050D, "Member 'UGzGA_CharacterState::CustomMovementMode' has a wrong offset!");
static_assert(offsetof(UGzGA_CharacterState, bSetGait) == 0x00050E, "Member 'UGzGA_CharacterState::bSetGait' has a wrong offset!");
static_assert(offsetof(UGzGA_CharacterState, LocomotionGait) == 0x00050F, "Member 'UGzGA_CharacterState::LocomotionGait' has a wrong offset!");
static_assert(offsetof(UGzGA_CharacterState, bSetRotationMode) == 0x000510, "Member 'UGzGA_CharacterState::bSetRotationMode' has a wrong offset!");
static_assert(offsetof(UGzGA_CharacterState, RotationMode) == 0x000511, "Member 'UGzGA_CharacterState::RotationMode' has a wrong offset!");
static_assert(offsetof(UGzGA_CharacterState, bFixedStateDuration) == 0x000512, "Member 'UGzGA_CharacterState::bFixedStateDuration' has a wrong offset!");
static_assert(offsetof(UGzGA_CharacterState, StateDuration) == 0x000514, "Member 'UGzGA_CharacterState::StateDuration' has a wrong offset!");
static_assert(offsetof(UGzGA_CharacterState, WaitStateActiveTimer) == 0x000518, "Member 'UGzGA_CharacterState::WaitStateActiveTimer' has a wrong offset!");
static_assert(offsetof(UGzGA_CharacterState, GameplayEffects) == 0x000520, "Member 'UGzGA_CharacterState::GameplayEffects' has a wrong offset!");
static_assert(offsetof(UGzGA_CharacterState, EffectHandles) == 0x000530, "Member 'UGzGA_CharacterState::EffectHandles' has a wrong offset!");
static_assert(offsetof(UGzGA_CharacterState, StateVariants) == 0x000540, "Member 'UGzGA_CharacterState::StateVariants' has a wrong offset!");

// Class G01.GzGA_BaseLimbAbility
// 0x0128 (0x0678 - 0x0550)
class UGzGA_BaseLimbAbility : public UGzGA_CharacterState
{
public:
	uint8                                         Pad_2C82[0x8];                                     // 0x0550(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	EGzLimbType                                   LimbSlot;                                          // 0x0558(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C83[0x7];                                     // 0x0559(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	FMulticastInlineDelegateProperty_             OnZeroCharges;                                     // 0x0560(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnFullCharges;                                     // 0x0570(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnChargeAmountChanged;                             // 0x0580(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	class UGzAsyncTaskAttributeChanged*           AttributeChangedTaskHandle;                        // 0x0590(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2C84[0x8];                                     // 0x0598(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UAnimMontage*                           ActivationMontage;                                 // 0x05A0(0x0008)(Edit, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAnimMontage*                           DeactivationMontage;                               // 0x05A8(0x0008)(Edit, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   ActivationMontageStartSection;                     // 0x05B0(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   DeactivationMontageStartSection;                   // 0x05B8(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UGzAT_PlayMontageAndWaitForEvent*       AnimMontage_AbilityTask;                           // 0x05C0(0x0008)(Edit, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2C85[0x30];                                    // 0x05C8(0x0030)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bClearAbilityStateTagsOnEndAbility;                // 0x05F8(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2C86[0x27];                                    // 0x05F9(0x0027)(Fixing Size After Last Property [ Dumper-7 ])
	class UAkAudioEvent*                          ActivationAudioEvent;                              // 0x0620(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAkAudioEvent*                          EndAudioEvent;                                     // 0x0628(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAkAudioEvent*                          CancelAudioEvent;                                  // 0x0630(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bAllowCancelWithInputPress;                        // 0x0638(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2C87[0x7];                                     // 0x0639(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UGzBodyPartAbilityData*                 BodyPartAbilityData;                               // 0x0640(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UGzBodyPartItemData*                    ItemData;                                          // 0x0648(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAbilityTask_WaitInputPress*            WaitForCancelInputTask;                            // 0x0650(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UGzLimbAbilityComponent>    AbilityComponentClass;                             // 0x0658(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bDestroyAbilityComponentOnAbilityRemoval;          // 0x0660(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bStopRechargeWhileActive;                          // 0x0661(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2C88[0x6];                                     // 0x0662(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class UGzLimbAbilityComponent*                AbilityComponent;                                  // 0x0668(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2C89[0x8];                                     // 0x0670(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AddAbilityStateTag(const struct FGameplayTag& Tag, const bool bReplicate);
	void BP_OnGiveAbility();
	void BP_OnRemoveAbility();
	void CancelAbilityAfterInput(float TimeWaited);
	void ClearAbilityStateTags();
	void EndAbilityWithAnimation();
	void OnChargesAttributeChanged(const struct FGameplayAttribute& Attribute, float NewValue, float OldValue);
	void OnMontageEnded();
	void PlayAnimEffect(class UAnimMontage* Effect);
	void ReadAbilityConfig();
	void RemoveAbilityStateTag(const struct FGameplayTag& Tag, const bool bReplicate);
	void ResetCancelViaAbilityInput();
	void SetAimingState(bool bIsAiming);
	void SetCancelViaAbilityInputEnabled(const bool bSetEnabled);
	void SetLimbHandOffset(const struct FVector& HandOffset);
	void SetLimbHandShoulderDistance(const float Distance);
	void SetLimbTargetLocation(const struct FVector& TargetLocation);

	class UActorComponent* BP_GetAbilityComponent() const;
	class UGzBodyPartAbilityData* BP_GetAbilityData() const;
	void BP_GetCurrentRemainingRechargeTimeAndDuration(float* TimeRemaining, float* RechargeDuration) const;
	void BP_GetTotalRemainingRechargeTimeAndDuration(float* TotalTimeRemaining, float* TotalRechargeDuration) const;
	float GetAbilityChargePercentage() const;
	struct FGameplayAttribute GetAbilityChargesAttribute() const;
	float GetActivationCost() const;
	int32 GetCurrentCharges() const;
	class UGzBodyPartItemData* GetItemData() const;
	class UGzLimbComponent* GetLimbComponent() const;
	struct FVector GetLimbHandOffset() const;
	struct FVector GetLimbSocketWorldLocation(const class FName& SocketName) const;
	struct FVector GetLimbTargetLocation() const;
	int32 GetMaxCharges() const;
	float GetRechargeDuration() const;
	struct FGameplayTag GetRechargeTypeTag() const;
	bool IsInAimingState() const;
	bool IsRecharging() const;
	void SendLimbAbilityUsageMessage() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzGA_BaseLimbAbility">();
	}
	static class UGzGA_BaseLimbAbility* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzGA_BaseLimbAbility>();
	}
};
static_assert(alignof(UGzGA_BaseLimbAbility) == 0x000008, "Wrong alignment on UGzGA_BaseLimbAbility");
static_assert(sizeof(UGzGA_BaseLimbAbility) == 0x000678, "Wrong size on UGzGA_BaseLimbAbility");
static_assert(offsetof(UGzGA_BaseLimbAbility, LimbSlot) == 0x000558, "Member 'UGzGA_BaseLimbAbility::LimbSlot' has a wrong offset!");
static_assert(offsetof(UGzGA_BaseLimbAbility, OnZeroCharges) == 0x000560, "Member 'UGzGA_BaseLimbAbility::OnZeroCharges' has a wrong offset!");
static_assert(offsetof(UGzGA_BaseLimbAbility, OnFullCharges) == 0x000570, "Member 'UGzGA_BaseLimbAbility::OnFullCharges' has a wrong offset!");
static_assert(offsetof(UGzGA_BaseLimbAbility, OnChargeAmountChanged) == 0x000580, "Member 'UGzGA_BaseLimbAbility::OnChargeAmountChanged' has a wrong offset!");
static_assert(offsetof(UGzGA_BaseLimbAbility, AttributeChangedTaskHandle) == 0x000590, "Member 'UGzGA_BaseLimbAbility::AttributeChangedTaskHandle' has a wrong offset!");
static_assert(offsetof(UGzGA_BaseLimbAbility, ActivationMontage) == 0x0005A0, "Member 'UGzGA_BaseLimbAbility::ActivationMontage' has a wrong offset!");
static_assert(offsetof(UGzGA_BaseLimbAbility, DeactivationMontage) == 0x0005A8, "Member 'UGzGA_BaseLimbAbility::DeactivationMontage' has a wrong offset!");
static_assert(offsetof(UGzGA_BaseLimbAbility, ActivationMontageStartSection) == 0x0005B0, "Member 'UGzGA_BaseLimbAbility::ActivationMontageStartSection' has a wrong offset!");
static_assert(offsetof(UGzGA_BaseLimbAbility, DeactivationMontageStartSection) == 0x0005B8, "Member 'UGzGA_BaseLimbAbility::DeactivationMontageStartSection' has a wrong offset!");
static_assert(offsetof(UGzGA_BaseLimbAbility, AnimMontage_AbilityTask) == 0x0005C0, "Member 'UGzGA_BaseLimbAbility::AnimMontage_AbilityTask' has a wrong offset!");
static_assert(offsetof(UGzGA_BaseLimbAbility, bClearAbilityStateTagsOnEndAbility) == 0x0005F8, "Member 'UGzGA_BaseLimbAbility::bClearAbilityStateTagsOnEndAbility' has a wrong offset!");
static_assert(offsetof(UGzGA_BaseLimbAbility, ActivationAudioEvent) == 0x000620, "Member 'UGzGA_BaseLimbAbility::ActivationAudioEvent' has a wrong offset!");
static_assert(offsetof(UGzGA_BaseLimbAbility, EndAudioEvent) == 0x000628, "Member 'UGzGA_BaseLimbAbility::EndAudioEvent' has a wrong offset!");
static_assert(offsetof(UGzGA_BaseLimbAbility, CancelAudioEvent) == 0x000630, "Member 'UGzGA_BaseLimbAbility::CancelAudioEvent' has a wrong offset!");
static_assert(offsetof(UGzGA_BaseLimbAbility, bAllowCancelWithInputPress) == 0x000638, "Member 'UGzGA_BaseLimbAbility::bAllowCancelWithInputPress' has a wrong offset!");
static_assert(offsetof(UGzGA_BaseLimbAbility, BodyPartAbilityData) == 0x000640, "Member 'UGzGA_BaseLimbAbility::BodyPartAbilityData' has a wrong offset!");
static_assert(offsetof(UGzGA_BaseLimbAbility, ItemData) == 0x000648, "Member 'UGzGA_BaseLimbAbility::ItemData' has a wrong offset!");
static_assert(offsetof(UGzGA_BaseLimbAbility, WaitForCancelInputTask) == 0x000650, "Member 'UGzGA_BaseLimbAbility::WaitForCancelInputTask' has a wrong offset!");
static_assert(offsetof(UGzGA_BaseLimbAbility, AbilityComponentClass) == 0x000658, "Member 'UGzGA_BaseLimbAbility::AbilityComponentClass' has a wrong offset!");
static_assert(offsetof(UGzGA_BaseLimbAbility, bDestroyAbilityComponentOnAbilityRemoval) == 0x000660, "Member 'UGzGA_BaseLimbAbility::bDestroyAbilityComponentOnAbilityRemoval' has a wrong offset!");
static_assert(offsetof(UGzGA_BaseLimbAbility, bStopRechargeWhileActive) == 0x000661, "Member 'UGzGA_BaseLimbAbility::bStopRechargeWhileActive' has a wrong offset!");
static_assert(offsetof(UGzGA_BaseLimbAbility, AbilityComponent) == 0x000668, "Member 'UGzGA_BaseLimbAbility::AbilityComponent' has a wrong offset!");

// Class G01.GzGA_Charge_LimbAbility
// 0x0080 (0x06F8 - 0x0678)
class UGzGA_Charge_LimbAbility : public UGzGA_BaseLimbAbility
{
public:
	TSoftObjectPtr<class UAnimMontage>            AimingShootingMontage;                             // 0x0678(0x0028)(Edit, DisableEditOnInstance, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   ActivationSection;                                 // 0x06A0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   DeactivationSection;                               // 0x06A8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   AimingSection;                                     // 0x06B0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   ShootingSection;                                   // 0x06B8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bStartCooldownAfterTriggering;                     // 0x06C0(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bTriggerOnActivation;                              // 0x06C1(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bAllowOnlyOneTriggeringPerActivation;              // 0x06C2(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2C8C[0x5];                                     // 0x06C3(0x0005)(Fixing Size After Last Property [ Dumper-7 ])
	class UAbilityTask_WaitInputRelease*          WaitInputReleaseTask;                              // 0x06C8(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAbilityTask_PlayMontageAndWait*        AimingShootingMontageTask;                         // 0x06D0(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2C8D[0x20];                                    // 0x06D8(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnAbilityInputReleased();
	void OnAimingShootingMontageCompleted();
	void OnAssetsLoaded();
	void OnCooldownStopped();
	void StartCooldown();
	bool TriggerAbility();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzGA_Charge_LimbAbility">();
	}
	static class UGzGA_Charge_LimbAbility* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzGA_Charge_LimbAbility>();
	}
};
static_assert(alignof(UGzGA_Charge_LimbAbility) == 0x000008, "Wrong alignment on UGzGA_Charge_LimbAbility");
static_assert(sizeof(UGzGA_Charge_LimbAbility) == 0x0006F8, "Wrong size on UGzGA_Charge_LimbAbility");
static_assert(offsetof(UGzGA_Charge_LimbAbility, AimingShootingMontage) == 0x000678, "Member 'UGzGA_Charge_LimbAbility::AimingShootingMontage' has a wrong offset!");
static_assert(offsetof(UGzGA_Charge_LimbAbility, ActivationSection) == 0x0006A0, "Member 'UGzGA_Charge_LimbAbility::ActivationSection' has a wrong offset!");
static_assert(offsetof(UGzGA_Charge_LimbAbility, DeactivationSection) == 0x0006A8, "Member 'UGzGA_Charge_LimbAbility::DeactivationSection' has a wrong offset!");
static_assert(offsetof(UGzGA_Charge_LimbAbility, AimingSection) == 0x0006B0, "Member 'UGzGA_Charge_LimbAbility::AimingSection' has a wrong offset!");
static_assert(offsetof(UGzGA_Charge_LimbAbility, ShootingSection) == 0x0006B8, "Member 'UGzGA_Charge_LimbAbility::ShootingSection' has a wrong offset!");
static_assert(offsetof(UGzGA_Charge_LimbAbility, bStartCooldownAfterTriggering) == 0x0006C0, "Member 'UGzGA_Charge_LimbAbility::bStartCooldownAfterTriggering' has a wrong offset!");
static_assert(offsetof(UGzGA_Charge_LimbAbility, bTriggerOnActivation) == 0x0006C1, "Member 'UGzGA_Charge_LimbAbility::bTriggerOnActivation' has a wrong offset!");
static_assert(offsetof(UGzGA_Charge_LimbAbility, bAllowOnlyOneTriggeringPerActivation) == 0x0006C2, "Member 'UGzGA_Charge_LimbAbility::bAllowOnlyOneTriggeringPerActivation' has a wrong offset!");
static_assert(offsetof(UGzGA_Charge_LimbAbility, WaitInputReleaseTask) == 0x0006C8, "Member 'UGzGA_Charge_LimbAbility::WaitInputReleaseTask' has a wrong offset!");
static_assert(offsetof(UGzGA_Charge_LimbAbility, AimingShootingMontageTask) == 0x0006D0, "Member 'UGzGA_Charge_LimbAbility::AimingShootingMontageTask' has a wrong offset!");

// Class G01.GzGA_ChargeProjectile
// 0x0098 (0x0790 - 0x06F8)
class alignas(0x10) UGzGA_ChargeProjectile : public UGzGA_Charge_LimbAbility
{
public:
	TSoftClassPtr<class UClass>                   ProjectileClass;                                   // 0x06F8(0x0028)(Edit, DisableEditOnInstance, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FGameplayTag                           ShootingGameplayCueTag;                            // 0x0720(0x0008)(Edit, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2C8E[0x68];                                    // 0x0728(0x0068)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Server_ReceiveClientTargetData(const struct FGameplayAbilityTargetDataHandle& Data);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzGA_ChargeProjectile">();
	}
	static class UGzGA_ChargeProjectile* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzGA_ChargeProjectile>();
	}
};
static_assert(alignof(UGzGA_ChargeProjectile) == 0x000010, "Wrong alignment on UGzGA_ChargeProjectile");
static_assert(sizeof(UGzGA_ChargeProjectile) == 0x000790, "Wrong size on UGzGA_ChargeProjectile");
static_assert(offsetof(UGzGA_ChargeProjectile, ProjectileClass) == 0x0006F8, "Member 'UGzGA_ChargeProjectile::ProjectileClass' has a wrong offset!");
static_assert(offsetof(UGzGA_ChargeProjectile, ShootingGameplayCueTag) == 0x000720, "Member 'UGzGA_ChargeProjectile::ShootingGameplayCueTag' has a wrong offset!");

// Class G01.GzGA_StickyGoo
// 0x0000 (0x0790 - 0x0790)
class UGzGA_StickyGoo : public UGzGA_ChargeProjectile
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzGA_StickyGoo">();
	}
	static class UGzGA_StickyGoo* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzGA_StickyGoo>();
	}
};
static_assert(alignof(UGzGA_StickyGoo) == 0x000010, "Wrong alignment on UGzGA_StickyGoo");
static_assert(sizeof(UGzGA_StickyGoo) == 0x000790, "Wrong size on UGzGA_StickyGoo");

// Class G01.EnvQueryTest_IsInterestPointFree
// 0x0000 (0x01F8 - 0x01F8)
class UEnvQueryTest_IsInterestPointFree final : public UEnvQueryTest
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EnvQueryTest_IsInterestPointFree">();
	}
	static class UEnvQueryTest_IsInterestPointFree* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEnvQueryTest_IsInterestPointFree>();
	}
};
static_assert(alignof(UEnvQueryTest_IsInterestPointFree) == 0x000008, "Wrong alignment on UEnvQueryTest_IsInterestPointFree");
static_assert(sizeof(UEnvQueryTest_IsInterestPointFree) == 0x0001F8, "Wrong size on UEnvQueryTest_IsInterestPointFree");

// Class G01.GzLoginModel
// 0x0020 (0x0090 - 0x0070)
class UGzLoginModel final : public UGzBackendModel
{
public:
	struct FGzCohtmlLoginQueueDetails             LoginQueue;                                        // 0x0070(0x0018)(NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C8F[0x8];                                     // 0x0088(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzLoginModel">();
	}
	static class UGzLoginModel* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzLoginModel>();
	}
};
static_assert(alignof(UGzLoginModel) == 0x000008, "Wrong alignment on UGzLoginModel");
static_assert(sizeof(UGzLoginModel) == 0x000090, "Wrong size on UGzLoginModel");
static_assert(offsetof(UGzLoginModel, LoginQueue) == 0x000070, "Member 'UGzLoginModel::LoginQueue' has a wrong offset!");

// Class G01.GzClientPlayerInventorySettings
// 0x0008 (0x0040 - 0x0038)
class UGzClientPlayerInventorySettings final : public UDeveloperSettings
{
public:
	float                                         ReviewedMarkSaveDelay;                             // 0x0038(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ReviewedMarkSaveMaxDelay;                          // 0x003C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzClientPlayerInventorySettings">();
	}
	static class UGzClientPlayerInventorySettings* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzClientPlayerInventorySettings>();
	}
};
static_assert(alignof(UGzClientPlayerInventorySettings) == 0x000008, "Wrong alignment on UGzClientPlayerInventorySettings");
static_assert(sizeof(UGzClientPlayerInventorySettings) == 0x000040, "Wrong size on UGzClientPlayerInventorySettings");
static_assert(offsetof(UGzClientPlayerInventorySettings, ReviewedMarkSaveDelay) == 0x000038, "Member 'UGzClientPlayerInventorySettings::ReviewedMarkSaveDelay' has a wrong offset!");
static_assert(offsetof(UGzClientPlayerInventorySettings, ReviewedMarkSaveMaxDelay) == 0x00003C, "Member 'UGzClientPlayerInventorySettings::ReviewedMarkSaveMaxDelay' has a wrong offset!");

// Class G01.GzSendEventNotify
// 0x0010 (0x0048 - 0x0038)
class UGzSendEventNotify final : public UAnimNotify
{
public:
	struct FGameplayTag                           EventTag;                                          // 0x0038(0x0008)(Edit, BlueprintReadOnly, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bSendOnAuthorityOnly;                              // 0x0040(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2C90[0x7];                                     // 0x0041(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzSendEventNotify">();
	}
	static class UGzSendEventNotify* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzSendEventNotify>();
	}
};
static_assert(alignof(UGzSendEventNotify) == 0x000008, "Wrong alignment on UGzSendEventNotify");
static_assert(sizeof(UGzSendEventNotify) == 0x000048, "Wrong size on UGzSendEventNotify");
static_assert(offsetof(UGzSendEventNotify, EventTag) == 0x000038, "Member 'UGzSendEventNotify::EventTag' has a wrong offset!");
static_assert(offsetof(UGzSendEventNotify, bSendOnAuthorityOnly) == 0x000040, "Member 'UGzSendEventNotify::bSendOnAuthorityOnly' has a wrong offset!");

// Class G01.GameplayPerformanceTrackerSystem
// 0x0060 (0x0090 - 0x0030)
class UGameplayPerformanceTrackerSystem final : public UWorldSubsystem
{
public:
	uint8                                         Pad_2C91[0x58];                                    // 0x0030(0x0058)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         PhysicsSimStatsPrintInterval;                      // 0x0088(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2C92[0x4];                                     // 0x008C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void PrintPerformanceStats();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GameplayPerformanceTrackerSystem">();
	}
	static class UGameplayPerformanceTrackerSystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGameplayPerformanceTrackerSystem>();
	}
};
static_assert(alignof(UGameplayPerformanceTrackerSystem) == 0x000008, "Wrong alignment on UGameplayPerformanceTrackerSystem");
static_assert(sizeof(UGameplayPerformanceTrackerSystem) == 0x000090, "Wrong size on UGameplayPerformanceTrackerSystem");
static_assert(offsetof(UGameplayPerformanceTrackerSystem, PhysicsSimStatsPrintInterval) == 0x000088, "Member 'UGameplayPerformanceTrackerSystem::PhysicsSimStatsPrintInterval' has a wrong offset!");

// Class G01.GzDamageIndicatorConfig
// 0x0108 (0x0140 - 0x0038)
class UGzDamageIndicatorConfig final : public UDeveloperSettings
{
public:
	TMap<EGzDamageIndicatorType, TSoftClassPtr<class UClass>> IndicatorClasses;                                  // 0x0038(0x0050)(Edit, Config, DisableEditOnInstance, UObjectWrapper, NativeAccessSpecifierPublic)
	TSet<struct FGameplayTag>                     AllowedSelfDamageSources;                          // 0x0088(0x0050)(Edit, Config, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TMap<EGzDamageIndicatorType, int32>           IndicatorTypesPriority;                            // 0x00D8(0x0050)(Edit, Config, DisableEditOnInstance, NativeAccessSpecifierPublic)
	float                                         RightOffset;                                       // 0x0128(0x0004)(Edit, ZeroConstructor, Config, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ForwardOffset;                                     // 0x012C(0x0004)(Edit, ZeroConstructor, Config, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HeightOffset;                                      // 0x0130(0x0004)(Edit, ZeroConstructor, Config, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Radius;                                            // 0x0134(0x0004)(Edit, ZeroConstructor, Config, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSystemActive;                                     // 0x0138(0x0001)(Edit, ZeroConstructor, Config, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C93[0x7];                                     // 0x0139(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzDamageIndicatorConfig">();
	}
	static class UGzDamageIndicatorConfig* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzDamageIndicatorConfig>();
	}
};
static_assert(alignof(UGzDamageIndicatorConfig) == 0x000008, "Wrong alignment on UGzDamageIndicatorConfig");
static_assert(sizeof(UGzDamageIndicatorConfig) == 0x000140, "Wrong size on UGzDamageIndicatorConfig");
static_assert(offsetof(UGzDamageIndicatorConfig, IndicatorClasses) == 0x000038, "Member 'UGzDamageIndicatorConfig::IndicatorClasses' has a wrong offset!");
static_assert(offsetof(UGzDamageIndicatorConfig, AllowedSelfDamageSources) == 0x000088, "Member 'UGzDamageIndicatorConfig::AllowedSelfDamageSources' has a wrong offset!");
static_assert(offsetof(UGzDamageIndicatorConfig, IndicatorTypesPriority) == 0x0000D8, "Member 'UGzDamageIndicatorConfig::IndicatorTypesPriority' has a wrong offset!");
static_assert(offsetof(UGzDamageIndicatorConfig, RightOffset) == 0x000128, "Member 'UGzDamageIndicatorConfig::RightOffset' has a wrong offset!");
static_assert(offsetof(UGzDamageIndicatorConfig, ForwardOffset) == 0x00012C, "Member 'UGzDamageIndicatorConfig::ForwardOffset' has a wrong offset!");
static_assert(offsetof(UGzDamageIndicatorConfig, HeightOffset) == 0x000130, "Member 'UGzDamageIndicatorConfig::HeightOffset' has a wrong offset!");
static_assert(offsetof(UGzDamageIndicatorConfig, Radius) == 0x000134, "Member 'UGzDamageIndicatorConfig::Radius' has a wrong offset!");
static_assert(offsetof(UGzDamageIndicatorConfig, bSystemActive) == 0x000138, "Member 'UGzDamageIndicatorConfig::bSystemActive' has a wrong offset!");

// Class G01.GzWE_DamageAware
// 0x0000 (0x0028 - 0x0028)
class UGzWE_DamageAware final : public UUserWidgetExtension
{
public:
	void OnDamageRecieved(const struct FGzServerDamageInfo& DamageInfo);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzWE_DamageAware">();
	}
	static class UGzWE_DamageAware* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzWE_DamageAware>();
	}
};
static_assert(alignof(UGzWE_DamageAware) == 0x000008, "Wrong alignment on UGzWE_DamageAware");
static_assert(sizeof(UGzWE_DamageAware) == 0x000028, "Wrong size on UGzWE_DamageAware");

// Class G01.GzPawnControlsComponent
// 0x0088 (0x0130 - 0x00A8)
class UGzPawnControlsComponent : public UActorComponent
{
public:
	class UGzPawnInputMappingConfig*              StartupMappingConfig;                              // 0x00A8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UEnhancedInputComponent*                InputComponent;                                    // 0x00B0(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TMap<struct FGzInputConfigBindingHandle, class UGzPawnInputMappingConfig*> ActiveConfigs;                                     // 0x00B8(0x0050)(Transient, Protected, NativeAccessSpecifierProtected)
	class UInputAction*                           PingAction;                                        // 0x0108(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<struct FAbilityInputActionBinding>     BoundInputActions;                                 // 0x0110(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2C94[0x10];                                    // 0x0120(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnPawnRestarted(class APawn* Pawn);
	void PopInputMapping(struct FGzInputConfigBindingHandle& InHandle, const struct FModifyContextOptions& OPTIONS);
	struct FGzInputConfigBindingHandle PushInputMapping(class UGzPawnInputMappingConfig* InMappingConfig, const struct FModifyContextOptions& OPTIONS);
	void SetupPlayerControls(class UEnhancedInputComponent* PlayerInputComponent);
	void TeardownPlayerControls(class UEnhancedInputComponent* PlayerInputComponent);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzPawnControlsComponent">();
	}
	static class UGzPawnControlsComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzPawnControlsComponent>();
	}
};
static_assert(alignof(UGzPawnControlsComponent) == 0x000008, "Wrong alignment on UGzPawnControlsComponent");
static_assert(sizeof(UGzPawnControlsComponent) == 0x000130, "Wrong size on UGzPawnControlsComponent");
static_assert(offsetof(UGzPawnControlsComponent, StartupMappingConfig) == 0x0000A8, "Member 'UGzPawnControlsComponent::StartupMappingConfig' has a wrong offset!");
static_assert(offsetof(UGzPawnControlsComponent, InputComponent) == 0x0000B0, "Member 'UGzPawnControlsComponent::InputComponent' has a wrong offset!");
static_assert(offsetof(UGzPawnControlsComponent, ActiveConfigs) == 0x0000B8, "Member 'UGzPawnControlsComponent::ActiveConfigs' has a wrong offset!");
static_assert(offsetof(UGzPawnControlsComponent, PingAction) == 0x000108, "Member 'UGzPawnControlsComponent::PingAction' has a wrong offset!");
static_assert(offsetof(UGzPawnControlsComponent, BoundInputActions) == 0x000110, "Member 'UGzPawnControlsComponent::BoundInputActions' has a wrong offset!");

// Class G01.Gz3DDamageIndicationSubsystem
// 0x0070 (0x00A0 - 0x0030)
class UGz3DDamageIndicationSubsystem final : public ULocalPlayerSubsystem
{
public:
	class AGzPlayerController*                    CurrentController;                                 // 0x0030(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class AGzPlayerCharacter*                     ViewTarget;                                        // 0x0038(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TMap<struct FGzDamageIndicatorKey, class AGz3DDamageIndicator*> CachedIndicators;                                  // 0x0040(0x0050)(Transient, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2C97[0x10];                                    // 0x0090(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnPawnChanged(class APawn* Pawn);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Gz3DDamageIndicationSubsystem">();
	}
	static class UGz3DDamageIndicationSubsystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGz3DDamageIndicationSubsystem>();
	}
};
static_assert(alignof(UGz3DDamageIndicationSubsystem) == 0x000008, "Wrong alignment on UGz3DDamageIndicationSubsystem");
static_assert(sizeof(UGz3DDamageIndicationSubsystem) == 0x0000A0, "Wrong size on UGz3DDamageIndicationSubsystem");
static_assert(offsetof(UGz3DDamageIndicationSubsystem, CurrentController) == 0x000030, "Member 'UGz3DDamageIndicationSubsystem::CurrentController' has a wrong offset!");
static_assert(offsetof(UGz3DDamageIndicationSubsystem, ViewTarget) == 0x000038, "Member 'UGz3DDamageIndicationSubsystem::ViewTarget' has a wrong offset!");
static_assert(offsetof(UGz3DDamageIndicationSubsystem, CachedIndicators) == 0x000040, "Member 'UGz3DDamageIndicationSubsystem::CachedIndicators' has a wrong offset!");

// Class G01.GzWeaponSpreadData
// 0x0030 (0x0060 - 0x0030)
class UGzWeaponSpreadData final : public UDataAsset
{
public:
	float                                         BaseAngleValue;                                    // 0x0030(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ADSMultiplier;                                     // 0x0034(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxScaleRatio;                                     // 0x0038(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         GrowthScaleRatioStep;                              // 0x003C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         GrowthScaleRatioStepADS;                           // 0x0040(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CooldownScaleRatioSpeed;                           // 0x0044(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         WalkingAccuracyModifier;                           // 0x0048(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SprintingAccuracyModifier;                         // 0x004C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CrouchingAccuracyModifier;                         // 0x0050(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SlidingAccuracyModifier;                           // 0x0054(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         GrapplingAccuracyModifier;                         // 0x0058(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FallingAccuracyModifier;                           // 0x005C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzWeaponSpreadData">();
	}
	static class UGzWeaponSpreadData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzWeaponSpreadData>();
	}
};
static_assert(alignof(UGzWeaponSpreadData) == 0x000008, "Wrong alignment on UGzWeaponSpreadData");
static_assert(sizeof(UGzWeaponSpreadData) == 0x000060, "Wrong size on UGzWeaponSpreadData");
static_assert(offsetof(UGzWeaponSpreadData, BaseAngleValue) == 0x000030, "Member 'UGzWeaponSpreadData::BaseAngleValue' has a wrong offset!");
static_assert(offsetof(UGzWeaponSpreadData, ADSMultiplier) == 0x000034, "Member 'UGzWeaponSpreadData::ADSMultiplier' has a wrong offset!");
static_assert(offsetof(UGzWeaponSpreadData, MaxScaleRatio) == 0x000038, "Member 'UGzWeaponSpreadData::MaxScaleRatio' has a wrong offset!");
static_assert(offsetof(UGzWeaponSpreadData, GrowthScaleRatioStep) == 0x00003C, "Member 'UGzWeaponSpreadData::GrowthScaleRatioStep' has a wrong offset!");
static_assert(offsetof(UGzWeaponSpreadData, GrowthScaleRatioStepADS) == 0x000040, "Member 'UGzWeaponSpreadData::GrowthScaleRatioStepADS' has a wrong offset!");
static_assert(offsetof(UGzWeaponSpreadData, CooldownScaleRatioSpeed) == 0x000044, "Member 'UGzWeaponSpreadData::CooldownScaleRatioSpeed' has a wrong offset!");
static_assert(offsetof(UGzWeaponSpreadData, WalkingAccuracyModifier) == 0x000048, "Member 'UGzWeaponSpreadData::WalkingAccuracyModifier' has a wrong offset!");
static_assert(offsetof(UGzWeaponSpreadData, SprintingAccuracyModifier) == 0x00004C, "Member 'UGzWeaponSpreadData::SprintingAccuracyModifier' has a wrong offset!");
static_assert(offsetof(UGzWeaponSpreadData, CrouchingAccuracyModifier) == 0x000050, "Member 'UGzWeaponSpreadData::CrouchingAccuracyModifier' has a wrong offset!");
static_assert(offsetof(UGzWeaponSpreadData, SlidingAccuracyModifier) == 0x000054, "Member 'UGzWeaponSpreadData::SlidingAccuracyModifier' has a wrong offset!");
static_assert(offsetof(UGzWeaponSpreadData, GrapplingAccuracyModifier) == 0x000058, "Member 'UGzWeaponSpreadData::GrapplingAccuracyModifier' has a wrong offset!");
static_assert(offsetof(UGzWeaponSpreadData, FallingAccuracyModifier) == 0x00005C, "Member 'UGzWeaponSpreadData::FallingAccuracyModifier' has a wrong offset!");

// Class G01.Gz3DDamageIndicator
// 0x0050 (0x02F0 - 0x02A0)
class AGz3DDamageIndicator final : public AActor
{
public:
	uint8                                         Pad_2C98[0x18];                                    // 0x02A0(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGzDamageDirectionData                 DamageData;                                        // 0x02B8(0x0030)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, Protected, NativeAccessSpecifierProtected)
	class APawn*                                  ViewTarget;                                        // 0x02E8(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void OnInit(const struct FGzDamageDirectionData& InDamageData);
	void OnRepeat();
	void Stop();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Gz3DDamageIndicator">();
	}
	static class AGz3DDamageIndicator* GetDefaultObj()
	{
		return GetDefaultObjImpl<AGz3DDamageIndicator>();
	}
};
static_assert(alignof(AGz3DDamageIndicator) == 0x000008, "Wrong alignment on AGz3DDamageIndicator");
static_assert(sizeof(AGz3DDamageIndicator) == 0x0002F0, "Wrong size on AGz3DDamageIndicator");
static_assert(offsetof(AGz3DDamageIndicator, DamageData) == 0x0002B8, "Member 'AGz3DDamageIndicator::DamageData' has a wrong offset!");
static_assert(offsetof(AGz3DDamageIndicator, ViewTarget) == 0x0002E8, "Member 'AGz3DDamageIndicator::ViewTarget' has a wrong offset!");

// Class G01.GzGA_SmashLanding
// 0x0300 (0x0978 - 0x0678)
class UGzGA_SmashLanding : public UGzGA_BaseLimbAbility
{
public:
	float                                         EndAbilityDelaySeconds;                            // 0x0678(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2C99[0x4];                                     // 0x067C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGzDashParams                          DashParams;                                        // 0x0680(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, Protected, NativeAccessSpecifierProtected)
	class UGzDashParamsData*                      DashParamsData;                                    // 0x06A8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         DashMaxHorizontalDistance;                         // 0x06B0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         LandingCollisionSizeIncrease;                      // 0x06B4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         LandingCollisionSweepLength;                       // 0x06B8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         DashTargetClientOffsetTolerance;                   // 0x06BC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<ECollisionChannel>                     LandingCollisionChannels;                          // 0x06C0(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	float                                         TargetingStartDelay;                               // 0x06D0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         TargetingTimeSeconds;                              // 0x06D4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         FallingTargetingTimeSeconds;                       // 0x06D8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ActivationMinGroundDistance;                       // 0x06DC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         DashStartMinGroundDistance;                        // 0x06E0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FGzHoverParams                         HoverParams;                                       // 0x06E4(0x001C)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FGameplayTag                           TargetingCameraModeTag;                            // 0x0700(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FGameplayTag                           DashCameraModeTag;                                 // 0x0708(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FGameplayTag                           SmashCameraModeTag;                                // 0x0710(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UInputAction*                           AttackInputAction;                                 // 0x0718(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         TargetingMaxAngle;                                 // 0x0720(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bRotateTargetPreviewToSurface;                     // 0x0724(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2C9A[0x3];                                     // 0x0725(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftClassPtr<class UClass>                   TargetPreviewClass;                                // 0x0728(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<ECollisionChannel>                     TargetPlacementTraceChannels;                      // 0x0750(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	TSubclassOf<class UGameplayEffect>            ConcussionEffectClass;                             // 0x0760(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<ECollisionChannel>                     DamageTraceChannels;                               // 0x0768(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FGameplayTag                           JumpStateTag;                                      // 0x0778(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FGameplayTag                           HoverStateTag;                                     // 0x0780(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FGameplayTag                           DashStateTag;                                      // 0x0788(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FGameplayTag                           SmashStateTag;                                     // 0x0790(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FGameplayTag                           LandedStateTag;                                    // 0x0798(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bTargetingActive;                                  // 0x07A0(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bDashStarted;                                      // 0x07A1(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bHasLanded;                                        // 0x07A2(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bDependenciesLoaded;                               // 0x07A3(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsTargetOutOfRange;                               // 0x07A4(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2C9B[0x83];                                    // 0x07A5(0x0083)(Fixing Size After Last Property [ Dumper-7 ])
	struct FHitResult                             DashTarget;                                        // 0x0828(0x00F8)(Transient, IsPlainOldData, NoDestructor, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	struct FVector                                DashingDirection;                                  // 0x0920(0x0018)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class AActor*                                 TargetPreviewActor;                                // 0x0938(0x0008)(BlueprintVisible, ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UGzAT_AbilityTick*                      TargetingTickTask;                                 // 0x0940(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UGzAT_ServerWaitForTargetData*          ServerWaitForTargetData;                           // 0x0948(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FTimerHandle                           TargetingStartDelayHandle;                         // 0x0950(0x0008)(Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FTimerHandle                           EndAbilityDelayHandle;                             // 0x0958(0x0008)(Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FTimerHandle                           FallingDeactivationTimerHandle;                    // 0x0960(0x0008)(Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2C9C[0x10];                                    // 0x0968(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void BP_OnDashEnded();
	void BP_OnDashStarted();
	void BP_OnFalling();
	void BP_OnJumpStarted();
	void BP_OnLanding();
	void BP_OnSmashLanding(const struct FHitResult& HitResult);
	void BP_OnTargetChanged(bool bIsOutOfRange);
	void BP_OnTargetingEnded();
	void BP_OnTargetingStarted();
	void OnAttackInputPressed(float TimeHeld);
	void OnCharacterLanded(const struct FHitResult& Hit);
	void OnDashStopped(const struct FHitResult& HitResult);
	void OnDependenciesLoaded();
	void OnTargetingTaskEnded(bool bWasCompleted);
	void OnTargetingTick(float DeltaTime);
	void ServerHandleClientDashHitData(const struct FGameplayAbilityTargetDataHandle& TargetData);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzGA_SmashLanding">();
	}
	static class UGzGA_SmashLanding* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzGA_SmashLanding>();
	}
};
static_assert(alignof(UGzGA_SmashLanding) == 0x000008, "Wrong alignment on UGzGA_SmashLanding");
static_assert(sizeof(UGzGA_SmashLanding) == 0x000978, "Wrong size on UGzGA_SmashLanding");
static_assert(offsetof(UGzGA_SmashLanding, EndAbilityDelaySeconds) == 0x000678, "Member 'UGzGA_SmashLanding::EndAbilityDelaySeconds' has a wrong offset!");
static_assert(offsetof(UGzGA_SmashLanding, DashParams) == 0x000680, "Member 'UGzGA_SmashLanding::DashParams' has a wrong offset!");
static_assert(offsetof(UGzGA_SmashLanding, DashParamsData) == 0x0006A8, "Member 'UGzGA_SmashLanding::DashParamsData' has a wrong offset!");
static_assert(offsetof(UGzGA_SmashLanding, DashMaxHorizontalDistance) == 0x0006B0, "Member 'UGzGA_SmashLanding::DashMaxHorizontalDistance' has a wrong offset!");
static_assert(offsetof(UGzGA_SmashLanding, LandingCollisionSizeIncrease) == 0x0006B4, "Member 'UGzGA_SmashLanding::LandingCollisionSizeIncrease' has a wrong offset!");
static_assert(offsetof(UGzGA_SmashLanding, LandingCollisionSweepLength) == 0x0006B8, "Member 'UGzGA_SmashLanding::LandingCollisionSweepLength' has a wrong offset!");
static_assert(offsetof(UGzGA_SmashLanding, DashTargetClientOffsetTolerance) == 0x0006BC, "Member 'UGzGA_SmashLanding::DashTargetClientOffsetTolerance' has a wrong offset!");
static_assert(offsetof(UGzGA_SmashLanding, LandingCollisionChannels) == 0x0006C0, "Member 'UGzGA_SmashLanding::LandingCollisionChannels' has a wrong offset!");
static_assert(offsetof(UGzGA_SmashLanding, TargetingStartDelay) == 0x0006D0, "Member 'UGzGA_SmashLanding::TargetingStartDelay' has a wrong offset!");
static_assert(offsetof(UGzGA_SmashLanding, TargetingTimeSeconds) == 0x0006D4, "Member 'UGzGA_SmashLanding::TargetingTimeSeconds' has a wrong offset!");
static_assert(offsetof(UGzGA_SmashLanding, FallingTargetingTimeSeconds) == 0x0006D8, "Member 'UGzGA_SmashLanding::FallingTargetingTimeSeconds' has a wrong offset!");
static_assert(offsetof(UGzGA_SmashLanding, ActivationMinGroundDistance) == 0x0006DC, "Member 'UGzGA_SmashLanding::ActivationMinGroundDistance' has a wrong offset!");
static_assert(offsetof(UGzGA_SmashLanding, DashStartMinGroundDistance) == 0x0006E0, "Member 'UGzGA_SmashLanding::DashStartMinGroundDistance' has a wrong offset!");
static_assert(offsetof(UGzGA_SmashLanding, HoverParams) == 0x0006E4, "Member 'UGzGA_SmashLanding::HoverParams' has a wrong offset!");
static_assert(offsetof(UGzGA_SmashLanding, TargetingCameraModeTag) == 0x000700, "Member 'UGzGA_SmashLanding::TargetingCameraModeTag' has a wrong offset!");
static_assert(offsetof(UGzGA_SmashLanding, DashCameraModeTag) == 0x000708, "Member 'UGzGA_SmashLanding::DashCameraModeTag' has a wrong offset!");
static_assert(offsetof(UGzGA_SmashLanding, SmashCameraModeTag) == 0x000710, "Member 'UGzGA_SmashLanding::SmashCameraModeTag' has a wrong offset!");
static_assert(offsetof(UGzGA_SmashLanding, AttackInputAction) == 0x000718, "Member 'UGzGA_SmashLanding::AttackInputAction' has a wrong offset!");
static_assert(offsetof(UGzGA_SmashLanding, TargetingMaxAngle) == 0x000720, "Member 'UGzGA_SmashLanding::TargetingMaxAngle' has a wrong offset!");
static_assert(offsetof(UGzGA_SmashLanding, bRotateTargetPreviewToSurface) == 0x000724, "Member 'UGzGA_SmashLanding::bRotateTargetPreviewToSurface' has a wrong offset!");
static_assert(offsetof(UGzGA_SmashLanding, TargetPreviewClass) == 0x000728, "Member 'UGzGA_SmashLanding::TargetPreviewClass' has a wrong offset!");
static_assert(offsetof(UGzGA_SmashLanding, TargetPlacementTraceChannels) == 0x000750, "Member 'UGzGA_SmashLanding::TargetPlacementTraceChannels' has a wrong offset!");
static_assert(offsetof(UGzGA_SmashLanding, ConcussionEffectClass) == 0x000760, "Member 'UGzGA_SmashLanding::ConcussionEffectClass' has a wrong offset!");
static_assert(offsetof(UGzGA_SmashLanding, DamageTraceChannels) == 0x000768, "Member 'UGzGA_SmashLanding::DamageTraceChannels' has a wrong offset!");
static_assert(offsetof(UGzGA_SmashLanding, JumpStateTag) == 0x000778, "Member 'UGzGA_SmashLanding::JumpStateTag' has a wrong offset!");
static_assert(offsetof(UGzGA_SmashLanding, HoverStateTag) == 0x000780, "Member 'UGzGA_SmashLanding::HoverStateTag' has a wrong offset!");
static_assert(offsetof(UGzGA_SmashLanding, DashStateTag) == 0x000788, "Member 'UGzGA_SmashLanding::DashStateTag' has a wrong offset!");
static_assert(offsetof(UGzGA_SmashLanding, SmashStateTag) == 0x000790, "Member 'UGzGA_SmashLanding::SmashStateTag' has a wrong offset!");
static_assert(offsetof(UGzGA_SmashLanding, LandedStateTag) == 0x000798, "Member 'UGzGA_SmashLanding::LandedStateTag' has a wrong offset!");
static_assert(offsetof(UGzGA_SmashLanding, bTargetingActive) == 0x0007A0, "Member 'UGzGA_SmashLanding::bTargetingActive' has a wrong offset!");
static_assert(offsetof(UGzGA_SmashLanding, bDashStarted) == 0x0007A1, "Member 'UGzGA_SmashLanding::bDashStarted' has a wrong offset!");
static_assert(offsetof(UGzGA_SmashLanding, bHasLanded) == 0x0007A2, "Member 'UGzGA_SmashLanding::bHasLanded' has a wrong offset!");
static_assert(offsetof(UGzGA_SmashLanding, bDependenciesLoaded) == 0x0007A3, "Member 'UGzGA_SmashLanding::bDependenciesLoaded' has a wrong offset!");
static_assert(offsetof(UGzGA_SmashLanding, bIsTargetOutOfRange) == 0x0007A4, "Member 'UGzGA_SmashLanding::bIsTargetOutOfRange' has a wrong offset!");
static_assert(offsetof(UGzGA_SmashLanding, DashTarget) == 0x000828, "Member 'UGzGA_SmashLanding::DashTarget' has a wrong offset!");
static_assert(offsetof(UGzGA_SmashLanding, DashingDirection) == 0x000920, "Member 'UGzGA_SmashLanding::DashingDirection' has a wrong offset!");
static_assert(offsetof(UGzGA_SmashLanding, TargetPreviewActor) == 0x000938, "Member 'UGzGA_SmashLanding::TargetPreviewActor' has a wrong offset!");
static_assert(offsetof(UGzGA_SmashLanding, TargetingTickTask) == 0x000940, "Member 'UGzGA_SmashLanding::TargetingTickTask' has a wrong offset!");
static_assert(offsetof(UGzGA_SmashLanding, ServerWaitForTargetData) == 0x000948, "Member 'UGzGA_SmashLanding::ServerWaitForTargetData' has a wrong offset!");
static_assert(offsetof(UGzGA_SmashLanding, TargetingStartDelayHandle) == 0x000950, "Member 'UGzGA_SmashLanding::TargetingStartDelayHandle' has a wrong offset!");
static_assert(offsetof(UGzGA_SmashLanding, EndAbilityDelayHandle) == 0x000958, "Member 'UGzGA_SmashLanding::EndAbilityDelayHandle' has a wrong offset!");
static_assert(offsetof(UGzGA_SmashLanding, FallingDeactivationTimerHandle) == 0x000960, "Member 'UGzGA_SmashLanding::FallingDeactivationTimerHandle' has a wrong offset!");

// Class G01.GzMission
// 0x0038 (0x0310 - 0x02D8)
class AGzMission : public AMission
{
public:
	FMulticastInlineDelegateProperty_             OnMissionStateChanged;                             // 0x02D8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	class UGzMissionData*                         MissionData;                                       // 0x02E8(0x0008)(Net, ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class AActor*                                 MissionOwner;                                      // 0x02F0(0x0008)(Net, ZeroConstructor, Transient, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class AGzPlayerState*                         MissionInstigator;                                 // 0x02F8(0x0008)(Net, ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         RuntimeId;                                         // 0x0300(0x0004)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FGzMissionState                        MissionState;                                      // 0x0304(0x000C)(Net, Transient, RepNotify, NoDestructor, NativeAccessSpecifierPrivate)

public:
	void DispatchUIMessage(const struct FGameplayTag& Tag, const class FText& Text, float Duration);
	void HandleMissionReadyToStart();
	void HandleParticipantConnectionChanged(class AGzPlayerState* PlayerState);
	void OnRep_MissionOwner();
	void OnRep_MissionState(const struct FGzMissionState& OldState);

	class UGzMissionData* GetMissionData() const;
	class AGzPlayerState* GetMissionInstigator() const;
	const class FText GetMissionName() const;
	struct FGzMissionState GetMissionState() const;
	int32 GetRuntimeId() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzMission">();
	}
	static class AGzMission* GetDefaultObj()
	{
		return GetDefaultObjImpl<AGzMission>();
	}
};
static_assert(alignof(AGzMission) == 0x000008, "Wrong alignment on AGzMission");
static_assert(sizeof(AGzMission) == 0x000310, "Wrong size on AGzMission");
static_assert(offsetof(AGzMission, OnMissionStateChanged) == 0x0002D8, "Member 'AGzMission::OnMissionStateChanged' has a wrong offset!");
static_assert(offsetof(AGzMission, MissionData) == 0x0002E8, "Member 'AGzMission::MissionData' has a wrong offset!");
static_assert(offsetof(AGzMission, MissionOwner) == 0x0002F0, "Member 'AGzMission::MissionOwner' has a wrong offset!");
static_assert(offsetof(AGzMission, MissionInstigator) == 0x0002F8, "Member 'AGzMission::MissionInstigator' has a wrong offset!");
static_assert(offsetof(AGzMission, RuntimeId) == 0x000300, "Member 'AGzMission::RuntimeId' has a wrong offset!");
static_assert(offsetof(AGzMission, MissionState) == 0x000304, "Member 'AGzMission::MissionState' has a wrong offset!");

// Class G01.GzCombinedCharacterDataFetcher
// 0x0030 (0x00D0 - 0x00A0)
class UGzCombinedCharacterDataFetcher final : public UGzServiceComponent
{
public:
	uint8                                         Pad_2C9E[0x30];                                    // 0x00A0(0x0030)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzCombinedCharacterDataFetcher">();
	}
	static class UGzCombinedCharacterDataFetcher* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzCombinedCharacterDataFetcher>();
	}
};
static_assert(alignof(UGzCombinedCharacterDataFetcher) == 0x000008, "Wrong alignment on UGzCombinedCharacterDataFetcher");
static_assert(sizeof(UGzCombinedCharacterDataFetcher) == 0x0000D0, "Wrong size on UGzCombinedCharacterDataFetcher");

// Class G01.GzLayerCharacterAnimInstance
// 0x0540 (0x08B0 - 0x0370)
class UGzLayerCharacterAnimInstance : public UAnimInstance
{
public:
	struct FGameplayTagBlueprintPropertyMap       GameplayTagPropertyMap;                            // 0x0368(0x0020)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	float                                         GroundDistance;                                    // 0x0388(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2C9F[0x4];                                     // 0x038C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UAnimInstance*                          DefaultAnimInstance;                               // 0x0390(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, EditConst, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UAnimSequence*                          Idle_IsAiming_Sequence;                            // 0x0398(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UAnimSequence*                          Crouch_IsAiming_Sequence;                          // 0x03A0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UAnimSequence*                          Crouch_Idle_Sequence;                              // 0x03A8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<class UAnimSequence*>                  Idle_Breaks_Sequence;                              // 0x03B0(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPrivate)
	class UAnimSequence*                          Crouch_Idle_Exit_Sequence;                         // 0x03C0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UAnimSequence*                          Crouch_Idle_Entry_Sequence;                        // 0x03C8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UAnimSequence*                          LeftHandPose_Override_Sequence;                    // 0x03D0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UAnimSequence*                          Idle_HipFire_Sequence;                             // 0x03D8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UAnimSequence*                          Crouch_HipFire_Sequence;                           // 0x03E0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UAnimSequence*                          Idle_Relaxing_Sequence;                            // 0x03E8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UAnimSequence*                          Crouch_Relaxing_Sequence;                          // 0x03F0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UAnimSequence*                          Idle_Prone_Sequence;                               // 0x03F8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FGzCardinalDirection                   Jog_Start_Cardinals_Sequence;                      // 0x0400(0x0020)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPrivate)
	struct FGzCardinalDirection                   IsAiming_Start_Cardinals_Sequence;                 // 0x0420(0x0020)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPrivate)
	struct FGzCardinalDirection                   Crouch_Start_Cardinals_Sequence;                   // 0x0440(0x0020)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPrivate)
	struct FGzCardinalDirection                   Crouch_IsAiming_Start_Cardinals_Sequence;          // 0x0460(0x0020)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPrivate)
	struct FGzCardinalDirection                   Crouch_Hipfire_Start_Cardinals_Sequence;           // 0x0480(0x0020)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPrivate)
	struct FGzCardinalDirection                   Sprint_Start_Cardinals_Sequence;                   // 0x04A0(0x0020)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPrivate)
	struct FGzCardinalDirection                   Hipfire_Start_Cardinals_Sequence;                  // 0x04C0(0x0020)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPrivate)
	struct FGzCardinalDirection                   Jog_Cardinals_Sequence;                            // 0x04E0(0x0020)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPrivate)
	struct FGzCardinalDirection                   Hipfire_Cardinals_Sequence;                        // 0x0500(0x0020)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPrivate)
	struct FGzCardinalDirection                   Jog_Pivot_Cardinals_Sequence;                      // 0x0520(0x0020)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPrivate)
	struct FGzCardinalDirection                   IsAiming_Pivot_Cardinals_Sequence;                 // 0x0540(0x0020)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPrivate)
	struct FGzCardinalDirection                   Crouch_Pivot_Cardinals_Sequence;                   // 0x0560(0x0020)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPrivate)
	struct FGzCardinalDirection                   Crouch_IsAiming_Pivot_Cardinals_Sequence;          // 0x0580(0x0020)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPrivate)
	struct FGzCardinalDirection                   Crouch_Hipfire_Pivot_Cardinals_Sequence;           // 0x05A0(0x0020)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPrivate)
	struct FGzCardinalDirection                   Sprint_Pivot_Cardinals_Sequence;                   // 0x05C0(0x0020)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPrivate)
	struct FGzCardinalDirection                   Hipfire_Pivot_Cardinals_Sequence;                  // 0x05E0(0x0020)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPrivate)
	struct FGzCardinalDirection                   Jog_Stop_Cardinals_Sequence;                       // 0x0600(0x0020)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPrivate)
	struct FGzCardinalDirection                   IsAiming_Stop_Cardinals_Sequence;                  // 0x0620(0x0020)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPrivate)
	struct FGzCardinalDirection                   Crouch_Stop_Cardinals_Sequence;                    // 0x0640(0x0020)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPrivate)
	struct FGzCardinalDirection                   Crouch_Hipfire_Stop_Cardinals_Sequence;            // 0x0660(0x0020)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPrivate)
	struct FGzCardinalDirection                   Crouch_IsAiming_Stop_Cardinals_Sequence;           // 0x0680(0x0020)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPrivate)
	struct FGzCardinalDirection                   Sprint_Stop_Cardinals_Sequence;                    // 0x06A0(0x0020)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPrivate)
	struct FGzCardinalDirection                   Hipfire_Stop_Cardinals_Sequence;                   // 0x06C0(0x0020)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPrivate)
	struct FGzCardinalDirection                   Walk_Cardinals_Sequence;                           // 0x06E0(0x0020)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPrivate)
	struct FGzCardinalDirection                   Crouch_Walk_Cardinals_Sequence;                    // 0x0700(0x0020)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPrivate)
	struct FGzCardinalDirection                   Crouch_Hipfire_Cardinals_Sequence;                 // 0x0720(0x0020)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPrivate)
	struct FGzCardinalDirection                   Crouch_Jog_Cardinals_Sequence;                     // 0x0740(0x0020)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPrivate)
	struct FGzCardinalDirection                   Crawl_Cardinals_Sequence;                          // 0x0760(0x0020)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPrivate)
	struct FGzCardinalDirection                   Crawl_Knockdown_Cardinals_Sequence;                // 0x0780(0x0020)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPrivate)
	class UAnimSequence*                          Aim_HipFirePose_Sequence;                          // 0x07A0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UAnimSequence*                          Aim_HipFirePose_Crouch_Sequence;                   // 0x07A8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UAimOffsetBlendSpace*                   Relaxed_AimOffset;                                 // 0x07B0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UAimOffsetBlendSpace*                   IdleAim_Offset;                                    // 0x07B8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UAimOffsetBlendSpace*                   Hipfire_AimOffset;                                 // 0x07C0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UAnimSequence*                          TurnInPlace_Left_Sequence;                         // 0x07C8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UAnimSequence*                          Crouch_TurnInPlace_Left_Sequence;                  // 0x07D0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UAnimSequence*                          Prone_TurnInPlace_Left_Sequence;                   // 0x07D8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UAnimSequence*                          TurnInPlace_Right_Sequence;                        // 0x07E0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UAnimSequence*                          Crouch_TurnInPlace_Right_Sequence;                 // 0x07E8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UAnimSequence*                          Prone_TurnInPlace_Right_Sequence;                  // 0x07F0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UAnimSequence*                          IsAiming_TurnInPlace_Left_Sequence;                // 0x07F8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UAnimSequence*                          Crouch_IsAiming_TurnInPlace_Left_Sequence;         // 0x0800(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UAnimSequence*                          Hipfire_TurnInPlace_Left_Sequence;                 // 0x0808(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UAnimSequence*                          Crouch_Hipfire_TurnInPlace_Left_Sequence;          // 0x0810(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UAnimSequence*                          IsAiming_TurnInPlace_Right_Sequence;               // 0x0818(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UAnimSequence*                          Crouch_IsAiming_TurnInPlace_Right_Sequence;        // 0x0820(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UAnimSequence*                          Hipfire_TurnInPlace_Right_Sequence;                // 0x0828(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UAnimSequence*                          Crouch_Hipfire_TurnInPlace_Right_Sequence;         // 0x0830(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FGzCardinalDirection                   Sprint_Cardinals_Sequence;                         // 0x0838(0x0020)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPrivate)
	class FName                                   JumpDistanceCurve_Name;                            // 0x0858(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UAnimSequence*                          Jump_Start_Sequence;                               // 0x0860(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UAnimSequence*                          Jump_Apex_Sequence;                                // 0x0868(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UAnimSequence*                          Jump_FallLand_Sequence;                            // 0x0870(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UAnimSequence*                          Jump_RecoveryAdditive_Sequence;                    // 0x0878(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UAnimSequence*                          Jump_StartLoop_Sequence;                           // 0x0880(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UAnimSequence*                          Jump_FallLoop_Sequence;                            // 0x0888(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UAnimSequence*                          Limbless_Enter_Sequence;                           // 0x0890(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UAnimSequence*                          Limbless_Exit_Sequence;                            // 0x0898(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	EGzLayerItemType                              LayerType;                                         // 0x08A0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2CA0[0xF];                                     // 0x08A1(0x000F)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	struct FSequenceEvaluatorReference AdvanceTimeByDistanceMatching(const struct FAnimUpdateContext& UpdateContext, const struct FSequenceEvaluatorReference& SequenceEvaluator, float DistanceTraveled, class FName DistanceCurveName, const struct FVector2D& PlayRateClamp);
	struct FSequenceEvaluatorReference DistanceMatchToTarget(const struct FSequenceEvaluatorReference& SequenceEvaluator, float DistanceToTarget, class FName DistanceCurveName);
	void SetDefaultAnimInstance(class UAnimInstance* NewAnimInstance);
	struct FSequencePlayerReference SetPlayrateToMatchSpeed(const struct FSequencePlayerReference& SequencePlayer, float SpeedToMatch, const struct FVector2D& PlayRateClamp);

	class UAnimInstance* GetDefaultAnimInstance() const;
	EGzLayerItemType GetLayerType() const;
	struct FVector PredictGroundMovementPivotLocation(const struct FVector& Acceleration, const struct FVector& Velocity, float GroundFriction) const;
	struct FVector PredictGroundMovementStopLocation(const struct FVector& Velocity, bool bUseSeparateBrakingFriction, float BrakingFriction, float GroundFriction, float BrakingFrictionFactor, float BrakingDecelerationWalking) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzLayerCharacterAnimInstance">();
	}
	static class UGzLayerCharacterAnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzLayerCharacterAnimInstance>();
	}
};
static_assert(alignof(UGzLayerCharacterAnimInstance) == 0x000010, "Wrong alignment on UGzLayerCharacterAnimInstance");
static_assert(sizeof(UGzLayerCharacterAnimInstance) == 0x0008B0, "Wrong size on UGzLayerCharacterAnimInstance");
static_assert(offsetof(UGzLayerCharacterAnimInstance, GameplayTagPropertyMap) == 0x000368, "Member 'UGzLayerCharacterAnimInstance::GameplayTagPropertyMap' has a wrong offset!");
static_assert(offsetof(UGzLayerCharacterAnimInstance, GroundDistance) == 0x000388, "Member 'UGzLayerCharacterAnimInstance::GroundDistance' has a wrong offset!");
static_assert(offsetof(UGzLayerCharacterAnimInstance, DefaultAnimInstance) == 0x000390, "Member 'UGzLayerCharacterAnimInstance::DefaultAnimInstance' has a wrong offset!");
static_assert(offsetof(UGzLayerCharacterAnimInstance, Idle_IsAiming_Sequence) == 0x000398, "Member 'UGzLayerCharacterAnimInstance::Idle_IsAiming_Sequence' has a wrong offset!");
static_assert(offsetof(UGzLayerCharacterAnimInstance, Crouch_IsAiming_Sequence) == 0x0003A0, "Member 'UGzLayerCharacterAnimInstance::Crouch_IsAiming_Sequence' has a wrong offset!");
static_assert(offsetof(UGzLayerCharacterAnimInstance, Crouch_Idle_Sequence) == 0x0003A8, "Member 'UGzLayerCharacterAnimInstance::Crouch_Idle_Sequence' has a wrong offset!");
static_assert(offsetof(UGzLayerCharacterAnimInstance, Idle_Breaks_Sequence) == 0x0003B0, "Member 'UGzLayerCharacterAnimInstance::Idle_Breaks_Sequence' has a wrong offset!");
static_assert(offsetof(UGzLayerCharacterAnimInstance, Crouch_Idle_Exit_Sequence) == 0x0003C0, "Member 'UGzLayerCharacterAnimInstance::Crouch_Idle_Exit_Sequence' has a wrong offset!");
static_assert(offsetof(UGzLayerCharacterAnimInstance, Crouch_Idle_Entry_Sequence) == 0x0003C8, "Member 'UGzLayerCharacterAnimInstance::Crouch_Idle_Entry_Sequence' has a wrong offset!");
static_assert(offsetof(UGzLayerCharacterAnimInstance, LeftHandPose_Override_Sequence) == 0x0003D0, "Member 'UGzLayerCharacterAnimInstance::LeftHandPose_Override_Sequence' has a wrong offset!");
static_assert(offsetof(UGzLayerCharacterAnimInstance, Idle_HipFire_Sequence) == 0x0003D8, "Member 'UGzLayerCharacterAnimInstance::Idle_HipFire_Sequence' has a wrong offset!");
static_assert(offsetof(UGzLayerCharacterAnimInstance, Crouch_HipFire_Sequence) == 0x0003E0, "Member 'UGzLayerCharacterAnimInstance::Crouch_HipFire_Sequence' has a wrong offset!");
static_assert(offsetof(UGzLayerCharacterAnimInstance, Idle_Relaxing_Sequence) == 0x0003E8, "Member 'UGzLayerCharacterAnimInstance::Idle_Relaxing_Sequence' has a wrong offset!");
static_assert(offsetof(UGzLayerCharacterAnimInstance, Crouch_Relaxing_Sequence) == 0x0003F0, "Member 'UGzLayerCharacterAnimInstance::Crouch_Relaxing_Sequence' has a wrong offset!");
static_assert(offsetof(UGzLayerCharacterAnimInstance, Idle_Prone_Sequence) == 0x0003F8, "Member 'UGzLayerCharacterAnimInstance::Idle_Prone_Sequence' has a wrong offset!");
static_assert(offsetof(UGzLayerCharacterAnimInstance, Jog_Start_Cardinals_Sequence) == 0x000400, "Member 'UGzLayerCharacterAnimInstance::Jog_Start_Cardinals_Sequence' has a wrong offset!");
static_assert(offsetof(UGzLayerCharacterAnimInstance, IsAiming_Start_Cardinals_Sequence) == 0x000420, "Member 'UGzLayerCharacterAnimInstance::IsAiming_Start_Cardinals_Sequence' has a wrong offset!");
static_assert(offsetof(UGzLayerCharacterAnimInstance, Crouch_Start_Cardinals_Sequence) == 0x000440, "Member 'UGzLayerCharacterAnimInstance::Crouch_Start_Cardinals_Sequence' has a wrong offset!");
static_assert(offsetof(UGzLayerCharacterAnimInstance, Crouch_IsAiming_Start_Cardinals_Sequence) == 0x000460, "Member 'UGzLayerCharacterAnimInstance::Crouch_IsAiming_Start_Cardinals_Sequence' has a wrong offset!");
static_assert(offsetof(UGzLayerCharacterAnimInstance, Crouch_Hipfire_Start_Cardinals_Sequence) == 0x000480, "Member 'UGzLayerCharacterAnimInstance::Crouch_Hipfire_Start_Cardinals_Sequence' has a wrong offset!");
static_assert(offsetof(UGzLayerCharacterAnimInstance, Sprint_Start_Cardinals_Sequence) == 0x0004A0, "Member 'UGzLayerCharacterAnimInstance::Sprint_Start_Cardinals_Sequence' has a wrong offset!");
static_assert(offsetof(UGzLayerCharacterAnimInstance, Hipfire_Start_Cardinals_Sequence) == 0x0004C0, "Member 'UGzLayerCharacterAnimInstance::Hipfire_Start_Cardinals_Sequence' has a wrong offset!");
static_assert(offsetof(UGzLayerCharacterAnimInstance, Jog_Cardinals_Sequence) == 0x0004E0, "Member 'UGzLayerCharacterAnimInstance::Jog_Cardinals_Sequence' has a wrong offset!");
static_assert(offsetof(UGzLayerCharacterAnimInstance, Hipfire_Cardinals_Sequence) == 0x000500, "Member 'UGzLayerCharacterAnimInstance::Hipfire_Cardinals_Sequence' has a wrong offset!");
static_assert(offsetof(UGzLayerCharacterAnimInstance, Jog_Pivot_Cardinals_Sequence) == 0x000520, "Member 'UGzLayerCharacterAnimInstance::Jog_Pivot_Cardinals_Sequence' has a wrong offset!");
static_assert(offsetof(UGzLayerCharacterAnimInstance, IsAiming_Pivot_Cardinals_Sequence) == 0x000540, "Member 'UGzLayerCharacterAnimInstance::IsAiming_Pivot_Cardinals_Sequence' has a wrong offset!");
static_assert(offsetof(UGzLayerCharacterAnimInstance, Crouch_Pivot_Cardinals_Sequence) == 0x000560, "Member 'UGzLayerCharacterAnimInstance::Crouch_Pivot_Cardinals_Sequence' has a wrong offset!");
static_assert(offsetof(UGzLayerCharacterAnimInstance, Crouch_IsAiming_Pivot_Cardinals_Sequence) == 0x000580, "Member 'UGzLayerCharacterAnimInstance::Crouch_IsAiming_Pivot_Cardinals_Sequence' has a wrong offset!");
static_assert(offsetof(UGzLayerCharacterAnimInstance, Crouch_Hipfire_Pivot_Cardinals_Sequence) == 0x0005A0, "Member 'UGzLayerCharacterAnimInstance::Crouch_Hipfire_Pivot_Cardinals_Sequence' has a wrong offset!");
static_assert(offsetof(UGzLayerCharacterAnimInstance, Sprint_Pivot_Cardinals_Sequence) == 0x0005C0, "Member 'UGzLayerCharacterAnimInstance::Sprint_Pivot_Cardinals_Sequence' has a wrong offset!");
static_assert(offsetof(UGzLayerCharacterAnimInstance, Hipfire_Pivot_Cardinals_Sequence) == 0x0005E0, "Member 'UGzLayerCharacterAnimInstance::Hipfire_Pivot_Cardinals_Sequence' has a wrong offset!");
static_assert(offsetof(UGzLayerCharacterAnimInstance, Jog_Stop_Cardinals_Sequence) == 0x000600, "Member 'UGzLayerCharacterAnimInstance::Jog_Stop_Cardinals_Sequence' has a wrong offset!");
static_assert(offsetof(UGzLayerCharacterAnimInstance, IsAiming_Stop_Cardinals_Sequence) == 0x000620, "Member 'UGzLayerCharacterAnimInstance::IsAiming_Stop_Cardinals_Sequence' has a wrong offset!");
static_assert(offsetof(UGzLayerCharacterAnimInstance, Crouch_Stop_Cardinals_Sequence) == 0x000640, "Member 'UGzLayerCharacterAnimInstance::Crouch_Stop_Cardinals_Sequence' has a wrong offset!");
static_assert(offsetof(UGzLayerCharacterAnimInstance, Crouch_Hipfire_Stop_Cardinals_Sequence) == 0x000660, "Member 'UGzLayerCharacterAnimInstance::Crouch_Hipfire_Stop_Cardinals_Sequence' has a wrong offset!");
static_assert(offsetof(UGzLayerCharacterAnimInstance, Crouch_IsAiming_Stop_Cardinals_Sequence) == 0x000680, "Member 'UGzLayerCharacterAnimInstance::Crouch_IsAiming_Stop_Cardinals_Sequence' has a wrong offset!");
static_assert(offsetof(UGzLayerCharacterAnimInstance, Sprint_Stop_Cardinals_Sequence) == 0x0006A0, "Member 'UGzLayerCharacterAnimInstance::Sprint_Stop_Cardinals_Sequence' has a wrong offset!");
static_assert(offsetof(UGzLayerCharacterAnimInstance, Hipfire_Stop_Cardinals_Sequence) == 0x0006C0, "Member 'UGzLayerCharacterAnimInstance::Hipfire_Stop_Cardinals_Sequence' has a wrong offset!");
static_assert(offsetof(UGzLayerCharacterAnimInstance, Walk_Cardinals_Sequence) == 0x0006E0, "Member 'UGzLayerCharacterAnimInstance::Walk_Cardinals_Sequence' has a wrong offset!");
static_assert(offsetof(UGzLayerCharacterAnimInstance, Crouch_Walk_Cardinals_Sequence) == 0x000700, "Member 'UGzLayerCharacterAnimInstance::Crouch_Walk_Cardinals_Sequence' has a wrong offset!");
static_assert(offsetof(UGzLayerCharacterAnimInstance, Crouch_Hipfire_Cardinals_Sequence) == 0x000720, "Member 'UGzLayerCharacterAnimInstance::Crouch_Hipfire_Cardinals_Sequence' has a wrong offset!");
static_assert(offsetof(UGzLayerCharacterAnimInstance, Crouch_Jog_Cardinals_Sequence) == 0x000740, "Member 'UGzLayerCharacterAnimInstance::Crouch_Jog_Cardinals_Sequence' has a wrong offset!");
static_assert(offsetof(UGzLayerCharacterAnimInstance, Crawl_Cardinals_Sequence) == 0x000760, "Member 'UGzLayerCharacterAnimInstance::Crawl_Cardinals_Sequence' has a wrong offset!");
static_assert(offsetof(UGzLayerCharacterAnimInstance, Crawl_Knockdown_Cardinals_Sequence) == 0x000780, "Member 'UGzLayerCharacterAnimInstance::Crawl_Knockdown_Cardinals_Sequence' has a wrong offset!");
static_assert(offsetof(UGzLayerCharacterAnimInstance, Aim_HipFirePose_Sequence) == 0x0007A0, "Member 'UGzLayerCharacterAnimInstance::Aim_HipFirePose_Sequence' has a wrong offset!");
static_assert(offsetof(UGzLayerCharacterAnimInstance, Aim_HipFirePose_Crouch_Sequence) == 0x0007A8, "Member 'UGzLayerCharacterAnimInstance::Aim_HipFirePose_Crouch_Sequence' has a wrong offset!");
static_assert(offsetof(UGzLayerCharacterAnimInstance, Relaxed_AimOffset) == 0x0007B0, "Member 'UGzLayerCharacterAnimInstance::Relaxed_AimOffset' has a wrong offset!");
static_assert(offsetof(UGzLayerCharacterAnimInstance, IdleAim_Offset) == 0x0007B8, "Member 'UGzLayerCharacterAnimInstance::IdleAim_Offset' has a wrong offset!");
static_assert(offsetof(UGzLayerCharacterAnimInstance, Hipfire_AimOffset) == 0x0007C0, "Member 'UGzLayerCharacterAnimInstance::Hipfire_AimOffset' has a wrong offset!");
static_assert(offsetof(UGzLayerCharacterAnimInstance, TurnInPlace_Left_Sequence) == 0x0007C8, "Member 'UGzLayerCharacterAnimInstance::TurnInPlace_Left_Sequence' has a wrong offset!");
static_assert(offsetof(UGzLayerCharacterAnimInstance, Crouch_TurnInPlace_Left_Sequence) == 0x0007D0, "Member 'UGzLayerCharacterAnimInstance::Crouch_TurnInPlace_Left_Sequence' has a wrong offset!");
static_assert(offsetof(UGzLayerCharacterAnimInstance, Prone_TurnInPlace_Left_Sequence) == 0x0007D8, "Member 'UGzLayerCharacterAnimInstance::Prone_TurnInPlace_Left_Sequence' has a wrong offset!");
static_assert(offsetof(UGzLayerCharacterAnimInstance, TurnInPlace_Right_Sequence) == 0x0007E0, "Member 'UGzLayerCharacterAnimInstance::TurnInPlace_Right_Sequence' has a wrong offset!");
static_assert(offsetof(UGzLayerCharacterAnimInstance, Crouch_TurnInPlace_Right_Sequence) == 0x0007E8, "Member 'UGzLayerCharacterAnimInstance::Crouch_TurnInPlace_Right_Sequence' has a wrong offset!");
static_assert(offsetof(UGzLayerCharacterAnimInstance, Prone_TurnInPlace_Right_Sequence) == 0x0007F0, "Member 'UGzLayerCharacterAnimInstance::Prone_TurnInPlace_Right_Sequence' has a wrong offset!");
static_assert(offsetof(UGzLayerCharacterAnimInstance, IsAiming_TurnInPlace_Left_Sequence) == 0x0007F8, "Member 'UGzLayerCharacterAnimInstance::IsAiming_TurnInPlace_Left_Sequence' has a wrong offset!");
static_assert(offsetof(UGzLayerCharacterAnimInstance, Crouch_IsAiming_TurnInPlace_Left_Sequence) == 0x000800, "Member 'UGzLayerCharacterAnimInstance::Crouch_IsAiming_TurnInPlace_Left_Sequence' has a wrong offset!");
static_assert(offsetof(UGzLayerCharacterAnimInstance, Hipfire_TurnInPlace_Left_Sequence) == 0x000808, "Member 'UGzLayerCharacterAnimInstance::Hipfire_TurnInPlace_Left_Sequence' has a wrong offset!");
static_assert(offsetof(UGzLayerCharacterAnimInstance, Crouch_Hipfire_TurnInPlace_Left_Sequence) == 0x000810, "Member 'UGzLayerCharacterAnimInstance::Crouch_Hipfire_TurnInPlace_Left_Sequence' has a wrong offset!");
static_assert(offsetof(UGzLayerCharacterAnimInstance, IsAiming_TurnInPlace_Right_Sequence) == 0x000818, "Member 'UGzLayerCharacterAnimInstance::IsAiming_TurnInPlace_Right_Sequence' has a wrong offset!");
static_assert(offsetof(UGzLayerCharacterAnimInstance, Crouch_IsAiming_TurnInPlace_Right_Sequence) == 0x000820, "Member 'UGzLayerCharacterAnimInstance::Crouch_IsAiming_TurnInPlace_Right_Sequence' has a wrong offset!");
static_assert(offsetof(UGzLayerCharacterAnimInstance, Hipfire_TurnInPlace_Right_Sequence) == 0x000828, "Member 'UGzLayerCharacterAnimInstance::Hipfire_TurnInPlace_Right_Sequence' has a wrong offset!");
static_assert(offsetof(UGzLayerCharacterAnimInstance, Crouch_Hipfire_TurnInPlace_Right_Sequence) == 0x000830, "Member 'UGzLayerCharacterAnimInstance::Crouch_Hipfire_TurnInPlace_Right_Sequence' has a wrong offset!");
static_assert(offsetof(UGzLayerCharacterAnimInstance, Sprint_Cardinals_Sequence) == 0x000838, "Member 'UGzLayerCharacterAnimInstance::Sprint_Cardinals_Sequence' has a wrong offset!");
static_assert(offsetof(UGzLayerCharacterAnimInstance, JumpDistanceCurve_Name) == 0x000858, "Member 'UGzLayerCharacterAnimInstance::JumpDistanceCurve_Name' has a wrong offset!");
static_assert(offsetof(UGzLayerCharacterAnimInstance, Jump_Start_Sequence) == 0x000860, "Member 'UGzLayerCharacterAnimInstance::Jump_Start_Sequence' has a wrong offset!");
static_assert(offsetof(UGzLayerCharacterAnimInstance, Jump_Apex_Sequence) == 0x000868, "Member 'UGzLayerCharacterAnimInstance::Jump_Apex_Sequence' has a wrong offset!");
static_assert(offsetof(UGzLayerCharacterAnimInstance, Jump_FallLand_Sequence) == 0x000870, "Member 'UGzLayerCharacterAnimInstance::Jump_FallLand_Sequence' has a wrong offset!");
static_assert(offsetof(UGzLayerCharacterAnimInstance, Jump_RecoveryAdditive_Sequence) == 0x000878, "Member 'UGzLayerCharacterAnimInstance::Jump_RecoveryAdditive_Sequence' has a wrong offset!");
static_assert(offsetof(UGzLayerCharacterAnimInstance, Jump_StartLoop_Sequence) == 0x000880, "Member 'UGzLayerCharacterAnimInstance::Jump_StartLoop_Sequence' has a wrong offset!");
static_assert(offsetof(UGzLayerCharacterAnimInstance, Jump_FallLoop_Sequence) == 0x000888, "Member 'UGzLayerCharacterAnimInstance::Jump_FallLoop_Sequence' has a wrong offset!");
static_assert(offsetof(UGzLayerCharacterAnimInstance, Limbless_Enter_Sequence) == 0x000890, "Member 'UGzLayerCharacterAnimInstance::Limbless_Enter_Sequence' has a wrong offset!");
static_assert(offsetof(UGzLayerCharacterAnimInstance, Limbless_Exit_Sequence) == 0x000898, "Member 'UGzLayerCharacterAnimInstance::Limbless_Exit_Sequence' has a wrong offset!");
static_assert(offsetof(UGzLayerCharacterAnimInstance, LayerType) == 0x0008A0, "Member 'UGzLayerCharacterAnimInstance::LayerType' has a wrong offset!");

// Class G01.GzGameMessage
// 0x0000 (0x0028 - 0x0028)
class UGzGameMessage : public UObject
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzGameMessage">();
	}
	static class UGzGameMessage* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzGameMessage>();
	}
};
static_assert(alignof(UGzGameMessage) == 0x000008, "Wrong alignment on UGzGameMessage");
static_assert(sizeof(UGzGameMessage) == 0x000028, "Wrong size on UGzGameMessage");

// Class G01.GzInstigatedMessage
// 0x0008 (0x0030 - 0x0028)
class UGzInstigatedMessage : public UGzGameMessage
{
public:
	struct FGzAdvancedIdType                      InstigatorId;                                      // 0x0028(0x0008)(BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzInstigatedMessage">();
	}
	static class UGzInstigatedMessage* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzInstigatedMessage>();
	}
};
static_assert(alignof(UGzInstigatedMessage) == 0x000008, "Wrong alignment on UGzInstigatedMessage");
static_assert(sizeof(UGzInstigatedMessage) == 0x000030, "Wrong size on UGzInstigatedMessage");
static_assert(offsetof(UGzInstigatedMessage, InstigatorId) == 0x000028, "Member 'UGzInstigatedMessage::InstigatorId' has a wrong offset!");

// Class G01.GzLimbActivationMessage
// 0x0000 (0x0030 - 0x0030)
class UGzLimbActivationMessage final : public UGzInstigatedMessage
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzLimbActivationMessage">();
	}
	static class UGzLimbActivationMessage* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzLimbActivationMessage>();
	}
};
static_assert(alignof(UGzLimbActivationMessage) == 0x000008, "Wrong alignment on UGzLimbActivationMessage");
static_assert(sizeof(UGzLimbActivationMessage) == 0x000030, "Wrong size on UGzLimbActivationMessage");

// Class G01.GzAbilityAnimInstance
// 0x0000 (0x08B0 - 0x08B0)
class UGzAbilityAnimInstance : public UGzLayerCharacterAnimInstance
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzAbilityAnimInstance">();
	}
	static class UGzAbilityAnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzAbilityAnimInstance>();
	}
};
static_assert(alignof(UGzAbilityAnimInstance) == 0x000010, "Wrong alignment on UGzAbilityAnimInstance");
static_assert(sizeof(UGzAbilityAnimInstance) == 0x0008B0, "Wrong size on UGzAbilityAnimInstance");

// Class G01.GzCheatManagerExtension
// 0x0000 (0x0028 - 0x0028)
class UGzCheatManagerExtension : public UCheatManagerExtension
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzCheatManagerExtension">();
	}
	static class UGzCheatManagerExtension* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzCheatManagerExtension>();
	}
};
static_assert(alignof(UGzCheatManagerExtension) == 0x000008, "Wrong alignment on UGzCheatManagerExtension");
static_assert(sizeof(UGzCheatManagerExtension) == 0x000028, "Wrong size on UGzCheatManagerExtension");

// Class G01.GzCharacterCustomizationCheatExtension
// 0x0018 (0x0040 - 0x0028)
class UGzCharacterCustomizationCheatExtension final : public UGzCheatManagerExtension
{
public:
	uint8                                         Pad_2CA7[0x8];                                     // 0x0028(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UGzCustomizationProfileData*>    CachedProfiles;                                    // 0x0030(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)

public:
	void SetNextCustomizationPreset();
	void SetPrevCustomizationPreset();

	void SetJetpackVisibility(bool bNewVisibility) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzCharacterCustomizationCheatExtension">();
	}
	static class UGzCharacterCustomizationCheatExtension* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzCharacterCustomizationCheatExtension>();
	}
};
static_assert(alignof(UGzCharacterCustomizationCheatExtension) == 0x000008, "Wrong alignment on UGzCharacterCustomizationCheatExtension");
static_assert(sizeof(UGzCharacterCustomizationCheatExtension) == 0x000040, "Wrong size on UGzCharacterCustomizationCheatExtension");
static_assert(offsetof(UGzCharacterCustomizationCheatExtension, CachedProfiles) == 0x000030, "Member 'UGzCharacterCustomizationCheatExtension::CachedProfiles' has a wrong offset!");

// Class G01.GzAbilityCacheAsset
// 0x0000 (0x0030 - 0x0030)
class UGzAbilityCacheAsset final : public UPrimaryDataAsset
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzAbilityCacheAsset">();
	}
	static class UGzAbilityCacheAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzAbilityCacheAsset>();
	}
};
static_assert(alignof(UGzAbilityCacheAsset) == 0x000008, "Wrong alignment on UGzAbilityCacheAsset");
static_assert(sizeof(UGzAbilityCacheAsset) == 0x000030, "Wrong size on UGzAbilityCacheAsset");

// Class G01.GzLimbMeshHelper
// 0x0000 (0x0028 - 0x0028)
class UGzLimbMeshHelper final : public UObject
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzLimbMeshHelper">();
	}
	static class UGzLimbMeshHelper* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzLimbMeshHelper>();
	}
};
static_assert(alignof(UGzLimbMeshHelper) == 0x000008, "Wrong alignment on UGzLimbMeshHelper");
static_assert(sizeof(UGzLimbMeshHelper) == 0x000028, "Wrong size on UGzLimbMeshHelper");

// Class G01.GzAbilityCacheSubsystem
// 0x0008 (0x0038 - 0x0030)
class UGzAbilityCacheSubsystem final : public UGameInstanceSubsystem
{
public:
	class UGzAbilityCacheAsset*                   AbilityCache;                                      // 0x0030(0x0008)(ZeroConstructor, Transient, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzAbilityCacheSubsystem">();
	}
	static class UGzAbilityCacheSubsystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzAbilityCacheSubsystem>();
	}
};
static_assert(alignof(UGzAbilityCacheSubsystem) == 0x000008, "Wrong alignment on UGzAbilityCacheSubsystem");
static_assert(sizeof(UGzAbilityCacheSubsystem) == 0x000038, "Wrong size on UGzAbilityCacheSubsystem");
static_assert(offsetof(UGzAbilityCacheSubsystem, AbilityCache) == 0x000030, "Member 'UGzAbilityCacheSubsystem::AbilityCache' has a wrong offset!");

// Class G01.GzWeaponConfigurationModel
// 0x0188 (0x01F8 - 0x0070)
class UGzWeaponConfigurationModel final : public UGzBackendModel
{
public:
	struct FGzCohtmlWeaponConfiguration           InEditingConfiguration;                            // 0x0070(0x00E8)(NativeAccessSpecifierPrivate)
	struct FGzCohtmlWeaponConfigurationCollection Collection;                                        // 0x0158(0x0050)(NativeAccessSpecifierPrivate)
	TMap<class FString, class FString>            WeaponInventoryIdToConfigurationId;                // 0x01A8(0x0050)(NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzWeaponConfigurationModel">();
	}
	static class UGzWeaponConfigurationModel* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzWeaponConfigurationModel>();
	}
};
static_assert(alignof(UGzWeaponConfigurationModel) == 0x000008, "Wrong alignment on UGzWeaponConfigurationModel");
static_assert(sizeof(UGzWeaponConfigurationModel) == 0x0001F8, "Wrong size on UGzWeaponConfigurationModel");
static_assert(offsetof(UGzWeaponConfigurationModel, InEditingConfiguration) == 0x000070, "Member 'UGzWeaponConfigurationModel::InEditingConfiguration' has a wrong offset!");
static_assert(offsetof(UGzWeaponConfigurationModel, Collection) == 0x000158, "Member 'UGzWeaponConfigurationModel::Collection' has a wrong offset!");
static_assert(offsetof(UGzWeaponConfigurationModel, WeaponInventoryIdToConfigurationId) == 0x0001A8, "Member 'UGzWeaponConfigurationModel::WeaponInventoryIdToConfigurationId' has a wrong offset!");

// Class G01.GzClientTelemetryService
// 0x0000 (0x00A0 - 0x00A0)
class UGzClientTelemetryService final : public UGzClientPFObject
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzClientTelemetryService">();
	}
	static class UGzClientTelemetryService* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzClientTelemetryService>();
	}
};
static_assert(alignof(UGzClientTelemetryService) == 0x000008, "Wrong alignment on UGzClientTelemetryService");
static_assert(sizeof(UGzClientTelemetryService) == 0x0000A0, "Wrong size on UGzClientTelemetryService");

// Class G01.GzPlayFabPartyModel
// 0x0020 (0x0090 - 0x0070)
class UGzPlayFabPartyModel final : public UGzBackendModel
{
public:
	uint8                                         Pad_2CA8[0x20];                                    // 0x0070(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzPlayFabPartyModel">();
	}
	static class UGzPlayFabPartyModel* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzPlayFabPartyModel>();
	}
};
static_assert(alignof(UGzPlayFabPartyModel) == 0x000008, "Wrong alignment on UGzPlayFabPartyModel");
static_assert(sizeof(UGzPlayFabPartyModel) == 0x000090, "Wrong size on UGzPlayFabPartyModel");

// Class G01.GzAbilityHelper
// 0x0000 (0x0028 - 0x0028)
class UGzAbilityHelper final : public UBlueprintFunctionLibrary
{
public:
	static class AActor* GetAvatar(class UAbilitySystemComponent* Target);
	static TSubclassOf<class UGameplayEffect> GetGameplayEffectDefinition(class UAbilitySystemComponent* Target, const struct FGameplayEffectSpec& Spec);
	static class UAbilitySystemComponent* GetInstigatorOfEffect(const struct FGameplayEffectSpec& Spec);
	static class AActor* GetOwner(class UAbilitySystemComponent* Target);
	static int32 GetPlayerIdFromASC(const class UAbilitySystemComponent* ASC);
	static TArray<class AGzCharacter*> GetTeammatesOfASCOwner(class UAbilitySystemComponent* Target);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzAbilityHelper">();
	}
	static class UGzAbilityHelper* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzAbilityHelper>();
	}
};
static_assert(alignof(UGzAbilityHelper) == 0x000008, "Wrong alignment on UGzAbilityHelper");
static_assert(sizeof(UGzAbilityHelper) == 0x000028, "Wrong size on UGzAbilityHelper");

// Class G01.GzAbilitySystemComponent
// 0x0030 (0x12A8 - 0x1278)
class UGzAbilitySystemComponent final : public UAbilitySystemComponent
{
public:
	uint8                                         Pad_2CAA[0x28];                                    // 0x1278(0x0028)(Fixing Size After Last Property [ Dumper-7 ])
	class UGzGameplayAbility*                     CurrentAnimLayerAbility;                           // 0x12A0(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static int32 SendGameplayEventToActor(class AActor* Actor, const struct FGameplayTag& EventTag, const struct FGameplayEventData& Payload);

	void AddGameplayCueLocal(const struct FGameplayTag& GameplayCueTag, const struct FGameplayCueParameters& GameplayCueParameters);
	struct FActiveGameplayEffectHandle BP_ApplyGameplayEffectFromActor(TSubclassOf<class UGameplayEffect> GameplayEffectClass, class AActor* EffectCauser, const struct FVector& EffectOrigin);
	struct FActiveGameplayEffectHandle BP_ApplyGameplayEffectFromActorWithCustomMagnitudes(TSubclassOf<class UGameplayEffect> GameplayEffectClass, class AActor* EffectCauser, const TMap<struct FGameplayTag, float>& SetSetByCallerMagnitudes, const struct FVector& EffectOrigin);
	struct FActiveGameplayEffectHandle BP_ApplyGameplayEffectToSelfWithPrediction(TSubclassOf<class UGameplayEffect> GameplayEffectClass, float Level, const struct FGameplayEffectContextHandle& EffectContext);
	struct FActiveGameplayEffectHandle BP_ApplyGameplayEffectToTargetWithPrediction(TSubclassOf<class UGameplayEffect> GameplayEffectClass, class UAbilitySystemComponent* Target, float Level, const struct FGameplayEffectContextHandle& Context);
	void CancelAbilityByClass(TSubclassOf<class UGameplayAbility> InAbilityToCancel);
	void CancelAbilityByTag(const struct FGameplayTag& AbilityTag);
	void ClientPreEndAbility(const struct FGameplayAbilitySpecHandle& AbilityToPreEnd, const struct FGameplayAbilityActivationInfo& ActivationInfo, bool bWasCancelled);
	void ExecuteGameplayCueLocal(const struct FGameplayTag& GameplayCueTag, const struct FGameplayCueParameters& GameplayCueParameters);
	void FindAbilitiesFromAbilityTag(const struct FGameplayTag& AbilityTag, TArray<class UGameplayAbility*>* OutAbilities);
	struct FGameplayAbilitySpecHandle FindAbilitySpecHandleForClass(TSubclassOf<class UGameplayAbility> AbilityClass, class UObject* OptionalSourceObject);
	void LinkAbilityAnimLayer(class UGzGameplayAbility* ActivatingAbility, const TSoftClassPtr<class UClass>& AnimLayer);
	void RemoveGameplayCueLocal(const struct FGameplayTag& GameplayCueTag, const struct FGameplayCueParameters& GameplayCueParameters);
	void ServerPreEndAbility(const struct FGameplayAbilitySpecHandle& AbilityToPreEnd, const struct FGameplayAbilityActivationInfo& ActivationInfo, const struct FPredictionKey& PredictionKey, bool bWasCancelled);
	bool TryPressAbilityInputByTag(const struct FGameplayTag& AbilityTag);
	bool TryReleaseAbilityInputByTag(const struct FGameplayTag& AbilityTag);
	void UnlinkAbilityAnimLayer(class UGzGameplayAbility* ActivatingAbility, const TSoftClassPtr<class UClass>& AnimLayer);

	void ApplyAdditionalDamageMultipliers(struct FGameplayEffectSpecHandle* SpecHandle, const TMap<struct FGameplayTag, float>& AdditionalMultipliers) const;
	bool CanActivateAbility(const struct FGameplayTag& AbilityTag) const;
	float GetDistanceInMetersToImpact(const struct FVector& ImpactPoint) const;
	float GetOngoingEffectDuration(const TSubclassOf<class UGameplayEffect> EffectClass) const;
	bool IsAbilityActive(const struct FGameplayTag& AbilityTag) const;
	bool IsTagBlocked(const struct FGameplayTag& Tag) const;
	int32 K2_GetTagCount(const struct FGameplayTag& TagToCheck) const;
	struct FGameplayEffectContextHandle MakeEffectContextWithInstigator(class AActor* Instigator, class AActor* EffectCauser) const;
	struct FGameplayEffectSpecHandle MakeOutgoingDamageSpec(TSubclassOf<class UGzGE_BaseDamage> GameplayDamageEffectClass, float Level, const struct FGameplayEffectContextHandle& Context, float Distance, float RangeCoefficient, float FalloffStrengthCoefficient) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzAbilitySystemComponent">();
	}
	static class UGzAbilitySystemComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzAbilitySystemComponent>();
	}
};
static_assert(alignof(UGzAbilitySystemComponent) == 0x000008, "Wrong alignment on UGzAbilitySystemComponent");
static_assert(sizeof(UGzAbilitySystemComponent) == 0x0012A8, "Wrong size on UGzAbilitySystemComponent");
static_assert(offsetof(UGzAbilitySystemComponent, CurrentAnimLayerAbility) == 0x0012A0, "Member 'UGzAbilitySystemComponent::CurrentAnimLayerAbility' has a wrong offset!");

// Class G01.GzLoadoutSlot
// 0x0100 (0x03E0 - 0x02E0)
class UGzLoadoutSlot : public UUserWidget
{
public:
	uint8                                         Pad_2CBC[0x8];                                     // 0x02E0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGzLoadoutSelectionContext             SelectionContext;                                  // 0x02E8(0x00F8)(BlueprintVisible, BlueprintReadOnly, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)

public:
	void OnLoadoutSlotReady_BP(const struct FGzLoadoutSelectionInitializeData& LoadoutInitializeData);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzLoadoutSlot">();
	}
	static class UGzLoadoutSlot* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzLoadoutSlot>();
	}
};
static_assert(alignof(UGzLoadoutSlot) == 0x000008, "Wrong alignment on UGzLoadoutSlot");
static_assert(sizeof(UGzLoadoutSlot) == 0x0003E0, "Wrong size on UGzLoadoutSlot");
static_assert(offsetof(UGzLoadoutSlot, SelectionContext) == 0x0002E8, "Member 'UGzLoadoutSlot::SelectionContext' has a wrong offset!");

// Class G01.GzLoadoutListBase
// 0x0088 (0x0468 - 0x03E0)
class UGzLoadoutListBase : public UGzLoadoutSlot
{
public:
	uint8                                         Pad_2CBD[0x40];                                    // 0x03E0(0x0040)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UGzLoadoutSelectionButton*>      Buttons;                                           // 0x0420(0x0010)(ExportObject, ZeroConstructor, Transient, ContainsInstancedReference, Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	class UGzLoadoutSelectionButton*              SelectedButton;                                    // 0x0430(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2CBE[0x8];                                     // 0x0438(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UUserWidget>                LoadoutButtonClass;                                // 0x0440(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bShouldShowLoadoutPrice;                           // 0x0448(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2CBF[0x3];                                     // 0x0449(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FMargin                                ButtonsMargin;                                     // 0x044C(0x0010)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2CC0[0xC];                                     // 0x045C(0x000C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnButtonCreated(class UGzLoadoutSelectionButton* NewButton);
	void OnClear();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzLoadoutListBase">();
	}
	static class UGzLoadoutListBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzLoadoutListBase>();
	}
};
static_assert(alignof(UGzLoadoutListBase) == 0x000008, "Wrong alignment on UGzLoadoutListBase");
static_assert(sizeof(UGzLoadoutListBase) == 0x000468, "Wrong size on UGzLoadoutListBase");
static_assert(offsetof(UGzLoadoutListBase, Buttons) == 0x000420, "Member 'UGzLoadoutListBase::Buttons' has a wrong offset!");
static_assert(offsetof(UGzLoadoutListBase, SelectedButton) == 0x000430, "Member 'UGzLoadoutListBase::SelectedButton' has a wrong offset!");
static_assert(offsetof(UGzLoadoutListBase, LoadoutButtonClass) == 0x000440, "Member 'UGzLoadoutListBase::LoadoutButtonClass' has a wrong offset!");
static_assert(offsetof(UGzLoadoutListBase, bShouldShowLoadoutPrice) == 0x000448, "Member 'UGzLoadoutListBase::bShouldShowLoadoutPrice' has a wrong offset!");
static_assert(offsetof(UGzLoadoutListBase, ButtonsMargin) == 0x00044C, "Member 'UGzLoadoutListBase::ButtonsMargin' has a wrong offset!");

// Class G01.GzWeaponSpawner
// 0x0078 (0x00A0 - 0x0028)
class alignas(0x10) UGzWeaponSpawner final : public UObject
{
public:
	class AGzWeaponSpawn*                         InspectWeaponSpawn;                                // 0x0028(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class AGzWeaponPickable*                      SpawnedWeapon;                                     // 0x0030(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2CC1[0x68];                                    // 0x0038(0x0068)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzWeaponSpawner">();
	}
	static class UGzWeaponSpawner* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzWeaponSpawner>();
	}
};
static_assert(alignof(UGzWeaponSpawner) == 0x000010, "Wrong alignment on UGzWeaponSpawner");
static_assert(sizeof(UGzWeaponSpawner) == 0x0000A0, "Wrong size on UGzWeaponSpawner");
static_assert(offsetof(UGzWeaponSpawner, InspectWeaponSpawn) == 0x000028, "Member 'UGzWeaponSpawner::InspectWeaponSpawn' has a wrong offset!");
static_assert(offsetof(UGzWeaponSpawner, SpawnedWeapon) == 0x000030, "Member 'UGzWeaponSpawner::SpawnedWeapon' has a wrong offset!");

// Class G01.GzViewpointClusterBase
// 0x0010 (0x02B0 - 0x02A0)
class AGzViewpointClusterBase : public AActor
{
public:
	uint8                                         Pad_2CC2[0x10];                                    // 0x02A0(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	TArray<class FString> GetViewpointNames() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzViewpointClusterBase">();
	}
	static class AGzViewpointClusterBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<AGzViewpointClusterBase>();
	}
};
static_assert(alignof(AGzViewpointClusterBase) == 0x000008, "Wrong alignment on AGzViewpointClusterBase");
static_assert(sizeof(AGzViewpointClusterBase) == 0x0002B0, "Wrong size on AGzViewpointClusterBase");

// Class G01.GZAbilitySystemGlobals
// 0x0000 (0x0308 - 0x0308)
class UGZAbilitySystemGlobals final : public UAbilitySystemGlobals
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GZAbilitySystemGlobals">();
	}
	static class UGZAbilitySystemGlobals* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGZAbilitySystemGlobals>();
	}
};
static_assert(alignof(UGZAbilitySystemGlobals) == 0x000008, "Wrong alignment on UGZAbilitySystemGlobals");
static_assert(sizeof(UGZAbilitySystemGlobals) == 0x000308, "Wrong size on UGZAbilitySystemGlobals");

// Class G01.GzAbilityTaskConfig
// 0x0050 (0x0078 - 0x0028)
class UGzAbilityTaskConfig : public UObject
{
public:
	bool                                          bCanCancelAbility;                                 // 0x0028(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseInstigatorTags;                                // 0x0029(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2CC3[0x6];                                     // 0x002A(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTagContainer                  ActivationRequiredTags;                            // 0x0030(0x0020)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FGameplayTagContainer                  ActivationBlockedTags;                             // 0x0050(0x0020)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	uint8                                         NetExecution;                                      // 0x0070(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2CC4[0x7];                                     // 0x0071(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	bool CheckActivationRequirements(const struct FGameplayAbilityActorInfo& ActorInfo, const struct FGameplayEventData& TriggerEventData) const;
	bool CheckNetExecutionMode(const struct FGameplayAbilityActorInfo& ActorInfo) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzAbilityTaskConfig">();
	}
	static class UGzAbilityTaskConfig* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzAbilityTaskConfig>();
	}
};
static_assert(alignof(UGzAbilityTaskConfig) == 0x000008, "Wrong alignment on UGzAbilityTaskConfig");
static_assert(sizeof(UGzAbilityTaskConfig) == 0x000078, "Wrong size on UGzAbilityTaskConfig");
static_assert(offsetof(UGzAbilityTaskConfig, bCanCancelAbility) == 0x000028, "Member 'UGzAbilityTaskConfig::bCanCancelAbility' has a wrong offset!");
static_assert(offsetof(UGzAbilityTaskConfig, bUseInstigatorTags) == 0x000029, "Member 'UGzAbilityTaskConfig::bUseInstigatorTags' has a wrong offset!");
static_assert(offsetof(UGzAbilityTaskConfig, ActivationRequiredTags) == 0x000030, "Member 'UGzAbilityTaskConfig::ActivationRequiredTags' has a wrong offset!");
static_assert(offsetof(UGzAbilityTaskConfig, ActivationBlockedTags) == 0x000050, "Member 'UGzAbilityTaskConfig::ActivationBlockedTags' has a wrong offset!");
static_assert(offsetof(UGzAbilityTaskConfig, NetExecution) == 0x000070, "Member 'UGzAbilityTaskConfig::NetExecution' has a wrong offset!");

// Class G01.GzCommonButton
// 0x0090 (0x1630 - 0x15A0)
class UGzCommonButton : public UCommonButtonBase
{
public:
	FMulticastInlineDelegateProperty_             OnRightClickEvent;                                 // 0x15A0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, Protected, NativeAccessSpecifierProtected)
	FMulticastInlineDelegateProperty_             OnHoldStartedEvent;                                // 0x15B0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, Protected, NativeAccessSpecifierProtected)
	FMulticastInlineDelegateProperty_             OnHoldEndedEvent;                                  // 0x15C0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, Protected, NativeAccessSpecifierProtected)
	FMulticastInlineDelegateProperty_             OnHoldCompletedEvent;                              // 0x15D0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, Protected, NativeAccessSpecifierProtected)
	class UGzButtonSoundData*                     SoundDataOverride;                                 // 0x15E0(0x0008)(Edit, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bSyncFocusableWithEnabled;                         // 0x15E8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bUseRightClickEvent;                               // 0x15E9(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2CC7[0x6];                                     // 0x15EA(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class UCommonTextBlock*                       ButtonTextBlock;                                   // 0x15F0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bFireHoldEvents;                                   // 0x15F8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2CC8[0x7];                                     // 0x15F9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UGzAudioManagerSubsystem*               AudioManagerSubsystem;                             // 0x1600(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2CC9[0x28];                                    // 0x1608(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetText(const class FText& InText);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzCommonButton">();
	}
	static class UGzCommonButton* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzCommonButton>();
	}
};
static_assert(alignof(UGzCommonButton) == 0x000010, "Wrong alignment on UGzCommonButton");
static_assert(sizeof(UGzCommonButton) == 0x001630, "Wrong size on UGzCommonButton");
static_assert(offsetof(UGzCommonButton, OnRightClickEvent) == 0x0015A0, "Member 'UGzCommonButton::OnRightClickEvent' has a wrong offset!");
static_assert(offsetof(UGzCommonButton, OnHoldStartedEvent) == 0x0015B0, "Member 'UGzCommonButton::OnHoldStartedEvent' has a wrong offset!");
static_assert(offsetof(UGzCommonButton, OnHoldEndedEvent) == 0x0015C0, "Member 'UGzCommonButton::OnHoldEndedEvent' has a wrong offset!");
static_assert(offsetof(UGzCommonButton, OnHoldCompletedEvent) == 0x0015D0, "Member 'UGzCommonButton::OnHoldCompletedEvent' has a wrong offset!");
static_assert(offsetof(UGzCommonButton, SoundDataOverride) == 0x0015E0, "Member 'UGzCommonButton::SoundDataOverride' has a wrong offset!");
static_assert(offsetof(UGzCommonButton, bSyncFocusableWithEnabled) == 0x0015E8, "Member 'UGzCommonButton::bSyncFocusableWithEnabled' has a wrong offset!");
static_assert(offsetof(UGzCommonButton, bUseRightClickEvent) == 0x0015E9, "Member 'UGzCommonButton::bUseRightClickEvent' has a wrong offset!");
static_assert(offsetof(UGzCommonButton, ButtonTextBlock) == 0x0015F0, "Member 'UGzCommonButton::ButtonTextBlock' has a wrong offset!");
static_assert(offsetof(UGzCommonButton, bFireHoldEvents) == 0x0015F8, "Member 'UGzCommonButton::bFireHoldEvents' has a wrong offset!");
static_assert(offsetof(UGzCommonButton, AudioManagerSubsystem) == 0x001600, "Member 'UGzCommonButton::AudioManagerSubsystem' has a wrong offset!");

// Class G01.GzAbilityTaskBase
// 0x00E8 (0x0168 - 0x0080)
class UGzAbilityTaskBase : public UAbilityTask
{
public:
	uint8                                         Pad_2CCA[0x30];                                    // 0x0080(0x0030)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayEventData                     AbilityEventData;                                  // 0x00B0(0x00B0)(Transient, Protected, NativeAccessSpecifierProtected)
	class UGzAbilityTaskConfig*                   TaskConfig;                                        // 0x0160(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void OnFinished();
	void OnInterrupted();
	void OnStateEvent(class FName NotifyName);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzAbilityTaskBase">();
	}
	static class UGzAbilityTaskBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzAbilityTaskBase>();
	}
};
static_assert(alignof(UGzAbilityTaskBase) == 0x000008, "Wrong alignment on UGzAbilityTaskBase");
static_assert(sizeof(UGzAbilityTaskBase) == 0x000168, "Wrong size on UGzAbilityTaskBase");
static_assert(offsetof(UGzAbilityTaskBase, AbilityEventData) == 0x0000B0, "Member 'UGzAbilityTaskBase::AbilityEventData' has a wrong offset!");
static_assert(offsetof(UGzAbilityTaskBase, TaskConfig) == 0x000160, "Member 'UGzAbilityTaskBase::TaskConfig' has a wrong offset!");

// Class G01.GzInteractableTransitionSettings
// 0x0020 (0x0050 - 0x0030)
class UGzInteractableTransitionSettings final : public UDataAsset
{
public:
	float                                         RotationToDestinationPointAngleSpeed;              // 0x0030(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RotationToInteractableAngleSpeed;                  // 0x0034(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AngleDistanceToStartMovement;                      // 0x0038(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MovementSpeed;                                     // 0x003C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCurveFloat*                            MovementCurve;                                     // 0x0040(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimMontage*                           MovementMontage;                                   // 0x0048(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzInteractableTransitionSettings">();
	}
	static class UGzInteractableTransitionSettings* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzInteractableTransitionSettings>();
	}
};
static_assert(alignof(UGzInteractableTransitionSettings) == 0x000008, "Wrong alignment on UGzInteractableTransitionSettings");
static_assert(sizeof(UGzInteractableTransitionSettings) == 0x000050, "Wrong size on UGzInteractableTransitionSettings");
static_assert(offsetof(UGzInteractableTransitionSettings, RotationToDestinationPointAngleSpeed) == 0x000030, "Member 'UGzInteractableTransitionSettings::RotationToDestinationPointAngleSpeed' has a wrong offset!");
static_assert(offsetof(UGzInteractableTransitionSettings, RotationToInteractableAngleSpeed) == 0x000034, "Member 'UGzInteractableTransitionSettings::RotationToInteractableAngleSpeed' has a wrong offset!");
static_assert(offsetof(UGzInteractableTransitionSettings, AngleDistanceToStartMovement) == 0x000038, "Member 'UGzInteractableTransitionSettings::AngleDistanceToStartMovement' has a wrong offset!");
static_assert(offsetof(UGzInteractableTransitionSettings, MovementSpeed) == 0x00003C, "Member 'UGzInteractableTransitionSettings::MovementSpeed' has a wrong offset!");
static_assert(offsetof(UGzInteractableTransitionSettings, MovementCurve) == 0x000040, "Member 'UGzInteractableTransitionSettings::MovementCurve' has a wrong offset!");
static_assert(offsetof(UGzInteractableTransitionSettings, MovementMontage) == 0x000048, "Member 'UGzInteractableTransitionSettings::MovementMontage' has a wrong offset!");

// Class G01.GzMetaSubsystem
// 0x0008 (0x0030 - 0x0028)
class UGzMetaSubsystem : public UObject
{
public:
	class UGzBackendManager*                      BackendManager;                                    // 0x0028(0x0008)(ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzMetaSubsystem">();
	}
	static class UGzMetaSubsystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzMetaSubsystem>();
	}
};
static_assert(alignof(UGzMetaSubsystem) == 0x000008, "Wrong alignment on UGzMetaSubsystem");
static_assert(sizeof(UGzMetaSubsystem) == 0x000030, "Wrong size on UGzMetaSubsystem");
static_assert(offsetof(UGzMetaSubsystem, BackendManager) == 0x000028, "Member 'UGzMetaSubsystem::BackendManager' has a wrong offset!");

// Class G01.GzInvComponent
// 0x02A8 (0x0350 - 0x00A8)
class UGzInvComponent final : public UActorComponent
{
public:
	FMulticastInlineDelegateProperty_             OnInventoryChangedGlobal;                          // 0x00A8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnExcessItemsGenerated;                            // 0x00B8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TArray<struct FGzInvPocketDef>                DefaultPocketDefinitions;                          // 0x00C8(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	struct FGzInvPocketsArray                     Pockets;                                           // 0x00D8(0x01B0)(Net, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2CCB[0xC8];                                    // 0x0288(0x00C8)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	bool AddItem(struct FGzInvItem& Item);
	void DecreasePocketPriority(const struct FGzInvPocketId& PocketId);
	const TArray<struct FGameplayTag> GetAllSlotsFromPocketDef(const EGzInvPocketType PocketType, const struct FGameplayTag& AllowedTag);
	void IncreasePocketPriority(const struct FGzInvPocketId& PocketId);
	struct FGzInvItem RemoveAllItemFromPocket(const struct FGzInvPocketId& PocketId);
	TArray<struct FGzInvItem> RemoveAllItems();
	struct FGzInvItem RemoveItem(const struct FGzInvItem& Item);
	struct FGzInvItem RemoveItemFromPocket(const struct FGzInvPocketId& PocketId, const int32 Quantity);
	void SetVirtualItem(const struct FGzInvPocketId& PocketId, class UGzItemData* ItemData);
	bool TrySwapPockets(const struct FGzInvPocketId& LeftPocketId, const struct FGzInvPocketId& RightPocketId);

	const struct FGzInvPocket GetPocketById(const struct FGzInvPocketId& PocketId) const;
	const struct FGzInvPocketDef GetPocketDefById(const struct FGzInvPocketId& PocketId) const;
	bool IsValidPocket(const struct FGzInvPocketId& PocketId) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzInvComponent">();
	}
	static class UGzInvComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzInvComponent>();
	}
};
static_assert(alignof(UGzInvComponent) == 0x000008, "Wrong alignment on UGzInvComponent");
static_assert(sizeof(UGzInvComponent) == 0x000350, "Wrong size on UGzInvComponent");
static_assert(offsetof(UGzInvComponent, OnInventoryChangedGlobal) == 0x0000A8, "Member 'UGzInvComponent::OnInventoryChangedGlobal' has a wrong offset!");
static_assert(offsetof(UGzInvComponent, OnExcessItemsGenerated) == 0x0000B8, "Member 'UGzInvComponent::OnExcessItemsGenerated' has a wrong offset!");
static_assert(offsetof(UGzInvComponent, DefaultPocketDefinitions) == 0x0000C8, "Member 'UGzInvComponent::DefaultPocketDefinitions' has a wrong offset!");
static_assert(offsetof(UGzInvComponent, Pockets) == 0x0000D8, "Member 'UGzInvComponent::Pockets' has a wrong offset!");

// Class G01.GzAccountService
// 0x0098 (0x0138 - 0x00A0)
class UGzAccountService final : public UGzClientPFObject
{
public:
	uint8                                         Pad_2CD2[0x98];                                    // 0x00A0(0x0098)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzAccountService">();
	}
	static class UGzAccountService* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzAccountService>();
	}
};
static_assert(alignof(UGzAccountService) == 0x000008, "Wrong alignment on UGzAccountService");
static_assert(sizeof(UGzAccountService) == 0x000138, "Wrong size on UGzAccountService");

// Class G01.GzSignalREventData
// 0x0000 (0x0028 - 0x0028)
class UGzSignalREventData : public UObject
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzSignalREventData">();
	}
	static class UGzSignalREventData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzSignalREventData>();
	}
};
static_assert(alignof(UGzSignalREventData) == 0x000008, "Wrong alignment on UGzSignalREventData");
static_assert(sizeof(UGzSignalREventData) == 0x000028, "Wrong size on UGzSignalREventData");

// Class G01.GzCoinsBalancesUpdatedData
// 0x0000 (0x0028 - 0x0028)
class UGzCoinsBalancesUpdatedData final : public UGzSignalREventData
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzCoinsBalancesUpdatedData">();
	}
	static class UGzCoinsBalancesUpdatedData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzCoinsBalancesUpdatedData>();
	}
};
static_assert(alignof(UGzCoinsBalancesUpdatedData) == 0x000008, "Wrong alignment on UGzCoinsBalancesUpdatedData");
static_assert(sizeof(UGzCoinsBalancesUpdatedData) == 0x000028, "Wrong size on UGzCoinsBalancesUpdatedData");

// Class G01.GzLimbAbilityComponent
// 0x0048 (0x00F0 - 0x00A8)
class UGzLimbAbilityComponent : public UActorComponent
{
public:
	ELifetimeCondition                            ReplicationCondition;                              // 0x00A8(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bUpdateDefaultLimbTargetLocation;                  // 0x00A9(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2CD3[0x6];                                     // 0x00AA(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class UGzLimbUIActivationSubsystem*           LimbUIActivationSystem;                            // 0x00B0(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UGzGA_BaseLimbAbility*                  LimbAbility;                                       // 0x00B8(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         RechargeProgress;                                  // 0x00C0(0x0004)(Net, ZeroConstructor, Transient, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsRecharging;                                     // 0x00C4(0x0001)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2CD4[0xB];                                     // 0x00C5(0x000B)(Fixing Size After Last Property [ Dumper-7 ])
	class UGzBodyPartAbilityData*                 AbilityData;                                       // 0x00D0(0x0008)(Net, ZeroConstructor, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	EGzLimbType                                   LimbType;                                          // 0x00D8(0x0001)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2CD5[0x7];                                     // 0x00D9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UGzAsyncTaskGameplayTagAddedRemoved*    ListenForGameplayTagAddedOrRemovedTask;            // 0x00E0(0x0008)(ZeroConstructor, Transient, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2CD6[0x8];                                     // 0x00E8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnLimbAimingStart(const struct FGameplayTag& AimingTag);
	void OnLimbAimingStop(const struct FGameplayTag& AimingTag);
	void OnRechargeTimerTick();
	void OnRep_AbilityData();
	void OnRep_IsRecharging(const bool bOldIsRecharging);
	void OnRep_LimbType();
	void OnRep_RechargeProgress();
	void SetLimbUIEnabled(bool bIsEnabled);

	class UGzBodyPartAbilityData* BP_GetAbilityData() const;
	float GetAbilityChargePercentage() const;
	class UGzBodyPartAbilityInputData* GetAbilityInputData() const;
	const class UGzGA_BaseLimbAbility* GetLimbAbility() const;
	class UGzLimbComponent* GetLimbComponent() const;
	struct FVector GetLimbSocketWorldLocation(const class FName& SocketName) const;
	EGzLimbType GetLimbType() const;
	class UGzLimbUIActivationSubsystem* GetLimbUISystem() const;
	class UGzAbilitySystemComponent* GetOwnerASC() const;
	class AGzMultiPartCharacter* GetOwnerCharacter() const;
	bool HasOwnerAuthority() const;
	bool IsOwnerLocallyControlled() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzLimbAbilityComponent">();
	}
	static class UGzLimbAbilityComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzLimbAbilityComponent>();
	}
};
static_assert(alignof(UGzLimbAbilityComponent) == 0x000008, "Wrong alignment on UGzLimbAbilityComponent");
static_assert(sizeof(UGzLimbAbilityComponent) == 0x0000F0, "Wrong size on UGzLimbAbilityComponent");
static_assert(offsetof(UGzLimbAbilityComponent, ReplicationCondition) == 0x0000A8, "Member 'UGzLimbAbilityComponent::ReplicationCondition' has a wrong offset!");
static_assert(offsetof(UGzLimbAbilityComponent, bUpdateDefaultLimbTargetLocation) == 0x0000A9, "Member 'UGzLimbAbilityComponent::bUpdateDefaultLimbTargetLocation' has a wrong offset!");
static_assert(offsetof(UGzLimbAbilityComponent, LimbUIActivationSystem) == 0x0000B0, "Member 'UGzLimbAbilityComponent::LimbUIActivationSystem' has a wrong offset!");
static_assert(offsetof(UGzLimbAbilityComponent, LimbAbility) == 0x0000B8, "Member 'UGzLimbAbilityComponent::LimbAbility' has a wrong offset!");
static_assert(offsetof(UGzLimbAbilityComponent, RechargeProgress) == 0x0000C0, "Member 'UGzLimbAbilityComponent::RechargeProgress' has a wrong offset!");
static_assert(offsetof(UGzLimbAbilityComponent, bIsRecharging) == 0x0000C4, "Member 'UGzLimbAbilityComponent::bIsRecharging' has a wrong offset!");
static_assert(offsetof(UGzLimbAbilityComponent, AbilityData) == 0x0000D0, "Member 'UGzLimbAbilityComponent::AbilityData' has a wrong offset!");
static_assert(offsetof(UGzLimbAbilityComponent, LimbType) == 0x0000D8, "Member 'UGzLimbAbilityComponent::LimbType' has a wrong offset!");
static_assert(offsetof(UGzLimbAbilityComponent, ListenForGameplayTagAddedOrRemovedTask) == 0x0000E0, "Member 'UGzLimbAbilityComponent::ListenForGameplayTagAddedOrRemovedTask' has a wrong offset!");

// Class G01.GzGrappleHookComponent
// 0x0390 (0x0480 - 0x00F0)
class UGzGrappleHookComponent : public UGzLimbAbilityComponent
{
public:
	uint8                                         Pad_2CD7[0x30];                                    // 0x00F0(0x0030)(Fixing Size After Last Property [ Dumper-7 ])
	class UGzGrappleHookData*                     GrappleHookData;                                   // 0x0120(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AGzGrappleHookProjectile*               GrappleHookProjectile;                             // 0x0128(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ACableActor*                            CableLine;                                         // 0x0130(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCableComponent*                        CachedGrappleHookCableComponent;                   // 0x0138(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EGzGrappleHookState                           GrappleState;                                      // 0x0140(0x0001)(Net, ZeroConstructor, Transient, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2CD8[0x32F];                                   // 0x0141(0x032F)(Fixing Size After Last Property [ Dumper-7 ])
	class UAkAudioEvent*                          ActiveEvent;                                       // 0x0470(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2CD9[0x8];                                     // 0x0478(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void MulticastDistributeHookLaunch(const struct FHitResult& HitResult);
	void OnGrappleHookProjectileDestroyed(class AActor* DestroyedActor);
	void OnRep_GrappleHookState(EGzGrappleHookState OldGrappleHookState);
	void ServerPullCharacterRequest(const struct FHitResult& HitResult);
	void ServerRequestHookLaunch(const struct FHitResult& HitResult);
	void ServerStopGrapple(const struct FHitResult& HitResult, const struct FVector& Offset);

	EGzGrappleHookState GetState() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzGrappleHookComponent">();
	}
	static class UGzGrappleHookComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzGrappleHookComponent>();
	}
};
static_assert(alignof(UGzGrappleHookComponent) == 0x000008, "Wrong alignment on UGzGrappleHookComponent");
static_assert(sizeof(UGzGrappleHookComponent) == 0x000480, "Wrong size on UGzGrappleHookComponent");
static_assert(offsetof(UGzGrappleHookComponent, GrappleHookData) == 0x000120, "Member 'UGzGrappleHookComponent::GrappleHookData' has a wrong offset!");
static_assert(offsetof(UGzGrappleHookComponent, GrappleHookProjectile) == 0x000128, "Member 'UGzGrappleHookComponent::GrappleHookProjectile' has a wrong offset!");
static_assert(offsetof(UGzGrappleHookComponent, CableLine) == 0x000130, "Member 'UGzGrappleHookComponent::CableLine' has a wrong offset!");
static_assert(offsetof(UGzGrappleHookComponent, CachedGrappleHookCableComponent) == 0x000138, "Member 'UGzGrappleHookComponent::CachedGrappleHookCableComponent' has a wrong offset!");
static_assert(offsetof(UGzGrappleHookComponent, GrappleState) == 0x000140, "Member 'UGzGrappleHookComponent::GrappleState' has a wrong offset!");
static_assert(offsetof(UGzGrappleHookComponent, ActiveEvent) == 0x000470, "Member 'UGzGrappleHookComponent::ActiveEvent' has a wrong offset!");

// Class G01.GzAccountSetupSettings
// 0x0090 (0x00C8 - 0x0038)
class UGzAccountSetupSettings final : public UDeveloperSettings
{
public:
	uint8                                         Pad_2CDA[0x8];                                     // 0x0038(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftObjectPtr<class UGzBundleItemData>       StarterPack;                                       // 0x0040(0x0028)(Edit, Config, DisableEditOnInstance, EditConst, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<TSoftObjectPtr<class UGzItemData>>     StarterPackItems;                                  // 0x0068(0x0010)(Edit, ZeroConstructor, Config, DisableEditOnInstance, UObjectWrapper, NativeAccessSpecifierPublic)
	TMap<struct FGameplayTag, TSoftObjectPtr<class UGzCustomizationItemTemplate>> DefaultCharacterCustomizationSlots;                // 0x0078(0x0050)(Edit, Config, DisableEditOnInstance, UObjectWrapper, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzAccountSetupSettings">();
	}
	static class UGzAccountSetupSettings* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzAccountSetupSettings>();
	}
};
static_assert(alignof(UGzAccountSetupSettings) == 0x000008, "Wrong alignment on UGzAccountSetupSettings");
static_assert(sizeof(UGzAccountSetupSettings) == 0x0000C8, "Wrong size on UGzAccountSetupSettings");
static_assert(offsetof(UGzAccountSetupSettings, StarterPack) == 0x000040, "Member 'UGzAccountSetupSettings::StarterPack' has a wrong offset!");
static_assert(offsetof(UGzAccountSetupSettings, StarterPackItems) == 0x000068, "Member 'UGzAccountSetupSettings::StarterPackItems' has a wrong offset!");
static_assert(offsetof(UGzAccountSetupSettings, DefaultCharacterCustomizationSlots) == 0x000078, "Member 'UGzAccountSetupSettings::DefaultCharacterCustomizationSlots' has a wrong offset!");

// Class G01.GzGameSession
// 0x0008 (0x02D0 - 0x02C8)
class AGzGameSession : public AGameSession
{
public:
	uint8                                         Pad_2CDB[0x8];                                     // 0x02C8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzGameSession">();
	}
	static class AGzGameSession* GetDefaultObj()
	{
		return GetDefaultObjImpl<AGzGameSession>();
	}
};
static_assert(alignof(AGzGameSession) == 0x000008, "Wrong alignment on AGzGameSession");
static_assert(sizeof(AGzGameSession) == 0x0002D0, "Wrong size on AGzGameSession");

// Class G01.GzJobZeroGameSession
// 0x0008 (0x02D8 - 0x02D0)
class AGzJobZeroGameSession final : public AGzGameSession
{
public:
	uint8                                         Pad_2CDC[0x8];                                     // 0x02D0(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzJobZeroGameSession">();
	}
	static class AGzJobZeroGameSession* GetDefaultObj()
	{
		return GetDefaultObjImpl<AGzJobZeroGameSession>();
	}
};
static_assert(alignof(AGzJobZeroGameSession) == 0x000008, "Wrong alignment on AGzJobZeroGameSession");
static_assert(sizeof(AGzJobZeroGameSession) == 0x0002D8, "Wrong size on AGzJobZeroGameSession");

// Class G01.GzPlayerToPlayerInteractionMessage
// 0x0020 (0x0048 - 0x0028)
class UGzPlayerToPlayerInteractionMessage : public UGzGameMessage
{
public:
	struct FGzAdvancedIdType                      VictimId;                                          // 0x0028(0x0008)(BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGzAdvancedIdType                      InstigatorId;                                      // 0x0030(0x0008)(BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FPrimaryAssetId                        AssetId;                                           // 0x0038(0x0010)(BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	bool AreFromSameTeam(const class UObject* WorldContext) const;
	class FString GetInstigatorName(const class UObject* WorldContextObject) const;
	class AGzPlayerState* GetInstigatorPlayerState(const class UObject* WorldContextObject) const;
	TSoftObjectPtr<class UTexture2D> GetUIAssetIcon() const;
	class FString GetUIAssetId() const;
	class FString GetVictimName(const class UObject* WorldContextObject) const;
	class AGzPlayerState* GetVictimPlayerState(const class UObject* WorldContextObject) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzPlayerToPlayerInteractionMessage">();
	}
	static class UGzPlayerToPlayerInteractionMessage* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzPlayerToPlayerInteractionMessage>();
	}
};
static_assert(alignof(UGzPlayerToPlayerInteractionMessage) == 0x000008, "Wrong alignment on UGzPlayerToPlayerInteractionMessage");
static_assert(sizeof(UGzPlayerToPlayerInteractionMessage) == 0x000048, "Wrong size on UGzPlayerToPlayerInteractionMessage");
static_assert(offsetof(UGzPlayerToPlayerInteractionMessage, VictimId) == 0x000028, "Member 'UGzPlayerToPlayerInteractionMessage::VictimId' has a wrong offset!");
static_assert(offsetof(UGzPlayerToPlayerInteractionMessage, InstigatorId) == 0x000030, "Member 'UGzPlayerToPlayerInteractionMessage::InstigatorId' has a wrong offset!");
static_assert(offsetof(UGzPlayerToPlayerInteractionMessage, AssetId) == 0x000038, "Member 'UGzPlayerToPlayerInteractionMessage::AssetId' has a wrong offset!");

// Class G01.GzHeadShotKillsMessage
// 0x0008 (0x0050 - 0x0048)
class UGzHeadShotKillsMessage final : public UGzPlayerToPlayerInteractionMessage
{
public:
	class FName                                   WeaponArchetype;                                   // 0x0048(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzHeadShotKillsMessage">();
	}
	static class UGzHeadShotKillsMessage* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzHeadShotKillsMessage>();
	}
};
static_assert(alignof(UGzHeadShotKillsMessage) == 0x000008, "Wrong alignment on UGzHeadShotKillsMessage");
static_assert(sizeof(UGzHeadShotKillsMessage) == 0x000050, "Wrong size on UGzHeadShotKillsMessage");
static_assert(offsetof(UGzHeadShotKillsMessage, WeaponArchetype) == 0x000048, "Member 'UGzHeadShotKillsMessage::WeaponArchetype' has a wrong offset!");

// Class G01.GzClientTelemetryStatCollector
// 0x0020 (0x0048 - 0x0028)
class UGzClientTelemetryStatCollector : public UObject
{
public:
	uint8                                         Pad_2CDE[0x20];                                    // 0x0028(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzClientTelemetryStatCollector">();
	}
	static class UGzClientTelemetryStatCollector* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzClientTelemetryStatCollector>();
	}
};
static_assert(alignof(UGzClientTelemetryStatCollector) == 0x000008, "Wrong alignment on UGzClientTelemetryStatCollector");
static_assert(sizeof(UGzClientTelemetryStatCollector) == 0x000048, "Wrong size on UGzClientTelemetryStatCollector");

// Class G01.GzClientTelemetryFpsCollector
// 0x0000 (0x0048 - 0x0048)
class UGzClientTelemetryFpsCollector final : public UGzClientTelemetryStatCollector
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzClientTelemetryFpsCollector">();
	}
	static class UGzClientTelemetryFpsCollector* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzClientTelemetryFpsCollector>();
	}
};
static_assert(alignof(UGzClientTelemetryFpsCollector) == 0x000008, "Wrong alignment on UGzClientTelemetryFpsCollector");
static_assert(sizeof(UGzClientTelemetryFpsCollector) == 0x000048, "Wrong size on UGzClientTelemetryFpsCollector");

// Class G01.GzAchievementServiceCheatExtension
// 0x0000 (0x0028 - 0x0028)
class UGzAchievementServiceCheatExtension final : public UGzCheatManagerExtension
{
public:
	void ResetAccountAchievementProgress();

	void ClientCompleteAchievementStage(const class FName& AchievementId, const int8 AchievementStageToComplete) const;
	void ClientResetAchievementProgress(const class FName& AchievementId) const;
	void ClientResetAllAchievements() const;
	void ClientUpdateAchievementsProgress(const class FName& AchievementId, const float ProgressToAdd) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzAchievementServiceCheatExtension">();
	}
	static class UGzAchievementServiceCheatExtension* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzAchievementServiceCheatExtension>();
	}
};
static_assert(alignof(UGzAchievementServiceCheatExtension) == 0x000008, "Wrong alignment on UGzAchievementServiceCheatExtension");
static_assert(sizeof(UGzAchievementServiceCheatExtension) == 0x000028, "Wrong size on UGzAchievementServiceCheatExtension");

// Class G01.GzLoadoutStatics
// 0x0000 (0x0028 - 0x0028)
class UGzLoadoutStatics final : public UBlueprintFunctionLibrary
{
public:
	static int32 GetAuthorityLoadoutCost(const class UObject* WorldContext, const class FString& PlayFabId, const struct FGuid& Guid);
	static struct FGzInvItem GetItemFromLocalLoadoutSlot(const class UObject* WorldContext, const struct FGuid& Guid, EGzLoadoutSlots SlotType);
	static TArray<struct FGzInvItem> GetItemsFromAuthorityLoadout(const class UObject* WorldContext, const class FString& PlayFabId, const struct FGuid& Guid);
	static TArray<struct FGzInvItem> GetItemsFromAuthorityLoadoutConfig(const class UObject* WorldContext, const struct FGzLoadoutDataConfig& Config, const class FString& PlayFabId);
	static TArray<struct FGzInvItem> GetItemsFromLocalLoadout(const class UObject* WorldContext, const struct FGuid& Guid);
	static TArray<struct FGzInvItem> GetItemsFromLocalLoadoutConfig(const class UObject* WorldContext, const struct FGzLoadoutDataConfig& Config);
	static TMap<EGzLoadoutSlots, struct FGzInvItem> GetLoadoutItemsForSlotsFromConfig(const class UObject* WorldContext, const struct FGzLoadoutDataConfig& Config);
	static TMap<EGzLoadoutSlots, struct FGzInvItem> GetLoadoutItemsForSlotsFromGuid(const class UObject* WorldContext, const struct FGuid& Guid);
	static float GetLoadoutPriceMultiplier(const class UObject* WorldContext);
	static int32 GetLocalLoadoutCost(const class UObject* WorldContext, const struct FGuid& Guid);
	static class FString GetLocalLoadoutName(const class UObject* WorldContext, const struct FGuid& Guid);
	static TArray<struct FGuid> GetPlayerLocalLoadoutGuids(const class UObject* WorldContext);
	static TArray<struct FGuid> GetSharedLocalLoadoutGuids(const class UObject* WorldContext);
	static bool HasPlayerLocalLoadouts(const class UObject* WorldContext);
	static bool HasSharedLocalLoadouts(const class UObject* WorldContext);
	static bool IsValidLoadoutConfig(const struct FGzLoadoutDataConfig& Config);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzLoadoutStatics">();
	}
	static class UGzLoadoutStatics* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzLoadoutStatics>();
	}
};
static_assert(alignof(UGzLoadoutStatics) == 0x000008, "Wrong alignment on UGzLoadoutStatics");
static_assert(sizeof(UGzLoadoutStatics) == 0x000028, "Wrong size on UGzLoadoutStatics");

// Class G01.GzNavigationWidget
// 0x00F8 (0x0528 - 0x0430)
class UGzNavigationWidget : public UCommonActivatableWidget
{
public:
	uint8                                         Pad_2CE7[0x8];                                     // 0x0430(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<ECommonInputType, struct FGzInputModeConfig> CapturingInputModes;                               // 0x0438(0x0050)(Edit, Protected, NativeAccessSpecifierProtected)
	struct FGzInputModeConfig                     CapturingInputMode;                                // 0x0488(0x0002)(Edit, NoDestructor, Protected, NativeAccessSpecifierProtected)
	bool                                          bUseInputTypeForCaptureMode;                       // 0x048A(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bAllowDuplicates;                                  // 0x048B(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bHideLowerLayers;                                  // 0x048C(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2CE8[0x3];                                     // 0x048D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTagContainer                  EventTags;                                         // 0x0490(0x0020)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	class UGzWE_UITagsAware*                      TagsAwareExtension;                                // 0x04B0(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, PersistentInstance, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FGzNavigationLayerKey                  Layer;                                             // 0x04B8(0x0008)(Edit, DisableEditOnInstance, NoDestructor, Protected, NativeAccessSpecifierProtected)
	bool                                          bCloseOnDamageRecieved;                            // 0x04C0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bCloseOnDeath;                                     // 0x04C1(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bCanOpenDuringCutscene;                            // 0x04C2(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bAllowInstantiationByTags;                         // 0x04C3(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bAllowRemovalByTags;                               // 0x04C4(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2CE9[0x3];                                     // 0x04C5(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class UInputAction*                           CloseEnhancedInputAction;                          // 0x04C8(0x0008)(Edit, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UInputAction*                           VoiceChatEnhancedInputAction;                      // 0x04D0(0x0008)(Edit, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UUserWidget>                CursorWidgetClass;                                 // 0x04D8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UUserWidget*                            CursorWidget;                                      // 0x04E0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, Transient, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bUseMappingConfigOverride;                         // 0x04E8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2CEA[0x7];                                     // 0x04E9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UGzPawnInputMappingConfig*              InputMappingConfigOverride;                        // 0x04F0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAkAudioEvent*                          CloseWidgetSound;                                  // 0x04F8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSubclassOf<class UUserWidget>                AnalogCursorClass;                                 // 0x0500(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bRegisterDefaultBindings;                          // 0x0508(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bHideBackAction;                                   // 0x0509(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2CEB[0x1E];                                    // 0x050A(0x001E)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	struct FVector2D GetInitialMousePosition();
	void OnBackAction();
	void OnClickAction();
	void OnCloseAction();
	void OnPawnChanged(class APawn* Pawn);
	void OnVoiceChatActive();
	void OnVoiceChatInactive();
	void RegisterBinding(class UInputAction* InputAction, const TDelegate<void()>& Callback, struct FGzInputActionBindingHandle* BindingHandle, bool bDisplayInBar, bool bConsumeInput, EInputEvent InputEvent);
	void RemoveFromLayer();
	bool ShouldFlushInputOnOpening();
	void UnregisterBinding(const struct FGzInputActionBindingHandle& BindingHandle);
	void UpdateAcceptButton(ECommonInputType NewInputType);

	bool CanBeAddedToLayer(class UObject* WorldContext) const;
	bool DoesAllowDuplicates() const;
	class FName GetLayerKey() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzNavigationWidget">();
	}
	static class UGzNavigationWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzNavigationWidget>();
	}
};
static_assert(alignof(UGzNavigationWidget) == 0x000008, "Wrong alignment on UGzNavigationWidget");
static_assert(sizeof(UGzNavigationWidget) == 0x000528, "Wrong size on UGzNavigationWidget");
static_assert(offsetof(UGzNavigationWidget, CapturingInputModes) == 0x000438, "Member 'UGzNavigationWidget::CapturingInputModes' has a wrong offset!");
static_assert(offsetof(UGzNavigationWidget, CapturingInputMode) == 0x000488, "Member 'UGzNavigationWidget::CapturingInputMode' has a wrong offset!");
static_assert(offsetof(UGzNavigationWidget, bUseInputTypeForCaptureMode) == 0x00048A, "Member 'UGzNavigationWidget::bUseInputTypeForCaptureMode' has a wrong offset!");
static_assert(offsetof(UGzNavigationWidget, bAllowDuplicates) == 0x00048B, "Member 'UGzNavigationWidget::bAllowDuplicates' has a wrong offset!");
static_assert(offsetof(UGzNavigationWidget, bHideLowerLayers) == 0x00048C, "Member 'UGzNavigationWidget::bHideLowerLayers' has a wrong offset!");
static_assert(offsetof(UGzNavigationWidget, EventTags) == 0x000490, "Member 'UGzNavigationWidget::EventTags' has a wrong offset!");
static_assert(offsetof(UGzNavigationWidget, TagsAwareExtension) == 0x0004B0, "Member 'UGzNavigationWidget::TagsAwareExtension' has a wrong offset!");
static_assert(offsetof(UGzNavigationWidget, Layer) == 0x0004B8, "Member 'UGzNavigationWidget::Layer' has a wrong offset!");
static_assert(offsetof(UGzNavigationWidget, bCloseOnDamageRecieved) == 0x0004C0, "Member 'UGzNavigationWidget::bCloseOnDamageRecieved' has a wrong offset!");
static_assert(offsetof(UGzNavigationWidget, bCloseOnDeath) == 0x0004C1, "Member 'UGzNavigationWidget::bCloseOnDeath' has a wrong offset!");
static_assert(offsetof(UGzNavigationWidget, bCanOpenDuringCutscene) == 0x0004C2, "Member 'UGzNavigationWidget::bCanOpenDuringCutscene' has a wrong offset!");
static_assert(offsetof(UGzNavigationWidget, bAllowInstantiationByTags) == 0x0004C3, "Member 'UGzNavigationWidget::bAllowInstantiationByTags' has a wrong offset!");
static_assert(offsetof(UGzNavigationWidget, bAllowRemovalByTags) == 0x0004C4, "Member 'UGzNavigationWidget::bAllowRemovalByTags' has a wrong offset!");
static_assert(offsetof(UGzNavigationWidget, CloseEnhancedInputAction) == 0x0004C8, "Member 'UGzNavigationWidget::CloseEnhancedInputAction' has a wrong offset!");
static_assert(offsetof(UGzNavigationWidget, VoiceChatEnhancedInputAction) == 0x0004D0, "Member 'UGzNavigationWidget::VoiceChatEnhancedInputAction' has a wrong offset!");
static_assert(offsetof(UGzNavigationWidget, CursorWidgetClass) == 0x0004D8, "Member 'UGzNavigationWidget::CursorWidgetClass' has a wrong offset!");
static_assert(offsetof(UGzNavigationWidget, CursorWidget) == 0x0004E0, "Member 'UGzNavigationWidget::CursorWidget' has a wrong offset!");
static_assert(offsetof(UGzNavigationWidget, bUseMappingConfigOverride) == 0x0004E8, "Member 'UGzNavigationWidget::bUseMappingConfigOverride' has a wrong offset!");
static_assert(offsetof(UGzNavigationWidget, InputMappingConfigOverride) == 0x0004F0, "Member 'UGzNavigationWidget::InputMappingConfigOverride' has a wrong offset!");
static_assert(offsetof(UGzNavigationWidget, CloseWidgetSound) == 0x0004F8, "Member 'UGzNavigationWidget::CloseWidgetSound' has a wrong offset!");
static_assert(offsetof(UGzNavigationWidget, AnalogCursorClass) == 0x000500, "Member 'UGzNavigationWidget::AnalogCursorClass' has a wrong offset!");
static_assert(offsetof(UGzNavigationWidget, bRegisterDefaultBindings) == 0x000508, "Member 'UGzNavigationWidget::bRegisterDefaultBindings' has a wrong offset!");
static_assert(offsetof(UGzNavigationWidget, bHideBackAction) == 0x000509, "Member 'UGzNavigationWidget::bHideBackAction' has a wrong offset!");

// Class G01.GzGenericMissionMessage
// 0x0028 (0x0050 - 0x0028)
class UGzGenericMissionMessage final : public UGzGameMessage
{
public:
	class AGzMission*                             Mission;                                           // 0x0028(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           GameplayTag;                                       // 0x0030(0x0008)(Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   Text;                                              // 0x0038(0x0010)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	float                                         Duration;                                          // 0x0048(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2CEE[0x4];                                     // 0x004C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzGenericMissionMessage">();
	}
	static class UGzGenericMissionMessage* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzGenericMissionMessage>();
	}
};
static_assert(alignof(UGzGenericMissionMessage) == 0x000008, "Wrong alignment on UGzGenericMissionMessage");
static_assert(sizeof(UGzGenericMissionMessage) == 0x000050, "Wrong size on UGzGenericMissionMessage");
static_assert(offsetof(UGzGenericMissionMessage, Mission) == 0x000028, "Member 'UGzGenericMissionMessage::Mission' has a wrong offset!");
static_assert(offsetof(UGzGenericMissionMessage, GameplayTag) == 0x000030, "Member 'UGzGenericMissionMessage::GameplayTag' has a wrong offset!");
static_assert(offsetof(UGzGenericMissionMessage, Text) == 0x000038, "Member 'UGzGenericMissionMessage::Text' has a wrong offset!");
static_assert(offsetof(UGzGenericMissionMessage, Duration) == 0x000048, "Member 'UGzGenericMissionMessage::Duration' has a wrong offset!");

// Class G01.GzAchievementsModel
// 0x0010 (0x0080 - 0x0070)
class UGzAchievementsModel final : public UGzBackendModel
{
public:
	uint8                                         Pad_2CEF[0x10];                                    // 0x0070(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzAchievementsModel">();
	}
	static class UGzAchievementsModel* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzAchievementsModel>();
	}
};
static_assert(alignof(UGzAchievementsModel) == 0x000008, "Wrong alignment on UGzAchievementsModel");
static_assert(sizeof(UGzAchievementsModel) == 0x000080, "Wrong size on UGzAchievementsModel");

// Class G01.GzClientWeaponConfigurationService
// 0x0120 (0x01C0 - 0x00A0)
class UGzClientWeaponConfigurationService final : public UGzClientPFObject
{
public:
	uint8                                         Pad_2CF0[0x120];                                   // 0x00A0(0x0120)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzClientWeaponConfigurationService">();
	}
	static class UGzClientWeaponConfigurationService* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzClientWeaponConfigurationService>();
	}
};
static_assert(alignof(UGzClientWeaponConfigurationService) == 0x000008, "Wrong alignment on UGzClientWeaponConfigurationService");
static_assert(sizeof(UGzClientWeaponConfigurationService) == 0x0001C0, "Wrong size on UGzClientWeaponConfigurationService");

// Class G01.GzTrialTemplate
// 0x0038 (0x0068 - 0x0030)
class UGzTrialTemplate : public UPrimaryDataAsset
{
public:
	uint8                                         Pad_2CF1[0x8];                                     // 0x0030(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	EGzTrialType                                  Type;                                              // 0x0038(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2CF2[0x7];                                     // 0x0039(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FGzTrialStage>                  Stages;                                            // 0x0040(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	EGzTrackerCategory                            TrackerCategory;                                   // 0x0050(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2CF3[0x7];                                     // 0x0051(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UGzTrialTracker>            TrackerType;                                       // 0x0058(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EGzMetaTrackerType                            MetaTrackerType;                                   // 0x0060(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bExport;                                           // 0x0061(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2CF4[0x6];                                     // 0x0062(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzTrialTemplate">();
	}
	static class UGzTrialTemplate* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzTrialTemplate>();
	}
};
static_assert(alignof(UGzTrialTemplate) == 0x000008, "Wrong alignment on UGzTrialTemplate");
static_assert(sizeof(UGzTrialTemplate) == 0x000068, "Wrong size on UGzTrialTemplate");
static_assert(offsetof(UGzTrialTemplate, Type) == 0x000038, "Member 'UGzTrialTemplate::Type' has a wrong offset!");
static_assert(offsetof(UGzTrialTemplate, Stages) == 0x000040, "Member 'UGzTrialTemplate::Stages' has a wrong offset!");
static_assert(offsetof(UGzTrialTemplate, TrackerCategory) == 0x000050, "Member 'UGzTrialTemplate::TrackerCategory' has a wrong offset!");
static_assert(offsetof(UGzTrialTemplate, TrackerType) == 0x000058, "Member 'UGzTrialTemplate::TrackerType' has a wrong offset!");
static_assert(offsetof(UGzTrialTemplate, MetaTrackerType) == 0x000060, "Member 'UGzTrialTemplate::MetaTrackerType' has a wrong offset!");
static_assert(offsetof(UGzTrialTemplate, bExport) == 0x000061, "Member 'UGzTrialTemplate::bExport' has a wrong offset!");

// Class G01.GzXR_BaseRedeployModifier
// 0x0060 (0x0088 - 0x0028)
class UGzXR_BaseRedeployModifier : public UObject
{
public:
	float                                         TimerModifier;                                     // 0x0028(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bUseCooldown;                                      // 0x002C(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2CF5[0x3];                                     // 0x002D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         CooldownTime;                                      // 0x0030(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2CF6[0x54];                                    // 0x0034(0x0054)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzXR_BaseRedeployModifier">();
	}
	static class UGzXR_BaseRedeployModifier* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzXR_BaseRedeployModifier>();
	}
};
static_assert(alignof(UGzXR_BaseRedeployModifier) == 0x000008, "Wrong alignment on UGzXR_BaseRedeployModifier");
static_assert(sizeof(UGzXR_BaseRedeployModifier) == 0x000088, "Wrong size on UGzXR_BaseRedeployModifier");
static_assert(offsetof(UGzXR_BaseRedeployModifier, TimerModifier) == 0x000028, "Member 'UGzXR_BaseRedeployModifier::TimerModifier' has a wrong offset!");
static_assert(offsetof(UGzXR_BaseRedeployModifier, bUseCooldown) == 0x00002C, "Member 'UGzXR_BaseRedeployModifier::bUseCooldown' has a wrong offset!");
static_assert(offsetof(UGzXR_BaseRedeployModifier, CooldownTime) == 0x000030, "Member 'UGzXR_BaseRedeployModifier::CooldownTime' has a wrong offset!");

// Class G01.GzXR_EnemyKillRedeployModifier
// 0x0028 (0x00B0 - 0x0088)
class UGzXR_EnemyKillRedeployModifier final : public UGzXR_BaseRedeployModifier
{
public:
	struct FGameplayTagContainer                  TagContainer;                                      // 0x0088(0x0020)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2CF7[0x8];                                     // 0x00A8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzXR_EnemyKillRedeployModifier">();
	}
	static class UGzXR_EnemyKillRedeployModifier* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzXR_EnemyKillRedeployModifier>();
	}
};
static_assert(alignof(UGzXR_EnemyKillRedeployModifier) == 0x000008, "Wrong alignment on UGzXR_EnemyKillRedeployModifier");
static_assert(sizeof(UGzXR_EnemyKillRedeployModifier) == 0x0000B0, "Wrong size on UGzXR_EnemyKillRedeployModifier");
static_assert(offsetof(UGzXR_EnemyKillRedeployModifier, TagContainer) == 0x000088, "Member 'UGzXR_EnemyKillRedeployModifier::TagContainer' has a wrong offset!");

// Class G01.GzInteractionCondition
// 0x0018 (0x0040 - 0x0028)
class UGzInteractionCondition : public UObject
{
public:
	class FText                                   FailedConditionText;                               // 0x0028(0x0010)(Edit, BlueprintVisible, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	bool                                          bShouldHideInteractableFocusOnFailure;             // 0x0038(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2CF8[0x7];                                     // 0x0039(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	bool IsAutoInteractionConditionPassed(const class AGzCharacter* InteractedBy, const class AActor* InteractableOwner);
	bool IsInteractionConditionPassed(const class AGzCharacter* InteractedBy, const class AActor* InteractableOwner);

	class AActor* GetOwnerActor() const;
	class UAbilitySystemComponent* GetOwnerASC() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzInteractionCondition">();
	}
	static class UGzInteractionCondition* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzInteractionCondition>();
	}
};
static_assert(alignof(UGzInteractionCondition) == 0x000008, "Wrong alignment on UGzInteractionCondition");
static_assert(sizeof(UGzInteractionCondition) == 0x000040, "Wrong size on UGzInteractionCondition");
static_assert(offsetof(UGzInteractionCondition, FailedConditionText) == 0x000028, "Member 'UGzInteractionCondition::FailedConditionText' has a wrong offset!");
static_assert(offsetof(UGzInteractionCondition, bShouldHideInteractableFocusOnFailure) == 0x000038, "Member 'UGzInteractionCondition::bShouldHideInteractableFocusOnFailure' has a wrong offset!");

// Class G01.GzAchievementTemplate
// 0x0000 (0x0068 - 0x0068)
class UGzAchievementTemplate final : public UGzTrialTemplate
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzAchievementTemplate">();
	}
	static class UGzAchievementTemplate* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzAchievementTemplate>();
	}
};
static_assert(alignof(UGzAchievementTemplate) == 0x000008, "Wrong alignment on UGzAchievementTemplate");
static_assert(sizeof(UGzAchievementTemplate) == 0x000068, "Wrong size on UGzAchievementTemplate");

// Class G01.GzComebackArenaStart
// 0x0008 (0x02D8 - 0x02D0)
class AGzComebackArenaStart final : public APlayerStart
{
public:
	int32                                         ComebackArenaStartTeamIndex;                       // 0x02D0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2CFB[0x4];                                     // 0x02D4(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzComebackArenaStart">();
	}
	static class AGzComebackArenaStart* GetDefaultObj()
	{
		return GetDefaultObjImpl<AGzComebackArenaStart>();
	}
};
static_assert(alignof(AGzComebackArenaStart) == 0x000008, "Wrong alignment on AGzComebackArenaStart");
static_assert(sizeof(AGzComebackArenaStart) == 0x0002D8, "Wrong size on AGzComebackArenaStart");
static_assert(offsetof(AGzComebackArenaStart, ComebackArenaStartTeamIndex) == 0x0002D0, "Member 'AGzComebackArenaStart::ComebackArenaStartTeamIndex' has a wrong offset!");

// Class G01.GzStateAction
// 0x0010 (0x0038 - 0x0028)
class UGzStateAction : public UObject
{
public:
	uint8                                         Pad_2CFC[0x3];                                     // 0x0028(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	uint8                                         NetExecution;                                      // 0x002B(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bOverrideActivationState;                          // 0x002C(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EGzGA_ActivationState                         OverridenActivationState;                          // 0x002D(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsActive;                                         // 0x002E(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2CFD[0x1];                                     // 0x002F(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	class UGzGameplayAbility*                     OwningAbility;                                     // 0x0030(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	bool CheckNetExecutionMode(const struct FGameplayAbilityActorInfo& ActorInfo);
	bool K2_CanActivate(const class UGzGameplayAbility* GameplayAbility, const struct FGameplayAbilityActorInfo& ActorInfo);
	bool K2_OnActivate(class UGzGameplayAbility* GameplayAbility, const struct FGameplayAbilityActorInfo& ActorInfo);
	bool K2_OnDeactivate(class UGzGameplayAbility* GameplayAbility, const struct FGameplayAbilityActorInfo& ActorInfo);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzStateAction">();
	}
	static class UGzStateAction* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzStateAction>();
	}
};
static_assert(alignof(UGzStateAction) == 0x000008, "Wrong alignment on UGzStateAction");
static_assert(sizeof(UGzStateAction) == 0x000038, "Wrong size on UGzStateAction");
static_assert(offsetof(UGzStateAction, NetExecution) == 0x00002B, "Member 'UGzStateAction::NetExecution' has a wrong offset!");
static_assert(offsetof(UGzStateAction, bOverrideActivationState) == 0x00002C, "Member 'UGzStateAction::bOverrideActivationState' has a wrong offset!");
static_assert(offsetof(UGzStateAction, OverridenActivationState) == 0x00002D, "Member 'UGzStateAction::OverridenActivationState' has a wrong offset!");
static_assert(offsetof(UGzStateAction, bIsActive) == 0x00002E, "Member 'UGzStateAction::bIsActive' has a wrong offset!");
static_assert(offsetof(UGzStateAction, OwningAbility) == 0x000030, "Member 'UGzStateAction::OwningAbility' has a wrong offset!");

// Class G01.GzSA_ActionOnTimer
// 0x0048 (0x0080 - 0x0038)
class UGzSA_ActionOnTimer final : public UGzStateAction
{
public:
	float                                         StateDuration;                                     // 0x0038(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2D02[0x4];                                     // 0x003C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UGzStateAction*                         Action;                                            // 0x0040(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, Protected, PersistentInstance, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bCancelOnEvent;                                    // 0x0048(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2D03[0x7];                                     // 0x0049(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTagContainer                  EventTags;                                         // 0x0050(0x0020)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FTimerHandle                           WaitStateActiveTimer;                              // 0x0070(0x0008)(Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UGzAT_WaitGameplayEventAny*             WaitEventTask;                                     // 0x0078(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void OnEvent(const struct FGameplayEventData& TriggerEventData);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzSA_ActionOnTimer">();
	}
	static class UGzSA_ActionOnTimer* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzSA_ActionOnTimer>();
	}
};
static_assert(alignof(UGzSA_ActionOnTimer) == 0x000008, "Wrong alignment on UGzSA_ActionOnTimer");
static_assert(sizeof(UGzSA_ActionOnTimer) == 0x000080, "Wrong size on UGzSA_ActionOnTimer");
static_assert(offsetof(UGzSA_ActionOnTimer, StateDuration) == 0x000038, "Member 'UGzSA_ActionOnTimer::StateDuration' has a wrong offset!");
static_assert(offsetof(UGzSA_ActionOnTimer, Action) == 0x000040, "Member 'UGzSA_ActionOnTimer::Action' has a wrong offset!");
static_assert(offsetof(UGzSA_ActionOnTimer, bCancelOnEvent) == 0x000048, "Member 'UGzSA_ActionOnTimer::bCancelOnEvent' has a wrong offset!");
static_assert(offsetof(UGzSA_ActionOnTimer, EventTags) == 0x000050, "Member 'UGzSA_ActionOnTimer::EventTags' has a wrong offset!");
static_assert(offsetof(UGzSA_ActionOnTimer, WaitStateActiveTimer) == 0x000070, "Member 'UGzSA_ActionOnTimer::WaitStateActiveTimer' has a wrong offset!");
static_assert(offsetof(UGzSA_ActionOnTimer, WaitEventTask) == 0x000078, "Member 'UGzSA_ActionOnTimer::WaitEventTask' has a wrong offset!");

// Class G01.GzActionRouter
// 0x0000 (0x0170 - 0x0170)
class UGzActionRouter final : public UCommonUIActionRouterBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzActionRouter">();
	}
	static class UGzActionRouter* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzActionRouter>();
	}
};
static_assert(alignof(UGzActionRouter) == 0x000008, "Wrong alignment on UGzActionRouter");
static_assert(sizeof(UGzActionRouter) == 0x000170, "Wrong size on UGzActionRouter");

// Class G01.GzActionWidget
// 0x01E0 (0x0670 - 0x0490)
class UGzActionWidget final : public UCommonActionWidget
{
public:
	class UInputAction*                           AssociatedInputAction;                             // 0x0488(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2D04[0x1C0];                                   // 0x0490(0x01C0)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTag                           CurrentState;                                      // 0x0650(0x0008)(Edit, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FGameplayTag                           Theme;                                             // 0x0658(0x0008)(Edit, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bAsHoldAction;                                     // 0x0660(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2D05[0xF];                                     // 0x0661(0x000F)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void RefreshIcon();
	void SetActionProgress(float ProgressValue);
	void SetAlwaysHide(const bool bHide);
	void SetAsHoldAction(bool bInAsHoldAction);
	void SetAssociatedInputAction(class UInputAction* NewInputAction);
	void SetState(const struct FGameplayTag& InState);
	void SetTheme(const struct FGameplayTag& ThemeTag);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzActionWidget">();
	}
	static class UGzActionWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzActionWidget>();
	}
};
static_assert(alignof(UGzActionWidget) == 0x000010, "Wrong alignment on UGzActionWidget");
static_assert(sizeof(UGzActionWidget) == 0x000670, "Wrong size on UGzActionWidget");
static_assert(offsetof(UGzActionWidget, AssociatedInputAction) == 0x000488, "Member 'UGzActionWidget::AssociatedInputAction' has a wrong offset!");
static_assert(offsetof(UGzActionWidget, CurrentState) == 0x000650, "Member 'UGzActionWidget::CurrentState' has a wrong offset!");
static_assert(offsetof(UGzActionWidget, Theme) == 0x000658, "Member 'UGzActionWidget::Theme' has a wrong offset!");
static_assert(offsetof(UGzActionWidget, bAsHoldAction) == 0x000660, "Member 'UGzActionWidget::bAsHoldAction' has a wrong offset!");

// Class G01.GzGA_ToggleSprint
// 0x0008 (0x0558 - 0x0550)
class UGzGA_ToggleSprint : public UGzGA_CharacterState
{
public:
	class UGzAT_WatchToggleSprintConditions*      WatchToggleSprintConditionsTask;                   // 0x0550(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void OnFinish();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzGA_ToggleSprint">();
	}
	static class UGzGA_ToggleSprint* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzGA_ToggleSprint>();
	}
};
static_assert(alignof(UGzGA_ToggleSprint) == 0x000008, "Wrong alignment on UGzGA_ToggleSprint");
static_assert(sizeof(UGzGA_ToggleSprint) == 0x000558, "Wrong size on UGzGA_ToggleSprint");
static_assert(offsetof(UGzGA_ToggleSprint, WatchToggleSprintConditionsTask) == 0x000550, "Member 'UGzGA_ToggleSprint::WatchToggleSprintConditionsTask' has a wrong offset!");

// Class G01.GzCohtmlUserWidget
// 0x0078 (0x0358 - 0x02E0)
class UGzCohtmlUserWidget final : public UUserWidget
{
public:
	class AGzUIDataSystem*                        UIDataSystem;                                      // 0x02E0(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UGzCohtmlWidget*                        CohtmlWidget;                                      // 0x02E8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UImage*                                 Background;                                        // 0x02F0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TMap<class FString, class UMaterialInterface*> Materials;                                         // 0x02F8(0x0050)(NativeAccessSpecifierPrivate)
	class UGzGamefaceSettings*                    GamefaceSettings;                                  // 0x0348(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSubclassOf<class AGzUIDataSystem>            DataSystemType;                                    // 0x0350(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void AllowTriggerEvents();
	void DeinitializeCohtmlUI();
	void NotifyPawnChange(class APawn* Pawn);
	void SetupCohtmlUI();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzCohtmlUserWidget">();
	}
	static class UGzCohtmlUserWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzCohtmlUserWidget>();
	}
};
static_assert(alignof(UGzCohtmlUserWidget) == 0x000008, "Wrong alignment on UGzCohtmlUserWidget");
static_assert(sizeof(UGzCohtmlUserWidget) == 0x000358, "Wrong size on UGzCohtmlUserWidget");
static_assert(offsetof(UGzCohtmlUserWidget, UIDataSystem) == 0x0002E0, "Member 'UGzCohtmlUserWidget::UIDataSystem' has a wrong offset!");
static_assert(offsetof(UGzCohtmlUserWidget, CohtmlWidget) == 0x0002E8, "Member 'UGzCohtmlUserWidget::CohtmlWidget' has a wrong offset!");
static_assert(offsetof(UGzCohtmlUserWidget, Background) == 0x0002F0, "Member 'UGzCohtmlUserWidget::Background' has a wrong offset!");
static_assert(offsetof(UGzCohtmlUserWidget, Materials) == 0x0002F8, "Member 'UGzCohtmlUserWidget::Materials' has a wrong offset!");
static_assert(offsetof(UGzCohtmlUserWidget, GamefaceSettings) == 0x000348, "Member 'UGzCohtmlUserWidget::GamefaceSettings' has a wrong offset!");
static_assert(offsetof(UGzCohtmlUserWidget, DataSystemType) == 0x000350, "Member 'UGzCohtmlUserWidget::DataSystemType' has a wrong offset!");

// Class G01.GzActivatableStateAction
// 0x0008 (0x0040 - 0x0038)
class UGzActivatableStateAction : public UGzStateAction
{
public:
	EGzGA_ActivationState                         ActivationType;                                    // 0x0038(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2D06[0x7];                                     // 0x0039(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzActivatableStateAction">();
	}
	static class UGzActivatableStateAction* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzActivatableStateAction>();
	}
};
static_assert(alignof(UGzActivatableStateAction) == 0x000008, "Wrong alignment on UGzActivatableStateAction");
static_assert(sizeof(UGzActivatableStateAction) == 0x000040, "Wrong size on UGzActivatableStateAction");
static_assert(offsetof(UGzActivatableStateAction, ActivationType) == 0x000038, "Member 'UGzActivatableStateAction::ActivationType' has a wrong offset!");

// Class G01.GzWeaponBehaviorAttachment
// 0x0010 (0x0038 - 0x0028)
class UGzWeaponBehaviorAttachment : public UObject
{
public:
	class AGzWeaponActor*                         WeaponOwner;                                       // 0x0028(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bInitialized;                                      // 0x0030(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2D07[0x7];                                     // 0x0031(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	bool GetHiden();
	void Hide(bool bHide);
	void Initialize();
	void OnDestroy();
	void OnEquipped();
	void OnHide(bool bHide);
	void OnHolstered();

	void OnUpdate() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzWeaponBehaviorAttachment">();
	}
	static class UGzWeaponBehaviorAttachment* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzWeaponBehaviorAttachment>();
	}
};
static_assert(alignof(UGzWeaponBehaviorAttachment) == 0x000008, "Wrong alignment on UGzWeaponBehaviorAttachment");
static_assert(sizeof(UGzWeaponBehaviorAttachment) == 0x000038, "Wrong size on UGzWeaponBehaviorAttachment");
static_assert(offsetof(UGzWeaponBehaviorAttachment, WeaponOwner) == 0x000028, "Member 'UGzWeaponBehaviorAttachment::WeaponOwner' has a wrong offset!");
static_assert(offsetof(UGzWeaponBehaviorAttachment, bInitialized) == 0x000030, "Member 'UGzWeaponBehaviorAttachment::bInitialized' has a wrong offset!");

// Class G01.GzNotificationService
// 0x0280 (0x0320 - 0x00A0)
class UGzNotificationService final : public UGzClientPFObject
{
public:
	uint8                                         Pad_2D08[0x280];                                   // 0x00A0(0x0280)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzNotificationService">();
	}
	static class UGzNotificationService* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzNotificationService>();
	}
};
static_assert(alignof(UGzNotificationService) == 0x000008, "Wrong alignment on UGzNotificationService");
static_assert(sizeof(UGzNotificationService) == 0x000320, "Wrong size on UGzNotificationService");

// Class G01.GzClientAchievementService
// 0x0028 (0x00C8 - 0x00A0)
class UGzClientAchievementService final : public UGzPlayFabObject
{
public:
	uint8                                         Pad_2D09[0x18];                                    // 0x00A0(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FGzMetaAchievementState>        PlayerAchievementsState;                           // 0x00B8(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzClientAchievementService">();
	}
	static class UGzClientAchievementService* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzClientAchievementService>();
	}
};
static_assert(alignof(UGzClientAchievementService) == 0x000008, "Wrong alignment on UGzClientAchievementService");
static_assert(sizeof(UGzClientAchievementService) == 0x0000C8, "Wrong size on UGzClientAchievementService");
static_assert(offsetof(UGzClientAchievementService, PlayerAchievementsState) == 0x0000B8, "Member 'UGzClientAchievementService::PlayerAchievementsState' has a wrong offset!");

// Class G01.GzActivatableWidgetStack
// 0x0000 (0x02B0 - 0x02B0)
class UGzActivatableWidgetStack final : public UCommonActivatableWidgetStack
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzActivatableWidgetStack">();
	}
	static class UGzActivatableWidgetStack* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzActivatableWidgetStack>();
	}
};
static_assert(alignof(UGzActivatableWidgetStack) == 0x000008, "Wrong alignment on UGzActivatableWidgetStack");
static_assert(sizeof(UGzActivatableWidgetStack) == 0x0002B0, "Wrong size on UGzActivatableWidgetStack");

// Class G01.GzAdvancedCameraParamsComponent
// 0x0070 (0x06C0 - 0x0650)
class UGzAdvancedCameraParamsComponent : public UATPCCameraComponent
{
public:
	TArray<class UGzCameraOverlayModeDataAsset*>  OverlayCameraModesAssets;                          // 0x0648(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	TMap<struct FGameplayTag, class UGzCameraOverlayModeDataAsset*> SortedOverlayCameraModes;                          // 0x0658(0x0050)(Protected, NativeAccessSpecifierProtected)
	TSubclassOf<class UGzCameraOverlayLocationObject> OverlayLocationObjectClass;                        // 0x06A8(0x0008)(Edit, ZeroConstructor, NoClear, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UGzCameraOverlayLocationObject*         OverlayLocationObject;                             // 0x06B0(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bCurrentCameraModeLocked;                          // 0x06B8(0x0001)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2D0A[0x7];                                     // 0x06B9(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void LockCurrentCameraMode();
	void ResetOverlayCameraMode(bool bWithInterpolation);
	void SetOverlayCameraDistance(float Distance, bool bWithInterpolation);
	void SetOverlayCameraMode(const struct FGameplayTag& CameraModeTag, bool bWithInterpolation);
	void SetOverlayCameraModeManually(class UGzCameraOverlayModeDataAsset* OverlayCameraMode, bool bWithInterpolation);
	void UnlockCurrentCameraMode();

	class UGzCameraOverlayModeDataAsset* GetOverlayCameraModeFromTag(const struct FGameplayTag& CameraModeTag) const;
	class UGzCameraOverlayLocationObject* GetOverlayLocationObject() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzAdvancedCameraParamsComponent">();
	}
	static class UGzAdvancedCameraParamsComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzAdvancedCameraParamsComponent>();
	}
};
static_assert(alignof(UGzAdvancedCameraParamsComponent) == 0x000010, "Wrong alignment on UGzAdvancedCameraParamsComponent");
static_assert(sizeof(UGzAdvancedCameraParamsComponent) == 0x0006C0, "Wrong size on UGzAdvancedCameraParamsComponent");
static_assert(offsetof(UGzAdvancedCameraParamsComponent, OverlayCameraModesAssets) == 0x000648, "Member 'UGzAdvancedCameraParamsComponent::OverlayCameraModesAssets' has a wrong offset!");
static_assert(offsetof(UGzAdvancedCameraParamsComponent, SortedOverlayCameraModes) == 0x000658, "Member 'UGzAdvancedCameraParamsComponent::SortedOverlayCameraModes' has a wrong offset!");
static_assert(offsetof(UGzAdvancedCameraParamsComponent, OverlayLocationObjectClass) == 0x0006A8, "Member 'UGzAdvancedCameraParamsComponent::OverlayLocationObjectClass' has a wrong offset!");
static_assert(offsetof(UGzAdvancedCameraParamsComponent, OverlayLocationObject) == 0x0006B0, "Member 'UGzAdvancedCameraParamsComponent::OverlayLocationObject' has a wrong offset!");
static_assert(offsetof(UGzAdvancedCameraParamsComponent, bCurrentCameraModeLocked) == 0x0006B8, "Member 'UGzAdvancedCameraParamsComponent::bCurrentCameraModeLocked' has a wrong offset!");

// Class G01.GzColorPalette
// 0x0010 (0x0040 - 0x0030)
class UGzColorPalette final : public UPrimaryDataAsset
{
public:
	TArray<struct FLinearColor>                   Colors;                                            // 0x0030(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzColorPalette">();
	}
	static class UGzColorPalette* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzColorPalette>();
	}
};
static_assert(alignof(UGzColorPalette) == 0x000008, "Wrong alignment on UGzColorPalette");
static_assert(sizeof(UGzColorPalette) == 0x000040, "Wrong size on UGzColorPalette");
static_assert(offsetof(UGzColorPalette, Colors) == 0x000030, "Member 'UGzColorPalette::Colors' has a wrong offset!");

// Class G01.GzAdvancedMission
// 0x0080 (0x0320 - 0x02A0)
class AGzAdvancedMission final : public AInfo
{
public:
	FMulticastInlineDelegateProperty_             MissionStateChanged;                               // 0x02A0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             PlayerJoined;                                      // 0x02B0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             PlayerLeft;                                        // 0x02C0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	class UGzMissionData*                         MissionData;                                       // 0x02D0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EGzMissionGroupType                           GroupType;                                         // 0x02D8(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2D0E[0x3];                                     // 0x02D9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRandomStream                          RandomStream;                                      // 0x02DC(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_2D0F[0x4];                                     // 0x02E4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class AGzAdvancedMission*                     Template;                                          // 0x02E8(0x0008)(Net, ZeroConstructor, Transient, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         RuntimeId;                                         // 0x02F0(0x0004)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         GroupID;                                           // 0x02F4(0x0004)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	EGzMissionState                               MissionState;                                      // 0x02F8(0x0001)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2D10[0x3];                                     // 0x02F9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         MissionSeed;                                       // 0x02FC(0x0004)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<class UGzMissionTask*>                 MissionTasks;                                      // 0x0300(0x0010)(Net, ZeroConstructor, RepNotify, NativeAccessSpecifierPrivate)
	class UGzObjective*                           RootObjective;                                     // 0x0310(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2D11[0x8];                                     // 0x0318(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	class UGzObjective* BuildObjectiveGraph();
	class UGzMissionTask* CreateOrSyncTask(const class UClass* TaskClass);
	void OnRep_MissionSeed();
	void OnRep_MissionState();
	void OnRep_MissionTasks();
	void OnRep_Template();
	void StartMission();
	void StartTracking();

	const class FText GetMissionName() const;
	EGzMissionState GetMissionState() const;
	bool IsTracked() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzAdvancedMission">();
	}
	static class AGzAdvancedMission* GetDefaultObj()
	{
		return GetDefaultObjImpl<AGzAdvancedMission>();
	}
};
static_assert(alignof(AGzAdvancedMission) == 0x000008, "Wrong alignment on AGzAdvancedMission");
static_assert(sizeof(AGzAdvancedMission) == 0x000320, "Wrong size on AGzAdvancedMission");
static_assert(offsetof(AGzAdvancedMission, MissionStateChanged) == 0x0002A0, "Member 'AGzAdvancedMission::MissionStateChanged' has a wrong offset!");
static_assert(offsetof(AGzAdvancedMission, PlayerJoined) == 0x0002B0, "Member 'AGzAdvancedMission::PlayerJoined' has a wrong offset!");
static_assert(offsetof(AGzAdvancedMission, PlayerLeft) == 0x0002C0, "Member 'AGzAdvancedMission::PlayerLeft' has a wrong offset!");
static_assert(offsetof(AGzAdvancedMission, MissionData) == 0x0002D0, "Member 'AGzAdvancedMission::MissionData' has a wrong offset!");
static_assert(offsetof(AGzAdvancedMission, GroupType) == 0x0002D8, "Member 'AGzAdvancedMission::GroupType' has a wrong offset!");
static_assert(offsetof(AGzAdvancedMission, RandomStream) == 0x0002DC, "Member 'AGzAdvancedMission::RandomStream' has a wrong offset!");
static_assert(offsetof(AGzAdvancedMission, Template) == 0x0002E8, "Member 'AGzAdvancedMission::Template' has a wrong offset!");
static_assert(offsetof(AGzAdvancedMission, RuntimeId) == 0x0002F0, "Member 'AGzAdvancedMission::RuntimeId' has a wrong offset!");
static_assert(offsetof(AGzAdvancedMission, GroupID) == 0x0002F4, "Member 'AGzAdvancedMission::GroupID' has a wrong offset!");
static_assert(offsetof(AGzAdvancedMission, MissionState) == 0x0002F8, "Member 'AGzAdvancedMission::MissionState' has a wrong offset!");
static_assert(offsetof(AGzAdvancedMission, MissionSeed) == 0x0002FC, "Member 'AGzAdvancedMission::MissionSeed' has a wrong offset!");
static_assert(offsetof(AGzAdvancedMission, MissionTasks) == 0x000300, "Member 'AGzAdvancedMission::MissionTasks' has a wrong offset!");
static_assert(offsetof(AGzAdvancedMission, RootObjective) == 0x000310, "Member 'AGzAdvancedMission::RootObjective' has a wrong offset!");

// Class G01.GzWeaponModifier
// 0x0000 (0x0028 - 0x0028)
class UGzWeaponModifier : public UObject
{
public:
	bool ApplyModifier(class UGzWeaponComponent* WeaponComponent) const;
	bool IsEquipModifier() const;
	bool IsServerOnlyModifier() const;
	bool RemoveModifier(class UGzWeaponComponent* WeaponComponent) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzWeaponModifier">();
	}
	static class UGzWeaponModifier* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzWeaponModifier>();
	}
};
static_assert(alignof(UGzWeaponModifier) == 0x000008, "Wrong alignment on UGzWeaponModifier");
static_assert(sizeof(UGzWeaponModifier) == 0x000028, "Wrong size on UGzWeaponModifier");

// Class G01.GzWeaponAimModifier
// 0x0000 (0x0028 - 0x0028)
class UGzWeaponAimModifier : public UGzWeaponModifier
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzWeaponAimModifier">();
	}
	static class UGzWeaponAimModifier* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzWeaponAimModifier>();
	}
};
static_assert(alignof(UGzWeaponAimModifier) == 0x000008, "Wrong alignment on UGzWeaponAimModifier");
static_assert(sizeof(UGzWeaponAimModifier) == 0x000028, "Wrong size on UGzWeaponAimModifier");

// Class G01.GzGoalData
// 0x0058 (0x0088 - 0x0030)
class UGzGoalData final : public UPrimaryDataAsset
{
public:
	uint8                                         Pad_2D14[0x8];                                     // 0x0030(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   Name_GzGoalData;                                   // 0x0038(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	class FText                                   Description;                                       // 0x0048(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TArray<class UGzGoalData*>                    BlockedBy;                                         // 0x0058(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TArray<struct FGzJobSequenceData>             JobSequences;                                      // 0x0068(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TArray<class UGzRewardData*>                  Rewards;                                           // 0x0078(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzGoalData">();
	}
	static class UGzGoalData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzGoalData>();
	}
};
static_assert(alignof(UGzGoalData) == 0x000008, "Wrong alignment on UGzGoalData");
static_assert(sizeof(UGzGoalData) == 0x000088, "Wrong size on UGzGoalData");
static_assert(offsetof(UGzGoalData, Name_GzGoalData) == 0x000038, "Member 'UGzGoalData::Name_GzGoalData' has a wrong offset!");
static_assert(offsetof(UGzGoalData, Description) == 0x000048, "Member 'UGzGoalData::Description' has a wrong offset!");
static_assert(offsetof(UGzGoalData, BlockedBy) == 0x000058, "Member 'UGzGoalData::BlockedBy' has a wrong offset!");
static_assert(offsetof(UGzGoalData, JobSequences) == 0x000068, "Member 'UGzGoalData::JobSequences' has a wrong offset!");
static_assert(offsetof(UGzGoalData, Rewards) == 0x000078, "Member 'UGzGoalData::Rewards' has a wrong offset!");

// Class G01.GzAIActivateAbilityAsyncTaskBlueprintProxy
// 0x0060 (0x0088 - 0x0028)
class UGzAIActivateAbilityAsyncTaskBlueprintProxy final : public UObject
{
public:
	FMulticastInlineDelegateProperty_             OnEnd;                                             // 0x0028(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnCancel;                                          // 0x0038(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnFail;                                            // 0x0048(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_2D15[0x30];                                    // 0x0058(0x0030)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UGzAIActivateAbilityAsyncTaskBlueprintProxy* CreateActivateAbilityMontageProxyObject(class APawn* InPawn, TSubclassOf<class UGameplayAbility> InAbilityToActivate, class UAnimMontage* AnimMontage, class FName StartSection);
	static class UGzAIActivateAbilityAsyncTaskBlueprintProxy* CreateActivateAbilityProxyObject(class APawn* InPawn, TSubclassOf<class UGameplayAbility> InAbilityToActivate);
	static class UGzAIActivateAbilityAsyncTaskBlueprintProxy* CreateActivateAbilityProxyObjectFull(class APawn* InPawn, TSubclassOf<class UGameplayAbility> InAbilityToActivate, class AActor* Target, class UObject* OptionalObject, class UObject* OptionalObject2);
	static class UGzAIActivateAbilityAsyncTaskBlueprintProxy* CreateActivateAbilityProxyObjectWithTarget(class APawn* InPawn, TSubclassOf<class UGameplayAbility> InAbilityToActivate, class AActor* Target);

	void EndTask();
	void OAIActivayeAbilitySimpleDelegate__DelegateSignature();
	void OnGameAbilityEnded(const struct FAbilityEndedData& AbilityEndedData);
	void OnGameAbilityFail();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzAIActivateAbilityAsyncTaskBlueprintProxy">();
	}
	static class UGzAIActivateAbilityAsyncTaskBlueprintProxy* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzAIActivateAbilityAsyncTaskBlueprintProxy>();
	}
};
static_assert(alignof(UGzAIActivateAbilityAsyncTaskBlueprintProxy) == 0x000008, "Wrong alignment on UGzAIActivateAbilityAsyncTaskBlueprintProxy");
static_assert(sizeof(UGzAIActivateAbilityAsyncTaskBlueprintProxy) == 0x000088, "Wrong size on UGzAIActivateAbilityAsyncTaskBlueprintProxy");
static_assert(offsetof(UGzAIActivateAbilityAsyncTaskBlueprintProxy, OnEnd) == 0x000028, "Member 'UGzAIActivateAbilityAsyncTaskBlueprintProxy::OnEnd' has a wrong offset!");
static_assert(offsetof(UGzAIActivateAbilityAsyncTaskBlueprintProxy, OnCancel) == 0x000038, "Member 'UGzAIActivateAbilityAsyncTaskBlueprintProxy::OnCancel' has a wrong offset!");
static_assert(offsetof(UGzAIActivateAbilityAsyncTaskBlueprintProxy, OnFail) == 0x000048, "Member 'UGzAIActivateAbilityAsyncTaskBlueprintProxy::OnFail' has a wrong offset!");

// Class G01.GzMissionTask
// 0x0018 (0x0040 - 0x0028)
class UGzMissionTask : public UObject
{
public:
	struct FGzMarkerContainer                     MarkerContainer;                                   // 0x0028(0x0018)(NativeAccessSpecifierPrivate)

public:
	void FlushNetDormancyOnMission();
	void OnActivateAuthority_BP();
	void OnDeactivateAuthority_BP();
	void OnInitAuthority_BP();
	void OnInitClient_BP();
	void RegisterMarker(class AGzMissionMarker* Marker);
	void UnregisterMarker(int32 Param_Index);

	const struct FGzMissionGroup GetGroupChecked() const;
	int32 GetGroupId() const;
	class AGzAdvancedMission* GetMissionChecked() const;
	bool HasAuthority() const;
	bool HasGroupMember(const int32 PlayerId) const;
	bool IsRunningOnClient() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzMissionTask">();
	}
	static class UGzMissionTask* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzMissionTask>();
	}
};
static_assert(alignof(UGzMissionTask) == 0x000008, "Wrong alignment on UGzMissionTask");
static_assert(sizeof(UGzMissionTask) == 0x000040, "Wrong size on UGzMissionTask");
static_assert(offsetof(UGzMissionTask, MarkerContainer) == 0x000028, "Member 'UGzMissionTask::MarkerContainer' has a wrong offset!");

// Class G01.GzObjective
// 0x0020 (0x0060 - 0x0040)
class UGzObjective : public UGzMissionTask
{
public:
	uint8                                         Pad_2D17[0x18];                                    // 0x0040(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	EGzObjectiveState                             State;                                             // 0x0058(0x0001)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2D18[0x7];                                     // 0x0059(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnRep_State();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzObjective">();
	}
	static class UGzObjective* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzObjective>();
	}
};
static_assert(alignof(UGzObjective) == 0x000008, "Wrong alignment on UGzObjective");
static_assert(sizeof(UGzObjective) == 0x000060, "Wrong size on UGzObjective");
static_assert(offsetof(UGzObjective, State) == 0x000058, "Member 'UGzObjective::State' has a wrong offset!");

// Class G01.GzCompletedObjective
// 0x0000 (0x0060 - 0x0060)
class UGzCompletedObjective final : public UGzObjective
{
public:
	static class UGzObjective* MakeCompletedObjective(class AGzAdvancedMission* Mission);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzCompletedObjective">();
	}
	static class UGzCompletedObjective* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzCompletedObjective>();
	}
};
static_assert(alignof(UGzCompletedObjective) == 0x000008, "Wrong alignment on UGzCompletedObjective");
static_assert(sizeof(UGzCompletedObjective) == 0x000060, "Wrong size on UGzCompletedObjective");

// Class G01.GzSettingEntryWidget
// 0x0020 (0x0328 - 0x0308)
class UGzSettingEntryWidget : public UCommonUserWidget
{
public:
	uint8                                         Pad_2D19[0x8];                                     // 0x0308(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UGameSetting*                           Setting;                                           // 0x0310(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             SettingNameText;                                   // 0x0318(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2D1A[0x8];                                     // 0x0320(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzSettingEntryWidget">();
	}
	static class UGzSettingEntryWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzSettingEntryWidget>();
	}
};
static_assert(alignof(UGzSettingEntryWidget) == 0x000008, "Wrong alignment on UGzSettingEntryWidget");
static_assert(sizeof(UGzSettingEntryWidget) == 0x000328, "Wrong size on UGzSettingEntryWidget");
static_assert(offsetof(UGzSettingEntryWidget, Setting) == 0x000310, "Member 'UGzSettingEntryWidget::Setting' has a wrong offset!");
static_assert(offsetof(UGzSettingEntryWidget, SettingNameText) == 0x000318, "Member 'UGzSettingEntryWidget::SettingNameText' has a wrong offset!");

// Class G01.GzAutotestComponent
// 0x0050 (0x00F8 - 0x00A8)
class UGzAutotestComponent : public UActorComponent
{
public:
	FMulticastSparseDelegateProperty_             OnAutotestComponentStateChanged;                   // 0x00A8(0x0001)(InstancedReference, BlueprintAssignable, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_2D1B[0x3];                                     // 0x00A9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   TriggerNameStart;                                  // 0x00AC(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   PathToTriggerStart;                                // 0x00B4(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2D1C[0x4];                                     // 0x00BC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UShapeComponent*                        TriggerStart;                                      // 0x00C0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TWeakObjectPtr<class ACharacter>              Character;                                         // 0x00C8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ExecutionMaxTime;                                  // 0x00D0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2D1D[0x4];                                     // 0x00D4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UGzCheatManager*                        CheatManagerPtr;                                   // 0x00D8(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2D1E[0x18];                                    // 0x00E0(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AppendBlueprintCommandDetailedLog(const class FString& DetailedLog);
	void FinishCommand();
	void InitializeTriggers(const class AActor* Owner);
	void OnCharacterBeginOverlap(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const struct FHitResult& SweepResult);
	void OnStateChanged(EGzAutotestComponentState CommandComponentState);
	bool PrepareCommand();
	void ResetCommand();
	bool StartCommand();
	void StopCommand();
	void UpdateTimer(float DeltaTime);

	class UGzCheatManager* GetCheatManager() const;
	EGzAutotestComponentState GetCommandState() const;
	class FString GetDetailedLog() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzAutotestComponent">();
	}
	static class UGzAutotestComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzAutotestComponent>();
	}
};
static_assert(alignof(UGzAutotestComponent) == 0x000008, "Wrong alignment on UGzAutotestComponent");
static_assert(sizeof(UGzAutotestComponent) == 0x0000F8, "Wrong size on UGzAutotestComponent");
static_assert(offsetof(UGzAutotestComponent, OnAutotestComponentStateChanged) == 0x0000A8, "Member 'UGzAutotestComponent::OnAutotestComponentStateChanged' has a wrong offset!");
static_assert(offsetof(UGzAutotestComponent, TriggerNameStart) == 0x0000AC, "Member 'UGzAutotestComponent::TriggerNameStart' has a wrong offset!");
static_assert(offsetof(UGzAutotestComponent, PathToTriggerStart) == 0x0000B4, "Member 'UGzAutotestComponent::PathToTriggerStart' has a wrong offset!");
static_assert(offsetof(UGzAutotestComponent, TriggerStart) == 0x0000C0, "Member 'UGzAutotestComponent::TriggerStart' has a wrong offset!");
static_assert(offsetof(UGzAutotestComponent, Character) == 0x0000C8, "Member 'UGzAutotestComponent::Character' has a wrong offset!");
static_assert(offsetof(UGzAutotestComponent, ExecutionMaxTime) == 0x0000D0, "Member 'UGzAutotestComponent::ExecutionMaxTime' has a wrong offset!");
static_assert(offsetof(UGzAutotestComponent, CheatManagerPtr) == 0x0000D8, "Member 'UGzAutotestComponent::CheatManagerPtr' has a wrong offset!");

// Class G01.GzAIAutotestComponent
// 0x0000 (0x00F8 - 0x00F8)
class UGzAIAutotestComponent : public UGzAutotestComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzAIAutotestComponent">();
	}
	static class UGzAIAutotestComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzAIAutotestComponent>();
	}
};
static_assert(alignof(UGzAIAutotestComponent) == 0x000008, "Wrong alignment on UGzAIAutotestComponent");
static_assert(sizeof(UGzAIAutotestComponent) == 0x0000F8, "Wrong size on UGzAIAutotestComponent");

// Class G01.GzCustomizationModifier
// 0x0008 (0x0030 - 0x0028)
class UGzCustomizationModifier : public UObject
{
public:
	uint8                                         Pad_2D20[0x1];                                     // 0x0028(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bUseAsSettings;                                    // 0x0029(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2D21[0x6];                                     // 0x002A(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzCustomizationModifier">();
	}
	static class UGzCustomizationModifier* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzCustomizationModifier>();
	}
};
static_assert(alignof(UGzCustomizationModifier) == 0x000008, "Wrong alignment on UGzCustomizationModifier");
static_assert(sizeof(UGzCustomizationModifier) == 0x000030, "Wrong size on UGzCustomizationModifier");
static_assert(offsetof(UGzCustomizationModifier, bUseAsSettings) == 0x000029, "Member 'UGzCustomizationModifier::bUseAsSettings' has a wrong offset!");

// Class G01.GzCustomizationModifier_Scale
// 0x0018 (0x0048 - 0x0030)
class UGzCustomizationModifier_Scale final : public UGzCustomizationModifier
{
public:
	struct FVector                                Scale;                                             // 0x0030(0x0018)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzCustomizationModifier_Scale">();
	}
	static class UGzCustomizationModifier_Scale* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzCustomizationModifier_Scale>();
	}
};
static_assert(alignof(UGzCustomizationModifier_Scale) == 0x000008, "Wrong alignment on UGzCustomizationModifier_Scale");
static_assert(sizeof(UGzCustomizationModifier_Scale) == 0x000048, "Wrong size on UGzCustomizationModifier_Scale");
static_assert(offsetof(UGzCustomizationModifier_Scale, Scale) == 0x000030, "Member 'UGzCustomizationModifier_Scale::Scale' has a wrong offset!");

// Class G01.GzAIAutotestCommandMoveTo
// 0x0038 (0x0130 - 0x00F8)
class UGzAIAutotestCommandMoveTo final : public UGzAIAutotestComponent
{
public:
	TArray<class FName>                           PatrolPointsName;                                  // 0x00F8(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	TSubclassOf<class AActor>                     PatrolPointClass;                                  // 0x0108(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class UChildActorComponent*>           PatrolPoints;                                      // 0x0110(0x0010)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_2D22[0x10];                                    // 0x0120(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnAIReachedPatrolPoint(class AActor* OverlappedActor, class AActor* OtherActor);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzAIAutotestCommandMoveTo">();
	}
	static class UGzAIAutotestCommandMoveTo* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzAIAutotestCommandMoveTo>();
	}
};
static_assert(alignof(UGzAIAutotestCommandMoveTo) == 0x000008, "Wrong alignment on UGzAIAutotestCommandMoveTo");
static_assert(sizeof(UGzAIAutotestCommandMoveTo) == 0x000130, "Wrong size on UGzAIAutotestCommandMoveTo");
static_assert(offsetof(UGzAIAutotestCommandMoveTo, PatrolPointsName) == 0x0000F8, "Member 'UGzAIAutotestCommandMoveTo::PatrolPointsName' has a wrong offset!");
static_assert(offsetof(UGzAIAutotestCommandMoveTo, PatrolPointClass) == 0x000108, "Member 'UGzAIAutotestCommandMoveTo::PatrolPointClass' has a wrong offset!");
static_assert(offsetof(UGzAIAutotestCommandMoveTo, PatrolPoints) == 0x000110, "Member 'UGzAIAutotestCommandMoveTo::PatrolPoints' has a wrong offset!");

// Class G01.GzHUDComponent
// 0x0060 (0x0340 - 0x02E0)
class UGzHUDComponent : public UUserWidget
{
public:
	uint8                                         Pad_2D23[0x8];                                     // 0x02E0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UGzHUDView*                             View;                                              // 0x02E8(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FGameplayTagContainer                  RequiredTags;                                      // 0x02F0(0x0020)(Edit, NativeAccessSpecifierPrivate)
	struct FGameplayTagContainer                  BlockingTags;                                      // 0x0310(0x0020)(Edit, NativeAccessSpecifierPrivate)
	bool                                          bOverrideVisibilityChanges;                        // 0x0330(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bListenToHUDTags;                                  // 0x0331(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2D24[0x6];                                     // 0x0332(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UGzWE_UITagsAware>          TagsAwareExtensionClass;                           // 0x0338(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void OnViewTargetChanged(class APawn* ViewTarget);
	void ReceiveBindEvents(class APawn* NewViewTarget);
	void ReceiveUnbindEvents(class APawn* OldViewTarget);
	void SubscribeToAttributeChange(const struct FGameplayAttribute& Attribute, TDelegate<void(float NewValue, float OldValue)> OnAttributeChanged);
	void SubscribeToTagChange(const struct FGameplayTag& Tag, TDelegate<void(bool bWasAdded)> OnTagChanged);

	class APawn* GetViewTarget() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzHUDComponent">();
	}
	static class UGzHUDComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzHUDComponent>();
	}
};
static_assert(alignof(UGzHUDComponent) == 0x000008, "Wrong alignment on UGzHUDComponent");
static_assert(sizeof(UGzHUDComponent) == 0x000340, "Wrong size on UGzHUDComponent");
static_assert(offsetof(UGzHUDComponent, View) == 0x0002E8, "Member 'UGzHUDComponent::View' has a wrong offset!");
static_assert(offsetof(UGzHUDComponent, RequiredTags) == 0x0002F0, "Member 'UGzHUDComponent::RequiredTags' has a wrong offset!");
static_assert(offsetof(UGzHUDComponent, BlockingTags) == 0x000310, "Member 'UGzHUDComponent::BlockingTags' has a wrong offset!");
static_assert(offsetof(UGzHUDComponent, bOverrideVisibilityChanges) == 0x000330, "Member 'UGzHUDComponent::bOverrideVisibilityChanges' has a wrong offset!");
static_assert(offsetof(UGzHUDComponent, bListenToHUDTags) == 0x000331, "Member 'UGzHUDComponent::bListenToHUDTags' has a wrong offset!");
static_assert(offsetof(UGzHUDComponent, TagsAwareExtensionClass) == 0x000338, "Member 'UGzHUDComponent::TagsAwareExtensionClass' has a wrong offset!");

// Class G01.GzBaseLogWidget
// 0x0030 (0x0370 - 0x0340)
#pragma pack(push, 0x1)
class alignas(0x10) UGzBaseLogWidget : public UGzHUDComponent
{
public:
	uint8                                         Pad_2D25[0x10];                                    // 0x0340(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class UPanelWidget*                           EntriesContainer;                                  // 0x0350(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         EntriesLimit;                                      // 0x0358(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2D26[0x4];                                     // 0x035C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UGzBaseLogEntryWidget>      LogEntryWidgetClass;                               // 0x0360(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void OnLogEmpty();
	void OnNewEntryEnqueued(class UGzBaseLogEntryWidget* Entry);
	void OnNewEntryShowed(class UGzBaseLogEntryWidget* Entry);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzBaseLogWidget">();
	}
	static class UGzBaseLogWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzBaseLogWidget>();
	}
};
#pragma pack(pop)
static_assert(alignof(UGzBaseLogWidget) == 0x000010, "Wrong alignment on UGzBaseLogWidget");
static_assert(sizeof(UGzBaseLogWidget) == 0x000370, "Wrong size on UGzBaseLogWidget");
static_assert(offsetof(UGzBaseLogWidget, EntriesContainer) == 0x000350, "Member 'UGzBaseLogWidget::EntriesContainer' has a wrong offset!");
static_assert(offsetof(UGzBaseLogWidget, EntriesLimit) == 0x000358, "Member 'UGzBaseLogWidget::EntriesLimit' has a wrong offset!");
static_assert(offsetof(UGzBaseLogWidget, LogEntryWidgetClass) == 0x000360, "Member 'UGzBaseLogWidget::LogEntryWidgetClass' has a wrong offset!");

// Class G01.GzXPLogWidget
// 0x0020 (0x0390 - 0x0370)
class UGzXPLogWidget : public UGzBaseLogWidget
{
public:
	float                                         XPCounter;                                         // 0x0368(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2D27[0x4];                                     // 0x036C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class URichTextBlock*                         XPCounterText;                                     // 0x0370(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FText                                   CounterTextFormat;                                 // 0x0378(0x0010)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2D28[0x8];                                     // 0x0388(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void UpdateLog(int32 PlayerId, const struct FGzGameStat& Stat);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzXPLogWidget">();
	}
	static class UGzXPLogWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzXPLogWidget>();
	}
};
static_assert(alignof(UGzXPLogWidget) == 0x000010, "Wrong alignment on UGzXPLogWidget");
static_assert(sizeof(UGzXPLogWidget) == 0x000390, "Wrong size on UGzXPLogWidget");
static_assert(offsetof(UGzXPLogWidget, XPCounter) == 0x000368, "Member 'UGzXPLogWidget::XPCounter' has a wrong offset!");
static_assert(offsetof(UGzXPLogWidget, XPCounterText) == 0x000370, "Member 'UGzXPLogWidget::XPCounterText' has a wrong offset!");
static_assert(offsetof(UGzXPLogWidget, CounterTextFormat) == 0x000378, "Member 'UGzXPLogWidget::CounterTextFormat' has a wrong offset!");

// Class G01.GzBaseCharacter
// 0x0150 (0x07D0 - 0x0680)
class AGzBaseCharacter : public ACharacter
{
public:
	uint8                                         Pad_2D2A[0x38];                                    // 0x0680(0x0038)(Fixing Size After Last Property [ Dumper-7 ])
	class UGzDamageableComponent*                 DamageableComponent;                               // 0x06B8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UGzAbilitySystemComponent*              AbilitySystemComponent;                            // 0x06C0(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDataTable*                             DefaultAttributesDT;                               // 0x06C8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<TSubclassOf<class UGameplayEffect>>    StartupEffects;                                    // 0x06D0(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	class FName                                   CapsuleCollisionProfileName;                       // 0x06E0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class APlayerState*                           PersistentPlayerState;                             // 0x06E8(0x0008)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, Transient, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FGzNativeCharacterComponentSpec        AkComponentSpec;                                   // 0x06F0(0x0080)(Edit, NoDestructor, Protected, NativeAccessSpecifierProtected)
	class UGzCharacterAkComponent*                AkComponent;                                       // 0x0770(0x0008)(Edit, ExportObject, ZeroConstructor, Transient, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UGzZoneTrackingComponent*               ZoneTrackingComponent;                             // 0x0778(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class UGzBPOnlyCharacterComponentSpec*> BPOnlyComponentSpecs;                              // 0x0780(0x0010)(Edit, ExportObject, ZeroConstructor, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	TSubclassOf<class UGzAITokenComponent>        AITokenComponentClass;                             // 0x0790(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UGzCombatComponent*                     CachedCombatComponent;                             // 0x0798(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UGzEnvironmentZoneManagerComponent*     EnvironmentZoneManager;                            // 0x07A0(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UGzInvComponent*                        InvComponent;                                      // 0x07A8(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UGzAITokenComponent*                    AITokenComponent;                                  // 0x07B0(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FLyraReplicatedAcceleration            ReplicatedAcceleration;                            // 0x07B8(0x0003)(Net, Transient, RepNotify, NoDestructor, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2D2B[0x5];                                     // 0x07BB(0x0005)(Fixing Size After Last Property [ Dumper-7 ])
	FMulticastInlineDelegateProperty_             OnRepPlayerState;                                  // 0x07C0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPrivate)

public:
	class USceneComponent* GetBPComponent(TSubclassOf<class USceneComponent> ComponentClass, const class FName CompName);
	void OnRep_PersistentPlayerState();
	void OnRep_ReplicatedAcceleration();

	const class UGzAliveObjectAttributeSet* GetAliveObjectAttributeSet() const;
	const class UGzAttributeSet* GetAttributeSet() const;
	class UGzCombatComponent* GetCombatComponent() const;
	class UGzAbilitySystemComponent* GetGzAbilitySystemComponent() const;
	class UGzInvComponent* GetInventoryComponent() const;
	bool HasCombatComponent() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzBaseCharacter">();
	}
	static class AGzBaseCharacter* GetDefaultObj()
	{
		return GetDefaultObjImpl<AGzBaseCharacter>();
	}
};
static_assert(alignof(AGzBaseCharacter) == 0x000010, "Wrong alignment on AGzBaseCharacter");
static_assert(sizeof(AGzBaseCharacter) == 0x0007D0, "Wrong size on AGzBaseCharacter");
static_assert(offsetof(AGzBaseCharacter, DamageableComponent) == 0x0006B8, "Member 'AGzBaseCharacter::DamageableComponent' has a wrong offset!");
static_assert(offsetof(AGzBaseCharacter, AbilitySystemComponent) == 0x0006C0, "Member 'AGzBaseCharacter::AbilitySystemComponent' has a wrong offset!");
static_assert(offsetof(AGzBaseCharacter, DefaultAttributesDT) == 0x0006C8, "Member 'AGzBaseCharacter::DefaultAttributesDT' has a wrong offset!");
static_assert(offsetof(AGzBaseCharacter, StartupEffects) == 0x0006D0, "Member 'AGzBaseCharacter::StartupEffects' has a wrong offset!");
static_assert(offsetof(AGzBaseCharacter, CapsuleCollisionProfileName) == 0x0006E0, "Member 'AGzBaseCharacter::CapsuleCollisionProfileName' has a wrong offset!");
static_assert(offsetof(AGzBaseCharacter, PersistentPlayerState) == 0x0006E8, "Member 'AGzBaseCharacter::PersistentPlayerState' has a wrong offset!");
static_assert(offsetof(AGzBaseCharacter, AkComponentSpec) == 0x0006F0, "Member 'AGzBaseCharacter::AkComponentSpec' has a wrong offset!");
static_assert(offsetof(AGzBaseCharacter, AkComponent) == 0x000770, "Member 'AGzBaseCharacter::AkComponent' has a wrong offset!");
static_assert(offsetof(AGzBaseCharacter, ZoneTrackingComponent) == 0x000778, "Member 'AGzBaseCharacter::ZoneTrackingComponent' has a wrong offset!");
static_assert(offsetof(AGzBaseCharacter, BPOnlyComponentSpecs) == 0x000780, "Member 'AGzBaseCharacter::BPOnlyComponentSpecs' has a wrong offset!");
static_assert(offsetof(AGzBaseCharacter, AITokenComponentClass) == 0x000790, "Member 'AGzBaseCharacter::AITokenComponentClass' has a wrong offset!");
static_assert(offsetof(AGzBaseCharacter, CachedCombatComponent) == 0x000798, "Member 'AGzBaseCharacter::CachedCombatComponent' has a wrong offset!");
static_assert(offsetof(AGzBaseCharacter, EnvironmentZoneManager) == 0x0007A0, "Member 'AGzBaseCharacter::EnvironmentZoneManager' has a wrong offset!");
static_assert(offsetof(AGzBaseCharacter, InvComponent) == 0x0007A8, "Member 'AGzBaseCharacter::InvComponent' has a wrong offset!");
static_assert(offsetof(AGzBaseCharacter, AITokenComponent) == 0x0007B0, "Member 'AGzBaseCharacter::AITokenComponent' has a wrong offset!");
static_assert(offsetof(AGzBaseCharacter, ReplicatedAcceleration) == 0x0007B8, "Member 'AGzBaseCharacter::ReplicatedAcceleration' has a wrong offset!");
static_assert(offsetof(AGzBaseCharacter, OnRepPlayerState) == 0x0007C0, "Member 'AGzBaseCharacter::OnRepPlayerState' has a wrong offset!");

// Class G01.GzGameModeObject
// 0x0000 (0x0028 - 0x0028)
class UGzGameModeObject : public UObject
{
public:
	class AGameModeBase* GetGameMode(const TSubclassOf<class AGameModeBase> GameModeClass) const;
	class UGzGameModeSettings* GetGameModeSettings(TSubclassOf<class UGzGameModeSettings> SettingsClass) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzGameModeObject">();
	}
	static class UGzGameModeObject* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzGameModeObject>();
	}
};
static_assert(alignof(UGzGameModeObject) == 0x000008, "Wrong alignment on UGzGameModeObject");
static_assert(sizeof(UGzGameModeObject) == 0x000028, "Wrong size on UGzGameModeObject");

// Class G01.GzGameStageBase
// 0x00E8 (0x0110 - 0x0028)
class UGzGameStageBase : public UGzGameModeObject
{
public:
	class FString                                 DisplayName;                                       // 0x0028(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FGameplayTag                           StageTag;                                          // 0x0038(0x0008)(Edit, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bEndIfAllInnerCompleted;                           // 0x0040(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2D2C[0x7];                                     // 0x0041(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGzRuleSet                             OverrideRules;                                     // 0x0048(0x0040)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	TArray<TSubclassOf<class UGameplayEffect>>    PlayerStartupEffects;                              // 0x0088(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	bool                                          bNewPlayersAllowed;                                // 0x0098(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2D2D[0x7];                                     // 0x0099(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UGzGameStageBase*                       OuterStage;                                        // 0x00A0(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<class UGzGameStageBase*>               InnerStages;                                       // 0x00A8(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	TMap<class FName, class UGzGameStageBase*>    Transitions;                                       // 0x00B8(0x0050)(Transient, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2D2E[0x8];                                     // 0x0108(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ExternalEnd();
	void OnEndStage();
	void OnStartStage();
	void Transition(const class FName& Key);
	void TransitionNext();

	class FString GetDisplayName() const;
	const struct FGameplayTag GetStageTag() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzGameStageBase">();
	}
	static class UGzGameStageBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzGameStageBase>();
	}
};
static_assert(alignof(UGzGameStageBase) == 0x000008, "Wrong alignment on UGzGameStageBase");
static_assert(sizeof(UGzGameStageBase) == 0x000110, "Wrong size on UGzGameStageBase");
static_assert(offsetof(UGzGameStageBase, DisplayName) == 0x000028, "Member 'UGzGameStageBase::DisplayName' has a wrong offset!");
static_assert(offsetof(UGzGameStageBase, StageTag) == 0x000038, "Member 'UGzGameStageBase::StageTag' has a wrong offset!");
static_assert(offsetof(UGzGameStageBase, bEndIfAllInnerCompleted) == 0x000040, "Member 'UGzGameStageBase::bEndIfAllInnerCompleted' has a wrong offset!");
static_assert(offsetof(UGzGameStageBase, OverrideRules) == 0x000048, "Member 'UGzGameStageBase::OverrideRules' has a wrong offset!");
static_assert(offsetof(UGzGameStageBase, PlayerStartupEffects) == 0x000088, "Member 'UGzGameStageBase::PlayerStartupEffects' has a wrong offset!");
static_assert(offsetof(UGzGameStageBase, bNewPlayersAllowed) == 0x000098, "Member 'UGzGameStageBase::bNewPlayersAllowed' has a wrong offset!");
static_assert(offsetof(UGzGameStageBase, OuterStage) == 0x0000A0, "Member 'UGzGameStageBase::OuterStage' has a wrong offset!");
static_assert(offsetof(UGzGameStageBase, InnerStages) == 0x0000A8, "Member 'UGzGameStageBase::InnerStages' has a wrong offset!");
static_assert(offsetof(UGzGameStageBase, Transitions) == 0x0000B8, "Member 'UGzGameStageBase::Transitions' has a wrong offset!");

// Class G01.GzJZ_PreparePlayersStage
// 0x0000 (0x0110 - 0x0110)
class UGzJZ_PreparePlayersStage final : public UGzGameStageBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzJZ_PreparePlayersStage">();
	}
	static class UGzJZ_PreparePlayersStage* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzJZ_PreparePlayersStage>();
	}
};
static_assert(alignof(UGzJZ_PreparePlayersStage) == 0x000008, "Wrong alignment on UGzJZ_PreparePlayersStage");
static_assert(sizeof(UGzJZ_PreparePlayersStage) == 0x000110, "Wrong size on UGzJZ_PreparePlayersStage");

// Class G01.GzMarkerComponent
// 0x0250 (0x0480 - 0x0230)
#pragma pack(push, 0x1)
class alignas(0x10) UGzMarkerComponent : public USceneComponent
{
public:
	uint8                                         Pad_2D2F[0x8];                                     // 0x0230(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	FMulticastInlineDelegateProperty_             OnPlayerMarkerFocusChanged;                        // 0x0238(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnPingDataChanged;                                 // 0x0248(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnPingAgreementsChanged;                           // 0x0258(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnMarkerStatesChanged;                             // 0x0268(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnServerDataChanged;                               // 0x0278(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnPreRemoveWidgetFinishedDelegate;                 // 0x0288(0x0010)(ZeroConstructor, InstancedReference, BlueprintCallable, NativeAccessSpecifierPublic)
	uint8                                         Pad_2D30[0x30];                                    // 0x0298(0x0030)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftClassPtr<class UClass>                   MapMarkerWidgetClass;                              // 0x02C8(0x0028)(Edit, DisableEditOnInstance, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftClassPtr<class UClass>                   CompassMarkerWidgetClass;                          // 0x02F0(0x0028)(Edit, DisableEditOnInstance, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftClassPtr<class UClass>                   ViewportMarkerWidgetClass;                         // 0x0318(0x0028)(Edit, DisableEditOnInstance, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bSupportsRotation;                                 // 0x0340(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2D31[0x3];                                     // 0x0341(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         Priority;                                          // 0x0344(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UGzMarkerShape*                         MarkerShape;                                       // 0x0348(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, PersistentInstance, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         MarkerPingChannels;                                // 0x0350(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2D32[0x4];                                     // 0x0354(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGzPingData                            PingData;                                          // 0x0358(0x0060)(Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FGameplayTagContainer                  MarkerStates;                                      // 0x03B8(0x0020)(BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)
	struct FGzMarkerServerData                    ServerData;                                        // 0x03D8(0x0050)(Transient, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_2D33[0x8];                                     // 0x0428(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTag                           MarkerType;                                        // 0x0430(0x0008)(Edit, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bRequiresDelayedDestroy;                           // 0x0438(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bUsesDeferredPositionUpdate;                       // 0x0439(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2D34[0x2];                                     // 0x043A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         DeferredPositionUpdateTime;                        // 0x043C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bStatic;                                           // 0x0440(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bUse3DRange;                                       // 0x0441(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bNavigatable;                                      // 0x0442(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2D35[0x5];                                     // 0x0443(0x0005)(Fixing Size After Last Property [ Dumper-7 ])
	class UGzMarkerRadiusSettingAsset*            RadiusSettingAsset;                                // 0x0448(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2D36[0x28];                                    // 0x0450(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AddMarkerState(const struct FGameplayTag& State);
	void DelayedDestroy();
	void HandleLocalPlayerControllerChanged(class APlayerController* InPlayerController);
	void OnEndDelayedDestroy();
	void OnPlayableAreaReady();
	void RemoveMarkerState(const struct FGameplayTag& State);
	void SetMarkerType(const struct FGameplayTag& InMarkerType);
	void SetPriority(int32 InPriority);
	void SetWorldInstanceId(int32 InInstanceId);

	struct FVector2D GetMarkerLocation() const;
	struct FVector GetMarkerLocation3D() const;
	float GetMarkerRotation() const;
	const struct FGameplayTagContainer GetMarkerStates() const;
	struct FGameplayTag GetMarkerType() const;
	struct FGzPingData GetPingData() const;
	int32 GetPriority() const;
	const struct FGzMarkerServerData GetServerData() const;
	class UGzMarkerShape* GetShape() const;
	bool IsCompassMarkerStickingToEdges() const;
	bool IsHighlighted() const;
	bool IsNavigatable() const;
	bool IsPingable(EGzPingChannels InChannel) const;
	bool IsSupportingRotation() const;
	bool RequiresDelayedDestroy() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzMarkerComponent">();
	}
	static class UGzMarkerComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzMarkerComponent>();
	}
};
#pragma pack(pop)
static_assert(alignof(UGzMarkerComponent) == 0x000010, "Wrong alignment on UGzMarkerComponent");
static_assert(sizeof(UGzMarkerComponent) == 0x000480, "Wrong size on UGzMarkerComponent");
static_assert(offsetof(UGzMarkerComponent, OnPlayerMarkerFocusChanged) == 0x000238, "Member 'UGzMarkerComponent::OnPlayerMarkerFocusChanged' has a wrong offset!");
static_assert(offsetof(UGzMarkerComponent, OnPingDataChanged) == 0x000248, "Member 'UGzMarkerComponent::OnPingDataChanged' has a wrong offset!");
static_assert(offsetof(UGzMarkerComponent, OnPingAgreementsChanged) == 0x000258, "Member 'UGzMarkerComponent::OnPingAgreementsChanged' has a wrong offset!");
static_assert(offsetof(UGzMarkerComponent, OnMarkerStatesChanged) == 0x000268, "Member 'UGzMarkerComponent::OnMarkerStatesChanged' has a wrong offset!");
static_assert(offsetof(UGzMarkerComponent, OnServerDataChanged) == 0x000278, "Member 'UGzMarkerComponent::OnServerDataChanged' has a wrong offset!");
static_assert(offsetof(UGzMarkerComponent, OnPreRemoveWidgetFinishedDelegate) == 0x000288, "Member 'UGzMarkerComponent::OnPreRemoveWidgetFinishedDelegate' has a wrong offset!");
static_assert(offsetof(UGzMarkerComponent, MapMarkerWidgetClass) == 0x0002C8, "Member 'UGzMarkerComponent::MapMarkerWidgetClass' has a wrong offset!");
static_assert(offsetof(UGzMarkerComponent, CompassMarkerWidgetClass) == 0x0002F0, "Member 'UGzMarkerComponent::CompassMarkerWidgetClass' has a wrong offset!");
static_assert(offsetof(UGzMarkerComponent, ViewportMarkerWidgetClass) == 0x000318, "Member 'UGzMarkerComponent::ViewportMarkerWidgetClass' has a wrong offset!");
static_assert(offsetof(UGzMarkerComponent, bSupportsRotation) == 0x000340, "Member 'UGzMarkerComponent::bSupportsRotation' has a wrong offset!");
static_assert(offsetof(UGzMarkerComponent, Priority) == 0x000344, "Member 'UGzMarkerComponent::Priority' has a wrong offset!");
static_assert(offsetof(UGzMarkerComponent, MarkerShape) == 0x000348, "Member 'UGzMarkerComponent::MarkerShape' has a wrong offset!");
static_assert(offsetof(UGzMarkerComponent, MarkerPingChannels) == 0x000350, "Member 'UGzMarkerComponent::MarkerPingChannels' has a wrong offset!");
static_assert(offsetof(UGzMarkerComponent, PingData) == 0x000358, "Member 'UGzMarkerComponent::PingData' has a wrong offset!");
static_assert(offsetof(UGzMarkerComponent, MarkerStates) == 0x0003B8, "Member 'UGzMarkerComponent::MarkerStates' has a wrong offset!");
static_assert(offsetof(UGzMarkerComponent, ServerData) == 0x0003D8, "Member 'UGzMarkerComponent::ServerData' has a wrong offset!");
static_assert(offsetof(UGzMarkerComponent, MarkerType) == 0x000430, "Member 'UGzMarkerComponent::MarkerType' has a wrong offset!");
static_assert(offsetof(UGzMarkerComponent, bRequiresDelayedDestroy) == 0x000438, "Member 'UGzMarkerComponent::bRequiresDelayedDestroy' has a wrong offset!");
static_assert(offsetof(UGzMarkerComponent, bUsesDeferredPositionUpdate) == 0x000439, "Member 'UGzMarkerComponent::bUsesDeferredPositionUpdate' has a wrong offset!");
static_assert(offsetof(UGzMarkerComponent, DeferredPositionUpdateTime) == 0x00043C, "Member 'UGzMarkerComponent::DeferredPositionUpdateTime' has a wrong offset!");
static_assert(offsetof(UGzMarkerComponent, bStatic) == 0x000440, "Member 'UGzMarkerComponent::bStatic' has a wrong offset!");
static_assert(offsetof(UGzMarkerComponent, bUse3DRange) == 0x000441, "Member 'UGzMarkerComponent::bUse3DRange' has a wrong offset!");
static_assert(offsetof(UGzMarkerComponent, bNavigatable) == 0x000442, "Member 'UGzMarkerComponent::bNavigatable' has a wrong offset!");
static_assert(offsetof(UGzMarkerComponent, RadiusSettingAsset) == 0x000448, "Member 'UGzMarkerComponent::RadiusSettingAsset' has a wrong offset!");

// Class G01.GzMissionMarkerComponent
// 0x0000 (0x0480 - 0x0480)
class UGzMissionMarkerComponent final : public UGzMarkerComponent
{
public:
	class AGzAdvancedMission*                     Mission;                                           // 0x0478(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void SetMission(class AGzAdvancedMission* InMission);

	const class AGzAdvancedMission* GetMission() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzMissionMarkerComponent">();
	}
	static class UGzMissionMarkerComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzMissionMarkerComponent>();
	}
};
static_assert(alignof(UGzMissionMarkerComponent) == 0x000010, "Wrong alignment on UGzMissionMarkerComponent");
static_assert(sizeof(UGzMissionMarkerComponent) == 0x000480, "Wrong size on UGzMissionMarkerComponent");
static_assert(offsetof(UGzMissionMarkerComponent, Mission) == 0x000478, "Member 'UGzMissionMarkerComponent::Mission' has a wrong offset!");

// Class G01.GzConsoleSessionCheatExtension
// 0x0020 (0x0048 - 0x0028)
class UGzConsoleSessionCheatExtension final : public UGzCheatManagerExtension
{
public:
	uint8                                         Pad_2D37[0x20];                                    // 0x0028(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void CreateConsoleLobby();
	void CreateConsoleSession();
	void LeaveConsoleSession();
	void UpdateConsoleSessionJoinDisable(bool bJoinable);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzConsoleSessionCheatExtension">();
	}
	static class UGzConsoleSessionCheatExtension* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzConsoleSessionCheatExtension>();
	}
};
static_assert(alignof(UGzConsoleSessionCheatExtension) == 0x000008, "Wrong alignment on UGzConsoleSessionCheatExtension");
static_assert(sizeof(UGzConsoleSessionCheatExtension) == 0x000048, "Wrong size on UGzConsoleSessionCheatExtension");

// Class G01.LocomotionCharacter
// 0x0390 (0x0B60 - 0x07D0)
class ALocomotionCharacter : public AGzBaseCharacter
{
public:
	uint8                                         Pad_2D38[0x10];                                    // 0x07D0(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class UGzCharacterMovementComponent*          GzCharacterMovement;                               // 0x07E0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, Transient, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class ULocomotionComponent*                   LocomotionComponent;                               // 0x07E8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UGzMovementManager*                     MovementManager;                                   // 0x07F0(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UAnimInstance>              ServerAnimClass;                                   // 0x07F8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UMotionWarpingComponent*                MotionWarpingComponent;                            // 0x0800(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Gait;                                              // 0x0808(0x0001)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2D39[0x3];                                     // 0x0809(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	uint32                                        RepLocomotionFlags;                                // 0x080C(0x0004)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2D3A[0x300];                                   // 0x0810(0x0300)(Fixing Size After Last Property [ Dumper-7 ])
	uint8                                         bIsWalking;                                        // 0x0B10(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         bIsSprinting;                                      // 0x0B11(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         bIsSliding;                                        // 0x0B12(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         bIsJumping;                                        // 0x0B13(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         bIsWingsuitActive;                                 // 0x0B14(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         bIsJetpackDelayed;                                 // 0x0B15(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         bIsJetpackDamaged;                                 // 0x0B16(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         bIsJetpackBoosterActive;                           // 0x0B17(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         SlideEyeHeight;                                    // 0x0B18(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2D3B[0xC];                                     // 0x0B1C(0x000C)(Fixing Size After Last Property [ Dumper-7 ])
	FMulticastInlineDelegateProperty_             OnMovementActionChangedDelegate;                   // 0x0B28(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	TDelegate<void()>                             OnJetpackVisualFlagsChanged;                       // 0x0B38(0x0010)(BlueprintVisible, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UGzMovementManager>         MovementManagerClass;                              // 0x0B48(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ULocomotionVaultingAssetCollection*     MantlingScenarios;                                 // 0x0B50(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2D3C[0x8];                                     // 0x0B58(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void K2_OnEndBoostSliding();
	void K2_OnEndGrapplingPull(bool bClientSimulation);
	void K2_OnMovementActionChanged(ELocomotionMovementAction NewAction, ELocomotionMovementAction PreviousAction);
	void K2_OnStartBoostSliding();
	void K2_OnStartGrapplingPull(bool bClientSimulation);
	void K2_OnStartLeglessState();
	void K2_OnStopLeglessState();
	void OnCharacterReachedJumpApex();
	void OnJetpackVisualFlagsChanged__DelegateSignature();
	void OnMovementActionChanged__DelegateSignature(ELocomotionMovementAction PreviousAction);
	void OnRep_LocomotionFlags(uint32 OldFlags);
	void SetSprintEnabled(bool bEnabled);
	void SetWalkEnabled(bool bIsEnabled);

	bool CanUncrouch() const;
	bool CanWingsuit() const;
	EDrawDebugTrace GetTraceDebugType(EDrawDebugTrace ShowTraceType) const;
	bool IsJetpackBoosterActive() const;
	bool IsJetpackDamaged() const;
	bool IsJetpackDelayed() const;
	bool IsWingsuitActive() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LocomotionCharacter">();
	}
	static class ALocomotionCharacter* GetDefaultObj()
	{
		return GetDefaultObjImpl<ALocomotionCharacter>();
	}
};
static_assert(alignof(ALocomotionCharacter) == 0x000010, "Wrong alignment on ALocomotionCharacter");
static_assert(sizeof(ALocomotionCharacter) == 0x000B60, "Wrong size on ALocomotionCharacter");
static_assert(offsetof(ALocomotionCharacter, GzCharacterMovement) == 0x0007E0, "Member 'ALocomotionCharacter::GzCharacterMovement' has a wrong offset!");
static_assert(offsetof(ALocomotionCharacter, LocomotionComponent) == 0x0007E8, "Member 'ALocomotionCharacter::LocomotionComponent' has a wrong offset!");
static_assert(offsetof(ALocomotionCharacter, MovementManager) == 0x0007F0, "Member 'ALocomotionCharacter::MovementManager' has a wrong offset!");
static_assert(offsetof(ALocomotionCharacter, ServerAnimClass) == 0x0007F8, "Member 'ALocomotionCharacter::ServerAnimClass' has a wrong offset!");
static_assert(offsetof(ALocomotionCharacter, MotionWarpingComponent) == 0x000800, "Member 'ALocomotionCharacter::MotionWarpingComponent' has a wrong offset!");
static_assert(offsetof(ALocomotionCharacter, Gait) == 0x000808, "Member 'ALocomotionCharacter::Gait' has a wrong offset!");
static_assert(offsetof(ALocomotionCharacter, RepLocomotionFlags) == 0x00080C, "Member 'ALocomotionCharacter::RepLocomotionFlags' has a wrong offset!");
static_assert(offsetof(ALocomotionCharacter, bIsWalking) == 0x000B10, "Member 'ALocomotionCharacter::bIsWalking' has a wrong offset!");
static_assert(offsetof(ALocomotionCharacter, bIsSprinting) == 0x000B11, "Member 'ALocomotionCharacter::bIsSprinting' has a wrong offset!");
static_assert(offsetof(ALocomotionCharacter, bIsSliding) == 0x000B12, "Member 'ALocomotionCharacter::bIsSliding' has a wrong offset!");
static_assert(offsetof(ALocomotionCharacter, bIsJumping) == 0x000B13, "Member 'ALocomotionCharacter::bIsJumping' has a wrong offset!");
static_assert(offsetof(ALocomotionCharacter, bIsWingsuitActive) == 0x000B14, "Member 'ALocomotionCharacter::bIsWingsuitActive' has a wrong offset!");
static_assert(offsetof(ALocomotionCharacter, bIsJetpackDelayed) == 0x000B15, "Member 'ALocomotionCharacter::bIsJetpackDelayed' has a wrong offset!");
static_assert(offsetof(ALocomotionCharacter, bIsJetpackDamaged) == 0x000B16, "Member 'ALocomotionCharacter::bIsJetpackDamaged' has a wrong offset!");
static_assert(offsetof(ALocomotionCharacter, bIsJetpackBoosterActive) == 0x000B17, "Member 'ALocomotionCharacter::bIsJetpackBoosterActive' has a wrong offset!");
static_assert(offsetof(ALocomotionCharacter, SlideEyeHeight) == 0x000B18, "Member 'ALocomotionCharacter::SlideEyeHeight' has a wrong offset!");
static_assert(offsetof(ALocomotionCharacter, OnMovementActionChangedDelegate) == 0x000B28, "Member 'ALocomotionCharacter::OnMovementActionChangedDelegate' has a wrong offset!");
static_assert(offsetof(ALocomotionCharacter, OnJetpackVisualFlagsChanged) == 0x000B38, "Member 'ALocomotionCharacter::OnJetpackVisualFlagsChanged' has a wrong offset!");
static_assert(offsetof(ALocomotionCharacter, MovementManagerClass) == 0x000B48, "Member 'ALocomotionCharacter::MovementManagerClass' has a wrong offset!");
static_assert(offsetof(ALocomotionCharacter, MantlingScenarios) == 0x000B50, "Member 'ALocomotionCharacter::MantlingScenarios' has a wrong offset!");

// Class G01.GzLiveFeaturesUpdatedData
// 0x0010 (0x0038 - 0x0028)
class UGzLiveFeaturesUpdatedData final : public UGzSignalREventData
{
public:
	class FString                                 DataVersion;                                       // 0x0028(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzLiveFeaturesUpdatedData">();
	}
	static class UGzLiveFeaturesUpdatedData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzLiveFeaturesUpdatedData>();
	}
};
static_assert(alignof(UGzLiveFeaturesUpdatedData) == 0x000008, "Wrong alignment on UGzLiveFeaturesUpdatedData");
static_assert(sizeof(UGzLiveFeaturesUpdatedData) == 0x000038, "Wrong size on UGzLiveFeaturesUpdatedData");
static_assert(offsetof(UGzLiveFeaturesUpdatedData, DataVersion) == 0x000028, "Member 'UGzLiveFeaturesUpdatedData::DataVersion' has a wrong offset!");

// Class G01.GzCharacter
// 0x06F0 (0x1250 - 0x0B60)
class AGzCharacter : public ALocomotionCharacter
{
public:
	uint8                                         Pad_2D3D[0x38];                                    // 0x0B60(0x0038)(Fixing Size After Last Property [ Dumper-7 ])
	class UGzInteractableComponent*               InteractableComponent;                             // 0x0B98(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FGzNativeCharacterComponentSpec        ZiplineNiagaraComponentSpec;                       // 0x0BA0(0x0080)(Edit, NoDestructor, Protected, NativeAccessSpecifierProtected)
	class UNiagaraComponent*                      ZiplineNiagaraComponent;                           // 0x0C20(0x0008)(Edit, ExportObject, ZeroConstructor, Transient, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UGzGameplayTagHandlingComponent*        TagHandlingComponent;                              // 0x0C28(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UGzCharacterCustomizationComponent*     CustomizationComponent;                            // 0x0C30(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UGzMovementSoundComponent*              MovementSoundComponent;                            // 0x0C38(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UGzLootSpawnerComponent*                CachedLootSpawnerComponent;                        // 0x0C40(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDefaultCharacterSetup*                 DefaultCharacterSetup;                             // 0x0C48(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<TSubclassOf<class UGzGameplayAbility>> AdditionalAbilities;                               // 0x0C50(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	TArray<struct FGzInventoryItemContent>        CustomLoadout;                                     // 0x0C60(0x0010)(Edit, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	float                                         DeathImpulseMagnitudeMultiplier;                   // 0x0C70(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	FMulticastSparseDelegateProperty_             OnCharacterKnockedDown_BP;                         // 0x0C74(0x0001)(InstancedReference, BlueprintAssignable, NoDestructor, NativeAccessSpecifierPublic)
	FMulticastSparseDelegateProperty_             OnCharacterKnockedDownStateChanged_BP;             // 0x0C75(0x0001)(InstancedReference, BlueprintAssignable, NoDestructor, NativeAccessSpecifierPublic)
	FMulticastSparseDelegateProperty_             OnCharacterDied_BP;                                // 0x0C76(0x0001)(InstancedReference, BlueprintAssignable, NoDestructor, NativeAccessSpecifierPublic)
	FMulticastSparseDelegateProperty_             OnCharacterStartDied_BP;                           // 0x0C77(0x0001)(InstancedReference, BlueprintAssignable, NoDestructor, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnCharacterKilled;                                 // 0x0C78(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnVehicleSeatChanged;                              // 0x0C88(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnOperableObjectChanged;                           // 0x0C98(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_2D3E[0x10];                                    // 0x0CA8(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Altitude2;                                         // 0x0CB8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2D3F[0x4];                                     // 0x0CBC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                JumpApexLocation;                                  // 0x0CC0(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnRagdollEndEvent;                                 // 0x0CD8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnBlockTagsChanged;                                // 0x0CE8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnFocusChanged;                                    // 0x0CF8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnWeaponChanged;                                   // 0x0D08(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnWeaponPocketChanged;                             // 0x0D18(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             InventoryChanged;                                  // 0x0D28(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             AbilitiesUpdateDelegate;                           // 0x0D38(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_2D40[0x8];                                     // 0x0D48(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                DashDirection;                                     // 0x0D50(0x0018)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UGzDashParamsData*                      DashParamsData;                                    // 0x0D68(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DynamicDashMaxDistance;                            // 0x0D70(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2D41[0x4];                                     // 0x0D74(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class AActor*                                 CurrentPullingActor;                               // 0x0D78(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2D42[0x10];                                    // 0x0D80(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<TSubclassOf<class UActorComponent>>    ActiveWhileDyingComponentTypes;                    // 0x0D90(0x0010)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, UObjectWrapper, NativeAccessSpecifierPublic)
	bool                                          bOnlyTickMeshDuringMontage;                        // 0x0DA0(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2D43[0x7];                                     // 0x0DA1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	FMulticastInlineDelegateProperty_             OnAbilityActivationSuccessfulDelegate;             // 0x0DA8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnAbilityEndedDelegate;                            // 0x0DB8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnAbilityActivationFailedDelegate;                 // 0x0DC8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TSoftClassPtr<class UClass>                   UnarmedAnimLayer;                                  // 0x0DD8(0x0028)(Edit, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2D44[0x1];                                     // 0x0E00(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bWingsuitNeedAutodeployment;                       // 0x0E01(0x0001)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2D45[0x2];                                     // 0x0E02(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         WingsuitAutodeploymentDelay;                       // 0x0E04(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2D46[0x8];                                     // 0x0E08(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<ECollisionChannel>                     AltitudeTraceChannels;                             // 0x0E10(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	TMap<struct FGameplayTag, struct FGzEquipStateData> NewEquipStateMapping;                              // 0x0E20(0x0050)(Edit, Config, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	class AGzVehicle*                             CurrentVehicle;                                    // 0x0E70(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, EditConst, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UGzOperableObjectComponent*             CurrentOperableObjectComponent;                    // 0x0E78(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, Transient, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UGzPhysicsSimulationSyncComponent*      PhysicsSyncComponent;                              // 0x0E80(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UGzGE_FallDamage>           FallDamageEffect;                                  // 0x0E88(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         SkeletalMeshTickEnableDistance;                    // 0x0E90(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         SkeletalMeshTickRateWhenNotRendered;               // 0x0E94(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FGzSlideParams                         SlideParams;                                       // 0x0E98(0x0038)(Net, Transient, NoDestructor, Protected, NativeAccessSpecifierProtected)
	class AGzZipline*                             CurrentZipline;                                    // 0x0ED0(0x0008)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FGzZiplineMovementRuntimeData          CurrentZiplineData;                                // 0x0ED8(0x0058)(BlueprintVisible, BlueprintReadOnly, Net, Transient, NoDestructor, Protected, NativeAccessSpecifierProtected)
	class UGzWingsuitSettingsDataAsset*           JetpackSettings;                                   // 0x0F30(0x0008)(Net, ZeroConstructor, Transient, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UGzWingsuitSettingsDataAsset*           JetpackBoosterSettings;                            // 0x0F38(0x0008)(Net, ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2D47[0x8];                                     // 0x0F40(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftClassPtr<class UClass>                   ActiveLayerClassSoftPtr;                           // 0x0F48(0x0028)(Net, RepNotify, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSubclassOf<class UGzLayerCharacterAnimInstance> ActiveLayerClass;                                  // 0x0F70(0x0008)(ZeroConstructor, Transient, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2D48[0x21C];                                   // 0x0F78(0x021C)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bCanDie;                                           // 0x1194(0x0001)(Edit, BlueprintVisible, Net, ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2D49[0x3];                                     // 0x1195(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGzHitReaction                         HitReactionsData;                                  // 0x1198(0x0040)(Edit, BlueprintVisible, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2D4A[0x8];                                     // 0x11D8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         RelaxedStanceDelay;                                // 0x11E0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2D4B[0xC];                                     // 0x11E4(0x000C)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bRelaxedStance;                                    // 0x11F0(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2D4C[0x1F];                                    // 0x11F1(0x001F)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FGzInventoryItemContent>        PredefinedLoadoutItems;                            // 0x1210(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	TArray<struct FGzInventoryItemContent>        AdditionalItemsToSpawn;                            // 0x1220(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2D4D[0x20];                                    // 0x1230(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AddAnimLayerToPool(const TSoftClassPtr<class UClass>& NewLayer);
	void AfterShootTimerEnd();
	void ApplyFallDamage(TSubclassOf<class UGzGE_FallDamage> EffectClass, const float FallHeight);
	void BeginAimAction();
	void Client_PlayFatalHitEffects(class AActor* Attacker, const EGzWeaponResourceType& Resource, const struct FHitResult& Hit);
	void ClientNotifyBeingRedeployed();
	void DropExcessItems(const TArray<struct FGzInvItem>& ExcessItems);
	void EndAimAction();
	void ForceNotRelaxedStance();
	void GzCharacterKilled__DelegateSignature(int32 KillerId);
	void GzOperableObjectChanged__DelegateSignature(class UGzOperableObjectComponent* OperableObjectComponent);
	void HandleFinishedMovingAlongZipline(bool bCanceled);
	void HandleFinishedMovingToZipline();
	void LinkActiveAnimLayer(const TSoftClassPtr<class UClass>& NewLayer);
	void LinkActiveItemLayer();
	void LinkUnarmedItemLayer();
	void MulticastOnJumpActivationFailed(const struct FGameplayTag& FailedAbilityTag);
	void MulticastStartRagDoll(const struct FGameplayEffectSpec& DeathEffect);
	void OnCharacterCustomizationApplied(const struct FGzCharacterCustomizationProfile& Profile);
	void OnCharacterDied_BP__DelegateSignature(class AGzCharacter* Character);
	void OnCharacterKnockedDown_BP__DelegateSignature(class AGzCharacter* Character);
	void OnCharacterKnockedDownStateChanged_BP__DelegateSignature(class AGzCharacter* Character, bool KnockedDownState);
	void OnCharacterStartDied_BP__DelegateSignature(class AGzCharacter* Character);
	void OnComebackArenaStateChanged(class AGzPlayerState* PS);
	void OnHitReaction(const class AActor* Who, const struct FHitResult& HitResult);
	void OnJumpActivationFailed(const struct FGameplayTag& FailedAbilityTag);
	void OnMontageEnded(class UAnimMontage* Montage, bool bInterrupted);
	void OnMontageStarted(class UAnimMontage* Montage);
	void OnPlayerTeamChangedInternal(class AGzPlayerState* PS);
	void OnRagDollEnded(const struct FGameplayEffectSpec& DeathEffect);
	void OnRep_ActiveLayerClass();
	void OnRep_JetpackSettings();
	void OnShoot();
	void OnSingleHitDamageReceived(class UGzDamageableComponent* Receiver, const struct FGzSingleHitDamage& SingleHit);
	void OnWorldInstanceIdChanged(class AGzPlayerState* InPlayerState);
	void ReceiveCharacterOnStartupInitialized();
	void ResetAnimAbility();
	void RevealActor(class AActor* Actor);
	void ServerOnJumpActivationFailed(const struct FGameplayTag& FailedAbilityTag);
	void SetCanDie(bool bInCanDie);
	void SetCurrentZipline(const class AGzZipline* NewZipline);
	void SetDefaultAnimLayer();
	void Shoot(bool bStart);
	void UnRevealActor(class AActor* Actor);

	bool BP_IsNewCharacter() const;
	bool CanDie() const;
	void GetAbilitiesForInventorySlots(const struct FGameplayTagContainer& ItemTypes, TArray<class UGzGameplayAbility*>* OutAbilities) const;
	class AGzWeaponActor* GetActiveWeapon() const;
	class UGzWeaponComponent* GetActiveWeaponComponent() const;
	float GetAirFrictionCoef() const;
	float GetArmor() const;
	int32 GetCharacterLevel() const;
	float GetCrouchCoef() const;
	struct FGzInvPocketId GetCurrentEquippedPocketID() const;
	class UGzOperableObjectComponent* GetCurrentOperableObjectComponent() const;
	class AGzVehicle* GetCurrentVehicle() const;
	const class AGzZipline* GetCurrentZipline() const;
	class UGzCharacterCustomizationComponent* GetCustomizationComponent() const;
	struct FGenericTeamId GetGenericTeamId() const;
	class UGzInteractableComponent* GetInteractableComponent() const;
	float GetJumpVelocityBaseValue() const;
	float GetKnockedTimeToLive() const;
	float GetLeftHandIKOffsetXValue() const;
	float GetLeftHandIKOffsetYValue() const;
	float GetLeftHandIKOffsetZValue() const;
	float GetLeftHandIKValue() const;
	float GetMaxArmor() const;
	float GetMovementSpeed() const;
	float GetMovementSpeedBaseValue() const;
	float GetRunCoef() const;
	float GetSprintCoef() const;
	int32 GetTeamId() const;
	const TSoftClassPtr<class UClass> GetUnarmedAnimLayer() const;
	float GetWalkCoef() const;
	class AGzWeaponActor* GetWeaponAtSlot(const struct FGzInvPocketId& SlotID) const;
	bool IsAfterShootTimerFinished() const;
	bool IsKnockedDown() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzCharacter">();
	}
	static class AGzCharacter* GetDefaultObj()
	{
		return GetDefaultObjImpl<AGzCharacter>();
	}
};
static_assert(alignof(AGzCharacter) == 0x000010, "Wrong alignment on AGzCharacter");
static_assert(sizeof(AGzCharacter) == 0x001250, "Wrong size on AGzCharacter");
static_assert(offsetof(AGzCharacter, InteractableComponent) == 0x000B98, "Member 'AGzCharacter::InteractableComponent' has a wrong offset!");
static_assert(offsetof(AGzCharacter, ZiplineNiagaraComponentSpec) == 0x000BA0, "Member 'AGzCharacter::ZiplineNiagaraComponentSpec' has a wrong offset!");
static_assert(offsetof(AGzCharacter, ZiplineNiagaraComponent) == 0x000C20, "Member 'AGzCharacter::ZiplineNiagaraComponent' has a wrong offset!");
static_assert(offsetof(AGzCharacter, TagHandlingComponent) == 0x000C28, "Member 'AGzCharacter::TagHandlingComponent' has a wrong offset!");
static_assert(offsetof(AGzCharacter, CustomizationComponent) == 0x000C30, "Member 'AGzCharacter::CustomizationComponent' has a wrong offset!");
static_assert(offsetof(AGzCharacter, MovementSoundComponent) == 0x000C38, "Member 'AGzCharacter::MovementSoundComponent' has a wrong offset!");
static_assert(offsetof(AGzCharacter, CachedLootSpawnerComponent) == 0x000C40, "Member 'AGzCharacter::CachedLootSpawnerComponent' has a wrong offset!");
static_assert(offsetof(AGzCharacter, DefaultCharacterSetup) == 0x000C48, "Member 'AGzCharacter::DefaultCharacterSetup' has a wrong offset!");
static_assert(offsetof(AGzCharacter, AdditionalAbilities) == 0x000C50, "Member 'AGzCharacter::AdditionalAbilities' has a wrong offset!");
static_assert(offsetof(AGzCharacter, CustomLoadout) == 0x000C60, "Member 'AGzCharacter::CustomLoadout' has a wrong offset!");
static_assert(offsetof(AGzCharacter, DeathImpulseMagnitudeMultiplier) == 0x000C70, "Member 'AGzCharacter::DeathImpulseMagnitudeMultiplier' has a wrong offset!");
static_assert(offsetof(AGzCharacter, OnCharacterKnockedDown_BP) == 0x000C74, "Member 'AGzCharacter::OnCharacterKnockedDown_BP' has a wrong offset!");
static_assert(offsetof(AGzCharacter, OnCharacterKnockedDownStateChanged_BP) == 0x000C75, "Member 'AGzCharacter::OnCharacterKnockedDownStateChanged_BP' has a wrong offset!");
static_assert(offsetof(AGzCharacter, OnCharacterDied_BP) == 0x000C76, "Member 'AGzCharacter::OnCharacterDied_BP' has a wrong offset!");
static_assert(offsetof(AGzCharacter, OnCharacterStartDied_BP) == 0x000C77, "Member 'AGzCharacter::OnCharacterStartDied_BP' has a wrong offset!");
static_assert(offsetof(AGzCharacter, OnCharacterKilled) == 0x000C78, "Member 'AGzCharacter::OnCharacterKilled' has a wrong offset!");
static_assert(offsetof(AGzCharacter, OnVehicleSeatChanged) == 0x000C88, "Member 'AGzCharacter::OnVehicleSeatChanged' has a wrong offset!");
static_assert(offsetof(AGzCharacter, OnOperableObjectChanged) == 0x000C98, "Member 'AGzCharacter::OnOperableObjectChanged' has a wrong offset!");
static_assert(offsetof(AGzCharacter, Altitude2) == 0x000CB8, "Member 'AGzCharacter::Altitude2' has a wrong offset!");
static_assert(offsetof(AGzCharacter, JumpApexLocation) == 0x000CC0, "Member 'AGzCharacter::JumpApexLocation' has a wrong offset!");
static_assert(offsetof(AGzCharacter, OnRagdollEndEvent) == 0x000CD8, "Member 'AGzCharacter::OnRagdollEndEvent' has a wrong offset!");
static_assert(offsetof(AGzCharacter, OnBlockTagsChanged) == 0x000CE8, "Member 'AGzCharacter::OnBlockTagsChanged' has a wrong offset!");
static_assert(offsetof(AGzCharacter, OnFocusChanged) == 0x000CF8, "Member 'AGzCharacter::OnFocusChanged' has a wrong offset!");
static_assert(offsetof(AGzCharacter, OnWeaponChanged) == 0x000D08, "Member 'AGzCharacter::OnWeaponChanged' has a wrong offset!");
static_assert(offsetof(AGzCharacter, OnWeaponPocketChanged) == 0x000D18, "Member 'AGzCharacter::OnWeaponPocketChanged' has a wrong offset!");
static_assert(offsetof(AGzCharacter, InventoryChanged) == 0x000D28, "Member 'AGzCharacter::InventoryChanged' has a wrong offset!");
static_assert(offsetof(AGzCharacter, AbilitiesUpdateDelegate) == 0x000D38, "Member 'AGzCharacter::AbilitiesUpdateDelegate' has a wrong offset!");
static_assert(offsetof(AGzCharacter, DashDirection) == 0x000D50, "Member 'AGzCharacter::DashDirection' has a wrong offset!");
static_assert(offsetof(AGzCharacter, DashParamsData) == 0x000D68, "Member 'AGzCharacter::DashParamsData' has a wrong offset!");
static_assert(offsetof(AGzCharacter, DynamicDashMaxDistance) == 0x000D70, "Member 'AGzCharacter::DynamicDashMaxDistance' has a wrong offset!");
static_assert(offsetof(AGzCharacter, CurrentPullingActor) == 0x000D78, "Member 'AGzCharacter::CurrentPullingActor' has a wrong offset!");
static_assert(offsetof(AGzCharacter, ActiveWhileDyingComponentTypes) == 0x000D90, "Member 'AGzCharacter::ActiveWhileDyingComponentTypes' has a wrong offset!");
static_assert(offsetof(AGzCharacter, bOnlyTickMeshDuringMontage) == 0x000DA0, "Member 'AGzCharacter::bOnlyTickMeshDuringMontage' has a wrong offset!");
static_assert(offsetof(AGzCharacter, OnAbilityActivationSuccessfulDelegate) == 0x000DA8, "Member 'AGzCharacter::OnAbilityActivationSuccessfulDelegate' has a wrong offset!");
static_assert(offsetof(AGzCharacter, OnAbilityEndedDelegate) == 0x000DB8, "Member 'AGzCharacter::OnAbilityEndedDelegate' has a wrong offset!");
static_assert(offsetof(AGzCharacter, OnAbilityActivationFailedDelegate) == 0x000DC8, "Member 'AGzCharacter::OnAbilityActivationFailedDelegate' has a wrong offset!");
static_assert(offsetof(AGzCharacter, UnarmedAnimLayer) == 0x000DD8, "Member 'AGzCharacter::UnarmedAnimLayer' has a wrong offset!");
static_assert(offsetof(AGzCharacter, bWingsuitNeedAutodeployment) == 0x000E01, "Member 'AGzCharacter::bWingsuitNeedAutodeployment' has a wrong offset!");
static_assert(offsetof(AGzCharacter, WingsuitAutodeploymentDelay) == 0x000E04, "Member 'AGzCharacter::WingsuitAutodeploymentDelay' has a wrong offset!");
static_assert(offsetof(AGzCharacter, AltitudeTraceChannels) == 0x000E10, "Member 'AGzCharacter::AltitudeTraceChannels' has a wrong offset!");
static_assert(offsetof(AGzCharacter, NewEquipStateMapping) == 0x000E20, "Member 'AGzCharacter::NewEquipStateMapping' has a wrong offset!");
static_assert(offsetof(AGzCharacter, CurrentVehicle) == 0x000E70, "Member 'AGzCharacter::CurrentVehicle' has a wrong offset!");
static_assert(offsetof(AGzCharacter, CurrentOperableObjectComponent) == 0x000E78, "Member 'AGzCharacter::CurrentOperableObjectComponent' has a wrong offset!");
static_assert(offsetof(AGzCharacter, PhysicsSyncComponent) == 0x000E80, "Member 'AGzCharacter::PhysicsSyncComponent' has a wrong offset!");
static_assert(offsetof(AGzCharacter, FallDamageEffect) == 0x000E88, "Member 'AGzCharacter::FallDamageEffect' has a wrong offset!");
static_assert(offsetof(AGzCharacter, SkeletalMeshTickEnableDistance) == 0x000E90, "Member 'AGzCharacter::SkeletalMeshTickEnableDistance' has a wrong offset!");
static_assert(offsetof(AGzCharacter, SkeletalMeshTickRateWhenNotRendered) == 0x000E94, "Member 'AGzCharacter::SkeletalMeshTickRateWhenNotRendered' has a wrong offset!");
static_assert(offsetof(AGzCharacter, SlideParams) == 0x000E98, "Member 'AGzCharacter::SlideParams' has a wrong offset!");
static_assert(offsetof(AGzCharacter, CurrentZipline) == 0x000ED0, "Member 'AGzCharacter::CurrentZipline' has a wrong offset!");
static_assert(offsetof(AGzCharacter, CurrentZiplineData) == 0x000ED8, "Member 'AGzCharacter::CurrentZiplineData' has a wrong offset!");
static_assert(offsetof(AGzCharacter, JetpackSettings) == 0x000F30, "Member 'AGzCharacter::JetpackSettings' has a wrong offset!");
static_assert(offsetof(AGzCharacter, JetpackBoosterSettings) == 0x000F38, "Member 'AGzCharacter::JetpackBoosterSettings' has a wrong offset!");
static_assert(offsetof(AGzCharacter, ActiveLayerClassSoftPtr) == 0x000F48, "Member 'AGzCharacter::ActiveLayerClassSoftPtr' has a wrong offset!");
static_assert(offsetof(AGzCharacter, ActiveLayerClass) == 0x000F70, "Member 'AGzCharacter::ActiveLayerClass' has a wrong offset!");
static_assert(offsetof(AGzCharacter, bCanDie) == 0x001194, "Member 'AGzCharacter::bCanDie' has a wrong offset!");
static_assert(offsetof(AGzCharacter, HitReactionsData) == 0x001198, "Member 'AGzCharacter::HitReactionsData' has a wrong offset!");
static_assert(offsetof(AGzCharacter, RelaxedStanceDelay) == 0x0011E0, "Member 'AGzCharacter::RelaxedStanceDelay' has a wrong offset!");
static_assert(offsetof(AGzCharacter, bRelaxedStance) == 0x0011F0, "Member 'AGzCharacter::bRelaxedStance' has a wrong offset!");
static_assert(offsetof(AGzCharacter, PredefinedLoadoutItems) == 0x001210, "Member 'AGzCharacter::PredefinedLoadoutItems' has a wrong offset!");
static_assert(offsetof(AGzCharacter, AdditionalItemsToSpawn) == 0x001220, "Member 'AGzCharacter::AdditionalItemsToSpawn' has a wrong offset!");

// Class G01.GzCustomizationModifierTemplate
// 0x0080 (0x00A8 - 0x0028)
class UGzCustomizationModifierTemplate : public UObject
{
public:
	class FName                                   ID;                                                // 0x0028(0x0008)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bApplyToThisCIT;                                   // 0x0030(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAnyGender;                                        // 0x0031(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EGzBodyGender                                 Gender;                                            // 0x0032(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2D52[0x5];                                     // 0x0033(0x0005)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTagContainer                  AdditionalSlotsToApplyTo;                          // 0x0038(0x0020)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	class FText                                   DisplayName;                                       // 0x0058(0x0010)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	class FText                                   Description;                                       // 0x0068(0x0010)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UTexture2D>              DisplayIcon;                                       // 0x0078(0x0028)(Edit, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2D53[0x8];                                     // 0x00A0(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzCustomizationModifierTemplate">();
	}
	static class UGzCustomizationModifierTemplate* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzCustomizationModifierTemplate>();
	}
};
static_assert(alignof(UGzCustomizationModifierTemplate) == 0x000008, "Wrong alignment on UGzCustomizationModifierTemplate");
static_assert(sizeof(UGzCustomizationModifierTemplate) == 0x0000A8, "Wrong size on UGzCustomizationModifierTemplate");
static_assert(offsetof(UGzCustomizationModifierTemplate, ID) == 0x000028, "Member 'UGzCustomizationModifierTemplate::ID' has a wrong offset!");
static_assert(offsetof(UGzCustomizationModifierTemplate, bApplyToThisCIT) == 0x000030, "Member 'UGzCustomizationModifierTemplate::bApplyToThisCIT' has a wrong offset!");
static_assert(offsetof(UGzCustomizationModifierTemplate, bAnyGender) == 0x000031, "Member 'UGzCustomizationModifierTemplate::bAnyGender' has a wrong offset!");
static_assert(offsetof(UGzCustomizationModifierTemplate, Gender) == 0x000032, "Member 'UGzCustomizationModifierTemplate::Gender' has a wrong offset!");
static_assert(offsetof(UGzCustomizationModifierTemplate, AdditionalSlotsToApplyTo) == 0x000038, "Member 'UGzCustomizationModifierTemplate::AdditionalSlotsToApplyTo' has a wrong offset!");
static_assert(offsetof(UGzCustomizationModifierTemplate, DisplayName) == 0x000058, "Member 'UGzCustomizationModifierTemplate::DisplayName' has a wrong offset!");
static_assert(offsetof(UGzCustomizationModifierTemplate, Description) == 0x000068, "Member 'UGzCustomizationModifierTemplate::Description' has a wrong offset!");
static_assert(offsetof(UGzCustomizationModifierTemplate, DisplayIcon) == 0x000078, "Member 'UGzCustomizationModifierTemplate::DisplayIcon' has a wrong offset!");

// Class G01.GzCustomizationModifierTemplate_Material
// 0x0020 (0x00C8 - 0x00A8)
class UGzCustomizationModifierTemplate_Material : public UGzCustomizationModifierTemplate
{
public:
	TArray<class FName>                           MaterialSlotNames;                                 // 0x00A8(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2D54[0x10];                                    // 0x00B8(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzCustomizationModifierTemplate_Material">();
	}
	static class UGzCustomizationModifierTemplate_Material* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzCustomizationModifierTemplate_Material>();
	}
};
static_assert(alignof(UGzCustomizationModifierTemplate_Material) == 0x000008, "Wrong alignment on UGzCustomizationModifierTemplate_Material");
static_assert(sizeof(UGzCustomizationModifierTemplate_Material) == 0x0000C8, "Wrong size on UGzCustomizationModifierTemplate_Material");
static_assert(offsetof(UGzCustomizationModifierTemplate_Material, MaterialSlotNames) == 0x0000A8, "Member 'UGzCustomizationModifierTemplate_Material::MaterialSlotNames' has a wrong offset!");

// Class G01.GzCustomizationModifierTemplate_MaterialAsset
// 0x0018 (0x00E0 - 0x00C8)
class UGzCustomizationModifierTemplate_MaterialAsset final : public UGzCustomizationModifierTemplate_Material
{
public:
	TArray<TSoftObjectPtr<class UMaterialInterface>> ValueRange;                                        // 0x00C8(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, UObjectWrapper, NativeAccessSpecifierPublic)
	uint8                                         DefaultValue;                                      // 0x00D8(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2D55[0x7];                                     // 0x00D9(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzCustomizationModifierTemplate_MaterialAsset">();
	}
	static class UGzCustomizationModifierTemplate_MaterialAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzCustomizationModifierTemplate_MaterialAsset>();
	}
};
static_assert(alignof(UGzCustomizationModifierTemplate_MaterialAsset) == 0x000008, "Wrong alignment on UGzCustomizationModifierTemplate_MaterialAsset");
static_assert(sizeof(UGzCustomizationModifierTemplate_MaterialAsset) == 0x0000E0, "Wrong size on UGzCustomizationModifierTemplate_MaterialAsset");
static_assert(offsetof(UGzCustomizationModifierTemplate_MaterialAsset, ValueRange) == 0x0000C8, "Member 'UGzCustomizationModifierTemplate_MaterialAsset::ValueRange' has a wrong offset!");
static_assert(offsetof(UGzCustomizationModifierTemplate_MaterialAsset, DefaultValue) == 0x0000D8, "Member 'UGzCustomizationModifierTemplate_MaterialAsset::DefaultValue' has a wrong offset!");

// Class G01.GzMultiPartCharacter
// 0x0380 (0x15D0 - 0x1250)
class AGzMultiPartCharacter : public AGzCharacter
{
public:
	uint8                                         Pad_2D56[0x28];                                    // 0x1250(0x0028)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UGzLimbComponent*>               LimbComponents;                                    // 0x1278(0x0010)(Edit, ExportObject, ZeroConstructor, Transient, EditConst, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	class USkeletalMeshComponent*                 TorsoMeshComponent;                                // 0x1288(0x0008)(Edit, ExportObject, ZeroConstructor, Transient, EditConst, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USkeletalMeshComponent*                 HeadMeshComponent;                                 // 0x1290(0x0008)(Edit, ExportObject, ZeroConstructor, Transient, EditConst, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USkeletalMeshComponent*                 HexCarrierMeshComponent;                           // 0x1298(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   HexMeshComponent;                                  // 0x12A0(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UNiagaraComponent*                      HexNiagaraComponent;                               // 0x12A8(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   BackpackMeshComponent;                             // 0x12B0(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   ArmorPackMeshComponent;                            // 0x12B8(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   ZiplineDeviceMeshComponent;                        // 0x12C0(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   MortarTabletMeshComponent;                         // 0x12C8(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UGzJetpackComponent*                    JetpackComponent;                                  // 0x12D0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, Transient, EditConst, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EGzLimbType                                   ZiplinePrimaryLimbType;                            // 0x12D8(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2D57[0x7];                                     // 0x12D9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	FMulticastInlineDelegateProperty_             OnLimbChanged;                                     // 0x12E0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnLimbLoaded;                                      // 0x12F0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnHexExtractionStarted;                            // 0x1300(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UNiagaraSystem>          LimbDetachedNiagaraSystem;                         // 0x1310(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UNiagaraSystem>          LimbAttachingNiagaraSystem;                        // 0x1338(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UGameplayEffect>            DefaultLegsPresentEffect;                          // 0x1360(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2D58[0x8];                                     // 0x1368(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UGzLimbGlitchFXData*                    LimbGlitchData;                                    // 0x1370(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UGzBodyPartFXData>       BodyPartFXDataSoftRef;                             // 0x1378(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftObjectPtr<class UGzLimbGlitchFXData>     LimbGlitchDataSoftRef;                             // 0x13A0(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UGzLimbInteractionData*                 LimbInteractionData;                               // 0x13C8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         MaxLimbsAmountToEnableHeadshot;                    // 0x13D0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsArmorBlockingHeadshots;                         // 0x13D4(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2D59[0x3];                                     // 0x13D5(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGzDamageAreaInfo                      JetpackDamageAreaInfo;                             // 0x13D8(0x000C)(Edit, DisableEditOnInstance, NoDestructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_2D5A[0x4];                                     // 0x13E4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UGzCharacterPhysicsSetup*               PhysicsSetup;                                      // 0x13E8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TMap<EGzCharacterDamageAreaType, TSubclassOf<class UGameplayEffect>> BlockingHealDamageableAreaGameplayEffects;         // 0x13F0(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	float                                         ActiveLimbHitReactionMultiplier;                   // 0x1440(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bEnableLeglessState;                               // 0x1444(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2D5B[0x3];                                     // 0x1445(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class UGzLimbAbilityComponent*                RightArmAbilityComponent;                          // 0x1448(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, Net, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UGzLimbAbilityComponent*                LeftArmAbilityComponent;                           // 0x1450(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, Net, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UGzLimbAbilityComponent*                LegsAbilityComponent;                              // 0x1458(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, Net, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UGzContainerItemData*                   InsertedHexItemData;                               // 0x1460(0x0008)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, Transient, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   ViewObstructionSocketUpperArmRight;                // 0x1468(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   ViewObstructionSocketUpperArmLeft;                 // 0x1470(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   ViewObstructionSocketPelvis;                       // 0x1478(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   BackpackSocketName;                                // 0x1480(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UGzBodyPartFXData*                      BodyPartFXData;                                    // 0x1488(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UPhysicsAsset*                          DynamicPhysicsAsset;                               // 0x1490(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2D5C[0x90];                                    // 0x1498(0x0090)(Fixing Size After Last Property [ Dumper-7 ])
	class UCurveFloat*                            MaxLimbArmorDRDiminishingReturnsCurve;             // 0x1528(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UNiagaraSystem*                         HexNiagaraPtr;                                     // 0x1530(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UGzDamageableAreasManager*              DamageableAreasManager;                            // 0x1538(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2D5D[0x68];                                    // 0x1540(0x0068)(Fixing Size After Last Property [ Dumper-7 ])
	class UPhysicalMaterial*                      CachedArmorPhysicalMaterial;                       // 0x15A8(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UPhysicalMaterial*                      CachedDeadPlayerPhysicalMaterial;                  // 0x15B0(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2D5E[0x8];                                     // 0x15B8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UGzAsyncTaskGameplayTagAddedRemoved*    LimbAbilityActiveTagListenerTask;                  // 0x15C0(0x0008)(ZeroConstructor, Transient, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2D5F[0x8];                                     // 0x15C8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void BP_OnBackpackChanged(const struct FGzInvPocketChangeData& Data);
	void Multicast_PlayHitReaction(const class AActor* Who, const struct FHitResult& HitResult);
	void MulticastEndZiplineJumpOffFX();
	void OnActiveLimbTagChanged(const struct FGameplayTag& LimbActiveTag);
	void OnDamageableAreaDamaged(const EGzCharacterDamageAreaType DamageableArea, const float Damage);
	void OnLimbAttachCancel(const struct FVector_NetQuantize& Location, const struct FQuat& Rotation, const struct FGzPickableSpawnInfo& LimbInfo, const struct FGzInvItem& InvItem);
	void OnLimbTypeHealthChange(EGzLimbType LimbType, float Health);
	void OnRep_InsertedHexItemData();
	void TearOffLimbByType(EGzLimbType LimbType, const bool bForced);
	void TearOffLimbByTypeWithTag(EGzLimbType LimbType, const struct FGameplayTag& Tag);

	class UGzGA_BaseLimbAbility* GetActiveLimbAbility() const;
	struct FGameplayTag GetActiveLimbAbilityTag() const;
	class UStaticMeshComponent* GetBackpackMeshComponent() const;
	class FName GetBoneNameByDamageArea(const EGzCharacterDamageAreaType DamageArea) const;
	EGzCharacterDamageAreaType GetDamageAreaTypeByBone(const class FName& bone) const;
	EGzCharacterDamageAreaType GetDamageAreaTypeByHit(const struct FHitResult& Hit) const;
	class UGzLimbComponent* GetEquippedLimbComponent(EGzLimbType Type) const;
	class UGzLimbAbilityComponent* GetLimbAbilityComponent(const EGzLimbType LimbType) const;
	class UGzLimbComponent* GetLimbComponent(EGzLimbType Type) const;
	class UGzLimbComponent* GetLimbComponentByBone(class FName bone) const;
	class UGzLimbAbilityComponent* GetLimbComponentByPocketId(const struct FGzInvPocketId& PocketId) const;
	float GetLimbHealth(EGzLimbType LimbType) const;
	EGzLimbType GetLimbTypeByBone(class FName bone) const;
	class UGzLimbComponent* GetLoadedLimbComponent(EGzLimbType Type) const;
	const class UGzMultiPartAttributeSet* GetMultiPartAttributeSet() const;
	class UPhysicalMaterial* GetPhysMaterialByDamageArea(EGzCharacterDamageAreaType DamageAreaType) const;
	float GetTotalArmorDamageReductionFromLimbs() const;
	bool HasDamageAreaOfType(EGzCharacterDamageAreaType Type) const;
	bool HasLimbEquipped(EGzLimbType Type) const;
	bool HasLimbLoaded(EGzLimbType Type) const;
	bool IsSwitchingLimb() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzMultiPartCharacter">();
	}
	static class AGzMultiPartCharacter* GetDefaultObj()
	{
		return GetDefaultObjImpl<AGzMultiPartCharacter>();
	}
};
static_assert(alignof(AGzMultiPartCharacter) == 0x000010, "Wrong alignment on AGzMultiPartCharacter");
static_assert(sizeof(AGzMultiPartCharacter) == 0x0015D0, "Wrong size on AGzMultiPartCharacter");
static_assert(offsetof(AGzMultiPartCharacter, LimbComponents) == 0x001278, "Member 'AGzMultiPartCharacter::LimbComponents' has a wrong offset!");
static_assert(offsetof(AGzMultiPartCharacter, TorsoMeshComponent) == 0x001288, "Member 'AGzMultiPartCharacter::TorsoMeshComponent' has a wrong offset!");
static_assert(offsetof(AGzMultiPartCharacter, HeadMeshComponent) == 0x001290, "Member 'AGzMultiPartCharacter::HeadMeshComponent' has a wrong offset!");
static_assert(offsetof(AGzMultiPartCharacter, HexCarrierMeshComponent) == 0x001298, "Member 'AGzMultiPartCharacter::HexCarrierMeshComponent' has a wrong offset!");
static_assert(offsetof(AGzMultiPartCharacter, HexMeshComponent) == 0x0012A0, "Member 'AGzMultiPartCharacter::HexMeshComponent' has a wrong offset!");
static_assert(offsetof(AGzMultiPartCharacter, HexNiagaraComponent) == 0x0012A8, "Member 'AGzMultiPartCharacter::HexNiagaraComponent' has a wrong offset!");
static_assert(offsetof(AGzMultiPartCharacter, BackpackMeshComponent) == 0x0012B0, "Member 'AGzMultiPartCharacter::BackpackMeshComponent' has a wrong offset!");
static_assert(offsetof(AGzMultiPartCharacter, ArmorPackMeshComponent) == 0x0012B8, "Member 'AGzMultiPartCharacter::ArmorPackMeshComponent' has a wrong offset!");
static_assert(offsetof(AGzMultiPartCharacter, ZiplineDeviceMeshComponent) == 0x0012C0, "Member 'AGzMultiPartCharacter::ZiplineDeviceMeshComponent' has a wrong offset!");
static_assert(offsetof(AGzMultiPartCharacter, MortarTabletMeshComponent) == 0x0012C8, "Member 'AGzMultiPartCharacter::MortarTabletMeshComponent' has a wrong offset!");
static_assert(offsetof(AGzMultiPartCharacter, JetpackComponent) == 0x0012D0, "Member 'AGzMultiPartCharacter::JetpackComponent' has a wrong offset!");
static_assert(offsetof(AGzMultiPartCharacter, ZiplinePrimaryLimbType) == 0x0012D8, "Member 'AGzMultiPartCharacter::ZiplinePrimaryLimbType' has a wrong offset!");
static_assert(offsetof(AGzMultiPartCharacter, OnLimbChanged) == 0x0012E0, "Member 'AGzMultiPartCharacter::OnLimbChanged' has a wrong offset!");
static_assert(offsetof(AGzMultiPartCharacter, OnLimbLoaded) == 0x0012F0, "Member 'AGzMultiPartCharacter::OnLimbLoaded' has a wrong offset!");
static_assert(offsetof(AGzMultiPartCharacter, OnHexExtractionStarted) == 0x001300, "Member 'AGzMultiPartCharacter::OnHexExtractionStarted' has a wrong offset!");
static_assert(offsetof(AGzMultiPartCharacter, LimbDetachedNiagaraSystem) == 0x001310, "Member 'AGzMultiPartCharacter::LimbDetachedNiagaraSystem' has a wrong offset!");
static_assert(offsetof(AGzMultiPartCharacter, LimbAttachingNiagaraSystem) == 0x001338, "Member 'AGzMultiPartCharacter::LimbAttachingNiagaraSystem' has a wrong offset!");
static_assert(offsetof(AGzMultiPartCharacter, DefaultLegsPresentEffect) == 0x001360, "Member 'AGzMultiPartCharacter::DefaultLegsPresentEffect' has a wrong offset!");
static_assert(offsetof(AGzMultiPartCharacter, LimbGlitchData) == 0x001370, "Member 'AGzMultiPartCharacter::LimbGlitchData' has a wrong offset!");
static_assert(offsetof(AGzMultiPartCharacter, BodyPartFXDataSoftRef) == 0x001378, "Member 'AGzMultiPartCharacter::BodyPartFXDataSoftRef' has a wrong offset!");
static_assert(offsetof(AGzMultiPartCharacter, LimbGlitchDataSoftRef) == 0x0013A0, "Member 'AGzMultiPartCharacter::LimbGlitchDataSoftRef' has a wrong offset!");
static_assert(offsetof(AGzMultiPartCharacter, LimbInteractionData) == 0x0013C8, "Member 'AGzMultiPartCharacter::LimbInteractionData' has a wrong offset!");
static_assert(offsetof(AGzMultiPartCharacter, MaxLimbsAmountToEnableHeadshot) == 0x0013D0, "Member 'AGzMultiPartCharacter::MaxLimbsAmountToEnableHeadshot' has a wrong offset!");
static_assert(offsetof(AGzMultiPartCharacter, bIsArmorBlockingHeadshots) == 0x0013D4, "Member 'AGzMultiPartCharacter::bIsArmorBlockingHeadshots' has a wrong offset!");
static_assert(offsetof(AGzMultiPartCharacter, JetpackDamageAreaInfo) == 0x0013D8, "Member 'AGzMultiPartCharacter::JetpackDamageAreaInfo' has a wrong offset!");
static_assert(offsetof(AGzMultiPartCharacter, PhysicsSetup) == 0x0013E8, "Member 'AGzMultiPartCharacter::PhysicsSetup' has a wrong offset!");
static_assert(offsetof(AGzMultiPartCharacter, BlockingHealDamageableAreaGameplayEffects) == 0x0013F0, "Member 'AGzMultiPartCharacter::BlockingHealDamageableAreaGameplayEffects' has a wrong offset!");
static_assert(offsetof(AGzMultiPartCharacter, ActiveLimbHitReactionMultiplier) == 0x001440, "Member 'AGzMultiPartCharacter::ActiveLimbHitReactionMultiplier' has a wrong offset!");
static_assert(offsetof(AGzMultiPartCharacter, bEnableLeglessState) == 0x001444, "Member 'AGzMultiPartCharacter::bEnableLeglessState' has a wrong offset!");
static_assert(offsetof(AGzMultiPartCharacter, RightArmAbilityComponent) == 0x001448, "Member 'AGzMultiPartCharacter::RightArmAbilityComponent' has a wrong offset!");
static_assert(offsetof(AGzMultiPartCharacter, LeftArmAbilityComponent) == 0x001450, "Member 'AGzMultiPartCharacter::LeftArmAbilityComponent' has a wrong offset!");
static_assert(offsetof(AGzMultiPartCharacter, LegsAbilityComponent) == 0x001458, "Member 'AGzMultiPartCharacter::LegsAbilityComponent' has a wrong offset!");
static_assert(offsetof(AGzMultiPartCharacter, InsertedHexItemData) == 0x001460, "Member 'AGzMultiPartCharacter::InsertedHexItemData' has a wrong offset!");
static_assert(offsetof(AGzMultiPartCharacter, ViewObstructionSocketUpperArmRight) == 0x001468, "Member 'AGzMultiPartCharacter::ViewObstructionSocketUpperArmRight' has a wrong offset!");
static_assert(offsetof(AGzMultiPartCharacter, ViewObstructionSocketUpperArmLeft) == 0x001470, "Member 'AGzMultiPartCharacter::ViewObstructionSocketUpperArmLeft' has a wrong offset!");
static_assert(offsetof(AGzMultiPartCharacter, ViewObstructionSocketPelvis) == 0x001478, "Member 'AGzMultiPartCharacter::ViewObstructionSocketPelvis' has a wrong offset!");
static_assert(offsetof(AGzMultiPartCharacter, BackpackSocketName) == 0x001480, "Member 'AGzMultiPartCharacter::BackpackSocketName' has a wrong offset!");
static_assert(offsetof(AGzMultiPartCharacter, BodyPartFXData) == 0x001488, "Member 'AGzMultiPartCharacter::BodyPartFXData' has a wrong offset!");
static_assert(offsetof(AGzMultiPartCharacter, DynamicPhysicsAsset) == 0x001490, "Member 'AGzMultiPartCharacter::DynamicPhysicsAsset' has a wrong offset!");
static_assert(offsetof(AGzMultiPartCharacter, MaxLimbArmorDRDiminishingReturnsCurve) == 0x001528, "Member 'AGzMultiPartCharacter::MaxLimbArmorDRDiminishingReturnsCurve' has a wrong offset!");
static_assert(offsetof(AGzMultiPartCharacter, HexNiagaraPtr) == 0x001530, "Member 'AGzMultiPartCharacter::HexNiagaraPtr' has a wrong offset!");
static_assert(offsetof(AGzMultiPartCharacter, DamageableAreasManager) == 0x001538, "Member 'AGzMultiPartCharacter::DamageableAreasManager' has a wrong offset!");
static_assert(offsetof(AGzMultiPartCharacter, CachedArmorPhysicalMaterial) == 0x0015A8, "Member 'AGzMultiPartCharacter::CachedArmorPhysicalMaterial' has a wrong offset!");
static_assert(offsetof(AGzMultiPartCharacter, CachedDeadPlayerPhysicalMaterial) == 0x0015B0, "Member 'AGzMultiPartCharacter::CachedDeadPlayerPhysicalMaterial' has a wrong offset!");
static_assert(offsetof(AGzMultiPartCharacter, LimbAbilityActiveTagListenerTask) == 0x0015C0, "Member 'AGzMultiPartCharacter::LimbAbilityActiveTagListenerTask' has a wrong offset!");

// Class G01.GzRichPresenceService
// 0x0030 (0x00D0 - 0x00A0)
class UGzRichPresenceService final : public UGzClientPFObject
{
public:
	uint8                                         Pad_2D6E[0x30];                                    // 0x00A0(0x0030)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzRichPresenceService">();
	}
	static class UGzRichPresenceService* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzRichPresenceService>();
	}
};
static_assert(alignof(UGzRichPresenceService) == 0x000008, "Wrong alignment on UGzRichPresenceService");
static_assert(sizeof(UGzRichPresenceService) == 0x0000D0, "Wrong size on UGzRichPresenceService");

// Class G01.GzAICharacter
// 0x0040 (0x1610 - 0x15D0)
class AGzAICharacter : public AGzMultiPartCharacter
{
public:
	uint8                                         Pad_2D6F[0x20];                                    // 0x15D0(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	class UGameplayTasksComponent*                CachedGameplayTasksComponent;                      // 0x15F0(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UGzCustomizationProfileData*            PredefinedCustomization;                           // 0x15F8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsCollisionEnabled;                               // 0x1600(0x0001)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	ECollisionEnabled                             CachedCollisionValue;                              // 0x1601(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2D70[0xE];                                     // 0x1602(0x000E)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ReleaseCover();
	void SetReplicatedCollision(bool bEnabled);

	void LaunchTo(const struct FVector& NavDestination) const;
	void OnRep_bIsCollisionEnabled() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzAICharacter">();
	}
	static class AGzAICharacter* GetDefaultObj()
	{
		return GetDefaultObjImpl<AGzAICharacter>();
	}
};
static_assert(alignof(AGzAICharacter) == 0x000010, "Wrong alignment on AGzAICharacter");
static_assert(sizeof(AGzAICharacter) == 0x001610, "Wrong size on AGzAICharacter");
static_assert(offsetof(AGzAICharacter, CachedGameplayTasksComponent) == 0x0015F0, "Member 'AGzAICharacter::CachedGameplayTasksComponent' has a wrong offset!");
static_assert(offsetof(AGzAICharacter, PredefinedCustomization) == 0x0015F8, "Member 'AGzAICharacter::PredefinedCustomization' has a wrong offset!");
static_assert(offsetof(AGzAICharacter, bIsCollisionEnabled) == 0x001600, "Member 'AGzAICharacter::bIsCollisionEnabled' has a wrong offset!");
static_assert(offsetof(AGzAICharacter, CachedCollisionValue) == 0x001601, "Member 'AGzAICharacter::CachedCollisionValue' has a wrong offset!");

// Class G01.GzConnectionSettings
// 0x0020 (0x0048 - 0x0028)
class UGzConnectionSettings final : public UObject
{
public:
	class FString                                 DefaultIP;                                         // 0x0028(0x0010)(ZeroConstructor, Config, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 DefaultPort;                                       // 0x0038(0x0010)(ZeroConstructor, Config, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzConnectionSettings">();
	}
	static class UGzConnectionSettings* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzConnectionSettings>();
	}
};
static_assert(alignof(UGzConnectionSettings) == 0x000008, "Wrong alignment on UGzConnectionSettings");
static_assert(sizeof(UGzConnectionSettings) == 0x000048, "Wrong size on UGzConnectionSettings");
static_assert(offsetof(UGzConnectionSettings, DefaultIP) == 0x000028, "Member 'UGzConnectionSettings::DefaultIP' has a wrong offset!");
static_assert(offsetof(UGzConnectionSettings, DefaultPort) == 0x000038, "Member 'UGzConnectionSettings::DefaultPort' has a wrong offset!");

// Class G01.GzSettingDiscreteGameMeshQuality
// 0x0000 (0x01B8 - 0x01B8)
class UGzSettingDiscreteGameMeshQuality final : public UGameSettingValueDiscreteDynamic
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzSettingDiscreteGameMeshQuality">();
	}
	static class UGzSettingDiscreteGameMeshQuality* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzSettingDiscreteGameMeshQuality>();
	}
};
static_assert(alignof(UGzSettingDiscreteGameMeshQuality) == 0x000008, "Wrong alignment on UGzSettingDiscreteGameMeshQuality");
static_assert(sizeof(UGzSettingDiscreteGameMeshQuality) == 0x0001B8, "Wrong size on UGzSettingDiscreteGameMeshQuality");

// Class G01.GzAIController
// 0x0100 (0x04C8 - 0x03C8)
class AGzAIController : public AAIController
{
public:
	FMulticastSparseDelegateProperty_             FOnAIChangeLODEvent_BP;                            // 0x03C8(0x0001)(InstancedReference, BlueprintAssignable, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_2D71[0x7];                                     // 0x03C9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UGzAIProcessTargetComponent> AIProcessTargetComponentClass;                     // 0x03D0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FGameplayTagContainer                  BlockSightSenseTags;                               // 0x03D8(0x0020)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	FMulticastInlineDelegateProperty_             OnMentalStateChanged;                              // 0x03F8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_2D72[0x8];                                     // 0x0408(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UBlackboardComponent*                   BlackboardComp;                                    // 0x0410(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UBehaviorTreeComponent*                 BehaviorComp;                                      // 0x0418(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UGzAsyncTaskAttributeChanged*           AsyncTaskAttributeDamageArmorChanged;              // 0x0420(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UGzAIProcessTargetComponent*            AIProcessTargetComponent;                          // 0x0428(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UGzAIVoiceComponent*                    AIVoiceComponent;                                  // 0x0430(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2D73[0x38];                                    // 0x0438(0x0038)(Fixing Size After Last Property [ Dumper-7 ])
	struct FBox                                   ZoneContolBox;                                     // 0x0470(0x0038)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, NativeAccessSpecifierPrivate)
	float                                         CurrentMentalStateTime;                            // 0x04A8(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	EGzMentalState                                CurrentAIMentalState;                              // 0x04AC(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	EGzNpcActionStates                            CurrentActionStates;                               // 0x04AD(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2D74[0x12];                                    // 0x04AE(0x0012)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTag                           OwningGameplayAITag;                               // 0x04C0(0x0008)(Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void InitializeBehavior(class UBehaviorTree* BTree);
	void LaunchOverObstacle(const struct FVector& NavDestination, const struct FVector& StartEdgeLocation, const struct FVector& EndEdgeLocation);
	void LaunchTo(const struct FVector& NavDestination);
	void OnAIChangeLODEvent_BP__DelegateSignature(const struct FGzAILOD& AILOD);
	void OnCapsuleHitCallback(class UPrimitiveComponent* HitComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, const struct FVector& NormalImpulse, const struct FHitResult& Hit);
	void RefillAmmoStock(const bool RefillOneClip);
	void RequestControllerSenseTeamEvent(class AActor* Target, const struct FVector& LastLocation, float EventRange, float PassedInfoAge, float InStrength);
	void SetCurrentActionState(const EGzNpcActionStates& ActionStateRef);
	void SetCurrentMentalState(const EGzMentalState& MentalStateRef);
	void SetCurrentMentalStateTime(const float& MentalStateTimeRef);
	void SetFocusTargetBodyPartsOffset(class AActor* FocusActor, const EGzCharacterDamageAreaType DamageAreaType, const struct FVector& Offset);
	void SetTargetNonVisibleBodyParts(const TArray<EGzCharacterDamageAreaType>& InNonVisibleParts);
	void SetTargetVisibleBodyPart(const EGzCharacterDamageAreaType& InVisibleParts);
	void SetZoneControl(const struct FBox& InValue);
	void StopBrain();

	bool GetActorLastStimulusLocation(const class AActor* Actor, struct FVector& OutLoc) const;
	class UGzAIProcessTargetComponent* GetAIProcessTargetComponent() const;
	class UGzAIVoiceComponent* GetAIVoiceComponent() const;
	const struct FGameplayTagContainer GetBlockSightSenseTags() const;
	EGzNpcActionStates GetCurrentActionState() const;
	EGzMentalState GetCurrentMentalState() const;
	float GetCurrentMentalStateTime() const;
	struct FGameplayTag GetOwningGameplayAITag() const;
	class UAISenseConfig_Damage* GetSenseConfigDamage() const;
	class UAISenseConfig_Hearing* GetSenseConfigHearing() const;
	class UAISenseConfig_Prediction* GetSenseConfigPrediction() const;
	class UAISenseConfig_Sight* GetSenseConfigSight() const;
	class UAISenseConfig_Team* GetSenseConfigTeam() const;
	class UAISenseConfig_Touch* GetSenseConfigTouch() const;
	const TArray<EGzCharacterDamageAreaType> GetTargetNonVisibleBodyParts() const;
	EGzCharacterDamageAreaType GetTargetVisibleBodyPart() const;
	struct FBox GetZoneControl() const;
	bool HasActiveDamageStimulus(class AActor* ActorPtr) const;
	bool HasActiveSightSenseStimulus(class AActor* ActorPtr) const;
	bool HasAnyCurrentStimulus(class AActor* ActorPtr) const;
	bool HasZoneControl() const;
	bool IsLocationReachable(const struct FVector& Loc, float AcceptanceRadius, TSubclassOf<class UNavigationQueryFilter> FilterClass) const;
	bool IsPointInZoneControl(const struct FVector& InValue) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzAIController">();
	}
	static class AGzAIController* GetDefaultObj()
	{
		return GetDefaultObjImpl<AGzAIController>();
	}
};
static_assert(alignof(AGzAIController) == 0x000008, "Wrong alignment on AGzAIController");
static_assert(sizeof(AGzAIController) == 0x0004C8, "Wrong size on AGzAIController");
static_assert(offsetof(AGzAIController, FOnAIChangeLODEvent_BP) == 0x0003C8, "Member 'AGzAIController::FOnAIChangeLODEvent_BP' has a wrong offset!");
static_assert(offsetof(AGzAIController, AIProcessTargetComponentClass) == 0x0003D0, "Member 'AGzAIController::AIProcessTargetComponentClass' has a wrong offset!");
static_assert(offsetof(AGzAIController, BlockSightSenseTags) == 0x0003D8, "Member 'AGzAIController::BlockSightSenseTags' has a wrong offset!");
static_assert(offsetof(AGzAIController, OnMentalStateChanged) == 0x0003F8, "Member 'AGzAIController::OnMentalStateChanged' has a wrong offset!");
static_assert(offsetof(AGzAIController, BlackboardComp) == 0x000410, "Member 'AGzAIController::BlackboardComp' has a wrong offset!");
static_assert(offsetof(AGzAIController, BehaviorComp) == 0x000418, "Member 'AGzAIController::BehaviorComp' has a wrong offset!");
static_assert(offsetof(AGzAIController, AsyncTaskAttributeDamageArmorChanged) == 0x000420, "Member 'AGzAIController::AsyncTaskAttributeDamageArmorChanged' has a wrong offset!");
static_assert(offsetof(AGzAIController, AIProcessTargetComponent) == 0x000428, "Member 'AGzAIController::AIProcessTargetComponent' has a wrong offset!");
static_assert(offsetof(AGzAIController, AIVoiceComponent) == 0x000430, "Member 'AGzAIController::AIVoiceComponent' has a wrong offset!");
static_assert(offsetof(AGzAIController, ZoneContolBox) == 0x000470, "Member 'AGzAIController::ZoneContolBox' has a wrong offset!");
static_assert(offsetof(AGzAIController, CurrentMentalStateTime) == 0x0004A8, "Member 'AGzAIController::CurrentMentalStateTime' has a wrong offset!");
static_assert(offsetof(AGzAIController, CurrentAIMentalState) == 0x0004AC, "Member 'AGzAIController::CurrentAIMentalState' has a wrong offset!");
static_assert(offsetof(AGzAIController, CurrentActionStates) == 0x0004AD, "Member 'AGzAIController::CurrentActionStates' has a wrong offset!");
static_assert(offsetof(AGzAIController, OwningGameplayAITag) == 0x0004C0, "Member 'AGzAIController::OwningGameplayAITag' has a wrong offset!");

// Class G01.GzAIInfo
// 0x0058 (0x02F8 - 0x02A0)
class AGzAIInfo : public AInfo
{
public:
	struct FDebugTargetSelection                  DebugAIData;                                       // 0x02A0(0x0024)(Net, NoDestructor, NativeAccessSpecifierPublic)
	int32                                         AiId;                                              // 0x02C4(0x0004)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FString                                 Name_GzAIInfo;                                     // 0x02C8(0x0010)(Net, ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	ENPCType                                      Type;                                              // 0x02D8(0x0001)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2D7E[0x3];                                     // 0x02D9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         TeamID;                                            // 0x02DC(0x0004)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         bIsInactive : 1;                                   // 0x02E0(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Net, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bIsAlive : 1;                                      // 0x02E0(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Net, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         AILODId;                                           // 0x02E1(0x0001)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2D7F[0x6];                                     // 0x02E2(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class APawn*                                  Pawn;                                              // 0x02E8(0x0008)(Net, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class AGzNPCSpawner*                          NPCSpawner;                                        // 0x02F0(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void OnPawnInactive(class AActor* Actor, EEndPlayReason EndPlayReason);
	void SetInactive(bool Value);
	void SetName(const class FString& InName);

	uint8 GetAILODId() const;
	int32 GetId() const;
	class FString GetNPCName() const;
	ENPCType GetNPCType() const;
	class APawn* GetPawn() const;
	class AGzNPCSpawner* GetSpawner() const;
	int32 GetTeamId() const;
	bool IsAlive() const;
	bool IsInactive() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzAIInfo">();
	}
	static class AGzAIInfo* GetDefaultObj()
	{
		return GetDefaultObjImpl<AGzAIInfo>();
	}
};
static_assert(alignof(AGzAIInfo) == 0x000008, "Wrong alignment on AGzAIInfo");
static_assert(sizeof(AGzAIInfo) == 0x0002F8, "Wrong size on AGzAIInfo");
static_assert(offsetof(AGzAIInfo, DebugAIData) == 0x0002A0, "Member 'AGzAIInfo::DebugAIData' has a wrong offset!");
static_assert(offsetof(AGzAIInfo, AiId) == 0x0002C4, "Member 'AGzAIInfo::AiId' has a wrong offset!");
static_assert(offsetof(AGzAIInfo, Name_GzAIInfo) == 0x0002C8, "Member 'AGzAIInfo::Name_GzAIInfo' has a wrong offset!");
static_assert(offsetof(AGzAIInfo, Type) == 0x0002D8, "Member 'AGzAIInfo::Type' has a wrong offset!");
static_assert(offsetof(AGzAIInfo, TeamID) == 0x0002DC, "Member 'AGzAIInfo::TeamID' has a wrong offset!");
static_assert(offsetof(AGzAIInfo, AILODId) == 0x0002E1, "Member 'AGzAIInfo::AILODId' has a wrong offset!");
static_assert(offsetof(AGzAIInfo, Pawn) == 0x0002E8, "Member 'AGzAIInfo::Pawn' has a wrong offset!");
static_assert(offsetof(AGzAIInfo, NPCSpawner) == 0x0002F0, "Member 'AGzAIInfo::NPCSpawner' has a wrong offset!");

// Class G01.GzBaseLogEntryWidget
// 0x0018 (0x02F8 - 0x02E0)
class UGzBaseLogEntryWidget : public UUserWidget
{
public:
	uint8                                         Pad_2D81[0x10];                                    // 0x02E0(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class UWidgetAnimation*                       ShowAnimation;                                     // 0x02F0(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzBaseLogEntryWidget">();
	}
	static class UGzBaseLogEntryWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzBaseLogEntryWidget>();
	}
};
static_assert(alignof(UGzBaseLogEntryWidget) == 0x000008, "Wrong alignment on UGzBaseLogEntryWidget");
static_assert(sizeof(UGzBaseLogEntryWidget) == 0x0002F8, "Wrong size on UGzBaseLogEntryWidget");
static_assert(offsetof(UGzBaseLogEntryWidget, ShowAnimation) == 0x0002F0, "Member 'UGzBaseLogEntryWidget::ShowAnimation' has a wrong offset!");

// Class G01.GzXPLogEntryWidget
// 0x0008 (0x0300 - 0x02F8)
class UGzXPLogEntryWidget : public UGzBaseLogEntryWidget
{
public:
	class UGzTextBlock*                           StatName;                                          // 0x02F8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void SetStatName(const class FText& Param_Name) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzXPLogEntryWidget">();
	}
	static class UGzXPLogEntryWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzXPLogEntryWidget>();
	}
};
static_assert(alignof(UGzXPLogEntryWidget) == 0x000008, "Wrong alignment on UGzXPLogEntryWidget");
static_assert(sizeof(UGzXPLogEntryWidget) == 0x000300, "Wrong size on UGzXPLogEntryWidget");
static_assert(offsetof(UGzXPLogEntryWidget, StatName) == 0x0002F8, "Member 'UGzXPLogEntryWidget::StatName' has a wrong offset!");

// Class G01.GzCustomizationModifierTemplate_MaterialParam
// 0x0008 (0x00D0 - 0x00C8)
class UGzCustomizationModifierTemplate_MaterialParam : public UGzCustomizationModifierTemplate_Material
{
public:
	class FName                                   ParamName;                                         // 0x00C8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzCustomizationModifierTemplate_MaterialParam">();
	}
	static class UGzCustomizationModifierTemplate_MaterialParam* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzCustomizationModifierTemplate_MaterialParam>();
	}
};
static_assert(alignof(UGzCustomizationModifierTemplate_MaterialParam) == 0x000008, "Wrong alignment on UGzCustomizationModifierTemplate_MaterialParam");
static_assert(sizeof(UGzCustomizationModifierTemplate_MaterialParam) == 0x0000D0, "Wrong size on UGzCustomizationModifierTemplate_MaterialParam");
static_assert(offsetof(UGzCustomizationModifierTemplate_MaterialParam, ParamName) == 0x0000C8, "Member 'UGzCustomizationModifierTemplate_MaterialParam::ParamName' has a wrong offset!");

// Class G01.GzCustomizationModifierTemplate_MaterialColor
// 0x0028 (0x00F8 - 0x00D0)
class UGzCustomizationModifierTemplate_MaterialColor final : public UGzCustomizationModifierTemplate_MaterialParam
{
public:
	TArray<struct FLinearColor>                   ValueRange;                                        // 0x00D0(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	uint8                                         DefaultValue;                                      // 0x00E0(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2D82[0x3];                                     // 0x00E1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FLinearColor                           ChosenValue;                                       // 0x00E4(0x0010)(Edit, ZeroConstructor, Transient, DisableEditOnInstance, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2D83[0x4];                                     // 0x00F4(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzCustomizationModifierTemplate_MaterialColor">();
	}
	static class UGzCustomizationModifierTemplate_MaterialColor* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzCustomizationModifierTemplate_MaterialColor>();
	}
};
static_assert(alignof(UGzCustomizationModifierTemplate_MaterialColor) == 0x000008, "Wrong alignment on UGzCustomizationModifierTemplate_MaterialColor");
static_assert(sizeof(UGzCustomizationModifierTemplate_MaterialColor) == 0x0000F8, "Wrong size on UGzCustomizationModifierTemplate_MaterialColor");
static_assert(offsetof(UGzCustomizationModifierTemplate_MaterialColor, ValueRange) == 0x0000D0, "Member 'UGzCustomizationModifierTemplate_MaterialColor::ValueRange' has a wrong offset!");
static_assert(offsetof(UGzCustomizationModifierTemplate_MaterialColor, DefaultValue) == 0x0000E0, "Member 'UGzCustomizationModifierTemplate_MaterialColor::DefaultValue' has a wrong offset!");
static_assert(offsetof(UGzCustomizationModifierTemplate_MaterialColor, ChosenValue) == 0x0000E4, "Member 'UGzCustomizationModifierTemplate_MaterialColor::ChosenValue' has a wrong offset!");

// Class G01.GzMirrorBreakerInfo
// 0x0010 (0x0308 - 0x02F8)
class AGzMirrorBreakerInfo final : public AGzAIInfo
{
public:
	class AGzPlayerState*                         MirrorPlayerState;                                 // 0x02F8(0x0008)(Net, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2D84[0x8];                                     // 0x0300(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ApplyCustomization();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzMirrorBreakerInfo">();
	}
	static class AGzMirrorBreakerInfo* GetDefaultObj()
	{
		return GetDefaultObjImpl<AGzMirrorBreakerInfo>();
	}
};
static_assert(alignof(AGzMirrorBreakerInfo) == 0x000008, "Wrong alignment on AGzMirrorBreakerInfo");
static_assert(sizeof(AGzMirrorBreakerInfo) == 0x000308, "Wrong size on AGzMirrorBreakerInfo");
static_assert(offsetof(AGzMirrorBreakerInfo, MirrorPlayerState) == 0x0002F8, "Member 'AGzMirrorBreakerInfo::MirrorPlayerState' has a wrong offset!");

// Class G01.GzGameModeSubsystem
// 0x0000 (0x02A0 - 0x02A0)
class AGzGameModeSubsystem : public AInfo
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzGameModeSubsystem">();
	}
	static class AGzGameModeSubsystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<AGzGameModeSubsystem>();
	}
};
static_assert(alignof(AGzGameModeSubsystem) == 0x000008, "Wrong alignment on AGzGameModeSubsystem");
static_assert(sizeof(AGzGameModeSubsystem) == 0x0002A0, "Wrong size on AGzGameModeSubsystem");

// Class G01.GzLootSpawner
// 0x0028 (0x02C8 - 0x02A0)
class AGzLootSpawner : public AActor
{
public:
	uint8                                         Pad_2D85[0x10];                                    // 0x02A0(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bSpawnExtraAmmoForWeapons;                         // 0x02B0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2D86[0x7];                                     // 0x02B1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UGzLootItemVariationsTableData*         ExtraAmmoVariationsTable;                          // 0x02B8(0x0008)(Edit, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2D87[0x8];                                     // 0x02C0(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	TArray<struct FTransform> GetLocalSocketTransforms() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzLootSpawner">();
	}
	static class AGzLootSpawner* GetDefaultObj()
	{
		return GetDefaultObjImpl<AGzLootSpawner>();
	}
};
static_assert(alignof(AGzLootSpawner) == 0x000008, "Wrong alignment on AGzLootSpawner");
static_assert(sizeof(AGzLootSpawner) == 0x0002C8, "Wrong size on AGzLootSpawner");
static_assert(offsetof(AGzLootSpawner, bSpawnExtraAmmoForWeapons) == 0x0002B0, "Member 'AGzLootSpawner::bSpawnExtraAmmoForWeapons' has a wrong offset!");
static_assert(offsetof(AGzLootSpawner, ExtraAmmoVariationsTable) == 0x0002B8, "Member 'AGzLootSpawner::ExtraAmmoVariationsTable' has a wrong offset!");

// Class G01.GzContainerLootSpawner
// 0x0018 (0x02E0 - 0x02C8)
class AGzContainerLootSpawner : public AGzLootSpawner
{
public:
	class UGzInteractableComponent*               InteractableComponent;                             // 0x02C8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bOpened;                                           // 0x02D0(0x0001)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIgnoreContainersRefreshEvent;                     // 0x02D1(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bResetAfterTime;                                   // 0x02D2(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2D88[0x1];                                     // 0x02D3(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ResetTime;                                         // 0x02D4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2D89[0x8];                                     // 0x02D8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnContainerStateChanged();
	void OnInteract(class AActor* InteractedBy, const class UGzInteractableComponent* Interactable);
	void OnRep_IsOpened();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzContainerLootSpawner">();
	}
	static class AGzContainerLootSpawner* GetDefaultObj()
	{
		return GetDefaultObjImpl<AGzContainerLootSpawner>();
	}
};
static_assert(alignof(AGzContainerLootSpawner) == 0x000008, "Wrong alignment on AGzContainerLootSpawner");
static_assert(sizeof(AGzContainerLootSpawner) == 0x0002E0, "Wrong size on AGzContainerLootSpawner");
static_assert(offsetof(AGzContainerLootSpawner, InteractableComponent) == 0x0002C8, "Member 'AGzContainerLootSpawner::InteractableComponent' has a wrong offset!");
static_assert(offsetof(AGzContainerLootSpawner, bOpened) == 0x0002D0, "Member 'AGzContainerLootSpawner::bOpened' has a wrong offset!");
static_assert(offsetof(AGzContainerLootSpawner, bIgnoreContainersRefreshEvent) == 0x0002D1, "Member 'AGzContainerLootSpawner::bIgnoreContainersRefreshEvent' has a wrong offset!");
static_assert(offsetof(AGzContainerLootSpawner, bResetAfterTime) == 0x0002D2, "Member 'AGzContainerLootSpawner::bResetAfterTime' has a wrong offset!");
static_assert(offsetof(AGzContainerLootSpawner, ResetTime) == 0x0002D4, "Member 'AGzContainerLootSpawner::ResetTime' has a wrong offset!");

// Class G01.GzBaseMarkerContainer
// 0x0208 (0x04E8 - 0x02E0)
class UGzBaseMarkerContainer : public UUserWidget
{
public:
	uint8                                         Pad_2D8A[0x30];                                    // 0x02E0(0x0030)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UGzMarkerActiveStateFilter*>     MarkerFilters;                                     // 0x0310(0x0010)(Edit, ExportObject, ZeroConstructor, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	TArray<TSubclassOf<class UGzMarkerWidget>>    AllowedMarkerWidgetClasses;                        // 0x0320(0x0010)(Edit, ZeroConstructor, Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	TMap<class UGzMarkerComponent*, class UGzMarkerWidget*> MarkerWidgets;                                     // 0x0330(0x0050)(BlueprintVisible, ExportObject, BlueprintReadOnly, Transient, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	TMap<class UGzMarkerComponent*, class UGzMarkerWidget*> NonSpatializedMarkers;                             // 0x0380(0x0050)(BlueprintVisible, ExportObject, BlueprintReadOnly, Transient, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	TMap<struct FIntPoint, struct FGzMarkerWidgets> MarkerCells;                                       // 0x03D0(0x0050)(Transient, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	struct FGameplayTagContainer                  EvaluateOnRemoveMarkerTags;                        // 0x0420(0x0020)(Edit, Protected, NativeAccessSpecifierProtected)
	struct FGameplayTagContainer                  EvaluateOnAddMarkerTags;                           // 0x0440(0x0020)(Edit, Protected, NativeAccessSpecifierProtected)
	bool                                          bDisableInactiveMarkers;                           // 0x0460(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bUseSpatialOptimisation;                           // 0x0461(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2D8B[0x6];                                     // 0x0462(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTagContainer                  IgnoreSpatializationStates;                        // 0x0468(0x0020)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	TSet<struct FIntPoint>                        CachedRelevantCells;                               // 0x0488(0x0050)(Transient, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_2D8C[0x10];                                    // 0x04D8(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AddMarker(class UGzMarkerComponent* MarkerComponent);
	void OnMarkerAdded(class UGzMarkerWidget* MarkerWidget, class UGzMarkerComponent* MarkerComponent);
	void OnMarkerRemoved(class UGzMarkerWidget* MarkerWidget, class UGzMarkerComponent* MarkerComponent);
	void OnMarkersDirty();
	void OnMarkerStateChanged(class UGzMarkerComponent* MarkerComponent, const struct FGameplayTagContainer& States);
	void OnMarkerWidgetRemove(class UGzMarkerComponent* InMarkerComponent);
	void OnPawnChanged(class APawn* Pawn);
	void RefreshMarker(class UGzMarkerComponent* MarkerComponent);
	void RefreshMarkers();
	void RemoveMarker(class UGzMarkerComponent* MarkerComponent);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzBaseMarkerContainer">();
	}
	static class UGzBaseMarkerContainer* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzBaseMarkerContainer>();
	}
};
static_assert(alignof(UGzBaseMarkerContainer) == 0x000008, "Wrong alignment on UGzBaseMarkerContainer");
static_assert(sizeof(UGzBaseMarkerContainer) == 0x0004E8, "Wrong size on UGzBaseMarkerContainer");
static_assert(offsetof(UGzBaseMarkerContainer, MarkerFilters) == 0x000310, "Member 'UGzBaseMarkerContainer::MarkerFilters' has a wrong offset!");
static_assert(offsetof(UGzBaseMarkerContainer, AllowedMarkerWidgetClasses) == 0x000320, "Member 'UGzBaseMarkerContainer::AllowedMarkerWidgetClasses' has a wrong offset!");
static_assert(offsetof(UGzBaseMarkerContainer, MarkerWidgets) == 0x000330, "Member 'UGzBaseMarkerContainer::MarkerWidgets' has a wrong offset!");
static_assert(offsetof(UGzBaseMarkerContainer, NonSpatializedMarkers) == 0x000380, "Member 'UGzBaseMarkerContainer::NonSpatializedMarkers' has a wrong offset!");
static_assert(offsetof(UGzBaseMarkerContainer, MarkerCells) == 0x0003D0, "Member 'UGzBaseMarkerContainer::MarkerCells' has a wrong offset!");
static_assert(offsetof(UGzBaseMarkerContainer, EvaluateOnRemoveMarkerTags) == 0x000420, "Member 'UGzBaseMarkerContainer::EvaluateOnRemoveMarkerTags' has a wrong offset!");
static_assert(offsetof(UGzBaseMarkerContainer, EvaluateOnAddMarkerTags) == 0x000440, "Member 'UGzBaseMarkerContainer::EvaluateOnAddMarkerTags' has a wrong offset!");
static_assert(offsetof(UGzBaseMarkerContainer, bDisableInactiveMarkers) == 0x000460, "Member 'UGzBaseMarkerContainer::bDisableInactiveMarkers' has a wrong offset!");
static_assert(offsetof(UGzBaseMarkerContainer, bUseSpatialOptimisation) == 0x000461, "Member 'UGzBaseMarkerContainer::bUseSpatialOptimisation' has a wrong offset!");
static_assert(offsetof(UGzBaseMarkerContainer, IgnoreSpatializationStates) == 0x000468, "Member 'UGzBaseMarkerContainer::IgnoreSpatializationStates' has a wrong offset!");
static_assert(offsetof(UGzBaseMarkerContainer, CachedRelevantCells) == 0x000488, "Member 'UGzBaseMarkerContainer::CachedRelevantCells' has a wrong offset!");

// Class G01.GzMapMarkerContainer
// 0x0060 (0x0548 - 0x04E8)
class UGzMapMarkerContainer : public UGzBaseMarkerContainer
{
public:
	class UGzMapWidget*                           ParentMap;                                         // 0x04E8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, Transient, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bClampMarkers;                                     // 0x04F0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bScaleMarkersWithZoom;                             // 0x04F1(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2D8D[0x6];                                     // 0x04F2(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class UCanvasPanel*                           RootContainer;                                     // 0x04F8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UGzMapMarkerWidget*                     HoveredMapMarker;                                  // 0x0500(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2D8E[0x40];                                    // 0x0508(0x0040)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void RequestPing(const struct FGameplayTag& PingType);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzMapMarkerContainer">();
	}
	static class UGzMapMarkerContainer* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzMapMarkerContainer>();
	}
};
static_assert(alignof(UGzMapMarkerContainer) == 0x000008, "Wrong alignment on UGzMapMarkerContainer");
static_assert(sizeof(UGzMapMarkerContainer) == 0x000548, "Wrong size on UGzMapMarkerContainer");
static_assert(offsetof(UGzMapMarkerContainer, ParentMap) == 0x0004E8, "Member 'UGzMapMarkerContainer::ParentMap' has a wrong offset!");
static_assert(offsetof(UGzMapMarkerContainer, bClampMarkers) == 0x0004F0, "Member 'UGzMapMarkerContainer::bClampMarkers' has a wrong offset!");
static_assert(offsetof(UGzMapMarkerContainer, bScaleMarkersWithZoom) == 0x0004F1, "Member 'UGzMapMarkerContainer::bScaleMarkersWithZoom' has a wrong offset!");
static_assert(offsetof(UGzMapMarkerContainer, RootContainer) == 0x0004F8, "Member 'UGzMapMarkerContainer::RootContainer' has a wrong offset!");
static_assert(offsetof(UGzMapMarkerContainer, HoveredMapMarker) == 0x000500, "Member 'UGzMapMarkerContainer::HoveredMapMarker' has a wrong offset!");

// Class G01.GzAIManager
// 0x02D8 (0x0578 - 0x02A0)
class AGzAIManager : public AGzGameModeSubsystem
{
public:
	TArray<class AGzAIInfo*>                      AIInfoStorage;                                     // 0x02A0(0x0010)(Net, ZeroConstructor, RepNotify, NativeAccessSpecifierPrivate)
	TArray<class AGzNPCTeam*>                     NPCTeamStorage;                                    // 0x02B0(0x0010)(Net, ZeroConstructor, RepNotify, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2D8F[0x8];                                     // 0x02C0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<int32, class AGzAIInfo*>                 AIInfoMap;                                         // 0x02C8(0x0050)(Transient, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2D90[0x8];                                     // 0x0318(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<int32, class AGzNPCTeam*>                NPCTeamsMap;                                       // 0x0320(0x0050)(Transient, NativeAccessSpecifierPrivate)
	TArray<struct FGameplayTag>                   TypeNpcArray;                                      // 0x0370(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	int32                                         MaxNPCDeathMatchMode;                              // 0x0380(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         MinNPCTeamId;                                      // 0x0384(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         MaxNPCTeamId;                                      // 0x0388(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2D91[0x4];                                     // 0x038C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<ENPCType, struct FAILODArray>            AILODMap;                                          // 0x0390(0x0050)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	bool                                          AILODsEnabled;                                     // 0x03E0(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2D92[0x3];                                     // 0x03E1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGzIntervalTimer                       AILODTimer;                                        // 0x03E4(0x0014)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPrivate)
	struct FGzIntervalTimer                       AISoundTimer;                                      // 0x03F8(0x0014)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPrivate)
	struct FGzIntervalTimer                       AILogTimer;                                        // 0x040C(0x0014)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPrivate)
	TMap<struct FGameplayTag, class UAkAudioEvent*> AIAudioMap;                                        // 0x0420(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	TMap<struct FGameplayTag, class UGzCustomizationProfileData*> AICustomizationMap;                                // 0x0470(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	TMap<struct FGameplayTag, TSubclassOf<class UGzNPCData>> NPCDataMap;                                        // 0x04C0(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, UObjectWrapper, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2D93[0x50];                                    // 0x0510(0x0050)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         NavLinkNums;                                       // 0x0560(0x0004)(Net, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         CoversNums;                                        // 0x0564(0x0004)(Net, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         NavMeshTileCounts;                                 // 0x0568(0x0004)(Net, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         NavMeshUpdateChangelistNumber;                     // 0x056C(0x0004)(Net, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2D94[0x8];                                     // 0x0570(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AddAllAttitudeTeam(ENPCTeamAttitude NPCTeamAttitude, int32 TeamID);
	bool AddAttitudeTeam(ENPCTeamAttitude AttitudeType, int32 TeamIdA, int32 TeamIdB);
	bool AddFriendTeam(int32 TeamIdA, int32 TeamIdB);
	bool AddHostileTeam(int32 TeamIdA, int32 TeamIdB);
	bool AddNeutralTeam(int32 TeamIdA, int32 TeamIdB);
	void MakeNPCTeamFriendlyToPlayers(const int32 NPCTeamId);
	void OnRep_AIInfoStorage();
	void OnRep_NPCTeamStorage();
	void RemoveAllAttitudeTeam(int32 TeamID);
	bool RemoveAttitudeTeam(int32 TeamIdA, int32 TeamIdB);
	void SetAILODsEnabled(bool bEnabled);
	void SetSuppressNPCSpawn(bool InValue);

	const class AGzAIInfo* GetAIInfoByIndex(int32 Param_Index) const;
	class UAkAudioEvent* GetAudioEvent(const struct FGameplayTag& AudioTag) const;
	TArray<class AGzBattleRoyaleZone*> GetDangerousZones() const;
	TArray<class APawn*> GetFriendlyMembers(int32 TeamID) const;
	class UGzNPCData* GetNPCData(const struct FGameplayTag& NPCType) const;
	class AGzNPCTeam* GetNPCTeam(int32 TeamID) const;
	TArray<class APawn*> GetNPCTeamMembers(int32 TeamID) const;
	int32 GetNumActiveNPCs() const;
	int32 GetNumNPCLOD(uint8 LodId) const;
	int32 GetNumNPCs() const;
	int32 GetNumNPCTeams() const;
	class UGzCustomizationProfileData* GetPredefinedCustomization(const struct FGameplayTag& CustomizationTag) const;
	TArray<class AGzBattleRoyaleZone*> GetSafeZones() const;
	bool IsSuppressNPCSpawn() const;
	bool IsTeamFriends(int32 NPCTeamId, int32 TeamID) const;
	bool IsTeamNeutrals(int32 NPCTeamId, int32 TeamID) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzAIManager">();
	}
	static class AGzAIManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<AGzAIManager>();
	}
};
static_assert(alignof(AGzAIManager) == 0x000008, "Wrong alignment on AGzAIManager");
static_assert(sizeof(AGzAIManager) == 0x000578, "Wrong size on AGzAIManager");
static_assert(offsetof(AGzAIManager, AIInfoStorage) == 0x0002A0, "Member 'AGzAIManager::AIInfoStorage' has a wrong offset!");
static_assert(offsetof(AGzAIManager, NPCTeamStorage) == 0x0002B0, "Member 'AGzAIManager::NPCTeamStorage' has a wrong offset!");
static_assert(offsetof(AGzAIManager, AIInfoMap) == 0x0002C8, "Member 'AGzAIManager::AIInfoMap' has a wrong offset!");
static_assert(offsetof(AGzAIManager, NPCTeamsMap) == 0x000320, "Member 'AGzAIManager::NPCTeamsMap' has a wrong offset!");
static_assert(offsetof(AGzAIManager, TypeNpcArray) == 0x000370, "Member 'AGzAIManager::TypeNpcArray' has a wrong offset!");
static_assert(offsetof(AGzAIManager, MaxNPCDeathMatchMode) == 0x000380, "Member 'AGzAIManager::MaxNPCDeathMatchMode' has a wrong offset!");
static_assert(offsetof(AGzAIManager, MinNPCTeamId) == 0x000384, "Member 'AGzAIManager::MinNPCTeamId' has a wrong offset!");
static_assert(offsetof(AGzAIManager, MaxNPCTeamId) == 0x000388, "Member 'AGzAIManager::MaxNPCTeamId' has a wrong offset!");
static_assert(offsetof(AGzAIManager, AILODMap) == 0x000390, "Member 'AGzAIManager::AILODMap' has a wrong offset!");
static_assert(offsetof(AGzAIManager, AILODsEnabled) == 0x0003E0, "Member 'AGzAIManager::AILODsEnabled' has a wrong offset!");
static_assert(offsetof(AGzAIManager, AILODTimer) == 0x0003E4, "Member 'AGzAIManager::AILODTimer' has a wrong offset!");
static_assert(offsetof(AGzAIManager, AISoundTimer) == 0x0003F8, "Member 'AGzAIManager::AISoundTimer' has a wrong offset!");
static_assert(offsetof(AGzAIManager, AILogTimer) == 0x00040C, "Member 'AGzAIManager::AILogTimer' has a wrong offset!");
static_assert(offsetof(AGzAIManager, AIAudioMap) == 0x000420, "Member 'AGzAIManager::AIAudioMap' has a wrong offset!");
static_assert(offsetof(AGzAIManager, AICustomizationMap) == 0x000470, "Member 'AGzAIManager::AICustomizationMap' has a wrong offset!");
static_assert(offsetof(AGzAIManager, NPCDataMap) == 0x0004C0, "Member 'AGzAIManager::NPCDataMap' has a wrong offset!");
static_assert(offsetof(AGzAIManager, NavLinkNums) == 0x000560, "Member 'AGzAIManager::NavLinkNums' has a wrong offset!");
static_assert(offsetof(AGzAIManager, CoversNums) == 0x000564, "Member 'AGzAIManager::CoversNums' has a wrong offset!");
static_assert(offsetof(AGzAIManager, NavMeshTileCounts) == 0x000568, "Member 'AGzAIManager::NavMeshTileCounts' has a wrong offset!");
static_assert(offsetof(AGzAIManager, NavMeshUpdateChangelistNumber) == 0x00056C, "Member 'AGzAIManager::NavMeshUpdateChangelistNumber' has a wrong offset!");

// Class G01.GzItemCatalogModel
// 0x0468 (0x04D8 - 0x0070)
class UGzItemCatalogModel final : public UGzBackendModel
{
public:
	TMap<class FName, struct FGzCohtmlWeaponItemData> Weapons;                                           // 0x0070(0x0050)(Transient, NativeAccessSpecifierPrivate)
	TMap<class FName, struct FGzCohtmlWeaponAttachmentItemData> WeaponsAttachments;                                // 0x00C0(0x0050)(Transient, NativeAccessSpecifierPrivate)
	TMap<class FName, struct FGzCohtmlWeaponSkinItemData> WeaponSkins;                                       // 0x0110(0x0050)(Transient, NativeAccessSpecifierPrivate)
	TMap<class FName, struct FGzCohtmlBodyPartItemData> BodyParts;                                         // 0x0160(0x0050)(Transient, NativeAccessSpecifierPrivate)
	TMap<class FName, struct FGzCohtmlItemData>   BodyPartSkins;                                     // 0x01B0(0x0050)(Transient, NativeAccessSpecifierPrivate)
	TMap<class FName, struct FGzCohtmlItemData>   Backpacks;                                         // 0x0200(0x0050)(Transient, NativeAccessSpecifierPrivate)
	TMap<class FName, struct FGzCohtmlCustomizationItemTemplate> CharacterCustomizationItems;                       // 0x0250(0x0050)(Transient, NativeAccessSpecifierPrivate)
	TMap<class FName, struct FGzCohtmlItemData>   Ammo;                                              // 0x02A0(0x0050)(Transient, NativeAccessSpecifierPrivate)
	TMap<class FName, struct FGzCohtmlItemData>   Consumables;                                       // 0x02F0(0x0050)(Transient, NativeAccessSpecifierPrivate)
	TMap<class FName, struct FGzCohtmlContainerItemData> Containers;                                        // 0x0340(0x0050)(Transient, NativeAccessSpecifierPrivate)
	TMap<class FName, struct FGzCohtmlItemData>   MiscItems;                                         // 0x0390(0x0050)(Transient, NativeAccessSpecifierPrivate)
	TMap<class FName, struct FGzCohtmlCurrencyItemData> Currency;                                          // 0x03E0(0x0050)(Transient, NativeAccessSpecifierPrivate)
	TMap<class FString, struct FGzCohtmlWeaponTypeFamilies> WeaponTypeFamiliesMap;                             // 0x0430(0x0050)(NativeAccessSpecifierPrivate)
	TMap<class FString, struct FGzCohtmlBodyPartTypeFamilies> BodyPartTypeFamiliesMap;                           // 0x0480(0x0050)(NativeAccessSpecifierPrivate)
	class UGzAssetManager*                        AssetManager;                                      // 0x04D0(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzItemCatalogModel">();
	}
	static class UGzItemCatalogModel* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzItemCatalogModel>();
	}
};
static_assert(alignof(UGzItemCatalogModel) == 0x000008, "Wrong alignment on UGzItemCatalogModel");
static_assert(sizeof(UGzItemCatalogModel) == 0x0004D8, "Wrong size on UGzItemCatalogModel");
static_assert(offsetof(UGzItemCatalogModel, Weapons) == 0x000070, "Member 'UGzItemCatalogModel::Weapons' has a wrong offset!");
static_assert(offsetof(UGzItemCatalogModel, WeaponsAttachments) == 0x0000C0, "Member 'UGzItemCatalogModel::WeaponsAttachments' has a wrong offset!");
static_assert(offsetof(UGzItemCatalogModel, WeaponSkins) == 0x000110, "Member 'UGzItemCatalogModel::WeaponSkins' has a wrong offset!");
static_assert(offsetof(UGzItemCatalogModel, BodyParts) == 0x000160, "Member 'UGzItemCatalogModel::BodyParts' has a wrong offset!");
static_assert(offsetof(UGzItemCatalogModel, BodyPartSkins) == 0x0001B0, "Member 'UGzItemCatalogModel::BodyPartSkins' has a wrong offset!");
static_assert(offsetof(UGzItemCatalogModel, Backpacks) == 0x000200, "Member 'UGzItemCatalogModel::Backpacks' has a wrong offset!");
static_assert(offsetof(UGzItemCatalogModel, CharacterCustomizationItems) == 0x000250, "Member 'UGzItemCatalogModel::CharacterCustomizationItems' has a wrong offset!");
static_assert(offsetof(UGzItemCatalogModel, Ammo) == 0x0002A0, "Member 'UGzItemCatalogModel::Ammo' has a wrong offset!");
static_assert(offsetof(UGzItemCatalogModel, Consumables) == 0x0002F0, "Member 'UGzItemCatalogModel::Consumables' has a wrong offset!");
static_assert(offsetof(UGzItemCatalogModel, Containers) == 0x000340, "Member 'UGzItemCatalogModel::Containers' has a wrong offset!");
static_assert(offsetof(UGzItemCatalogModel, MiscItems) == 0x000390, "Member 'UGzItemCatalogModel::MiscItems' has a wrong offset!");
static_assert(offsetof(UGzItemCatalogModel, Currency) == 0x0003E0, "Member 'UGzItemCatalogModel::Currency' has a wrong offset!");
static_assert(offsetof(UGzItemCatalogModel, WeaponTypeFamiliesMap) == 0x000430, "Member 'UGzItemCatalogModel::WeaponTypeFamiliesMap' has a wrong offset!");
static_assert(offsetof(UGzItemCatalogModel, BodyPartTypeFamiliesMap) == 0x000480, "Member 'UGzItemCatalogModel::BodyPartTypeFamiliesMap' has a wrong offset!");
static_assert(offsetof(UGzItemCatalogModel, AssetManager) == 0x0004D0, "Member 'UGzItemCatalogModel::AssetManager' has a wrong offset!");

// Class G01.GzAimAssistComponent
// 0x0098 (0x0140 - 0x00A8)
class UGzAimAssistComponent final : public UActorComponent
{
public:
	class AGzPlayerCharacter*                     CachedChar;                                        // 0x00A8(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class AGzPlayerController*                    CachedController;                                  // 0x00B0(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UGzTargetableRegisterSubsystem*         CachedSubsystem;                                   // 0x00B8(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UGzCharacterDefaultSettings*            CachedSettings;                                    // 0x00C0(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UGzAsyncTaskGameplayTagAddedRemoved*    TagsListenTask;                                    // 0x00C8(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UGzTargetableComponent*                 CachedTargetableComponent;                         // 0x00D0(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2DA3[0x68];                                    // 0x00D8(0x0068)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnInputMethodChanged(ECommonInputType bNewInputType);
	void OnOwnerControllerChanged(class APawn* Pawn, class AController* OldController, class AController* NewController);
	void OnOwnerTagAdded(const struct FGameplayTag& ChangedTag);
	void OnOwnerTagRemoved(const struct FGameplayTag& ChangedTag);
	void OnWeaponEquipChanged(const struct FGzInvPocketId& PocketId);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzAimAssistComponent">();
	}
	static class UGzAimAssistComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzAimAssistComponent>();
	}
};
static_assert(alignof(UGzAimAssistComponent) == 0x000008, "Wrong alignment on UGzAimAssistComponent");
static_assert(sizeof(UGzAimAssistComponent) == 0x000140, "Wrong size on UGzAimAssistComponent");
static_assert(offsetof(UGzAimAssistComponent, CachedChar) == 0x0000A8, "Member 'UGzAimAssistComponent::CachedChar' has a wrong offset!");
static_assert(offsetof(UGzAimAssistComponent, CachedController) == 0x0000B0, "Member 'UGzAimAssistComponent::CachedController' has a wrong offset!");
static_assert(offsetof(UGzAimAssistComponent, CachedSubsystem) == 0x0000B8, "Member 'UGzAimAssistComponent::CachedSubsystem' has a wrong offset!");
static_assert(offsetof(UGzAimAssistComponent, CachedSettings) == 0x0000C0, "Member 'UGzAimAssistComponent::CachedSettings' has a wrong offset!");
static_assert(offsetof(UGzAimAssistComponent, TagsListenTask) == 0x0000C8, "Member 'UGzAimAssistComponent::TagsListenTask' has a wrong offset!");
static_assert(offsetof(UGzAimAssistComponent, CachedTargetableComponent) == 0x0000D0, "Member 'UGzAimAssistComponent::CachedTargetableComponent' has a wrong offset!");

// Class G01.GzCustomizationProfileData
// 0x0150 (0x0180 - 0x0030)
class UGzCustomizationProfileData final : public UDataAsset
{
public:
	struct FGzCharacterCustomizationProfile       Profile;                                           // 0x0030(0x0150)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzCustomizationProfileData">();
	}
	static class UGzCustomizationProfileData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzCustomizationProfileData>();
	}
};
static_assert(alignof(UGzCustomizationProfileData) == 0x000008, "Wrong alignment on UGzCustomizationProfileData");
static_assert(sizeof(UGzCustomizationProfileData) == 0x000180, "Wrong size on UGzCustomizationProfileData");
static_assert(offsetof(UGzCustomizationProfileData, Profile) == 0x000030, "Member 'UGzCustomizationProfileData::Profile' has a wrong offset!");

// Class G01.GzAIProjectSettings
// 0x0000 (0x0038 - 0x0038)
class UGzAIProjectSettings final : public UDeveloperSettings
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzAIProjectSettings">();
	}
	static class UGzAIProjectSettings* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzAIProjectSettings>();
	}
};
static_assert(alignof(UGzAIProjectSettings) == 0x000008, "Wrong alignment on UGzAIProjectSettings");
static_assert(sizeof(UGzAIProjectSettings) == 0x000038, "Wrong size on UGzAIProjectSettings");

// Class G01.GzHUDBase
// 0x0120 (0x04B0 - 0x0390)
class AGzHUDBase : public AHUD
{
public:
	uint8                                         Pad_2DA4[0x18];                                    // 0x0390(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftClassPtr<class UClass>                   ViewClass;                                         // 0x03A8(0x0028)(Edit, DisableEditOnInstance, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bUseTabNavigation;                                 // 0x03D0(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2DA5[0x7];                                     // 0x03D1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<struct FGameplayTag, struct FGameplayTag> UITagMap;                                          // 0x03D8(0x0050)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	TSubclassOf<class UGzNavigationWidget>        SpectatorOverlayWidgetClass;                       // 0x0428(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSubclassOf<class UGzNavigationWidget>        SpectatorTransitionWidget;                         // 0x0430(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSoftClassPtr<class UClass>                   VoiceChatStateWidgetClass;                         // 0x0438(0x0028)(Edit, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UGzNavigationWidget*                    SpectatorOverlayWidget;                            // 0x0460(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UGzNavigationRoot*                      NavigationRoot;                                    // 0x0468(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UGzHUDView*                             View;                                              // 0x0470(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UGzDebugInfoWidget*                     DebugInfo;                                         // 0x0478(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class APawn*                                  ViewTarget;                                        // 0x0480(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UGzWatermarkWidget*                     WatermarkWidget;                                   // 0x0488(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UGzVoiceChatStateWidget*                VoiceChatStateWidget;                              // 0x0490(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FVector2D                              VoiceChatStatePosNormalized;                       // 0x0498(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2DA6[0x8];                                     // 0x04A8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnEndedSpectating();
	void OnInit_BP();
	void OnMatchStageChanged();
	void OnPawnChanged(class APawn* Pawn);
	void OnPlayerControllerInitialized(class AGzPlayerController* PlayerController, class AGzPlayerState* PlayerState);
	void OnPlayerControllerInitialized_BP(class AGzPlayerController* PlayerController, class AGzPlayerState* PlayerState);
	void OnStartedSpectating();
	void OnViewTargetPlayerStateRep(class AGzPlayerState* PlayerState);
	void ReceiveOnPawnChanged(class APawn* Pawn);

	struct FGameplayTagContainer GetActiveStageUITags(const struct FGameplayTagContainer& ActiveStageTags) const;
	class UGzHUDView* GetView() const;
	bool ShouldWaitKillerSpectateEnd() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzHUDBase">();
	}
	static class AGzHUDBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<AGzHUDBase>();
	}
};
static_assert(alignof(AGzHUDBase) == 0x000008, "Wrong alignment on AGzHUDBase");
static_assert(sizeof(AGzHUDBase) == 0x0004B0, "Wrong size on AGzHUDBase");
static_assert(offsetof(AGzHUDBase, ViewClass) == 0x0003A8, "Member 'AGzHUDBase::ViewClass' has a wrong offset!");
static_assert(offsetof(AGzHUDBase, bUseTabNavigation) == 0x0003D0, "Member 'AGzHUDBase::bUseTabNavigation' has a wrong offset!");
static_assert(offsetof(AGzHUDBase, UITagMap) == 0x0003D8, "Member 'AGzHUDBase::UITagMap' has a wrong offset!");
static_assert(offsetof(AGzHUDBase, SpectatorOverlayWidgetClass) == 0x000428, "Member 'AGzHUDBase::SpectatorOverlayWidgetClass' has a wrong offset!");
static_assert(offsetof(AGzHUDBase, SpectatorTransitionWidget) == 0x000430, "Member 'AGzHUDBase::SpectatorTransitionWidget' has a wrong offset!");
static_assert(offsetof(AGzHUDBase, VoiceChatStateWidgetClass) == 0x000438, "Member 'AGzHUDBase::VoiceChatStateWidgetClass' has a wrong offset!");
static_assert(offsetof(AGzHUDBase, SpectatorOverlayWidget) == 0x000460, "Member 'AGzHUDBase::SpectatorOverlayWidget' has a wrong offset!");
static_assert(offsetof(AGzHUDBase, NavigationRoot) == 0x000468, "Member 'AGzHUDBase::NavigationRoot' has a wrong offset!");
static_assert(offsetof(AGzHUDBase, View) == 0x000470, "Member 'AGzHUDBase::View' has a wrong offset!");
static_assert(offsetof(AGzHUDBase, DebugInfo) == 0x000478, "Member 'AGzHUDBase::DebugInfo' has a wrong offset!");
static_assert(offsetof(AGzHUDBase, ViewTarget) == 0x000480, "Member 'AGzHUDBase::ViewTarget' has a wrong offset!");
static_assert(offsetof(AGzHUDBase, WatermarkWidget) == 0x000488, "Member 'AGzHUDBase::WatermarkWidget' has a wrong offset!");
static_assert(offsetof(AGzHUDBase, VoiceChatStateWidget) == 0x000490, "Member 'AGzHUDBase::VoiceChatStateWidget' has a wrong offset!");
static_assert(offsetof(AGzHUDBase, VoiceChatStatePosNormalized) == 0x000498, "Member 'AGzHUDBase::VoiceChatStatePosNormalized' has a wrong offset!");

// Class G01.GzAIParamConfig
// 0x0028 (0x0058 - 0x0030)
class UGzAIParamConfig final : public UDataAsset
{
public:
	float                                         FreeStateSpeed;                                    // 0x0030(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AlertStateSpeed;                                   // 0x0034(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CombatStateSpeed;                                  // 0x0038(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TimeToFirstAttack;                                 // 0x003C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TimeToFirstAttackDeviation;                        // 0x0040(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AttackTime;                                        // 0x0044(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AttackTimeDeviation;                               // 0x0048(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DelayAttackTime;                                   // 0x004C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DelayAttackTimeDeviation;                          // 0x0050(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2DA7[0x4];                                     // 0x0054(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzAIParamConfig">();
	}
	static class UGzAIParamConfig* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzAIParamConfig>();
	}
};
static_assert(alignof(UGzAIParamConfig) == 0x000008, "Wrong alignment on UGzAIParamConfig");
static_assert(sizeof(UGzAIParamConfig) == 0x000058, "Wrong size on UGzAIParamConfig");
static_assert(offsetof(UGzAIParamConfig, FreeStateSpeed) == 0x000030, "Member 'UGzAIParamConfig::FreeStateSpeed' has a wrong offset!");
static_assert(offsetof(UGzAIParamConfig, AlertStateSpeed) == 0x000034, "Member 'UGzAIParamConfig::AlertStateSpeed' has a wrong offset!");
static_assert(offsetof(UGzAIParamConfig, CombatStateSpeed) == 0x000038, "Member 'UGzAIParamConfig::CombatStateSpeed' has a wrong offset!");
static_assert(offsetof(UGzAIParamConfig, TimeToFirstAttack) == 0x00003C, "Member 'UGzAIParamConfig::TimeToFirstAttack' has a wrong offset!");
static_assert(offsetof(UGzAIParamConfig, TimeToFirstAttackDeviation) == 0x000040, "Member 'UGzAIParamConfig::TimeToFirstAttackDeviation' has a wrong offset!");
static_assert(offsetof(UGzAIParamConfig, AttackTime) == 0x000044, "Member 'UGzAIParamConfig::AttackTime' has a wrong offset!");
static_assert(offsetof(UGzAIParamConfig, AttackTimeDeviation) == 0x000048, "Member 'UGzAIParamConfig::AttackTimeDeviation' has a wrong offset!");
static_assert(offsetof(UGzAIParamConfig, DelayAttackTime) == 0x00004C, "Member 'UGzAIParamConfig::DelayAttackTime' has a wrong offset!");
static_assert(offsetof(UGzAIParamConfig, DelayAttackTimeDeviation) == 0x000050, "Member 'UGzAIParamConfig::DelayAttackTimeDeviation' has a wrong offset!");

// Class G01.GzPartyServiceBase
// 0x0120 (0x01C0 - 0x00A0)
class UGzPartyServiceBase : public UGzClientPFObject
{
public:
	uint8                                         Pad_2DA8[0xF0];                                    // 0x00A0(0x00F0)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGzPartyInfo                           LocalParty;                                        // 0x0190(0x0020)(Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_2DA9[0x10];                                    // 0x01B0(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzPartyServiceBase">();
	}
	static class UGzPartyServiceBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzPartyServiceBase>();
	}
};
static_assert(alignof(UGzPartyServiceBase) == 0x000008, "Wrong alignment on UGzPartyServiceBase");
static_assert(sizeof(UGzPartyServiceBase) == 0x0001C0, "Wrong size on UGzPartyServiceBase");
static_assert(offsetof(UGzPartyServiceBase, LocalParty) == 0x000190, "Member 'UGzPartyServiceBase::LocalParty' has a wrong offset!");

// Class G01.GzTeamBlueprintLibrary
// 0x0000 (0x0028 - 0x0028)
class UGzTeamBlueprintLibrary final : public UBlueprintFunctionLibrary
{
public:
	static TArray<class AGzPlayerState*> FindDefeatedTeammates(class APlayerState* PlayerState, bool IncludePlayer);
	static TArray<class AGzPlayerState*> FindTeammates(class APlayerState* PlayerState, bool IncludePlayer);
	static TArray<class AGzPlayerState*> FindTeammatesInMatch(class APlayerState* PlayerState, bool IncludePlayer);
	static TArray<int32> GetAliveTeams(class UObject* WorldContextObject);
	static int32 GetNumAliveTeams(class UObject* WorldContextObject);
	static int32 GetNumNotDefeatedTeams(class UObject* WorldContextObject);
	static class AGzPlayerCharacter* GetPlayerCharacterFromPlayerId(const class UObject* WorldContextObject, int32 PlayerId);
	static class AGzPlayerState* GetPlayerState(const class UObject* WorldContextObject, int32 PlayerId);
	static ETeamAttitude GetTeamAttitude(class AActor* A, class AActor* B);
	static ETeamAttitude GetTeamAttitudeByPlayerIds(const class UObject* WorldContextObject, int32 PlayerIdA, int32 PlayerIdB);
	static class AGzTeam* GetTeamFromPlayer(const class AActor* Player);
	static class AGzTeam* GetTeamFromPlayerId(const class UObject* WorldContextObject, int32 PlayerId);
	static TArray<int32> GetTeamMembers(class UObject* WorldContextObject, int32 Team);
	static int32 GetTeamsCount(class UObject* WorldContextObject);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzTeamBlueprintLibrary">();
	}
	static class UGzTeamBlueprintLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzTeamBlueprintLibrary>();
	}
};
static_assert(alignof(UGzTeamBlueprintLibrary) == 0x000008, "Wrong alignment on UGzTeamBlueprintLibrary");
static_assert(sizeof(UGzTeamBlueprintLibrary) == 0x000028, "Wrong size on UGzTeamBlueprintLibrary");

// Class G01.GzGameStatCollector
// 0x0010 (0x0038 - 0x0028)
class UGzGameStatCollector : public UObject
{
public:
	class UGzGameStatTemplate*                    StatTemplate;                                      // 0x0028(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2DB6[0x8];                                     // 0x0030(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnStartCollecting();
	void OnStopCollecting();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzGameStatCollector">();
	}
	static class UGzGameStatCollector* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzGameStatCollector>();
	}
};
static_assert(alignof(UGzGameStatCollector) == 0x000008, "Wrong alignment on UGzGameStatCollector");
static_assert(sizeof(UGzGameStatCollector) == 0x000038, "Wrong size on UGzGameStatCollector");
static_assert(offsetof(UGzGameStatCollector, StatTemplate) == 0x000028, "Member 'UGzGameStatCollector::StatTemplate' has a wrong offset!");

// Class G01.GzGlobalStatsCollector
// 0x0000 (0x0038 - 0x0038)
class UGzGlobalStatsCollector : public UGzGameStatCollector
{
public:
	void IncrementStat(const int32 PlayerId);
	void IncrementSubStat(const class FName& SubKey, const int32 PlayerId);
	void SetStat(const int32 PlayerId, const float Value);
	void SetSubStat(const class FName& SubKey, const int32 PlayerId, const float Value);

	void AddStat(const int32 PlayerId, const float Value) const;
	void AddSubStat(const class FName& SubKey, const int32 PlayerId, const float Value) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzGlobalStatsCollector">();
	}
	static class UGzGlobalStatsCollector* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzGlobalStatsCollector>();
	}
};
static_assert(alignof(UGzGlobalStatsCollector) == 0x000008, "Wrong alignment on UGzGlobalStatsCollector");
static_assert(sizeof(UGzGlobalStatsCollector) == 0x000038, "Wrong size on UGzGlobalStatsCollector");

// Class G01.GzHexTypeExtractionStatsCollector
// 0x0008 (0x0040 - 0x0038)
class UGzHexTypeExtractionStatsCollector final : public UGzGlobalStatsCollector
{
public:
	uint8                                         Pad_2DB7[0x8];                                     // 0x0038(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzHexTypeExtractionStatsCollector">();
	}
	static class UGzHexTypeExtractionStatsCollector* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzHexTypeExtractionStatsCollector>();
	}
};
static_assert(alignof(UGzHexTypeExtractionStatsCollector) == 0x000008, "Wrong alignment on UGzHexTypeExtractionStatsCollector");
static_assert(sizeof(UGzHexTypeExtractionStatsCollector) == 0x000040, "Wrong size on UGzHexTypeExtractionStatsCollector");

// Class G01.GzAIPawn
// 0x0168 (0x0490 - 0x0328)
class AGzAIPawn : public APawn
{
public:
	uint8                                         Pad_2DB8[0x58];                                    // 0x0328(0x0058)(Fixing Size After Last Property [ Dumper-7 ])
	class UGzAbilitySystemComponent*              AbilitySystemComponent;                            // 0x0380(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UGzDamageableComponent*                 DamageableComponent;                               // 0x0388(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAkComponent*                           AkComponent;                                       // 0x0390(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UGzAliveObjectAttributeSet*             AliveObjectAttributeSet;                           // 0x0398(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDataTable*                             DefaultAttributes;                                 // 0x03A0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<TSubclassOf<class UGameplayEffect>>    StartupEffects;                                    // 0x03A8(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	class UDefaultCharacterSetup*                 DefaultPawnSetup;                                  // 0x03B8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FGenericTeamId                         TeamID;                                            // 0x03C0(0x0001)(BlueprintVisible, BlueprintReadOnly, Net, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2DB9[0x7];                                     // 0x03C1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<struct FGameplayTag, struct FGzEquipStateData> NewEquipStateMapping;                              // 0x03C8(0x0050)(Edit, Config, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	class UGzZoneTrackingComponent*               ZoneTrackingComponent;                             // 0x0418(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                BaseTranslationOffset;                             // 0x0420(0x0018)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2DBA[0x8];                                     // 0x0438(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FQuat                                  BaseRotationOffset;                                // 0x0440(0x0020)(IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UGzInvComponent*                        CachedInventoryComponent;                          // 0x0460(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UGzCombatComponent*                     CachedCombatComponent;                             // 0x0468(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class USkeletalMeshComponent*                 Mesh;                                              // 0x0470(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UCapsuleComponent*                      CapsuleComponent;                                  // 0x0478(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bUseWeaponAutoEquip;                               // 0x0480(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2DBB[0x3];                                     // 0x0481(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         AiId;                                              // 0x0484(0x0004)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2DBC[0x8];                                     // 0x0488(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnDeath();
	void OnHealthChange(float Health);
	void OnRep_TeamId();
	void Shoot(bool bStart);

	class UGzCombatComponent* GetCombatComponent() const;
	class UGzAbilitySystemComponent* GetGzAbilitySystemComponent() const;
	class UGzInvComponent* GetInventoryComponent() const;
	bool HasCombatComponent() const;
	bool HasInventoryComponent() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzAIPawn">();
	}
	static class AGzAIPawn* GetDefaultObj()
	{
		return GetDefaultObjImpl<AGzAIPawn>();
	}
};
static_assert(alignof(AGzAIPawn) == 0x000010, "Wrong alignment on AGzAIPawn");
static_assert(sizeof(AGzAIPawn) == 0x000490, "Wrong size on AGzAIPawn");
static_assert(offsetof(AGzAIPawn, AbilitySystemComponent) == 0x000380, "Member 'AGzAIPawn::AbilitySystemComponent' has a wrong offset!");
static_assert(offsetof(AGzAIPawn, DamageableComponent) == 0x000388, "Member 'AGzAIPawn::DamageableComponent' has a wrong offset!");
static_assert(offsetof(AGzAIPawn, AkComponent) == 0x000390, "Member 'AGzAIPawn::AkComponent' has a wrong offset!");
static_assert(offsetof(AGzAIPawn, AliveObjectAttributeSet) == 0x000398, "Member 'AGzAIPawn::AliveObjectAttributeSet' has a wrong offset!");
static_assert(offsetof(AGzAIPawn, DefaultAttributes) == 0x0003A0, "Member 'AGzAIPawn::DefaultAttributes' has a wrong offset!");
static_assert(offsetof(AGzAIPawn, StartupEffects) == 0x0003A8, "Member 'AGzAIPawn::StartupEffects' has a wrong offset!");
static_assert(offsetof(AGzAIPawn, DefaultPawnSetup) == 0x0003B8, "Member 'AGzAIPawn::DefaultPawnSetup' has a wrong offset!");
static_assert(offsetof(AGzAIPawn, TeamID) == 0x0003C0, "Member 'AGzAIPawn::TeamID' has a wrong offset!");
static_assert(offsetof(AGzAIPawn, NewEquipStateMapping) == 0x0003C8, "Member 'AGzAIPawn::NewEquipStateMapping' has a wrong offset!");
static_assert(offsetof(AGzAIPawn, ZoneTrackingComponent) == 0x000418, "Member 'AGzAIPawn::ZoneTrackingComponent' has a wrong offset!");
static_assert(offsetof(AGzAIPawn, BaseTranslationOffset) == 0x000420, "Member 'AGzAIPawn::BaseTranslationOffset' has a wrong offset!");
static_assert(offsetof(AGzAIPawn, BaseRotationOffset) == 0x000440, "Member 'AGzAIPawn::BaseRotationOffset' has a wrong offset!");
static_assert(offsetof(AGzAIPawn, CachedInventoryComponent) == 0x000460, "Member 'AGzAIPawn::CachedInventoryComponent' has a wrong offset!");
static_assert(offsetof(AGzAIPawn, CachedCombatComponent) == 0x000468, "Member 'AGzAIPawn::CachedCombatComponent' has a wrong offset!");
static_assert(offsetof(AGzAIPawn, Mesh) == 0x000470, "Member 'AGzAIPawn::Mesh' has a wrong offset!");
static_assert(offsetof(AGzAIPawn, CapsuleComponent) == 0x000478, "Member 'AGzAIPawn::CapsuleComponent' has a wrong offset!");
static_assert(offsetof(AGzAIPawn, bUseWeaponAutoEquip) == 0x000480, "Member 'AGzAIPawn::bUseWeaponAutoEquip' has a wrong offset!");
static_assert(offsetof(AGzAIPawn, AiId) == 0x000484, "Member 'AGzAIPawn::AiId' has a wrong offset!");

// Class G01.GzUserWidgetExtension
// 0x0000 (0x0028 - 0x0028)
class UGzUserWidgetExtension : public UUserWidgetExtension
{
public:
	void EventTick(const struct FGeometry& MyGeometry, float InDeltaTime);
	void OnConstruct();
	void OnDestruct();
	void OnInitialize();

	bool DoesRequiresTick() const;
	class UUserWidget* GetWidget() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzUserWidgetExtension">();
	}
	static class UGzUserWidgetExtension* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzUserWidgetExtension>();
	}
};
static_assert(alignof(UGzUserWidgetExtension) == 0x000008, "Wrong alignment on UGzUserWidgetExtension");
static_assert(sizeof(UGzUserWidgetExtension) == 0x000028, "Wrong size on UGzUserWidgetExtension");

// Class G01.GzAIPawnInterface
// 0x0000 (0x0028 - 0x0028)
class IGzAIPawnInterface final : public IInterface
{
public:
	int32 GetAiId() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzAIPawnInterface">();
	}
	static class IGzAIPawnInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IGzAIPawnInterface>();
	}
};
static_assert(alignof(IGzAIPawnInterface) == 0x000008, "Wrong alignment on IGzAIPawnInterface");
static_assert(sizeof(IGzAIPawnInterface) == 0x000028, "Wrong size on IGzAIPawnInterface");

// Class G01.GzLimbComponent
// 0x00F0 (0x1060 - 0x0F70)
class UGzLimbComponent final : public USkeletalMeshComponent
{
public:
	uint8                                         Pad_2DBD[0x8];                                     // 0x0F68(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	FMulticastSparseDelegateProperty_             OnDamaged;                                         // 0x0F70(0x0001)(InstancedReference, BlueprintAssignable, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_2DBE[0x7];                                     // 0x0F71(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class USkeletalMesh*                          MangledMesh;                                       // 0x0F78(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2DBF[0x8];                                     // 0x0F80(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGzLimbInvItem                         Item;                                              // 0x0F88(0x0058)(Transient, NativeAccessSpecifierPrivate)
	TArray<class UNiagaraComponent*>              LimbParticleComponents;                            // 0x0FE0(0x0010)(ExportObject, ZeroConstructor, Transient, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	TArray<class UNiagaraComponent*>              LimbGlitchComponents;                              // 0x0FF0(0x0010)(ExportObject, ZeroConstructor, Transient, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2DC0[0x60];                                    // 0x1000(0x0060)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	float GetArmorDamageReductionValue() const;
	class UGzBodyPartItemData* GetBodyPartItemData() const;
	float GetLimbDamageMultiplier() const;
	EGzLimbType GetType() const;
	bool HasLoadedMesh() const;
	bool IsDetachable() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzLimbComponent">();
	}
	static class UGzLimbComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzLimbComponent>();
	}
};
static_assert(alignof(UGzLimbComponent) == 0x000010, "Wrong alignment on UGzLimbComponent");
static_assert(sizeof(UGzLimbComponent) == 0x001060, "Wrong size on UGzLimbComponent");
static_assert(offsetof(UGzLimbComponent, OnDamaged) == 0x000F70, "Member 'UGzLimbComponent::OnDamaged' has a wrong offset!");
static_assert(offsetof(UGzLimbComponent, MangledMesh) == 0x000F78, "Member 'UGzLimbComponent::MangledMesh' has a wrong offset!");
static_assert(offsetof(UGzLimbComponent, Item) == 0x000F88, "Member 'UGzLimbComponent::Item' has a wrong offset!");
static_assert(offsetof(UGzLimbComponent, LimbParticleComponents) == 0x000FE0, "Member 'UGzLimbComponent::LimbParticleComponents' has a wrong offset!");
static_assert(offsetof(UGzLimbComponent, LimbGlitchComponents) == 0x000FF0, "Member 'UGzLimbComponent::LimbGlitchComponents' has a wrong offset!");

// Class G01.GzASCActor
// 0x0018 (0x02B8 - 0x02A0)
class AGzASCActor : public AActor
{
public:
	uint8                                         Pad_2DC1[0x8];                                     // 0x02A0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UGzAbilitySystemComponent*              ASC;                                               // 0x02A8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UGameplayEffect>            SpawnEffect;                                       // 0x02B0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, ExposeOnSpawn, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzASCActor">();
	}
	static class AGzASCActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<AGzASCActor>();
	}
};
static_assert(alignof(AGzASCActor) == 0x000008, "Wrong alignment on AGzASCActor");
static_assert(sizeof(AGzASCActor) == 0x0002B8, "Wrong size on AGzASCActor");
static_assert(offsetof(AGzASCActor, ASC) == 0x0002A8, "Member 'AGzASCActor::ASC' has a wrong offset!");
static_assert(offsetof(AGzASCActor, SpawnEffect) == 0x0002B0, "Member 'AGzASCActor::SpawnEffect' has a wrong offset!");

// Class G01.GzDamageableActor
// 0x0048 (0x0300 - 0x02B8)
class AGzDamageableActor : public AGzASCActor
{
public:
	uint8                                         Pad_2DC2[0x30];                                    // 0x02B8(0x0030)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bIsCombatRelevant;                                 // 0x02E8(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2DC3[0x7];                                     // 0x02E9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UGzAliveObjectAttributeSet*             AliveObjectAttributeSet;                           // 0x02F0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, Net, ZeroConstructor, InstancedReference, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UGzDamageableComponent*                 DamageableComponent;                               // 0x02F8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void BP_OnDeath(bool HasDeathHitPoint, const struct FVector& DeathHitPoint);
	void BP_OnHealthChange(float Health);
	void OnRep_AliveObjectAttributeSet();

	float GetCurrentHealth() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzDamageableActor">();
	}
	static class AGzDamageableActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<AGzDamageableActor>();
	}
};
static_assert(alignof(AGzDamageableActor) == 0x000008, "Wrong alignment on AGzDamageableActor");
static_assert(sizeof(AGzDamageableActor) == 0x000300, "Wrong size on AGzDamageableActor");
static_assert(offsetof(AGzDamageableActor, bIsCombatRelevant) == 0x0002E8, "Member 'AGzDamageableActor::bIsCombatRelevant' has a wrong offset!");
static_assert(offsetof(AGzDamageableActor, AliveObjectAttributeSet) == 0x0002F0, "Member 'AGzDamageableActor::AliveObjectAttributeSet' has a wrong offset!");
static_assert(offsetof(AGzDamageableActor, DamageableComponent) == 0x0002F8, "Member 'AGzDamageableActor::DamageableComponent' has a wrong offset!");

// Class G01.GzHitReactableActor
// 0x0010 (0x0310 - 0x0300)
class AGzHitReactableActor : public AGzDamageableActor
{
public:
	TArray<struct FHitResult>                     DamageHits;                                        // 0x0300(0x0010)(Net, ZeroConstructor, RepNotify, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)

public:
	void BP_ClientOnDiedPlayFx(const struct FVector& LastHitLocation);
	void BP_OnHitApplied(const struct FHitResult& HitResult);
	bool GetLastHitResult(struct FHitResult* OutHitResult);
	void Multicast_OnDied(const struct FVector_NetQuantize& LastHitLocation);
	void OnRep_Hits(const TArray<struct FHitResult>& OldHits);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzHitReactableActor">();
	}
	static class AGzHitReactableActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<AGzHitReactableActor>();
	}
};
static_assert(alignof(AGzHitReactableActor) == 0x000008, "Wrong alignment on AGzHitReactableActor");
static_assert(sizeof(AGzHitReactableActor) == 0x000310, "Wrong size on AGzHitReactableActor");
static_assert(offsetof(AGzHitReactableActor, DamageHits) == 0x000300, "Member 'AGzHitReactableActor::DamageHits' has a wrong offset!");

// Class G01.GzConfirmLoadoutSelectionButton
// 0x0000 (0x1630 - 0x1630)
class UGzConfirmLoadoutSelectionButton final : public UGzCommonButton
{
public:
	void SetCooldown(const float Cooldown);
	void SetDisabled();
	void SetEnabled();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzConfirmLoadoutSelectionButton">();
	}
	static class UGzConfirmLoadoutSelectionButton* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzConfirmLoadoutSelectionButton>();
	}
};
static_assert(alignof(UGzConfirmLoadoutSelectionButton) == 0x000010, "Wrong alignment on UGzConfirmLoadoutSelectionButton");
static_assert(sizeof(UGzConfirmLoadoutSelectionButton) == 0x001630, "Wrong size on UGzConfirmLoadoutSelectionButton");

// Class G01.GzAIProcessTargetComponent
// 0x00F0 (0x0198 - 0x00A8)
class UGzAIProcessTargetComponent : public UActorComponent
{
public:
	class UCurveFloat*                            DistanceTargetWeightsCurve;                        // 0x00A8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCurveFloat*                            DamageTargetWeightsCurve;                          // 0x00B0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RatioKnockDown;                                    // 0x00B8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RatioHasNoFreeToken;                               // 0x00BC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RatioHasNoActiveSightSenseStimulus;                // 0x00C0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RatioDamage;                                       // 0x00C4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinTargetTime;                                     // 0x00C8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinTargetTimeDeviation;                            // 0x00CC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMap<int32, TWeakObjectPtr<class AActor>>     TargetsMap;                                        // 0x00D0(0x0050)(Transient, UObjectWrapper, NativeAccessSpecifierPrivate)
	TWeakObjectPtr<class AGzAIController>         AIController;                                      // 0x0120(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TWeakObjectPtr<class APawn>                   PawnOwner;                                         // 0x0128(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TWeakObjectPtr<class AActor>                  CurrentTarget;                                     // 0x0130(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2DC6[0x60];                                    // 0x0138(0x0060)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AddAlertLocation(int32 TargetId, const struct FVector& Location);
	void RemoveAllAlertLocation();
	bool TryAddUniqueTarget(class AActor* Target, int32 TargetId);
	bool TryRemoveNonActiveTarget(int32 TargetId);
	bool TryRemoveTarget(int32 TargetId);
	void UpdateTargets(float DeltaTime);

	class AGzAIController* GetAIController() const;
	class AActor* GetCurrentTarget() const;
	bool GetNearestAlertLocation(struct FVector& OutLocation) const;
	class APawn* GetPawnOwner() const;
	bool HasAlertLocations() const;
	bool HasTargets() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzAIProcessTargetComponent">();
	}
	static class UGzAIProcessTargetComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzAIProcessTargetComponent>();
	}
};
static_assert(alignof(UGzAIProcessTargetComponent) == 0x000008, "Wrong alignment on UGzAIProcessTargetComponent");
static_assert(sizeof(UGzAIProcessTargetComponent) == 0x000198, "Wrong size on UGzAIProcessTargetComponent");
static_assert(offsetof(UGzAIProcessTargetComponent, DistanceTargetWeightsCurve) == 0x0000A8, "Member 'UGzAIProcessTargetComponent::DistanceTargetWeightsCurve' has a wrong offset!");
static_assert(offsetof(UGzAIProcessTargetComponent, DamageTargetWeightsCurve) == 0x0000B0, "Member 'UGzAIProcessTargetComponent::DamageTargetWeightsCurve' has a wrong offset!");
static_assert(offsetof(UGzAIProcessTargetComponent, RatioKnockDown) == 0x0000B8, "Member 'UGzAIProcessTargetComponent::RatioKnockDown' has a wrong offset!");
static_assert(offsetof(UGzAIProcessTargetComponent, RatioHasNoFreeToken) == 0x0000BC, "Member 'UGzAIProcessTargetComponent::RatioHasNoFreeToken' has a wrong offset!");
static_assert(offsetof(UGzAIProcessTargetComponent, RatioHasNoActiveSightSenseStimulus) == 0x0000C0, "Member 'UGzAIProcessTargetComponent::RatioHasNoActiveSightSenseStimulus' has a wrong offset!");
static_assert(offsetof(UGzAIProcessTargetComponent, RatioDamage) == 0x0000C4, "Member 'UGzAIProcessTargetComponent::RatioDamage' has a wrong offset!");
static_assert(offsetof(UGzAIProcessTargetComponent, MinTargetTime) == 0x0000C8, "Member 'UGzAIProcessTargetComponent::MinTargetTime' has a wrong offset!");
static_assert(offsetof(UGzAIProcessTargetComponent, MinTargetTimeDeviation) == 0x0000CC, "Member 'UGzAIProcessTargetComponent::MinTargetTimeDeviation' has a wrong offset!");
static_assert(offsetof(UGzAIProcessTargetComponent, TargetsMap) == 0x0000D0, "Member 'UGzAIProcessTargetComponent::TargetsMap' has a wrong offset!");
static_assert(offsetof(UGzAIProcessTargetComponent, AIController) == 0x000120, "Member 'UGzAIProcessTargetComponent::AIController' has a wrong offset!");
static_assert(offsetof(UGzAIProcessTargetComponent, PawnOwner) == 0x000128, "Member 'UGzAIProcessTargetComponent::PawnOwner' has a wrong offset!");
static_assert(offsetof(UGzAIProcessTargetComponent, CurrentTarget) == 0x000130, "Member 'UGzAIProcessTargetComponent::CurrentTarget' has a wrong offset!");

// Class G01.GzAITokenComponent
// 0x0060 (0x0108 - 0x00A8)
class UGzAITokenComponent : public UActorComponent
{
public:
	int32                                         MaxTokenOwners;                                    // 0x00A8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         TimeTokenCanBeChanged;                             // 0x00AC(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         TimeTokenCanBeChangedDeviation;                    // 0x00B0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2DCC[0x4];                                     // 0x00B4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<uint32, struct FAITokenData>             TokenDataMap;                                      // 0x00B8(0x0050)(Transient, NativeAccessSpecifierPrivate)

public:
	bool AddAttacker(class APawn* InPawn);
	void RemoveAttacker(class APawn* InPawn);

	bool CanBeAttackedBy(class APawn* InPawn) const;
	int32 GetNumAttackers() const;
	bool HasAttacker(const class APawn* InPawn) const;
	bool HasFreeToken() const;
	bool IsValidAttacker(class APawn* InPawn) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzAITokenComponent">();
	}
	static class UGzAITokenComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzAITokenComponent>();
	}
};
static_assert(alignof(UGzAITokenComponent) == 0x000008, "Wrong alignment on UGzAITokenComponent");
static_assert(sizeof(UGzAITokenComponent) == 0x000108, "Wrong size on UGzAITokenComponent");
static_assert(offsetof(UGzAITokenComponent, MaxTokenOwners) == 0x0000A8, "Member 'UGzAITokenComponent::MaxTokenOwners' has a wrong offset!");
static_assert(offsetof(UGzAITokenComponent, TimeTokenCanBeChanged) == 0x0000AC, "Member 'UGzAITokenComponent::TimeTokenCanBeChanged' has a wrong offset!");
static_assert(offsetof(UGzAITokenComponent, TimeTokenCanBeChangedDeviation) == 0x0000B0, "Member 'UGzAITokenComponent::TimeTokenCanBeChangedDeviation' has a wrong offset!");
static_assert(offsetof(UGzAITokenComponent, TokenDataMap) == 0x0000B8, "Member 'UGzAITokenComponent::TokenDataMap' has a wrong offset!");

// Class G01.GzCritHitResultInterface
// 0x0000 (0x0028 - 0x0028)
class IGzCritHitResultInterface final : public IInterface
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzCritHitResultInterface">();
	}
	static class IGzCritHitResultInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IGzCritHitResultInterface>();
	}
};
static_assert(alignof(IGzCritHitResultInterface) == 0x000008, "Wrong alignment on IGzCritHitResultInterface");
static_assert(sizeof(IGzCritHitResultInterface) == 0x000028, "Wrong size on IGzCritHitResultInterface");

// Class G01.GzAIVoiceComponent
// 0x00B0 (0x0158 - 0x00A8)
class UGzAIVoiceComponent : public UActorComponent
{
public:
	TMap<struct FGameplayTag, struct FBarkData>   BarksMap;                                          // 0x00A8(0x0050)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_2DD1[0x60];                                    // 0x00F8(0x0060)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnStartSoundAccepted(const struct FGameplayTag& AudioEventTag, bool StopActive);
	bool StartSound(const struct FGameplayTag& AIBarkTag, bool StopActiveCooldownAndSound);

	bool HasActiveSound() const;
	bool IsSoundActive(const struct FGameplayTag& AIBarkTag) const;
	bool IsSoundCooldown(const struct FGameplayTag& AIBarkTag) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzAIVoiceComponent">();
	}
	static class UGzAIVoiceComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzAIVoiceComponent>();
	}
};
static_assert(alignof(UGzAIVoiceComponent) == 0x000008, "Wrong alignment on UGzAIVoiceComponent");
static_assert(sizeof(UGzAIVoiceComponent) == 0x000158, "Wrong size on UGzAIVoiceComponent");
static_assert(offsetof(UGzAIVoiceComponent, BarksMap) == 0x0000A8, "Member 'UGzAIVoiceComponent::BarksMap' has a wrong offset!");

// Class G01.GzMarkerWidget
// 0x0058 (0x0338 - 0x02E0)
class UGzMarkerWidget : public UUserWidget
{
public:
	struct FGameplayTagContainer                  TargetStates;                                      // 0x02E0(0x0020)(Edit, Protected, NativeAccessSpecifierProtected)
	class UGzMarkerComponent*                     MarkerComponent;                                   // 0x0300(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, Transient, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UGzBaseMarkerContainer*                 ParentContainer;                                   // 0x0308(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, Transient, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EGzMarkerActiveState                          ActiveState;                                       // 0x0310(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2DD6[0x7];                                     // 0x0311(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UWidgetAnimation*                       HighlightedAnim;                                   // 0x0318(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       WarningAnim;                                       // 0x0320(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidget*                                HighlightWidget;                                   // 0x0328(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bVisible;                                          // 0x0330(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2DD7[0x7];                                     // 0x0331(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnPreRemoveWidget();
	void OnShow(bool bInVisible);
	void SetupActiveState();
	void SetupDisabledState();
	void SetupHiddenState();

	ESlateVisibility GetHideVisibility() const;
	ESlateVisibility GetShowVisibility() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzMarkerWidget">();
	}
	static class UGzMarkerWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzMarkerWidget>();
	}
};
static_assert(alignof(UGzMarkerWidget) == 0x000008, "Wrong alignment on UGzMarkerWidget");
static_assert(sizeof(UGzMarkerWidget) == 0x000338, "Wrong size on UGzMarkerWidget");
static_assert(offsetof(UGzMarkerWidget, TargetStates) == 0x0002E0, "Member 'UGzMarkerWidget::TargetStates' has a wrong offset!");
static_assert(offsetof(UGzMarkerWidget, MarkerComponent) == 0x000300, "Member 'UGzMarkerWidget::MarkerComponent' has a wrong offset!");
static_assert(offsetof(UGzMarkerWidget, ParentContainer) == 0x000308, "Member 'UGzMarkerWidget::ParentContainer' has a wrong offset!");
static_assert(offsetof(UGzMarkerWidget, ActiveState) == 0x000310, "Member 'UGzMarkerWidget::ActiveState' has a wrong offset!");
static_assert(offsetof(UGzMarkerWidget, HighlightedAnim) == 0x000318, "Member 'UGzMarkerWidget::HighlightedAnim' has a wrong offset!");
static_assert(offsetof(UGzMarkerWidget, WarningAnim) == 0x000320, "Member 'UGzMarkerWidget::WarningAnim' has a wrong offset!");
static_assert(offsetof(UGzMarkerWidget, HighlightWidget) == 0x000328, "Member 'UGzMarkerWidget::HighlightWidget' has a wrong offset!");
static_assert(offsetof(UGzMarkerWidget, bVisible) == 0x000330, "Member 'UGzMarkerWidget::bVisible' has a wrong offset!");

// Class G01.GzMapMarkerWidget
// 0x0068 (0x03A0 - 0x0338)
class UGzMapMarkerWidget : public UGzMarkerWidget
{
public:
	uint8                                         Pad_2DD8[0x18];                                    // 0x0338(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	FMulticastInlineDelegateProperty_             OnMarkerOffMapChanged;                             // 0x0350(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, Protected, NativeAccessSpecifierProtected)
	class UGzMapWidget*                           ParentMap;                                         // 0x0360(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, Transient, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bDisplayClampedOffMap;                             // 0x0368(0x0001)(Edit, BlueprintVisible, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bShouldClamp;                                      // 0x0369(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2DD9[0x2];                                     // 0x036A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         MarkerLocationVisibility;                          // 0x036C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ClampSizeRatio;                                    // 0x0370(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bDisplayBasedOnZoom;                               // 0x0374(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2DDA[0x3];                                     // 0x0375(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MinZoom;                                           // 0x0378(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MaxZoom;                                           // 0x037C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bEnableZoomScaleCurve;                             // 0x0380(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2DDB[0x7];                                     // 0x0381(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UCurveFloat*                            ZoomMarkerScaleCurve;                              // 0x0388(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         DefaultZoomCurveScale;                             // 0x0390(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2DDC[0xC];                                     // 0x0394(0x000C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnNotifyMapTransformChanged();
	void ResetScaleForZoomCurve();
	void ResetZoomCurveScaleFactor();
	void SetShouldClamp(bool bInShouldClamp);
	void SetZoomCurveScaleFactor(float ScaleMultiplier);

	float GetScaleByZoomCurve() const;
	float GetZoomCurveScaleFactor() const;
	bool K2_ShouldShow() const;
	bool ShouldBeClamped() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzMapMarkerWidget">();
	}
	static class UGzMapMarkerWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzMapMarkerWidget>();
	}
};
static_assert(alignof(UGzMapMarkerWidget) == 0x000008, "Wrong alignment on UGzMapMarkerWidget");
static_assert(sizeof(UGzMapMarkerWidget) == 0x0003A0, "Wrong size on UGzMapMarkerWidget");
static_assert(offsetof(UGzMapMarkerWidget, OnMarkerOffMapChanged) == 0x000350, "Member 'UGzMapMarkerWidget::OnMarkerOffMapChanged' has a wrong offset!");
static_assert(offsetof(UGzMapMarkerWidget, ParentMap) == 0x000360, "Member 'UGzMapMarkerWidget::ParentMap' has a wrong offset!");
static_assert(offsetof(UGzMapMarkerWidget, bDisplayClampedOffMap) == 0x000368, "Member 'UGzMapMarkerWidget::bDisplayClampedOffMap' has a wrong offset!");
static_assert(offsetof(UGzMapMarkerWidget, bShouldClamp) == 0x000369, "Member 'UGzMapMarkerWidget::bShouldClamp' has a wrong offset!");
static_assert(offsetof(UGzMapMarkerWidget, MarkerLocationVisibility) == 0x00036C, "Member 'UGzMapMarkerWidget::MarkerLocationVisibility' has a wrong offset!");
static_assert(offsetof(UGzMapMarkerWidget, ClampSizeRatio) == 0x000370, "Member 'UGzMapMarkerWidget::ClampSizeRatio' has a wrong offset!");
static_assert(offsetof(UGzMapMarkerWidget, bDisplayBasedOnZoom) == 0x000374, "Member 'UGzMapMarkerWidget::bDisplayBasedOnZoom' has a wrong offset!");
static_assert(offsetof(UGzMapMarkerWidget, MinZoom) == 0x000378, "Member 'UGzMapMarkerWidget::MinZoom' has a wrong offset!");
static_assert(offsetof(UGzMapMarkerWidget, MaxZoom) == 0x00037C, "Member 'UGzMapMarkerWidget::MaxZoom' has a wrong offset!");
static_assert(offsetof(UGzMapMarkerWidget, bEnableZoomScaleCurve) == 0x000380, "Member 'UGzMapMarkerWidget::bEnableZoomScaleCurve' has a wrong offset!");
static_assert(offsetof(UGzMapMarkerWidget, ZoomMarkerScaleCurve) == 0x000388, "Member 'UGzMapMarkerWidget::ZoomMarkerScaleCurve' has a wrong offset!");
static_assert(offsetof(UGzMapMarkerWidget, DefaultZoomCurveScale) == 0x000390, "Member 'UGzMapMarkerWidget::DefaultZoomCurveScale' has a wrong offset!");

// Class G01.GzShapeMapMarkerWidget
// 0x0008 (0x03A8 - 0x03A0)
class UGzShapeMapMarkerWidget : public UGzMapMarkerWidget
{
public:
	class UImage*                                 AreaImage;                                         // 0x03A0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void DrawShape();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzShapeMapMarkerWidget">();
	}
	static class UGzShapeMapMarkerWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzShapeMapMarkerWidget>();
	}
};
static_assert(alignof(UGzShapeMapMarkerWidget) == 0x000008, "Wrong alignment on UGzShapeMapMarkerWidget");
static_assert(sizeof(UGzShapeMapMarkerWidget) == 0x0003A8, "Wrong size on UGzShapeMapMarkerWidget");
static_assert(offsetof(UGzShapeMapMarkerWidget, AreaImage) == 0x0003A0, "Member 'UGzShapeMapMarkerWidget::AreaImage' has a wrong offset!");

// Class G01.GzCircleAreaMarkerWidget
// 0x0038 (0x03E0 - 0x03A8)
class UGzCircleAreaMarkerWidget : public UGzShapeMapMarkerWidget
{
public:
	class UMaterialInstanceDynamic*               CircleFillMaterialInstance;                        // 0x03A8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftObjectPtr<class UMaterialInterface>      CircleFillMaterial;                                // 0x03B0(0x0028)(Edit, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2DDD[0x8];                                     // 0x03D8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnDrawInit();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzCircleAreaMarkerWidget">();
	}
	static class UGzCircleAreaMarkerWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzCircleAreaMarkerWidget>();
	}
};
static_assert(alignof(UGzCircleAreaMarkerWidget) == 0x000008, "Wrong alignment on UGzCircleAreaMarkerWidget");
static_assert(sizeof(UGzCircleAreaMarkerWidget) == 0x0003E0, "Wrong size on UGzCircleAreaMarkerWidget");
static_assert(offsetof(UGzCircleAreaMarkerWidget, CircleFillMaterialInstance) == 0x0003A8, "Member 'UGzCircleAreaMarkerWidget::CircleFillMaterialInstance' has a wrong offset!");
static_assert(offsetof(UGzCircleAreaMarkerWidget, CircleFillMaterial) == 0x0003B0, "Member 'UGzCircleAreaMarkerWidget::CircleFillMaterial' has a wrong offset!");

// Class G01.GzHexSearchCircleMarkerWidget
// 0x0010 (0x03F0 - 0x03E0)
class UGzHexSearchCircleMarkerWidget final : public UGzCircleAreaMarkerWidget
{
public:
	class UImage*                                 HexImage;                                          // 0x03E0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         IconRadiusRatio;                                   // 0x03E8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2DDE[0x4];                                     // 0x03EC(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzHexSearchCircleMarkerWidget">();
	}
	static class UGzHexSearchCircleMarkerWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzHexSearchCircleMarkerWidget>();
	}
};
static_assert(alignof(UGzHexSearchCircleMarkerWidget) == 0x000008, "Wrong alignment on UGzHexSearchCircleMarkerWidget");
static_assert(sizeof(UGzHexSearchCircleMarkerWidget) == 0x0003F0, "Wrong size on UGzHexSearchCircleMarkerWidget");
static_assert(offsetof(UGzHexSearchCircleMarkerWidget, HexImage) == 0x0003E0, "Member 'UGzHexSearchCircleMarkerWidget::HexImage' has a wrong offset!");
static_assert(offsetof(UGzHexSearchCircleMarkerWidget, IconRadiusRatio) == 0x0003E8, "Member 'UGzHexSearchCircleMarkerWidget::IconRadiusRatio' has a wrong offset!");

// Class G01.GzAliveObjectAttributeSet
// 0x0088 (0x00B8 - 0x0030)
class UGzAliveObjectAttributeSet : public UAttributeSet
{
public:
	uint8                                         Pad_2DDF[0x38];                                    // 0x0030(0x0038)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayAttributeData                 Health;                                            // 0x0068(0x0010)(BlueprintVisible, BlueprintReadOnly, Net, RepNotify, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 MaxHealth;                                         // 0x0078(0x0010)(BlueprintVisible, BlueprintReadOnly, Net, RepNotify, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 Damage;                                            // 0x0088(0x0010)(BlueprintVisible, BlueprintReadOnly, Net, RepNotify, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 Impulse;                                           // 0x0098(0x0010)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 ExplosionDamageMultiplier;                         // 0x00A8(0x0010)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)

public:
	void OnRep_Damage(const struct FGameplayAttributeData& OldDamage);
	void OnRep_Health(const struct FGameplayAttributeData& OldHealth);
	void OnRep_MaxHealth(const struct FGameplayAttributeData& OldMaxHealth);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzAliveObjectAttributeSet">();
	}
	static class UGzAliveObjectAttributeSet* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzAliveObjectAttributeSet>();
	}
};
static_assert(alignof(UGzAliveObjectAttributeSet) == 0x000008, "Wrong alignment on UGzAliveObjectAttributeSet");
static_assert(sizeof(UGzAliveObjectAttributeSet) == 0x0000B8, "Wrong size on UGzAliveObjectAttributeSet");
static_assert(offsetof(UGzAliveObjectAttributeSet, Health) == 0x000068, "Member 'UGzAliveObjectAttributeSet::Health' has a wrong offset!");
static_assert(offsetof(UGzAliveObjectAttributeSet, MaxHealth) == 0x000078, "Member 'UGzAliveObjectAttributeSet::MaxHealth' has a wrong offset!");
static_assert(offsetof(UGzAliveObjectAttributeSet, Damage) == 0x000088, "Member 'UGzAliveObjectAttributeSet::Damage' has a wrong offset!");
static_assert(offsetof(UGzAliveObjectAttributeSet, Impulse) == 0x000098, "Member 'UGzAliveObjectAttributeSet::Impulse' has a wrong offset!");
static_assert(offsetof(UGzAliveObjectAttributeSet, ExplosionDamageMultiplier) == 0x0000A8, "Member 'UGzAliveObjectAttributeSet::ExplosionDamageMultiplier' has a wrong offset!");

// Class G01.GzConsoleAccountService
// 0x0180 (0x0220 - 0x00A0)
class alignas(0x10) UGzConsoleAccountService final : public UGzClientPFObject
{
public:
	uint8                                         Pad_2DE0[0xF8];                                    // 0x00A0(0x00F8)(Fixing Size After Last Property [ Dumper-7 ])
	class UGzPartyServiceBase*                    PartyService;                                      // 0x0198(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2DE1[0x80];                                    // 0x01A0(0x0080)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzConsoleAccountService">();
	}
	static class UGzConsoleAccountService* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzConsoleAccountService>();
	}
};
static_assert(alignof(UGzConsoleAccountService) == 0x000010, "Wrong alignment on UGzConsoleAccountService");
static_assert(sizeof(UGzConsoleAccountService) == 0x000220, "Wrong size on UGzConsoleAccountService");
static_assert(offsetof(UGzConsoleAccountService, PartyService) == 0x000198, "Member 'UGzConsoleAccountService::PartyService' has a wrong offset!");

// Class G01.GzItemDataFunctionLibrary
// 0x0000 (0x0028 - 0x0028)
class UGzItemDataFunctionLibrary final : public UBlueprintFunctionLibrary
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzItemDataFunctionLibrary">();
	}
	static class UGzItemDataFunctionLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzItemDataFunctionLibrary>();
	}
};
static_assert(alignof(UGzItemDataFunctionLibrary) == 0x000008, "Wrong alignment on UGzItemDataFunctionLibrary");
static_assert(sizeof(UGzItemDataFunctionLibrary) == 0x000028, "Wrong size on UGzItemDataFunctionLibrary");

// Class G01.GzAllTerminalsInactiveMessage
// 0x0008 (0x0030 - 0x0028)
class UGzAllTerminalsInactiveMessage final : public UGzGameMessage
{
public:
	class UClass*                                 TerminalClass;                                     // 0x0028(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzAllTerminalsInactiveMessage">();
	}
	static class UGzAllTerminalsInactiveMessage* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzAllTerminalsInactiveMessage>();
	}
};
static_assert(alignof(UGzAllTerminalsInactiveMessage) == 0x000008, "Wrong alignment on UGzAllTerminalsInactiveMessage");
static_assert(sizeof(UGzAllTerminalsInactiveMessage) == 0x000030, "Wrong size on UGzAllTerminalsInactiveMessage");
static_assert(offsetof(UGzAllTerminalsInactiveMessage, TerminalClass) == 0x000028, "Member 'UGzAllTerminalsInactiveMessage::TerminalClass' has a wrong offset!");

// Class G01.GzConsumableMessage
// 0x0008 (0x0038 - 0x0030)
class UGzConsumableMessage final : public UGzInstigatedMessage
{
public:
	class UGzItemData*                            ConsumableItemData;                                // 0x0030(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzConsumableMessage">();
	}
	static class UGzConsumableMessage* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzConsumableMessage>();
	}
};
static_assert(alignof(UGzConsumableMessage) == 0x000008, "Wrong alignment on UGzConsumableMessage");
static_assert(sizeof(UGzConsumableMessage) == 0x000038, "Wrong size on UGzConsumableMessage");
static_assert(offsetof(UGzConsumableMessage, ConsumableItemData) == 0x000030, "Member 'UGzConsumableMessage::ConsumableItemData' has a wrong offset!");

// Class G01.GzGA_Passive
// 0x0020 (0x0528 - 0x0508)
class UGzGA_Passive : public UGzGameplayAbility
{
public:
	TArray<TSubclassOf<class UGameplayEffect>>    PassiveEffects;                                    // 0x0508(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, UObjectWrapper, NativeAccessSpecifierPublic)
	uint8                                         Pad_2DE2[0x10];                                    // 0x0518(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzGA_Passive">();
	}
	static class UGzGA_Passive* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzGA_Passive>();
	}
};
static_assert(alignof(UGzGA_Passive) == 0x000008, "Wrong alignment on UGzGA_Passive");
static_assert(sizeof(UGzGA_Passive) == 0x000528, "Wrong size on UGzGA_Passive");
static_assert(offsetof(UGzGA_Passive, PassiveEffects) == 0x000508, "Member 'UGzGA_Passive::PassiveEffects' has a wrong offset!");

// Class G01.GzGA_ReloadHolsteredWeapons
// 0x0068 (0x0590 - 0x0528)
class UGzGA_ReloadHolsteredWeapons : public UGzGA_Passive
{
public:
	bool                                          bUseWeaponReloadTime;                              // 0x0528(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2DE3[0x3];                                     // 0x0529(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ReloadDelay;                                       // 0x052C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2DE4[0x60];                                    // 0x0530(0x0060)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnAmmoAdded(const struct FGzInvItem& Item, EGzInvChangeEvent Event);
	void OnWeaponPocketChanged(const struct FGzInvPocketId& PocketId);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzGA_ReloadHolsteredWeapons">();
	}
	static class UGzGA_ReloadHolsteredWeapons* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzGA_ReloadHolsteredWeapons>();
	}
};
static_assert(alignof(UGzGA_ReloadHolsteredWeapons) == 0x000008, "Wrong alignment on UGzGA_ReloadHolsteredWeapons");
static_assert(sizeof(UGzGA_ReloadHolsteredWeapons) == 0x000590, "Wrong size on UGzGA_ReloadHolsteredWeapons");
static_assert(offsetof(UGzGA_ReloadHolsteredWeapons, bUseWeaponReloadTime) == 0x000528, "Member 'UGzGA_ReloadHolsteredWeapons::bUseWeaponReloadTime' has a wrong offset!");
static_assert(offsetof(UGzGA_ReloadHolsteredWeapons, ReloadDelay) == 0x00052C, "Member 'UGzGA_ReloadHolsteredWeapons::ReloadDelay' has a wrong offset!");

// Class G01.GzItemData
// 0x02A8 (0x02D8 - 0x0030)
class UGzItemData : public UPrimaryDataAsset
{
public:
	uint8                                         Pad_2DE6[0x8];                                     // 0x0030(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FPrimaryAssetType                      AssetTypeData;                                     // 0x0038(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, NoDestructor, AssetRegistrySearchable, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<TSoftClassPtr<class UClass>>           ItemAbilities;                                     // 0x0040(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
	TArray<TSoftClassPtr<class UClass>>           ItemEffects;                                       // 0x0050(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UItemInteractionData>    ItemInteractionData;                               // 0x0060(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           ItemType;                                          // 0x0088(0x0008)(Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EGzItemRarity                                 Rarity;                                            // 0x0090(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, AssetRegistrySearchable, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EGzLayerItemType                              LayerItemType;                                     // 0x0091(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         AccessPermission;                                  // 0x0092(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bOverrideCustomSpawnRotation;                      // 0x0093(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGzCustomSpawnRotation                 CustomSpawnRotation;                               // 0x0094(0x0030)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_2DE7[0x4];                                     // 0x00C4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   DisplayName;                                       // 0x00C8(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	class FText                                   Description;                                       // 0x00D8(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	bool                                          bEnableShortDescription;                           // 0x00E8(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2DE8[0x7];                                     // 0x00E9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   DescriptionShort;                                  // 0x00F0(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	class FText                                   DescriptionShared;                                 // 0x0100(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	class FText                                   DetailedDescription;                               // 0x0110(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	class FText                                   DetailedDescriptionShared;                         // 0x0120(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	int32                                         ItemTypeSortPriority;                              // 0x0130(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsStackable;                                       // 0x0134(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsRemovable;                                       // 0x0135(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsTradable;                                        // 0x0136(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, AssetRegistrySearchable, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsLimitedEdition;                                  // 0x0137(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         InitialLimitedEditionCount;                        // 0x0138(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsUserFacingItem;                                  // 0x013C(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AssetRegistrySearchable, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsOnlineItem;                                      // 0x013D(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AssetRegistrySearchable, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsReadyForExport;                                  // 0x013E(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AssetRegistrySearchable, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2DE9[0x1];                                     // 0x013F(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<EGzItemCollectionType>                 ItemCollectionType;                                // 0x0140(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          IsMarketplaceItem;                                 // 0x0150(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AssetRegistrySearchable, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2DEA[0x3];                                     // 0x0151(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         MaxStackSize;                                      // 0x0154(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         DefaultDropAmount;                                 // 0x0158(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2DEB[0x4];                                     // 0x015C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftObjectPtr<class UTexture2D>              HUDIcon;                                           // 0x0160(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMap<struct FGameplayTag, TSoftObjectPtr<class UTexture2D>> Icons;                                             // 0x0188(0x0050)(Edit, DisableEditOnInstance, UObjectWrapper, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UTexture2D>              CoherentHideoutImage;                              // 0x01D8(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 CoherentImage;                                     // 0x0200(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Price;                                             // 0x0210(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCanAutoPickUp;                                    // 0x0214(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bForceAutoPickUpWhenNoStack;                       // 0x0215(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2DEC[0x2];                                     // 0x0216(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FGzItemAttribute>               ItemAttributes;                                    // 0x0218(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	bool                                          bConsumeOnPlayersDeath;                            // 0x0228(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsDeprecated;                                     // 0x0229(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShowInDebugMenu;                                  // 0x022A(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCreateItemParts;                                  // 0x022B(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2DED[0x4];                                     // 0x022C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftObjectPtr<class UTexture2D>              PartsIcons[0x4];                                   // 0x0230(0x0028)(Edit, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDevOnly;                                          // 0x02D0(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2DEE[0x7];                                     // 0x02D1(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	bool CanBeAccessBy(EGzItemAccessPermission PermissionMask) const;
	TSoftObjectPtr<class UTexture2D> GetHUDIconByTag(const struct FGameplayTag& IconTag, bool bWarnOnMissingTag) const;
	class FString GetIdentifierString() const;
	EGzItemRarity GetRarity() const;
	const class FText GetShortDescription() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzItemData">();
	}
	static class UGzItemData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzItemData>();
	}
};
static_assert(alignof(UGzItemData) == 0x000008, "Wrong alignment on UGzItemData");
static_assert(sizeof(UGzItemData) == 0x0002D8, "Wrong size on UGzItemData");
static_assert(offsetof(UGzItemData, AssetTypeData) == 0x000038, "Member 'UGzItemData::AssetTypeData' has a wrong offset!");
static_assert(offsetof(UGzItemData, ItemAbilities) == 0x000040, "Member 'UGzItemData::ItemAbilities' has a wrong offset!");
static_assert(offsetof(UGzItemData, ItemEffects) == 0x000050, "Member 'UGzItemData::ItemEffects' has a wrong offset!");
static_assert(offsetof(UGzItemData, ItemInteractionData) == 0x000060, "Member 'UGzItemData::ItemInteractionData' has a wrong offset!");
static_assert(offsetof(UGzItemData, ItemType) == 0x000088, "Member 'UGzItemData::ItemType' has a wrong offset!");
static_assert(offsetof(UGzItemData, Rarity) == 0x000090, "Member 'UGzItemData::Rarity' has a wrong offset!");
static_assert(offsetof(UGzItemData, LayerItemType) == 0x000091, "Member 'UGzItemData::LayerItemType' has a wrong offset!");
static_assert(offsetof(UGzItemData, AccessPermission) == 0x000092, "Member 'UGzItemData::AccessPermission' has a wrong offset!");
static_assert(offsetof(UGzItemData, bOverrideCustomSpawnRotation) == 0x000093, "Member 'UGzItemData::bOverrideCustomSpawnRotation' has a wrong offset!");
static_assert(offsetof(UGzItemData, CustomSpawnRotation) == 0x000094, "Member 'UGzItemData::CustomSpawnRotation' has a wrong offset!");
static_assert(offsetof(UGzItemData, DisplayName) == 0x0000C8, "Member 'UGzItemData::DisplayName' has a wrong offset!");
static_assert(offsetof(UGzItemData, Description) == 0x0000D8, "Member 'UGzItemData::Description' has a wrong offset!");
static_assert(offsetof(UGzItemData, bEnableShortDescription) == 0x0000E8, "Member 'UGzItemData::bEnableShortDescription' has a wrong offset!");
static_assert(offsetof(UGzItemData, DescriptionShort) == 0x0000F0, "Member 'UGzItemData::DescriptionShort' has a wrong offset!");
static_assert(offsetof(UGzItemData, DescriptionShared) == 0x000100, "Member 'UGzItemData::DescriptionShared' has a wrong offset!");
static_assert(offsetof(UGzItemData, DetailedDescription) == 0x000110, "Member 'UGzItemData::DetailedDescription' has a wrong offset!");
static_assert(offsetof(UGzItemData, DetailedDescriptionShared) == 0x000120, "Member 'UGzItemData::DetailedDescriptionShared' has a wrong offset!");
static_assert(offsetof(UGzItemData, ItemTypeSortPriority) == 0x000130, "Member 'UGzItemData::ItemTypeSortPriority' has a wrong offset!");
static_assert(offsetof(UGzItemData, IsStackable) == 0x000134, "Member 'UGzItemData::IsStackable' has a wrong offset!");
static_assert(offsetof(UGzItemData, IsRemovable) == 0x000135, "Member 'UGzItemData::IsRemovable' has a wrong offset!");
static_assert(offsetof(UGzItemData, IsTradable) == 0x000136, "Member 'UGzItemData::IsTradable' has a wrong offset!");
static_assert(offsetof(UGzItemData, IsLimitedEdition) == 0x000137, "Member 'UGzItemData::IsLimitedEdition' has a wrong offset!");
static_assert(offsetof(UGzItemData, InitialLimitedEditionCount) == 0x000138, "Member 'UGzItemData::InitialLimitedEditionCount' has a wrong offset!");
static_assert(offsetof(UGzItemData, IsUserFacingItem) == 0x00013C, "Member 'UGzItemData::IsUserFacingItem' has a wrong offset!");
static_assert(offsetof(UGzItemData, IsOnlineItem) == 0x00013D, "Member 'UGzItemData::IsOnlineItem' has a wrong offset!");
static_assert(offsetof(UGzItemData, IsReadyForExport) == 0x00013E, "Member 'UGzItemData::IsReadyForExport' has a wrong offset!");
static_assert(offsetof(UGzItemData, ItemCollectionType) == 0x000140, "Member 'UGzItemData::ItemCollectionType' has a wrong offset!");
static_assert(offsetof(UGzItemData, IsMarketplaceItem) == 0x000150, "Member 'UGzItemData::IsMarketplaceItem' has a wrong offset!");
static_assert(offsetof(UGzItemData, MaxStackSize) == 0x000154, "Member 'UGzItemData::MaxStackSize' has a wrong offset!");
static_assert(offsetof(UGzItemData, DefaultDropAmount) == 0x000158, "Member 'UGzItemData::DefaultDropAmount' has a wrong offset!");
static_assert(offsetof(UGzItemData, HUDIcon) == 0x000160, "Member 'UGzItemData::HUDIcon' has a wrong offset!");
static_assert(offsetof(UGzItemData, Icons) == 0x000188, "Member 'UGzItemData::Icons' has a wrong offset!");
static_assert(offsetof(UGzItemData, CoherentHideoutImage) == 0x0001D8, "Member 'UGzItemData::CoherentHideoutImage' has a wrong offset!");
static_assert(offsetof(UGzItemData, CoherentImage) == 0x000200, "Member 'UGzItemData::CoherentImage' has a wrong offset!");
static_assert(offsetof(UGzItemData, Price) == 0x000210, "Member 'UGzItemData::Price' has a wrong offset!");
static_assert(offsetof(UGzItemData, bCanAutoPickUp) == 0x000214, "Member 'UGzItemData::bCanAutoPickUp' has a wrong offset!");
static_assert(offsetof(UGzItemData, bForceAutoPickUpWhenNoStack) == 0x000215, "Member 'UGzItemData::bForceAutoPickUpWhenNoStack' has a wrong offset!");
static_assert(offsetof(UGzItemData, ItemAttributes) == 0x000218, "Member 'UGzItemData::ItemAttributes' has a wrong offset!");
static_assert(offsetof(UGzItemData, bConsumeOnPlayersDeath) == 0x000228, "Member 'UGzItemData::bConsumeOnPlayersDeath' has a wrong offset!");
static_assert(offsetof(UGzItemData, bIsDeprecated) == 0x000229, "Member 'UGzItemData::bIsDeprecated' has a wrong offset!");
static_assert(offsetof(UGzItemData, bShowInDebugMenu) == 0x00022A, "Member 'UGzItemData::bShowInDebugMenu' has a wrong offset!");
static_assert(offsetof(UGzItemData, bCreateItemParts) == 0x00022B, "Member 'UGzItemData::bCreateItemParts' has a wrong offset!");
static_assert(offsetof(UGzItemData, PartsIcons) == 0x000230, "Member 'UGzItemData::PartsIcons' has a wrong offset!");
static_assert(offsetof(UGzItemData, bDevOnly) == 0x0002D0, "Member 'UGzItemData::bDevOnly' has a wrong offset!");

// Class G01.GzMatchInProgressStage
// 0x0008 (0x0118 - 0x0110)
class UGzMatchInProgressStage : public UGzGameStageBase
{
public:
	bool                                          bHandleReplays;                                    // 0x0110(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2DF0[0x7];                                     // 0x0111(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzMatchInProgressStage">();
	}
	static class UGzMatchInProgressStage* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzMatchInProgressStage>();
	}
};
static_assert(alignof(UGzMatchInProgressStage) == 0x000008, "Wrong alignment on UGzMatchInProgressStage");
static_assert(sizeof(UGzMatchInProgressStage) == 0x000118, "Wrong size on UGzMatchInProgressStage");
static_assert(offsetof(UGzMatchInProgressStage, bHandleReplays) == 0x000110, "Member 'UGzMatchInProgressStage::bHandleReplays' has a wrong offset!");

// Class G01.GzSimpleItemData
// 0x00F0 (0x03C8 - 0x02D8)
class UGzSimpleItemData : public UGzItemData
{
public:
	TSoftObjectPtr<class UStaticMesh>             StaticMesh;                                        // 0x02D8(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMap<int32, TSoftObjectPtr<class UMaterialInterface>> SlotMaterialOverride;                              // 0x0300(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, UObjectWrapper, NativeAccessSpecifierPublic)
	TMap<int32, TSoftObjectPtr<class UStaticMesh>> StaticMeshMap;                                     // 0x0350(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, UObjectWrapper, NativeAccessSpecifierPublic)
	struct FVector                                MeshScaleOverride;                                 // 0x03A0(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGzPingVoiceLineData                   PingVoiceLineEvent;                                // 0x03B8(0x0010)(Edit, DisableEditOnInstance, NoDestructor, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzSimpleItemData">();
	}
	static class UGzSimpleItemData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzSimpleItemData>();
	}
};
static_assert(alignof(UGzSimpleItemData) == 0x000008, "Wrong alignment on UGzSimpleItemData");
static_assert(sizeof(UGzSimpleItemData) == 0x0003C8, "Wrong size on UGzSimpleItemData");
static_assert(offsetof(UGzSimpleItemData, StaticMesh) == 0x0002D8, "Member 'UGzSimpleItemData::StaticMesh' has a wrong offset!");
static_assert(offsetof(UGzSimpleItemData, SlotMaterialOverride) == 0x000300, "Member 'UGzSimpleItemData::SlotMaterialOverride' has a wrong offset!");
static_assert(offsetof(UGzSimpleItemData, StaticMeshMap) == 0x000350, "Member 'UGzSimpleItemData::StaticMeshMap' has a wrong offset!");
static_assert(offsetof(UGzSimpleItemData, MeshScaleOverride) == 0x0003A0, "Member 'UGzSimpleItemData::MeshScaleOverride' has a wrong offset!");
static_assert(offsetof(UGzSimpleItemData, PingVoiceLineEvent) == 0x0003B8, "Member 'UGzSimpleItemData::PingVoiceLineEvent' has a wrong offset!");

// Class G01.GzLegalDocsModel
// 0x0150 (0x01C0 - 0x0070)
class UGzLegalDocsModel final : public UGzBackendModel
{
public:
	uint8                                         Pad_2DF1[0x150];                                   // 0x0070(0x0150)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzLegalDocsModel">();
	}
	static class UGzLegalDocsModel* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzLegalDocsModel>();
	}
};
static_assert(alignof(UGzLegalDocsModel) == 0x000008, "Wrong alignment on UGzLegalDocsModel");
static_assert(sizeof(UGzLegalDocsModel) == 0x0001C0, "Wrong size on UGzLegalDocsModel");

// Class G01.GzGA_WeaponAbilityBase
// 0x0008 (0x0558 - 0x0550)
class UGzGA_WeaponAbilityBase : public UGzGA_CharacterState
{
public:
	class AGzWeaponActor*                         CachedWeapon;                                      // 0x0550(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzGA_WeaponAbilityBase">();
	}
	static class UGzGA_WeaponAbilityBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzGA_WeaponAbilityBase>();
	}
};
static_assert(alignof(UGzGA_WeaponAbilityBase) == 0x000008, "Wrong alignment on UGzGA_WeaponAbilityBase");
static_assert(sizeof(UGzGA_WeaponAbilityBase) == 0x000558, "Wrong size on UGzGA_WeaponAbilityBase");
static_assert(offsetof(UGzGA_WeaponAbilityBase, CachedWeapon) == 0x000550, "Member 'UGzGA_WeaponAbilityBase::CachedWeapon' has a wrong offset!");

// Class G01.GzGA_SwitchFireMode
// 0x0000 (0x0558 - 0x0558)
class UGzGA_SwitchFireMode : public UGzGA_WeaponAbilityBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzGA_SwitchFireMode">();
	}
	static class UGzGA_SwitchFireMode* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzGA_SwitchFireMode>();
	}
};
static_assert(alignof(UGzGA_SwitchFireMode) == 0x000008, "Wrong alignment on UGzGA_SwitchFireMode");
static_assert(sizeof(UGzGA_SwitchFireMode) == 0x000558, "Wrong size on UGzGA_SwitchFireMode");

// Class G01.GzFriendsServiceBase
// 0x0068 (0x0108 - 0x00A0)
class UGzFriendsServiceBase : public UGzClientPFObject
{
public:
	uint8                                         Pad_2DF2[0x68];                                    // 0x00A0(0x0068)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzFriendsServiceBase">();
	}
	static class UGzFriendsServiceBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzFriendsServiceBase>();
	}
};
static_assert(alignof(UGzFriendsServiceBase) == 0x000008, "Wrong alignment on UGzFriendsServiceBase");
static_assert(sizeof(UGzFriendsServiceBase) == 0x000108, "Wrong size on UGzFriendsServiceBase");

// Class G01.GzAmmoItemData
// 0x0010 (0x03D8 - 0x03C8)
class UGzAmmoItemData final : public UGzSimpleItemData
{
public:
	TArray<EGzWeaponType>                         WeaponTypes;                                       // 0x03C8(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzAmmoItemData">();
	}
	static class UGzAmmoItemData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzAmmoItemData>();
	}
};
static_assert(alignof(UGzAmmoItemData) == 0x000008, "Wrong alignment on UGzAmmoItemData");
static_assert(sizeof(UGzAmmoItemData) == 0x0003D8, "Wrong size on UGzAmmoItemData");
static_assert(offsetof(UGzAmmoItemData, WeaponTypes) == 0x0003C8, "Member 'UGzAmmoItemData::WeaponTypes' has a wrong offset!");

// Class G01.GzAnimatedAi
// 0x0000 (0x0028 - 0x0028)
class IGzAnimatedAi final : public IInterface
{
public:
	EGzNPCMentalState GetMentalState() const;
	struct FVector GetTrackingTargetPosition() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzAnimatedAi">();
	}
	static class IGzAnimatedAi* GetDefaultObj()
	{
		return GetDefaultObjImpl<IGzAnimatedAi>();
	}
};
static_assert(alignof(IGzAnimatedAi) == 0x000008, "Wrong alignment on IGzAnimatedAi");
static_assert(sizeof(IGzAnimatedAi) == 0x000028, "Wrong size on IGzAnimatedAi");

// Class G01.GzLimbsSwitchedStatCollector
// 0x0008 (0x0040 - 0x0038)
class UGzLimbsSwitchedStatCollector final : public UGzGlobalStatsCollector
{
public:
	uint8                                         Pad_2DF3[0x8];                                     // 0x0038(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzLimbsSwitchedStatCollector">();
	}
	static class UGzLimbsSwitchedStatCollector* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzLimbsSwitchedStatCollector>();
	}
};
static_assert(alignof(UGzLimbsSwitchedStatCollector) == 0x000008, "Wrong alignment on UGzLimbsSwitchedStatCollector");
static_assert(sizeof(UGzLimbsSwitchedStatCollector) == 0x000040, "Wrong size on UGzLimbsSwitchedStatCollector");

// Class G01.GzAnimMetaData
// 0x0000 (0x0028 - 0x0028)
class UGzAnimMetaData : public UAnimMetaData
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzAnimMetaData">();
	}
	static class UGzAnimMetaData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzAnimMetaData>();
	}
};
static_assert(alignof(UGzAnimMetaData) == 0x000008, "Wrong alignment on UGzAnimMetaData");
static_assert(sizeof(UGzAnimMetaData) == 0x000028, "Wrong size on UGzAnimMetaData");

// Class G01.GzInteractionComponent
// 0x0290 (0x0338 - 0x00A8)
class UGzInteractionComponent final : public UActorComponent
{
public:
	class UGzGA_Interact*                         CachedInteractionAbility;                          // 0x00A8(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UGzInteractableComponent*               CachedInteractable;                                // 0x00B0(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2DF4[0xF8];                                    // 0x00B8(0x00F8)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         InteractionGatherRange;                            // 0x01B0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         PreviewGatherRange;                                // 0x01B4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         CameraRayLength;                                   // 0x01B8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MaxInteractionDistance;                            // 0x01BC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MaxInteractionAngleBetweenRayAndObject;            // 0x01C0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MaxOutOfRangeInteractionAngleBetweenRayAndObject;  // 0x01C4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         RecheckVisibleInteractablesInterval;               // 0x01C8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2DF5[0x4];                                     // 0x01CC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UGzInteractableComponent*               FocusedInteractableComponent;                      // 0x01D0(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UGzInteractableComponent*               FocusedAutoInteractInteractableComponent;          // 0x01D8(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCameraComponent*                       CachedPlayerCamera;                                // 0x01E0(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSet<class UGzInteractableComponent*>         VisibleInteractables;                              // 0x01E8(0x0050)(ExportObject, Transient, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	TSet<class UGzInteractableComponent*>         InteractableComponents;                            // 0x0238(0x0050)(ExportObject, Transient, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_2DF6[0xB0];                                    // 0x0288(0x00B0)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	const class FText GetFailedInteractionText() const;
	bool GetInteractionConditionsPassed() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzInteractionComponent">();
	}
	static class UGzInteractionComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzInteractionComponent>();
	}
};
static_assert(alignof(UGzInteractionComponent) == 0x000008, "Wrong alignment on UGzInteractionComponent");
static_assert(sizeof(UGzInteractionComponent) == 0x000338, "Wrong size on UGzInteractionComponent");
static_assert(offsetof(UGzInteractionComponent, CachedInteractionAbility) == 0x0000A8, "Member 'UGzInteractionComponent::CachedInteractionAbility' has a wrong offset!");
static_assert(offsetof(UGzInteractionComponent, CachedInteractable) == 0x0000B0, "Member 'UGzInteractionComponent::CachedInteractable' has a wrong offset!");
static_assert(offsetof(UGzInteractionComponent, InteractionGatherRange) == 0x0001B0, "Member 'UGzInteractionComponent::InteractionGatherRange' has a wrong offset!");
static_assert(offsetof(UGzInteractionComponent, PreviewGatherRange) == 0x0001B4, "Member 'UGzInteractionComponent::PreviewGatherRange' has a wrong offset!");
static_assert(offsetof(UGzInteractionComponent, CameraRayLength) == 0x0001B8, "Member 'UGzInteractionComponent::CameraRayLength' has a wrong offset!");
static_assert(offsetof(UGzInteractionComponent, MaxInteractionDistance) == 0x0001BC, "Member 'UGzInteractionComponent::MaxInteractionDistance' has a wrong offset!");
static_assert(offsetof(UGzInteractionComponent, MaxInteractionAngleBetweenRayAndObject) == 0x0001C0, "Member 'UGzInteractionComponent::MaxInteractionAngleBetweenRayAndObject' has a wrong offset!");
static_assert(offsetof(UGzInteractionComponent, MaxOutOfRangeInteractionAngleBetweenRayAndObject) == 0x0001C4, "Member 'UGzInteractionComponent::MaxOutOfRangeInteractionAngleBetweenRayAndObject' has a wrong offset!");
static_assert(offsetof(UGzInteractionComponent, RecheckVisibleInteractablesInterval) == 0x0001C8, "Member 'UGzInteractionComponent::RecheckVisibleInteractablesInterval' has a wrong offset!");
static_assert(offsetof(UGzInteractionComponent, FocusedInteractableComponent) == 0x0001D0, "Member 'UGzInteractionComponent::FocusedInteractableComponent' has a wrong offset!");
static_assert(offsetof(UGzInteractionComponent, FocusedAutoInteractInteractableComponent) == 0x0001D8, "Member 'UGzInteractionComponent::FocusedAutoInteractInteractableComponent' has a wrong offset!");
static_assert(offsetof(UGzInteractionComponent, CachedPlayerCamera) == 0x0001E0, "Member 'UGzInteractionComponent::CachedPlayerCamera' has a wrong offset!");
static_assert(offsetof(UGzInteractionComponent, VisibleInteractables) == 0x0001E8, "Member 'UGzInteractionComponent::VisibleInteractables' has a wrong offset!");
static_assert(offsetof(UGzInteractionComponent, InteractableComponents) == 0x000238, "Member 'UGzInteractionComponent::InteractableComponents' has a wrong offset!");

// Class G01.GzPreMatchStage
// 0x0008 (0x0118 - 0x0110)
class UGzPreMatchStage : public UGzGameStageBase
{
public:
	uint8                                         Pad_2DF7[0x8];                                     // 0x0110(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void CheckAllReady(class AGzPlayerState* NewPlayerState);
	void OnMatchReady();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzPreMatchStage">();
	}
	static class UGzPreMatchStage* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzPreMatchStage>();
	}
};
static_assert(alignof(UGzPreMatchStage) == 0x000008, "Wrong alignment on UGzPreMatchStage");
static_assert(sizeof(UGzPreMatchStage) == 0x000118, "Wrong size on UGzPreMatchStage");

// Class G01.GzAnimNotifyState_ArmorPlate
// 0x0008 (0x0038 - 0x0030)
class UGzAnimNotifyState_ArmorPlate final : public UAnimNotifyState
{
public:
	bool                                          bIsLeftHand;                                       // 0x0030(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2DF8[0x7];                                     // 0x0031(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzAnimNotifyState_ArmorPlate">();
	}
	static class UGzAnimNotifyState_ArmorPlate* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzAnimNotifyState_ArmorPlate>();
	}
};
static_assert(alignof(UGzAnimNotifyState_ArmorPlate) == 0x000008, "Wrong alignment on UGzAnimNotifyState_ArmorPlate");
static_assert(sizeof(UGzAnimNotifyState_ArmorPlate) == 0x000038, "Wrong size on UGzAnimNotifyState_ArmorPlate");
static_assert(offsetof(UGzAnimNotifyState_ArmorPlate, bIsLeftHand) == 0x000030, "Member 'UGzAnimNotifyState_ArmorPlate::bIsLeftHand' has a wrong offset!");

// Class G01.GzPaymentProviderComponent
// 0x0018 (0x00B8 - 0x00A0)
class UGzPaymentProviderComponent : public UGzServiceComponent
{
public:
	uint8                                         Pad_2DF9[0x18];                                    // 0x00A0(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzPaymentProviderComponent">();
	}
	static class UGzPaymentProviderComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzPaymentProviderComponent>();
	}
};
static_assert(alignof(UGzPaymentProviderComponent) == 0x000008, "Wrong alignment on UGzPaymentProviderComponent");
static_assert(sizeof(UGzPaymentProviderComponent) == 0x0000B8, "Wrong size on UGzPaymentProviderComponent");

// Class G01.GzAnimNotifyState_JetBooster
// 0x0008 (0x0038 - 0x0030)
class UGzAnimNotifyState_JetBooster final : public UAnimNotifyState
{
public:
	bool                                          bPlayJetpackSFX;                                   // 0x0030(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2DFA[0x7];                                     // 0x0031(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzAnimNotifyState_JetBooster">();
	}
	static class UGzAnimNotifyState_JetBooster* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzAnimNotifyState_JetBooster>();
	}
};
static_assert(alignof(UGzAnimNotifyState_JetBooster) == 0x000008, "Wrong alignment on UGzAnimNotifyState_JetBooster");
static_assert(sizeof(UGzAnimNotifyState_JetBooster) == 0x000038, "Wrong size on UGzAnimNotifyState_JetBooster");
static_assert(offsetof(UGzAnimNotifyState_JetBooster, bPlayJetpackSFX) == 0x000030, "Member 'UGzAnimNotifyState_JetBooster::bPlayJetpackSFX' has a wrong offset!");

// Class G01.GzWeaponUdimSkinData
// 0x00E0 (0x0110 - 0x0030)
class UGzWeaponUdimSkinData final : public UPrimaryDataAsset
{
public:
	struct FIntVector2                            Udim;                                              // 0x0030(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              UVTile;                                            // 0x0038(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              UVOffset;                                          // 0x0048(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SkinMaskContrast;                                  // 0x0058(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bFillWithWhite;                                    // 0x005C(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseSkinAsCamoMask;                                // 0x005D(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2DFB[0x2];                                     // 0x005E(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         SolidColorCoef;                                    // 0x0060(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           OverlayColor;                                      // 0x0064(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           CamoColor01;                                       // 0x0074(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           CamoColor02;                                       // 0x0084(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           CamoColor03;                                       // 0x0094(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         OverrideOpacity;                                   // 0x00A4(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         OpacityValue;                                      // 0x00A8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SkinRoughness;                                     // 0x00AC(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RoughnessContrast;                                 // 0x00B0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RoughnessIntensity;                                // 0x00B4(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         NormalIntensity;                                   // 0x00B8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MetallicIntensity;                                 // 0x00BC(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         WearContrast;                                      // 0x00C0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         WearIntensity;                                     // 0x00C4(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           WearColor;                                         // 0x00C8(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         WearRoughness;                                     // 0x00D8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         WearMetallic;                                      // 0x00DC(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DirtContrast;                                      // 0x00E0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DirtIntensity;                                     // 0x00E4(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           DirtColor;                                         // 0x00E8(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DirtRoughness;                                     // 0x00F8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2DFC[0x4];                                     // 0x00FC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 DebugName;                                         // 0x0100(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	void ApplyParametersForMesh(class UMeshComponent* Mesh) const;
	void ApplyParametersForMeshArray(const TArray<class UMeshComponent*>& Meshes) const;
	void GetIndexNumbersArray(TArray<float>* Values) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzWeaponUdimSkinData">();
	}
	static class UGzWeaponUdimSkinData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzWeaponUdimSkinData>();
	}
};
static_assert(alignof(UGzWeaponUdimSkinData) == 0x000008, "Wrong alignment on UGzWeaponUdimSkinData");
static_assert(sizeof(UGzWeaponUdimSkinData) == 0x000110, "Wrong size on UGzWeaponUdimSkinData");
static_assert(offsetof(UGzWeaponUdimSkinData, Udim) == 0x000030, "Member 'UGzWeaponUdimSkinData::Udim' has a wrong offset!");
static_assert(offsetof(UGzWeaponUdimSkinData, UVTile) == 0x000038, "Member 'UGzWeaponUdimSkinData::UVTile' has a wrong offset!");
static_assert(offsetof(UGzWeaponUdimSkinData, UVOffset) == 0x000048, "Member 'UGzWeaponUdimSkinData::UVOffset' has a wrong offset!");
static_assert(offsetof(UGzWeaponUdimSkinData, SkinMaskContrast) == 0x000058, "Member 'UGzWeaponUdimSkinData::SkinMaskContrast' has a wrong offset!");
static_assert(offsetof(UGzWeaponUdimSkinData, bFillWithWhite) == 0x00005C, "Member 'UGzWeaponUdimSkinData::bFillWithWhite' has a wrong offset!");
static_assert(offsetof(UGzWeaponUdimSkinData, bUseSkinAsCamoMask) == 0x00005D, "Member 'UGzWeaponUdimSkinData::bUseSkinAsCamoMask' has a wrong offset!");
static_assert(offsetof(UGzWeaponUdimSkinData, SolidColorCoef) == 0x000060, "Member 'UGzWeaponUdimSkinData::SolidColorCoef' has a wrong offset!");
static_assert(offsetof(UGzWeaponUdimSkinData, OverlayColor) == 0x000064, "Member 'UGzWeaponUdimSkinData::OverlayColor' has a wrong offset!");
static_assert(offsetof(UGzWeaponUdimSkinData, CamoColor01) == 0x000074, "Member 'UGzWeaponUdimSkinData::CamoColor01' has a wrong offset!");
static_assert(offsetof(UGzWeaponUdimSkinData, CamoColor02) == 0x000084, "Member 'UGzWeaponUdimSkinData::CamoColor02' has a wrong offset!");
static_assert(offsetof(UGzWeaponUdimSkinData, CamoColor03) == 0x000094, "Member 'UGzWeaponUdimSkinData::CamoColor03' has a wrong offset!");
static_assert(offsetof(UGzWeaponUdimSkinData, OverrideOpacity) == 0x0000A4, "Member 'UGzWeaponUdimSkinData::OverrideOpacity' has a wrong offset!");
static_assert(offsetof(UGzWeaponUdimSkinData, OpacityValue) == 0x0000A8, "Member 'UGzWeaponUdimSkinData::OpacityValue' has a wrong offset!");
static_assert(offsetof(UGzWeaponUdimSkinData, SkinRoughness) == 0x0000AC, "Member 'UGzWeaponUdimSkinData::SkinRoughness' has a wrong offset!");
static_assert(offsetof(UGzWeaponUdimSkinData, RoughnessContrast) == 0x0000B0, "Member 'UGzWeaponUdimSkinData::RoughnessContrast' has a wrong offset!");
static_assert(offsetof(UGzWeaponUdimSkinData, RoughnessIntensity) == 0x0000B4, "Member 'UGzWeaponUdimSkinData::RoughnessIntensity' has a wrong offset!");
static_assert(offsetof(UGzWeaponUdimSkinData, NormalIntensity) == 0x0000B8, "Member 'UGzWeaponUdimSkinData::NormalIntensity' has a wrong offset!");
static_assert(offsetof(UGzWeaponUdimSkinData, MetallicIntensity) == 0x0000BC, "Member 'UGzWeaponUdimSkinData::MetallicIntensity' has a wrong offset!");
static_assert(offsetof(UGzWeaponUdimSkinData, WearContrast) == 0x0000C0, "Member 'UGzWeaponUdimSkinData::WearContrast' has a wrong offset!");
static_assert(offsetof(UGzWeaponUdimSkinData, WearIntensity) == 0x0000C4, "Member 'UGzWeaponUdimSkinData::WearIntensity' has a wrong offset!");
static_assert(offsetof(UGzWeaponUdimSkinData, WearColor) == 0x0000C8, "Member 'UGzWeaponUdimSkinData::WearColor' has a wrong offset!");
static_assert(offsetof(UGzWeaponUdimSkinData, WearRoughness) == 0x0000D8, "Member 'UGzWeaponUdimSkinData::WearRoughness' has a wrong offset!");
static_assert(offsetof(UGzWeaponUdimSkinData, WearMetallic) == 0x0000DC, "Member 'UGzWeaponUdimSkinData::WearMetallic' has a wrong offset!");
static_assert(offsetof(UGzWeaponUdimSkinData, DirtContrast) == 0x0000E0, "Member 'UGzWeaponUdimSkinData::DirtContrast' has a wrong offset!");
static_assert(offsetof(UGzWeaponUdimSkinData, DirtIntensity) == 0x0000E4, "Member 'UGzWeaponUdimSkinData::DirtIntensity' has a wrong offset!");
static_assert(offsetof(UGzWeaponUdimSkinData, DirtColor) == 0x0000E8, "Member 'UGzWeaponUdimSkinData::DirtColor' has a wrong offset!");
static_assert(offsetof(UGzWeaponUdimSkinData, DirtRoughness) == 0x0000F8, "Member 'UGzWeaponUdimSkinData::DirtRoughness' has a wrong offset!");
static_assert(offsetof(UGzWeaponUdimSkinData, DebugName) == 0x000100, "Member 'UGzWeaponUdimSkinData::DebugName' has a wrong offset!");

// Class G01.GzSearchZone
// 0x0048 (0x02E8 - 0x02A0)
class AGzSearchZone : public AActor
{
public:
	struct FGzSearchZoneWorldData                 SearchZoneData;                                    // 0x02A0(0x0038)(BlueprintVisible, BlueprintReadOnly, Transient, NoDestructor, Protected, NativeAccessSpecifierProtected)
	class UGzMarkerComponent*                     MarkerComponent;                                   // 0x02D8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bCullByShrinkingZoneSize;                          // 0x02E0(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2DFD[0x3];                                     // 0x02E1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ShrinkingZoneRadiusThreshold;                      // 0x02E4(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void OnShrinkingZoneAvailable(class AGzShrinkingZone* Zone);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzSearchZone">();
	}
	static class AGzSearchZone* GetDefaultObj()
	{
		return GetDefaultObjImpl<AGzSearchZone>();
	}
};
static_assert(alignof(AGzSearchZone) == 0x000008, "Wrong alignment on AGzSearchZone");
static_assert(sizeof(AGzSearchZone) == 0x0002E8, "Wrong size on AGzSearchZone");
static_assert(offsetof(AGzSearchZone, SearchZoneData) == 0x0002A0, "Member 'AGzSearchZone::SearchZoneData' has a wrong offset!");
static_assert(offsetof(AGzSearchZone, MarkerComponent) == 0x0002D8, "Member 'AGzSearchZone::MarkerComponent' has a wrong offset!");
static_assert(offsetof(AGzSearchZone, bCullByShrinkingZoneSize) == 0x0002E0, "Member 'AGzSearchZone::bCullByShrinkingZoneSize' has a wrong offset!");
static_assert(offsetof(AGzSearchZone, ShrinkingZoneRadiusThreshold) == 0x0002E4, "Member 'AGzSearchZone::ShrinkingZoneRadiusThreshold' has a wrong offset!");

// Class G01.GzHexSearchZone
// 0x0008 (0x02F0 - 0x02E8)
class AGzHexSearchZone final : public AGzSearchZone
{
public:
	EGzItemRarity                                 Rarity;                                            // 0x02E8(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2DFE[0x7];                                     // 0x02E9(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzHexSearchZone">();
	}
	static class AGzHexSearchZone* GetDefaultObj()
	{
		return GetDefaultObjImpl<AGzHexSearchZone>();
	}
};
static_assert(alignof(AGzHexSearchZone) == 0x000008, "Wrong alignment on AGzHexSearchZone");
static_assert(sizeof(AGzHexSearchZone) == 0x0002F0, "Wrong size on AGzHexSearchZone");
static_assert(offsetof(AGzHexSearchZone, Rarity) == 0x0002E8, "Member 'AGzHexSearchZone::Rarity' has a wrong offset!");

// Class G01.GzAnimNotifyState_MortarTablet
// 0x00A0 (0x00D0 - 0x0030)
class UGzAnimNotifyState_MortarTablet final : public UAnimNotifyState
{
public:
	TSoftObjectPtr<class UStaticMesh>             StaticMeshSoftPtr;                                 // 0x0030(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   AttachSocket;                                      // 0x0058(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FTransform                             AttachTransform;                                   // 0x0060(0x0060)(Edit, BlueprintVisible, BlueprintReadOnly, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bDestroyImmediatelyOnEnd;                          // 0x00C0(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2DFF[0x3];                                     // 0x00C1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         DestroyDelay;                                      // 0x00C4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2E00[0x8];                                     // 0x00C8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzAnimNotifyState_MortarTablet">();
	}
	static class UGzAnimNotifyState_MortarTablet* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzAnimNotifyState_MortarTablet>();
	}
};
static_assert(alignof(UGzAnimNotifyState_MortarTablet) == 0x000010, "Wrong alignment on UGzAnimNotifyState_MortarTablet");
static_assert(sizeof(UGzAnimNotifyState_MortarTablet) == 0x0000D0, "Wrong size on UGzAnimNotifyState_MortarTablet");
static_assert(offsetof(UGzAnimNotifyState_MortarTablet, StaticMeshSoftPtr) == 0x000030, "Member 'UGzAnimNotifyState_MortarTablet::StaticMeshSoftPtr' has a wrong offset!");
static_assert(offsetof(UGzAnimNotifyState_MortarTablet, AttachSocket) == 0x000058, "Member 'UGzAnimNotifyState_MortarTablet::AttachSocket' has a wrong offset!");
static_assert(offsetof(UGzAnimNotifyState_MortarTablet, AttachTransform) == 0x000060, "Member 'UGzAnimNotifyState_MortarTablet::AttachTransform' has a wrong offset!");
static_assert(offsetof(UGzAnimNotifyState_MortarTablet, bDestroyImmediatelyOnEnd) == 0x0000C0, "Member 'UGzAnimNotifyState_MortarTablet::bDestroyImmediatelyOnEnd' has a wrong offset!");
static_assert(offsetof(UGzAnimNotifyState_MortarTablet, DestroyDelay) == 0x0000C4, "Member 'UGzAnimNotifyState_MortarTablet::DestroyDelay' has a wrong offset!");

// Class G01.GzNavigationComponent
// 0x0008 (0x00B0 - 0x00A8)
class UGzNavigationComponent : public UActorComponent
{
public:
	class AGzRecastNavMesh*                       CachedNavMesh;                                     // 0x00A8(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzNavigationComponent">();
	}
	static class UGzNavigationComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzNavigationComponent>();
	}
};
static_assert(alignof(UGzNavigationComponent) == 0x000008, "Wrong alignment on UGzNavigationComponent");
static_assert(sizeof(UGzNavigationComponent) == 0x0000B0, "Wrong size on UGzNavigationComponent");
static_assert(offsetof(UGzNavigationComponent, CachedNavMesh) == 0x0000A8, "Member 'UGzNavigationComponent::CachedNavMesh' has a wrong offset!");

// Class G01.GzShrinkingZoneAkComponent
// 0x0010 (0x0450 - 0x0440)
class UGzShrinkingZoneAkComponent final : public UAkComponent
{
public:
	float                                         UpdateDistanceAttenuationDelta;                    // 0x0438(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2E01[0x4];                                     // 0x043C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class AGzShrinkingZone*                       OwnerZone;                                         // 0x0440(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2E02[0x8];                                     // 0x0448(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzShrinkingZoneAkComponent">();
	}
	static class UGzShrinkingZoneAkComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzShrinkingZoneAkComponent>();
	}
};
static_assert(alignof(UGzShrinkingZoneAkComponent) == 0x000010, "Wrong alignment on UGzShrinkingZoneAkComponent");
static_assert(sizeof(UGzShrinkingZoneAkComponent) == 0x000450, "Wrong size on UGzShrinkingZoneAkComponent");
static_assert(offsetof(UGzShrinkingZoneAkComponent, UpdateDistanceAttenuationDelta) == 0x000438, "Member 'UGzShrinkingZoneAkComponent::UpdateDistanceAttenuationDelta' has a wrong offset!");
static_assert(offsetof(UGzShrinkingZoneAkComponent, OwnerZone) == 0x000440, "Member 'UGzShrinkingZoneAkComponent::OwnerZone' has a wrong offset!");

// Class G01.GzAnimNotifyState_WeaponReloadMontage
// 0x0000 (0x0030 - 0x0030)
class UGzAnimNotifyState_WeaponReloadMontage final : public UAnimNotifyState
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzAnimNotifyState_WeaponReloadMontage">();
	}
	static class UGzAnimNotifyState_WeaponReloadMontage* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzAnimNotifyState_WeaponReloadMontage>();
	}
};
static_assert(alignof(UGzAnimNotifyState_WeaponReloadMontage) == 0x000008, "Wrong alignment on UGzAnimNotifyState_WeaponReloadMontage");
static_assert(sizeof(UGzAnimNotifyState_WeaponReloadMontage) == 0x000030, "Wrong size on UGzAnimNotifyState_WeaponReloadMontage");

// Class G01.GzAnimNotify_WeaponMagazineFollow
// 0x0008 (0x0040 - 0x0038)
class UGzAnimNotify_WeaponMagazineFollow final : public UAnimNotify
{
public:
	bool                                          bShouldFollowCharactersHand;                       // 0x0038(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsLeftHand;                                       // 0x0039(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2E03[0x6];                                     // 0x003A(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzAnimNotify_WeaponMagazineFollow">();
	}
	static class UGzAnimNotify_WeaponMagazineFollow* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzAnimNotify_WeaponMagazineFollow>();
	}
};
static_assert(alignof(UGzAnimNotify_WeaponMagazineFollow) == 0x000008, "Wrong alignment on UGzAnimNotify_WeaponMagazineFollow");
static_assert(sizeof(UGzAnimNotify_WeaponMagazineFollow) == 0x000040, "Wrong size on UGzAnimNotify_WeaponMagazineFollow");
static_assert(offsetof(UGzAnimNotify_WeaponMagazineFollow, bShouldFollowCharactersHand) == 0x000038, "Member 'UGzAnimNotify_WeaponMagazineFollow::bShouldFollowCharactersHand' has a wrong offset!");
static_assert(offsetof(UGzAnimNotify_WeaponMagazineFollow, bIsLeftHand) == 0x000039, "Member 'UGzAnimNotify_WeaponMagazineFollow::bIsLeftHand' has a wrong offset!");

// Class G01.GzClientEntitlementService
// 0x0000 (0x00A0 - 0x00A0)
class UGzClientEntitlementService final : public UGzClientPFObject
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzClientEntitlementService">();
	}
	static class UGzClientEntitlementService* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzClientEntitlementService>();
	}
};
static_assert(alignof(UGzClientEntitlementService) == 0x000008, "Wrong alignment on UGzClientEntitlementService");
static_assert(sizeof(UGzClientEntitlementService) == 0x0000A0, "Wrong size on UGzClientEntitlementService");

// Class G01.GzAnimNotify_WeaponMagazineVisibility
// 0x0020 (0x0058 - 0x0038)
class UGzAnimNotify_WeaponMagazineVisibility final : public UAnimNotify
{
public:
	bool                                          bIsVisible;                                        // 0x0038(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bShouldDropWorldProp;                              // 0x0039(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2E04[0x2];                                     // 0x003A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ThrowVelocity;                                     // 0x003C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FRotator                               ThrowRotation;                                     // 0x0040(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzAnimNotify_WeaponMagazineVisibility">();
	}
	static class UGzAnimNotify_WeaponMagazineVisibility* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzAnimNotify_WeaponMagazineVisibility>();
	}
};
static_assert(alignof(UGzAnimNotify_WeaponMagazineVisibility) == 0x000008, "Wrong alignment on UGzAnimNotify_WeaponMagazineVisibility");
static_assert(sizeof(UGzAnimNotify_WeaponMagazineVisibility) == 0x000058, "Wrong size on UGzAnimNotify_WeaponMagazineVisibility");
static_assert(offsetof(UGzAnimNotify_WeaponMagazineVisibility, bIsVisible) == 0x000038, "Member 'UGzAnimNotify_WeaponMagazineVisibility::bIsVisible' has a wrong offset!");
static_assert(offsetof(UGzAnimNotify_WeaponMagazineVisibility, bShouldDropWorldProp) == 0x000039, "Member 'UGzAnimNotify_WeaponMagazineVisibility::bShouldDropWorldProp' has a wrong offset!");
static_assert(offsetof(UGzAnimNotify_WeaponMagazineVisibility, ThrowVelocity) == 0x00003C, "Member 'UGzAnimNotify_WeaponMagazineVisibility::ThrowVelocity' has a wrong offset!");
static_assert(offsetof(UGzAnimNotify_WeaponMagazineVisibility, ThrowRotation) == 0x000040, "Member 'UGzAnimNotify_WeaponMagazineVisibility::ThrowRotation' has a wrong offset!");

// Class G01.GzXR_BaseStage
// 0x0008 (0x0118 - 0x0110)
class UGzXR_BaseStage : public UGzGameStageBase
{
public:
	class UGzXR_StageSettings*                    StageSettings;                                     // 0x0110(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzXR_BaseStage">();
	}
	static class UGzXR_BaseStage* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzXR_BaseStage>();
	}
};
static_assert(alignof(UGzXR_BaseStage) == 0x000008, "Wrong alignment on UGzXR_BaseStage");
static_assert(sizeof(UGzXR_BaseStage) == 0x000118, "Wrong size on UGzXR_BaseStage");
static_assert(offsetof(UGzXR_BaseStage, StageSettings) == 0x000110, "Member 'UGzXR_BaseStage::StageSettings' has a wrong offset!");

// Class G01.GzXR_WaitingStage
// 0x0008 (0x0120 - 0x0118)
class UGzXR_WaitingStage : public UGzXR_BaseStage
{
public:
	uint8                                         Pad_2E05[0x8];                                     // 0x0118(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzXR_WaitingStage">();
	}
	static class UGzXR_WaitingStage* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzXR_WaitingStage>();
	}
};
static_assert(alignof(UGzXR_WaitingStage) == 0x000008, "Wrong alignment on UGzXR_WaitingStage");
static_assert(sizeof(UGzXR_WaitingStage) == 0x000120, "Wrong size on UGzXR_WaitingStage");

// Class G01.GzAnimNotify_WeaponMagazineAttachedProp
// 0x0020 (0x0058 - 0x0038)
class UGzAnimNotify_WeaponMagazineAttachedProp final : public UAnimNotify
{
public:
	bool                                          bShouldSpawn;                                      // 0x0038(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2E06[0x3];                                     // 0x0039(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ThrowVelocity;                                     // 0x003C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FRotator                               ThrowRotation;                                     // 0x0040(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzAnimNotify_WeaponMagazineAttachedProp">();
	}
	static class UGzAnimNotify_WeaponMagazineAttachedProp* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzAnimNotify_WeaponMagazineAttachedProp>();
	}
};
static_assert(alignof(UGzAnimNotify_WeaponMagazineAttachedProp) == 0x000008, "Wrong alignment on UGzAnimNotify_WeaponMagazineAttachedProp");
static_assert(sizeof(UGzAnimNotify_WeaponMagazineAttachedProp) == 0x000058, "Wrong size on UGzAnimNotify_WeaponMagazineAttachedProp");
static_assert(offsetof(UGzAnimNotify_WeaponMagazineAttachedProp, bShouldSpawn) == 0x000038, "Member 'UGzAnimNotify_WeaponMagazineAttachedProp::bShouldSpawn' has a wrong offset!");
static_assert(offsetof(UGzAnimNotify_WeaponMagazineAttachedProp, ThrowVelocity) == 0x00003C, "Member 'UGzAnimNotify_WeaponMagazineAttachedProp::ThrowVelocity' has a wrong offset!");
static_assert(offsetof(UGzAnimNotify_WeaponMagazineAttachedProp, ThrowRotation) == 0x000040, "Member 'UGzAnimNotify_WeaponMagazineAttachedProp::ThrowRotation' has a wrong offset!");

// Class G01.GzHexHuntComponent
// 0x0080 (0x0128 - 0x00A8)
class UGzHexHuntComponent : public UActorComponent
{
public:
	class UGzInvComponent*                        OwnerInventory;                                    // 0x00A8(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UGzSearchZonesSubsystem*                SearchZonesSubsystem;                              // 0x00B0(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TMap<EGzItemRarity, struct FGzSearchZoneSpec> HexSearchZoneConfigs;                              // 0x00B8(0x0050)(Edit, Protected, NativeAccessSpecifierProtected)
	EGzItemRarity                                 CurrentRarityHex;                                  // 0x0108(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2E07[0x1F];                                    // 0x0109(0x001F)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzHexHuntComponent">();
	}
	static class UGzHexHuntComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzHexHuntComponent>();
	}
};
static_assert(alignof(UGzHexHuntComponent) == 0x000008, "Wrong alignment on UGzHexHuntComponent");
static_assert(sizeof(UGzHexHuntComponent) == 0x000128, "Wrong size on UGzHexHuntComponent");
static_assert(offsetof(UGzHexHuntComponent, OwnerInventory) == 0x0000A8, "Member 'UGzHexHuntComponent::OwnerInventory' has a wrong offset!");
static_assert(offsetof(UGzHexHuntComponent, SearchZonesSubsystem) == 0x0000B0, "Member 'UGzHexHuntComponent::SearchZonesSubsystem' has a wrong offset!");
static_assert(offsetof(UGzHexHuntComponent, HexSearchZoneConfigs) == 0x0000B8, "Member 'UGzHexHuntComponent::HexSearchZoneConfigs' has a wrong offset!");
static_assert(offsetof(UGzHexHuntComponent, CurrentRarityHex) == 0x000108, "Member 'UGzHexHuntComponent::CurrentRarityHex' has a wrong offset!");

// Class G01.GzMortarTabletActor
// 0x00A0 (0x0340 - 0x02A0)
class AGzMortarTabletActor : public AActor
{
public:
	FMulticastInlineDelegateProperty_             OnTabletScreenReady;                               // 0x02A0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	class USceneComponent*                        RootSceneComponent;                                // 0x02B0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UStaticMeshComponent*                   TabletMeshComponent;                               // 0x02B8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetComponent*                       MapWidgetComponent;                                // 0x02C0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2E08[0x8];                                     // 0x02C8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             InitialTransform;                                  // 0x02D0(0x0060)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ShowMapDelay;                                      // 0x0330(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2E09[0xC];                                     // 0x0334(0x000C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzMortarTabletActor">();
	}
	static class AGzMortarTabletActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<AGzMortarTabletActor>();
	}
};
static_assert(alignof(AGzMortarTabletActor) == 0x000010, "Wrong alignment on AGzMortarTabletActor");
static_assert(sizeof(AGzMortarTabletActor) == 0x000340, "Wrong size on AGzMortarTabletActor");
static_assert(offsetof(AGzMortarTabletActor, OnTabletScreenReady) == 0x0002A0, "Member 'AGzMortarTabletActor::OnTabletScreenReady' has a wrong offset!");
static_assert(offsetof(AGzMortarTabletActor, RootSceneComponent) == 0x0002B0, "Member 'AGzMortarTabletActor::RootSceneComponent' has a wrong offset!");
static_assert(offsetof(AGzMortarTabletActor, TabletMeshComponent) == 0x0002B8, "Member 'AGzMortarTabletActor::TabletMeshComponent' has a wrong offset!");
static_assert(offsetof(AGzMortarTabletActor, MapWidgetComponent) == 0x0002C0, "Member 'AGzMortarTabletActor::MapWidgetComponent' has a wrong offset!");
static_assert(offsetof(AGzMortarTabletActor, InitialTransform) == 0x0002D0, "Member 'AGzMortarTabletActor::InitialTransform' has a wrong offset!");
static_assert(offsetof(AGzMortarTabletActor, ShowMapDelay) == 0x000330, "Member 'AGzMortarTabletActor::ShowMapDelay' has a wrong offset!");

// Class G01.GzCustomizationModifier_Material
// 0x0010 (0x0040 - 0x0030)
class UGzCustomizationModifier_Material : public UGzCustomizationModifier
{
public:
	class FName                                   MaterialSlotName;                                  // 0x0030(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   ParamName;                                         // 0x0038(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzCustomizationModifier_Material">();
	}
	static class UGzCustomizationModifier_Material* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzCustomizationModifier_Material>();
	}
};
static_assert(alignof(UGzCustomizationModifier_Material) == 0x000008, "Wrong alignment on UGzCustomizationModifier_Material");
static_assert(sizeof(UGzCustomizationModifier_Material) == 0x000040, "Wrong size on UGzCustomizationModifier_Material");
static_assert(offsetof(UGzCustomizationModifier_Material, MaterialSlotName) == 0x000030, "Member 'UGzCustomizationModifier_Material::MaterialSlotName' has a wrong offset!");
static_assert(offsetof(UGzCustomizationModifier_Material, ParamName) == 0x000038, "Member 'UGzCustomizationModifier_Material::ParamName' has a wrong offset!");

// Class G01.GzCustomizationModifier_MaterialScalar
// 0x0008 (0x0048 - 0x0040)
class UGzCustomizationModifier_MaterialScalar final : public UGzCustomizationModifier_Material
{
public:
	float                                         ParamValue;                                        // 0x0040(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2E0A[0x4];                                     // 0x0044(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzCustomizationModifier_MaterialScalar">();
	}
	static class UGzCustomizationModifier_MaterialScalar* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzCustomizationModifier_MaterialScalar>();
	}
};
static_assert(alignof(UGzCustomizationModifier_MaterialScalar) == 0x000008, "Wrong alignment on UGzCustomizationModifier_MaterialScalar");
static_assert(sizeof(UGzCustomizationModifier_MaterialScalar) == 0x000048, "Wrong size on UGzCustomizationModifier_MaterialScalar");
static_assert(offsetof(UGzCustomizationModifier_MaterialScalar, ParamValue) == 0x000040, "Member 'UGzCustomizationModifier_MaterialScalar::ParamValue' has a wrong offset!");

// Class G01.GzAnimNotify_TriggerLocalTag
// 0x0008 (0x0040 - 0x0038)
class UGzAnimNotify_TriggerLocalTag final : public UAnimNotify
{
public:
	struct FGameplayTag                           TriggeringGameplayTag;                             // 0x0038(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzAnimNotify_TriggerLocalTag">();
	}
	static class UGzAnimNotify_TriggerLocalTag* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzAnimNotify_TriggerLocalTag>();
	}
};
static_assert(alignof(UGzAnimNotify_TriggerLocalTag) == 0x000008, "Wrong alignment on UGzAnimNotify_TriggerLocalTag");
static_assert(sizeof(UGzAnimNotify_TriggerLocalTag) == 0x000040, "Wrong size on UGzAnimNotify_TriggerLocalTag");
static_assert(offsetof(UGzAnimNotify_TriggerLocalTag, TriggeringGameplayTag) == 0x000038, "Member 'UGzAnimNotify_TriggerLocalTag::TriggeringGameplayTag' has a wrong offset!");

// Class G01.GzFlowState
// 0x0038 (0x0060 - 0x0028)
class UGzFlowState : public UObject
{
public:
	uint8                                         Pad_2E0B[0x20];                                    // 0x0028(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGzStateParameterContainer             StoredParameter;                                   // 0x0048(0x0018)(NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzFlowState">();
	}
	static class UGzFlowState* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzFlowState>();
	}
};
static_assert(alignof(UGzFlowState) == 0x000008, "Wrong alignment on UGzFlowState");
static_assert(sizeof(UGzFlowState) == 0x000060, "Wrong size on UGzFlowState");
static_assert(offsetof(UGzFlowState, StoredParameter) == 0x000048, "Member 'UGzFlowState::StoredParameter' has a wrong offset!");

// Class G01.GzFlowStateWithActionGraph
// 0x0010 (0x0070 - 0x0060)
class UGzFlowStateWithActionGraph : public UGzFlowState
{
public:
	uint8                                         Pad_2E0C[0x10];                                    // 0x0060(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzFlowStateWithActionGraph">();
	}
	static class UGzFlowStateWithActionGraph* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzFlowStateWithActionGraph>();
	}
};
static_assert(alignof(UGzFlowStateWithActionGraph) == 0x000008, "Wrong alignment on UGzFlowStateWithActionGraph");
static_assert(sizeof(UGzFlowStateWithActionGraph) == 0x000070, "Wrong size on UGzFlowStateWithActionGraph");

// Class G01.GzLobbyGateState
// 0x0000 (0x0070 - 0x0070)
class UGzLobbyGateState final : public UGzFlowStateWithActionGraph
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzLobbyGateState">();
	}
	static class UGzLobbyGateState* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzLobbyGateState>();
	}
};
static_assert(alignof(UGzLobbyGateState) == 0x000008, "Wrong alignment on UGzLobbyGateState");
static_assert(sizeof(UGzLobbyGateState) == 0x000070, "Wrong size on UGzLobbyGateState");

// Class G01.GzAnimNotify_WeaponShellEject
// 0x0000 (0x0038 - 0x0038)
class UGzAnimNotify_WeaponShellEject final : public UAnimNotify
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzAnimNotify_WeaponShellEject">();
	}
	static class UGzAnimNotify_WeaponShellEject* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzAnimNotify_WeaponShellEject>();
	}
};
static_assert(alignof(UGzAnimNotify_WeaponShellEject) == 0x000008, "Wrong alignment on UGzAnimNotify_WeaponShellEject");
static_assert(sizeof(UGzAnimNotify_WeaponShellEject) == 0x000038, "Wrong size on UGzAnimNotify_WeaponShellEject");

// Class G01.GzFacade
// 0x0008 (0x0030 - 0x0028)
class UGzFacade : public UObject
{
public:
	class UGzBackendManager*                      BackendManager;                                    // 0x0028(0x0008)(ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzFacade">();
	}
	static class UGzFacade* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzFacade>();
	}
};
static_assert(alignof(UGzFacade) == 0x000008, "Wrong alignment on UGzFacade");
static_assert(sizeof(UGzFacade) == 0x000030, "Wrong size on UGzFacade");
static_assert(offsetof(UGzFacade, BackendManager) == 0x000028, "Member 'UGzFacade::BackendManager' has a wrong offset!");

// Class G01.GzClientLoadoutFacade
// 0x0000 (0x0030 - 0x0030)
class UGzClientLoadoutFacade final : public UGzFacade
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzClientLoadoutFacade">();
	}
	static class UGzClientLoadoutFacade* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzClientLoadoutFacade>();
	}
};
static_assert(alignof(UGzClientLoadoutFacade) == 0x000008, "Wrong alignment on UGzClientLoadoutFacade");
static_assert(sizeof(UGzClientLoadoutFacade) == 0x000030, "Wrong size on UGzClientLoadoutFacade");

// Class G01.GzAreaComponent
// 0x0000 (0x00A8 - 0x00A8)
class UGzAreaComponent : public UActorComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzAreaComponent">();
	}
	static class UGzAreaComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzAreaComponent>();
	}
};
static_assert(alignof(UGzAreaComponent) == 0x000008, "Wrong alignment on UGzAreaComponent");
static_assert(sizeof(UGzAreaComponent) == 0x0000A8, "Wrong size on UGzAreaComponent");

// Class G01.GzPlayFabServerSettings
// 0x0010 (0x0038 - 0x0028)
class UGzPlayFabServerSettings final : public UObject
{
public:
	class FString                                 DeveloperSecretKey;                                // 0x0028(0x0010)(ZeroConstructor, Config, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzPlayFabServerSettings">();
	}
	static class UGzPlayFabServerSettings* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzPlayFabServerSettings>();
	}
};
static_assert(alignof(UGzPlayFabServerSettings) == 0x000008, "Wrong alignment on UGzPlayFabServerSettings");
static_assert(sizeof(UGzPlayFabServerSettings) == 0x000038, "Wrong size on UGzPlayFabServerSettings");
static_assert(offsetof(UGzPlayFabServerSettings, DeveloperSecretKey) == 0x000028, "Member 'UGzPlayFabServerSettings::DeveloperSecretKey' has a wrong offset!");

// Class G01.GzCircleAreaComponent
// 0x0008 (0x00B0 - 0x00A8)
class UGzCircleAreaComponent final : public UGzAreaComponent
{
public:
	double                                        Radius;                                            // 0x00A8(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzCircleAreaComponent">();
	}
	static class UGzCircleAreaComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzCircleAreaComponent>();
	}
};
static_assert(alignof(UGzCircleAreaComponent) == 0x000008, "Wrong alignment on UGzCircleAreaComponent");
static_assert(sizeof(UGzCircleAreaComponent) == 0x0000B0, "Wrong size on UGzCircleAreaComponent");
static_assert(offsetof(UGzCircleAreaComponent, Radius) == 0x0000A8, "Member 'UGzCircleAreaComponent::Radius' has a wrong offset!");

// Class G01.GzWorldInstanceId
// 0x0000 (0x0028 - 0x0028)
class IGzWorldInstanceId final : public IInterface
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzWorldInstanceId">();
	}
	static class IGzWorldInstanceId* GetDefaultObj()
	{
		return GetDefaultObjImpl<IGzWorldInstanceId>();
	}
};
static_assert(alignof(IGzWorldInstanceId) == 0x000008, "Wrong alignment on IGzWorldInstanceId");
static_assert(sizeof(IGzWorldInstanceId) == 0x000028, "Wrong size on IGzWorldInstanceId");

// Class G01.GzCrosshairContainer
// 0x0100 (0x0440 - 0x0340)
class UGzCrosshairContainer : public UGzHUDComponent
{
public:
	uint8                                         Pad_2E0D[0x8];                                     // 0x0340(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTagContainer                  TriggerUpdateCrosshairTags;                        // 0x0348(0x0020)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	struct FGameplayTagContainer                  BlockWeaponCrosshairTags;                          // 0x0368(0x0020)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	class UWidgetSwitcher*                        CrosshairStateHolder;                              // 0x0388(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TMap<EGzWeaponType, TSubclassOf<class UGzCrosshair>> WeaponTypeCrosshairClasses;                        // 0x0390(0x0050)(Edit, DisableEditOnInstance, UObjectWrapper, NativeAccessSpecifierPrivate)
	TMap<EGzCrossHairState, TSubclassOf<class UGzCrosshair>> DefaultCrosshairStatesClasses;                     // 0x03E0(0x0050)(Edit, DisableEditOnInstance, UObjectWrapper, NativeAccessSpecifierPrivate)
	TSubclassOf<class UGzCrosshairSlot>           CrosshairSlotClass;                                // 0x0430(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2E0E[0x8];                                     // 0x0438(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnAdsUpdated(bool bIsInAds);
	void OnLimbChanged(EGzLimbType LimbType);
	void OnOperableObjectChanged(class UGzOperableObjectComponent* OperableObjectComponent);
	void OnTriggerUpdateTagsUpdated(bool bWasAdded);
	void OnVehicleSeatChanged(class AGzCharacter* Character, EGzVehicleSeatType NewSeat, EGzVehicleSeatType OldSeat);
	void OnWeaponUpdated(const struct FGzInvPocketId& PocketId, class AGzWeaponActor* WeaponActor);

	class UGzCrosshair* GetCurrentCrosshair() const;
	void OnAimUpdatedBP(const struct FVector& blockedLocation, bool bIsBlocked) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzCrosshairContainer">();
	}
	static class UGzCrosshairContainer* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzCrosshairContainer>();
	}
};
static_assert(alignof(UGzCrosshairContainer) == 0x000008, "Wrong alignment on UGzCrosshairContainer");
static_assert(sizeof(UGzCrosshairContainer) == 0x000440, "Wrong size on UGzCrosshairContainer");
static_assert(offsetof(UGzCrosshairContainer, TriggerUpdateCrosshairTags) == 0x000348, "Member 'UGzCrosshairContainer::TriggerUpdateCrosshairTags' has a wrong offset!");
static_assert(offsetof(UGzCrosshairContainer, BlockWeaponCrosshairTags) == 0x000368, "Member 'UGzCrosshairContainer::BlockWeaponCrosshairTags' has a wrong offset!");
static_assert(offsetof(UGzCrosshairContainer, CrosshairStateHolder) == 0x000388, "Member 'UGzCrosshairContainer::CrosshairStateHolder' has a wrong offset!");
static_assert(offsetof(UGzCrosshairContainer, WeaponTypeCrosshairClasses) == 0x000390, "Member 'UGzCrosshairContainer::WeaponTypeCrosshairClasses' has a wrong offset!");
static_assert(offsetof(UGzCrosshairContainer, DefaultCrosshairStatesClasses) == 0x0003E0, "Member 'UGzCrosshairContainer::DefaultCrosshairStatesClasses' has a wrong offset!");
static_assert(offsetof(UGzCrosshairContainer, CrosshairSlotClass) == 0x000430, "Member 'UGzCrosshairContainer::CrosshairSlotClass' has a wrong offset!");

// Class G01.GzGameModeBase
// 0x0138 (0x0470 - 0x0338)
class AGzGameModeBase : public AGameModeBase
{
public:
	TSet<TSubclassOf<class AGzGameModeSubsystem>> SubsystemsClasses;                                 // 0x0338(0x0050)(Edit, DisableEditOnInstance, Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	class UGzGameModeSettings*                    DefaultSettings;                                   // 0x0388(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoClear, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UGzGameModeSettings>        SettingsClass;                                     // 0x0390(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoClear, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FString                                 DisplayName;                                       // 0x0398(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UGzGameModeSettings*                    SettingsAsset;                                     // 0x03A8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TMap<TSubclassOf<class AGzGameModeSubsystem>, class AGzGameModeSubsystem*> InstancedSubsystems;                               // 0x03B0(0x0050)(BlueprintVisible, BlueprintReadOnly, Transient, Protected, NativeAccessSpecifierProtected)
	TMap<class AController*, struct FTimerHandle> PlayerRestartTimers;                               // 0x0400(0x0050)(Transient, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2E11[0x20];                                    // 0x0450(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	class AGzGameModeSubsystem* GetSubsystemByClass(TSubclassOf<class AGzGameModeSubsystem> InClass);
	void RestartPlayerInMatch(class AController* PlayerController);
	void RestartPlayerInMatchAtTransform(class AController* PlayerController, const struct FTransform& Transform);

	class FString GetDisplayName() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzGameModeBase">();
	}
	static class AGzGameModeBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<AGzGameModeBase>();
	}
};
static_assert(alignof(AGzGameModeBase) == 0x000008, "Wrong alignment on AGzGameModeBase");
static_assert(sizeof(AGzGameModeBase) == 0x000470, "Wrong size on AGzGameModeBase");
static_assert(offsetof(AGzGameModeBase, SubsystemsClasses) == 0x000338, "Member 'AGzGameModeBase::SubsystemsClasses' has a wrong offset!");
static_assert(offsetof(AGzGameModeBase, DefaultSettings) == 0x000388, "Member 'AGzGameModeBase::DefaultSettings' has a wrong offset!");
static_assert(offsetof(AGzGameModeBase, SettingsClass) == 0x000390, "Member 'AGzGameModeBase::SettingsClass' has a wrong offset!");
static_assert(offsetof(AGzGameModeBase, DisplayName) == 0x000398, "Member 'AGzGameModeBase::DisplayName' has a wrong offset!");
static_assert(offsetof(AGzGameModeBase, SettingsAsset) == 0x0003A8, "Member 'AGzGameModeBase::SettingsAsset' has a wrong offset!");
static_assert(offsetof(AGzGameModeBase, InstancedSubsystems) == 0x0003B0, "Member 'AGzGameModeBase::InstancedSubsystems' has a wrong offset!");
static_assert(offsetof(AGzGameModeBase, PlayerRestartTimers) == 0x000400, "Member 'AGzGameModeBase::PlayerRestartTimers' has a wrong offset!");

// Class G01.GzSessionGameModeBase
// 0x0158 (0x05C8 - 0x0470)
class AGzSessionGameModeBase : public AGzGameModeBase
{
public:
	uint8                                         Pad_2E13[0x18];                                    // 0x0470(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	class UGzLootModifierTableData*               GlobalLootModifier;                                // 0x0488(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class FName>                           ActiveLootZoneLayers;                              // 0x0490(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	TMap<class UGzLootModifierTableData*, class UCurveFloat*> TimeLootModifiers;                                 // 0x04A0(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	TMap<struct FGameplayTag, class UGzLootModifierTableData*> PlayerStatsLootModifiers;                          // 0x04F0(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	class UGzLootModifierTableData*               SpecialLootModifier;                               // 0x0540(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AGzGameState*                           GzGameState;                                       // 0x0548(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2E14[0x8];                                     // 0x0550(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class AGzTeam*                                WinnerTeam;                                        // 0x0558(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2E15[0x68];                                    // 0x0560(0x0068)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnAIDied(class AGzAIController* Controller);
	void OnAISpawned(class AGzAIController* Controller);
	void OnPlayerDied(class AGzCharacter* Character);
	void OnPlayerLoggedOut(class AGzPlayerController* Player, EGzPlayerLogoutReason LogoutReason);
	void SpawnPlayer(class AGzPlayerState* InPlayerState, const struct FTransform& SpawnTransform);

	bool CanSpawnAtPlayerStart(const class AGzPlayerState* PlayerState, const class AGzTeamStart* PlayerStart) const;
	int32 GetTotalTeamCount() const;
	class AGzTeam* GetWinnerTeam() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzSessionGameModeBase">();
	}
	static class AGzSessionGameModeBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<AGzSessionGameModeBase>();
	}
};
static_assert(alignof(AGzSessionGameModeBase) == 0x000008, "Wrong alignment on AGzSessionGameModeBase");
static_assert(sizeof(AGzSessionGameModeBase) == 0x0005C8, "Wrong size on AGzSessionGameModeBase");
static_assert(offsetof(AGzSessionGameModeBase, GlobalLootModifier) == 0x000488, "Member 'AGzSessionGameModeBase::GlobalLootModifier' has a wrong offset!");
static_assert(offsetof(AGzSessionGameModeBase, ActiveLootZoneLayers) == 0x000490, "Member 'AGzSessionGameModeBase::ActiveLootZoneLayers' has a wrong offset!");
static_assert(offsetof(AGzSessionGameModeBase, TimeLootModifiers) == 0x0004A0, "Member 'AGzSessionGameModeBase::TimeLootModifiers' has a wrong offset!");
static_assert(offsetof(AGzSessionGameModeBase, PlayerStatsLootModifiers) == 0x0004F0, "Member 'AGzSessionGameModeBase::PlayerStatsLootModifiers' has a wrong offset!");
static_assert(offsetof(AGzSessionGameModeBase, SpecialLootModifier) == 0x000540, "Member 'AGzSessionGameModeBase::SpecialLootModifier' has a wrong offset!");
static_assert(offsetof(AGzSessionGameModeBase, GzGameState) == 0x000548, "Member 'AGzSessionGameModeBase::GzGameState' has a wrong offset!");
static_assert(offsetof(AGzSessionGameModeBase, WinnerTeam) == 0x000558, "Member 'AGzSessionGameModeBase::WinnerTeam' has a wrong offset!");

// Class G01.GzPrototypeSessionGameMode
// 0x0000 (0x05C8 - 0x05C8)
class AGzPrototypeSessionGameMode final : public AGzSessionGameModeBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzPrototypeSessionGameMode">();
	}
	static class AGzPrototypeSessionGameMode* GetDefaultObj()
	{
		return GetDefaultObjImpl<AGzPrototypeSessionGameMode>();
	}
};
static_assert(alignof(AGzPrototypeSessionGameMode) == 0x000008, "Wrong alignment on AGzPrototypeSessionGameMode");
static_assert(sizeof(AGzPrototypeSessionGameMode) == 0x0005C8, "Wrong size on AGzPrototypeSessionGameMode");

// Class G01.GzArmorBreakMessage
// 0x0000 (0x0048 - 0x0048)
class UGzArmorBreakMessage final : public UGzPlayerToPlayerInteractionMessage
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzArmorBreakMessage">();
	}
	static class UGzArmorBreakMessage* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzArmorBreakMessage>();
	}
};
static_assert(alignof(UGzArmorBreakMessage) == 0x000008, "Wrong alignment on UGzArmorBreakMessage");
static_assert(sizeof(UGzArmorBreakMessage) == 0x000048, "Wrong size on UGzArmorBreakMessage");

// Class G01.GzXR_UseLimbRedeployModifier
// 0x0008 (0x0090 - 0x0088)
class UGzXR_UseLimbRedeployModifier final : public UGzXR_BaseRedeployModifier
{
public:
	uint8                                         Pad_2E19[0x8];                                     // 0x0088(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzXR_UseLimbRedeployModifier">();
	}
	static class UGzXR_UseLimbRedeployModifier* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzXR_UseLimbRedeployModifier>();
	}
};
static_assert(alignof(UGzXR_UseLimbRedeployModifier) == 0x000008, "Wrong alignment on UGzXR_UseLimbRedeployModifier");
static_assert(sizeof(UGzXR_UseLimbRedeployModifier) == 0x000090, "Wrong size on UGzXR_UseLimbRedeployModifier");

// Class G01.GzClientPlayerInventoryFacade
// 0x0000 (0x0030 - 0x0030)
class UGzClientPlayerInventoryFacade final : public UGzFacade
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzClientPlayerInventoryFacade">();
	}
	static class UGzClientPlayerInventoryFacade* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzClientPlayerInventoryFacade>();
	}
};
static_assert(alignof(UGzClientPlayerInventoryFacade) == 0x000008, "Wrong alignment on UGzClientPlayerInventoryFacade");
static_assert(sizeof(UGzClientPlayerInventoryFacade) == 0x000030, "Wrong size on UGzClientPlayerInventoryFacade");

// Class G01.GzMarkerSceneContainer
// 0x0078 (0x0318 - 0x02A0)
class AGzMarkerSceneContainer : public AActor
{
public:
	class UGzMarkerComponent*                     MarkerComponent;                                   // 0x02A0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FGameplayTag                           MarkerTypeTag;                                     // 0x02A8(0x0008)(BlueprintVisible, NoDestructor, Protected, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bEnableAutoAttachToOwner;                          // 0x02B0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2E1A[0x7];                                     // 0x02B1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGzMarkerServerData                    ServerData;                                        // 0x02B8(0x0050)(Transient, Protected, NativeAccessSpecifierProtected)
	FMulticastInlineDelegateProperty_             OnAttachedToActor;                                 // 0x0308(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, Protected, NativeAccessSpecifierProtected)

public:
	int32 GetMarkerID() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzMarkerSceneContainer">();
	}
	static class AGzMarkerSceneContainer* GetDefaultObj()
	{
		return GetDefaultObjImpl<AGzMarkerSceneContainer>();
	}
};
static_assert(alignof(AGzMarkerSceneContainer) == 0x000008, "Wrong alignment on AGzMarkerSceneContainer");
static_assert(sizeof(AGzMarkerSceneContainer) == 0x000318, "Wrong size on AGzMarkerSceneContainer");
static_assert(offsetof(AGzMarkerSceneContainer, MarkerComponent) == 0x0002A0, "Member 'AGzMarkerSceneContainer::MarkerComponent' has a wrong offset!");
static_assert(offsetof(AGzMarkerSceneContainer, MarkerTypeTag) == 0x0002A8, "Member 'AGzMarkerSceneContainer::MarkerTypeTag' has a wrong offset!");
static_assert(offsetof(AGzMarkerSceneContainer, bEnableAutoAttachToOwner) == 0x0002B0, "Member 'AGzMarkerSceneContainer::bEnableAutoAttachToOwner' has a wrong offset!");
static_assert(offsetof(AGzMarkerSceneContainer, ServerData) == 0x0002B8, "Member 'AGzMarkerSceneContainer::ServerData' has a wrong offset!");
static_assert(offsetof(AGzMarkerSceneContainer, OnAttachedToActor) == 0x000308, "Member 'AGzMarkerSceneContainer::OnAttachedToActor' has a wrong offset!");

// Class G01.GzArrivalMarker
// 0x0010 (0x0328 - 0x0318)
class AGzArrivalMarker final : public AGzMarkerSceneContainer
{
public:
	FMulticastInlineDelegateProperty_             OnArrivalTimeUpdated;                              // 0x0318(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)

public:
	float GetArrivalTime();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzArrivalMarker">();
	}
	static class AGzArrivalMarker* GetDefaultObj()
	{
		return GetDefaultObjImpl<AGzArrivalMarker>();
	}
};
static_assert(alignof(AGzArrivalMarker) == 0x000008, "Wrong alignment on AGzArrivalMarker");
static_assert(sizeof(AGzArrivalMarker) == 0x000328, "Wrong size on AGzArrivalMarker");
static_assert(offsetof(AGzArrivalMarker, OnArrivalTimeUpdated) == 0x000318, "Member 'AGzArrivalMarker::OnArrivalTimeUpdated' has a wrong offset!");

// Class G01.GzMicroMissileCarrier
// 0x00B8 (0x03B8 - 0x0300)
class AGzMicroMissileCarrier final : public AGzDamageableActor
{
public:
	TSoftClassPtr<class UClass>                   MicroMissileProjectileClass;                       // 0x0300(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UGzProjectileData*                      MicroMissileProjectileData;                        // 0x0328(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MaxProjectileSpreadAngle;                          // 0x0330(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         ProjectileCount;                                   // 0x0334(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MissileSpeed;                                      // 0x0338(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2E1B[0x4];                                     // 0x033C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                Start;                                             // 0x0340(0x0018)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                StartAnchor;                                       // 0x0358(0x0018)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                End;                                               // 0x0370(0x0018)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                EndAnchor;                                         // 0x0388(0x0018)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         Distance;                                          // 0x03A0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2E1C[0x4];                                     // 0x03A4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGzCharacterIdAccess                   CharacterIdAccess;                                 // 0x03A8(0x0010)(BlueprintVisible, Transient, NoDestructor, NativeAccessSpecifierPublic)

public:
	void SpawnMicroMissile(int32 MissileIndex);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzMicroMissileCarrier">();
	}
	static class AGzMicroMissileCarrier* GetDefaultObj()
	{
		return GetDefaultObjImpl<AGzMicroMissileCarrier>();
	}
};
static_assert(alignof(AGzMicroMissileCarrier) == 0x000008, "Wrong alignment on AGzMicroMissileCarrier");
static_assert(sizeof(AGzMicroMissileCarrier) == 0x0003B8, "Wrong size on AGzMicroMissileCarrier");
static_assert(offsetof(AGzMicroMissileCarrier, MicroMissileProjectileClass) == 0x000300, "Member 'AGzMicroMissileCarrier::MicroMissileProjectileClass' has a wrong offset!");
static_assert(offsetof(AGzMicroMissileCarrier, MicroMissileProjectileData) == 0x000328, "Member 'AGzMicroMissileCarrier::MicroMissileProjectileData' has a wrong offset!");
static_assert(offsetof(AGzMicroMissileCarrier, MaxProjectileSpreadAngle) == 0x000330, "Member 'AGzMicroMissileCarrier::MaxProjectileSpreadAngle' has a wrong offset!");
static_assert(offsetof(AGzMicroMissileCarrier, ProjectileCount) == 0x000334, "Member 'AGzMicroMissileCarrier::ProjectileCount' has a wrong offset!");
static_assert(offsetof(AGzMicroMissileCarrier, MissileSpeed) == 0x000338, "Member 'AGzMicroMissileCarrier::MissileSpeed' has a wrong offset!");
static_assert(offsetof(AGzMicroMissileCarrier, Start) == 0x000340, "Member 'AGzMicroMissileCarrier::Start' has a wrong offset!");
static_assert(offsetof(AGzMicroMissileCarrier, StartAnchor) == 0x000358, "Member 'AGzMicroMissileCarrier::StartAnchor' has a wrong offset!");
static_assert(offsetof(AGzMicroMissileCarrier, End) == 0x000370, "Member 'AGzMicroMissileCarrier::End' has a wrong offset!");
static_assert(offsetof(AGzMicroMissileCarrier, EndAnchor) == 0x000388, "Member 'AGzMicroMissileCarrier::EndAnchor' has a wrong offset!");
static_assert(offsetof(AGzMicroMissileCarrier, Distance) == 0x0003A0, "Member 'AGzMicroMissileCarrier::Distance' has a wrong offset!");
static_assert(offsetof(AGzMicroMissileCarrier, CharacterIdAccess) == 0x0003A8, "Member 'AGzMicroMissileCarrier::CharacterIdAccess' has a wrong offset!");

// Class G01.GzCustomizationModifierTemplate_MaterialScalar
// 0x0018 (0x00E8 - 0x00D0)
class UGzCustomizationModifierTemplate_MaterialScalar final : public UGzCustomizationModifierTemplate_MaterialParam
{
public:
	struct FFloatRange                            ValueRange;                                        // 0x00D0(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DefaultValue;                                      // 0x00E0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2E1D[0x4];                                     // 0x00E4(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzCustomizationModifierTemplate_MaterialScalar">();
	}
	static class UGzCustomizationModifierTemplate_MaterialScalar* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzCustomizationModifierTemplate_MaterialScalar>();
	}
};
static_assert(alignof(UGzCustomizationModifierTemplate_MaterialScalar) == 0x000008, "Wrong alignment on UGzCustomizationModifierTemplate_MaterialScalar");
static_assert(sizeof(UGzCustomizationModifierTemplate_MaterialScalar) == 0x0000E8, "Wrong size on UGzCustomizationModifierTemplate_MaterialScalar");
static_assert(offsetof(UGzCustomizationModifierTemplate_MaterialScalar, ValueRange) == 0x0000D0, "Member 'UGzCustomizationModifierTemplate_MaterialScalar::ValueRange' has a wrong offset!");
static_assert(offsetof(UGzCustomizationModifierTemplate_MaterialScalar, DefaultValue) == 0x0000E0, "Member 'UGzCustomizationModifierTemplate_MaterialScalar::DefaultValue' has a wrong offset!");

// Class G01.LaserBeam
// 0x0020 (0x02C0 - 0x02A0)
class ALaserBeam final : public AActor
{
public:
	class USceneComponent*                        RootSceneComponent;                                // 0x02A0(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UParticleSystemComponent*               LaserFlashComponent;                               // 0x02A8(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   TubeMeshComponent;                                 // 0x02B0(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UGzWeaponComponent*                     Weapon;                                            // 0x02B8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LaserBeam">();
	}
	static class ALaserBeam* GetDefaultObj()
	{
		return GetDefaultObjImpl<ALaserBeam>();
	}
};
static_assert(alignof(ALaserBeam) == 0x000008, "Wrong alignment on ALaserBeam");
static_assert(sizeof(ALaserBeam) == 0x0002C0, "Wrong size on ALaserBeam");
static_assert(offsetof(ALaserBeam, RootSceneComponent) == 0x0002A0, "Member 'ALaserBeam::RootSceneComponent' has a wrong offset!");
static_assert(offsetof(ALaserBeam, LaserFlashComponent) == 0x0002A8, "Member 'ALaserBeam::LaserFlashComponent' has a wrong offset!");
static_assert(offsetof(ALaserBeam, TubeMeshComponent) == 0x0002B0, "Member 'ALaserBeam::TubeMeshComponent' has a wrong offset!");
static_assert(offsetof(ALaserBeam, Weapon) == 0x0002B8, "Member 'ALaserBeam::Weapon' has a wrong offset!");

// Class G01.GzASCBlueprintFunctionLibrary
// 0x0000 (0x0028 - 0x0028)
class UGzASCBlueprintFunctionLibrary final : public UBlueprintFunctionLibrary
{
public:
	static void AddGameplayCue_NonReplicated(class AActor* Target, const struct FGameplayTag& GameplayCueTag, const struct FGameplayCueParameters& Parameters);
	static void EffectContextAddSourceObject(const struct FGameplayEffectContextHandle& EffectContext, class UObject* SourceObject);
	static void ExecuteGameplayCue_NonReplicated(class AActor* Target, const struct FGameplayTag& GameplayCueTag, const struct FGameplayCueParameters& Parameters);
	static void RemoveGameplayCue_NonReplicated(class AActor* Target, const struct FGameplayTag& GameplayCueTag, const struct FGameplayCueParameters& Parameters);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzASCBlueprintFunctionLibrary">();
	}
	static class UGzASCBlueprintFunctionLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzASCBlueprintFunctionLibrary>();
	}
};
static_assert(alignof(UGzASCBlueprintFunctionLibrary) == 0x000008, "Wrong alignment on UGzASCBlueprintFunctionLibrary");
static_assert(sizeof(UGzASCBlueprintFunctionLibrary) == 0x000028, "Wrong size on UGzASCBlueprintFunctionLibrary");

// Class G01.GzClientSettingsService
// 0x0010 (0x00B0 - 0x00A0)
class UGzClientSettingsService final : public UGzClientPFObject
{
public:
	uint8                                         Pad_2E1E[0x10];                                    // 0x00A0(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzClientSettingsService">();
	}
	static class UGzClientSettingsService* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzClientSettingsService>();
	}
};
static_assert(alignof(UGzClientSettingsService) == 0x000008, "Wrong alignment on UGzClientSettingsService");
static_assert(sizeof(UGzClientSettingsService) == 0x0000B0, "Wrong size on UGzClientSettingsService");

// Class G01.GzDamageableComponent
// 0x0028 (0x00D0 - 0x00A8)
class UGzDamageableComponent : public UActorComponent
{
public:
	FMulticastInlineDelegateProperty_             OnSingleHitDamage;                                 // 0x00A8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnMultiHitDamage;                                  // 0x00B8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	bool                                          bSendHitResponses;                                 // 0x00C8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2E1F[0x7];                                     // 0x00C9(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnReceiveMultiHitDamage(const struct FGzMultiHitDamage& Damage);
	void OnReceiveSingleHitDamage(const struct FGzSingleHitDamage& Damage);
	void ReceiveMultiHitDamage(const struct FGzMultiHitDamage& Damage);
	void ReceiveSingleHitDamage(const struct FGzSingleHitDamage& Damage);
	void SetTeamOverride(const struct FGenericTeamId& TeamID);

	struct FGenericTeamId GetTeamOverride() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzDamageableComponent">();
	}
	static class UGzDamageableComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzDamageableComponent>();
	}
};
static_assert(alignof(UGzDamageableComponent) == 0x000008, "Wrong alignment on UGzDamageableComponent");
static_assert(sizeof(UGzDamageableComponent) == 0x0000D0, "Wrong size on UGzDamageableComponent");
static_assert(offsetof(UGzDamageableComponent, OnSingleHitDamage) == 0x0000A8, "Member 'UGzDamageableComponent::OnSingleHitDamage' has a wrong offset!");
static_assert(offsetof(UGzDamageableComponent, OnMultiHitDamage) == 0x0000B8, "Member 'UGzDamageableComponent::OnMultiHitDamage' has a wrong offset!");
static_assert(offsetof(UGzDamageableComponent, bSendHitResponses) == 0x0000C8, "Member 'UGzDamageableComponent::bSendHitResponses' has a wrong offset!");

// Class G01.GzGA_MeleeAttack
// 0x0028 (0x06A0 - 0x0678)
class UGzGA_MeleeAttack final : public UGzGA_BaseLimbAbility
{
public:
	class UAnimMontage*                           MontageToPlay;                                     // 0x0678(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           PredictedHitGameplayCueTag;                        // 0x0680(0x0008)(Edit, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           ApprovedHitGameplayCueTag;                         // 0x0688(0x0008)(Edit, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UGzGE_BaseDamage>           HitDamageEffect;                                   // 0x0690(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxValidDistance;                                  // 0x0698(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxValidAngle;                                     // 0x069C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static bool CalculateSnapDirection(class AActor* CharacterActor, float DetectionRadius, struct FVector* OutDirectionToEnemy, float* OutDistanceToEnemy);

	void ClientPredictTargetData(const struct FGameplayAbilityTargetDataHandle& TargetData);
	void OnTagetDataAccepted(const struct FGameplayAbilityTargetDataHandle& TargetData);
	void ServerHandleClientTargetData(const struct FGameplayAbilityTargetDataHandle& TargetData);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzGA_MeleeAttack">();
	}
	static class UGzGA_MeleeAttack* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzGA_MeleeAttack>();
	}
};
static_assert(alignof(UGzGA_MeleeAttack) == 0x000008, "Wrong alignment on UGzGA_MeleeAttack");
static_assert(sizeof(UGzGA_MeleeAttack) == 0x0006A0, "Wrong size on UGzGA_MeleeAttack");
static_assert(offsetof(UGzGA_MeleeAttack, MontageToPlay) == 0x000678, "Member 'UGzGA_MeleeAttack::MontageToPlay' has a wrong offset!");
static_assert(offsetof(UGzGA_MeleeAttack, PredictedHitGameplayCueTag) == 0x000680, "Member 'UGzGA_MeleeAttack::PredictedHitGameplayCueTag' has a wrong offset!");
static_assert(offsetof(UGzGA_MeleeAttack, ApprovedHitGameplayCueTag) == 0x000688, "Member 'UGzGA_MeleeAttack::ApprovedHitGameplayCueTag' has a wrong offset!");
static_assert(offsetof(UGzGA_MeleeAttack, HitDamageEffect) == 0x000690, "Member 'UGzGA_MeleeAttack::HitDamageEffect' has a wrong offset!");
static_assert(offsetof(UGzGA_MeleeAttack, MaxValidDistance) == 0x000698, "Member 'UGzGA_MeleeAttack::MaxValidDistance' has a wrong offset!");
static_assert(offsetof(UGzGA_MeleeAttack, MaxValidAngle) == 0x00069C, "Member 'UGzGA_MeleeAttack::MaxValidAngle' has a wrong offset!");

// Class G01.GzLimbAttachedMessage
// 0x0008 (0x0038 - 0x0030)
class UGzLimbAttachedMessage final : public UGzInstigatedMessage
{
public:
	EGzLimbType                                   LimbType;                                          // 0x0030(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2E22[0x7];                                     // 0x0031(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzLimbAttachedMessage">();
	}
	static class UGzLimbAttachedMessage* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzLimbAttachedMessage>();
	}
};
static_assert(alignof(UGzLimbAttachedMessage) == 0x000008, "Wrong alignment on UGzLimbAttachedMessage");
static_assert(sizeof(UGzLimbAttachedMessage) == 0x000038, "Wrong size on UGzLimbAttachedMessage");
static_assert(offsetof(UGzLimbAttachedMessage, LimbType) == 0x000030, "Member 'UGzLimbAttachedMessage::LimbType' has a wrong offset!");

// Class G01.GzAscDamageableComponent
// 0x0000 (0x00D0 - 0x00D0)
class UGzAscDamageableComponent final : public UGzDamageableComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzAscDamageableComponent">();
	}
	static class UGzAscDamageableComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzAscDamageableComponent>();
	}
};
static_assert(alignof(UGzAscDamageableComponent) == 0x000008, "Wrong alignment on UGzAscDamageableComponent");
static_assert(sizeof(UGzAscDamageableComponent) == 0x0000D0, "Wrong size on UGzAscDamageableComponent");

// Class G01.GZ_GAS_EngineSubsystem
// 0x0000 (0x0030 - 0x0030)
class UGZ_GAS_EngineSubsystem final : public UEngineSubsystem
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GZ_GAS_EngineSubsystem">();
	}
	static class UGZ_GAS_EngineSubsystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGZ_GAS_EngineSubsystem>();
	}
};
static_assert(alignof(UGZ_GAS_EngineSubsystem) == 0x000008, "Wrong alignment on UGZ_GAS_EngineSubsystem");
static_assert(sizeof(UGZ_GAS_EngineSubsystem) == 0x000030, "Wrong size on UGZ_GAS_EngineSubsystem");

// Class G01.GzCharacterCustomizationModel
// 0x0220 (0x0290 - 0x0070)
class UGzCharacterCustomizationModel final : public UGzBackendModel
{
public:
	uint8                                         Pad_2E23[0x220];                                   // 0x0070(0x0220)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzCharacterCustomizationModel">();
	}
	static class UGzCharacterCustomizationModel* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzCharacterCustomizationModel>();
	}
};
static_assert(alignof(UGzCharacterCustomizationModel) == 0x000008, "Wrong alignment on UGzCharacterCustomizationModel");
static_assert(sizeof(UGzCharacterCustomizationModel) == 0x000290, "Wrong size on UGzCharacterCustomizationModel");

// Class G01.GzInputMappingConfig
// 0x0018 (0x0048 - 0x0030)
class UGzInputMappingConfig : public UDataAsset
{
public:
	TArray<struct FGzInputMappingContextInfo>     MappingContextsData;                               // 0x0030(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	int32                                         ConfigPriority;                                    // 0x0040(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2E24[0x4];                                     // 0x0044(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzInputMappingConfig">();
	}
	static class UGzInputMappingConfig* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzInputMappingConfig>();
	}
};
static_assert(alignof(UGzInputMappingConfig) == 0x000008, "Wrong alignment on UGzInputMappingConfig");
static_assert(sizeof(UGzInputMappingConfig) == 0x000048, "Wrong size on UGzInputMappingConfig");
static_assert(offsetof(UGzInputMappingConfig, MappingContextsData) == 0x000030, "Member 'UGzInputMappingConfig::MappingContextsData' has a wrong offset!");
static_assert(offsetof(UGzInputMappingConfig, ConfigPriority) == 0x000040, "Member 'UGzInputMappingConfig::ConfigPriority' has a wrong offset!");

// Class G01.GzAssaultDrone
// 0x0120 (0x05B0 - 0x0490)
class AGzAssaultDrone : public AGzAIPawn
{
public:
	uint8                                         Pad_2E25[0x10];                                    // 0x0490(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class UGzSmoothPawnMovementComponent*         SmoothPawnMovementComponent;                       // 0x04A0(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bHasDestinationPoint;                              // 0x04A8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2E26[0x3];                                     // 0x04A9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Lifetime;                                          // 0x04AC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CooldownTime;                                      // 0x04B0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InterpSpeed;                                       // 0x04B4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DroneAnimationValue;                               // 0x04B8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2E27[0x4];                                     // 0x04BC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                FlyBoxExtend;                                      // 0x04C0(0x0018)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TargetRotationInterpSpeed;                         // 0x04D8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2E28[0x4];                                     // 0x04DC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftClassPtr<class UClass>                   DroneMarkerClass;                                  // 0x04E0(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UGzCombatComponent*                     CombatComponent;                                   // 0x0508(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MarkerId;                                          // 0x0510(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CurrentLifeTime;                                   // 0x0514(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 AttackTarget;                                      // 0x0518(0x0008)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                FlyVelocity;                                       // 0x0520(0x0018)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Acceleration;                                      // 0x0538(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2E29[0x4];                                     // 0x053C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                TargetPoint;                                       // 0x0540(0x0018)(Net, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FVector                                VolumeLocation;                                    // 0x0558(0x0018)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class AActor*                                 SpawnableOwner;                                    // 0x0570(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2E2A[0x18];                                    // 0x0578(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         FlyAcceleration;                                   // 0x0590(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         FlyPlaneCoef;                                      // 0x0594(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         BounceCoef;                                        // 0x0598(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         DroneMass;                                         // 0x059C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         DroneAnimationInterpSpeed;                         // 0x05A0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         MaxDroneAnimationValue;                            // 0x05A4(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2E2B[0x8];                                     // 0x05A8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AddImpulse(const struct FVector& Impulse);
	void AssignOnOwnerEvents(class AActor* NewOwner);
	void CalculateAnimationValue(float DeltaSeconds);
	void CalculateLifeTime(float DeltaSeconds);
	void FindNextTargetPoint();
	struct FVector GeneratePatrolVolume(const struct FVector& StartPointRef, const struct FVector& TargetPointRef);
	void OnCollisionHit(const struct FHitResult& HitResult);
	void OnOwnerDestroyed(class AActor* Actor);
	void OnOwnerKilled(int32 KillerId);
	void SetFlyPoint(const struct FVector& TargetPointRef);
	void TryFlyToPoint(float DeltaSeconds);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzAssaultDrone">();
	}
	static class AGzAssaultDrone* GetDefaultObj()
	{
		return GetDefaultObjImpl<AGzAssaultDrone>();
	}
};
static_assert(alignof(AGzAssaultDrone) == 0x000010, "Wrong alignment on AGzAssaultDrone");
static_assert(sizeof(AGzAssaultDrone) == 0x0005B0, "Wrong size on AGzAssaultDrone");
static_assert(offsetof(AGzAssaultDrone, SmoothPawnMovementComponent) == 0x0004A0, "Member 'AGzAssaultDrone::SmoothPawnMovementComponent' has a wrong offset!");
static_assert(offsetof(AGzAssaultDrone, bHasDestinationPoint) == 0x0004A8, "Member 'AGzAssaultDrone::bHasDestinationPoint' has a wrong offset!");
static_assert(offsetof(AGzAssaultDrone, Lifetime) == 0x0004AC, "Member 'AGzAssaultDrone::Lifetime' has a wrong offset!");
static_assert(offsetof(AGzAssaultDrone, CooldownTime) == 0x0004B0, "Member 'AGzAssaultDrone::CooldownTime' has a wrong offset!");
static_assert(offsetof(AGzAssaultDrone, InterpSpeed) == 0x0004B4, "Member 'AGzAssaultDrone::InterpSpeed' has a wrong offset!");
static_assert(offsetof(AGzAssaultDrone, DroneAnimationValue) == 0x0004B8, "Member 'AGzAssaultDrone::DroneAnimationValue' has a wrong offset!");
static_assert(offsetof(AGzAssaultDrone, FlyBoxExtend) == 0x0004C0, "Member 'AGzAssaultDrone::FlyBoxExtend' has a wrong offset!");
static_assert(offsetof(AGzAssaultDrone, TargetRotationInterpSpeed) == 0x0004D8, "Member 'AGzAssaultDrone::TargetRotationInterpSpeed' has a wrong offset!");
static_assert(offsetof(AGzAssaultDrone, DroneMarkerClass) == 0x0004E0, "Member 'AGzAssaultDrone::DroneMarkerClass' has a wrong offset!");
static_assert(offsetof(AGzAssaultDrone, CombatComponent) == 0x000508, "Member 'AGzAssaultDrone::CombatComponent' has a wrong offset!");
static_assert(offsetof(AGzAssaultDrone, MarkerId) == 0x000510, "Member 'AGzAssaultDrone::MarkerId' has a wrong offset!");
static_assert(offsetof(AGzAssaultDrone, CurrentLifeTime) == 0x000514, "Member 'AGzAssaultDrone::CurrentLifeTime' has a wrong offset!");
static_assert(offsetof(AGzAssaultDrone, AttackTarget) == 0x000518, "Member 'AGzAssaultDrone::AttackTarget' has a wrong offset!");
static_assert(offsetof(AGzAssaultDrone, FlyVelocity) == 0x000520, "Member 'AGzAssaultDrone::FlyVelocity' has a wrong offset!");
static_assert(offsetof(AGzAssaultDrone, Acceleration) == 0x000538, "Member 'AGzAssaultDrone::Acceleration' has a wrong offset!");
static_assert(offsetof(AGzAssaultDrone, TargetPoint) == 0x000540, "Member 'AGzAssaultDrone::TargetPoint' has a wrong offset!");
static_assert(offsetof(AGzAssaultDrone, VolumeLocation) == 0x000558, "Member 'AGzAssaultDrone::VolumeLocation' has a wrong offset!");
static_assert(offsetof(AGzAssaultDrone, SpawnableOwner) == 0x000570, "Member 'AGzAssaultDrone::SpawnableOwner' has a wrong offset!");
static_assert(offsetof(AGzAssaultDrone, FlyAcceleration) == 0x000590, "Member 'AGzAssaultDrone::FlyAcceleration' has a wrong offset!");
static_assert(offsetof(AGzAssaultDrone, FlyPlaneCoef) == 0x000594, "Member 'AGzAssaultDrone::FlyPlaneCoef' has a wrong offset!");
static_assert(offsetof(AGzAssaultDrone, BounceCoef) == 0x000598, "Member 'AGzAssaultDrone::BounceCoef' has a wrong offset!");
static_assert(offsetof(AGzAssaultDrone, DroneMass) == 0x00059C, "Member 'AGzAssaultDrone::DroneMass' has a wrong offset!");
static_assert(offsetof(AGzAssaultDrone, DroneAnimationInterpSpeed) == 0x0005A0, "Member 'AGzAssaultDrone::DroneAnimationInterpSpeed' has a wrong offset!");
static_assert(offsetof(AGzAssaultDrone, MaxDroneAnimationValue) == 0x0005A4, "Member 'AGzAssaultDrone::MaxDroneAnimationValue' has a wrong offset!");

// Class G01.GzAssetManager
// 0x01C8 (0x0698 - 0x04D0)
class UGzAssetManager final : public UAssetManager
{
public:
	uint8                                         Pad_2E2C[0x18];                                    // 0x04D0(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<EGzItemType, struct FGzItemsGroup>       ItemsBank;                                         // 0x04E8(0x0050)(Transient, Protected, NativeAccessSpecifierProtected)
	TMap<EGzAssetCacheType, struct FGzCachedAssetList> CacheMap;                                          // 0x0538(0x0050)(Transient, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_2E2D[0xA0];                                    // 0x0588(0x00A0)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UObject*>                        AssetsCache;                                       // 0x0628(0x0010)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_2E2E[0x60];                                    // 0x0638(0x0060)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzAssetManager">();
	}
	static class UGzAssetManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzAssetManager>();
	}
};
static_assert(alignof(UGzAssetManager) == 0x000008, "Wrong alignment on UGzAssetManager");
static_assert(sizeof(UGzAssetManager) == 0x000698, "Wrong size on UGzAssetManager");
static_assert(offsetof(UGzAssetManager, ItemsBank) == 0x0004E8, "Member 'UGzAssetManager::ItemsBank' has a wrong offset!");
static_assert(offsetof(UGzAssetManager, CacheMap) == 0x000538, "Member 'UGzAssetManager::CacheMap' has a wrong offset!");
static_assert(offsetof(UGzAssetManager, AssetsCache) == 0x000628, "Member 'UGzAssetManager::AssetsCache' has a wrong offset!");

// Class G01.GzLoadingScreenController
// 0x0040 (0x0068 - 0x0028)
class UGzLoadingScreenController final : public UObject
{
public:
	uint8                                         Pad_2E2F[0x30];                                    // 0x0028(0x0030)(Fixing Size After Last Property [ Dumper-7 ])
	class UGzLoadingScreenView*                   LoadingScreen;                                     // 0x0058(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2E30[0x8];                                     // 0x0060(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void StartLoadingScreen(class UGzLoadingScreenContext* Context, bool bIsStartup);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzLoadingScreenController">();
	}
	static class UGzLoadingScreenController* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzLoadingScreenController>();
	}
};
static_assert(alignof(UGzLoadingScreenController) == 0x000008, "Wrong alignment on UGzLoadingScreenController");
static_assert(sizeof(UGzLoadingScreenController) == 0x000068, "Wrong size on UGzLoadingScreenController");
static_assert(offsetof(UGzLoadingScreenController, LoadingScreen) == 0x000058, "Member 'UGzLoadingScreenController::LoadingScreen' has a wrong offset!");

// Class G01.GzMarkerActiveStateFilter
// 0x0010 (0x0038 - 0x0028)
class UGzMarkerActiveStateFilter : public UObject
{
public:
	TArray<EGzMarkerActiveStateFilterType>        FilterTypes;                                       // 0x0028(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)

public:
	EGzMarkerActiveState EvaluateState(class UGzMarkerWidget* InMarker) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzMarkerActiveStateFilter">();
	}
	static class UGzMarkerActiveStateFilter* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzMarkerActiveStateFilter>();
	}
};
static_assert(alignof(UGzMarkerActiveStateFilter) == 0x000008, "Wrong alignment on UGzMarkerActiveStateFilter");
static_assert(sizeof(UGzMarkerActiveStateFilter) == 0x000038, "Wrong size on UGzMarkerActiveStateFilter");
static_assert(offsetof(UGzMarkerActiveStateFilter, FilterTypes) == 0x000028, "Member 'UGzMarkerActiveStateFilter::FilterTypes' has a wrong offset!");

// Class G01.GzInteractionPingedMarkerFilter
// 0x0010 (0x0048 - 0x0038)
class UGzInteractionPingedMarkerFilter : public UGzMarkerActiveStateFilter
{
public:
	TArray<TSubclassOf<class AActor>>             InteractableClassesToHide;                         // 0x0038(0x0010)(Edit, ZeroConstructor, Protected, UObjectWrapper, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzInteractionPingedMarkerFilter">();
	}
	static class UGzInteractionPingedMarkerFilter* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzInteractionPingedMarkerFilter>();
	}
};
static_assert(alignof(UGzInteractionPingedMarkerFilter) == 0x000008, "Wrong alignment on UGzInteractionPingedMarkerFilter");
static_assert(sizeof(UGzInteractionPingedMarkerFilter) == 0x000048, "Wrong size on UGzInteractionPingedMarkerFilter");
static_assert(offsetof(UGzInteractionPingedMarkerFilter, InteractableClassesToHide) == 0x000038, "Member 'UGzInteractionPingedMarkerFilter::InteractableClassesToHide' has a wrong offset!");

// Class G01.GzCriticalMessagesService
// 0x0068 (0x0108 - 0x00A0)
class UGzCriticalMessagesService final : public UGzClientPFObject
{
public:
	uint8                                         Pad_2E33[0x18];                                    // 0x00A0(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<EGzCohtmlCriticalMessageAction, class UGzCriticalMessageActionHandler*> Actions;                                           // 0x00B8(0x0050)(NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzCriticalMessagesService">();
	}
	static class UGzCriticalMessagesService* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzCriticalMessagesService>();
	}
};
static_assert(alignof(UGzCriticalMessagesService) == 0x000008, "Wrong alignment on UGzCriticalMessagesService");
static_assert(sizeof(UGzCriticalMessagesService) == 0x000108, "Wrong size on UGzCriticalMessagesService");
static_assert(offsetof(UGzCriticalMessagesService, Actions) == 0x0000B8, "Member 'UGzCriticalMessagesService::Actions' has a wrong offset!");

// Class G01.GzAssignmentData
// 0x0060 (0x0090 - 0x0030)
class UGzAssignmentData final : public UPrimaryDataAsset
{
public:
	uint8                                         Pad_2E34[0x8];                                     // 0x0030(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   Name_GzAssignmentData;                             // 0x0038(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	class FText                                   Description;                                       // 0x0048(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FGzPlayerFactionKey                    Faction;                                           // 0x0058(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	TArray<class UGzAssignmentData*>              BlockedBy;                                         // 0x0060(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TArray<class UGzGoalData*>                    Goals;                                             // 0x0070(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TArray<class UGzRewardData*>                  Rewards;                                           // 0x0080(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzAssignmentData">();
	}
	static class UGzAssignmentData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzAssignmentData>();
	}
};
static_assert(alignof(UGzAssignmentData) == 0x000008, "Wrong alignment on UGzAssignmentData");
static_assert(sizeof(UGzAssignmentData) == 0x000090, "Wrong size on UGzAssignmentData");
static_assert(offsetof(UGzAssignmentData, Name_GzAssignmentData) == 0x000038, "Member 'UGzAssignmentData::Name_GzAssignmentData' has a wrong offset!");
static_assert(offsetof(UGzAssignmentData, Description) == 0x000048, "Member 'UGzAssignmentData::Description' has a wrong offset!");
static_assert(offsetof(UGzAssignmentData, Faction) == 0x000058, "Member 'UGzAssignmentData::Faction' has a wrong offset!");
static_assert(offsetof(UGzAssignmentData, BlockedBy) == 0x000060, "Member 'UGzAssignmentData::BlockedBy' has a wrong offset!");
static_assert(offsetof(UGzAssignmentData, Goals) == 0x000070, "Member 'UGzAssignmentData::Goals' has a wrong offset!");
static_assert(offsetof(UGzAssignmentData, Rewards) == 0x000080, "Member 'UGzAssignmentData::Rewards' has a wrong offset!");

// Class G01.GzSoundAnimNotifyBase
// 0x0010 (0x0048 - 0x0038)
class UGzSoundAnimNotifyBase : public UAnimNotify
{
public:
	EGzSoundSourceBodyPart                        SoundSourceBodyPart;                               // 0x0038(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2E35[0x3];                                     // 0x0039(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   ActionType;                                        // 0x003C(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2E36[0x4];                                     // 0x0044(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetActionType(const class FName& InActionType) const;
	void SetSoundSourceBodyPart(EGzSoundSourceBodyPart InSoundSourceBodyPart) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzSoundAnimNotifyBase">();
	}
	static class UGzSoundAnimNotifyBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzSoundAnimNotifyBase>();
	}
};
static_assert(alignof(UGzSoundAnimNotifyBase) == 0x000008, "Wrong alignment on UGzSoundAnimNotifyBase");
static_assert(sizeof(UGzSoundAnimNotifyBase) == 0x000048, "Wrong size on UGzSoundAnimNotifyBase");
static_assert(offsetof(UGzSoundAnimNotifyBase, SoundSourceBodyPart) == 0x000038, "Member 'UGzSoundAnimNotifyBase::SoundSourceBodyPart' has a wrong offset!");
static_assert(offsetof(UGzSoundAnimNotifyBase, ActionType) == 0x00003C, "Member 'UGzSoundAnimNotifyBase::ActionType' has a wrong offset!");

// Class G01.GzCustomizationSoundNotify
// 0x0008 (0x0050 - 0x0048)
class UGzCustomizationSoundNotify final : public UGzSoundAnimNotifyBase
{
public:
	struct FGameplayTag                           Slot;                                              // 0x0048(0x0008)(Edit, BlueprintReadOnly, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void SetSlot(const struct FGameplayTag& InSlot) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzCustomizationSoundNotify">();
	}
	static class UGzCustomizationSoundNotify* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzCustomizationSoundNotify>();
	}
};
static_assert(alignof(UGzCustomizationSoundNotify) == 0x000008, "Wrong alignment on UGzCustomizationSoundNotify");
static_assert(sizeof(UGzCustomizationSoundNotify) == 0x000050, "Wrong size on UGzCustomizationSoundNotify");
static_assert(offsetof(UGzCustomizationSoundNotify, Slot) == 0x000048, "Member 'UGzCustomizationSoundNotify::Slot' has a wrong offset!");

// Class G01.GzInputControlsComponent
// 0x0088 (0x0130 - 0x00A8)
class UGzInputControlsComponent final : public UControllerComponent
{
public:
	class UGzInputMappingConfig*                  DefaultInputConfig;                                // 0x00A8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UInputMappingContext*                   DebugActions;                                      // 0x00B0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UGzInputMappingConfig*                  ActiveInputConfig;                                 // 0x00B8(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<class UInputAction*>                   InputFlushWhitelist;                               // 0x00C0(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	TArray<struct FGzInputMappingDecoratorInfo>   ActiveDecorators;                                  // 0x00D0(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	TMap<struct FGzInputConfigBindingHandle, class UGzInputMappingConfig*> InputMappingConfigs;                               // 0x00E0(0x0050)(Transient, NativeAccessSpecifierPrivate)

public:
	struct FGzInputMappingDecoratorHandle AddInputMappingDecorator(const struct FGzInputMappingContextInfo& MappingContextInfo, const struct FModifyContextOptions& OPTIONS);
	void PopInputMapping(struct FGzInputConfigBindingHandle& InHandle, const struct FModifyContextOptions& OPTIONS);
	struct FGzInputConfigBindingHandle PushInputMapping(class UGzInputMappingConfig* InMappingConfig, const struct FModifyContextOptions& OPTIONS);
	void RemoveInputMappingDecorator(struct FGzInputMappingDecoratorHandle* InHandle);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzInputControlsComponent">();
	}
	static class UGzInputControlsComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzInputControlsComponent>();
	}
};
static_assert(alignof(UGzInputControlsComponent) == 0x000008, "Wrong alignment on UGzInputControlsComponent");
static_assert(sizeof(UGzInputControlsComponent) == 0x000130, "Wrong size on UGzInputControlsComponent");
static_assert(offsetof(UGzInputControlsComponent, DefaultInputConfig) == 0x0000A8, "Member 'UGzInputControlsComponent::DefaultInputConfig' has a wrong offset!");
static_assert(offsetof(UGzInputControlsComponent, DebugActions) == 0x0000B0, "Member 'UGzInputControlsComponent::DebugActions' has a wrong offset!");
static_assert(offsetof(UGzInputControlsComponent, ActiveInputConfig) == 0x0000B8, "Member 'UGzInputControlsComponent::ActiveInputConfig' has a wrong offset!");
static_assert(offsetof(UGzInputControlsComponent, InputFlushWhitelist) == 0x0000C0, "Member 'UGzInputControlsComponent::InputFlushWhitelist' has a wrong offset!");
static_assert(offsetof(UGzInputControlsComponent, ActiveDecorators) == 0x0000D0, "Member 'UGzInputControlsComponent::ActiveDecorators' has a wrong offset!");
static_assert(offsetof(UGzInputControlsComponent, InputMappingConfigs) == 0x0000E0, "Member 'UGzInputControlsComponent::InputMappingConfigs' has a wrong offset!");

// Class G01.GzCharacterDeathStatCollector
// 0x0008 (0x0040 - 0x0038)
class UGzCharacterDeathStatCollector : public UGzGlobalStatsCollector
{
public:
	uint8                                         Pad_2E3A[0x8];                                     // 0x0038(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzCharacterDeathStatCollector">();
	}
	static class UGzCharacterDeathStatCollector* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzCharacterDeathStatCollector>();
	}
};
static_assert(alignof(UGzCharacterDeathStatCollector) == 0x000008, "Wrong alignment on UGzCharacterDeathStatCollector");
static_assert(sizeof(UGzCharacterDeathStatCollector) == 0x000040, "Wrong size on UGzCharacterDeathStatCollector");

// Class G01.GzCrosshairSlot
// 0x0008 (0x02E8 - 0x02E0)
class UGzCrosshairSlot : public UUserWidget
{
public:
	class UOverlay*                               SlotHolder;                                        // 0x02E0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzCrosshairSlot">();
	}
	static class UGzCrosshairSlot* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzCrosshairSlot>();
	}
};
static_assert(alignof(UGzCrosshairSlot) == 0x000008, "Wrong alignment on UGzCrosshairSlot");
static_assert(sizeof(UGzCrosshairSlot) == 0x0002E8, "Wrong size on UGzCrosshairSlot");
static_assert(offsetof(UGzCrosshairSlot, SlotHolder) == 0x0002E0, "Member 'UGzCrosshairSlot::SlotHolder' has a wrong offset!");

// Class G01.GzAssistStatCollector
// 0x0000 (0x0040 - 0x0040)
class UGzAssistStatCollector final : public UGzCharacterDeathStatCollector
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzAssistStatCollector">();
	}
	static class UGzAssistStatCollector* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzAssistStatCollector>();
	}
};
static_assert(alignof(UGzAssistStatCollector) == 0x000008, "Wrong alignment on UGzAssistStatCollector");
static_assert(sizeof(UGzAssistStatCollector) == 0x000040, "Wrong size on UGzAssistStatCollector");

// Class G01.GzWeaponComponent
// 0x02B8 (0x0360 - 0x00A8)
class UGzWeaponComponent : public UActorComponent
{
public:
	uint8                                         Pad_2E3B[0x20];                                    // 0x00A8(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	FMulticastInlineDelegateProperty_             ClipAmmoUpdated;                                   // 0x00C8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             FireModeSwitched;                                  // 0x00D8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnScopeModeChanged;                                // 0x00E8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OverheatStatusChanged;                             // 0x00F8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnWeaponShotWithoutResource;                       // 0x0108(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_2E3C[0x20];                                    // 0x0118(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	class UGzBulletAttackStrategy*                AttackStrategy;                                    // 0x0138(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UGzWeaponResourcesSystem*               WeaponResourcesSystem;                             // 0x0140(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UGzWeaponSpreadSystem*                  WeaponSpreadSystem;                                // 0x0148(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UGzWeaponRecoilSystem*                  WeaponRecoilSystem;                                // 0x0150(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UGzWeaponSwaySystem*                    WeaponSwaySystem;                                  // 0x0158(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UGzWeaponAdsSystem*                     WeaponAdsSystem;                                   // 0x0160(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UGzWeaponOverheatSystem*                WeaponOverheatSystem;                              // 0x0168(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class UGzWeaponSystemBase*>            WeaponSystemsCache;                                // 0x0170(0x0010)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	class UGzWeaponData*                          WeaponData;                                        // 0x0180(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UGzWeaponAIData*                        AIData;                                            // 0x0188(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UGzWeaponAnimationData*                 AnimationData;                                     // 0x0190(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UGzWeaponFXData*                        FXData;                                            // 0x0198(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UGzWeaponSoundData*                     SoundData;                                         // 0x01A0(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UGzWeaponSpreadData*                    SpreadData;                                        // 0x01A8(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UGzWeaponRecoilData*                    RecoilData;                                        // 0x01B0(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UGzWeaponSwayData*                      SwayData;                                          // 0x01B8(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UGzWeaponOverheatData*                  OverheatData;                                      // 0x01C0(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class UGzWeaponModifier*>              PendingModifiers;                                  // 0x01C8(0x0010)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	TArray<class UGzWeaponModifier*>              ActiveModifiers;                                   // 0x01D8(0x0010)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	class UNiagaraComponent*                      MuzzleNiagaraComponent;                            // 0x01E8(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UNiagaraComponent*                      ShellEjectNiagaraComponent;                        // 0x01F0(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UNiagaraComponent*                      GlintNiagaraComponent;                             // 0x01F8(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EGzWeaponSupportHoldType                      LHWeaponSupportHoldTypeOverride;                   // 0x0200(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2E3D[0x7];                                     // 0x0201(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UNiagaraSystem*                         MuzzleNiagaraSystemOverride;                       // 0x0208(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UNiagaraSystem*                         InScope_MuzzleNiagaraSystemOverride;               // 0x0210(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UNiagaraSystem*                         ShellEjectNiagaraSystemOverride;                   // 0x0218(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UNiagaraSystem*                         TraceNiagaraSystemOverride;                        // 0x0220(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UNiagaraSystem*                         GlintNiagaraSystemOverride;                        // 0x0228(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FGameplayTag                           PredictedImpactTagOverride;                        // 0x0230(0x0008)(BlueprintVisible, BlueprintReadOnly, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FGameplayTag                           ApprovedImpactTagOverride;                         // 0x0238(0x0008)(BlueprintVisible, BlueprintReadOnly, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UGzWeaponSoundData*                     FireSoundOverrides;                                // 0x0240(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UCameraShakeBase>           ShotCameraShakeOverride;                           // 0x0248(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UCameraShakeBase>           ShotADSCameraShakeOverride;                        // 0x0250(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<int32>                                 AvailableScopeMagnifications;                      // 0x0258(0x0010)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_2E3E[0xD8];                                    // 0x0268(0x00D8)(Fixing Size After Last Property [ Dumper-7 ])
	class UAkRtpc*                                CachedClipAmmoRtpc;                                // 0x0340(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UGzBulletSubsystem*                     BulletSubsystem;                                   // 0x0348(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UAnimMontage*                           CachedShotMontage;                                 // 0x0350(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2E3F[0x8];                                     // 0x0358(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AddShootingBarrel(const class FName& ShootingBarrelSuffix);
	void Reload();
	void RequestShotInternal();
	void ServerRequestSyncResources();
	void StartAttackRequest();
	void StopAttackRequest();

	bool CanAim() const;
	bool CanAttack() const;
	bool CanReload() const;
	bool CanSimulateShooting() const;
	bool CanStopAttack() const;
	class FName GetActiveShootingBarrel() const;
	float GetAimingProgress() const;
	TArray<int32> GetAllScopeMagnifications() const;
	struct FGzWeaponAnimationLayerData GetAnimationLayer(class AActor* Character) const;
	TSubclassOf<class UGzGE_BaseDamage> GetAttackDamageEffect() const;
	const TArray<struct FGzScopeMode> GetAvailableScopeModes() const;
	TArray<EGzWeaponMode> GetAvailibleFireModes() const;
	int32 GetClipAmmoAmount() const;
	const struct FGzWeaponFireMode GetCurrentFireMode() const;
	int32 GetCurrentScopeMagnification() const;
	const struct FGzScopeMode GetCurrentScopeMode() const;
	int32 GetFireModeIndexByType(EGzWeaponMode WeaponMode) const;
	bool GetFireStartLocationAndRotation(struct FVector* OutLocation, struct FRotator* OutRotation, class FName MuzzleSocketName) const;
	const struct FVector GetJointTargetLocation() const;
	int32 GetMaxClipAmmoAmount() const;
	const class UGzWeaponOverheatData* GetOverheatData() const;
	float GetOverheatPercentage() const;
	class UGzCombatComponent* GetOwnerCombatComponent() const;
	const class UGzWeaponRecoilData* GetRecoilData() const;
	float GetReloadTimeSeconds(class APawn* Pawn) const;
	const class UGzWeaponSpreadData* GetSpreadData() const;
	int32 GetStockAmmoAmount() const;
	const class UGzWeaponSwayData* GetSwayData() const;
	class AGzWeaponActor* GetWeaponActor() const;
	const class UGzWeaponAIData* GetWeaponAIData() const;
	const class UGzWeaponAnimationData* GetWeaponAnimationData() const;
	const class UGzWeaponData* GetWeaponData() const;
	const class UGzWeaponFXData* GetWeaponFXData() const;
	const class UGzWeaponSoundData* GetWeaponSoundData() const;
	bool HasScope() const;
	bool IsClipEmpty() const;
	bool IsClipFull() const;
	bool IsCurrentlyEquipped() const;
	bool IsLimbWeapon() const;
	bool IsOverheated() const;
	bool IsOwnerAiming() const;
	bool IsPendingAttack() const;
	bool IsWeaponSilenced() const;
	bool NeedsRechambering() const;
	void OnWeaponAttackMontageEnded(class UAnimMontage* Montage, bool bInterrupted) const;
	void OnWeaponReloadMontageEnded(class UAnimMontage* Montage, bool bInterrupted) const;
	bool TryFindSocketLocation(class FName MuzzleSocketName, struct FVector* OutLocation) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzWeaponComponent">();
	}
	static class UGzWeaponComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzWeaponComponent>();
	}
};
static_assert(alignof(UGzWeaponComponent) == 0x000008, "Wrong alignment on UGzWeaponComponent");
static_assert(sizeof(UGzWeaponComponent) == 0x000360, "Wrong size on UGzWeaponComponent");
static_assert(offsetof(UGzWeaponComponent, ClipAmmoUpdated) == 0x0000C8, "Member 'UGzWeaponComponent::ClipAmmoUpdated' has a wrong offset!");
static_assert(offsetof(UGzWeaponComponent, FireModeSwitched) == 0x0000D8, "Member 'UGzWeaponComponent::FireModeSwitched' has a wrong offset!");
static_assert(offsetof(UGzWeaponComponent, OnScopeModeChanged) == 0x0000E8, "Member 'UGzWeaponComponent::OnScopeModeChanged' has a wrong offset!");
static_assert(offsetof(UGzWeaponComponent, OverheatStatusChanged) == 0x0000F8, "Member 'UGzWeaponComponent::OverheatStatusChanged' has a wrong offset!");
static_assert(offsetof(UGzWeaponComponent, OnWeaponShotWithoutResource) == 0x000108, "Member 'UGzWeaponComponent::OnWeaponShotWithoutResource' has a wrong offset!");
static_assert(offsetof(UGzWeaponComponent, AttackStrategy) == 0x000138, "Member 'UGzWeaponComponent::AttackStrategy' has a wrong offset!");
static_assert(offsetof(UGzWeaponComponent, WeaponResourcesSystem) == 0x000140, "Member 'UGzWeaponComponent::WeaponResourcesSystem' has a wrong offset!");
static_assert(offsetof(UGzWeaponComponent, WeaponSpreadSystem) == 0x000148, "Member 'UGzWeaponComponent::WeaponSpreadSystem' has a wrong offset!");
static_assert(offsetof(UGzWeaponComponent, WeaponRecoilSystem) == 0x000150, "Member 'UGzWeaponComponent::WeaponRecoilSystem' has a wrong offset!");
static_assert(offsetof(UGzWeaponComponent, WeaponSwaySystem) == 0x000158, "Member 'UGzWeaponComponent::WeaponSwaySystem' has a wrong offset!");
static_assert(offsetof(UGzWeaponComponent, WeaponAdsSystem) == 0x000160, "Member 'UGzWeaponComponent::WeaponAdsSystem' has a wrong offset!");
static_assert(offsetof(UGzWeaponComponent, WeaponOverheatSystem) == 0x000168, "Member 'UGzWeaponComponent::WeaponOverheatSystem' has a wrong offset!");
static_assert(offsetof(UGzWeaponComponent, WeaponSystemsCache) == 0x000170, "Member 'UGzWeaponComponent::WeaponSystemsCache' has a wrong offset!");
static_assert(offsetof(UGzWeaponComponent, WeaponData) == 0x000180, "Member 'UGzWeaponComponent::WeaponData' has a wrong offset!");
static_assert(offsetof(UGzWeaponComponent, AIData) == 0x000188, "Member 'UGzWeaponComponent::AIData' has a wrong offset!");
static_assert(offsetof(UGzWeaponComponent, AnimationData) == 0x000190, "Member 'UGzWeaponComponent::AnimationData' has a wrong offset!");
static_assert(offsetof(UGzWeaponComponent, FXData) == 0x000198, "Member 'UGzWeaponComponent::FXData' has a wrong offset!");
static_assert(offsetof(UGzWeaponComponent, SoundData) == 0x0001A0, "Member 'UGzWeaponComponent::SoundData' has a wrong offset!");
static_assert(offsetof(UGzWeaponComponent, SpreadData) == 0x0001A8, "Member 'UGzWeaponComponent::SpreadData' has a wrong offset!");
static_assert(offsetof(UGzWeaponComponent, RecoilData) == 0x0001B0, "Member 'UGzWeaponComponent::RecoilData' has a wrong offset!");
static_assert(offsetof(UGzWeaponComponent, SwayData) == 0x0001B8, "Member 'UGzWeaponComponent::SwayData' has a wrong offset!");
static_assert(offsetof(UGzWeaponComponent, OverheatData) == 0x0001C0, "Member 'UGzWeaponComponent::OverheatData' has a wrong offset!");
static_assert(offsetof(UGzWeaponComponent, PendingModifiers) == 0x0001C8, "Member 'UGzWeaponComponent::PendingModifiers' has a wrong offset!");
static_assert(offsetof(UGzWeaponComponent, ActiveModifiers) == 0x0001D8, "Member 'UGzWeaponComponent::ActiveModifiers' has a wrong offset!");
static_assert(offsetof(UGzWeaponComponent, MuzzleNiagaraComponent) == 0x0001E8, "Member 'UGzWeaponComponent::MuzzleNiagaraComponent' has a wrong offset!");
static_assert(offsetof(UGzWeaponComponent, ShellEjectNiagaraComponent) == 0x0001F0, "Member 'UGzWeaponComponent::ShellEjectNiagaraComponent' has a wrong offset!");
static_assert(offsetof(UGzWeaponComponent, GlintNiagaraComponent) == 0x0001F8, "Member 'UGzWeaponComponent::GlintNiagaraComponent' has a wrong offset!");
static_assert(offsetof(UGzWeaponComponent, LHWeaponSupportHoldTypeOverride) == 0x000200, "Member 'UGzWeaponComponent::LHWeaponSupportHoldTypeOverride' has a wrong offset!");
static_assert(offsetof(UGzWeaponComponent, MuzzleNiagaraSystemOverride) == 0x000208, "Member 'UGzWeaponComponent::MuzzleNiagaraSystemOverride' has a wrong offset!");
static_assert(offsetof(UGzWeaponComponent, InScope_MuzzleNiagaraSystemOverride) == 0x000210, "Member 'UGzWeaponComponent::InScope_MuzzleNiagaraSystemOverride' has a wrong offset!");
static_assert(offsetof(UGzWeaponComponent, ShellEjectNiagaraSystemOverride) == 0x000218, "Member 'UGzWeaponComponent::ShellEjectNiagaraSystemOverride' has a wrong offset!");
static_assert(offsetof(UGzWeaponComponent, TraceNiagaraSystemOverride) == 0x000220, "Member 'UGzWeaponComponent::TraceNiagaraSystemOverride' has a wrong offset!");
static_assert(offsetof(UGzWeaponComponent, GlintNiagaraSystemOverride) == 0x000228, "Member 'UGzWeaponComponent::GlintNiagaraSystemOverride' has a wrong offset!");
static_assert(offsetof(UGzWeaponComponent, PredictedImpactTagOverride) == 0x000230, "Member 'UGzWeaponComponent::PredictedImpactTagOverride' has a wrong offset!");
static_assert(offsetof(UGzWeaponComponent, ApprovedImpactTagOverride) == 0x000238, "Member 'UGzWeaponComponent::ApprovedImpactTagOverride' has a wrong offset!");
static_assert(offsetof(UGzWeaponComponent, FireSoundOverrides) == 0x000240, "Member 'UGzWeaponComponent::FireSoundOverrides' has a wrong offset!");
static_assert(offsetof(UGzWeaponComponent, ShotCameraShakeOverride) == 0x000248, "Member 'UGzWeaponComponent::ShotCameraShakeOverride' has a wrong offset!");
static_assert(offsetof(UGzWeaponComponent, ShotADSCameraShakeOverride) == 0x000250, "Member 'UGzWeaponComponent::ShotADSCameraShakeOverride' has a wrong offset!");
static_assert(offsetof(UGzWeaponComponent, AvailableScopeMagnifications) == 0x000258, "Member 'UGzWeaponComponent::AvailableScopeMagnifications' has a wrong offset!");
static_assert(offsetof(UGzWeaponComponent, CachedClipAmmoRtpc) == 0x000340, "Member 'UGzWeaponComponent::CachedClipAmmoRtpc' has a wrong offset!");
static_assert(offsetof(UGzWeaponComponent, BulletSubsystem) == 0x000348, "Member 'UGzWeaponComponent::BulletSubsystem' has a wrong offset!");
static_assert(offsetof(UGzWeaponComponent, CachedShotMontage) == 0x000350, "Member 'UGzWeaponComponent::CachedShotMontage' has a wrong offset!");

// Class G01.GzLaserWeaponComponent
// 0x0018 (0x0378 - 0x0360)
class UGzLaserWeaponComponent final : public UGzWeaponComponent
{
public:
	TSubclassOf<class ALaserBeam>                 LaserActorClass;                                   // 0x0360(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class ALaserBeam*                             LaserBeamActor;                                    // 0x0368(0x0008)(ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bPendingAttack;                                    // 0x0370(0x0001)(Net, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2E46[0x7];                                     // 0x0371(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzLaserWeaponComponent">();
	}
	static class UGzLaserWeaponComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzLaserWeaponComponent>();
	}
};
static_assert(alignof(UGzLaserWeaponComponent) == 0x000008, "Wrong alignment on UGzLaserWeaponComponent");
static_assert(sizeof(UGzLaserWeaponComponent) == 0x000378, "Wrong size on UGzLaserWeaponComponent");
static_assert(offsetof(UGzLaserWeaponComponent, LaserActorClass) == 0x000360, "Member 'UGzLaserWeaponComponent::LaserActorClass' has a wrong offset!");
static_assert(offsetof(UGzLaserWeaponComponent, LaserBeamActor) == 0x000368, "Member 'UGzLaserWeaponComponent::LaserBeamActor' has a wrong offset!");
static_assert(offsetof(UGzLaserWeaponComponent, bPendingAttack) == 0x000370, "Member 'UGzLaserWeaponComponent::bPendingAttack' has a wrong offset!");

// Class G01.GzAsyncTaskAttributeChanged
// 0x0078 (0x00A8 - 0x0030)
class UGzAsyncTaskAttributeChanged final : public UBlueprintAsyncActionBase
{
public:
	FMulticastInlineDelegateProperty_             OnAttributeChanged;                                // 0x0030(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_2E47[0x18];                                    // 0x0040(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	class UAbilitySystemComponent*                ASC;                                               // 0x0058(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2E48[0x48];                                    // 0x0060(0x0048)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UGzAsyncTaskAttributeChanged* ListenForAttributeChange(class UAbilitySystemComponent* AbilitySystemComponent, const struct FGameplayAttribute& Attribute);
	static class UGzAsyncTaskAttributeChanged* ListenForAttributesChange(class UAbilitySystemComponent* AbilitySystemComponent, const TArray<struct FGameplayAttribute>& Attributes);

	void EndTask();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzAsyncTaskAttributeChanged">();
	}
	static class UGzAsyncTaskAttributeChanged* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzAsyncTaskAttributeChanged>();
	}
};
static_assert(alignof(UGzAsyncTaskAttributeChanged) == 0x000008, "Wrong alignment on UGzAsyncTaskAttributeChanged");
static_assert(sizeof(UGzAsyncTaskAttributeChanged) == 0x0000A8, "Wrong size on UGzAsyncTaskAttributeChanged");
static_assert(offsetof(UGzAsyncTaskAttributeChanged, OnAttributeChanged) == 0x000030, "Member 'UGzAsyncTaskAttributeChanged::OnAttributeChanged' has a wrong offset!");
static_assert(offsetof(UGzAsyncTaskAttributeChanged, ASC) == 0x000058, "Member 'UGzAsyncTaskAttributeChanged::ASC' has a wrong offset!");

// Class G01.GzGC_PredictedRangedImpact
// 0x0140 (0x0180 - 0x0040)
class UGzGC_PredictedRangedImpact : public UGameplayCueNotify_Static
{
public:
	struct FGzSurfaceImpactSound                  SurfaceImpactSound;                                // 0x0040(0x0060)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FGzSurfaceBulletDecals                 SurfaceBulletDecals;                               // 0x00A0(0x0060)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FGzSurfaceImpactEffects                SurfaceImpactEffects;                              // 0x0100(0x0060)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	float                                         DecalFadeOutDelayMin;                              // 0x0160(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         DecalFadeOutDelayMax;                              // 0x0164(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         DefaultDecalSize;                                  // 0x0168(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2E49[0x4];                                     // 0x016C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UNiagaraSystem*                         ImpactNiagaraSystem;                               // 0x0170(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2E4A[0x8];                                     // 0x0178(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzGC_PredictedRangedImpact">();
	}
	static class UGzGC_PredictedRangedImpact* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzGC_PredictedRangedImpact>();
	}
};
static_assert(alignof(UGzGC_PredictedRangedImpact) == 0x000008, "Wrong alignment on UGzGC_PredictedRangedImpact");
static_assert(sizeof(UGzGC_PredictedRangedImpact) == 0x000180, "Wrong size on UGzGC_PredictedRangedImpact");
static_assert(offsetof(UGzGC_PredictedRangedImpact, SurfaceImpactSound) == 0x000040, "Member 'UGzGC_PredictedRangedImpact::SurfaceImpactSound' has a wrong offset!");
static_assert(offsetof(UGzGC_PredictedRangedImpact, SurfaceBulletDecals) == 0x0000A0, "Member 'UGzGC_PredictedRangedImpact::SurfaceBulletDecals' has a wrong offset!");
static_assert(offsetof(UGzGC_PredictedRangedImpact, SurfaceImpactEffects) == 0x000100, "Member 'UGzGC_PredictedRangedImpact::SurfaceImpactEffects' has a wrong offset!");
static_assert(offsetof(UGzGC_PredictedRangedImpact, DecalFadeOutDelayMin) == 0x000160, "Member 'UGzGC_PredictedRangedImpact::DecalFadeOutDelayMin' has a wrong offset!");
static_assert(offsetof(UGzGC_PredictedRangedImpact, DecalFadeOutDelayMax) == 0x000164, "Member 'UGzGC_PredictedRangedImpact::DecalFadeOutDelayMax' has a wrong offset!");
static_assert(offsetof(UGzGC_PredictedRangedImpact, DefaultDecalSize) == 0x000168, "Member 'UGzGC_PredictedRangedImpact::DefaultDecalSize' has a wrong offset!");
static_assert(offsetof(UGzGC_PredictedRangedImpact, ImpactNiagaraSystem) == 0x000170, "Member 'UGzGC_PredictedRangedImpact::ImpactNiagaraSystem' has a wrong offset!");

// Class G01.GzAsyncTaskGameplayTagAddedRemoved
// 0x0048 (0x0078 - 0x0030)
class UGzAsyncTaskGameplayTagAddedRemoved final : public UBlueprintAsyncActionBase
{
public:
	FMulticastInlineDelegateProperty_             OnTagAdded;                                        // 0x0030(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnTagRemoved;                                      // 0x0040(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	class UAbilitySystemComponent*                ASC;                                               // 0x0050(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2E4B[0x20];                                    // 0x0058(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UGzAsyncTaskGameplayTagAddedRemoved* ListenForGameplayTagAddedOrRemoved(class UAbilitySystemComponent* AbilitySystemComponent, const struct FGameplayTagContainer& Tags);

	void EndTask();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzAsyncTaskGameplayTagAddedRemoved">();
	}
	static class UGzAsyncTaskGameplayTagAddedRemoved* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzAsyncTaskGameplayTagAddedRemoved>();
	}
};
static_assert(alignof(UGzAsyncTaskGameplayTagAddedRemoved) == 0x000008, "Wrong alignment on UGzAsyncTaskGameplayTagAddedRemoved");
static_assert(sizeof(UGzAsyncTaskGameplayTagAddedRemoved) == 0x000078, "Wrong size on UGzAsyncTaskGameplayTagAddedRemoved");
static_assert(offsetof(UGzAsyncTaskGameplayTagAddedRemoved, OnTagAdded) == 0x000030, "Member 'UGzAsyncTaskGameplayTagAddedRemoved::OnTagAdded' has a wrong offset!");
static_assert(offsetof(UGzAsyncTaskGameplayTagAddedRemoved, OnTagRemoved) == 0x000040, "Member 'UGzAsyncTaskGameplayTagAddedRemoved::OnTagRemoved' has a wrong offset!");
static_assert(offsetof(UGzAsyncTaskGameplayTagAddedRemoved, ASC) == 0x000050, "Member 'UGzAsyncTaskGameplayTagAddedRemoved::ASC' has a wrong offset!");

// Class G01.GzAttachementItemSpawner
// 0x0010 (0x02B0 - 0x02A0)
class AGzAttachementItemSpawner final : public AActor
{
public:
	class AStaticMeshActor*                       StaticMeshActor;                                   // 0x02A0(0x0008)(Edit, ZeroConstructor, DisableEditOnTemplate, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ASkeletalMeshActor*                     SkeletalMeshActor;                                 // 0x02A8(0x0008)(Edit, ZeroConstructor, DisableEditOnTemplate, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzAttachementItemSpawner">();
	}
	static class AGzAttachementItemSpawner* GetDefaultObj()
	{
		return GetDefaultObjImpl<AGzAttachementItemSpawner>();
	}
};
static_assert(alignof(AGzAttachementItemSpawner) == 0x000008, "Wrong alignment on AGzAttachementItemSpawner");
static_assert(sizeof(AGzAttachementItemSpawner) == 0x0002B0, "Wrong size on AGzAttachementItemSpawner");
static_assert(offsetof(AGzAttachementItemSpawner, StaticMeshActor) == 0x0002A0, "Member 'AGzAttachementItemSpawner::StaticMeshActor' has a wrong offset!");
static_assert(offsetof(AGzAttachementItemSpawner, SkeletalMeshActor) == 0x0002A8, "Member 'AGzAttachementItemSpawner::SkeletalMeshActor' has a wrong offset!");

// Class G01.GzHideoutViewpoint
// 0x0020 (0x0A90 - 0x0A70)
class AGzHideoutViewpoint final : public ACineCameraActor
{
public:
	class FString                                 ViewpointName;                                     // 0x0A68(0x0010)(Edit, ZeroConstructor, DisableEditOnTemplate, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TransitionDuration;                                // 0x0A78(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EViewTargetBlendFunction                      BlendFunction;                                     // 0x0A7C(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2E4C[0x3];                                     // 0x0A7D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         BlendExponent;                                     // 0x0A80(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2E4D[0xC];                                     // 0x0A84(0x000C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzHideoutViewpoint">();
	}
	static class AGzHideoutViewpoint* GetDefaultObj()
	{
		return GetDefaultObjImpl<AGzHideoutViewpoint>();
	}
};
static_assert(alignof(AGzHideoutViewpoint) == 0x000010, "Wrong alignment on AGzHideoutViewpoint");
static_assert(sizeof(AGzHideoutViewpoint) == 0x000A90, "Wrong size on AGzHideoutViewpoint");
static_assert(offsetof(AGzHideoutViewpoint, ViewpointName) == 0x000A68, "Member 'AGzHideoutViewpoint::ViewpointName' has a wrong offset!");
static_assert(offsetof(AGzHideoutViewpoint, TransitionDuration) == 0x000A78, "Member 'AGzHideoutViewpoint::TransitionDuration' has a wrong offset!");
static_assert(offsetof(AGzHideoutViewpoint, BlendFunction) == 0x000A7C, "Member 'AGzHideoutViewpoint::BlendFunction' has a wrong offset!");
static_assert(offsetof(AGzHideoutViewpoint, BlendExponent) == 0x000A80, "Member 'AGzHideoutViewpoint::BlendExponent' has a wrong offset!");

// Class G01.GzProjectileBase
// 0x00A8 (0x0348 - 0x02A0)
class AGzProjectileBase : public AActor
{
public:
	uint8                                         Pad_2E4E[0x28];                                    // 0x02A0(0x0028)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bIsDamageable;                                     // 0x02C8(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2E4F[0x7];                                     // 0x02C9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class USphereComponent*                       SphereComponent;                                   // 0x02D0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   StaticMeshComponent;                               // 0x02D8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UGzProjectileMovementComponent*         ProjectileMovementComponent;                       // 0x02E0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bHasPreLaunchCollision;                            // 0x02E8(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShouldRotate;                                     // 0x02E9(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2E50[0x6];                                     // 0x02EA(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRotator                               VisualRotationDelta;                               // 0x02F0(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          bWasLaunched;                                      // 0x0308(0x0001)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2E51[0x3];                                     // 0x0309(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ProjectileGravityScale;                            // 0x030C(0x0004)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2E52[0x8];                                     // 0x0310(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UGzItemData*                            ItemData;                                          // 0x0318(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2E53[0x8];                                     // 0x0320(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UGzProjectileData*                      GzProjectileData;                                  // 0x0328(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UGzDamageableComponent*                 DamageableComponent;                               // 0x0330(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGzCharacterIdAccess                   CharacterIdAccess;                                 // 0x0338(0x0010)(BlueprintVisible, Transient, NoDestructor, NativeAccessSpecifierPublic)

public:
	void InitializeWithData(const class UGzProjectileData* Data);
	void LaunchProjectile(const struct FVector& LaunchPosition, const struct FVector& Direction);
	void LaunchProjectileWithSpeed(const struct FVector& LaunchPosition, const struct FVector& Direction, const float Speed);
	void OnMultiHitDamageReceived(class UGzDamageableComponent* Receiver, const struct FGzMultiHitDamage& Hit);
	void OnRep_GravityScale();
	void OnRep_WasLaunched();
	void OnSingleHitDamageReceived(class UGzDamageableComponent* Receiver, const struct FGzSingleHitDamage& Hit);
	void SetItemData(class UGzItemData* Param_ItemData);
	void SetProjectileLive();
	bool WasLaunched();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzProjectileBase">();
	}
	static class AGzProjectileBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<AGzProjectileBase>();
	}
};
static_assert(alignof(AGzProjectileBase) == 0x000008, "Wrong alignment on AGzProjectileBase");
static_assert(sizeof(AGzProjectileBase) == 0x000348, "Wrong size on AGzProjectileBase");
static_assert(offsetof(AGzProjectileBase, bIsDamageable) == 0x0002C8, "Member 'AGzProjectileBase::bIsDamageable' has a wrong offset!");
static_assert(offsetof(AGzProjectileBase, SphereComponent) == 0x0002D0, "Member 'AGzProjectileBase::SphereComponent' has a wrong offset!");
static_assert(offsetof(AGzProjectileBase, StaticMeshComponent) == 0x0002D8, "Member 'AGzProjectileBase::StaticMeshComponent' has a wrong offset!");
static_assert(offsetof(AGzProjectileBase, ProjectileMovementComponent) == 0x0002E0, "Member 'AGzProjectileBase::ProjectileMovementComponent' has a wrong offset!");
static_assert(offsetof(AGzProjectileBase, bHasPreLaunchCollision) == 0x0002E8, "Member 'AGzProjectileBase::bHasPreLaunchCollision' has a wrong offset!");
static_assert(offsetof(AGzProjectileBase, bShouldRotate) == 0x0002E9, "Member 'AGzProjectileBase::bShouldRotate' has a wrong offset!");
static_assert(offsetof(AGzProjectileBase, VisualRotationDelta) == 0x0002F0, "Member 'AGzProjectileBase::VisualRotationDelta' has a wrong offset!");
static_assert(offsetof(AGzProjectileBase, bWasLaunched) == 0x000308, "Member 'AGzProjectileBase::bWasLaunched' has a wrong offset!");
static_assert(offsetof(AGzProjectileBase, ProjectileGravityScale) == 0x00030C, "Member 'AGzProjectileBase::ProjectileGravityScale' has a wrong offset!");
static_assert(offsetof(AGzProjectileBase, ItemData) == 0x000318, "Member 'AGzProjectileBase::ItemData' has a wrong offset!");
static_assert(offsetof(AGzProjectileBase, GzProjectileData) == 0x000328, "Member 'AGzProjectileBase::GzProjectileData' has a wrong offset!");
static_assert(offsetof(AGzProjectileBase, DamageableComponent) == 0x000330, "Member 'AGzProjectileBase::DamageableComponent' has a wrong offset!");
static_assert(offsetof(AGzProjectileBase, CharacterIdAccess) == 0x000338, "Member 'AGzProjectileBase::CharacterIdAccess' has a wrong offset!");

// Class G01.GzGrappleHookProjectile
// 0x0010 (0x0358 - 0x0348)
class AGzGrappleHookProjectile : public AGzProjectileBase
{
public:
	class UGzGrappleHookComponent*                CachedGrappleHookComponent;                        // 0x0348(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2E55[0x8];                                     // 0x0350(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnFlyingStop(const struct FHitResult& ImpactResult);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzGrappleHookProjectile">();
	}
	static class AGzGrappleHookProjectile* GetDefaultObj()
	{
		return GetDefaultObjImpl<AGzGrappleHookProjectile>();
	}
};
static_assert(alignof(AGzGrappleHookProjectile) == 0x000008, "Wrong alignment on AGzGrappleHookProjectile");
static_assert(sizeof(AGzGrappleHookProjectile) == 0x000358, "Wrong size on AGzGrappleHookProjectile");
static_assert(offsetof(AGzGrappleHookProjectile, CachedGrappleHookComponent) == 0x000348, "Member 'AGzGrappleHookProjectile::CachedGrappleHookComponent' has a wrong offset!");

// Class G01.GzCustomizationItemSpawner
// 0x0010 (0x02B0 - 0x02A0)
class AGzCustomizationItemSpawner final : public AActor
{
public:
	class AStaticMeshActor*                       StaticMeshActor;                                   // 0x02A0(0x0008)(Edit, ZeroConstructor, DisableEditOnTemplate, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ASkeletalMeshActor*                     SkeletalMeshActor;                                 // 0x02A8(0x0008)(Edit, ZeroConstructor, DisableEditOnTemplate, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzCustomizationItemSpawner">();
	}
	static class AGzCustomizationItemSpawner* GetDefaultObj()
	{
		return GetDefaultObjImpl<AGzCustomizationItemSpawner>();
	}
};
static_assert(alignof(AGzCustomizationItemSpawner) == 0x000008, "Wrong alignment on AGzCustomizationItemSpawner");
static_assert(sizeof(AGzCustomizationItemSpawner) == 0x0002B0, "Wrong size on AGzCustomizationItemSpawner");
static_assert(offsetof(AGzCustomizationItemSpawner, StaticMeshActor) == 0x0002A0, "Member 'AGzCustomizationItemSpawner::StaticMeshActor' has a wrong offset!");
static_assert(offsetof(AGzCustomizationItemSpawner, SkeletalMeshActor) == 0x0002A8, "Member 'AGzCustomizationItemSpawner::SkeletalMeshActor' has a wrong offset!");

// Class G01.GzAttachmentSetupToolModel
// 0x0000 (0x0070 - 0x0070)
class UGzAttachmentSetupToolModel final : public UGzBackendModel
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzAttachmentSetupToolModel">();
	}
	static class UGzAttachmentSetupToolModel* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzAttachmentSetupToolModel>();
	}
};
static_assert(alignof(UGzAttachmentSetupToolModel) == 0x000008, "Wrong alignment on UGzAttachmentSetupToolModel");
static_assert(sizeof(UGzAttachmentSetupToolModel) == 0x000070, "Wrong size on UGzAttachmentSetupToolModel");

// Class G01.GzBulletAttackStrategyHolder
// 0x0000 (0x0028 - 0x0028)
class IGzBulletAttackStrategyHolder final : public IInterface
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzBulletAttackStrategyHolder">();
	}
	static class IGzBulletAttackStrategyHolder* GetDefaultObj()
	{
		return GetDefaultObjImpl<IGzBulletAttackStrategyHolder>();
	}
};
static_assert(alignof(IGzBulletAttackStrategyHolder) == 0x000008, "Wrong alignment on IGzBulletAttackStrategyHolder");
static_assert(sizeof(IGzBulletAttackStrategyHolder) == 0x000028, "Wrong size on IGzBulletAttackStrategyHolder");

// Class G01.GzLoadoutSelectionScreen
// 0x0150 (0x0678 - 0x0528)
class UGzLoadoutSelectionScreen : public UGzNavigationWidget
{
public:
	FMulticastInlineDelegateProperty_             OnEndedSelection;                                  // 0x0528(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	class UGzLoadoutsGrid*                        LoadoutsGrid;                                      // 0x0538(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UGzLoadoutListBase*                     LoadoutsList;                                      // 0x0540(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UGzCommonButton*                        ConfirmSelectionButton;                            // 0x0548(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UGzCommonButton*                        AbortSelectionButton;                              // 0x0550(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FGzLoadoutDataConfig                   SelectedLoadoutData;                               // 0x0558(0x0070)(BlueprintVisible, BlueprintReadOnly, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	struct FGzLoadoutDataConfig                   HotLoadoutData;                                    // 0x05C8(0x0070)(BlueprintVisible, BlueprintReadOnly, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	class AGzPlayerController*                    CachedOwningController;                            // 0x0638(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class UGzLoadoutSlot*>                 LoadoutSlots;                                      // 0x0640(0x0010)(BlueprintVisible, ExportObject, ZeroConstructor, ContainsInstancedReference, Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	class FText                                   ScreenDescription;                                 // 0x0650(0x0010)(Edit, NativeAccessSpecifierPrivate)
	class FText                                   LoadoutSelectionCaption;                           // 0x0660(0x0010)(Edit, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2E56[0x8];                                     // 0x0670(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AbortSelection();
	void InitializeLoadoutSlots();
	void OnAbortedSelection_BP();
	void OnConfirmed_BP(class AGzPlayerController* ConfirmedBy, const struct FGzLoadoutDataConfig& LoadoutConfig);
	void OnLoadoutButtonClicked_BP(const struct FGzLoadoutDataConfig& LoadoutConfig);
	void OnLoadoutButtonDoubleClicked_BP(const struct FGzLoadoutDataConfig& LoadoutConfig);
	void OnLoadoutButtonHovered_BP(const struct FGzLoadoutDataConfig& LoadoutConfig);
	void OnLoadoutButtonUnHovered_BP(const struct FGzLoadoutDataConfig& LoadoutConfig);
	void TryConfirmSelection();
	bool ValidateCompleteSelection();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzLoadoutSelectionScreen">();
	}
	static class UGzLoadoutSelectionScreen* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzLoadoutSelectionScreen>();
	}
};
static_assert(alignof(UGzLoadoutSelectionScreen) == 0x000008, "Wrong alignment on UGzLoadoutSelectionScreen");
static_assert(sizeof(UGzLoadoutSelectionScreen) == 0x000678, "Wrong size on UGzLoadoutSelectionScreen");
static_assert(offsetof(UGzLoadoutSelectionScreen, OnEndedSelection) == 0x000528, "Member 'UGzLoadoutSelectionScreen::OnEndedSelection' has a wrong offset!");
static_assert(offsetof(UGzLoadoutSelectionScreen, LoadoutsGrid) == 0x000538, "Member 'UGzLoadoutSelectionScreen::LoadoutsGrid' has a wrong offset!");
static_assert(offsetof(UGzLoadoutSelectionScreen, LoadoutsList) == 0x000540, "Member 'UGzLoadoutSelectionScreen::LoadoutsList' has a wrong offset!");
static_assert(offsetof(UGzLoadoutSelectionScreen, ConfirmSelectionButton) == 0x000548, "Member 'UGzLoadoutSelectionScreen::ConfirmSelectionButton' has a wrong offset!");
static_assert(offsetof(UGzLoadoutSelectionScreen, AbortSelectionButton) == 0x000550, "Member 'UGzLoadoutSelectionScreen::AbortSelectionButton' has a wrong offset!");
static_assert(offsetof(UGzLoadoutSelectionScreen, SelectedLoadoutData) == 0x000558, "Member 'UGzLoadoutSelectionScreen::SelectedLoadoutData' has a wrong offset!");
static_assert(offsetof(UGzLoadoutSelectionScreen, HotLoadoutData) == 0x0005C8, "Member 'UGzLoadoutSelectionScreen::HotLoadoutData' has a wrong offset!");
static_assert(offsetof(UGzLoadoutSelectionScreen, CachedOwningController) == 0x000638, "Member 'UGzLoadoutSelectionScreen::CachedOwningController' has a wrong offset!");
static_assert(offsetof(UGzLoadoutSelectionScreen, LoadoutSlots) == 0x000640, "Member 'UGzLoadoutSelectionScreen::LoadoutSlots' has a wrong offset!");
static_assert(offsetof(UGzLoadoutSelectionScreen, ScreenDescription) == 0x000650, "Member 'UGzLoadoutSelectionScreen::ScreenDescription' has a wrong offset!");
static_assert(offsetof(UGzLoadoutSelectionScreen, LoadoutSelectionCaption) == 0x000660, "Member 'UGzLoadoutSelectionScreen::LoadoutSelectionCaption' has a wrong offset!");

// Class G01.GzPlayableArea
// 0x00A8 (0x0348 - 0x02A0)
class AGzPlayableArea : public AActor
{
public:
	TSubclassOf<class UGzGameplayEffect>          OutsideZoneEffect;                                 // 0x02A0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UMaterialInterface*                     Material;                                          // 0x02A8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         MinHeight;                                         // 0x02B0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         MaxHeight;                                         // 0x02B4(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         TrackingUpdateRate;                                // 0x02B8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2E57[0x4];                                     // 0x02BC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGzPlayableAreaData                    Data;                                              // 0x02C0(0x0018)(Net, Transient, RepNotify, NativeAccessSpecifierPrivate)
	class UProceduralMeshComponent*               BorderMesh;                                        // 0x02D8(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TMap<class AGzPlayerState*, struct FActiveGameplayEffectHandle> PlayerToActiveEffect;                              // 0x02E0(0x0050)(Transient, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2E58[0x18];                                    // 0x0330(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnRep_Data();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzPlayableArea">();
	}
	static class AGzPlayableArea* GetDefaultObj()
	{
		return GetDefaultObjImpl<AGzPlayableArea>();
	}
};
static_assert(alignof(AGzPlayableArea) == 0x000008, "Wrong alignment on AGzPlayableArea");
static_assert(sizeof(AGzPlayableArea) == 0x000348, "Wrong size on AGzPlayableArea");
static_assert(offsetof(AGzPlayableArea, OutsideZoneEffect) == 0x0002A0, "Member 'AGzPlayableArea::OutsideZoneEffect' has a wrong offset!");
static_assert(offsetof(AGzPlayableArea, Material) == 0x0002A8, "Member 'AGzPlayableArea::Material' has a wrong offset!");
static_assert(offsetof(AGzPlayableArea, MinHeight) == 0x0002B0, "Member 'AGzPlayableArea::MinHeight' has a wrong offset!");
static_assert(offsetof(AGzPlayableArea, MaxHeight) == 0x0002B4, "Member 'AGzPlayableArea::MaxHeight' has a wrong offset!");
static_assert(offsetof(AGzPlayableArea, TrackingUpdateRate) == 0x0002B8, "Member 'AGzPlayableArea::TrackingUpdateRate' has a wrong offset!");
static_assert(offsetof(AGzPlayableArea, Data) == 0x0002C0, "Member 'AGzPlayableArea::Data' has a wrong offset!");
static_assert(offsetof(AGzPlayableArea, BorderMesh) == 0x0002D8, "Member 'AGzPlayableArea::BorderMesh' has a wrong offset!");
static_assert(offsetof(AGzPlayableArea, PlayerToActiveEffect) == 0x0002E0, "Member 'AGzPlayableArea::PlayerToActiveEffect' has a wrong offset!");

// Class G01.GzPlatformAchievementComponent
// 0x0000 (0x00A0 - 0x00A0)
class UGzPlatformAchievementComponent : public UGzServiceComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzPlatformAchievementComponent">();
	}
	static class UGzPlatformAchievementComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzPlatformAchievementComponent>();
	}
};
static_assert(alignof(UGzPlatformAchievementComponent) == 0x000008, "Wrong alignment on UGzPlatformAchievementComponent");
static_assert(sizeof(UGzPlatformAchievementComponent) == 0x0000A0, "Wrong size on UGzPlatformAchievementComponent");

// Class G01.GzConsoleAchievementComponent
// 0x0020 (0x00C0 - 0x00A0)
class UGzConsoleAchievementComponent final : public UGzPlatformAchievementComponent
{
public:
	uint8                                         Pad_2E59[0x20];                                    // 0x00A0(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzConsoleAchievementComponent">();
	}
	static class UGzConsoleAchievementComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzConsoleAchievementComponent>();
	}
};
static_assert(alignof(UGzConsoleAchievementComponent) == 0x000008, "Wrong alignment on UGzConsoleAchievementComponent");
static_assert(sizeof(UGzConsoleAchievementComponent) == 0x0000C0, "Wrong size on UGzConsoleAchievementComponent");

// Class G01.GzMultiPartAttributeSet
// 0x0170 (0x0228 - 0x00B8)
class UGzMultiPartAttributeSet : public UGzAliveObjectAttributeSet
{
public:
	struct FGameplayAttributeData                 LeftArmHealth;                                     // 0x00B8(0x0010)(BlueprintVisible, BlueprintReadOnly, Net, RepNotify, Protected, NativeAccessSpecifierProtected)
	struct FGameplayAttributeData                 LeftArmMaxHealth;                                  // 0x00C8(0x0010)(BlueprintVisible, BlueprintReadOnly, Net, RepNotify, Protected, NativeAccessSpecifierProtected)
	struct FGameplayAttributeData                 LeftArmHealing;                                    // 0x00D8(0x0010)(BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)
	struct FGameplayAttributeData                 LeftArmDamage;                                     // 0x00E8(0x0010)(BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)
	struct FGameplayAttributeData                 LeftArmAbilityCharges;                             // 0x00F8(0x0010)(BlueprintVisible, BlueprintReadOnly, Net, RepNotify, Protected, NativeAccessSpecifierProtected)
	struct FGameplayAttributeData                 LeftArmMaxAbilityCharges;                          // 0x0108(0x0010)(BlueprintVisible, BlueprintReadOnly, Net, RepNotify, Protected, NativeAccessSpecifierProtected)
	struct FGameplayAttributeData                 RightArmHealth;                                    // 0x0118(0x0010)(BlueprintVisible, BlueprintReadOnly, Net, RepNotify, Protected, NativeAccessSpecifierProtected)
	struct FGameplayAttributeData                 RightArmMaxHealth;                                 // 0x0128(0x0010)(BlueprintVisible, BlueprintReadOnly, Net, RepNotify, Protected, NativeAccessSpecifierProtected)
	struct FGameplayAttributeData                 RightArmHealing;                                   // 0x0138(0x0010)(BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)
	struct FGameplayAttributeData                 RightArmDamage;                                    // 0x0148(0x0010)(BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)
	struct FGameplayAttributeData                 RightArmAbilityCharges;                            // 0x0158(0x0010)(BlueprintVisible, BlueprintReadOnly, Net, RepNotify, Protected, NativeAccessSpecifierProtected)
	struct FGameplayAttributeData                 RightArmMaxAbilityCharges;                         // 0x0168(0x0010)(BlueprintVisible, BlueprintReadOnly, Net, RepNotify, Protected, NativeAccessSpecifierProtected)
	struct FGameplayAttributeData                 LegsHealth;                                        // 0x0178(0x0010)(BlueprintVisible, BlueprintReadOnly, Net, RepNotify, Protected, NativeAccessSpecifierProtected)
	struct FGameplayAttributeData                 LegsMaxHealth;                                     // 0x0188(0x0010)(BlueprintVisible, BlueprintReadOnly, Net, RepNotify, Protected, NativeAccessSpecifierProtected)
	struct FGameplayAttributeData                 LegsHealing;                                       // 0x0198(0x0010)(BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)
	struct FGameplayAttributeData                 LegsDamage;                                        // 0x01A8(0x0010)(BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)
	struct FGameplayAttributeData                 LegsAbilityCharges;                                // 0x01B8(0x0010)(BlueprintVisible, BlueprintReadOnly, Net, RepNotify, Protected, NativeAccessSpecifierProtected)
	struct FGameplayAttributeData                 LegsMaxAbilityCharges;                             // 0x01C8(0x0010)(BlueprintVisible, BlueprintReadOnly, Net, RepNotify, Protected, NativeAccessSpecifierProtected)
	struct FGameplayAttributeData                 AbilityRechargeMultiplier;                         // 0x01D8(0x0010)(BlueprintVisible, BlueprintReadOnly, Net, RepNotify, Protected, NativeAccessSpecifierProtected)
	struct FGameplayAttributeData                 JetpackHealth;                                     // 0x01E8(0x0010)(BlueprintVisible, BlueprintReadOnly, Net, RepNotify, Protected, NativeAccessSpecifierProtected)
	struct FGameplayAttributeData                 JetpackMaxHealth;                                  // 0x01F8(0x0010)(BlueprintVisible, BlueprintReadOnly, Net, RepNotify, Protected, NativeAccessSpecifierProtected)
	struct FGameplayAttributeData                 JetpackHealing;                                    // 0x0208(0x0010)(BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)
	struct FGameplayAttributeData                 JetpackDamage;                                     // 0x0218(0x0010)(BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)

public:
	void OnRep_AbilityRechargeMultiplier(const struct FGameplayAttributeData& OldAbilityRechargeMultiplier);
	void OnRep_JetpackHealth(const struct FGameplayAttributeData& OldValue);
	void OnRep_JetpackMaxHealth(const struct FGameplayAttributeData& OldValue);
	void OnRep_LeftArmAbilityCharges(const struct FGameplayAttributeData& OldLeftArmAbilityCharges);
	void OnRep_LeftArmHealth(const struct FGameplayAttributeData& OldValue);
	void OnRep_LeftArmMaxAbilityCharges(const struct FGameplayAttributeData& OldLeftArmMaxAbilityCharges);
	void OnRep_LeftArmMaxHealth(const struct FGameplayAttributeData& OldValue);
	void OnRep_LegsAbilityCharges(const struct FGameplayAttributeData& OldLegsAbilityCharges);
	void OnRep_LegsHealth(const struct FGameplayAttributeData& OldValue);
	void OnRep_LegsMaxAbilityCharges(const struct FGameplayAttributeData& OldLegsMaxAbilityCharges);
	void OnRep_LegsMaxHealth(const struct FGameplayAttributeData& OldValue);
	void OnRep_RightArmAbilityCharges(const struct FGameplayAttributeData& OldRightArmAbilityCharges);
	void OnRep_RightArmHealth(const struct FGameplayAttributeData& OldValue);
	void OnRep_RightArmMaxAbilityCharges(const struct FGameplayAttributeData& OldRightArmMaxAbilityCharges);
	void OnRep_RightArmMaxHealth(const struct FGameplayAttributeData& OldValue);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzMultiPartAttributeSet">();
	}
	static class UGzMultiPartAttributeSet* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzMultiPartAttributeSet>();
	}
};
static_assert(alignof(UGzMultiPartAttributeSet) == 0x000008, "Wrong alignment on UGzMultiPartAttributeSet");
static_assert(sizeof(UGzMultiPartAttributeSet) == 0x000228, "Wrong size on UGzMultiPartAttributeSet");
static_assert(offsetof(UGzMultiPartAttributeSet, LeftArmHealth) == 0x0000B8, "Member 'UGzMultiPartAttributeSet::LeftArmHealth' has a wrong offset!");
static_assert(offsetof(UGzMultiPartAttributeSet, LeftArmMaxHealth) == 0x0000C8, "Member 'UGzMultiPartAttributeSet::LeftArmMaxHealth' has a wrong offset!");
static_assert(offsetof(UGzMultiPartAttributeSet, LeftArmHealing) == 0x0000D8, "Member 'UGzMultiPartAttributeSet::LeftArmHealing' has a wrong offset!");
static_assert(offsetof(UGzMultiPartAttributeSet, LeftArmDamage) == 0x0000E8, "Member 'UGzMultiPartAttributeSet::LeftArmDamage' has a wrong offset!");
static_assert(offsetof(UGzMultiPartAttributeSet, LeftArmAbilityCharges) == 0x0000F8, "Member 'UGzMultiPartAttributeSet::LeftArmAbilityCharges' has a wrong offset!");
static_assert(offsetof(UGzMultiPartAttributeSet, LeftArmMaxAbilityCharges) == 0x000108, "Member 'UGzMultiPartAttributeSet::LeftArmMaxAbilityCharges' has a wrong offset!");
static_assert(offsetof(UGzMultiPartAttributeSet, RightArmHealth) == 0x000118, "Member 'UGzMultiPartAttributeSet::RightArmHealth' has a wrong offset!");
static_assert(offsetof(UGzMultiPartAttributeSet, RightArmMaxHealth) == 0x000128, "Member 'UGzMultiPartAttributeSet::RightArmMaxHealth' has a wrong offset!");
static_assert(offsetof(UGzMultiPartAttributeSet, RightArmHealing) == 0x000138, "Member 'UGzMultiPartAttributeSet::RightArmHealing' has a wrong offset!");
static_assert(offsetof(UGzMultiPartAttributeSet, RightArmDamage) == 0x000148, "Member 'UGzMultiPartAttributeSet::RightArmDamage' has a wrong offset!");
static_assert(offsetof(UGzMultiPartAttributeSet, RightArmAbilityCharges) == 0x000158, "Member 'UGzMultiPartAttributeSet::RightArmAbilityCharges' has a wrong offset!");
static_assert(offsetof(UGzMultiPartAttributeSet, RightArmMaxAbilityCharges) == 0x000168, "Member 'UGzMultiPartAttributeSet::RightArmMaxAbilityCharges' has a wrong offset!");
static_assert(offsetof(UGzMultiPartAttributeSet, LegsHealth) == 0x000178, "Member 'UGzMultiPartAttributeSet::LegsHealth' has a wrong offset!");
static_assert(offsetof(UGzMultiPartAttributeSet, LegsMaxHealth) == 0x000188, "Member 'UGzMultiPartAttributeSet::LegsMaxHealth' has a wrong offset!");
static_assert(offsetof(UGzMultiPartAttributeSet, LegsHealing) == 0x000198, "Member 'UGzMultiPartAttributeSet::LegsHealing' has a wrong offset!");
static_assert(offsetof(UGzMultiPartAttributeSet, LegsDamage) == 0x0001A8, "Member 'UGzMultiPartAttributeSet::LegsDamage' has a wrong offset!");
static_assert(offsetof(UGzMultiPartAttributeSet, LegsAbilityCharges) == 0x0001B8, "Member 'UGzMultiPartAttributeSet::LegsAbilityCharges' has a wrong offset!");
static_assert(offsetof(UGzMultiPartAttributeSet, LegsMaxAbilityCharges) == 0x0001C8, "Member 'UGzMultiPartAttributeSet::LegsMaxAbilityCharges' has a wrong offset!");
static_assert(offsetof(UGzMultiPartAttributeSet, AbilityRechargeMultiplier) == 0x0001D8, "Member 'UGzMultiPartAttributeSet::AbilityRechargeMultiplier' has a wrong offset!");
static_assert(offsetof(UGzMultiPartAttributeSet, JetpackHealth) == 0x0001E8, "Member 'UGzMultiPartAttributeSet::JetpackHealth' has a wrong offset!");
static_assert(offsetof(UGzMultiPartAttributeSet, JetpackMaxHealth) == 0x0001F8, "Member 'UGzMultiPartAttributeSet::JetpackMaxHealth' has a wrong offset!");
static_assert(offsetof(UGzMultiPartAttributeSet, JetpackHealing) == 0x000208, "Member 'UGzMultiPartAttributeSet::JetpackHealing' has a wrong offset!");
static_assert(offsetof(UGzMultiPartAttributeSet, JetpackDamage) == 0x000218, "Member 'UGzMultiPartAttributeSet::JetpackDamage' has a wrong offset!");

// Class G01.GzGA_Throw
// 0x00B8 (0x05C0 - 0x0508)
class UGzGA_Throw : public UGzGameplayAbility
{
public:
	FMulticastInlineDelegateProperty_             OnStartCookingGrenade;                             // 0x0508(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnGrenadeLaunched;                                 // 0x0518(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	class UInputAction*                           AttackInputAction;                                 // 0x0528(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FGameplayTag                           ThrowableType;                                     // 0x0530(0x0008)(Edit, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class AGzThrowPathActor>          ThrowPathActorClass;                               // 0x0538(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         TargetThrowDistance;                               // 0x0540(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ThrowCurveAddedAngle;                              // 0x0544(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MaxThrowAngle;                                     // 0x0548(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   ProjectileAttachSocket;                            // 0x054C(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2E5A[0x4];                                     // 0x0554(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FGzThrowAnimationData>          AnimMontagesPerSituation;                          // 0x0558(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	class UGzThrowableItemData*                   ThrowableItemData;                                 // 0x0568(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FGzThrowAnimationData                  ThrowMontageAnim;                                  // 0x0570(0x0020)(Transient, NoDestructor, Protected, NativeAccessSpecifierProtected)
	class AGzProjectileBase*                      ProjectileActor;                                   // 0x0590(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class AGzThrowPathActor*                      ThrowPathActor;                                    // 0x0598(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UGzAT_PlayMontageAndWaitForEvent*       ThrowMontageTask;                                  // 0x05A0(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UGzAT_ServerWaitForTargetData*          ServerWaitForTargetData;                           // 0x05A8(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2E5B[0x10];                                    // 0x05B0(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void BP_BindEventOnGrenadeLaunched(TDelegate<void()> Event);
	void BP_BindEventOnStartCookingGrenade(TDelegate<void(float GrenadeTime)> Event);
	void BP_RemoveEventOnGrenadeLaunched(TDelegate<void()> Event);
	void BP_RemoveEventOnStartCookingGrenade(TDelegate<void(float GrenadeTime)> Event);
	void CancelThrow(class AActor* Actor);
	void OnAbilityInputPressedAgain(float TimeHeld);
	void OnAttackInputPressed(float TimeHeld);
	void OnMontageEnded();
	void OnStartThrow(float TimeHeld);
	void OnThrowAnimationNotification(class FName NotifyName);
	void ServerHandleClientTargetData(const struct FGameplayAbilityTargetDataHandle& TargetData);

	const class UGzThrowableItemData* GetThrowableItemData() const;
	const class AGzProjectileBase* GetThrowableProjectile() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzGA_Throw">();
	}
	static class UGzGA_Throw* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzGA_Throw>();
	}
};
static_assert(alignof(UGzGA_Throw) == 0x000008, "Wrong alignment on UGzGA_Throw");
static_assert(sizeof(UGzGA_Throw) == 0x0005C0, "Wrong size on UGzGA_Throw");
static_assert(offsetof(UGzGA_Throw, OnStartCookingGrenade) == 0x000508, "Member 'UGzGA_Throw::OnStartCookingGrenade' has a wrong offset!");
static_assert(offsetof(UGzGA_Throw, OnGrenadeLaunched) == 0x000518, "Member 'UGzGA_Throw::OnGrenadeLaunched' has a wrong offset!");
static_assert(offsetof(UGzGA_Throw, AttackInputAction) == 0x000528, "Member 'UGzGA_Throw::AttackInputAction' has a wrong offset!");
static_assert(offsetof(UGzGA_Throw, ThrowableType) == 0x000530, "Member 'UGzGA_Throw::ThrowableType' has a wrong offset!");
static_assert(offsetof(UGzGA_Throw, ThrowPathActorClass) == 0x000538, "Member 'UGzGA_Throw::ThrowPathActorClass' has a wrong offset!");
static_assert(offsetof(UGzGA_Throw, TargetThrowDistance) == 0x000540, "Member 'UGzGA_Throw::TargetThrowDistance' has a wrong offset!");
static_assert(offsetof(UGzGA_Throw, ThrowCurveAddedAngle) == 0x000544, "Member 'UGzGA_Throw::ThrowCurveAddedAngle' has a wrong offset!");
static_assert(offsetof(UGzGA_Throw, MaxThrowAngle) == 0x000548, "Member 'UGzGA_Throw::MaxThrowAngle' has a wrong offset!");
static_assert(offsetof(UGzGA_Throw, ProjectileAttachSocket) == 0x00054C, "Member 'UGzGA_Throw::ProjectileAttachSocket' has a wrong offset!");
static_assert(offsetof(UGzGA_Throw, AnimMontagesPerSituation) == 0x000558, "Member 'UGzGA_Throw::AnimMontagesPerSituation' has a wrong offset!");
static_assert(offsetof(UGzGA_Throw, ThrowableItemData) == 0x000568, "Member 'UGzGA_Throw::ThrowableItemData' has a wrong offset!");
static_assert(offsetof(UGzGA_Throw, ThrowMontageAnim) == 0x000570, "Member 'UGzGA_Throw::ThrowMontageAnim' has a wrong offset!");
static_assert(offsetof(UGzGA_Throw, ProjectileActor) == 0x000590, "Member 'UGzGA_Throw::ProjectileActor' has a wrong offset!");
static_assert(offsetof(UGzGA_Throw, ThrowPathActor) == 0x000598, "Member 'UGzGA_Throw::ThrowPathActor' has a wrong offset!");
static_assert(offsetof(UGzGA_Throw, ThrowMontageTask) == 0x0005A0, "Member 'UGzGA_Throw::ThrowMontageTask' has a wrong offset!");
static_assert(offsetof(UGzGA_Throw, ServerWaitForTargetData) == 0x0005A8, "Member 'UGzGA_Throw::ServerWaitForTargetData' has a wrong offset!");

// Class G01.GzAttributeSet
// 0x00D0 (0x02F8 - 0x0228)
class UGzAttributeSet final : public UGzMultiPartAttributeSet
{
public:
	struct FGameplayAttributeData                 Armor;                                             // 0x0228(0x0010)(BlueprintVisible, BlueprintReadOnly, Net, RepNotify, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 MaxArmor;                                          // 0x0238(0x0010)(BlueprintVisible, BlueprintReadOnly, Net, RepNotify, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 GridArmor;                                         // 0x0248(0x0010)(BlueprintVisible, BlueprintReadOnly, Net, RepNotify, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 MovementSpeed;                                     // 0x0258(0x0010)(BlueprintVisible, BlueprintReadOnly, Net, RepNotify, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 SprintCoef;                                        // 0x0268(0x0010)(BlueprintVisible, BlueprintReadOnly, Net, RepNotify, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 WalkCoef;                                          // 0x0278(0x0010)(BlueprintVisible, BlueprintReadOnly, Net, RepNotify, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 RunCoef;                                           // 0x0288(0x0010)(BlueprintVisible, BlueprintReadOnly, Net, RepNotify, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 AirFrictionCoef;                                   // 0x0298(0x0010)(BlueprintVisible, BlueprintReadOnly, Net, RepNotify, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 CrouchCoef;                                        // 0x02A8(0x0010)(BlueprintVisible, BlueprintReadOnly, Net, RepNotify, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 JumpVelocity;                                      // 0x02B8(0x0010)(BlueprintVisible, BlueprintReadOnly, Net, RepNotify, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 MantleSpeed;                                       // 0x02C8(0x0010)(BlueprintVisible, BlueprintReadOnly, Net, RepNotify, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 ClimbSpeed;                                        // 0x02D8(0x0010)(BlueprintVisible, BlueprintReadOnly, Net, RepNotify, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 MantleAndClimbHeight;                              // 0x02E8(0x0010)(BlueprintVisible, BlueprintReadOnly, Net, RepNotify, NativeAccessSpecifierPublic)

public:
	void OnRep_AirFrictionCoef(const struct FGameplayAttributeData& OldAirFrictionCoef);
	void OnRep_Armor(const struct FGameplayAttributeData& OldArmor);
	void OnRep_ClimbSpeed(const struct FGameplayAttributeData& OldClimbSpeed);
	void OnRep_CrouchCoef(const struct FGameplayAttributeData& OldCrouchCoef);
	void OnRep_GridArmor(const struct FGameplayAttributeData& OldGridArmor);
	void OnRep_JumpVelocity(const struct FGameplayAttributeData& OldJumpVelocity);
	void OnRep_MantleAndClimbHeight(const struct FGameplayAttributeData& OldMantleAndClimbHeight);
	void OnRep_MantleSpeed(const struct FGameplayAttributeData& OldMantleSpeed);
	void OnRep_MaxArmor(const struct FGameplayAttributeData& OldMaxArmor);
	void OnRep_MovementSpeed(const struct FGameplayAttributeData& OldMovementSpeed);
	void OnRep_RunCoef(const struct FGameplayAttributeData& OldRunCoef);
	void OnRep_SprintCoef(const struct FGameplayAttributeData& OldSprintCoef);
	void OnRep_WalkCoef(const struct FGameplayAttributeData& OldWalkCoef);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzAttributeSet">();
	}
	static class UGzAttributeSet* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzAttributeSet>();
	}
};
static_assert(alignof(UGzAttributeSet) == 0x000008, "Wrong alignment on UGzAttributeSet");
static_assert(sizeof(UGzAttributeSet) == 0x0002F8, "Wrong size on UGzAttributeSet");
static_assert(offsetof(UGzAttributeSet, Armor) == 0x000228, "Member 'UGzAttributeSet::Armor' has a wrong offset!");
static_assert(offsetof(UGzAttributeSet, MaxArmor) == 0x000238, "Member 'UGzAttributeSet::MaxArmor' has a wrong offset!");
static_assert(offsetof(UGzAttributeSet, GridArmor) == 0x000248, "Member 'UGzAttributeSet::GridArmor' has a wrong offset!");
static_assert(offsetof(UGzAttributeSet, MovementSpeed) == 0x000258, "Member 'UGzAttributeSet::MovementSpeed' has a wrong offset!");
static_assert(offsetof(UGzAttributeSet, SprintCoef) == 0x000268, "Member 'UGzAttributeSet::SprintCoef' has a wrong offset!");
static_assert(offsetof(UGzAttributeSet, WalkCoef) == 0x000278, "Member 'UGzAttributeSet::WalkCoef' has a wrong offset!");
static_assert(offsetof(UGzAttributeSet, RunCoef) == 0x000288, "Member 'UGzAttributeSet::RunCoef' has a wrong offset!");
static_assert(offsetof(UGzAttributeSet, AirFrictionCoef) == 0x000298, "Member 'UGzAttributeSet::AirFrictionCoef' has a wrong offset!");
static_assert(offsetof(UGzAttributeSet, CrouchCoef) == 0x0002A8, "Member 'UGzAttributeSet::CrouchCoef' has a wrong offset!");
static_assert(offsetof(UGzAttributeSet, JumpVelocity) == 0x0002B8, "Member 'UGzAttributeSet::JumpVelocity' has a wrong offset!");
static_assert(offsetof(UGzAttributeSet, MantleSpeed) == 0x0002C8, "Member 'UGzAttributeSet::MantleSpeed' has a wrong offset!");
static_assert(offsetof(UGzAttributeSet, ClimbSpeed) == 0x0002D8, "Member 'UGzAttributeSet::ClimbSpeed' has a wrong offset!");
static_assert(offsetof(UGzAttributeSet, MantleAndClimbHeight) == 0x0002E8, "Member 'UGzAttributeSet::MantleAndClimbHeight' has a wrong offset!");

// Class G01.GzAT_AbilityTick
// 0x0028 (0x00A8 - 0x0080)
class UGzAT_AbilityTick final : public UAbilityTask
{
public:
	FMulticastInlineDelegateProperty_             OnTick;                                            // 0x0080(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnEnded;                                           // 0x0090(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	float                                         TaskDeltaTime;                                     // 0x00A0(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         Duration;                                          // 0x00A4(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UGzAT_AbilityTick* AbilityTick(class UGameplayAbility* OwningAbility, float Param_Duration);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzAT_AbilityTick">();
	}
	static class UGzAT_AbilityTick* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzAT_AbilityTick>();
	}
};
static_assert(alignof(UGzAT_AbilityTick) == 0x000008, "Wrong alignment on UGzAT_AbilityTick");
static_assert(sizeof(UGzAT_AbilityTick) == 0x0000A8, "Wrong size on UGzAT_AbilityTick");
static_assert(offsetof(UGzAT_AbilityTick, OnTick) == 0x000080, "Member 'UGzAT_AbilityTick::OnTick' has a wrong offset!");
static_assert(offsetof(UGzAT_AbilityTick, OnEnded) == 0x000090, "Member 'UGzAT_AbilityTick::OnEnded' has a wrong offset!");
static_assert(offsetof(UGzAT_AbilityTick, TaskDeltaTime) == 0x0000A0, "Member 'UGzAT_AbilityTick::TaskDeltaTime' has a wrong offset!");
static_assert(offsetof(UGzAT_AbilityTick, Duration) == 0x0000A4, "Member 'UGzAT_AbilityTick::Duration' has a wrong offset!");

// Class G01.GzXR_BaseEvent
// 0x0030 (0x0058 - 0x0028)
class UGzXR_BaseEvent : public UObject
{
public:
	float                                         Duration;                                          // 0x0028(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FFloatRange                            DelayRange;                                        // 0x002C(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2E5D[0x4];                                     // 0x003C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UGzXR_BaseStage*                        OwningStage;                                       // 0x0040(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2E5E[0x10];                                    // 0x0048(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzXR_BaseEvent">();
	}
	static class UGzXR_BaseEvent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzXR_BaseEvent>();
	}
};
static_assert(alignof(UGzXR_BaseEvent) == 0x000008, "Wrong alignment on UGzXR_BaseEvent");
static_assert(sizeof(UGzXR_BaseEvent) == 0x000058, "Wrong size on UGzXR_BaseEvent");
static_assert(offsetof(UGzXR_BaseEvent, Duration) == 0x000028, "Member 'UGzXR_BaseEvent::Duration' has a wrong offset!");
static_assert(offsetof(UGzXR_BaseEvent, DelayRange) == 0x00002C, "Member 'UGzXR_BaseEvent::DelayRange' has a wrong offset!");
static_assert(offsetof(UGzXR_BaseEvent, OwningStage) == 0x000040, "Member 'UGzXR_BaseEvent::OwningStage' has a wrong offset!");

// Class G01.GzInputSettings
// 0x0020 (0x0058 - 0x0038)
class UGzInputSettings final : public UDeveloperSettings
{
public:
	float                                         InputPitchScale;                                   // 0x0038(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InputYawScale;                                     // 0x003C(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AimingInputScale;                                  // 0x0040(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SniperScopeInputScale;                             // 0x0044(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FKey>                           UnbindableKeys;                                    // 0x0048(0x0010)(Edit, ZeroConstructor, Config, DisableEditOnInstance, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzInputSettings">();
	}
	static class UGzInputSettings* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzInputSettings>();
	}
};
static_assert(alignof(UGzInputSettings) == 0x000008, "Wrong alignment on UGzInputSettings");
static_assert(sizeof(UGzInputSettings) == 0x000058, "Wrong size on UGzInputSettings");
static_assert(offsetof(UGzInputSettings, InputPitchScale) == 0x000038, "Member 'UGzInputSettings::InputPitchScale' has a wrong offset!");
static_assert(offsetof(UGzInputSettings, InputYawScale) == 0x00003C, "Member 'UGzInputSettings::InputYawScale' has a wrong offset!");
static_assert(offsetof(UGzInputSettings, AimingInputScale) == 0x000040, "Member 'UGzInputSettings::AimingInputScale' has a wrong offset!");
static_assert(offsetof(UGzInputSettings, SniperScopeInputScale) == 0x000044, "Member 'UGzInputSettings::SniperScopeInputScale' has a wrong offset!");
static_assert(offsetof(UGzInputSettings, UnbindableKeys) == 0x000048, "Member 'UGzInputSettings::UnbindableKeys' has a wrong offset!");

// Class G01.GzAT_ApplyRootMotionDash
// 0x00B0 (0x0180 - 0x00D0)
class UGzAT_ApplyRootMotionDash final : public UAbilityTask_ApplyRootMotion_Base
{
public:
	FMulticastInlineDelegateProperty_             OnFinished;                                        // 0x00D0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnDistanceTriggerReached;                          // 0x00E0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnHitEvent;                                        // 0x00F0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnHitCharacterEvent;                               // 0x0100(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	struct FVector                                StartLocation;                                     // 0x0110(0x0018)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                InitialTargetLocation;                             // 0x0128(0x0018)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                TargetLocation;                                    // 0x0140(0x0018)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         DistanceTriggerDistance;                           // 0x0158(0x0004)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         Duration;                                          // 0x015C(0x0004)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class AActor*                                 TargetActor;                                       // 0x0160(0x0008)(Net, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ReachedDestinationDistance;                        // 0x0168(0x0004)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2E5F[0x4];                                     // 0x016C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UGzDashParamsData*                      DashParams;                                        // 0x0170(0x0008)(Net, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2E60[0x8];                                     // 0x0178(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UGzAT_ApplyRootMotionDash* ApplyRootMotionDash(class UGameplayAbility* OwningAbility, class FName TaskInstanceName, const class AActor* Param_TargetActor, const class UGzDashParamsData* Param_DashParams, const struct FVector& Param_InitialTargetLocation, float Param_DistanceTriggerDistance, const bool bResetVelocityAtEnd, float Param_ReachedDestinationDistance);

	void OnAvatarActorHitEvent(class AActor* SelfActor, class AActor* OtherActor, const struct FVector& NormalImpulse, const struct FHitResult& Hit);
	void OnRep_TargetLocation();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzAT_ApplyRootMotionDash">();
	}
	static class UGzAT_ApplyRootMotionDash* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzAT_ApplyRootMotionDash>();
	}
};
static_assert(alignof(UGzAT_ApplyRootMotionDash) == 0x000008, "Wrong alignment on UGzAT_ApplyRootMotionDash");
static_assert(sizeof(UGzAT_ApplyRootMotionDash) == 0x000180, "Wrong size on UGzAT_ApplyRootMotionDash");
static_assert(offsetof(UGzAT_ApplyRootMotionDash, OnFinished) == 0x0000D0, "Member 'UGzAT_ApplyRootMotionDash::OnFinished' has a wrong offset!");
static_assert(offsetof(UGzAT_ApplyRootMotionDash, OnDistanceTriggerReached) == 0x0000E0, "Member 'UGzAT_ApplyRootMotionDash::OnDistanceTriggerReached' has a wrong offset!");
static_assert(offsetof(UGzAT_ApplyRootMotionDash, OnHitEvent) == 0x0000F0, "Member 'UGzAT_ApplyRootMotionDash::OnHitEvent' has a wrong offset!");
static_assert(offsetof(UGzAT_ApplyRootMotionDash, OnHitCharacterEvent) == 0x000100, "Member 'UGzAT_ApplyRootMotionDash::OnHitCharacterEvent' has a wrong offset!");
static_assert(offsetof(UGzAT_ApplyRootMotionDash, StartLocation) == 0x000110, "Member 'UGzAT_ApplyRootMotionDash::StartLocation' has a wrong offset!");
static_assert(offsetof(UGzAT_ApplyRootMotionDash, InitialTargetLocation) == 0x000128, "Member 'UGzAT_ApplyRootMotionDash::InitialTargetLocation' has a wrong offset!");
static_assert(offsetof(UGzAT_ApplyRootMotionDash, TargetLocation) == 0x000140, "Member 'UGzAT_ApplyRootMotionDash::TargetLocation' has a wrong offset!");
static_assert(offsetof(UGzAT_ApplyRootMotionDash, DistanceTriggerDistance) == 0x000158, "Member 'UGzAT_ApplyRootMotionDash::DistanceTriggerDistance' has a wrong offset!");
static_assert(offsetof(UGzAT_ApplyRootMotionDash, Duration) == 0x00015C, "Member 'UGzAT_ApplyRootMotionDash::Duration' has a wrong offset!");
static_assert(offsetof(UGzAT_ApplyRootMotionDash, TargetActor) == 0x000160, "Member 'UGzAT_ApplyRootMotionDash::TargetActor' has a wrong offset!");
static_assert(offsetof(UGzAT_ApplyRootMotionDash, ReachedDestinationDistance) == 0x000168, "Member 'UGzAT_ApplyRootMotionDash::ReachedDestinationDistance' has a wrong offset!");
static_assert(offsetof(UGzAT_ApplyRootMotionDash, DashParams) == 0x000170, "Member 'UGzAT_ApplyRootMotionDash::DashParams' has a wrong offset!");

// Class G01.GzCustomizationModifierTemplate_MaterialTexture
// 0x0018 (0x00E8 - 0x00D0)
class UGzCustomizationModifierTemplate_MaterialTexture final : public UGzCustomizationModifierTemplate_MaterialParam
{
public:
	TArray<TSoftObjectPtr<class UTexture>>        ValueRange;                                        // 0x00D0(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, UObjectWrapper, NativeAccessSpecifierPublic)
	uint8                                         DefaultValue;                                      // 0x00E0(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2E63[0x7];                                     // 0x00E1(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzCustomizationModifierTemplate_MaterialTexture">();
	}
	static class UGzCustomizationModifierTemplate_MaterialTexture* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzCustomizationModifierTemplate_MaterialTexture>();
	}
};
static_assert(alignof(UGzCustomizationModifierTemplate_MaterialTexture) == 0x000008, "Wrong alignment on UGzCustomizationModifierTemplate_MaterialTexture");
static_assert(sizeof(UGzCustomizationModifierTemplate_MaterialTexture) == 0x0000E8, "Wrong size on UGzCustomizationModifierTemplate_MaterialTexture");
static_assert(offsetof(UGzCustomizationModifierTemplate_MaterialTexture, ValueRange) == 0x0000D0, "Member 'UGzCustomizationModifierTemplate_MaterialTexture::ValueRange' has a wrong offset!");
static_assert(offsetof(UGzCustomizationModifierTemplate_MaterialTexture, DefaultValue) == 0x0000E0, "Member 'UGzCustomizationModifierTemplate_MaterialTexture::DefaultValue' has a wrong offset!");

// Class G01.GzSquadPanel
// 0x0018 (0x02F8 - 0x02E0)
class UGzSquadPanel : public UUserWidget
{
public:
	class AGzPlayerState*                         ViewTargetPlayerState;                             // 0x02E0(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class AGzTeam*                                ViewTargetTeam;                                    // 0x02E8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bSyncVoiceChatState;                               // 0x02F0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2E64[0x7];                                     // 0x02F1(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Init(class AGzPlayerState* InViewTargetPlayerState);
	void OnPlayerChangeTeam(class AGzPlayerState* PlayerState);
	void OnTeammatesUpdated(const TArray<struct FGzTeamMember>& TeamMembers);
	void TryBindOnTeamChanged();
	void UpdateTeamEntries();

	TArray<struct FGzTeamMember> GetViewTargetTeamMembers() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzSquadPanel">();
	}
	static class UGzSquadPanel* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzSquadPanel>();
	}
};
static_assert(alignof(UGzSquadPanel) == 0x000008, "Wrong alignment on UGzSquadPanel");
static_assert(sizeof(UGzSquadPanel) == 0x0002F8, "Wrong size on UGzSquadPanel");
static_assert(offsetof(UGzSquadPanel, ViewTargetPlayerState) == 0x0002E0, "Member 'UGzSquadPanel::ViewTargetPlayerState' has a wrong offset!");
static_assert(offsetof(UGzSquadPanel, ViewTargetTeam) == 0x0002E8, "Member 'UGzSquadPanel::ViewTargetTeam' has a wrong offset!");
static_assert(offsetof(UGzSquadPanel, bSyncVoiceChatState) == 0x0002F0, "Member 'UGzSquadPanel::bSyncVoiceChatState' has a wrong offset!");

// Class G01.GzAT_ApplyRootMotionInteractable
// 0x0148 (0x0218 - 0x00D0)
class UGzAT_ApplyRootMotionInteractable final : public UAbilityTask_ApplyRootMotion_Base
{
public:
	uint8                                         Pad_2E65[0x40];                                    // 0x00D0(0x0040)(Fixing Size After Last Property [ Dumper-7 ])
	class UGzInteractableTransitionSettings*      InteractableTransitionSettings;                    // 0x0110(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UGzInteractableComponent*               InteractableComponent;                             // 0x0118(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2E66[0xF8];                                    // 0x0120(0x00F8)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UGzAT_ApplyRootMotionInteractable* ApplyRootMotionInteractable(class UGameplayAbility* OwningAbility, const class UGzInteractableComponent* Param_InteractableComponent, const class UGzInteractableTransitionSettings* Param_InteractableTransitionSettings, const struct FGzInteractionData& InInteractionData);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzAT_ApplyRootMotionInteractable">();
	}
	static class UGzAT_ApplyRootMotionInteractable* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzAT_ApplyRootMotionInteractable>();
	}
};
static_assert(alignof(UGzAT_ApplyRootMotionInteractable) == 0x000008, "Wrong alignment on UGzAT_ApplyRootMotionInteractable");
static_assert(sizeof(UGzAT_ApplyRootMotionInteractable) == 0x000218, "Wrong size on UGzAT_ApplyRootMotionInteractable");
static_assert(offsetof(UGzAT_ApplyRootMotionInteractable, InteractableTransitionSettings) == 0x000110, "Member 'UGzAT_ApplyRootMotionInteractable::InteractableTransitionSettings' has a wrong offset!");
static_assert(offsetof(UGzAT_ApplyRootMotionInteractable, InteractableComponent) == 0x000118, "Member 'UGzAT_ApplyRootMotionInteractable::InteractableComponent' has a wrong offset!");

// Class G01.GzBodyPartData
// 0x0040 (0x0070 - 0x0030)
class UGzBodyPartData : public UDataAsset
{
public:
	float                                         MaxHealth;                                         // 0x0030(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGzDamageAreaInfo                      DamageAreaInfo;                                    // 0x0034(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	TArray<struct FGameplayModifierInfo>          CharacterAttributeModifiers;                       // 0x0040(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	class FName                                   BoneName;                                          // 0x0050(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   BoneName_Right;                                    // 0x0058(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCurveFloat*                            SprintSpeedCurve;                                  // 0x0060(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SprintGraceTime;                                   // 0x0068(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsDetachable;                                     // 0x006C(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EGzLimbType                                   Type;                                              // 0x006D(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2E67[0x2];                                     // 0x006E(0x0002)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzBodyPartData">();
	}
	static class UGzBodyPartData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzBodyPartData>();
	}
};
static_assert(alignof(UGzBodyPartData) == 0x000008, "Wrong alignment on UGzBodyPartData");
static_assert(sizeof(UGzBodyPartData) == 0x000070, "Wrong size on UGzBodyPartData");
static_assert(offsetof(UGzBodyPartData, MaxHealth) == 0x000030, "Member 'UGzBodyPartData::MaxHealth' has a wrong offset!");
static_assert(offsetof(UGzBodyPartData, DamageAreaInfo) == 0x000034, "Member 'UGzBodyPartData::DamageAreaInfo' has a wrong offset!");
static_assert(offsetof(UGzBodyPartData, CharacterAttributeModifiers) == 0x000040, "Member 'UGzBodyPartData::CharacterAttributeModifiers' has a wrong offset!");
static_assert(offsetof(UGzBodyPartData, BoneName) == 0x000050, "Member 'UGzBodyPartData::BoneName' has a wrong offset!");
static_assert(offsetof(UGzBodyPartData, BoneName_Right) == 0x000058, "Member 'UGzBodyPartData::BoneName_Right' has a wrong offset!");
static_assert(offsetof(UGzBodyPartData, SprintSpeedCurve) == 0x000060, "Member 'UGzBodyPartData::SprintSpeedCurve' has a wrong offset!");
static_assert(offsetof(UGzBodyPartData, SprintGraceTime) == 0x000068, "Member 'UGzBodyPartData::SprintGraceTime' has a wrong offset!");
static_assert(offsetof(UGzBodyPartData, bIsDetachable) == 0x00006C, "Member 'UGzBodyPartData::bIsDetachable' has a wrong offset!");
static_assert(offsetof(UGzBodyPartData, Type) == 0x00006D, "Member 'UGzBodyPartData::Type' has a wrong offset!");

// Class G01.GzBodyPartAbilityData
// 0x0010 (0x0080 - 0x0070)
class UGzBodyPartAbilityData : public UGzBodyPartData
{
public:
	int32                                         MaxCharges;                                        // 0x0070(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RechargeDurationPerCharge;                         // 0x0074(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bOnlyRechargeWhenEmpty;                            // 0x0078(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsPercentage;                                     // 0x0079(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bHasSecondaryCharges;                              // 0x007A(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2E68[0x1];                                     // 0x007B(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         MaxSecondaryCharges;                               // 0x007C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	struct FGameplayTag GetRechargeTypeTag() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzBodyPartAbilityData">();
	}
	static class UGzBodyPartAbilityData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzBodyPartAbilityData>();
	}
};
static_assert(alignof(UGzBodyPartAbilityData) == 0x000008, "Wrong alignment on UGzBodyPartAbilityData");
static_assert(sizeof(UGzBodyPartAbilityData) == 0x000080, "Wrong size on UGzBodyPartAbilityData");
static_assert(offsetof(UGzBodyPartAbilityData, MaxCharges) == 0x000070, "Member 'UGzBodyPartAbilityData::MaxCharges' has a wrong offset!");
static_assert(offsetof(UGzBodyPartAbilityData, RechargeDurationPerCharge) == 0x000074, "Member 'UGzBodyPartAbilityData::RechargeDurationPerCharge' has a wrong offset!");
static_assert(offsetof(UGzBodyPartAbilityData, bOnlyRechargeWhenEmpty) == 0x000078, "Member 'UGzBodyPartAbilityData::bOnlyRechargeWhenEmpty' has a wrong offset!");
static_assert(offsetof(UGzBodyPartAbilityData, bIsPercentage) == 0x000079, "Member 'UGzBodyPartAbilityData::bIsPercentage' has a wrong offset!");
static_assert(offsetof(UGzBodyPartAbilityData, bHasSecondaryCharges) == 0x00007A, "Member 'UGzBodyPartAbilityData::bHasSecondaryCharges' has a wrong offset!");
static_assert(offsetof(UGzBodyPartAbilityData, MaxSecondaryCharges) == 0x00007C, "Member 'UGzBodyPartAbilityData::MaxSecondaryCharges' has a wrong offset!");

// Class G01.GzBodyPartAbilityData_Tether
// 0x0018 (0x0098 - 0x0080)
class UGzBodyPartAbilityData_Tether final : public UGzBodyPartAbilityData
{
public:
	int32                                         MaxTetherAmount;                                   // 0x0080(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxPlacementDistance;                              // 0x0084(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinLinkLength;                                     // 0x0088(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxLinkLength;                                     // 0x008C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Damage;                                            // 0x0090(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SlowPercentage;                                    // 0x0094(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzBodyPartAbilityData_Tether">();
	}
	static class UGzBodyPartAbilityData_Tether* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzBodyPartAbilityData_Tether>();
	}
};
static_assert(alignof(UGzBodyPartAbilityData_Tether) == 0x000008, "Wrong alignment on UGzBodyPartAbilityData_Tether");
static_assert(sizeof(UGzBodyPartAbilityData_Tether) == 0x000098, "Wrong size on UGzBodyPartAbilityData_Tether");
static_assert(offsetof(UGzBodyPartAbilityData_Tether, MaxTetherAmount) == 0x000080, "Member 'UGzBodyPartAbilityData_Tether::MaxTetherAmount' has a wrong offset!");
static_assert(offsetof(UGzBodyPartAbilityData_Tether, MaxPlacementDistance) == 0x000084, "Member 'UGzBodyPartAbilityData_Tether::MaxPlacementDistance' has a wrong offset!");
static_assert(offsetof(UGzBodyPartAbilityData_Tether, MinLinkLength) == 0x000088, "Member 'UGzBodyPartAbilityData_Tether::MinLinkLength' has a wrong offset!");
static_assert(offsetof(UGzBodyPartAbilityData_Tether, MaxLinkLength) == 0x00008C, "Member 'UGzBodyPartAbilityData_Tether::MaxLinkLength' has a wrong offset!");
static_assert(offsetof(UGzBodyPartAbilityData_Tether, Damage) == 0x000090, "Member 'UGzBodyPartAbilityData_Tether::Damage' has a wrong offset!");
static_assert(offsetof(UGzBodyPartAbilityData_Tether, SlowPercentage) == 0x000094, "Member 'UGzBodyPartAbilityData_Tether::SlowPercentage' has a wrong offset!");

// Class G01.GzAT_ApplyRootMotionZipline
// 0x0040 (0x0110 - 0x00D0)
class UGzAT_ApplyRootMotionZipline final : public UAbilityTask_ApplyRootMotion_Base
{
public:
	class UGzZiplineMovementSettings*             ZiplineSettings;                                   // 0x00D0(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class AGzZipline*                             Zipline;                                           // 0x00D8(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2E69[0x30];                                    // 0x00E0(0x0030)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UGzAT_ApplyRootMotionZipline* ApplyRootMotionZipline(class UGameplayAbility* OwningAbility, class AGzZipline* Param_Zipline, class UGzZiplineMovementSettings* ZiplineMovementSettings);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzAT_ApplyRootMotionZipline">();
	}
	static class UGzAT_ApplyRootMotionZipline* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzAT_ApplyRootMotionZipline>();
	}
};
static_assert(alignof(UGzAT_ApplyRootMotionZipline) == 0x000008, "Wrong alignment on UGzAT_ApplyRootMotionZipline");
static_assert(sizeof(UGzAT_ApplyRootMotionZipline) == 0x000110, "Wrong size on UGzAT_ApplyRootMotionZipline");
static_assert(offsetof(UGzAT_ApplyRootMotionZipline, ZiplineSettings) == 0x0000D0, "Member 'UGzAT_ApplyRootMotionZipline::ZiplineSettings' has a wrong offset!");
static_assert(offsetof(UGzAT_ApplyRootMotionZipline, Zipline) == 0x0000D8, "Member 'UGzAT_ApplyRootMotionZipline::Zipline' has a wrong offset!");

// Class G01.GzGenericIdMaintainingComponent
// 0x0018 (0x00B8 - 0x00A0)
class UGzGenericIdMaintainingComponent final : public UGzServiceComponent
{
public:
	uint8                                         Pad_2E6A[0x18];                                    // 0x00A0(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzGenericIdMaintainingComponent">();
	}
	static class UGzGenericIdMaintainingComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzGenericIdMaintainingComponent>();
	}
};
static_assert(alignof(UGzGenericIdMaintainingComponent) == 0x000008, "Wrong alignment on UGzGenericIdMaintainingComponent");
static_assert(sizeof(UGzGenericIdMaintainingComponent) == 0x0000B8, "Wrong size on UGzGenericIdMaintainingComponent");

// Class G01.GzAT_ApplyRootMotionZiplineJumpOff
// 0x0090 (0x0160 - 0x00D0)
class alignas(0x10) UGzAT_ApplyRootMotionZiplineJumpOff final : public UAbilityTask_ApplyRootMotion_Base
{
public:
	class UGzZiplineMovementSettings*             ZiplineSettings;                                   // 0x00D0(0x0008)(ZeroConstructor, Transient, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2E6B[0x88];                                    // 0x00D8(0x0088)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UGzAT_ApplyRootMotionZiplineJumpOff* ApplyRootMotionZiplineJumpOff(class UGameplayAbility* OwningAbility, const struct FGzZiplineMovementRuntimeData& ZiplineData, const class UGzZiplineMovementSettings* ZiplineMovementSettings);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzAT_ApplyRootMotionZiplineJumpOff">();
	}
	static class UGzAT_ApplyRootMotionZiplineJumpOff* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzAT_ApplyRootMotionZiplineJumpOff>();
	}
};
static_assert(alignof(UGzAT_ApplyRootMotionZiplineJumpOff) == 0x000010, "Wrong alignment on UGzAT_ApplyRootMotionZiplineJumpOff");
static_assert(sizeof(UGzAT_ApplyRootMotionZiplineJumpOff) == 0x000160, "Wrong size on UGzAT_ApplyRootMotionZiplineJumpOff");
static_assert(offsetof(UGzAT_ApplyRootMotionZiplineJumpOff, ZiplineSettings) == 0x0000D0, "Member 'UGzAT_ApplyRootMotionZiplineJumpOff::ZiplineSettings' has a wrong offset!");

// Class G01.GzMissionObjective_HaveItem
// 0x0018 (0x0200 - 0x01E8)
class UGzMissionObjective_HaveItem final : public UGameplayObjective
{
public:
	class UGzItemData*                            Item;                                              // 0x01E8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2E6C[0x10];                                    // 0x01F0(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzMissionObjective_HaveItem">();
	}
	static class UGzMissionObjective_HaveItem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzMissionObjective_HaveItem>();
	}
};
static_assert(alignof(UGzMissionObjective_HaveItem) == 0x000008, "Wrong alignment on UGzMissionObjective_HaveItem");
static_assert(sizeof(UGzMissionObjective_HaveItem) == 0x000200, "Wrong size on UGzMissionObjective_HaveItem");
static_assert(offsetof(UGzMissionObjective_HaveItem, Item) == 0x0001E8, "Member 'UGzMissionObjective_HaveItem::Item' has a wrong offset!");

// Class G01.GzBodyPartAbilityData_Minigun
// 0x0018 (0x0098 - 0x0080)
class UGzBodyPartAbilityData_Minigun final : public UGzBodyPartAbilityData
{
public:
	int32                                         MaxAmmo;                                           // 0x0080(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bApplyAdditionalCooldownPerBullet;                 // 0x0084(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2E6D[0x3];                                     // 0x0085(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         AdditionalCooldownPerBullet;                       // 0x0088(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bApplyOverheatCooldownModifier;                    // 0x008C(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2E6E[0x3];                                     // 0x008D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         OverheatCooldownModifier;                          // 0x0090(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2E6F[0x4];                                     // 0x0094(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzBodyPartAbilityData_Minigun">();
	}
	static class UGzBodyPartAbilityData_Minigun* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzBodyPartAbilityData_Minigun>();
	}
};
static_assert(alignof(UGzBodyPartAbilityData_Minigun) == 0x000008, "Wrong alignment on UGzBodyPartAbilityData_Minigun");
static_assert(sizeof(UGzBodyPartAbilityData_Minigun) == 0x000098, "Wrong size on UGzBodyPartAbilityData_Minigun");
static_assert(offsetof(UGzBodyPartAbilityData_Minigun, MaxAmmo) == 0x000080, "Member 'UGzBodyPartAbilityData_Minigun::MaxAmmo' has a wrong offset!");
static_assert(offsetof(UGzBodyPartAbilityData_Minigun, bApplyAdditionalCooldownPerBullet) == 0x000084, "Member 'UGzBodyPartAbilityData_Minigun::bApplyAdditionalCooldownPerBullet' has a wrong offset!");
static_assert(offsetof(UGzBodyPartAbilityData_Minigun, AdditionalCooldownPerBullet) == 0x000088, "Member 'UGzBodyPartAbilityData_Minigun::AdditionalCooldownPerBullet' has a wrong offset!");
static_assert(offsetof(UGzBodyPartAbilityData_Minigun, bApplyOverheatCooldownModifier) == 0x00008C, "Member 'UGzBodyPartAbilityData_Minigun::bApplyOverheatCooldownModifier' has a wrong offset!");
static_assert(offsetof(UGzBodyPartAbilityData_Minigun, OverheatCooldownModifier) == 0x000090, "Member 'UGzBodyPartAbilityData_Minigun::OverheatCooldownModifier' has a wrong offset!");

// Class G01.GzAT_ApplySmoothRotation
// 0x0038 (0x00B8 - 0x0080)
class UGzAT_ApplySmoothRotation final : public UAbilityTask
{
public:
	FMulticastInlineDelegateProperty_             OnFinish;                                          // 0x0080(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	class UCurveFloat*                            RotationOverTime;                                  // 0x0090(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2E70[0x20];                                    // 0x0098(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UGzAT_ApplySmoothRotation* ApplySmoothRotation(class UGameplayAbility* OwningAbility, class FName TaskInstanceName, float Duration, class UCurveFloat* Param_RotationOverTime, const struct FRotator& TargetRotation);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzAT_ApplySmoothRotation">();
	}
	static class UGzAT_ApplySmoothRotation* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzAT_ApplySmoothRotation>();
	}
};
static_assert(alignof(UGzAT_ApplySmoothRotation) == 0x000008, "Wrong alignment on UGzAT_ApplySmoothRotation");
static_assert(sizeof(UGzAT_ApplySmoothRotation) == 0x0000B8, "Wrong size on UGzAT_ApplySmoothRotation");
static_assert(offsetof(UGzAT_ApplySmoothRotation, OnFinish) == 0x000080, "Member 'UGzAT_ApplySmoothRotation::OnFinish' has a wrong offset!");
static_assert(offsetof(UGzAT_ApplySmoothRotation, RotationOverTime) == 0x000090, "Member 'UGzAT_ApplySmoothRotation::RotationOverTime' has a wrong offset!");

// Class G01.GzLoadoutListSingleTab
// 0x0000 (0x0468 - 0x0468)
class UGzLoadoutListSingleTab : public UGzLoadoutListBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzLoadoutListSingleTab">();
	}
	static class UGzLoadoutListSingleTab* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzLoadoutListSingleTab>();
	}
};
static_assert(alignof(UGzLoadoutListSingleTab) == 0x000008, "Wrong alignment on UGzLoadoutListSingleTab");
static_assert(sizeof(UGzLoadoutListSingleTab) == 0x000468, "Wrong size on UGzLoadoutListSingleTab");

// Class G01.GzAT_AsyncSweep
// 0x0110 (0x0190 - 0x0080)
class UGzAT_AsyncSweep final : public UAbilityTask
{
public:
	TDelegate<void(TArray<struct FHitResult>& OutHits)> OnTraceComplete;                                   // 0x0080(0x0010)(BlueprintVisible, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2E72[0x100];                                   // 0x0090(0x0100)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UGzAT_AsyncSweep* AsyncSweepByBox(class UGameplayAbility* OwningAbility, class FName TaskInstanceName, EGzAsyncTraceType TraceType, const struct FVector& StartPoint, const struct FVector& Endpoint, const struct FQuat& Rotation, ECollisionChannel Channel, const struct FVector& BoxHalfExtend, bool bTraceComplex, const TArray<class AActor*>& ActorsToIgnore, bool bIgnoreSelf);
	static class UGzAT_AsyncSweep* AsyncSweepBySphere(class UGameplayAbility* OwningAbility, class FName TaskInstanceName, EGzAsyncTraceType TraceType, const struct FVector& StartPoint, const struct FVector& Endpoint, const struct FQuat& Rotation, ECollisionChannel Channel, float SphereRadius, bool bTraceComplex, const TArray<class AActor*>& ActorsToIgnore, bool bIgnoreSelf);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzAT_AsyncSweep">();
	}
	static class UGzAT_AsyncSweep* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzAT_AsyncSweep>();
	}
};
static_assert(alignof(UGzAT_AsyncSweep) == 0x000008, "Wrong alignment on UGzAT_AsyncSweep");
static_assert(sizeof(UGzAT_AsyncSweep) == 0x000190, "Wrong size on UGzAT_AsyncSweep");
static_assert(offsetof(UGzAT_AsyncSweep, OnTraceComplete) == 0x000080, "Member 'UGzAT_AsyncSweep::OnTraceComplete' has a wrong offset!");

// Class G01.GzGA_Sprint
// 0x0008 (0x0510 - 0x0508)
class UGzGA_Sprint : public UGzGameplayAbility
{
public:
	class UGzAT_WatchToggleSprintConditions*      WatchToggleSprintConditionsTask;                   // 0x0508(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void OnFinish();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzGA_Sprint">();
	}
	static class UGzGA_Sprint* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzGA_Sprint>();
	}
};
static_assert(alignof(UGzGA_Sprint) == 0x000008, "Wrong alignment on UGzGA_Sprint");
static_assert(sizeof(UGzGA_Sprint) == 0x000510, "Wrong size on UGzGA_Sprint");
static_assert(offsetof(UGzGA_Sprint, WatchToggleSprintConditionsTask) == 0x000508, "Member 'UGzGA_Sprint::WatchToggleSprintConditionsTask' has a wrong offset!");

// Class G01.GzBodyPartArchetype
// 0x0058 (0x0088 - 0x0030)
class UGzBodyPartArchetype final : public UDataAsset
{
public:
	class UGzBodyPartSkinItemData*                DefaultSkin;                                       // 0x0030(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class UGzBodyPartSkinItemData*>        SuitableSkins;                                     // 0x0038(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	bool                                          bNeedsClientTick;                                  // 0x0048(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2E7E[0x7];                                     // 0x0049(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UGzCrosshair>               AimCrosshairClass;                                 // 0x0050(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UGzProgressLogEntryWidget>  ProgressLogEntryClass;                             // 0x0058(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UGzBodyPartAbilityInputData*            AbilityInputData;                                  // 0x0060(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGzPingVoiceLineData                   PingVoiceLineEvent;                                // 0x0068(0x0010)(Edit, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	struct FGzPingVoiceLineData                   PersonalAssistantVoiceLine;                        // 0x0078(0x0010)(Edit, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)

public:
	TArray<class FName> GetSuitableSkinNames() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzBodyPartArchetype">();
	}
	static class UGzBodyPartArchetype* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzBodyPartArchetype>();
	}
};
static_assert(alignof(UGzBodyPartArchetype) == 0x000008, "Wrong alignment on UGzBodyPartArchetype");
static_assert(sizeof(UGzBodyPartArchetype) == 0x000088, "Wrong size on UGzBodyPartArchetype");
static_assert(offsetof(UGzBodyPartArchetype, DefaultSkin) == 0x000030, "Member 'UGzBodyPartArchetype::DefaultSkin' has a wrong offset!");
static_assert(offsetof(UGzBodyPartArchetype, SuitableSkins) == 0x000038, "Member 'UGzBodyPartArchetype::SuitableSkins' has a wrong offset!");
static_assert(offsetof(UGzBodyPartArchetype, bNeedsClientTick) == 0x000048, "Member 'UGzBodyPartArchetype::bNeedsClientTick' has a wrong offset!");
static_assert(offsetof(UGzBodyPartArchetype, AimCrosshairClass) == 0x000050, "Member 'UGzBodyPartArchetype::AimCrosshairClass' has a wrong offset!");
static_assert(offsetof(UGzBodyPartArchetype, ProgressLogEntryClass) == 0x000058, "Member 'UGzBodyPartArchetype::ProgressLogEntryClass' has a wrong offset!");
static_assert(offsetof(UGzBodyPartArchetype, AbilityInputData) == 0x000060, "Member 'UGzBodyPartArchetype::AbilityInputData' has a wrong offset!");
static_assert(offsetof(UGzBodyPartArchetype, PingVoiceLineEvent) == 0x000068, "Member 'UGzBodyPartArchetype::PingVoiceLineEvent' has a wrong offset!");
static_assert(offsetof(UGzBodyPartArchetype, PersonalAssistantVoiceLine) == 0x000078, "Member 'UGzBodyPartArchetype::PersonalAssistantVoiceLine' has a wrong offset!");

// Class G01.GzAT_AsyncTrace
// 0x00D8 (0x0158 - 0x0080)
class UGzAT_AsyncTrace final : public UAbilityTask
{
public:
	TDelegate<void(TArray<struct FHitResult>& OutHits)> OnTraceTaskComplete;                               // 0x0080(0x0010)(BlueprintVisible, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2E7F[0xC8];                                    // 0x0090(0x00C8)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UGzAT_AsyncTrace* AsyncTrace(class UGameplayAbility* OwningAbility, class FName TaskInstanceName, EGzAsyncTraceType TraceType, const struct FVector& StartPoint, const struct FVector& Endpoint, ECollisionChannel Channel, bool bTraceComplex, const TArray<class AActor*>& ActorsToIgnore, bool bIgnoreSelf);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzAT_AsyncTrace">();
	}
	static class UGzAT_AsyncTrace* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzAT_AsyncTrace>();
	}
};
static_assert(alignof(UGzAT_AsyncTrace) == 0x000008, "Wrong alignment on UGzAT_AsyncTrace");
static_assert(sizeof(UGzAT_AsyncTrace) == 0x000158, "Wrong size on UGzAT_AsyncTrace");
static_assert(offsetof(UGzAT_AsyncTrace, OnTraceTaskComplete) == 0x000080, "Member 'UGzAT_AsyncTrace::OnTraceTaskComplete' has a wrong offset!");

// Class G01.GzAT_CheckInteractionAbility
// 0x0020 (0x00A0 - 0x0080)
class UGzAT_CheckInteractionAbility final : public UAbilityTask
{
public:
	FMulticastInlineDelegateProperty_             OnInterrupt;                                       // 0x0080(0x0010)(ZeroConstructor, Transient, InstancedReference, NativeAccessSpecifierPublic)
	class UGzInteractionComponent*                InteractionInstigator;                             // 0x0090(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2E83[0x8];                                     // 0x0098(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzAT_CheckInteractionAbility">();
	}
	static class UGzAT_CheckInteractionAbility* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzAT_CheckInteractionAbility>();
	}
};
static_assert(alignof(UGzAT_CheckInteractionAbility) == 0x000008, "Wrong alignment on UGzAT_CheckInteractionAbility");
static_assert(sizeof(UGzAT_CheckInteractionAbility) == 0x0000A0, "Wrong size on UGzAT_CheckInteractionAbility");
static_assert(offsetof(UGzAT_CheckInteractionAbility, OnInterrupt) == 0x000080, "Member 'UGzAT_CheckInteractionAbility::OnInterrupt' has a wrong offset!");
static_assert(offsetof(UGzAT_CheckInteractionAbility, InteractionInstigator) == 0x000090, "Member 'UGzAT_CheckInteractionAbility::InteractionInstigator' has a wrong offset!");

// Class G01.GzWeaponAttackStrategy
// 0x0080 (0x00A8 - 0x0028)
class UGzWeaponAttackStrategy : public UObject
{
public:
	uint8                                         Pad_2E84[0x8];                                     // 0x0028(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UGzWeaponComponent*                     CachedWeaponComponent;                             // 0x0030(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class UGzWeaponAttackModifier*>        WeaponDamageModifiers;                             // 0x0038(0x0010)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_2E85[0x60];                                    // 0x0048(0x0060)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzWeaponAttackStrategy">();
	}
	static class UGzWeaponAttackStrategy* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzWeaponAttackStrategy>();
	}
};
static_assert(alignof(UGzWeaponAttackStrategy) == 0x000008, "Wrong alignment on UGzWeaponAttackStrategy");
static_assert(sizeof(UGzWeaponAttackStrategy) == 0x0000A8, "Wrong size on UGzWeaponAttackStrategy");
static_assert(offsetof(UGzWeaponAttackStrategy, CachedWeaponComponent) == 0x000030, "Member 'UGzWeaponAttackStrategy::CachedWeaponComponent' has a wrong offset!");
static_assert(offsetof(UGzWeaponAttackStrategy, WeaponDamageModifiers) == 0x000038, "Member 'UGzWeaponAttackStrategy::WeaponDamageModifiers' has a wrong offset!");

// Class G01.GzSettingDiscreteHDROutput
// 0x0000 (0x01B8 - 0x01B8)
class UGzSettingDiscreteHDROutput final : public UGameSettingValueDiscreteDynamic_Bool
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzSettingDiscreteHDROutput">();
	}
	static class UGzSettingDiscreteHDROutput* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzSettingDiscreteHDROutput>();
	}
};
static_assert(alignof(UGzSettingDiscreteHDROutput) == 0x000008, "Wrong alignment on UGzSettingDiscreteHDROutput");
static_assert(sizeof(UGzSettingDiscreteHDROutput) == 0x0001B8, "Wrong size on UGzSettingDiscreteHDROutput");

// Class G01.GzAT_JetpackDelayedActivation
// 0x0010 (0x0090 - 0x0080)
class UGzAT_JetpackDelayedActivation final : public UAbilityTask
{
public:
	class UGzGA_Wingsuit*                         WingsuitAbility;                                   // 0x0080(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2E86[0x8];                                     // 0x0088(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UGzAT_JetpackDelayedActivation* JetpackDelayActivation(class UGameplayAbility* OwningAbility, class FName TaskInstanceName, float InActivationDelay, bool InbInterruptDelayedJetpackIfWeCantExecuteAbility);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzAT_JetpackDelayedActivation">();
	}
	static class UGzAT_JetpackDelayedActivation* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzAT_JetpackDelayedActivation>();
	}
};
static_assert(alignof(UGzAT_JetpackDelayedActivation) == 0x000008, "Wrong alignment on UGzAT_JetpackDelayedActivation");
static_assert(sizeof(UGzAT_JetpackDelayedActivation) == 0x000090, "Wrong size on UGzAT_JetpackDelayedActivation");
static_assert(offsetof(UGzAT_JetpackDelayedActivation, WingsuitAbility) == 0x000080, "Member 'UGzAT_JetpackDelayedActivation::WingsuitAbility' has a wrong offset!");

// Class G01.GzSpawnArea
// 0x0010 (0x02B0 - 0x02A0)
class AGzSpawnArea : public AActor
{
public:
	struct FGameplayTag                           ZoneTag;                                           // 0x02A0(0x0008)(Edit, DisableEditOnTemplate, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UGzCircleAreaComponent*                 AreaComponent;                                     // 0x02A8(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	const struct FGameplayTag GetZoneTag() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzSpawnArea">();
	}
	static class AGzSpawnArea* GetDefaultObj()
	{
		return GetDefaultObjImpl<AGzSpawnArea>();
	}
};
static_assert(alignof(AGzSpawnArea) == 0x000008, "Wrong alignment on AGzSpawnArea");
static_assert(sizeof(AGzSpawnArea) == 0x0002B0, "Wrong size on AGzSpawnArea");
static_assert(offsetof(AGzSpawnArea, ZoneTag) == 0x0002A0, "Member 'AGzSpawnArea::ZoneTag' has a wrong offset!");
static_assert(offsetof(AGzSpawnArea, AreaComponent) == 0x0002A8, "Member 'AGzSpawnArea::AreaComponent' has a wrong offset!");

// Class G01.GzAT_LimbAbilityMonitor
// 0x0060 (0x00E0 - 0x0080)
class UGzAT_LimbAbilityMonitor final : public UAbilityTask
{
public:
	FMulticastInlineDelegateProperty_             ImpulseThresholdReached;                           // 0x0080(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             LimbLost;                                          // 0x0090(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	class AGzMultiPartCharacter*                  OwnerAvatar;                                       // 0x00A0(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UGzAbilitySystemComponent*              ASC;                                               // 0x00A8(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2E88[0x30];                                    // 0x00B0(0x0030)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UGzAT_LimbAbilityMonitor* MonitorLimbAbility(class UGameplayAbility* OwningAbility, const bool bEnableImpulseTreshold, const float ImpulseThreshold, const bool bListenForLimbLoss);

	void GzLimbMonitorDelegate__DelegateSignature();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzAT_LimbAbilityMonitor">();
	}
	static class UGzAT_LimbAbilityMonitor* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzAT_LimbAbilityMonitor>();
	}
};
static_assert(alignof(UGzAT_LimbAbilityMonitor) == 0x000008, "Wrong alignment on UGzAT_LimbAbilityMonitor");
static_assert(sizeof(UGzAT_LimbAbilityMonitor) == 0x0000E0, "Wrong size on UGzAT_LimbAbilityMonitor");
static_assert(offsetof(UGzAT_LimbAbilityMonitor, ImpulseThresholdReached) == 0x000080, "Member 'UGzAT_LimbAbilityMonitor::ImpulseThresholdReached' has a wrong offset!");
static_assert(offsetof(UGzAT_LimbAbilityMonitor, LimbLost) == 0x000090, "Member 'UGzAT_LimbAbilityMonitor::LimbLost' has a wrong offset!");
static_assert(offsetof(UGzAT_LimbAbilityMonitor, OwnerAvatar) == 0x0000A0, "Member 'UGzAT_LimbAbilityMonitor::OwnerAvatar' has a wrong offset!");
static_assert(offsetof(UGzAT_LimbAbilityMonitor, ASC) == 0x0000A8, "Member 'UGzAT_LimbAbilityMonitor::ASC' has a wrong offset!");

// Class G01.GzSkinItemData
// 0x0040 (0x0318 - 0x02D8)
class UGzSkinItemData : public UGzItemData
{
public:
	uint8                                         Pad_2E8B[0x8];                                     // 0x02D8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftObjectPtr<class USkeletalMesh>           SkeletalMesh;                                      // 0x02E0(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class UGzItemSkinMaterial*>            MaterialList;                                      // 0x0308(0x0010)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, ContainsInstancedReference, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzSkinItemData">();
	}
	static class UGzSkinItemData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzSkinItemData>();
	}
};
static_assert(alignof(UGzSkinItemData) == 0x000008, "Wrong alignment on UGzSkinItemData");
static_assert(sizeof(UGzSkinItemData) == 0x000318, "Wrong size on UGzSkinItemData");
static_assert(offsetof(UGzSkinItemData, SkeletalMesh) == 0x0002E0, "Member 'UGzSkinItemData::SkeletalMesh' has a wrong offset!");
static_assert(offsetof(UGzSkinItemData, MaterialList) == 0x000308, "Member 'UGzSkinItemData::MaterialList' has a wrong offset!");

// Class G01.GzAT_MortarLegs_Scanner
// 0x00F0 (0x0170 - 0x0080)
class UGzAT_MortarLegs_Scanner final : public UAbilityTask
{
public:
	FMulticastInlineDelegateProperty_             OnScanStarted;                                     // 0x0080(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnScanFinished;                                    // 0x0090(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnProgressUpdate;                                  // 0x00A0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	class AGzPlayerCharacter*                     OwnerPlayer;                                       // 0x00B0(0x0008)(ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftClassPtr<class UClass>                   ScannedTargetMarkerActorClass;                     // 0x00B8(0x0028)(Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UGzBodyPartAbilityData_MortarLegs*      AbilityData;                                       // 0x00E0(0x0008)(ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2E8C[0x88];                                    // 0x00E8(0x0088)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UGzAT_MortarLegs_Scanner* MortarLegs_Scanner(class UGameplayAbility* OwningAbility, class AGzPlayerCharacter* Param_OwnerPlayer, const struct FVector& OwnerForwardVector, TSoftClassPtr<class UClass> Param_ScannedTargetMarkerActorClass, class UGzBodyPartAbilityData_MortarLegs* Param_AbilityData, const float RoofCheckDistance);

	void OnScanDelayFinished();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzAT_MortarLegs_Scanner">();
	}
	static class UGzAT_MortarLegs_Scanner* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzAT_MortarLegs_Scanner>();
	}
};
static_assert(alignof(UGzAT_MortarLegs_Scanner) == 0x000008, "Wrong alignment on UGzAT_MortarLegs_Scanner");
static_assert(sizeof(UGzAT_MortarLegs_Scanner) == 0x000170, "Wrong size on UGzAT_MortarLegs_Scanner");
static_assert(offsetof(UGzAT_MortarLegs_Scanner, OnScanStarted) == 0x000080, "Member 'UGzAT_MortarLegs_Scanner::OnScanStarted' has a wrong offset!");
static_assert(offsetof(UGzAT_MortarLegs_Scanner, OnScanFinished) == 0x000090, "Member 'UGzAT_MortarLegs_Scanner::OnScanFinished' has a wrong offset!");
static_assert(offsetof(UGzAT_MortarLegs_Scanner, OnProgressUpdate) == 0x0000A0, "Member 'UGzAT_MortarLegs_Scanner::OnProgressUpdate' has a wrong offset!");
static_assert(offsetof(UGzAT_MortarLegs_Scanner, OwnerPlayer) == 0x0000B0, "Member 'UGzAT_MortarLegs_Scanner::OwnerPlayer' has a wrong offset!");
static_assert(offsetof(UGzAT_MortarLegs_Scanner, ScannedTargetMarkerActorClass) == 0x0000B8, "Member 'UGzAT_MortarLegs_Scanner::ScannedTargetMarkerActorClass' has a wrong offset!");
static_assert(offsetof(UGzAT_MortarLegs_Scanner, AbilityData) == 0x0000E0, "Member 'UGzAT_MortarLegs_Scanner::AbilityData' has a wrong offset!");

// Class G01.GzAT_MovementMonitor
// 0x0048 (0x00C8 - 0x0080)
class UGzAT_MovementMonitor final : public UAbilityTask
{
public:
	FMulticastInlineDelegateProperty_             SpeedThresholdReached;                             // 0x0080(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             MovementInputReceived;                             // 0x0090(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	class AGzMultiPartCharacter*                  OwnerAvatar;                                       // 0x00A0(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UGzCharacterMovementComponent*          MovementComponent;                                 // 0x00A8(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2E8E[0x18];                                    // 0x00B0(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UGzAT_MovementMonitor* MonitorMovement(class UGameplayAbility* OwningAbility, const bool bEnableSpeedTreshold, const float SpeedThreshold, const bool bListenForMovementInput, const float MovementInputThreshold, const bool bOnlyTriggerOnce);

	void GzMovementMonitorDelegate__DelegateSignature();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzAT_MovementMonitor">();
	}
	static class UGzAT_MovementMonitor* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzAT_MovementMonitor>();
	}
};
static_assert(alignof(UGzAT_MovementMonitor) == 0x000008, "Wrong alignment on UGzAT_MovementMonitor");
static_assert(sizeof(UGzAT_MovementMonitor) == 0x0000C8, "Wrong size on UGzAT_MovementMonitor");
static_assert(offsetof(UGzAT_MovementMonitor, SpeedThresholdReached) == 0x000080, "Member 'UGzAT_MovementMonitor::SpeedThresholdReached' has a wrong offset!");
static_assert(offsetof(UGzAT_MovementMonitor, MovementInputReceived) == 0x000090, "Member 'UGzAT_MovementMonitor::MovementInputReceived' has a wrong offset!");
static_assert(offsetof(UGzAT_MovementMonitor, OwnerAvatar) == 0x0000A0, "Member 'UGzAT_MovementMonitor::OwnerAvatar' has a wrong offset!");
static_assert(offsetof(UGzAT_MovementMonitor, MovementComponent) == 0x0000A8, "Member 'UGzAT_MovementMonitor::MovementComponent' has a wrong offset!");

// Class G01.GzBodyPartAbilityData_StickyGoo
// 0x0018 (0x0098 - 0x0080)
class UGzBodyPartAbilityData_StickyGoo final : public UGzBodyPartAbilityData
{
public:
	float                                         GooLifespan;                                       // 0x0080(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinProjectileLaunchSpeed;                          // 0x0084(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxProjectileLaunchSpeed;                          // 0x0088(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SlowEffectStackLimit;                              // 0x008C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         JumpHeightReductionMagnitudePerStack;              // 0x0090(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MoveSpeedReductionMagnitudePerStack;               // 0x0094(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzBodyPartAbilityData_StickyGoo">();
	}
	static class UGzBodyPartAbilityData_StickyGoo* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzBodyPartAbilityData_StickyGoo>();
	}
};
static_assert(alignof(UGzBodyPartAbilityData_StickyGoo) == 0x000008, "Wrong alignment on UGzBodyPartAbilityData_StickyGoo");
static_assert(sizeof(UGzBodyPartAbilityData_StickyGoo) == 0x000098, "Wrong size on UGzBodyPartAbilityData_StickyGoo");
static_assert(offsetof(UGzBodyPartAbilityData_StickyGoo, GooLifespan) == 0x000080, "Member 'UGzBodyPartAbilityData_StickyGoo::GooLifespan' has a wrong offset!");
static_assert(offsetof(UGzBodyPartAbilityData_StickyGoo, MinProjectileLaunchSpeed) == 0x000084, "Member 'UGzBodyPartAbilityData_StickyGoo::MinProjectileLaunchSpeed' has a wrong offset!");
static_assert(offsetof(UGzBodyPartAbilityData_StickyGoo, MaxProjectileLaunchSpeed) == 0x000088, "Member 'UGzBodyPartAbilityData_StickyGoo::MaxProjectileLaunchSpeed' has a wrong offset!");
static_assert(offsetof(UGzBodyPartAbilityData_StickyGoo, SlowEffectStackLimit) == 0x00008C, "Member 'UGzBodyPartAbilityData_StickyGoo::SlowEffectStackLimit' has a wrong offset!");
static_assert(offsetof(UGzBodyPartAbilityData_StickyGoo, JumpHeightReductionMagnitudePerStack) == 0x000090, "Member 'UGzBodyPartAbilityData_StickyGoo::JumpHeightReductionMagnitudePerStack' has a wrong offset!");
static_assert(offsetof(UGzBodyPartAbilityData_StickyGoo, MoveSpeedReductionMagnitudePerStack) == 0x000094, "Member 'UGzBodyPartAbilityData_StickyGoo::MoveSpeedReductionMagnitudePerStack' has a wrong offset!");

// Class G01.GzAT_PlayMontageAndWaitForEvent
// 0x00D0 (0x0150 - 0x0080)
class UGzAT_PlayMontageAndWaitForEvent final : public UAbilityTask
{
public:
	class UAnimMontage*                           MontageToPlay;                                     // 0x0080(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnCompleted;                                       // 0x0088(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnBlendOut;                                        // 0x0098(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnInterrupted;                                     // 0x00A8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             EventReceived;                                     // 0x00B8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnNotifyBegin;                                     // 0x00C8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnNotifyEnd;                                       // 0x00D8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	struct FGameplayTagContainer                  EventTags;                                         // 0x00E8(0x0020)(NativeAccessSpecifierPrivate)
	float                                         Rate;                                              // 0x0108(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FName                                   StartSection;                                      // 0x010C(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         AnimRootMotionTranslationScale;                    // 0x0114(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bStopWhenAbilityEnds;                              // 0x0118(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2E92[0x37];                                    // 0x0119(0x0037)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UGzAT_PlayMontageAndWaitForEvent* PlayMontageAndWaitForEvent(class UGameplayAbility* OwningAbility, class FName TaskInstanceName, class UAnimMontage* Param_MontageToPlay, const struct FGameplayTagContainer& Param_EventTags, float Param_Rate, class FName Param_StartSection, bool Param_bStopWhenAbilityEnds, float Param_AnimRootMotionTranslationScale);

	void OnNotifyBeginReceived(class FName NotifyName, const struct FBranchingPointNotifyPayload& BranchingPointNotifyPayload);
	void OnNotifyEndReceived(class FName NotifyName, const struct FBranchingPointNotifyPayload& BranchingPointNotifyPayload);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzAT_PlayMontageAndWaitForEvent">();
	}
	static class UGzAT_PlayMontageAndWaitForEvent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzAT_PlayMontageAndWaitForEvent>();
	}
};
static_assert(alignof(UGzAT_PlayMontageAndWaitForEvent) == 0x000008, "Wrong alignment on UGzAT_PlayMontageAndWaitForEvent");
static_assert(sizeof(UGzAT_PlayMontageAndWaitForEvent) == 0x000150, "Wrong size on UGzAT_PlayMontageAndWaitForEvent");
static_assert(offsetof(UGzAT_PlayMontageAndWaitForEvent, MontageToPlay) == 0x000080, "Member 'UGzAT_PlayMontageAndWaitForEvent::MontageToPlay' has a wrong offset!");
static_assert(offsetof(UGzAT_PlayMontageAndWaitForEvent, OnCompleted) == 0x000088, "Member 'UGzAT_PlayMontageAndWaitForEvent::OnCompleted' has a wrong offset!");
static_assert(offsetof(UGzAT_PlayMontageAndWaitForEvent, OnBlendOut) == 0x000098, "Member 'UGzAT_PlayMontageAndWaitForEvent::OnBlendOut' has a wrong offset!");
static_assert(offsetof(UGzAT_PlayMontageAndWaitForEvent, OnInterrupted) == 0x0000A8, "Member 'UGzAT_PlayMontageAndWaitForEvent::OnInterrupted' has a wrong offset!");
static_assert(offsetof(UGzAT_PlayMontageAndWaitForEvent, EventReceived) == 0x0000B8, "Member 'UGzAT_PlayMontageAndWaitForEvent::EventReceived' has a wrong offset!");
static_assert(offsetof(UGzAT_PlayMontageAndWaitForEvent, OnNotifyBegin) == 0x0000C8, "Member 'UGzAT_PlayMontageAndWaitForEvent::OnNotifyBegin' has a wrong offset!");
static_assert(offsetof(UGzAT_PlayMontageAndWaitForEvent, OnNotifyEnd) == 0x0000D8, "Member 'UGzAT_PlayMontageAndWaitForEvent::OnNotifyEnd' has a wrong offset!");
static_assert(offsetof(UGzAT_PlayMontageAndWaitForEvent, EventTags) == 0x0000E8, "Member 'UGzAT_PlayMontageAndWaitForEvent::EventTags' has a wrong offset!");
static_assert(offsetof(UGzAT_PlayMontageAndWaitForEvent, Rate) == 0x000108, "Member 'UGzAT_PlayMontageAndWaitForEvent::Rate' has a wrong offset!");
static_assert(offsetof(UGzAT_PlayMontageAndWaitForEvent, StartSection) == 0x00010C, "Member 'UGzAT_PlayMontageAndWaitForEvent::StartSection' has a wrong offset!");
static_assert(offsetof(UGzAT_PlayMontageAndWaitForEvent, AnimRootMotionTranslationScale) == 0x000114, "Member 'UGzAT_PlayMontageAndWaitForEvent::AnimRootMotionTranslationScale' has a wrong offset!");
static_assert(offsetof(UGzAT_PlayMontageAndWaitForEvent, bStopWhenAbilityEnds) == 0x000118, "Member 'UGzAT_PlayMontageAndWaitForEvent::bStopWhenAbilityEnds' has a wrong offset!");

// Class G01.GzAT_ServerWaitForTargetData
// 0x0018 (0x0098 - 0x0080)
class UGzAT_ServerWaitForTargetData final : public UAbilityTask
{
public:
	FMulticastInlineDelegateProperty_             ValidData;                                         // 0x0080(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_2E95[0x8];                                     // 0x0090(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UGzAT_ServerWaitForTargetData* ServerWaitForClientTargetData(class UGameplayAbility* OwningAbility, class FName TaskInstanceName, bool TriggerOnce);

	void OnTargetDataReplicatedCallback(const struct FGameplayAbilityTargetDataHandle& Data, const struct FGameplayTag& ActivationTag);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzAT_ServerWaitForTargetData">();
	}
	static class UGzAT_ServerWaitForTargetData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzAT_ServerWaitForTargetData>();
	}
};
static_assert(alignof(UGzAT_ServerWaitForTargetData) == 0x000008, "Wrong alignment on UGzAT_ServerWaitForTargetData");
static_assert(sizeof(UGzAT_ServerWaitForTargetData) == 0x000098, "Wrong size on UGzAT_ServerWaitForTargetData");
static_assert(offsetof(UGzAT_ServerWaitForTargetData, ValidData) == 0x000080, "Member 'UGzAT_ServerWaitForTargetData::ValidData' has a wrong offset!");

// Class G01.GzLimbStepSoundsData
// 0x0328 (0x0358 - 0x0030)
class UGzLimbStepSoundsData final : public UDataAsset
{
public:
	TMap<EGzCharacterSoundAction, class UAkSwitchValue*> StepTypeSwitches;                                  // 0x0030(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TMap<class FName, class UAkSwitchValue*>      ActionTypeSwitches;                                // 0x0080(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TMap<EPhysicalSurface, class UAkSwitchValue*> SurfaceTypeSwitches;                               // 0x00D0(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TMap<EGzSoundSourceBodyPart, class UAkSwitchValue*> SoundSourceBodyPartSwitches;                       // 0x0120(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TMap<class UGzBodyPartItemData*, class UAkSwitchValue*> LimbSpecificSwitches;                              // 0x0170(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TMap<class UGzBodyPartArchetype*, class UAkSwitchValue*> LimbArchetypeSpecificSwitches;                     // 0x01C0(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TMap<EGzLimbType, class UAkSwitchValue*>      DefaultLimbSwitches;                               // 0x0210(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TMap<EGzLimbType, class UAkSwitchValue*>      NoLimbSwitches;                                    // 0x0260(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	class UAkAudioEvent*                          SurfaceStepEvent;                                  // 0x02B0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMap<EGzSoundSourceBodyPart, class UAkAudioEvent*> BodyPartPlayEvents;                                // 0x02B8(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TMap<EGzSoundSourceBodyPart, class UAkAudioEvent*> BodyPartStopEvents;                                // 0x0308(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzLimbStepSoundsData">();
	}
	static class UGzLimbStepSoundsData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzLimbStepSoundsData>();
	}
};
static_assert(alignof(UGzLimbStepSoundsData) == 0x000008, "Wrong alignment on UGzLimbStepSoundsData");
static_assert(sizeof(UGzLimbStepSoundsData) == 0x000358, "Wrong size on UGzLimbStepSoundsData");
static_assert(offsetof(UGzLimbStepSoundsData, StepTypeSwitches) == 0x000030, "Member 'UGzLimbStepSoundsData::StepTypeSwitches' has a wrong offset!");
static_assert(offsetof(UGzLimbStepSoundsData, ActionTypeSwitches) == 0x000080, "Member 'UGzLimbStepSoundsData::ActionTypeSwitches' has a wrong offset!");
static_assert(offsetof(UGzLimbStepSoundsData, SurfaceTypeSwitches) == 0x0000D0, "Member 'UGzLimbStepSoundsData::SurfaceTypeSwitches' has a wrong offset!");
static_assert(offsetof(UGzLimbStepSoundsData, SoundSourceBodyPartSwitches) == 0x000120, "Member 'UGzLimbStepSoundsData::SoundSourceBodyPartSwitches' has a wrong offset!");
static_assert(offsetof(UGzLimbStepSoundsData, LimbSpecificSwitches) == 0x000170, "Member 'UGzLimbStepSoundsData::LimbSpecificSwitches' has a wrong offset!");
static_assert(offsetof(UGzLimbStepSoundsData, LimbArchetypeSpecificSwitches) == 0x0001C0, "Member 'UGzLimbStepSoundsData::LimbArchetypeSpecificSwitches' has a wrong offset!");
static_assert(offsetof(UGzLimbStepSoundsData, DefaultLimbSwitches) == 0x000210, "Member 'UGzLimbStepSoundsData::DefaultLimbSwitches' has a wrong offset!");
static_assert(offsetof(UGzLimbStepSoundsData, NoLimbSwitches) == 0x000260, "Member 'UGzLimbStepSoundsData::NoLimbSwitches' has a wrong offset!");
static_assert(offsetof(UGzLimbStepSoundsData, SurfaceStepEvent) == 0x0002B0, "Member 'UGzLimbStepSoundsData::SurfaceStepEvent' has a wrong offset!");
static_assert(offsetof(UGzLimbStepSoundsData, BodyPartPlayEvents) == 0x0002B8, "Member 'UGzLimbStepSoundsData::BodyPartPlayEvents' has a wrong offset!");
static_assert(offsetof(UGzLimbStepSoundsData, BodyPartStopEvents) == 0x000308, "Member 'UGzLimbStepSoundsData::BodyPartStopEvents' has a wrong offset!");

// Class G01.DefaultInteractionBehavior
// 0x0080 (0x00A8 - 0x0028)
class UDefaultInteractionBehavior : public UObject
{
public:
	FMulticastInlineDelegateProperty_             OnInteractionEnded;                                // 0x0028(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	struct FGameplayTag                           Tag;                                               // 0x0038(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   Text;                                              // 0x0040(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	class FText                                   HoldInteractionTooltip;                            // 0x0050(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	EGzInteractionType                            InteractionType;                                   // 0x0060(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2E97[0x3];                                     // 0x0061(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         InteractionTime;                                   // 0x0064(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InteractionRadius;                                 // 0x0068(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AutoPickUpRadius;                                  // 0x006C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEndOnInteractionComplete;                         // 0x0070(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2E98[0x37];                                    // 0x0071(0x0037)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ExternalEndInteraction();
	void OnInteractionEnds(class AActor* InteractedBy, bool bHasAuthority);

	bool CanBeInteractedBy(class UGzInteractionComponent* InteractedBy) const;
	class AActor* GetOwnerActor() const;
	class UAbilitySystemComponent* GetOwnerASC() const;
	class UGzInteractableComponent* GetOwnerInteractable() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DefaultInteractionBehavior">();
	}
	static class UDefaultInteractionBehavior* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDefaultInteractionBehavior>();
	}
};
static_assert(alignof(UDefaultInteractionBehavior) == 0x000008, "Wrong alignment on UDefaultInteractionBehavior");
static_assert(sizeof(UDefaultInteractionBehavior) == 0x0000A8, "Wrong size on UDefaultInteractionBehavior");
static_assert(offsetof(UDefaultInteractionBehavior, OnInteractionEnded) == 0x000028, "Member 'UDefaultInteractionBehavior::OnInteractionEnded' has a wrong offset!");
static_assert(offsetof(UDefaultInteractionBehavior, Tag) == 0x000038, "Member 'UDefaultInteractionBehavior::Tag' has a wrong offset!");
static_assert(offsetof(UDefaultInteractionBehavior, Text) == 0x000040, "Member 'UDefaultInteractionBehavior::Text' has a wrong offset!");
static_assert(offsetof(UDefaultInteractionBehavior, HoldInteractionTooltip) == 0x000050, "Member 'UDefaultInteractionBehavior::HoldInteractionTooltip' has a wrong offset!");
static_assert(offsetof(UDefaultInteractionBehavior, InteractionType) == 0x000060, "Member 'UDefaultInteractionBehavior::InteractionType' has a wrong offset!");
static_assert(offsetof(UDefaultInteractionBehavior, InteractionTime) == 0x000064, "Member 'UDefaultInteractionBehavior::InteractionTime' has a wrong offset!");
static_assert(offsetof(UDefaultInteractionBehavior, InteractionRadius) == 0x000068, "Member 'UDefaultInteractionBehavior::InteractionRadius' has a wrong offset!");
static_assert(offsetof(UDefaultInteractionBehavior, AutoPickUpRadius) == 0x00006C, "Member 'UDefaultInteractionBehavior::AutoPickUpRadius' has a wrong offset!");
static_assert(offsetof(UDefaultInteractionBehavior, bEndOnInteractionComplete) == 0x000070, "Member 'UDefaultInteractionBehavior::bEndOnInteractionComplete' has a wrong offset!");

// Class G01.MontageInteractionBehavior
// 0x0030 (0x00D8 - 0x00A8)
class UMontageInteractionBehavior : public UDefaultInteractionBehavior
{
public:
	class UAnimMontage*                           StartInteractionMontage;                           // 0x00A8(0x0008)(Edit, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAnimMontage*                           EndInteractionMontage;                             // 0x00B0(0x0008)(Edit, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bInteractOnNotify;                                 // 0x00B8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bInteractOnStartMontageCompleted;                  // 0x00B9(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2E9B[0x6];                                     // 0x00BA(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class UGzAT_PlayMontageAndWaitForEvent*       StartMontageTask;                                  // 0x00C0(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UGzAT_PlayMontageAndWaitForEvent*       EndMontageTask;                                    // 0x00C8(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class AActor*                                 CachedInteractedBy;                                // 0x00D0(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void OnMontageEnded();
	void OnMontageInterrupted();
	void OnMontageNotify(class FName NotifyName);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MontageInteractionBehavior">();
	}
	static class UMontageInteractionBehavior* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMontageInteractionBehavior>();
	}
};
static_assert(alignof(UMontageInteractionBehavior) == 0x000008, "Wrong alignment on UMontageInteractionBehavior");
static_assert(sizeof(UMontageInteractionBehavior) == 0x0000D8, "Wrong size on UMontageInteractionBehavior");
static_assert(offsetof(UMontageInteractionBehavior, StartInteractionMontage) == 0x0000A8, "Member 'UMontageInteractionBehavior::StartInteractionMontage' has a wrong offset!");
static_assert(offsetof(UMontageInteractionBehavior, EndInteractionMontage) == 0x0000B0, "Member 'UMontageInteractionBehavior::EndInteractionMontage' has a wrong offset!");
static_assert(offsetof(UMontageInteractionBehavior, bInteractOnNotify) == 0x0000B8, "Member 'UMontageInteractionBehavior::bInteractOnNotify' has a wrong offset!");
static_assert(offsetof(UMontageInteractionBehavior, bInteractOnStartMontageCompleted) == 0x0000B9, "Member 'UMontageInteractionBehavior::bInteractOnStartMontageCompleted' has a wrong offset!");
static_assert(offsetof(UMontageInteractionBehavior, StartMontageTask) == 0x0000C0, "Member 'UMontageInteractionBehavior::StartMontageTask' has a wrong offset!");
static_assert(offsetof(UMontageInteractionBehavior, EndMontageTask) == 0x0000C8, "Member 'UMontageInteractionBehavior::EndMontageTask' has a wrong offset!");
static_assert(offsetof(UMontageInteractionBehavior, CachedInteractedBy) == 0x0000D0, "Member 'UMontageInteractionBehavior::CachedInteractedBy' has a wrong offset!");

// Class G01.GzDefaultPickableInteractionBehaviour
// 0x0010 (0x00E8 - 0x00D8)
class UGzDefaultPickableInteractionBehaviour : public UMontageInteractionBehavior
{
public:
	class AGzPickableBase*                        CachedPickable;                                    // 0x00D8(0x0008)(ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2E9C[0x8];                                     // 0x00E0(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzDefaultPickableInteractionBehaviour">();
	}
	static class UGzDefaultPickableInteractionBehaviour* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzDefaultPickableInteractionBehaviour>();
	}
};
static_assert(alignof(UGzDefaultPickableInteractionBehaviour) == 0x000008, "Wrong alignment on UGzDefaultPickableInteractionBehaviour");
static_assert(sizeof(UGzDefaultPickableInteractionBehaviour) == 0x0000E8, "Wrong size on UGzDefaultPickableInteractionBehaviour");
static_assert(offsetof(UGzDefaultPickableInteractionBehaviour, CachedPickable) == 0x0000D8, "Member 'UGzDefaultPickableInteractionBehaviour::CachedPickable' has a wrong offset!");

// Class G01.GzAT_SuperSprintTrailSpawner
// 0x0038 (0x00B8 - 0x0080)
class UGzAT_SuperSprintTrailSpawner final : public UAbilityTask
{
public:
	class UGzBodyPartAbilityData_SuperSprintLegs* AbilityData;                                       // 0x0080(0x0008)(ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class AGzCharacter*                           GzCharacter;                                       // 0x0088(0x0008)(ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class AGzSuperSprintTrailActor>   TrailActorClass;                                   // 0x0090(0x0008)(ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2E9D[0x20];                                    // 0x0098(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzAT_SuperSprintTrailSpawner">();
	}
	static class UGzAT_SuperSprintTrailSpawner* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzAT_SuperSprintTrailSpawner>();
	}
};
static_assert(alignof(UGzAT_SuperSprintTrailSpawner) == 0x000008, "Wrong alignment on UGzAT_SuperSprintTrailSpawner");
static_assert(sizeof(UGzAT_SuperSprintTrailSpawner) == 0x0000B8, "Wrong size on UGzAT_SuperSprintTrailSpawner");
static_assert(offsetof(UGzAT_SuperSprintTrailSpawner, AbilityData) == 0x000080, "Member 'UGzAT_SuperSprintTrailSpawner::AbilityData' has a wrong offset!");
static_assert(offsetof(UGzAT_SuperSprintTrailSpawner, GzCharacter) == 0x000088, "Member 'UGzAT_SuperSprintTrailSpawner::GzCharacter' has a wrong offset!");
static_assert(offsetof(UGzAT_SuperSprintTrailSpawner, TrailActorClass) == 0x000090, "Member 'UGzAT_SuperSprintTrailSpawner::TrailActorClass' has a wrong offset!");

// Class G01.GzAT_W8AttributeChangeThreshold
// 0x0070 (0x00F0 - 0x0080)
class UGzAT_W8AttributeChangeThreshold final : public UAbilityTask
{
public:
	FMulticastInlineDelegateProperty_             OnChange;                                          // 0x0080(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_2E9E[0x58];                                    // 0x0090(0x0058)(Fixing Size After Last Property [ Dumper-7 ])
	class UAbilitySystemComponent*                ExternalOwner;                                     // 0x00E8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UGzAT_W8AttributeChangeThreshold* WaitForAttributeChangeThreshold(class UGameplayAbility* OwningAbility, const struct FGameplayAttribute& Attribute, EWaitAttributeChangeComparison ComparisonType, float ComparisonValue, bool bTriggerOnce, class AActor* OptionalExternalOwner);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzAT_W8AttributeChangeThreshold">();
	}
	static class UGzAT_W8AttributeChangeThreshold* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzAT_W8AttributeChangeThreshold>();
	}
};
static_assert(alignof(UGzAT_W8AttributeChangeThreshold) == 0x000008, "Wrong alignment on UGzAT_W8AttributeChangeThreshold");
static_assert(sizeof(UGzAT_W8AttributeChangeThreshold) == 0x0000F0, "Wrong size on UGzAT_W8AttributeChangeThreshold");
static_assert(offsetof(UGzAT_W8AttributeChangeThreshold, OnChange) == 0x000080, "Member 'UGzAT_W8AttributeChangeThreshold::OnChange' has a wrong offset!");
static_assert(offsetof(UGzAT_W8AttributeChangeThreshold, ExternalOwner) == 0x0000E8, "Member 'UGzAT_W8AttributeChangeThreshold::ExternalOwner' has a wrong offset!");

// Class G01.GzMultiStageGameMode
// 0x0078 (0x0640 - 0x05C8)
class AGzMultiStageGameMode : public AGzSessionGameModeBase
{
public:
	TSubclassOf<class UGzRootStage>               RootStageClass;                                    // 0x05C8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoClear, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSubclassOf<class UGzGameRestartStage>        RestartStageClass;                                 // 0x05D0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoClear, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSubclassOf<class UGzGameAbortStage>          AbortStageClass;                                   // 0x05D8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoClear, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<TSubclassOf<class UGzGameStageBase>>   Stages;                                            // 0x05E0(0x0010)(ZeroConstructor, Transient, UObjectWrapper, NativeAccessSpecifierPrivate)
	class UGzRootStage*                           Root;                                              // 0x05F0(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UGzGameRestartStage*                    RestartStage;                                      // 0x05F8(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UGzGameAbortStage*                      AbortStage;                                        // 0x0600(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UGzGameStageBase*                       ActiveStage;                                       // 0x0608(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UGzGameStageBase*                       PreviousStage;                                     // 0x0610(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2EA1[0x28];                                    // 0x0618(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzMultiStageGameMode">();
	}
	static class AGzMultiStageGameMode* GetDefaultObj()
	{
		return GetDefaultObjImpl<AGzMultiStageGameMode>();
	}
};
static_assert(alignof(AGzMultiStageGameMode) == 0x000008, "Wrong alignment on AGzMultiStageGameMode");
static_assert(sizeof(AGzMultiStageGameMode) == 0x000640, "Wrong size on AGzMultiStageGameMode");
static_assert(offsetof(AGzMultiStageGameMode, RootStageClass) == 0x0005C8, "Member 'AGzMultiStageGameMode::RootStageClass' has a wrong offset!");
static_assert(offsetof(AGzMultiStageGameMode, RestartStageClass) == 0x0005D0, "Member 'AGzMultiStageGameMode::RestartStageClass' has a wrong offset!");
static_assert(offsetof(AGzMultiStageGameMode, AbortStageClass) == 0x0005D8, "Member 'AGzMultiStageGameMode::AbortStageClass' has a wrong offset!");
static_assert(offsetof(AGzMultiStageGameMode, Stages) == 0x0005E0, "Member 'AGzMultiStageGameMode::Stages' has a wrong offset!");
static_assert(offsetof(AGzMultiStageGameMode, Root) == 0x0005F0, "Member 'AGzMultiStageGameMode::Root' has a wrong offset!");
static_assert(offsetof(AGzMultiStageGameMode, RestartStage) == 0x0005F8, "Member 'AGzMultiStageGameMode::RestartStage' has a wrong offset!");
static_assert(offsetof(AGzMultiStageGameMode, AbortStage) == 0x000600, "Member 'AGzMultiStageGameMode::AbortStage' has a wrong offset!");
static_assert(offsetof(AGzMultiStageGameMode, ActiveStage) == 0x000608, "Member 'AGzMultiStageGameMode::ActiveStage' has a wrong offset!");
static_assert(offsetof(AGzMultiStageGameMode, PreviousStage) == 0x000610, "Member 'AGzMultiStageGameMode::PreviousStage' has a wrong offset!");

// Class G01.GzJobZeroGameMode
// 0x00C0 (0x0700 - 0x0640)
class AGzJobZeroGameMode final : public AGzMultiStageGameMode
{
public:
	TSoftClassPtr<class UClass>                   PreMatchSoftClass;                                 // 0x0640(0x0028)(Edit, DisableEditOnInstance, NoClear, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftClassPtr<class UClass>                   PreparePlayersSoftClass;                           // 0x0668(0x0028)(Edit, DisableEditOnInstance, NoClear, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftClassPtr<class UClass>                   InProgressSoftClass;                               // 0x0690(0x0028)(Edit, DisableEditOnInstance, NoClear, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftClassPtr<class UClass>                   PostMatchSoftClass;                                // 0x06B8(0x0028)(Edit, DisableEditOnInstance, NoClear, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<struct FGzPlayerProfileUsage>          Profiles;                                          // 0x06E0(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	class AGzTeam*                                TargetTeam;                                        // 0x06F0(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2EA2[0x8];                                     // 0x06F8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzJobZeroGameMode">();
	}
	static class AGzJobZeroGameMode* GetDefaultObj()
	{
		return GetDefaultObjImpl<AGzJobZeroGameMode>();
	}
};
static_assert(alignof(AGzJobZeroGameMode) == 0x000008, "Wrong alignment on AGzJobZeroGameMode");
static_assert(sizeof(AGzJobZeroGameMode) == 0x000700, "Wrong size on AGzJobZeroGameMode");
static_assert(offsetof(AGzJobZeroGameMode, PreMatchSoftClass) == 0x000640, "Member 'AGzJobZeroGameMode::PreMatchSoftClass' has a wrong offset!");
static_assert(offsetof(AGzJobZeroGameMode, PreparePlayersSoftClass) == 0x000668, "Member 'AGzJobZeroGameMode::PreparePlayersSoftClass' has a wrong offset!");
static_assert(offsetof(AGzJobZeroGameMode, InProgressSoftClass) == 0x000690, "Member 'AGzJobZeroGameMode::InProgressSoftClass' has a wrong offset!");
static_assert(offsetof(AGzJobZeroGameMode, PostMatchSoftClass) == 0x0006B8, "Member 'AGzJobZeroGameMode::PostMatchSoftClass' has a wrong offset!");
static_assert(offsetof(AGzJobZeroGameMode, Profiles) == 0x0006E0, "Member 'AGzJobZeroGameMode::Profiles' has a wrong offset!");
static_assert(offsetof(AGzJobZeroGameMode, TargetTeam) == 0x0006F0, "Member 'AGzJobZeroGameMode::TargetTeam' has a wrong offset!");

// Class G01.GzBodyPartAbilityData_IntelCanister
// 0x0008 (0x0088 - 0x0080)
class UGzBodyPartAbilityData_IntelCanister final : public UGzBodyPartAbilityData
{
public:
	float                                         LifeSpan;                                          // 0x0080(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2EA3[0x4];                                     // 0x0084(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzBodyPartAbilityData_IntelCanister">();
	}
	static class UGzBodyPartAbilityData_IntelCanister* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzBodyPartAbilityData_IntelCanister>();
	}
};
static_assert(alignof(UGzBodyPartAbilityData_IntelCanister) == 0x000008, "Wrong alignment on UGzBodyPartAbilityData_IntelCanister");
static_assert(sizeof(UGzBodyPartAbilityData_IntelCanister) == 0x000088, "Wrong size on UGzBodyPartAbilityData_IntelCanister");
static_assert(offsetof(UGzBodyPartAbilityData_IntelCanister, LifeSpan) == 0x000080, "Member 'UGzBodyPartAbilityData_IntelCanister::LifeSpan' has a wrong offset!");

// Class G01.GzPredefinedPlayerProfilesSettings
// 0x0010 (0x0048 - 0x0038)
class UGzPredefinedPlayerProfilesSettings final : public UDeveloperSettings
{
public:
	TArray<struct FGzPredefinedPlayerProfile>     Profiles;                                          // 0x0038(0x0010)(Edit, ZeroConstructor, Config, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzPredefinedPlayerProfilesSettings">();
	}
	static class UGzPredefinedPlayerProfilesSettings* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzPredefinedPlayerProfilesSettings>();
	}
};
static_assert(alignof(UGzPredefinedPlayerProfilesSettings) == 0x000008, "Wrong alignment on UGzPredefinedPlayerProfilesSettings");
static_assert(sizeof(UGzPredefinedPlayerProfilesSettings) == 0x000048, "Wrong size on UGzPredefinedPlayerProfilesSettings");
static_assert(offsetof(UGzPredefinedPlayerProfilesSettings, Profiles) == 0x000038, "Member 'UGzPredefinedPlayerProfilesSettings::Profiles' has a wrong offset!");

// Class G01.GzAT_WaitComponentOverlap
// 0x0020 (0x00A0 - 0x0080)
class UGzAT_WaitComponentOverlap final : public UAbilityTask
{
public:
	FMulticastInlineDelegateProperty_             OnOverlap;                                         // 0x0080(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	class UPrimitiveComponent*                    OverlapWith;                                       // 0x0090(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEndAfterFirstOverlap;                             // 0x0098(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bReceiveComponentHit;                              // 0x0099(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bReceiveComponentOverlap;                          // 0x009A(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2EA4[0x5];                                     // 0x009B(0x0005)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UGzAT_WaitComponentOverlap* WaitForOverlap(class UGameplayAbility* OwningAbility, class UPrimitiveComponent* OverlapWithComponent, bool bEndTaskAfterFirstOverlap, bool bReceiveHit, bool bReceiveBeginOverlap);

	void OnBeginOverlapCallback(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const struct FHitResult& SweepResult);
	void OnHitCallback(class UPrimitiveComponent* HitComp, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, const struct FVector& NormalImpulse, const struct FHitResult& Hit);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzAT_WaitComponentOverlap">();
	}
	static class UGzAT_WaitComponentOverlap* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzAT_WaitComponentOverlap>();
	}
};
static_assert(alignof(UGzAT_WaitComponentOverlap) == 0x000008, "Wrong alignment on UGzAT_WaitComponentOverlap");
static_assert(sizeof(UGzAT_WaitComponentOverlap) == 0x0000A0, "Wrong size on UGzAT_WaitComponentOverlap");
static_assert(offsetof(UGzAT_WaitComponentOverlap, OnOverlap) == 0x000080, "Member 'UGzAT_WaitComponentOverlap::OnOverlap' has a wrong offset!");
static_assert(offsetof(UGzAT_WaitComponentOverlap, OverlapWith) == 0x000090, "Member 'UGzAT_WaitComponentOverlap::OverlapWith' has a wrong offset!");
static_assert(offsetof(UGzAT_WaitComponentOverlap, bEndAfterFirstOverlap) == 0x000098, "Member 'UGzAT_WaitComponentOverlap::bEndAfterFirstOverlap' has a wrong offset!");
static_assert(offsetof(UGzAT_WaitComponentOverlap, bReceiveComponentHit) == 0x000099, "Member 'UGzAT_WaitComponentOverlap::bReceiveComponentHit' has a wrong offset!");
static_assert(offsetof(UGzAT_WaitComponentOverlap, bReceiveComponentOverlap) == 0x00009A, "Member 'UGzAT_WaitComponentOverlap::bReceiveComponentOverlap' has a wrong offset!");

// Class G01.GzUserSettingsManager
// 0x0010 (0x0038 - 0x0028)
class UGzUserSettingsManager final : public UObject
{
public:
	class UGzSensitivityManager*                  SensitivityManager;                                // 0x0028(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UGameSettingRegistry*                   SettingsRegistry;                                  // 0x0030(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzUserSettingsManager">();
	}
	static class UGzUserSettingsManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzUserSettingsManager>();
	}
};
static_assert(alignof(UGzUserSettingsManager) == 0x000008, "Wrong alignment on UGzUserSettingsManager");
static_assert(sizeof(UGzUserSettingsManager) == 0x000038, "Wrong size on UGzUserSettingsManager");
static_assert(offsetof(UGzUserSettingsManager, SensitivityManager) == 0x000028, "Member 'UGzUserSettingsManager::SensitivityManager' has a wrong offset!");
static_assert(offsetof(UGzUserSettingsManager, SettingsRegistry) == 0x000030, "Member 'UGzUserSettingsManager::SettingsRegistry' has a wrong offset!");

// Class G01.GzInWorldHitmarkSubsystem
// 0x0018 (0x0048 - 0x0030)
class UGzInWorldHitmarkSubsystem final : public ULocalPlayerSubsystem
{
public:
	TArray<struct FGzWorldHitmarkEntry>           Hitmarks;                                          // 0x0030(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2EA7[0x8];                                     // 0x0040(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnHitResponse(const struct FGzHitResponseData& HitResponseData);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzInWorldHitmarkSubsystem">();
	}
	static class UGzInWorldHitmarkSubsystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzInWorldHitmarkSubsystem>();
	}
};
static_assert(alignof(UGzInWorldHitmarkSubsystem) == 0x000008, "Wrong alignment on UGzInWorldHitmarkSubsystem");
static_assert(sizeof(UGzInWorldHitmarkSubsystem) == 0x000048, "Wrong size on UGzInWorldHitmarkSubsystem");
static_assert(offsetof(UGzInWorldHitmarkSubsystem, Hitmarks) == 0x000030, "Member 'UGzInWorldHitmarkSubsystem::Hitmarks' has a wrong offset!");

// Class G01.GzAT_WaitCustomInputBase
// 0x0040 (0x00C0 - 0x0080)
class UGzAT_WaitCustomInputBase : public UAbilityTask
{
public:
	FMulticastInlineDelegateProperty_             OnInput;                                           // 0x0080(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TArray<class UInputAction*>                   CustomInputActions;                                // 0x0090(0x0010)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_2EA8[0x20];                                    // 0x00A0(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnInputCallback();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzAT_WaitCustomInputBase">();
	}
	static class UGzAT_WaitCustomInputBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzAT_WaitCustomInputBase>();
	}
};
static_assert(alignof(UGzAT_WaitCustomInputBase) == 0x000008, "Wrong alignment on UGzAT_WaitCustomInputBase");
static_assert(sizeof(UGzAT_WaitCustomInputBase) == 0x0000C0, "Wrong size on UGzAT_WaitCustomInputBase");
static_assert(offsetof(UGzAT_WaitCustomInputBase, OnInput) == 0x000080, "Member 'UGzAT_WaitCustomInputBase::OnInput' has a wrong offset!");
static_assert(offsetof(UGzAT_WaitCustomInputBase, CustomInputActions) == 0x000090, "Member 'UGzAT_WaitCustomInputBase::CustomInputActions' has a wrong offset!");

// Class G01.GzCharacterPhysicsSetup
// 0x0060 (0x0090 - 0x0030)
class UGzCharacterPhysicsSetup final : public UPrimaryDataAsset
{
public:
	class UPhysicsAsset*                          LeaderPhysicsAsset;                                // 0x0030(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EGzCharacterDamageAreaType                    DefaultDamageArea;                                 // 0x0038(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2EA9[0x7];                                     // 0x0039(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<EGzCharacterDamageAreaType, struct FGzDamageAreaParameters> DamageAreaParameters;                              // 0x0040(0x0050)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzCharacterPhysicsSetup">();
	}
	static class UGzCharacterPhysicsSetup* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzCharacterPhysicsSetup>();
	}
};
static_assert(alignof(UGzCharacterPhysicsSetup) == 0x000008, "Wrong alignment on UGzCharacterPhysicsSetup");
static_assert(sizeof(UGzCharacterPhysicsSetup) == 0x000090, "Wrong size on UGzCharacterPhysicsSetup");
static_assert(offsetof(UGzCharacterPhysicsSetup, LeaderPhysicsAsset) == 0x000030, "Member 'UGzCharacterPhysicsSetup::LeaderPhysicsAsset' has a wrong offset!");
static_assert(offsetof(UGzCharacterPhysicsSetup, DefaultDamageArea) == 0x000038, "Member 'UGzCharacterPhysicsSetup::DefaultDamageArea' has a wrong offset!");
static_assert(offsetof(UGzCharacterPhysicsSetup, DamageAreaParameters) == 0x000040, "Member 'UGzCharacterPhysicsSetup::DamageAreaParameters' has a wrong offset!");

// Class G01.GzAT_WaitCustomInputPress
// 0x0000 (0x00C0 - 0x00C0)
class UGzAT_WaitCustomInputPress final : public UGzAT_WaitCustomInputBase
{
public:
	static class UGzAT_WaitCustomInputPress* WaitCustomAnyInputPress(class UGameplayAbility* OwningAbility, const TArray<class UInputAction*>& InputActions, bool bTestAlreadyPressed, EGzCustomInputEvent EventId);
	static class UGzAT_WaitCustomInputPress* WaitCustomInputPress(class UGameplayAbility* OwningAbility, class UInputAction* InputAction, bool bTestAlreadyPressed, EGzCustomInputEvent EventId);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzAT_WaitCustomInputPress">();
	}
	static class UGzAT_WaitCustomInputPress* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzAT_WaitCustomInputPress>();
	}
};
static_assert(alignof(UGzAT_WaitCustomInputPress) == 0x000008, "Wrong alignment on UGzAT_WaitCustomInputPress");
static_assert(sizeof(UGzAT_WaitCustomInputPress) == 0x0000C0, "Wrong size on UGzAT_WaitCustomInputPress");

// Class G01.GzItemSpawnPoint
// 0x0000 (0x02B0 - 0x02B0)
class AGzItemSpawnPoint final : public AStaticMeshActor
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzItemSpawnPoint">();
	}
	static class AGzItemSpawnPoint* GetDefaultObj()
	{
		return GetDefaultObjImpl<AGzItemSpawnPoint>();
	}
};
static_assert(alignof(AGzItemSpawnPoint) == 0x000008, "Wrong alignment on AGzItemSpawnPoint");
static_assert(sizeof(AGzItemSpawnPoint) == 0x0002B0, "Wrong size on AGzItemSpawnPoint");

// Class G01.GzAT_WaitCustomInputRelease
// 0x0000 (0x00C0 - 0x00C0)
class UGzAT_WaitCustomInputRelease final : public UGzAT_WaitCustomInputBase
{
public:
	static class UGzAT_WaitCustomInputRelease* WaitCustomAnyInputRelease(class UGameplayAbility* OwningAbility, const TArray<class UInputAction*>& InputActions, bool bTestAlreadyReleased_NotImplemented, EGzCustomInputEvent EventId);
	static class UGzAT_WaitCustomInputRelease* WaitCustomInputRelease(class UGameplayAbility* OwningAbility, class UInputAction* InputAction, bool bTestAlreadyReleased_NotImplemented, EGzCustomInputEvent EventId);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzAT_WaitCustomInputRelease">();
	}
	static class UGzAT_WaitCustomInputRelease* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzAT_WaitCustomInputRelease>();
	}
};
static_assert(alignof(UGzAT_WaitCustomInputRelease) == 0x000008, "Wrong alignment on UGzAT_WaitCustomInputRelease");
static_assert(sizeof(UGzAT_WaitCustomInputRelease) == 0x0000C0, "Wrong size on UGzAT_WaitCustomInputRelease");

// Class G01.GzPerfCPointOfInterest
// 0x0000 (0x02A0 - 0x02A0)
class AGzPerfCPointOfInterest final : public AActor
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzPerfCPointOfInterest">();
	}
	static class AGzPerfCPointOfInterest* GetDefaultObj()
	{
		return GetDefaultObjImpl<AGzPerfCPointOfInterest>();
	}
};
static_assert(alignof(AGzPerfCPointOfInterest) == 0x000008, "Wrong alignment on AGzPerfCPointOfInterest");
static_assert(sizeof(AGzPerfCPointOfInterest) == 0x0002A0, "Wrong size on AGzPerfCPointOfInterest");

// Class G01.GzLimbGlitchFXData
// 0x0058 (0x0088 - 0x0030)
class UGzLimbGlitchFXData final : public UDataAsset
{
public:
	class UNiagaraSystem*                         ArmsGlitchNiagaraSystem;                           // 0x0030(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UNiagaraSystem*                         LegsGlitchNiagaraSystem;                           // 0x0038(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         GlitchScaleDefaultValue;                           // 0x0040(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         GlitchScaleMaxValue;                               // 0x0044(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   GlitchScaleParamName;                              // 0x0048(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         GlitchLostScaleDefaultValue;                       // 0x0050(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         TranslucencySortPriority;                          // 0x0054(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         GlitchLostScaleMaxValue;                           // 0x0058(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   GlitchLostScaleParamName;                          // 0x005C(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DamageWaitTime;                                    // 0x0064(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         GlitchBlendOutTime;                                // 0x0068(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2EAE[0x4];                                     // 0x006C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector2D                              LegsSpriteXY_Scale;                                // 0x0070(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   LegsSpriteXY_ScaleParamName;                       // 0x0080(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzLimbGlitchFXData">();
	}
	static class UGzLimbGlitchFXData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzLimbGlitchFXData>();
	}
};
static_assert(alignof(UGzLimbGlitchFXData) == 0x000008, "Wrong alignment on UGzLimbGlitchFXData");
static_assert(sizeof(UGzLimbGlitchFXData) == 0x000088, "Wrong size on UGzLimbGlitchFXData");
static_assert(offsetof(UGzLimbGlitchFXData, ArmsGlitchNiagaraSystem) == 0x000030, "Member 'UGzLimbGlitchFXData::ArmsGlitchNiagaraSystem' has a wrong offset!");
static_assert(offsetof(UGzLimbGlitchFXData, LegsGlitchNiagaraSystem) == 0x000038, "Member 'UGzLimbGlitchFXData::LegsGlitchNiagaraSystem' has a wrong offset!");
static_assert(offsetof(UGzLimbGlitchFXData, GlitchScaleDefaultValue) == 0x000040, "Member 'UGzLimbGlitchFXData::GlitchScaleDefaultValue' has a wrong offset!");
static_assert(offsetof(UGzLimbGlitchFXData, GlitchScaleMaxValue) == 0x000044, "Member 'UGzLimbGlitchFXData::GlitchScaleMaxValue' has a wrong offset!");
static_assert(offsetof(UGzLimbGlitchFXData, GlitchScaleParamName) == 0x000048, "Member 'UGzLimbGlitchFXData::GlitchScaleParamName' has a wrong offset!");
static_assert(offsetof(UGzLimbGlitchFXData, GlitchLostScaleDefaultValue) == 0x000050, "Member 'UGzLimbGlitchFXData::GlitchLostScaleDefaultValue' has a wrong offset!");
static_assert(offsetof(UGzLimbGlitchFXData, TranslucencySortPriority) == 0x000054, "Member 'UGzLimbGlitchFXData::TranslucencySortPriority' has a wrong offset!");
static_assert(offsetof(UGzLimbGlitchFXData, GlitchLostScaleMaxValue) == 0x000058, "Member 'UGzLimbGlitchFXData::GlitchLostScaleMaxValue' has a wrong offset!");
static_assert(offsetof(UGzLimbGlitchFXData, GlitchLostScaleParamName) == 0x00005C, "Member 'UGzLimbGlitchFXData::GlitchLostScaleParamName' has a wrong offset!");
static_assert(offsetof(UGzLimbGlitchFXData, DamageWaitTime) == 0x000064, "Member 'UGzLimbGlitchFXData::DamageWaitTime' has a wrong offset!");
static_assert(offsetof(UGzLimbGlitchFXData, GlitchBlendOutTime) == 0x000068, "Member 'UGzLimbGlitchFXData::GlitchBlendOutTime' has a wrong offset!");
static_assert(offsetof(UGzLimbGlitchFXData, LegsSpriteXY_Scale) == 0x000070, "Member 'UGzLimbGlitchFXData::LegsSpriteXY_Scale' has a wrong offset!");
static_assert(offsetof(UGzLimbGlitchFXData, LegsSpriteXY_ScaleParamName) == 0x000080, "Member 'UGzLimbGlitchFXData::LegsSpriteXY_ScaleParamName' has a wrong offset!");

// Class G01.GzAT_WaitDelayRepeated
// 0x0038 (0x01A0 - 0x0168)
class UGzAT_WaitDelayRepeated final : public UGzAbilityTaskBase
{
public:
	FMulticastInlineDelegateProperty_             OnRepetitionFinish;                                // 0x0168(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnWaitFinish;                                      // 0x0178(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_2EAF[0x18];                                    // 0x0188(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UGzAT_WaitDelayRepeated* WaitDelayRepeated(class UGameplayAbility* OwningAbility, float Time, int32 RepetionAmount, bool bTriggerOnStart, const uint8 Priority);

	void TaskDelayDelegate__DelegateSignature();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzAT_WaitDelayRepeated">();
	}
	static class UGzAT_WaitDelayRepeated* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzAT_WaitDelayRepeated>();
	}
};
static_assert(alignof(UGzAT_WaitDelayRepeated) == 0x000008, "Wrong alignment on UGzAT_WaitDelayRepeated");
static_assert(sizeof(UGzAT_WaitDelayRepeated) == 0x0001A0, "Wrong size on UGzAT_WaitDelayRepeated");
static_assert(offsetof(UGzAT_WaitDelayRepeated, OnRepetitionFinish) == 0x000168, "Member 'UGzAT_WaitDelayRepeated::OnRepetitionFinish' has a wrong offset!");
static_assert(offsetof(UGzAT_WaitDelayRepeated, OnWaitFinish) == 0x000178, "Member 'UGzAT_WaitDelayRepeated::OnWaitFinish' has a wrong offset!");

// Class G01.GzSequentialEquipTaskConfig
// 0x0010 (0x0088 - 0x0078)
class UGzSequentialEquipTaskConfig final : public UGzAbilityTaskConfig
{
public:
	bool                                          bSkipAnimation;                                    // 0x0078(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EGzEquipTaskType                              EquipType;                                         // 0x0079(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2EB1[0xE];                                     // 0x007A(0x000E)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzSequentialEquipTaskConfig">();
	}
	static class UGzSequentialEquipTaskConfig* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzSequentialEquipTaskConfig>();
	}
};
static_assert(alignof(UGzSequentialEquipTaskConfig) == 0x000008, "Wrong alignment on UGzSequentialEquipTaskConfig");
static_assert(sizeof(UGzSequentialEquipTaskConfig) == 0x000088, "Wrong size on UGzSequentialEquipTaskConfig");
static_assert(offsetof(UGzSequentialEquipTaskConfig, bSkipAnimation) == 0x000078, "Member 'UGzSequentialEquipTaskConfig::bSkipAnimation' has a wrong offset!");
static_assert(offsetof(UGzSequentialEquipTaskConfig, EquipType) == 0x000079, "Member 'UGzSequentialEquipTaskConfig::EquipType' has a wrong offset!");

// Class G01.GzInventoryScreen
// 0x0078 (0x05A0 - 0x0528)
class UGzInventoryScreen : public UGzNavigationWidget
{
public:
	struct FGameplayTagContainer                  ReadOnlyTags;                                      // 0x0528(0x0020)(Edit, NativeAccessSpecifierPrivate)
	struct FGameplayTagContainer                  ReadWriteTags;                                     // 0x0548(0x0020)(Edit, NativeAccessSpecifierPrivate)
	TSubclassOf<class UGzInventoryTooltip>        ItemTooltipWidgetClass;                            // 0x0568(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UGzInventoryTooltip*                    ItemTooltipWidget;                                 // 0x0570(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FVector2D                              AdditionalTooltipOffset;                           // 0x0578(0x0010)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UCanvasPanel*                           RootContainer;                                     // 0x0588(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UCommonUIActionRouterBase*              ActionRouter;                                      // 0x0590(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2EB2[0x8];                                     // 0x0598(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetReadOnlyState();
	void SetReadWriteState();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzInventoryScreen">();
	}
	static class UGzInventoryScreen* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzInventoryScreen>();
	}
};
static_assert(alignof(UGzInventoryScreen) == 0x000008, "Wrong alignment on UGzInventoryScreen");
static_assert(sizeof(UGzInventoryScreen) == 0x0005A0, "Wrong size on UGzInventoryScreen");
static_assert(offsetof(UGzInventoryScreen, ReadOnlyTags) == 0x000528, "Member 'UGzInventoryScreen::ReadOnlyTags' has a wrong offset!");
static_assert(offsetof(UGzInventoryScreen, ReadWriteTags) == 0x000548, "Member 'UGzInventoryScreen::ReadWriteTags' has a wrong offset!");
static_assert(offsetof(UGzInventoryScreen, ItemTooltipWidgetClass) == 0x000568, "Member 'UGzInventoryScreen::ItemTooltipWidgetClass' has a wrong offset!");
static_assert(offsetof(UGzInventoryScreen, ItemTooltipWidget) == 0x000570, "Member 'UGzInventoryScreen::ItemTooltipWidget' has a wrong offset!");
static_assert(offsetof(UGzInventoryScreen, AdditionalTooltipOffset) == 0x000578, "Member 'UGzInventoryScreen::AdditionalTooltipOffset' has a wrong offset!");
static_assert(offsetof(UGzInventoryScreen, RootContainer) == 0x000588, "Member 'UGzInventoryScreen::RootContainer' has a wrong offset!");
static_assert(offsetof(UGzInventoryScreen, ActionRouter) == 0x000590, "Member 'UGzInventoryScreen::ActionRouter' has a wrong offset!");

// Class G01.GzCharacterViewpointCluster
// 0x0050 (0x0300 - 0x02B0)
class AGzCharacterViewpointCluster final : public AGzViewpointClusterBase
{
public:
	TMap<class FName, struct FGzCharacterViewpointData> Viewpoints;                                        // 0x02B0(0x0050)(Edit, DisableEditOnTemplate, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzCharacterViewpointCluster">();
	}
	static class AGzCharacterViewpointCluster* GetDefaultObj()
	{
		return GetDefaultObjImpl<AGzCharacterViewpointCluster>();
	}
};
static_assert(alignof(AGzCharacterViewpointCluster) == 0x000008, "Wrong alignment on AGzCharacterViewpointCluster");
static_assert(sizeof(AGzCharacterViewpointCluster) == 0x000300, "Wrong size on AGzCharacterViewpointCluster");
static_assert(offsetof(AGzCharacterViewpointCluster, Viewpoints) == 0x0002B0, "Member 'AGzCharacterViewpointCluster::Viewpoints' has a wrong offset!");

// Class G01.GzAT_WaitEquip
// 0x0018 (0x0180 - 0x0168)
class UGzAT_WaitEquip final : public UGzAbilityTaskBase
{
public:
	uint8                                         Pad_2EB3[0x10];                                    // 0x0168(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class UGzAT_PlayMontageAndWaitForEvent*       MontageTask;                                       // 0x0178(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UGzAT_WaitEquip* WaitEquipAbilityTask(class UGameplayAbility* OwningAbility, const struct FGameplayEventData& Payload, class UGzAbilityTaskConfig* AbilityTaskConfig);

	void OnWeaponEquiped(const struct FGzInvPocketId& InvPocketId, const class AGzWeaponActor* WeaponActor, bool bEquipped);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzAT_WaitEquip">();
	}
	static class UGzAT_WaitEquip* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzAT_WaitEquip>();
	}
};
static_assert(alignof(UGzAT_WaitEquip) == 0x000008, "Wrong alignment on UGzAT_WaitEquip");
static_assert(sizeof(UGzAT_WaitEquip) == 0x000180, "Wrong size on UGzAT_WaitEquip");
static_assert(offsetof(UGzAT_WaitEquip, MontageTask) == 0x000178, "Member 'UGzAT_WaitEquip::MontageTask' has a wrong offset!");

// Class G01.GzAT_WaitGameplayEventAny
// 0x0048 (0x00C8 - 0x0080)
class UGzAT_WaitGameplayEventAny final : public UAbilityTask
{
public:
	FMulticastInlineDelegateProperty_             EventReceived;                                     // 0x0080(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_2EB5[0x20];                                    // 0x0090(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	class UAbilitySystemComponent*                OptionalExternalTarget;                            // 0x00B0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2EB6[0x10];                                    // 0x00B8(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UGzAT_WaitGameplayEventAny* WaitGameplayEventAny(class UGameplayAbility* OwningAbility, const struct FGameplayTagContainer& EventTags, class AActor* Param_OptionalExternalTarget, bool OnlyTriggerOnce);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzAT_WaitGameplayEventAny">();
	}
	static class UGzAT_WaitGameplayEventAny* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzAT_WaitGameplayEventAny>();
	}
};
static_assert(alignof(UGzAT_WaitGameplayEventAny) == 0x000008, "Wrong alignment on UGzAT_WaitGameplayEventAny");
static_assert(sizeof(UGzAT_WaitGameplayEventAny) == 0x0000C8, "Wrong size on UGzAT_WaitGameplayEventAny");
static_assert(offsetof(UGzAT_WaitGameplayEventAny, EventReceived) == 0x000080, "Member 'UGzAT_WaitGameplayEventAny::EventReceived' has a wrong offset!");
static_assert(offsetof(UGzAT_WaitGameplayEventAny, OptionalExternalTarget) == 0x0000B0, "Member 'UGzAT_WaitGameplayEventAny::OptionalExternalTarget' has a wrong offset!");

// Class G01.GzGA_ThrowableShield_Return
// 0x0008 (0x0510 - 0x0508)
class UGzGA_ThrowableShield_Return : public UGzGameplayAbility
{
public:
	EGzLimbType                                   TargetLimbSlot;                                    // 0x0508(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2EB8[0x7];                                     // 0x0509(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzGA_ThrowableShield_Return">();
	}
	static class UGzGA_ThrowableShield_Return* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzGA_ThrowableShield_Return>();
	}
};
static_assert(alignof(UGzGA_ThrowableShield_Return) == 0x000008, "Wrong alignment on UGzGA_ThrowableShield_Return");
static_assert(sizeof(UGzGA_ThrowableShield_Return) == 0x000510, "Wrong size on UGzGA_ThrowableShield_Return");
static_assert(offsetof(UGzGA_ThrowableShield_Return, TargetLimbSlot) == 0x000508, "Member 'UGzGA_ThrowableShield_Return::TargetLimbSlot' has a wrong offset!");

// Class G01.GzBodyPartAbilityData_Regeneration
// 0x0010 (0x0090 - 0x0080)
class UGzBodyPartAbilityData_Regeneration final : public UGzBodyPartAbilityData
{
public:
	float                                         LifeSpan;                                          // 0x0080(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HealthRegenerationPerSecond;                       // 0x0084(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ArmorRegnerationPerSecond;                         // 0x0088(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2EB9[0x4];                                     // 0x008C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzBodyPartAbilityData_Regeneration">();
	}
	static class UGzBodyPartAbilityData_Regeneration* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzBodyPartAbilityData_Regeneration>();
	}
};
static_assert(alignof(UGzBodyPartAbilityData_Regeneration) == 0x000008, "Wrong alignment on UGzBodyPartAbilityData_Regeneration");
static_assert(sizeof(UGzBodyPartAbilityData_Regeneration) == 0x000090, "Wrong size on UGzBodyPartAbilityData_Regeneration");
static_assert(offsetof(UGzBodyPartAbilityData_Regeneration, LifeSpan) == 0x000080, "Member 'UGzBodyPartAbilityData_Regeneration::LifeSpan' has a wrong offset!");
static_assert(offsetof(UGzBodyPartAbilityData_Regeneration, HealthRegenerationPerSecond) == 0x000084, "Member 'UGzBodyPartAbilityData_Regeneration::HealthRegenerationPerSecond' has a wrong offset!");
static_assert(offsetof(UGzBodyPartAbilityData_Regeneration, ArmorRegnerationPerSecond) == 0x000088, "Member 'UGzBodyPartAbilityData_Regeneration::ArmorRegnerationPerSecond' has a wrong offset!");

// Class G01.GzLimbsUsageStatCollector
// 0x0008 (0x0040 - 0x0038)
class UGzLimbsUsageStatCollector final : public UGzGlobalStatsCollector
{
public:
	uint8                                         Pad_2EBA[0x8];                                     // 0x0038(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzLimbsUsageStatCollector">();
	}
	static class UGzLimbsUsageStatCollector* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzLimbsUsageStatCollector>();
	}
};
static_assert(alignof(UGzLimbsUsageStatCollector) == 0x000008, "Wrong alignment on UGzLimbsUsageStatCollector");
static_assert(sizeof(UGzLimbsUsageStatCollector) == 0x000040, "Wrong size on UGzLimbsUsageStatCollector");

// Class G01.GzAT_WatchSprintConditions
// 0x0030 (0x00B0 - 0x0080)
class UGzAT_WatchSprintConditions final : public UAbilityTask
{
public:
	uint8                                         Pad_2EBB[0x8];                                     // 0x0080(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class AGzCharacter*                           CachedCharacter;                                   // 0x0088(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCameraComponent*                       CharacterCamera;                                   // 0x0090(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCurveFloat*                            MinSpeedCurve;                                     // 0x0098(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FGameplayTag                           EventTag;                                          // 0x00A0(0x0008)(Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bCheckMinSpeed;                                    // 0x00A8(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2EBC[0x3];                                     // 0x00A9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         CurrentActivationTime;                             // 0x00AC(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzAT_WatchSprintConditions">();
	}
	static class UGzAT_WatchSprintConditions* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzAT_WatchSprintConditions>();
	}
};
static_assert(alignof(UGzAT_WatchSprintConditions) == 0x000008, "Wrong alignment on UGzAT_WatchSprintConditions");
static_assert(sizeof(UGzAT_WatchSprintConditions) == 0x0000B0, "Wrong size on UGzAT_WatchSprintConditions");
static_assert(offsetof(UGzAT_WatchSprintConditions, CachedCharacter) == 0x000088, "Member 'UGzAT_WatchSprintConditions::CachedCharacter' has a wrong offset!");
static_assert(offsetof(UGzAT_WatchSprintConditions, CharacterCamera) == 0x000090, "Member 'UGzAT_WatchSprintConditions::CharacterCamera' has a wrong offset!");
static_assert(offsetof(UGzAT_WatchSprintConditions, MinSpeedCurve) == 0x000098, "Member 'UGzAT_WatchSprintConditions::MinSpeedCurve' has a wrong offset!");
static_assert(offsetof(UGzAT_WatchSprintConditions, EventTag) == 0x0000A0, "Member 'UGzAT_WatchSprintConditions::EventTag' has a wrong offset!");
static_assert(offsetof(UGzAT_WatchSprintConditions, bCheckMinSpeed) == 0x0000A8, "Member 'UGzAT_WatchSprintConditions::bCheckMinSpeed' has a wrong offset!");
static_assert(offsetof(UGzAT_WatchSprintConditions, CurrentActivationTime) == 0x0000AC, "Member 'UGzAT_WatchSprintConditions::CurrentActivationTime' has a wrong offset!");

// Class G01.GzHexExtractorMenu
// 0x0040 (0x0568 - 0x0528)
class UGzHexExtractorMenu : public UGzNavigationWidget
{
public:
	FMulticastInlineDelegateProperty_             OnHexConfirmed;                                    // 0x0528(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnHexCanceled;                                     // 0x0538(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	TArray<struct FGzInvItem>                     HexesList;                                         // 0x0548(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	class AGzItemExtractor*                       HexExtractor;                                      // 0x0558(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UGzInvComponent*                        Inventory;                                         // 0x0560(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void Init(class AGzItemExtractor* InHexExtractor);

	int32 GetPlayerCurrency() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzHexExtractorMenu">();
	}
	static class UGzHexExtractorMenu* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzHexExtractorMenu>();
	}
};
static_assert(alignof(UGzHexExtractorMenu) == 0x000008, "Wrong alignment on UGzHexExtractorMenu");
static_assert(sizeof(UGzHexExtractorMenu) == 0x000568, "Wrong size on UGzHexExtractorMenu");
static_assert(offsetof(UGzHexExtractorMenu, OnHexConfirmed) == 0x000528, "Member 'UGzHexExtractorMenu::OnHexConfirmed' has a wrong offset!");
static_assert(offsetof(UGzHexExtractorMenu, OnHexCanceled) == 0x000538, "Member 'UGzHexExtractorMenu::OnHexCanceled' has a wrong offset!");
static_assert(offsetof(UGzHexExtractorMenu, HexesList) == 0x000548, "Member 'UGzHexExtractorMenu::HexesList' has a wrong offset!");
static_assert(offsetof(UGzHexExtractorMenu, HexExtractor) == 0x000558, "Member 'UGzHexExtractorMenu::HexExtractor' has a wrong offset!");
static_assert(offsetof(UGzHexExtractorMenu, Inventory) == 0x000560, "Member 'UGzHexExtractorMenu::Inventory' has a wrong offset!");

// Class G01.GzAT_WatchToggleSprintConditions
// 0x0018 (0x0098 - 0x0080)
class UGzAT_WatchToggleSprintConditions final : public UAbilityTask
{
public:
	FMulticastInlineDelegateProperty_             OnEnded;                                           // 0x0080(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	class AGzCharacter*                           CachedCharacter;                                   // 0x0090(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzAT_WatchToggleSprintConditions">();
	}
	static class UGzAT_WatchToggleSprintConditions* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzAT_WatchToggleSprintConditions>();
	}
};
static_assert(alignof(UGzAT_WatchToggleSprintConditions) == 0x000008, "Wrong alignment on UGzAT_WatchToggleSprintConditions");
static_assert(sizeof(UGzAT_WatchToggleSprintConditions) == 0x000098, "Wrong size on UGzAT_WatchToggleSprintConditions");
static_assert(offsetof(UGzAT_WatchToggleSprintConditions, OnEnded) == 0x000080, "Member 'UGzAT_WatchToggleSprintConditions::OnEnded' has a wrong offset!");
static_assert(offsetof(UGzAT_WatchToggleSprintConditions, CachedCharacter) == 0x000090, "Member 'UGzAT_WatchToggleSprintConditions::CachedCharacter' has a wrong offset!");

// Class G01.GzPreviewPathActor
// 0x01F0 (0x0490 - 0x02A0)
class AGzPreviewPathActor : public AActor
{
public:
	TSubclassOf<class AActor>                     TargetPreviewClass;                                // 0x02A0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bUseSplineMeshes;                                  // 0x02A8(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2EBD[0x7];                                     // 0x02A9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class USplineComponent*                       SplineComponent;                                   // 0x02B0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UStaticMesh*                            PathStaticMesh;                                    // 0x02B8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UMaterialInstance*                      PathMaterial;                                      // 0x02C0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bUseSplineNiagaraSystems;                          // 0x02C8(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2EBE[0x3];                                     // 0x02C9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         NiagaraSystemGapDistance;                          // 0x02CC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         NiagaraSystemDistance_InitialOffset;               // 0x02D0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         RectangleSystemsBetweenBrackets;                   // 0x02D4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UNiagaraSystem*                         SplineNiagaraSystem_Bracket;                       // 0x02D8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UNiagaraSystem*                         SplineNiagaraSystem_Rectangle;                     // 0x02E0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bUseInstancedMeshes;                               // 0x02E8(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2EBF[0x7];                                     // 0x02E9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UStaticMesh*                            InstancedStaticMesh;                               // 0x02F0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UMaterialInstance*                      InstancedPathMaterial;                             // 0x02F8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         InstancedMesh_GapDistance;                         // 0x0300(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         InstancedMesh_InitialOffset;                       // 0x0304(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class AActor*                                 TargetPreviewActor;                                // 0x0308(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FPredictProjectilePathResult           PathDataCache;                                     // 0x0310(0x0140)(BlueprintVisible, BlueprintReadOnly, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	TArray<class USplineMeshComponent*>           SplineMeshes;                                      // 0x0450(0x0010)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, Transient, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	TArray<class UNiagaraComponent*>              NiagaraComponents;                                 // 0x0460(0x0010)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, Transient, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	class UInstancedStaticMeshComponent*          InstancedStaticMeshComponent;                      // 0x0470(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, Transient, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<int32>                                 InstancedMeshComponentIndices;                     // 0x0478(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_2EC0[0x8];                                     // 0x0488(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetPathData(const struct FPredictProjectilePathResult& NewPathData);
	void SetVisible(bool bIsVisible);
	void UpdatePredictedProjectilePath();

	const TArray<class UNiagaraComponent*> GetNiagaraComponents() const;
	struct FVector GetPathEndLocation() const;
	const TArray<class USplineMeshComponent*> GetSplineMeshComponents() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzPreviewPathActor">();
	}
	static class AGzPreviewPathActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<AGzPreviewPathActor>();
	}
};
static_assert(alignof(AGzPreviewPathActor) == 0x000008, "Wrong alignment on AGzPreviewPathActor");
static_assert(sizeof(AGzPreviewPathActor) == 0x000490, "Wrong size on AGzPreviewPathActor");
static_assert(offsetof(AGzPreviewPathActor, TargetPreviewClass) == 0x0002A0, "Member 'AGzPreviewPathActor::TargetPreviewClass' has a wrong offset!");
static_assert(offsetof(AGzPreviewPathActor, bUseSplineMeshes) == 0x0002A8, "Member 'AGzPreviewPathActor::bUseSplineMeshes' has a wrong offset!");
static_assert(offsetof(AGzPreviewPathActor, SplineComponent) == 0x0002B0, "Member 'AGzPreviewPathActor::SplineComponent' has a wrong offset!");
static_assert(offsetof(AGzPreviewPathActor, PathStaticMesh) == 0x0002B8, "Member 'AGzPreviewPathActor::PathStaticMesh' has a wrong offset!");
static_assert(offsetof(AGzPreviewPathActor, PathMaterial) == 0x0002C0, "Member 'AGzPreviewPathActor::PathMaterial' has a wrong offset!");
static_assert(offsetof(AGzPreviewPathActor, bUseSplineNiagaraSystems) == 0x0002C8, "Member 'AGzPreviewPathActor::bUseSplineNiagaraSystems' has a wrong offset!");
static_assert(offsetof(AGzPreviewPathActor, NiagaraSystemGapDistance) == 0x0002CC, "Member 'AGzPreviewPathActor::NiagaraSystemGapDistance' has a wrong offset!");
static_assert(offsetof(AGzPreviewPathActor, NiagaraSystemDistance_InitialOffset) == 0x0002D0, "Member 'AGzPreviewPathActor::NiagaraSystemDistance_InitialOffset' has a wrong offset!");
static_assert(offsetof(AGzPreviewPathActor, RectangleSystemsBetweenBrackets) == 0x0002D4, "Member 'AGzPreviewPathActor::RectangleSystemsBetweenBrackets' has a wrong offset!");
static_assert(offsetof(AGzPreviewPathActor, SplineNiagaraSystem_Bracket) == 0x0002D8, "Member 'AGzPreviewPathActor::SplineNiagaraSystem_Bracket' has a wrong offset!");
static_assert(offsetof(AGzPreviewPathActor, SplineNiagaraSystem_Rectangle) == 0x0002E0, "Member 'AGzPreviewPathActor::SplineNiagaraSystem_Rectangle' has a wrong offset!");
static_assert(offsetof(AGzPreviewPathActor, bUseInstancedMeshes) == 0x0002E8, "Member 'AGzPreviewPathActor::bUseInstancedMeshes' has a wrong offset!");
static_assert(offsetof(AGzPreviewPathActor, InstancedStaticMesh) == 0x0002F0, "Member 'AGzPreviewPathActor::InstancedStaticMesh' has a wrong offset!");
static_assert(offsetof(AGzPreviewPathActor, InstancedPathMaterial) == 0x0002F8, "Member 'AGzPreviewPathActor::InstancedPathMaterial' has a wrong offset!");
static_assert(offsetof(AGzPreviewPathActor, InstancedMesh_GapDistance) == 0x000300, "Member 'AGzPreviewPathActor::InstancedMesh_GapDistance' has a wrong offset!");
static_assert(offsetof(AGzPreviewPathActor, InstancedMesh_InitialOffset) == 0x000304, "Member 'AGzPreviewPathActor::InstancedMesh_InitialOffset' has a wrong offset!");
static_assert(offsetof(AGzPreviewPathActor, TargetPreviewActor) == 0x000308, "Member 'AGzPreviewPathActor::TargetPreviewActor' has a wrong offset!");
static_assert(offsetof(AGzPreviewPathActor, PathDataCache) == 0x000310, "Member 'AGzPreviewPathActor::PathDataCache' has a wrong offset!");
static_assert(offsetof(AGzPreviewPathActor, SplineMeshes) == 0x000450, "Member 'AGzPreviewPathActor::SplineMeshes' has a wrong offset!");
static_assert(offsetof(AGzPreviewPathActor, NiagaraComponents) == 0x000460, "Member 'AGzPreviewPathActor::NiagaraComponents' has a wrong offset!");
static_assert(offsetof(AGzPreviewPathActor, InstancedStaticMeshComponent) == 0x000470, "Member 'AGzPreviewPathActor::InstancedStaticMeshComponent' has a wrong offset!");
static_assert(offsetof(AGzPreviewPathActor, InstancedMeshComponentIndices) == 0x000478, "Member 'AGzPreviewPathActor::InstancedMeshComponentIndices' has a wrong offset!");

// Class G01.GzAT_WingsuitBooster
// 0x0018 (0x0098 - 0x0080)
class UGzAT_WingsuitBooster final : public UAbilityTask
{
public:
	class UGzGA_WingsuitBoost*                    CachedAbility;                                     // 0x0080(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2EC1[0x10];                                    // 0x0088(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzAT_WingsuitBooster">();
	}
	static class UGzAT_WingsuitBooster* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzAT_WingsuitBooster>();
	}
};
static_assert(alignof(UGzAT_WingsuitBooster) == 0x000008, "Wrong alignment on UGzAT_WingsuitBooster");
static_assert(sizeof(UGzAT_WingsuitBooster) == 0x000098, "Wrong size on UGzAT_WingsuitBooster");
static_assert(offsetof(UGzAT_WingsuitBooster, CachedAbility) == 0x000080, "Member 'UGzAT_WingsuitBooster::CachedAbility' has a wrong offset!");

// Class G01.GzLoadoutSettings
// 0x0088 (0x00C0 - 0x0038)
class UGzLoadoutSettings final : public UDeveloperSettings
{
public:
	uint8                                         Pad_2EC2[0x8];                                     // 0x0038(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<EGzLoadoutSlots, TSoftObjectPtr<class UGzItemData>> DefaultSlotItems;                                  // 0x0040(0x0050)(Edit, Config, DisableEditOnInstance, AdvancedDisplay, UObjectWrapper, NativeAccessSpecifierPublic)
	int32                                         DefaultAttachmentStartPrice;                       // 0x0090(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         DefaultAttachmentStepPrice;                        // 0x0094(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         BaseLoadoutCount;                                  // 0x0098(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaxLoadoutCount;                                   // 0x009C(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaxLoadoutNameLength;                              // 0x00A0(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2EC3[0x4];                                     // 0x00A4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	double                                        IncreaseMaxLoadoutCountCost;                       // 0x00A8(0x0008)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MinConsumableQuantity;                             // 0x00B0(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaxConsumableQuantity;                             // 0x00B4(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MinThrowableQuantity;                              // 0x00B8(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaxThrowableQuantity;                              // 0x00BC(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzLoadoutSettings">();
	}
	static class UGzLoadoutSettings* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzLoadoutSettings>();
	}
};
static_assert(alignof(UGzLoadoutSettings) == 0x000008, "Wrong alignment on UGzLoadoutSettings");
static_assert(sizeof(UGzLoadoutSettings) == 0x0000C0, "Wrong size on UGzLoadoutSettings");
static_assert(offsetof(UGzLoadoutSettings, DefaultSlotItems) == 0x000040, "Member 'UGzLoadoutSettings::DefaultSlotItems' has a wrong offset!");
static_assert(offsetof(UGzLoadoutSettings, DefaultAttachmentStartPrice) == 0x000090, "Member 'UGzLoadoutSettings::DefaultAttachmentStartPrice' has a wrong offset!");
static_assert(offsetof(UGzLoadoutSettings, DefaultAttachmentStepPrice) == 0x000094, "Member 'UGzLoadoutSettings::DefaultAttachmentStepPrice' has a wrong offset!");
static_assert(offsetof(UGzLoadoutSettings, BaseLoadoutCount) == 0x000098, "Member 'UGzLoadoutSettings::BaseLoadoutCount' has a wrong offset!");
static_assert(offsetof(UGzLoadoutSettings, MaxLoadoutCount) == 0x00009C, "Member 'UGzLoadoutSettings::MaxLoadoutCount' has a wrong offset!");
static_assert(offsetof(UGzLoadoutSettings, MaxLoadoutNameLength) == 0x0000A0, "Member 'UGzLoadoutSettings::MaxLoadoutNameLength' has a wrong offset!");
static_assert(offsetof(UGzLoadoutSettings, IncreaseMaxLoadoutCountCost) == 0x0000A8, "Member 'UGzLoadoutSettings::IncreaseMaxLoadoutCountCost' has a wrong offset!");
static_assert(offsetof(UGzLoadoutSettings, MinConsumableQuantity) == 0x0000B0, "Member 'UGzLoadoutSettings::MinConsumableQuantity' has a wrong offset!");
static_assert(offsetof(UGzLoadoutSettings, MaxConsumableQuantity) == 0x0000B4, "Member 'UGzLoadoutSettings::MaxConsumableQuantity' has a wrong offset!");
static_assert(offsetof(UGzLoadoutSettings, MinThrowableQuantity) == 0x0000B8, "Member 'UGzLoadoutSettings::MinThrowableQuantity' has a wrong offset!");
static_assert(offsetof(UGzLoadoutSettings, MaxThrowableQuantity) == 0x0000BC, "Member 'UGzLoadoutSettings::MaxThrowableQuantity' has a wrong offset!");

// Class G01.GzGameState
// 0x02E0 (0x05D8 - 0x02F8)
class AGzGameState : public AGameStateBase
{
public:
	FMulticastInlineDelegateProperty_             OnMatchResultReceived;                             // 0x02F8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	class UGzGameModeSettings*                    GameModeSettings;                                  // 0x0308(0x0008)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 MatchID;                                           // 0x0310(0x0010)(Net, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGzRuleSet                             RuleSet;                                           // 0x0320(0x0040)(Net, Transient, NativeAccessSpecifierPublic)
	TArray<class AGzGameModeSubsystem*>           LocalSubsystems;                                   // 0x0360(0x0010)(Net, ZeroConstructor, RepNotify, NativeAccessSpecifierPublic)
	uint8                                         Pad_2EC4[0x18];                                    // 0x0370(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         ServerFPS;                                         // 0x0388(0x0004)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2EC5[0x4];                                     // 0x038C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<uint64, struct FGzBreakableConnection>   BreakableConnectivityMap;                          // 0x0390(0x0050)(Transient, NativeAccessSpecifierPublic)
	uint8                                         Pad_2EC6[0x8];                                     // 0x03E0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<int32, class AGzPlayerState*>            PlayerIdToPlayerState;                             // 0x03E8(0x0050)(Protected, NativeAccessSpecifierProtected)
	TMap<class FString, class AGzPlayerState*>    PlayFabIdToPlayerState;                            // 0x0438(0x0050)(Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_2EC7[0x58];                                    // 0x0488(0x0058)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 ConsoleMatchId;                                    // 0x04E0(0x0010)(Net, ZeroConstructor, RepNotify, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2EC8[0xE8];                                    // 0x04F0(0x00E8)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Multicast_SetMatchEndResult(const struct FGzMatchEndResult& Result);
	void OnRep_ConsoleMatchInfo();
	void OnRep_GameModeSettings();
	void OnRep_LocalSubsystem();

	class AGzGameModeSubsystem* FindLocalSubsystem(TSubclassOf<class AGzGameModeSubsystem> SubsystemClass) const;
	class AGzPlayerState* FindPlayerState(int32 PlayerId) const;
	const struct FGzMatchEndResult GetMatchEndResult() const;
	class FString GetMatchId() const;
	void GetPlayerStates(TArray<class AGzPlayerState*>* PlayerStates) const;
	bool HasMatchEndResult() const;
	bool IsGameRuleEnabled(const struct FGameplayTag& Rule) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzGameState">();
	}
	static class AGzGameState* GetDefaultObj()
	{
		return GetDefaultObjImpl<AGzGameState>();
	}
};
static_assert(alignof(AGzGameState) == 0x000008, "Wrong alignment on AGzGameState");
static_assert(sizeof(AGzGameState) == 0x0005D8, "Wrong size on AGzGameState");
static_assert(offsetof(AGzGameState, OnMatchResultReceived) == 0x0002F8, "Member 'AGzGameState::OnMatchResultReceived' has a wrong offset!");
static_assert(offsetof(AGzGameState, GameModeSettings) == 0x000308, "Member 'AGzGameState::GameModeSettings' has a wrong offset!");
static_assert(offsetof(AGzGameState, MatchID) == 0x000310, "Member 'AGzGameState::MatchID' has a wrong offset!");
static_assert(offsetof(AGzGameState, RuleSet) == 0x000320, "Member 'AGzGameState::RuleSet' has a wrong offset!");
static_assert(offsetof(AGzGameState, LocalSubsystems) == 0x000360, "Member 'AGzGameState::LocalSubsystems' has a wrong offset!");
static_assert(offsetof(AGzGameState, ServerFPS) == 0x000388, "Member 'AGzGameState::ServerFPS' has a wrong offset!");
static_assert(offsetof(AGzGameState, BreakableConnectivityMap) == 0x000390, "Member 'AGzGameState::BreakableConnectivityMap' has a wrong offset!");
static_assert(offsetof(AGzGameState, PlayerIdToPlayerState) == 0x0003E8, "Member 'AGzGameState::PlayerIdToPlayerState' has a wrong offset!");
static_assert(offsetof(AGzGameState, PlayFabIdToPlayerState) == 0x000438, "Member 'AGzGameState::PlayFabIdToPlayerState' has a wrong offset!");
static_assert(offsetof(AGzGameState, ConsoleMatchId) == 0x0004E0, "Member 'AGzGameState::ConsoleMatchId' has a wrong offset!");

// Class G01.GzHideoutGameState
// 0x0000 (0x05D8 - 0x05D8)
class AGzHideoutGameState final : public AGzGameState
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzHideoutGameState">();
	}
	static class AGzHideoutGameState* GetDefaultObj()
	{
		return GetDefaultObjImpl<AGzHideoutGameState>();
	}
};
static_assert(alignof(AGzHideoutGameState) == 0x000008, "Wrong alignment on AGzHideoutGameState");
static_assert(sizeof(AGzHideoutGameState) == 0x0005D8, "Wrong size on AGzHideoutGameState");

// Class G01.GzAT_WingsuitWaitForLand
// 0x0030 (0x00B0 - 0x0080)
class UGzAT_WingsuitWaitForLand final : public UAbilityTask
{
public:
	uint8                                         Pad_2ECB[0x30];                                    // 0x0080(0x0030)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzAT_WingsuitWaitForLand">();
	}
	static class UGzAT_WingsuitWaitForLand* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzAT_WingsuitWaitForLand>();
	}
};
static_assert(alignof(UGzAT_WingsuitWaitForLand) == 0x000008, "Wrong alignment on UGzAT_WingsuitWaitForLand");
static_assert(sizeof(UGzAT_WingsuitWaitForLand) == 0x0000B0, "Wrong size on UGzAT_WingsuitWaitForLand");

// Class G01.GzMTW_Base
// 0x0018 (0x02F8 - 0x02E0)
class UGzMTW_Base : public UUserWidget
{
public:
	FMulticastInlineDelegateProperty_             OnActivated;                                       // 0x02E0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	bool                                          bActive;                                           // 0x02F0(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2ECC[0x7];                                     // 0x02F1(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void InjectTimer(class UGzMTW_Timer* CurrentTimer);
	void OnBecomeActive();
	void OnBecomeInactive();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzMTW_Base">();
	}
	static class UGzMTW_Base* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzMTW_Base>();
	}
};
static_assert(alignof(UGzMTW_Base) == 0x000008, "Wrong alignment on UGzMTW_Base");
static_assert(sizeof(UGzMTW_Base) == 0x0002F8, "Wrong size on UGzMTW_Base");
static_assert(offsetof(UGzMTW_Base, OnActivated) == 0x0002E0, "Member 'UGzMTW_Base::OnActivated' has a wrong offset!");
static_assert(offsetof(UGzMTW_Base, bActive) == 0x0002F0, "Member 'UGzMTW_Base::bActive' has a wrong offset!");

// Class G01.GzMTW_Timer
// 0x0018 (0x0310 - 0x02F8)
class UGzMTW_Timer final : public UGzMTW_Base
{
public:
	class UGzTimerCondition*                      TimerCondition;                                    // 0x02F8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Time;                                              // 0x0300(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2ECD[0x4];                                     // 0x0304(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class AGameStateBase*                         CachedGameState;                                   // 0x0308(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	void OnStateChanged_BP(EGzConditionState NewState);
	void OnTimerStateChanged(EGzConditionState NewState);

	float GetRemainingTime() const;
	bool IsInActiveState(const EGzConditionState State) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzMTW_Timer">();
	}
	static class UGzMTW_Timer* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzMTW_Timer>();
	}
};
static_assert(alignof(UGzMTW_Timer) == 0x000008, "Wrong alignment on UGzMTW_Timer");
static_assert(sizeof(UGzMTW_Timer) == 0x000310, "Wrong size on UGzMTW_Timer");
static_assert(offsetof(UGzMTW_Timer, TimerCondition) == 0x0002F8, "Member 'UGzMTW_Timer::TimerCondition' has a wrong offset!");
static_assert(offsetof(UGzMTW_Timer, Time) == 0x000300, "Member 'UGzMTW_Timer::Time' has a wrong offset!");
static_assert(offsetof(UGzMTW_Timer, CachedGameState) == 0x000308, "Member 'UGzMTW_Timer::CachedGameState' has a wrong offset!");

// Class G01.GzBotFarmSubsystem
// 0x0018 (0x02B8 - 0x02A0)
class AGzBotFarmSubsystem : public AGzGameModeSubsystem
{
public:
	TSubclassOf<class AGzShadowBot>               ShadowBotClass;                                    // 0x02A0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class AGzShadowBot*                           ShadowBotRef;                                      // 0x02A8(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2ECE[0x8];                                     // 0x02B0(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzBotFarmSubsystem">();
	}
	static class AGzBotFarmSubsystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<AGzBotFarmSubsystem>();
	}
};
static_assert(alignof(AGzBotFarmSubsystem) == 0x000008, "Wrong alignment on AGzBotFarmSubsystem");
static_assert(sizeof(AGzBotFarmSubsystem) == 0x0002B8, "Wrong size on AGzBotFarmSubsystem");
static_assert(offsetof(AGzBotFarmSubsystem, ShadowBotClass) == 0x0002A0, "Member 'AGzBotFarmSubsystem::ShadowBotClass' has a wrong offset!");
static_assert(offsetof(AGzBotFarmSubsystem, ShadowBotRef) == 0x0002A8, "Member 'AGzBotFarmSubsystem::ShadowBotRef' has a wrong offset!");

// Class G01.GzAudioAnimNotifyState
// 0x0018 (0x0048 - 0x0030)
class UGzAudioAnimNotifyState final : public UAnimNotifyState
{
public:
	class UAkAudioEvent*                          StartEvent;                                        // 0x0030(0x0008)(Edit, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAkAudioEvent*                          EndEvent;                                          // 0x0038(0x0008)(Edit, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2ECF[0x8];                                     // 0x0040(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzAudioAnimNotifyState">();
	}
	static class UGzAudioAnimNotifyState* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzAudioAnimNotifyState>();
	}
};
static_assert(alignof(UGzAudioAnimNotifyState) == 0x000008, "Wrong alignment on UGzAudioAnimNotifyState");
static_assert(sizeof(UGzAudioAnimNotifyState) == 0x000048, "Wrong size on UGzAudioAnimNotifyState");
static_assert(offsetof(UGzAudioAnimNotifyState, StartEvent) == 0x000030, "Member 'UGzAudioAnimNotifyState::StartEvent' has a wrong offset!");
static_assert(offsetof(UGzAudioAnimNotifyState, EndEvent) == 0x000038, "Member 'UGzAudioAnimNotifyState::EndEvent' has a wrong offset!");

// Class G01.GzStripePaymentProviderComponent
// 0x0050 (0x0108 - 0x00B8)
class UGzStripePaymentProviderComponent final : public UGzPaymentProviderComponent
{
public:
	uint8                                         Pad_2ED0[0x50];                                    // 0x00B8(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzStripePaymentProviderComponent">();
	}
	static class UGzStripePaymentProviderComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzStripePaymentProviderComponent>();
	}
};
static_assert(alignof(UGzStripePaymentProviderComponent) == 0x000008, "Wrong alignment on UGzStripePaymentProviderComponent");
static_assert(sizeof(UGzStripePaymentProviderComponent) == 0x000108, "Wrong size on UGzStripePaymentProviderComponent");

// Class G01.GzAudioAnnouncer
// 0x0150 (0x03F0 - 0x02A0)
class AGzAudioAnnouncer : public AInfo
{
public:
	uint8                                         Pad_2ED1[0x8];                                     // 0x02A0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         VoiceLineDelay;                                    // 0x02A8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         VoiceLineQueueSize;                                // 0x02AC(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TMap<struct FGameplayTag, float>              VoiceLineDelayOverride;                            // 0x02B0(0x0050)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	TMap<struct FGameplayTag, struct FGzPingVoiceLineData> StartVoiceLineData;                                // 0x0300(0x0050)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	TMap<struct FGameplayTag, struct FGzPingVoiceLineData> EndVoiceLineData;                                  // 0x0350(0x0050)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2ED2[0x50];                                    // 0x03A0(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnAnnouncementEnded(const class AActor* Actor, class UAkAudioEvent* Event, const struct FGameplayTag& VoiceLineTag);
	bool PostAnnouncement(const struct FGameplayTag& VoiceLineTag, bool bStarted, const TDelegate<void()>& AnnouncementEndDelegate);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzAudioAnnouncer">();
	}
	static class AGzAudioAnnouncer* GetDefaultObj()
	{
		return GetDefaultObjImpl<AGzAudioAnnouncer>();
	}
};
static_assert(alignof(AGzAudioAnnouncer) == 0x000008, "Wrong alignment on AGzAudioAnnouncer");
static_assert(sizeof(AGzAudioAnnouncer) == 0x0003F0, "Wrong size on AGzAudioAnnouncer");
static_assert(offsetof(AGzAudioAnnouncer, VoiceLineDelay) == 0x0002A8, "Member 'AGzAudioAnnouncer::VoiceLineDelay' has a wrong offset!");
static_assert(offsetof(AGzAudioAnnouncer, VoiceLineQueueSize) == 0x0002AC, "Member 'AGzAudioAnnouncer::VoiceLineQueueSize' has a wrong offset!");
static_assert(offsetof(AGzAudioAnnouncer, VoiceLineDelayOverride) == 0x0002B0, "Member 'AGzAudioAnnouncer::VoiceLineDelayOverride' has a wrong offset!");
static_assert(offsetof(AGzAudioAnnouncer, StartVoiceLineData) == 0x000300, "Member 'AGzAudioAnnouncer::StartVoiceLineData' has a wrong offset!");
static_assert(offsetof(AGzAudioAnnouncer, EndVoiceLineData) == 0x000350, "Member 'AGzAudioAnnouncer::EndVoiceLineData' has a wrong offset!");

// Class G01.GzStepSoundAnimNotify
// 0x0008 (0x0050 - 0x0048)
class UGzStepSoundAnimNotify final : public UGzSoundAnimNotifyBase
{
public:
	uint8                                         Pad_2ED5[0x8];                                     // 0x0048(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzStepSoundAnimNotify">();
	}
	static class UGzStepSoundAnimNotify* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzStepSoundAnimNotify>();
	}
};
static_assert(alignof(UGzStepSoundAnimNotify) == 0x000008, "Wrong alignment on UGzStepSoundAnimNotify");
static_assert(sizeof(UGzStepSoundAnimNotify) == 0x000050, "Wrong size on UGzStepSoundAnimNotify");

// Class G01.GzCheatManager
// 0x00C8 (0x0150 - 0x0088)
class UGzCheatManager : public UCheatManager
{
public:
	class UInputMappingContext*                   DebugFreeCamInputMapping;                          // 0x0088(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UInputAction*                           DebugFreeCamZoomAction;                            // 0x0090(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ZoomSpeed;                                         // 0x0098(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2ED6[0x64];                                    // 0x009C(0x0064)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<class UDataLayerAsset*, EDataLayerRuntimeState> PreviousDataLayerStates;                           // 0x0100(0x0050)(Transient, NativeAccessSpecifierPrivate)

public:
	void AddConsumable(const class FString& ItemName);
	void AddCyberLimb(const class FString& CyberLimbName);
	void AddMeNPCTeamFriend(const int32 TeamID);
	void AddPlayerXp(int32 Xp);
	void AddWeapon(const class FString& WeaponName);
	void AddWidget(const class FString& WidgetClassName);
	void ChangeTeam(int32 NewTeamIndex);
	void ClientTeleportPlayerToMe();
	void CompleteSelectedJob();
	void DebugGetHit(float DamageAmount, const struct FVector& TraceStartOffset, const struct FVector& TraceEndOffset, bool bVisualizeTrace);
	void DebugGetHitFromTop(float DamageAmount, bool bVisualizeTrace);
	void DisableServerNetProfile();
	void DisableStall();
	void DismissAllNotifications();
	void DrawCoversInOrigin(const float& Extent);
	void DropCurrentWeapon();
	void EnableServerNetProfile();
	void EnableStall(float MinInterval, float MaxInterval, float MinStallTime, float MaxStallTime);
	void FullAmmo();
	void Immortal();
	void Interact();
	void JoinOnlineMatch(const class FString& NetworkAddress);
	void KillAll();
	void KillMe();
	void KillNpc(const class FString& Param_Name);
	void KnockMe();
	void MarkAllReady();
	void PublishLoadouts();
	void PublishWeaponConfigurations();
	void PullAvailableAssignments();
	void RemoveMeNPCTeamFriend(const int32 TeamID);
	void RepeatInteract(int32 RepeatCount);
	void ResetAllJobs();
	void ResetLimbCharges();
	void ResetPlayerAccount();
	void ResetProgression();
	void RespawnMe();
	void RestartServer();
	void ReviveMe();
	void SetAICoversDebug(bool bEnabled, float Radius);
	void SetAILODsEnabled(bool bEnabled);
	void SetBotFarmMode(bool bEnable);
	void SetDataLayerPreset(const class FName& PresetName);
	void SetDebugFreeCam(bool bEnable);
	void SetGzCheatsEnabled(bool bEnabled);
	void SetJetpackHealth(float Health);
	void SetMaxNPCDeathMatchMode(int32 Count);
	void SetMovementSpeed(float Value);
	void SetQuitGameTime(float Value);
	void SetReadyToStart(bool bReadyToStart);
	void SetRespawnInMatch(bool bRespawnPlayers, bool bRespawnAfterZoneActivation);
	void SetRTPCValue(const class FString& RTPC, float NewValue);
	void SetServerFPSAccTime(float FPSAccTime);
	void SetTargetFpsClient(float TargetFps);
	void SetTargetFpsServer(float TargetFps);
	void SetTeamChangeUnlocked(bool bUnlocked);
	void SetVoiceState(bool Value);
	void ShowAICharacterOutline(uint8 InValue);
	void ShowCheats();
	void ShowGameNotification(const class FName& TestNotificationID);
	void ShowPlayerNames(bool bShow);
	void SimulateKeyAxis(const struct FKey& Key, float Delta);
	void SimulateKeyPressed(const struct FKey& Key);
	void SimulateKeyPressedAndReleased(const struct FKey& Key, float Delay);
	void SimulateKeyReleased(const struct FKey& Key);
	void SpawnAI(const class FString& Param_Name, int32 TeamID, int32 Count);
	void SpawnMirrorBreaker();
	void SpawnNPC(int32 Count, float Radius, int32 TeamID, int32 MaxTeamSize);
	void StartRecording();
	void StartVisualLogOnServer();
	void StopRecording();
	void StopVisualLogOnServer();
	void SweepShape(uint8 ShapeType, float ShapeRadius, float ShapeHeight, bool bIgnoreCharacter, float StartX, float StartY, float StartZ, float EndX, float EndY, float EndZ);
	void SweepShapeByDelta(uint8 ShapeType, float ShapeRadius, float ShapeHeight, bool bIgnoreCharacter, float StartX, float StartY, float StartZ, float DeltaX, float DeltaY, float DeltaZ);
	void TearOffLimb(const class FString& Param_Name, const bool bForced);
	void TeleportToCoordinates(float X, float Y, float Z);
	void TeleportToNextAICharacter();
	void TeleportToNextPlayer();
	void ToggleCharacterCustomizationDebug();
	void TriggerServerCrash();
	void TryServerPause();
	void ZoomDebugFreeCamAction(const struct FInputActionValue& Instance);

	void AddBlockchainCoins(double CurrencyAmount) const;
	void EnterOfflineSession(const class FString& LevelName) const;
	void ExitOfflineSession() const;
	void KickMe() const;
	void Logout() const;
	void PostVoiceLine(const class FString& EventName) const;
	void SetLeglessState(bool bEnable) const;
	void SetQuickOrderCooldown(const float Time) const;
	void SetRespawnCheatUnlocked(bool bUnlocked) const;
	void SetVirtualCurrency(uint8 CurrencyType, int32 CurrencyAmount) const;
	void ShowCurrentCoordinates() const;
	void SubtractBlockchainCoins(double CurrencyAmount) const;
	void TriggerMotionInput() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzCheatManager">();
	}
	static class UGzCheatManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzCheatManager>();
	}
};
static_assert(alignof(UGzCheatManager) == 0x000008, "Wrong alignment on UGzCheatManager");
static_assert(sizeof(UGzCheatManager) == 0x000150, "Wrong size on UGzCheatManager");
static_assert(offsetof(UGzCheatManager, DebugFreeCamInputMapping) == 0x000088, "Member 'UGzCheatManager::DebugFreeCamInputMapping' has a wrong offset!");
static_assert(offsetof(UGzCheatManager, DebugFreeCamZoomAction) == 0x000090, "Member 'UGzCheatManager::DebugFreeCamZoomAction' has a wrong offset!");
static_assert(offsetof(UGzCheatManager, ZoomSpeed) == 0x000098, "Member 'UGzCheatManager::ZoomSpeed' has a wrong offset!");
static_assert(offsetof(UGzCheatManager, PreviousDataLayerStates) == 0x000100, "Member 'UGzCheatManager::PreviousDataLayerStates' has a wrong offset!");

// Class G01.GzAudioControllerComponent
// 0x06D0 (0x0778 - 0x00A8)
class UGzAudioControllerComponent : public UControllerComponent
{
public:
	FMulticastInlineDelegateProperty_             OnAudioMarkerHit;                                  // 0x00A8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             VoiceLineEndEvents;                                // 0x00B8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMap<struct FGameplayTag, struct FGzSoundStateKey> GameStageToSoundState;                             // 0x00C8(0x0050)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	TMap<EGzFlowState, struct FGzSoundStateKey>   FlowStateToSoundState;                             // 0x0118(0x0050)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	struct FGzPingSoundData                       DefaultPingSound;                                  // 0x0168(0x0020)(Edit, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPrivate)
	TMap<EGzPingTarget, struct FGzPingSoundData>  PingTargetSoundOverride;                           // 0x0188(0x0050)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	TMap<struct FGameplayTag, struct FGzPingVoiceLineData> PingTypeVoiceLineOverride;                         // 0x01D8(0x0050)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	TMap<EGzPingTarget, struct FGzPingVoiceLineData> PingTargetVoiceLineOverride;                       // 0x0228(0x0050)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	struct FGzPingVoiceLineData                   PingCancelVoiceLine;                               // 0x0278(0x0010)(Edit, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPrivate)
	struct FGzPingVoiceLineData                   PingAgreedVoiceLine;                               // 0x0288(0x0010)(Edit, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPrivate)
	struct FGzPingVoiceLineData                   PingDisagreedVoiceLine;                            // 0x0298(0x0010)(Edit, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPrivate)
	TMap<EGzConnectionState, struct FGameplayTag> TeammateConnectionStateVoiceLineTags;              // 0x02A8(0x0050)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	class UAkAudioEvent*                          HitResponseEvent;                                  // 0x02F8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TMap<struct FGameplayTag, class UAkSwitchValue*> DamageSourceSwitches;                              // 0x0300(0x0050)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	TMap<EGzHitResponseType, class UAkSwitchValue*> HitResponseTypeSwitches;                           // 0x0350(0x0050)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	class UAkSwitchValue*                         CriticalKillSwitch;                                // 0x03A0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UAkSwitchValue*                         HitPlayerSwitch;                                   // 0x03A8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UAkSwitchValue*                         DefaultDamageSourceSwitch;                         // 0x03B0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UAkSwitchValue*                         DefaultHitResponseTypeSwitch;                      // 0x03B8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UAkSwitchValue*                         DefaultHitObjectSwitch;                            // 0x03C0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UAkSwitchValue*                         DefaultReceivingDamageSwitch;                      // 0x03C8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TMap<struct FGameplayTag, class UAkSwitchValue*> ReceivingDamageSwitches;                           // 0x03D0(0x0050)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	class UAkRtpc*                                DamageAmountRtpc;                                  // 0x0420(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UAkAudioEvent*                          LocalAmbientEvent;                                 // 0x0428(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FGameplayAttribute                     ArmorAttribute;                                    // 0x0430(0x0038)(Edit, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FGameplayAttribute                     MaxArmorAttribute;                                 // 0x0468(0x0038)(Edit, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         LowArmorValue;                                     // 0x04A0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2EE4[0x4];                                     // 0x04A4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<EGzAudioSettingsChangeType, class UGzSettingsChangeAction*> AudioSettingsChangeActions;                        // 0x04A8(0x0050)(Edit, ExportObject, DisableEditOnInstance, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	class UGzEnvironmentZoneComponent*            CachedEnvZone;                                     // 0x04F8(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UAkComponent*                           OwnerAkComponent;                                  // 0x0500(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UGzEnvironmentZoneManagerComponent*     ListeningZoneManager;                              // 0x0508(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class APawn*                                  CachedViewTarget;                                  // 0x0510(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class AActor*                                 DistanceProbe;                                     // 0x0518(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSet<class UGzEnvironmentZoneComponent*>      EnvironmentZones;                                  // 0x0520(0x0050)(ExportObject, Transient, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	TMap<uint32, struct FGzAudioHintData>         ActiveAudioHints;                                  // 0x0570(0x0050)(Transient, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	TMap<class AActor*, struct FGzVoiceLineData>  ActiveVoiceLines;                                  // 0x05C0(0x0050)(Transient, NativeAccessSpecifierPrivate)
	TMap<class AActor*, struct FGzVoiceLineDataArray> VoiceLineQueue;                                    // 0x0610(0x0050)(Transient, NativeAccessSpecifierPrivate)
	TMap<class AActor*, struct FGzVoiceLineTimeoutData> ActorVoiceLineTimeOutData;                         // 0x0660(0x0050)(Transient, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2EE5[0xC8];                                    // 0x06B0(0x00C8)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	struct FGameplayTag GetMissionVoiceLineTag(class AGzMission* InMission, EMissionState MissionState);
	void OnMatchStateChanged();
	void OnMessageReceived(const class UGzGameMessage* Message);
	void OnMissionStateChanged(class AGzMission* Mission, const struct FGzMissionState& OldState, const struct FGzMissionState& MissionState);
	void OnPingAdded(const struct FGzPingData& PingData);
	void OnPingAgreementChanged(class AGzPlayerState* PlayerState, const struct FGzPingData& PingData, bool bAgree);
	void OnPingCanceled(const struct FGzPingData& PingData);
	void OnTeamDied(class AGzTeam* DefeatedTeam);
	void OnViewTargetChanged(class APawn* NewViewTarget);
	void OnVoiceLineEventHit(EAkCallbackType CallbackType, class UAkCallbackInfo* CallbackInfo);
	bool PostCharacterActionVoiceLine(class AActor* Actor, class UAkAudioEvent* Event, const struct FGameplayTag& VoiceLineTag, EGzVoiceLinePriority Priority);
	int32 PostLocalAkEvent(class UAkAudioEvent* Event);
	bool PostVoiceLine(class AActor* Actor, class UAkAudioEvent* Event, const struct FGameplayTag& VoiceLineTag, EGzVoiceLinePriority Priority);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzAudioControllerComponent">();
	}
	static class UGzAudioControllerComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzAudioControllerComponent>();
	}
};
static_assert(alignof(UGzAudioControllerComponent) == 0x000008, "Wrong alignment on UGzAudioControllerComponent");
static_assert(sizeof(UGzAudioControllerComponent) == 0x000778, "Wrong size on UGzAudioControllerComponent");
static_assert(offsetof(UGzAudioControllerComponent, OnAudioMarkerHit) == 0x0000A8, "Member 'UGzAudioControllerComponent::OnAudioMarkerHit' has a wrong offset!");
static_assert(offsetof(UGzAudioControllerComponent, VoiceLineEndEvents) == 0x0000B8, "Member 'UGzAudioControllerComponent::VoiceLineEndEvents' has a wrong offset!");
static_assert(offsetof(UGzAudioControllerComponent, GameStageToSoundState) == 0x0000C8, "Member 'UGzAudioControllerComponent::GameStageToSoundState' has a wrong offset!");
static_assert(offsetof(UGzAudioControllerComponent, FlowStateToSoundState) == 0x000118, "Member 'UGzAudioControllerComponent::FlowStateToSoundState' has a wrong offset!");
static_assert(offsetof(UGzAudioControllerComponent, DefaultPingSound) == 0x000168, "Member 'UGzAudioControllerComponent::DefaultPingSound' has a wrong offset!");
static_assert(offsetof(UGzAudioControllerComponent, PingTargetSoundOverride) == 0x000188, "Member 'UGzAudioControllerComponent::PingTargetSoundOverride' has a wrong offset!");
static_assert(offsetof(UGzAudioControllerComponent, PingTypeVoiceLineOverride) == 0x0001D8, "Member 'UGzAudioControllerComponent::PingTypeVoiceLineOverride' has a wrong offset!");
static_assert(offsetof(UGzAudioControllerComponent, PingTargetVoiceLineOverride) == 0x000228, "Member 'UGzAudioControllerComponent::PingTargetVoiceLineOverride' has a wrong offset!");
static_assert(offsetof(UGzAudioControllerComponent, PingCancelVoiceLine) == 0x000278, "Member 'UGzAudioControllerComponent::PingCancelVoiceLine' has a wrong offset!");
static_assert(offsetof(UGzAudioControllerComponent, PingAgreedVoiceLine) == 0x000288, "Member 'UGzAudioControllerComponent::PingAgreedVoiceLine' has a wrong offset!");
static_assert(offsetof(UGzAudioControllerComponent, PingDisagreedVoiceLine) == 0x000298, "Member 'UGzAudioControllerComponent::PingDisagreedVoiceLine' has a wrong offset!");
static_assert(offsetof(UGzAudioControllerComponent, TeammateConnectionStateVoiceLineTags) == 0x0002A8, "Member 'UGzAudioControllerComponent::TeammateConnectionStateVoiceLineTags' has a wrong offset!");
static_assert(offsetof(UGzAudioControllerComponent, HitResponseEvent) == 0x0002F8, "Member 'UGzAudioControllerComponent::HitResponseEvent' has a wrong offset!");
static_assert(offsetof(UGzAudioControllerComponent, DamageSourceSwitches) == 0x000300, "Member 'UGzAudioControllerComponent::DamageSourceSwitches' has a wrong offset!");
static_assert(offsetof(UGzAudioControllerComponent, HitResponseTypeSwitches) == 0x000350, "Member 'UGzAudioControllerComponent::HitResponseTypeSwitches' has a wrong offset!");
static_assert(offsetof(UGzAudioControllerComponent, CriticalKillSwitch) == 0x0003A0, "Member 'UGzAudioControllerComponent::CriticalKillSwitch' has a wrong offset!");
static_assert(offsetof(UGzAudioControllerComponent, HitPlayerSwitch) == 0x0003A8, "Member 'UGzAudioControllerComponent::HitPlayerSwitch' has a wrong offset!");
static_assert(offsetof(UGzAudioControllerComponent, DefaultDamageSourceSwitch) == 0x0003B0, "Member 'UGzAudioControllerComponent::DefaultDamageSourceSwitch' has a wrong offset!");
static_assert(offsetof(UGzAudioControllerComponent, DefaultHitResponseTypeSwitch) == 0x0003B8, "Member 'UGzAudioControllerComponent::DefaultHitResponseTypeSwitch' has a wrong offset!");
static_assert(offsetof(UGzAudioControllerComponent, DefaultHitObjectSwitch) == 0x0003C0, "Member 'UGzAudioControllerComponent::DefaultHitObjectSwitch' has a wrong offset!");
static_assert(offsetof(UGzAudioControllerComponent, DefaultReceivingDamageSwitch) == 0x0003C8, "Member 'UGzAudioControllerComponent::DefaultReceivingDamageSwitch' has a wrong offset!");
static_assert(offsetof(UGzAudioControllerComponent, ReceivingDamageSwitches) == 0x0003D0, "Member 'UGzAudioControllerComponent::ReceivingDamageSwitches' has a wrong offset!");
static_assert(offsetof(UGzAudioControllerComponent, DamageAmountRtpc) == 0x000420, "Member 'UGzAudioControllerComponent::DamageAmountRtpc' has a wrong offset!");
static_assert(offsetof(UGzAudioControllerComponent, LocalAmbientEvent) == 0x000428, "Member 'UGzAudioControllerComponent::LocalAmbientEvent' has a wrong offset!");
static_assert(offsetof(UGzAudioControllerComponent, ArmorAttribute) == 0x000430, "Member 'UGzAudioControllerComponent::ArmorAttribute' has a wrong offset!");
static_assert(offsetof(UGzAudioControllerComponent, MaxArmorAttribute) == 0x000468, "Member 'UGzAudioControllerComponent::MaxArmorAttribute' has a wrong offset!");
static_assert(offsetof(UGzAudioControllerComponent, LowArmorValue) == 0x0004A0, "Member 'UGzAudioControllerComponent::LowArmorValue' has a wrong offset!");
static_assert(offsetof(UGzAudioControllerComponent, AudioSettingsChangeActions) == 0x0004A8, "Member 'UGzAudioControllerComponent::AudioSettingsChangeActions' has a wrong offset!");
static_assert(offsetof(UGzAudioControllerComponent, CachedEnvZone) == 0x0004F8, "Member 'UGzAudioControllerComponent::CachedEnvZone' has a wrong offset!");
static_assert(offsetof(UGzAudioControllerComponent, OwnerAkComponent) == 0x000500, "Member 'UGzAudioControllerComponent::OwnerAkComponent' has a wrong offset!");
static_assert(offsetof(UGzAudioControllerComponent, ListeningZoneManager) == 0x000508, "Member 'UGzAudioControllerComponent::ListeningZoneManager' has a wrong offset!");
static_assert(offsetof(UGzAudioControllerComponent, CachedViewTarget) == 0x000510, "Member 'UGzAudioControllerComponent::CachedViewTarget' has a wrong offset!");
static_assert(offsetof(UGzAudioControllerComponent, DistanceProbe) == 0x000518, "Member 'UGzAudioControllerComponent::DistanceProbe' has a wrong offset!");
static_assert(offsetof(UGzAudioControllerComponent, EnvironmentZones) == 0x000520, "Member 'UGzAudioControllerComponent::EnvironmentZones' has a wrong offset!");
static_assert(offsetof(UGzAudioControllerComponent, ActiveAudioHints) == 0x000570, "Member 'UGzAudioControllerComponent::ActiveAudioHints' has a wrong offset!");
static_assert(offsetof(UGzAudioControllerComponent, ActiveVoiceLines) == 0x0005C0, "Member 'UGzAudioControllerComponent::ActiveVoiceLines' has a wrong offset!");
static_assert(offsetof(UGzAudioControllerComponent, VoiceLineQueue) == 0x000610, "Member 'UGzAudioControllerComponent::VoiceLineQueue' has a wrong offset!");
static_assert(offsetof(UGzAudioControllerComponent, ActorVoiceLineTimeOutData) == 0x000660, "Member 'UGzAudioControllerComponent::ActorVoiceLineTimeOutData' has a wrong offset!");

// Class G01.GzAudioEngineSubsystem
// 0x0050 (0x0080 - 0x0030)
class UGzAudioEngineSubsystem final : public UEngineSubsystem
{
public:
	uint8                                         Pad_2EED[0x50];                                    // 0x0030(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnInputMethodChanged(const struct FPlatformUserId& UserId, const struct FInputDeviceId& InputDeviceId);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzAudioEngineSubsystem">();
	}
	static class UGzAudioEngineSubsystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzAudioEngineSubsystem>();
	}
};
static_assert(alignof(UGzAudioEngineSubsystem) == 0x000008, "Wrong alignment on UGzAudioEngineSubsystem");
static_assert(sizeof(UGzAudioEngineSubsystem) == 0x000080, "Wrong size on UGzAudioEngineSubsystem");

// Class G01.GzLootUtility
// 0x0000 (0x0028 - 0x0028)
class UGzLootUtility final : public UBlueprintFunctionLibrary
{
public:
	static TArray<class FName> GetLootModifiableNames();
	static TArray<struct FGzLootModifier> MergeLootModifiers(const TArray<class UGzLootModifierTableData*>& ModifierTables);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzLootUtility">();
	}
	static class UGzLootUtility* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzLootUtility>();
	}
};
static_assert(alignof(UGzLootUtility) == 0x000008, "Wrong alignment on UGzLootUtility");
static_assert(sizeof(UGzLootUtility) == 0x000028, "Wrong size on UGzLootUtility");

// Class G01.GzBodyPartAbilityData_ToxicSmoke
// 0x0010 (0x0090 - 0x0080)
class UGzBodyPartAbilityData_ToxicSmoke final : public UGzBodyPartAbilityData
{
public:
	float                                         SmokeLifespan;                                     // 0x0080(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BodyDamagePerSecond;                               // 0x0084(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ArmsDamagePerSecond;                               // 0x0088(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LegsDamagePerSecond;                               // 0x008C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzBodyPartAbilityData_ToxicSmoke">();
	}
	static class UGzBodyPartAbilityData_ToxicSmoke* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzBodyPartAbilityData_ToxicSmoke>();
	}
};
static_assert(alignof(UGzBodyPartAbilityData_ToxicSmoke) == 0x000008, "Wrong alignment on UGzBodyPartAbilityData_ToxicSmoke");
static_assert(sizeof(UGzBodyPartAbilityData_ToxicSmoke) == 0x000090, "Wrong size on UGzBodyPartAbilityData_ToxicSmoke");
static_assert(offsetof(UGzBodyPartAbilityData_ToxicSmoke, SmokeLifespan) == 0x000080, "Member 'UGzBodyPartAbilityData_ToxicSmoke::SmokeLifespan' has a wrong offset!");
static_assert(offsetof(UGzBodyPartAbilityData_ToxicSmoke, BodyDamagePerSecond) == 0x000084, "Member 'UGzBodyPartAbilityData_ToxicSmoke::BodyDamagePerSecond' has a wrong offset!");
static_assert(offsetof(UGzBodyPartAbilityData_ToxicSmoke, ArmsDamagePerSecond) == 0x000088, "Member 'UGzBodyPartAbilityData_ToxicSmoke::ArmsDamagePerSecond' has a wrong offset!");
static_assert(offsetof(UGzBodyPartAbilityData_ToxicSmoke, LegsDamagePerSecond) == 0x00008C, "Member 'UGzBodyPartAbilityData_ToxicSmoke::LegsDamagePerSecond' has a wrong offset!");

// Class G01.GzInventoryTooltip
// 0x0000 (0x0308 - 0x0308)
class UGzInventoryTooltip final : public UCommonUserWidget
{
public:
	void InitFromItem_BP(const struct FGzInvItem& InItem, const struct FGzInvPocketId& PocketId);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzInventoryTooltip">();
	}
	static class UGzInventoryTooltip* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzInventoryTooltip>();
	}
};
static_assert(alignof(UGzInventoryTooltip) == 0x000008, "Wrong alignment on UGzInventoryTooltip");
static_assert(sizeof(UGzInventoryTooltip) == 0x000308, "Wrong size on UGzInventoryTooltip");

// Class G01.GzAudioHintComponent
// 0x0010 (0x0240 - 0x0230)
class UGzAudioHintComponent final : public USceneComponent
{
public:
	class UAkAudioEvent*                          SoundEvent;                                        // 0x0230(0x0008)(Edit, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2EEE[0x8];                                     // 0x0238(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void StartEvent();
	void StopEvent();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzAudioHintComponent">();
	}
	static class UGzAudioHintComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzAudioHintComponent>();
	}
};
static_assert(alignof(UGzAudioHintComponent) == 0x000010, "Wrong alignment on UGzAudioHintComponent");
static_assert(sizeof(UGzAudioHintComponent) == 0x000240, "Wrong size on UGzAudioHintComponent");
static_assert(offsetof(UGzAudioHintComponent, SoundEvent) == 0x000230, "Member 'UGzAudioHintComponent::SoundEvent' has a wrong offset!");

// Class G01.GzGA_Minigun
// 0x00E0 (0x0758 - 0x0678)
class UGzGA_Minigun : public UGzGA_BaseLimbAbility
{
public:
	class UInputAction*                           ShootingInputAction;                               // 0x0678(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftObjectPtr<class UAnimMontage>            SoftAimingMontage;                                 // 0x0680(0x0028)(Edit, DisableEditOnInstance, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bUseGameplayEventToAllowShooting;                  // 0x06A8(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2EEF[0x3];                                     // 0x06A9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTag                           AllowShootingEventTag;                             // 0x06AC(0x0008)(Edit, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         AllowShootingEventTimeSec;                         // 0x06B4(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   DeactivationSectionName;                           // 0x06B8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   ShootingSocketName;                                // 0x06C0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   OverheatEffectSpawnSocketName;                     // 0x06C8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   ShellEjectEffectSocketName;                        // 0x06D0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         SpinningTimeInSec;                                 // 0x06D8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bApplyCustomSensitivityOnActivation;               // 0x06DC(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2EF0[0x3];                                     // 0x06DD(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         PitchModifier;                                     // 0x06E0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         YawModifier;                                       // 0x06E4(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAbilityTask_WaitInputPress*            AT_WaitInputPress;                                 // 0x06E8(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UGzAT_WaitCustomInputPress*             AT_WaitCustomInputPress;                           // 0x06F0(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UGzAT_WaitCustomInputRelease*           AT_WaitCustomInputRelease;                         // 0x06F8(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAbilityTask_PlayMontageAndWait*        AT_PlayMontage;                                    // 0x0700(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UGzMinigunComponent*                    MinigunComponent;                                  // 0x0708(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2EF1[0x48];                                    // 0x0710(0x0048)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void HandleAbilityInputPressed(float TimeHeld);
	void HandleShootingInputPressed(float Time);
	void HandleShootingInputReleased(float Time);
	void OnMontageCompleted();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzGA_Minigun">();
	}
	static class UGzGA_Minigun* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzGA_Minigun>();
	}
};
static_assert(alignof(UGzGA_Minigun) == 0x000008, "Wrong alignment on UGzGA_Minigun");
static_assert(sizeof(UGzGA_Minigun) == 0x000758, "Wrong size on UGzGA_Minigun");
static_assert(offsetof(UGzGA_Minigun, ShootingInputAction) == 0x000678, "Member 'UGzGA_Minigun::ShootingInputAction' has a wrong offset!");
static_assert(offsetof(UGzGA_Minigun, SoftAimingMontage) == 0x000680, "Member 'UGzGA_Minigun::SoftAimingMontage' has a wrong offset!");
static_assert(offsetof(UGzGA_Minigun, bUseGameplayEventToAllowShooting) == 0x0006A8, "Member 'UGzGA_Minigun::bUseGameplayEventToAllowShooting' has a wrong offset!");
static_assert(offsetof(UGzGA_Minigun, AllowShootingEventTag) == 0x0006AC, "Member 'UGzGA_Minigun::AllowShootingEventTag' has a wrong offset!");
static_assert(offsetof(UGzGA_Minigun, AllowShootingEventTimeSec) == 0x0006B4, "Member 'UGzGA_Minigun::AllowShootingEventTimeSec' has a wrong offset!");
static_assert(offsetof(UGzGA_Minigun, DeactivationSectionName) == 0x0006B8, "Member 'UGzGA_Minigun::DeactivationSectionName' has a wrong offset!");
static_assert(offsetof(UGzGA_Minigun, ShootingSocketName) == 0x0006C0, "Member 'UGzGA_Minigun::ShootingSocketName' has a wrong offset!");
static_assert(offsetof(UGzGA_Minigun, OverheatEffectSpawnSocketName) == 0x0006C8, "Member 'UGzGA_Minigun::OverheatEffectSpawnSocketName' has a wrong offset!");
static_assert(offsetof(UGzGA_Minigun, ShellEjectEffectSocketName) == 0x0006D0, "Member 'UGzGA_Minigun::ShellEjectEffectSocketName' has a wrong offset!");
static_assert(offsetof(UGzGA_Minigun, SpinningTimeInSec) == 0x0006D8, "Member 'UGzGA_Minigun::SpinningTimeInSec' has a wrong offset!");
static_assert(offsetof(UGzGA_Minigun, bApplyCustomSensitivityOnActivation) == 0x0006DC, "Member 'UGzGA_Minigun::bApplyCustomSensitivityOnActivation' has a wrong offset!");
static_assert(offsetof(UGzGA_Minigun, PitchModifier) == 0x0006E0, "Member 'UGzGA_Minigun::PitchModifier' has a wrong offset!");
static_assert(offsetof(UGzGA_Minigun, YawModifier) == 0x0006E4, "Member 'UGzGA_Minigun::YawModifier' has a wrong offset!");
static_assert(offsetof(UGzGA_Minigun, AT_WaitInputPress) == 0x0006E8, "Member 'UGzGA_Minigun::AT_WaitInputPress' has a wrong offset!");
static_assert(offsetof(UGzGA_Minigun, AT_WaitCustomInputPress) == 0x0006F0, "Member 'UGzGA_Minigun::AT_WaitCustomInputPress' has a wrong offset!");
static_assert(offsetof(UGzGA_Minigun, AT_WaitCustomInputRelease) == 0x0006F8, "Member 'UGzGA_Minigun::AT_WaitCustomInputRelease' has a wrong offset!");
static_assert(offsetof(UGzGA_Minigun, AT_PlayMontage) == 0x000700, "Member 'UGzGA_Minigun::AT_PlayMontage' has a wrong offset!");
static_assert(offsetof(UGzGA_Minigun, MinigunComponent) == 0x000708, "Member 'UGzGA_Minigun::MinigunComponent' has a wrong offset!");

// Class G01.GzAudioManagerSubsystem
// 0x0170 (0x01A0 - 0x0030)
class UGzAudioManagerSubsystem final : public UGameInstanceSubsystem
{
public:
	class UAkAudioEvent*                          LoadedStateEvent;                                  // 0x0030(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSet<class UObject*>                          LoadedResources;                                   // 0x0038(0x0050)(Transient, NativeAccessSpecifierPrivate)
	TSet<TSoftObjectPtr<class UObject>>           ResourcesSoftPtrs;                                 // 0x0088(0x0050)(Transient, UObjectWrapper, NativeAccessSpecifierPrivate)
	TMap<struct FGameplayTag, class AGzAudioAnnouncer*> AudioAnnouncers;                                   // 0x00D8(0x0050)(Transient, NativeAccessSpecifierPrivate)
	class UAkRtpc*                                MainVolumeRtpc;                                    // 0x0128(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UAkRtpc*                                MusicVolumeRtpc;                                   // 0x0130(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UAkRtpc*                                SfxVolumeRtpc;                                     // 0x0138(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UAkRtpc*                                VoVolumeRtpc;                                      // 0x0140(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UAkRtpc*                                MatchStateAnnouncerVolumeRtpc;                     // 0x0148(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UAkRtpc*                                PersonalAssistantVolumeRtpc;                       // 0x0150(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UAkRtpc*                                CharacterVoiceVolumeRtpc;                          // 0x0158(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UAkRtpc*                                HapticsStrengthRtpc;                               // 0x0160(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UGzButtonSoundData*                     DefaultButtonSoundData;                            // 0x0168(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2EF2[0x30];                                    // 0x0170(0x0030)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class AGzAudioAnnouncer* GetAudioAnnouncer(const class UObject* WorldContext, const struct FGameplayTag& AnnouncerTag);

	void ResetLoadedStateEvent(EAkCallbackType CallbackType, class UAkCallbackInfo* CallbackInfo);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzAudioManagerSubsystem">();
	}
	static class UGzAudioManagerSubsystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzAudioManagerSubsystem>();
	}
};
static_assert(alignof(UGzAudioManagerSubsystem) == 0x000008, "Wrong alignment on UGzAudioManagerSubsystem");
static_assert(sizeof(UGzAudioManagerSubsystem) == 0x0001A0, "Wrong size on UGzAudioManagerSubsystem");
static_assert(offsetof(UGzAudioManagerSubsystem, LoadedStateEvent) == 0x000030, "Member 'UGzAudioManagerSubsystem::LoadedStateEvent' has a wrong offset!");
static_assert(offsetof(UGzAudioManagerSubsystem, LoadedResources) == 0x000038, "Member 'UGzAudioManagerSubsystem::LoadedResources' has a wrong offset!");
static_assert(offsetof(UGzAudioManagerSubsystem, ResourcesSoftPtrs) == 0x000088, "Member 'UGzAudioManagerSubsystem::ResourcesSoftPtrs' has a wrong offset!");
static_assert(offsetof(UGzAudioManagerSubsystem, AudioAnnouncers) == 0x0000D8, "Member 'UGzAudioManagerSubsystem::AudioAnnouncers' has a wrong offset!");
static_assert(offsetof(UGzAudioManagerSubsystem, MainVolumeRtpc) == 0x000128, "Member 'UGzAudioManagerSubsystem::MainVolumeRtpc' has a wrong offset!");
static_assert(offsetof(UGzAudioManagerSubsystem, MusicVolumeRtpc) == 0x000130, "Member 'UGzAudioManagerSubsystem::MusicVolumeRtpc' has a wrong offset!");
static_assert(offsetof(UGzAudioManagerSubsystem, SfxVolumeRtpc) == 0x000138, "Member 'UGzAudioManagerSubsystem::SfxVolumeRtpc' has a wrong offset!");
static_assert(offsetof(UGzAudioManagerSubsystem, VoVolumeRtpc) == 0x000140, "Member 'UGzAudioManagerSubsystem::VoVolumeRtpc' has a wrong offset!");
static_assert(offsetof(UGzAudioManagerSubsystem, MatchStateAnnouncerVolumeRtpc) == 0x000148, "Member 'UGzAudioManagerSubsystem::MatchStateAnnouncerVolumeRtpc' has a wrong offset!");
static_assert(offsetof(UGzAudioManagerSubsystem, PersonalAssistantVolumeRtpc) == 0x000150, "Member 'UGzAudioManagerSubsystem::PersonalAssistantVolumeRtpc' has a wrong offset!");
static_assert(offsetof(UGzAudioManagerSubsystem, CharacterVoiceVolumeRtpc) == 0x000158, "Member 'UGzAudioManagerSubsystem::CharacterVoiceVolumeRtpc' has a wrong offset!");
static_assert(offsetof(UGzAudioManagerSubsystem, HapticsStrengthRtpc) == 0x000160, "Member 'UGzAudioManagerSubsystem::HapticsStrengthRtpc' has a wrong offset!");
static_assert(offsetof(UGzAudioManagerSubsystem, DefaultButtonSoundData) == 0x000168, "Member 'UGzAudioManagerSubsystem::DefaultButtonSoundData' has a wrong offset!");

// Class G01.GzBTBaseService
// 0x0038 (0x00A8 - 0x0070)
class UGzBTBaseService : public UBTService
{
public:
	class AGzAIController*                        GzAIController;                                    // 0x0070(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class APawn*                                  PawnOwner;                                         // 0x0078(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UBlackboardComponent*                   BlackboardComponent;                               // 0x0080(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UGzCombatComponent*                     CombatComponent;                                   // 0x0088(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UGzAbilitySystemComponent*              AbilitySystemComponent;                            // 0x0090(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UGzAIProcessTargetComponent*            ProcessTargetComponent;                            // 0x0098(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UGzAITokenComponent*                    TokenComponent;                                    // 0x00A0(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	class UBlackboardComponent* GetBlackboardComponent() const;
	class AGzAIController* GetGzAIController() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzBTBaseService">();
	}
	static class UGzBTBaseService* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzBTBaseService>();
	}
};
static_assert(alignof(UGzBTBaseService) == 0x000008, "Wrong alignment on UGzBTBaseService");
static_assert(sizeof(UGzBTBaseService) == 0x0000A8, "Wrong size on UGzBTBaseService");
static_assert(offsetof(UGzBTBaseService, GzAIController) == 0x000070, "Member 'UGzBTBaseService::GzAIController' has a wrong offset!");
static_assert(offsetof(UGzBTBaseService, PawnOwner) == 0x000078, "Member 'UGzBTBaseService::PawnOwner' has a wrong offset!");
static_assert(offsetof(UGzBTBaseService, BlackboardComponent) == 0x000080, "Member 'UGzBTBaseService::BlackboardComponent' has a wrong offset!");
static_assert(offsetof(UGzBTBaseService, CombatComponent) == 0x000088, "Member 'UGzBTBaseService::CombatComponent' has a wrong offset!");
static_assert(offsetof(UGzBTBaseService, AbilitySystemComponent) == 0x000090, "Member 'UGzBTBaseService::AbilitySystemComponent' has a wrong offset!");
static_assert(offsetof(UGzBTBaseService, ProcessTargetComponent) == 0x000098, "Member 'UGzBTBaseService::ProcessTargetComponent' has a wrong offset!");
static_assert(offsetof(UGzBTBaseService, TokenComponent) == 0x0000A0, "Member 'UGzBTBaseService::TokenComponent' has a wrong offset!");

// Class G01.GzBTServiceAttack
// 0x0068 (0x0110 - 0x00A8)
class UGzBTServiceAttack final : public UGzBTBaseService
{
public:
	struct FBlackboardKeySelector                 TargetVisible;                                     // 0x00A8(0x0028)(Edit, Protected, NativeAccessSpecifierProtected)
	float                                         TimeToFirstAttack;                                 // 0x00D0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         TimeToFirstAttackDeviation;                        // 0x00D4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         AttackTime;                                        // 0x00D8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         AttackTimeDeviation;                               // 0x00DC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ConusTargetFire;                                   // 0x00E0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         DelayAttackTime;                                   // 0x00E4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         DelayAttackTimeDeviation;                          // 0x00E8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         DelayAfterDamageTime;                              // 0x00EC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         DelayAfterDamageTimeDeviation;                     // 0x00F0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2EF4[0x4];                                     // 0x00F4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UCurveFloat*                            DelayAfterDamageTimeCurve;                         // 0x00F8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2EF5[0x10];                                    // 0x0100(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnTakeDamage(class AActor* DamagedActor, float Damage, const class UDamageType* DamageType, class AController* InstigatedBy, class AActor* DamageCauser);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzBTServiceAttack">();
	}
	static class UGzBTServiceAttack* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzBTServiceAttack>();
	}
};
static_assert(alignof(UGzBTServiceAttack) == 0x000008, "Wrong alignment on UGzBTServiceAttack");
static_assert(sizeof(UGzBTServiceAttack) == 0x000110, "Wrong size on UGzBTServiceAttack");
static_assert(offsetof(UGzBTServiceAttack, TargetVisible) == 0x0000A8, "Member 'UGzBTServiceAttack::TargetVisible' has a wrong offset!");
static_assert(offsetof(UGzBTServiceAttack, TimeToFirstAttack) == 0x0000D0, "Member 'UGzBTServiceAttack::TimeToFirstAttack' has a wrong offset!");
static_assert(offsetof(UGzBTServiceAttack, TimeToFirstAttackDeviation) == 0x0000D4, "Member 'UGzBTServiceAttack::TimeToFirstAttackDeviation' has a wrong offset!");
static_assert(offsetof(UGzBTServiceAttack, AttackTime) == 0x0000D8, "Member 'UGzBTServiceAttack::AttackTime' has a wrong offset!");
static_assert(offsetof(UGzBTServiceAttack, AttackTimeDeviation) == 0x0000DC, "Member 'UGzBTServiceAttack::AttackTimeDeviation' has a wrong offset!");
static_assert(offsetof(UGzBTServiceAttack, ConusTargetFire) == 0x0000E0, "Member 'UGzBTServiceAttack::ConusTargetFire' has a wrong offset!");
static_assert(offsetof(UGzBTServiceAttack, DelayAttackTime) == 0x0000E4, "Member 'UGzBTServiceAttack::DelayAttackTime' has a wrong offset!");
static_assert(offsetof(UGzBTServiceAttack, DelayAttackTimeDeviation) == 0x0000E8, "Member 'UGzBTServiceAttack::DelayAttackTimeDeviation' has a wrong offset!");
static_assert(offsetof(UGzBTServiceAttack, DelayAfterDamageTime) == 0x0000EC, "Member 'UGzBTServiceAttack::DelayAfterDamageTime' has a wrong offset!");
static_assert(offsetof(UGzBTServiceAttack, DelayAfterDamageTimeDeviation) == 0x0000F0, "Member 'UGzBTServiceAttack::DelayAfterDamageTimeDeviation' has a wrong offset!");
static_assert(offsetof(UGzBTServiceAttack, DelayAfterDamageTimeCurve) == 0x0000F8, "Member 'UGzBTServiceAttack::DelayAfterDamageTimeCurve' has a wrong offset!");

// Class G01.GzAuthenticationCheatExtension
// 0x0008 (0x0030 - 0x0028)
class UGzAuthenticationCheatExtension final : public UGzCheatManagerExtension
{
public:
	uint8                                         Pad_2EF7[0x8];                                     // 0x0028(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AutoLogin();
	void GetConsoleAuth();
	void Relogin();
	void ShowAccountId();
	void ShowAuthCode();
	void ShowLoginUI();
	void ShowTitleInfo();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzAuthenticationCheatExtension">();
	}
	static class UGzAuthenticationCheatExtension* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzAuthenticationCheatExtension>();
	}
};
static_assert(alignof(UGzAuthenticationCheatExtension) == 0x000008, "Wrong alignment on UGzAuthenticationCheatExtension");
static_assert(sizeof(UGzAuthenticationCheatExtension) == 0x000030, "Wrong size on UGzAuthenticationCheatExtension");

// Class G01.GzConsumableItemData
// 0x0000 (0x03C8 - 0x03C8)
class UGzConsumableItemData : public UGzSimpleItemData
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzConsumableItemData">();
	}
	static class UGzConsumableItemData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzConsumableItemData>();
	}
};
static_assert(alignof(UGzConsumableItemData) == 0x000008, "Wrong alignment on UGzConsumableItemData");
static_assert(sizeof(UGzConsumableItemData) == 0x0003C8, "Wrong size on UGzConsumableItemData");

// Class G01.GzAuthorizationSettings
// 0x0008 (0x0030 - 0x0028)
class UGzAuthorizationSettings final : public UObject
{
public:
	uint8                                         UsernameMaxLength;                                 // 0x0028(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2EF8[0x7];                                     // 0x0029(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzAuthorizationSettings">();
	}
	static class UGzAuthorizationSettings* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzAuthorizationSettings>();
	}
};
static_assert(alignof(UGzAuthorizationSettings) == 0x000008, "Wrong alignment on UGzAuthorizationSettings");
static_assert(sizeof(UGzAuthorizationSettings) == 0x000030, "Wrong size on UGzAuthorizationSettings");
static_assert(offsetof(UGzAuthorizationSettings, UsernameMaxLength) == 0x000028, "Member 'UGzAuthorizationSettings::UsernameMaxLength' has a wrong offset!");

// Class G01.GzBR_GridOverloadStage
// 0x0000 (0x0110 - 0x0110)
class UGzBR_GridOverloadStage final : public UGzGameStageBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzBR_GridOverloadStage">();
	}
	static class UGzBR_GridOverloadStage* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzBR_GridOverloadStage>();
	}
};
static_assert(alignof(UGzBR_GridOverloadStage) == 0x000008, "Wrong alignment on UGzBR_GridOverloadStage");
static_assert(sizeof(UGzBR_GridOverloadStage) == 0x000110, "Wrong size on UGzBR_GridOverloadStage");

// Class G01.GzLogReporterComponent
// 0x0048 (0x00E8 - 0x00A0)
class UGzLogReporterComponent final : public UGzServiceComponent
{
public:
	uint8                                         Pad_2EF9[0x48];                                    // 0x00A0(0x0048)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzLogReporterComponent">();
	}
	static class UGzLogReporterComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzLogReporterComponent>();
	}
};
static_assert(alignof(UGzLogReporterComponent) == 0x000008, "Wrong alignment on UGzLogReporterComponent");
static_assert(sizeof(UGzLogReporterComponent) == 0x0000E8, "Wrong size on UGzLogReporterComponent");

// Class G01.GzMetaGameFunctionalTestComponent
// 0x0010 (0x00B8 - 0x00A8)
class UGzMetaGameFunctionalTestComponent : public UActorComponent
{
public:
	uint8                                         Pad_2EFA[0x10];                                    // 0x00A8(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzMetaGameFunctionalTestComponent">();
	}
	static class UGzMetaGameFunctionalTestComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzMetaGameFunctionalTestComponent>();
	}
};
static_assert(alignof(UGzMetaGameFunctionalTestComponent) == 0x000008, "Wrong alignment on UGzMetaGameFunctionalTestComponent");
static_assert(sizeof(UGzMetaGameFunctionalTestComponent) == 0x0000B8, "Wrong size on UGzMetaGameFunctionalTestComponent");

// Class G01.GzInventoryRemintComponent
// 0x0020 (0x00C0 - 0x00A0)
class UGzInventoryRemintComponent final : public UGzServiceComponent
{
public:
	uint8                                         Pad_2EFB[0x10];                                    // 0x00A0(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FName>                           GuidsForRemint;                                    // 0x00B0(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzInventoryRemintComponent">();
	}
	static class UGzInventoryRemintComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzInventoryRemintComponent>();
	}
};
static_assert(alignof(UGzInventoryRemintComponent) == 0x000008, "Wrong alignment on UGzInventoryRemintComponent");
static_assert(sizeof(UGzInventoryRemintComponent) == 0x0000C0, "Wrong size on UGzInventoryRemintComponent");
static_assert(offsetof(UGzInventoryRemintComponent, GuidsForRemint) == 0x0000B0, "Member 'UGzInventoryRemintComponent::GuidsForRemint' has a wrong offset!");

// Class G01.GzAuthTestMetaGameComponent
// 0x0000 (0x00B8 - 0x00B8)
class UGzAuthTestMetaGameComponent final : public UGzMetaGameFunctionalTestComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzAuthTestMetaGameComponent">();
	}
	static class UGzAuthTestMetaGameComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzAuthTestMetaGameComponent>();
	}
};
static_assert(alignof(UGzAuthTestMetaGameComponent) == 0x000008, "Wrong alignment on UGzAuthTestMetaGameComponent");
static_assert(sizeof(UGzAuthTestMetaGameComponent) == 0x0000B8, "Wrong size on UGzAuthTestMetaGameComponent");

// Class G01.GzGlobalSettings
// 0x0330 (0x0358 - 0x0028)
class UGzGlobalSettings : public UObject
{
public:
	TSubclassOf<class UGzDamageSettings>          DamageSettingsClass;                               // 0x0028(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UGzDamageIndicatorSettings> DamageIndicatorSettingsClass;                      // 0x0030(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMaterialInterface*                     DefaultPlayerCharacterPostProcess;                 // 0x0038(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class AActor>                     DefaultWeaponMagazinePropActor;                    // 0x0040(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UGameplayEffect>            DefaultLimbCostEffect_LeftArm;                     // 0x0048(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UGameplayEffect>            DefaultLimbCostEffect_RightArm;                    // 0x0050(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UGameplayEffect>            DefaultLimbCostEffect_Legs;                        // 0x0058(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UGameplayEffect>            LimbMaxChargesEffect_LeftArm;                      // 0x0060(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UGameplayEffect>            LimbMaxChargesEffect_RightArm;                     // 0x0068(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UGameplayEffect>            LimbMaxChargesEffect_Legs;                         // 0x0070(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UGameplayEffect>            LimbRechargingEffect_LeftArm;                      // 0x0078(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UGameplayEffect>            LimbRechargingEffect_RightArm;                     // 0x0080(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UGameplayEffect>            LimbRechargingEffect_Legs;                         // 0x0088(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UGameplayEffect>            InterruptBlockAbilityDurationEffectClass;          // 0x0090(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UGameplayEffect>            InterruptBlockAbilityInfiniteEffectClass;          // 0x0098(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Default_HandSocketName_Left;                       // 0x00A0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Default_HandSocketName_Right;                      // 0x00A8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Default_ShoulderSocketName_Left;                   // 0x00B0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Default_ShoulderSocketName_Right;                  // 0x00B8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Default_PelvisSocketName;                          // 0x00C0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Default_CalfSocketName_Left;                       // 0x00C8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Default_CalfSocketName_Right;                      // 0x00D0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Default_MangledCalfSocketName_Left;                // 0x00D8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Default_MangledCalfSocketName_Right;               // 0x00E0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Default_FootSocketName_Left;                       // 0x00E8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Default_FootSocketName_Right;                      // 0x00F0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Default_ThighSocketName_Left;                      // 0x00F8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Default_ThighSocketName_Right;                     // 0x0100(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   GroundHandIKSocketName_Left;                       // 0x0108(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   GroundHandIKSocketName_Right;                      // 0x0110(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   GroundFootIKSocketName_Left;                       // 0x0118(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   GroundFootIKSocketName_Right;                      // 0x0120(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class FName>                           WeaponSocketSizeSuffixList;                        // 0x0128(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	class FName                                   WeaponHolsterBackFirstSlotSocketName;              // 0x0138(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   WeaponHolsterBackSecondSlotSocketName;             // 0x0140(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   WeaponHolsterHipSecondSlotSocketName;              // 0x0148(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   ArmorPackHandSocket_Left;                          // 0x0150(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   ArmorPackHandSocket_Right;                         // 0x0158(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   ZiplineDeviceHandSocket_Left;                      // 0x0160(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   ZiplineDeviceHandSocket_Right;                     // 0x0168(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   WeaponLeftHandIKPositionSocketName;                // 0x0170(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   WeaponBarrelAttachmentDefaultSocketName;           // 0x0178(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   WeaponUnderBarrelAttachmentDefaultSocketName;      // 0x0180(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   WeaponMagazineAttachmentDefaultSocketName;         // 0x0188(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   WeaponMuzzleAttachmentDefaultSocketName;           // 0x0190(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   WeaponSightAttachmentDefaultSocketName;            // 0x0198(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   WeaponStockAttachmentDefaultSocketName;            // 0x01A0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   WeaponSightFrontAttachmentDefaultSocketName;       // 0x01A8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   WeaponBridgeStockAttachmentDefaultSocketName;      // 0x01B0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   WeaponBridgeBarrelAttachmentDefaultSocketName;     // 0x01B8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   WeaponSiderailAttachmentDefaultSocketName;         // 0x01C0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   WeaponSlideAttachmentDefaultSocketName;            // 0x01C8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   WeaponPistolGripAttachmentDefaultSocketName;       // 0x01D0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   WeaponAttachmentSocketOverrideDefaultSocketSuffix; // 0x01D8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   WeaponAttachmentAttachRootDefaultSocketName;       // 0x01E0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   WeaponMuzzleVFXSocketName;                         // 0x01E8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   WeaponGlintVFXSocketName;                          // 0x01F0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   WeaponShellEjectVFXSocketName;                     // 0x01F8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   WeaponMagazinePropSocketName;                      // 0x0200(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   CombatAimRightSocketName;                          // 0x0208(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   CombatAimLeftSocketName;                           // 0x0210(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   CameraSocketName;                                  // 0x0218(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   HexSocketName;                                     // 0x0220(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   LeftInsertedHexSocketName;                         // 0x0228(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   RightInsertedHexSocketName;                        // 0x0230(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   WeaponTraceEndVFXSystemParameterName;              // 0x0238(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   WeaponTracerLengthParameterName;                   // 0x0240(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   BulletPreviousPositionParameterName;               // 0x0248(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   BulletCurrentPositionParameterName;                // 0x0250(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   BulletLastMoveLengthParameterName;                 // 0x0258(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ParticleDeactivationDelay;                         // 0x0260(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   LimbEffectBeamStartParameterName;                  // 0x0264(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   LimbEffectBeamMiddleParameterName;                 // 0x026C(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   LimbEffectBeamSecondMiddleParameterName;           // 0x0274(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   LimbEffectBeamEndParameterName;                    // 0x027C(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         OnLimbLossWeaponImpulseMultiplier;                 // 0x0284(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LegsDetachFxOffset;                                // 0x0288(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         GlitchEffectMaxScaleDistance;                      // 0x028C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SquaredDistToDroppedPickableToEnableAutoPickup;    // 0x0290(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         WeaponAttackBuffer;                                // 0x0294(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DefaultShootMontageDuration;                       // 0x0298(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CrouchRecoilMultiplier;                            // 0x029C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SpectatorScopeBlock;                               // 0x02A0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         IgnoreAimCorrectionThreshold;                      // 0x02A4(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                InScope_BulletOffset;                              // 0x02A8(0x0018)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BarrelLengthCoefficient;                           // 0x02C0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BulletSpawnForPistol;                              // 0x02C4(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMaterialParameterCollection*           FovMpc;                                            // 0x02C8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           PredictedFatalImpactTag;                           // 0x02D0(0x0008)(Edit, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SimProxyAimCorrectionTraceDist;                    // 0x02D8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         HexNiagaraAlphaCloakArm;                           // 0x02DC(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2EFC[0x3];                                     // 0x02DD(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftObjectPtr<class USkeletalMesh>           SoftHexCarrierMeshPtr;                             // 0x02E0(0x0028)(Edit, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UStaticMesh>             SoftArmorPackMeshPtr;                              // 0x0308(0x0028)(Edit, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UStaticMesh>             SoftZiplineDeviceMeshPtr;                          // 0x0330(0x0028)(Edit, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UGzGlobalSettings* GetGlobalSettings();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzGlobalSettings">();
	}
	static class UGzGlobalSettings* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzGlobalSettings>();
	}
};
static_assert(alignof(UGzGlobalSettings) == 0x000008, "Wrong alignment on UGzGlobalSettings");
static_assert(sizeof(UGzGlobalSettings) == 0x000358, "Wrong size on UGzGlobalSettings");
static_assert(offsetof(UGzGlobalSettings, DamageSettingsClass) == 0x000028, "Member 'UGzGlobalSettings::DamageSettingsClass' has a wrong offset!");
static_assert(offsetof(UGzGlobalSettings, DamageIndicatorSettingsClass) == 0x000030, "Member 'UGzGlobalSettings::DamageIndicatorSettingsClass' has a wrong offset!");
static_assert(offsetof(UGzGlobalSettings, DefaultPlayerCharacterPostProcess) == 0x000038, "Member 'UGzGlobalSettings::DefaultPlayerCharacterPostProcess' has a wrong offset!");
static_assert(offsetof(UGzGlobalSettings, DefaultWeaponMagazinePropActor) == 0x000040, "Member 'UGzGlobalSettings::DefaultWeaponMagazinePropActor' has a wrong offset!");
static_assert(offsetof(UGzGlobalSettings, DefaultLimbCostEffect_LeftArm) == 0x000048, "Member 'UGzGlobalSettings::DefaultLimbCostEffect_LeftArm' has a wrong offset!");
static_assert(offsetof(UGzGlobalSettings, DefaultLimbCostEffect_RightArm) == 0x000050, "Member 'UGzGlobalSettings::DefaultLimbCostEffect_RightArm' has a wrong offset!");
static_assert(offsetof(UGzGlobalSettings, DefaultLimbCostEffect_Legs) == 0x000058, "Member 'UGzGlobalSettings::DefaultLimbCostEffect_Legs' has a wrong offset!");
static_assert(offsetof(UGzGlobalSettings, LimbMaxChargesEffect_LeftArm) == 0x000060, "Member 'UGzGlobalSettings::LimbMaxChargesEffect_LeftArm' has a wrong offset!");
static_assert(offsetof(UGzGlobalSettings, LimbMaxChargesEffect_RightArm) == 0x000068, "Member 'UGzGlobalSettings::LimbMaxChargesEffect_RightArm' has a wrong offset!");
static_assert(offsetof(UGzGlobalSettings, LimbMaxChargesEffect_Legs) == 0x000070, "Member 'UGzGlobalSettings::LimbMaxChargesEffect_Legs' has a wrong offset!");
static_assert(offsetof(UGzGlobalSettings, LimbRechargingEffect_LeftArm) == 0x000078, "Member 'UGzGlobalSettings::LimbRechargingEffect_LeftArm' has a wrong offset!");
static_assert(offsetof(UGzGlobalSettings, LimbRechargingEffect_RightArm) == 0x000080, "Member 'UGzGlobalSettings::LimbRechargingEffect_RightArm' has a wrong offset!");
static_assert(offsetof(UGzGlobalSettings, LimbRechargingEffect_Legs) == 0x000088, "Member 'UGzGlobalSettings::LimbRechargingEffect_Legs' has a wrong offset!");
static_assert(offsetof(UGzGlobalSettings, InterruptBlockAbilityDurationEffectClass) == 0x000090, "Member 'UGzGlobalSettings::InterruptBlockAbilityDurationEffectClass' has a wrong offset!");
static_assert(offsetof(UGzGlobalSettings, InterruptBlockAbilityInfiniteEffectClass) == 0x000098, "Member 'UGzGlobalSettings::InterruptBlockAbilityInfiniteEffectClass' has a wrong offset!");
static_assert(offsetof(UGzGlobalSettings, Default_HandSocketName_Left) == 0x0000A0, "Member 'UGzGlobalSettings::Default_HandSocketName_Left' has a wrong offset!");
static_assert(offsetof(UGzGlobalSettings, Default_HandSocketName_Right) == 0x0000A8, "Member 'UGzGlobalSettings::Default_HandSocketName_Right' has a wrong offset!");
static_assert(offsetof(UGzGlobalSettings, Default_ShoulderSocketName_Left) == 0x0000B0, "Member 'UGzGlobalSettings::Default_ShoulderSocketName_Left' has a wrong offset!");
static_assert(offsetof(UGzGlobalSettings, Default_ShoulderSocketName_Right) == 0x0000B8, "Member 'UGzGlobalSettings::Default_ShoulderSocketName_Right' has a wrong offset!");
static_assert(offsetof(UGzGlobalSettings, Default_PelvisSocketName) == 0x0000C0, "Member 'UGzGlobalSettings::Default_PelvisSocketName' has a wrong offset!");
static_assert(offsetof(UGzGlobalSettings, Default_CalfSocketName_Left) == 0x0000C8, "Member 'UGzGlobalSettings::Default_CalfSocketName_Left' has a wrong offset!");
static_assert(offsetof(UGzGlobalSettings, Default_CalfSocketName_Right) == 0x0000D0, "Member 'UGzGlobalSettings::Default_CalfSocketName_Right' has a wrong offset!");
static_assert(offsetof(UGzGlobalSettings, Default_MangledCalfSocketName_Left) == 0x0000D8, "Member 'UGzGlobalSettings::Default_MangledCalfSocketName_Left' has a wrong offset!");
static_assert(offsetof(UGzGlobalSettings, Default_MangledCalfSocketName_Right) == 0x0000E0, "Member 'UGzGlobalSettings::Default_MangledCalfSocketName_Right' has a wrong offset!");
static_assert(offsetof(UGzGlobalSettings, Default_FootSocketName_Left) == 0x0000E8, "Member 'UGzGlobalSettings::Default_FootSocketName_Left' has a wrong offset!");
static_assert(offsetof(UGzGlobalSettings, Default_FootSocketName_Right) == 0x0000F0, "Member 'UGzGlobalSettings::Default_FootSocketName_Right' has a wrong offset!");
static_assert(offsetof(UGzGlobalSettings, Default_ThighSocketName_Left) == 0x0000F8, "Member 'UGzGlobalSettings::Default_ThighSocketName_Left' has a wrong offset!");
static_assert(offsetof(UGzGlobalSettings, Default_ThighSocketName_Right) == 0x000100, "Member 'UGzGlobalSettings::Default_ThighSocketName_Right' has a wrong offset!");
static_assert(offsetof(UGzGlobalSettings, GroundHandIKSocketName_Left) == 0x000108, "Member 'UGzGlobalSettings::GroundHandIKSocketName_Left' has a wrong offset!");
static_assert(offsetof(UGzGlobalSettings, GroundHandIKSocketName_Right) == 0x000110, "Member 'UGzGlobalSettings::GroundHandIKSocketName_Right' has a wrong offset!");
static_assert(offsetof(UGzGlobalSettings, GroundFootIKSocketName_Left) == 0x000118, "Member 'UGzGlobalSettings::GroundFootIKSocketName_Left' has a wrong offset!");
static_assert(offsetof(UGzGlobalSettings, GroundFootIKSocketName_Right) == 0x000120, "Member 'UGzGlobalSettings::GroundFootIKSocketName_Right' has a wrong offset!");
static_assert(offsetof(UGzGlobalSettings, WeaponSocketSizeSuffixList) == 0x000128, "Member 'UGzGlobalSettings::WeaponSocketSizeSuffixList' has a wrong offset!");
static_assert(offsetof(UGzGlobalSettings, WeaponHolsterBackFirstSlotSocketName) == 0x000138, "Member 'UGzGlobalSettings::WeaponHolsterBackFirstSlotSocketName' has a wrong offset!");
static_assert(offsetof(UGzGlobalSettings, WeaponHolsterBackSecondSlotSocketName) == 0x000140, "Member 'UGzGlobalSettings::WeaponHolsterBackSecondSlotSocketName' has a wrong offset!");
static_assert(offsetof(UGzGlobalSettings, WeaponHolsterHipSecondSlotSocketName) == 0x000148, "Member 'UGzGlobalSettings::WeaponHolsterHipSecondSlotSocketName' has a wrong offset!");
static_assert(offsetof(UGzGlobalSettings, ArmorPackHandSocket_Left) == 0x000150, "Member 'UGzGlobalSettings::ArmorPackHandSocket_Left' has a wrong offset!");
static_assert(offsetof(UGzGlobalSettings, ArmorPackHandSocket_Right) == 0x000158, "Member 'UGzGlobalSettings::ArmorPackHandSocket_Right' has a wrong offset!");
static_assert(offsetof(UGzGlobalSettings, ZiplineDeviceHandSocket_Left) == 0x000160, "Member 'UGzGlobalSettings::ZiplineDeviceHandSocket_Left' has a wrong offset!");
static_assert(offsetof(UGzGlobalSettings, ZiplineDeviceHandSocket_Right) == 0x000168, "Member 'UGzGlobalSettings::ZiplineDeviceHandSocket_Right' has a wrong offset!");
static_assert(offsetof(UGzGlobalSettings, WeaponLeftHandIKPositionSocketName) == 0x000170, "Member 'UGzGlobalSettings::WeaponLeftHandIKPositionSocketName' has a wrong offset!");
static_assert(offsetof(UGzGlobalSettings, WeaponBarrelAttachmentDefaultSocketName) == 0x000178, "Member 'UGzGlobalSettings::WeaponBarrelAttachmentDefaultSocketName' has a wrong offset!");
static_assert(offsetof(UGzGlobalSettings, WeaponUnderBarrelAttachmentDefaultSocketName) == 0x000180, "Member 'UGzGlobalSettings::WeaponUnderBarrelAttachmentDefaultSocketName' has a wrong offset!");
static_assert(offsetof(UGzGlobalSettings, WeaponMagazineAttachmentDefaultSocketName) == 0x000188, "Member 'UGzGlobalSettings::WeaponMagazineAttachmentDefaultSocketName' has a wrong offset!");
static_assert(offsetof(UGzGlobalSettings, WeaponMuzzleAttachmentDefaultSocketName) == 0x000190, "Member 'UGzGlobalSettings::WeaponMuzzleAttachmentDefaultSocketName' has a wrong offset!");
static_assert(offsetof(UGzGlobalSettings, WeaponSightAttachmentDefaultSocketName) == 0x000198, "Member 'UGzGlobalSettings::WeaponSightAttachmentDefaultSocketName' has a wrong offset!");
static_assert(offsetof(UGzGlobalSettings, WeaponStockAttachmentDefaultSocketName) == 0x0001A0, "Member 'UGzGlobalSettings::WeaponStockAttachmentDefaultSocketName' has a wrong offset!");
static_assert(offsetof(UGzGlobalSettings, WeaponSightFrontAttachmentDefaultSocketName) == 0x0001A8, "Member 'UGzGlobalSettings::WeaponSightFrontAttachmentDefaultSocketName' has a wrong offset!");
static_assert(offsetof(UGzGlobalSettings, WeaponBridgeStockAttachmentDefaultSocketName) == 0x0001B0, "Member 'UGzGlobalSettings::WeaponBridgeStockAttachmentDefaultSocketName' has a wrong offset!");
static_assert(offsetof(UGzGlobalSettings, WeaponBridgeBarrelAttachmentDefaultSocketName) == 0x0001B8, "Member 'UGzGlobalSettings::WeaponBridgeBarrelAttachmentDefaultSocketName' has a wrong offset!");
static_assert(offsetof(UGzGlobalSettings, WeaponSiderailAttachmentDefaultSocketName) == 0x0001C0, "Member 'UGzGlobalSettings::WeaponSiderailAttachmentDefaultSocketName' has a wrong offset!");
static_assert(offsetof(UGzGlobalSettings, WeaponSlideAttachmentDefaultSocketName) == 0x0001C8, "Member 'UGzGlobalSettings::WeaponSlideAttachmentDefaultSocketName' has a wrong offset!");
static_assert(offsetof(UGzGlobalSettings, WeaponPistolGripAttachmentDefaultSocketName) == 0x0001D0, "Member 'UGzGlobalSettings::WeaponPistolGripAttachmentDefaultSocketName' has a wrong offset!");
static_assert(offsetof(UGzGlobalSettings, WeaponAttachmentSocketOverrideDefaultSocketSuffix) == 0x0001D8, "Member 'UGzGlobalSettings::WeaponAttachmentSocketOverrideDefaultSocketSuffix' has a wrong offset!");
static_assert(offsetof(UGzGlobalSettings, WeaponAttachmentAttachRootDefaultSocketName) == 0x0001E0, "Member 'UGzGlobalSettings::WeaponAttachmentAttachRootDefaultSocketName' has a wrong offset!");
static_assert(offsetof(UGzGlobalSettings, WeaponMuzzleVFXSocketName) == 0x0001E8, "Member 'UGzGlobalSettings::WeaponMuzzleVFXSocketName' has a wrong offset!");
static_assert(offsetof(UGzGlobalSettings, WeaponGlintVFXSocketName) == 0x0001F0, "Member 'UGzGlobalSettings::WeaponGlintVFXSocketName' has a wrong offset!");
static_assert(offsetof(UGzGlobalSettings, WeaponShellEjectVFXSocketName) == 0x0001F8, "Member 'UGzGlobalSettings::WeaponShellEjectVFXSocketName' has a wrong offset!");
static_assert(offsetof(UGzGlobalSettings, WeaponMagazinePropSocketName) == 0x000200, "Member 'UGzGlobalSettings::WeaponMagazinePropSocketName' has a wrong offset!");
static_assert(offsetof(UGzGlobalSettings, CombatAimRightSocketName) == 0x000208, "Member 'UGzGlobalSettings::CombatAimRightSocketName' has a wrong offset!");
static_assert(offsetof(UGzGlobalSettings, CombatAimLeftSocketName) == 0x000210, "Member 'UGzGlobalSettings::CombatAimLeftSocketName' has a wrong offset!");
static_assert(offsetof(UGzGlobalSettings, CameraSocketName) == 0x000218, "Member 'UGzGlobalSettings::CameraSocketName' has a wrong offset!");
static_assert(offsetof(UGzGlobalSettings, HexSocketName) == 0x000220, "Member 'UGzGlobalSettings::HexSocketName' has a wrong offset!");
static_assert(offsetof(UGzGlobalSettings, LeftInsertedHexSocketName) == 0x000228, "Member 'UGzGlobalSettings::LeftInsertedHexSocketName' has a wrong offset!");
static_assert(offsetof(UGzGlobalSettings, RightInsertedHexSocketName) == 0x000230, "Member 'UGzGlobalSettings::RightInsertedHexSocketName' has a wrong offset!");
static_assert(offsetof(UGzGlobalSettings, WeaponTraceEndVFXSystemParameterName) == 0x000238, "Member 'UGzGlobalSettings::WeaponTraceEndVFXSystemParameterName' has a wrong offset!");
static_assert(offsetof(UGzGlobalSettings, WeaponTracerLengthParameterName) == 0x000240, "Member 'UGzGlobalSettings::WeaponTracerLengthParameterName' has a wrong offset!");
static_assert(offsetof(UGzGlobalSettings, BulletPreviousPositionParameterName) == 0x000248, "Member 'UGzGlobalSettings::BulletPreviousPositionParameterName' has a wrong offset!");
static_assert(offsetof(UGzGlobalSettings, BulletCurrentPositionParameterName) == 0x000250, "Member 'UGzGlobalSettings::BulletCurrentPositionParameterName' has a wrong offset!");
static_assert(offsetof(UGzGlobalSettings, BulletLastMoveLengthParameterName) == 0x000258, "Member 'UGzGlobalSettings::BulletLastMoveLengthParameterName' has a wrong offset!");
static_assert(offsetof(UGzGlobalSettings, ParticleDeactivationDelay) == 0x000260, "Member 'UGzGlobalSettings::ParticleDeactivationDelay' has a wrong offset!");
static_assert(offsetof(UGzGlobalSettings, LimbEffectBeamStartParameterName) == 0x000264, "Member 'UGzGlobalSettings::LimbEffectBeamStartParameterName' has a wrong offset!");
static_assert(offsetof(UGzGlobalSettings, LimbEffectBeamMiddleParameterName) == 0x00026C, "Member 'UGzGlobalSettings::LimbEffectBeamMiddleParameterName' has a wrong offset!");
static_assert(offsetof(UGzGlobalSettings, LimbEffectBeamSecondMiddleParameterName) == 0x000274, "Member 'UGzGlobalSettings::LimbEffectBeamSecondMiddleParameterName' has a wrong offset!");
static_assert(offsetof(UGzGlobalSettings, LimbEffectBeamEndParameterName) == 0x00027C, "Member 'UGzGlobalSettings::LimbEffectBeamEndParameterName' has a wrong offset!");
static_assert(offsetof(UGzGlobalSettings, OnLimbLossWeaponImpulseMultiplier) == 0x000284, "Member 'UGzGlobalSettings::OnLimbLossWeaponImpulseMultiplier' has a wrong offset!");
static_assert(offsetof(UGzGlobalSettings, LegsDetachFxOffset) == 0x000288, "Member 'UGzGlobalSettings::LegsDetachFxOffset' has a wrong offset!");
static_assert(offsetof(UGzGlobalSettings, GlitchEffectMaxScaleDistance) == 0x00028C, "Member 'UGzGlobalSettings::GlitchEffectMaxScaleDistance' has a wrong offset!");
static_assert(offsetof(UGzGlobalSettings, SquaredDistToDroppedPickableToEnableAutoPickup) == 0x000290, "Member 'UGzGlobalSettings::SquaredDistToDroppedPickableToEnableAutoPickup' has a wrong offset!");
static_assert(offsetof(UGzGlobalSettings, WeaponAttackBuffer) == 0x000294, "Member 'UGzGlobalSettings::WeaponAttackBuffer' has a wrong offset!");
static_assert(offsetof(UGzGlobalSettings, DefaultShootMontageDuration) == 0x000298, "Member 'UGzGlobalSettings::DefaultShootMontageDuration' has a wrong offset!");
static_assert(offsetof(UGzGlobalSettings, CrouchRecoilMultiplier) == 0x00029C, "Member 'UGzGlobalSettings::CrouchRecoilMultiplier' has a wrong offset!");
static_assert(offsetof(UGzGlobalSettings, SpectatorScopeBlock) == 0x0002A0, "Member 'UGzGlobalSettings::SpectatorScopeBlock' has a wrong offset!");
static_assert(offsetof(UGzGlobalSettings, IgnoreAimCorrectionThreshold) == 0x0002A4, "Member 'UGzGlobalSettings::IgnoreAimCorrectionThreshold' has a wrong offset!");
static_assert(offsetof(UGzGlobalSettings, InScope_BulletOffset) == 0x0002A8, "Member 'UGzGlobalSettings::InScope_BulletOffset' has a wrong offset!");
static_assert(offsetof(UGzGlobalSettings, BarrelLengthCoefficient) == 0x0002C0, "Member 'UGzGlobalSettings::BarrelLengthCoefficient' has a wrong offset!");
static_assert(offsetof(UGzGlobalSettings, BulletSpawnForPistol) == 0x0002C4, "Member 'UGzGlobalSettings::BulletSpawnForPistol' has a wrong offset!");
static_assert(offsetof(UGzGlobalSettings, FovMpc) == 0x0002C8, "Member 'UGzGlobalSettings::FovMpc' has a wrong offset!");
static_assert(offsetof(UGzGlobalSettings, PredictedFatalImpactTag) == 0x0002D0, "Member 'UGzGlobalSettings::PredictedFatalImpactTag' has a wrong offset!");
static_assert(offsetof(UGzGlobalSettings, SimProxyAimCorrectionTraceDist) == 0x0002D8, "Member 'UGzGlobalSettings::SimProxyAimCorrectionTraceDist' has a wrong offset!");
static_assert(offsetof(UGzGlobalSettings, HexNiagaraAlphaCloakArm) == 0x0002DC, "Member 'UGzGlobalSettings::HexNiagaraAlphaCloakArm' has a wrong offset!");
static_assert(offsetof(UGzGlobalSettings, SoftHexCarrierMeshPtr) == 0x0002E0, "Member 'UGzGlobalSettings::SoftHexCarrierMeshPtr' has a wrong offset!");
static_assert(offsetof(UGzGlobalSettings, SoftArmorPackMeshPtr) == 0x000308, "Member 'UGzGlobalSettings::SoftArmorPackMeshPtr' has a wrong offset!");
static_assert(offsetof(UGzGlobalSettings, SoftZiplineDeviceMeshPtr) == 0x000330, "Member 'UGzGlobalSettings::SoftZiplineDeviceMeshPtr' has a wrong offset!");

// Class G01.GzBTServiceSwitchFireMode
// 0x0078 (0x0120 - 0x00A8)
class UGzBTServiceSwitchFireMode final : public UGzBTBaseService
{
public:
	TMap<EGzWeaponMode, struct FGameplayTag>      SwitchFireModeMap;                                 // 0x00A8(0x0050)(Edit, Protected, NativeAccessSpecifierProtected)
	struct FBlackboardKeySelector                 FireModeKey;                                       // 0x00F8(0x0028)(Edit, Protected, NativeAccessSpecifierProtected)

public:
	EGzWeaponMode GetCurrentFireMode() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzBTServiceSwitchFireMode">();
	}
	static class UGzBTServiceSwitchFireMode* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzBTServiceSwitchFireMode>();
	}
};
static_assert(alignof(UGzBTServiceSwitchFireMode) == 0x000008, "Wrong alignment on UGzBTServiceSwitchFireMode");
static_assert(sizeof(UGzBTServiceSwitchFireMode) == 0x000120, "Wrong size on UGzBTServiceSwitchFireMode");
static_assert(offsetof(UGzBTServiceSwitchFireMode, SwitchFireModeMap) == 0x0000A8, "Member 'UGzBTServiceSwitchFireMode::SwitchFireModeMap' has a wrong offset!");
static_assert(offsetof(UGzBTServiceSwitchFireMode, FireModeKey) == 0x0000F8, "Member 'UGzBTServiceSwitchFireMode::FireModeKey' has a wrong offset!");

// Class G01.GzNavLinkProxy
// 0x0048 (0x0338 - 0x02F0)
class AGzNavLinkProxy : public ANavLinkProxy
{
public:
	bool                                          CanBeRegenerated;                                  // 0x02F0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ENavLinkDirection                             NavLinkDirection;                                  // 0x02F1(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2EFD[0x6];                                     // 0x02F2(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                LeftMidPoint;                                      // 0x02F8(0x0018)(Edit, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                RightMidPoint;                                     // 0x0310(0x0018)(Edit, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class AGzAICharacter*                         CurrentAgent;                                      // 0x0328(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bLeftToRightMovement;                              // 0x0330(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2EFE[0x7];                                     // 0x0331(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzNavLinkProxy">();
	}
	static class AGzNavLinkProxy* GetDefaultObj()
	{
		return GetDefaultObjImpl<AGzNavLinkProxy>();
	}
};
static_assert(alignof(AGzNavLinkProxy) == 0x000008, "Wrong alignment on AGzNavLinkProxy");
static_assert(sizeof(AGzNavLinkProxy) == 0x000338, "Wrong size on AGzNavLinkProxy");
static_assert(offsetof(AGzNavLinkProxy, CanBeRegenerated) == 0x0002F0, "Member 'AGzNavLinkProxy::CanBeRegenerated' has a wrong offset!");
static_assert(offsetof(AGzNavLinkProxy, NavLinkDirection) == 0x0002F1, "Member 'AGzNavLinkProxy::NavLinkDirection' has a wrong offset!");
static_assert(offsetof(AGzNavLinkProxy, LeftMidPoint) == 0x0002F8, "Member 'AGzNavLinkProxy::LeftMidPoint' has a wrong offset!");
static_assert(offsetof(AGzNavLinkProxy, RightMidPoint) == 0x000310, "Member 'AGzNavLinkProxy::RightMidPoint' has a wrong offset!");
static_assert(offsetof(AGzNavLinkProxy, CurrentAgent) == 0x000328, "Member 'AGzNavLinkProxy::CurrentAgent' has a wrong offset!");
static_assert(offsetof(AGzNavLinkProxy, bLeftToRightMovement) == 0x000330, "Member 'AGzNavLinkProxy::bLeftToRightMovement' has a wrong offset!");

// Class G01.GzContainerItemData
// 0x0058 (0x0420 - 0x03C8)
class UGzContainerItemData final : public UGzSimpleItemData
{
public:
	TSoftObjectPtr<class UGzDropTableData>        DropTable;                                         // 0x03C8(0x0028)(UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGzDecodePayment                       DecodePayment;                                     // 0x03F0(0x0010)(Edit, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	EGzItemType                                   RewardPoolType;                                    // 0x0400(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2EFF[0x7];                                     // 0x0401(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FGzLootTableVariant>            LootTableVariants;                                 // 0x0408(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FColor                                 HexTrailColor;                                     // 0x0418(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2F00[0x4];                                     // 0x041C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzContainerItemData">();
	}
	static class UGzContainerItemData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzContainerItemData>();
	}
};
static_assert(alignof(UGzContainerItemData) == 0x000008, "Wrong alignment on UGzContainerItemData");
static_assert(sizeof(UGzContainerItemData) == 0x000420, "Wrong size on UGzContainerItemData");
static_assert(offsetof(UGzContainerItemData, DropTable) == 0x0003C8, "Member 'UGzContainerItemData::DropTable' has a wrong offset!");
static_assert(offsetof(UGzContainerItemData, DecodePayment) == 0x0003F0, "Member 'UGzContainerItemData::DecodePayment' has a wrong offset!");
static_assert(offsetof(UGzContainerItemData, RewardPoolType) == 0x000400, "Member 'UGzContainerItemData::RewardPoolType' has a wrong offset!");
static_assert(offsetof(UGzContainerItemData, LootTableVariants) == 0x000408, "Member 'UGzContainerItemData::LootTableVariants' has a wrong offset!");
static_assert(offsetof(UGzContainerItemData, HexTrailColor) == 0x000418, "Member 'UGzContainerItemData::HexTrailColor' has a wrong offset!");

// Class G01.GzAutoNavLink
// 0x0000 (0x0338 - 0x0338)
class AGzAutoNavLink : public AGzNavLinkProxy
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzAutoNavLink">();
	}
	static class AGzAutoNavLink* GetDefaultObj()
	{
		return GetDefaultObjImpl<AGzAutoNavLink>();
	}
};
static_assert(alignof(AGzAutoNavLink) == 0x000008, "Wrong alignment on AGzAutoNavLink");
static_assert(sizeof(AGzAutoNavLink) == 0x000338, "Wrong size on AGzAutoNavLink");

// Class G01.GzQuickOrderComponent
// 0x00C8 (0x0170 - 0x00A8)
class UGzQuickOrderComponent : public UPawnComponent
{
public:
	FMulticastInlineDelegateProperty_             OnOrderAvailabilityChanged;                        // 0x00A8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_2F01[0x30];                                    // 0x00B8(0x0030)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftClassPtr<class UClass>                   DeliveryDroneClass;                                // 0x00E8(0x0028)(Edit, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UGzPawnInputMappingConfig*              SelectionMappingConfig;                            // 0x0110(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         DeliveryLocationSelectionRadius;                   // 0x0118(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         CheckTimeDeviation;                                // 0x011C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	ECollisionChannel                             BlockingVolumeChannel;                             // 0x0120(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2F02[0x3];                                     // 0x0121(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         LineTraceExtend;                                   // 0x0124(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UGzDeliveryTransportSettings*           CachedDeliverySettings;                            // 0x0128(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class AGzDeliveryPreviewMarker*               DeliveryLocationMarker;                            // 0x0130(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2F03[0x38];                                    // 0x0138(0x0038)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void EndSelectingDeliveryLocation();
	void Server_SpawnDeliveryDrone(const struct FGuid& LoadoutGuid, const struct FVector& InDeliveryLocation);
	void StartSelectingDeliveryLocation(const struct FGuid& LoadoutGuid);
	bool TryCallDrone();

	bool CanCallDeliveryDrone() const;
	float GetCallDroneAvailableTime() const;
	float GetDroneRemainingCooldown() const;
	bool IsSelectingLocation() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzQuickOrderComponent">();
	}
	static class UGzQuickOrderComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzQuickOrderComponent>();
	}
};
static_assert(alignof(UGzQuickOrderComponent) == 0x000008, "Wrong alignment on UGzQuickOrderComponent");
static_assert(sizeof(UGzQuickOrderComponent) == 0x000170, "Wrong size on UGzQuickOrderComponent");
static_assert(offsetof(UGzQuickOrderComponent, OnOrderAvailabilityChanged) == 0x0000A8, "Member 'UGzQuickOrderComponent::OnOrderAvailabilityChanged' has a wrong offset!");
static_assert(offsetof(UGzQuickOrderComponent, DeliveryDroneClass) == 0x0000E8, "Member 'UGzQuickOrderComponent::DeliveryDroneClass' has a wrong offset!");
static_assert(offsetof(UGzQuickOrderComponent, SelectionMappingConfig) == 0x000110, "Member 'UGzQuickOrderComponent::SelectionMappingConfig' has a wrong offset!");
static_assert(offsetof(UGzQuickOrderComponent, DeliveryLocationSelectionRadius) == 0x000118, "Member 'UGzQuickOrderComponent::DeliveryLocationSelectionRadius' has a wrong offset!");
static_assert(offsetof(UGzQuickOrderComponent, CheckTimeDeviation) == 0x00011C, "Member 'UGzQuickOrderComponent::CheckTimeDeviation' has a wrong offset!");
static_assert(offsetof(UGzQuickOrderComponent, BlockingVolumeChannel) == 0x000120, "Member 'UGzQuickOrderComponent::BlockingVolumeChannel' has a wrong offset!");
static_assert(offsetof(UGzQuickOrderComponent, LineTraceExtend) == 0x000124, "Member 'UGzQuickOrderComponent::LineTraceExtend' has a wrong offset!");
static_assert(offsetof(UGzQuickOrderComponent, CachedDeliverySettings) == 0x000128, "Member 'UGzQuickOrderComponent::CachedDeliverySettings' has a wrong offset!");
static_assert(offsetof(UGzQuickOrderComponent, DeliveryLocationMarker) == 0x000130, "Member 'UGzQuickOrderComponent::DeliveryLocationMarker' has a wrong offset!");

// Class G01.GzAutoPerformanceCollector
// 0x0000 (0x02A0 - 0x02A0)
class AGzAutoPerformanceCollector final : public AActor
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzAutoPerformanceCollector">();
	}
	static class AGzAutoPerformanceCollector* GetDefaultObj()
	{
		return GetDefaultObjImpl<AGzAutoPerformanceCollector>();
	}
};
static_assert(alignof(AGzAutoPerformanceCollector) == 0x000008, "Wrong alignment on AGzAutoPerformanceCollector");
static_assert(sizeof(AGzAutoPerformanceCollector) == 0x0002A0, "Wrong size on AGzAutoPerformanceCollector");

// Class G01.GzScoreboardHeader
// 0x0020 (0x0300 - 0x02E0)
class UGzScoreboardHeader : public UUserWidget
{
public:
	class UHorizontalBox*                         StatNamesContainer;                                // 0x02E0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FMargin                                StatPadding;                                       // 0x02E8(0x0010)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	TSubclassOf<class UGzScoreValueWidget>        ValueWidgetClass;                                  // 0x02F8(0x0008)(Edit, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzScoreboardHeader">();
	}
	static class UGzScoreboardHeader* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzScoreboardHeader>();
	}
};
static_assert(alignof(UGzScoreboardHeader) == 0x000008, "Wrong alignment on UGzScoreboardHeader");
static_assert(sizeof(UGzScoreboardHeader) == 0x000300, "Wrong size on UGzScoreboardHeader");
static_assert(offsetof(UGzScoreboardHeader, StatNamesContainer) == 0x0002E0, "Member 'UGzScoreboardHeader::StatNamesContainer' has a wrong offset!");
static_assert(offsetof(UGzScoreboardHeader, StatPadding) == 0x0002E8, "Member 'UGzScoreboardHeader::StatPadding' has a wrong offset!");
static_assert(offsetof(UGzScoreboardHeader, ValueWidgetClass) == 0x0002F8, "Member 'UGzScoreboardHeader::ValueWidgetClass' has a wrong offset!");

// Class G01.GzAutoReplaySubsystem
// 0x0020 (0x0050 - 0x0030)
class UGzAutoReplaySubsystem final : public UGameInstanceSubsystem
{
public:
	uint8                                         Pad_2F04[0x8];                                     // 0x0030(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class AGzReplayPlayerController*              ReplayController;                                  // 0x0038(0x0008)(ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2F05[0x10];                                    // 0x0040(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnReplayPlaybackComplete(class UWorld* World);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzAutoReplaySubsystem">();
	}
	static class UGzAutoReplaySubsystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzAutoReplaySubsystem>();
	}
};
static_assert(alignof(UGzAutoReplaySubsystem) == 0x000008, "Wrong alignment on UGzAutoReplaySubsystem");
static_assert(sizeof(UGzAutoReplaySubsystem) == 0x000050, "Wrong size on UGzAutoReplaySubsystem");
static_assert(offsetof(UGzAutoReplaySubsystem, ReplayController) == 0x000038, "Member 'UGzAutoReplaySubsystem::ReplayController' has a wrong offset!");

// Class G01.GzBTTaskIdlePawnRotation
// 0x0018 (0x00B0 - 0x0098)
class UGzBTTaskIdlePawnRotation final : public UBTTask_BlackboardBase
{
public:
	float                                         RotationAngle;                                     // 0x0098(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RotationSpeed;                                     // 0x009C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseRandomAngle;                                   // 0x00A0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2F06[0x3];                                     // 0x00A1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MinRotationAngle;                                  // 0x00A4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxRotationAngle;                                  // 0x00A8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2F07[0x4];                                     // 0x00AC(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzBTTaskIdlePawnRotation">();
	}
	static class UGzBTTaskIdlePawnRotation* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzBTTaskIdlePawnRotation>();
	}
};
static_assert(alignof(UGzBTTaskIdlePawnRotation) == 0x000008, "Wrong alignment on UGzBTTaskIdlePawnRotation");
static_assert(sizeof(UGzBTTaskIdlePawnRotation) == 0x0000B0, "Wrong size on UGzBTTaskIdlePawnRotation");
static_assert(offsetof(UGzBTTaskIdlePawnRotation, RotationAngle) == 0x000098, "Member 'UGzBTTaskIdlePawnRotation::RotationAngle' has a wrong offset!");
static_assert(offsetof(UGzBTTaskIdlePawnRotation, RotationSpeed) == 0x00009C, "Member 'UGzBTTaskIdlePawnRotation::RotationSpeed' has a wrong offset!");
static_assert(offsetof(UGzBTTaskIdlePawnRotation, bUseRandomAngle) == 0x0000A0, "Member 'UGzBTTaskIdlePawnRotation::bUseRandomAngle' has a wrong offset!");
static_assert(offsetof(UGzBTTaskIdlePawnRotation, MinRotationAngle) == 0x0000A4, "Member 'UGzBTTaskIdlePawnRotation::MinRotationAngle' has a wrong offset!");
static_assert(offsetof(UGzBTTaskIdlePawnRotation, MaxRotationAngle) == 0x0000A8, "Member 'UGzBTTaskIdlePawnRotation::MaxRotationAngle' has a wrong offset!");

// Class G01.GzAutoRespawnAvailabilityMessage
// 0x0008 (0x0030 - 0x0028)
class UGzAutoRespawnAvailabilityMessage final : public UGzGameMessage
{
public:
	float                                         RespawnAvailabilityChangeTime;                     // 0x0028(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAvailable;                                        // 0x002C(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2F08[0x3];                                     // 0x002D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	float GetAutoRespawnChangeTime() const;
	float GetNewAvailabilityStatus() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzAutoRespawnAvailabilityMessage">();
	}
	static class UGzAutoRespawnAvailabilityMessage* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzAutoRespawnAvailabilityMessage>();
	}
};
static_assert(alignof(UGzAutoRespawnAvailabilityMessage) == 0x000008, "Wrong alignment on UGzAutoRespawnAvailabilityMessage");
static_assert(sizeof(UGzAutoRespawnAvailabilityMessage) == 0x000030, "Wrong size on UGzAutoRespawnAvailabilityMessage");
static_assert(offsetof(UGzAutoRespawnAvailabilityMessage, RespawnAvailabilityChangeTime) == 0x000028, "Member 'UGzAutoRespawnAvailabilityMessage::RespawnAvailabilityChangeTime' has a wrong offset!");
static_assert(offsetof(UGzAutoRespawnAvailabilityMessage, bAvailable) == 0x00002C, "Member 'UGzAutoRespawnAvailabilityMessage::bAvailable' has a wrong offset!");

// Class G01.GzCoreBlueprintFunctionLibrary
// 0x0000 (0x0028 - 0x0028)
class UGzCoreBlueprintFunctionLibrary final : public UBlueprintFunctionLibrary
{
public:
	static void LogStreamingGridInfo(const class UObject* WorldContextObject);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzCoreBlueprintFunctionLibrary">();
	}
	static class UGzCoreBlueprintFunctionLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzCoreBlueprintFunctionLibrary>();
	}
};
static_assert(alignof(UGzCoreBlueprintFunctionLibrary) == 0x000008, "Wrong alignment on UGzCoreBlueprintFunctionLibrary");
static_assert(sizeof(UGzCoreBlueprintFunctionLibrary) == 0x000028, "Wrong size on UGzCoreBlueprintFunctionLibrary");

// Class G01.GzAutotestCommandComponentDefault
// 0x0020 (0x0118 - 0x00F8)
class UGzAutotestCommandComponentDefault : public UGzAutotestComponent
{
public:
	class FName                                   TriggerNameEnd;                                    // 0x00F8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   PathToTriggerEnd;                                  // 0x0100(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UShapeComponent*                        TriggerEnd;                                        // 0x0108(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bShouldHaveEndTrigger;                             // 0x0110(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2F09[0x7];                                     // 0x0111(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzAutotestCommandComponentDefault">();
	}
	static class UGzAutotestCommandComponentDefault* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzAutotestCommandComponentDefault>();
	}
};
static_assert(alignof(UGzAutotestCommandComponentDefault) == 0x000008, "Wrong alignment on UGzAutotestCommandComponentDefault");
static_assert(sizeof(UGzAutotestCommandComponentDefault) == 0x000118, "Wrong size on UGzAutotestCommandComponentDefault");
static_assert(offsetof(UGzAutotestCommandComponentDefault, TriggerNameEnd) == 0x0000F8, "Member 'UGzAutotestCommandComponentDefault::TriggerNameEnd' has a wrong offset!");
static_assert(offsetof(UGzAutotestCommandComponentDefault, PathToTriggerEnd) == 0x000100, "Member 'UGzAutotestCommandComponentDefault::PathToTriggerEnd' has a wrong offset!");
static_assert(offsetof(UGzAutotestCommandComponentDefault, TriggerEnd) == 0x000108, "Member 'UGzAutotestCommandComponentDefault::TriggerEnd' has a wrong offset!");
static_assert(offsetof(UGzAutotestCommandComponentDefault, bShouldHaveEndTrigger) == 0x000110, "Member 'UGzAutotestCommandComponentDefault::bShouldHaveEndTrigger' has a wrong offset!");

// Class G01.GzBR_PrepareMatchStage
// 0x0000 (0x0110 - 0x0110)
class UGzBR_PrepareMatchStage final : public UGzGameStageBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzBR_PrepareMatchStage">();
	}
	static class UGzBR_PrepareMatchStage* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzBR_PrepareMatchStage>();
	}
};
static_assert(alignof(UGzBR_PrepareMatchStage) == 0x000008, "Wrong alignment on UGzBR_PrepareMatchStage");
static_assert(sizeof(UGzBR_PrepareMatchStage) == 0x000110, "Wrong size on UGzBR_PrepareMatchStage");

// Class G01.GzAutotestCommandCrouch
// 0x0000 (0x0118 - 0x0118)
class UGzAutotestCommandCrouch final : public UGzAutotestCommandComponentDefault
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzAutotestCommandCrouch">();
	}
	static class UGzAutotestCommandCrouch* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzAutotestCommandCrouch>();
	}
};
static_assert(alignof(UGzAutotestCommandCrouch) == 0x000008, "Wrong alignment on UGzAutotestCommandCrouch");
static_assert(sizeof(UGzAutotestCommandCrouch) == 0x000118, "Wrong size on UGzAutotestCommandCrouch");

// Class G01.GzAutotestCommandCutBodyPart
// 0x0010 (0x0128 - 0x0118)
class UGzAutotestCommandCutBodyPart final : public UGzAutotestCommandComponentDefault
{
public:
	EGzLimbType                                   BodyPartTypeToCut;                                 // 0x0118(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2F0A[0x3];                                     // 0x0119(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         DetachWaitTime;                                    // 0x011C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2F0B[0x8];                                     // 0x0120(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzAutotestCommandCutBodyPart">();
	}
	static class UGzAutotestCommandCutBodyPart* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzAutotestCommandCutBodyPart>();
	}
};
static_assert(alignof(UGzAutotestCommandCutBodyPart) == 0x000008, "Wrong alignment on UGzAutotestCommandCutBodyPart");
static_assert(sizeof(UGzAutotestCommandCutBodyPart) == 0x000128, "Wrong size on UGzAutotestCommandCutBodyPart");
static_assert(offsetof(UGzAutotestCommandCutBodyPart, BodyPartTypeToCut) == 0x000118, "Member 'UGzAutotestCommandCutBodyPart::BodyPartTypeToCut' has a wrong offset!");
static_assert(offsetof(UGzAutotestCommandCutBodyPart, DetachWaitTime) == 0x00011C, "Member 'UGzAutotestCommandCutBodyPart::DetachWaitTime' has a wrong offset!");

// Class G01.GzLoadoutSelectionScreenSharedContainer
// 0x0008 (0x0680 - 0x0678)
class UGzLoadoutSelectionScreenSharedContainer : public UGzLoadoutSelectionScreen
{
public:
	class AGzPlayerCharacter*                     CachedOwningPlayerCharacter;                       // 0x0678(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzLoadoutSelectionScreenSharedContainer">();
	}
	static class UGzLoadoutSelectionScreenSharedContainer* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzLoadoutSelectionScreenSharedContainer>();
	}
};
static_assert(alignof(UGzLoadoutSelectionScreenSharedContainer) == 0x000008, "Wrong alignment on UGzLoadoutSelectionScreenSharedContainer");
static_assert(sizeof(UGzLoadoutSelectionScreenSharedContainer) == 0x000680, "Wrong size on UGzLoadoutSelectionScreenSharedContainer");
static_assert(offsetof(UGzLoadoutSelectionScreenSharedContainer, CachedOwningPlayerCharacter) == 0x000678, "Member 'UGzLoadoutSelectionScreenSharedContainer::CachedOwningPlayerCharacter' has a wrong offset!");

// Class G01.GzBulletSubsystem
// 0x0098 (0x00D8 - 0x0040)
class UGzBulletSubsystem final : public UTickableWorldSubsystem
{
public:
	uint8                                         Pad_2F0C[0x30];                                    // 0x0040(0x0030)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FGzBullet>                      BulletsList;                                       // 0x0070(0x0010)(ZeroConstructor, Transient, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	TMap<struct FGzBulletID, class UNiagaraComponent*> NiagaraTracesList;                                 // 0x0080(0x0050)(ExportObject, Transient, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	class APlayerController*                      LocalPlayerControllerCache;                        // 0x00D0(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzBulletSubsystem">();
	}
	static class UGzBulletSubsystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzBulletSubsystem>();
	}
};
static_assert(alignof(UGzBulletSubsystem) == 0x000008, "Wrong alignment on UGzBulletSubsystem");
static_assert(sizeof(UGzBulletSubsystem) == 0x0000D8, "Wrong size on UGzBulletSubsystem");
static_assert(offsetof(UGzBulletSubsystem, BulletsList) == 0x000070, "Member 'UGzBulletSubsystem::BulletsList' has a wrong offset!");
static_assert(offsetof(UGzBulletSubsystem, NiagaraTracesList) == 0x000080, "Member 'UGzBulletSubsystem::NiagaraTracesList' has a wrong offset!");
static_assert(offsetof(UGzBulletSubsystem, LocalPlayerControllerCache) == 0x0000D0, "Member 'UGzBulletSubsystem::LocalPlayerControllerCache' has a wrong offset!");

// Class G01.GzAutotestCommandDropWeapon
// 0x0028 (0x0140 - 0x0118)
class UGzAutotestCommandDropWeapon final : public UGzAutotestCommandComponentDefault
{
public:
	struct FGameplayTagContainer                  SlotsToDrop;                                       // 0x0118(0x0020)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	bool                                          bDropNear;                                         // 0x0138(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2F0D[0x7];                                     // 0x0139(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzAutotestCommandDropWeapon">();
	}
	static class UGzAutotestCommandDropWeapon* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzAutotestCommandDropWeapon>();
	}
};
static_assert(alignof(UGzAutotestCommandDropWeapon) == 0x000008, "Wrong alignment on UGzAutotestCommandDropWeapon");
static_assert(sizeof(UGzAutotestCommandDropWeapon) == 0x000140, "Wrong size on UGzAutotestCommandDropWeapon");
static_assert(offsetof(UGzAutotestCommandDropWeapon, SlotsToDrop) == 0x000118, "Member 'UGzAutotestCommandDropWeapon::SlotsToDrop' has a wrong offset!");
static_assert(offsetof(UGzAutotestCommandDropWeapon, bDropNear) == 0x000138, "Member 'UGzAutotestCommandDropWeapon::bDropNear' has a wrong offset!");

// Class G01.GzCreatePartyData
// 0x0010 (0x0038 - 0x0028)
class UGzCreatePartyData final : public UGzSignalREventData
{
public:
	uint8                                         Pad_2F0E[0x10];                                    // 0x0028(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzCreatePartyData">();
	}
	static class UGzCreatePartyData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzCreatePartyData>();
	}
};
static_assert(alignof(UGzCreatePartyData) == 0x000008, "Wrong alignment on UGzCreatePartyData");
static_assert(sizeof(UGzCreatePartyData) == 0x000038, "Wrong size on UGzCreatePartyData");

// Class G01.GzAutotestCommandInteract
// 0x0038 (0x0150 - 0x0118)
class UGzAutotestCommandInteract : public UGzAutotestCommandComponentDefault
{
public:
	uint8                                         Pad_2F0F[0x8];                                     // 0x0118(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class AActor*                                 ActorToInteract;                                   // 0x0120(0x0008)(BlueprintVisible, Net, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UGzItemData*                            ItemToCheck;                                       // 0x0128(0x0008)(Edit, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bDoOnce;                                           // 0x0130(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2F10[0x3];                                     // 0x0131(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         InteractionWaitDelay;                              // 0x0134(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bContinousAction;                                  // 0x0138(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2F11[0x17];                                    // 0x0139(0x0017)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnInteract(class AActor* InteractedBy, const class UGzInteractableComponent* Interaction);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzAutotestCommandInteract">();
	}
	static class UGzAutotestCommandInteract* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzAutotestCommandInteract>();
	}
};
static_assert(alignof(UGzAutotestCommandInteract) == 0x000008, "Wrong alignment on UGzAutotestCommandInteract");
static_assert(sizeof(UGzAutotestCommandInteract) == 0x000150, "Wrong size on UGzAutotestCommandInteract");
static_assert(offsetof(UGzAutotestCommandInteract, ActorToInteract) == 0x000120, "Member 'UGzAutotestCommandInteract::ActorToInteract' has a wrong offset!");
static_assert(offsetof(UGzAutotestCommandInteract, ItemToCheck) == 0x000128, "Member 'UGzAutotestCommandInteract::ItemToCheck' has a wrong offset!");
static_assert(offsetof(UGzAutotestCommandInteract, bDoOnce) == 0x000130, "Member 'UGzAutotestCommandInteract::bDoOnce' has a wrong offset!");
static_assert(offsetof(UGzAutotestCommandInteract, InteractionWaitDelay) == 0x000134, "Member 'UGzAutotestCommandInteract::InteractionWaitDelay' has a wrong offset!");
static_assert(offsetof(UGzAutotestCommandInteract, bContinousAction) == 0x000138, "Member 'UGzAutotestCommandInteract::bContinousAction' has a wrong offset!");

// Class G01.GzHealthInterface
// 0x0000 (0x0028 - 0x0028)
class IGzHealthInterface final : public IInterface
{
public:
	float GetHealth() const;
	float GetMaxHealth() const;
	bool IsAlive() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzHealthInterface">();
	}
	static class IGzHealthInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IGzHealthInterface>();
	}
};
static_assert(alignof(IGzHealthInterface) == 0x000008, "Wrong alignment on IGzHealthInterface");
static_assert(sizeof(IGzHealthInterface) == 0x000028, "Wrong size on IGzHealthInterface");

// Class G01.GzMapWidgetExtension
// 0x0010 (0x0038 - 0x0028)
class UGzMapWidgetExtension : public UGzUserWidgetExtension
{
public:
	class UGzMapWidget*                           ParentMap;                                         // 0x0028(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2F12[0x8];                                     // 0x0030(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnMapReady();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzMapWidgetExtension">();
	}
	static class UGzMapWidgetExtension* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzMapWidgetExtension>();
	}
};
static_assert(alignof(UGzMapWidgetExtension) == 0x000008, "Wrong alignment on UGzMapWidgetExtension");
static_assert(sizeof(UGzMapWidgetExtension) == 0x000038, "Wrong size on UGzMapWidgetExtension");
static_assert(offsetof(UGzMapWidgetExtension, ParentMap) == 0x000028, "Member 'UGzMapWidgetExtension::ParentMap' has a wrong offset!");

// Class G01.GzBRZoneExtension
// 0x0018 (0x0050 - 0x0038)
class UGzBRZoneExtension : public UGzMapWidgetExtension
{
public:
	class UMaterialInterface*                     ZoneFillMaterial;                                  // 0x0038(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UGzZoneFillLayerWidget*                 ZoneFillLayerWidget;                               // 0x0040(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         LayerZOrder;                                       // 0x0048(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2F13[0x4];                                     // 0x004C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzBRZoneExtension">();
	}
	static class UGzBRZoneExtension* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzBRZoneExtension>();
	}
};
static_assert(alignof(UGzBRZoneExtension) == 0x000008, "Wrong alignment on UGzBRZoneExtension");
static_assert(sizeof(UGzBRZoneExtension) == 0x000050, "Wrong size on UGzBRZoneExtension");
static_assert(offsetof(UGzBRZoneExtension, ZoneFillMaterial) == 0x000038, "Member 'UGzBRZoneExtension::ZoneFillMaterial' has a wrong offset!");
static_assert(offsetof(UGzBRZoneExtension, ZoneFillLayerWidget) == 0x000040, "Member 'UGzBRZoneExtension::ZoneFillLayerWidget' has a wrong offset!");
static_assert(offsetof(UGzBRZoneExtension, LayerZOrder) == 0x000048, "Member 'UGzBRZoneExtension::LayerZOrder' has a wrong offset!");

// Class G01.GzPropagationStrategy
// 0x00A0 (0x00C8 - 0x0028)
class UGzPropagationStrategy : public UObject
{
public:
	uint8                                         Pad_2F14[0x8];                                     // 0x0028(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UGzPropagationConfiguration*            Config;                                            // 0x0030(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UGzPropagationCollisionStrategy*        CollisionStrategy;                                 // 0x0038(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class AActor*                                 OuterActor;                                        // 0x0040(0x0008)(ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class AActor*                                 OuterOwner;                                        // 0x0048(0x0008)(ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2F15[0x78];                                    // 0x0050(0x0078)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzPropagationStrategy">();
	}
	static class UGzPropagationStrategy* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzPropagationStrategy>();
	}
};
static_assert(alignof(UGzPropagationStrategy) == 0x000008, "Wrong alignment on UGzPropagationStrategy");
static_assert(sizeof(UGzPropagationStrategy) == 0x0000C8, "Wrong size on UGzPropagationStrategy");
static_assert(offsetof(UGzPropagationStrategy, Config) == 0x000030, "Member 'UGzPropagationStrategy::Config' has a wrong offset!");
static_assert(offsetof(UGzPropagationStrategy, CollisionStrategy) == 0x000038, "Member 'UGzPropagationStrategy::CollisionStrategy' has a wrong offset!");
static_assert(offsetof(UGzPropagationStrategy, OuterActor) == 0x000040, "Member 'UGzPropagationStrategy::OuterActor' has a wrong offset!");
static_assert(offsetof(UGzPropagationStrategy, OuterOwner) == 0x000048, "Member 'UGzPropagationStrategy::OuterOwner' has a wrong offset!");

// Class G01.GzPropagationStrategy_Grid
// 0x0020 (0x00E8 - 0x00C8)
class UGzPropagationStrategy_Grid : public UGzPropagationStrategy
{
public:
	uint8                                         Pad_2F16[0x18];                                    // 0x00C8(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	class UGzPropagationStrategyConfig_Grid*      GridConfig;                                        // 0x00E0(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzPropagationStrategy_Grid">();
	}
	static class UGzPropagationStrategy_Grid* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzPropagationStrategy_Grid>();
	}
};
static_assert(alignof(UGzPropagationStrategy_Grid) == 0x000008, "Wrong alignment on UGzPropagationStrategy_Grid");
static_assert(sizeof(UGzPropagationStrategy_Grid) == 0x0000E8, "Wrong size on UGzPropagationStrategy_Grid");
static_assert(offsetof(UGzPropagationStrategy_Grid, GridConfig) == 0x0000E0, "Member 'UGzPropagationStrategy_Grid::GridConfig' has a wrong offset!");

// Class G01.GzAutotestCommandInteractNearObject
// 0x0000 (0x0150 - 0x0150)
class UGzAutotestCommandInteractNearObject final : public UGzAutotestCommandInteract
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzAutotestCommandInteractNearObject">();
	}
	static class UGzAutotestCommandInteractNearObject* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzAutotestCommandInteractNearObject>();
	}
};
static_assert(alignof(UGzAutotestCommandInteractNearObject) == 0x000008, "Wrong alignment on UGzAutotestCommandInteractNearObject");
static_assert(sizeof(UGzAutotestCommandInteractNearObject) == 0x000150, "Wrong size on UGzAutotestCommandInteractNearObject");

// Class G01.GzPropagationActor
// 0x01E8 (0x0488 - 0x02A0)
class AGzPropagationActor : public AActor
{
public:
	uint8                                         Pad_2F17[0x10];                                    // 0x02A0(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class UGzAbilitySystemComponent*              AbilitySystemComponent;                            // 0x02B0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bPropagateOnSpawn;                                 // 0x02B8(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bRetrySpawningInitialPoint;                        // 0x02B9(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2F18[0x2];                                     // 0x02BA(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         InitialPointRetryInterval;                         // 0x02BC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         MaxPropagationPoints;                              // 0x02C0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bUsePropagationSpeed;                              // 0x02C4(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2F19[0x3];                                     // 0x02C5(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         PropagationSpeed;                                  // 0x02C8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bApplyGravityToPropgationSpeed;                    // 0x02CC(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2F1A[0x3];                                     // 0x02CD(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         GravityMultiplier;                                 // 0x02D0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         PropagationDelay;                                  // 0x02D4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         PropagationDelayVarianceMin;                       // 0x02D8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         PropagationDelayVarianceMax;                       // 0x02DC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         SpawnSurfaceTraceLength;                           // 0x02E0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2F1B[0x4];                                     // 0x02E4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<ECollisionChannel>                     ValidSpawnSurfaceObjectTypes;                      // 0x02E8(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	float                                         GapBetweenPoints;                                  // 0x02F8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MinPropagationDistance;                            // 0x02FC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bUseUpwardsGrowthLimit;                            // 0x0300(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2F1C[0x3];                                     // 0x0301(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         UpwardsGrowthLimit;                                // 0x0304(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bUseDownwardsGrowthLimit;                          // 0x0308(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2F1D[0x3];                                     // 0x0309(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         DownwardsGrowthLimit;                              // 0x030C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         CollisionTraceVerticalOffset;                      // 0x0310(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bRequireSurfaceToPropagate;                        // 0x0314(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2F1E[0x3];                                     // 0x0315(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         SurfaceCheckDistance;                              // 0x0318(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2F1F[0x4];                                     // 0x031C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UGzItemData*                            ItemData;                                          // 0x0320(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2F20[0x18];                                    // 0x0328(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGzPropagationPointArray               PointTracker;                                      // 0x0340(0x0128)(Net, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_2F21[0x10];                                    // 0x0468(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGzCharacterIdAccess                   CharacterIdAccess;                                 // 0x0478(0x0010)(BlueprintVisible, Transient, NoDestructor, NativeAccessSpecifierPublic)

public:
	void OnPropagationPointActivated(const int32 PropagationPointID, const struct FVector& Location, const struct FVector& Normal, const float PointLifespan);
	void OnPropagationPointDeactivated(const int32 PropagationPointID, const struct FVector& Location, const struct FVector& Normal);
	void RegisterCollisionComponentWithPoint(const int32 PropagationPointID, class UPrimitiveComponent* CollisionComponent);
	void RegisterVisualComponentWithPoint(const int32 PropagationPointID, class USceneComponent* VisualComponent);
	void StartPropagation();

	float GetAdjustedLifespan(const float TotalLifespan) const;
	struct FGameplayEffectContextHandle MakeEffectContext() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzPropagationActor">();
	}
	static class AGzPropagationActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<AGzPropagationActor>();
	}
};
static_assert(alignof(AGzPropagationActor) == 0x000008, "Wrong alignment on AGzPropagationActor");
static_assert(sizeof(AGzPropagationActor) == 0x000488, "Wrong size on AGzPropagationActor");
static_assert(offsetof(AGzPropagationActor, AbilitySystemComponent) == 0x0002B0, "Member 'AGzPropagationActor::AbilitySystemComponent' has a wrong offset!");
static_assert(offsetof(AGzPropagationActor, bPropagateOnSpawn) == 0x0002B8, "Member 'AGzPropagationActor::bPropagateOnSpawn' has a wrong offset!");
static_assert(offsetof(AGzPropagationActor, bRetrySpawningInitialPoint) == 0x0002B9, "Member 'AGzPropagationActor::bRetrySpawningInitialPoint' has a wrong offset!");
static_assert(offsetof(AGzPropagationActor, InitialPointRetryInterval) == 0x0002BC, "Member 'AGzPropagationActor::InitialPointRetryInterval' has a wrong offset!");
static_assert(offsetof(AGzPropagationActor, MaxPropagationPoints) == 0x0002C0, "Member 'AGzPropagationActor::MaxPropagationPoints' has a wrong offset!");
static_assert(offsetof(AGzPropagationActor, bUsePropagationSpeed) == 0x0002C4, "Member 'AGzPropagationActor::bUsePropagationSpeed' has a wrong offset!");
static_assert(offsetof(AGzPropagationActor, PropagationSpeed) == 0x0002C8, "Member 'AGzPropagationActor::PropagationSpeed' has a wrong offset!");
static_assert(offsetof(AGzPropagationActor, bApplyGravityToPropgationSpeed) == 0x0002CC, "Member 'AGzPropagationActor::bApplyGravityToPropgationSpeed' has a wrong offset!");
static_assert(offsetof(AGzPropagationActor, GravityMultiplier) == 0x0002D0, "Member 'AGzPropagationActor::GravityMultiplier' has a wrong offset!");
static_assert(offsetof(AGzPropagationActor, PropagationDelay) == 0x0002D4, "Member 'AGzPropagationActor::PropagationDelay' has a wrong offset!");
static_assert(offsetof(AGzPropagationActor, PropagationDelayVarianceMin) == 0x0002D8, "Member 'AGzPropagationActor::PropagationDelayVarianceMin' has a wrong offset!");
static_assert(offsetof(AGzPropagationActor, PropagationDelayVarianceMax) == 0x0002DC, "Member 'AGzPropagationActor::PropagationDelayVarianceMax' has a wrong offset!");
static_assert(offsetof(AGzPropagationActor, SpawnSurfaceTraceLength) == 0x0002E0, "Member 'AGzPropagationActor::SpawnSurfaceTraceLength' has a wrong offset!");
static_assert(offsetof(AGzPropagationActor, ValidSpawnSurfaceObjectTypes) == 0x0002E8, "Member 'AGzPropagationActor::ValidSpawnSurfaceObjectTypes' has a wrong offset!");
static_assert(offsetof(AGzPropagationActor, GapBetweenPoints) == 0x0002F8, "Member 'AGzPropagationActor::GapBetweenPoints' has a wrong offset!");
static_assert(offsetof(AGzPropagationActor, MinPropagationDistance) == 0x0002FC, "Member 'AGzPropagationActor::MinPropagationDistance' has a wrong offset!");
static_assert(offsetof(AGzPropagationActor, bUseUpwardsGrowthLimit) == 0x000300, "Member 'AGzPropagationActor::bUseUpwardsGrowthLimit' has a wrong offset!");
static_assert(offsetof(AGzPropagationActor, UpwardsGrowthLimit) == 0x000304, "Member 'AGzPropagationActor::UpwardsGrowthLimit' has a wrong offset!");
static_assert(offsetof(AGzPropagationActor, bUseDownwardsGrowthLimit) == 0x000308, "Member 'AGzPropagationActor::bUseDownwardsGrowthLimit' has a wrong offset!");
static_assert(offsetof(AGzPropagationActor, DownwardsGrowthLimit) == 0x00030C, "Member 'AGzPropagationActor::DownwardsGrowthLimit' has a wrong offset!");
static_assert(offsetof(AGzPropagationActor, CollisionTraceVerticalOffset) == 0x000310, "Member 'AGzPropagationActor::CollisionTraceVerticalOffset' has a wrong offset!");
static_assert(offsetof(AGzPropagationActor, bRequireSurfaceToPropagate) == 0x000314, "Member 'AGzPropagationActor::bRequireSurfaceToPropagate' has a wrong offset!");
static_assert(offsetof(AGzPropagationActor, SurfaceCheckDistance) == 0x000318, "Member 'AGzPropagationActor::SurfaceCheckDistance' has a wrong offset!");
static_assert(offsetof(AGzPropagationActor, ItemData) == 0x000320, "Member 'AGzPropagationActor::ItemData' has a wrong offset!");
static_assert(offsetof(AGzPropagationActor, PointTracker) == 0x000340, "Member 'AGzPropagationActor::PointTracker' has a wrong offset!");
static_assert(offsetof(AGzPropagationActor, CharacterIdAccess) == 0x000478, "Member 'AGzPropagationActor::CharacterIdAccess' has a wrong offset!");

// Class G01.GzStickyGooPropagationActor
// 0x00C0 (0x0548 - 0x0488)
class AGzStickyGooPropagationActor final : public AGzPropagationActor
{
public:
	uint8                                         Pad_2F27[0x8];                                     // 0x0488(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bEnableFriendlyFire;                               // 0x0490(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2F28[0x7];                                     // 0x0491(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UGameplayEffect>            EffectClass;                                       // 0x0498(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UNiagaraSystem*                         PrimaryVFX_System;                                 // 0x04A0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UNiagaraSystem*                         SecondaryVFX_System;                               // 0x04A8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         InitialPlacementChance;                            // 0x04B0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         MaxTries;                                          // 0x04B4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MinDistanceToCenter;                               // 0x04B8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         PrimaryVFXLocationCheckGridSize;                   // 0x04BC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         PrimaryLocationCheckGridGapSize;                   // 0x04C0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         PrimaryValidLocationThreshold;                     // 0x04C4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         SecondaryVFXLocationCheckGridSize;                 // 0x04C8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         SecondaryLocationCheckGridGapSize;                 // 0x04CC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         SecondaryValidLocationThreshold;                   // 0x04D0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         SecondaryVFX_InstanceLimit;                        // 0x04D4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MinDistanceBewtweenSecondaryVFX;                   // 0x04D8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bUpdateScale_PrimaryVFX;                           // 0x04DC(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bUpdateScale_SecondaryVFX;                         // 0x04DD(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bApplyRandomOffset_PrimaryVFX;                     // 0x04DE(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2F29[0x1];                                     // 0x04DF(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         RandomOffsetMagnitude_PrimaryVFX;                  // 0x04E0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bApplyRandomOffset_SecondaryVFX;                   // 0x04E4(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2F2A[0x3];                                     // 0x04E5(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         RandomOffsetMagnitude_SecondaryVFX;                // 0x04E8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MaxRadius_PrimaryVFX;                              // 0x04EC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MaxRadius_SecondaryVFX;                            // 0x04F0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         VFXScaleDuration;                                  // 0x04F4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bRemoveGooWhenBurning;                             // 0x04F8(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2F2B[0x7];                                     // 0x04F9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UGzBodyPartAbilityData_StickyGoo*       AbilityData;                                       // 0x0500(0x0008)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2F2C[0x40];                                    // 0x0508(0x0040)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnPawnBeginOverlap(class AActor* OverlappedActor, class AActor* OtherActor);
	void OnPawnEndOverlap(class AActor* OverlappedActor, class AActor* OtherActor);
	void OnRep_AbilityData();
	void OnScaleDownStart();
	class UNiagaraComponent* SpawnDecalNiagaraComponent(const struct FVector& WorldLocation, const struct FRotator& Rotation);
	class UNiagaraComponent* SpawnPrimaryNiagaraComponent(const struct FVector& WorldLocation, const struct FVector& Normal);
	class UNiagaraComponent* SpawnSecondaryNiagaraComponent(const struct FVector& WorldLocation, const struct FVector& Normal);
	void UpdateVFX(const float DeltaSeconds, class UNiagaraComponent* Instance, const float ScaleProgress, const float MaxRadius);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzStickyGooPropagationActor">();
	}
	static class AGzStickyGooPropagationActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<AGzStickyGooPropagationActor>();
	}
};
static_assert(alignof(AGzStickyGooPropagationActor) == 0x000008, "Wrong alignment on AGzStickyGooPropagationActor");
static_assert(sizeof(AGzStickyGooPropagationActor) == 0x000548, "Wrong size on AGzStickyGooPropagationActor");
static_assert(offsetof(AGzStickyGooPropagationActor, bEnableFriendlyFire) == 0x000490, "Member 'AGzStickyGooPropagationActor::bEnableFriendlyFire' has a wrong offset!");
static_assert(offsetof(AGzStickyGooPropagationActor, EffectClass) == 0x000498, "Member 'AGzStickyGooPropagationActor::EffectClass' has a wrong offset!");
static_assert(offsetof(AGzStickyGooPropagationActor, PrimaryVFX_System) == 0x0004A0, "Member 'AGzStickyGooPropagationActor::PrimaryVFX_System' has a wrong offset!");
static_assert(offsetof(AGzStickyGooPropagationActor, SecondaryVFX_System) == 0x0004A8, "Member 'AGzStickyGooPropagationActor::SecondaryVFX_System' has a wrong offset!");
static_assert(offsetof(AGzStickyGooPropagationActor, InitialPlacementChance) == 0x0004B0, "Member 'AGzStickyGooPropagationActor::InitialPlacementChance' has a wrong offset!");
static_assert(offsetof(AGzStickyGooPropagationActor, MaxTries) == 0x0004B4, "Member 'AGzStickyGooPropagationActor::MaxTries' has a wrong offset!");
static_assert(offsetof(AGzStickyGooPropagationActor, MinDistanceToCenter) == 0x0004B8, "Member 'AGzStickyGooPropagationActor::MinDistanceToCenter' has a wrong offset!");
static_assert(offsetof(AGzStickyGooPropagationActor, PrimaryVFXLocationCheckGridSize) == 0x0004BC, "Member 'AGzStickyGooPropagationActor::PrimaryVFXLocationCheckGridSize' has a wrong offset!");
static_assert(offsetof(AGzStickyGooPropagationActor, PrimaryLocationCheckGridGapSize) == 0x0004C0, "Member 'AGzStickyGooPropagationActor::PrimaryLocationCheckGridGapSize' has a wrong offset!");
static_assert(offsetof(AGzStickyGooPropagationActor, PrimaryValidLocationThreshold) == 0x0004C4, "Member 'AGzStickyGooPropagationActor::PrimaryValidLocationThreshold' has a wrong offset!");
static_assert(offsetof(AGzStickyGooPropagationActor, SecondaryVFXLocationCheckGridSize) == 0x0004C8, "Member 'AGzStickyGooPropagationActor::SecondaryVFXLocationCheckGridSize' has a wrong offset!");
static_assert(offsetof(AGzStickyGooPropagationActor, SecondaryLocationCheckGridGapSize) == 0x0004CC, "Member 'AGzStickyGooPropagationActor::SecondaryLocationCheckGridGapSize' has a wrong offset!");
static_assert(offsetof(AGzStickyGooPropagationActor, SecondaryValidLocationThreshold) == 0x0004D0, "Member 'AGzStickyGooPropagationActor::SecondaryValidLocationThreshold' has a wrong offset!");
static_assert(offsetof(AGzStickyGooPropagationActor, SecondaryVFX_InstanceLimit) == 0x0004D4, "Member 'AGzStickyGooPropagationActor::SecondaryVFX_InstanceLimit' has a wrong offset!");
static_assert(offsetof(AGzStickyGooPropagationActor, MinDistanceBewtweenSecondaryVFX) == 0x0004D8, "Member 'AGzStickyGooPropagationActor::MinDistanceBewtweenSecondaryVFX' has a wrong offset!");
static_assert(offsetof(AGzStickyGooPropagationActor, bUpdateScale_PrimaryVFX) == 0x0004DC, "Member 'AGzStickyGooPropagationActor::bUpdateScale_PrimaryVFX' has a wrong offset!");
static_assert(offsetof(AGzStickyGooPropagationActor, bUpdateScale_SecondaryVFX) == 0x0004DD, "Member 'AGzStickyGooPropagationActor::bUpdateScale_SecondaryVFX' has a wrong offset!");
static_assert(offsetof(AGzStickyGooPropagationActor, bApplyRandomOffset_PrimaryVFX) == 0x0004DE, "Member 'AGzStickyGooPropagationActor::bApplyRandomOffset_PrimaryVFX' has a wrong offset!");
static_assert(offsetof(AGzStickyGooPropagationActor, RandomOffsetMagnitude_PrimaryVFX) == 0x0004E0, "Member 'AGzStickyGooPropagationActor::RandomOffsetMagnitude_PrimaryVFX' has a wrong offset!");
static_assert(offsetof(AGzStickyGooPropagationActor, bApplyRandomOffset_SecondaryVFX) == 0x0004E4, "Member 'AGzStickyGooPropagationActor::bApplyRandomOffset_SecondaryVFX' has a wrong offset!");
static_assert(offsetof(AGzStickyGooPropagationActor, RandomOffsetMagnitude_SecondaryVFX) == 0x0004E8, "Member 'AGzStickyGooPropagationActor::RandomOffsetMagnitude_SecondaryVFX' has a wrong offset!");
static_assert(offsetof(AGzStickyGooPropagationActor, MaxRadius_PrimaryVFX) == 0x0004EC, "Member 'AGzStickyGooPropagationActor::MaxRadius_PrimaryVFX' has a wrong offset!");
static_assert(offsetof(AGzStickyGooPropagationActor, MaxRadius_SecondaryVFX) == 0x0004F0, "Member 'AGzStickyGooPropagationActor::MaxRadius_SecondaryVFX' has a wrong offset!");
static_assert(offsetof(AGzStickyGooPropagationActor, VFXScaleDuration) == 0x0004F4, "Member 'AGzStickyGooPropagationActor::VFXScaleDuration' has a wrong offset!");
static_assert(offsetof(AGzStickyGooPropagationActor, bRemoveGooWhenBurning) == 0x0004F8, "Member 'AGzStickyGooPropagationActor::bRemoveGooWhenBurning' has a wrong offset!");
static_assert(offsetof(AGzStickyGooPropagationActor, AbilityData) == 0x000500, "Member 'AGzStickyGooPropagationActor::AbilityData' has a wrong offset!");

// Class G01.GzKnockDownStatCollector
// 0x0008 (0x0040 - 0x0038)
class UGzKnockDownStatCollector final : public UGzGlobalStatsCollector
{
public:
	uint8                                         Pad_2F2E[0x8];                                     // 0x0038(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzKnockDownStatCollector">();
	}
	static class UGzKnockDownStatCollector* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzKnockDownStatCollector>();
	}
};
static_assert(alignof(UGzKnockDownStatCollector) == 0x000008, "Wrong alignment on UGzKnockDownStatCollector");
static_assert(sizeof(UGzKnockDownStatCollector) == 0x000040, "Wrong size on UGzKnockDownStatCollector");

// Class G01.GzAutotestCommandWithFailBox
// 0x0018 (0x0130 - 0x0118)
class UGzAutotestCommandWithFailBox : public UGzAutotestCommandComponentDefault
{
public:
	class FName                                   TriggerNameBoxFailed;                              // 0x0118(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   PathToTriggerBoxFailed;                            // 0x0120(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UShapeComponent*                        TriggerBoxFailed;                                  // 0x0128(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzAutotestCommandWithFailBox">();
	}
	static class UGzAutotestCommandWithFailBox* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzAutotestCommandWithFailBox>();
	}
};
static_assert(alignof(UGzAutotestCommandWithFailBox) == 0x000008, "Wrong alignment on UGzAutotestCommandWithFailBox");
static_assert(sizeof(UGzAutotestCommandWithFailBox) == 0x000130, "Wrong size on UGzAutotestCommandWithFailBox");
static_assert(offsetof(UGzAutotestCommandWithFailBox, TriggerNameBoxFailed) == 0x000118, "Member 'UGzAutotestCommandWithFailBox::TriggerNameBoxFailed' has a wrong offset!");
static_assert(offsetof(UGzAutotestCommandWithFailBox, PathToTriggerBoxFailed) == 0x000120, "Member 'UGzAutotestCommandWithFailBox::PathToTriggerBoxFailed' has a wrong offset!");
static_assert(offsetof(UGzAutotestCommandWithFailBox, TriggerBoxFailed) == 0x000128, "Member 'UGzAutotestCommandWithFailBox::TriggerBoxFailed' has a wrong offset!");

// Class G01.GzBodyPartAbilityData_HardeningGoo
// 0x0010 (0x0090 - 0x0080)
class UGzBodyPartAbilityData_HardeningGoo final : public UGzBodyPartAbilityData
{
public:
	float                                         LifeSpan;                                          // 0x0080(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HealthRegenPerSecond;                              // 0x0084(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         GooMaxHealth;                                      // 0x0088(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2F2F[0x4];                                     // 0x008C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzBodyPartAbilityData_HardeningGoo">();
	}
	static class UGzBodyPartAbilityData_HardeningGoo* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzBodyPartAbilityData_HardeningGoo>();
	}
};
static_assert(alignof(UGzBodyPartAbilityData_HardeningGoo) == 0x000008, "Wrong alignment on UGzBodyPartAbilityData_HardeningGoo");
static_assert(sizeof(UGzBodyPartAbilityData_HardeningGoo) == 0x000090, "Wrong size on UGzBodyPartAbilityData_HardeningGoo");
static_assert(offsetof(UGzBodyPartAbilityData_HardeningGoo, LifeSpan) == 0x000080, "Member 'UGzBodyPartAbilityData_HardeningGoo::LifeSpan' has a wrong offset!");
static_assert(offsetof(UGzBodyPartAbilityData_HardeningGoo, HealthRegenPerSecond) == 0x000084, "Member 'UGzBodyPartAbilityData_HardeningGoo::HealthRegenPerSecond' has a wrong offset!");
static_assert(offsetof(UGzBodyPartAbilityData_HardeningGoo, GooMaxHealth) == 0x000088, "Member 'UGzBodyPartAbilityData_HardeningGoo::GooMaxHealth' has a wrong offset!");

// Class G01.GzAutotestCommandJump
// 0x0000 (0x0130 - 0x0130)
class UGzAutotestCommandJump final : public UGzAutotestCommandWithFailBox
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzAutotestCommandJump">();
	}
	static class UGzAutotestCommandJump* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzAutotestCommandJump>();
	}
};
static_assert(alignof(UGzAutotestCommandJump) == 0x000008, "Wrong alignment on UGzAutotestCommandJump");
static_assert(sizeof(UGzAutotestCommandJump) == 0x000130, "Wrong size on UGzAutotestCommandJump");

// Class G01.GzLegalSettings
// 0x03E8 (0x0420 - 0x0038)
class UGzLegalSettings final : public UDeveloperSettings
{
public:
	uint8                                         Pad_2F30[0x8];                                     // 0x0038(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGzPlatformLegalDocs                   PlatformDocuments[0x4];                            // 0x0040(0x00D0)(Edit, Config, DisableEditOnInstance, NativeAccessSpecifierPublic)
	class FText                                   SieEulaTexts[0x5];                                 // 0x0380(0x0010)(Edit, Config, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TMap<class FString, class FString>            SupportedTagsUsage;                                // 0x03D0(0x0050)(Edit, DisableEditOnInstance, EditConst, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzLegalSettings">();
	}
	static class UGzLegalSettings* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzLegalSettings>();
	}
};
static_assert(alignof(UGzLegalSettings) == 0x000008, "Wrong alignment on UGzLegalSettings");
static_assert(sizeof(UGzLegalSettings) == 0x000420, "Wrong size on UGzLegalSettings");
static_assert(offsetof(UGzLegalSettings, PlatformDocuments) == 0x000040, "Member 'UGzLegalSettings::PlatformDocuments' has a wrong offset!");
static_assert(offsetof(UGzLegalSettings, SieEulaTexts) == 0x000380, "Member 'UGzLegalSettings::SieEulaTexts' has a wrong offset!");
static_assert(offsetof(UGzLegalSettings, SupportedTagsUsage) == 0x0003D0, "Member 'UGzLegalSettings::SupportedTagsUsage' has a wrong offset!");

// Class G01.GzAutotestCommandMoveTo
// 0x0030 (0x0148 - 0x0118)
class UGzAutotestCommandMoveTo final : public UGzAutotestCommandComponentDefault
{
public:
	bool                                          bShouldSprint;                                     // 0x0118(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2F31[0x3];                                     // 0x0119(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         TimeWaitToSprint;                                  // 0x011C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2F32[0x28];                                    // 0x0120(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzAutotestCommandMoveTo">();
	}
	static class UGzAutotestCommandMoveTo* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzAutotestCommandMoveTo>();
	}
};
static_assert(alignof(UGzAutotestCommandMoveTo) == 0x000008, "Wrong alignment on UGzAutotestCommandMoveTo");
static_assert(sizeof(UGzAutotestCommandMoveTo) == 0x000148, "Wrong size on UGzAutotestCommandMoveTo");
static_assert(offsetof(UGzAutotestCommandMoveTo, bShouldSprint) == 0x000118, "Member 'UGzAutotestCommandMoveTo::bShouldSprint' has a wrong offset!");
static_assert(offsetof(UGzAutotestCommandMoveTo, TimeWaitToSprint) == 0x00011C, "Member 'UGzAutotestCommandMoveTo::TimeWaitToSprint' has a wrong offset!");

// Class G01.GzPlayerInventoryModel
// 0x0058 (0x00C8 - 0x0070)
class UGzPlayerInventoryModel final : public UGzBackendModel
{
public:
	uint8                                         Pad_2F33[0x58];                                    // 0x0070(0x0058)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzPlayerInventoryModel">();
	}
	static class UGzPlayerInventoryModel* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzPlayerInventoryModel>();
	}
};
static_assert(alignof(UGzPlayerInventoryModel) == 0x000008, "Wrong alignment on UGzPlayerInventoryModel");
static_assert(sizeof(UGzPlayerInventoryModel) == 0x0000C8, "Wrong size on UGzPlayerInventoryModel");

// Class G01.GzBTService_MirrorLimbMove
// 0x0048 (0x00E0 - 0x0098)
class UGzBTService_MirrorLimbMove final : public UBTService_BlackboardBase
{
public:
	float                                         InitialDistance;                                   // 0x0098(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TimeToMove;                                        // 0x009C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         VelocityBacklash;                                  // 0x00A0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2F34[0x4];                                     // 0x00A4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class AGzAIController*                        AIController;                                      // 0x00A8(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UBlackboardComponent*                   BlackboardComponent;                               // 0x00B0(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class AGzCharacter*                           NpcPawn;                                           // 0x00B8(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FVector                                TargetLocation;                                    // 0x00C0(0x0018)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         CurrentMovementTime;                               // 0x00D8(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2F35[0x4];                                     // 0x00DC(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	bool CheckIsFalling();
	void StartMove();
	void StopMovement();

	bool CheckIsNeedStop() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzBTService_MirrorLimbMove">();
	}
	static class UGzBTService_MirrorLimbMove* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzBTService_MirrorLimbMove>();
	}
};
static_assert(alignof(UGzBTService_MirrorLimbMove) == 0x000008, "Wrong alignment on UGzBTService_MirrorLimbMove");
static_assert(sizeof(UGzBTService_MirrorLimbMove) == 0x0000E0, "Wrong size on UGzBTService_MirrorLimbMove");
static_assert(offsetof(UGzBTService_MirrorLimbMove, InitialDistance) == 0x000098, "Member 'UGzBTService_MirrorLimbMove::InitialDistance' has a wrong offset!");
static_assert(offsetof(UGzBTService_MirrorLimbMove, TimeToMove) == 0x00009C, "Member 'UGzBTService_MirrorLimbMove::TimeToMove' has a wrong offset!");
static_assert(offsetof(UGzBTService_MirrorLimbMove, VelocityBacklash) == 0x0000A0, "Member 'UGzBTService_MirrorLimbMove::VelocityBacklash' has a wrong offset!");
static_assert(offsetof(UGzBTService_MirrorLimbMove, AIController) == 0x0000A8, "Member 'UGzBTService_MirrorLimbMove::AIController' has a wrong offset!");
static_assert(offsetof(UGzBTService_MirrorLimbMove, BlackboardComponent) == 0x0000B0, "Member 'UGzBTService_MirrorLimbMove::BlackboardComponent' has a wrong offset!");
static_assert(offsetof(UGzBTService_MirrorLimbMove, NpcPawn) == 0x0000B8, "Member 'UGzBTService_MirrorLimbMove::NpcPawn' has a wrong offset!");
static_assert(offsetof(UGzBTService_MirrorLimbMove, TargetLocation) == 0x0000C0, "Member 'UGzBTService_MirrorLimbMove::TargetLocation' has a wrong offset!");
static_assert(offsetof(UGzBTService_MirrorLimbMove, CurrentMovementTime) == 0x0000D8, "Member 'UGzBTService_MirrorLimbMove::CurrentMovementTime' has a wrong offset!");

// Class G01.GzAutotestCommandShoot
// 0x0038 (0x0150 - 0x0118)
class UGzAutotestCommandShoot final : public UGzAutotestCommandComponentDefault
{
public:
	uint8                                         Pad_2F36[0x8];                                     // 0x0118(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class AActor*                                 ActorToAim;                                        // 0x0120(0x0008)(BlueprintVisible, Net, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   AimSocketName;                                     // 0x0128(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FGameplayTag                           PocketSlotToUse;                                   // 0x0130(0x0008)(Edit, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ShootDelay;                                        // 0x0138(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         ShootCount;                                        // 0x013C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2F37[0x10];                                    // 0x0140(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzAutotestCommandShoot">();
	}
	static class UGzAutotestCommandShoot* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzAutotestCommandShoot>();
	}
};
static_assert(alignof(UGzAutotestCommandShoot) == 0x000008, "Wrong alignment on UGzAutotestCommandShoot");
static_assert(sizeof(UGzAutotestCommandShoot) == 0x000150, "Wrong size on UGzAutotestCommandShoot");
static_assert(offsetof(UGzAutotestCommandShoot, ActorToAim) == 0x000120, "Member 'UGzAutotestCommandShoot::ActorToAim' has a wrong offset!");
static_assert(offsetof(UGzAutotestCommandShoot, AimSocketName) == 0x000128, "Member 'UGzAutotestCommandShoot::AimSocketName' has a wrong offset!");
static_assert(offsetof(UGzAutotestCommandShoot, PocketSlotToUse) == 0x000130, "Member 'UGzAutotestCommandShoot::PocketSlotToUse' has a wrong offset!");
static_assert(offsetof(UGzAutotestCommandShoot, ShootDelay) == 0x000138, "Member 'UGzAutotestCommandShoot::ShootDelay' has a wrong offset!");
static_assert(offsetof(UGzAutotestCommandShoot, ShootCount) == 0x00013C, "Member 'UGzAutotestCommandShoot::ShootCount' has a wrong offset!");

// Class G01.GzAutotestCommandUseLimb
// 0x0040 (0x0158 - 0x0118)
class UGzAutotestCommandUseLimb : public UGzAutotestCommandComponentDefault
{
public:
	FMulticastSparseDelegateProperty_             OnLimbActivationDelegate;                          // 0x0118(0x0001)(InstancedReference, BlueprintAssignable, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_2F38[0x7];                                     // 0x0119(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                AimPosition;                                       // 0x0120(0x0018)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EGzLimbType                                   LimbType;                                          // 0x0138(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2F39[0x1F];                                    // 0x0139(0x001F)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnLimbActivated();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzAutotestCommandUseLimb">();
	}
	static class UGzAutotestCommandUseLimb* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzAutotestCommandUseLimb>();
	}
};
static_assert(alignof(UGzAutotestCommandUseLimb) == 0x000008, "Wrong alignment on UGzAutotestCommandUseLimb");
static_assert(sizeof(UGzAutotestCommandUseLimb) == 0x000158, "Wrong size on UGzAutotestCommandUseLimb");
static_assert(offsetof(UGzAutotestCommandUseLimb, OnLimbActivationDelegate) == 0x000118, "Member 'UGzAutotestCommandUseLimb::OnLimbActivationDelegate' has a wrong offset!");
static_assert(offsetof(UGzAutotestCommandUseLimb, AimPosition) == 0x000120, "Member 'UGzAutotestCommandUseLimb::AimPosition' has a wrong offset!");
static_assert(offsetof(UGzAutotestCommandUseLimb, LimbType) == 0x000138, "Member 'UGzAutotestCommandUseLimb::LimbType' has a wrong offset!");

// Class G01.GzKillAttributionComponent
// 0x00E0 (0x0188 - 0x00A8)
class UGzKillAttributionComponent final : public UActorComponent
{
public:
	TMap<struct FGzAdvancedIdType, struct FGzDamageMark> DamageMarks;                                       // 0x00A8(0x0050)(Transient, Protected, NativeAccessSpecifierProtected)
	TArray<struct FActiveGameplayEffectHandle>    DebuffEffectsSnapshot;                             // 0x00F8(0x0010)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	struct FGzMarkAttributionResult               LatestAttributionResult;                           // 0x0108(0x0080)(Transient, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzKillAttributionComponent">();
	}
	static class UGzKillAttributionComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzKillAttributionComponent>();
	}
};
static_assert(alignof(UGzKillAttributionComponent) == 0x000008, "Wrong alignment on UGzKillAttributionComponent");
static_assert(sizeof(UGzKillAttributionComponent) == 0x000188, "Wrong size on UGzKillAttributionComponent");
static_assert(offsetof(UGzKillAttributionComponent, DamageMarks) == 0x0000A8, "Member 'UGzKillAttributionComponent::DamageMarks' has a wrong offset!");
static_assert(offsetof(UGzKillAttributionComponent, DebuffEffectsSnapshot) == 0x0000F8, "Member 'UGzKillAttributionComponent::DebuffEffectsSnapshot' has a wrong offset!");
static_assert(offsetof(UGzKillAttributionComponent, LatestAttributionResult) == 0x000108, "Member 'UGzKillAttributionComponent::LatestAttributionResult' has a wrong offset!");

// Class G01.GzBodyPartAbilityData_KatanaArm
// 0x0018 (0x0098 - 0x0080)
class UGzBodyPartAbilityData_KatanaArm final : public UGzBodyPartAbilityData
{
public:
	float                                         CenterConeAttackDamage;                            // 0x0080(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SideConeAttackDamage;                              // 0x0084(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         VerticalAttackDamage;                              // 0x0088(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxAttackRange_Horizontal;                         // 0x008C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxAttackRange_Vertical;                           // 0x0090(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEnableHomingAssist;                               // 0x0094(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2F3A[0x3];                                     // 0x0095(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzBodyPartAbilityData_KatanaArm">();
	}
	static class UGzBodyPartAbilityData_KatanaArm* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzBodyPartAbilityData_KatanaArm>();
	}
};
static_assert(alignof(UGzBodyPartAbilityData_KatanaArm) == 0x000008, "Wrong alignment on UGzBodyPartAbilityData_KatanaArm");
static_assert(sizeof(UGzBodyPartAbilityData_KatanaArm) == 0x000098, "Wrong size on UGzBodyPartAbilityData_KatanaArm");
static_assert(offsetof(UGzBodyPartAbilityData_KatanaArm, CenterConeAttackDamage) == 0x000080, "Member 'UGzBodyPartAbilityData_KatanaArm::CenterConeAttackDamage' has a wrong offset!");
static_assert(offsetof(UGzBodyPartAbilityData_KatanaArm, SideConeAttackDamage) == 0x000084, "Member 'UGzBodyPartAbilityData_KatanaArm::SideConeAttackDamage' has a wrong offset!");
static_assert(offsetof(UGzBodyPartAbilityData_KatanaArm, VerticalAttackDamage) == 0x000088, "Member 'UGzBodyPartAbilityData_KatanaArm::VerticalAttackDamage' has a wrong offset!");
static_assert(offsetof(UGzBodyPartAbilityData_KatanaArm, MaxAttackRange_Horizontal) == 0x00008C, "Member 'UGzBodyPartAbilityData_KatanaArm::MaxAttackRange_Horizontal' has a wrong offset!");
static_assert(offsetof(UGzBodyPartAbilityData_KatanaArm, MaxAttackRange_Vertical) == 0x000090, "Member 'UGzBodyPartAbilityData_KatanaArm::MaxAttackRange_Vertical' has a wrong offset!");
static_assert(offsetof(UGzBodyPartAbilityData_KatanaArm, bEnableHomingAssist) == 0x000094, "Member 'UGzBodyPartAbilityData_KatanaArm::bEnableHomingAssist' has a wrong offset!");

// Class G01.GzAutotestCommandUseLimbCharged
// 0x0020 (0x0178 - 0x0158)
class UGzAutotestCommandUseLimbCharged final : public UGzAutotestCommandUseLimb
{
public:
	float                                         DelayAfterUse;                                     // 0x0158(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ChargeTime;                                        // 0x015C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FKey                                   ActivateButton;                                    // 0x0160(0x0018)(Edit, DisableEditOnInstance, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzAutotestCommandUseLimbCharged">();
	}
	static class UGzAutotestCommandUseLimbCharged* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzAutotestCommandUseLimbCharged>();
	}
};
static_assert(alignof(UGzAutotestCommandUseLimbCharged) == 0x000008, "Wrong alignment on UGzAutotestCommandUseLimbCharged");
static_assert(sizeof(UGzAutotestCommandUseLimbCharged) == 0x000178, "Wrong size on UGzAutotestCommandUseLimbCharged");
static_assert(offsetof(UGzAutotestCommandUseLimbCharged, DelayAfterUse) == 0x000158, "Member 'UGzAutotestCommandUseLimbCharged::DelayAfterUse' has a wrong offset!");
static_assert(offsetof(UGzAutotestCommandUseLimbCharged, ChargeTime) == 0x00015C, "Member 'UGzAutotestCommandUseLimbCharged::ChargeTime' has a wrong offset!");
static_assert(offsetof(UGzAutotestCommandUseLimbCharged, ActivateButton) == 0x000160, "Member 'UGzAutotestCommandUseLimbCharged::ActivateButton' has a wrong offset!");

// Class G01.GzAutotestCommandUseLimbImmediate
// 0x0018 (0x0170 - 0x0158)
class UGzAutotestCommandUseLimbImmediate final : public UGzAutotestCommandUseLimb
{
public:
	struct FKey                                   ActivateButton;                                    // 0x0158(0x0018)(Edit, DisableEditOnInstance, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzAutotestCommandUseLimbImmediate">();
	}
	static class UGzAutotestCommandUseLimbImmediate* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzAutotestCommandUseLimbImmediate>();
	}
};
static_assert(alignof(UGzAutotestCommandUseLimbImmediate) == 0x000008, "Wrong alignment on UGzAutotestCommandUseLimbImmediate");
static_assert(sizeof(UGzAutotestCommandUseLimbImmediate) == 0x000170, "Wrong size on UGzAutotestCommandUseLimbImmediate");
static_assert(offsetof(UGzAutotestCommandUseLimbImmediate, ActivateButton) == 0x000158, "Member 'UGzAutotestCommandUseLimbImmediate::ActivateButton' has a wrong offset!");

// Class G01.GzLootSpawnerComponent
// 0x0060 (0x0108 - 0x00A8)
class UGzLootSpawnerComponent : public UActorComponent
{
public:
	struct FVector                                InitialSpawnLocationOffset;                        // 0x00A8(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                FinalSpawnLocationOffset;                          // 0x00C0(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector2D                              RandomFinalSpawnLocationOffsetForSlot;             // 0x00D8(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         SpawnDelay;                                        // 0x00E8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bUseLootStacking;                                  // 0x00EC(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2F3B[0x3];                                     // 0x00ED(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FGzSpawnParameters>             SpawnParameters;                                   // 0x00F0(0x0010)(Edit, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	float                                         LegsSpawnImpulseMultiplier;                        // 0x0100(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ArmsSpawnImpulseMultiplier;                        // 0x0104(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void SpawnLoot(const struct FGzSpawnContentsParameters& SpawnContentParameters);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzLootSpawnerComponent">();
	}
	static class UGzLootSpawnerComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzLootSpawnerComponent>();
	}
};
static_assert(alignof(UGzLootSpawnerComponent) == 0x000008, "Wrong alignment on UGzLootSpawnerComponent");
static_assert(sizeof(UGzLootSpawnerComponent) == 0x000108, "Wrong size on UGzLootSpawnerComponent");
static_assert(offsetof(UGzLootSpawnerComponent, InitialSpawnLocationOffset) == 0x0000A8, "Member 'UGzLootSpawnerComponent::InitialSpawnLocationOffset' has a wrong offset!");
static_assert(offsetof(UGzLootSpawnerComponent, FinalSpawnLocationOffset) == 0x0000C0, "Member 'UGzLootSpawnerComponent::FinalSpawnLocationOffset' has a wrong offset!");
static_assert(offsetof(UGzLootSpawnerComponent, RandomFinalSpawnLocationOffsetForSlot) == 0x0000D8, "Member 'UGzLootSpawnerComponent::RandomFinalSpawnLocationOffsetForSlot' has a wrong offset!");
static_assert(offsetof(UGzLootSpawnerComponent, SpawnDelay) == 0x0000E8, "Member 'UGzLootSpawnerComponent::SpawnDelay' has a wrong offset!");
static_assert(offsetof(UGzLootSpawnerComponent, bUseLootStacking) == 0x0000EC, "Member 'UGzLootSpawnerComponent::bUseLootStacking' has a wrong offset!");
static_assert(offsetof(UGzLootSpawnerComponent, SpawnParameters) == 0x0000F0, "Member 'UGzLootSpawnerComponent::SpawnParameters' has a wrong offset!");
static_assert(offsetof(UGzLootSpawnerComponent, LegsSpawnImpulseMultiplier) == 0x000100, "Member 'UGzLootSpawnerComponent::LegsSpawnImpulseMultiplier' has a wrong offset!");
static_assert(offsetof(UGzLootSpawnerComponent, ArmsSpawnImpulseMultiplier) == 0x000104, "Member 'UGzLootSpawnerComponent::ArmsSpawnImpulseMultiplier' has a wrong offset!");

// Class G01.GzGridLootSpawnerComponent
// 0x0020 (0x0128 - 0x0108)
class UGzGridLootSpawnerComponent final : public UGzLootSpawnerComponent
{
public:
	int32                                         ItemsPerRow;                                       // 0x0108(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2F3C[0x4];                                     // 0x010C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector2D                              SpawnGridSize;                                     // 0x0110(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2F3D[0x8];                                     // 0x0120(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzGridLootSpawnerComponent">();
	}
	static class UGzGridLootSpawnerComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzGridLootSpawnerComponent>();
	}
};
static_assert(alignof(UGzGridLootSpawnerComponent) == 0x000008, "Wrong alignment on UGzGridLootSpawnerComponent");
static_assert(sizeof(UGzGridLootSpawnerComponent) == 0x000128, "Wrong size on UGzGridLootSpawnerComponent");
static_assert(offsetof(UGzGridLootSpawnerComponent, ItemsPerRow) == 0x000108, "Member 'UGzGridLootSpawnerComponent::ItemsPerRow' has a wrong offset!");
static_assert(offsetof(UGzGridLootSpawnerComponent, SpawnGridSize) == 0x000110, "Member 'UGzGridLootSpawnerComponent::SpawnGridSize' has a wrong offset!");

// Class G01.GzBR_PostMatchStage
// 0x0008 (0x0118 - 0x0110)
class UGzBR_PostMatchStage final : public UGzGameStageBase
{
public:
	uint8                                         Pad_2F3E[0x8];                                     // 0x0110(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzBR_PostMatchStage">();
	}
	static class UGzBR_PostMatchStage* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzBR_PostMatchStage>();
	}
};
static_assert(alignof(UGzBR_PostMatchStage) == 0x000008, "Wrong alignment on UGzBR_PostMatchStage");
static_assert(sizeof(UGzBR_PostMatchStage) == 0x000118, "Wrong size on UGzBR_PostMatchStage");

// Class G01.GzLoadoutSelectionScreenTraining
// 0x0018 (0x0690 - 0x0678)
class UGzLoadoutSelectionScreenTraining final : public UGzLoadoutSelectionScreen
{
public:
	class UGzTrainingPresetsData*                 PresetsData;                                       // 0x0678(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<struct FGzInvItem>                     RequiredItems;                                     // 0x0680(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzLoadoutSelectionScreenTraining">();
	}
	static class UGzLoadoutSelectionScreenTraining* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzLoadoutSelectionScreenTraining>();
	}
};
static_assert(alignof(UGzLoadoutSelectionScreenTraining) == 0x000008, "Wrong alignment on UGzLoadoutSelectionScreenTraining");
static_assert(sizeof(UGzLoadoutSelectionScreenTraining) == 0x000690, "Wrong size on UGzLoadoutSelectionScreenTraining");
static_assert(offsetof(UGzLoadoutSelectionScreenTraining, PresetsData) == 0x000678, "Member 'UGzLoadoutSelectionScreenTraining::PresetsData' has a wrong offset!");
static_assert(offsetof(UGzLoadoutSelectionScreenTraining, RequiredItems) == 0x000680, "Member 'UGzLoadoutSelectionScreenTraining::RequiredItems' has a wrong offset!");

// Class G01.GzAutotestCommandWingsuit
// 0x0040 (0x0170 - 0x0130)
class UGzAutotestCommandWingsuit final : public UGzAutotestCommandWithFailBox
{
public:
	class UGzCharacterMovementComponent*          PlayerMoveComp;                                    // 0x0130(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         WingsuitWaitDelay;                                 // 0x0138(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2F3F[0x14];                                    // 0x013C(0x0014)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   RoundaboutPointName;                               // 0x0150(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2F40[0x18];                                    // 0x0158(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzAutotestCommandWingsuit">();
	}
	static class UGzAutotestCommandWingsuit* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzAutotestCommandWingsuit>();
	}
};
static_assert(alignof(UGzAutotestCommandWingsuit) == 0x000008, "Wrong alignment on UGzAutotestCommandWingsuit");
static_assert(sizeof(UGzAutotestCommandWingsuit) == 0x000170, "Wrong size on UGzAutotestCommandWingsuit");
static_assert(offsetof(UGzAutotestCommandWingsuit, PlayerMoveComp) == 0x000130, "Member 'UGzAutotestCommandWingsuit::PlayerMoveComp' has a wrong offset!");
static_assert(offsetof(UGzAutotestCommandWingsuit, WingsuitWaitDelay) == 0x000138, "Member 'UGzAutotestCommandWingsuit::WingsuitWaitDelay' has a wrong offset!");
static_assert(offsetof(UGzAutotestCommandWingsuit, RoundaboutPointName) == 0x000150, "Member 'UGzAutotestCommandWingsuit::RoundaboutPointName' has a wrong offset!");

// Class G01.GzInitialShrinkingZoneSetup
// 0x0018 (0x02B8 - 0x02A0)
class AGzInitialShrinkingZoneSetup : public AActor
{
public:
	float                                         SpawnHeight;                                       // 0x02A0(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FGameplayTag                           ZoneTag;                                           // 0x02A4(0x0008)(Edit, DisableEditOnTemplate, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2F41[0x4];                                     // 0x02AC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UGzCircleAreaComponent*                 AreaZoneComponent;                                 // 0x02B0(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	struct FGzCircle2D GetCircle() const;
	float GetRadius() const;
	float GetSpawnHeight() const;
	const struct FGameplayTag GetZoneTag() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzInitialShrinkingZoneSetup">();
	}
	static class AGzInitialShrinkingZoneSetup* GetDefaultObj()
	{
		return GetDefaultObjImpl<AGzInitialShrinkingZoneSetup>();
	}
};
static_assert(alignof(AGzInitialShrinkingZoneSetup) == 0x000008, "Wrong alignment on AGzInitialShrinkingZoneSetup");
static_assert(sizeof(AGzInitialShrinkingZoneSetup) == 0x0002B8, "Wrong size on AGzInitialShrinkingZoneSetup");
static_assert(offsetof(AGzInitialShrinkingZoneSetup, SpawnHeight) == 0x0002A0, "Member 'AGzInitialShrinkingZoneSetup::SpawnHeight' has a wrong offset!");
static_assert(offsetof(AGzInitialShrinkingZoneSetup, ZoneTag) == 0x0002A4, "Member 'AGzInitialShrinkingZoneSetup::ZoneTag' has a wrong offset!");
static_assert(offsetof(AGzInitialShrinkingZoneSetup, AreaZoneComponent) == 0x0002B0, "Member 'AGzInitialShrinkingZoneSetup::AreaZoneComponent' has a wrong offset!");

// Class G01.GzAutotestStateCheckerComponentDefault
// 0x0000 (0x00F8 - 0x00F8)
class UGzAutotestStateCheckerComponentDefault : public UGzAutotestComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzAutotestStateCheckerComponentDefault">();
	}
	static class UGzAutotestStateCheckerComponentDefault* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzAutotestStateCheckerComponentDefault>();
	}
};
static_assert(alignof(UGzAutotestStateCheckerComponentDefault) == 0x000008, "Wrong alignment on UGzAutotestStateCheckerComponentDefault");
static_assert(sizeof(UGzAutotestStateCheckerComponentDefault) == 0x0000F8, "Wrong size on UGzAutotestStateCheckerComponentDefault");

// Class G01.GzBodyPartAbilityData_Phosphor
// 0x0008 (0x0088 - 0x0080)
class UGzBodyPartAbilityData_Phosphor final : public UGzBodyPartAbilityData
{
public:
	float                                         EffectDuration;                                    // 0x0080(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2F42[0x4];                                     // 0x0084(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzBodyPartAbilityData_Phosphor">();
	}
	static class UGzBodyPartAbilityData_Phosphor* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzBodyPartAbilityData_Phosphor>();
	}
};
static_assert(alignof(UGzBodyPartAbilityData_Phosphor) == 0x000008, "Wrong alignment on UGzBodyPartAbilityData_Phosphor");
static_assert(sizeof(UGzBodyPartAbilityData_Phosphor) == 0x000088, "Wrong size on UGzBodyPartAbilityData_Phosphor");
static_assert(offsetof(UGzBodyPartAbilityData_Phosphor, EffectDuration) == 0x000080, "Member 'UGzBodyPartAbilityData_Phosphor::EffectDuration' has a wrong offset!");

// Class G01.GzAutotestStateCheckerAbilitySystem
// 0x0048 (0x0140 - 0x00F8)
class UGzAutotestStateCheckerAbilitySystem final : public UGzAutotestStateCheckerComponentDefault
{
public:
	struct FGameplayTagContainer                  RequiredTags;                                      // 0x00F8(0x0020)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FGameplayTagContainer                  BlockedTags;                                       // 0x0118(0x0020)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_2F43[0x8];                                     // 0x0138(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void RetargetCharacter(class AGzCharacter* NewTargetCharacter);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzAutotestStateCheckerAbilitySystem">();
	}
	static class UGzAutotestStateCheckerAbilitySystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzAutotestStateCheckerAbilitySystem>();
	}
};
static_assert(alignof(UGzAutotestStateCheckerAbilitySystem) == 0x000008, "Wrong alignment on UGzAutotestStateCheckerAbilitySystem");
static_assert(sizeof(UGzAutotestStateCheckerAbilitySystem) == 0x000140, "Wrong size on UGzAutotestStateCheckerAbilitySystem");
static_assert(offsetof(UGzAutotestStateCheckerAbilitySystem, RequiredTags) == 0x0000F8, "Member 'UGzAutotestStateCheckerAbilitySystem::RequiredTags' has a wrong offset!");
static_assert(offsetof(UGzAutotestStateCheckerAbilitySystem, BlockedTags) == 0x000118, "Member 'UGzAutotestStateCheckerAbilitySystem::BlockedTags' has a wrong offset!");

// Class G01.GzItemIconRenderer
// 0x0048 (0x02E8 - 0x02A0)
class AGzItemIconRenderer final : public AActor
{
public:
	class AStaticMeshActor*                       StaticMeshComponent;                               // 0x02A0(0x0008)(Edit, ZeroConstructor, DisableEditOnTemplate, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class ASkeletalMeshActor*                     SkeletalMeshComponent;                             // 0x02A8(0x0008)(Edit, ZeroConstructor, DisableEditOnTemplate, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class ASceneCapture2D*                        Capture;                                           // 0x02B0(0x0008)(Edit, ZeroConstructor, DisableEditOnTemplate, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FColor                                 ChromaKeyColor;                                    // 0x02B8(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         InSizeX;                                           // 0x02BC(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         InSizeY;                                           // 0x02C0(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         RenderDelayThreshold;                              // 0x02C4(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextureRenderTarget2D*                 RenderTarget;                                      // 0x02C8(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UExporter*                              Exporter;                                          // 0x02D0(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FString                                 FolderName;                                        // 0x02D8(0x0010)(Edit, ZeroConstructor, DisableEditOnTemplate, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzItemIconRenderer">();
	}
	static class AGzItemIconRenderer* GetDefaultObj()
	{
		return GetDefaultObjImpl<AGzItemIconRenderer>();
	}
};
static_assert(alignof(AGzItemIconRenderer) == 0x000008, "Wrong alignment on AGzItemIconRenderer");
static_assert(sizeof(AGzItemIconRenderer) == 0x0002E8, "Wrong size on AGzItemIconRenderer");
static_assert(offsetof(AGzItemIconRenderer, StaticMeshComponent) == 0x0002A0, "Member 'AGzItemIconRenderer::StaticMeshComponent' has a wrong offset!");
static_assert(offsetof(AGzItemIconRenderer, SkeletalMeshComponent) == 0x0002A8, "Member 'AGzItemIconRenderer::SkeletalMeshComponent' has a wrong offset!");
static_assert(offsetof(AGzItemIconRenderer, Capture) == 0x0002B0, "Member 'AGzItemIconRenderer::Capture' has a wrong offset!");
static_assert(offsetof(AGzItemIconRenderer, ChromaKeyColor) == 0x0002B8, "Member 'AGzItemIconRenderer::ChromaKeyColor' has a wrong offset!");
static_assert(offsetof(AGzItemIconRenderer, InSizeX) == 0x0002BC, "Member 'AGzItemIconRenderer::InSizeX' has a wrong offset!");
static_assert(offsetof(AGzItemIconRenderer, InSizeY) == 0x0002C0, "Member 'AGzItemIconRenderer::InSizeY' has a wrong offset!");
static_assert(offsetof(AGzItemIconRenderer, RenderDelayThreshold) == 0x0002C4, "Member 'AGzItemIconRenderer::RenderDelayThreshold' has a wrong offset!");
static_assert(offsetof(AGzItemIconRenderer, RenderTarget) == 0x0002C8, "Member 'AGzItemIconRenderer::RenderTarget' has a wrong offset!");
static_assert(offsetof(AGzItemIconRenderer, Exporter) == 0x0002D0, "Member 'AGzItemIconRenderer::Exporter' has a wrong offset!");
static_assert(offsetof(AGzItemIconRenderer, FolderName) == 0x0002D8, "Member 'AGzItemIconRenderer::FolderName' has a wrong offset!");

// Class G01.GzInteractableComponent
// 0x0218 (0x02C0 - 0x00A8)
class UGzInteractableComponent final : public UActorComponent
{
public:
	FMulticastInlineDelegateProperty_             OnInteractionStarted;                              // 0x00A8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastSparseDelegateProperty_             OnInteract;                                        // 0x00B8(0x0001)(InstancedReference, BlueprintAssignable, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_2F44[0x7];                                     // 0x00B9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	FMulticastInlineDelegateProperty_             OnInteractV2;                                      // 0x00C0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnInteractionCanceled;                             // 0x00D0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnInteractionEnded;                                // 0x00E0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnLastSavedProgressChanged;                        // 0x00F0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnInteractionOwnersChanged;                        // 0x0100(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TSet<class UMeshComponent*>                   InteractableMeshes;                                // 0x0110(0x0050)(Edit, BlueprintVisible, ExportObject, EditConst, ContainsInstancedReference, NativeAccessSpecifierPublic)
	TSet<class FName>                             InteractableMeshesNames;                           // 0x0160(0x0050)(Edit, BlueprintVisible, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FGameplayTag                           CurrentInteractionTag;                             // 0x01B0(0x0008)(BlueprintVisible, BlueprintReadOnly, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AutoInteractionRadius;                             // 0x01B8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         StartInteractionRadius;                            // 0x01BC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxContinuousInteractionRadius;                    // 0x01C0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2F45[0x4];                                     // 0x01C4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTagContainer                  CharacterOwnedTagsToBlockFocus;                    // 0x01C8(0x0020)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TArray<struct FGzInteractionInfo>             InteractionInfoArray;                              // 0x01E8(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FGzInteractionStage                    CurrentInteractionStage;                           // 0x01F8(0x0030)(BlueprintVisible, BlueprintReadOnly, Transient, NativeAccessSpecifierPublic)
	TArray<class AActor*>                         InteractionOwners;                                 // 0x0228(0x0010)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, RepNotify, NativeAccessSpecifierPublic)
	struct FGzIntervalInteractionData             IntervalInteractionData;                           // 0x0238(0x0008)(BlueprintVisible, Net, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          bIgnoreSelfInteractionOwner;                       // 0x0240(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCanSelect;                                        // 0x0241(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShowPermanentOutline;                             // 0x0242(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShowOutOfRangeOutline;                            // 0x0243(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUncrouchOnInteract;                               // 0x0244(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bOverrideMaxInteractionAngle;                      // 0x0245(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2F46[0x2];                                     // 0x0246(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MaxInteractionAngle;                               // 0x0248(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2F47[0xA];                                     // 0x024C(0x000A)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bIsInteractionAllowed;                             // 0x0256(0x0001)(Edit, BlueprintVisible, Net, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bSnapInteractionTooltip;                           // 0x0257(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bUseWholeActorForOutline;                          // 0x0258(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2F48[0x67];                                    // 0x0259(0x0067)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AddInteractableHighlightState(EGzInteractableHighlightState State, EDepthStencilValue InHighlightStateStencilValue);
	void AddInteraction(class UDefaultInteractionBehavior* Interaction);
	void BroadcastFocusedObjectForced();
	void RemoveInteractableHighlightState(EGzInteractableHighlightState State);
	void SetInteractionAllowed(bool bNewInteractionAllowed);
	void ShiftToNextInteractionInterval(class AGzCharacter* InteractedBy);

	bool FindInteractionDataByTag(const struct FGameplayTag& Tag, struct FGzInteractionData* OutInteractionData) const;
	float GetCurrentMontagePlayLength() const;
	float GetInteractionDuration() const;
	float GetLastSavedInteractionProgress() const;
	bool GetResetProgressBarOnRelease() const;
	bool HasDefaultInteractionSetup() const;
	bool IsInteractionCapturedBy(const class AActor* InteractedBy) const;
	void OnRep_InteractionOwners(const TArray<class AActor*>& OldInteractionOwners) const;
	bool TryGetCurrentInteractionData(struct FGzInteractionData* OutInteractionData) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzInteractableComponent">();
	}
	static class UGzInteractableComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzInteractableComponent>();
	}
};
static_assert(alignof(UGzInteractableComponent) == 0x000008, "Wrong alignment on UGzInteractableComponent");
static_assert(sizeof(UGzInteractableComponent) == 0x0002C0, "Wrong size on UGzInteractableComponent");
static_assert(offsetof(UGzInteractableComponent, OnInteractionStarted) == 0x0000A8, "Member 'UGzInteractableComponent::OnInteractionStarted' has a wrong offset!");
static_assert(offsetof(UGzInteractableComponent, OnInteract) == 0x0000B8, "Member 'UGzInteractableComponent::OnInteract' has a wrong offset!");
static_assert(offsetof(UGzInteractableComponent, OnInteractV2) == 0x0000C0, "Member 'UGzInteractableComponent::OnInteractV2' has a wrong offset!");
static_assert(offsetof(UGzInteractableComponent, OnInteractionCanceled) == 0x0000D0, "Member 'UGzInteractableComponent::OnInteractionCanceled' has a wrong offset!");
static_assert(offsetof(UGzInteractableComponent, OnInteractionEnded) == 0x0000E0, "Member 'UGzInteractableComponent::OnInteractionEnded' has a wrong offset!");
static_assert(offsetof(UGzInteractableComponent, OnLastSavedProgressChanged) == 0x0000F0, "Member 'UGzInteractableComponent::OnLastSavedProgressChanged' has a wrong offset!");
static_assert(offsetof(UGzInteractableComponent, OnInteractionOwnersChanged) == 0x000100, "Member 'UGzInteractableComponent::OnInteractionOwnersChanged' has a wrong offset!");
static_assert(offsetof(UGzInteractableComponent, InteractableMeshes) == 0x000110, "Member 'UGzInteractableComponent::InteractableMeshes' has a wrong offset!");
static_assert(offsetof(UGzInteractableComponent, InteractableMeshesNames) == 0x000160, "Member 'UGzInteractableComponent::InteractableMeshesNames' has a wrong offset!");
static_assert(offsetof(UGzInteractableComponent, CurrentInteractionTag) == 0x0001B0, "Member 'UGzInteractableComponent::CurrentInteractionTag' has a wrong offset!");
static_assert(offsetof(UGzInteractableComponent, AutoInteractionRadius) == 0x0001B8, "Member 'UGzInteractableComponent::AutoInteractionRadius' has a wrong offset!");
static_assert(offsetof(UGzInteractableComponent, StartInteractionRadius) == 0x0001BC, "Member 'UGzInteractableComponent::StartInteractionRadius' has a wrong offset!");
static_assert(offsetof(UGzInteractableComponent, MaxContinuousInteractionRadius) == 0x0001C0, "Member 'UGzInteractableComponent::MaxContinuousInteractionRadius' has a wrong offset!");
static_assert(offsetof(UGzInteractableComponent, CharacterOwnedTagsToBlockFocus) == 0x0001C8, "Member 'UGzInteractableComponent::CharacterOwnedTagsToBlockFocus' has a wrong offset!");
static_assert(offsetof(UGzInteractableComponent, InteractionInfoArray) == 0x0001E8, "Member 'UGzInteractableComponent::InteractionInfoArray' has a wrong offset!");
static_assert(offsetof(UGzInteractableComponent, CurrentInteractionStage) == 0x0001F8, "Member 'UGzInteractableComponent::CurrentInteractionStage' has a wrong offset!");
static_assert(offsetof(UGzInteractableComponent, InteractionOwners) == 0x000228, "Member 'UGzInteractableComponent::InteractionOwners' has a wrong offset!");
static_assert(offsetof(UGzInteractableComponent, IntervalInteractionData) == 0x000238, "Member 'UGzInteractableComponent::IntervalInteractionData' has a wrong offset!");
static_assert(offsetof(UGzInteractableComponent, bIgnoreSelfInteractionOwner) == 0x000240, "Member 'UGzInteractableComponent::bIgnoreSelfInteractionOwner' has a wrong offset!");
static_assert(offsetof(UGzInteractableComponent, bCanSelect) == 0x000241, "Member 'UGzInteractableComponent::bCanSelect' has a wrong offset!");
static_assert(offsetof(UGzInteractableComponent, bShowPermanentOutline) == 0x000242, "Member 'UGzInteractableComponent::bShowPermanentOutline' has a wrong offset!");
static_assert(offsetof(UGzInteractableComponent, bShowOutOfRangeOutline) == 0x000243, "Member 'UGzInteractableComponent::bShowOutOfRangeOutline' has a wrong offset!");
static_assert(offsetof(UGzInteractableComponent, bUncrouchOnInteract) == 0x000244, "Member 'UGzInteractableComponent::bUncrouchOnInteract' has a wrong offset!");
static_assert(offsetof(UGzInteractableComponent, bOverrideMaxInteractionAngle) == 0x000245, "Member 'UGzInteractableComponent::bOverrideMaxInteractionAngle' has a wrong offset!");
static_assert(offsetof(UGzInteractableComponent, MaxInteractionAngle) == 0x000248, "Member 'UGzInteractableComponent::MaxInteractionAngle' has a wrong offset!");
static_assert(offsetof(UGzInteractableComponent, bIsInteractionAllowed) == 0x000256, "Member 'UGzInteractableComponent::bIsInteractionAllowed' has a wrong offset!");
static_assert(offsetof(UGzInteractableComponent, bSnapInteractionTooltip) == 0x000257, "Member 'UGzInteractableComponent::bSnapInteractionTooltip' has a wrong offset!");
static_assert(offsetof(UGzInteractableComponent, bUseWholeActorForOutline) == 0x000258, "Member 'UGzInteractableComponent::bUseWholeActorForOutline' has a wrong offset!");

// Class G01.GzAutotestStateCheckerActorHealth
// 0x0020 (0x0118 - 0x00F8)
class UGzAutotestStateCheckerActorHealth final : public UGzAutotestStateCheckerComponentDefault
{
public:
	uint8                                         Pad_2F4C[0x8];                                     // 0x00F8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class AActor*                                 ActorToSpectate;                                   // 0x0100(0x0008)(BlueprintVisible, Net, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EGzCharacterDamageAreaType                    ExpectedDamageArea;                                // 0x0108(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bWasNecessaryHit;                                  // 0x0109(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2F4D[0x6];                                     // 0x010A(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class UGzAsyncTaskAttributeChanged*           AsyncTaskAttributeDamageArmorChanged;              // 0x0110(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzAutotestStateCheckerActorHealth">();
	}
	static class UGzAutotestStateCheckerActorHealth* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzAutotestStateCheckerActorHealth>();
	}
};
static_assert(alignof(UGzAutotestStateCheckerActorHealth) == 0x000008, "Wrong alignment on UGzAutotestStateCheckerActorHealth");
static_assert(sizeof(UGzAutotestStateCheckerActorHealth) == 0x000118, "Wrong size on UGzAutotestStateCheckerActorHealth");
static_assert(offsetof(UGzAutotestStateCheckerActorHealth, ActorToSpectate) == 0x000100, "Member 'UGzAutotestStateCheckerActorHealth::ActorToSpectate' has a wrong offset!");
static_assert(offsetof(UGzAutotestStateCheckerActorHealth, ExpectedDamageArea) == 0x000108, "Member 'UGzAutotestStateCheckerActorHealth::ExpectedDamageArea' has a wrong offset!");
static_assert(offsetof(UGzAutotestStateCheckerActorHealth, bWasNecessaryHit) == 0x000109, "Member 'UGzAutotestStateCheckerActorHealth::bWasNecessaryHit' has a wrong offset!");
static_assert(offsetof(UGzAutotestStateCheckerActorHealth, AsyncTaskAttributeDamageArmorChanged) == 0x000110, "Member 'UGzAutotestStateCheckerActorHealth::AsyncTaskAttributeDamageArmorChanged' has a wrong offset!");

// Class G01.GzNPCTeam
// 0x0200 (0x04A0 - 0x02A0)
class AGzNPCTeam final : public AInfo
{
public:
	struct FGzAIFastArray                         NPCTeamMembers;                                    // 0x02A0(0x0168)(Net, Transient, NativeAccessSpecifierPublic)
	class FString                                 NPCTeamName;                                       // 0x0408(0x0010)(Net, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         NPCTeamId;                                         // 0x0418(0x0004)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2F4E[0x4];                                     // 0x041C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FGzNPCTeamAttitude>             NPCTeamAttitudes;                                  // 0x0420(0x0010)(Net, ZeroConstructor, RepNotify, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2F4F[0x58];                                    // 0x0430(0x0058)(Fixing Size After Last Property [ Dumper-7 ])
	ENPCTeamAttitude                              DefaultTeamAttitude;                               // 0x0488(0x0001)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2F50[0x17];                                    // 0x0489(0x0017)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AddAttitudeTeam(ENPCTeamAttitude TeamAttitude, int32 TeamID);
	void AddFriendlyTeam(int32 TeamID);
	void AddHostileTeam(int32 TeamID);
	void AddNeutralTeam(int32 TeamID);
	void AddNPC(class AGzAIInfo* NPCAIInfo);
	void OnRep_NPCTeamAttitudes();
	void RemoveAllAttitude();
	void RemoveAttitudeTeam(int32 TeamID);
	void RemoveNPC(class AGzAIInfo* NPCAIInfo);
	void SetDefaultTeamAttitude(ENPCTeamAttitude InValue);
	void SetTeamName(const class FString& InTeamName);

	ENPCTeamAttitude GetDefaultTeamAttitude() const;
	void GetFriendsTeamsIds(TArray<int32>* TeamsIdsRef) const;
	ENPCTeamAttitude GetNPCTeamAttitude(int32 TeamID) const;
	ETeamAttitude GetTeamAttitude(int32 TeamID) const;
	int32 GetTeamId() const;
	class FString GetTeamName() const;
	bool IsEmpty() const;
	bool IsFriendlyTeam(int32 TeamID) const;
	bool IsHostileTeam(int32 TeamID) const;
	bool IsNeutralTeam(int32 TeamID) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzNPCTeam">();
	}
	static class AGzNPCTeam* GetDefaultObj()
	{
		return GetDefaultObjImpl<AGzNPCTeam>();
	}
};
static_assert(alignof(AGzNPCTeam) == 0x000008, "Wrong alignment on AGzNPCTeam");
static_assert(sizeof(AGzNPCTeam) == 0x0004A0, "Wrong size on AGzNPCTeam");
static_assert(offsetof(AGzNPCTeam, NPCTeamMembers) == 0x0002A0, "Member 'AGzNPCTeam::NPCTeamMembers' has a wrong offset!");
static_assert(offsetof(AGzNPCTeam, NPCTeamName) == 0x000408, "Member 'AGzNPCTeam::NPCTeamName' has a wrong offset!");
static_assert(offsetof(AGzNPCTeam, NPCTeamId) == 0x000418, "Member 'AGzNPCTeam::NPCTeamId' has a wrong offset!");
static_assert(offsetof(AGzNPCTeam, NPCTeamAttitudes) == 0x000420, "Member 'AGzNPCTeam::NPCTeamAttitudes' has a wrong offset!");
static_assert(offsetof(AGzNPCTeam, DefaultTeamAttitude) == 0x000488, "Member 'AGzNPCTeam::DefaultTeamAttitude' has a wrong offset!");

// Class G01.GzButtonSoundData
// 0x0018 (0x0048 - 0x0030)
class UGzButtonSoundData final : public UDataAsset
{
public:
	class UAkAudioEvent*                          PressSound;                                        // 0x0030(0x0008)(Edit, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UAkAudioEvent*                          ReleaseSound;                                      // 0x0038(0x0008)(Edit, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UAkAudioEvent*                          HoverSound;                                        // 0x0040(0x0008)(Edit, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzButtonSoundData">();
	}
	static class UGzButtonSoundData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzButtonSoundData>();
	}
};
static_assert(alignof(UGzButtonSoundData) == 0x000008, "Wrong alignment on UGzButtonSoundData");
static_assert(sizeof(UGzButtonSoundData) == 0x000048, "Wrong size on UGzButtonSoundData");
static_assert(offsetof(UGzButtonSoundData, PressSound) == 0x000030, "Member 'UGzButtonSoundData::PressSound' has a wrong offset!");
static_assert(offsetof(UGzButtonSoundData, ReleaseSound) == 0x000038, "Member 'UGzButtonSoundData::ReleaseSound' has a wrong offset!");
static_assert(offsetof(UGzButtonSoundData, HoverSound) == 0x000040, "Member 'UGzButtonSoundData::HoverSound' has a wrong offset!");

// Class G01.GzAutotestStateCheckerCustom
// 0x0008 (0x0100 - 0x00F8)
class UGzAutotestStateCheckerCustom final : public UGzAutotestStateCheckerComponentDefault
{
public:
	FMulticastSparseDelegateProperty_             OnCheckCustomConditionDelegate;                    // 0x00F8(0x0001)(InstancedReference, BlueprintAssignable, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_2F57[0x7];                                     // 0x00F9(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetCondtionState(EGzCustomCheckingState CheckingState);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzAutotestStateCheckerCustom">();
	}
	static class UGzAutotestStateCheckerCustom* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzAutotestStateCheckerCustom>();
	}
};
static_assert(alignof(UGzAutotestStateCheckerCustom) == 0x000008, "Wrong alignment on UGzAutotestStateCheckerCustom");
static_assert(sizeof(UGzAutotestStateCheckerCustom) == 0x000100, "Wrong size on UGzAutotestStateCheckerCustom");
static_assert(offsetof(UGzAutotestStateCheckerCustom, OnCheckCustomConditionDelegate) == 0x0000F8, "Member 'UGzAutotestStateCheckerCustom::OnCheckCustomConditionDelegate' has a wrong offset!");

// Class G01.GzTeamSubsystem
// 0x00D0 (0x0370 - 0x02A0)
class AGzTeamSubsystem : public AGzGameModeSubsystem
{
public:
	FMulticastInlineDelegateProperty_             OnTeamDied;                                        // 0x02A0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnTeamAliveStateChanged;                           // 0x02B0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnPlayerStartChangingTeam;                         // 0x02C0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnPlayerChangedTeam;                               // 0x02D0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TSubclassOf<class AGzTeam>                    TeamType;                                          // 0x02E0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FGzTeamSettings                        Settings;                                          // 0x02E8(0x0010)(Edit, DisableEditOnInstance, NoDestructor, Protected, NativeAccessSpecifierProtected)
	TArray<class AGzTeam*>                        Teams;                                             // 0x02F8(0x0010)(Net, ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	TArray<class AGzPlayerState*>                 UnassignedPool;                                    // 0x0308(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2F58[0x58];                                    // 0x0318(0x0058)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	bool CanChangeTeam(const class AGzPlayerState* Player, const int32 NewTeamId) const;
	int32 GetMaxTeamCapacity() const;
	int32 GetMaxTeamCount() const;
	class AGzTeam* GetTeam(const int32 TeamID) const;
	const TArray<class AGzTeam*> GetTeams() const;
	int32 GetTeamsCount() const;
	bool IsTeamExist(const int32 TeamID) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzTeamSubsystem">();
	}
	static class AGzTeamSubsystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<AGzTeamSubsystem>();
	}
};
static_assert(alignof(AGzTeamSubsystem) == 0x000008, "Wrong alignment on AGzTeamSubsystem");
static_assert(sizeof(AGzTeamSubsystem) == 0x000370, "Wrong size on AGzTeamSubsystem");
static_assert(offsetof(AGzTeamSubsystem, OnTeamDied) == 0x0002A0, "Member 'AGzTeamSubsystem::OnTeamDied' has a wrong offset!");
static_assert(offsetof(AGzTeamSubsystem, OnTeamAliveStateChanged) == 0x0002B0, "Member 'AGzTeamSubsystem::OnTeamAliveStateChanged' has a wrong offset!");
static_assert(offsetof(AGzTeamSubsystem, OnPlayerStartChangingTeam) == 0x0002C0, "Member 'AGzTeamSubsystem::OnPlayerStartChangingTeam' has a wrong offset!");
static_assert(offsetof(AGzTeamSubsystem, OnPlayerChangedTeam) == 0x0002D0, "Member 'AGzTeamSubsystem::OnPlayerChangedTeam' has a wrong offset!");
static_assert(offsetof(AGzTeamSubsystem, TeamType) == 0x0002E0, "Member 'AGzTeamSubsystem::TeamType' has a wrong offset!");
static_assert(offsetof(AGzTeamSubsystem, Settings) == 0x0002E8, "Member 'AGzTeamSubsystem::Settings' has a wrong offset!");
static_assert(offsetof(AGzTeamSubsystem, Teams) == 0x0002F8, "Member 'AGzTeamSubsystem::Teams' has a wrong offset!");
static_assert(offsetof(AGzTeamSubsystem, UnassignedPool) == 0x000308, "Member 'AGzTeamSubsystem::UnassignedPool' has a wrong offset!");

// Class G01.GzAutotestStateCheckerHasItemOfType
// 0x0028 (0x0120 - 0x00F8)
class UGzAutotestStateCheckerHasItemOfType final : public UGzAutotestStateCheckerComponentDefault
{
public:
	struct FGameplayTagContainer                  ItemTypes;                                         // 0x00F8(0x0020)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	bool                                          bCheckNegative;                                    // 0x0118(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2F5C[0x7];                                     // 0x0119(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzAutotestStateCheckerHasItemOfType">();
	}
	static class UGzAutotestStateCheckerHasItemOfType* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzAutotestStateCheckerHasItemOfType>();
	}
};
static_assert(alignof(UGzAutotestStateCheckerHasItemOfType) == 0x000008, "Wrong alignment on UGzAutotestStateCheckerHasItemOfType");
static_assert(sizeof(UGzAutotestStateCheckerHasItemOfType) == 0x000120, "Wrong size on UGzAutotestStateCheckerHasItemOfType");
static_assert(offsetof(UGzAutotestStateCheckerHasItemOfType, ItemTypes) == 0x0000F8, "Member 'UGzAutotestStateCheckerHasItemOfType::ItemTypes' has a wrong offset!");
static_assert(offsetof(UGzAutotestStateCheckerHasItemOfType, bCheckNegative) == 0x000118, "Member 'UGzAutotestStateCheckerHasItemOfType::bCheckNegative' has a wrong offset!");

// Class G01.GzHideoutSettings
// 0x0058 (0x0090 - 0x0038)
class UGzHideoutSettings final : public UDeveloperSettings
{
public:
	double                                        ItemPreviewRotationSpeedMultiplier;                // 0x0038(0x0008)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	double                                        CharacterRotationSpeedMultiplier;                  // 0x0040(0x0008)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	double                                        GunsmithBenchWeaponRotationSpeedMultiplier;        // 0x0048(0x0008)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           SceneManagerTag;                                   // 0x0050(0x0008)(Edit, Config, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGzSceneTransitionParameters           DefaultSceneTransitionParameters;                  // 0x0058(0x000C)(Edit, Config, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_2F5D[0x4];                                     // 0x0064(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftClassPtr<class UClass>                   PreviewCharacterClass;                             // 0x0068(0x0028)(Edit, Config, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzHideoutSettings">();
	}
	static class UGzHideoutSettings* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzHideoutSettings>();
	}
};
static_assert(alignof(UGzHideoutSettings) == 0x000008, "Wrong alignment on UGzHideoutSettings");
static_assert(sizeof(UGzHideoutSettings) == 0x000090, "Wrong size on UGzHideoutSettings");
static_assert(offsetof(UGzHideoutSettings, ItemPreviewRotationSpeedMultiplier) == 0x000038, "Member 'UGzHideoutSettings::ItemPreviewRotationSpeedMultiplier' has a wrong offset!");
static_assert(offsetof(UGzHideoutSettings, CharacterRotationSpeedMultiplier) == 0x000040, "Member 'UGzHideoutSettings::CharacterRotationSpeedMultiplier' has a wrong offset!");
static_assert(offsetof(UGzHideoutSettings, GunsmithBenchWeaponRotationSpeedMultiplier) == 0x000048, "Member 'UGzHideoutSettings::GunsmithBenchWeaponRotationSpeedMultiplier' has a wrong offset!");
static_assert(offsetof(UGzHideoutSettings, SceneManagerTag) == 0x000050, "Member 'UGzHideoutSettings::SceneManagerTag' has a wrong offset!");
static_assert(offsetof(UGzHideoutSettings, DefaultSceneTransitionParameters) == 0x000058, "Member 'UGzHideoutSettings::DefaultSceneTransitionParameters' has a wrong offset!");
static_assert(offsetof(UGzHideoutSettings, PreviewCharacterClass) == 0x000068, "Member 'UGzHideoutSettings::PreviewCharacterClass' has a wrong offset!");

// Class G01.GzTargetType
// 0x0000 (0x0028 - 0x0028)
class UGzTargetType : public UObject
{
public:
	void GetTargets(class AGzCharacter* TargetingCharacter, class AActor* TargetingActor, const struct FGameplayEventData& EventData, TArray<struct FGameplayAbilityTargetDataHandle>* OutTargetData, TArray<struct FHitResult>* OutHitResults, TArray<class AActor*>* OutActors) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzTargetType">();
	}
	static class UGzTargetType* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzTargetType>();
	}
};
static_assert(alignof(UGzTargetType) == 0x000008, "Wrong alignment on UGzTargetType");
static_assert(sizeof(UGzTargetType) == 0x000028, "Wrong size on UGzTargetType");

// Class G01.GzTargetType_UseOwner
// 0x0000 (0x0028 - 0x0028)
class UGzTargetType_UseOwner final : public UGzTargetType
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzTargetType_UseOwner">();
	}
	static class UGzTargetType_UseOwner* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzTargetType_UseOwner>();
	}
};
static_assert(alignof(UGzTargetType_UseOwner) == 0x000008, "Wrong alignment on UGzTargetType_UseOwner");
static_assert(sizeof(UGzTargetType_UseOwner) == 0x000028, "Wrong size on UGzTargetType_UseOwner");

// Class G01.GzBodyPartAbilityData_SmashLanding
// 0x0040 (0x00C0 - 0x0080)
class UGzBodyPartAbilityData_SmashLanding final : public UGzBodyPartAbilityData
{
public:
	TSubclassOf<class UGzGE_BaseDamage>           AttackDamageEffect;                                // 0x0080(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UCurveFloat>             SmashKnockbackStrengthCurve;                       // 0x0088(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SmashLandingRadius;                                // 0x00B0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SmashKnockUpAngle;                                 // 0x00B4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SmashLandingConcussionTime;                        // 0x00B8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2F5E[0x4];                                     // 0x00BC(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzBodyPartAbilityData_SmashLanding">();
	}
	static class UGzBodyPartAbilityData_SmashLanding* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzBodyPartAbilityData_SmashLanding>();
	}
};
static_assert(alignof(UGzBodyPartAbilityData_SmashLanding) == 0x000008, "Wrong alignment on UGzBodyPartAbilityData_SmashLanding");
static_assert(sizeof(UGzBodyPartAbilityData_SmashLanding) == 0x0000C0, "Wrong size on UGzBodyPartAbilityData_SmashLanding");
static_assert(offsetof(UGzBodyPartAbilityData_SmashLanding, AttackDamageEffect) == 0x000080, "Member 'UGzBodyPartAbilityData_SmashLanding::AttackDamageEffect' has a wrong offset!");
static_assert(offsetof(UGzBodyPartAbilityData_SmashLanding, SmashKnockbackStrengthCurve) == 0x000088, "Member 'UGzBodyPartAbilityData_SmashLanding::SmashKnockbackStrengthCurve' has a wrong offset!");
static_assert(offsetof(UGzBodyPartAbilityData_SmashLanding, SmashLandingRadius) == 0x0000B0, "Member 'UGzBodyPartAbilityData_SmashLanding::SmashLandingRadius' has a wrong offset!");
static_assert(offsetof(UGzBodyPartAbilityData_SmashLanding, SmashKnockUpAngle) == 0x0000B4, "Member 'UGzBodyPartAbilityData_SmashLanding::SmashKnockUpAngle' has a wrong offset!");
static_assert(offsetof(UGzBodyPartAbilityData_SmashLanding, SmashLandingConcussionTime) == 0x0000B8, "Member 'UGzBodyPartAbilityData_SmashLanding::SmashLandingConcussionTime' has a wrong offset!");

// Class G01.GzTrackTransport
// 0x00E0 (0x0380 - 0x02A0)
class AGzTrackTransport : public AActor
{
public:
	uint8                                         Pad_2F5F[0x40];                                    // 0x02A0(0x0040)(Fixing Size After Last Property [ Dumper-7 ])
	class AGzTrack*                               Track;                                             // 0x02E0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, RepNotify, NoDestructor, Protected, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bAlignToSplineRotation;                            // 0x02E8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bAllowTickWhenNotMoving;                           // 0x02E9(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bDormantWhenNotMoving;                             // 0x02EA(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2F60[0x1];                                     // 0x02EB(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         AccelerationRate;                                  // 0x02EC(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         DecelerationRate;                                  // 0x02F0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MaxSpeed;                                          // 0x02F4(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         NetCorrectionDistance;                             // 0x02F8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bShouldInclineOnTurn;                              // 0x02FC(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2F61[0x3];                                     // 0x02FD(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGzTurnInclineCalculationSettings      InclineSettings;                                   // 0x0300(0x0010)(Edit, DisableEditOnInstance, NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FGzTrackDistance                       TargetDistance;                                    // 0x0310(0x0010)(Net, Transient, RepNotify, NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FGzTrackDistance                       CurrentAuthorityDistance;                          // 0x0320(0x0010)(Net, Transient, RepNotify, NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FGzTrackDistance                       CurrentPredictedDistance;                          // 0x0330(0x0010)(Transient, NoDestructor, Protected, NativeAccessSpecifierProtected)
	TArray<class UGzTrackEventHandlerComponent*>  RegisteredEventHandlers;                           // 0x0340(0x0010)(ExportObject, ZeroConstructor, Transient, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	float                                         CurrentSpeed;                                      // 0x0350(0x0004)(Net, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2F62[0x4];                                     // 0x0354(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FGzTrackEventsSegment>          ActiveSegments;                                    // 0x0358(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	int32                                         NextTrackEventsIndex;                              // 0x0368(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2F63[0x14];                                    // 0x036C(0x0014)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void EnableSplineAlignment(bool bEnable);
	void OnRep_CurrentDistance(const struct FGzTrackDistance& OldDistance);
	void OnRep_TargetDistance();
	void OnRep_Track(class AGzTrack* OldTrack);
	void ReceiveMovementEnd();
	void ReceiveMovementStart();
	void SetMaxSpeed(float InMaxSpeed);
	void StopMoving(float StopDistance);

	float GetCurrentSpeed() const;
	double GetDistanceAlongSpline() const;
	double GetDistanceAlongTrack() const;
	float GetTargetSpeed() const;
	float GetTurnInclineRoll() const;
	bool HasReachedTarget() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzTrackTransport">();
	}
	static class AGzTrackTransport* GetDefaultObj()
	{
		return GetDefaultObjImpl<AGzTrackTransport>();
	}
};
static_assert(alignof(AGzTrackTransport) == 0x000008, "Wrong alignment on AGzTrackTransport");
static_assert(sizeof(AGzTrackTransport) == 0x000380, "Wrong size on AGzTrackTransport");
static_assert(offsetof(AGzTrackTransport, Track) == 0x0002E0, "Member 'AGzTrackTransport::Track' has a wrong offset!");
static_assert(offsetof(AGzTrackTransport, bAlignToSplineRotation) == 0x0002E8, "Member 'AGzTrackTransport::bAlignToSplineRotation' has a wrong offset!");
static_assert(offsetof(AGzTrackTransport, bAllowTickWhenNotMoving) == 0x0002E9, "Member 'AGzTrackTransport::bAllowTickWhenNotMoving' has a wrong offset!");
static_assert(offsetof(AGzTrackTransport, bDormantWhenNotMoving) == 0x0002EA, "Member 'AGzTrackTransport::bDormantWhenNotMoving' has a wrong offset!");
static_assert(offsetof(AGzTrackTransport, AccelerationRate) == 0x0002EC, "Member 'AGzTrackTransport::AccelerationRate' has a wrong offset!");
static_assert(offsetof(AGzTrackTransport, DecelerationRate) == 0x0002F0, "Member 'AGzTrackTransport::DecelerationRate' has a wrong offset!");
static_assert(offsetof(AGzTrackTransport, MaxSpeed) == 0x0002F4, "Member 'AGzTrackTransport::MaxSpeed' has a wrong offset!");
static_assert(offsetof(AGzTrackTransport, NetCorrectionDistance) == 0x0002F8, "Member 'AGzTrackTransport::NetCorrectionDistance' has a wrong offset!");
static_assert(offsetof(AGzTrackTransport, bShouldInclineOnTurn) == 0x0002FC, "Member 'AGzTrackTransport::bShouldInclineOnTurn' has a wrong offset!");
static_assert(offsetof(AGzTrackTransport, InclineSettings) == 0x000300, "Member 'AGzTrackTransport::InclineSettings' has a wrong offset!");
static_assert(offsetof(AGzTrackTransport, TargetDistance) == 0x000310, "Member 'AGzTrackTransport::TargetDistance' has a wrong offset!");
static_assert(offsetof(AGzTrackTransport, CurrentAuthorityDistance) == 0x000320, "Member 'AGzTrackTransport::CurrentAuthorityDistance' has a wrong offset!");
static_assert(offsetof(AGzTrackTransport, CurrentPredictedDistance) == 0x000330, "Member 'AGzTrackTransport::CurrentPredictedDistance' has a wrong offset!");
static_assert(offsetof(AGzTrackTransport, RegisteredEventHandlers) == 0x000340, "Member 'AGzTrackTransport::RegisteredEventHandlers' has a wrong offset!");
static_assert(offsetof(AGzTrackTransport, CurrentSpeed) == 0x000350, "Member 'AGzTrackTransport::CurrentSpeed' has a wrong offset!");
static_assert(offsetof(AGzTrackTransport, ActiveSegments) == 0x000358, "Member 'AGzTrackTransport::ActiveSegments' has a wrong offset!");
static_assert(offsetof(AGzTrackTransport, NextTrackEventsIndex) == 0x000368, "Member 'AGzTrackTransport::NextTrackEventsIndex' has a wrong offset!");

// Class G01.GzAutoTrackTransport
// 0x0030 (0x03B0 - 0x0380)
class AGzAutoTrackTransport : public AGzTrackTransport
{
public:
	bool                                          bUseCustomStart;                                   // 0x0380(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2F64[0x3];                                     // 0x0381(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGzTrackStopDetails                    InitialStop;                                       // 0x0384(0x000C)(Edit, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bAutoContinueMovement;                             // 0x0390(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2F65[0x3];                                     // 0x0391(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         StopIndex;                                         // 0x0394(0x0004)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2F66[0x18];                                    // 0x0398(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ContinueAutoMovement();
	void MoveToNextStop();
	void OnRep_StopIndex();
	void ReceiveManualStop();
	void ReceiveWaitOnStop(int32 Stop);

	float GetArrivalTimeToNextStop() const;
	float GetArrivalTimeToStop(int32 InStopIndex) const;
	double GetDistanceToNextStop() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzAutoTrackTransport">();
	}
	static class AGzAutoTrackTransport* GetDefaultObj()
	{
		return GetDefaultObjImpl<AGzAutoTrackTransport>();
	}
};
static_assert(alignof(AGzAutoTrackTransport) == 0x000008, "Wrong alignment on AGzAutoTrackTransport");
static_assert(sizeof(AGzAutoTrackTransport) == 0x0003B0, "Wrong size on AGzAutoTrackTransport");
static_assert(offsetof(AGzAutoTrackTransport, bUseCustomStart) == 0x000380, "Member 'AGzAutoTrackTransport::bUseCustomStart' has a wrong offset!");
static_assert(offsetof(AGzAutoTrackTransport, InitialStop) == 0x000384, "Member 'AGzAutoTrackTransport::InitialStop' has a wrong offset!");
static_assert(offsetof(AGzAutoTrackTransport, bAutoContinueMovement) == 0x000390, "Member 'AGzAutoTrackTransport::bAutoContinueMovement' has a wrong offset!");
static_assert(offsetof(AGzAutoTrackTransport, StopIndex) == 0x000394, "Member 'AGzAutoTrackTransport::StopIndex' has a wrong offset!");

// Class G01.Gz_BTService_MentalStateSelection
// 0x00B0 (0x0148 - 0x0098)
class UGz_BTService_MentalStateSelection : public UBTService_BlackboardBase
{
public:
	struct FBlackboardKeySelector                 EnemyKey;                                          // 0x0098(0x0028)(Edit, NativeAccessSpecifierPublic)
	struct FBlackboardKeySelector                 TargetVisibleKey;                                  // 0x00C0(0x0028)(Edit, NativeAccessSpecifierPublic)
	struct FBlackboardKeySelector                 StimulusLocationKey;                               // 0x00E8(0x0028)(Edit, NativeAccessSpecifierPublic)
	struct FBlackboardKeySelector                 EMentalStateKey;                                   // 0x0110(0x0028)(Edit, NativeAccessSpecifierPublic)
	class AGzAIController*                        GzAIController;                                    // 0x0138(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UBlackboardComponent*                   BlackboardComponent;                               // 0x0140(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void ChooseAndSetTarget(float DeltaTime) const;
	class UBlackboardComponent* GetBlackboardComponent() const;
	class AGzAIController* GetGzAIController() const;
	void MakeAlerted() const;
	void MakeCombat() const;
	void MakeFree() const;
	void SetMentalState(EGzMentalState GzMentalState) const;
	void SetStimulusLocation(const struct FVector& StimulusLocationRef) const;
	void SetTargetEnemy(class AActor* TargetEnemyPtr) const;
	void SetTargetVisible(bool bVisible) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Gz_BTService_MentalStateSelection">();
	}
	static class UGz_BTService_MentalStateSelection* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGz_BTService_MentalStateSelection>();
	}
};
static_assert(alignof(UGz_BTService_MentalStateSelection) == 0x000008, "Wrong alignment on UGz_BTService_MentalStateSelection");
static_assert(sizeof(UGz_BTService_MentalStateSelection) == 0x000148, "Wrong size on UGz_BTService_MentalStateSelection");
static_assert(offsetof(UGz_BTService_MentalStateSelection, EnemyKey) == 0x000098, "Member 'UGz_BTService_MentalStateSelection::EnemyKey' has a wrong offset!");
static_assert(offsetof(UGz_BTService_MentalStateSelection, TargetVisibleKey) == 0x0000C0, "Member 'UGz_BTService_MentalStateSelection::TargetVisibleKey' has a wrong offset!");
static_assert(offsetof(UGz_BTService_MentalStateSelection, StimulusLocationKey) == 0x0000E8, "Member 'UGz_BTService_MentalStateSelection::StimulusLocationKey' has a wrong offset!");
static_assert(offsetof(UGz_BTService_MentalStateSelection, EMentalStateKey) == 0x000110, "Member 'UGz_BTService_MentalStateSelection::EMentalStateKey' has a wrong offset!");
static_assert(offsetof(UGz_BTService_MentalStateSelection, GzAIController) == 0x000138, "Member 'UGz_BTService_MentalStateSelection::GzAIController' has a wrong offset!");
static_assert(offsetof(UGz_BTService_MentalStateSelection, BlackboardComponent) == 0x000140, "Member 'UGz_BTService_MentalStateSelection::BlackboardComponent' has a wrong offset!");

// Class G01.GzBTServiceMentalStateMirrorLimb
// 0x0000 (0x0148 - 0x0148)
class UGzBTServiceMentalStateMirrorLimb final : public UGz_BTService_MentalStateSelection
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzBTServiceMentalStateMirrorLimb">();
	}
	static class UGzBTServiceMentalStateMirrorLimb* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzBTServiceMentalStateMirrorLimb>();
	}
};
static_assert(alignof(UGzBTServiceMentalStateMirrorLimb) == 0x000008, "Wrong alignment on UGzBTServiceMentalStateMirrorLimb");
static_assert(sizeof(UGzBTServiceMentalStateMirrorLimb) == 0x000148, "Wrong size on UGzBTServiceMentalStateMirrorLimb");

// Class G01.GzKillLogEntryWidget
// 0x0020 (0x0318 - 0x02F8)
class UGzKillLogEntryWidget : public UGzBaseLogEntryWidget
{
public:
	class UGzTextBlock*                           ActionName;                                        // 0x02F8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UGzTextBlock*                           PlayerName;                                        // 0x0300(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ResetAnimationOnUpdateTime;                        // 0x0308(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2F67[0xC];                                     // 0x030C(0x000C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetActionInfo(const class FText& ActionText, const struct FGzAdvancedIdType& InVictimId);

	const struct FGzAdvancedIdType GetVictimId() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzKillLogEntryWidget">();
	}
	static class UGzKillLogEntryWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzKillLogEntryWidget>();
	}
};
static_assert(alignof(UGzKillLogEntryWidget) == 0x000008, "Wrong alignment on UGzKillLogEntryWidget");
static_assert(sizeof(UGzKillLogEntryWidget) == 0x000318, "Wrong size on UGzKillLogEntryWidget");
static_assert(offsetof(UGzKillLogEntryWidget, ActionName) == 0x0002F8, "Member 'UGzKillLogEntryWidget::ActionName' has a wrong offset!");
static_assert(offsetof(UGzKillLogEntryWidget, PlayerName) == 0x000300, "Member 'UGzKillLogEntryWidget::PlayerName' has a wrong offset!");
static_assert(offsetof(UGzKillLogEntryWidget, ResetAnimationOnUpdateTime) == 0x000308, "Member 'UGzKillLogEntryWidget::ResetAnimationOnUpdateTime' has a wrong offset!");

// Class G01.GzGA_WeaponReload
// 0x0018 (0x0570 - 0x0558)
class UGzGA_WeaponReload : public UGzGA_WeaponAbilityBase
{
public:
	class UGzAT_PlayMontageAndWaitForEvent*       PlayMontageAndWaitForEventTask_Reload;             // 0x0558(0x0008)(Edit, ZeroConstructor, EditConst, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2F68[0x10];                                    // 0x0560(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnMontageEnded();
	void OnMontageInterrupted();
	void OnReloadEvent(class FName NotifyName);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzGA_WeaponReload">();
	}
	static class UGzGA_WeaponReload* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzGA_WeaponReload>();
	}
};
static_assert(alignof(UGzGA_WeaponReload) == 0x000008, "Wrong alignment on UGzGA_WeaponReload");
static_assert(sizeof(UGzGA_WeaponReload) == 0x000570, "Wrong size on UGzGA_WeaponReload");
static_assert(offsetof(UGzGA_WeaponReload, PlayMontageAndWaitForEventTask_Reload) == 0x000558, "Member 'UGzGA_WeaponReload::PlayMontageAndWaitForEventTask_Reload' has a wrong offset!");

// Class G01.GzGA_WeaponSocketReload
// 0x0000 (0x0570 - 0x0570)
class UGzGA_WeaponSocketReload final : public UGzGA_WeaponReload
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzGA_WeaponSocketReload">();
	}
	static class UGzGA_WeaponSocketReload* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzGA_WeaponSocketReload>();
	}
};
static_assert(alignof(UGzGA_WeaponSocketReload) == 0x000008, "Wrong alignment on UGzGA_WeaponSocketReload");
static_assert(sizeof(UGzGA_WeaponSocketReload) == 0x000570, "Wrong size on UGzGA_WeaponSocketReload");

// Class G01.GzBackendDataBroadcastingComponent
// 0x00A8 (0x0148 - 0x00A0)
class UGzBackendDataBroadcastingComponent final : public UGzServiceComponent
{
public:
	uint8                                         Pad_2F69[0xA8];                                    // 0x00A0(0x00A8)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzBackendDataBroadcastingComponent">();
	}
	static class UGzBackendDataBroadcastingComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzBackendDataBroadcastingComponent>();
	}
};
static_assert(alignof(UGzBackendDataBroadcastingComponent) == 0x000008, "Wrong alignment on UGzBackendDataBroadcastingComponent");
static_assert(sizeof(UGzBackendDataBroadcastingComponent) == 0x000148, "Wrong size on UGzBackendDataBroadcastingComponent");

// Class G01.GzCharacterControlsComponent
// 0x0038 (0x0168 - 0x0130)
class UGzCharacterControlsComponent final : public UGzPawnControlsComponent
{
public:
	class UInputAction*                           MoveForwardInputAction;                            // 0x0130(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UInputAction*                           MoveRightInputAction;                              // 0x0138(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UInputAction*                           LookUpInputAction;                                 // 0x0140(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UInputAction*                           TurnInputAction;                                   // 0x0148(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         BlockMoveForwardHandle;                            // 0x0150(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         BlockMoveBackwardsHandle;                          // 0x0151(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         BlockMoveRightHandle;                              // 0x0152(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         BlockMoveLeftHandle;                               // 0x0153(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         BlockLookUpHandle;                                 // 0x0154(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         BlockTurnHandle;                                   // 0x0155(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2F6A[0x12];                                    // 0x0156(0x0012)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void HandleLookUp(const float Value);
	void HandleMoveForward(const float Value);
	void HandleMoveRight(const float Value);
	void HandleTurn(const float Value);
	void HandleWingsuitMovementPitch(const float ForwardAxisValue, const float RightAxisValue);
	void HandleWingsuitMovementYaw(const float ForwardAxisValue, const float RightAxisValue);
	void SetMovementEnabled(bool bEnabled);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzCharacterControlsComponent">();
	}
	static class UGzCharacterControlsComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzCharacterControlsComponent>();
	}
};
static_assert(alignof(UGzCharacterControlsComponent) == 0x000008, "Wrong alignment on UGzCharacterControlsComponent");
static_assert(sizeof(UGzCharacterControlsComponent) == 0x000168, "Wrong size on UGzCharacterControlsComponent");
static_assert(offsetof(UGzCharacterControlsComponent, MoveForwardInputAction) == 0x000130, "Member 'UGzCharacterControlsComponent::MoveForwardInputAction' has a wrong offset!");
static_assert(offsetof(UGzCharacterControlsComponent, MoveRightInputAction) == 0x000138, "Member 'UGzCharacterControlsComponent::MoveRightInputAction' has a wrong offset!");
static_assert(offsetof(UGzCharacterControlsComponent, LookUpInputAction) == 0x000140, "Member 'UGzCharacterControlsComponent::LookUpInputAction' has a wrong offset!");
static_assert(offsetof(UGzCharacterControlsComponent, TurnInputAction) == 0x000148, "Member 'UGzCharacterControlsComponent::TurnInputAction' has a wrong offset!");
static_assert(offsetof(UGzCharacterControlsComponent, BlockMoveForwardHandle) == 0x000150, "Member 'UGzCharacterControlsComponent::BlockMoveForwardHandle' has a wrong offset!");
static_assert(offsetof(UGzCharacterControlsComponent, BlockMoveBackwardsHandle) == 0x000151, "Member 'UGzCharacterControlsComponent::BlockMoveBackwardsHandle' has a wrong offset!");
static_assert(offsetof(UGzCharacterControlsComponent, BlockMoveRightHandle) == 0x000152, "Member 'UGzCharacterControlsComponent::BlockMoveRightHandle' has a wrong offset!");
static_assert(offsetof(UGzCharacterControlsComponent, BlockMoveLeftHandle) == 0x000153, "Member 'UGzCharacterControlsComponent::BlockMoveLeftHandle' has a wrong offset!");
static_assert(offsetof(UGzCharacterControlsComponent, BlockLookUpHandle) == 0x000154, "Member 'UGzCharacterControlsComponent::BlockLookUpHandle' has a wrong offset!");
static_assert(offsetof(UGzCharacterControlsComponent, BlockTurnHandle) == 0x000155, "Member 'UGzCharacterControlsComponent::BlockTurnHandle' has a wrong offset!");

// Class G01.GzInputControllerData
// 0x0218 (0x0300 - 0x00E8)
class UGzInputControllerData : public UCommonInputBaseControllerData
{
public:
	TMap<struct FGameplayTag, struct FSlateBrush> BackgroundBrushes;                                 // 0x00E8(0x0050)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	TMap<struct FGameplayTag, float>              ImageRenderOpacities;                              // 0x0138(0x0050)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_2F6B[0x8];                                     // 0x0188(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FSlateBrush                            HoldIndicationBrush;                               // 0x0190(0x00D0)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	TMap<struct FGameplayTag, struct FGzBrushKeys> BrushKeyThemes;                                    // 0x0260(0x0050)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	TMap<struct FGameplayTag, struct FGzBrushKeySets> BrushKeySetThemes;                                 // 0x02B0(0x0050)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzInputControllerData">();
	}
	static class UGzInputControllerData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzInputControllerData>();
	}
};
static_assert(alignof(UGzInputControllerData) == 0x000010, "Wrong alignment on UGzInputControllerData");
static_assert(sizeof(UGzInputControllerData) == 0x000300, "Wrong size on UGzInputControllerData");
static_assert(offsetof(UGzInputControllerData, BackgroundBrushes) == 0x0000E8, "Member 'UGzInputControllerData::BackgroundBrushes' has a wrong offset!");
static_assert(offsetof(UGzInputControllerData, ImageRenderOpacities) == 0x000138, "Member 'UGzInputControllerData::ImageRenderOpacities' has a wrong offset!");
static_assert(offsetof(UGzInputControllerData, HoldIndicationBrush) == 0x000190, "Member 'UGzInputControllerData::HoldIndicationBrush' has a wrong offset!");
static_assert(offsetof(UGzInputControllerData, BrushKeyThemes) == 0x000260, "Member 'UGzInputControllerData::BrushKeyThemes' has a wrong offset!");
static_assert(offsetof(UGzInputControllerData, BrushKeySetThemes) == 0x0002B0, "Member 'UGzInputControllerData::BrushKeySetThemes' has a wrong offset!");

// Class G01.GzBackendDataFacade
// 0x0000 (0x0030 - 0x0030)
class UGzBackendDataFacade final : public UGzFacade
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzBackendDataFacade">();
	}
	static class UGzBackendDataFacade* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzBackendDataFacade>();
	}
};
static_assert(alignof(UGzBackendDataFacade) == 0x000008, "Wrong alignment on UGzBackendDataFacade");
static_assert(sizeof(UGzBackendDataFacade) == 0x000030, "Wrong size on UGzBackendDataFacade");

// Class G01.GzNotificationsCheatExtension
// 0x0000 (0x0028 - 0x0028)
class UGzNotificationsCheatExtension final : public UGzCheatManagerExtension
{
public:
	void PostMetaNotificationAchievement() const;
	void PostMetaNotificationBattlePassLevelUp() const;
	void PostMetaNotificationChallenge() const;
	void PostMetaNotificationMarketLotBought() const;
	void PostMetaNotificationMarketLotExpired() const;
	void PostMetaNotificationMarketLotSold() const;
	void PostMetaNotificationMint() const;
	void PostMetaNotificationPlayerLevelUp() const;
	void SimulateLotSoldNotification(const class FString& ItemGuid) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzNotificationsCheatExtension">();
	}
	static class UGzNotificationsCheatExtension* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzNotificationsCheatExtension>();
	}
};
static_assert(alignof(UGzNotificationsCheatExtension) == 0x000008, "Wrong alignment on UGzNotificationsCheatExtension");
static_assert(sizeof(UGzNotificationsCheatExtension) == 0x000028, "Wrong size on UGzNotificationsCheatExtension");

// Class G01.GzGameplayTagHandler
// 0x0008 (0x0030 - 0x0028)
class UGzGameplayTagHandler : public UObject
{
public:
	int32                                         RoleFlags;                                         // 0x0028(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EGameplayTagEventType                         TagEventType;                                      // 0x002C(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2F6C[0x3];                                     // 0x002D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnTagCountChanged(class UGzAbilitySystemComponent* Target, const struct FGameplayTag& Tag, int32 Count) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzGameplayTagHandler">();
	}
	static class UGzGameplayTagHandler* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzGameplayTagHandler>();
	}
};
static_assert(alignof(UGzGameplayTagHandler) == 0x000008, "Wrong alignment on UGzGameplayTagHandler");
static_assert(sizeof(UGzGameplayTagHandler) == 0x000030, "Wrong size on UGzGameplayTagHandler");
static_assert(offsetof(UGzGameplayTagHandler, RoleFlags) == 0x000028, "Member 'UGzGameplayTagHandler::RoleFlags' has a wrong offset!");
static_assert(offsetof(UGzGameplayTagHandler, TagEventType) == 0x00002C, "Member 'UGzGameplayTagHandler::TagEventType' has a wrong offset!");

// Class G01.GzBackendDataHolderComponent
// 0x03D0 (0x0470 - 0x00A0)
class UGzBackendDataHolderComponent final : public UGzServiceComponent
{
public:
	uint8                                         Pad_2F6E[0x3D0];                                   // 0x00A0(0x03D0)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzBackendDataHolderComponent">();
	}
	static class UGzBackendDataHolderComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzBackendDataHolderComponent>();
	}
};
static_assert(alignof(UGzBackendDataHolderComponent) == 0x000008, "Wrong alignment on UGzBackendDataHolderComponent");
static_assert(sizeof(UGzBackendDataHolderComponent) == 0x000470, "Wrong size on UGzBackendDataHolderComponent");

// Class G01.GzBackendDataService
// 0x0018 (0x00B8 - 0x00A0)
class UGzBackendDataService final : public UGzClientPFObject
{
public:
	uint8                                         Pad_2F6F[0x18];                                    // 0x00A0(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzBackendDataService">();
	}
	static class UGzBackendDataService* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzBackendDataService>();
	}
};
static_assert(alignof(UGzBackendDataService) == 0x000008, "Wrong alignment on UGzBackendDataService");
static_assert(sizeof(UGzBackendDataService) == 0x0000B8, "Wrong size on UGzBackendDataService");

// Class G01.GzCharacterCustomizationComponent
// 0x0778 (0x0820 - 0x00A8)
class UGzCharacterCustomizationComponent : public UActorComponent
{
public:
	uint8                                         Pad_2F70[0x38];                                    // 0x00A8(0x0038)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGzCharacterCustomizationDebugger      Debugger;                                          // 0x00E0(0x0200)(Edit, DisableEditOnInstance, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	TMap<struct FGameplayTag, struct FGzMeshesInLogicalSlotsContainer> MeshesInLogicalSlots;                              // 0x02E0(0x0050)(Edit, Transient, EditConst, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	TArray<class UMeshComponent*>                 MeshesToDestroy;                                   // 0x0330(0x0010)(Edit, ExportObject, ZeroConstructor, Transient, EditConst, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_2F71[0x8];                                     // 0x0340(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTagContainer                  PersistentMeshComponentSlots;                      // 0x0348(0x0020)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FGzCharacterCustomizationProfile       CurrentCustomizationProfile;                       // 0x0368(0x0150)(Transient, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_2F72[0xA0];                                    // 0x04B8(0x00A0)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bEditorShoesPreview;                               // 0x0558(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bLegsPreview;                                      // 0x0559(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2F73[0x6];                                     // 0x055A(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UGzCustomizationModifier*>       CurrentCharacterModifiers;                         // 0x0560(0x0010)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	class UTexture2D*                             DefaultBodyOpacityMask;                            // 0x0570(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2F74[0x2A8];                                   // 0x0578(0x02A8)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ApplyCurrentProfile();
	void ApplyCustomizationItem(const struct FGzCharacterCustomizationItem& CustomizationItem, const bool bDefaultProfile);
	void ApplyCustomizationServer();
	void OnCharacterLimbChanged(const EGzLimbType LimbType);
	void OnHasDefaultLegsTagChanged(const struct FGameplayTag& DefaultLegsPresentTag, int32 Count);
	void OnHasInitialLegsTagChanged(const struct FGameplayTag& InitialLegsPresentTag, int32 Count);
	void SetNewCustomizationProfile(const struct FGzCharacterCustomizationProfile& NewProfile);

	const struct FGzCharacterCustomizationProfile GetCurrentCharacterCustomizationProfile() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzCharacterCustomizationComponent">();
	}
	static class UGzCharacterCustomizationComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzCharacterCustomizationComponent>();
	}
};
static_assert(alignof(UGzCharacterCustomizationComponent) == 0x000010, "Wrong alignment on UGzCharacterCustomizationComponent");
static_assert(sizeof(UGzCharacterCustomizationComponent) == 0x000820, "Wrong size on UGzCharacterCustomizationComponent");
static_assert(offsetof(UGzCharacterCustomizationComponent, Debugger) == 0x0000E0, "Member 'UGzCharacterCustomizationComponent::Debugger' has a wrong offset!");
static_assert(offsetof(UGzCharacterCustomizationComponent, MeshesInLogicalSlots) == 0x0002E0, "Member 'UGzCharacterCustomizationComponent::MeshesInLogicalSlots' has a wrong offset!");
static_assert(offsetof(UGzCharacterCustomizationComponent, MeshesToDestroy) == 0x000330, "Member 'UGzCharacterCustomizationComponent::MeshesToDestroy' has a wrong offset!");
static_assert(offsetof(UGzCharacterCustomizationComponent, PersistentMeshComponentSlots) == 0x000348, "Member 'UGzCharacterCustomizationComponent::PersistentMeshComponentSlots' has a wrong offset!");
static_assert(offsetof(UGzCharacterCustomizationComponent, CurrentCustomizationProfile) == 0x000368, "Member 'UGzCharacterCustomizationComponent::CurrentCustomizationProfile' has a wrong offset!");
static_assert(offsetof(UGzCharacterCustomizationComponent, bEditorShoesPreview) == 0x000558, "Member 'UGzCharacterCustomizationComponent::bEditorShoesPreview' has a wrong offset!");
static_assert(offsetof(UGzCharacterCustomizationComponent, bLegsPreview) == 0x000559, "Member 'UGzCharacterCustomizationComponent::bLegsPreview' has a wrong offset!");
static_assert(offsetof(UGzCharacterCustomizationComponent, CurrentCharacterModifiers) == 0x000560, "Member 'UGzCharacterCustomizationComponent::CurrentCharacterModifiers' has a wrong offset!");
static_assert(offsetof(UGzCharacterCustomizationComponent, DefaultBodyOpacityMask) == 0x000570, "Member 'UGzCharacterCustomizationComponent::DefaultBodyOpacityMask' has a wrong offset!");

// Class G01.GzBackendExportedObject
// 0x0000 (0x0028 - 0x0028)
class IGzBackendExportedObject final : public IInterface
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzBackendExportedObject">();
	}
	static class IGzBackendExportedObject* GetDefaultObj()
	{
		return GetDefaultObjImpl<IGzBackendExportedObject>();
	}
};
static_assert(alignof(IGzBackendExportedObject) == 0x000008, "Wrong alignment on IGzBackendExportedObject");
static_assert(sizeof(IGzBackendExportedObject) == 0x000028, "Wrong size on IGzBackendExportedObject");

// Class G01.GzBackendManager
// 0x01B0 (0x01E0 - 0x0030)
class UGzBackendManager final : public UGameInstanceSubsystem
{
public:
	TMap<TSubclassOf<class UGzPlayFabObject>, class UGzPlayFabObject*> PlayFabObjects;                                    // 0x0030(0x0050)(NativeAccessSpecifierPrivate)
	TMap<TSubclassOf<class UGzMetaSubsystem>, class UGzMetaSubsystem*> MetaSubsystems;                                    // 0x0080(0x0050)(NativeAccessSpecifierPrivate)
	TMap<TSubclassOf<class UGzFacade>, class UGzFacade*> Facades;                                           // 0x00D0(0x0050)(NativeAccessSpecifierPrivate)
	uint8                                         Pad_2F76[0xC0];                                    // 0x0120(0x00C0)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzBackendManager">();
	}
	static class UGzBackendManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzBackendManager>();
	}
};
static_assert(alignof(UGzBackendManager) == 0x000008, "Wrong alignment on UGzBackendManager");
static_assert(sizeof(UGzBackendManager) == 0x0001E0, "Wrong size on UGzBackendManager");
static_assert(offsetof(UGzBackendManager, PlayFabObjects) == 0x000030, "Member 'UGzBackendManager::PlayFabObjects' has a wrong offset!");
static_assert(offsetof(UGzBackendManager, MetaSubsystems) == 0x000080, "Member 'UGzBackendManager::MetaSubsystems' has a wrong offset!");
static_assert(offsetof(UGzBackendManager, Facades) == 0x0000D0, "Member 'UGzBackendManager::Facades' has a wrong offset!");

// Class G01.GzSurfaceTypeEvents
// 0x0058 (0x0088 - 0x0030)
class UGzSurfaceTypeEvents final : public UDataAsset
{
public:
	class UAkAudioEvent*                          Default;                                           // 0x0030(0x0008)(Edit, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMap<EPhysicalSurface, class UAkAudioEvent*>  AudioEventsForSurfaceType;                         // 0x0038(0x0050)(Edit, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzSurfaceTypeEvents">();
	}
	static class UGzSurfaceTypeEvents* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzSurfaceTypeEvents>();
	}
};
static_assert(alignof(UGzSurfaceTypeEvents) == 0x000008, "Wrong alignment on UGzSurfaceTypeEvents");
static_assert(sizeof(UGzSurfaceTypeEvents) == 0x000088, "Wrong size on UGzSurfaceTypeEvents");
static_assert(offsetof(UGzSurfaceTypeEvents, Default) == 0x000030, "Member 'UGzSurfaceTypeEvents::Default' has a wrong offset!");
static_assert(offsetof(UGzSurfaceTypeEvents, AudioEventsForSurfaceType) == 0x000038, "Member 'UGzSurfaceTypeEvents::AudioEventsForSurfaceType' has a wrong offset!");

// Class G01.GzCustomizationItemTemplate
// 0x0178 (0x0450 - 0x02D8)
class UGzCustomizationItemTemplate : public UGzItemData
{
public:
	uint8                                         Pad_2F77[0x8];                                     // 0x02D8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTag                           PrimaryLogicalSlot;                                // 0x02E0(0x0008)(Edit, BlueprintVisible, DisableEditOnInstance, NoDestructor, AssetRegistrySearchable, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTagContainer                  LogicalSlots;                                      // 0x02E8(0x0020)(Edit, BlueprintVisible, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FGameplayTagContainer                  IdentificationVisualSlots;                         // 0x0308(0x0020)(Edit, BlueprintVisible, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FGameplayTagContainer                  UsedVisualSlots;                                   // 0x0328(0x0020)(Edit, BlueprintVisible, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FGzCustomizationAudioEvents            CustomizationAudioEvents;                          // 0x0348(0x0018)(Edit, BlueprintVisible, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	TArray<struct FGzCustomizationItemVariation>  ItemVariationsData;                                // 0x0360(0x0010)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FGzMeshContainer                       MeshContainer;                                     // 0x0370(0x0010)(Edit, BlueprintVisible, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TArray<class UGzCustomizationModifierTemplate*> AvailableModifiers;                                // 0x0380(0x0010)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, ContainsInstancedReference, NativeAccessSpecifierPublic)
	class UGzModifiersPreset*                     ModifiersPresetAsset;                              // 0x0390(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bOverrideModifiersPresetProperties;                // 0x0398(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2F78[0x7];                                     // 0x0399(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FGzModifiersPresetOverrideProperties> ModifiersPresetPropertiesOverride;                 // 0x03A0(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	struct FGzGenderedBodyOpacityMasks            GenderedBodyOpacityMasks;                          // 0x03B0(0x00A0)(Edit, BlueprintVisible, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzCustomizationItemTemplate">();
	}
	static class UGzCustomizationItemTemplate* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzCustomizationItemTemplate>();
	}
};
static_assert(alignof(UGzCustomizationItemTemplate) == 0x000008, "Wrong alignment on UGzCustomizationItemTemplate");
static_assert(sizeof(UGzCustomizationItemTemplate) == 0x000450, "Wrong size on UGzCustomizationItemTemplate");
static_assert(offsetof(UGzCustomizationItemTemplate, PrimaryLogicalSlot) == 0x0002E0, "Member 'UGzCustomizationItemTemplate::PrimaryLogicalSlot' has a wrong offset!");
static_assert(offsetof(UGzCustomizationItemTemplate, LogicalSlots) == 0x0002E8, "Member 'UGzCustomizationItemTemplate::LogicalSlots' has a wrong offset!");
static_assert(offsetof(UGzCustomizationItemTemplate, IdentificationVisualSlots) == 0x000308, "Member 'UGzCustomizationItemTemplate::IdentificationVisualSlots' has a wrong offset!");
static_assert(offsetof(UGzCustomizationItemTemplate, UsedVisualSlots) == 0x000328, "Member 'UGzCustomizationItemTemplate::UsedVisualSlots' has a wrong offset!");
static_assert(offsetof(UGzCustomizationItemTemplate, CustomizationAudioEvents) == 0x000348, "Member 'UGzCustomizationItemTemplate::CustomizationAudioEvents' has a wrong offset!");
static_assert(offsetof(UGzCustomizationItemTemplate, ItemVariationsData) == 0x000360, "Member 'UGzCustomizationItemTemplate::ItemVariationsData' has a wrong offset!");
static_assert(offsetof(UGzCustomizationItemTemplate, MeshContainer) == 0x000370, "Member 'UGzCustomizationItemTemplate::MeshContainer' has a wrong offset!");
static_assert(offsetof(UGzCustomizationItemTemplate, AvailableModifiers) == 0x000380, "Member 'UGzCustomizationItemTemplate::AvailableModifiers' has a wrong offset!");
static_assert(offsetof(UGzCustomizationItemTemplate, ModifiersPresetAsset) == 0x000390, "Member 'UGzCustomizationItemTemplate::ModifiersPresetAsset' has a wrong offset!");
static_assert(offsetof(UGzCustomizationItemTemplate, bOverrideModifiersPresetProperties) == 0x000398, "Member 'UGzCustomizationItemTemplate::bOverrideModifiersPresetProperties' has a wrong offset!");
static_assert(offsetof(UGzCustomizationItemTemplate, ModifiersPresetPropertiesOverride) == 0x0003A0, "Member 'UGzCustomizationItemTemplate::ModifiersPresetPropertiesOverride' has a wrong offset!");
static_assert(offsetof(UGzCustomizationItemTemplate, GenderedBodyOpacityMasks) == 0x0003B0, "Member 'UGzCustomizationItemTemplate::GenderedBodyOpacityMasks' has a wrong offset!");

// Class G01.GzCIT_Emote
// 0x0060 (0x04B0 - 0x0450)
class UGzCIT_Emote final : public UGzCustomizationItemTemplate
{
public:
	TSoftObjectPtr<class UAnimMontage>            EmoteMontage;                                      // 0x0450(0x0028)(Edit, DisableEditOnInstance, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         EmoteId;                                           // 0x0478(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   EmoteName;                                         // 0x047C(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2F79[0x4];                                     // 0x0484(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftObjectPtr<class UTexture2D>              EmoteImage;                                        // 0x0488(0x0028)(Edit, DisableEditOnInstance, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	int32 GetEmoteId() const;
	class UAnimMontage* GetEmoteMontage() const;
	class FName GetEmoteName() const;
	class UTexture2D* GetEmoteTexture() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzCIT_Emote">();
	}
	static class UGzCIT_Emote* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzCIT_Emote>();
	}
};
static_assert(alignof(UGzCIT_Emote) == 0x000008, "Wrong alignment on UGzCIT_Emote");
static_assert(sizeof(UGzCIT_Emote) == 0x0004B0, "Wrong size on UGzCIT_Emote");
static_assert(offsetof(UGzCIT_Emote, EmoteMontage) == 0x000450, "Member 'UGzCIT_Emote::EmoteMontage' has a wrong offset!");
static_assert(offsetof(UGzCIT_Emote, EmoteId) == 0x000478, "Member 'UGzCIT_Emote::EmoteId' has a wrong offset!");
static_assert(offsetof(UGzCIT_Emote, EmoteName) == 0x00047C, "Member 'UGzCIT_Emote::EmoteName' has a wrong offset!");
static_assert(offsetof(UGzCIT_Emote, EmoteImage) == 0x000488, "Member 'UGzCIT_Emote::EmoteImage' has a wrong offset!");

// Class G01.GzSpawnZone
// 0x0080 (0x0320 - 0x02A0)
class AGzSpawnZone final : public AActor
{
public:
	float                                         SpawnZoneRadius;                                   // 0x02A0(0x0004)(Edit, Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         PlayerSpawnHeight;                                 // 0x02A4(0x0004)(Edit, Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bKillOutsideZone;                                  // 0x02A8(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2F7A[0x7];                                     // 0x02A9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UGameplayEffect>            ExitSpawnZoneEffect;                               // 0x02B0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UMaterialInterface*                     Material;                                          // 0x02B8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         CirclePointsCount;                                 // 0x02C0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2F7B[0x4];                                     // 0x02C4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UProceduralMeshComponent*               CircleMesh;                                        // 0x02C8(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TMap<class AGzCharacter*, struct FActiveGameplayEffectHandle> CharacterToEffectHandle;                           // 0x02D0(0x0050)(Transient, NativeAccessSpecifierPrivate)

public:
	void Activate();
	void Deactivate();
	void OnEndOverlap(class UPrimitiveComponent* Component, class AActor* Actor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex);

	float GetSpawnHeight() const;
	float GetSpawnRadius() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzSpawnZone">();
	}
	static class AGzSpawnZone* GetDefaultObj()
	{
		return GetDefaultObjImpl<AGzSpawnZone>();
	}
};
static_assert(alignof(AGzSpawnZone) == 0x000008, "Wrong alignment on AGzSpawnZone");
static_assert(sizeof(AGzSpawnZone) == 0x000320, "Wrong size on AGzSpawnZone");
static_assert(offsetof(AGzSpawnZone, SpawnZoneRadius) == 0x0002A0, "Member 'AGzSpawnZone::SpawnZoneRadius' has a wrong offset!");
static_assert(offsetof(AGzSpawnZone, PlayerSpawnHeight) == 0x0002A4, "Member 'AGzSpawnZone::PlayerSpawnHeight' has a wrong offset!");
static_assert(offsetof(AGzSpawnZone, bKillOutsideZone) == 0x0002A8, "Member 'AGzSpawnZone::bKillOutsideZone' has a wrong offset!");
static_assert(offsetof(AGzSpawnZone, ExitSpawnZoneEffect) == 0x0002B0, "Member 'AGzSpawnZone::ExitSpawnZoneEffect' has a wrong offset!");
static_assert(offsetof(AGzSpawnZone, Material) == 0x0002B8, "Member 'AGzSpawnZone::Material' has a wrong offset!");
static_assert(offsetof(AGzSpawnZone, CirclePointsCount) == 0x0002C0, "Member 'AGzSpawnZone::CirclePointsCount' has a wrong offset!");
static_assert(offsetof(AGzSpawnZone, CircleMesh) == 0x0002C8, "Member 'AGzSpawnZone::CircleMesh' has a wrong offset!");
static_assert(offsetof(AGzSpawnZone, CharacterToEffectHandle) == 0x0002D0, "Member 'AGzSpawnZone::CharacterToEffectHandle' has a wrong offset!");

// Class G01.GzBackendPlayerDataHelper
// 0x0000 (0x0028 - 0x0028)
class UGzBackendPlayerDataHelper final : public UBlueprintFunctionLibrary
{
public:
	static const class UTexture2D* GetPlayerAvatar(const class UObject* WorldContextObject);
	static class FString GetPlayerClanTag(const class UObject* WorldContextObject);
	static const struct FGzLevelProgression GetPlayerProgression(const class UObject* WorldContextObject);
	static bool HasPlayerValidSubscription(const class UObject* WorldContextObject);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzBackendPlayerDataHelper">();
	}
	static class UGzBackendPlayerDataHelper* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzBackendPlayerDataHelper>();
	}
};
static_assert(alignof(UGzBackendPlayerDataHelper) == 0x000008, "Wrong alignment on UGzBackendPlayerDataHelper");
static_assert(sizeof(UGzBackendPlayerDataHelper) == 0x000028, "Wrong size on UGzBackendPlayerDataHelper");

// Class G01.GzBackendSubsystem
// 0x0020 (0x02C0 - 0x02A0)
class AGzBackendSubsystem final : public AGzGameModeSubsystem
{
public:
	FMulticastInlineDelegateProperty_             OnCallLoadout;                                     // 0x02A0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnCallSaveLoadout;                                 // 0x02B0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)

public:
	void OnCallLoadout__DelegateSignature(class AActor* InitiatorObject, const class FString& PlayFabId, const class FString& CharacterId);
	void OnCallSaveLoadout__DelegateSignature(const class FString& PlayFabId, const class FString& CharacterId);
	void SpawnLootChest(class AActor* InitiatorObject, const TArray<struct FGzInventoryItemContent>& LootList);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzBackendSubsystem">();
	}
	static class AGzBackendSubsystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<AGzBackendSubsystem>();
	}
};
static_assert(alignof(AGzBackendSubsystem) == 0x000008, "Wrong alignment on AGzBackendSubsystem");
static_assert(sizeof(AGzBackendSubsystem) == 0x0002C0, "Wrong size on AGzBackendSubsystem");
static_assert(offsetof(AGzBackendSubsystem, OnCallLoadout) == 0x0002A0, "Member 'AGzBackendSubsystem::OnCallLoadout' has a wrong offset!");
static_assert(offsetof(AGzBackendSubsystem, OnCallSaveLoadout) == 0x0002B0, "Member 'AGzBackendSubsystem::OnCallSaveLoadout' has a wrong offset!");

// Class G01.GzCharacterCustomizationViewpointCluster
// 0x0050 (0x0300 - 0x02B0)
class AGzCharacterCustomizationViewpointCluster final : public AGzViewpointClusterBase
{
public:
	TMap<struct FGameplayTag, struct FGzViewpoint> Viewpoints;                                        // 0x02B0(0x0050)(Edit, DisableEditOnTemplate, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzCharacterCustomizationViewpointCluster">();
	}
	static class AGzCharacterCustomizationViewpointCluster* GetDefaultObj()
	{
		return GetDefaultObjImpl<AGzCharacterCustomizationViewpointCluster>();
	}
};
static_assert(alignof(AGzCharacterCustomizationViewpointCluster) == 0x000008, "Wrong alignment on AGzCharacterCustomizationViewpointCluster");
static_assert(sizeof(AGzCharacterCustomizationViewpointCluster) == 0x000300, "Wrong size on AGzCharacterCustomizationViewpointCluster");
static_assert(offsetof(AGzCharacterCustomizationViewpointCluster, Viewpoints) == 0x0002B0, "Member 'AGzCharacterCustomizationViewpointCluster::Viewpoints' has a wrong offset!");

// Class G01.GzBackpackItemData
// 0x0018 (0x03E0 - 0x03C8)
class UGzBackpackItemData final : public UGzSimpleItemData
{
public:
	int32                                         AdditionalPocketCount;                             // 0x03C8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2F7E[0x4];                                     // 0x03CC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FGzInvPocketDef>                BackpackPocketDefs;                                // 0x03D0(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPrivate)

public:
	int32 GetBackpackPocketDefsCount() const;
	int32 GetPocketCount() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzBackpackItemData">();
	}
	static class UGzBackpackItemData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzBackpackItemData>();
	}
};
static_assert(alignof(UGzBackpackItemData) == 0x000008, "Wrong alignment on UGzBackpackItemData");
static_assert(sizeof(UGzBackpackItemData) == 0x0003E0, "Wrong size on UGzBackpackItemData");
static_assert(offsetof(UGzBackpackItemData, AdditionalPocketCount) == 0x0003C8, "Member 'UGzBackpackItemData::AdditionalPocketCount' has a wrong offset!");
static_assert(offsetof(UGzBackpackItemData, BackpackPocketDefs) == 0x0003D0, "Member 'UGzBackpackItemData::BackpackPocketDefs' has a wrong offset!");

// Class G01.GzGA_Wingsuit
// 0x0160 (0x06B0 - 0x0550)
class UGzGA_Wingsuit : public UGzGA_CharacterState
{
public:
	struct FLocomotionMantleTraceSettings         FallingTraceSettings;                              // 0x0550(0x0020)(Edit, BlueprintVisible, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	float                                         WingsuitDownwardTraceDist;                         // 0x0570(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2F7F[0x4];                                     // 0x0574(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UGzWingsuitSettingsDataAsset*           WingsuitMovementSettings;                          // 0x0578(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UGzWingsuitSettingsDataAsset*           DamagedWingsuitMovementSettings;                   // 0x0580(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FRuntimeFloatCurve                     HitReactionStacksPerDamageReceived;                // 0x0588(0x0088)(Edit, BlueprintVisible, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	class UGzPawnInputMappingConfig*              WingsuitInputMappingConfig;                        // 0x0610(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         AutodeploymentHeightMeters;                        // 0x0618(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         AutodeploymentMinimalHeightMeters;                 // 0x061C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         LandingHeightTreshold;                             // 0x0620(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         PreLandingHeightTreshold;                          // 0x0624(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bShouldSnapPlayerToCameraForwardVector;            // 0x0628(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2F80[0x7];                                     // 0x0629(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UGzWingsuitSettingsDataAsset*           CurrentWingsuitDataSettings;                       // 0x0630(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         LandingAnimationPitchThreshold;                    // 0x0638(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         LandingAnimationSpeedThreshold;                    // 0x063C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAnimMontage*                           LandingRollAnim;                                   // 0x0640(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAnimMontage*                           LandingSquatAnim;                                  // 0x0648(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAnimMontage*                           HitReactionAnim;                                   // 0x0650(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UGzAT_PlayMontageAndWaitForEvent*       CurrentReactionTask;                               // 0x0658(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UGzAT_PlayMontageAndWaitForEvent*       CurrentHitReactionTask;                            // 0x0660(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UGameplayEffect>            HitReactionInJetpackEffect;                        // 0x0668(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2F81[0x40];                                    // 0x0670(0x0040)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static bool CanActivateJetpack(class AGzCharacter* Character);
	static bool IsJetpackActive(class AGzCharacter* Character);

	void BP_DeactivateJetpack(const bool bWasCancelled);
	void OnHitReactionInJetpackTagChanged(const struct FGameplayTag& HitReactionInJetpackTag, int32 Count);
	void OnMontageEnded();
	void OnMontageNotify(const class FName NotifyName);
	void OnMovementModeChangeWingsuit(class ACharacter* Character, EMovementMode PrevMovementMode, uint8 PreviousCustomMode);

	bool IsDamaged() const;
	bool IsStarted() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzGA_Wingsuit">();
	}
	static class UGzGA_Wingsuit* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzGA_Wingsuit>();
	}
};
static_assert(alignof(UGzGA_Wingsuit) == 0x000008, "Wrong alignment on UGzGA_Wingsuit");
static_assert(sizeof(UGzGA_Wingsuit) == 0x0006B0, "Wrong size on UGzGA_Wingsuit");
static_assert(offsetof(UGzGA_Wingsuit, FallingTraceSettings) == 0x000550, "Member 'UGzGA_Wingsuit::FallingTraceSettings' has a wrong offset!");
static_assert(offsetof(UGzGA_Wingsuit, WingsuitDownwardTraceDist) == 0x000570, "Member 'UGzGA_Wingsuit::WingsuitDownwardTraceDist' has a wrong offset!");
static_assert(offsetof(UGzGA_Wingsuit, WingsuitMovementSettings) == 0x000578, "Member 'UGzGA_Wingsuit::WingsuitMovementSettings' has a wrong offset!");
static_assert(offsetof(UGzGA_Wingsuit, DamagedWingsuitMovementSettings) == 0x000580, "Member 'UGzGA_Wingsuit::DamagedWingsuitMovementSettings' has a wrong offset!");
static_assert(offsetof(UGzGA_Wingsuit, HitReactionStacksPerDamageReceived) == 0x000588, "Member 'UGzGA_Wingsuit::HitReactionStacksPerDamageReceived' has a wrong offset!");
static_assert(offsetof(UGzGA_Wingsuit, WingsuitInputMappingConfig) == 0x000610, "Member 'UGzGA_Wingsuit::WingsuitInputMappingConfig' has a wrong offset!");
static_assert(offsetof(UGzGA_Wingsuit, AutodeploymentHeightMeters) == 0x000618, "Member 'UGzGA_Wingsuit::AutodeploymentHeightMeters' has a wrong offset!");
static_assert(offsetof(UGzGA_Wingsuit, AutodeploymentMinimalHeightMeters) == 0x00061C, "Member 'UGzGA_Wingsuit::AutodeploymentMinimalHeightMeters' has a wrong offset!");
static_assert(offsetof(UGzGA_Wingsuit, LandingHeightTreshold) == 0x000620, "Member 'UGzGA_Wingsuit::LandingHeightTreshold' has a wrong offset!");
static_assert(offsetof(UGzGA_Wingsuit, PreLandingHeightTreshold) == 0x000624, "Member 'UGzGA_Wingsuit::PreLandingHeightTreshold' has a wrong offset!");
static_assert(offsetof(UGzGA_Wingsuit, bShouldSnapPlayerToCameraForwardVector) == 0x000628, "Member 'UGzGA_Wingsuit::bShouldSnapPlayerToCameraForwardVector' has a wrong offset!");
static_assert(offsetof(UGzGA_Wingsuit, CurrentWingsuitDataSettings) == 0x000630, "Member 'UGzGA_Wingsuit::CurrentWingsuitDataSettings' has a wrong offset!");
static_assert(offsetof(UGzGA_Wingsuit, LandingAnimationPitchThreshold) == 0x000638, "Member 'UGzGA_Wingsuit::LandingAnimationPitchThreshold' has a wrong offset!");
static_assert(offsetof(UGzGA_Wingsuit, LandingAnimationSpeedThreshold) == 0x00063C, "Member 'UGzGA_Wingsuit::LandingAnimationSpeedThreshold' has a wrong offset!");
static_assert(offsetof(UGzGA_Wingsuit, LandingRollAnim) == 0x000640, "Member 'UGzGA_Wingsuit::LandingRollAnim' has a wrong offset!");
static_assert(offsetof(UGzGA_Wingsuit, LandingSquatAnim) == 0x000648, "Member 'UGzGA_Wingsuit::LandingSquatAnim' has a wrong offset!");
static_assert(offsetof(UGzGA_Wingsuit, HitReactionAnim) == 0x000650, "Member 'UGzGA_Wingsuit::HitReactionAnim' has a wrong offset!");
static_assert(offsetof(UGzGA_Wingsuit, CurrentReactionTask) == 0x000658, "Member 'UGzGA_Wingsuit::CurrentReactionTask' has a wrong offset!");
static_assert(offsetof(UGzGA_Wingsuit, CurrentHitReactionTask) == 0x000660, "Member 'UGzGA_Wingsuit::CurrentHitReactionTask' has a wrong offset!");
static_assert(offsetof(UGzGA_Wingsuit, HitReactionInJetpackEffect) == 0x000668, "Member 'UGzGA_Wingsuit::HitReactionInJetpackEffect' has a wrong offset!");

// Class G01.GzUIDataSystem
// 0x0068 (0x0308 - 0x02A0)
class AGzUIDataSystem : public AInfo
{
public:
	TMap<TSubclassOf<class UGzCohtmlDataModel>, class UGzCohtmlDataModel*> DataModels;                                        // 0x02A0(0x0050)(NativeAccessSpecifierPrivate)
	uint8                                         Pad_2F85[0x10];                                    // 0x02F0(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class AGzCharacter*                           Character;                                         // 0x0300(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzUIDataSystem">();
	}
	static class AGzUIDataSystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<AGzUIDataSystem>();
	}
};
static_assert(alignof(AGzUIDataSystem) == 0x000008, "Wrong alignment on AGzUIDataSystem");
static_assert(sizeof(AGzUIDataSystem) == 0x000308, "Wrong size on AGzUIDataSystem");
static_assert(offsetof(AGzUIDataSystem, DataModels) == 0x0002A0, "Member 'AGzUIDataSystem::DataModels' has a wrong offset!");
static_assert(offsetof(AGzUIDataSystem, Character) == 0x000300, "Member 'AGzUIDataSystem::Character' has a wrong offset!");

// Class G01.GzGA_WeaponSwitchScopeMode
// 0x0000 (0x0558 - 0x0558)
class UGzGA_WeaponSwitchScopeMode : public UGzGA_WeaponAbilityBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzGA_WeaponSwitchScopeMode">();
	}
	static class UGzGA_WeaponSwitchScopeMode* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzGA_WeaponSwitchScopeMode>();
	}
};
static_assert(alignof(UGzGA_WeaponSwitchScopeMode) == 0x000008, "Wrong alignment on UGzGA_WeaponSwitchScopeMode");
static_assert(sizeof(UGzGA_WeaponSwitchScopeMode) == 0x000558, "Wrong size on UGzGA_WeaponSwitchScopeMode");

// Class G01.GzCharacterAkComponent
// 0x00A0 (0x04E0 - 0x0440)
class UGzCharacterAkComponent : public UAkComponent
{
public:
	TMap<EGzZiplineEventType, class UAkAudioEvent*> ZiplineEvents;                                     // 0x0438(0x0050)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	TMap<ETeamAttitude, class UAkSwitchValue*>    TeamAttitudeSwitches;                              // 0x0488(0x0050)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	bool                                          bCanPlayVoiceLines;                                // 0x04D8(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2F86[0x7];                                     // 0x04D9(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnLocalPlayerInitialized(class AGzPlayerController* Controller, class AGzPlayerState* PlayerState);
	void OnPlayerStateReplicated(class AGzPlayerState* PlayerState);
	void OnTeamChanged(class AGzPlayerState* PlayerState);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzCharacterAkComponent">();
	}
	static class UGzCharacterAkComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzCharacterAkComponent>();
	}
};
static_assert(alignof(UGzCharacterAkComponent) == 0x000010, "Wrong alignment on UGzCharacterAkComponent");
static_assert(sizeof(UGzCharacterAkComponent) == 0x0004E0, "Wrong size on UGzCharacterAkComponent");
static_assert(offsetof(UGzCharacterAkComponent, ZiplineEvents) == 0x000438, "Member 'UGzCharacterAkComponent::ZiplineEvents' has a wrong offset!");
static_assert(offsetof(UGzCharacterAkComponent, TeamAttitudeSwitches) == 0x000488, "Member 'UGzCharacterAkComponent::TeamAttitudeSwitches' has a wrong offset!");
static_assert(offsetof(UGzCharacterAkComponent, bCanPlayVoiceLines) == 0x0004D8, "Member 'UGzCharacterAkComponent::bCanPlayVoiceLines' has a wrong offset!");

// Class G01.GzBanReceivedData
// 0x0000 (0x0028 - 0x0028)
class UGzBanReceivedData final : public UGzSignalREventData
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzBanReceivedData">();
	}
	static class UGzBanReceivedData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzBanReceivedData>();
	}
};
static_assert(alignof(UGzBanReceivedData) == 0x000008, "Wrong alignment on UGzBanReceivedData");
static_assert(sizeof(UGzBanReceivedData) == 0x000028, "Wrong size on UGzBanReceivedData");

// Class G01.GzSignalREvent
// 0x0020 (0x0048 - 0x0028)
class UGzSignalREvent : public UObject
{
public:
	class UGzSignalREventData*                    Data;                                              // 0x0028(0x0008)(ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2F87[0x18];                                    // 0x0030(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzSignalREvent">();
	}
	static class UGzSignalREvent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzSignalREvent>();
	}
};
static_assert(alignof(UGzSignalREvent) == 0x000008, "Wrong alignment on UGzSignalREvent");
static_assert(sizeof(UGzSignalREvent) == 0x000048, "Wrong size on UGzSignalREvent");
static_assert(offsetof(UGzSignalREvent, Data) == 0x000028, "Member 'UGzSignalREvent::Data' has a wrong offset!");

// Class G01.GzGA_OperateObject
// 0x0008 (0x0510 - 0x0508)
class UGzGA_OperateObject final : public UGzGameplayAbility
{
public:
	class UGzOperableObjectComponent*             OperableObjectComponent;                           // 0x0508(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzGA_OperateObject">();
	}
	static class UGzGA_OperateObject* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzGA_OperateObject>();
	}
};
static_assert(alignof(UGzGA_OperateObject) == 0x000008, "Wrong alignment on UGzGA_OperateObject");
static_assert(sizeof(UGzGA_OperateObject) == 0x000510, "Wrong size on UGzGA_OperateObject");
static_assert(offsetof(UGzGA_OperateObject, OperableObjectComponent) == 0x000508, "Member 'UGzGA_OperateObject::OperableObjectComponent' has a wrong offset!");

// Class G01.GzCharacterMetaSubsystem
// 0x0060 (0x0090 - 0x0030)
class UGzCharacterMetaSubsystem final : public UGzMetaSubsystem
{
public:
	uint8                                         Pad_2F88[0x60];                                    // 0x0030(0x0060)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void DestroyMetaCharacter(class AActor* Actor);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzCharacterMetaSubsystem">();
	}
	static class UGzCharacterMetaSubsystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzCharacterMetaSubsystem>();
	}
};
static_assert(alignof(UGzCharacterMetaSubsystem) == 0x000008, "Wrong alignment on UGzCharacterMetaSubsystem");
static_assert(sizeof(UGzCharacterMetaSubsystem) == 0x000090, "Wrong size on UGzCharacterMetaSubsystem");

// Class G01.GzBanReceivedHandler
// 0x0000 (0x0048 - 0x0048)
class UGzBanReceivedHandler final : public UGzSignalREvent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzBanReceivedHandler">();
	}
	static class UGzBanReceivedHandler* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzBanReceivedHandler>();
	}
};
static_assert(alignof(UGzBanReceivedHandler) == 0x000008, "Wrong alignment on UGzBanReceivedHandler");
static_assert(sizeof(UGzBanReceivedHandler) == 0x000048, "Wrong size on UGzBanReceivedHandler");

// Class G01.GzBansComponent
// 0x0028 (0x00C8 - 0x00A0)
class UGzBansComponent final : public UGzServiceComponent
{
public:
	uint8                                         Pad_2F89[0x28];                                    // 0x00A0(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzBansComponent">();
	}
	static class UGzBansComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzBansComponent>();
	}
};
static_assert(alignof(UGzBansComponent) == 0x000008, "Wrong alignment on UGzBansComponent");
static_assert(sizeof(UGzBansComponent) == 0x0000C8, "Wrong size on UGzBansComponent");

// Class G01.GzLoadingScreenContext
// 0x0050 (0x0078 - 0x0028)
class UGzLoadingScreenContext final : public UObject
{
public:
	uint8                                         Pad_2F8A[0x8];                                     // 0x0028(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftClassPtr<class UClass>                   Widget;                                            // 0x0030(0x0028)(Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	FMulticastInlineDelegateProperty_             OnMapChanged;                                      // 0x0058(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, Protected, NativeAccessSpecifierProtected)
	class FString                                 Map;                                               // 0x0068(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzLoadingScreenContext">();
	}
	static class UGzLoadingScreenContext* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzLoadingScreenContext>();
	}
};
static_assert(alignof(UGzLoadingScreenContext) == 0x000008, "Wrong alignment on UGzLoadingScreenContext");
static_assert(sizeof(UGzLoadingScreenContext) == 0x000078, "Wrong size on UGzLoadingScreenContext");
static_assert(offsetof(UGzLoadingScreenContext, Widget) == 0x000030, "Member 'UGzLoadingScreenContext::Widget' has a wrong offset!");
static_assert(offsetof(UGzLoadingScreenContext, OnMapChanged) == 0x000058, "Member 'UGzLoadingScreenContext::OnMapChanged' has a wrong offset!");
static_assert(offsetof(UGzLoadingScreenContext, Map) == 0x000068, "Member 'UGzLoadingScreenContext::Map' has a wrong offset!");

// Class G01.GzCameraLocationObject
// 0x0120 (0x04F0 - 0x03D0)
class UGzCameraLocationObject : public UATPCCameraLocationObject
{
public:
	TArray<struct FGzCameraOffset>                OffsetsPerLimbState;                               // 0x03C8(0x0010)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	uint8                                         Pad_2F8B[0x38];                                    // 0x03D8(0x0038)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         OffsetApplicationSpeed;                            // 0x0410(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         VisiblityDistanceTreshold;                         // 0x0414(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2F8C[0xB0];                                    // 0x0418(0x00B0)(Fixing Size After Last Property [ Dumper-7 ])
	class UCurveFloat*                            LeglessCameraBlendInCurve;                         // 0x04C8(0x0008)(Edit, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCurveFloat*                            LeglessCameraBlendOutCurve;                        // 0x04D0(0x0008)(Edit, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2F8D[0x18];                                    // 0x04D8(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void HidePlayer(class AGzPlayerCharacter* Character);
	void ShowPlayer(class AGzPlayerCharacter* Character);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzCameraLocationObject">();
	}
	static class UGzCameraLocationObject* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzCameraLocationObject>();
	}
};
static_assert(alignof(UGzCameraLocationObject) == 0x000010, "Wrong alignment on UGzCameraLocationObject");
static_assert(sizeof(UGzCameraLocationObject) == 0x0004F0, "Wrong size on UGzCameraLocationObject");
static_assert(offsetof(UGzCameraLocationObject, OffsetsPerLimbState) == 0x0003C8, "Member 'UGzCameraLocationObject::OffsetsPerLimbState' has a wrong offset!");
static_assert(offsetof(UGzCameraLocationObject, OffsetApplicationSpeed) == 0x000410, "Member 'UGzCameraLocationObject::OffsetApplicationSpeed' has a wrong offset!");
static_assert(offsetof(UGzCameraLocationObject, VisiblityDistanceTreshold) == 0x000414, "Member 'UGzCameraLocationObject::VisiblityDistanceTreshold' has a wrong offset!");
static_assert(offsetof(UGzCameraLocationObject, LeglessCameraBlendInCurve) == 0x0004C8, "Member 'UGzCameraLocationObject::LeglessCameraBlendInCurve' has a wrong offset!");
static_assert(offsetof(UGzCameraLocationObject, LeglessCameraBlendOutCurve) == 0x0004D0, "Member 'UGzCameraLocationObject::LeglessCameraBlendOutCurve' has a wrong offset!");

// Class G01.GzReplicationGraphNode_AlwaysRelevant_ForConnection
// 0x0280 (0x02D0 - 0x0050)
class UGzReplicationGraphNode_AlwaysRelevant_ForConnection final : public UReplicationGraphNode
{
public:
	uint8                                         Pad_2F8E[0x220];                                   // 0x0050(0x0220)(Fixing Size After Last Property [ Dumper-7 ])
	class AActor*                                 LastPawn;                                          // 0x0270(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2F8F[0x58];                                    // 0x0278(0x0058)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzReplicationGraphNode_AlwaysRelevant_ForConnection">();
	}
	static class UGzReplicationGraphNode_AlwaysRelevant_ForConnection* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzReplicationGraphNode_AlwaysRelevant_ForConnection>();
	}
};
static_assert(alignof(UGzReplicationGraphNode_AlwaysRelevant_ForConnection) == 0x000008, "Wrong alignment on UGzReplicationGraphNode_AlwaysRelevant_ForConnection");
static_assert(sizeof(UGzReplicationGraphNode_AlwaysRelevant_ForConnection) == 0x0002D0, "Wrong size on UGzReplicationGraphNode_AlwaysRelevant_ForConnection");
static_assert(offsetof(UGzReplicationGraphNode_AlwaysRelevant_ForConnection, LastPawn) == 0x000270, "Member 'UGzReplicationGraphNode_AlwaysRelevant_ForConnection::LastPawn' has a wrong offset!");

// Class G01.GzBaseAiAnimInstance
// 0x0020 (0x0390 - 0x0370)
class UGzBaseAiAnimInstance final : public UAnimInstance
{
public:
	EGzNPCMentalState                             MentalState;                                       // 0x0368(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2F90[0x7];                                     // 0x0369(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                LookAtTarget;                                      // 0x0370(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2F91[0x8];                                     // 0x0388(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzBaseAiAnimInstance">();
	}
	static class UGzBaseAiAnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzBaseAiAnimInstance>();
	}
};
static_assert(alignof(UGzBaseAiAnimInstance) == 0x000010, "Wrong alignment on UGzBaseAiAnimInstance");
static_assert(sizeof(UGzBaseAiAnimInstance) == 0x000390, "Wrong size on UGzBaseAiAnimInstance");
static_assert(offsetof(UGzBaseAiAnimInstance, MentalState) == 0x000368, "Member 'UGzBaseAiAnimInstance::MentalState' has a wrong offset!");
static_assert(offsetof(UGzBaseAiAnimInstance, LookAtTarget) == 0x000370, "Member 'UGzBaseAiAnimInstance::LookAtTarget' has a wrong offset!");

// Class G01.GzWeaponFXModifier
// 0x00B0 (0x00D8 - 0x0028)
class UGzWeaponFXModifier final : public UGzWeaponModifier
{
public:
	TSoftObjectPtr<class UNiagaraSystem>          MuzzleNiagaraSystemOverride;                       // 0x0028(0x0028)(Edit, DisableEditOnInstance, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftObjectPtr<class UNiagaraSystem>          InScope_MuzzleNiagaraSystemOverride;               // 0x0050(0x0028)(Edit, DisableEditOnInstance, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftObjectPtr<class UNiagaraSystem>          ShellEjectNiagaraSystemOverride;                   // 0x0078(0x0028)(Edit, DisableEditOnInstance, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftObjectPtr<class UNiagaraSystem>          TraceNiagaraSystemOverride;                        // 0x00A0(0x0028)(Edit, DisableEditOnInstance, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FGameplayTag                           PredictedImpactTagOverride;                        // 0x00C8(0x0008)(Edit, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FGameplayTag                           ApprovedImpactTagOverride;                         // 0x00D0(0x0008)(Edit, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzWeaponFXModifier">();
	}
	static class UGzWeaponFXModifier* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzWeaponFXModifier>();
	}
};
static_assert(alignof(UGzWeaponFXModifier) == 0x000008, "Wrong alignment on UGzWeaponFXModifier");
static_assert(sizeof(UGzWeaponFXModifier) == 0x0000D8, "Wrong size on UGzWeaponFXModifier");
static_assert(offsetof(UGzWeaponFXModifier, MuzzleNiagaraSystemOverride) == 0x000028, "Member 'UGzWeaponFXModifier::MuzzleNiagaraSystemOverride' has a wrong offset!");
static_assert(offsetof(UGzWeaponFXModifier, InScope_MuzzleNiagaraSystemOverride) == 0x000050, "Member 'UGzWeaponFXModifier::InScope_MuzzleNiagaraSystemOverride' has a wrong offset!");
static_assert(offsetof(UGzWeaponFXModifier, ShellEjectNiagaraSystemOverride) == 0x000078, "Member 'UGzWeaponFXModifier::ShellEjectNiagaraSystemOverride' has a wrong offset!");
static_assert(offsetof(UGzWeaponFXModifier, TraceNiagaraSystemOverride) == 0x0000A0, "Member 'UGzWeaponFXModifier::TraceNiagaraSystemOverride' has a wrong offset!");
static_assert(offsetof(UGzWeaponFXModifier, PredictedImpactTagOverride) == 0x0000C8, "Member 'UGzWeaponFXModifier::PredictedImpactTagOverride' has a wrong offset!");
static_assert(offsetof(UGzWeaponFXModifier, ApprovedImpactTagOverride) == 0x0000D0, "Member 'UGzWeaponFXModifier::ApprovedImpactTagOverride' has a wrong offset!");

// Class G01.GzLimbsSpawnedStatCollector
// 0x0008 (0x0040 - 0x0038)
class UGzLimbsSpawnedStatCollector final : public UGzGlobalStatsCollector
{
public:
	uint8                                         Pad_2F92[0x8];                                     // 0x0038(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzLimbsSpawnedStatCollector">();
	}
	static class UGzLimbsSpawnedStatCollector* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzLimbsSpawnedStatCollector>();
	}
};
static_assert(alignof(UGzLimbsSpawnedStatCollector) == 0x000008, "Wrong alignment on UGzLimbsSpawnedStatCollector");
static_assert(sizeof(UGzLimbsSpawnedStatCollector) == 0x000040, "Wrong size on UGzLimbsSpawnedStatCollector");

// Class G01.GzBPOnlyCharacterComponentSpec
// 0x00A8 (0x00D0 - 0x0028)
class UGzBPOnlyCharacterComponentSpec final : public UObject
{
public:
	uint8                                         Pad_2F93[0x8];                                     // 0x0028(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGzNativeCharacterComponentSpec        NativeComponentSpec;                               // 0x0030(0x0080)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          bIncludeOnServer;                                  // 0x00B0(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2F94[0x3];                                     // 0x00B1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   AccessName;                                        // 0x00B4(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   AttachToComponent;                                 // 0x00BC(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2F95[0x4];                                     // 0x00C4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class USceneComponent*                        Instance;                                          // 0x00C8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, Transient, EditConst, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzBPOnlyCharacterComponentSpec">();
	}
	static class UGzBPOnlyCharacterComponentSpec* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzBPOnlyCharacterComponentSpec>();
	}
};
static_assert(alignof(UGzBPOnlyCharacterComponentSpec) == 0x000010, "Wrong alignment on UGzBPOnlyCharacterComponentSpec");
static_assert(sizeof(UGzBPOnlyCharacterComponentSpec) == 0x0000D0, "Wrong size on UGzBPOnlyCharacterComponentSpec");
static_assert(offsetof(UGzBPOnlyCharacterComponentSpec, NativeComponentSpec) == 0x000030, "Member 'UGzBPOnlyCharacterComponentSpec::NativeComponentSpec' has a wrong offset!");
static_assert(offsetof(UGzBPOnlyCharacterComponentSpec, bIncludeOnServer) == 0x0000B0, "Member 'UGzBPOnlyCharacterComponentSpec::bIncludeOnServer' has a wrong offset!");
static_assert(offsetof(UGzBPOnlyCharacterComponentSpec, AccessName) == 0x0000B4, "Member 'UGzBPOnlyCharacterComponentSpec::AccessName' has a wrong offset!");
static_assert(offsetof(UGzBPOnlyCharacterComponentSpec, AttachToComponent) == 0x0000BC, "Member 'UGzBPOnlyCharacterComponentSpec::AttachToComponent' has a wrong offset!");
static_assert(offsetof(UGzBPOnlyCharacterComponentSpec, Instance) == 0x0000C8, "Member 'UGzBPOnlyCharacterComponentSpec::Instance' has a wrong offset!");

// Class G01.GzClientTelemetryPingCollector
// 0x0000 (0x0048 - 0x0048)
class UGzClientTelemetryPingCollector final : public UGzClientTelemetryStatCollector
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzClientTelemetryPingCollector">();
	}
	static class UGzClientTelemetryPingCollector* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzClientTelemetryPingCollector>();
	}
};
static_assert(alignof(UGzClientTelemetryPingCollector) == 0x000008, "Wrong alignment on UGzClientTelemetryPingCollector");
static_assert(sizeof(UGzClientTelemetryPingCollector) == 0x000048, "Wrong size on UGzClientTelemetryPingCollector");

// Class G01.GzBaseInventoryWidget
// 0x0008 (0x0310 - 0x0308)
class UGzBaseInventoryWidget : public UCommonUserWidget
{
public:
	class UGzInventoryScreen*                     InventoryScreen;                                   // 0x0308(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	class UGzInvComponent* GetInventoryComponent() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzBaseInventoryWidget">();
	}
	static class UGzBaseInventoryWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzBaseInventoryWidget>();
	}
};
static_assert(alignof(UGzBaseInventoryWidget) == 0x000008, "Wrong alignment on UGzBaseInventoryWidget");
static_assert(sizeof(UGzBaseInventoryWidget) == 0x000310, "Wrong size on UGzBaseInventoryWidget");
static_assert(offsetof(UGzBaseInventoryWidget, InventoryScreen) == 0x000308, "Member 'UGzBaseInventoryWidget::InventoryScreen' has a wrong offset!");

// Class G01.GzLiveFeaturesModel
// 0x00B0 (0x0120 - 0x0070)
class UGzLiveFeaturesModel final : public UGzBackendModel
{
public:
	uint8                                         Pad_2F96[0xB0];                                    // 0x0070(0x00B0)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzLiveFeaturesModel">();
	}
	static class UGzLiveFeaturesModel* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzLiveFeaturesModel>();
	}
};
static_assert(alignof(UGzLiveFeaturesModel) == 0x000008, "Wrong alignment on UGzLiveFeaturesModel");
static_assert(sizeof(UGzLiveFeaturesModel) == 0x000120, "Wrong size on UGzLiveFeaturesModel");

// Class G01.GzCharacterCustomizationSettings
// 0x02C0 (0x02F8 - 0x0038)
class UGzCharacterCustomizationSettings final : public UDeveloperSettings
{
public:
	uint8                                         Pad_2F97[0x8];                                     // 0x0038(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         MaxPresetCount;                                    // 0x0040(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         EmoteWheelSize;                                    // 0x0044(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTagContainer                  LogicalSlots;                                      // 0x0048(0x0020)(Edit, Config, AdvancedDisplay, NativeAccessSpecifierPublic)
	struct FGameplayTagContainer                  UiNonRemovableSlots;                               // 0x0068(0x0020)(Edit, Config, AdvancedDisplay, NativeAccessSpecifierPublic)
	struct FGameplayTagContainer                  LogicalNonRemovableSlots;                          // 0x0088(0x0020)(Edit, Config, AdvancedDisplay, NativeAccessSpecifierPublic)
	TMap<struct FGameplayTag, struct FGameplayTagContainer> BlockingSlots;                                     // 0x00A8(0x0050)(Edit, Config, AdvancedDisplay, NativeAccessSpecifierPublic)
	TMap<struct FGameplayTag, float>              DesiredCharacterRotation;                          // 0x00F8(0x0050)(Edit, Config, AdvancedDisplay, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UGzCustomizationItemTemplate> DefaultJetpack;                                    // 0x0148(0x0028)(Edit, Config, DisableEditOnInstance, AdvancedDisplay, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<TSoftObjectPtr<class UGzCustomizationProfileData>> DebugCustomizationPresets;                         // 0x0170(0x0010)(Edit, ZeroConstructor, Config, DisableEditOnInstance, UObjectWrapper, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UGzCustomizationProfileData> DefaultCustomizationPreset;                        // 0x0180(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, Config, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMap<class FName, struct FTransform>          RelativeTransformsForSkeletonSockets;              // 0x01A8(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, Config, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TMap<struct FGzBodyCustomizationArchetypeKey, TSoftObjectPtr<class UGzBodyCustomizationArchetype>> BodyCustomizationArchetypes;                       // 0x01F8(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, Config, DisableEditOnInstance, UObjectWrapper, NativeAccessSpecifierPublic)
	struct FGzBodyCustomizationArchetypeKey       DefaultBodyArchetype;                              // 0x0248(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, Config, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2F98[0x3];                                     // 0x0249(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   BodyMaskMaterialParamName;                         // 0x024C(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         BodyMaskMaterialParamsNum;                         // 0x0254(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UTexture2D>              BodyMaskDefaultTexture;                            // 0x0258(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, Config, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 LeftEyeMaterialSlotNameSuffix;                     // 0x0280(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 RightEyeMaterialSlotNameSuffix;                    // 0x0290(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 LeftEyeMaterialParamNameSuffix;                    // 0x02A0(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 RightEyeMaterialParamNameSuffix;                   // 0x02B0(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class USkinnedAsset>           HairReference;                                     // 0x02C0(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, Config, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 HairMorphTargetNameFilter;                         // 0x02E8(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzCharacterCustomizationSettings">();
	}
	static class UGzCharacterCustomizationSettings* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzCharacterCustomizationSettings>();
	}
};
static_assert(alignof(UGzCharacterCustomizationSettings) == 0x000008, "Wrong alignment on UGzCharacterCustomizationSettings");
static_assert(sizeof(UGzCharacterCustomizationSettings) == 0x0002F8, "Wrong size on UGzCharacterCustomizationSettings");
static_assert(offsetof(UGzCharacterCustomizationSettings, MaxPresetCount) == 0x000040, "Member 'UGzCharacterCustomizationSettings::MaxPresetCount' has a wrong offset!");
static_assert(offsetof(UGzCharacterCustomizationSettings, EmoteWheelSize) == 0x000044, "Member 'UGzCharacterCustomizationSettings::EmoteWheelSize' has a wrong offset!");
static_assert(offsetof(UGzCharacterCustomizationSettings, LogicalSlots) == 0x000048, "Member 'UGzCharacterCustomizationSettings::LogicalSlots' has a wrong offset!");
static_assert(offsetof(UGzCharacterCustomizationSettings, UiNonRemovableSlots) == 0x000068, "Member 'UGzCharacterCustomizationSettings::UiNonRemovableSlots' has a wrong offset!");
static_assert(offsetof(UGzCharacterCustomizationSettings, LogicalNonRemovableSlots) == 0x000088, "Member 'UGzCharacterCustomizationSettings::LogicalNonRemovableSlots' has a wrong offset!");
static_assert(offsetof(UGzCharacterCustomizationSettings, BlockingSlots) == 0x0000A8, "Member 'UGzCharacterCustomizationSettings::BlockingSlots' has a wrong offset!");
static_assert(offsetof(UGzCharacterCustomizationSettings, DesiredCharacterRotation) == 0x0000F8, "Member 'UGzCharacterCustomizationSettings::DesiredCharacterRotation' has a wrong offset!");
static_assert(offsetof(UGzCharacterCustomizationSettings, DefaultJetpack) == 0x000148, "Member 'UGzCharacterCustomizationSettings::DefaultJetpack' has a wrong offset!");
static_assert(offsetof(UGzCharacterCustomizationSettings, DebugCustomizationPresets) == 0x000170, "Member 'UGzCharacterCustomizationSettings::DebugCustomizationPresets' has a wrong offset!");
static_assert(offsetof(UGzCharacterCustomizationSettings, DefaultCustomizationPreset) == 0x000180, "Member 'UGzCharacterCustomizationSettings::DefaultCustomizationPreset' has a wrong offset!");
static_assert(offsetof(UGzCharacterCustomizationSettings, RelativeTransformsForSkeletonSockets) == 0x0001A8, "Member 'UGzCharacterCustomizationSettings::RelativeTransformsForSkeletonSockets' has a wrong offset!");
static_assert(offsetof(UGzCharacterCustomizationSettings, BodyCustomizationArchetypes) == 0x0001F8, "Member 'UGzCharacterCustomizationSettings::BodyCustomizationArchetypes' has a wrong offset!");
static_assert(offsetof(UGzCharacterCustomizationSettings, DefaultBodyArchetype) == 0x000248, "Member 'UGzCharacterCustomizationSettings::DefaultBodyArchetype' has a wrong offset!");
static_assert(offsetof(UGzCharacterCustomizationSettings, BodyMaskMaterialParamName) == 0x00024C, "Member 'UGzCharacterCustomizationSettings::BodyMaskMaterialParamName' has a wrong offset!");
static_assert(offsetof(UGzCharacterCustomizationSettings, BodyMaskMaterialParamsNum) == 0x000254, "Member 'UGzCharacterCustomizationSettings::BodyMaskMaterialParamsNum' has a wrong offset!");
static_assert(offsetof(UGzCharacterCustomizationSettings, BodyMaskDefaultTexture) == 0x000258, "Member 'UGzCharacterCustomizationSettings::BodyMaskDefaultTexture' has a wrong offset!");
static_assert(offsetof(UGzCharacterCustomizationSettings, LeftEyeMaterialSlotNameSuffix) == 0x000280, "Member 'UGzCharacterCustomizationSettings::LeftEyeMaterialSlotNameSuffix' has a wrong offset!");
static_assert(offsetof(UGzCharacterCustomizationSettings, RightEyeMaterialSlotNameSuffix) == 0x000290, "Member 'UGzCharacterCustomizationSettings::RightEyeMaterialSlotNameSuffix' has a wrong offset!");
static_assert(offsetof(UGzCharacterCustomizationSettings, LeftEyeMaterialParamNameSuffix) == 0x0002A0, "Member 'UGzCharacterCustomizationSettings::LeftEyeMaterialParamNameSuffix' has a wrong offset!");
static_assert(offsetof(UGzCharacterCustomizationSettings, RightEyeMaterialParamNameSuffix) == 0x0002B0, "Member 'UGzCharacterCustomizationSettings::RightEyeMaterialParamNameSuffix' has a wrong offset!");
static_assert(offsetof(UGzCharacterCustomizationSettings, HairReference) == 0x0002C0, "Member 'UGzCharacterCustomizationSettings::HairReference' has a wrong offset!");
static_assert(offsetof(UGzCharacterCustomizationSettings, HairMorphTargetNameFilter) == 0x0002E8, "Member 'UGzCharacterCustomizationSettings::HairMorphTargetNameFilter' has a wrong offset!");

// Class G01.GzLimbsAttachedStatCollector
// 0x0008 (0x0040 - 0x0038)
class UGzLimbsAttachedStatCollector final : public UGzGlobalStatsCollector
{
public:
	uint8                                         Pad_2F99[0x8];                                     // 0x0038(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzLimbsAttachedStatCollector">();
	}
	static class UGzLimbsAttachedStatCollector* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzLimbsAttachedStatCollector>();
	}
};
static_assert(alignof(UGzLimbsAttachedStatCollector) == 0x000008, "Wrong alignment on UGzLimbsAttachedStatCollector");
static_assert(sizeof(UGzLimbsAttachedStatCollector) == 0x000040, "Wrong size on UGzLimbsAttachedStatCollector");

// Class G01.GzCloakComponent
// 0x0370 (0x0460 - 0x00F0)
class UGzCloakComponent : public UGzLimbAbilityComponent
{
public:
	class UCurveFloat*                            DisolveCurve;                                      // 0x00F0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCurveFloat*                            CloakCurve;                                        // 0x00F8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMaterialInstanceDynamic*               UniversalDisolveMaterialDynamic;                   // 0x0100(0x0008)(BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMaterialInstanceDynamic*               CloakMaterialDynamic;                              // 0x0108(0x0008)(BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   DisolveEffectParameterName;                        // 0x0110(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   CloakEffectParameterName;                          // 0x0118(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bMaterialReseted;                                  // 0x0120(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bActive;                                           // 0x0121(0x0001)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2F9A[0x6];                                     // 0x0122(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class AGzCloak_Gadget*                        Gadjet;                                            // 0x0128(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnStateChanged;                                    // 0x0130(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	struct FGzCloak_Gadget_InitInfo               InitInfo;                                          // 0x0140(0x0058)(BlueprintVisible, BlueprintReadOnly, Net, RepNotify, NoDestructor, Protected, NativeAccessSpecifierProtected)
	class FName                                   PatternColorParameterName;                         // 0x0198(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FVector4                               PatternColorStart;                                 // 0x01A0(0x0020)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FVector4                               PatternColorEnd;                                   // 0x01C0(0x0020)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UAkAudioEvent*                          EnterAudioEvent;                                   // 0x01E0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UAkAudioEvent*                          ExitAudioEvent;                                    // 0x01E8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UPawnMovementComponent*                 CharacterMovementComponent;                        // 0x01F0(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FGzMeshCachedMaterials                 LimbCachedMaterials[0x3];                          // 0x01F8(0x0020)(ContainsInstancedReference, NativeAccessSpecifierPrivate)
	struct FGzMeshCachedMaterials                 HeadCachedMaterials;                               // 0x0258(0x0020)(ContainsInstancedReference, NativeAccessSpecifierPrivate)
	struct FGzMeshCachedMaterials                 TorsoCachedMaterials;                              // 0x0278(0x0020)(ContainsInstancedReference, NativeAccessSpecifierPrivate)
	struct FGzMeshCachedMaterials                 JetpackCachedMaterials;                            // 0x0298(0x0020)(ContainsInstancedReference, NativeAccessSpecifierPrivate)
	struct FGzMeshCachedMaterials                 BackpackCachedMaterials;                           // 0x02B8(0x0020)(ContainsInstancedReference, NativeAccessSpecifierPrivate)
	struct FGzMeshCachedMaterials                 ArmorCachedMaterials;                              // 0x02D8(0x0020)(ContainsInstancedReference, NativeAccessSpecifierPrivate)
	struct FGzMeshCachedMaterials                 HexCarrierCachedMaterials;                         // 0x02F8(0x0020)(ContainsInstancedReference, NativeAccessSpecifierPrivate)
	struct FGzMeshCachedMaterials                 HexCachedMaterials;                                // 0x0318(0x0020)(ContainsInstancedReference, NativeAccessSpecifierPrivate)
	struct FGzMeshCachedMaterials                 CharacterMeshCachedMaterials;                      // 0x0338(0x0020)(ContainsInstancedReference, NativeAccessSpecifierPrivate)
	TArray<struct FGzWeaponCachedMeshes>          WeaponCachedMeshesArray;                           // 0x0358(0x0010)(ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	TArray<struct FGzMeshCachedMaterials>         CachedCastomizations;                              // 0x0368(0x0010)(ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	class UGzAsyncTaskGameplayTagAddedRemoved*    ListenForBlockingTagAddedRemoved;                  // 0x0378(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UGzAsyncTaskGameplayTagAddedRemoved*    ListenForPartiallyBlockingTagAddedRemoved;         // 0x0380(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FGameplayTagContainer                  BlockingTags;                                      // 0x0388(0x0020)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	struct FGameplayTagContainer                  PartiallyBlockingTags;                             // 0x03A8(0x0020)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	TArray<class UGzWeaponBehaviorAttachment*>    WeaponsAttachments;                                // 0x03C8(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	float                                         CloakDamageCoef;                                   // 0x03D8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         BlendTime;                                         // 0x03DC(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         CloakChargeMaxSpeed;                               // 0x03E0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         CloakChargeMinOnMaxSpeed;                          // 0x03E4(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         MinBlendTime;                                      // 0x03E8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         ShootDebuff;                                       // 0x03EC(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         DamageDebuff;                                      // 0x03F0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         TagStateDebuff;                                    // 0x03F4(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2F9B[0x58];                                    // 0x03F8(0x0058)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTag                           TransparentStateTag;                               // 0x0450(0x0008)(Edit, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2F9C[0x8];                                     // 0x0458(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnBackpackChanged(const struct FGzInvPocketChangeData& Data);
	void OnBlockingTagsAddedRemoved(const struct FGameplayTag& Tag);
	void OnCharacterReceivedDamage(const struct FGameplayAttribute& Attribute, float NewValue, float OldValue);
	void OnInited();
	void OnLimbChanged(EGzLimbType ChangedLimbType);
	void OnPartiallyBlockingTagsAddedRemoved(const struct FGameplayTag& Tag);
	void OnRep_InitInfo();
	void OnShoot();
	void OnWeaponeEquiped(const struct FGzInvPocketId& InvPocketId, const class AGzWeaponActor* WeaponActor, bool bEquipped);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzCloakComponent">();
	}
	static class UGzCloakComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzCloakComponent>();
	}
};
static_assert(alignof(UGzCloakComponent) == 0x000010, "Wrong alignment on UGzCloakComponent");
static_assert(sizeof(UGzCloakComponent) == 0x000460, "Wrong size on UGzCloakComponent");
static_assert(offsetof(UGzCloakComponent, DisolveCurve) == 0x0000F0, "Member 'UGzCloakComponent::DisolveCurve' has a wrong offset!");
static_assert(offsetof(UGzCloakComponent, CloakCurve) == 0x0000F8, "Member 'UGzCloakComponent::CloakCurve' has a wrong offset!");
static_assert(offsetof(UGzCloakComponent, UniversalDisolveMaterialDynamic) == 0x000100, "Member 'UGzCloakComponent::UniversalDisolveMaterialDynamic' has a wrong offset!");
static_assert(offsetof(UGzCloakComponent, CloakMaterialDynamic) == 0x000108, "Member 'UGzCloakComponent::CloakMaterialDynamic' has a wrong offset!");
static_assert(offsetof(UGzCloakComponent, DisolveEffectParameterName) == 0x000110, "Member 'UGzCloakComponent::DisolveEffectParameterName' has a wrong offset!");
static_assert(offsetof(UGzCloakComponent, CloakEffectParameterName) == 0x000118, "Member 'UGzCloakComponent::CloakEffectParameterName' has a wrong offset!");
static_assert(offsetof(UGzCloakComponent, bMaterialReseted) == 0x000120, "Member 'UGzCloakComponent::bMaterialReseted' has a wrong offset!");
static_assert(offsetof(UGzCloakComponent, bActive) == 0x000121, "Member 'UGzCloakComponent::bActive' has a wrong offset!");
static_assert(offsetof(UGzCloakComponent, Gadjet) == 0x000128, "Member 'UGzCloakComponent::Gadjet' has a wrong offset!");
static_assert(offsetof(UGzCloakComponent, OnStateChanged) == 0x000130, "Member 'UGzCloakComponent::OnStateChanged' has a wrong offset!");
static_assert(offsetof(UGzCloakComponent, InitInfo) == 0x000140, "Member 'UGzCloakComponent::InitInfo' has a wrong offset!");
static_assert(offsetof(UGzCloakComponent, PatternColorParameterName) == 0x000198, "Member 'UGzCloakComponent::PatternColorParameterName' has a wrong offset!");
static_assert(offsetof(UGzCloakComponent, PatternColorStart) == 0x0001A0, "Member 'UGzCloakComponent::PatternColorStart' has a wrong offset!");
static_assert(offsetof(UGzCloakComponent, PatternColorEnd) == 0x0001C0, "Member 'UGzCloakComponent::PatternColorEnd' has a wrong offset!");
static_assert(offsetof(UGzCloakComponent, EnterAudioEvent) == 0x0001E0, "Member 'UGzCloakComponent::EnterAudioEvent' has a wrong offset!");
static_assert(offsetof(UGzCloakComponent, ExitAudioEvent) == 0x0001E8, "Member 'UGzCloakComponent::ExitAudioEvent' has a wrong offset!");
static_assert(offsetof(UGzCloakComponent, CharacterMovementComponent) == 0x0001F0, "Member 'UGzCloakComponent::CharacterMovementComponent' has a wrong offset!");
static_assert(offsetof(UGzCloakComponent, LimbCachedMaterials) == 0x0001F8, "Member 'UGzCloakComponent::LimbCachedMaterials' has a wrong offset!");
static_assert(offsetof(UGzCloakComponent, HeadCachedMaterials) == 0x000258, "Member 'UGzCloakComponent::HeadCachedMaterials' has a wrong offset!");
static_assert(offsetof(UGzCloakComponent, TorsoCachedMaterials) == 0x000278, "Member 'UGzCloakComponent::TorsoCachedMaterials' has a wrong offset!");
static_assert(offsetof(UGzCloakComponent, JetpackCachedMaterials) == 0x000298, "Member 'UGzCloakComponent::JetpackCachedMaterials' has a wrong offset!");
static_assert(offsetof(UGzCloakComponent, BackpackCachedMaterials) == 0x0002B8, "Member 'UGzCloakComponent::BackpackCachedMaterials' has a wrong offset!");
static_assert(offsetof(UGzCloakComponent, ArmorCachedMaterials) == 0x0002D8, "Member 'UGzCloakComponent::ArmorCachedMaterials' has a wrong offset!");
static_assert(offsetof(UGzCloakComponent, HexCarrierCachedMaterials) == 0x0002F8, "Member 'UGzCloakComponent::HexCarrierCachedMaterials' has a wrong offset!");
static_assert(offsetof(UGzCloakComponent, HexCachedMaterials) == 0x000318, "Member 'UGzCloakComponent::HexCachedMaterials' has a wrong offset!");
static_assert(offsetof(UGzCloakComponent, CharacterMeshCachedMaterials) == 0x000338, "Member 'UGzCloakComponent::CharacterMeshCachedMaterials' has a wrong offset!");
static_assert(offsetof(UGzCloakComponent, WeaponCachedMeshesArray) == 0x000358, "Member 'UGzCloakComponent::WeaponCachedMeshesArray' has a wrong offset!");
static_assert(offsetof(UGzCloakComponent, CachedCastomizations) == 0x000368, "Member 'UGzCloakComponent::CachedCastomizations' has a wrong offset!");
static_assert(offsetof(UGzCloakComponent, ListenForBlockingTagAddedRemoved) == 0x000378, "Member 'UGzCloakComponent::ListenForBlockingTagAddedRemoved' has a wrong offset!");
static_assert(offsetof(UGzCloakComponent, ListenForPartiallyBlockingTagAddedRemoved) == 0x000380, "Member 'UGzCloakComponent::ListenForPartiallyBlockingTagAddedRemoved' has a wrong offset!");
static_assert(offsetof(UGzCloakComponent, BlockingTags) == 0x000388, "Member 'UGzCloakComponent::BlockingTags' has a wrong offset!");
static_assert(offsetof(UGzCloakComponent, PartiallyBlockingTags) == 0x0003A8, "Member 'UGzCloakComponent::PartiallyBlockingTags' has a wrong offset!");
static_assert(offsetof(UGzCloakComponent, WeaponsAttachments) == 0x0003C8, "Member 'UGzCloakComponent::WeaponsAttachments' has a wrong offset!");
static_assert(offsetof(UGzCloakComponent, CloakDamageCoef) == 0x0003D8, "Member 'UGzCloakComponent::CloakDamageCoef' has a wrong offset!");
static_assert(offsetof(UGzCloakComponent, BlendTime) == 0x0003DC, "Member 'UGzCloakComponent::BlendTime' has a wrong offset!");
static_assert(offsetof(UGzCloakComponent, CloakChargeMaxSpeed) == 0x0003E0, "Member 'UGzCloakComponent::CloakChargeMaxSpeed' has a wrong offset!");
static_assert(offsetof(UGzCloakComponent, CloakChargeMinOnMaxSpeed) == 0x0003E4, "Member 'UGzCloakComponent::CloakChargeMinOnMaxSpeed' has a wrong offset!");
static_assert(offsetof(UGzCloakComponent, MinBlendTime) == 0x0003E8, "Member 'UGzCloakComponent::MinBlendTime' has a wrong offset!");
static_assert(offsetof(UGzCloakComponent, ShootDebuff) == 0x0003EC, "Member 'UGzCloakComponent::ShootDebuff' has a wrong offset!");
static_assert(offsetof(UGzCloakComponent, DamageDebuff) == 0x0003F0, "Member 'UGzCloakComponent::DamageDebuff' has a wrong offset!");
static_assert(offsetof(UGzCloakComponent, TagStateDebuff) == 0x0003F4, "Member 'UGzCloakComponent::TagStateDebuff' has a wrong offset!");
static_assert(offsetof(UGzCloakComponent, TransparentStateTag) == 0x000450, "Member 'UGzCloakComponent::TransparentStateTag' has a wrong offset!");

// Class G01.GzBaseNavDataDelegate
// 0x0008 (0x0030 - 0x0028)
class UGzBaseNavDataDelegate : public UObject
{
public:
	class AGzRecastNavMesh*                       ActiveNavMesh;                                     // 0x0028(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzBaseNavDataDelegate">();
	}
	static class UGzBaseNavDataDelegate* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzBaseNavDataDelegate>();
	}
};
static_assert(alignof(UGzBaseNavDataDelegate) == 0x000008, "Wrong alignment on UGzBaseNavDataDelegate");
static_assert(sizeof(UGzBaseNavDataDelegate) == 0x000030, "Wrong size on UGzBaseNavDataDelegate");
static_assert(offsetof(UGzBaseNavDataDelegate, ActiveNavMesh) == 0x000028, "Member 'UGzBaseNavDataDelegate::ActiveNavMesh' has a wrong offset!");

// Class G01.GzHideoutStatics
// 0x0000 (0x0028 - 0x0028)
class UGzHideoutStatics final : public UBlueprintFunctionLibrary
{
public:
	static bool CurrentMapIsHideout(const class UObject* WorldContext);
	static class UGzClientLoadoutService* GetLoadoutServiceChecked(const class UObject* WorldContext);
	static class AGzSceneManager* GetSceneManager(const class UObject* WorldContext);
	static class AGzSceneManager* GetSceneManagerChecked(const class UObject* WorldContext);
	static class UGzScenePuppeteer* GetScenePuppeteerChecked(const class UObject* WorldContext);
	static void ResetCharacterRotation(const class UObject* WorldContext);
	static void RotateCharacter(const class UObject* WorldContext, double Pitch, double Yaw, double Roll, double Delta);
	static void RotateSpawnedWeapon(const class UObject* WorldContext, double Pitch, double Yaw, double Roll, double Delta);
	static void ToggleCohtmlInput(bool bEnable, const class UObject* WorldContext);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzHideoutStatics">();
	}
	static class UGzHideoutStatics* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzHideoutStatics>();
	}
};
static_assert(alignof(UGzHideoutStatics) == 0x000008, "Wrong alignment on UGzHideoutStatics");
static_assert(sizeof(UGzHideoutStatics) == 0x000028, "Wrong size on UGzHideoutStatics");

// Class G01.GzChallengesModel
// 0x0060 (0x00D0 - 0x0070)
class UGzChallengesModel final : public UGzBackendModel
{
public:
	struct FGzCohtmlChallengeList                 DailyChallenges;                                   // 0x0070(0x0020)(NativeAccessSpecifierPrivate)
	struct FGzCohtmlChallengeList                 WeeklyChallenges;                                  // 0x0090(0x0020)(NativeAccessSpecifierPrivate)
	struct FGzCohtmlChallengeList                 MonthlyChallenges;                                 // 0x00B0(0x0020)(NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzChallengesModel">();
	}
	static class UGzChallengesModel* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzChallengesModel>();
	}
};
static_assert(alignof(UGzChallengesModel) == 0x000008, "Wrong alignment on UGzChallengesModel");
static_assert(sizeof(UGzChallengesModel) == 0x0000D0, "Wrong size on UGzChallengesModel");
static_assert(offsetof(UGzChallengesModel, DailyChallenges) == 0x000070, "Member 'UGzChallengesModel::DailyChallenges' has a wrong offset!");
static_assert(offsetof(UGzChallengesModel, WeeklyChallenges) == 0x000090, "Member 'UGzChallengesModel::WeeklyChallenges' has a wrong offset!");
static_assert(offsetof(UGzChallengesModel, MonthlyChallenges) == 0x0000B0, "Member 'UGzChallengesModel::MonthlyChallenges' has a wrong offset!");

// Class G01.GzPostmatchState
// 0x0000 (0x0060 - 0x0060)
class UGzPostmatchState final : public UGzFlowState
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzPostmatchState">();
	}
	static class UGzPostmatchState* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzPostmatchState>();
	}
};
static_assert(alignof(UGzPostmatchState) == 0x000008, "Wrong alignment on UGzPostmatchState");
static_assert(sizeof(UGzPostmatchState) == 0x000060, "Wrong size on UGzPostmatchState");

// Class G01.GzBaseTerminal
// 0x0058 (0x02F8 - 0x02A0)
class AGzBaseTerminal : public AActor
{
public:
	uint8                                         Pad_2FA0[0x10];                                    // 0x02A0(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	FMulticastInlineDelegateProperty_             OnTerminalStateChanged;                            // 0x02B0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	class UGzInteractableComponent*               InteractableComponent;                             // 0x02C0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UGzZoneTrackingComponent*               ZoneTracking;                                      // 0x02C8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bAllowActivityStateChange;                         // 0x02D0(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bNotifyDistanceToPlayer;                           // 0x02D1(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2FA1[0x2];                                     // 0x02D2(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         DistancePollingFrequency;                          // 0x02D4(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         InOverloadZonePollFrequency;                       // 0x02D8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2FA2[0x4];                                     // 0x02DC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class AGzBattleRoyaleZone*                    OwnerBattleRoyaleZone;                             // 0x02E0(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bActive;                                           // 0x02E8(0x0001)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2FA3[0xF];                                     // 0x02E9(0x000F)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnRep_Active();
	void OnZoneSideSwitched(bool bInOverloadZone);
	void ReceiveActiveStateChanged(bool bNewActive);
	void ReceiveZoneOverloadSwitched(bool bInOverloadZone);
	void SetIsActive(bool bNewActive);
	void UpdateMarkerActiveState();

	bool IsActive() const;
	bool IsInsideOverloadZone() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzBaseTerminal">();
	}
	static class AGzBaseTerminal* GetDefaultObj()
	{
		return GetDefaultObjImpl<AGzBaseTerminal>();
	}
};
static_assert(alignof(AGzBaseTerminal) == 0x000008, "Wrong alignment on AGzBaseTerminal");
static_assert(sizeof(AGzBaseTerminal) == 0x0002F8, "Wrong size on AGzBaseTerminal");
static_assert(offsetof(AGzBaseTerminal, OnTerminalStateChanged) == 0x0002B0, "Member 'AGzBaseTerminal::OnTerminalStateChanged' has a wrong offset!");
static_assert(offsetof(AGzBaseTerminal, InteractableComponent) == 0x0002C0, "Member 'AGzBaseTerminal::InteractableComponent' has a wrong offset!");
static_assert(offsetof(AGzBaseTerminal, ZoneTracking) == 0x0002C8, "Member 'AGzBaseTerminal::ZoneTracking' has a wrong offset!");
static_assert(offsetof(AGzBaseTerminal, bAllowActivityStateChange) == 0x0002D0, "Member 'AGzBaseTerminal::bAllowActivityStateChange' has a wrong offset!");
static_assert(offsetof(AGzBaseTerminal, bNotifyDistanceToPlayer) == 0x0002D1, "Member 'AGzBaseTerminal::bNotifyDistanceToPlayer' has a wrong offset!");
static_assert(offsetof(AGzBaseTerminal, DistancePollingFrequency) == 0x0002D4, "Member 'AGzBaseTerminal::DistancePollingFrequency' has a wrong offset!");
static_assert(offsetof(AGzBaseTerminal, InOverloadZonePollFrequency) == 0x0002D8, "Member 'AGzBaseTerminal::InOverloadZonePollFrequency' has a wrong offset!");
static_assert(offsetof(AGzBaseTerminal, OwnerBattleRoyaleZone) == 0x0002E0, "Member 'AGzBaseTerminal::OwnerBattleRoyaleZone' has a wrong offset!");
static_assert(offsetof(AGzBaseTerminal, bActive) == 0x0002E8, "Member 'AGzBaseTerminal::bActive' has a wrong offset!");

// Class G01.GzTagSwitcherHorizontal
// 0x0058 (0x01F8 - 0x01A0)
class UGzTagSwitcherHorizontal final : public UHorizontalBox
{
public:
	struct FGzTagVisibilitySettings               TagSettings;                                       // 0x01A0(0x0050)(Edit, Protected, NativeAccessSpecifierProtected)
	class UUserWidget*                            ParentWidget;                                      // 0x01F0(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void InitializedTag(class UUserWidget* InParentWidget, const bool bResetTagSettings, const struct FGzTagVisibilitySettings& InTagSettings);
	void SetTagVisibility(EGzTargetUITagsState TagsState);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzTagSwitcherHorizontal">();
	}
	static class UGzTagSwitcherHorizontal* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzTagSwitcherHorizontal>();
	}
};
static_assert(alignof(UGzTagSwitcherHorizontal) == 0x000008, "Wrong alignment on UGzTagSwitcherHorizontal");
static_assert(sizeof(UGzTagSwitcherHorizontal) == 0x0001F8, "Wrong size on UGzTagSwitcherHorizontal");
static_assert(offsetof(UGzTagSwitcherHorizontal, TagSettings) == 0x0001A0, "Member 'UGzTagSwitcherHorizontal::TagSettings' has a wrong offset!");
static_assert(offsetof(UGzTagSwitcherHorizontal, ParentWidget) == 0x0001F0, "Member 'UGzTagSwitcherHorizontal::ParentWidget' has a wrong offset!");

// Class G01.GzInventoryItemUsedConceptComponent
// 0x0050 (0x00F0 - 0x00A0)
class UGzInventoryItemUsedConceptComponent final : public UGzServiceComponent
{
public:
	uint8                                         Pad_2FA5[0x50];                                    // 0x00A0(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzInventoryItemUsedConceptComponent">();
	}
	static class UGzInventoryItemUsedConceptComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzInventoryItemUsedConceptComponent>();
	}
};
static_assert(alignof(UGzInventoryItemUsedConceptComponent) == 0x000008, "Wrong alignment on UGzInventoryItemUsedConceptComponent");
static_assert(sizeof(UGzInventoryItemUsedConceptComponent) == 0x0000F0, "Wrong size on UGzInventoryItemUsedConceptComponent");

// Class G01.GzBattlePassContentManagementComponent
// 0x0028 (0x00C8 - 0x00A0)
class UGzBattlePassContentManagementComponent final : public UGzServiceComponent
{
public:
	uint8                                         Pad_2FA6[0x28];                                    // 0x00A0(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzBattlePassContentManagementComponent">();
	}
	static class UGzBattlePassContentManagementComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzBattlePassContentManagementComponent>();
	}
};
static_assert(alignof(UGzBattlePassContentManagementComponent) == 0x000008, "Wrong alignment on UGzBattlePassContentManagementComponent");
static_assert(sizeof(UGzBattlePassContentManagementComponent) == 0x0000C8, "Wrong size on UGzBattlePassContentManagementComponent");

// Class G01.GzCohtmlWidget
// 0x0000 (0x0320 - 0x0320)
class UGzCohtmlWidget final : public UCohtmlWidget
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzCohtmlWidget">();
	}
	static class UGzCohtmlWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzCohtmlWidget>();
	}
};
static_assert(alignof(UGzCohtmlWidget) == 0x000008, "Wrong alignment on UGzCohtmlWidget");
static_assert(sizeof(UGzCohtmlWidget) == 0x000320, "Wrong size on UGzCohtmlWidget");

// Class G01.GzBattlePassDataV2
// 0x0068 (0x0098 - 0x0030)
class UGzBattlePassDataV2 final : public UPrimaryDataAsset
{
public:
	uint8                                         Pad_2FA7[0x8];                                     // 0x0030(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FDateTime                              StartDate;                                         // 0x0038(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FDateTime                              EndDate;                                           // 0x0040(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMap<struct FGuid, struct FGzBattlePassPageDataV2> Pages;                                             // 0x0048(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzBattlePassDataV2">();
	}
	static class UGzBattlePassDataV2* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzBattlePassDataV2>();
	}
};
static_assert(alignof(UGzBattlePassDataV2) == 0x000008, "Wrong alignment on UGzBattlePassDataV2");
static_assert(sizeof(UGzBattlePassDataV2) == 0x000098, "Wrong size on UGzBattlePassDataV2");
static_assert(offsetof(UGzBattlePassDataV2, StartDate) == 0x000038, "Member 'UGzBattlePassDataV2::StartDate' has a wrong offset!");
static_assert(offsetof(UGzBattlePassDataV2, EndDate) == 0x000040, "Member 'UGzBattlePassDataV2::EndDate' has a wrong offset!");
static_assert(offsetof(UGzBattlePassDataV2, Pages) == 0x000048, "Member 'UGzBattlePassDataV2::Pages' has a wrong offset!");

// Class G01.GzIrisGroupOwner
// 0x0000 (0x0028 - 0x0028)
class IGzIrisGroupOwner final : public IInterface
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzIrisGroupOwner">();
	}
	static class IGzIrisGroupOwner* GetDefaultObj()
	{
		return GetDefaultObjImpl<IGzIrisGroupOwner>();
	}
};
static_assert(alignof(IGzIrisGroupOwner) == 0x000008, "Wrong alignment on IGzIrisGroupOwner");
static_assert(sizeof(IGzIrisGroupOwner) == 0x000028, "Wrong size on IGzIrisGroupOwner");

// Class G01.GzBattlePassModelV2
// 0x0060 (0x00D0 - 0x0070)
class UGzBattlePassModelV2 final : public UGzBackendModel
{
public:
	TArray<struct FGzCohtmlBattlePassPageV2>      Pages;                                             // 0x0070(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	TArray<struct FGzCohtmlBattlePassThemeSectionV2> ThemeSections;                                     // 0x0080(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	TArray<struct FGzCohtmlBattlePassNodeConnectionV2> PagesConnections;                                  // 0x0090(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	TArray<struct FGzCohtmlBattlePassNodeConnectionV2> ThemeSectionsConnections;                          // 0x00A0(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	struct FGzCohtmlBattlePassLevelProgressionV2  Progression;                                       // 0x00B0(0x000C)(NoDestructor, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2FA8[0x4];                                     // 0x00BC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 ExpirationUtcTimeDate;                             // 0x00C0(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzBattlePassModelV2">();
	}
	static class UGzBattlePassModelV2* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzBattlePassModelV2>();
	}
};
static_assert(alignof(UGzBattlePassModelV2) == 0x000008, "Wrong alignment on UGzBattlePassModelV2");
static_assert(sizeof(UGzBattlePassModelV2) == 0x0000D0, "Wrong size on UGzBattlePassModelV2");
static_assert(offsetof(UGzBattlePassModelV2, Pages) == 0x000070, "Member 'UGzBattlePassModelV2::Pages' has a wrong offset!");
static_assert(offsetof(UGzBattlePassModelV2, ThemeSections) == 0x000080, "Member 'UGzBattlePassModelV2::ThemeSections' has a wrong offset!");
static_assert(offsetof(UGzBattlePassModelV2, PagesConnections) == 0x000090, "Member 'UGzBattlePassModelV2::PagesConnections' has a wrong offset!");
static_assert(offsetof(UGzBattlePassModelV2, ThemeSectionsConnections) == 0x0000A0, "Member 'UGzBattlePassModelV2::ThemeSectionsConnections' has a wrong offset!");
static_assert(offsetof(UGzBattlePassModelV2, Progression) == 0x0000B0, "Member 'UGzBattlePassModelV2::Progression' has a wrong offset!");
static_assert(offsetof(UGzBattlePassModelV2, ExpirationUtcTimeDate) == 0x0000C0, "Member 'UGzBattlePassModelV2::ExpirationUtcTimeDate' has a wrong offset!");

// Class G01.GzPartyHelper
// 0x0000 (0x0028 - 0x0028)
class UGzPartyHelper final : public UBlueprintFunctionLibrary
{
public:
	static bool IsInParty(const class UObject* WorldContextObject);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzPartyHelper">();
	}
	static class UGzPartyHelper* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzPartyHelper>();
	}
};
static_assert(alignof(UGzPartyHelper) == 0x000008, "Wrong alignment on UGzPartyHelper");
static_assert(sizeof(UGzPartyHelper) == 0x000028, "Wrong size on UGzPartyHelper");

// Class G01.GzCharacterMovementComponent
// 0x0B10 (0x1BB0 - 0x10A0)
class UGzCharacterMovementComponent : public UCharacterMovementComponent
{
public:
	uint8                                         Pad_2FAA[0x88];                                    // 0x10A0(0x0088)(Fixing Size After Last Property [ Dumper-7 ])
	class UGzDashParamsData*                      CurrentDashParamsData;                             // 0x1128(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2FAB[0xFC];                                    // 0x1130(0x00FC)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGzHoverParams                         CurrentHoverParams;                                // 0x122C(0x001C)(NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_2FAC[0x5];                                     // 0x1248(0x0005)(Fixing Size After Last Property [ Dumper-7 ])
	EMovementMode                                 MovementModeToSwitchIfStuckInFlying;               // 0x124D(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2FAD[0x4A2];                                   // 0x124E(0x04A2)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                GrapplingLaunchPosition;                           // 0x16F0(0x0018)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                GrappleHookTargetLocation;                         // 0x1708(0x0018)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SecondsPastSinceHookMovementStart;                 // 0x1720(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2FAE[0x4];                                     // 0x1724(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UGzGrappleHookData*                     CurrentGrappleHookData;                            // 0x1728(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2FAF[0x4];                                     // 0x1730(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bWingsuitBoostActive;                              // 0x1734(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2FB0[0x7];                                     // 0x1735(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         SprintMinAngle;                                    // 0x173C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ALocomotionCharacter*                   LocomotionCharacter;                               // 0x1740(0x0008)(ZeroConstructor, Transient, DuplicateTransient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2FB1[0x138];                                   // 0x1748(0x0138)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         CachedSlidingAngle;                                // 0x1880(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2FB2[0x4];                                     // 0x1884(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class AGzCharacter*                           GzCharacter;                                       // 0x1888(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         WingsuitPitch;                                     // 0x1890(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2FB3[0x4];                                     // 0x1894(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         WingsuitRoll;                                      // 0x1898(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         WingsuitYaw;                                       // 0x189C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         WingsuitMomentum;                                  // 0x18A0(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         WingsuitMomentumTarget;                            // 0x18A4(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         WingsuitLandingPitch;                              // 0x18A8(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2FB4[0x4];                                     // 0x18AC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bWingsuitLandApproaching;                          // 0x18B0(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2FB5[0x7];                                     // 0x18B1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UGzZiplineMovementSettings*             ZiplineSettings;                                   // 0x18B8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FLocomotionMantleTraceSettings         FallingTraceSettings;                              // 0x18C0(0x0020)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPrivate)
	struct FLocomotionMantleTraceSettings         GroundedTraceSettings;                             // 0x18E0(0x0020)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPrivate)
	ETraceTypeQuery                               MantleTraceChannel;                                // 0x1900(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2FB6[0x3];                                     // 0x1901(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGzAntiStuckParams                     AntiStuckParams;                                   // 0x1904(0x0024)(Edit, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2FB7[0x8];                                     // 0x1928(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                PrevAcceleration;                                  // 0x1930(0x0018)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FDataTableRowHandle                    MovementModelTable;                                // 0x1948(0x0010)(Edit, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2FB8[0xC8];                                    // 0x1958(0x00C8)(Fixing Size After Last Property [ Dumper-7 ])
	ELocomotionMovementAction                     MovementAction;                                    // 0x1A20(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2FB9[0x7];                                     // 0x1A21(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UCurveVector*                           SmashLandingJumpHeightCurve;                       // 0x1A28(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UCurveVector*                           PullForceOffsetCurve;                              // 0x1A30(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UCurveFloat*                            PullForceTimeMapCurve;                             // 0x1A38(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         SlideHalfHeight;                                   // 0x1A40(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         LeglessHalfHeight;                                 // 0x1A44(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         LeglessPoseMeshOffset;                             // 0x1A48(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         AirFriction;                                       // 0x1A4C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2FBA[0x18];                                    // 0x1A50(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bHasReplicatedAcceleration;                        // 0x1A68(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2FBB[0x147];                                   // 0x1A69(0x0147)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void CancelJetpack();
	const struct FLyraCharacterGroundInfo GetGroundInfo();
	void ResetRotationRateToDefault();
	void SetCurrentDashParams(const class UGzDashParamsData* NewDashParamsData);
	void SetCurrentHoverParams(const struct FGzHoverParams& HoverParams);
	void StartDashing(bool bClientSimulation, const struct FVector& Direction);
	void StartHover(bool bClientSimulation);
	void StopDashing(bool bClientSimulation);
	void StopHover(bool bClientSimulation);

	struct FVector GetDashingDirection() const;
	float GetJumpZVelocity(float Height) const;
	float GetMaxJumpTime(float Height, float ZVelocity) const;
	bool HasAppliedRootMotion(EGzRootMotionSourceType RMSType) const;
	bool HasQueuedRootMotion(EGzRootMotionSourceType RMSType) const;
	bool IsDashing() const;
	bool IsHovering() const;
	bool IsInWingsuitLandingRoll() const;
	bool IsWingsuit() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzCharacterMovementComponent">();
	}
	static class UGzCharacterMovementComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzCharacterMovementComponent>();
	}
};
static_assert(alignof(UGzCharacterMovementComponent) == 0x000010, "Wrong alignment on UGzCharacterMovementComponent");
static_assert(sizeof(UGzCharacterMovementComponent) == 0x001BB0, "Wrong size on UGzCharacterMovementComponent");
static_assert(offsetof(UGzCharacterMovementComponent, CurrentDashParamsData) == 0x001128, "Member 'UGzCharacterMovementComponent::CurrentDashParamsData' has a wrong offset!");
static_assert(offsetof(UGzCharacterMovementComponent, CurrentHoverParams) == 0x00122C, "Member 'UGzCharacterMovementComponent::CurrentHoverParams' has a wrong offset!");
static_assert(offsetof(UGzCharacterMovementComponent, MovementModeToSwitchIfStuckInFlying) == 0x00124D, "Member 'UGzCharacterMovementComponent::MovementModeToSwitchIfStuckInFlying' has a wrong offset!");
static_assert(offsetof(UGzCharacterMovementComponent, GrapplingLaunchPosition) == 0x0016F0, "Member 'UGzCharacterMovementComponent::GrapplingLaunchPosition' has a wrong offset!");
static_assert(offsetof(UGzCharacterMovementComponent, GrappleHookTargetLocation) == 0x001708, "Member 'UGzCharacterMovementComponent::GrappleHookTargetLocation' has a wrong offset!");
static_assert(offsetof(UGzCharacterMovementComponent, SecondsPastSinceHookMovementStart) == 0x001720, "Member 'UGzCharacterMovementComponent::SecondsPastSinceHookMovementStart' has a wrong offset!");
static_assert(offsetof(UGzCharacterMovementComponent, CurrentGrappleHookData) == 0x001728, "Member 'UGzCharacterMovementComponent::CurrentGrappleHookData' has a wrong offset!");
static_assert(offsetof(UGzCharacterMovementComponent, bWingsuitBoostActive) == 0x001734, "Member 'UGzCharacterMovementComponent::bWingsuitBoostActive' has a wrong offset!");
static_assert(offsetof(UGzCharacterMovementComponent, SprintMinAngle) == 0x00173C, "Member 'UGzCharacterMovementComponent::SprintMinAngle' has a wrong offset!");
static_assert(offsetof(UGzCharacterMovementComponent, LocomotionCharacter) == 0x001740, "Member 'UGzCharacterMovementComponent::LocomotionCharacter' has a wrong offset!");
static_assert(offsetof(UGzCharacterMovementComponent, CachedSlidingAngle) == 0x001880, "Member 'UGzCharacterMovementComponent::CachedSlidingAngle' has a wrong offset!");
static_assert(offsetof(UGzCharacterMovementComponent, GzCharacter) == 0x001888, "Member 'UGzCharacterMovementComponent::GzCharacter' has a wrong offset!");
static_assert(offsetof(UGzCharacterMovementComponent, WingsuitPitch) == 0x001890, "Member 'UGzCharacterMovementComponent::WingsuitPitch' has a wrong offset!");
static_assert(offsetof(UGzCharacterMovementComponent, WingsuitRoll) == 0x001898, "Member 'UGzCharacterMovementComponent::WingsuitRoll' has a wrong offset!");
static_assert(offsetof(UGzCharacterMovementComponent, WingsuitYaw) == 0x00189C, "Member 'UGzCharacterMovementComponent::WingsuitYaw' has a wrong offset!");
static_assert(offsetof(UGzCharacterMovementComponent, WingsuitMomentum) == 0x0018A0, "Member 'UGzCharacterMovementComponent::WingsuitMomentum' has a wrong offset!");
static_assert(offsetof(UGzCharacterMovementComponent, WingsuitMomentumTarget) == 0x0018A4, "Member 'UGzCharacterMovementComponent::WingsuitMomentumTarget' has a wrong offset!");
static_assert(offsetof(UGzCharacterMovementComponent, WingsuitLandingPitch) == 0x0018A8, "Member 'UGzCharacterMovementComponent::WingsuitLandingPitch' has a wrong offset!");
static_assert(offsetof(UGzCharacterMovementComponent, bWingsuitLandApproaching) == 0x0018B0, "Member 'UGzCharacterMovementComponent::bWingsuitLandApproaching' has a wrong offset!");
static_assert(offsetof(UGzCharacterMovementComponent, ZiplineSettings) == 0x0018B8, "Member 'UGzCharacterMovementComponent::ZiplineSettings' has a wrong offset!");
static_assert(offsetof(UGzCharacterMovementComponent, FallingTraceSettings) == 0x0018C0, "Member 'UGzCharacterMovementComponent::FallingTraceSettings' has a wrong offset!");
static_assert(offsetof(UGzCharacterMovementComponent, GroundedTraceSettings) == 0x0018E0, "Member 'UGzCharacterMovementComponent::GroundedTraceSettings' has a wrong offset!");
static_assert(offsetof(UGzCharacterMovementComponent, MantleTraceChannel) == 0x001900, "Member 'UGzCharacterMovementComponent::MantleTraceChannel' has a wrong offset!");
static_assert(offsetof(UGzCharacterMovementComponent, AntiStuckParams) == 0x001904, "Member 'UGzCharacterMovementComponent::AntiStuckParams' has a wrong offset!");
static_assert(offsetof(UGzCharacterMovementComponent, PrevAcceleration) == 0x001930, "Member 'UGzCharacterMovementComponent::PrevAcceleration' has a wrong offset!");
static_assert(offsetof(UGzCharacterMovementComponent, MovementModelTable) == 0x001948, "Member 'UGzCharacterMovementComponent::MovementModelTable' has a wrong offset!");
static_assert(offsetof(UGzCharacterMovementComponent, MovementAction) == 0x001A20, "Member 'UGzCharacterMovementComponent::MovementAction' has a wrong offset!");
static_assert(offsetof(UGzCharacterMovementComponent, SmashLandingJumpHeightCurve) == 0x001A28, "Member 'UGzCharacterMovementComponent::SmashLandingJumpHeightCurve' has a wrong offset!");
static_assert(offsetof(UGzCharacterMovementComponent, PullForceOffsetCurve) == 0x001A30, "Member 'UGzCharacterMovementComponent::PullForceOffsetCurve' has a wrong offset!");
static_assert(offsetof(UGzCharacterMovementComponent, PullForceTimeMapCurve) == 0x001A38, "Member 'UGzCharacterMovementComponent::PullForceTimeMapCurve' has a wrong offset!");
static_assert(offsetof(UGzCharacterMovementComponent, SlideHalfHeight) == 0x001A40, "Member 'UGzCharacterMovementComponent::SlideHalfHeight' has a wrong offset!");
static_assert(offsetof(UGzCharacterMovementComponent, LeglessHalfHeight) == 0x001A44, "Member 'UGzCharacterMovementComponent::LeglessHalfHeight' has a wrong offset!");
static_assert(offsetof(UGzCharacterMovementComponent, LeglessPoseMeshOffset) == 0x001A48, "Member 'UGzCharacterMovementComponent::LeglessPoseMeshOffset' has a wrong offset!");
static_assert(offsetof(UGzCharacterMovementComponent, AirFriction) == 0x001A4C, "Member 'UGzCharacterMovementComponent::AirFriction' has a wrong offset!");
static_assert(offsetof(UGzCharacterMovementComponent, bHasReplicatedAcceleration) == 0x001A68, "Member 'UGzCharacterMovementComponent::bHasReplicatedAcceleration' has a wrong offset!");

// Class G01.GzClientBattlePassServiceV2
// 0x00D0 (0x0170 - 0x00A0)
class UGzClientBattlePassServiceV2 final : public UGzClientPFObject
{
public:
	class FString                                 BattlePassId;                                      // 0x00A0(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FDateTime                              StartDate;                                         // 0x00B0(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FDateTime                              EndDate;                                           // 0x00B8(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2FBD[0x8];                                     // 0x00C0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGzMetaBattlePassLevelProgressionV2    Progression;                                       // 0x00C8(0x000C)(NoDestructor, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2FBE[0x4];                                     // 0x00D4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGzMetaBattlePassPagesCollectionV2     Pages;                                             // 0x00D8(0x0050)(NativeAccessSpecifierPrivate)
	uint8                                         Pad_2FBF[0x48];                                    // 0x0128(0x0048)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzClientBattlePassServiceV2">();
	}
	static class UGzClientBattlePassServiceV2* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzClientBattlePassServiceV2>();
	}
};
static_assert(alignof(UGzClientBattlePassServiceV2) == 0x000008, "Wrong alignment on UGzClientBattlePassServiceV2");
static_assert(sizeof(UGzClientBattlePassServiceV2) == 0x000170, "Wrong size on UGzClientBattlePassServiceV2");
static_assert(offsetof(UGzClientBattlePassServiceV2, BattlePassId) == 0x0000A0, "Member 'UGzClientBattlePassServiceV2::BattlePassId' has a wrong offset!");
static_assert(offsetof(UGzClientBattlePassServiceV2, StartDate) == 0x0000B0, "Member 'UGzClientBattlePassServiceV2::StartDate' has a wrong offset!");
static_assert(offsetof(UGzClientBattlePassServiceV2, EndDate) == 0x0000B8, "Member 'UGzClientBattlePassServiceV2::EndDate' has a wrong offset!");
static_assert(offsetof(UGzClientBattlePassServiceV2, Progression) == 0x0000C8, "Member 'UGzClientBattlePassServiceV2::Progression' has a wrong offset!");
static_assert(offsetof(UGzClientBattlePassServiceV2, Pages) == 0x0000D8, "Member 'UGzClientBattlePassServiceV2::Pages' has a wrong offset!");

// Class G01.GzTraversalAnimMetaData
// 0x0010 (0x0038 - 0x0028)
class UGzTraversalAnimMetaData : public UGzAnimMetaData
{
public:
	float                                         Distance;                                          // 0x0028(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Height;                                            // 0x002C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EGzTraversalFootPhase                         FootPhase;                                         // 0x0030(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EGzTraversalMovementState                     StartState;                                        // 0x0031(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EGzTraversalType                              TraversalType;                                     // 0x0032(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2FC0[0x5];                                     // 0x0033(0x0005)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzTraversalAnimMetaData">();
	}
	static class UGzTraversalAnimMetaData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzTraversalAnimMetaData>();
	}
};
static_assert(alignof(UGzTraversalAnimMetaData) == 0x000008, "Wrong alignment on UGzTraversalAnimMetaData");
static_assert(sizeof(UGzTraversalAnimMetaData) == 0x000038, "Wrong size on UGzTraversalAnimMetaData");
static_assert(offsetof(UGzTraversalAnimMetaData, Distance) == 0x000028, "Member 'UGzTraversalAnimMetaData::Distance' has a wrong offset!");
static_assert(offsetof(UGzTraversalAnimMetaData, Height) == 0x00002C, "Member 'UGzTraversalAnimMetaData::Height' has a wrong offset!");
static_assert(offsetof(UGzTraversalAnimMetaData, FootPhase) == 0x000030, "Member 'UGzTraversalAnimMetaData::FootPhase' has a wrong offset!");
static_assert(offsetof(UGzTraversalAnimMetaData, StartState) == 0x000031, "Member 'UGzTraversalAnimMetaData::StartState' has a wrong offset!");
static_assert(offsetof(UGzTraversalAnimMetaData, TraversalType) == 0x000032, "Member 'UGzTraversalAnimMetaData::TraversalType' has a wrong offset!");

// Class G01.GzBattlePassSettings
// 0x0070 (0x00A8 - 0x0038)
class UGzBattlePassSettings final : public UDeveloperSettings
{
public:
	class FText                                   PageLockTemplate;                                  // 0x0038(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, Config, DisableEditOnInstance, NativeAccessSpecifierPublic)
	class FText                                   TierLockTemplate;                                  // 0x0048(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, Config, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TMap<EGzCohtmlBattlePassPageLockReasonV2, struct FGzBattlePassPageLockTemplate> LockTemplates;                                     // 0x0058(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, Config, DisableEditOnInstance, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzBattlePassSettings">();
	}
	static class UGzBattlePassSettings* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzBattlePassSettings>();
	}
};
static_assert(alignof(UGzBattlePassSettings) == 0x000008, "Wrong alignment on UGzBattlePassSettings");
static_assert(sizeof(UGzBattlePassSettings) == 0x0000A8, "Wrong size on UGzBattlePassSettings");
static_assert(offsetof(UGzBattlePassSettings, PageLockTemplate) == 0x000038, "Member 'UGzBattlePassSettings::PageLockTemplate' has a wrong offset!");
static_assert(offsetof(UGzBattlePassSettings, TierLockTemplate) == 0x000048, "Member 'UGzBattlePassSettings::TierLockTemplate' has a wrong offset!");
static_assert(offsetof(UGzBattlePassSettings, LockTemplates) == 0x000058, "Member 'UGzBattlePassSettings::LockTemplates' has a wrong offset!");

// Class G01.GzTrainingPresetsData
// 0x0010 (0x0040 - 0x0030)
class UGzTrainingPresetsData final : public UDataAsset
{
public:
	TArray<struct FGzLoadoutPresetData>           PresetsData;                                       // 0x0030(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzTrainingPresetsData">();
	}
	static class UGzTrainingPresetsData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzTrainingPresetsData>();
	}
};
static_assert(alignof(UGzTrainingPresetsData) == 0x000008, "Wrong alignment on UGzTrainingPresetsData");
static_assert(sizeof(UGzTrainingPresetsData) == 0x000040, "Wrong size on UGzTrainingPresetsData");
static_assert(offsetof(UGzTrainingPresetsData, PresetsData) == 0x000030, "Member 'UGzTrainingPresetsData::PresetsData' has a wrong offset!");

// Class G01.GzTradeRateValidationComponent
// 0x0048 (0x00E8 - 0x00A0)
class UGzTradeRateValidationComponent : public UGzServiceComponent
{
public:
	uint8                                         Pad_2FC1[0x48];                                    // 0x00A0(0x0048)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzTradeRateValidationComponent">();
	}
	static class UGzTradeRateValidationComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzTradeRateValidationComponent>();
	}
};
static_assert(alignof(UGzTradeRateValidationComponent) == 0x000008, "Wrong alignment on UGzTradeRateValidationComponent");
static_assert(sizeof(UGzTradeRateValidationComponent) == 0x0000E8, "Wrong size on UGzTradeRateValidationComponent");

// Class G01.GzCombatComponent
// 0x0610 (0x06B8 - 0x00A8)
class UGzCombatComponent final : public UActorComponent
{
public:
	FMulticastInlineDelegateProperty_             WeaponShootEvent;                                  // 0x00A8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             AimingUpdateDelegate;                              // 0x00B8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             ReloadStartedDelegate;                             // 0x00C8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             ReloadEndedDelegate;                               // 0x00D8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnWeaponEquipedDelegate;                           // 0x00E8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnWeaponAmmoSynced;                                // 0x00F8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	float                                         PostShotPerformCooldownTime;                       // 0x0108(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2FC2[0x4];                                     // 0x010C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FName>                           MeshWeaponSocketNames;                             // 0x0110(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	float                                         MinAimTraceDistance;                               // 0x0120(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         AimFwdOffset;                                      // 0x0124(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         HitDiffTolerance;                                  // 0x0128(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MaxAimRaycastRange;                                // 0x012C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2FC3[0x4];                                     // 0x0130(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MaxDistanceToObstacle;                             // 0x0134(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MinDistanceToObstacle;                             // 0x0138(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2FC4[0x4];                                     // 0x013C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                ObstacleAimOffset;                                 // 0x0140(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TMap<EGzWeaponType, float>                    EquipMontageRateByWeaponType;                      // 0x0158(0x0050)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	TMap<struct FGzInvPocketId, int32>            ClientPredictedAmmoOnSpawn;                        // 0x01A8(0x0050)(Protected, NativeAccessSpecifierProtected)
	int32                                         WeaponInitialSeed;                                 // 0x01F8(0x0004)(Net, ZeroConstructor, Transient, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2FC5[0x8];                                     // 0x01FC(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bIsAiming;                                         // 0x0204(0x0001)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bShouldUseBarrelShooting;                          // 0x0205(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2FC6[0x2];                                     // 0x0206(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FGzWeaponSocketState>           RegisteredSockets;                                 // 0x0208(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	struct FGzInvPocketId                         PreviousEquippedPocket;                            // 0x0218(0x0008)(Net, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FGzInvPocketId                         EquippedPocketId;                                  // 0x0220(0x0008)(Net, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2FC7[0x8];                                     // 0x0228(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<struct FGzInvPocketId, class AGzWeaponActor*> Weapons;                                           // 0x0230(0x0050)(Transient, NativeAccessSpecifierPrivate)
	TMap<struct FGzInvPocketId, class AGzWeaponActor*> NotInitializedWeapons;                             // 0x0280(0x0050)(Transient, NativeAccessSpecifierPrivate)
	class USkeletalMeshComponent*                 OwnerMesh;                                         // 0x02D0(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UGzInvComponent*                        CachedInventoryComponent;                          // 0x02D8(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UGzAbilitySystemComponent*              CachedAbilitySystemComponent;                      // 0x02E0(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UATPCCameraComponent*                   CachedAdvancedCameraComponent;                     // 0x02E8(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<struct FGzSocketInitializationData>    WeaponSocketsInitializationData;                   // 0x02F0(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2FC8[0x3B8];                                   // 0x0300(0x03B8)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void BeginAimAction();
	void ClientSetHostOverheatChanged(bool bOverheated, const struct FGzInvPocketId& PocketId);
	void ClientSyncResourceInClip(const struct FGzWeaponInvItem& Item, const struct FGzInvPocketId& PocketId, int32 AmountResourceInClip, uint8 LastProcessedShotId);
	void DistributeBullets(const TArray<struct FGzBulletNetData>& BulletsData, const struct FGzShotData& ShotData, bool bBulletFromWeapon);
	void EndAimAction();
	void EquipPreviousWeaponImmediately();
	void HolsterCurrentWeapon();
	void HolsterCurrentWeaponImmediately();
	void Initialize(class USkeletalMeshComponent* Mesh);
	void InitializeWithSockets(class USkeletalMeshComponent* Mesh);
	void OnAbilityActivationFailed(const class UGameplayAbility* FailedAbility, const struct FGameplayTagContainer& FailureReasonTags);
	void OnRep_EquippedPocket(const struct FGzInvPocketId& OldPocketID);
	void OnRep_IsAiming();
	void OnRep_WeaponInitialSeed();
	void ServerDistributeBullets(const TArray<struct FGzBulletNetData>& BulletsData, const struct FGzShotData& ShotData, bool bBulletFromWeapon);
	void ServerProcessBulletHit(const struct FGzBulletID& BulletID, const struct FHitResult& Hit, float SyncedWorldTime);
	void SetAllWeaponsHidden(bool bHideWeapons);
	void SwitchEquippedWeaponSocket(bool bUseUnholserAnim);

	void ActivateEquipPreviousWeaponAbility(const class FName SocketName) const;
	bool CanEquip(const struct FGzInvPocketId& WeaponPocket) const;
	bool EquippedWeaponCanAttack() const;
	void EquipPreviousWeapon() const;
	void EquipWeaponAtPocket(const struct FGzInvPocketId& PocketId, const class FName SocketName) const;
	class UGzAbilitySystemComponent* GetAbilitySystemComponent() const;
	class UATPCCameraComponent* GetAdvancedCameraComponent() const;
	void GetAllWeaponComponents(TArray<class UGzWeaponComponent*>* OutWeapons) const;
	void GetAllWeapons(TArray<class AGzWeaponActor*>* OutWeapons) const;
	struct FGzInvPocketId GetDesiredPocket() const;
	const struct FGzInvPocketId GetEquippedPocketID() const;
	class AGzWeaponActor* GetEquippedWeapon() const;
	class UGzWeaponComponent* GetEquippedWeaponComponent() const;
	class UGzInvComponent* GetInventoryComponent() const;
	bool GetIsAiming() const;
	class USkeletalMeshComponent* GetMesh() const;
	class APawn* GetOwnerPawn() const;
	struct FGzInvPocketId GetPocketByWeaponComponent(const class UGzWeaponComponent* WeaponComponent) const;
	struct FGzInvPocketId GetPreviousEquippedPocketID() const;
	const struct FHitResult GetViewHitResult() const;
	class AGzWeaponActor* GetWeaponAtPocket(const struct FGzInvPocketId& PocketId) const;
	class UGzWeaponComponent* GetWeaponComponentAtPocket(const struct FGzInvPocketId& PocketId) const;
	bool HasEquippedWeapon() const;
	bool HasSingleSocket() const;
	void HolsterWeaponAtPocket(const struct FGzInvPocketId& PocketId) const;
	bool IsDesiredWeaponPocket(const struct FGzInvPocketId& WeaponPocket) const;
	bool IsEquippedWeapon(const class UGzWeaponComponent* GzWeaponComponent) const;
	bool IsEquippedWeaponPocket(const struct FGzInvPocketId& WeaponPocket) const;
	bool IsInitialized() const;
	void ServerProcessAttackRequest(const struct FGzWeaponInvItem& Item, const struct FGzInvPocketId& PocketId, const TArray<struct FGzBulletNetData>& BulletsData, int32 AmountResourceInClip, uint8 InNumberOfSequencedShots) const;
	void TryActivateEquipWeaponAbility(const struct FGzInvPocketId& PocketId, const class FName SocketName) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzCombatComponent">();
	}
	static class UGzCombatComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzCombatComponent>();
	}
};
static_assert(alignof(UGzCombatComponent) == 0x000008, "Wrong alignment on UGzCombatComponent");
static_assert(sizeof(UGzCombatComponent) == 0x0006B8, "Wrong size on UGzCombatComponent");
static_assert(offsetof(UGzCombatComponent, WeaponShootEvent) == 0x0000A8, "Member 'UGzCombatComponent::WeaponShootEvent' has a wrong offset!");
static_assert(offsetof(UGzCombatComponent, AimingUpdateDelegate) == 0x0000B8, "Member 'UGzCombatComponent::AimingUpdateDelegate' has a wrong offset!");
static_assert(offsetof(UGzCombatComponent, ReloadStartedDelegate) == 0x0000C8, "Member 'UGzCombatComponent::ReloadStartedDelegate' has a wrong offset!");
static_assert(offsetof(UGzCombatComponent, ReloadEndedDelegate) == 0x0000D8, "Member 'UGzCombatComponent::ReloadEndedDelegate' has a wrong offset!");
static_assert(offsetof(UGzCombatComponent, OnWeaponEquipedDelegate) == 0x0000E8, "Member 'UGzCombatComponent::OnWeaponEquipedDelegate' has a wrong offset!");
static_assert(offsetof(UGzCombatComponent, OnWeaponAmmoSynced) == 0x0000F8, "Member 'UGzCombatComponent::OnWeaponAmmoSynced' has a wrong offset!");
static_assert(offsetof(UGzCombatComponent, PostShotPerformCooldownTime) == 0x000108, "Member 'UGzCombatComponent::PostShotPerformCooldownTime' has a wrong offset!");
static_assert(offsetof(UGzCombatComponent, MeshWeaponSocketNames) == 0x000110, "Member 'UGzCombatComponent::MeshWeaponSocketNames' has a wrong offset!");
static_assert(offsetof(UGzCombatComponent, MinAimTraceDistance) == 0x000120, "Member 'UGzCombatComponent::MinAimTraceDistance' has a wrong offset!");
static_assert(offsetof(UGzCombatComponent, AimFwdOffset) == 0x000124, "Member 'UGzCombatComponent::AimFwdOffset' has a wrong offset!");
static_assert(offsetof(UGzCombatComponent, HitDiffTolerance) == 0x000128, "Member 'UGzCombatComponent::HitDiffTolerance' has a wrong offset!");
static_assert(offsetof(UGzCombatComponent, MaxAimRaycastRange) == 0x00012C, "Member 'UGzCombatComponent::MaxAimRaycastRange' has a wrong offset!");
static_assert(offsetof(UGzCombatComponent, MaxDistanceToObstacle) == 0x000134, "Member 'UGzCombatComponent::MaxDistanceToObstacle' has a wrong offset!");
static_assert(offsetof(UGzCombatComponent, MinDistanceToObstacle) == 0x000138, "Member 'UGzCombatComponent::MinDistanceToObstacle' has a wrong offset!");
static_assert(offsetof(UGzCombatComponent, ObstacleAimOffset) == 0x000140, "Member 'UGzCombatComponent::ObstacleAimOffset' has a wrong offset!");
static_assert(offsetof(UGzCombatComponent, EquipMontageRateByWeaponType) == 0x000158, "Member 'UGzCombatComponent::EquipMontageRateByWeaponType' has a wrong offset!");
static_assert(offsetof(UGzCombatComponent, ClientPredictedAmmoOnSpawn) == 0x0001A8, "Member 'UGzCombatComponent::ClientPredictedAmmoOnSpawn' has a wrong offset!");
static_assert(offsetof(UGzCombatComponent, WeaponInitialSeed) == 0x0001F8, "Member 'UGzCombatComponent::WeaponInitialSeed' has a wrong offset!");
static_assert(offsetof(UGzCombatComponent, bIsAiming) == 0x000204, "Member 'UGzCombatComponent::bIsAiming' has a wrong offset!");
static_assert(offsetof(UGzCombatComponent, bShouldUseBarrelShooting) == 0x000205, "Member 'UGzCombatComponent::bShouldUseBarrelShooting' has a wrong offset!");
static_assert(offsetof(UGzCombatComponent, RegisteredSockets) == 0x000208, "Member 'UGzCombatComponent::RegisteredSockets' has a wrong offset!");
static_assert(offsetof(UGzCombatComponent, PreviousEquippedPocket) == 0x000218, "Member 'UGzCombatComponent::PreviousEquippedPocket' has a wrong offset!");
static_assert(offsetof(UGzCombatComponent, EquippedPocketId) == 0x000220, "Member 'UGzCombatComponent::EquippedPocketId' has a wrong offset!");
static_assert(offsetof(UGzCombatComponent, Weapons) == 0x000230, "Member 'UGzCombatComponent::Weapons' has a wrong offset!");
static_assert(offsetof(UGzCombatComponent, NotInitializedWeapons) == 0x000280, "Member 'UGzCombatComponent::NotInitializedWeapons' has a wrong offset!");
static_assert(offsetof(UGzCombatComponent, OwnerMesh) == 0x0002D0, "Member 'UGzCombatComponent::OwnerMesh' has a wrong offset!");
static_assert(offsetof(UGzCombatComponent, CachedInventoryComponent) == 0x0002D8, "Member 'UGzCombatComponent::CachedInventoryComponent' has a wrong offset!");
static_assert(offsetof(UGzCombatComponent, CachedAbilitySystemComponent) == 0x0002E0, "Member 'UGzCombatComponent::CachedAbilitySystemComponent' has a wrong offset!");
static_assert(offsetof(UGzCombatComponent, CachedAdvancedCameraComponent) == 0x0002E8, "Member 'UGzCombatComponent::CachedAdvancedCameraComponent' has a wrong offset!");
static_assert(offsetof(UGzCombatComponent, WeaponSocketsInitializationData) == 0x0002F0, "Member 'UGzCombatComponent::WeaponSocketsInitializationData' has a wrong offset!");

// Class G01.GzBattlePassUiDataV2
// 0x00A8 (0x00D8 - 0x0030)
class UGzBattlePassUiDataV2 final : public UPrimaryDataAsset
{
public:
	class UGzBattlePassDataV2*                    BattlePassData;                                    // 0x0030(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMap<struct FGuid, struct FGzBattlePassPageUiDataV2> PagesUi;                                           // 0x0038(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TMap<struct FGuid, struct FGzBattlePassThemeSectionUiDataV2> ThemeSectionsUi;                                   // 0x0088(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzBattlePassUiDataV2">();
	}
	static class UGzBattlePassUiDataV2* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzBattlePassUiDataV2>();
	}
};
static_assert(alignof(UGzBattlePassUiDataV2) == 0x000008, "Wrong alignment on UGzBattlePassUiDataV2");
static_assert(sizeof(UGzBattlePassUiDataV2) == 0x0000D8, "Wrong size on UGzBattlePassUiDataV2");
static_assert(offsetof(UGzBattlePassUiDataV2, BattlePassData) == 0x000030, "Member 'UGzBattlePassUiDataV2::BattlePassData' has a wrong offset!");
static_assert(offsetof(UGzBattlePassUiDataV2, PagesUi) == 0x000038, "Member 'UGzBattlePassUiDataV2::PagesUi' has a wrong offset!");
static_assert(offsetof(UGzBattlePassUiDataV2, ThemeSectionsUi) == 0x000088, "Member 'UGzBattlePassUiDataV2::ThemeSectionsUi' has a wrong offset!");

// Class G01.GzGA_Stun
// 0x0010 (0x0518 - 0x0508)
class UGzGA_Stun : public UGzGameplayAbility
{
public:
	class UAnimMontage*                           DefaultMontage;                                    // 0x0508(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAbilityTask_PlayMontageAndWait*        AT_PlayMontageAndWait;                             // 0x0510(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void HandleMontageFinished();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzGA_Stun">();
	}
	static class UGzGA_Stun* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzGA_Stun>();
	}
};
static_assert(alignof(UGzGA_Stun) == 0x000008, "Wrong alignment on UGzGA_Stun");
static_assert(sizeof(UGzGA_Stun) == 0x000518, "Wrong size on UGzGA_Stun");
static_assert(offsetof(UGzGA_Stun, DefaultMontage) == 0x000508, "Member 'UGzGA_Stun::DefaultMontage' has a wrong offset!");
static_assert(offsetof(UGzGA_Stun, AT_PlayMontageAndWait) == 0x000510, "Member 'UGzGA_Stun::AT_PlayMontageAndWait' has a wrong offset!");

// Class G01.GzCharacterCreationState
// 0x0008 (0x0068 - 0x0060)
class UGzCharacterCreationState final : public UGzFlowState
{
public:
	uint8                                         Pad_2FD4[0x8];                                     // 0x0060(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzCharacterCreationState">();
	}
	static class UGzCharacterCreationState* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzCharacterCreationState>();
	}
};
static_assert(alignof(UGzCharacterCreationState) == 0x000008, "Wrong alignment on UGzCharacterCreationState");
static_assert(sizeof(UGzCharacterCreationState) == 0x000068, "Wrong size on UGzCharacterCreationState");

// Class G01.GzLimbsShootOffStatsCollector
// 0x0008 (0x0040 - 0x0038)
class UGzLimbsShootOffStatsCollector final : public UGzGlobalStatsCollector
{
public:
	uint8                                         Pad_2FD5[0x8];                                     // 0x0038(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzLimbsShootOffStatsCollector">();
	}
	static class UGzLimbsShootOffStatsCollector* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzLimbsShootOffStatsCollector>();
	}
};
static_assert(alignof(UGzLimbsShootOffStatsCollector) == 0x000008, "Wrong alignment on UGzLimbsShootOffStatsCollector");
static_assert(sizeof(UGzLimbsShootOffStatsCollector) == 0x000040, "Wrong size on UGzLimbsShootOffStatsCollector");

// Class G01.GzHexExtractionMessageBase
// 0x0018 (0x0040 - 0x0028)
class UGzHexExtractionMessageBase : public UGzGameMessage
{
public:
	int32                                         ExtractingPlayerId;                                // 0x0028(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FPrimaryAssetId                        AssetId;                                           // 0x002C(0x0010)(BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ExtractionTeamID;                                  // 0x003C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	bool IsExtractionTeam(const class AGzPlayerState* PlayerState);
	void SetAssetID(const struct FPrimaryAssetId& InAssetID);
	void SetExtractingPlayerId(const int32 InPlayerId);
	void SetExtractionTeamID(const int32 TeamID);

	int32 GetExtractingPlayerId() const;
	int32 GetExtractionTeamID() const;
	class UGzItemData* GetItemData() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzHexExtractionMessageBase">();
	}
	static class UGzHexExtractionMessageBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzHexExtractionMessageBase>();
	}
};
static_assert(alignof(UGzHexExtractionMessageBase) == 0x000008, "Wrong alignment on UGzHexExtractionMessageBase");
static_assert(sizeof(UGzHexExtractionMessageBase) == 0x000040, "Wrong size on UGzHexExtractionMessageBase");
static_assert(offsetof(UGzHexExtractionMessageBase, ExtractingPlayerId) == 0x000028, "Member 'UGzHexExtractionMessageBase::ExtractingPlayerId' has a wrong offset!");
static_assert(offsetof(UGzHexExtractionMessageBase, AssetId) == 0x00002C, "Member 'UGzHexExtractionMessageBase::AssetId' has a wrong offset!");
static_assert(offsetof(UGzHexExtractionMessageBase, ExtractionTeamID) == 0x00003C, "Member 'UGzHexExtractionMessageBase::ExtractionTeamID' has a wrong offset!");

// Class G01.GzHexExtractionHackBaseMessage
// 0x0008 (0x0048 - 0x0040)
class UGzHexExtractionHackBaseMessage : public UGzHexExtractionMessageBase
{
public:
	int32                                         HackedTeamID;                                      // 0x0040(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         HackedPlayerId;                                    // 0x0044(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void SetHackedTeamID(const int32 TeamID);

	int32 GetHackedPlayerId() const;
	int32 GetHackedTeamID() const;
	bool IsHackedTeamMessage() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzHexExtractionHackBaseMessage">();
	}
	static class UGzHexExtractionHackBaseMessage* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzHexExtractionHackBaseMessage>();
	}
};
static_assert(alignof(UGzHexExtractionHackBaseMessage) == 0x000008, "Wrong alignment on UGzHexExtractionHackBaseMessage");
static_assert(sizeof(UGzHexExtractionHackBaseMessage) == 0x000048, "Wrong size on UGzHexExtractionHackBaseMessage");
static_assert(offsetof(UGzHexExtractionHackBaseMessage, HackedTeamID) == 0x000040, "Member 'UGzHexExtractionHackBaseMessage::HackedTeamID' has a wrong offset!");
static_assert(offsetof(UGzHexExtractionHackBaseMessage, HackedPlayerId) == 0x000044, "Member 'UGzHexExtractionHackBaseMessage::HackedPlayerId' has a wrong offset!");

// Class G01.GzCheatWeaponConfigurationService
// 0x0000 (0x00A0 - 0x00A0)
class UGzCheatWeaponConfigurationService final : public UGzClientPFObject
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzCheatWeaponConfigurationService">();
	}
	static class UGzCheatWeaponConfigurationService* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzCheatWeaponConfigurationService>();
	}
};
static_assert(alignof(UGzCheatWeaponConfigurationService) == 0x000008, "Wrong alignment on UGzCheatWeaponConfigurationService");
static_assert(sizeof(UGzCheatWeaponConfigurationService) == 0x0000A0, "Wrong size on UGzCheatWeaponConfigurationService");

// Class G01.GzBattleRoyaleGameMode
// 0x0048 (0x0688 - 0x0640)
class AGzBattleRoyaleGameMode final : public AGzMultiStageGameMode
{
public:
	TSubclassOf<class UGzBR_PreMatchStage>        PreMatchClass;                                     // 0x0640(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoClear, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UGzBR_PreMatchCountdownStage> PreMatchCountdownClass;                            // 0x0648(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoClear, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UGzBR_MatchInProgressStage> MatchInProgressClass;                              // 0x0650(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoClear, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UGzBR_LootAndShootStage>    LootAndShootClass;                                 // 0x0658(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoClear, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UGzBR_DeploymentStage>      DeploymentClass;                                   // 0x0660(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoClear, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UGzBR_GridOverloadStage>    GridOverloadClass;                                 // 0x0668(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoClear, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UGzBR_PostMatchStage>       PostMatchClass;                                    // 0x0670(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoClear, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<TSubclassOf<class UGzGameStageBase>>   PrepareForMatchClasses;                            // 0x0678(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, Protected, UObjectWrapper, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzBattleRoyaleGameMode">();
	}
	static class AGzBattleRoyaleGameMode* GetDefaultObj()
	{
		return GetDefaultObjImpl<AGzBattleRoyaleGameMode>();
	}
};
static_assert(alignof(AGzBattleRoyaleGameMode) == 0x000008, "Wrong alignment on AGzBattleRoyaleGameMode");
static_assert(sizeof(AGzBattleRoyaleGameMode) == 0x000688, "Wrong size on AGzBattleRoyaleGameMode");
static_assert(offsetof(AGzBattleRoyaleGameMode, PreMatchClass) == 0x000640, "Member 'AGzBattleRoyaleGameMode::PreMatchClass' has a wrong offset!");
static_assert(offsetof(AGzBattleRoyaleGameMode, PreMatchCountdownClass) == 0x000648, "Member 'AGzBattleRoyaleGameMode::PreMatchCountdownClass' has a wrong offset!");
static_assert(offsetof(AGzBattleRoyaleGameMode, MatchInProgressClass) == 0x000650, "Member 'AGzBattleRoyaleGameMode::MatchInProgressClass' has a wrong offset!");
static_assert(offsetof(AGzBattleRoyaleGameMode, LootAndShootClass) == 0x000658, "Member 'AGzBattleRoyaleGameMode::LootAndShootClass' has a wrong offset!");
static_assert(offsetof(AGzBattleRoyaleGameMode, DeploymentClass) == 0x000660, "Member 'AGzBattleRoyaleGameMode::DeploymentClass' has a wrong offset!");
static_assert(offsetof(AGzBattleRoyaleGameMode, GridOverloadClass) == 0x000668, "Member 'AGzBattleRoyaleGameMode::GridOverloadClass' has a wrong offset!");
static_assert(offsetof(AGzBattleRoyaleGameMode, PostMatchClass) == 0x000670, "Member 'AGzBattleRoyaleGameMode::PostMatchClass' has a wrong offset!");
static_assert(offsetof(AGzBattleRoyaleGameMode, PrepareForMatchClasses) == 0x000678, "Member 'AGzBattleRoyaleGameMode::PrepareForMatchClasses' has a wrong offset!");

// Class G01.GzGA_SmokeWall
// 0x00E0 (0x0758 - 0x0678)
class UGzGA_SmokeWall final : public UGzGA_BaseLimbAbility
{
public:
	class UInputAction*                           AttackInputAction;                                 // 0x0678(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftClassPtr<class UClass>                   SmokeMissileClass;                                 // 0x0680(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   LaunchSocketName;                                  // 0x06A8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MissileLifespan;                                   // 0x06B0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2FD7[0x4];                                     // 0x06B4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UGzProjectileData*                      ProjectileData;                                    // 0x06B8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         AbilityEndDelay;                                   // 0x06C0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2FD8[0x4];                                     // 0x06C4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftObjectPtr<class UNiagaraSystem>          MissileMuzzleEffect;                               // 0x06C8(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftClassPtr<class UClass>                   PreviewActorClass;                                 // 0x06F0(0x0028)(Edit, DisableEditOnInstance, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class AGzSmokeWallPreviewPathActor*           PathPreviewActor;                                  // 0x0718(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FGameplayAbilityTargetDataHandle       ReceivedTargetDataHandle;                          // 0x0720(0x0028)(Transient, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_2FD9[0x10];                                    // 0x0748(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnAttackInputPressed(float TimeHeld);
	void OnMissileSpawned();
	void SpawnSmokeMissile();
	void TargetDataReceived(const struct FGameplayAbilityTargetDataHandle& Data);
	void WaitForNetSyncShootingFinished();

	struct FVector GetLaunchSocketLocation() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzGA_SmokeWall">();
	}
	static class UGzGA_SmokeWall* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzGA_SmokeWall>();
	}
};
static_assert(alignof(UGzGA_SmokeWall) == 0x000008, "Wrong alignment on UGzGA_SmokeWall");
static_assert(sizeof(UGzGA_SmokeWall) == 0x000758, "Wrong size on UGzGA_SmokeWall");
static_assert(offsetof(UGzGA_SmokeWall, AttackInputAction) == 0x000678, "Member 'UGzGA_SmokeWall::AttackInputAction' has a wrong offset!");
static_assert(offsetof(UGzGA_SmokeWall, SmokeMissileClass) == 0x000680, "Member 'UGzGA_SmokeWall::SmokeMissileClass' has a wrong offset!");
static_assert(offsetof(UGzGA_SmokeWall, LaunchSocketName) == 0x0006A8, "Member 'UGzGA_SmokeWall::LaunchSocketName' has a wrong offset!");
static_assert(offsetof(UGzGA_SmokeWall, MissileLifespan) == 0x0006B0, "Member 'UGzGA_SmokeWall::MissileLifespan' has a wrong offset!");
static_assert(offsetof(UGzGA_SmokeWall, ProjectileData) == 0x0006B8, "Member 'UGzGA_SmokeWall::ProjectileData' has a wrong offset!");
static_assert(offsetof(UGzGA_SmokeWall, AbilityEndDelay) == 0x0006C0, "Member 'UGzGA_SmokeWall::AbilityEndDelay' has a wrong offset!");
static_assert(offsetof(UGzGA_SmokeWall, MissileMuzzleEffect) == 0x0006C8, "Member 'UGzGA_SmokeWall::MissileMuzzleEffect' has a wrong offset!");
static_assert(offsetof(UGzGA_SmokeWall, PreviewActorClass) == 0x0006F0, "Member 'UGzGA_SmokeWall::PreviewActorClass' has a wrong offset!");
static_assert(offsetof(UGzGA_SmokeWall, PathPreviewActor) == 0x000718, "Member 'UGzGA_SmokeWall::PathPreviewActor' has a wrong offset!");
static_assert(offsetof(UGzGA_SmokeWall, ReceivedTargetDataHandle) == 0x000720, "Member 'UGzGA_SmokeWall::ReceivedTargetDataHandle' has a wrong offset!");

// Class G01.GzMissionAction_Trigger
// 0x0028 (0x0078 - 0x0050)
class UGzMissionAction_Trigger final : public UMissionAction
{
public:
	TSoftObjectPtr<class AActor>                  Trigger;                                           // 0x0050(0x0028)(Edit, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzMissionAction_Trigger">();
	}
	static class UGzMissionAction_Trigger* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzMissionAction_Trigger>();
	}
};
static_assert(alignof(UGzMissionAction_Trigger) == 0x000008, "Wrong alignment on UGzMissionAction_Trigger");
static_assert(sizeof(UGzMissionAction_Trigger) == 0x000078, "Wrong size on UGzMissionAction_Trigger");
static_assert(offsetof(UGzMissionAction_Trigger, Trigger) == 0x000050, "Member 'UGzMissionAction_Trigger::Trigger' has a wrong offset!");

// Class G01.GzMultiStageGameState
// 0x00A0 (0x0678 - 0x05D8)
class AGzMultiStageGameState : public AGzGameState
{
public:
	FMulticastInlineDelegateProperty_             OnStageChanged;                                    // 0x05D8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnDeploymentPawnCountChanged;                      // 0x05E8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	struct FGameplayTagContainer                  MatchStartedStageTags;                             // 0x05F8(0x0020)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	struct FGameplayTagContainer                  MatchEndedStageTags;                               // 0x0618(0x0020)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	TArray<TSubclassOf<class UGzGameStageBase>>   ActiveStageClasses;                                // 0x0638(0x0010)(Net, ZeroConstructor, RepNotify, UObjectWrapper, NativeAccessSpecifierPrivate)
	int32                                         DeploymentPawnCount;                               // 0x0648(0x0004)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         StageStartTime;                                    // 0x064C(0x0004)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         MatchStartTime;                                    // 0x0650(0x0004)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         StageEndTime;                                      // 0x0654(0x0004)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2FDA[0x20];                                    // 0x0658(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnRep_ActiveStages();
	void SetMatchStartTime(float NewMatchStartTime);
	void SetStageEndTime(float NewStageEndTime);
	void SetStageStartTime(float NewStageStartTime);

	const struct FGameplayTagContainer GetActiveStageTags() const;
	int32 GetDeploymentPawnCount() const;
	float GetStageRemainingTime() const;
	float GetTimeFromMatchStart() const;
	float GetTimeFromStageStart() const;
	void OnRep_DeploymentPawnCount() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzMultiStageGameState">();
	}
	static class AGzMultiStageGameState* GetDefaultObj()
	{
		return GetDefaultObjImpl<AGzMultiStageGameState>();
	}
};
static_assert(alignof(AGzMultiStageGameState) == 0x000008, "Wrong alignment on AGzMultiStageGameState");
static_assert(sizeof(AGzMultiStageGameState) == 0x000678, "Wrong size on AGzMultiStageGameState");
static_assert(offsetof(AGzMultiStageGameState, OnStageChanged) == 0x0005D8, "Member 'AGzMultiStageGameState::OnStageChanged' has a wrong offset!");
static_assert(offsetof(AGzMultiStageGameState, OnDeploymentPawnCountChanged) == 0x0005E8, "Member 'AGzMultiStageGameState::OnDeploymentPawnCountChanged' has a wrong offset!");
static_assert(offsetof(AGzMultiStageGameState, MatchStartedStageTags) == 0x0005F8, "Member 'AGzMultiStageGameState::MatchStartedStageTags' has a wrong offset!");
static_assert(offsetof(AGzMultiStageGameState, MatchEndedStageTags) == 0x000618, "Member 'AGzMultiStageGameState::MatchEndedStageTags' has a wrong offset!");
static_assert(offsetof(AGzMultiStageGameState, ActiveStageClasses) == 0x000638, "Member 'AGzMultiStageGameState::ActiveStageClasses' has a wrong offset!");
static_assert(offsetof(AGzMultiStageGameState, DeploymentPawnCount) == 0x000648, "Member 'AGzMultiStageGameState::DeploymentPawnCount' has a wrong offset!");
static_assert(offsetof(AGzMultiStageGameState, StageStartTime) == 0x00064C, "Member 'AGzMultiStageGameState::StageStartTime' has a wrong offset!");
static_assert(offsetof(AGzMultiStageGameState, MatchStartTime) == 0x000650, "Member 'AGzMultiStageGameState::MatchStartTime' has a wrong offset!");
static_assert(offsetof(AGzMultiStageGameState, StageEndTime) == 0x000654, "Member 'AGzMultiStageGameState::StageEndTime' has a wrong offset!");

// Class G01.GzPocketWidget
// 0x0048 (0x0358 - 0x0310)
class UGzPocketWidget : public UGzBaseInventoryWidget
{
public:
	FMulticastInlineDelegateProperty_             OnPocketWidgetDataChanged;                         // 0x0310(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	bool                                          bShowTooltipOnHover;                               // 0x0320(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2FDB[0x7];                                     // 0x0321(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UGzCommonButton*                        PocketButton;                                      // 0x0328(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FGzInvItem                             PocketItem;                                        // 0x0330(0x0010)(BlueprintVisible, BlueprintReadOnly, Transient, Protected, NativeAccessSpecifierProtected)
	struct FGzInvPocketId                         PocketId;                                          // 0x0340(0x0008)(BlueprintVisible, BlueprintReadOnly, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2FDC[0x10];                                    // 0x0348(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnClick();
	void OnHoldCompleted(class UCommonButtonBase* Button, const struct FKey& HoldingKey);
	void OnHovered();
	void OnPocketChanged_BP(const struct FGzInvItem& NewItem);
	void OnRightClick(class UCommonButtonBase* Button);
	void OnUnhovered();

	const struct FGzInvPocket GetPocket() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzPocketWidget">();
	}
	static class UGzPocketWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzPocketWidget>();
	}
};
static_assert(alignof(UGzPocketWidget) == 0x000008, "Wrong alignment on UGzPocketWidget");
static_assert(sizeof(UGzPocketWidget) == 0x000358, "Wrong size on UGzPocketWidget");
static_assert(offsetof(UGzPocketWidget, OnPocketWidgetDataChanged) == 0x000310, "Member 'UGzPocketWidget::OnPocketWidgetDataChanged' has a wrong offset!");
static_assert(offsetof(UGzPocketWidget, bShowTooltipOnHover) == 0x000320, "Member 'UGzPocketWidget::bShowTooltipOnHover' has a wrong offset!");
static_assert(offsetof(UGzPocketWidget, PocketButton) == 0x000328, "Member 'UGzPocketWidget::PocketButton' has a wrong offset!");
static_assert(offsetof(UGzPocketWidget, PocketItem) == 0x000330, "Member 'UGzPocketWidget::PocketItem' has a wrong offset!");
static_assert(offsetof(UGzPocketWidget, PocketId) == 0x000340, "Member 'UGzPocketWidget::PocketId' has a wrong offset!");

// Class G01.GzEquipmentPocketWidget
// 0x0008 (0x0360 - 0x0358)
class UGzEquipmentPocketWidget : public UGzPocketWidget
{
public:
	struct FGameplayTag                           ItemSlot;                                          // 0x0358(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzEquipmentPocketWidget">();
	}
	static class UGzEquipmentPocketWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzEquipmentPocketWidget>();
	}
};
static_assert(alignof(UGzEquipmentPocketWidget) == 0x000008, "Wrong alignment on UGzEquipmentPocketWidget");
static_assert(sizeof(UGzEquipmentPocketWidget) == 0x000360, "Wrong size on UGzEquipmentPocketWidget");
static_assert(offsetof(UGzEquipmentPocketWidget, ItemSlot) == 0x000358, "Member 'UGzEquipmentPocketWidget::ItemSlot' has a wrong offset!");

// Class G01.GzLimbPocketWidget
// 0x0000 (0x0360 - 0x0360)
class UGzLimbPocketWidget : public UGzEquipmentPocketWidget
{
public:
	void OnLimbHealthChanged_BP(float OldHealth, float NewHealth);

	class UAbilitySystemComponent* GetAbilitySystemComponent() const;
	struct FGameplayAttribute GetHealthAttribute() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzLimbPocketWidget">();
	}
	static class UGzLimbPocketWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzLimbPocketWidget>();
	}
};
static_assert(alignof(UGzLimbPocketWidget) == 0x000008, "Wrong alignment on UGzLimbPocketWidget");
static_assert(sizeof(UGzLimbPocketWidget) == 0x000360, "Wrong size on UGzLimbPocketWidget");

// Class G01.GzBattleRoyaleGameState
// 0x0000 (0x0678 - 0x0678)
class AGzBattleRoyaleGameState final : public AGzMultiStageGameState
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzBattleRoyaleGameState">();
	}
	static class AGzBattleRoyaleGameState* GetDefaultObj()
	{
		return GetDefaultObjImpl<AGzBattleRoyaleGameState>();
	}
};
static_assert(alignof(AGzBattleRoyaleGameState) == 0x000008, "Wrong alignment on AGzBattleRoyaleGameState");
static_assert(sizeof(AGzBattleRoyaleGameState) == 0x000678, "Wrong size on AGzBattleRoyaleGameState");

// Class G01.GzInputModifierGlobalDeadZone
// 0x0008 (0x0030 - 0x0028)
class UGzInputModifierGlobalDeadZone final : public UInputModifier
{
public:
	EDeadZoneType                                 Type;                                              // 0x0028(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnTemplate, Config, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2FDD[0x7];                                     // 0x0029(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzInputModifierGlobalDeadZone">();
	}
	static class UGzInputModifierGlobalDeadZone* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzInputModifierGlobalDeadZone>();
	}
};
static_assert(alignof(UGzInputModifierGlobalDeadZone) == 0x000008, "Wrong alignment on UGzInputModifierGlobalDeadZone");
static_assert(sizeof(UGzInputModifierGlobalDeadZone) == 0x000030, "Wrong size on UGzInputModifierGlobalDeadZone");
static_assert(offsetof(UGzInputModifierGlobalDeadZone, Type) == 0x000028, "Member 'UGzInputModifierGlobalDeadZone::Type' has a wrong offset!");

// Class G01.LocomotionController
// 0x0040 (0x08C8 - 0x0888)
class ALocomotionController : public APlayerController
{
public:
	uint8                                         Pad_2FDE[0x8];                                     // 0x0888(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class ULocomotionHUDWidget>       DebugHUDWidget;                                    // 0x0890(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSubclassOf<class ULocomotionStateSwitcherWidget> OverlayStateSwitcherWidget;                        // 0x0898(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class USoundBase*                             ClickSound;                                        // 0x08A0(0x0008)(Edit, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class ULocomotionStateSwitcherWidget*         OverlaySwitcher;                                   // 0x08A8(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class ULocomotionHUDWidget*                   DebugHUD;                                          // 0x08B0(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          ShowTraces;                                        // 0x08B8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          DebugView;                                         // 0x08B9(0x0001)(Edit, BlueprintVisible, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          ShowHUD;                                           // 0x08BA(0x0001)(Edit, BlueprintVisible, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          ShowDebugShapes;                                   // 0x08BB(0x0001)(Edit, BlueprintVisible, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          ShowLayerColors;                                   // 0x08BC(0x0001)(Edit, BlueprintVisible, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          Slomo;                                             // 0x08BD(0x0001)(Edit, BlueprintVisible, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          ShowCharacterInfo;                                 // 0x08BE(0x0001)(Edit, BlueprintVisible, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bInitDebugKeys;                                    // 0x08BF(0x0001)(Edit, BlueprintVisible, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          OverlayMenuOpen;                                   // 0x08C0(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2FDF[0x7];                                     // 0x08C1(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LocomotionController">();
	}
	static class ALocomotionController* GetDefaultObj()
	{
		return GetDefaultObjImpl<ALocomotionController>();
	}
};
static_assert(alignof(ALocomotionController) == 0x000008, "Wrong alignment on ALocomotionController");
static_assert(sizeof(ALocomotionController) == 0x0008C8, "Wrong size on ALocomotionController");
static_assert(offsetof(ALocomotionController, DebugHUDWidget) == 0x000890, "Member 'ALocomotionController::DebugHUDWidget' has a wrong offset!");
static_assert(offsetof(ALocomotionController, OverlayStateSwitcherWidget) == 0x000898, "Member 'ALocomotionController::OverlayStateSwitcherWidget' has a wrong offset!");
static_assert(offsetof(ALocomotionController, ClickSound) == 0x0008A0, "Member 'ALocomotionController::ClickSound' has a wrong offset!");
static_assert(offsetof(ALocomotionController, OverlaySwitcher) == 0x0008A8, "Member 'ALocomotionController::OverlaySwitcher' has a wrong offset!");
static_assert(offsetof(ALocomotionController, DebugHUD) == 0x0008B0, "Member 'ALocomotionController::DebugHUD' has a wrong offset!");
static_assert(offsetof(ALocomotionController, ShowTraces) == 0x0008B8, "Member 'ALocomotionController::ShowTraces' has a wrong offset!");
static_assert(offsetof(ALocomotionController, DebugView) == 0x0008B9, "Member 'ALocomotionController::DebugView' has a wrong offset!");
static_assert(offsetof(ALocomotionController, ShowHUD) == 0x0008BA, "Member 'ALocomotionController::ShowHUD' has a wrong offset!");
static_assert(offsetof(ALocomotionController, ShowDebugShapes) == 0x0008BB, "Member 'ALocomotionController::ShowDebugShapes' has a wrong offset!");
static_assert(offsetof(ALocomotionController, ShowLayerColors) == 0x0008BC, "Member 'ALocomotionController::ShowLayerColors' has a wrong offset!");
static_assert(offsetof(ALocomotionController, Slomo) == 0x0008BD, "Member 'ALocomotionController::Slomo' has a wrong offset!");
static_assert(offsetof(ALocomotionController, ShowCharacterInfo) == 0x0008BE, "Member 'ALocomotionController::ShowCharacterInfo' has a wrong offset!");
static_assert(offsetof(ALocomotionController, bInitDebugKeys) == 0x0008BF, "Member 'ALocomotionController::bInitDebugKeys' has a wrong offset!");
static_assert(offsetof(ALocomotionController, OverlayMenuOpen) == 0x0008C0, "Member 'ALocomotionController::OverlayMenuOpen' has a wrong offset!");

// Class G01.GzPlayerController
// 0x0638 (0x0F00 - 0x08C8)
class AGzPlayerController : public ALocomotionController
{
public:
	uint8                                         Pad_2FE0[0x10];                                    // 0x08C8(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class AActor*                                 CurrentInteractionActor;                           // 0x08D8(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGzSoundStateKey                       LandedSoundState;                                  // 0x08E0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnRespawnTimeReceived;                             // 0x08E8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnTeamRespawnTimeReduced;                          // 0x08F8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnInteractionStarted;                              // 0x0908(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnInteractionStartedV2;                            // 0x0918(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnFinishCurrentInteractionStage;                   // 0x0928(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnRecievedHitResponse;                             // 0x0938(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnPawnChanged;                                     // 0x0948(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnStartedSpectating;                               // 0x0958(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnEndedSpectating;                                 // 0x0968(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_2FE1[0x18];                                    // 0x0978(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	FMulticastInlineDelegateProperty_             OnPlayerControllerInitialized;                     // 0x0990(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnMatchResultSet;                                  // 0x09A0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnSpectatingKillerChanged;                         // 0x09B0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnActiveExtractionsChanged;                        // 0x09C0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnMinigameBytesReceived;                           // 0x09D0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnLoadoutSelectionTimerStarted;                    // 0x09E0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnKillerInfoSet;                                   // 0x09F0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_2FE2[0x49];                                    // 0x0A00(0x0049)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bClientReceivedPlayerState;                        // 0x0A49(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EGzAimingSensitivityState                     SensitivityState;                                  // 0x0A4A(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2FE3[0x1];                                     // 0x0A4B(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         SensitivityYawModifier;                            // 0x0A4C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         SensitivityPitchModifier;                          // 0x0A50(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bAimAssistEnabled;                                 // 0x0A54(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2FE4[0x3];                                     // 0x0A55(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTag                           ActiveCameraModeTag;                               // 0x0A58(0x0008)(Net, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FGameplayTag                           ActiveOverlayCameraModeTag;                        // 0x0A60(0x0008)(Net, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<struct FGzRevealedActorInfo>           RevealedActorsReplicated;                          // 0x0A68(0x0010)(Net, ZeroConstructor, RepNotify, Protected, NativeAccessSpecifierProtected)
	TArray<struct FGzRevealedActorInfo>           RevealedActors;                                    // 0x0A78(0x0010)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	bool                                          bSpectateKiller;                                   // 0x0A88(0x0001)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2FE5[0x3];                                     // 0x0A89(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ForceLeaveDelay;                                   // 0x0A8C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UGzStatsHolderComponent*                StatsComponent;                                    // 0x0A90(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UGzAimAssistComponent*                  AimAssistComponent;                                // 0x0A98(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2FE6[0x40];                                    // 0x0AA0(0x0040)(Fixing Size After Last Property [ Dumper-7 ])
	class APawn*                                  ObservedPawn;                                      // 0x0AE0(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2FE7[0x20];                                    // 0x0AE8(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	class AGzPlayerState*                         ViewTargetKiller;                                  // 0x0B08(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSubclassOf<class UGzAudioControllerComponent> AudioControllerComponentClass;                     // 0x0B10(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UGzAudioControllerComponent*            AudioControllerComponent;                          // 0x0B18(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UGzPostProcessControllerComponent*      PostProcessControllerComponent;                    // 0x0B20(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UGzPlayerMarkersHolderComponent*        MarkersHolderComponent;                            // 0x0B28(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UGzTrialsControllerComponent*           TrialsControllerComponent;                         // 0x0B30(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UGzPingControllerComponent*             PingControllerComponent;                           // 0x0B38(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UGzSearchZonesComponent*                SearchZonesComponent;                              // 0x0B40(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UGzInputControlsComponent*              InputControlsComponent;                            // 0x0B48(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FGzMatchResult                         MatchResult;                                       // 0x0B50(0x0090)(Transient, NativeAccessSpecifierPrivate)
	class APawn*                                  CachedViewTarget;                                  // 0x0BE0(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2FE8[0x10];                                    // 0x0BE8(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FGzQuickOrderArrivalData>       QuickOrderArrivals;                                // 0x0BF8(0x0010)(Net, ZeroConstructor, RepNotify, NativeAccessSpecifierPrivate)
	TArray<struct FGzShrinkingStageCircle>        RevealedZoneCircles;                               // 0x0C08(0x0010)(Net, ZeroConstructor, RepNotify, NativeAccessSpecifierPrivate)
	TArray<struct FGzExtractionData>              ActiveHexExtractions;                              // 0x0C18(0x0010)(Net, ZeroConstructor, RepNotify, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2FE9[0x20];                                    // 0x0C28(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGzKillerInfo                          KillerInfo;                                        // 0x0C48(0x0030)(NativeAccessSpecifierPrivate)
	uint8                                         Pad_2FEA[0x260];                                   // 0x0C78(0x0260)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         NetworkClockUpdateFrequency;                       // 0x0ED8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         NetworkClockRTTCircularBufferSize;                 // 0x0EDC(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class AGzTeam*                                OwningTeam;                                        // 0x0EE0(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2FEB[0x18];                                    // 0x0EE8(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AntiCheatSendToClient(const TArray<uint8>& Data);
	void AntiCheatSendToServer(const TArray<uint8>& Data);
	void Client_NotifyReceivedHitResponse(const struct FGzHitResponseData& HitResponseData);
	void Client_NotifyRespawnTime(float RespawnTime);
	void Client_NotifyTeamRespawnTimeReduced(float TimeBonus);
	void Client_NotifyUpdateRecentPlayers(const TArray<class FString>& PlatformUserIds);
	void Client_NotifyViewTargetReceivedDamage(const struct FGzServerDamageInfo& ServerDamageInfo);
	void Client_ResetSpectatorCameraMode(const struct FGameplayTag& CameraModeTag);
	void Client_ResetSpectatorOverlayCameraMode(bool bWithInterpolation);
	void Client_SendAudioAnnouncement(const struct FGameplayTag& AnnouncerTag, const struct FGameplayTag& VoiceLineTag, bool bStarted);
	void Client_SendGameMessage(const struct FGzMessageNetData& MessageData);
	void Client_SendVoiceableActionEvent(class AActor* ActionInstigator, const struct FGameplayTag& Tag, bool bStarted);
	void Client_SetSpectatorCameraMode(const struct FGameplayTag& CameraModeTag);
	void Client_SetSpectatorOverlayCameraMode(const struct FGameplayTag& CameraModeTag, bool bWithInterpolation);
	void ClientSetMatchResult(const struct FGzMatchResult& InMatchResult);
	void ClientSetSoundState(const struct FGzSoundStateKey& State);
	void ClientUpdateWorldTime(float ClientTimestamp, float ServerTimestamp);
	void ConnectToVoiceChatRoom(const struct FGuid& RoomGuid, const class FString& JoinUrl, const class FString& JoinToken);
	void DisplayDamage(const struct FDamageDisplayData& DamageData, const struct FVector& ImpactNormal);
	void DrawDebugCovers(const TArray<struct FDrawCovers>& TakeCovers);
	void K2_DisplayDamage(const struct FDamageDisplayData& DamageData);
	void LeaveMatch();
	void ListenLandedEvent(bool bChangeSoundState);
	void OnCinematicModeChanged(bool bNewCinematicMode);
	void OnConnectionStateChanged(class AGzPlayerState* PS);
	void OnObservedPlayerConnectionChanged(class AGzPlayerState* InPlayerState);
	void OnRep_ActiveHexExtractions();
	void OnRep_QuickOrderArrivals();
	void OnRep_RevealedActors();
	void OnRep_RevealedZoneCircles();
	void OnRep_SpectateKiller(bool bPrevSpectateKiller);
	void OnTeamChanged(class AGzPlayerState* PS);
	void OnTeammateAliveStateChanged(class AGzPlayerState* PS);
	void RemoveActiveHexExtraction(int32 ExtractionId);
	void RequestSuicide();
	void SendServerFloorToClient(const struct FFindFloorResult& FloorResult);
	void Server_CallRedeployment(class AGzRedeploymentTerminal* RedeploymentTerminal, const TArray<int32>& TeammatesIds);
	void Server_SendMinigameBytes(uint8 Bytes);
	void Server_SendPlatformUserInfo(const class FString& PlayFabId, const class FString& PlatformUserId);
	void Server_SetVirtualItem(const struct FGzInvPocketId& PocketId, class UGzItemData* ItemData);
	void ServerHandleDeliberateLeave();
	void ServerNotifyBuildHealthChecked();
	void ServerNotifyPlayerStateReceived();
	void ServerRemoveItem(const struct FGzInvItem& Item);
	void ServerRemoveSlot(const struct FGameplayTag& Slot);
	void ServerRename(const class FString& BaseName);
	void ServerRequestWorldTime(float ClientTimestamp);
	void ServerStartPostLoadoutSelectionTimer(const struct FGuid& LoadoutGuid);
	void ServerSwapPockets(const struct FGzInvPocketId& LeftPocketId, const struct FGzInvPocketId& RightPocketId);
	void SetActiveHexExtraction(const struct FGzExtractionData& InExtractionData);
	void SetAimingInputScale(float Scale);
	void SetFlushKeysOnViewportFocusChange(bool bInFlushKeysOnViewportFocusChange);
	void SetInputPitchYawScale(float PitchScale, float YawScale);
	void SetPreciseControlRotation(const struct FRotator& NewRotation);
	void SetSniperScopeInputScale(float Scale);
	void StartPostLoadoutSelectionTimer(const struct FGuid& LoadoutGuid);
	void StopListenLandedEvent();
	void SubscribeToTeamChange();

	const TArray<struct FGzExtractionData> GetActiveHexExtractions() const;
	class UGzInputControlsComponent* GetInputControlsComponent() const;
	const struct FGzKillerInfo GetKillerInfo() const;
	class UGzPlayerMarkersHolderComponent* GetMarkersHolderComponent() const;
	const struct FGzMatchResult GetMatchResult() const;
	float GetServerWorldTimeDelta() const;
	float GetSyncedServerWorldTime() const;
	bool IsMatchResultSet() const;
	bool IsPartyMember() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzPlayerController">();
	}
	static class AGzPlayerController* GetDefaultObj()
	{
		return GetDefaultObjImpl<AGzPlayerController>();
	}
};
static_assert(alignof(AGzPlayerController) == 0x000008, "Wrong alignment on AGzPlayerController");
static_assert(sizeof(AGzPlayerController) == 0x000F00, "Wrong size on AGzPlayerController");
static_assert(offsetof(AGzPlayerController, CurrentInteractionActor) == 0x0008D8, "Member 'AGzPlayerController::CurrentInteractionActor' has a wrong offset!");
static_assert(offsetof(AGzPlayerController, LandedSoundState) == 0x0008E0, "Member 'AGzPlayerController::LandedSoundState' has a wrong offset!");
static_assert(offsetof(AGzPlayerController, OnRespawnTimeReceived) == 0x0008E8, "Member 'AGzPlayerController::OnRespawnTimeReceived' has a wrong offset!");
static_assert(offsetof(AGzPlayerController, OnTeamRespawnTimeReduced) == 0x0008F8, "Member 'AGzPlayerController::OnTeamRespawnTimeReduced' has a wrong offset!");
static_assert(offsetof(AGzPlayerController, OnInteractionStarted) == 0x000908, "Member 'AGzPlayerController::OnInteractionStarted' has a wrong offset!");
static_assert(offsetof(AGzPlayerController, OnInteractionStartedV2) == 0x000918, "Member 'AGzPlayerController::OnInteractionStartedV2' has a wrong offset!");
static_assert(offsetof(AGzPlayerController, OnFinishCurrentInteractionStage) == 0x000928, "Member 'AGzPlayerController::OnFinishCurrentInteractionStage' has a wrong offset!");
static_assert(offsetof(AGzPlayerController, OnRecievedHitResponse) == 0x000938, "Member 'AGzPlayerController::OnRecievedHitResponse' has a wrong offset!");
static_assert(offsetof(AGzPlayerController, OnPawnChanged) == 0x000948, "Member 'AGzPlayerController::OnPawnChanged' has a wrong offset!");
static_assert(offsetof(AGzPlayerController, OnStartedSpectating) == 0x000958, "Member 'AGzPlayerController::OnStartedSpectating' has a wrong offset!");
static_assert(offsetof(AGzPlayerController, OnEndedSpectating) == 0x000968, "Member 'AGzPlayerController::OnEndedSpectating' has a wrong offset!");
static_assert(offsetof(AGzPlayerController, OnPlayerControllerInitialized) == 0x000990, "Member 'AGzPlayerController::OnPlayerControllerInitialized' has a wrong offset!");
static_assert(offsetof(AGzPlayerController, OnMatchResultSet) == 0x0009A0, "Member 'AGzPlayerController::OnMatchResultSet' has a wrong offset!");
static_assert(offsetof(AGzPlayerController, OnSpectatingKillerChanged) == 0x0009B0, "Member 'AGzPlayerController::OnSpectatingKillerChanged' has a wrong offset!");
static_assert(offsetof(AGzPlayerController, OnActiveExtractionsChanged) == 0x0009C0, "Member 'AGzPlayerController::OnActiveExtractionsChanged' has a wrong offset!");
static_assert(offsetof(AGzPlayerController, OnMinigameBytesReceived) == 0x0009D0, "Member 'AGzPlayerController::OnMinigameBytesReceived' has a wrong offset!");
static_assert(offsetof(AGzPlayerController, OnLoadoutSelectionTimerStarted) == 0x0009E0, "Member 'AGzPlayerController::OnLoadoutSelectionTimerStarted' has a wrong offset!");
static_assert(offsetof(AGzPlayerController, OnKillerInfoSet) == 0x0009F0, "Member 'AGzPlayerController::OnKillerInfoSet' has a wrong offset!");
static_assert(offsetof(AGzPlayerController, bClientReceivedPlayerState) == 0x000A49, "Member 'AGzPlayerController::bClientReceivedPlayerState' has a wrong offset!");
static_assert(offsetof(AGzPlayerController, SensitivityState) == 0x000A4A, "Member 'AGzPlayerController::SensitivityState' has a wrong offset!");
static_assert(offsetof(AGzPlayerController, SensitivityYawModifier) == 0x000A4C, "Member 'AGzPlayerController::SensitivityYawModifier' has a wrong offset!");
static_assert(offsetof(AGzPlayerController, SensitivityPitchModifier) == 0x000A50, "Member 'AGzPlayerController::SensitivityPitchModifier' has a wrong offset!");
static_assert(offsetof(AGzPlayerController, bAimAssistEnabled) == 0x000A54, "Member 'AGzPlayerController::bAimAssistEnabled' has a wrong offset!");
static_assert(offsetof(AGzPlayerController, ActiveCameraModeTag) == 0x000A58, "Member 'AGzPlayerController::ActiveCameraModeTag' has a wrong offset!");
static_assert(offsetof(AGzPlayerController, ActiveOverlayCameraModeTag) == 0x000A60, "Member 'AGzPlayerController::ActiveOverlayCameraModeTag' has a wrong offset!");
static_assert(offsetof(AGzPlayerController, RevealedActorsReplicated) == 0x000A68, "Member 'AGzPlayerController::RevealedActorsReplicated' has a wrong offset!");
static_assert(offsetof(AGzPlayerController, RevealedActors) == 0x000A78, "Member 'AGzPlayerController::RevealedActors' has a wrong offset!");
static_assert(offsetof(AGzPlayerController, bSpectateKiller) == 0x000A88, "Member 'AGzPlayerController::bSpectateKiller' has a wrong offset!");
static_assert(offsetof(AGzPlayerController, ForceLeaveDelay) == 0x000A8C, "Member 'AGzPlayerController::ForceLeaveDelay' has a wrong offset!");
static_assert(offsetof(AGzPlayerController, StatsComponent) == 0x000A90, "Member 'AGzPlayerController::StatsComponent' has a wrong offset!");
static_assert(offsetof(AGzPlayerController, AimAssistComponent) == 0x000A98, "Member 'AGzPlayerController::AimAssistComponent' has a wrong offset!");
static_assert(offsetof(AGzPlayerController, ObservedPawn) == 0x000AE0, "Member 'AGzPlayerController::ObservedPawn' has a wrong offset!");
static_assert(offsetof(AGzPlayerController, ViewTargetKiller) == 0x000B08, "Member 'AGzPlayerController::ViewTargetKiller' has a wrong offset!");
static_assert(offsetof(AGzPlayerController, AudioControllerComponentClass) == 0x000B10, "Member 'AGzPlayerController::AudioControllerComponentClass' has a wrong offset!");
static_assert(offsetof(AGzPlayerController, AudioControllerComponent) == 0x000B18, "Member 'AGzPlayerController::AudioControllerComponent' has a wrong offset!");
static_assert(offsetof(AGzPlayerController, PostProcessControllerComponent) == 0x000B20, "Member 'AGzPlayerController::PostProcessControllerComponent' has a wrong offset!");
static_assert(offsetof(AGzPlayerController, MarkersHolderComponent) == 0x000B28, "Member 'AGzPlayerController::MarkersHolderComponent' has a wrong offset!");
static_assert(offsetof(AGzPlayerController, TrialsControllerComponent) == 0x000B30, "Member 'AGzPlayerController::TrialsControllerComponent' has a wrong offset!");
static_assert(offsetof(AGzPlayerController, PingControllerComponent) == 0x000B38, "Member 'AGzPlayerController::PingControllerComponent' has a wrong offset!");
static_assert(offsetof(AGzPlayerController, SearchZonesComponent) == 0x000B40, "Member 'AGzPlayerController::SearchZonesComponent' has a wrong offset!");
static_assert(offsetof(AGzPlayerController, InputControlsComponent) == 0x000B48, "Member 'AGzPlayerController::InputControlsComponent' has a wrong offset!");
static_assert(offsetof(AGzPlayerController, MatchResult) == 0x000B50, "Member 'AGzPlayerController::MatchResult' has a wrong offset!");
static_assert(offsetof(AGzPlayerController, CachedViewTarget) == 0x000BE0, "Member 'AGzPlayerController::CachedViewTarget' has a wrong offset!");
static_assert(offsetof(AGzPlayerController, QuickOrderArrivals) == 0x000BF8, "Member 'AGzPlayerController::QuickOrderArrivals' has a wrong offset!");
static_assert(offsetof(AGzPlayerController, RevealedZoneCircles) == 0x000C08, "Member 'AGzPlayerController::RevealedZoneCircles' has a wrong offset!");
static_assert(offsetof(AGzPlayerController, ActiveHexExtractions) == 0x000C18, "Member 'AGzPlayerController::ActiveHexExtractions' has a wrong offset!");
static_assert(offsetof(AGzPlayerController, KillerInfo) == 0x000C48, "Member 'AGzPlayerController::KillerInfo' has a wrong offset!");
static_assert(offsetof(AGzPlayerController, NetworkClockUpdateFrequency) == 0x000ED8, "Member 'AGzPlayerController::NetworkClockUpdateFrequency' has a wrong offset!");
static_assert(offsetof(AGzPlayerController, NetworkClockRTTCircularBufferSize) == 0x000EDC, "Member 'AGzPlayerController::NetworkClockRTTCircularBufferSize' has a wrong offset!");
static_assert(offsetof(AGzPlayerController, OwningTeam) == 0x000EE0, "Member 'AGzPlayerController::OwningTeam' has a wrong offset!");

// Class G01.GzTimeSurvivedStatsCollector
// 0x0060 (0x0098 - 0x0038)
class UGzTimeSurvivedStatsCollector final : public UGzGlobalStatsCollector
{
public:
	TMap<class AGzPlayerState*, float>            LastConsumedTimestamps;                            // 0x0038(0x0050)(Transient, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2FEF[0x10];                                    // 0x0088(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void UpdatePlayerTimeSurvived(class AGzPlayerState* PlayerState);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzTimeSurvivedStatsCollector">();
	}
	static class UGzTimeSurvivedStatsCollector* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzTimeSurvivedStatsCollector>();
	}
};
static_assert(alignof(UGzTimeSurvivedStatsCollector) == 0x000008, "Wrong alignment on UGzTimeSurvivedStatsCollector");
static_assert(sizeof(UGzTimeSurvivedStatsCollector) == 0x000098, "Wrong size on UGzTimeSurvivedStatsCollector");
static_assert(offsetof(UGzTimeSurvivedStatsCollector, LastConsumedTimestamps) == 0x000038, "Member 'UGzTimeSurvivedStatsCollector::LastConsumedTimestamps' has a wrong offset!");

// Class G01.GzScoreValueWidget
// 0x0008 (0x02E8 - 0x02E0)
class UGzScoreValueWidget : public UUserWidget
{
public:
	class UCommonTextBlock*                       Text;                                              // 0x02E0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzScoreValueWidget">();
	}
	static class UGzScoreValueWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzScoreValueWidget>();
	}
};
static_assert(alignof(UGzScoreValueWidget) == 0x000008, "Wrong alignment on UGzScoreValueWidget");
static_assert(sizeof(UGzScoreValueWidget) == 0x0002E8, "Wrong size on UGzScoreValueWidget");
static_assert(offsetof(UGzScoreValueWidget, Text) == 0x0002E0, "Member 'UGzScoreValueWidget::Text' has a wrong offset!");

// Class G01.GzBattleRoyalePlayerController
// 0x0018 (0x0F18 - 0x0F00)
class AGzBattleRoyalePlayerController : public AGzPlayerController
{
public:
	FMulticastInlineDelegateProperty_             OnLastZoneSelected;                                // 0x0F00(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	struct FGzSelectedZoneData                    SelectedZoneData;                                  // 0x0F10(0x0008)(Net, RepNotify, NoDestructor, Protected, NativeAccessSpecifierProtected)

public:
	void OnRep_SelectedLastZoneData(const struct FGzSelectedZoneData& OldZoneData);

	const struct FGzSelectedZoneData GetSelectedLastZoneIndex() const;
	bool HasSelectedLastZoneData() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzBattleRoyalePlayerController">();
	}
	static class AGzBattleRoyalePlayerController* GetDefaultObj()
	{
		return GetDefaultObjImpl<AGzBattleRoyalePlayerController>();
	}
};
static_assert(alignof(AGzBattleRoyalePlayerController) == 0x000008, "Wrong alignment on AGzBattleRoyalePlayerController");
static_assert(sizeof(AGzBattleRoyalePlayerController) == 0x000F18, "Wrong size on AGzBattleRoyalePlayerController");
static_assert(offsetof(AGzBattleRoyalePlayerController, OnLastZoneSelected) == 0x000F00, "Member 'AGzBattleRoyalePlayerController::OnLastZoneSelected' has a wrong offset!");
static_assert(offsetof(AGzBattleRoyalePlayerController, SelectedZoneData) == 0x000F10, "Member 'AGzBattleRoyalePlayerController::SelectedZoneData' has a wrong offset!");

// Class G01.GzShootHitStatCollector
// 0x0000 (0x0038 - 0x0038)
class UGzShootHitStatCollector : public UGzGlobalStatsCollector
{
public:
	void PlayerHit(const class APawn* Instigator, class FName WeaponName, EGzCharacterDamageAreaType CharacterDamageAreaType);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzShootHitStatCollector">();
	}
	static class UGzShootHitStatCollector* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzShootHitStatCollector>();
	}
};
static_assert(alignof(UGzShootHitStatCollector) == 0x000008, "Wrong alignment on UGzShootHitStatCollector");
static_assert(sizeof(UGzShootHitStatCollector) == 0x000038, "Wrong size on UGzShootHitStatCollector");

// Class G01.GzPlayerState
// 0x0338 (0x0690 - 0x0358)
class AGzPlayerState : public APlayerState
{
public:
	uint8                                         Pad_2FF1[0x20];                                    // 0x0358(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	FMulticastInlineDelegateProperty_             OnPlayerNameChanged;                               // 0x0378(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnConnectionChanged;                               // 0x0388(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnTeamChanged;                                     // 0x0398(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnPlayerAliveStateChanged;                         // 0x03A8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnComebackArenaStateChanged;                       // 0x03B8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnReadyStateChanged;                               // 0x03C8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnWorldInstanceIdChanged;                          // 0x03D8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnRespawnTimeChanged;                              // 0x03E8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnCustomizationProfileChanged;                     // 0x03F8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnRedeploymentCountChanged;                        // 0x0408(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnPlayerSubscriptionOrClanTagChange;               // 0x0418(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnStoredInGameCurrencyChange;                      // 0x0428(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	class FString                                 ConsolePlayerId;                                   // 0x0438(0x0010)(ZeroConstructor, Transient, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         StoredInGameCurrencyQuantity;                      // 0x0448(0x0004)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2FF2[0x4];                                     // 0x044C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 PlayFabId;                                         // 0x0450(0x0010)(Net, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FString                                 TitleAccountId;                                    // 0x0460(0x0010)(Net, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FString                                 EpicProductUserId;                                 // 0x0470(0x0010)(Net, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         FactionId;                                         // 0x0480(0x0004)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2FF3[0x4];                                     // 0x0484(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class AGzTeam*                                Team;                                              // 0x0488(0x0008)(Net, ZeroConstructor, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	EGzAliveState                                 AliveState;                                        // 0x0490(0x0001)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	EGzConnectionState                            ConnectionState;                                   // 0x0491(0x0001)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	EGzComebackArenaCandidateState                ComebackArenaState;                                // 0x0492(0x0001)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2FF4[0x1];                                     // 0x0493(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	uint32                                        WorldInstanceId;                                   // 0x0494(0x0004)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         bReadyToStart : 1;                                 // 0x0498(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Net, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate))
	uint8                                         Pad_2FF5[0x3];                                     // 0x0499(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         ComebackArenaSecondChances;                        // 0x049C(0x0004)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         RedeploymentCount;                                 // 0x04A0(0x0004)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         RespawnTime;                                       // 0x04A4(0x0004)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         InitialRespawnTime;                                // 0x04A8(0x0004)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         QuickOrderDroneAvailableTime;                      // 0x04AC(0x0004)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         OldRespawnTime;                                    // 0x04B0(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         PreMatchStartTime;                                 // 0x04B4(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FGzCharacterCustomizationProfile       CustomizationProfile;                              // 0x04B8(0x0150)(Net, Transient, RepNotify, NativeAccessSpecifierPrivate)
	TArray<struct FGzExtractionData>              ActiveHexExtractions;                              // 0x0608(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	TArray<struct FGzInvItem>                     SpawnLoadout;                                      // 0x0618(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2FF6[0x30];                                    // 0x0628(0x0030)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 PlayerClanTag;                                     // 0x0658(0x0010)(Net, ZeroConstructor, RepNotify, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bPlayerSubscriptionIsValid;                        // 0x0668(0x0001)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2FF7[0x27];                                    // 0x0669(0x0027)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Client_NotifyConsoleUserInfos(const TArray<class FString>& InConsoleUserIds, const TArray<class FString>& InPlayFabIds);
	void OnPawnChanged(class APlayerState* Player, class APawn* NewPawn, class APawn* OldPawn);
	void OnRep_AliveState();
	void OnRep_ComebackArenaState();
	void OnRep_Connected();
	void OnRep_CustomizationProfile();
	void OnRep_PlayerClanTag();
	void OnRep_PlayerSubscriptionIsValid();
	void OnRep_RedeployedCount();
	void OnRep_RespawnTime();
	void OnRep_StoredInGameCurrencyQuantity();
	void OnRep_Team();
	void OnRep_WorldInstanceId();
	void Server_QueryConsoleUserIds(const TArray<class FString>& InPlayFabIds);
	void Server_SaveConsoleUserId(const class FString& InPlayfabId, const class FString& InConsoleUserId);
	void SetPreMatchStartTime(const float InTime);

	const class FName GetBackendCharacterId() const;
	EGzComebackArenaCandidateState GetComebackArenaState() const;
	EGzConnectionState GetConnectionState() const;
	const struct FGzCharacterCustomizationProfile GetCustomizationProfile() const;
	class FString GetEpicProductUserId() const;
	const struct FGzFaction GetFaction() const;
	int32 GetFactionId() const;
	struct FGenericTeamId GetGenericTeamId() const;
	float GetInitialRespawnTime() const;
	float GetOldRespawnTime() const;
	EGzAliveState GetPlayerAliveState() const;
	class FString GetPlayerClanTag() const;
	bool GetPlayerSubscriptionIsValid() const;
	class FString GetPlayFabId() const;
	float GetQuickOrderDroneAvailableTime() const;
	int32 GetRedeploymentCost() const;
	int32 GetRedeploymentCount() const;
	float GetRespawnTime() const;
	class FString GetSessionTeamId() const;
	int32 GetStoredInGameCurrencyQuantity() const;
	class AGzTeam* GetTeam() const;
	int32 GetTeamId() const;
	class FString GetTitleAccountId() const;
	bool HasLeftMatch() const;
	bool IsConnected() const;
	bool IsInComebackArena() const;
	bool IsInComebackArenaQueue() const;
	bool IsInMatch() const;
	bool IsReadyToStart() const;
	bool IsSecondChanceAvailable() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzPlayerState">();
	}
	static class AGzPlayerState* GetDefaultObj()
	{
		return GetDefaultObjImpl<AGzPlayerState>();
	}
};
static_assert(alignof(AGzPlayerState) == 0x000008, "Wrong alignment on AGzPlayerState");
static_assert(sizeof(AGzPlayerState) == 0x000690, "Wrong size on AGzPlayerState");
static_assert(offsetof(AGzPlayerState, OnPlayerNameChanged) == 0x000378, "Member 'AGzPlayerState::OnPlayerNameChanged' has a wrong offset!");
static_assert(offsetof(AGzPlayerState, OnConnectionChanged) == 0x000388, "Member 'AGzPlayerState::OnConnectionChanged' has a wrong offset!");
static_assert(offsetof(AGzPlayerState, OnTeamChanged) == 0x000398, "Member 'AGzPlayerState::OnTeamChanged' has a wrong offset!");
static_assert(offsetof(AGzPlayerState, OnPlayerAliveStateChanged) == 0x0003A8, "Member 'AGzPlayerState::OnPlayerAliveStateChanged' has a wrong offset!");
static_assert(offsetof(AGzPlayerState, OnComebackArenaStateChanged) == 0x0003B8, "Member 'AGzPlayerState::OnComebackArenaStateChanged' has a wrong offset!");
static_assert(offsetof(AGzPlayerState, OnReadyStateChanged) == 0x0003C8, "Member 'AGzPlayerState::OnReadyStateChanged' has a wrong offset!");
static_assert(offsetof(AGzPlayerState, OnWorldInstanceIdChanged) == 0x0003D8, "Member 'AGzPlayerState::OnWorldInstanceIdChanged' has a wrong offset!");
static_assert(offsetof(AGzPlayerState, OnRespawnTimeChanged) == 0x0003E8, "Member 'AGzPlayerState::OnRespawnTimeChanged' has a wrong offset!");
static_assert(offsetof(AGzPlayerState, OnCustomizationProfileChanged) == 0x0003F8, "Member 'AGzPlayerState::OnCustomizationProfileChanged' has a wrong offset!");
static_assert(offsetof(AGzPlayerState, OnRedeploymentCountChanged) == 0x000408, "Member 'AGzPlayerState::OnRedeploymentCountChanged' has a wrong offset!");
static_assert(offsetof(AGzPlayerState, OnPlayerSubscriptionOrClanTagChange) == 0x000418, "Member 'AGzPlayerState::OnPlayerSubscriptionOrClanTagChange' has a wrong offset!");
static_assert(offsetof(AGzPlayerState, OnStoredInGameCurrencyChange) == 0x000428, "Member 'AGzPlayerState::OnStoredInGameCurrencyChange' has a wrong offset!");
static_assert(offsetof(AGzPlayerState, ConsolePlayerId) == 0x000438, "Member 'AGzPlayerState::ConsolePlayerId' has a wrong offset!");
static_assert(offsetof(AGzPlayerState, StoredInGameCurrencyQuantity) == 0x000448, "Member 'AGzPlayerState::StoredInGameCurrencyQuantity' has a wrong offset!");
static_assert(offsetof(AGzPlayerState, PlayFabId) == 0x000450, "Member 'AGzPlayerState::PlayFabId' has a wrong offset!");
static_assert(offsetof(AGzPlayerState, TitleAccountId) == 0x000460, "Member 'AGzPlayerState::TitleAccountId' has a wrong offset!");
static_assert(offsetof(AGzPlayerState, EpicProductUserId) == 0x000470, "Member 'AGzPlayerState::EpicProductUserId' has a wrong offset!");
static_assert(offsetof(AGzPlayerState, FactionId) == 0x000480, "Member 'AGzPlayerState::FactionId' has a wrong offset!");
static_assert(offsetof(AGzPlayerState, Team) == 0x000488, "Member 'AGzPlayerState::Team' has a wrong offset!");
static_assert(offsetof(AGzPlayerState, AliveState) == 0x000490, "Member 'AGzPlayerState::AliveState' has a wrong offset!");
static_assert(offsetof(AGzPlayerState, ConnectionState) == 0x000491, "Member 'AGzPlayerState::ConnectionState' has a wrong offset!");
static_assert(offsetof(AGzPlayerState, ComebackArenaState) == 0x000492, "Member 'AGzPlayerState::ComebackArenaState' has a wrong offset!");
static_assert(offsetof(AGzPlayerState, WorldInstanceId) == 0x000494, "Member 'AGzPlayerState::WorldInstanceId' has a wrong offset!");
static_assert(offsetof(AGzPlayerState, ComebackArenaSecondChances) == 0x00049C, "Member 'AGzPlayerState::ComebackArenaSecondChances' has a wrong offset!");
static_assert(offsetof(AGzPlayerState, RedeploymentCount) == 0x0004A0, "Member 'AGzPlayerState::RedeploymentCount' has a wrong offset!");
static_assert(offsetof(AGzPlayerState, RespawnTime) == 0x0004A4, "Member 'AGzPlayerState::RespawnTime' has a wrong offset!");
static_assert(offsetof(AGzPlayerState, InitialRespawnTime) == 0x0004A8, "Member 'AGzPlayerState::InitialRespawnTime' has a wrong offset!");
static_assert(offsetof(AGzPlayerState, QuickOrderDroneAvailableTime) == 0x0004AC, "Member 'AGzPlayerState::QuickOrderDroneAvailableTime' has a wrong offset!");
static_assert(offsetof(AGzPlayerState, OldRespawnTime) == 0x0004B0, "Member 'AGzPlayerState::OldRespawnTime' has a wrong offset!");
static_assert(offsetof(AGzPlayerState, PreMatchStartTime) == 0x0004B4, "Member 'AGzPlayerState::PreMatchStartTime' has a wrong offset!");
static_assert(offsetof(AGzPlayerState, CustomizationProfile) == 0x0004B8, "Member 'AGzPlayerState::CustomizationProfile' has a wrong offset!");
static_assert(offsetof(AGzPlayerState, ActiveHexExtractions) == 0x000608, "Member 'AGzPlayerState::ActiveHexExtractions' has a wrong offset!");
static_assert(offsetof(AGzPlayerState, SpawnLoadout) == 0x000618, "Member 'AGzPlayerState::SpawnLoadout' has a wrong offset!");
static_assert(offsetof(AGzPlayerState, PlayerClanTag) == 0x000658, "Member 'AGzPlayerState::PlayerClanTag' has a wrong offset!");
static_assert(offsetof(AGzPlayerState, bPlayerSubscriptionIsValid) == 0x000668, "Member 'AGzPlayerState::bPlayerSubscriptionIsValid' has a wrong offset!");

// Class G01.GzBattleRoyalePlayerState
// 0x0000 (0x0690 - 0x0690)
class AGzBattleRoyalePlayerState final : public AGzPlayerState
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzBattleRoyalePlayerState">();
	}
	static class AGzBattleRoyalePlayerState* GetDefaultObj()
	{
		return GetDefaultObjImpl<AGzBattleRoyalePlayerState>();
	}
};
static_assert(alignof(AGzBattleRoyalePlayerState) == 0x000008, "Wrong alignment on AGzBattleRoyalePlayerState");
static_assert(sizeof(AGzBattleRoyalePlayerState) == 0x000690, "Wrong size on AGzBattleRoyalePlayerState");

// Class G01.GzGameModeSettings
// 0x0078 (0x00A8 - 0x0030)
class UGzGameModeSettings : public UPrimaryDataAsset
{
public:
	TArray<TSubclassOf<class UGameplayEffect>>    PlayerStartupEffects;                              // 0x0030(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, UObjectWrapper, NativeAccessSpecifierPrivate)
	class UGzStatsProfile*                        StatsProfile;                                      // 0x0040(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FGzRuleSet                             DefaultGameRules;                                  // 0x0048(0x0040)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	TArray<class UDataLayerAsset*>                EnabledDataLayers;                                 // 0x0088(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	TArray<class UDataLayerAsset*>                DisabledDataLayers;                                // 0x0098(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzGameModeSettings">();
	}
	static class UGzGameModeSettings* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzGameModeSettings>();
	}
};
static_assert(alignof(UGzGameModeSettings) == 0x000008, "Wrong alignment on UGzGameModeSettings");
static_assert(sizeof(UGzGameModeSettings) == 0x0000A8, "Wrong size on UGzGameModeSettings");
static_assert(offsetof(UGzGameModeSettings, PlayerStartupEffects) == 0x000030, "Member 'UGzGameModeSettings::PlayerStartupEffects' has a wrong offset!");
static_assert(offsetof(UGzGameModeSettings, StatsProfile) == 0x000040, "Member 'UGzGameModeSettings::StatsProfile' has a wrong offset!");
static_assert(offsetof(UGzGameModeSettings, DefaultGameRules) == 0x000048, "Member 'UGzGameModeSettings::DefaultGameRules' has a wrong offset!");
static_assert(offsetof(UGzGameModeSettings, EnabledDataLayers) == 0x000088, "Member 'UGzGameModeSettings::EnabledDataLayers' has a wrong offset!");
static_assert(offsetof(UGzGameModeSettings, DisabledDataLayers) == 0x000098, "Member 'UGzGameModeSettings::DisabledDataLayers' has a wrong offset!");

// Class G01.GzCheatMissionService
// 0x0000 (0x00A0 - 0x00A0)
class UGzCheatMissionService final : public UGzClientPFObject
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzCheatMissionService">();
	}
	static class UGzCheatMissionService* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzCheatMissionService>();
	}
};
static_assert(alignof(UGzCheatMissionService) == 0x000008, "Wrong alignment on UGzCheatMissionService");
static_assert(sizeof(UGzCheatMissionService) == 0x0000A0, "Wrong size on UGzCheatMissionService");

// Class G01.GzSessionGameModeSettings
// 0x00C8 (0x0170 - 0x00A8)
class UGzSessionGameModeSettings : public UGzGameModeSettings
{
public:
	int32                                         MaxPlayerCount;                                    // 0x00A8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGzTeamSettings                        TeamSettings;                                      // 0x00AC(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	float                                         MinRespawnDelay;                                   // 0x00BC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         KillMarkDuration;                                  // 0x00C0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AssistMarkDuration;                                // 0x00C4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PreMatchLootLifetime;                              // 0x00C8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MatchLootLifetime;                                 // 0x00CC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DeadCharacterLifetime;                             // 0x00D0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSpectateAnyone;                                   // 0x00D4(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUpdateOnlyLocalViewTargetKiller;                  // 0x00D5(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2FF8[0x2];                                     // 0x00D6(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	class UGzDeliveryTransportSettings*           DeliveryTransportSettingsOverride;                 // 0x00D8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         QuickOrderCooldown;                                // 0x00E0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CurrencyKeepPercent;                               // 0x00E4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FScalableFloat                         RedeploymentCostLevels;                            // 0x00E8(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	bool                                          bAllowReconnect;                                   // 0x0110(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2FF9[0x7];                                     // 0x0111(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<EGzItemRarity, struct FGzHexExtractionSettings> HexExtractionSettings;                             // 0x0118(0x0050)(Edit, NativeAccessSpecifierPrivate)
	bool                                          bKillPlayerOnLeave;                                // 0x0168(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2FFA[0x7];                                     // 0x0169(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	bool CanReconnect() const;
	struct FGzHexExtractionSettings GetHexExtractionSetting(EGzItemRarity ItemRarity) const;
	float GetRedeploymentCostAtLevel(int32 Level) const;
	bool ShouldKillPlayerOnLeave() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzSessionGameModeSettings">();
	}
	static class UGzSessionGameModeSettings* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzSessionGameModeSettings>();
	}
};
static_assert(alignof(UGzSessionGameModeSettings) == 0x000008, "Wrong alignment on UGzSessionGameModeSettings");
static_assert(sizeof(UGzSessionGameModeSettings) == 0x000170, "Wrong size on UGzSessionGameModeSettings");
static_assert(offsetof(UGzSessionGameModeSettings, MaxPlayerCount) == 0x0000A8, "Member 'UGzSessionGameModeSettings::MaxPlayerCount' has a wrong offset!");
static_assert(offsetof(UGzSessionGameModeSettings, TeamSettings) == 0x0000AC, "Member 'UGzSessionGameModeSettings::TeamSettings' has a wrong offset!");
static_assert(offsetof(UGzSessionGameModeSettings, MinRespawnDelay) == 0x0000BC, "Member 'UGzSessionGameModeSettings::MinRespawnDelay' has a wrong offset!");
static_assert(offsetof(UGzSessionGameModeSettings, KillMarkDuration) == 0x0000C0, "Member 'UGzSessionGameModeSettings::KillMarkDuration' has a wrong offset!");
static_assert(offsetof(UGzSessionGameModeSettings, AssistMarkDuration) == 0x0000C4, "Member 'UGzSessionGameModeSettings::AssistMarkDuration' has a wrong offset!");
static_assert(offsetof(UGzSessionGameModeSettings, PreMatchLootLifetime) == 0x0000C8, "Member 'UGzSessionGameModeSettings::PreMatchLootLifetime' has a wrong offset!");
static_assert(offsetof(UGzSessionGameModeSettings, MatchLootLifetime) == 0x0000CC, "Member 'UGzSessionGameModeSettings::MatchLootLifetime' has a wrong offset!");
static_assert(offsetof(UGzSessionGameModeSettings, DeadCharacterLifetime) == 0x0000D0, "Member 'UGzSessionGameModeSettings::DeadCharacterLifetime' has a wrong offset!");
static_assert(offsetof(UGzSessionGameModeSettings, bSpectateAnyone) == 0x0000D4, "Member 'UGzSessionGameModeSettings::bSpectateAnyone' has a wrong offset!");
static_assert(offsetof(UGzSessionGameModeSettings, bUpdateOnlyLocalViewTargetKiller) == 0x0000D5, "Member 'UGzSessionGameModeSettings::bUpdateOnlyLocalViewTargetKiller' has a wrong offset!");
static_assert(offsetof(UGzSessionGameModeSettings, DeliveryTransportSettingsOverride) == 0x0000D8, "Member 'UGzSessionGameModeSettings::DeliveryTransportSettingsOverride' has a wrong offset!");
static_assert(offsetof(UGzSessionGameModeSettings, QuickOrderCooldown) == 0x0000E0, "Member 'UGzSessionGameModeSettings::QuickOrderCooldown' has a wrong offset!");
static_assert(offsetof(UGzSessionGameModeSettings, CurrencyKeepPercent) == 0x0000E4, "Member 'UGzSessionGameModeSettings::CurrencyKeepPercent' has a wrong offset!");
static_assert(offsetof(UGzSessionGameModeSettings, RedeploymentCostLevels) == 0x0000E8, "Member 'UGzSessionGameModeSettings::RedeploymentCostLevels' has a wrong offset!");
static_assert(offsetof(UGzSessionGameModeSettings, bAllowReconnect) == 0x000110, "Member 'UGzSessionGameModeSettings::bAllowReconnect' has a wrong offset!");
static_assert(offsetof(UGzSessionGameModeSettings, HexExtractionSettings) == 0x000118, "Member 'UGzSessionGameModeSettings::HexExtractionSettings' has a wrong offset!");
static_assert(offsetof(UGzSessionGameModeSettings, bKillPlayerOnLeave) == 0x000168, "Member 'UGzSessionGameModeSettings::bKillPlayerOnLeave' has a wrong offset!");

// Class G01.GzBattleRoyaleSettings
// 0x00C0 (0x0230 - 0x0170)
class UGzBattleRoyaleSettings final : public UGzSessionGameModeSettings
{
public:
	float                                         MatchStartCountdownDuration;                       // 0x0170(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PostMatchDuration;                                 // 0x0174(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          RespawnPlayers;                                    // 0x0178(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         EnableRespawnAfterZoneActivation : 1;              // 0x0179(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_2FFC[0x2];                                     // 0x017A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         PlayerRespawnDelay;                                // 0x017C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinRespawnDistanceToEnemy;                         // 0x0180(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ServerIdleDelay;                                   // 0x0184(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AbortMatchDelay;                                   // 0x0188(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bDeploymentFromPlaneActive : 1;                    // 0x018C(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_2FFD[0x3];                                     // 0x018D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftClassPtr<class UClass>                   DeploymentTransportClass;                          // 0x0190(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftClassPtr<class UClass>                   DeploymentPawnClass;                               // 0x01B8(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         NumberOfDeploymentTransport;                       // 0x01E0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   OverrideDeploymentPathSetName;                     // 0x01E4(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         RequiredPlayerCountToStartTimer;                   // 0x01EC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         RequiredPlayerCountToStartMatch;                   // 0x01F0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PreMatchCountdownTimer;                            // 0x01F4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PostLoadoutSelectionTimer;                         // 0x01F8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         RandomZonesCount;                                  // 0x01FC(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShowLoadoutSelection;                             // 0x01FD(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EGzComebackArenaAvailability                  ComebackArenaAvailability;                         // 0x01FE(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         ComebackArenaOpponentsNumber;                      // 0x01FF(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         MaxComebackArenasNumber;                           // 0x0200(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         NumberOfSecondChances;                             // 0x0201(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bEndMatchWhenLastTeamLeft : 1;                     // 0x0202(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bAutoZoneOverloadEnabled : 1;                      // 0x0202(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_2FFE[0x1];                                     // 0x0203(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	struct FFloatRange                            TimeToStartAutoOverload;                           // 0x0204(0x0010)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FInt32Range                            TeamCountToStartAutoOverload;                      // 0x0214(0x0010)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         RedeploymentCost;                                  // 0x0224(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         RedeploymentIncrementalCostFactor;                 // 0x0228(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2FFF[0x4];                                     // 0x022C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzBattleRoyaleSettings">();
	}
	static class UGzBattleRoyaleSettings* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzBattleRoyaleSettings>();
	}
};
static_assert(alignof(UGzBattleRoyaleSettings) == 0x000008, "Wrong alignment on UGzBattleRoyaleSettings");
static_assert(sizeof(UGzBattleRoyaleSettings) == 0x000230, "Wrong size on UGzBattleRoyaleSettings");
static_assert(offsetof(UGzBattleRoyaleSettings, MatchStartCountdownDuration) == 0x000170, "Member 'UGzBattleRoyaleSettings::MatchStartCountdownDuration' has a wrong offset!");
static_assert(offsetof(UGzBattleRoyaleSettings, PostMatchDuration) == 0x000174, "Member 'UGzBattleRoyaleSettings::PostMatchDuration' has a wrong offset!");
static_assert(offsetof(UGzBattleRoyaleSettings, RespawnPlayers) == 0x000178, "Member 'UGzBattleRoyaleSettings::RespawnPlayers' has a wrong offset!");
static_assert(offsetof(UGzBattleRoyaleSettings, PlayerRespawnDelay) == 0x00017C, "Member 'UGzBattleRoyaleSettings::PlayerRespawnDelay' has a wrong offset!");
static_assert(offsetof(UGzBattleRoyaleSettings, MinRespawnDistanceToEnemy) == 0x000180, "Member 'UGzBattleRoyaleSettings::MinRespawnDistanceToEnemy' has a wrong offset!");
static_assert(offsetof(UGzBattleRoyaleSettings, ServerIdleDelay) == 0x000184, "Member 'UGzBattleRoyaleSettings::ServerIdleDelay' has a wrong offset!");
static_assert(offsetof(UGzBattleRoyaleSettings, AbortMatchDelay) == 0x000188, "Member 'UGzBattleRoyaleSettings::AbortMatchDelay' has a wrong offset!");
static_assert(offsetof(UGzBattleRoyaleSettings, DeploymentTransportClass) == 0x000190, "Member 'UGzBattleRoyaleSettings::DeploymentTransportClass' has a wrong offset!");
static_assert(offsetof(UGzBattleRoyaleSettings, DeploymentPawnClass) == 0x0001B8, "Member 'UGzBattleRoyaleSettings::DeploymentPawnClass' has a wrong offset!");
static_assert(offsetof(UGzBattleRoyaleSettings, NumberOfDeploymentTransport) == 0x0001E0, "Member 'UGzBattleRoyaleSettings::NumberOfDeploymentTransport' has a wrong offset!");
static_assert(offsetof(UGzBattleRoyaleSettings, OverrideDeploymentPathSetName) == 0x0001E4, "Member 'UGzBattleRoyaleSettings::OverrideDeploymentPathSetName' has a wrong offset!");
static_assert(offsetof(UGzBattleRoyaleSettings, RequiredPlayerCountToStartTimer) == 0x0001EC, "Member 'UGzBattleRoyaleSettings::RequiredPlayerCountToStartTimer' has a wrong offset!");
static_assert(offsetof(UGzBattleRoyaleSettings, RequiredPlayerCountToStartMatch) == 0x0001F0, "Member 'UGzBattleRoyaleSettings::RequiredPlayerCountToStartMatch' has a wrong offset!");
static_assert(offsetof(UGzBattleRoyaleSettings, PreMatchCountdownTimer) == 0x0001F4, "Member 'UGzBattleRoyaleSettings::PreMatchCountdownTimer' has a wrong offset!");
static_assert(offsetof(UGzBattleRoyaleSettings, PostLoadoutSelectionTimer) == 0x0001F8, "Member 'UGzBattleRoyaleSettings::PostLoadoutSelectionTimer' has a wrong offset!");
static_assert(offsetof(UGzBattleRoyaleSettings, RandomZonesCount) == 0x0001FC, "Member 'UGzBattleRoyaleSettings::RandomZonesCount' has a wrong offset!");
static_assert(offsetof(UGzBattleRoyaleSettings, bShowLoadoutSelection) == 0x0001FD, "Member 'UGzBattleRoyaleSettings::bShowLoadoutSelection' has a wrong offset!");
static_assert(offsetof(UGzBattleRoyaleSettings, ComebackArenaAvailability) == 0x0001FE, "Member 'UGzBattleRoyaleSettings::ComebackArenaAvailability' has a wrong offset!");
static_assert(offsetof(UGzBattleRoyaleSettings, ComebackArenaOpponentsNumber) == 0x0001FF, "Member 'UGzBattleRoyaleSettings::ComebackArenaOpponentsNumber' has a wrong offset!");
static_assert(offsetof(UGzBattleRoyaleSettings, MaxComebackArenasNumber) == 0x000200, "Member 'UGzBattleRoyaleSettings::MaxComebackArenasNumber' has a wrong offset!");
static_assert(offsetof(UGzBattleRoyaleSettings, NumberOfSecondChances) == 0x000201, "Member 'UGzBattleRoyaleSettings::NumberOfSecondChances' has a wrong offset!");
static_assert(offsetof(UGzBattleRoyaleSettings, TimeToStartAutoOverload) == 0x000204, "Member 'UGzBattleRoyaleSettings::TimeToStartAutoOverload' has a wrong offset!");
static_assert(offsetof(UGzBattleRoyaleSettings, TeamCountToStartAutoOverload) == 0x000214, "Member 'UGzBattleRoyaleSettings::TeamCountToStartAutoOverload' has a wrong offset!");
static_assert(offsetof(UGzBattleRoyaleSettings, RedeploymentCost) == 0x000224, "Member 'UGzBattleRoyaleSettings::RedeploymentCost' has a wrong offset!");
static_assert(offsetof(UGzBattleRoyaleSettings, RedeploymentIncrementalCostFactor) == 0x000228, "Member 'UGzBattleRoyaleSettings::RedeploymentIncrementalCostFactor' has a wrong offset!");

// Class G01.GzGA_Zipline
// 0x0060 (0x05B0 - 0x0550)
class UGzGA_Zipline : public UGzGA_CharacterState
{
public:
	struct FGzInputMappingContextInfo             CancelZiplineMappingContextInfo;                   // 0x0550(0x0010)(Edit, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	float                                         CancelInputDelay;                                  // 0x0560(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ZiplineInputPriority;                              // 0x0564(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimMontage*                           FinishZiplineMontage;                              // 0x0568(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimMontage*                           ManualCancelZiplineMontage;                        // 0x0570(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimMontage*                           ForcedCancelZiplineMontage;                        // 0x0578(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UGzAT_WaitCustomInputPress*             WaitForCancelInput_AbilityTask;                    // 0x0580(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UGzAT_PlayMontageAndWaitForEvent*       PlayJumpOffMontage_AbilityTask;                    // 0x0588(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UGzAT_PlayMontageAndWaitForEvent*       PlayLandingMontage_AbilityTask;                    // 0x0590(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FGameplayTag                           RequiredOngoingLimb;                               // 0x0598(0x0008)(BlueprintVisible, BlueprintReadOnly, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3000[0x10];                                    // 0x05A0(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnJumpOffFromCancelFinished();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzGA_Zipline">();
	}
	static class UGzGA_Zipline* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzGA_Zipline>();
	}
};
static_assert(alignof(UGzGA_Zipline) == 0x000008, "Wrong alignment on UGzGA_Zipline");
static_assert(sizeof(UGzGA_Zipline) == 0x0005B0, "Wrong size on UGzGA_Zipline");
static_assert(offsetof(UGzGA_Zipline, CancelZiplineMappingContextInfo) == 0x000550, "Member 'UGzGA_Zipline::CancelZiplineMappingContextInfo' has a wrong offset!");
static_assert(offsetof(UGzGA_Zipline, CancelInputDelay) == 0x000560, "Member 'UGzGA_Zipline::CancelInputDelay' has a wrong offset!");
static_assert(offsetof(UGzGA_Zipline, ZiplineInputPriority) == 0x000564, "Member 'UGzGA_Zipline::ZiplineInputPriority' has a wrong offset!");
static_assert(offsetof(UGzGA_Zipline, FinishZiplineMontage) == 0x000568, "Member 'UGzGA_Zipline::FinishZiplineMontage' has a wrong offset!");
static_assert(offsetof(UGzGA_Zipline, ManualCancelZiplineMontage) == 0x000570, "Member 'UGzGA_Zipline::ManualCancelZiplineMontage' has a wrong offset!");
static_assert(offsetof(UGzGA_Zipline, ForcedCancelZiplineMontage) == 0x000578, "Member 'UGzGA_Zipline::ForcedCancelZiplineMontage' has a wrong offset!");
static_assert(offsetof(UGzGA_Zipline, WaitForCancelInput_AbilityTask) == 0x000580, "Member 'UGzGA_Zipline::WaitForCancelInput_AbilityTask' has a wrong offset!");
static_assert(offsetof(UGzGA_Zipline, PlayJumpOffMontage_AbilityTask) == 0x000588, "Member 'UGzGA_Zipline::PlayJumpOffMontage_AbilityTask' has a wrong offset!");
static_assert(offsetof(UGzGA_Zipline, PlayLandingMontage_AbilityTask) == 0x000590, "Member 'UGzGA_Zipline::PlayLandingMontage_AbilityTask' has a wrong offset!");
static_assert(offsetof(UGzGA_Zipline, RequiredOngoingLimb) == 0x000598, "Member 'UGzGA_Zipline::RequiredOngoingLimb' has a wrong offset!");

// Class G01.GzCIT_Hair
// 0x0000 (0x0450 - 0x0450)
class UGzCIT_Hair final : public UGzCustomizationItemTemplate
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzCIT_Hair">();
	}
	static class UGzCIT_Hair* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzCIT_Hair>();
	}
};
static_assert(alignof(UGzCIT_Hair) == 0x000008, "Wrong alignment on UGzCIT_Hair");
static_assert(sizeof(UGzCIT_Hair) == 0x000450, "Wrong size on UGzCIT_Hair");

// Class G01.GzBattleRoyaleZone
// 0x00C0 (0x0360 - 0x02A0)
class AGzBattleRoyaleZone : public AActor
{
public:
	FMulticastInlineDelegateProperty_             OnOverloadStartTimeChanged;                        // 0x02A0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TArray<struct FVector>                        LandingZones;                                      // 0x02B0(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnRadiusUpdatedEvent;                              // 0x02C0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_3001[0x18];                                    // 0x02D0(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         Weight;                                            // 0x02E8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_3002[0x4];                                     // 0x02EC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UMaterialInterface*                     ZoneMaterial;                                      // 0x02F0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         MinHeight;                                         // 0x02F8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         MaxHeight;                                         // 0x02FC(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         InterpolationPointsPerUnit;                        // 0x0300(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         MinInterpolationPoints;                            // 0x0304(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         MaxInterpolationPoints;                            // 0x0308(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_3003[0x4];                                     // 0x030C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UGzWorldZone*                           CachedWorldZone;                                   // 0x0310(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class AGzBattleRoyaleZoneManager*             ZoneManager;                                       // 0x0318(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UProceduralMeshComponent*               ZoneMesh;                                          // 0x0320(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FGzOverloadData                        OverloadData;                                      // 0x0328(0x000C)(Net, RepNotify, NoDestructor, NativeAccessSpecifierPrivate)
	int32                                         LandingZoneIndex;                                  // 0x0334(0x0004)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         OverloadStartTime;                                 // 0x0338(0x0004)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_3004[0x24];                                    // 0x033C(0x0024)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void GzOnRadiusUpdated__DelegateSignature(float NewRadius);
	void NotifyOverloadComplete();
	void NotifyOverloadStart();
	void OnRep_OverloadData();
	void OverloadExpanding();
	void OverloadShrinking();
	void ReceiveOnOverloadDataUpdate();
	void ReceiveOnOverloadEnd();
	void ReceiveOnOverloadStart();
	void ReceiveOverloadRestart();
	void ResetOverload();
	void SetOverloadPaused(bool bPaused);

	float GetCurrentRadius() const;
	struct FVector2D GetLandingZoneOrigin() const;
	float GetOverloadStartTime() const;
	EGzZoneOverloadState GetOverloadState() const;
	struct FVector2D GetZoneCenter() const;
	int32 GetZoneIndex() const;
	class FName GetZoneName() const;
	struct FVector2D GetZoneOrigin() const;
	void GetZonePoints(TArray<struct FVector2D>* ZonePoints) const;
	class FText GetZoneText() const;
	bool IsFullyOverloaded() const;
	bool IsInOverloadedZone(const struct FVector2D& Position) const;
	bool IsInOverloadingZoneRadius(const struct FVector2D& Position) const;
	bool IsOverloading() const;
	bool IsOverloadStarted() const;
	bool IsShrinking() const;
	void OnRep_OverloadStartTime() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzBattleRoyaleZone">();
	}
	static class AGzBattleRoyaleZone* GetDefaultObj()
	{
		return GetDefaultObjImpl<AGzBattleRoyaleZone>();
	}
};
static_assert(alignof(AGzBattleRoyaleZone) == 0x000008, "Wrong alignment on AGzBattleRoyaleZone");
static_assert(sizeof(AGzBattleRoyaleZone) == 0x000360, "Wrong size on AGzBattleRoyaleZone");
static_assert(offsetof(AGzBattleRoyaleZone, OnOverloadStartTimeChanged) == 0x0002A0, "Member 'AGzBattleRoyaleZone::OnOverloadStartTimeChanged' has a wrong offset!");
static_assert(offsetof(AGzBattleRoyaleZone, LandingZones) == 0x0002B0, "Member 'AGzBattleRoyaleZone::LandingZones' has a wrong offset!");
static_assert(offsetof(AGzBattleRoyaleZone, OnRadiusUpdatedEvent) == 0x0002C0, "Member 'AGzBattleRoyaleZone::OnRadiusUpdatedEvent' has a wrong offset!");
static_assert(offsetof(AGzBattleRoyaleZone, Weight) == 0x0002E8, "Member 'AGzBattleRoyaleZone::Weight' has a wrong offset!");
static_assert(offsetof(AGzBattleRoyaleZone, ZoneMaterial) == 0x0002F0, "Member 'AGzBattleRoyaleZone::ZoneMaterial' has a wrong offset!");
static_assert(offsetof(AGzBattleRoyaleZone, MinHeight) == 0x0002F8, "Member 'AGzBattleRoyaleZone::MinHeight' has a wrong offset!");
static_assert(offsetof(AGzBattleRoyaleZone, MaxHeight) == 0x0002FC, "Member 'AGzBattleRoyaleZone::MaxHeight' has a wrong offset!");
static_assert(offsetof(AGzBattleRoyaleZone, InterpolationPointsPerUnit) == 0x000300, "Member 'AGzBattleRoyaleZone::InterpolationPointsPerUnit' has a wrong offset!");
static_assert(offsetof(AGzBattleRoyaleZone, MinInterpolationPoints) == 0x000304, "Member 'AGzBattleRoyaleZone::MinInterpolationPoints' has a wrong offset!");
static_assert(offsetof(AGzBattleRoyaleZone, MaxInterpolationPoints) == 0x000308, "Member 'AGzBattleRoyaleZone::MaxInterpolationPoints' has a wrong offset!");
static_assert(offsetof(AGzBattleRoyaleZone, CachedWorldZone) == 0x000310, "Member 'AGzBattleRoyaleZone::CachedWorldZone' has a wrong offset!");
static_assert(offsetof(AGzBattleRoyaleZone, ZoneManager) == 0x000318, "Member 'AGzBattleRoyaleZone::ZoneManager' has a wrong offset!");
static_assert(offsetof(AGzBattleRoyaleZone, ZoneMesh) == 0x000320, "Member 'AGzBattleRoyaleZone::ZoneMesh' has a wrong offset!");
static_assert(offsetof(AGzBattleRoyaleZone, OverloadData) == 0x000328, "Member 'AGzBattleRoyaleZone::OverloadData' has a wrong offset!");
static_assert(offsetof(AGzBattleRoyaleZone, LandingZoneIndex) == 0x000334, "Member 'AGzBattleRoyaleZone::LandingZoneIndex' has a wrong offset!");
static_assert(offsetof(AGzBattleRoyaleZone, OverloadStartTime) == 0x000338, "Member 'AGzBattleRoyaleZone::OverloadStartTime' has a wrong offset!");

// Class G01.GzBattleRoyaleZoneCheatExtension
// 0x0000 (0x0028 - 0x0028)
class UGzBattleRoyaleZoneCheatExtension final : public UGzCheatManagerExtension
{
public:
	void OverloadZone(const class FString& ZoneName) const;
	void ResetOverload() const;
	void ResetZone(const class FString& ZoneName) const;
	void SelectLastZoneAndStartOverload(const class FString& ZoneName, const int32 LandingZoneIndex) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzBattleRoyaleZoneCheatExtension">();
	}
	static class UGzBattleRoyaleZoneCheatExtension* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzBattleRoyaleZoneCheatExtension>();
	}
};
static_assert(alignof(UGzBattleRoyaleZoneCheatExtension) == 0x000008, "Wrong alignment on UGzBattleRoyaleZoneCheatExtension");
static_assert(sizeof(UGzBattleRoyaleZoneCheatExtension) == 0x000028, "Wrong size on UGzBattleRoyaleZoneCheatExtension");

// Class G01.GzInventoryCheatExtension
// 0x0000 (0x0028 - 0x0028)
class UGzInventoryCheatExtension final : public UGzCheatManagerExtension
{
public:
	void AddAttachmentToActiveWeapon(const class FString& AttachmentItemName);
	void AddBackpack(const class FString& BackpackName);
	void AddConsumableWithQuantity(const class FString& ItemName, int32 Quantity);
	void AddContainerItem(const class FString& ItemName);
	void AddMiscItem(const class FString& ItemName);
	void AddMiscItemWithQuantity(const class FString& ItemName, int32 Quantity);
	void ApplySkinForActiveWeapon(const class FString& SkinItemName);
	void ApplySkinForLimb(int32 LimbType, const class FString& SkinItemName);
	void DropCurrentWeapon();
	void RemoveAttachmentFromActiveWeapon(const class FString& AttachmentTypeStr);
	void RemoveSkinFromActiveWeapon();
	void RemoveSkinFromLimb(int32 LimbType);
	void SaveInventoryForRespawn();
	void ShowEquippedItems();

	void PrintInventoryItems() const;
	void ShowAllAttachments() const;
	void ShowAllConsumables() const;
	void ShowAllCyberLimbs() const;
	void ShowAllMiscItems() const;
	void ShowAllWeapons() const;
	void ShowCurrentSkinForActiveWeapon() const;
	void ShowSuitableAttachmentsOfTypeForActiveWeapon(const class FString& AttachmentTypeStr) const;
	void ShowSuitableSkinsForActiveWeapon() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzInventoryCheatExtension">();
	}
	static class UGzInventoryCheatExtension* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzInventoryCheatExtension>();
	}
};
static_assert(alignof(UGzInventoryCheatExtension) == 0x000008, "Wrong alignment on UGzInventoryCheatExtension");
static_assert(sizeof(UGzInventoryCheatExtension) == 0x000028, "Wrong size on UGzInventoryCheatExtension");

// Class G01.GzPingableComponent
// 0x0030 (0x00D8 - 0x00A8)
class UGzPingableComponent : public UActorComponent
{
public:
	EGzPingTarget                                 PingTargetType;                                    // 0x00A8(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_300B[0x7];                                     // 0x00A9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                MarkerOffset;                                      // 0x00B0(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FGameplayTag                           MarkerTypeToApply;                                 // 0x00C8(0x0008)(Edit, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class AGzPingTooltipActor>        TooltipPingActorClass;                             // 0x00D0(0x0008)(Edit, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzPingableComponent">();
	}
	static class UGzPingableComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzPingableComponent>();
	}
};
static_assert(alignof(UGzPingableComponent) == 0x000008, "Wrong alignment on UGzPingableComponent");
static_assert(sizeof(UGzPingableComponent) == 0x0000D8, "Wrong size on UGzPingableComponent");
static_assert(offsetof(UGzPingableComponent, PingTargetType) == 0x0000A8, "Member 'UGzPingableComponent::PingTargetType' has a wrong offset!");
static_assert(offsetof(UGzPingableComponent, MarkerOffset) == 0x0000B0, "Member 'UGzPingableComponent::MarkerOffset' has a wrong offset!");
static_assert(offsetof(UGzPingableComponent, MarkerTypeToApply) == 0x0000C8, "Member 'UGzPingableComponent::MarkerTypeToApply' has a wrong offset!");
static_assert(offsetof(UGzPingableComponent, TooltipPingActorClass) == 0x0000D0, "Member 'UGzPingableComponent::TooltipPingActorClass' has a wrong offset!");

// Class G01.GzCharacterPingableComponent
// 0x0000 (0x00D8 - 0x00D8)
class UGzCharacterPingableComponent final : public UGzPingableComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzCharacterPingableComponent">();
	}
	static class UGzCharacterPingableComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzCharacterPingableComponent>();
	}
};
static_assert(alignof(UGzCharacterPingableComponent) == 0x000008, "Wrong alignment on UGzCharacterPingableComponent");
static_assert(sizeof(UGzCharacterPingableComponent) == 0x0000D8, "Wrong size on UGzCharacterPingableComponent");

// Class G01.GzSceneManager
// 0x0288 (0x0528 - 0x02A0)
class AGzSceneManager final : public AActor
{
public:
	uint8                                         Pad_300C[0x18];                                    // 0x02A0(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	FMulticastInlineDelegateProperty_             OnSceneEnterBP;                                    // 0x02B8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnSceneLeaveBP;                                    // 0x02C8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnSceneUpdateBP;                                   // 0x02D8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	struct FGameplayTag                           Tag;                                               // 0x02E8(0x0008)(Edit, DisableEditOnTemplate, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TMap<struct FGameplayTag, struct FInstancedStruct> Setups;                                            // 0x02F0(0x0050)(Edit, DisableEditOnTemplate, NativeAccessSpecifierPrivate)
	TArray<struct FGzSceneTransitionSetup>        Transitions;                                       // 0x0340(0x0010)(Edit, ZeroConstructor, DisableEditOnTemplate, NativeAccessSpecifierPrivate)
	uint8                                         Pad_300D[0x1B8];                                   // 0x0350(0x01B8)(Fixing Size After Last Property [ Dumper-7 ])
	class AGzViewpointManager*                    ViewpointManager;                                  // 0x0508(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UGzWeaponSpawner*                       WeaponSpawner;                                     // 0x0510(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class AGzDatacubeDecoder*                     DatacubeDecoder;                                   // 0x0518(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UGzScenePuppeteer*                      ScenePuppeteer;                                    // 0x0520(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void GzSceneChangedDynamic__DelegateSignature(const struct FGameplayTag& SceneTag, const struct FGzSceneChangedEventData& EventData);
	void GzSceneUpdatedDynamic__DelegateSignature(const struct FGameplayTag& SceneTag, const struct FGzSceneChangedEventData& EventData);

	const struct FGzSceneTransitionParameters GetTransitionParameters(const struct FGameplayTag& From, const struct FGameplayTag& To) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzSceneManager">();
	}
	static class AGzSceneManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<AGzSceneManager>();
	}
};
static_assert(alignof(AGzSceneManager) == 0x000008, "Wrong alignment on AGzSceneManager");
static_assert(sizeof(AGzSceneManager) == 0x000528, "Wrong size on AGzSceneManager");
static_assert(offsetof(AGzSceneManager, OnSceneEnterBP) == 0x0002B8, "Member 'AGzSceneManager::OnSceneEnterBP' has a wrong offset!");
static_assert(offsetof(AGzSceneManager, OnSceneLeaveBP) == 0x0002C8, "Member 'AGzSceneManager::OnSceneLeaveBP' has a wrong offset!");
static_assert(offsetof(AGzSceneManager, OnSceneUpdateBP) == 0x0002D8, "Member 'AGzSceneManager::OnSceneUpdateBP' has a wrong offset!");
static_assert(offsetof(AGzSceneManager, Tag) == 0x0002E8, "Member 'AGzSceneManager::Tag' has a wrong offset!");
static_assert(offsetof(AGzSceneManager, Setups) == 0x0002F0, "Member 'AGzSceneManager::Setups' has a wrong offset!");
static_assert(offsetof(AGzSceneManager, Transitions) == 0x000340, "Member 'AGzSceneManager::Transitions' has a wrong offset!");
static_assert(offsetof(AGzSceneManager, ViewpointManager) == 0x000508, "Member 'AGzSceneManager::ViewpointManager' has a wrong offset!");
static_assert(offsetof(AGzSceneManager, WeaponSpawner) == 0x000510, "Member 'AGzSceneManager::WeaponSpawner' has a wrong offset!");
static_assert(offsetof(AGzSceneManager, DatacubeDecoder) == 0x000518, "Member 'AGzSceneManager::DatacubeDecoder' has a wrong offset!");
static_assert(offsetof(AGzSceneManager, ScenePuppeteer) == 0x000520, "Member 'AGzSceneManager::ScenePuppeteer' has a wrong offset!");

// Class G01.GzBattleRoyaleZoneManager
// 0x00F8 (0x0398 - 0x02A0)
class AGzBattleRoyaleZoneManager : public AInfo
{
public:
	uint8                                         Pad_300E[0x8];                                     // 0x02A0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         LandingZoneRadius;                                 // 0x02A8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_300F[0x4];                                     // 0x02AC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class AGzBattleRoyaleZone*>            Zones;                                             // 0x02B0(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnGlobalOverloadActivated;                         // 0x02C0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnZoneActivated;                                   // 0x02D0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnStageChanged;                                    // 0x02E0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	class UGzZoneSelectionPolicy*                 ZoneSelectionPolicy;                               // 0x02F0(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, PersistentInstance, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<struct FGzOverloadStage>               Stages;                                            // 0x02F8(0x0010)(Edit, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	int32                                         NumberOfAvailableLastZones;                        // 0x0308(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         NumberOfAvailableLandingZones;                     // 0x030C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<struct FGzZoneSelectionData>           AvailableZoneData;                                 // 0x0310(0x0010)(Net, ZeroConstructor, NativeAccessSpecifierPrivate)
	struct FGzOverloadStageData                   CurrentStageData;                                  // 0x0320(0x0008)(Net, RepNotify, NoDestructor, NativeAccessSpecifierPrivate)
	uint8                                         Pad_3010[0x10];                                    // 0x0328(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UGzZoneTrackingComponent*>       TrackedComponents;                                 // 0x0338(0x0010)(ExportObject, ZeroConstructor, Transient, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	TMap<class AGzBattleRoyaleZone*, struct FGzTrackingComponentCache> StaticTrackedComponentCache;                       // 0x0348(0x0050)(Transient, ContainsInstancedReference, NativeAccessSpecifierPrivate)

public:
	static class AGzBattleRoyaleZoneManager* Instance(class UObject* WorldContextObject);

	void OnRep_CurrentStageData();
	void ResetLastOverloadedZone();
	void SelectLastOverloadedZoneByName(const class FName& SelectedZoneName, const int32 SelectedLastZoneIndex, const int32 SelectedZonePlayerID);

	float ExpandZone(float CurrentRadius, float MaxExpansionRadius, float DeltaTime) const;
	TArray<struct FGzZoneSelectionData> GetAvailableLastZoneData() const;
	int32 GetCurrentStageIndex() const;
	class AGzBattleRoyaleZone* GetLastOverloadedZone() const;
	float GetOverloadTime() const;
	float GetOverloadWaitPeriodTime() const;
	int32 GetPlayerActivatedOverload() const;
	float GetWaitPeriodEndTime() const;
	class AGzBattleRoyaleZone* GetZoneByPosition(const struct FVector& Position) const;
	int32 GetZoneCount() const;
	bool IsInAnyOverloadedZone(const struct FVector& Position) const;
	bool IsInOverloadedZoneRadius(class AGzBattleRoyaleZone* Zone, const struct FVector& Position) const;
	bool IsOverloadStarted() const;
	float ShrinkZone(float CurrentRadius, float MaxExpansionRadius, float DeltaTime) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzBattleRoyaleZoneManager">();
	}
	static class AGzBattleRoyaleZoneManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<AGzBattleRoyaleZoneManager>();
	}
};
static_assert(alignof(AGzBattleRoyaleZoneManager) == 0x000008, "Wrong alignment on AGzBattleRoyaleZoneManager");
static_assert(sizeof(AGzBattleRoyaleZoneManager) == 0x000398, "Wrong size on AGzBattleRoyaleZoneManager");
static_assert(offsetof(AGzBattleRoyaleZoneManager, LandingZoneRadius) == 0x0002A8, "Member 'AGzBattleRoyaleZoneManager::LandingZoneRadius' has a wrong offset!");
static_assert(offsetof(AGzBattleRoyaleZoneManager, Zones) == 0x0002B0, "Member 'AGzBattleRoyaleZoneManager::Zones' has a wrong offset!");
static_assert(offsetof(AGzBattleRoyaleZoneManager, OnGlobalOverloadActivated) == 0x0002C0, "Member 'AGzBattleRoyaleZoneManager::OnGlobalOverloadActivated' has a wrong offset!");
static_assert(offsetof(AGzBattleRoyaleZoneManager, OnZoneActivated) == 0x0002D0, "Member 'AGzBattleRoyaleZoneManager::OnZoneActivated' has a wrong offset!");
static_assert(offsetof(AGzBattleRoyaleZoneManager, OnStageChanged) == 0x0002E0, "Member 'AGzBattleRoyaleZoneManager::OnStageChanged' has a wrong offset!");
static_assert(offsetof(AGzBattleRoyaleZoneManager, ZoneSelectionPolicy) == 0x0002F0, "Member 'AGzBattleRoyaleZoneManager::ZoneSelectionPolicy' has a wrong offset!");
static_assert(offsetof(AGzBattleRoyaleZoneManager, Stages) == 0x0002F8, "Member 'AGzBattleRoyaleZoneManager::Stages' has a wrong offset!");
static_assert(offsetof(AGzBattleRoyaleZoneManager, NumberOfAvailableLastZones) == 0x000308, "Member 'AGzBattleRoyaleZoneManager::NumberOfAvailableLastZones' has a wrong offset!");
static_assert(offsetof(AGzBattleRoyaleZoneManager, NumberOfAvailableLandingZones) == 0x00030C, "Member 'AGzBattleRoyaleZoneManager::NumberOfAvailableLandingZones' has a wrong offset!");
static_assert(offsetof(AGzBattleRoyaleZoneManager, AvailableZoneData) == 0x000310, "Member 'AGzBattleRoyaleZoneManager::AvailableZoneData' has a wrong offset!");
static_assert(offsetof(AGzBattleRoyaleZoneManager, CurrentStageData) == 0x000320, "Member 'AGzBattleRoyaleZoneManager::CurrentStageData' has a wrong offset!");
static_assert(offsetof(AGzBattleRoyaleZoneManager, TrackedComponents) == 0x000338, "Member 'AGzBattleRoyaleZoneManager::TrackedComponents' has a wrong offset!");
static_assert(offsetof(AGzBattleRoyaleZoneManager, StaticTrackedComponentCache) == 0x000348, "Member 'AGzBattleRoyaleZoneManager::StaticTrackedComponentCache' has a wrong offset!");

// Class G01.GzTrainCar
// 0x0038 (0x02D8 - 0x02A0)
class AGzTrainCar final : public AActor
{
public:
	class USceneComponent*                        FirstAttachment;                                   // 0x02A0(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USceneComponent*                        SecondAttachment;                                  // 0x02A8(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3013[0x8];                                     // 0x02B0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class AGzTrack*                               ParentTrack;                                       // 0x02B8(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_3014[0x18];                                    // 0x02C0(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzTrainCar">();
	}
	static class AGzTrainCar* GetDefaultObj()
	{
		return GetDefaultObjImpl<AGzTrainCar>();
	}
};
static_assert(alignof(AGzTrainCar) == 0x000008, "Wrong alignment on AGzTrainCar");
static_assert(sizeof(AGzTrainCar) == 0x0002D8, "Wrong size on AGzTrainCar");
static_assert(offsetof(AGzTrainCar, FirstAttachment) == 0x0002A0, "Member 'AGzTrainCar::FirstAttachment' has a wrong offset!");
static_assert(offsetof(AGzTrainCar, SecondAttachment) == 0x0002A8, "Member 'AGzTrainCar::SecondAttachment' has a wrong offset!");
static_assert(offsetof(AGzTrainCar, ParentTrack) == 0x0002B8, "Member 'AGzTrainCar::ParentTrack' has a wrong offset!");

// Class G01.GzLoadoutSelectionComponent
// 0x0038 (0x00E0 - 0x00A8)
class UGzLoadoutSelectionComponent final : public UActorComponent
{
public:
	FMulticastInlineDelegateProperty_             OnLoadoutAvailabilityChanged;                      // 0x00A8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnLoadoutGiven;                                    // 0x00B8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	int32                                         MaxLoadoutGiveCount;                               // 0x00C8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3015[0x4];                                     // 0x00CC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<int32>                                 LoadoutGrantedPlayerIds;                           // 0x00D0(0x0010)(Net, ZeroConstructor, RepNotify, Protected, NativeAccessSpecifierProtected)

public:
	void TryGiveLoadout(class AGzCharacter* Player, const struct FGuid& LoadoutGuid);

	bool CanGiveLoadout(const class AGzCharacter* Player) const;
	void OnRep_LoadoutGrantedPlayerIds(const TArray<int32>& OldLoadoutGrantedPlayerIds) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzLoadoutSelectionComponent">();
	}
	static class UGzLoadoutSelectionComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzLoadoutSelectionComponent>();
	}
};
static_assert(alignof(UGzLoadoutSelectionComponent) == 0x000008, "Wrong alignment on UGzLoadoutSelectionComponent");
static_assert(sizeof(UGzLoadoutSelectionComponent) == 0x0000E0, "Wrong size on UGzLoadoutSelectionComponent");
static_assert(offsetof(UGzLoadoutSelectionComponent, OnLoadoutAvailabilityChanged) == 0x0000A8, "Member 'UGzLoadoutSelectionComponent::OnLoadoutAvailabilityChanged' has a wrong offset!");
static_assert(offsetof(UGzLoadoutSelectionComponent, OnLoadoutGiven) == 0x0000B8, "Member 'UGzLoadoutSelectionComponent::OnLoadoutGiven' has a wrong offset!");
static_assert(offsetof(UGzLoadoutSelectionComponent, MaxLoadoutGiveCount) == 0x0000C8, "Member 'UGzLoadoutSelectionComponent::MaxLoadoutGiveCount' has a wrong offset!");
static_assert(offsetof(UGzLoadoutSelectionComponent, LoadoutGrantedPlayerIds) == 0x0000D0, "Member 'UGzLoadoutSelectionComponent::LoadoutGrantedPlayerIds' has a wrong offset!");

// Class G01.GzBeaconHost
// 0x0000 (0x02C8 - 0x02C8)
class AGzBeaconHost final : public AOnlineBeaconHostObject
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzBeaconHost">();
	}
	static class AGzBeaconHost* GetDefaultObj()
	{
		return GetDefaultObjImpl<AGzBeaconHost>();
	}
};
static_assert(alignof(AGzBeaconHost) == 0x000008, "Wrong alignment on AGzBeaconHost");
static_assert(sizeof(AGzBeaconHost) == 0x0002C8, "Wrong size on AGzBeaconHost");

// Class G01.GzCallRedeployStatsCollector
// 0x0018 (0x0050 - 0x0038)
class UGzCallRedeployStatsCollector final : public UGzGlobalStatsCollector
{
public:
	uint8                                         Pad_3017[0x8];                                     // 0x0038(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<int32>                                 TeamIds;                                           // 0x0040(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzCallRedeployStatsCollector">();
	}
	static class UGzCallRedeployStatsCollector* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzCallRedeployStatsCollector>();
	}
};
static_assert(alignof(UGzCallRedeployStatsCollector) == 0x000008, "Wrong alignment on UGzCallRedeployStatsCollector");
static_assert(sizeof(UGzCallRedeployStatsCollector) == 0x000050, "Wrong size on UGzCallRedeployStatsCollector");
static_assert(offsetof(UGzCallRedeployStatsCollector, TeamIds) == 0x000040, "Member 'UGzCallRedeployStatsCollector::TeamIds' has a wrong offset!");

// Class G01.GzBlackboardCoverData
// 0x00A0 (0x00C8 - 0x0028)
class UGzBlackboardCoverData final : public UObject
{
public:
	struct FGzCoverData                           CoverData;                                         // 0x0028(0x0088)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UWorld*                                 World;                                             // 0x00B0(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3018[0x8];                                     // 0x00B8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UGzCoversComponent*                     CachedCoverComponent;                              // 0x00C0(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void FreeCover();

	bool HasData() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzBlackboardCoverData">();
	}
	static class UGzBlackboardCoverData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzBlackboardCoverData>();
	}
};
static_assert(alignof(UGzBlackboardCoverData) == 0x000008, "Wrong alignment on UGzBlackboardCoverData");
static_assert(sizeof(UGzBlackboardCoverData) == 0x0000C8, "Wrong size on UGzBlackboardCoverData");
static_assert(offsetof(UGzBlackboardCoverData, CoverData) == 0x000028, "Member 'UGzBlackboardCoverData::CoverData' has a wrong offset!");
static_assert(offsetof(UGzBlackboardCoverData, World) == 0x0000B0, "Member 'UGzBlackboardCoverData::World' has a wrong offset!");
static_assert(offsetof(UGzBlackboardCoverData, CachedCoverComponent) == 0x0000C0, "Member 'UGzBlackboardCoverData::CachedCoverComponent' has a wrong offset!");

// Class G01.GzLobbyGameModeBase
// 0x0000 (0x0470 - 0x0470)
class AGzLobbyGameModeBase final : public AGzGameModeBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzLobbyGameModeBase">();
	}
	static class AGzLobbyGameModeBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<AGzLobbyGameModeBase>();
	}
};
static_assert(alignof(AGzLobbyGameModeBase) == 0x000008, "Wrong alignment on AGzLobbyGameModeBase");
static_assert(sizeof(AGzLobbyGameModeBase) == 0x000470, "Wrong size on AGzLobbyGameModeBase");

// Class G01.GzBlacklistService
// 0x0010 (0x00B0 - 0x00A0)
class UGzBlacklistService final : public UGzClientPFObject
{
public:
	uint8                                         Pad_3019[0x10];                                    // 0x00A0(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzBlacklistService">();
	}
	static class UGzBlacklistService* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzBlacklistService>();
	}
};
static_assert(alignof(UGzBlacklistService) == 0x000008, "Wrong alignment on UGzBlacklistService");
static_assert(sizeof(UGzBlacklistService) == 0x0000B0, "Wrong size on UGzBlacklistService");

// Class G01.GzMarkerShape
// 0x0010 (0x0038 - 0x0028)
class UGzMarkerShape : public UObject
{
public:
	FMulticastInlineDelegateProperty_             OnMarkerShapeChanged;                              // 0x0028(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzMarkerShape">();
	}
	static class UGzMarkerShape* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzMarkerShape>();
	}
};
static_assert(alignof(UGzMarkerShape) == 0x000008, "Wrong alignment on UGzMarkerShape");
static_assert(sizeof(UGzMarkerShape) == 0x000038, "Wrong size on UGzMarkerShape");
static_assert(offsetof(UGzMarkerShape, OnMarkerShapeChanged) == 0x000028, "Member 'UGzMarkerShape::OnMarkerShapeChanged' has a wrong offset!");

// Class G01.GzBlueprintCVarHelper
// 0x0040 (0x0068 - 0x0028)
class UGzBlueprintCVarHelper final : public UObject
{
public:
	uint8                                         Pad_301A[0x40];                                    // 0x0028(0x0040)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetCVarName(const class FString& NewName);
	void SetValue(const class FString& NewValue);

	class FString GetCVarName() const;
	TArray<class FString> GetDesciptionMultiline() const;
	class FString GetDescription() const;
	class FString GetValue() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzBlueprintCVarHelper">();
	}
	static class UGzBlueprintCVarHelper* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzBlueprintCVarHelper>();
	}
};
static_assert(alignof(UGzBlueprintCVarHelper) == 0x000008, "Wrong alignment on UGzBlueprintCVarHelper");
static_assert(sizeof(UGzBlueprintCVarHelper) == 0x000068, "Wrong size on UGzBlueprintCVarHelper");

// Class G01.GzBlueprintFunctionLibrary
// 0x0000 (0x0028 - 0x0028)
class UGzBlueprintFunctionLibrary final : public UBlueprintFunctionLibrary
{
public:
	static void BindObjectInputDelegates(class UObject* ObjectBindTo, const class APawn* Pawn);
	static bool CanSpectateSomebodyElse(class AGzPlayerController* Viewer);
	static class FString CircleAsString(const struct FGzCircle2D& Circle);
	static void ClearStencilValue(const class AActor* Actor);
	static void ConvertWorldLocationToWidgetPositionWithScale(const struct FVector& WorldLocation, const struct FVector& WorldOrigin, float GameplayArea, float ScaleFactor, struct FVector2D* WidgetPosition);
	static bool DoesSupportRayTracing();
	static struct FGameplayTagContainer FilterGameplayTagContainer(const struct FGameplayTagContainer& Container, const struct FGameplayTagContainer& OtherContainer, const bool bFilterExact);
	static struct FGzAttachmentPoint FindClosestBone(class AActor* ActorPtr, const struct FVector& ImpactPoint);
	static const class AGzAIInfo* GetAiInfo(const class UObject* WorldContextObject, int32 AiId);
	static class AGzAIManager* GetAiManager(const class UObject* WorldContextObject);
	static int64 GetChangelistBuiltFrom();
	static class FString GetConsoleAccountId();
	static int64 GetEnumMaxValue(const class UEnum* Enum);
	static int64 GetEnumValueByNameString(const class UEnum* Enum, const class FString& Param_Name);
	static class AGzPlayerController* GetFirstLocalPlayerController(const class UObject* WorldContextObject);
	static class UGzGameUserSettings* GetGameUserSettings();
	static class UGzLimbUIActivationSubsystem* GetLimbUIActivationSubsystem(const class UObject* WorldContextObject);
	static class FString GetNameStringByEnumValue(const class UEnum* Enum, int64 Value);
	static float GetNetworkLag(class UObject* WorldContextObject);
	static class APawn* GetPawnByCharacterId(const class UObject* WorldContextObject, class AActor* CharacterIdInterfaceActor);
	static class APawn* GetPawnById(const class UObject* WorldContextObject, const struct FGzAdvancedIdType& ID);
	static class AGzPlayerState* GetPersistentPlayerState(const class APawn* Pawn);
	static EGzPlatformMasks GetPlatformMasks();
	static class APlayerController* GetPlayerController(const class UObject* WorldContextObject, int32 PlayerId);
	static class UGzPostProcessControllerComponent* GetPlayerPostProcessControllerComponent(const class UObject* WorldContextObject);
	static class AGzPlayerState* GetPlayerState(const class UObject* WorldContextObject, int32 PlayerId);
	static float GetRandomDeviationFloat(float Value, float Deviation);
	static float GetSignedAngle(const struct FVector2D& A, const struct FVector2D& B);
	static EDepthStencilValue GetStencilValue(class UPrimitiveComponent* Component);
	static void GetTimeMinutesSeconds(float InSeconds, float* OutMinutes, float* OutSeconds);
	static const class UGzUISettings* GetUIDeveloperSettings();
	static class AGzWorldSettings* GetWorldSettings(const class UObject* WorldContextObject);
	static bool IsAlive(const class AActor* TargetActor);
	static bool IsConsole();
	static bool IsCoverValid(class AActor* ObserverActor, class AActor* TargetActor, const struct FVector& CoverLocation);
	static bool IsLocalViewTarget(const class APawn* InPawn);
	static bool IsPeerToPeer(class UObject* WorldContextObject);
	static bool IsPointInCircle(const struct FVector2D& Point, const struct FGzCircle2D& Circle);
	static bool IsPointInPolygon(const struct FVector2D& Point, const TArray<struct FVector2D>& PolygonBorder);
	static bool IsSameLocalPlayerTeamId(const class UObject* WorldContextObject, const int32 CallerTeamId);
	static bool IsShipping();
	static bool IsSpectatedViewTarget(const class APawn* InPawn);
	static bool IsWatermarkEnabled();
	static void RefreshCharactersVisibilityStates(class UObject* WorldContext);
	static void SetInputMode(const class UObject* WorldContextObject, EGzInputMode InputMode, class UWidget* WidgetToFocus);
	static void SetStencilValue(const class AActor* Actor, EDepthStencilValue Value, bool bWriteInCustomDepthOnZeroStencil);
	static bool ShouldShowComparisonTooltip();
	static void SpawnNSAtTransformsWithDelay(class UObject* WorldContextObject, const struct FTransform& WorldTransform, const struct FGzDelayedVFXSpawnData& DelayedVFXSpawnData);
	static void StartListening(class UObject* WorldContextObject, int32 Port);
	static bool SupportsQualityMode();
	static bool TriggerEquipWeaponAtSlot(class APawn* Character, const struct FGameplayTag& PocketSlot);
	static void UnbindObjectInputDelegates(class UObject* BindingOwner, const class APawn* Pawn);
	static void UnsetConsoleVariable(const class FString& ConsoleVariableToUnset);
	static float WorldRotationToAzimuth(const struct FRotator& WorldRotation);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzBlueprintFunctionLibrary">();
	}
	static class UGzBlueprintFunctionLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzBlueprintFunctionLibrary>();
	}
};
static_assert(alignof(UGzBlueprintFunctionLibrary) == 0x000008, "Wrong alignment on UGzBlueprintFunctionLibrary");
static_assert(sizeof(UGzBlueprintFunctionLibrary) == 0x000028, "Wrong size on UGzBlueprintFunctionLibrary");

// Class G01.GzLoadoutListQuickOrder
// 0x0010 (0x0478 - 0x0468)
class UGzLoadoutListQuickOrder : public UGzLoadoutListSingleTab
{
public:
	uint8                                         Pad_3032[0x10];                                    // 0x0468(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzLoadoutListQuickOrder">();
	}
	static class UGzLoadoutListQuickOrder* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzLoadoutListQuickOrder>();
	}
};
static_assert(alignof(UGzLoadoutListQuickOrder) == 0x000008, "Wrong alignment on UGzLoadoutListQuickOrder");
static_assert(sizeof(UGzLoadoutListQuickOrder) == 0x000478, "Wrong size on UGzLoadoutListQuickOrder");

// Class G01.GzCameraOverlayModeDataAsset
// 0x0210 (0x0240 - 0x0030)
class UGzCameraOverlayModeDataAsset : public UDataAsset
{
public:
	struct FGameplayTag                           CameraModeTag;                                     // 0x0030(0x0008)(Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEnableLocationSettings;                           // 0x0038(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EGzCameraModeOverlay                          LocationSettingsApplyMode;                         // 0x0039(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3033[0x6];                                     // 0x003A(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	struct FATPCLocationSettings                  LocationSettings;                                  // 0x0040(0x00D0)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          bEnableRotationSettings;                           // 0x0110(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3034[0x7];                                     // 0x0111(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FATPCRotationSettings                  RotationSettings;                                  // 0x0118(0x0100)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	bool                                          bEnableFOVSettings;                                // 0x0218(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3035[0x7];                                     // 0x0219(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FATPCFOVSettings                       FOVSettings;                                       // 0x0220(0x0018)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	float                                         MaxCompensateAngle;                                // 0x0238(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3036[0x4];                                     // 0x023C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzCameraOverlayModeDataAsset">();
	}
	static class UGzCameraOverlayModeDataAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzCameraOverlayModeDataAsset>();
	}
};
static_assert(alignof(UGzCameraOverlayModeDataAsset) == 0x000008, "Wrong alignment on UGzCameraOverlayModeDataAsset");
static_assert(sizeof(UGzCameraOverlayModeDataAsset) == 0x000240, "Wrong size on UGzCameraOverlayModeDataAsset");
static_assert(offsetof(UGzCameraOverlayModeDataAsset, CameraModeTag) == 0x000030, "Member 'UGzCameraOverlayModeDataAsset::CameraModeTag' has a wrong offset!");
static_assert(offsetof(UGzCameraOverlayModeDataAsset, bEnableLocationSettings) == 0x000038, "Member 'UGzCameraOverlayModeDataAsset::bEnableLocationSettings' has a wrong offset!");
static_assert(offsetof(UGzCameraOverlayModeDataAsset, LocationSettingsApplyMode) == 0x000039, "Member 'UGzCameraOverlayModeDataAsset::LocationSettingsApplyMode' has a wrong offset!");
static_assert(offsetof(UGzCameraOverlayModeDataAsset, LocationSettings) == 0x000040, "Member 'UGzCameraOverlayModeDataAsset::LocationSettings' has a wrong offset!");
static_assert(offsetof(UGzCameraOverlayModeDataAsset, bEnableRotationSettings) == 0x000110, "Member 'UGzCameraOverlayModeDataAsset::bEnableRotationSettings' has a wrong offset!");
static_assert(offsetof(UGzCameraOverlayModeDataAsset, RotationSettings) == 0x000118, "Member 'UGzCameraOverlayModeDataAsset::RotationSettings' has a wrong offset!");
static_assert(offsetof(UGzCameraOverlayModeDataAsset, bEnableFOVSettings) == 0x000218, "Member 'UGzCameraOverlayModeDataAsset::bEnableFOVSettings' has a wrong offset!");
static_assert(offsetof(UGzCameraOverlayModeDataAsset, FOVSettings) == 0x000220, "Member 'UGzCameraOverlayModeDataAsset::FOVSettings' has a wrong offset!");
static_assert(offsetof(UGzCameraOverlayModeDataAsset, MaxCompensateAngle) == 0x000238, "Member 'UGzCameraOverlayModeDataAsset::MaxCompensateAngle' has a wrong offset!");

// Class G01.GzBodyCustomizationArchetype
// 0x0060 (0x0090 - 0x0030)
class UGzBodyCustomizationArchetype final : public UPrimaryDataAsset
{
public:
	uint8                                         Pad_3037[0x8];                                     // 0x0030(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UGzCIT_Torso*>                   TorsoOptions;                                      // 0x0038(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TArray<class UGzCIT_Head*>                    HeadOptions;                                       // 0x0048(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	class FString                                 DefaultHead;                                       // 0x0058(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 DefaultTorso;                                      // 0x0068(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class UGzCustomizationModifierTemplate*> BodyModifiers;                                     // 0x0078(0x0010)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, ContainsInstancedReference, NativeAccessSpecifierPublic)
	class UAkSwitchValue*                         VoiceTypeSwitch;                                   // 0x0088(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzBodyCustomizationArchetype">();
	}
	static class UGzBodyCustomizationArchetype* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzBodyCustomizationArchetype>();
	}
};
static_assert(alignof(UGzBodyCustomizationArchetype) == 0x000008, "Wrong alignment on UGzBodyCustomizationArchetype");
static_assert(sizeof(UGzBodyCustomizationArchetype) == 0x000090, "Wrong size on UGzBodyCustomizationArchetype");
static_assert(offsetof(UGzBodyCustomizationArchetype, TorsoOptions) == 0x000038, "Member 'UGzBodyCustomizationArchetype::TorsoOptions' has a wrong offset!");
static_assert(offsetof(UGzBodyCustomizationArchetype, HeadOptions) == 0x000048, "Member 'UGzBodyCustomizationArchetype::HeadOptions' has a wrong offset!");
static_assert(offsetof(UGzBodyCustomizationArchetype, DefaultHead) == 0x000058, "Member 'UGzBodyCustomizationArchetype::DefaultHead' has a wrong offset!");
static_assert(offsetof(UGzBodyCustomizationArchetype, DefaultTorso) == 0x000068, "Member 'UGzBodyCustomizationArchetype::DefaultTorso' has a wrong offset!");
static_assert(offsetof(UGzBodyCustomizationArchetype, BodyModifiers) == 0x000078, "Member 'UGzBodyCustomizationArchetype::BodyModifiers' has a wrong offset!");
static_assert(offsetof(UGzBodyCustomizationArchetype, VoiceTypeSwitch) == 0x000088, "Member 'UGzBodyCustomizationArchetype::VoiceTypeSwitch' has a wrong offset!");

// Class G01.GzInteractionCondition_Missions
// 0x0010 (0x0050 - 0x0040)
class UGzInteractionCondition_Missions final : public UGzInteractionCondition
{
public:
	TArray<class UMissionObjective*>              RegisteredObjectives;                              // 0x0040(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzInteractionCondition_Missions">();
	}
	static class UGzInteractionCondition_Missions* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzInteractionCondition_Missions>();
	}
};
static_assert(alignof(UGzInteractionCondition_Missions) == 0x000008, "Wrong alignment on UGzInteractionCondition_Missions");
static_assert(sizeof(UGzInteractionCondition_Missions) == 0x000050, "Wrong size on UGzInteractionCondition_Missions");
static_assert(offsetof(UGzInteractionCondition_Missions, RegisteredObjectives) == 0x000040, "Member 'UGzInteractionCondition_Missions::RegisteredObjectives' has a wrong offset!");

// Class G01.GzCheatChallengeService
// 0x0008 (0x00A8 - 0x00A0)
class UGzCheatChallengeService final : public UGzPlayFabObject
{
public:
	uint8                                         Pad_3038[0x8];                                     // 0x00A0(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzCheatChallengeService">();
	}
	static class UGzCheatChallengeService* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzCheatChallengeService>();
	}
};
static_assert(alignof(UGzCheatChallengeService) == 0x000008, "Wrong alignment on UGzCheatChallengeService");
static_assert(sizeof(UGzCheatChallengeService) == 0x0000A8, "Wrong size on UGzCheatChallengeService");

// Class G01.GzPropagationCollisionStrategy
// 0x0040 (0x0068 - 0x0028)
class UGzPropagationCollisionStrategy : public UObject
{
public:
	class UGzPropagationStrategy*                 PropagationStrategy;                               // 0x0028(0x0008)(ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UGzPropagationConfiguration*            Config;                                            // 0x0030(0x0008)(ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3039[0x30];                                    // 0x0038(0x0030)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzPropagationCollisionStrategy">();
	}
	static class UGzPropagationCollisionStrategy* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzPropagationCollisionStrategy>();
	}
};
static_assert(alignof(UGzPropagationCollisionStrategy) == 0x000008, "Wrong alignment on UGzPropagationCollisionStrategy");
static_assert(sizeof(UGzPropagationCollisionStrategy) == 0x000068, "Wrong size on UGzPropagationCollisionStrategy");
static_assert(offsetof(UGzPropagationCollisionStrategy, PropagationStrategy) == 0x000028, "Member 'UGzPropagationCollisionStrategy::PropagationStrategy' has a wrong offset!");
static_assert(offsetof(UGzPropagationCollisionStrategy, Config) == 0x000030, "Member 'UGzPropagationCollisionStrategy::Config' has a wrong offset!");

// Class G01.GzPropagationCollisionStrategy_DirectFromStart
// 0x0000 (0x0068 - 0x0068)
class UGzPropagationCollisionStrategy_DirectFromStart final : public UGzPropagationCollisionStrategy
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzPropagationCollisionStrategy_DirectFromStart">();
	}
	static class UGzPropagationCollisionStrategy_DirectFromStart* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzPropagationCollisionStrategy_DirectFromStart>();
	}
};
static_assert(alignof(UGzPropagationCollisionStrategy_DirectFromStart) == 0x000008, "Wrong alignment on UGzPropagationCollisionStrategy_DirectFromStart");
static_assert(sizeof(UGzPropagationCollisionStrategy_DirectFromStart) == 0x000068, "Wrong size on UGzPropagationCollisionStrategy_DirectFromStart");

// Class G01.GzTrackedPathsExtension
// 0x0050 (0x0088 - 0x0038)
class UGzTrackedPathsExtension final : public UGzMapWidgetExtension
{
public:
	TMap<class UGzPathTrackingComponent*, class UGzSplineMapWidget*> PathsWidgets;                                      // 0x0038(0x0050)(ExportObject, Transient, ContainsInstancedReference, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzTrackedPathsExtension">();
	}
	static class UGzTrackedPathsExtension* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzTrackedPathsExtension>();
	}
};
static_assert(alignof(UGzTrackedPathsExtension) == 0x000008, "Wrong alignment on UGzTrackedPathsExtension");
static_assert(sizeof(UGzTrackedPathsExtension) == 0x000088, "Wrong size on UGzTrackedPathsExtension");
static_assert(offsetof(UGzTrackedPathsExtension, PathsWidgets) == 0x000038, "Member 'UGzTrackedPathsExtension::PathsWidgets' has a wrong offset!");

// Class G01.GzJZ_PreMatchStage
// 0x0000 (0x0118 - 0x0118)
class UGzJZ_PreMatchStage final : public UGzPreMatchStage
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzJZ_PreMatchStage">();
	}
	static class UGzJZ_PreMatchStage* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzJZ_PreMatchStage>();
	}
};
static_assert(alignof(UGzJZ_PreMatchStage) == 0x000008, "Wrong alignment on UGzJZ_PreMatchStage");
static_assert(sizeof(UGzJZ_PreMatchStage) == 0x000118, "Wrong size on UGzJZ_PreMatchStage");

// Class G01.GzBodyPartAbilityData_ADrone
// 0x0008 (0x0088 - 0x0080)
class UGzBodyPartAbilityData_ADrone final : public UGzBodyPartAbilityData
{
public:
	int32                                         Level;                                             // 0x0080(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_303A[0x4];                                     // 0x0084(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzBodyPartAbilityData_ADrone">();
	}
	static class UGzBodyPartAbilityData_ADrone* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzBodyPartAbilityData_ADrone>();
	}
};
static_assert(alignof(UGzBodyPartAbilityData_ADrone) == 0x000008, "Wrong alignment on UGzBodyPartAbilityData_ADrone");
static_assert(sizeof(UGzBodyPartAbilityData_ADrone) == 0x000088, "Wrong size on UGzBodyPartAbilityData_ADrone");
static_assert(offsetof(UGzBodyPartAbilityData_ADrone, Level) == 0x000080, "Member 'UGzBodyPartAbilityData_ADrone::Level' has a wrong offset!");

// Class G01.GzCarTrackTransport
// 0x0110 (0x04C0 - 0x03B0)
class alignas(0x10) AGzCarTrackTransport : public AGzAutoTrackTransport
{
public:
	class USceneComponent*                        FrontAttachment;                                   // 0x03B0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USceneComponent*                        BackAttachment;                                    // 0x03B8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bAlignRootToAttachments;                           // 0x03C0(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_303B[0x7];                                     // 0x03C1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FSoftComponentReference                WheelsSkeletalMesh;                                // 0x03C8(0x0048)(Edit, DisableEditOnInstance, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<struct FGzWheelData>                   WheelsData;                                        // 0x0410(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	bool                                          bUseHighestWheelFromGroup;                         // 0x0420(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_303C[0x3];                                     // 0x0421(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         WheelRadius;                                       // 0x0424(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         SuspensionLength;                                  // 0x0428(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         SuspensionInterpolationTimeSeconds;                // 0x042C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_303D[0x4];                                     // 0x0430(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGzCarTrackTransportDebugger           Debugger;                                          // 0x0434(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, NativeAccessSpecifierPrivate)
	uint8                                         Pad_303E[0x8B];                                    // 0x0435(0x008B)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ReceiveCarTransformUpdated();

	const struct FTransform GetHullTransformLocal() const;
	const struct FTransform GetWheelTransform(int32 Param_Index) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzCarTrackTransport">();
	}
	static class AGzCarTrackTransport* GetDefaultObj()
	{
		return GetDefaultObjImpl<AGzCarTrackTransport>();
	}
};
static_assert(alignof(AGzCarTrackTransport) == 0x000010, "Wrong alignment on AGzCarTrackTransport");
static_assert(sizeof(AGzCarTrackTransport) == 0x0004C0, "Wrong size on AGzCarTrackTransport");
static_assert(offsetof(AGzCarTrackTransport, FrontAttachment) == 0x0003B0, "Member 'AGzCarTrackTransport::FrontAttachment' has a wrong offset!");
static_assert(offsetof(AGzCarTrackTransport, BackAttachment) == 0x0003B8, "Member 'AGzCarTrackTransport::BackAttachment' has a wrong offset!");
static_assert(offsetof(AGzCarTrackTransport, bAlignRootToAttachments) == 0x0003C0, "Member 'AGzCarTrackTransport::bAlignRootToAttachments' has a wrong offset!");
static_assert(offsetof(AGzCarTrackTransport, WheelsSkeletalMesh) == 0x0003C8, "Member 'AGzCarTrackTransport::WheelsSkeletalMesh' has a wrong offset!");
static_assert(offsetof(AGzCarTrackTransport, WheelsData) == 0x000410, "Member 'AGzCarTrackTransport::WheelsData' has a wrong offset!");
static_assert(offsetof(AGzCarTrackTransport, bUseHighestWheelFromGroup) == 0x000420, "Member 'AGzCarTrackTransport::bUseHighestWheelFromGroup' has a wrong offset!");
static_assert(offsetof(AGzCarTrackTransport, WheelRadius) == 0x000424, "Member 'AGzCarTrackTransport::WheelRadius' has a wrong offset!");
static_assert(offsetof(AGzCarTrackTransport, SuspensionLength) == 0x000428, "Member 'AGzCarTrackTransport::SuspensionLength' has a wrong offset!");
static_assert(offsetof(AGzCarTrackTransport, SuspensionInterpolationTimeSeconds) == 0x00042C, "Member 'AGzCarTrackTransport::SuspensionInterpolationTimeSeconds' has a wrong offset!");
static_assert(offsetof(AGzCarTrackTransport, Debugger) == 0x000434, "Member 'AGzCarTrackTransport::Debugger' has a wrong offset!");

// Class G01.GzBodyPartAbilityData_Barrier
// 0x0008 (0x0088 - 0x0080)
class UGzBodyPartAbilityData_Barrier final : public UGzBodyPartAbilityData
{
public:
	float                                         BarrierMaxHealth;                                  // 0x0080(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LifeSpan;                                          // 0x0084(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzBodyPartAbilityData_Barrier">();
	}
	static class UGzBodyPartAbilityData_Barrier* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzBodyPartAbilityData_Barrier>();
	}
};
static_assert(alignof(UGzBodyPartAbilityData_Barrier) == 0x000008, "Wrong alignment on UGzBodyPartAbilityData_Barrier");
static_assert(sizeof(UGzBodyPartAbilityData_Barrier) == 0x000088, "Wrong size on UGzBodyPartAbilityData_Barrier");
static_assert(offsetof(UGzBodyPartAbilityData_Barrier, BarrierMaxHealth) == 0x000080, "Member 'UGzBodyPartAbilityData_Barrier::BarrierMaxHealth' has a wrong offset!");
static_assert(offsetof(UGzBodyPartAbilityData_Barrier, LifeSpan) == 0x000084, "Member 'UGzBodyPartAbilityData_Barrier::LifeSpan' has a wrong offset!");

// Class G01.GzLimbUIActivationSubsystem
// 0x0098 (0x00C8 - 0x0030)
class UGzLimbUIActivationSubsystem final : public ULocalPlayerSubsystem
{
public:
	FMulticastInlineDelegateProperty_             OnStarted;                                         // 0x0030(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnUpdated;                                         // 0x0040(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnFinalValue;                                      // 0x0050(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnEnded;                                           // 0x0060(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	struct FGzLimbGaugeData                       CurrentActivationData;                             // 0x0070(0x0028)(Transient, NoDestructor, NativeAccessSpecifierPrivate)
	struct FGzLimbGaugeData                       InitialActivationData;                             // 0x0098(0x0028)(Transient, NoDestructor, NativeAccessSpecifierPrivate)
	class AGzHUDBase*                             TargetHUD;                                         // 0x00C0(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void EndActivation(EGzLimbType LimbType);
	void OnViewTargetChanged(class APawn* Pawn);
	void SetActivationValue(EGzLimbType LimbType, float NewValue);
	void StartActivation(EGzLimbType LimbType, const struct FGzLimbGaugeData& ActivationData);
	void UpdateActivationValue(EGzLimbType LimbType, float AddValue);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzLimbUIActivationSubsystem">();
	}
	static class UGzLimbUIActivationSubsystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzLimbUIActivationSubsystem>();
	}
};
static_assert(alignof(UGzLimbUIActivationSubsystem) == 0x000008, "Wrong alignment on UGzLimbUIActivationSubsystem");
static_assert(sizeof(UGzLimbUIActivationSubsystem) == 0x0000C8, "Wrong size on UGzLimbUIActivationSubsystem");
static_assert(offsetof(UGzLimbUIActivationSubsystem, OnStarted) == 0x000030, "Member 'UGzLimbUIActivationSubsystem::OnStarted' has a wrong offset!");
static_assert(offsetof(UGzLimbUIActivationSubsystem, OnUpdated) == 0x000040, "Member 'UGzLimbUIActivationSubsystem::OnUpdated' has a wrong offset!");
static_assert(offsetof(UGzLimbUIActivationSubsystem, OnFinalValue) == 0x000050, "Member 'UGzLimbUIActivationSubsystem::OnFinalValue' has a wrong offset!");
static_assert(offsetof(UGzLimbUIActivationSubsystem, OnEnded) == 0x000060, "Member 'UGzLimbUIActivationSubsystem::OnEnded' has a wrong offset!");
static_assert(offsetof(UGzLimbUIActivationSubsystem, CurrentActivationData) == 0x000070, "Member 'UGzLimbUIActivationSubsystem::CurrentActivationData' has a wrong offset!");
static_assert(offsetof(UGzLimbUIActivationSubsystem, InitialActivationData) == 0x000098, "Member 'UGzLimbUIActivationSubsystem::InitialActivationData' has a wrong offset!");
static_assert(offsetof(UGzLimbUIActivationSubsystem, TargetHUD) == 0x0000C0, "Member 'UGzLimbUIActivationSubsystem::TargetHUD' has a wrong offset!");

// Class G01.GzLaserAttachmentBehaviour
// 0x0068 (0x00A0 - 0x0038)
class UGzLaserAttachmentBehaviour : public UGzWeaponBehaviorAttachment
{
public:
	class UNiagaraSystem*                         LaserNiagara;                                      // 0x0038(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UNiagaraSystem*                         LaserNiagara_Lobby;                                // 0x0040(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UNiagaraComponent*                      Beam;                                              // 0x0048(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USpotLightComponent*                    SpotLight;                                         // 0x0050(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   SocketToAttach;                                    // 0x0058(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FLinearColor                           LightColor;                                        // 0x0060(0x0010)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         LightAttentionRadius;                              // 0x0070(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	ELightUnits                                   LightIntensityUnits;                               // 0x0074(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3043[0x3];                                     // 0x0075(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         LightIntensity;                                    // 0x0078(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         LightInnerConeAngle;                               // 0x007C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         LightOuterConeAngle;                               // 0x0080(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MaxLaserCastDistance;                              // 0x0084(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         LigthOffsetFromHitPoint;                           // 0x0088(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ParticleScaleModifier;                             // 0x008C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UGzWeaponAttachmentComponent*           AttachmentComp;                                    // 0x0090(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3044[0x8];                                     // 0x0098(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Enable(bool bEnable);
	struct FHitResult UpdatePoint();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzLaserAttachmentBehaviour">();
	}
	static class UGzLaserAttachmentBehaviour* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzLaserAttachmentBehaviour>();
	}
};
static_assert(alignof(UGzLaserAttachmentBehaviour) == 0x000008, "Wrong alignment on UGzLaserAttachmentBehaviour");
static_assert(sizeof(UGzLaserAttachmentBehaviour) == 0x0000A0, "Wrong size on UGzLaserAttachmentBehaviour");
static_assert(offsetof(UGzLaserAttachmentBehaviour, LaserNiagara) == 0x000038, "Member 'UGzLaserAttachmentBehaviour::LaserNiagara' has a wrong offset!");
static_assert(offsetof(UGzLaserAttachmentBehaviour, LaserNiagara_Lobby) == 0x000040, "Member 'UGzLaserAttachmentBehaviour::LaserNiagara_Lobby' has a wrong offset!");
static_assert(offsetof(UGzLaserAttachmentBehaviour, Beam) == 0x000048, "Member 'UGzLaserAttachmentBehaviour::Beam' has a wrong offset!");
static_assert(offsetof(UGzLaserAttachmentBehaviour, SpotLight) == 0x000050, "Member 'UGzLaserAttachmentBehaviour::SpotLight' has a wrong offset!");
static_assert(offsetof(UGzLaserAttachmentBehaviour, SocketToAttach) == 0x000058, "Member 'UGzLaserAttachmentBehaviour::SocketToAttach' has a wrong offset!");
static_assert(offsetof(UGzLaserAttachmentBehaviour, LightColor) == 0x000060, "Member 'UGzLaserAttachmentBehaviour::LightColor' has a wrong offset!");
static_assert(offsetof(UGzLaserAttachmentBehaviour, LightAttentionRadius) == 0x000070, "Member 'UGzLaserAttachmentBehaviour::LightAttentionRadius' has a wrong offset!");
static_assert(offsetof(UGzLaserAttachmentBehaviour, LightIntensityUnits) == 0x000074, "Member 'UGzLaserAttachmentBehaviour::LightIntensityUnits' has a wrong offset!");
static_assert(offsetof(UGzLaserAttachmentBehaviour, LightIntensity) == 0x000078, "Member 'UGzLaserAttachmentBehaviour::LightIntensity' has a wrong offset!");
static_assert(offsetof(UGzLaserAttachmentBehaviour, LightInnerConeAngle) == 0x00007C, "Member 'UGzLaserAttachmentBehaviour::LightInnerConeAngle' has a wrong offset!");
static_assert(offsetof(UGzLaserAttachmentBehaviour, LightOuterConeAngle) == 0x000080, "Member 'UGzLaserAttachmentBehaviour::LightOuterConeAngle' has a wrong offset!");
static_assert(offsetof(UGzLaserAttachmentBehaviour, MaxLaserCastDistance) == 0x000084, "Member 'UGzLaserAttachmentBehaviour::MaxLaserCastDistance' has a wrong offset!");
static_assert(offsetof(UGzLaserAttachmentBehaviour, LigthOffsetFromHitPoint) == 0x000088, "Member 'UGzLaserAttachmentBehaviour::LigthOffsetFromHitPoint' has a wrong offset!");
static_assert(offsetof(UGzLaserAttachmentBehaviour, ParticleScaleModifier) == 0x00008C, "Member 'UGzLaserAttachmentBehaviour::ParticleScaleModifier' has a wrong offset!");
static_assert(offsetof(UGzLaserAttachmentBehaviour, AttachmentComp) == 0x000090, "Member 'UGzLaserAttachmentBehaviour::AttachmentComp' has a wrong offset!");

// Class G01.GzBodyPartAbilityData_BioScanner
// 0x0010 (0x0090 - 0x0080)
class UGzBodyPartAbilityData_BioScanner final : public UGzBodyPartAbilityData
{
public:
	float                                         WaveRange;                                         // 0x0080(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         WaveRadius;                                        // 0x0084(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         WaveSpeed;                                         // 0x0088(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         EnemyRevealedDuration;                             // 0x008C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzBodyPartAbilityData_BioScanner">();
	}
	static class UGzBodyPartAbilityData_BioScanner* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzBodyPartAbilityData_BioScanner>();
	}
};
static_assert(alignof(UGzBodyPartAbilityData_BioScanner) == 0x000008, "Wrong alignment on UGzBodyPartAbilityData_BioScanner");
static_assert(sizeof(UGzBodyPartAbilityData_BioScanner) == 0x000090, "Wrong size on UGzBodyPartAbilityData_BioScanner");
static_assert(offsetof(UGzBodyPartAbilityData_BioScanner, WaveRange) == 0x000080, "Member 'UGzBodyPartAbilityData_BioScanner::WaveRange' has a wrong offset!");
static_assert(offsetof(UGzBodyPartAbilityData_BioScanner, WaveRadius) == 0x000084, "Member 'UGzBodyPartAbilityData_BioScanner::WaveRadius' has a wrong offset!");
static_assert(offsetof(UGzBodyPartAbilityData_BioScanner, WaveSpeed) == 0x000088, "Member 'UGzBodyPartAbilityData_BioScanner::WaveSpeed' has a wrong offset!");
static_assert(offsetof(UGzBodyPartAbilityData_BioScanner, EnemyRevealedDuration) == 0x00008C, "Member 'UGzBodyPartAbilityData_BioScanner::EnemyRevealedDuration' has a wrong offset!");

// Class G01.GzThrottleStatsCollector
// 0x0060 (0x0098 - 0x0038)
class UGzThrottleStatsCollector : public UGzGlobalStatsCollector
{
public:
	float                                         FrequencyTime;                                     // 0x0038(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3045[0x4];                                     // 0x003C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<int32, float>                            AccumulatedStatValues;                             // 0x0040(0x0050)(Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_3046[0x8];                                     // 0x0090(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzThrottleStatsCollector">();
	}
	static class UGzThrottleStatsCollector* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzThrottleStatsCollector>();
	}
};
static_assert(alignof(UGzThrottleStatsCollector) == 0x000008, "Wrong alignment on UGzThrottleStatsCollector");
static_assert(sizeof(UGzThrottleStatsCollector) == 0x000098, "Wrong size on UGzThrottleStatsCollector");
static_assert(offsetof(UGzThrottleStatsCollector, FrequencyTime) == 0x000038, "Member 'UGzThrottleStatsCollector::FrequencyTime' has a wrong offset!");
static_assert(offsetof(UGzThrottleStatsCollector, AccumulatedStatValues) == 0x000040, "Member 'UGzThrottleStatsCollector::AccumulatedStatValues' has a wrong offset!");

// Class G01.GzCIT_Implant
// 0x0000 (0x0450 - 0x0450)
class UGzCIT_Implant final : public UGzCustomizationItemTemplate
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzCIT_Implant">();
	}
	static class UGzCIT_Implant* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzCIT_Implant>();
	}
};
static_assert(alignof(UGzCIT_Implant) == 0x000008, "Wrong alignment on UGzCIT_Implant");
static_assert(sizeof(UGzCIT_Implant) == 0x000450, "Wrong size on UGzCIT_Implant");

// Class G01.GzBodyPartAbilityData_BuffLegs
// 0x0018 (0x0098 - 0x0080)
class UGzBodyPartAbilityData_BuffLegs final : public UGzBodyPartAbilityData
{
public:
	float                                         Radius;                                            // 0x0080(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3047[0x4];                                     // 0x0084(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<TSubclassOf<class UGameplayEffect>>    EffectsToApply;                                    // 0x0088(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, UObjectWrapper, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzBodyPartAbilityData_BuffLegs">();
	}
	static class UGzBodyPartAbilityData_BuffLegs* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzBodyPartAbilityData_BuffLegs>();
	}
};
static_assert(alignof(UGzBodyPartAbilityData_BuffLegs) == 0x000008, "Wrong alignment on UGzBodyPartAbilityData_BuffLegs");
static_assert(sizeof(UGzBodyPartAbilityData_BuffLegs) == 0x000098, "Wrong size on UGzBodyPartAbilityData_BuffLegs");
static_assert(offsetof(UGzBodyPartAbilityData_BuffLegs, Radius) == 0x000080, "Member 'UGzBodyPartAbilityData_BuffLegs::Radius' has a wrong offset!");
static_assert(offsetof(UGzBodyPartAbilityData_BuffLegs, EffectsToApply) == 0x000088, "Member 'UGzBodyPartAbilityData_BuffLegs::EffectsToApply' has a wrong offset!");

// Class G01.GzVehicleConfig
// 0x0100 (0x0130 - 0x0030)
class UGzVehicleConfig final : public UDataAsset
{
public:
	class FText                                   DisplayName;                                       // 0x0030(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	class FText                                   Description;                                       // 0x0040(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	class FText                                   DetailedDescription;                               // 0x0050(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TSubclassOf<class UGameplayEffect>            DefaultAttributes;                                 // 0x0060(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UGameplayEffect>            OnDestructionEffectOnOccupants;                    // 0x0068(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DestroyedDamageValue;                              // 0x0070(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEjectAllPassengersOnDestruction;                  // 0x0074(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3048[0x3];                                     // 0x0075(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class UCurveFloat*                            SpeedCollisionDamageCurve;                         // 0x0078(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCurveFloat*                            SpeedAttachedDamageCurve;                          // 0x0080(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UGameplayEffect>            CollisionDamageEffect;                             // 0x0088(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UGameplayEffect>            CollisionDamageCooldownEffect;                     // 0x0090(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEnableFriendlyCollisionDamage;                    // 0x0098(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3049[0x3];                                     // 0x0099(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTag                           CollisionMagnitudeTag;                             // 0x009C(0x0008)(Edit, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CollisionDamageCooldown;                           // 0x00A4(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AllowedCollisionPushAngle;                         // 0x00A8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AttachedDamagePeriod;                              // 0x00AC(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         KnockedDownDamage;                                 // 0x00B0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AttachPushForceMultiplier;                         // 0x00B4(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MustTeleportThreshold;                             // 0x00B8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEnableEnvironmentCollisionDamageVehicle;          // 0x00BC(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_304A[0x3];                                     // 0x00BD(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UGameplayEffect>            EnvironmentCollisionDamageEffect;                  // 0x00C0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCurveFloat*                            EnvironmentCollisionDamageCurveVehicle;            // 0x00C8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEnableEnvironmentCollisionDamageCharacter;        // 0x00D0(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_304B[0x7];                                     // 0x00D1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UCurveFloat*                            EnvironmentCollisionDamageCurveCharacter;          // 0x00D8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         EnvironmentCollisionSpeedThresholdForDamage;       // 0x00E0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         EnvironmentCollisionSpeedThresholdForEffects;      // 0x00E4(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UGzVehicleEffectSettings*               EffectSettings;                                    // 0x00E8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   HeadLight_Material_Param;                          // 0x00F0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   BrakeLight_Material_Param;                         // 0x00F8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   TailLight_Material_Param;                          // 0x0100(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   ReverseLight_Material_Param;                       // 0x0108(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bStartParked;                                      // 0x0110(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSetParkedWithoutDriver;                           // 0x0111(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSwitchDriverSeatOnDisconnect;                     // 0x0112(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bOnlySwitchDriverSeatIfAllyPresent;                // 0x0113(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEnterSeatsBasedOnDistance;                        // 0x0114(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_304C[0x3];                                     // 0x0115(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ExtraExitDistance;                                 // 0x0118(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_304D[0x4];                                     // 0x011C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FGzSeatConfig>                  Seats;                                             // 0x0120(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)

public:
	bool HasSeat(const EGzVehicleSeatType VehicleSeatType) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzVehicleConfig">();
	}
	static class UGzVehicleConfig* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzVehicleConfig>();
	}
};
static_assert(alignof(UGzVehicleConfig) == 0x000008, "Wrong alignment on UGzVehicleConfig");
static_assert(sizeof(UGzVehicleConfig) == 0x000130, "Wrong size on UGzVehicleConfig");
static_assert(offsetof(UGzVehicleConfig, DisplayName) == 0x000030, "Member 'UGzVehicleConfig::DisplayName' has a wrong offset!");
static_assert(offsetof(UGzVehicleConfig, Description) == 0x000040, "Member 'UGzVehicleConfig::Description' has a wrong offset!");
static_assert(offsetof(UGzVehicleConfig, DetailedDescription) == 0x000050, "Member 'UGzVehicleConfig::DetailedDescription' has a wrong offset!");
static_assert(offsetof(UGzVehicleConfig, DefaultAttributes) == 0x000060, "Member 'UGzVehicleConfig::DefaultAttributes' has a wrong offset!");
static_assert(offsetof(UGzVehicleConfig, OnDestructionEffectOnOccupants) == 0x000068, "Member 'UGzVehicleConfig::OnDestructionEffectOnOccupants' has a wrong offset!");
static_assert(offsetof(UGzVehicleConfig, DestroyedDamageValue) == 0x000070, "Member 'UGzVehicleConfig::DestroyedDamageValue' has a wrong offset!");
static_assert(offsetof(UGzVehicleConfig, bEjectAllPassengersOnDestruction) == 0x000074, "Member 'UGzVehicleConfig::bEjectAllPassengersOnDestruction' has a wrong offset!");
static_assert(offsetof(UGzVehicleConfig, SpeedCollisionDamageCurve) == 0x000078, "Member 'UGzVehicleConfig::SpeedCollisionDamageCurve' has a wrong offset!");
static_assert(offsetof(UGzVehicleConfig, SpeedAttachedDamageCurve) == 0x000080, "Member 'UGzVehicleConfig::SpeedAttachedDamageCurve' has a wrong offset!");
static_assert(offsetof(UGzVehicleConfig, CollisionDamageEffect) == 0x000088, "Member 'UGzVehicleConfig::CollisionDamageEffect' has a wrong offset!");
static_assert(offsetof(UGzVehicleConfig, CollisionDamageCooldownEffect) == 0x000090, "Member 'UGzVehicleConfig::CollisionDamageCooldownEffect' has a wrong offset!");
static_assert(offsetof(UGzVehicleConfig, bEnableFriendlyCollisionDamage) == 0x000098, "Member 'UGzVehicleConfig::bEnableFriendlyCollisionDamage' has a wrong offset!");
static_assert(offsetof(UGzVehicleConfig, CollisionMagnitudeTag) == 0x00009C, "Member 'UGzVehicleConfig::CollisionMagnitudeTag' has a wrong offset!");
static_assert(offsetof(UGzVehicleConfig, CollisionDamageCooldown) == 0x0000A4, "Member 'UGzVehicleConfig::CollisionDamageCooldown' has a wrong offset!");
static_assert(offsetof(UGzVehicleConfig, AllowedCollisionPushAngle) == 0x0000A8, "Member 'UGzVehicleConfig::AllowedCollisionPushAngle' has a wrong offset!");
static_assert(offsetof(UGzVehicleConfig, AttachedDamagePeriod) == 0x0000AC, "Member 'UGzVehicleConfig::AttachedDamagePeriod' has a wrong offset!");
static_assert(offsetof(UGzVehicleConfig, KnockedDownDamage) == 0x0000B0, "Member 'UGzVehicleConfig::KnockedDownDamage' has a wrong offset!");
static_assert(offsetof(UGzVehicleConfig, AttachPushForceMultiplier) == 0x0000B4, "Member 'UGzVehicleConfig::AttachPushForceMultiplier' has a wrong offset!");
static_assert(offsetof(UGzVehicleConfig, MustTeleportThreshold) == 0x0000B8, "Member 'UGzVehicleConfig::MustTeleportThreshold' has a wrong offset!");
static_assert(offsetof(UGzVehicleConfig, bEnableEnvironmentCollisionDamageVehicle) == 0x0000BC, "Member 'UGzVehicleConfig::bEnableEnvironmentCollisionDamageVehicle' has a wrong offset!");
static_assert(offsetof(UGzVehicleConfig, EnvironmentCollisionDamageEffect) == 0x0000C0, "Member 'UGzVehicleConfig::EnvironmentCollisionDamageEffect' has a wrong offset!");
static_assert(offsetof(UGzVehicleConfig, EnvironmentCollisionDamageCurveVehicle) == 0x0000C8, "Member 'UGzVehicleConfig::EnvironmentCollisionDamageCurveVehicle' has a wrong offset!");
static_assert(offsetof(UGzVehicleConfig, bEnableEnvironmentCollisionDamageCharacter) == 0x0000D0, "Member 'UGzVehicleConfig::bEnableEnvironmentCollisionDamageCharacter' has a wrong offset!");
static_assert(offsetof(UGzVehicleConfig, EnvironmentCollisionDamageCurveCharacter) == 0x0000D8, "Member 'UGzVehicleConfig::EnvironmentCollisionDamageCurveCharacter' has a wrong offset!");
static_assert(offsetof(UGzVehicleConfig, EnvironmentCollisionSpeedThresholdForDamage) == 0x0000E0, "Member 'UGzVehicleConfig::EnvironmentCollisionSpeedThresholdForDamage' has a wrong offset!");
static_assert(offsetof(UGzVehicleConfig, EnvironmentCollisionSpeedThresholdForEffects) == 0x0000E4, "Member 'UGzVehicleConfig::EnvironmentCollisionSpeedThresholdForEffects' has a wrong offset!");
static_assert(offsetof(UGzVehicleConfig, EffectSettings) == 0x0000E8, "Member 'UGzVehicleConfig::EffectSettings' has a wrong offset!");
static_assert(offsetof(UGzVehicleConfig, HeadLight_Material_Param) == 0x0000F0, "Member 'UGzVehicleConfig::HeadLight_Material_Param' has a wrong offset!");
static_assert(offsetof(UGzVehicleConfig, BrakeLight_Material_Param) == 0x0000F8, "Member 'UGzVehicleConfig::BrakeLight_Material_Param' has a wrong offset!");
static_assert(offsetof(UGzVehicleConfig, TailLight_Material_Param) == 0x000100, "Member 'UGzVehicleConfig::TailLight_Material_Param' has a wrong offset!");
static_assert(offsetof(UGzVehicleConfig, ReverseLight_Material_Param) == 0x000108, "Member 'UGzVehicleConfig::ReverseLight_Material_Param' has a wrong offset!");
static_assert(offsetof(UGzVehicleConfig, bStartParked) == 0x000110, "Member 'UGzVehicleConfig::bStartParked' has a wrong offset!");
static_assert(offsetof(UGzVehicleConfig, bSetParkedWithoutDriver) == 0x000111, "Member 'UGzVehicleConfig::bSetParkedWithoutDriver' has a wrong offset!");
static_assert(offsetof(UGzVehicleConfig, bSwitchDriverSeatOnDisconnect) == 0x000112, "Member 'UGzVehicleConfig::bSwitchDriverSeatOnDisconnect' has a wrong offset!");
static_assert(offsetof(UGzVehicleConfig, bOnlySwitchDriverSeatIfAllyPresent) == 0x000113, "Member 'UGzVehicleConfig::bOnlySwitchDriverSeatIfAllyPresent' has a wrong offset!");
static_assert(offsetof(UGzVehicleConfig, bEnterSeatsBasedOnDistance) == 0x000114, "Member 'UGzVehicleConfig::bEnterSeatsBasedOnDistance' has a wrong offset!");
static_assert(offsetof(UGzVehicleConfig, ExtraExitDistance) == 0x000118, "Member 'UGzVehicleConfig::ExtraExitDistance' has a wrong offset!");
static_assert(offsetof(UGzVehicleConfig, Seats) == 0x000120, "Member 'UGzVehicleConfig::Seats' has a wrong offset!");

// Class G01.GzBodyPartAbilityData_ChargedJumpLegs
// 0x0010 (0x0090 - 0x0080)
class UGzBodyPartAbilityData_ChargedJumpLegs final : public UGzBodyPartAbilityData
{
public:
	float                                         ChargedJumpHeightMultiplier;                       // 0x0080(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         KnockbackRadius;                                   // 0x0084(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         KnockbackStrength;                                 // 0x0088(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_304E[0x4];                                     // 0x008C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzBodyPartAbilityData_ChargedJumpLegs">();
	}
	static class UGzBodyPartAbilityData_ChargedJumpLegs* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzBodyPartAbilityData_ChargedJumpLegs>();
	}
};
static_assert(alignof(UGzBodyPartAbilityData_ChargedJumpLegs) == 0x000008, "Wrong alignment on UGzBodyPartAbilityData_ChargedJumpLegs");
static_assert(sizeof(UGzBodyPartAbilityData_ChargedJumpLegs) == 0x000090, "Wrong size on UGzBodyPartAbilityData_ChargedJumpLegs");
static_assert(offsetof(UGzBodyPartAbilityData_ChargedJumpLegs, ChargedJumpHeightMultiplier) == 0x000080, "Member 'UGzBodyPartAbilityData_ChargedJumpLegs::ChargedJumpHeightMultiplier' has a wrong offset!");
static_assert(offsetof(UGzBodyPartAbilityData_ChargedJumpLegs, KnockbackRadius) == 0x000084, "Member 'UGzBodyPartAbilityData_ChargedJumpLegs::KnockbackRadius' has a wrong offset!");
static_assert(offsetof(UGzBodyPartAbilityData_ChargedJumpLegs, KnockbackStrength) == 0x000088, "Member 'UGzBodyPartAbilityData_ChargedJumpLegs::KnockbackStrength' has a wrong offset!");

// Class G01.GzItemConstructionStatics
// 0x0000 (0x0028 - 0x0028)
class UGzItemConstructionStatics final : public UBlueprintFunctionLibrary
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzItemConstructionStatics">();
	}
	static class UGzItemConstructionStatics* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzItemConstructionStatics>();
	}
};
static_assert(alignof(UGzItemConstructionStatics) == 0x000008, "Wrong alignment on UGzItemConstructionStatics");
static_assert(sizeof(UGzItemConstructionStatics) == 0x000028, "Wrong size on UGzItemConstructionStatics");

// Class G01.GzCondition
// 0x0020 (0x0060 - 0x0040)
class UGzCondition : public UGzMissionTask
{
public:
	uint8                                         Pad_304F[0x18];                                    // 0x0040(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	EGzConditionState                             State;                                             // 0x0058(0x0001)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_3050[0x7];                                     // 0x0059(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnRep_State();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzCondition">();
	}
	static class UGzCondition* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzCondition>();
	}
};
static_assert(alignof(UGzCondition) == 0x000008, "Wrong alignment on UGzCondition");
static_assert(sizeof(UGzCondition) == 0x000060, "Wrong size on UGzCondition");
static_assert(offsetof(UGzCondition, State) == 0x000058, "Member 'UGzCondition::State' has a wrong offset!");

// Class G01.GzUnlockCondition
// 0x0010 (0x0070 - 0x0060)
class UGzUnlockCondition final : public UGzCondition
{
public:
	class UGzCondition*                           KeyCondition;                                      // 0x0060(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UGzCondition*                           LockedCondition;                                   // 0x0068(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UGzCondition* MakeUnlockCondition(class AGzAdvancedMission* Mission, class UGzCondition* Key, class UGzCondition* Param_LockedCondition);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzUnlockCondition">();
	}
	static class UGzUnlockCondition* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzUnlockCondition>();
	}
};
static_assert(alignof(UGzUnlockCondition) == 0x000008, "Wrong alignment on UGzUnlockCondition");
static_assert(sizeof(UGzUnlockCondition) == 0x000070, "Wrong size on UGzUnlockCondition");
static_assert(offsetof(UGzUnlockCondition, KeyCondition) == 0x000060, "Member 'UGzUnlockCondition::KeyCondition' has a wrong offset!");
static_assert(offsetof(UGzUnlockCondition, LockedCondition) == 0x000068, "Member 'UGzUnlockCondition::LockedCondition' has a wrong offset!");

// Class G01.GzChaosWheeledVehicleMovementComponent
// 0x0070 (0x0CD0 - 0x0C60)
class UGzChaosWheeledVehicleMovementComponent final : public UChaosWheeledVehicleMovementComponent
{
public:
	FMulticastInlineDelegateProperty_             OnVehicleWheelPhysMaterialChanged;                 // 0x0C60(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_3051[0x50];                                    // 0x0C70(0x0050)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UPhysicalMaterial*>              WheelPhysicalMaterials;                            // 0x0CC0(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)

public:
	void OnOnwerControllerChanged(class APawn* Pawn, class AController* OldController, class AController* NewController);

	float GetBrakeInput_Replicated() const;
	float GetEngineRPM() const;
	bool GetHandbrakeInput_Replicated() const;
	float GetSteerInput_Replicated() const;
	int32 GetTargetGear_Replicated() const;
	float GetThrottleInput_Replicated() const;
	struct FVector GetVelocity() const;
	int32 GetWheelCount() const;
	class UPhysicalMaterial* GetWheelPhysicalMaterial(int32 WheelIndex) const;
	float GetWheelSteeringAngle(int32 WheelIndex) const;
	float GetWheelSuspensionPercentage(int32 WheelIndex) const;
	bool IsAnyWheelOnGround() const;
	bool IsWheelOnGround(int32 WheelIndex) const;
	bool IsWheelSkidding(int32 WheelIndex) const;
	bool IsWheelSlipping(int32 WheelIndex) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzChaosWheeledVehicleMovementComponent">();
	}
	static class UGzChaosWheeledVehicleMovementComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzChaosWheeledVehicleMovementComponent>();
	}
};
static_assert(alignof(UGzChaosWheeledVehicleMovementComponent) == 0x000010, "Wrong alignment on UGzChaosWheeledVehicleMovementComponent");
static_assert(sizeof(UGzChaosWheeledVehicleMovementComponent) == 0x000CD0, "Wrong size on UGzChaosWheeledVehicleMovementComponent");
static_assert(offsetof(UGzChaosWheeledVehicleMovementComponent, OnVehicleWheelPhysMaterialChanged) == 0x000C60, "Member 'UGzChaosWheeledVehicleMovementComponent::OnVehicleWheelPhysMaterialChanged' has a wrong offset!");
static_assert(offsetof(UGzChaosWheeledVehicleMovementComponent, WheelPhysicalMaterials) == 0x000CC0, "Member 'UGzChaosWheeledVehicleMovementComponent::WheelPhysicalMaterials' has a wrong offset!");

// Class G01.GzBodyPartAbilityData_Cloak
// 0x0010 (0x0090 - 0x0080)
class UGzBodyPartAbilityData_Cloak final : public UGzBodyPartAbilityData
{
public:
	float                                         Duration;                                          // 0x0080(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Radius;                                            // 0x0084(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Health;                                            // 0x0088(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BlendTime;                                         // 0x008C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzBodyPartAbilityData_Cloak">();
	}
	static class UGzBodyPartAbilityData_Cloak* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzBodyPartAbilityData_Cloak>();
	}
};
static_assert(alignof(UGzBodyPartAbilityData_Cloak) == 0x000008, "Wrong alignment on UGzBodyPartAbilityData_Cloak");
static_assert(sizeof(UGzBodyPartAbilityData_Cloak) == 0x000090, "Wrong size on UGzBodyPartAbilityData_Cloak");
static_assert(offsetof(UGzBodyPartAbilityData_Cloak, Duration) == 0x000080, "Member 'UGzBodyPartAbilityData_Cloak::Duration' has a wrong offset!");
static_assert(offsetof(UGzBodyPartAbilityData_Cloak, Radius) == 0x000084, "Member 'UGzBodyPartAbilityData_Cloak::Radius' has a wrong offset!");
static_assert(offsetof(UGzBodyPartAbilityData_Cloak, Health) == 0x000088, "Member 'UGzBodyPartAbilityData_Cloak::Health' has a wrong offset!");
static_assert(offsetof(UGzBodyPartAbilityData_Cloak, BlendTime) == 0x00008C, "Member 'UGzBodyPartAbilityData_Cloak::BlendTime' has a wrong offset!");

// Class G01.GzBodyPartAbilityData_Defiler
// 0x0020 (0x00A0 - 0x0080)
class UGzBodyPartAbilityData_Defiler final : public UGzBodyPartAbilityData
{
public:
	float                                         TapeLifespanAttached;                              // 0x0080(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TapeHealth;                                        // 0x0084(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PulsePeriod;                                       // 0x0088(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PulseRadius;                                       // 0x008C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ScanRadius;                                        // 0x0090(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ShootCoolDown;                                     // 0x0094(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         VisionDuration;                                    // 0x0098(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3056[0x4];                                     // 0x009C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzBodyPartAbilityData_Defiler">();
	}
	static class UGzBodyPartAbilityData_Defiler* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzBodyPartAbilityData_Defiler>();
	}
};
static_assert(alignof(UGzBodyPartAbilityData_Defiler) == 0x000008, "Wrong alignment on UGzBodyPartAbilityData_Defiler");
static_assert(sizeof(UGzBodyPartAbilityData_Defiler) == 0x0000A0, "Wrong size on UGzBodyPartAbilityData_Defiler");
static_assert(offsetof(UGzBodyPartAbilityData_Defiler, TapeLifespanAttached) == 0x000080, "Member 'UGzBodyPartAbilityData_Defiler::TapeLifespanAttached' has a wrong offset!");
static_assert(offsetof(UGzBodyPartAbilityData_Defiler, TapeHealth) == 0x000084, "Member 'UGzBodyPartAbilityData_Defiler::TapeHealth' has a wrong offset!");
static_assert(offsetof(UGzBodyPartAbilityData_Defiler, PulsePeriod) == 0x000088, "Member 'UGzBodyPartAbilityData_Defiler::PulsePeriod' has a wrong offset!");
static_assert(offsetof(UGzBodyPartAbilityData_Defiler, PulseRadius) == 0x00008C, "Member 'UGzBodyPartAbilityData_Defiler::PulseRadius' has a wrong offset!");
static_assert(offsetof(UGzBodyPartAbilityData_Defiler, ScanRadius) == 0x000090, "Member 'UGzBodyPartAbilityData_Defiler::ScanRadius' has a wrong offset!");
static_assert(offsetof(UGzBodyPartAbilityData_Defiler, ShootCoolDown) == 0x000094, "Member 'UGzBodyPartAbilityData_Defiler::ShootCoolDown' has a wrong offset!");
static_assert(offsetof(UGzBodyPartAbilityData_Defiler, VisionDuration) == 0x000098, "Member 'UGzBodyPartAbilityData_Defiler::VisionDuration' has a wrong offset!");

// Class G01.GzChargeableAbilityComponent
// 0x0168 (0x0258 - 0x00F0)
class UGzChargeableAbilityComponent : public UGzLimbAbilityComponent
{
public:
	FMulticastInlineDelegateProperty_             OnChargeStarted;                                   // 0x00F0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnChargeStopped;                                   // 0x0100(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnMaxChargeReached;                                // 0x0110(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnCooldownStarted;                                 // 0x0120(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnCooldownStopped;                                 // 0x0130(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnAimAssistTargetChangedEvent;                     // 0x0140(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	bool                                          bUseLimbLocationOffsets;                           // 0x0150(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3057[0x7];                                     // 0x0151(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                ProjectileSpawnOffset_Left;                        // 0x0158(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                ProjectileSpawnOffset_Right;                       // 0x0170(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   ProjectileSpawnOffset_Socket;                      // 0x0188(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   ProjectileSpawnSocket_Left;                        // 0x0190(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   ProjectileSpawnSocket_Right;                       // 0x0198(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftClassPtr<class UClass>                   PreviewActorClass;                                 // 0x01A0(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bRequireCharging;                                  // 0x01C8(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3058[0x3];                                     // 0x01C9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MaxChargeTime;                                     // 0x01CC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         CooldownDuration;                                  // 0x01D0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MinProjectileSpeed;                                // 0x01D4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MaxProjectileSpeed;                                // 0x01D8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ProjectileGravityMultiplier;                       // 0x01DC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bEnableAimAssist;                                  // 0x01E0(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3059[0x7];                                     // 0x01E1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UCurveFloat*                            AimAssistToleranceDistanceCurve;                   // 0x01E8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         AimAssistDefaultToleranceDistance;                 // 0x01F0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_305A[0x4];                                     // 0x01F4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                AimAssistOriginLocationOffset;                     // 0x01F8(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bOnlyDetectSingleAimAssistTargets;                 // 0x0210(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_305B[0x7];                                     // 0x0211(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class AGzChargePreviewPathActor*              PreviewPathActor;                                  // 0x0218(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class AActor*>                         CurrentAimAssistTargets;                           // 0x0220(0x0010)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_305C[0x28];                                    // 0x0230(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void CooldownFinished();
	void GzChargeAbilityEventDelegate__DelegateSignature();
	void GzLimbAbilityAimAssistTargetChanged__DelegateSignature(class AActor* PreviousTarget, class AActor* NewTarget);
	void OnAssetsLoaded();

	bool CanShoot() const;
	float GetAimAssistRange() const;
	class AActor* GetAimAssistSingleTarget() const;
	const TArray<class AActor*> GetAimAssistTargets() const;
	struct FVector GetAimAssistViewDirection() const;
	struct FVector GetAimAssistViewLocation() const;
	float GetChargeProgress() const;
	float GetCooldownDuration() const;
	float GetCooldownProgress() const;
	struct FVector GetLaunchDirection() const;
	float GetLaunchSpeed() const;
	struct FVector GetLaunchWorldLocation() const;
	struct FVector GetLaunchWorldLocation_Offset() const;
	struct FVector GetLaunchWorldLocation_Socket() const;
	float GetProjectileGravityMultiplier() const;
	bool IsCharging() const;
	bool ShouldIgnoreActorForAimAssist(class AActor* Actor) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzChargeableAbilityComponent">();
	}
	static class UGzChargeableAbilityComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzChargeableAbilityComponent>();
	}
};
static_assert(alignof(UGzChargeableAbilityComponent) == 0x000008, "Wrong alignment on UGzChargeableAbilityComponent");
static_assert(sizeof(UGzChargeableAbilityComponent) == 0x000258, "Wrong size on UGzChargeableAbilityComponent");
static_assert(offsetof(UGzChargeableAbilityComponent, OnChargeStarted) == 0x0000F0, "Member 'UGzChargeableAbilityComponent::OnChargeStarted' has a wrong offset!");
static_assert(offsetof(UGzChargeableAbilityComponent, OnChargeStopped) == 0x000100, "Member 'UGzChargeableAbilityComponent::OnChargeStopped' has a wrong offset!");
static_assert(offsetof(UGzChargeableAbilityComponent, OnMaxChargeReached) == 0x000110, "Member 'UGzChargeableAbilityComponent::OnMaxChargeReached' has a wrong offset!");
static_assert(offsetof(UGzChargeableAbilityComponent, OnCooldownStarted) == 0x000120, "Member 'UGzChargeableAbilityComponent::OnCooldownStarted' has a wrong offset!");
static_assert(offsetof(UGzChargeableAbilityComponent, OnCooldownStopped) == 0x000130, "Member 'UGzChargeableAbilityComponent::OnCooldownStopped' has a wrong offset!");
static_assert(offsetof(UGzChargeableAbilityComponent, OnAimAssistTargetChangedEvent) == 0x000140, "Member 'UGzChargeableAbilityComponent::OnAimAssistTargetChangedEvent' has a wrong offset!");
static_assert(offsetof(UGzChargeableAbilityComponent, bUseLimbLocationOffsets) == 0x000150, "Member 'UGzChargeableAbilityComponent::bUseLimbLocationOffsets' has a wrong offset!");
static_assert(offsetof(UGzChargeableAbilityComponent, ProjectileSpawnOffset_Left) == 0x000158, "Member 'UGzChargeableAbilityComponent::ProjectileSpawnOffset_Left' has a wrong offset!");
static_assert(offsetof(UGzChargeableAbilityComponent, ProjectileSpawnOffset_Right) == 0x000170, "Member 'UGzChargeableAbilityComponent::ProjectileSpawnOffset_Right' has a wrong offset!");
static_assert(offsetof(UGzChargeableAbilityComponent, ProjectileSpawnOffset_Socket) == 0x000188, "Member 'UGzChargeableAbilityComponent::ProjectileSpawnOffset_Socket' has a wrong offset!");
static_assert(offsetof(UGzChargeableAbilityComponent, ProjectileSpawnSocket_Left) == 0x000190, "Member 'UGzChargeableAbilityComponent::ProjectileSpawnSocket_Left' has a wrong offset!");
static_assert(offsetof(UGzChargeableAbilityComponent, ProjectileSpawnSocket_Right) == 0x000198, "Member 'UGzChargeableAbilityComponent::ProjectileSpawnSocket_Right' has a wrong offset!");
static_assert(offsetof(UGzChargeableAbilityComponent, PreviewActorClass) == 0x0001A0, "Member 'UGzChargeableAbilityComponent::PreviewActorClass' has a wrong offset!");
static_assert(offsetof(UGzChargeableAbilityComponent, bRequireCharging) == 0x0001C8, "Member 'UGzChargeableAbilityComponent::bRequireCharging' has a wrong offset!");
static_assert(offsetof(UGzChargeableAbilityComponent, MaxChargeTime) == 0x0001CC, "Member 'UGzChargeableAbilityComponent::MaxChargeTime' has a wrong offset!");
static_assert(offsetof(UGzChargeableAbilityComponent, CooldownDuration) == 0x0001D0, "Member 'UGzChargeableAbilityComponent::CooldownDuration' has a wrong offset!");
static_assert(offsetof(UGzChargeableAbilityComponent, MinProjectileSpeed) == 0x0001D4, "Member 'UGzChargeableAbilityComponent::MinProjectileSpeed' has a wrong offset!");
static_assert(offsetof(UGzChargeableAbilityComponent, MaxProjectileSpeed) == 0x0001D8, "Member 'UGzChargeableAbilityComponent::MaxProjectileSpeed' has a wrong offset!");
static_assert(offsetof(UGzChargeableAbilityComponent, ProjectileGravityMultiplier) == 0x0001DC, "Member 'UGzChargeableAbilityComponent::ProjectileGravityMultiplier' has a wrong offset!");
static_assert(offsetof(UGzChargeableAbilityComponent, bEnableAimAssist) == 0x0001E0, "Member 'UGzChargeableAbilityComponent::bEnableAimAssist' has a wrong offset!");
static_assert(offsetof(UGzChargeableAbilityComponent, AimAssistToleranceDistanceCurve) == 0x0001E8, "Member 'UGzChargeableAbilityComponent::AimAssistToleranceDistanceCurve' has a wrong offset!");
static_assert(offsetof(UGzChargeableAbilityComponent, AimAssistDefaultToleranceDistance) == 0x0001F0, "Member 'UGzChargeableAbilityComponent::AimAssistDefaultToleranceDistance' has a wrong offset!");
static_assert(offsetof(UGzChargeableAbilityComponent, AimAssistOriginLocationOffset) == 0x0001F8, "Member 'UGzChargeableAbilityComponent::AimAssistOriginLocationOffset' has a wrong offset!");
static_assert(offsetof(UGzChargeableAbilityComponent, bOnlyDetectSingleAimAssistTargets) == 0x000210, "Member 'UGzChargeableAbilityComponent::bOnlyDetectSingleAimAssistTargets' has a wrong offset!");
static_assert(offsetof(UGzChargeableAbilityComponent, PreviewPathActor) == 0x000218, "Member 'UGzChargeableAbilityComponent::PreviewPathActor' has a wrong offset!");
static_assert(offsetof(UGzChargeableAbilityComponent, CurrentAimAssistTargets) == 0x000220, "Member 'UGzChargeableAbilityComponent::CurrentAimAssistTargets' has a wrong offset!");

// Class G01.GzGorillaArmComponent
// 0x0058 (0x02B0 - 0x0258)
class UGzGorillaArmComponent : public UGzChargeableAbilityComponent
{
public:
	FMulticastInlineDelegateProperty_             OnAbilityEnd;                                      // 0x0258(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnDashStart;                                       // 0x0268(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnDashStop;                                        // 0x0278(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	float                                         CollisionCheckRadius;                              // 0x0288(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CollisionExtraDistance;                            // 0x028C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCancelChargeAfterTime;                            // 0x0290(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_305E[0x3];                                     // 0x0291(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ChargeCancelTime;                                  // 0x0294(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCurveFloat*                            AimAssistHorizontalToleranceDistanceCurve;         // 0x0298(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCurveFloat*                            AimAssistVerticalToleranceDistanceCurve;           // 0x02A0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MaxCorrectionWithAimAssist;                        // 0x02A8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MaxCorrectionWithOutAimAssist;                     // 0x02AC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void GzGorillaArmStateDelegate__DelegateSignature();

	void GetDashDirectionAndLocation(struct FVector* OutDirection, struct FVector* OutLocation) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzGorillaArmComponent">();
	}
	static class UGzGorillaArmComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzGorillaArmComponent>();
	}
};
static_assert(alignof(UGzGorillaArmComponent) == 0x000008, "Wrong alignment on UGzGorillaArmComponent");
static_assert(sizeof(UGzGorillaArmComponent) == 0x0002B0, "Wrong size on UGzGorillaArmComponent");
static_assert(offsetof(UGzGorillaArmComponent, OnAbilityEnd) == 0x000258, "Member 'UGzGorillaArmComponent::OnAbilityEnd' has a wrong offset!");
static_assert(offsetof(UGzGorillaArmComponent, OnDashStart) == 0x000268, "Member 'UGzGorillaArmComponent::OnDashStart' has a wrong offset!");
static_assert(offsetof(UGzGorillaArmComponent, OnDashStop) == 0x000278, "Member 'UGzGorillaArmComponent::OnDashStop' has a wrong offset!");
static_assert(offsetof(UGzGorillaArmComponent, CollisionCheckRadius) == 0x000288, "Member 'UGzGorillaArmComponent::CollisionCheckRadius' has a wrong offset!");
static_assert(offsetof(UGzGorillaArmComponent, CollisionExtraDistance) == 0x00028C, "Member 'UGzGorillaArmComponent::CollisionExtraDistance' has a wrong offset!");
static_assert(offsetof(UGzGorillaArmComponent, bCancelChargeAfterTime) == 0x000290, "Member 'UGzGorillaArmComponent::bCancelChargeAfterTime' has a wrong offset!");
static_assert(offsetof(UGzGorillaArmComponent, ChargeCancelTime) == 0x000294, "Member 'UGzGorillaArmComponent::ChargeCancelTime' has a wrong offset!");
static_assert(offsetof(UGzGorillaArmComponent, AimAssistHorizontalToleranceDistanceCurve) == 0x000298, "Member 'UGzGorillaArmComponent::AimAssistHorizontalToleranceDistanceCurve' has a wrong offset!");
static_assert(offsetof(UGzGorillaArmComponent, AimAssistVerticalToleranceDistanceCurve) == 0x0002A0, "Member 'UGzGorillaArmComponent::AimAssistVerticalToleranceDistanceCurve' has a wrong offset!");
static_assert(offsetof(UGzGorillaArmComponent, MaxCorrectionWithAimAssist) == 0x0002A8, "Member 'UGzGorillaArmComponent::MaxCorrectionWithAimAssist' has a wrong offset!");
static_assert(offsetof(UGzGorillaArmComponent, MaxCorrectionWithOutAimAssist) == 0x0002AC, "Member 'UGzGorillaArmComponent::MaxCorrectionWithOutAimAssist' has a wrong offset!");

// Class G01.GzLoadoutModel
// 0x01D0 (0x0240 - 0x0070)
class UGzLoadoutModel final : public UGzBackendModel
{
public:
	uint8                                         Pad_305F[0x1D0];                                   // 0x0070(0x01D0)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzLoadoutModel">();
	}
	static class UGzLoadoutModel* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzLoadoutModel>();
	}
};
static_assert(alignof(UGzLoadoutModel) == 0x000008, "Wrong alignment on UGzLoadoutModel");
static_assert(sizeof(UGzLoadoutModel) == 0x000240, "Wrong size on UGzLoadoutModel");

// Class G01.GzBodyPartAbilityData_GorillaArm
// 0x0028 (0x00A8 - 0x0080)
class UGzBodyPartAbilityData_GorillaArm final : public UGzBodyPartAbilityData
{
public:
	float                                         RecoilModifier;                                    // 0x0080(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SpreadModifier;                                    // 0x0084(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         KnockbackDistance;                                 // 0x0088(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PunchDamage;                                       // 0x008C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DashSpeed;                                         // 0x0090(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxDashDistance;                                   // 0x0094(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinDashDistance;                                   // 0x0098(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxPunchDebuffDuration;                            // 0x009C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxPunchHorizontalImpulse;                         // 0x00A0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PunchVerticalImpulse;                              // 0x00A4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzBodyPartAbilityData_GorillaArm">();
	}
	static class UGzBodyPartAbilityData_GorillaArm* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzBodyPartAbilityData_GorillaArm>();
	}
};
static_assert(alignof(UGzBodyPartAbilityData_GorillaArm) == 0x000008, "Wrong alignment on UGzBodyPartAbilityData_GorillaArm");
static_assert(sizeof(UGzBodyPartAbilityData_GorillaArm) == 0x0000A8, "Wrong size on UGzBodyPartAbilityData_GorillaArm");
static_assert(offsetof(UGzBodyPartAbilityData_GorillaArm, RecoilModifier) == 0x000080, "Member 'UGzBodyPartAbilityData_GorillaArm::RecoilModifier' has a wrong offset!");
static_assert(offsetof(UGzBodyPartAbilityData_GorillaArm, SpreadModifier) == 0x000084, "Member 'UGzBodyPartAbilityData_GorillaArm::SpreadModifier' has a wrong offset!");
static_assert(offsetof(UGzBodyPartAbilityData_GorillaArm, KnockbackDistance) == 0x000088, "Member 'UGzBodyPartAbilityData_GorillaArm::KnockbackDistance' has a wrong offset!");
static_assert(offsetof(UGzBodyPartAbilityData_GorillaArm, PunchDamage) == 0x00008C, "Member 'UGzBodyPartAbilityData_GorillaArm::PunchDamage' has a wrong offset!");
static_assert(offsetof(UGzBodyPartAbilityData_GorillaArm, DashSpeed) == 0x000090, "Member 'UGzBodyPartAbilityData_GorillaArm::DashSpeed' has a wrong offset!");
static_assert(offsetof(UGzBodyPartAbilityData_GorillaArm, MaxDashDistance) == 0x000094, "Member 'UGzBodyPartAbilityData_GorillaArm::MaxDashDistance' has a wrong offset!");
static_assert(offsetof(UGzBodyPartAbilityData_GorillaArm, MinDashDistance) == 0x000098, "Member 'UGzBodyPartAbilityData_GorillaArm::MinDashDistance' has a wrong offset!");
static_assert(offsetof(UGzBodyPartAbilityData_GorillaArm, MaxPunchDebuffDuration) == 0x00009C, "Member 'UGzBodyPartAbilityData_GorillaArm::MaxPunchDebuffDuration' has a wrong offset!");
static_assert(offsetof(UGzBodyPartAbilityData_GorillaArm, MaxPunchHorizontalImpulse) == 0x0000A0, "Member 'UGzBodyPartAbilityData_GorillaArm::MaxPunchHorizontalImpulse' has a wrong offset!");
static_assert(offsetof(UGzBodyPartAbilityData_GorillaArm, PunchVerticalImpulse) == 0x0000A4, "Member 'UGzBodyPartAbilityData_GorillaArm::PunchVerticalImpulse' has a wrong offset!");

// Class G01.GzHUDStatesSubsystem
// 0x0080 (0x00B0 - 0x0030)
class UGzHUDStatesSubsystem final : public UGameInstanceSubsystem
{
public:
	uint8                                         Pad_3060[0x70];                                    // 0x0030(0x0070)(Fixing Size After Last Property [ Dumper-7 ])
	class AGzHUDBase*                             TargetHUD;                                         // 0x00A0(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class APawn*                                  ViewTarget;                                        // 0x00A8(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void OnComebackArenaStateChanged(class AGzPlayerState* PlayerState);
	void OnDeploymentStateChanged(bool bEnabled);
	void OnEndedSpectating();
	void OnMatchStateTagsChanged();
	void OnPlayerTagsChanged(const struct FGameplayTag& GameplayTag, int32 Count);
	void OnSpectatingKillerChanged(bool bSpectatingKiller);
	void OnStartedSpectating();
	void OnVehicleSeatChanged(class AGzCharacter* Character, EGzVehicleSeatType NewSeat, EGzVehicleSeatType OldSeat);
	void OnViewTargetChanged(class APawn* NewViewTarget);
	void OnViewTargetWeaponChanged(const struct FGzInvPocketId& PocketId, class AGzWeaponActor* WeaponActor);

	void UpdateHUDVisibility() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzHUDStatesSubsystem">();
	}
	static class UGzHUDStatesSubsystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzHUDStatesSubsystem>();
	}
};
static_assert(alignof(UGzHUDStatesSubsystem) == 0x000008, "Wrong alignment on UGzHUDStatesSubsystem");
static_assert(sizeof(UGzHUDStatesSubsystem) == 0x0000B0, "Wrong size on UGzHUDStatesSubsystem");
static_assert(offsetof(UGzHUDStatesSubsystem, TargetHUD) == 0x0000A0, "Member 'UGzHUDStatesSubsystem::TargetHUD' has a wrong offset!");
static_assert(offsetof(UGzHUDStatesSubsystem, ViewTarget) == 0x0000A8, "Member 'UGzHUDStatesSubsystem::ViewTarget' has a wrong offset!");

// Class G01.GzBodyPartAbilityData_GrappleHook
// 0x0010 (0x0090 - 0x0080)
class UGzBodyPartAbilityData_GrappleHook final : public UGzBodyPartAbilityData
{
public:
	class UGzGrappleHookData*                     GrappleHookData;                                   // 0x0080(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UGzGrappleHookData*                     GrappleHookDataRight;                              // 0x0088(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzBodyPartAbilityData_GrappleHook">();
	}
	static class UGzBodyPartAbilityData_GrappleHook* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzBodyPartAbilityData_GrappleHook>();
	}
};
static_assert(alignof(UGzBodyPartAbilityData_GrappleHook) == 0x000008, "Wrong alignment on UGzBodyPartAbilityData_GrappleHook");
static_assert(sizeof(UGzBodyPartAbilityData_GrappleHook) == 0x000090, "Wrong size on UGzBodyPartAbilityData_GrappleHook");
static_assert(offsetof(UGzBodyPartAbilityData_GrappleHook, GrappleHookData) == 0x000080, "Member 'UGzBodyPartAbilityData_GrappleHook::GrappleHookData' has a wrong offset!");
static_assert(offsetof(UGzBodyPartAbilityData_GrappleHook, GrappleHookDataRight) == 0x000088, "Member 'UGzBodyPartAbilityData_GrappleHook::GrappleHookDataRight' has a wrong offset!");

// Class G01.GzBodyPartAbilityData_HackingArm
// 0x0008 (0x0088 - 0x0080)
class UGzBodyPartAbilityData_HackingArm final : public UGzBodyPartAbilityData
{
public:
	float                                         HackedEffectDuration;                              // 0x0080(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3062[0x4];                                     // 0x0084(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzBodyPartAbilityData_HackingArm">();
	}
	static class UGzBodyPartAbilityData_HackingArm* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzBodyPartAbilityData_HackingArm>();
	}
};
static_assert(alignof(UGzBodyPartAbilityData_HackingArm) == 0x000008, "Wrong alignment on UGzBodyPartAbilityData_HackingArm");
static_assert(sizeof(UGzBodyPartAbilityData_HackingArm) == 0x000088, "Wrong size on UGzBodyPartAbilityData_HackingArm");
static_assert(offsetof(UGzBodyPartAbilityData_HackingArm, HackedEffectDuration) == 0x000080, "Member 'UGzBodyPartAbilityData_HackingArm::HackedEffectDuration' has a wrong offset!");

// Class G01.GzVehiclesCheatExtension
// 0x0000 (0x0028 - 0x0028)
class UGzVehiclesCheatExtension final : public UGzCheatManagerExtension
{
public:
	void DestroyCurrentVehicle() const;
	void SpawnVehicle(const int32 VehicleClassIndex) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzVehiclesCheatExtension">();
	}
	static class UGzVehiclesCheatExtension* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzVehiclesCheatExtension>();
	}
};
static_assert(alignof(UGzVehiclesCheatExtension) == 0x000008, "Wrong alignment on UGzVehiclesCheatExtension");
static_assert(sizeof(UGzVehiclesCheatExtension) == 0x000028, "Wrong size on UGzVehiclesCheatExtension");

// Class G01.GzBodyPartAbilityData_Harpoon
// 0x0008 (0x0088 - 0x0080)
class UGzBodyPartAbilityData_Harpoon final : public UGzBodyPartAbilityData
{
public:
	float                                         EffectDuration;                                    // 0x0080(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3063[0x4];                                     // 0x0084(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzBodyPartAbilityData_Harpoon">();
	}
	static class UGzBodyPartAbilityData_Harpoon* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzBodyPartAbilityData_Harpoon>();
	}
};
static_assert(alignof(UGzBodyPartAbilityData_Harpoon) == 0x000008, "Wrong alignment on UGzBodyPartAbilityData_Harpoon");
static_assert(sizeof(UGzBodyPartAbilityData_Harpoon) == 0x000088, "Wrong size on UGzBodyPartAbilityData_Harpoon");
static_assert(offsetof(UGzBodyPartAbilityData_Harpoon, EffectDuration) == 0x000080, "Member 'UGzBodyPartAbilityData_Harpoon::EffectDuration' has a wrong offset!");

// Class G01.GzItemLimitingSettings
// 0x0008 (0x0040 - 0x0038)
class UGzItemLimitingSettings final : public UDeveloperSettings
{
public:
	int32                                         BumpVersion;                                       // 0x0038(0x0004)(Edit, ZeroConstructor, Config, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3064[0x4];                                     // 0x003C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzItemLimitingSettings">();
	}
	static class UGzItemLimitingSettings* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzItemLimitingSettings>();
	}
};
static_assert(alignof(UGzItemLimitingSettings) == 0x000008, "Wrong alignment on UGzItemLimitingSettings");
static_assert(sizeof(UGzItemLimitingSettings) == 0x000040, "Wrong size on UGzItemLimitingSettings");
static_assert(offsetof(UGzItemLimitingSettings, BumpVersion) == 0x000038, "Member 'UGzItemLimitingSettings::BumpVersion' has a wrong offset!");

// Class G01.GzBodyPartAbilityData_JumpBoost
// 0x0008 (0x0088 - 0x0080)
class UGzBodyPartAbilityData_JumpBoost final : public UGzBodyPartAbilityData
{
public:
	float                                         JumpBoostStrength;                                 // 0x0080(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DodgeBoostStrength;                                // 0x0084(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzBodyPartAbilityData_JumpBoost">();
	}
	static class UGzBodyPartAbilityData_JumpBoost* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzBodyPartAbilityData_JumpBoost>();
	}
};
static_assert(alignof(UGzBodyPartAbilityData_JumpBoost) == 0x000008, "Wrong alignment on UGzBodyPartAbilityData_JumpBoost");
static_assert(sizeof(UGzBodyPartAbilityData_JumpBoost) == 0x000088, "Wrong size on UGzBodyPartAbilityData_JumpBoost");
static_assert(offsetof(UGzBodyPartAbilityData_JumpBoost, JumpBoostStrength) == 0x000080, "Member 'UGzBodyPartAbilityData_JumpBoost::JumpBoostStrength' has a wrong offset!");
static_assert(offsetof(UGzBodyPartAbilityData_JumpBoost, DodgeBoostStrength) == 0x000084, "Member 'UGzBodyPartAbilityData_JumpBoost::DodgeBoostStrength' has a wrong offset!");

// Class G01.GzMatchesPlayedStatCollector
// 0x0008 (0x0040 - 0x0038)
class UGzMatchesPlayedStatCollector : public UGzGlobalStatsCollector
{
public:
	uint8                                         Pad_3065[0x8];                                     // 0x0038(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzMatchesPlayedStatCollector">();
	}
	static class UGzMatchesPlayedStatCollector* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzMatchesPlayedStatCollector>();
	}
};
static_assert(alignof(UGzMatchesPlayedStatCollector) == 0x000008, "Wrong alignment on UGzMatchesPlayedStatCollector");
static_assert(sizeof(UGzMatchesPlayedStatCollector) == 0x000040, "Wrong size on UGzMatchesPlayedStatCollector");

// Class G01.GzPlayerMatchWinsStatCollector
// 0x0000 (0x0040 - 0x0040)
class UGzPlayerMatchWinsStatCollector final : public UGzMatchesPlayedStatCollector
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzPlayerMatchWinsStatCollector">();
	}
	static class UGzPlayerMatchWinsStatCollector* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzPlayerMatchWinsStatCollector>();
	}
};
static_assert(alignof(UGzPlayerMatchWinsStatCollector) == 0x000008, "Wrong alignment on UGzPlayerMatchWinsStatCollector");
static_assert(sizeof(UGzPlayerMatchWinsStatCollector) == 0x000040, "Wrong size on UGzPlayerMatchWinsStatCollector");

// Class G01.GzBodyPartAbilityData_MicroMissileArm
// 0x0018 (0x0098 - 0x0080)
class UGzBodyPartAbilityData_MicroMissileArm final : public UGzBodyPartAbilityData
{
public:
	int32                                         MissilesPerTarget;                                 // 0x0080(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MissileDamage;                                     // 0x0084(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MissileShootingInterval;                           // 0x0088(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TargetingRange;                                    // 0x008C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseMultipleLocksForOneCharge;                     // 0x0090(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3066[0x3];                                     // 0x0091(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         LocksPerCharge;                                    // 0x0094(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzBodyPartAbilityData_MicroMissileArm">();
	}
	static class UGzBodyPartAbilityData_MicroMissileArm* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzBodyPartAbilityData_MicroMissileArm>();
	}
};
static_assert(alignof(UGzBodyPartAbilityData_MicroMissileArm) == 0x000008, "Wrong alignment on UGzBodyPartAbilityData_MicroMissileArm");
static_assert(sizeof(UGzBodyPartAbilityData_MicroMissileArm) == 0x000098, "Wrong size on UGzBodyPartAbilityData_MicroMissileArm");
static_assert(offsetof(UGzBodyPartAbilityData_MicroMissileArm, MissilesPerTarget) == 0x000080, "Member 'UGzBodyPartAbilityData_MicroMissileArm::MissilesPerTarget' has a wrong offset!");
static_assert(offsetof(UGzBodyPartAbilityData_MicroMissileArm, MissileDamage) == 0x000084, "Member 'UGzBodyPartAbilityData_MicroMissileArm::MissileDamage' has a wrong offset!");
static_assert(offsetof(UGzBodyPartAbilityData_MicroMissileArm, MissileShootingInterval) == 0x000088, "Member 'UGzBodyPartAbilityData_MicroMissileArm::MissileShootingInterval' has a wrong offset!");
static_assert(offsetof(UGzBodyPartAbilityData_MicroMissileArm, TargetingRange) == 0x00008C, "Member 'UGzBodyPartAbilityData_MicroMissileArm::TargetingRange' has a wrong offset!");
static_assert(offsetof(UGzBodyPartAbilityData_MicroMissileArm, bUseMultipleLocksForOneCharge) == 0x000090, "Member 'UGzBodyPartAbilityData_MicroMissileArm::bUseMultipleLocksForOneCharge' has a wrong offset!");
static_assert(offsetof(UGzBodyPartAbilityData_MicroMissileArm, LocksPerCharge) == 0x000094, "Member 'UGzBodyPartAbilityData_MicroMissileArm::LocksPerCharge' has a wrong offset!");

// Class G01.GzWingsuitSoundSettingsDataAsset
// 0x0058 (0x0088 - 0x0030)
class UGzWingsuitSoundSettingsDataAsset final : public UDataAsset
{
public:
	class UAkAudioEvent*                          StartEvent;                                        // 0x0030(0x0008)(Edit, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAkAudioEvent*                          StopEvent;                                         // 0x0038(0x0008)(Edit, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAkAudioEvent*                          PlayerHitEvent;                                    // 0x0040(0x0008)(Edit, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAkAudioEvent*                          ZiplineJumpEvent;                                  // 0x0048(0x0008)(Edit, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAkRtpc*                                Pitch;                                             // 0x0050(0x0008)(Edit, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAkRtpc*                                RotationSpeed;                                     // 0x0058(0x0008)(Edit, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAkRtpc*                                Height;                                            // 0x0060(0x0008)(Edit, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         IncreaseHeightInterpTime;                          // 0x0068(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DecreaseHeightInterpTime;                          // 0x006C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAkAudioEvent*                          ProximityEvent;                                    // 0x0070(0x0008)(Edit, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ProximityUpdateRate;                               // 0x0078(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         NumOfSegmentsForRaycast;                           // 0x007C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RaycastLength;                                     // 0x0080(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3067[0x4];                                     // 0x0084(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzWingsuitSoundSettingsDataAsset">();
	}
	static class UGzWingsuitSoundSettingsDataAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzWingsuitSoundSettingsDataAsset>();
	}
};
static_assert(alignof(UGzWingsuitSoundSettingsDataAsset) == 0x000008, "Wrong alignment on UGzWingsuitSoundSettingsDataAsset");
static_assert(sizeof(UGzWingsuitSoundSettingsDataAsset) == 0x000088, "Wrong size on UGzWingsuitSoundSettingsDataAsset");
static_assert(offsetof(UGzWingsuitSoundSettingsDataAsset, StartEvent) == 0x000030, "Member 'UGzWingsuitSoundSettingsDataAsset::StartEvent' has a wrong offset!");
static_assert(offsetof(UGzWingsuitSoundSettingsDataAsset, StopEvent) == 0x000038, "Member 'UGzWingsuitSoundSettingsDataAsset::StopEvent' has a wrong offset!");
static_assert(offsetof(UGzWingsuitSoundSettingsDataAsset, PlayerHitEvent) == 0x000040, "Member 'UGzWingsuitSoundSettingsDataAsset::PlayerHitEvent' has a wrong offset!");
static_assert(offsetof(UGzWingsuitSoundSettingsDataAsset, ZiplineJumpEvent) == 0x000048, "Member 'UGzWingsuitSoundSettingsDataAsset::ZiplineJumpEvent' has a wrong offset!");
static_assert(offsetof(UGzWingsuitSoundSettingsDataAsset, Pitch) == 0x000050, "Member 'UGzWingsuitSoundSettingsDataAsset::Pitch' has a wrong offset!");
static_assert(offsetof(UGzWingsuitSoundSettingsDataAsset, RotationSpeed) == 0x000058, "Member 'UGzWingsuitSoundSettingsDataAsset::RotationSpeed' has a wrong offset!");
static_assert(offsetof(UGzWingsuitSoundSettingsDataAsset, Height) == 0x000060, "Member 'UGzWingsuitSoundSettingsDataAsset::Height' has a wrong offset!");
static_assert(offsetof(UGzWingsuitSoundSettingsDataAsset, IncreaseHeightInterpTime) == 0x000068, "Member 'UGzWingsuitSoundSettingsDataAsset::IncreaseHeightInterpTime' has a wrong offset!");
static_assert(offsetof(UGzWingsuitSoundSettingsDataAsset, DecreaseHeightInterpTime) == 0x00006C, "Member 'UGzWingsuitSoundSettingsDataAsset::DecreaseHeightInterpTime' has a wrong offset!");
static_assert(offsetof(UGzWingsuitSoundSettingsDataAsset, ProximityEvent) == 0x000070, "Member 'UGzWingsuitSoundSettingsDataAsset::ProximityEvent' has a wrong offset!");
static_assert(offsetof(UGzWingsuitSoundSettingsDataAsset, ProximityUpdateRate) == 0x000078, "Member 'UGzWingsuitSoundSettingsDataAsset::ProximityUpdateRate' has a wrong offset!");
static_assert(offsetof(UGzWingsuitSoundSettingsDataAsset, NumOfSegmentsForRaycast) == 0x00007C, "Member 'UGzWingsuitSoundSettingsDataAsset::NumOfSegmentsForRaycast' has a wrong offset!");
static_assert(offsetof(UGzWingsuitSoundSettingsDataAsset, RaycastLength) == 0x000080, "Member 'UGzWingsuitSoundSettingsDataAsset::RaycastLength' has a wrong offset!");

// Class G01.GzBodyPartAbilityData_MortarLegs
// 0x0030 (0x00B0 - 0x0080)
class UGzBodyPartAbilityData_MortarLegs final : public UGzBodyPartAbilityData
{
public:
	int32                                         TargetLimit;                                       // 0x0080(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ProjectileCount;                                   // 0x0084(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinSpreadDistance;                                 // 0x0088(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxSpreadDistance;                                 // 0x008C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinRange;                                          // 0x0090(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxRange;                                          // 0x0094(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ExtraRadarRangeMultiplier;                         // 0x0098(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AllowedHalfAngle;                                  // 0x009C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ScannerTimePeriod;                                 // 0x00A0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ScannerDelay;                                      // 0x00A4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MarkerLifespan;                                    // 0x00A8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3068[0x4];                                     // 0x00AC(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzBodyPartAbilityData_MortarLegs">();
	}
	static class UGzBodyPartAbilityData_MortarLegs* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzBodyPartAbilityData_MortarLegs>();
	}
};
static_assert(alignof(UGzBodyPartAbilityData_MortarLegs) == 0x000008, "Wrong alignment on UGzBodyPartAbilityData_MortarLegs");
static_assert(sizeof(UGzBodyPartAbilityData_MortarLegs) == 0x0000B0, "Wrong size on UGzBodyPartAbilityData_MortarLegs");
static_assert(offsetof(UGzBodyPartAbilityData_MortarLegs, TargetLimit) == 0x000080, "Member 'UGzBodyPartAbilityData_MortarLegs::TargetLimit' has a wrong offset!");
static_assert(offsetof(UGzBodyPartAbilityData_MortarLegs, ProjectileCount) == 0x000084, "Member 'UGzBodyPartAbilityData_MortarLegs::ProjectileCount' has a wrong offset!");
static_assert(offsetof(UGzBodyPartAbilityData_MortarLegs, MinSpreadDistance) == 0x000088, "Member 'UGzBodyPartAbilityData_MortarLegs::MinSpreadDistance' has a wrong offset!");
static_assert(offsetof(UGzBodyPartAbilityData_MortarLegs, MaxSpreadDistance) == 0x00008C, "Member 'UGzBodyPartAbilityData_MortarLegs::MaxSpreadDistance' has a wrong offset!");
static_assert(offsetof(UGzBodyPartAbilityData_MortarLegs, MinRange) == 0x000090, "Member 'UGzBodyPartAbilityData_MortarLegs::MinRange' has a wrong offset!");
static_assert(offsetof(UGzBodyPartAbilityData_MortarLegs, MaxRange) == 0x000094, "Member 'UGzBodyPartAbilityData_MortarLegs::MaxRange' has a wrong offset!");
static_assert(offsetof(UGzBodyPartAbilityData_MortarLegs, ExtraRadarRangeMultiplier) == 0x000098, "Member 'UGzBodyPartAbilityData_MortarLegs::ExtraRadarRangeMultiplier' has a wrong offset!");
static_assert(offsetof(UGzBodyPartAbilityData_MortarLegs, AllowedHalfAngle) == 0x00009C, "Member 'UGzBodyPartAbilityData_MortarLegs::AllowedHalfAngle' has a wrong offset!");
static_assert(offsetof(UGzBodyPartAbilityData_MortarLegs, ScannerTimePeriod) == 0x0000A0, "Member 'UGzBodyPartAbilityData_MortarLegs::ScannerTimePeriod' has a wrong offset!");
static_assert(offsetof(UGzBodyPartAbilityData_MortarLegs, ScannerDelay) == 0x0000A4, "Member 'UGzBodyPartAbilityData_MortarLegs::ScannerDelay' has a wrong offset!");
static_assert(offsetof(UGzBodyPartAbilityData_MortarLegs, MarkerLifespan) == 0x0000A8, "Member 'UGzBodyPartAbilityData_MortarLegs::MarkerLifespan' has a wrong offset!");

// Class G01.GzMapController
// 0x0030 (0x0058 - 0x0028)
class UGzMapController : public UObject
{
public:
	uint8                                         Pad_3069[0x8];                                     // 0x0028(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	FMulticastInlineDelegateProperty_             OnMapClickDelegate;                                // 0x0030(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	class UGzMapWidget*                           MapWidget;                                         // 0x0040(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bSupportInteraction;                               // 0x0048(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bSupportZoneInteraction;                           // 0x0049(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_306A[0x6];                                     // 0x004A(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class UGzMapZoneWidget*                       HoveredZone;                                       // 0x0050(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UGzMapController* CreateControllerForMap(class UObject* Parent, class UGzMapWidget* Param_MapWidget, TSubclassOf<class UGzMapController> ControllerType);

	void OnInit();
	void OnMapClick(const struct FVector2D& ScreenPosition, const struct FVector2D& WorldPos);
	void OnMapDoubleClick(const struct FVector2D& Vector2D, const struct FVector2D& WorldPos);
	void OnMapHover(const struct FVector2D& Vector2D, const struct FVector2D& WorldPos);
	void OnMapReady();
	struct FEventReply OnMouseButtonUp(const struct FGeometry& Geometry, const struct FPointerEvent& MouseEvent);
	struct FEventReply OnPanelDoubleClick(const struct FGeometry& Geometry, const struct FPointerEvent& MouseEvent);
	struct FEventReply OnPanelHover(const struct FGeometry& Geometry, const struct FPointerEvent& MouseEvent);
	void OnTick(float DeltaTime);
	void OnZoneClick(class UGzMapZoneWidget* ZoneWidget, const struct FVector2D& Vector2D, const struct FVector2D& WorldPos);
	void OnZoneDoubleClick(class UGzMapZoneWidget* ZoneWidget, const struct FVector2D& Vector2D, const struct FVector2D& WorldPos);
	void OnZoneEndHover(class UGzMapZoneWidget* ZoneWidget);
	void OnZoneStartHover(class UGzMapZoneWidget* ZoneWidget, const struct FVector2D& Vector2D, const struct FVector2D& WorldPos);
	void SetMapCenter(const struct FVector2D& Center);
	void SetMapRotation(float RotationAngle);
	void SetMapZoom(float Zoom);

	bool CanInteractWithZone(const class FName& ZoneName) const;
	class UGzMapWidget* GetMapWidget() const;
	float GetMapWidth() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzMapController">();
	}
	static class UGzMapController* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzMapController>();
	}
};
static_assert(alignof(UGzMapController) == 0x000008, "Wrong alignment on UGzMapController");
static_assert(sizeof(UGzMapController) == 0x000058, "Wrong size on UGzMapController");
static_assert(offsetof(UGzMapController, OnMapClickDelegate) == 0x000030, "Member 'UGzMapController::OnMapClickDelegate' has a wrong offset!");
static_assert(offsetof(UGzMapController, MapWidget) == 0x000040, "Member 'UGzMapController::MapWidget' has a wrong offset!");
static_assert(offsetof(UGzMapController, bSupportInteraction) == 0x000048, "Member 'UGzMapController::bSupportInteraction' has a wrong offset!");
static_assert(offsetof(UGzMapController, bSupportZoneInteraction) == 0x000049, "Member 'UGzMapController::bSupportZoneInteraction' has a wrong offset!");
static_assert(offsetof(UGzMapController, HoveredZone) == 0x000050, "Member 'UGzMapController::HoveredZone' has a wrong offset!");

// Class G01.GzBodyPartAbilityData_RDrone
// 0x0010 (0x0090 - 0x0080)
class UGzBodyPartAbilityData_RDrone final : public UGzBodyPartAbilityData
{
public:
	float                                         Duration;                                          // 0x0080(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Radius;                                            // 0x0084(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Health;                                            // 0x0088(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_306C[0x4];                                     // 0x008C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzBodyPartAbilityData_RDrone">();
	}
	static class UGzBodyPartAbilityData_RDrone* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzBodyPartAbilityData_RDrone>();
	}
};
static_assert(alignof(UGzBodyPartAbilityData_RDrone) == 0x000008, "Wrong alignment on UGzBodyPartAbilityData_RDrone");
static_assert(sizeof(UGzBodyPartAbilityData_RDrone) == 0x000090, "Wrong size on UGzBodyPartAbilityData_RDrone");
static_assert(offsetof(UGzBodyPartAbilityData_RDrone, Duration) == 0x000080, "Member 'UGzBodyPartAbilityData_RDrone::Duration' has a wrong offset!");
static_assert(offsetof(UGzBodyPartAbilityData_RDrone, Radius) == 0x000084, "Member 'UGzBodyPartAbilityData_RDrone::Radius' has a wrong offset!");
static_assert(offsetof(UGzBodyPartAbilityData_RDrone, Health) == 0x000088, "Member 'UGzBodyPartAbilityData_RDrone::Health' has a wrong offset!");

// Class G01.GzBodyPartAbilityData_Shield
// 0x0030 (0x00B0 - 0x0080)
class UGzBodyPartAbilityData_Shield final : public UGzBodyPartAbilityData
{
public:
	float                                         ShieldMaxWidth;                                    // 0x0080(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ShieldMaxHeight;                                   // 0x0084(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ShieldUpOffset;                                    // 0x0088(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ShieldMaxWidth_Legless;                            // 0x008C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ShieldMaxHeight_Legless;                           // 0x0090(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ShieldUpOffset_Legless;                            // 0x0094(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         EnergyRegenDelay;                                  // 0x0098(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinLimbEnergyToActivateAfterDestruction;           // 0x009C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         EnergyDamageRatio;                                 // 0x00A0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HitEffectSlowdownMultiplier;                       // 0x00A4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HitEffectSlowdownDuration;                         // 0x00A8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxBlastDamage;                                    // 0x00AC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzBodyPartAbilityData_Shield">();
	}
	static class UGzBodyPartAbilityData_Shield* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzBodyPartAbilityData_Shield>();
	}
};
static_assert(alignof(UGzBodyPartAbilityData_Shield) == 0x000008, "Wrong alignment on UGzBodyPartAbilityData_Shield");
static_assert(sizeof(UGzBodyPartAbilityData_Shield) == 0x0000B0, "Wrong size on UGzBodyPartAbilityData_Shield");
static_assert(offsetof(UGzBodyPartAbilityData_Shield, ShieldMaxWidth) == 0x000080, "Member 'UGzBodyPartAbilityData_Shield::ShieldMaxWidth' has a wrong offset!");
static_assert(offsetof(UGzBodyPartAbilityData_Shield, ShieldMaxHeight) == 0x000084, "Member 'UGzBodyPartAbilityData_Shield::ShieldMaxHeight' has a wrong offset!");
static_assert(offsetof(UGzBodyPartAbilityData_Shield, ShieldUpOffset) == 0x000088, "Member 'UGzBodyPartAbilityData_Shield::ShieldUpOffset' has a wrong offset!");
static_assert(offsetof(UGzBodyPartAbilityData_Shield, ShieldMaxWidth_Legless) == 0x00008C, "Member 'UGzBodyPartAbilityData_Shield::ShieldMaxWidth_Legless' has a wrong offset!");
static_assert(offsetof(UGzBodyPartAbilityData_Shield, ShieldMaxHeight_Legless) == 0x000090, "Member 'UGzBodyPartAbilityData_Shield::ShieldMaxHeight_Legless' has a wrong offset!");
static_assert(offsetof(UGzBodyPartAbilityData_Shield, ShieldUpOffset_Legless) == 0x000094, "Member 'UGzBodyPartAbilityData_Shield::ShieldUpOffset_Legless' has a wrong offset!");
static_assert(offsetof(UGzBodyPartAbilityData_Shield, EnergyRegenDelay) == 0x000098, "Member 'UGzBodyPartAbilityData_Shield::EnergyRegenDelay' has a wrong offset!");
static_assert(offsetof(UGzBodyPartAbilityData_Shield, MinLimbEnergyToActivateAfterDestruction) == 0x00009C, "Member 'UGzBodyPartAbilityData_Shield::MinLimbEnergyToActivateAfterDestruction' has a wrong offset!");
static_assert(offsetof(UGzBodyPartAbilityData_Shield, EnergyDamageRatio) == 0x0000A0, "Member 'UGzBodyPartAbilityData_Shield::EnergyDamageRatio' has a wrong offset!");
static_assert(offsetof(UGzBodyPartAbilityData_Shield, HitEffectSlowdownMultiplier) == 0x0000A4, "Member 'UGzBodyPartAbilityData_Shield::HitEffectSlowdownMultiplier' has a wrong offset!");
static_assert(offsetof(UGzBodyPartAbilityData_Shield, HitEffectSlowdownDuration) == 0x0000A8, "Member 'UGzBodyPartAbilityData_Shield::HitEffectSlowdownDuration' has a wrong offset!");
static_assert(offsetof(UGzBodyPartAbilityData_Shield, MaxBlastDamage) == 0x0000AC, "Member 'UGzBodyPartAbilityData_Shield::MaxBlastDamage' has a wrong offset!");

// Class G01.GzBodyPartAbilityData_SmokeWall
// 0x0030 (0x00B0 - 0x0080)
class UGzBodyPartAbilityData_SmokeWall final : public UGzBodyPartAbilityData
{
public:
	TSoftClassPtr<class UClass>                   PropagationActorClass;                             // 0x0080(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SmokeLifespan;                                     // 0x00A8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_306D[0x4];                                     // 0x00AC(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzBodyPartAbilityData_SmokeWall">();
	}
	static class UGzBodyPartAbilityData_SmokeWall* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzBodyPartAbilityData_SmokeWall>();
	}
};
static_assert(alignof(UGzBodyPartAbilityData_SmokeWall) == 0x000008, "Wrong alignment on UGzBodyPartAbilityData_SmokeWall");
static_assert(sizeof(UGzBodyPartAbilityData_SmokeWall) == 0x0000B0, "Wrong size on UGzBodyPartAbilityData_SmokeWall");
static_assert(offsetof(UGzBodyPartAbilityData_SmokeWall, PropagationActorClass) == 0x000080, "Member 'UGzBodyPartAbilityData_SmokeWall::PropagationActorClass' has a wrong offset!");
static_assert(offsetof(UGzBodyPartAbilityData_SmokeWall, SmokeLifespan) == 0x0000A8, "Member 'UGzBodyPartAbilityData_SmokeWall::SmokeLifespan' has a wrong offset!");

// Class G01.GzWeaponAIData
// 0x00C8 (0x00F8 - 0x0030)
class UGzWeaponAIData final : public UDataAsset
{
public:
	float                                         FireLoudness;                                      // 0x0030(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FireMaxRange;                                      // 0x0034(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ReloadLoudness;                                    // 0x0038(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ReloadMaxRange;                                    // 0x003C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HitLoudness;                                       // 0x0040(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HitMaxRange;                                       // 0x0044(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCurveFloat*                            DistanceWeightsCurve;                              // 0x0048(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         OptimalAttackDistanceMin;                          // 0x0050(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         OptimalAttackDistanceMax;                          // 0x0054(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMap<EGzWeaponMode, struct FGzWeaponModeAIData> FireModeDistanceMap;                               // 0x0058(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TMap<EGzCharacterDamageAreaType, struct FGzDamageAreaAIData> DamageAreaDataMap;                                 // 0x00A8(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzWeaponAIData">();
	}
	static class UGzWeaponAIData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzWeaponAIData>();
	}
};
static_assert(alignof(UGzWeaponAIData) == 0x000008, "Wrong alignment on UGzWeaponAIData");
static_assert(sizeof(UGzWeaponAIData) == 0x0000F8, "Wrong size on UGzWeaponAIData");
static_assert(offsetof(UGzWeaponAIData, FireLoudness) == 0x000030, "Member 'UGzWeaponAIData::FireLoudness' has a wrong offset!");
static_assert(offsetof(UGzWeaponAIData, FireMaxRange) == 0x000034, "Member 'UGzWeaponAIData::FireMaxRange' has a wrong offset!");
static_assert(offsetof(UGzWeaponAIData, ReloadLoudness) == 0x000038, "Member 'UGzWeaponAIData::ReloadLoudness' has a wrong offset!");
static_assert(offsetof(UGzWeaponAIData, ReloadMaxRange) == 0x00003C, "Member 'UGzWeaponAIData::ReloadMaxRange' has a wrong offset!");
static_assert(offsetof(UGzWeaponAIData, HitLoudness) == 0x000040, "Member 'UGzWeaponAIData::HitLoudness' has a wrong offset!");
static_assert(offsetof(UGzWeaponAIData, HitMaxRange) == 0x000044, "Member 'UGzWeaponAIData::HitMaxRange' has a wrong offset!");
static_assert(offsetof(UGzWeaponAIData, DistanceWeightsCurve) == 0x000048, "Member 'UGzWeaponAIData::DistanceWeightsCurve' has a wrong offset!");
static_assert(offsetof(UGzWeaponAIData, OptimalAttackDistanceMin) == 0x000050, "Member 'UGzWeaponAIData::OptimalAttackDistanceMin' has a wrong offset!");
static_assert(offsetof(UGzWeaponAIData, OptimalAttackDistanceMax) == 0x000054, "Member 'UGzWeaponAIData::OptimalAttackDistanceMax' has a wrong offset!");
static_assert(offsetof(UGzWeaponAIData, FireModeDistanceMap) == 0x000058, "Member 'UGzWeaponAIData::FireModeDistanceMap' has a wrong offset!");
static_assert(offsetof(UGzWeaponAIData, DamageAreaDataMap) == 0x0000A8, "Member 'UGzWeaponAIData::DamageAreaDataMap' has a wrong offset!");

// Class G01.GzBodyPartAbilityData_SuperSprintLegs
// 0x0020 (0x00A0 - 0x0080)
class UGzBodyPartAbilityData_SuperSprintLegs final : public UGzBodyPartAbilityData
{
public:
	float                                         TrailLifetime;                                     // 0x0080(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TrailEffectDuration;                               // 0x0084(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MovementSpeedMultiplier;                           // 0x0088(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SuperSprintStateDuration;                          // 0x008C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bRegenerateDurationWhenInactive;                   // 0x0090(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_306E[0x3];                                     // 0x0091(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         DurationRegenerationMagnitude;                     // 0x0094(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinDurationPercentageNecessaryForActivation;       // 0x0098(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bTrailAffectEnemy;                                 // 0x009C(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_306F[0x3];                                     // 0x009D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzBodyPartAbilityData_SuperSprintLegs">();
	}
	static class UGzBodyPartAbilityData_SuperSprintLegs* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzBodyPartAbilityData_SuperSprintLegs>();
	}
};
static_assert(alignof(UGzBodyPartAbilityData_SuperSprintLegs) == 0x000008, "Wrong alignment on UGzBodyPartAbilityData_SuperSprintLegs");
static_assert(sizeof(UGzBodyPartAbilityData_SuperSprintLegs) == 0x0000A0, "Wrong size on UGzBodyPartAbilityData_SuperSprintLegs");
static_assert(offsetof(UGzBodyPartAbilityData_SuperSprintLegs, TrailLifetime) == 0x000080, "Member 'UGzBodyPartAbilityData_SuperSprintLegs::TrailLifetime' has a wrong offset!");
static_assert(offsetof(UGzBodyPartAbilityData_SuperSprintLegs, TrailEffectDuration) == 0x000084, "Member 'UGzBodyPartAbilityData_SuperSprintLegs::TrailEffectDuration' has a wrong offset!");
static_assert(offsetof(UGzBodyPartAbilityData_SuperSprintLegs, MovementSpeedMultiplier) == 0x000088, "Member 'UGzBodyPartAbilityData_SuperSprintLegs::MovementSpeedMultiplier' has a wrong offset!");
static_assert(offsetof(UGzBodyPartAbilityData_SuperSprintLegs, SuperSprintStateDuration) == 0x00008C, "Member 'UGzBodyPartAbilityData_SuperSprintLegs::SuperSprintStateDuration' has a wrong offset!");
static_assert(offsetof(UGzBodyPartAbilityData_SuperSprintLegs, bRegenerateDurationWhenInactive) == 0x000090, "Member 'UGzBodyPartAbilityData_SuperSprintLegs::bRegenerateDurationWhenInactive' has a wrong offset!");
static_assert(offsetof(UGzBodyPartAbilityData_SuperSprintLegs, DurationRegenerationMagnitude) == 0x000094, "Member 'UGzBodyPartAbilityData_SuperSprintLegs::DurationRegenerationMagnitude' has a wrong offset!");
static_assert(offsetof(UGzBodyPartAbilityData_SuperSprintLegs, MinDurationPercentageNecessaryForActivation) == 0x000098, "Member 'UGzBodyPartAbilityData_SuperSprintLegs::MinDurationPercentageNecessaryForActivation' has a wrong offset!");
static_assert(offsetof(UGzBodyPartAbilityData_SuperSprintLegs, bTrailAffectEnemy) == 0x00009C, "Member 'UGzBodyPartAbilityData_SuperSprintLegs::bTrailAffectEnemy' has a wrong offset!");

// Class G01.GzXRZoneExtension
// 0x00B0 (0x00E8 - 0x0038)
class UGzXRZoneExtension : public UGzMapWidgetExtension
{
public:
	class UGzZoneFillLayerWidget*                 CurrentZoneLayer;                                  // 0x0038(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class AGzShrinkingZoneManager*                ShrinkingZoneManager;                              // 0x0040(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class UGzRingMapDecoration*>           RevealedZoneCirclesWidgets;                        // 0x0048(0x0010)(ExportObject, ZeroConstructor, Transient, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	class UGzRingMapDecoration*                   CurrentCircleWidget;                               // 0x0058(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UMaterialInterface*                     ZoneFillMaterial;                                  // 0x0060(0x0008)(Edit, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         ZoneZOrder;                                        // 0x0068(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         CurrentZoneCircleZOrder;                           // 0x006C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         NextZoneCircleZOrder;                              // 0x0070(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3070[0x4];                                     // 0x0074(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UGzRingMapDecoration>       TargetZoneWidgetClass;                             // 0x0078(0x0008)(Edit, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UGzRingMapDecoration>       CurrentZoneCircleWidgetClass;                      // 0x0080(0x0008)(Edit, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TMap<struct FGameplayTag, TSubclassOf<class UGzRingMapDecoration>> TargetZoneWidgetClassMap;                          // 0x0088(0x0050)(Edit, Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	class UTexture2D*                             DefaultPlayableAreaMask;                           // 0x00D8(0x0008)(Edit, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3071[0x8];                                     // 0x00E0(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnGameModeStageChanged();
	void OnPlayableAreaReady();
	void OnStageChanged(const int32 StageIndex);
	void OnZoneAvailable(class AGzShrinkingZone* Zone);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzXRZoneExtension">();
	}
	static class UGzXRZoneExtension* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzXRZoneExtension>();
	}
};
static_assert(alignof(UGzXRZoneExtension) == 0x000008, "Wrong alignment on UGzXRZoneExtension");
static_assert(sizeof(UGzXRZoneExtension) == 0x0000E8, "Wrong size on UGzXRZoneExtension");
static_assert(offsetof(UGzXRZoneExtension, CurrentZoneLayer) == 0x000038, "Member 'UGzXRZoneExtension::CurrentZoneLayer' has a wrong offset!");
static_assert(offsetof(UGzXRZoneExtension, ShrinkingZoneManager) == 0x000040, "Member 'UGzXRZoneExtension::ShrinkingZoneManager' has a wrong offset!");
static_assert(offsetof(UGzXRZoneExtension, RevealedZoneCirclesWidgets) == 0x000048, "Member 'UGzXRZoneExtension::RevealedZoneCirclesWidgets' has a wrong offset!");
static_assert(offsetof(UGzXRZoneExtension, CurrentCircleWidget) == 0x000058, "Member 'UGzXRZoneExtension::CurrentCircleWidget' has a wrong offset!");
static_assert(offsetof(UGzXRZoneExtension, ZoneFillMaterial) == 0x000060, "Member 'UGzXRZoneExtension::ZoneFillMaterial' has a wrong offset!");
static_assert(offsetof(UGzXRZoneExtension, ZoneZOrder) == 0x000068, "Member 'UGzXRZoneExtension::ZoneZOrder' has a wrong offset!");
static_assert(offsetof(UGzXRZoneExtension, CurrentZoneCircleZOrder) == 0x00006C, "Member 'UGzXRZoneExtension::CurrentZoneCircleZOrder' has a wrong offset!");
static_assert(offsetof(UGzXRZoneExtension, NextZoneCircleZOrder) == 0x000070, "Member 'UGzXRZoneExtension::NextZoneCircleZOrder' has a wrong offset!");
static_assert(offsetof(UGzXRZoneExtension, TargetZoneWidgetClass) == 0x000078, "Member 'UGzXRZoneExtension::TargetZoneWidgetClass' has a wrong offset!");
static_assert(offsetof(UGzXRZoneExtension, CurrentZoneCircleWidgetClass) == 0x000080, "Member 'UGzXRZoneExtension::CurrentZoneCircleWidgetClass' has a wrong offset!");
static_assert(offsetof(UGzXRZoneExtension, TargetZoneWidgetClassMap) == 0x000088, "Member 'UGzXRZoneExtension::TargetZoneWidgetClassMap' has a wrong offset!");
static_assert(offsetof(UGzXRZoneExtension, DefaultPlayableAreaMask) == 0x0000D8, "Member 'UGzXRZoneExtension::DefaultPlayableAreaMask' has a wrong offset!");

// Class G01.GzBodyPartAbilityData_ThrowableShield
// 0x0008 (0x0088 - 0x0080)
class UGzBodyPartAbilityData_ThrowableShield final : public UGzBodyPartAbilityData
{
public:
	int32                                         BounceCount;                                       // 0x0080(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3072[0x4];                                     // 0x0084(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzBodyPartAbilityData_ThrowableShield">();
	}
	static class UGzBodyPartAbilityData_ThrowableShield* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzBodyPartAbilityData_ThrowableShield>();
	}
};
static_assert(alignof(UGzBodyPartAbilityData_ThrowableShield) == 0x000008, "Wrong alignment on UGzBodyPartAbilityData_ThrowableShield");
static_assert(sizeof(UGzBodyPartAbilityData_ThrowableShield) == 0x000088, "Wrong size on UGzBodyPartAbilityData_ThrowableShield");
static_assert(offsetof(UGzBodyPartAbilityData_ThrowableShield, BounceCount) == 0x000080, "Member 'UGzBodyPartAbilityData_ThrowableShield::BounceCount' has a wrong offset!");

// Class G01.GzBodyPartAbilityInputData
// 0x0060 (0x0090 - 0x0030)
class UGzBodyPartAbilityInputData final : public UDataAsset
{
public:
	class FText                                   DefaultHintText;                                   // 0x0030(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TMap<EGzAbilityInputModifier, struct FGzBodyPartAbilityInputEntry> InputEntries;                                      // 0x0040(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzBodyPartAbilityInputData">();
	}
	static class UGzBodyPartAbilityInputData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzBodyPartAbilityInputData>();
	}
};
static_assert(alignof(UGzBodyPartAbilityInputData) == 0x000008, "Wrong alignment on UGzBodyPartAbilityInputData");
static_assert(sizeof(UGzBodyPartAbilityInputData) == 0x000090, "Wrong size on UGzBodyPartAbilityInputData");
static_assert(offsetof(UGzBodyPartAbilityInputData, DefaultHintText) == 0x000030, "Member 'UGzBodyPartAbilityInputData::DefaultHintText' has a wrong offset!");
static_assert(offsetof(UGzBodyPartAbilityInputData, InputEntries) == 0x000040, "Member 'UGzBodyPartAbilityInputData::InputEntries' has a wrong offset!");

// Class G01.GzUnityMatchmakingPingService
// 0x0038 (0x00D8 - 0x00A0)
class UGzUnityMatchmakingPingService final : public UGzClientPFObject
{
public:
	uint8                                         Pad_3073[0x38];                                    // 0x00A0(0x0038)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzUnityMatchmakingPingService">();
	}
	static class UGzUnityMatchmakingPingService* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzUnityMatchmakingPingService>();
	}
};
static_assert(alignof(UGzUnityMatchmakingPingService) == 0x000008, "Wrong alignment on UGzUnityMatchmakingPingService");
static_assert(sizeof(UGzUnityMatchmakingPingService) == 0x0000D8, "Wrong size on UGzUnityMatchmakingPingService");

// Class G01.GzLimbLossDamageExecution
// 0x0000 (0x0040 - 0x0040)
class UGzLimbLossDamageExecution final : public UGameplayEffectExecutionCalculation
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzLimbLossDamageExecution">();
	}
	static class UGzLimbLossDamageExecution* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzLimbLossDamageExecution>();
	}
};
static_assert(alignof(UGzLimbLossDamageExecution) == 0x000008, "Wrong alignment on UGzLimbLossDamageExecution");
static_assert(sizeof(UGzLimbLossDamageExecution) == 0x000040, "Wrong size on UGzLimbLossDamageExecution");

// Class G01.GzBodyPartFXData
// 0x0050 (0x0080 - 0x0030)
class UGzBodyPartFXData final : public UDataAsset
{
public:
	class UNiagaraSystem*                         AttachArmNiagaraSystem;                            // 0x0030(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UNiagaraSystem*                         AttachLegsNiagaraSystem;                           // 0x0038(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UNiagaraSystem*                         DetachArmNiagaraSystem;                            // 0x0040(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UNiagaraSystem*                         DetachLegsNiagaraSystem;                           // 0x0048(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAkAudioEvent*                          AttachLeftArmSoundCue;                             // 0x0050(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAkAudioEvent*                          AttachRightArmSoundCue;                            // 0x0058(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAkAudioEvent*                          AttachLegsSoundCue;                                // 0x0060(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAkAudioEvent*                          DetachLeftArmSoundCue;                             // 0x0068(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAkAudioEvent*                          DetachRightArmSoundCue;                            // 0x0070(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAkAudioEvent*                          DetachLegsSoundCue;                                // 0x0078(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzBodyPartFXData">();
	}
	static class UGzBodyPartFXData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzBodyPartFXData>();
	}
};
static_assert(alignof(UGzBodyPartFXData) == 0x000008, "Wrong alignment on UGzBodyPartFXData");
static_assert(sizeof(UGzBodyPartFXData) == 0x000080, "Wrong size on UGzBodyPartFXData");
static_assert(offsetof(UGzBodyPartFXData, AttachArmNiagaraSystem) == 0x000030, "Member 'UGzBodyPartFXData::AttachArmNiagaraSystem' has a wrong offset!");
static_assert(offsetof(UGzBodyPartFXData, AttachLegsNiagaraSystem) == 0x000038, "Member 'UGzBodyPartFXData::AttachLegsNiagaraSystem' has a wrong offset!");
static_assert(offsetof(UGzBodyPartFXData, DetachArmNiagaraSystem) == 0x000040, "Member 'UGzBodyPartFXData::DetachArmNiagaraSystem' has a wrong offset!");
static_assert(offsetof(UGzBodyPartFXData, DetachLegsNiagaraSystem) == 0x000048, "Member 'UGzBodyPartFXData::DetachLegsNiagaraSystem' has a wrong offset!");
static_assert(offsetof(UGzBodyPartFXData, AttachLeftArmSoundCue) == 0x000050, "Member 'UGzBodyPartFXData::AttachLeftArmSoundCue' has a wrong offset!");
static_assert(offsetof(UGzBodyPartFXData, AttachRightArmSoundCue) == 0x000058, "Member 'UGzBodyPartFXData::AttachRightArmSoundCue' has a wrong offset!");
static_assert(offsetof(UGzBodyPartFXData, AttachLegsSoundCue) == 0x000060, "Member 'UGzBodyPartFXData::AttachLegsSoundCue' has a wrong offset!");
static_assert(offsetof(UGzBodyPartFXData, DetachLeftArmSoundCue) == 0x000068, "Member 'UGzBodyPartFXData::DetachLeftArmSoundCue' has a wrong offset!");
static_assert(offsetof(UGzBodyPartFXData, DetachRightArmSoundCue) == 0x000070, "Member 'UGzBodyPartFXData::DetachRightArmSoundCue' has a wrong offset!");
static_assert(offsetof(UGzBodyPartFXData, DetachLegsSoundCue) == 0x000078, "Member 'UGzBodyPartFXData::DetachLegsSoundCue' has a wrong offset!");

// Class G01.GzVoiceChatStateWidget
// 0x00A0 (0x0380 - 0x02E0)
class UGzVoiceChatStateWidget : public UUserWidget
{
public:
	class UCanvasPanel*                           RootContainer;                                     // 0x02E0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UPanelWidget*                           MovingPanel;                                       // 0x02E8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<struct FGzVoiceChatTalker>             Talkers;                                           // 0x02F0(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	TSubclassOf<class UUserWidget>                TalkerWidgetClass;                                 // 0x0300(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FVector2D                              NormalizedPosition;                                // 0x0308(0x0010)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         DelayBeforeDisappear;                              // 0x0318(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_3074[0x4];                                     // 0x031C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UGzSquadPanel*                          LocalSquadPanel;                                   // 0x0320(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TMap<class FString, struct FGzPartyMemberMiscData> PartyMiscData;                                     // 0x0328(0x0050)(Transient, NativeAccessSpecifierPrivate)
	class AGzTeam*                                LocalPlayerTeam;                                   // 0x0378(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void OnControllerInit(class AGzPlayerController* PlayerController, class AGzPlayerState* PlayerState);
	void OnLocalPlayerTeamChanged(class AGzPlayerState* PlayerState);
	void OnPawnChanged(class APawn* Pawn);
	void OnRoomEnter();
	void OnRoomExit();
	void OnTalkerAdded(const struct FGzVoiceChatTalker& NewTalker);
	void SetNormalizedPosition(const struct FVector2D& InPosition);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzVoiceChatStateWidget">();
	}
	static class UGzVoiceChatStateWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzVoiceChatStateWidget>();
	}
};
static_assert(alignof(UGzVoiceChatStateWidget) == 0x000008, "Wrong alignment on UGzVoiceChatStateWidget");
static_assert(sizeof(UGzVoiceChatStateWidget) == 0x000380, "Wrong size on UGzVoiceChatStateWidget");
static_assert(offsetof(UGzVoiceChatStateWidget, RootContainer) == 0x0002E0, "Member 'UGzVoiceChatStateWidget::RootContainer' has a wrong offset!");
static_assert(offsetof(UGzVoiceChatStateWidget, MovingPanel) == 0x0002E8, "Member 'UGzVoiceChatStateWidget::MovingPanel' has a wrong offset!");
static_assert(offsetof(UGzVoiceChatStateWidget, Talkers) == 0x0002F0, "Member 'UGzVoiceChatStateWidget::Talkers' has a wrong offset!");
static_assert(offsetof(UGzVoiceChatStateWidget, TalkerWidgetClass) == 0x000300, "Member 'UGzVoiceChatStateWidget::TalkerWidgetClass' has a wrong offset!");
static_assert(offsetof(UGzVoiceChatStateWidget, NormalizedPosition) == 0x000308, "Member 'UGzVoiceChatStateWidget::NormalizedPosition' has a wrong offset!");
static_assert(offsetof(UGzVoiceChatStateWidget, DelayBeforeDisappear) == 0x000318, "Member 'UGzVoiceChatStateWidget::DelayBeforeDisappear' has a wrong offset!");
static_assert(offsetof(UGzVoiceChatStateWidget, LocalSquadPanel) == 0x000320, "Member 'UGzVoiceChatStateWidget::LocalSquadPanel' has a wrong offset!");
static_assert(offsetof(UGzVoiceChatStateWidget, PartyMiscData) == 0x000328, "Member 'UGzVoiceChatStateWidget::PartyMiscData' has a wrong offset!");
static_assert(offsetof(UGzVoiceChatStateWidget, LocalPlayerTeam) == 0x000378, "Member 'UGzVoiceChatStateWidget::LocalPlayerTeam' has a wrong offset!");

// Class G01.GzBodyPartItemData
// 0x0040 (0x0318 - 0x02D8)
class UGzBodyPartItemData final : public UGzItemData
{
public:
	EGzLimbType                                   Type;                                              // 0x02D8(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3075[0x7];                                     // 0x02D9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UUserWidget>                ActivationGaugeWidgetClass;                        // 0x02E0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UGzBodyPartArchetype*                   BodyPartArchetype;                                 // 0x02E8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UGzBodyPartData*                        BodyPartData;                                      // 0x02F0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UGzDepthOfFieldDataAsset*               DepthOfFieldData;                                  // 0x02F8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGzLimbStatusData                      LimbStatus;                                        // 0x0300(0x0018)(Transient, NoDestructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzBodyPartItemData">();
	}
	static class UGzBodyPartItemData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzBodyPartItemData>();
	}
};
static_assert(alignof(UGzBodyPartItemData) == 0x000008, "Wrong alignment on UGzBodyPartItemData");
static_assert(sizeof(UGzBodyPartItemData) == 0x000318, "Wrong size on UGzBodyPartItemData");
static_assert(offsetof(UGzBodyPartItemData, Type) == 0x0002D8, "Member 'UGzBodyPartItemData::Type' has a wrong offset!");
static_assert(offsetof(UGzBodyPartItemData, ActivationGaugeWidgetClass) == 0x0002E0, "Member 'UGzBodyPartItemData::ActivationGaugeWidgetClass' has a wrong offset!");
static_assert(offsetof(UGzBodyPartItemData, BodyPartArchetype) == 0x0002E8, "Member 'UGzBodyPartItemData::BodyPartArchetype' has a wrong offset!");
static_assert(offsetof(UGzBodyPartItemData, BodyPartData) == 0x0002F0, "Member 'UGzBodyPartItemData::BodyPartData' has a wrong offset!");
static_assert(offsetof(UGzBodyPartItemData, DepthOfFieldData) == 0x0002F8, "Member 'UGzBodyPartItemData::DepthOfFieldData' has a wrong offset!");
static_assert(offsetof(UGzBodyPartItemData, LimbStatus) == 0x000300, "Member 'UGzBodyPartItemData::LimbStatus' has a wrong offset!");

// Class G01.GzWeaponItemSpawner
// 0x0018 (0x02B8 - 0x02A0)
class AGzWeaponItemSpawner final : public AActor
{
public:
	class UGzWeaponSpawner*                       WeaponSpawner;                                     // 0x02A0(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ACameraActor*                           CameraActor;                                       // 0x02A8(0x0008)(Edit, ZeroConstructor, DisableEditOnTemplate, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ASceneCapture2D*                        SceneCapture2D;                                    // 0x02B0(0x0008)(Edit, ZeroConstructor, DisableEditOnTemplate, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzWeaponItemSpawner">();
	}
	static class AGzWeaponItemSpawner* GetDefaultObj()
	{
		return GetDefaultObjImpl<AGzWeaponItemSpawner>();
	}
};
static_assert(alignof(AGzWeaponItemSpawner) == 0x000008, "Wrong alignment on AGzWeaponItemSpawner");
static_assert(sizeof(AGzWeaponItemSpawner) == 0x0002B8, "Wrong size on AGzWeaponItemSpawner");
static_assert(offsetof(AGzWeaponItemSpawner, WeaponSpawner) == 0x0002A0, "Member 'AGzWeaponItemSpawner::WeaponSpawner' has a wrong offset!");
static_assert(offsetof(AGzWeaponItemSpawner, CameraActor) == 0x0002A8, "Member 'AGzWeaponItemSpawner::CameraActor' has a wrong offset!");
static_assert(offsetof(AGzWeaponItemSpawner, SceneCapture2D) == 0x0002B0, "Member 'AGzWeaponItemSpawner::SceneCapture2D' has a wrong offset!");

// Class G01.GzBodyPartSkinItemData
// 0x0000 (0x0318 - 0x0318)
class UGzBodyPartSkinItemData final : public UGzSkinItemData
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzBodyPartSkinItemData">();
	}
	static class UGzBodyPartSkinItemData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzBodyPartSkinItemData>();
	}
};
static_assert(alignof(UGzBodyPartSkinItemData) == 0x000008, "Wrong alignment on UGzBodyPartSkinItemData");
static_assert(sizeof(UGzBodyPartSkinItemData) == 0x000318, "Wrong size on UGzBodyPartSkinItemData");

// Class G01.GzSubscriptionStateComponent
// 0x0098 (0x0138 - 0x00A0)
class UGzSubscriptionStateComponent final : public UGzServiceComponent
{
public:
	uint8                                         Pad_3076[0x98];                                    // 0x00A0(0x0098)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzSubscriptionStateComponent">();
	}
	static class UGzSubscriptionStateComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzSubscriptionStateComponent>();
	}
};
static_assert(alignof(UGzSubscriptionStateComponent) == 0x000008, "Wrong alignment on UGzSubscriptionStateComponent");
static_assert(sizeof(UGzSubscriptionStateComponent) == 0x000138, "Wrong size on UGzSubscriptionStateComponent");

// Class G01.GzInteriorCameraVolume
// 0x0010 (0x02B8 - 0x02A8)
class AGzInteriorCameraVolume : public ATriggerBox
{
public:
	class UCurveFloat*                            FOVOffsetFloatCurve;                               // 0x02A8(0x0008)(Edit, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCurveVector*                           LocationOffsetVectorCurve;                         // 0x02B0(0x0008)(Edit, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void OnBeginOverlap(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const struct FHitResult& SweepResult);
	void OnEndOverlap(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzInteriorCameraVolume">();
	}
	static class AGzInteriorCameraVolume* GetDefaultObj()
	{
		return GetDefaultObjImpl<AGzInteriorCameraVolume>();
	}
};
static_assert(alignof(AGzInteriorCameraVolume) == 0x000008, "Wrong alignment on AGzInteriorCameraVolume");
static_assert(sizeof(AGzInteriorCameraVolume) == 0x0002B8, "Wrong size on AGzInteriorCameraVolume");
static_assert(offsetof(AGzInteriorCameraVolume, FOVOffsetFloatCurve) == 0x0002A8, "Member 'AGzInteriorCameraVolume::FOVOffsetFloatCurve' has a wrong offset!");
static_assert(offsetof(AGzInteriorCameraVolume, LocationOffsetVectorCurve) == 0x0002B0, "Member 'AGzInteriorCameraVolume::LocationOffsetVectorCurve' has a wrong offset!");

// Class G01.GzBoosterPickableInteractionBehaviour
// 0x0008 (0x00F0 - 0x00E8)
class UGzBoosterPickableInteractionBehaviour final : public UGzDefaultPickableInteractionBehaviour
{
public:
	uint8                                         Pad_3079[0x8];                                     // 0x00E8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzBoosterPickableInteractionBehaviour">();
	}
	static class UGzBoosterPickableInteractionBehaviour* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzBoosterPickableInteractionBehaviour>();
	}
};
static_assert(alignof(UGzBoosterPickableInteractionBehaviour) == 0x000008, "Wrong alignment on UGzBoosterPickableInteractionBehaviour");
static_assert(sizeof(UGzBoosterPickableInteractionBehaviour) == 0x0000F0, "Wrong size on UGzBoosterPickableInteractionBehaviour");

// Class G01.GzBoundaryZone
// 0x0068 (0x0308 - 0x02A0)
class AGzBoundaryZone final : public AActor
{
public:
	TArray<struct FVector2D>                      Triangles;                                         // 0x02A0(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	struct FGzBoundaryZoneParams                  SpawnParams;                                       // 0x02B0(0x0018)(Edit, DisableEditOnInstance, NoDestructor, Protected, NativeAccessSpecifierProtected)
	TArray<class FName>                           ZoneNames;                                         // 0x02C8(0x0010)(Net, ZeroConstructor, RepNotify, NativeAccessSpecifierPrivate)
	uint8                                         Pad_307A[0x28];                                    // 0x02D8(0x0028)(Fixing Size After Last Property [ Dumper-7 ])
	class UProceduralMeshComponent*               BorderMesh;                                        // 0x0300(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	struct FGzTeamSpawnPoints GetTeamSpawnPoints(float TeammatesSpawnOffset, const int32 TeammatesCount, float SpawnHeight, float MaxDistFromCenter);
	void OnRep_ZoneNames();
	void SetBounds(const TArray<class FName>& Zones);

	bool IsInsideBoxZoneBounds(const struct FVector2D& Loc2d) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzBoundaryZone">();
	}
	static class AGzBoundaryZone* GetDefaultObj()
	{
		return GetDefaultObjImpl<AGzBoundaryZone>();
	}
};
static_assert(alignof(AGzBoundaryZone) == 0x000008, "Wrong alignment on AGzBoundaryZone");
static_assert(sizeof(AGzBoundaryZone) == 0x000308, "Wrong size on AGzBoundaryZone");
static_assert(offsetof(AGzBoundaryZone, Triangles) == 0x0002A0, "Member 'AGzBoundaryZone::Triangles' has a wrong offset!");
static_assert(offsetof(AGzBoundaryZone, SpawnParams) == 0x0002B0, "Member 'AGzBoundaryZone::SpawnParams' has a wrong offset!");
static_assert(offsetof(AGzBoundaryZone, ZoneNames) == 0x0002C8, "Member 'AGzBoundaryZone::ZoneNames' has a wrong offset!");
static_assert(offsetof(AGzBoundaryZone, BorderMesh) == 0x000300, "Member 'AGzBoundaryZone::BorderMesh' has a wrong offset!");

// Class G01.GzSubscriptionManagingComponent
// 0x0040 (0x00E0 - 0x00A0)
class UGzSubscriptionManagingComponent final : public UGzServiceComponent
{
public:
	uint8                                         Pad_307C[0x20];                                    // 0x00A0(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	class UGzXsollaCoreComponent*                 XsollaCore;                                        // 0x00C0(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_307D[0x18];                                    // 0x00C8(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnSubscriptionsFetchSuccess(const struct FSubscriptionPlansList& SubscriptionPlansList);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzSubscriptionManagingComponent">();
	}
	static class UGzSubscriptionManagingComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzSubscriptionManagingComponent>();
	}
};
static_assert(alignof(UGzSubscriptionManagingComponent) == 0x000008, "Wrong alignment on UGzSubscriptionManagingComponent");
static_assert(sizeof(UGzSubscriptionManagingComponent) == 0x0000E0, "Wrong size on UGzSubscriptionManagingComponent");
static_assert(offsetof(UGzSubscriptionManagingComponent, XsollaCore) == 0x0000C0, "Member 'UGzSubscriptionManagingComponent::XsollaCore' has a wrong offset!");

// Class G01.GzLegalDocsService
// 0x0068 (0x0108 - 0x00A0)
class UGzLegalDocsService final : public UGzClientPFObject
{
public:
	uint8                                         Pad_307E[0x68];                                    // 0x00A0(0x0068)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzLegalDocsService">();
	}
	static class UGzLegalDocsService* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzLegalDocsService>();
	}
};
static_assert(alignof(UGzLegalDocsService) == 0x000008, "Wrong alignment on UGzLegalDocsService");
static_assert(sizeof(UGzLegalDocsService) == 0x000108, "Wrong size on UGzLegalDocsService");

// Class G01.GzBR_DeploymentStage
// 0x0020 (0x0130 - 0x0110)
class UGzBR_DeploymentStage final : public UGzGameStageBase
{
public:
	float                                         DeploymentDuration;                                // 0x0110(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_307F[0x4];                                     // 0x0114(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class AGzDeploymentTransport*>         DeploymentTransport;                               // 0x0118(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_3080[0x8];                                     // 0x0128(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzBR_DeploymentStage">();
	}
	static class UGzBR_DeploymentStage* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzBR_DeploymentStage>();
	}
};
static_assert(alignof(UGzBR_DeploymentStage) == 0x000008, "Wrong alignment on UGzBR_DeploymentStage");
static_assert(sizeof(UGzBR_DeploymentStage) == 0x000130, "Wrong size on UGzBR_DeploymentStage");
static_assert(offsetof(UGzBR_DeploymentStage, DeploymentDuration) == 0x000110, "Member 'UGzBR_DeploymentStage::DeploymentDuration' has a wrong offset!");
static_assert(offsetof(UGzBR_DeploymentStage, DeploymentTransport) == 0x000118, "Member 'UGzBR_DeploymentStage::DeploymentTransport' has a wrong offset!");

// Class G01.GzXR_HexExtractionHackedRedeployModifier
// 0x0008 (0x0090 - 0x0088)
class UGzXR_HexExtractionHackedRedeployModifier final : public UGzXR_BaseRedeployModifier
{
public:
	uint8                                         Pad_3081[0x8];                                     // 0x0088(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzXR_HexExtractionHackedRedeployModifier">();
	}
	static class UGzXR_HexExtractionHackedRedeployModifier* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzXR_HexExtractionHackedRedeployModifier>();
	}
};
static_assert(alignof(UGzXR_HexExtractionHackedRedeployModifier) == 0x000008, "Wrong alignment on UGzXR_HexExtractionHackedRedeployModifier");
static_assert(sizeof(UGzXR_HexExtractionHackedRedeployModifier) == 0x000090, "Wrong size on UGzXR_HexExtractionHackedRedeployModifier");

// Class G01.GzBR_LootAndShootStage
// 0x0010 (0x0120 - 0x0110)
class UGzBR_LootAndShootStage final : public UGzGameStageBase
{
public:
	uint8                                         Pad_3082[0x10];                                    // 0x0110(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnGridOverloadStateChanged(bool bOverloadActivated);
	void OnTeamDefeated(class AGzTeam* Team);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzBR_LootAndShootStage">();
	}
	static class UGzBR_LootAndShootStage* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzBR_LootAndShootStage>();
	}
};
static_assert(alignof(UGzBR_LootAndShootStage) == 0x000008, "Wrong alignment on UGzBR_LootAndShootStage");
static_assert(sizeof(UGzBR_LootAndShootStage) == 0x000120, "Wrong size on UGzBR_LootAndShootStage");

// Class G01.GzBR_MatchInProgressStage
// 0x0010 (0x0128 - 0x0118)
class UGzBR_MatchInProgressStage final : public UGzMatchInProgressStage
{
public:
	TArray<class AGzTeam*>                        AliveTeams;                                        // 0x0118(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)

public:
	void OnTeamChanged(class AGzPlayerState* PlayerState, int32 PrevTeamID, int32 NewTeamId);
	void OnTeamDefeated(class AGzTeam* DefeatedTeam);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzBR_MatchInProgressStage">();
	}
	static class UGzBR_MatchInProgressStage* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzBR_MatchInProgressStage>();
	}
};
static_assert(alignof(UGzBR_MatchInProgressStage) == 0x000008, "Wrong alignment on UGzBR_MatchInProgressStage");
static_assert(sizeof(UGzBR_MatchInProgressStage) == 0x000128, "Wrong size on UGzBR_MatchInProgressStage");
static_assert(offsetof(UGzBR_MatchInProgressStage, AliveTeams) == 0x000118, "Member 'UGzBR_MatchInProgressStage::AliveTeams' has a wrong offset!");

// Class G01.GzBR_PreMatchCountdownStage
// 0x0008 (0x0118 - 0x0110)
class UGzBR_PreMatchCountdownStage final : public UGzGameStageBase
{
public:
	uint8                                         Pad_3083[0x8];                                     // 0x0110(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzBR_PreMatchCountdownStage">();
	}
	static class UGzBR_PreMatchCountdownStage* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzBR_PreMatchCountdownStage>();
	}
};
static_assert(alignof(UGzBR_PreMatchCountdownStage) == 0x000008, "Wrong alignment on UGzBR_PreMatchCountdownStage");
static_assert(sizeof(UGzBR_PreMatchCountdownStage) == 0x000118, "Wrong size on UGzBR_PreMatchCountdownStage");

// Class G01.GzBR_PreMatchStage
// 0x0018 (0x0130 - 0x0118)
class UGzBR_PreMatchStage final : public UGzPreMatchStage
{
public:
	TArray<class AGzSpawnZone*>                   SpawnZones;                                        // 0x0118(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	uint8                                         Pad_3084[0x8];                                     // 0x0128(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzBR_PreMatchStage">();
	}
	static class UGzBR_PreMatchStage* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzBR_PreMatchStage>();
	}
};
static_assert(alignof(UGzBR_PreMatchStage) == 0x000008, "Wrong alignment on UGzBR_PreMatchStage");
static_assert(sizeof(UGzBR_PreMatchStage) == 0x000130, "Wrong size on UGzBR_PreMatchStage");
static_assert(offsetof(UGzBR_PreMatchStage, SpawnZones) == 0x000118, "Member 'UGzBR_PreMatchStage::SpawnZones' has a wrong offset!");

// Class G01.GzWeaponSensitivityModifier
// 0x0008 (0x0030 - 0x0028)
class UGzWeaponSensitivityModifier final : public UGzWeaponAimModifier
{
public:
	float                                         SensitvityPitchCoefficient;                        // 0x0028(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SensitvityYawCoefficient;                          // 0x002C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzWeaponSensitivityModifier">();
	}
	static class UGzWeaponSensitivityModifier* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzWeaponSensitivityModifier>();
	}
};
static_assert(alignof(UGzWeaponSensitivityModifier) == 0x000008, "Wrong alignment on UGzWeaponSensitivityModifier");
static_assert(sizeof(UGzWeaponSensitivityModifier) == 0x000030, "Wrong size on UGzWeaponSensitivityModifier");
static_assert(offsetof(UGzWeaponSensitivityModifier, SensitvityPitchCoefficient) == 0x000028, "Member 'UGzWeaponSensitivityModifier::SensitvityPitchCoefficient' has a wrong offset!");
static_assert(offsetof(UGzWeaponSensitivityModifier, SensitvityYawCoefficient) == 0x00002C, "Member 'UGzWeaponSensitivityModifier::SensitvityYawCoefficient' has a wrong offset!");

// Class G01.GzXsollaCoreComponent
// 0x0030 (0x00D0 - 0x00A0)
class UGzXsollaCoreComponent final : public UGzServiceComponent
{
public:
	uint8                                         Pad_3085[0x30];                                    // 0x00A0(0x0030)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void LaunchPaymentConsole(const class FString& AccessToken, int32 OrderId);

	void OnGeneralXsollaError(int32 StatusCode, int32 ErrorCode, const class FString& ErrorMessage) const;
	void OnPaymentBrowserClosed(bool bIsManually) const;
	void OnStoreSuccessPayment() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzXsollaCoreComponent">();
	}
	static class UGzXsollaCoreComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzXsollaCoreComponent>();
	}
};
static_assert(alignof(UGzXsollaCoreComponent) == 0x000008, "Wrong alignment on UGzXsollaCoreComponent");
static_assert(sizeof(UGzXsollaCoreComponent) == 0x0000D0, "Wrong size on UGzXsollaCoreComponent");

// Class G01.GzBTServiceSetEnemyFocus
// 0x0008 (0x00B0 - 0x00A8)
class UGzBTServiceSetEnemyFocus final : public UGzBTBaseService
{
public:
	float                                         OffsetDefault;                                     // 0x00A8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         RatioOffsetWithoutToken;                           // 0x00AC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzBTServiceSetEnemyFocus">();
	}
	static class UGzBTServiceSetEnemyFocus* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzBTServiceSetEnemyFocus>();
	}
};
static_assert(alignof(UGzBTServiceSetEnemyFocus) == 0x000008, "Wrong alignment on UGzBTServiceSetEnemyFocus");
static_assert(sizeof(UGzBTServiceSetEnemyFocus) == 0x0000B0, "Wrong size on UGzBTServiceSetEnemyFocus");
static_assert(offsetof(UGzBTServiceSetEnemyFocus, OffsetDefault) == 0x0000A8, "Member 'UGzBTServiceSetEnemyFocus::OffsetDefault' has a wrong offset!");
static_assert(offsetof(UGzBTServiceSetEnemyFocus, RatioOffsetWithoutToken) == 0x0000AC, "Member 'UGzBTServiceSetEnemyFocus::RatioOffsetWithoutToken' has a wrong offset!");

// Class G01.GzVoiceChatHelper
// 0x0000 (0x0028 - 0x0028)
class UGzVoiceChatHelper final : public UBlueprintFunctionLibrary
{
public:
	static void BlockPlayer(const class UObject* WorldContextObject, const class FString& EpicUserId);
	static TArray<class FString> GetBlockedPlayers(const class UObject* WorldContextObject);
	static void GetInputDevices(const class UObject* WorldContextObject, TArray<struct FGzVoiceChatAudioDevice>* Result);
	static void GetOutputDevices(const class UObject* WorldContextObject, TArray<struct FGzVoiceChatAudioDevice>* Result);
	static class UGzVoiceChatBlueprintEventsComponent* GetVoiceChatEvents(const class UObject* WorldContextObject);
	static bool IsPlayerBlocked(const class UObject* WorldContextObject, const class FString& EpicUserId);
	static void SetVoiceState(const class UObject* WorldContextObject, bool bState);
	static void UnblockPlayer(const class UObject* WorldContextObject, const class FString& EpicUserId);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzVoiceChatHelper">();
	}
	static class UGzVoiceChatHelper* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzVoiceChatHelper>();
	}
};
static_assert(alignof(UGzVoiceChatHelper) == 0x000008, "Wrong alignment on UGzVoiceChatHelper");
static_assert(sizeof(UGzVoiceChatHelper) == 0x000028, "Wrong size on UGzVoiceChatHelper");

// Class G01.GzLoadingScreenView
// 0x0050 (0x0330 - 0x02E0)
class UGzLoadingScreenView : public UUserWidget
{
public:
	uint8                                         Pad_3089[0x28];                                    // 0x02E0(0x0028)(Fixing Size After Last Property [ Dumper-7 ])
	class UGzLoadingScreenContext*                Context;                                           // 0x0308(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UGzLoadingScreenMoviesCollection*       Movies;                                            // 0x0310(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_308A[0x18];                                    // 0x0318(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnShutdownAvailable();
	void OnStartup(class UGzLoadingScreenContext* InContext);

	TArray<class UWidget*> GetBackgroundWidgets() const;
	EGzLoadingInputType GetInputType() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzLoadingScreenView">();
	}
	static class UGzLoadingScreenView* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzLoadingScreenView>();
	}
};
static_assert(alignof(UGzLoadingScreenView) == 0x000008, "Wrong alignment on UGzLoadingScreenView");
static_assert(sizeof(UGzLoadingScreenView) == 0x000330, "Wrong size on UGzLoadingScreenView");
static_assert(offsetof(UGzLoadingScreenView, Context) == 0x000308, "Member 'UGzLoadingScreenView::Context' has a wrong offset!");
static_assert(offsetof(UGzLoadingScreenView, Movies) == 0x000310, "Member 'UGzLoadingScreenView::Movies' has a wrong offset!");

// Class G01.GzBTServiceTurretAnimsState
// 0x0000 (0x00A8 - 0x00A8)
class UGzBTServiceTurretAnimsState final : public UGzBTBaseService
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzBTServiceTurretAnimsState">();
	}
	static class UGzBTServiceTurretAnimsState* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzBTServiceTurretAnimsState>();
	}
};
static_assert(alignof(UGzBTServiceTurretAnimsState) == 0x000008, "Wrong alignment on UGzBTServiceTurretAnimsState");
static_assert(sizeof(UGzBTServiceTurretAnimsState) == 0x0000A8, "Wrong size on UGzBTServiceTurretAnimsState");

// Class G01.GzLootTableSlotsSetup
// 0x0010 (0x0040 - 0x0030)
class UGzLootTableSlotsSetup final : public UDataAsset
{
public:
	TArray<struct FGzLootlTableSlot>              LootSlots;                                         // 0x0030(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzLootTableSlotsSetup">();
	}
	static class UGzLootTableSlotsSetup* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzLootTableSlotsSetup>();
	}
};
static_assert(alignof(UGzLootTableSlotsSetup) == 0x000008, "Wrong alignment on UGzLootTableSlotsSetup");
static_assert(sizeof(UGzLootTableSlotsSetup) == 0x000040, "Wrong size on UGzLootTableSlotsSetup");
static_assert(offsetof(UGzLootTableSlotsSetup, LootSlots) == 0x000030, "Member 'UGzLootTableSlotsSetup::LootSlots' has a wrong offset!");

// Class G01.GzBTTaskFindCover
// 0x00A8 (0x0140 - 0x0098)
class UGzBTTaskFindCover final : public UBTTask_BlackboardBase
{
public:
	struct FBlackboardKeySelector                 CoverObjectBlackboardKey;                          // 0x0098(0x0028)(Edit, Protected, NativeAccessSpecifierProtected)
	struct FBlackboardKeySelector                 MoveLocationBlackboardKey;                         // 0x00C0(0x0028)(Edit, Protected, NativeAccessSpecifierProtected)
	struct FBlackboardKeySelector                 CoverPointType;                                    // 0x00E8(0x0028)(Edit, Protected, NativeAccessSpecifierProtected)
	struct FVector                                AABBExt;                                           // 0x0110(0x0018)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         RatioPath;                                         // 0x0128(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         MaxCoverPoints;                                    // 0x012C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_308B[0x10];                                    // 0x0130(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzBTTaskFindCover">();
	}
	static class UGzBTTaskFindCover* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzBTTaskFindCover>();
	}
};
static_assert(alignof(UGzBTTaskFindCover) == 0x000008, "Wrong alignment on UGzBTTaskFindCover");
static_assert(sizeof(UGzBTTaskFindCover) == 0x000140, "Wrong size on UGzBTTaskFindCover");
static_assert(offsetof(UGzBTTaskFindCover, CoverObjectBlackboardKey) == 0x000098, "Member 'UGzBTTaskFindCover::CoverObjectBlackboardKey' has a wrong offset!");
static_assert(offsetof(UGzBTTaskFindCover, MoveLocationBlackboardKey) == 0x0000C0, "Member 'UGzBTTaskFindCover::MoveLocationBlackboardKey' has a wrong offset!");
static_assert(offsetof(UGzBTTaskFindCover, CoverPointType) == 0x0000E8, "Member 'UGzBTTaskFindCover::CoverPointType' has a wrong offset!");
static_assert(offsetof(UGzBTTaskFindCover, AABBExt) == 0x000110, "Member 'UGzBTTaskFindCover::AABBExt' has a wrong offset!");
static_assert(offsetof(UGzBTTaskFindCover, RatioPath) == 0x000128, "Member 'UGzBTTaskFindCover::RatioPath' has a wrong offset!");
static_assert(offsetof(UGzBTTaskFindCover, MaxCoverPoints) == 0x00012C, "Member 'UGzBTTaskFindCover::MaxCoverPoints' has a wrong offset!");

// Class G01.GzWeaponSystemBase
// 0x0010 (0x0038 - 0x0028)
class UGzWeaponSystemBase : public UObject
{
public:
	uint8                                         Pad_308C[0x8];                                     // 0x0028(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UGzWeaponComponent*                     CachedWeaponComponent;                             // 0x0030(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzWeaponSystemBase">();
	}
	static class UGzWeaponSystemBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzWeaponSystemBase>();
	}
};
static_assert(alignof(UGzWeaponSystemBase) == 0x000008, "Wrong alignment on UGzWeaponSystemBase");
static_assert(sizeof(UGzWeaponSystemBase) == 0x000038, "Wrong size on UGzWeaponSystemBase");
static_assert(offsetof(UGzWeaponSystemBase, CachedWeaponComponent) == 0x000030, "Member 'UGzWeaponSystemBase::CachedWeaponComponent' has a wrong offset!");

// Class G01.GzWeaponRecoilSystem
// 0x0090 (0x00C8 - 0x0038)
class UGzWeaponRecoilSystem final : public UGzWeaponSystemBase
{
public:
	TArray<class UGzWeaponRecoilModifier*>        RecoilModifiers;                                   // 0x0038(0x0010)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	class UGzWeaponRecoilProgressTask*            RecoilProgressTask;                                // 0x0048(0x0008)(ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UGzWeaponRecoilCompensatingChecker*     CompensatingChecker;                               // 0x0050(0x0008)(ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_308D[0x70];                                    // 0x0058(0x0070)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnPostRecoilTravelCooldown();
	void OnRecoilPatternOverCompensating();
	void OnRecoilShotCooldown();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzWeaponRecoilSystem">();
	}
	static class UGzWeaponRecoilSystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzWeaponRecoilSystem>();
	}
};
static_assert(alignof(UGzWeaponRecoilSystem) == 0x000008, "Wrong alignment on UGzWeaponRecoilSystem");
static_assert(sizeof(UGzWeaponRecoilSystem) == 0x0000C8, "Wrong size on UGzWeaponRecoilSystem");
static_assert(offsetof(UGzWeaponRecoilSystem, RecoilModifiers) == 0x000038, "Member 'UGzWeaponRecoilSystem::RecoilModifiers' has a wrong offset!");
static_assert(offsetof(UGzWeaponRecoilSystem, RecoilProgressTask) == 0x000048, "Member 'UGzWeaponRecoilSystem::RecoilProgressTask' has a wrong offset!");
static_assert(offsetof(UGzWeaponRecoilSystem, CompensatingChecker) == 0x000050, "Member 'UGzWeaponRecoilSystem::CompensatingChecker' has a wrong offset!");

// Class G01.GzBulletParams
// 0x0010 (0x0038 - 0x0028)
class UGzBulletParams final : public UObject
{
public:
	float                                         Lifetime;                                          // 0x0028(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         StartVelocity;                                     // 0x002C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         GravityAcceleration;                               // 0x0030(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ParticleSpawnOffset;                               // 0x0034(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzBulletParams">();
	}
	static class UGzBulletParams* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzBulletParams>();
	}
};
static_assert(alignof(UGzBulletParams) == 0x000008, "Wrong alignment on UGzBulletParams");
static_assert(sizeof(UGzBulletParams) == 0x000038, "Wrong size on UGzBulletParams");
static_assert(offsetof(UGzBulletParams, Lifetime) == 0x000028, "Member 'UGzBulletParams::Lifetime' has a wrong offset!");
static_assert(offsetof(UGzBulletParams, StartVelocity) == 0x00002C, "Member 'UGzBulletParams::StartVelocity' has a wrong offset!");
static_assert(offsetof(UGzBulletParams, GravityAcceleration) == 0x000030, "Member 'UGzBulletParams::GravityAcceleration' has a wrong offset!");
static_assert(offsetof(UGzBulletParams, ParticleSpawnOffset) == 0x000034, "Member 'UGzBulletParams::ParticleSpawnOffset' has a wrong offset!");

// Class G01.GzBulletAttackStrategy
// 0x0058 (0x0100 - 0x00A8)
class UGzBulletAttackStrategy final : public UGzWeaponAttackStrategy
{
public:
	class UGzBulletSubsystem*                     BulletSubsystem;                                   // 0x00A8(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UGzWeaponData*                          WeaponData;                                        // 0x00B0(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class UGzWeaponBulletTravelModifier*>  WeaponBulletTravelModifiers;                       // 0x00B8(0x0010)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_308E[0x38];                                    // 0x00C8(0x0038)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzBulletAttackStrategy">();
	}
	static class UGzBulletAttackStrategy* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzBulletAttackStrategy>();
	}
};
static_assert(alignof(UGzBulletAttackStrategy) == 0x000008, "Wrong alignment on UGzBulletAttackStrategy");
static_assert(sizeof(UGzBulletAttackStrategy) == 0x000100, "Wrong size on UGzBulletAttackStrategy");
static_assert(offsetof(UGzBulletAttackStrategy, BulletSubsystem) == 0x0000A8, "Member 'UGzBulletAttackStrategy::BulletSubsystem' has a wrong offset!");
static_assert(offsetof(UGzBulletAttackStrategy, WeaponData) == 0x0000B0, "Member 'UGzBulletAttackStrategy::WeaponData' has a wrong offset!");
static_assert(offsetof(UGzBulletAttackStrategy, WeaponBulletTravelModifiers) == 0x0000B8, "Member 'UGzBulletAttackStrategy::WeaponBulletTravelModifiers' has a wrong offset!");

// Class G01.GzThrowableItemData
// 0x0008 (0x03D0 - 0x03C8)
class UGzThrowableItemData final : public UGzConsumableItemData
{
public:
	class UGzProjectileData*                      ThrowableData;                                     // 0x03C8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzThrowableItemData">();
	}
	static class UGzThrowableItemData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzThrowableItemData>();
	}
};
static_assert(alignof(UGzThrowableItemData) == 0x000008, "Wrong alignment on UGzThrowableItemData");
static_assert(sizeof(UGzThrowableItemData) == 0x0003D0, "Wrong size on UGzThrowableItemData");
static_assert(offsetof(UGzThrowableItemData, ThrowableData) == 0x0003C8, "Member 'UGzThrowableItemData::ThrowableData' has a wrong offset!");

// Class G01.GzJetpackComponent
// 0x0078 (0x0120 - 0x00A8)
class UGzJetpackComponent : public UActorComponent
{
public:
	uint8                                         Pad_308F[0x8];                                     // 0x00A8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ZiplineJumpOnDuration;                             // 0x00B0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ZiplineJumpOffMaxDuration;                         // 0x00B4(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bActive;                                           // 0x00B8(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3090[0x7];                                     // 0x00B9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UGzWingsuitSettingsDataAsset*           CachedSettings;                                    // 0x00C0(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3091[0x4];                                     // 0x00C8(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGzDamageAreaInfo                      DamageAreaInfo;                                    // 0x00CC(0x000C)(Edit, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPrivate)
	class UMeshComponent*                         VisualComponent;                                   // 0x00D8(0x0008)(Edit, ExportObject, ZeroConstructor, Transient, EditConst, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	EGzCharacterDamageAreaType                    DamageAreaType;                                    // 0x00E0(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_3092[0x3];                                     // 0x00E1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   DamageableBone;                                    // 0x00E4(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_3093[0x4];                                     // 0x00EC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class AGzMultiPartCharacter*                  CachedCharacter;                                   // 0x00F0(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UAkComponent*                           ProximityComponent;                                // 0x00F8(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_3094[0x20];                                    // 0x0100(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void DetachJetpackBoostVisual();
	void K2_EndZiplineJumpOffVFX();
	void K2_EndZiplineJumpOnVFX();
	void K2_OnEndWingsuit();
	void K2_OnPlayerHit();
	void K2_OnStartWingsuit();
	void K2_StartZiplineJumpOffVFX();
	void K2_StartZiplineJumpOnVFX();
	void OnAkEventEnd(EAkCallbackType CallbackType, class UAkCallbackInfo* CallbackInfo);
	void OnVisualMeshSet(class UMeshComponent* NewVisualComponent);
	void SetJetpackBoostVisual(class UStaticMesh* JetpackBoostVisual, bool bShow);

	class AGzMultiPartCharacter* GetOwnerCharacter() const;
	class UMeshComponent* GetVisualComponent() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzJetpackComponent">();
	}
	static class UGzJetpackComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzJetpackComponent>();
	}
};
static_assert(alignof(UGzJetpackComponent) == 0x000008, "Wrong alignment on UGzJetpackComponent");
static_assert(sizeof(UGzJetpackComponent) == 0x000120, "Wrong size on UGzJetpackComponent");
static_assert(offsetof(UGzJetpackComponent, ZiplineJumpOnDuration) == 0x0000B0, "Member 'UGzJetpackComponent::ZiplineJumpOnDuration' has a wrong offset!");
static_assert(offsetof(UGzJetpackComponent, ZiplineJumpOffMaxDuration) == 0x0000B4, "Member 'UGzJetpackComponent::ZiplineJumpOffMaxDuration' has a wrong offset!");
static_assert(offsetof(UGzJetpackComponent, bActive) == 0x0000B8, "Member 'UGzJetpackComponent::bActive' has a wrong offset!");
static_assert(offsetof(UGzJetpackComponent, CachedSettings) == 0x0000C0, "Member 'UGzJetpackComponent::CachedSettings' has a wrong offset!");
static_assert(offsetof(UGzJetpackComponent, DamageAreaInfo) == 0x0000CC, "Member 'UGzJetpackComponent::DamageAreaInfo' has a wrong offset!");
static_assert(offsetof(UGzJetpackComponent, VisualComponent) == 0x0000D8, "Member 'UGzJetpackComponent::VisualComponent' has a wrong offset!");
static_assert(offsetof(UGzJetpackComponent, DamageAreaType) == 0x0000E0, "Member 'UGzJetpackComponent::DamageAreaType' has a wrong offset!");
static_assert(offsetof(UGzJetpackComponent, DamageableBone) == 0x0000E4, "Member 'UGzJetpackComponent::DamageableBone' has a wrong offset!");
static_assert(offsetof(UGzJetpackComponent, CachedCharacter) == 0x0000F0, "Member 'UGzJetpackComponent::CachedCharacter' has a wrong offset!");
static_assert(offsetof(UGzJetpackComponent, ProximityComponent) == 0x0000F8, "Member 'UGzJetpackComponent::ProximityComponent' has a wrong offset!");

// Class G01.GzBundleItemData
// 0x00B0 (0x0388 - 0x02D8)
class UGzBundleItemData final : public UGzItemData
{
public:
	TArray<class UGzItemData*>                    Items;                                             // 0x02D8(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TMap<EGzVirtualCurrencyType, int32>           VirtualCurrencies;                                 // 0x02E8(0x0050)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TMap<EGzBlockchainCoinType, double>           Coins;                                             // 0x0338(0x0050)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzBundleItemData">();
	}
	static class UGzBundleItemData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzBundleItemData>();
	}
};
static_assert(alignof(UGzBundleItemData) == 0x000008, "Wrong alignment on UGzBundleItemData");
static_assert(sizeof(UGzBundleItemData) == 0x000388, "Wrong size on UGzBundleItemData");
static_assert(offsetof(UGzBundleItemData, Items) == 0x0002D8, "Member 'UGzBundleItemData::Items' has a wrong offset!");
static_assert(offsetof(UGzBundleItemData, VirtualCurrencies) == 0x0002E8, "Member 'UGzBundleItemData::VirtualCurrencies' has a wrong offset!");
static_assert(offsetof(UGzBundleItemData, Coins) == 0x000338, "Member 'UGzBundleItemData::Coins' has a wrong offset!");

// Class G01.GzCallRedeployMessage
// 0x0010 (0x0038 - 0x0028)
class UGzCallRedeployMessage final : public UGzGameMessage
{
public:
	class AGzPlayerState*                         PlayerState;                                       // 0x0028(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         InitiatorPlayerId;                                 // 0x0030(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3097[0x4];                                     // 0x0034(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzCallRedeployMessage">();
	}
	static class UGzCallRedeployMessage* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzCallRedeployMessage>();
	}
};
static_assert(alignof(UGzCallRedeployMessage) == 0x000008, "Wrong alignment on UGzCallRedeployMessage");
static_assert(sizeof(UGzCallRedeployMessage) == 0x000038, "Wrong size on UGzCallRedeployMessage");
static_assert(offsetof(UGzCallRedeployMessage, PlayerState) == 0x000028, "Member 'UGzCallRedeployMessage::PlayerState' has a wrong offset!");
static_assert(offsetof(UGzCallRedeployMessage, InitiatorPlayerId) == 0x000030, "Member 'UGzCallRedeployMessage::InitiatorPlayerId' has a wrong offset!");

// Class G01.GzWeaponReloadSpeedModifier
// 0x0008 (0x0030 - 0x0028)
class UGzWeaponReloadSpeedModifier final : public UGzWeaponModifier
{
public:
	float                                         ReloadSecondsCoefficient;                          // 0x0028(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3098[0x4];                                     // 0x002C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzWeaponReloadSpeedModifier">();
	}
	static class UGzWeaponReloadSpeedModifier* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzWeaponReloadSpeedModifier>();
	}
};
static_assert(alignof(UGzWeaponReloadSpeedModifier) == 0x000008, "Wrong alignment on UGzWeaponReloadSpeedModifier");
static_assert(sizeof(UGzWeaponReloadSpeedModifier) == 0x000030, "Wrong size on UGzWeaponReloadSpeedModifier");
static_assert(offsetof(UGzWeaponReloadSpeedModifier, ReloadSecondsCoefficient) == 0x000028, "Member 'UGzWeaponReloadSpeedModifier::ReloadSecondsCoefficient' has a wrong offset!");

// Class G01.GzCameraComponent
// 0x00C0 (0x0AD0 - 0x0A10)
class UGzCameraComponent : public UCameraComponent
{
public:
	struct FCameraFocusSettings                   FocusSettings;                                     // 0x0A10(0x0060)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	struct FCameraLensSettings                    LensSettings;                                      // 0x0A70(0x001C)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	float                                         DepthOfFieldCurrentAperture;                       // 0x0A8C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DepthOfFieldCurrentFocusDistance;                  // 0x0A90(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DepthOfFieldSensorWidth;                           // 0x0A94(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3099[0x8];                                     // 0x0A98(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FGzEnvironmentZoneKey>          InteriorEnvironmentZoneKeys;                       // 0x0AA0(0x0010)(Edit, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	class UCurveFloat*                            FOVOffsetFloatCurve;                               // 0x0AB0(0x0008)(Edit, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCurveVector*                           LocationOffsetVectorCurve;                         // 0x0AB8(0x0008)(Edit, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         DynamicFocusDistanceLimit;                         // 0x0AC0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_309A[0xC];                                     // 0x0AC4(0x000C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzCameraComponent">();
	}
	static class UGzCameraComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzCameraComponent>();
	}
};
static_assert(alignof(UGzCameraComponent) == 0x000010, "Wrong alignment on UGzCameraComponent");
static_assert(sizeof(UGzCameraComponent) == 0x000AD0, "Wrong size on UGzCameraComponent");
static_assert(offsetof(UGzCameraComponent, FocusSettings) == 0x000A10, "Member 'UGzCameraComponent::FocusSettings' has a wrong offset!");
static_assert(offsetof(UGzCameraComponent, LensSettings) == 0x000A70, "Member 'UGzCameraComponent::LensSettings' has a wrong offset!");
static_assert(offsetof(UGzCameraComponent, DepthOfFieldCurrentAperture) == 0x000A8C, "Member 'UGzCameraComponent::DepthOfFieldCurrentAperture' has a wrong offset!");
static_assert(offsetof(UGzCameraComponent, DepthOfFieldCurrentFocusDistance) == 0x000A90, "Member 'UGzCameraComponent::DepthOfFieldCurrentFocusDistance' has a wrong offset!");
static_assert(offsetof(UGzCameraComponent, DepthOfFieldSensorWidth) == 0x000A94, "Member 'UGzCameraComponent::DepthOfFieldSensorWidth' has a wrong offset!");
static_assert(offsetof(UGzCameraComponent, InteriorEnvironmentZoneKeys) == 0x000AA0, "Member 'UGzCameraComponent::InteriorEnvironmentZoneKeys' has a wrong offset!");
static_assert(offsetof(UGzCameraComponent, FOVOffsetFloatCurve) == 0x000AB0, "Member 'UGzCameraComponent::FOVOffsetFloatCurve' has a wrong offset!");
static_assert(offsetof(UGzCameraComponent, LocationOffsetVectorCurve) == 0x000AB8, "Member 'UGzCameraComponent::LocationOffsetVectorCurve' has a wrong offset!");
static_assert(offsetof(UGzCameraComponent, DynamicFocusDistanceLimit) == 0x000AC0, "Member 'UGzCameraComponent::DynamicFocusDistanceLimit' has a wrong offset!");

// Class G01.GzLiveDataSettings
// 0x0010 (0x0048 - 0x0038)
class UGzLiveDataSettings final : public UDeveloperSettings
{
public:
	class FString                                 LiveDataCdnUrl;                                    // 0x0038(0x0010)(Edit, ZeroConstructor, Config, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzLiveDataSettings">();
	}
	static class UGzLiveDataSettings* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzLiveDataSettings>();
	}
};
static_assert(alignof(UGzLiveDataSettings) == 0x000008, "Wrong alignment on UGzLiveDataSettings");
static_assert(sizeof(UGzLiveDataSettings) == 0x000048, "Wrong size on UGzLiveDataSettings");
static_assert(offsetof(UGzLiveDataSettings, LiveDataCdnUrl) == 0x000038, "Member 'UGzLiveDataSettings::LiveDataCdnUrl' has a wrong offset!");

// Class G01.GzCameraModifier_InterpFOV
// 0x0018 (0x00C8 - 0x00B0)
class UGzCameraModifier_InterpFOV final : public UCameraModifier_CameraShake
{
public:
	uint8                                         Pad_309B[0x18];                                    // 0x00B0(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzCameraModifier_InterpFOV">();
	}
	static class UGzCameraModifier_InterpFOV* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzCameraModifier_InterpFOV>();
	}
};
static_assert(alignof(UGzCameraModifier_InterpFOV) == 0x000008, "Wrong alignment on UGzCameraModifier_InterpFOV");
static_assert(sizeof(UGzCameraModifier_InterpFOV) == 0x0000C8, "Wrong size on UGzCameraModifier_InterpFOV");

// Class G01.GzGameplayObjective_SingleTarget
// 0x0088 (0x0270 - 0x01E8)
class UGzGameplayObjective_SingleTarget : public UGameplayObjective
{
public:
	uint8                                         Pad_309C[0x10];                                    // 0x01E8(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	uint64                                        ObjectId;                                          // 0x01F8(0x0008)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bUnreserveResourcesAfterCompletion;                // 0x0200(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_309D[0xF];                                     // 0x0201(0x000F)(Fixing Size After Last Property [ Dumper-7 ])
	class AActor*                                 ResolvedTarget;                                    // 0x0210(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UGzStreamableTrackerSubsystem*          StreamableTrackerSubsystem;                        // 0x0218(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FMissionResourceRef                    Target;                                            // 0x0220(0x0028)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_309E[0x28];                                    // 0x0248(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnObjectReceived(class AActor* Object);
	void OnPreviousObjectInvalidated(class AActor* InvalidatedObject);
	void OnRep_ObjectId();
	void SetTarget(const struct FMissionResourceRef& InTarget);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzGameplayObjective_SingleTarget">();
	}
	static class UGzGameplayObjective_SingleTarget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzGameplayObjective_SingleTarget>();
	}
};
static_assert(alignof(UGzGameplayObjective_SingleTarget) == 0x000008, "Wrong alignment on UGzGameplayObjective_SingleTarget");
static_assert(sizeof(UGzGameplayObjective_SingleTarget) == 0x000270, "Wrong size on UGzGameplayObjective_SingleTarget");
static_assert(offsetof(UGzGameplayObjective_SingleTarget, ObjectId) == 0x0001F8, "Member 'UGzGameplayObjective_SingleTarget::ObjectId' has a wrong offset!");
static_assert(offsetof(UGzGameplayObjective_SingleTarget, bUnreserveResourcesAfterCompletion) == 0x000200, "Member 'UGzGameplayObjective_SingleTarget::bUnreserveResourcesAfterCompletion' has a wrong offset!");
static_assert(offsetof(UGzGameplayObjective_SingleTarget, ResolvedTarget) == 0x000210, "Member 'UGzGameplayObjective_SingleTarget::ResolvedTarget' has a wrong offset!");
static_assert(offsetof(UGzGameplayObjective_SingleTarget, StreamableTrackerSubsystem) == 0x000218, "Member 'UGzGameplayObjective_SingleTarget::StreamableTrackerSubsystem' has a wrong offset!");
static_assert(offsetof(UGzGameplayObjective_SingleTarget, Target) == 0x000220, "Member 'UGzGameplayObjective_SingleTarget::Target' has a wrong offset!");

// Class G01.GzMissionObjective_Interact
// 0x0028 (0x0298 - 0x0270)
class UGzMissionObjective_Interact final : public UGzGameplayObjective_SingleTarget
{
public:
	bool                                          bIsExclusive;                                      // 0x0270(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bAutoComplete;                                     // 0x0271(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bAllowLastChance;                                  // 0x0272(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_309F[0x1];                                     // 0x0273(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         LastChanceTime;                                    // 0x0274(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UGzInteractableComponent*               InteractableComponent;                             // 0x0278(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UGzInteractionCondition_Missions*       InteractionCondition;                              // 0x0280(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_30A0[0x8];                                     // 0x0288(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         StartedObjectiveTime;                              // 0x0290(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_30A1[0x4];                                     // 0x0294(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnInteractionCancelledWithoutTime(class AActor* InteractedBy, const class UGzInteractableComponent* Interactable);
	void OnInteractionEnded(class AActor* Actor, const class UGzInteractableComponent* GzInteractableComponent);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzMissionObjective_Interact">();
	}
	static class UGzMissionObjective_Interact* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzMissionObjective_Interact>();
	}
};
static_assert(alignof(UGzMissionObjective_Interact) == 0x000008, "Wrong alignment on UGzMissionObjective_Interact");
static_assert(sizeof(UGzMissionObjective_Interact) == 0x000298, "Wrong size on UGzMissionObjective_Interact");
static_assert(offsetof(UGzMissionObjective_Interact, bIsExclusive) == 0x000270, "Member 'UGzMissionObjective_Interact::bIsExclusive' has a wrong offset!");
static_assert(offsetof(UGzMissionObjective_Interact, bAutoComplete) == 0x000271, "Member 'UGzMissionObjective_Interact::bAutoComplete' has a wrong offset!");
static_assert(offsetof(UGzMissionObjective_Interact, bAllowLastChance) == 0x000272, "Member 'UGzMissionObjective_Interact::bAllowLastChance' has a wrong offset!");
static_assert(offsetof(UGzMissionObjective_Interact, LastChanceTime) == 0x000274, "Member 'UGzMissionObjective_Interact::LastChanceTime' has a wrong offset!");
static_assert(offsetof(UGzMissionObjective_Interact, InteractableComponent) == 0x000278, "Member 'UGzMissionObjective_Interact::InteractableComponent' has a wrong offset!");
static_assert(offsetof(UGzMissionObjective_Interact, InteractionCondition) == 0x000280, "Member 'UGzMissionObjective_Interact::InteractionCondition' has a wrong offset!");
static_assert(offsetof(UGzMissionObjective_Interact, StartedObjectiveTime) == 0x000290, "Member 'UGzMissionObjective_Interact::StartedObjectiveTime' has a wrong offset!");

// Class G01.GzCameraOverlayLocationObject
// 0x0000 (0x03D0 - 0x03D0)
class UGzCameraOverlayLocationObject final : public UATPCCameraLocationObject
{
public:
	class UGzCameraOverlayModeDataAsset*          CurrentMode;                                       // 0x03C8(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void SetOverlayCameraDistance(float Distance, bool bWithInterpolation);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzCameraOverlayLocationObject">();
	}
	static class UGzCameraOverlayLocationObject* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzCameraOverlayLocationObject>();
	}
};
static_assert(alignof(UGzCameraOverlayLocationObject) == 0x000010, "Wrong alignment on UGzCameraOverlayLocationObject");
static_assert(sizeof(UGzCameraOverlayLocationObject) == 0x0003D0, "Wrong size on UGzCameraOverlayLocationObject");
static_assert(offsetof(UGzCameraOverlayLocationObject, CurrentMode) == 0x0003C8, "Member 'UGzCameraOverlayLocationObject::CurrentMode' has a wrong offset!");

// Class G01.GzCameraRotationSpeed_TagHandler
// 0x0008 (0x0038 - 0x0030)
class UGzCameraRotationSpeed_TagHandler : public UGzGameplayTagHandler
{
public:
	float                                         DebuffAimCameraYawRotationSpeedMultiplier;         // 0x0030(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         DebuffAimCameraPitchRotationSpeedMultiplier;       // 0x0034(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzCameraRotationSpeed_TagHandler">();
	}
	static class UGzCameraRotationSpeed_TagHandler* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzCameraRotationSpeed_TagHandler>();
	}
};
static_assert(alignof(UGzCameraRotationSpeed_TagHandler) == 0x000008, "Wrong alignment on UGzCameraRotationSpeed_TagHandler");
static_assert(sizeof(UGzCameraRotationSpeed_TagHandler) == 0x000038, "Wrong size on UGzCameraRotationSpeed_TagHandler");
static_assert(offsetof(UGzCameraRotationSpeed_TagHandler, DebuffAimCameraYawRotationSpeedMultiplier) == 0x000030, "Member 'UGzCameraRotationSpeed_TagHandler::DebuffAimCameraYawRotationSpeedMultiplier' has a wrong offset!");
static_assert(offsetof(UGzCameraRotationSpeed_TagHandler, DebuffAimCameraPitchRotationSpeedMultiplier) == 0x000034, "Member 'UGzCameraRotationSpeed_TagHandler::DebuffAimCameraPitchRotationSpeedMultiplier' has a wrong offset!");

// Class G01.GzChallengeServiceCheatExtension
// 0x0000 (0x0028 - 0x0028)
class UGzChallengeServiceCheatExtension final : public UGzCheatManagerExtension
{
public:
	void ClientCompleteChallenge(const class FName& ChallengeAssetId) const;
	void ClientRegenerateChallenges() const;
	void ClientResetAllChallenges() const;
	void ClientResetChallenge(const class FName& ChallengeAssetId) const;
	void ClientUpdateChallengeProgress(const class FName& ChallengeAssetId, const float NewProgress) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzChallengeServiceCheatExtension">();
	}
	static class UGzChallengeServiceCheatExtension* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzChallengeServiceCheatExtension>();
	}
};
static_assert(alignof(UGzChallengeServiceCheatExtension) == 0x000008, "Wrong alignment on UGzChallengeServiceCheatExtension");
static_assert(sizeof(UGzChallengeServiceCheatExtension) == 0x000028, "Wrong size on UGzChallengeServiceCheatExtension");

// Class G01.GzChallengeTemplate
// 0x0008 (0x0070 - 0x0068)
class UGzChallengeTemplate final : public UGzTrialTemplate
{
public:
	EGzSchedulingType                             ScheduleType;                                      // 0x0068(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_30A3[0x7];                                     // 0x0069(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzChallengeTemplate">();
	}
	static class UGzChallengeTemplate* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzChallengeTemplate>();
	}
};
static_assert(alignof(UGzChallengeTemplate) == 0x000008, "Wrong alignment on UGzChallengeTemplate");
static_assert(sizeof(UGzChallengeTemplate) == 0x000070, "Wrong size on UGzChallengeTemplate");
static_assert(offsetof(UGzChallengeTemplate, ScheduleType) == 0x000068, "Member 'UGzChallengeTemplate::ScheduleType' has a wrong offset!");

// Class G01.DefaultCharacterSetup
// 0x0030 (0x0060 - 0x0030)
class UDefaultCharacterSetup final : public UDataAsset
{
public:
	TArray<struct FGzInventoryItemContent>        DefaultStartupInventoryItems;                      // 0x0030(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FGzInventoryItemContent>        DefaultPitInventoryItems;                          // 0x0040(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<TSubclassOf<class UGzGameplayAbility>> DefaultAbilities;                                  // 0x0050(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, UObjectWrapper, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DefaultCharacterSetup">();
	}
	static class UDefaultCharacterSetup* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDefaultCharacterSetup>();
	}
};
static_assert(alignof(UDefaultCharacterSetup) == 0x000008, "Wrong alignment on UDefaultCharacterSetup");
static_assert(sizeof(UDefaultCharacterSetup) == 0x000060, "Wrong size on UDefaultCharacterSetup");
static_assert(offsetof(UDefaultCharacterSetup, DefaultStartupInventoryItems) == 0x000030, "Member 'UDefaultCharacterSetup::DefaultStartupInventoryItems' has a wrong offset!");
static_assert(offsetof(UDefaultCharacterSetup, DefaultPitInventoryItems) == 0x000040, "Member 'UDefaultCharacterSetup::DefaultPitInventoryItems' has a wrong offset!");
static_assert(offsetof(UDefaultCharacterSetup, DefaultAbilities) == 0x000050, "Member 'UDefaultCharacterSetup::DefaultAbilities' has a wrong offset!");

// Class G01.GzLootChooserComponent
// 0x0000 (0x00A8 - 0x00A8)
class UGzLootChooserComponent : public UActorComponent
{
public:
	TArray<struct FGzInvItem> GetInvItems(class AActor* InteractActor, const bool bSkipRarityValidation) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzLootChooserComponent">();
	}
	static class UGzLootChooserComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzLootChooserComponent>();
	}
};
static_assert(alignof(UGzLootChooserComponent) == 0x000008, "Wrong alignment on UGzLootChooserComponent");
static_assert(sizeof(UGzLootChooserComponent) == 0x0000A8, "Wrong size on UGzLootChooserComponent");

// Class G01.GzCharacterCustomizationDebugWidget
// 0x0160 (0x0468 - 0x0308)
class UGzCharacterCustomizationDebugWidget final : public UCommonUserWidget
{
public:
	struct FGzDebugCustomizationProfile           ExpectedDebugProfile;                              // 0x0308(0x00B0)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FGzDebugCustomizationProfile           AppliedDebugProfile;                               // 0x03B8(0x00B0)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)

public:
	void Refresh();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzCharacterCustomizationDebugWidget">();
	}
	static class UGzCharacterCustomizationDebugWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzCharacterCustomizationDebugWidget>();
	}
};
static_assert(alignof(UGzCharacterCustomizationDebugWidget) == 0x000008, "Wrong alignment on UGzCharacterCustomizationDebugWidget");
static_assert(sizeof(UGzCharacterCustomizationDebugWidget) == 0x000468, "Wrong size on UGzCharacterCustomizationDebugWidget");
static_assert(offsetof(UGzCharacterCustomizationDebugWidget, ExpectedDebugProfile) == 0x000308, "Member 'UGzCharacterCustomizationDebugWidget::ExpectedDebugProfile' has a wrong offset!");
static_assert(offsetof(UGzCharacterCustomizationDebugWidget, AppliedDebugProfile) == 0x0003B8, "Member 'UGzCharacterCustomizationDebugWidget::AppliedDebugProfile' has a wrong offset!");

// Class G01.GzWorldZoneMetadata
// 0x0000 (0x0028 - 0x0028)
class UGzWorldZoneMetadata : public UObject
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzWorldZoneMetadata">();
	}
	static class UGzWorldZoneMetadata* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzWorldZoneMetadata>();
	}
};
static_assert(alignof(UGzWorldZoneMetadata) == 0x000008, "Wrong alignment on UGzWorldZoneMetadata");
static_assert(sizeof(UGzWorldZoneMetadata) == 0x000028, "Wrong size on UGzWorldZoneMetadata");

// Class G01.GzWorldZoneLootMetadata
// 0x0008 (0x0030 - 0x0028)
class UGzWorldZoneLootMetadata final : public UGzWorldZoneMetadata
{
public:
	class UGzLootModifierTableData*               LocalLootModifier;                                 // 0x0028(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzWorldZoneLootMetadata">();
	}
	static class UGzWorldZoneLootMetadata* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzWorldZoneLootMetadata>();
	}
};
static_assert(alignof(UGzWorldZoneLootMetadata) == 0x000008, "Wrong alignment on UGzWorldZoneLootMetadata");
static_assert(sizeof(UGzWorldZoneLootMetadata) == 0x000030, "Wrong size on UGzWorldZoneLootMetadata");
static_assert(offsetof(UGzWorldZoneLootMetadata, LocalLootModifier) == 0x000028, "Member 'UGzWorldZoneLootMetadata::LocalLootModifier' has a wrong offset!");

// Class G01.GzCharacterDefaultSettings
// 0x0410 (0x0448 - 0x0038)
class UGzCharacterDefaultSettings final : public UDeveloperSettingsBackedByCVars
{
public:
	TMap<EGzAttachNodeName, class FName>          SocketNameMapping;                                 // 0x0038(0x0050)(Edit, Config, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UGzZiplineMovementSettings> ZiplineSettings;                                   // 0x0088(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, Config, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UGzInteractableTransitionSettings> InteractableTransitionSettings;                    // 0x00B0(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, Config, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   JetpackSocketName;                                 // 0x00D8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGzAimAssistPresetSettings             DefaultAimAssistPreset;                            // 0x00E0(0x0018)(Edit, Config, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TArray<struct FGzAimAssistPresetSettings>     AimAssistPresets;                                  // 0x00F8(0x0010)(Edit, ZeroConstructor, Config, DisableEditOnInstance, NativeAccessSpecifierPublic)
	float                                         MinAimAssistActivationDistance;                    // 0x0108(0x0004)(Edit, ZeroConstructor, Config, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxAimAssistActivationDistance;                    // 0x010C(0x0004)(Edit, ZeroConstructor, Config, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTagContainer                  AimAssistRequiredTags;                             // 0x0110(0x0020)(Edit, Config, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FGameplayTagContainer                  AimAssistBlockedTags;                              // 0x0130(0x0020)(Edit, Config, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FGameplayTagContainer                  AimAssistAimingTags;                               // 0x0150(0x0020)(Edit, Config, DisableEditOnInstance, NativeAccessSpecifierPublic)
	float                                         AimAssistInputChangedDelay;                        // 0x0170(0x0004)(Edit, ZeroConstructor, Config, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AimAssistActivationTimeThreshold;                  // 0x0174(0x0004)(Edit, ZeroConstructor, Config, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAimAssistUseCurve;                                // 0x0178(0x0001)(Edit, ZeroConstructor, Config, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_30A5[0x3];                                     // 0x0179(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         AimAssistRightStickMaxInputRate;                   // 0x017C(0x0004)(Edit, ZeroConstructor, Config, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AimAssistActivationAngle;                          // 0x0180(0x0004)(Edit, ZeroConstructor, Config, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AimAssistTargetRecheckTimeInterval;                // 0x0184(0x0004)(Edit, ZeroConstructor, Config, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AimAssistTargetChangeTimeInterval;                 // 0x0188(0x0004)(Edit, ZeroConstructor, Config, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AimAssistTargetRecheckDistance;                    // 0x018C(0x0004)(Edit, ZeroConstructor, Config, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAutoAimActive;                                    // 0x0190(0x0001)(Edit, ZeroConstructor, Config, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_30A6[0x3];                                     // 0x0191(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         AutoAimingTransitionDuration;                      // 0x0194(0x0004)(Edit, ZeroConstructor, Config, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AutoAimRetriggerDelay;                             // 0x0198(0x0004)(Edit, ZeroConstructor, Config, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxAutoAimDistance;                                // 0x019C(0x0004)(Edit, ZeroConstructor, Config, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxAutoAimAngle;                                   // 0x01A0(0x0004)(Edit, ZeroConstructor, Config, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_30A7[0x4];                                     // 0x01A4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftObjectPtr<class UCurveFloat>             MaxAutoAimAngleDistanceCurve;                      // 0x01A8(0x0028)(Edit, Config, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDisableRotationalAimAssistOnMaxInput;             // 0x01D0(0x0001)(Edit, ZeroConstructor, Config, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bRotateOnlyToMovingTargets;                        // 0x01D1(0x0001)(Edit, ZeroConstructor, Config, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_30A8[0x2];                                     // 0x01D2(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MaxRotationalHorizontalDistanceToTarget;           // 0x01D4(0x0004)(Edit, ZeroConstructor, Config, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RotationRetriggerDelay;                            // 0x01D8(0x0004)(Edit, ZeroConstructor, Config, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxRotationDistanceHipFire;                        // 0x01DC(0x0004)(Edit, ZeroConstructor, Config, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxRotationDistanceADS;                            // 0x01E0(0x0004)(Edit, ZeroConstructor, Config, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxAngleToTriggerRotation;                         // 0x01E4(0x0004)(Edit, ZeroConstructor, Config, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UCurveFloat>             MaxAngleToTriggerRotationDistanceCurve;            // 0x01E8(0x0028)(Edit, Config, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxRotationSpeed;                                  // 0x0210(0x0004)(Edit, ZeroConstructor, Config, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_30A9[0x4];                                     // 0x0214(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftObjectPtr<class UCurveFloat>             MaxRotationSpeedDistanceCurveADS;                  // 0x0218(0x0028)(Edit, Config, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UCurveFloat>             MaxRotationSpeedDistanceCurveHipFire;              // 0x0240(0x0028)(Edit, Config, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AimAssistRotationRate;                             // 0x0268(0x0004)(Edit, ZeroConstructor, Config, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_30AA[0x4];                                     // 0x026C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftObjectPtr<class UCurveFloat>             AimAssistRotationRateDistanceCurveADS;             // 0x0270(0x0028)(Edit, Config, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UCurveFloat>             AimAssistRotationRateDistanceCurveHipFire;         // 0x0298(0x0028)(Edit, Config, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDisableSensitivityReductionOnMaxInput;            // 0x02C0(0x0001)(Edit, ZeroConstructor, Config, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_30AB[0x3];                                     // 0x02C1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         AimAssistSensitivityDistanceTolerance;             // 0x02C4(0x0004)(Edit, ZeroConstructor, Config, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UCurveFloat>             AimAssistDistanceToleranceDistanceCurve;           // 0x02C8(0x0028)(Edit, Config, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AimAssistSensitivityYawModifier;                   // 0x02F0(0x0004)(Edit, ZeroConstructor, Config, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_30AC[0x4];                                     // 0x02F4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftObjectPtr<class UCurveFloat>             AimAssistSensitivityYawModifierDistanceCurve;      // 0x02F8(0x0028)(Edit, Config, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UCurveFloat>             AimAssistSensitivityYawModifierInterpolationDistanceCurve; // 0x0320(0x0028)(Edit, Config, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AimAssistSensitivityPitchModifier;                 // 0x0348(0x0004)(Edit, ZeroConstructor, Config, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_30AD[0x4];                                     // 0x034C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftObjectPtr<class UCurveFloat>             AimAssistSensitivityPitchModifierDistanceCurve;    // 0x0350(0x0028)(Edit, Config, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UCurveFloat>             AimAssistSensitivityPitchModifierInterpolationDistanceCurve; // 0x0378(0x0028)(Edit, Config, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SensitivityInterpolationTime;                      // 0x03A0(0x0004)(Edit, ZeroConstructor, Config, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_30AE[0x4];                                     // 0x03A4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<struct FGameplayAttribute, struct FGzAttributeSetting> AttributeSettingsMap;                              // 0x03A8(0x0050)(Edit, Config, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UGzItemData>             InGameCurrencyItemData;                            // 0x03F8(0x0028)(Edit, Config, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftClassPtr<class UClass>                   DefaultDropPod;                                    // 0x0420(0x0028)(Edit, Config, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzCharacterDefaultSettings">();
	}
	static class UGzCharacterDefaultSettings* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzCharacterDefaultSettings>();
	}
};
static_assert(alignof(UGzCharacterDefaultSettings) == 0x000008, "Wrong alignment on UGzCharacterDefaultSettings");
static_assert(sizeof(UGzCharacterDefaultSettings) == 0x000448, "Wrong size on UGzCharacterDefaultSettings");
static_assert(offsetof(UGzCharacterDefaultSettings, SocketNameMapping) == 0x000038, "Member 'UGzCharacterDefaultSettings::SocketNameMapping' has a wrong offset!");
static_assert(offsetof(UGzCharacterDefaultSettings, ZiplineSettings) == 0x000088, "Member 'UGzCharacterDefaultSettings::ZiplineSettings' has a wrong offset!");
static_assert(offsetof(UGzCharacterDefaultSettings, InteractableTransitionSettings) == 0x0000B0, "Member 'UGzCharacterDefaultSettings::InteractableTransitionSettings' has a wrong offset!");
static_assert(offsetof(UGzCharacterDefaultSettings, JetpackSocketName) == 0x0000D8, "Member 'UGzCharacterDefaultSettings::JetpackSocketName' has a wrong offset!");
static_assert(offsetof(UGzCharacterDefaultSettings, DefaultAimAssistPreset) == 0x0000E0, "Member 'UGzCharacterDefaultSettings::DefaultAimAssistPreset' has a wrong offset!");
static_assert(offsetof(UGzCharacterDefaultSettings, AimAssistPresets) == 0x0000F8, "Member 'UGzCharacterDefaultSettings::AimAssistPresets' has a wrong offset!");
static_assert(offsetof(UGzCharacterDefaultSettings, MinAimAssistActivationDistance) == 0x000108, "Member 'UGzCharacterDefaultSettings::MinAimAssistActivationDistance' has a wrong offset!");
static_assert(offsetof(UGzCharacterDefaultSettings, MaxAimAssistActivationDistance) == 0x00010C, "Member 'UGzCharacterDefaultSettings::MaxAimAssistActivationDistance' has a wrong offset!");
static_assert(offsetof(UGzCharacterDefaultSettings, AimAssistRequiredTags) == 0x000110, "Member 'UGzCharacterDefaultSettings::AimAssistRequiredTags' has a wrong offset!");
static_assert(offsetof(UGzCharacterDefaultSettings, AimAssistBlockedTags) == 0x000130, "Member 'UGzCharacterDefaultSettings::AimAssistBlockedTags' has a wrong offset!");
static_assert(offsetof(UGzCharacterDefaultSettings, AimAssistAimingTags) == 0x000150, "Member 'UGzCharacterDefaultSettings::AimAssistAimingTags' has a wrong offset!");
static_assert(offsetof(UGzCharacterDefaultSettings, AimAssistInputChangedDelay) == 0x000170, "Member 'UGzCharacterDefaultSettings::AimAssistInputChangedDelay' has a wrong offset!");
static_assert(offsetof(UGzCharacterDefaultSettings, AimAssistActivationTimeThreshold) == 0x000174, "Member 'UGzCharacterDefaultSettings::AimAssistActivationTimeThreshold' has a wrong offset!");
static_assert(offsetof(UGzCharacterDefaultSettings, bAimAssistUseCurve) == 0x000178, "Member 'UGzCharacterDefaultSettings::bAimAssistUseCurve' has a wrong offset!");
static_assert(offsetof(UGzCharacterDefaultSettings, AimAssistRightStickMaxInputRate) == 0x00017C, "Member 'UGzCharacterDefaultSettings::AimAssistRightStickMaxInputRate' has a wrong offset!");
static_assert(offsetof(UGzCharacterDefaultSettings, AimAssistActivationAngle) == 0x000180, "Member 'UGzCharacterDefaultSettings::AimAssistActivationAngle' has a wrong offset!");
static_assert(offsetof(UGzCharacterDefaultSettings, AimAssistTargetRecheckTimeInterval) == 0x000184, "Member 'UGzCharacterDefaultSettings::AimAssistTargetRecheckTimeInterval' has a wrong offset!");
static_assert(offsetof(UGzCharacterDefaultSettings, AimAssistTargetChangeTimeInterval) == 0x000188, "Member 'UGzCharacterDefaultSettings::AimAssistTargetChangeTimeInterval' has a wrong offset!");
static_assert(offsetof(UGzCharacterDefaultSettings, AimAssistTargetRecheckDistance) == 0x00018C, "Member 'UGzCharacterDefaultSettings::AimAssistTargetRecheckDistance' has a wrong offset!");
static_assert(offsetof(UGzCharacterDefaultSettings, bAutoAimActive) == 0x000190, "Member 'UGzCharacterDefaultSettings::bAutoAimActive' has a wrong offset!");
static_assert(offsetof(UGzCharacterDefaultSettings, AutoAimingTransitionDuration) == 0x000194, "Member 'UGzCharacterDefaultSettings::AutoAimingTransitionDuration' has a wrong offset!");
static_assert(offsetof(UGzCharacterDefaultSettings, AutoAimRetriggerDelay) == 0x000198, "Member 'UGzCharacterDefaultSettings::AutoAimRetriggerDelay' has a wrong offset!");
static_assert(offsetof(UGzCharacterDefaultSettings, MaxAutoAimDistance) == 0x00019C, "Member 'UGzCharacterDefaultSettings::MaxAutoAimDistance' has a wrong offset!");
static_assert(offsetof(UGzCharacterDefaultSettings, MaxAutoAimAngle) == 0x0001A0, "Member 'UGzCharacterDefaultSettings::MaxAutoAimAngle' has a wrong offset!");
static_assert(offsetof(UGzCharacterDefaultSettings, MaxAutoAimAngleDistanceCurve) == 0x0001A8, "Member 'UGzCharacterDefaultSettings::MaxAutoAimAngleDistanceCurve' has a wrong offset!");
static_assert(offsetof(UGzCharacterDefaultSettings, bDisableRotationalAimAssistOnMaxInput) == 0x0001D0, "Member 'UGzCharacterDefaultSettings::bDisableRotationalAimAssistOnMaxInput' has a wrong offset!");
static_assert(offsetof(UGzCharacterDefaultSettings, bRotateOnlyToMovingTargets) == 0x0001D1, "Member 'UGzCharacterDefaultSettings::bRotateOnlyToMovingTargets' has a wrong offset!");
static_assert(offsetof(UGzCharacterDefaultSettings, MaxRotationalHorizontalDistanceToTarget) == 0x0001D4, "Member 'UGzCharacterDefaultSettings::MaxRotationalHorizontalDistanceToTarget' has a wrong offset!");
static_assert(offsetof(UGzCharacterDefaultSettings, RotationRetriggerDelay) == 0x0001D8, "Member 'UGzCharacterDefaultSettings::RotationRetriggerDelay' has a wrong offset!");
static_assert(offsetof(UGzCharacterDefaultSettings, MaxRotationDistanceHipFire) == 0x0001DC, "Member 'UGzCharacterDefaultSettings::MaxRotationDistanceHipFire' has a wrong offset!");
static_assert(offsetof(UGzCharacterDefaultSettings, MaxRotationDistanceADS) == 0x0001E0, "Member 'UGzCharacterDefaultSettings::MaxRotationDistanceADS' has a wrong offset!");
static_assert(offsetof(UGzCharacterDefaultSettings, MaxAngleToTriggerRotation) == 0x0001E4, "Member 'UGzCharacterDefaultSettings::MaxAngleToTriggerRotation' has a wrong offset!");
static_assert(offsetof(UGzCharacterDefaultSettings, MaxAngleToTriggerRotationDistanceCurve) == 0x0001E8, "Member 'UGzCharacterDefaultSettings::MaxAngleToTriggerRotationDistanceCurve' has a wrong offset!");
static_assert(offsetof(UGzCharacterDefaultSettings, MaxRotationSpeed) == 0x000210, "Member 'UGzCharacterDefaultSettings::MaxRotationSpeed' has a wrong offset!");
static_assert(offsetof(UGzCharacterDefaultSettings, MaxRotationSpeedDistanceCurveADS) == 0x000218, "Member 'UGzCharacterDefaultSettings::MaxRotationSpeedDistanceCurveADS' has a wrong offset!");
static_assert(offsetof(UGzCharacterDefaultSettings, MaxRotationSpeedDistanceCurveHipFire) == 0x000240, "Member 'UGzCharacterDefaultSettings::MaxRotationSpeedDistanceCurveHipFire' has a wrong offset!");
static_assert(offsetof(UGzCharacterDefaultSettings, AimAssistRotationRate) == 0x000268, "Member 'UGzCharacterDefaultSettings::AimAssistRotationRate' has a wrong offset!");
static_assert(offsetof(UGzCharacterDefaultSettings, AimAssistRotationRateDistanceCurveADS) == 0x000270, "Member 'UGzCharacterDefaultSettings::AimAssistRotationRateDistanceCurveADS' has a wrong offset!");
static_assert(offsetof(UGzCharacterDefaultSettings, AimAssistRotationRateDistanceCurveHipFire) == 0x000298, "Member 'UGzCharacterDefaultSettings::AimAssistRotationRateDistanceCurveHipFire' has a wrong offset!");
static_assert(offsetof(UGzCharacterDefaultSettings, bDisableSensitivityReductionOnMaxInput) == 0x0002C0, "Member 'UGzCharacterDefaultSettings::bDisableSensitivityReductionOnMaxInput' has a wrong offset!");
static_assert(offsetof(UGzCharacterDefaultSettings, AimAssistSensitivityDistanceTolerance) == 0x0002C4, "Member 'UGzCharacterDefaultSettings::AimAssistSensitivityDistanceTolerance' has a wrong offset!");
static_assert(offsetof(UGzCharacterDefaultSettings, AimAssistDistanceToleranceDistanceCurve) == 0x0002C8, "Member 'UGzCharacterDefaultSettings::AimAssistDistanceToleranceDistanceCurve' has a wrong offset!");
static_assert(offsetof(UGzCharacterDefaultSettings, AimAssistSensitivityYawModifier) == 0x0002F0, "Member 'UGzCharacterDefaultSettings::AimAssistSensitivityYawModifier' has a wrong offset!");
static_assert(offsetof(UGzCharacterDefaultSettings, AimAssistSensitivityYawModifierDistanceCurve) == 0x0002F8, "Member 'UGzCharacterDefaultSettings::AimAssistSensitivityYawModifierDistanceCurve' has a wrong offset!");
static_assert(offsetof(UGzCharacterDefaultSettings, AimAssistSensitivityYawModifierInterpolationDistanceCurve) == 0x000320, "Member 'UGzCharacterDefaultSettings::AimAssistSensitivityYawModifierInterpolationDistanceCurve' has a wrong offset!");
static_assert(offsetof(UGzCharacterDefaultSettings, AimAssistSensitivityPitchModifier) == 0x000348, "Member 'UGzCharacterDefaultSettings::AimAssistSensitivityPitchModifier' has a wrong offset!");
static_assert(offsetof(UGzCharacterDefaultSettings, AimAssistSensitivityPitchModifierDistanceCurve) == 0x000350, "Member 'UGzCharacterDefaultSettings::AimAssistSensitivityPitchModifierDistanceCurve' has a wrong offset!");
static_assert(offsetof(UGzCharacterDefaultSettings, AimAssistSensitivityPitchModifierInterpolationDistanceCurve) == 0x000378, "Member 'UGzCharacterDefaultSettings::AimAssistSensitivityPitchModifierInterpolationDistanceCurve' has a wrong offset!");
static_assert(offsetof(UGzCharacterDefaultSettings, SensitivityInterpolationTime) == 0x0003A0, "Member 'UGzCharacterDefaultSettings::SensitivityInterpolationTime' has a wrong offset!");
static_assert(offsetof(UGzCharacterDefaultSettings, AttributeSettingsMap) == 0x0003A8, "Member 'UGzCharacterDefaultSettings::AttributeSettingsMap' has a wrong offset!");
static_assert(offsetof(UGzCharacterDefaultSettings, InGameCurrencyItemData) == 0x0003F8, "Member 'UGzCharacterDefaultSettings::InGameCurrencyItemData' has a wrong offset!");
static_assert(offsetof(UGzCharacterDefaultSettings, DefaultDropPod) == 0x000420, "Member 'UGzCharacterDefaultSettings::DefaultDropPod' has a wrong offset!");

// Class G01.GzVoiceChatBlueprintEventsComponent
// 0x0040 (0x00E0 - 0x00A0)
class UGzVoiceChatBlueprintEventsComponent final : public UGzServiceComponent
{
public:
	FMulticastInlineDelegateProperty_             VoiceChatMembersUpdated;                           // 0x00A0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             VoiceChatMemberStateUpdated;                       // 0x00B0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             VoiceChatMemberTalkingStateUpdated;                // 0x00C0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             VoiceChatMemberBlockStateUpdated;                  // 0x00D0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)

public:
	void GzVoiceChatMemberBlockStateUpdatedDynamic__DelegateSignature(const class FString& ProductUserId, bool bIsBlocked);
	void GzVoiceChatMemberStateUpdatedDynamic__DelegateSignature(const class FString& PlayFabId, bool bIsMuted);
	void GzVoiceChatMembersUpdatedDynamic__DelegateSignature();
	void GzVoiceChatMemberTalkingStateUpdatedDynamic__DelegateSignature(const class FString& PlayFabId, bool bTalkingState);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzVoiceChatBlueprintEventsComponent">();
	}
	static class UGzVoiceChatBlueprintEventsComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzVoiceChatBlueprintEventsComponent>();
	}
};
static_assert(alignof(UGzVoiceChatBlueprintEventsComponent) == 0x000008, "Wrong alignment on UGzVoiceChatBlueprintEventsComponent");
static_assert(sizeof(UGzVoiceChatBlueprintEventsComponent) == 0x0000E0, "Wrong size on UGzVoiceChatBlueprintEventsComponent");
static_assert(offsetof(UGzVoiceChatBlueprintEventsComponent, VoiceChatMembersUpdated) == 0x0000A0, "Member 'UGzVoiceChatBlueprintEventsComponent::VoiceChatMembersUpdated' has a wrong offset!");
static_assert(offsetof(UGzVoiceChatBlueprintEventsComponent, VoiceChatMemberStateUpdated) == 0x0000B0, "Member 'UGzVoiceChatBlueprintEventsComponent::VoiceChatMemberStateUpdated' has a wrong offset!");
static_assert(offsetof(UGzVoiceChatBlueprintEventsComponent, VoiceChatMemberTalkingStateUpdated) == 0x0000C0, "Member 'UGzVoiceChatBlueprintEventsComponent::VoiceChatMemberTalkingStateUpdated' has a wrong offset!");
static_assert(offsetof(UGzVoiceChatBlueprintEventsComponent, VoiceChatMemberBlockStateUpdated) == 0x0000D0, "Member 'UGzVoiceChatBlueprintEventsComponent::VoiceChatMemberBlockStateUpdated' has a wrong offset!");

// Class G01.GzCharacterIdInterface
// 0x0000 (0x0028 - 0x0028)
class IGzCharacterIdInterface final : public IInterface
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzCharacterIdInterface">();
	}
	static class IGzCharacterIdInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IGzCharacterIdInterface>();
	}
};
static_assert(alignof(IGzCharacterIdInterface) == 0x000008, "Wrong alignment on IGzCharacterIdInterface");
static_assert(sizeof(IGzCharacterIdInterface) == 0x000028, "Wrong size on IGzCharacterIdInterface");

// Class G01.GzWeaponActor
// 0x0128 (0x03C8 - 0x02A0)
class AGzWeaponActor : public AActor
{
public:
	uint8                                         Pad_30B2[0x10];                                    // 0x02A0(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class AActor*                                 MagazineProp;                                      // 0x02B0(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGzWeaponConstructionInfo              ConstructionInfo;                                  // 0x02B8(0x0058)(Transient, Protected, NativeAccessSpecifierProtected)
	class USkeletalMeshComponent*                 SkeletalMeshComponent;                             // 0x0310(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UGzWeaponComponent*                     WeaponComponent;                                   // 0x0318(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UGzWeaponItemData*                      WeaponItemData;                                    // 0x0320(0x0008)(Edit, ZeroConstructor, Transient, EditConst, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UGzWeaponSkinItemData*                  WeaponSkinItemData;                                // 0x0328(0x0008)(Edit, ZeroConstructor, Transient, EditConst, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UGzWeaponAttachmentComponent*           AttachmentComponents[0x8];                         // 0x0330(0x0008)(Edit, ExportObject, ZeroConstructor, Transient, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAkComponent*                           AkComponent;                                       // 0x0370(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<struct FGzInventoryItemAttachmentContent> PendingAttachments;                                // 0x0378(0x0010)(ZeroConstructor, Transient, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	TArray<class UObject*>                        AttachmentModifierResources;                       // 0x0388(0x0010)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	TArray<class UGzWeaponBehaviorAttachment*>    BehaviorAttachments;                               // 0x0398(0x0010)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_30B3[0x20];                                    // 0x03A8(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnInitBehaviorAttachments();
	void OnInitWeaponConstructionInfo();

	void DestroyBehaviorSpawnedComponent(class UActorComponent* ComponentToDestroy) const;
	const struct FGzInvPocketId GetDedicatedPocketID() const;
	class UGzWeaponItemData* GetItemData() const;
	struct FTransform GetLeftHandIKTransform(ERelativeTransformSpace CurrentSpace) const;
	class USkeletalMeshComponent* GetSkeletalMeshComponent() const;
	class UGzWeaponSkinItemData* GetSkinItemData() const;
	class UGzWeaponAttachmentComponent* GetWeaponAttachment(EGzWeaponAttachmentType Type) const;
	class UGzWeaponComponent* GetWeaponComponent() const;
	EGzWeaponSupportHoldType GetWeaponSupportHoldType() const;
	bool HasLeftHandIKHandling() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzWeaponActor">();
	}
	static class AGzWeaponActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<AGzWeaponActor>();
	}
};
static_assert(alignof(AGzWeaponActor) == 0x000008, "Wrong alignment on AGzWeaponActor");
static_assert(sizeof(AGzWeaponActor) == 0x0003C8, "Wrong size on AGzWeaponActor");
static_assert(offsetof(AGzWeaponActor, MagazineProp) == 0x0002B0, "Member 'AGzWeaponActor::MagazineProp' has a wrong offset!");
static_assert(offsetof(AGzWeaponActor, ConstructionInfo) == 0x0002B8, "Member 'AGzWeaponActor::ConstructionInfo' has a wrong offset!");
static_assert(offsetof(AGzWeaponActor, SkeletalMeshComponent) == 0x000310, "Member 'AGzWeaponActor::SkeletalMeshComponent' has a wrong offset!");
static_assert(offsetof(AGzWeaponActor, WeaponComponent) == 0x000318, "Member 'AGzWeaponActor::WeaponComponent' has a wrong offset!");
static_assert(offsetof(AGzWeaponActor, WeaponItemData) == 0x000320, "Member 'AGzWeaponActor::WeaponItemData' has a wrong offset!");
static_assert(offsetof(AGzWeaponActor, WeaponSkinItemData) == 0x000328, "Member 'AGzWeaponActor::WeaponSkinItemData' has a wrong offset!");
static_assert(offsetof(AGzWeaponActor, AttachmentComponents) == 0x000330, "Member 'AGzWeaponActor::AttachmentComponents' has a wrong offset!");
static_assert(offsetof(AGzWeaponActor, AkComponent) == 0x000370, "Member 'AGzWeaponActor::AkComponent' has a wrong offset!");
static_assert(offsetof(AGzWeaponActor, PendingAttachments) == 0x000378, "Member 'AGzWeaponActor::PendingAttachments' has a wrong offset!");
static_assert(offsetof(AGzWeaponActor, AttachmentModifierResources) == 0x000388, "Member 'AGzWeaponActor::AttachmentModifierResources' has a wrong offset!");
static_assert(offsetof(AGzWeaponActor, BehaviorAttachments) == 0x000398, "Member 'AGzWeaponActor::BehaviorAttachments' has a wrong offset!");

// Class G01.GzLimbAnimNotifyState
// 0x0098 (0x00C8 - 0x0030)
class UGzLimbAnimNotifyState final : public UAnimNotifyState
{
public:
	class UNiagaraSystem*                         Template;                                          // 0x0030(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   SocketName;                                        // 0x0038(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                LocationOffset;                                    // 0x0040(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               RotationOffset;                                    // 0x0058(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          bDestroyAtEnd;                                     // 0x0070(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bRunOnServer;                                      // 0x0071(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_30B6[0x6];                                     // 0x0072(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<class FName, class FName>                ParameterToBoneLinks;                              // 0x0078(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)

public:
	class UNiagaraComponent* GetSpawnedEffect(class UMeshComponent* MeshComp) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzLimbAnimNotifyState">();
	}
	static class UGzLimbAnimNotifyState* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzLimbAnimNotifyState>();
	}
};
static_assert(alignof(UGzLimbAnimNotifyState) == 0x000008, "Wrong alignment on UGzLimbAnimNotifyState");
static_assert(sizeof(UGzLimbAnimNotifyState) == 0x0000C8, "Wrong size on UGzLimbAnimNotifyState");
static_assert(offsetof(UGzLimbAnimNotifyState, Template) == 0x000030, "Member 'UGzLimbAnimNotifyState::Template' has a wrong offset!");
static_assert(offsetof(UGzLimbAnimNotifyState, SocketName) == 0x000038, "Member 'UGzLimbAnimNotifyState::SocketName' has a wrong offset!");
static_assert(offsetof(UGzLimbAnimNotifyState, LocationOffset) == 0x000040, "Member 'UGzLimbAnimNotifyState::LocationOffset' has a wrong offset!");
static_assert(offsetof(UGzLimbAnimNotifyState, RotationOffset) == 0x000058, "Member 'UGzLimbAnimNotifyState::RotationOffset' has a wrong offset!");
static_assert(offsetof(UGzLimbAnimNotifyState, bDestroyAtEnd) == 0x000070, "Member 'UGzLimbAnimNotifyState::bDestroyAtEnd' has a wrong offset!");
static_assert(offsetof(UGzLimbAnimNotifyState, bRunOnServer) == 0x000071, "Member 'UGzLimbAnimNotifyState::bRunOnServer' has a wrong offset!");
static_assert(offsetof(UGzLimbAnimNotifyState, ParameterToBoneLinks) == 0x000078, "Member 'UGzLimbAnimNotifyState::ParameterToBoneLinks' has a wrong offset!");

// Class G01.GzCharacterModel
// 0x0000 (0x0070 - 0x0070)
class UGzCharacterModel final : public UGzBackendModel
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzCharacterModel">();
	}
	static class UGzCharacterModel* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzCharacterModel>();
	}
};
static_assert(alignof(UGzCharacterModel) == 0x000008, "Wrong alignment on UGzCharacterModel");
static_assert(sizeof(UGzCharacterModel) == 0x000070, "Wrong size on UGzCharacterModel");

// Class G01.GzCharacterNameComponent
// 0x0000 (0x06A0 - 0x06A0)
class UGzCharacterNameComponent : public UWidgetComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzCharacterNameComponent">();
	}
	static class UGzCharacterNameComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzCharacterNameComponent>();
	}
};
static_assert(alignof(UGzCharacterNameComponent) == 0x000010, "Wrong alignment on UGzCharacterNameComponent");
static_assert(sizeof(UGzCharacterNameComponent) == 0x0006A0, "Wrong size on UGzCharacterNameComponent");

// Class G01.GzTrialsControllerComponent
// 0x0198 (0x0240 - 0x00A8)
class UGzTrialsControllerComponent final : public UControllerComponent
{
public:
	FMulticastInlineDelegateProperty_             OnChallengeAddedDelegate;                          // 0x00A8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnChallengeProgressedDelegate;                     // 0x00B8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnChallengeCompletedDelegate;                      // 0x00C8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnAchievementCompletedDelegate;                    // 0x00D8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	struct FGzTrialsFastArray                     OwnedTrials;                                       // 0x00E8(0x0150)(Net, NativeAccessSpecifierPrivate)
	uint8                                         Pad_30B7[0x8];                                     // 0x0238(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	const TArray<struct FGzGameplayTrial> GetOwnedTrials();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzTrialsControllerComponent">();
	}
	static class UGzTrialsControllerComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzTrialsControllerComponent>();
	}
};
static_assert(alignof(UGzTrialsControllerComponent) == 0x000008, "Wrong alignment on UGzTrialsControllerComponent");
static_assert(sizeof(UGzTrialsControllerComponent) == 0x000240, "Wrong size on UGzTrialsControllerComponent");
static_assert(offsetof(UGzTrialsControllerComponent, OnChallengeAddedDelegate) == 0x0000A8, "Member 'UGzTrialsControllerComponent::OnChallengeAddedDelegate' has a wrong offset!");
static_assert(offsetof(UGzTrialsControllerComponent, OnChallengeProgressedDelegate) == 0x0000B8, "Member 'UGzTrialsControllerComponent::OnChallengeProgressedDelegate' has a wrong offset!");
static_assert(offsetof(UGzTrialsControllerComponent, OnChallengeCompletedDelegate) == 0x0000C8, "Member 'UGzTrialsControllerComponent::OnChallengeCompletedDelegate' has a wrong offset!");
static_assert(offsetof(UGzTrialsControllerComponent, OnAchievementCompletedDelegate) == 0x0000D8, "Member 'UGzTrialsControllerComponent::OnAchievementCompletedDelegate' has a wrong offset!");
static_assert(offsetof(UGzTrialsControllerComponent, OwnedTrials) == 0x0000E8, "Member 'UGzTrialsControllerComponent::OwnedTrials' has a wrong offset!");

// Class G01.GzLoadoutsGrid
// 0x0000 (0x03E0 - 0x03E0)
class UGzLoadoutsGrid : public UGzLoadoutSlot
{
public:
	void Clear();
	void SetDataToSlot(const struct FGzLoadoutDataConfig& LoadoutConfig);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzLoadoutsGrid">();
	}
	static class UGzLoadoutsGrid* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzLoadoutsGrid>();
	}
};
static_assert(alignof(UGzLoadoutsGrid) == 0x000008, "Wrong alignment on UGzLoadoutsGrid");
static_assert(sizeof(UGzLoadoutsGrid) == 0x0003E0, "Wrong size on UGzLoadoutsGrid");

// Class G01.GzCharacterService
// 0x00C0 (0x0160 - 0x00A0)
class UGzCharacterService final : public UGzClientPFObject
{
public:
	uint8                                         Pad_30B8[0xC0];                                    // 0x00A0(0x00C0)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzCharacterService">();
	}
	static class UGzCharacterService* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzCharacterService>();
	}
};
static_assert(alignof(UGzCharacterService) == 0x000008, "Wrong alignment on UGzCharacterService");
static_assert(sizeof(UGzCharacterService) == 0x000160, "Wrong size on UGzCharacterService");

// Class G01.GzCharacterWorldVisibilityComponent
// 0x00B0 (0x0158 - 0x00A8)
class UGzCharacterWorldVisibilityComponent final : public UActorComponent
{
public:
	FMulticastInlineDelegateProperty_             OnVisibilityStateChangedMarker;                    // 0x00A8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnVisibilityStateChangedStencil;                   // 0x00B8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TArray<struct FGzTagToVisibilityState>        OwnedTagToVisibilityState;                         // 0x00C8(0x0010)(Edit, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	TMap<EGzWorldVisibilityState, struct FGzWorldVisibilityData> VisibilityStates;                                  // 0x00D8(0x0050)(Edit, Protected, NativeAccessSpecifierProtected)
	float                                         RecentlyShotRevealDuration;                        // 0x0128(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MaxShootingRevealDistance;                         // 0x012C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class AGzWorldVisibilityBlendActor*           WorldVisibilityBlendActor;                         // 0x0130(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSubclassOf<class AGzWorldVisibilityBlendActor> WorldVisibilityBlendActorClass;                    // 0x0138(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_30B9[0x18];                                    // 0x0140(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnOwnerShoot();
	void Refresh();

	EGzWorldVisibilityState GetVisibilityState() const;
	EGzWorldVisibilityState GetVisibilityStateStencil() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzCharacterWorldVisibilityComponent">();
	}
	static class UGzCharacterWorldVisibilityComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzCharacterWorldVisibilityComponent>();
	}
};
static_assert(alignof(UGzCharacterWorldVisibilityComponent) == 0x000008, "Wrong alignment on UGzCharacterWorldVisibilityComponent");
static_assert(sizeof(UGzCharacterWorldVisibilityComponent) == 0x000158, "Wrong size on UGzCharacterWorldVisibilityComponent");
static_assert(offsetof(UGzCharacterWorldVisibilityComponent, OnVisibilityStateChangedMarker) == 0x0000A8, "Member 'UGzCharacterWorldVisibilityComponent::OnVisibilityStateChangedMarker' has a wrong offset!");
static_assert(offsetof(UGzCharacterWorldVisibilityComponent, OnVisibilityStateChangedStencil) == 0x0000B8, "Member 'UGzCharacterWorldVisibilityComponent::OnVisibilityStateChangedStencil' has a wrong offset!");
static_assert(offsetof(UGzCharacterWorldVisibilityComponent, OwnedTagToVisibilityState) == 0x0000C8, "Member 'UGzCharacterWorldVisibilityComponent::OwnedTagToVisibilityState' has a wrong offset!");
static_assert(offsetof(UGzCharacterWorldVisibilityComponent, VisibilityStates) == 0x0000D8, "Member 'UGzCharacterWorldVisibilityComponent::VisibilityStates' has a wrong offset!");
static_assert(offsetof(UGzCharacterWorldVisibilityComponent, RecentlyShotRevealDuration) == 0x000128, "Member 'UGzCharacterWorldVisibilityComponent::RecentlyShotRevealDuration' has a wrong offset!");
static_assert(offsetof(UGzCharacterWorldVisibilityComponent, MaxShootingRevealDistance) == 0x00012C, "Member 'UGzCharacterWorldVisibilityComponent::MaxShootingRevealDistance' has a wrong offset!");
static_assert(offsetof(UGzCharacterWorldVisibilityComponent, WorldVisibilityBlendActor) == 0x000130, "Member 'UGzCharacterWorldVisibilityComponent::WorldVisibilityBlendActor' has a wrong offset!");
static_assert(offsetof(UGzCharacterWorldVisibilityComponent, WorldVisibilityBlendActorClass) == 0x000138, "Member 'UGzCharacterWorldVisibilityComponent::WorldVisibilityBlendActorClass' has a wrong offset!");

// Class G01.GzGameLogSettings
// 0x0020 (0x0058 - 0x0038)
class UGzGameLogSettings final : public UDeveloperSettings
{
public:
	class FString                                 SharedLogPath;                                     // 0x0038(0x0010)(ZeroConstructor, Config, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 SharedLogPathLinux;                                // 0x0048(0x0010)(ZeroConstructor, Config, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzGameLogSettings">();
	}
	static class UGzGameLogSettings* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzGameLogSettings>();
	}
};
static_assert(alignof(UGzGameLogSettings) == 0x000008, "Wrong alignment on UGzGameLogSettings");
static_assert(sizeof(UGzGameLogSettings) == 0x000058, "Wrong size on UGzGameLogSettings");
static_assert(offsetof(UGzGameLogSettings, SharedLogPath) == 0x000038, "Member 'UGzGameLogSettings::SharedLogPath' has a wrong offset!");
static_assert(offsetof(UGzGameLogSettings, SharedLogPathLinux) == 0x000048, "Member 'UGzGameLogSettings::SharedLogPathLinux' has a wrong offset!");

// Class G01.GzChargePreviewPathActor
// 0x0020 (0x04B0 - 0x0490)
class AGzChargePreviewPathActor : public AGzPreviewPathActor
{
public:
	float                                         MaxSimulationTime;                                 // 0x0490(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ProjectileRadius;                                  // 0x0494(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bEnableDrag;                                       // 0x0498(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_30BA[0x3];                                     // 0x0499(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         DragCoefficient;                                   // 0x049C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         DragStartingDistance;                              // 0x04A0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_30BB[0x4];                                     // 0x04A4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UGzChargeableAbilityComponent*          AbilityComponent;                                  // 0x04A8(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	class UGzChargeableAbilityComponent* GetAbilityComponent() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzChargePreviewPathActor">();
	}
	static class AGzChargePreviewPathActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<AGzChargePreviewPathActor>();
	}
};
static_assert(alignof(AGzChargePreviewPathActor) == 0x000008, "Wrong alignment on AGzChargePreviewPathActor");
static_assert(sizeof(AGzChargePreviewPathActor) == 0x0004B0, "Wrong size on AGzChargePreviewPathActor");
static_assert(offsetof(AGzChargePreviewPathActor, MaxSimulationTime) == 0x000490, "Member 'AGzChargePreviewPathActor::MaxSimulationTime' has a wrong offset!");
static_assert(offsetof(AGzChargePreviewPathActor, ProjectileRadius) == 0x000494, "Member 'AGzChargePreviewPathActor::ProjectileRadius' has a wrong offset!");
static_assert(offsetof(AGzChargePreviewPathActor, bEnableDrag) == 0x000498, "Member 'AGzChargePreviewPathActor::bEnableDrag' has a wrong offset!");
static_assert(offsetof(AGzChargePreviewPathActor, DragCoefficient) == 0x00049C, "Member 'AGzChargePreviewPathActor::DragCoefficient' has a wrong offset!");
static_assert(offsetof(AGzChargePreviewPathActor, DragStartingDistance) == 0x0004A0, "Member 'AGzChargePreviewPathActor::DragStartingDistance' has a wrong offset!");
static_assert(offsetof(AGzChargePreviewPathActor, AbilityComponent) == 0x0004A8, "Member 'AGzChargePreviewPathActor::AbilityComponent' has a wrong offset!");

// Class G01.GzCheatClientPlayerInventoryService
// 0x0070 (0x0110 - 0x00A0)
class UGzCheatClientPlayerInventoryService final : public UGzClientPFObject
{
public:
	uint8                                         Pad_30BC[0x8];                                     // 0x00A0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGzOnlineInventoryItemsCollection      LocalComparisonInventory;                          // 0x00A8(0x0068)(NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzCheatClientPlayerInventoryService">();
	}
	static class UGzCheatClientPlayerInventoryService* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzCheatClientPlayerInventoryService>();
	}
};
static_assert(alignof(UGzCheatClientPlayerInventoryService) == 0x000008, "Wrong alignment on UGzCheatClientPlayerInventoryService");
static_assert(sizeof(UGzCheatClientPlayerInventoryService) == 0x000110, "Wrong size on UGzCheatClientPlayerInventoryService");
static_assert(offsetof(UGzCheatClientPlayerInventoryService, LocalComparisonInventory) == 0x0000A8, "Member 'UGzCheatClientPlayerInventoryService::LocalComparisonInventory' has a wrong offset!");

// Class G01.GzCheatManagerSettings
// 0x0078 (0x00B0 - 0x0038)
class UGzCheatManagerSettings final : public UDeveloperSettings
{
public:
	TSoftClassPtr<class UClass>                   ReviveEffectClass;                                 // 0x0038(0x0028)(Edit, Config, AdvancedDisplay, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftClassPtr<class UClass>                   KillEffectClass;                                   // 0x0060(0x0028)(Edit, Config, AdvancedDisplay, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftClassPtr<class UClass>                   KnockEffectClass;                                  // 0x0088(0x0028)(Edit, Config, AdvancedDisplay, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzCheatManagerSettings">();
	}
	static class UGzCheatManagerSettings* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzCheatManagerSettings>();
	}
};
static_assert(alignof(UGzCheatManagerSettings) == 0x000008, "Wrong alignment on UGzCheatManagerSettings");
static_assert(sizeof(UGzCheatManagerSettings) == 0x0000B0, "Wrong size on UGzCheatManagerSettings");
static_assert(offsetof(UGzCheatManagerSettings, ReviveEffectClass) == 0x000038, "Member 'UGzCheatManagerSettings::ReviveEffectClass' has a wrong offset!");
static_assert(offsetof(UGzCheatManagerSettings, KillEffectClass) == 0x000060, "Member 'UGzCheatManagerSettings::KillEffectClass' has a wrong offset!");
static_assert(offsetof(UGzCheatManagerSettings, KnockEffectClass) == 0x000088, "Member 'UGzCheatManagerSettings::KnockEffectClass' has a wrong offset!");

// Class G01.GzXR_ContainersRefreshEvent
// 0x0000 (0x0058 - 0x0058)
class UGzXR_ContainersRefreshEvent final : public UGzXR_BaseEvent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzXR_ContainersRefreshEvent">();
	}
	static class UGzXR_ContainersRefreshEvent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzXR_ContainersRefreshEvent>();
	}
};
static_assert(alignof(UGzXR_ContainersRefreshEvent) == 0x000008, "Wrong alignment on UGzXR_ContainersRefreshEvent");
static_assert(sizeof(UGzXR_ContainersRefreshEvent) == 0x000058, "Wrong size on UGzXR_ContainersRefreshEvent");

// Class G01.GzCheatSharedLoadoutService
// 0x0000 (0x00A0 - 0x00A0)
class UGzCheatSharedLoadoutService final : public UGzClientPFObject
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzCheatSharedLoadoutService">();
	}
	static class UGzCheatSharedLoadoutService* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzCheatSharedLoadoutService>();
	}
};
static_assert(alignof(UGzCheatSharedLoadoutService) == 0x000008, "Wrong alignment on UGzCheatSharedLoadoutService");
static_assert(sizeof(UGzCheatSharedLoadoutService) == 0x0000A0, "Wrong size on UGzCheatSharedLoadoutService");

// Class G01.GzCheckedOverlapSphereComponent
// 0x0040 (0x0590 - 0x0550)
class UGzCheckedOverlapSphereComponent : public USphereComponent
{
public:
	FMulticastInlineDelegateProperty_             OnValidBeginOverlap;                               // 0x0550(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnValidEndOverlap;                                 // 0x0560(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	bool                                          bEnableOverlapObstacleCheck;                       // 0x0570(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_30BD[0x7];                                     // 0x0571(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                OverlapObstacleCheckOffset;                        // 0x0578(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void GzComponentBeginOverlapSignature__DelegateSignature(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const struct FHitResult& SweepResult);
	void GzComponentEndOverlapSignature__DelegateSignature(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex);
	void OnBeginOverlap(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const struct FHitResult& SweepResult);
	void OnEndOverlap(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzCheckedOverlapSphereComponent">();
	}
	static class UGzCheckedOverlapSphereComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzCheckedOverlapSphereComponent>();
	}
};
static_assert(alignof(UGzCheckedOverlapSphereComponent) == 0x000010, "Wrong alignment on UGzCheckedOverlapSphereComponent");
static_assert(sizeof(UGzCheckedOverlapSphereComponent) == 0x000590, "Wrong size on UGzCheckedOverlapSphereComponent");
static_assert(offsetof(UGzCheckedOverlapSphereComponent, OnValidBeginOverlap) == 0x000550, "Member 'UGzCheckedOverlapSphereComponent::OnValidBeginOverlap' has a wrong offset!");
static_assert(offsetof(UGzCheckedOverlapSphereComponent, OnValidEndOverlap) == 0x000560, "Member 'UGzCheckedOverlapSphereComponent::OnValidEndOverlap' has a wrong offset!");
static_assert(offsetof(UGzCheckedOverlapSphereComponent, bEnableOverlapObstacleCheck) == 0x000570, "Member 'UGzCheckedOverlapSphereComponent::bEnableOverlapObstacleCheck' has a wrong offset!");
static_assert(offsetof(UGzCheckedOverlapSphereComponent, OverlapObstacleCheckOffset) == 0x000578, "Member 'UGzCheckedOverlapSphereComponent::OverlapObstacleCheckOffset' has a wrong offset!");

// Class G01.GzUnityMatchmakingQueuesManager
// 0x0030 (0x00D0 - 0x00A0)
class UGzUnityMatchmakingQueuesManager final : public UGzServiceComponent
{
public:
	uint8                                         Pad_30C2[0x30];                                    // 0x00A0(0x0030)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzUnityMatchmakingQueuesManager">();
	}
	static class UGzUnityMatchmakingQueuesManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzUnityMatchmakingQueuesManager>();
	}
};
static_assert(alignof(UGzUnityMatchmakingQueuesManager) == 0x000008, "Wrong alignment on UGzUnityMatchmakingQueuesManager");
static_assert(sizeof(UGzUnityMatchmakingQueuesManager) == 0x0000D0, "Wrong size on UGzUnityMatchmakingQueuesManager");

// Class G01.GzCircleMarkerShape
// 0x0008 (0x0040 - 0x0038)
class UGzCircleMarkerShape final : public UGzMarkerShape
{
public:
	float                                         Radius;                                            // 0x0038(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_30C3[0x4];                                     // 0x003C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetRadius(float InRadius);

	float GetAreaRadius() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzCircleMarkerShape">();
	}
	static class UGzCircleMarkerShape* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzCircleMarkerShape>();
	}
};
static_assert(alignof(UGzCircleMarkerShape) == 0x000008, "Wrong alignment on UGzCircleMarkerShape");
static_assert(sizeof(UGzCircleMarkerShape) == 0x000040, "Wrong size on UGzCircleMarkerShape");
static_assert(offsetof(UGzCircleMarkerShape, Radius) == 0x000038, "Member 'UGzCircleMarkerShape::Radius' has a wrong offset!");

// Class G01.GzXR_PreMatchStage
// 0x0020 (0x0138 - 0x0118)
class UGzXR_PreMatchStage : public UGzPreMatchStage
{
public:
	TArray<class AGzSpawnArea*>                   SpawnAreas;                                        // 0x0118(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	uint8                                         Pad_30C4[0x10];                                    // 0x0128(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzXR_PreMatchStage">();
	}
	static class UGzXR_PreMatchStage* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzXR_PreMatchStage>();
	}
};
static_assert(alignof(UGzXR_PreMatchStage) == 0x000008, "Wrong alignment on UGzXR_PreMatchStage");
static_assert(sizeof(UGzXR_PreMatchStage) == 0x000138, "Wrong size on UGzXR_PreMatchStage");
static_assert(offsetof(UGzXR_PreMatchStage, SpawnAreas) == 0x000118, "Member 'UGzXR_PreMatchStage::SpawnAreas' has a wrong offset!");

// Class G01.GzCIT_Clothing
// 0x0000 (0x0450 - 0x0450)
class UGzCIT_Clothing : public UGzCustomizationItemTemplate
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzCIT_Clothing">();
	}
	static class UGzCIT_Clothing* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzCIT_Clothing>();
	}
};
static_assert(alignof(UGzCIT_Clothing) == 0x000008, "Wrong alignment on UGzCIT_Clothing");
static_assert(sizeof(UGzCIT_Clothing) == 0x000450, "Wrong size on UGzCIT_Clothing");

// Class G01.GzCIT_Eye
// 0x0000 (0x0450 - 0x0450)
class UGzCIT_Eye final : public UGzCustomizationItemTemplate
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzCIT_Eye">();
	}
	static class UGzCIT_Eye* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzCIT_Eye>();
	}
};
static_assert(alignof(UGzCIT_Eye) == 0x000008, "Wrong alignment on UGzCIT_Eye");
static_assert(sizeof(UGzCIT_Eye) == 0x000450, "Wrong size on UGzCIT_Eye");

// Class G01.GzViewObstructionInterface
// 0x0000 (0x0028 - 0x0028)
class IGzViewObstructionInterface final : public IInterface
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzViewObstructionInterface">();
	}
	static class IGzViewObstructionInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IGzViewObstructionInterface>();
	}
};
static_assert(alignof(IGzViewObstructionInterface) == 0x000008, "Wrong alignment on IGzViewObstructionInterface");
static_assert(sizeof(IGzViewObstructionInterface) == 0x000028, "Wrong size on IGzViewObstructionInterface");

// Class G01.GzLiveFeaturesUpdatedHandler
// 0x0000 (0x0048 - 0x0048)
class UGzLiveFeaturesUpdatedHandler final : public UGzSignalREvent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzLiveFeaturesUpdatedHandler">();
	}
	static class UGzLiveFeaturesUpdatedHandler* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzLiveFeaturesUpdatedHandler>();
	}
};
static_assert(alignof(UGzLiveFeaturesUpdatedHandler) == 0x000008, "Wrong alignment on UGzLiveFeaturesUpdatedHandler");
static_assert(sizeof(UGzLiveFeaturesUpdatedHandler) == 0x000048, "Wrong size on UGzLiveFeaturesUpdatedHandler");

// Class G01.GzCIT_Head
// 0x0050 (0x04A0 - 0x0450)
class UGzCIT_Head final : public UGzCustomizationItemTemplate
{
public:
	struct FGzMorphData                           HeadMorphData;                                     // 0x0450(0x0050)(Edit, DisableEditOnInstance, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzCIT_Head">();
	}
	static class UGzCIT_Head* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzCIT_Head>();
	}
};
static_assert(alignof(UGzCIT_Head) == 0x000008, "Wrong alignment on UGzCIT_Head");
static_assert(sizeof(UGzCIT_Head) == 0x0004A0, "Wrong size on UGzCIT_Head");
static_assert(offsetof(UGzCIT_Head, HeadMorphData) == 0x000450, "Member 'UGzCIT_Head::HeadMorphData' has a wrong offset!");

// Class G01.GzGA_WeaponAim
// 0x00A0 (0x05F8 - 0x0558)
class UGzGA_WeaponAim : public UGzGA_WeaponAbilityBase
{
public:
	FMulticastInlineDelegateProperty_             OnHoldBreathStarted;                               // 0x0558(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnBreathStaminaChanged;                            // 0x0568(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnOutOfBreathStamina;                              // 0x0578(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnBreathStaminaFull;                               // 0x0588(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnHoldBreathStopped;                               // 0x0598(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TSubclassOf<class UGameplayEffect>            ScopeAimEffect;                                    // 0x05A8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_30C5[0x8];                                     // 0x05B0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         UncrouchMaxDistance;                               // 0x05B8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_30C6[0x4];                                     // 0x05BC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UInputAction*                           HoldBreathAction;                                  // 0x05C0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FGzInputMappingContextInfo             ScopedInputMappingDecorator;                       // 0x05C8(0x0010)(Edit, DisableEditOnInstance, NoDestructor, Protected, NativeAccessSpecifierProtected)
	TSubclassOf<class UGzProgressLogEntryWidget>  HoldBreathWidgetClass;                             // 0x05D8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UGzAT_WaitCustomInputPress*             WaitHoldBreathPressTask;                           // 0x05E0(0x0008)(ZeroConstructor, Transient, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UGzAT_WaitCustomInputRelease*           WaitHoldBreathReleaseTask;                         // 0x05E8(0x0008)(ZeroConstructor, Transient, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_30C7[0x8];                                     // 0x05F0(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnHoldBreathPressedInput(float TimeHeld);
	void OnHoldBreathReleasedInput(float TimeHeld);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzGA_WeaponAim">();
	}
	static class UGzGA_WeaponAim* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzGA_WeaponAim>();
	}
};
static_assert(alignof(UGzGA_WeaponAim) == 0x000008, "Wrong alignment on UGzGA_WeaponAim");
static_assert(sizeof(UGzGA_WeaponAim) == 0x0005F8, "Wrong size on UGzGA_WeaponAim");
static_assert(offsetof(UGzGA_WeaponAim, OnHoldBreathStarted) == 0x000558, "Member 'UGzGA_WeaponAim::OnHoldBreathStarted' has a wrong offset!");
static_assert(offsetof(UGzGA_WeaponAim, OnBreathStaminaChanged) == 0x000568, "Member 'UGzGA_WeaponAim::OnBreathStaminaChanged' has a wrong offset!");
static_assert(offsetof(UGzGA_WeaponAim, OnOutOfBreathStamina) == 0x000578, "Member 'UGzGA_WeaponAim::OnOutOfBreathStamina' has a wrong offset!");
static_assert(offsetof(UGzGA_WeaponAim, OnBreathStaminaFull) == 0x000588, "Member 'UGzGA_WeaponAim::OnBreathStaminaFull' has a wrong offset!");
static_assert(offsetof(UGzGA_WeaponAim, OnHoldBreathStopped) == 0x000598, "Member 'UGzGA_WeaponAim::OnHoldBreathStopped' has a wrong offset!");
static_assert(offsetof(UGzGA_WeaponAim, ScopeAimEffect) == 0x0005A8, "Member 'UGzGA_WeaponAim::ScopeAimEffect' has a wrong offset!");
static_assert(offsetof(UGzGA_WeaponAim, UncrouchMaxDistance) == 0x0005B8, "Member 'UGzGA_WeaponAim::UncrouchMaxDistance' has a wrong offset!");
static_assert(offsetof(UGzGA_WeaponAim, HoldBreathAction) == 0x0005C0, "Member 'UGzGA_WeaponAim::HoldBreathAction' has a wrong offset!");
static_assert(offsetof(UGzGA_WeaponAim, ScopedInputMappingDecorator) == 0x0005C8, "Member 'UGzGA_WeaponAim::ScopedInputMappingDecorator' has a wrong offset!");
static_assert(offsetof(UGzGA_WeaponAim, HoldBreathWidgetClass) == 0x0005D8, "Member 'UGzGA_WeaponAim::HoldBreathWidgetClass' has a wrong offset!");
static_assert(offsetof(UGzGA_WeaponAim, WaitHoldBreathPressTask) == 0x0005E0, "Member 'UGzGA_WeaponAim::WaitHoldBreathPressTask' has a wrong offset!");
static_assert(offsetof(UGzGA_WeaponAim, WaitHoldBreathReleaseTask) == 0x0005E8, "Member 'UGzGA_WeaponAim::WaitHoldBreathReleaseTask' has a wrong offset!");

// Class G01.GzCIT_Jetpack
// 0x0000 (0x0450 - 0x0450)
class UGzCIT_Jetpack final : public UGzCustomizationItemTemplate
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzCIT_Jetpack">();
	}
	static class UGzCIT_Jetpack* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzCIT_Jetpack>();
	}
};
static_assert(alignof(UGzCIT_Jetpack) == 0x000008, "Wrong alignment on UGzCIT_Jetpack");
static_assert(sizeof(UGzCIT_Jetpack) == 0x000450, "Wrong size on UGzCIT_Jetpack");

// Class G01.GzCIT_Pants
// 0x0010 (0x0460 - 0x0450)
class UGzCIT_Pants final : public UGzCIT_Clothing
{
public:
	TArray<struct FGzVariationMeshData>           RippedPantsMeshAssetArray;                         // 0x0450(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzCIT_Pants">();
	}
	static class UGzCIT_Pants* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzCIT_Pants>();
	}
};
static_assert(alignof(UGzCIT_Pants) == 0x000008, "Wrong alignment on UGzCIT_Pants");
static_assert(sizeof(UGzCIT_Pants) == 0x000460, "Wrong size on UGzCIT_Pants");
static_assert(offsetof(UGzCIT_Pants, RippedPantsMeshAssetArray) == 0x000450, "Member 'UGzCIT_Pants::RippedPantsMeshAssetArray' has a wrong offset!");

// Class G01.GzXR_HexExtractionStartRedeployModifier
// 0x0008 (0x0090 - 0x0088)
class UGzXR_HexExtractionStartRedeployModifier final : public UGzXR_BaseRedeployModifier
{
public:
	uint8                                         Pad_30C8[0x8];                                     // 0x0088(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzXR_HexExtractionStartRedeployModifier">();
	}
	static class UGzXR_HexExtractionStartRedeployModifier* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzXR_HexExtractionStartRedeployModifier>();
	}
};
static_assert(alignof(UGzXR_HexExtractionStartRedeployModifier) == 0x000008, "Wrong alignment on UGzXR_HexExtractionStartRedeployModifier");
static_assert(sizeof(UGzXR_HexExtractionStartRedeployModifier) == 0x000090, "Wrong size on UGzXR_HexExtractionStartRedeployModifier");

// Class G01.GzCIT_Set
// 0x0150 (0x05A0 - 0x0450)
class UGzCIT_Set final : public UGzCustomizationItemTemplate
{
public:
	struct FGzCharacterCustomizationProfile       SetPieces;                                         // 0x0450(0x0150)(Edit, BlueprintVisible, DisableEditOnInstance, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzCIT_Set">();
	}
	static class UGzCIT_Set* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzCIT_Set>();
	}
};
static_assert(alignof(UGzCIT_Set) == 0x000008, "Wrong alignment on UGzCIT_Set");
static_assert(sizeof(UGzCIT_Set) == 0x0005A0, "Wrong size on UGzCIT_Set");
static_assert(offsetof(UGzCIT_Set, SetPieces) == 0x000450, "Member 'UGzCIT_Set::SetPieces' has a wrong offset!");

// Class G01.GzCyberLimbsPanel_Limb
// 0x00B8 (0x03F8 - 0x0340)
class UGzCyberLimbsPanel_Limb : public UGzHUDComponent
{
public:
	class UGzItemData*                            LimbItemData;                                      // 0x0340(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UGzGA_BaseLimbAbility*                  LimbAbility;                                       // 0x0348(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EGzLimbType                                   CyberLimb;                                         // 0x0350(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EGzLimbWidgetState                            ActivationState;                                   // 0x0351(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_30C9[0xA6];                                    // 0x0352(0x00A6)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void InitializeLimbInfo();
	void OnActivationStateUpdated(EGzLimbWidgetState NewState);
	void OnLimbAbilityComponentUpdated(bool bLimbAbilityComponentValid);
	void OnLimbAbilityUpdated(bool bLimbAbilityValid);
	void OnLimbAtMaxCharges(bool bHaveMaxCharges);
	void OnLimbChanged(EGzLimbType LimbType);
	void OnLimbCooldown(bool bOnCooldown);
	void OnLimbRecharging(bool bRecharging);
	void OnLimbUpdated(bool bLimbValid);
	void UpdateLimbData();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzCyberLimbsPanel_Limb">();
	}
	static class UGzCyberLimbsPanel_Limb* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzCyberLimbsPanel_Limb>();
	}
};
static_assert(alignof(UGzCyberLimbsPanel_Limb) == 0x000008, "Wrong alignment on UGzCyberLimbsPanel_Limb");
static_assert(sizeof(UGzCyberLimbsPanel_Limb) == 0x0003F8, "Wrong size on UGzCyberLimbsPanel_Limb");
static_assert(offsetof(UGzCyberLimbsPanel_Limb, LimbItemData) == 0x000340, "Member 'UGzCyberLimbsPanel_Limb::LimbItemData' has a wrong offset!");
static_assert(offsetof(UGzCyberLimbsPanel_Limb, LimbAbility) == 0x000348, "Member 'UGzCyberLimbsPanel_Limb::LimbAbility' has a wrong offset!");
static_assert(offsetof(UGzCyberLimbsPanel_Limb, CyberLimb) == 0x000350, "Member 'UGzCyberLimbsPanel_Limb::CyberLimb' has a wrong offset!");
static_assert(offsetof(UGzCyberLimbsPanel_Limb, ActivationState) == 0x000351, "Member 'UGzCyberLimbsPanel_Limb::ActivationState' has a wrong offset!");

// Class G01.GzSubscriptionReceivedHandler
// 0x0000 (0x0048 - 0x0048)
class UGzSubscriptionReceivedHandler final : public UGzSignalREvent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzSubscriptionReceivedHandler">();
	}
	static class UGzSubscriptionReceivedHandler* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzSubscriptionReceivedHandler>();
	}
};
static_assert(alignof(UGzSubscriptionReceivedHandler) == 0x000008, "Wrong alignment on UGzSubscriptionReceivedHandler");
static_assert(sizeof(UGzSubscriptionReceivedHandler) == 0x000048, "Wrong size on UGzSubscriptionReceivedHandler");

// Class G01.GzCIT_Skin
// 0x0000 (0x0450 - 0x0450)
class UGzCIT_Skin final : public UGzCustomizationItemTemplate
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzCIT_Skin">();
	}
	static class UGzCIT_Skin* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzCIT_Skin>();
	}
};
static_assert(alignof(UGzCIT_Skin) == 0x000008, "Wrong alignment on UGzCIT_Skin");
static_assert(sizeof(UGzCIT_Skin) == 0x000450, "Wrong size on UGzCIT_Skin");

// Class G01.GzCIT_Torso
// 0x0000 (0x0450 - 0x0450)
class UGzCIT_Torso final : public UGzCustomizationItemTemplate
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzCIT_Torso">();
	}
	static class UGzCIT_Torso* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzCIT_Torso>();
	}
};
static_assert(alignof(UGzCIT_Torso) == 0x000008, "Wrong alignment on UGzCIT_Torso");
static_assert(sizeof(UGzCIT_Torso) == 0x000450, "Wrong size on UGzCIT_Torso");

// Class G01.GzCIT_Voice
// 0x0028 (0x0478 - 0x0450)
class UGzCIT_Voice final : public UGzCustomizationItemTemplate
{
public:
	TSoftObjectPtr<class UAkSwitchValue>          VoiceSwitch;                                       // 0x0450(0x0028)(Edit, DisableEditOnInstance, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzCIT_Voice">();
	}
	static class UGzCIT_Voice* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzCIT_Voice>();
	}
};
static_assert(alignof(UGzCIT_Voice) == 0x000008, "Wrong alignment on UGzCIT_Voice");
static_assert(sizeof(UGzCIT_Voice) == 0x000478, "Wrong size on UGzCIT_Voice");
static_assert(offsetof(UGzCIT_Voice, VoiceSwitch) == 0x000450, "Member 'UGzCIT_Voice::VoiceSwitch' has a wrong offset!");

// Class G01.GzPlatformsCheatExtension
// 0x0000 (0x0028 - 0x0028)
class UGzPlatformsCheatExtension final : public UGzCheatManagerExtension
{
public:
	void SetPlatformType(const class FString& PlatformType) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzPlatformsCheatExtension">();
	}
	static class UGzPlatformsCheatExtension* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzPlatformsCheatExtension>();
	}
};
static_assert(alignof(UGzPlatformsCheatExtension) == 0x000008, "Wrong alignment on UGzPlatformsCheatExtension");
static_assert(sizeof(UGzPlatformsCheatExtension) == 0x000028, "Wrong size on UGzPlatformsCheatExtension");

// Class G01.GzClientAntiCheatService
// 0x0008 (0x00A8 - 0x00A0)
class UGzClientAntiCheatService final : public UGzClientPFObject
{
public:
	uint8                                         Pad_30CA[0x8];                                     // 0x00A0(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzClientAntiCheatService">();
	}
	static class UGzClientAntiCheatService* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzClientAntiCheatService>();
	}
};
static_assert(alignof(UGzClientAntiCheatService) == 0x000008, "Wrong alignment on UGzClientAntiCheatService");
static_assert(sizeof(UGzClientAntiCheatService) == 0x0000A8, "Wrong size on UGzClientAntiCheatService");

// Class G01.GzGameplayCueEventChooser
// 0x0010 (0x0038 - 0x0028)
class UGzGameplayCueEventChooser final : public UObject
{
public:
	TSubclassOf<class UGzGameplayAbility>         TargetAbility;                                     // 0x0028(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         EventId;                                           // 0x0030(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_30CB[0x7];                                     // 0x0031(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzGameplayCueEventChooser">();
	}
	static class UGzGameplayCueEventChooser* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzGameplayCueEventChooser>();
	}
};
static_assert(alignof(UGzGameplayCueEventChooser) == 0x000008, "Wrong alignment on UGzGameplayCueEventChooser");
static_assert(sizeof(UGzGameplayCueEventChooser) == 0x000038, "Wrong size on UGzGameplayCueEventChooser");
static_assert(offsetof(UGzGameplayCueEventChooser, TargetAbility) == 0x000028, "Member 'UGzGameplayCueEventChooser::TargetAbility' has a wrong offset!");
static_assert(offsetof(UGzGameplayCueEventChooser, EventId) == 0x000030, "Member 'UGzGameplayCueEventChooser::EventId' has a wrong offset!");

// Class G01.GzNewNotificationsData
// 0x0000 (0x0028 - 0x0028)
class UGzNewNotificationsData final : public UGzSignalREventData
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzNewNotificationsData">();
	}
	static class UGzNewNotificationsData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzNewNotificationsData>();
	}
};
static_assert(alignof(UGzNewNotificationsData) == 0x000008, "Wrong alignment on UGzNewNotificationsData");
static_assert(sizeof(UGzNewNotificationsData) == 0x000028, "Wrong size on UGzNewNotificationsData");

// Class G01.GzCustomMatchmakingService
// 0x0028 (0x00C8 - 0x00A0)
class UGzCustomMatchmakingService final : public UGzClientPFObject
{
public:
	uint8                                         Pad_30CC[0x28];                                    // 0x00A0(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzCustomMatchmakingService">();
	}
	static class UGzCustomMatchmakingService* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzCustomMatchmakingService>();
	}
};
static_assert(alignof(UGzCustomMatchmakingService) == 0x000008, "Wrong alignment on UGzCustomMatchmakingService");
static_assert(sizeof(UGzCustomMatchmakingService) == 0x0000C8, "Wrong size on UGzCustomMatchmakingService");

// Class G01.GzClientChallengeService
// 0x0080 (0x0120 - 0x00A0)
class UGzClientChallengeService final : public UGzPlayFabObject
{
public:
	uint8                                         Pad_30CD[0x80];                                    // 0x00A0(0x0080)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzClientChallengeService">();
	}
	static class UGzClientChallengeService* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzClientChallengeService>();
	}
};
static_assert(alignof(UGzClientChallengeService) == 0x000008, "Wrong alignment on UGzClientChallengeService");
static_assert(sizeof(UGzClientChallengeService) == 0x000120, "Wrong size on UGzClientChallengeService");

// Class G01.GzClientConsoleMatchService
// 0x0050 (0x00F0 - 0x00A0)
class UGzClientConsoleMatchService final : public UGzPlayFabObject
{
public:
	uint8                                         Pad_30CE[0x50];                                    // 0x00A0(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzClientConsoleMatchService">();
	}
	static class UGzClientConsoleMatchService* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzClientConsoleMatchService>();
	}
};
static_assert(alignof(UGzClientConsoleMatchService) == 0x000008, "Wrong alignment on UGzClientConsoleMatchService");
static_assert(sizeof(UGzClientConsoleMatchService) == 0x0000F0, "Wrong size on UGzClientConsoleMatchService");

// Class G01.GzDamageableSkeletalMeshComponent
// 0x0030 (0x0FA0 - 0x0F70)
class UGzDamageableSkeletalMeshComponent final : public USkeletalMeshComponent
{
public:
	uint8                                         Pad_30CF[0x8];                                     // 0x0F68(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UPrimitiveComponent>        HitShapeClass;                                     // 0x0F70(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UPrimitiveComponent*                    HitShape;                                          // 0x0F78(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FGzDamageAreaInfo                      DamageAreaInfo;                                    // 0x0F80(0x000C)(Edit, DisableEditOnInstance, NoDestructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_30D0[0x14];                                    // 0x0F8C(0x0014)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzDamageableSkeletalMeshComponent">();
	}
	static class UGzDamageableSkeletalMeshComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzDamageableSkeletalMeshComponent>();
	}
};
static_assert(alignof(UGzDamageableSkeletalMeshComponent) == 0x000010, "Wrong alignment on UGzDamageableSkeletalMeshComponent");
static_assert(sizeof(UGzDamageableSkeletalMeshComponent) == 0x000FA0, "Wrong size on UGzDamageableSkeletalMeshComponent");
static_assert(offsetof(UGzDamageableSkeletalMeshComponent, HitShapeClass) == 0x000F70, "Member 'UGzDamageableSkeletalMeshComponent::HitShapeClass' has a wrong offset!");
static_assert(offsetof(UGzDamageableSkeletalMeshComponent, HitShape) == 0x000F78, "Member 'UGzDamageableSkeletalMeshComponent::HitShape' has a wrong offset!");
static_assert(offsetof(UGzDamageableSkeletalMeshComponent, DamageAreaInfo) == 0x000F80, "Member 'UGzDamageableSkeletalMeshComponent::DamageAreaInfo' has a wrong offset!");

// Class G01.GzClientCustomizationFacade
// 0x0000 (0x0030 - 0x0030)
class UGzClientCustomizationFacade final : public UGzFacade
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzClientCustomizationFacade">();
	}
	static class UGzClientCustomizationFacade* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzClientCustomizationFacade>();
	}
};
static_assert(alignof(UGzClientCustomizationFacade) == 0x000008, "Wrong alignment on UGzClientCustomizationFacade");
static_assert(sizeof(UGzClientCustomizationFacade) == 0x000030, "Wrong size on UGzClientCustomizationFacade");

// Class G01.GzHasDamageableAreas
// 0x0000 (0x0028 - 0x0028)
class IGzHasDamageableAreas final : public IInterface
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzHasDamageableAreas">();
	}
	static class IGzHasDamageableAreas* GetDefaultObj()
	{
		return GetDefaultObjImpl<IGzHasDamageableAreas>();
	}
};
static_assert(alignof(IGzHasDamageableAreas) == 0x000008, "Wrong alignment on IGzHasDamageableAreas");
static_assert(sizeof(IGzHasDamageableAreas) == 0x000028, "Wrong size on IGzHasDamageableAreas");

// Class G01.GzGA_WingsuitBoost
// 0x0020 (0x0528 - 0x0508)
class UGzGA_WingsuitBoost : public UGzGameplayAbility
{
public:
	float                                         FuelRemaining;                                     // 0x0508(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_30D1[0x4];                                     // 0x050C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UGzWingsuitSettingsDataAsset*           BoostSettings;                                     // 0x0510(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         FuelChargePerSecond;                               // 0x0518(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_30D2[0x4];                                     // 0x051C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UStaticMesh*                            Visual;                                            // 0x0520(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	bool IsBoostActivate() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzGA_WingsuitBoost">();
	}
	static class UGzGA_WingsuitBoost* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzGA_WingsuitBoost>();
	}
};
static_assert(alignof(UGzGA_WingsuitBoost) == 0x000008, "Wrong alignment on UGzGA_WingsuitBoost");
static_assert(sizeof(UGzGA_WingsuitBoost) == 0x000528, "Wrong size on UGzGA_WingsuitBoost");
static_assert(offsetof(UGzGA_WingsuitBoost, FuelRemaining) == 0x000508, "Member 'UGzGA_WingsuitBoost::FuelRemaining' has a wrong offset!");
static_assert(offsetof(UGzGA_WingsuitBoost, BoostSettings) == 0x000510, "Member 'UGzGA_WingsuitBoost::BoostSettings' has a wrong offset!");
static_assert(offsetof(UGzGA_WingsuitBoost, FuelChargePerSecond) == 0x000518, "Member 'UGzGA_WingsuitBoost::FuelChargePerSecond' has a wrong offset!");
static_assert(offsetof(UGzGA_WingsuitBoost, Visual) == 0x000520, "Member 'UGzGA_WingsuitBoost::Visual' has a wrong offset!");

// Class G01.GzWeaponADSModifier
// 0x0010 (0x0038 - 0x0028)
class UGzWeaponADSModifier final : public UGzWeaponAimModifier
{
public:
	float                                         AimingBlendTimeCoefficient;                        // 0x0028(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ADSWalkSpeedCoefficient;                           // 0x002C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ADSCrouchSpeedCoefficient;                         // 0x0030(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_30D3[0x4];                                     // 0x0034(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzWeaponADSModifier">();
	}
	static class UGzWeaponADSModifier* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzWeaponADSModifier>();
	}
};
static_assert(alignof(UGzWeaponADSModifier) == 0x000008, "Wrong alignment on UGzWeaponADSModifier");
static_assert(sizeof(UGzWeaponADSModifier) == 0x000038, "Wrong size on UGzWeaponADSModifier");
static_assert(offsetof(UGzWeaponADSModifier, AimingBlendTimeCoefficient) == 0x000028, "Member 'UGzWeaponADSModifier::AimingBlendTimeCoefficient' has a wrong offset!");
static_assert(offsetof(UGzWeaponADSModifier, ADSWalkSpeedCoefficient) == 0x00002C, "Member 'UGzWeaponADSModifier::ADSWalkSpeedCoefficient' has a wrong offset!");
static_assert(offsetof(UGzWeaponADSModifier, ADSCrouchSpeedCoefficient) == 0x000030, "Member 'UGzWeaponADSModifier::ADSCrouchSpeedCoefficient' has a wrong offset!");

// Class G01.GzClientDatacubeService
// 0x0030 (0x00D0 - 0x00A0)
class UGzClientDatacubeService final : public UGzClientPFObject
{
public:
	uint8                                         Pad_30D4[0x30];                                    // 0x00A0(0x0030)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzClientDatacubeService">();
	}
	static class UGzClientDatacubeService* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzClientDatacubeService>();
	}
};
static_assert(alignof(UGzClientDatacubeService) == 0x000008, "Wrong alignment on UGzClientDatacubeService");
static_assert(sizeof(UGzClientDatacubeService) == 0x0000D0, "Wrong size on UGzClientDatacubeService");

// Class G01.GzMarkersSettingAsset
// 0x0060 (0x0090 - 0x0030)
class UGzMarkersSettingAsset final : public UDataAsset
{
public:
	TMap<struct FGameplayTag, struct FGzMarkerSettings> MarkerSettings;                                    // 0x0030(0x0050)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	TArray<TSoftClassPtr<class UClass>>           ServerMarkerActorClasses;                          // 0x0080(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, Protected, UObjectWrapper, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzMarkersSettingAsset">();
	}
	static class UGzMarkersSettingAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzMarkersSettingAsset>();
	}
};
static_assert(alignof(UGzMarkersSettingAsset) == 0x000008, "Wrong alignment on UGzMarkersSettingAsset");
static_assert(sizeof(UGzMarkersSettingAsset) == 0x000090, "Wrong size on UGzMarkersSettingAsset");
static_assert(offsetof(UGzMarkersSettingAsset, MarkerSettings) == 0x000030, "Member 'UGzMarkersSettingAsset::MarkerSettings' has a wrong offset!");
static_assert(offsetof(UGzMarkersSettingAsset, ServerMarkerActorClasses) == 0x000080, "Member 'UGzMarkersSettingAsset::ServerMarkerActorClasses' has a wrong offset!");

// Class G01.GzClientDiscoveryService
// 0x0038 (0x00D8 - 0x00A0)
class UGzClientDiscoveryService final : public UGzClientPFObject
{
public:
	uint8                                         Pad_30D5[0x38];                                    // 0x00A0(0x0038)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzClientDiscoveryService">();
	}
	static class UGzClientDiscoveryService* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzClientDiscoveryService>();
	}
};
static_assert(alignof(UGzClientDiscoveryService) == 0x000008, "Wrong alignment on UGzClientDiscoveryService");
static_assert(sizeof(UGzClientDiscoveryService) == 0x0000D8, "Wrong size on UGzClientDiscoveryService");

// Class G01.GzSoundNotifyStateBase
// 0x0018 (0x0048 - 0x0030)
class UGzSoundNotifyStateBase : public UAnimNotifyState
{
public:
	EGzSoundSourceBodyPart                        SoundSourceBodyPart;                               // 0x0030(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_30D6[0x3];                                     // 0x0031(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   ActionType;                                        // 0x0034(0x0008)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_30D7[0x4];                                     // 0x003C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UAkComponent*                           CachedAkComponent;                                 // 0x0040(0x0008)(ExportObject, BlueprintReadOnly, ZeroConstructor, Transient, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void SetActionType(const class FName& InActionType) const;
	void SetSoundSourceBodyPart(EGzSoundSourceBodyPart InSoundSourceBodyPart) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzSoundNotifyStateBase">();
	}
	static class UGzSoundNotifyStateBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzSoundNotifyStateBase>();
	}
};
static_assert(alignof(UGzSoundNotifyStateBase) == 0x000008, "Wrong alignment on UGzSoundNotifyStateBase");
static_assert(sizeof(UGzSoundNotifyStateBase) == 0x000048, "Wrong size on UGzSoundNotifyStateBase");
static_assert(offsetof(UGzSoundNotifyStateBase, SoundSourceBodyPart) == 0x000030, "Member 'UGzSoundNotifyStateBase::SoundSourceBodyPart' has a wrong offset!");
static_assert(offsetof(UGzSoundNotifyStateBase, ActionType) == 0x000034, "Member 'UGzSoundNotifyStateBase::ActionType' has a wrong offset!");
static_assert(offsetof(UGzSoundNotifyStateBase, CachedAkComponent) == 0x000040, "Member 'UGzSoundNotifyStateBase::CachedAkComponent' has a wrong offset!");

// Class G01.GzCustomizationSoundNotifyState
// 0x0008 (0x0050 - 0x0048)
class UGzCustomizationSoundNotifyState final : public UGzSoundNotifyStateBase
{
public:
	struct FGameplayTag                           Slot;                                              // 0x0048(0x0008)(Edit, BlueprintReadOnly, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void SetSlot(const struct FGameplayTag& InSlot) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzCustomizationSoundNotifyState">();
	}
	static class UGzCustomizationSoundNotifyState* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzCustomizationSoundNotifyState>();
	}
};
static_assert(alignof(UGzCustomizationSoundNotifyState) == 0x000008, "Wrong alignment on UGzCustomizationSoundNotifyState");
static_assert(sizeof(UGzCustomizationSoundNotifyState) == 0x000050, "Wrong size on UGzCustomizationSoundNotifyState");
static_assert(offsetof(UGzCustomizationSoundNotifyState, Slot) == 0x000048, "Member 'UGzCustomizationSoundNotifyState::Slot' has a wrong offset!");

// Class G01.GzWeaponItemData
// 0x0100 (0x03D8 - 0x02D8)
class UGzWeaponItemData final : public UGzItemData
{
public:
	class UGzWeaponArchetype*                     WeaponArchetype;                                   // 0x02D8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UGzWeaponData*                          WeaponData;                                        // 0x02E0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           WeaponSetupTag;                                    // 0x02E8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAllowPlayerToChangeSkin;                          // 0x02F0(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_30D8[0x7];                                     // 0x02F1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UGzWeaponSkinItemData*                  VariantSkinItemData;                               // 0x02F8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bOverrideDefaultAttachmentsList;                   // 0x0300(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_30D9[0x7];                                     // 0x0301(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UGzCrosshair>               WeaponCrosshairClass;                              // 0x0308(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMap<EGzWeaponAttachmentType, class UGzWeaponAttachmentItemData*> DefaultAttachmentsOverridePerCategory;             // 0x0310(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TSet<EGzWeaponAttachmentType>                 AdditionalNonModifieableSlots;                     // 0x0360(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TArray<class UGzWeaponModifier*>              WeaponModifiers;                                   // 0x03B0(0x0010)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, ContainsInstancedReference, NativeAccessSpecifierPublic)
	TArray<class UGzWeaponSkinItemData*>          SetupSuitableSkins;                                // 0x03C0(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	bool                                          bIsUnique;                                         // 0x03D0(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_30DA[0x7];                                     // 0x03D1(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	TMap<EGzWeaponAttachmentType, struct FGzSuitableAttachmentsCategory> GetSuitableAndOverriddenDefaultAttachments() const;
	TArray<class UGzWeaponAttachmentItemData*> GetSuitableAttachmentsList(bool bIncludeDefaults) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzWeaponItemData">();
	}
	static class UGzWeaponItemData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzWeaponItemData>();
	}
};
static_assert(alignof(UGzWeaponItemData) == 0x000008, "Wrong alignment on UGzWeaponItemData");
static_assert(sizeof(UGzWeaponItemData) == 0x0003D8, "Wrong size on UGzWeaponItemData");
static_assert(offsetof(UGzWeaponItemData, WeaponArchetype) == 0x0002D8, "Member 'UGzWeaponItemData::WeaponArchetype' has a wrong offset!");
static_assert(offsetof(UGzWeaponItemData, WeaponData) == 0x0002E0, "Member 'UGzWeaponItemData::WeaponData' has a wrong offset!");
static_assert(offsetof(UGzWeaponItemData, WeaponSetupTag) == 0x0002E8, "Member 'UGzWeaponItemData::WeaponSetupTag' has a wrong offset!");
static_assert(offsetof(UGzWeaponItemData, bAllowPlayerToChangeSkin) == 0x0002F0, "Member 'UGzWeaponItemData::bAllowPlayerToChangeSkin' has a wrong offset!");
static_assert(offsetof(UGzWeaponItemData, VariantSkinItemData) == 0x0002F8, "Member 'UGzWeaponItemData::VariantSkinItemData' has a wrong offset!");
static_assert(offsetof(UGzWeaponItemData, bOverrideDefaultAttachmentsList) == 0x000300, "Member 'UGzWeaponItemData::bOverrideDefaultAttachmentsList' has a wrong offset!");
static_assert(offsetof(UGzWeaponItemData, WeaponCrosshairClass) == 0x000308, "Member 'UGzWeaponItemData::WeaponCrosshairClass' has a wrong offset!");
static_assert(offsetof(UGzWeaponItemData, DefaultAttachmentsOverridePerCategory) == 0x000310, "Member 'UGzWeaponItemData::DefaultAttachmentsOverridePerCategory' has a wrong offset!");
static_assert(offsetof(UGzWeaponItemData, AdditionalNonModifieableSlots) == 0x000360, "Member 'UGzWeaponItemData::AdditionalNonModifieableSlots' has a wrong offset!");
static_assert(offsetof(UGzWeaponItemData, WeaponModifiers) == 0x0003B0, "Member 'UGzWeaponItemData::WeaponModifiers' has a wrong offset!");
static_assert(offsetof(UGzWeaponItemData, SetupSuitableSkins) == 0x0003C0, "Member 'UGzWeaponItemData::SetupSuitableSkins' has a wrong offset!");
static_assert(offsetof(UGzWeaponItemData, bIsUnique) == 0x0003D0, "Member 'UGzWeaponItemData::bIsUnique' has a wrong offset!");

// Class G01.GzHUDView
// 0x0130 (0x0410 - 0x02E0)
class UGzHUDView : public UUserWidget
{
public:
	class APawn*                                  ViewTarget;                                        // 0x02E0(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCanvasPanel*                           AbilityWidgetsContainer;                           // 0x02E8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class URetainerBox*                           CurveRetainerBox;                                  // 0x02F0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UGzViewportMarkerContainer*             ViewportMarkerContainer;                           // 0x02F8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USpacer*                                LeftAspectRatioSpacer;                             // 0x0300(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USpacer*                                RightAspectRatioSpacer;                            // 0x0308(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class UGzHUDComponent*>                Widgets;                                           // 0x0310(0x0010)(ExportObject, ZeroConstructor, Transient, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	TMap<class UGzGameplayAbility*, class UUserWidget*> ActiveAbilitiesWidgets;                            // 0x0320(0x0050)(ExportObject, Transient, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	TMap<struct FGameplayAttribute, FMulticastInlineDelegateProperty_> AttributeChangedEvents;                            // 0x0370(0x0050)(Transient, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	TMap<struct FGameplayTag, FMulticastInlineDelegateProperty_> TagChangedEvents;                                  // 0x03C0(0x0050)(Transient, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)

public:
	void ApplyUIAspectRatio();
	void NotifyOnAbilityActivated(class UGameplayAbility* GameplayAbility);
	void NotifyOnAbilityEnded(class UGameplayAbility* GameplayAbility);
	void OnAbilityActivated(class UGzGameplayAbility* GameplayAbility);
	void OnAbilityEnded(class UGzGameplayAbility* GameplayAbility);
	void OnViewTargetChanged();
	void ReceiveBindEvents(class APawn* NewViewTarget);
	void ReceiveUnbindEvents(class APawn* OldViewTarget);
	void SubscribeToAttributeChange(const struct FGameplayAttribute& Attribute, TDelegate<void(float NewValue, float OldValue)> OnAttributeChanged);
	void SubscribeToTagChange(const struct FGameplayTag& Tag, TDelegate<void(bool bWasAdded)> OnTagChanged);

	bool IsSpectating() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzHUDView">();
	}
	static class UGzHUDView* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzHUDView>();
	}
};
static_assert(alignof(UGzHUDView) == 0x000008, "Wrong alignment on UGzHUDView");
static_assert(sizeof(UGzHUDView) == 0x000410, "Wrong size on UGzHUDView");
static_assert(offsetof(UGzHUDView, ViewTarget) == 0x0002E0, "Member 'UGzHUDView::ViewTarget' has a wrong offset!");
static_assert(offsetof(UGzHUDView, AbilityWidgetsContainer) == 0x0002E8, "Member 'UGzHUDView::AbilityWidgetsContainer' has a wrong offset!");
static_assert(offsetof(UGzHUDView, CurveRetainerBox) == 0x0002F0, "Member 'UGzHUDView::CurveRetainerBox' has a wrong offset!");
static_assert(offsetof(UGzHUDView, ViewportMarkerContainer) == 0x0002F8, "Member 'UGzHUDView::ViewportMarkerContainer' has a wrong offset!");
static_assert(offsetof(UGzHUDView, LeftAspectRatioSpacer) == 0x000300, "Member 'UGzHUDView::LeftAspectRatioSpacer' has a wrong offset!");
static_assert(offsetof(UGzHUDView, RightAspectRatioSpacer) == 0x000308, "Member 'UGzHUDView::RightAspectRatioSpacer' has a wrong offset!");
static_assert(offsetof(UGzHUDView, Widgets) == 0x000310, "Member 'UGzHUDView::Widgets' has a wrong offset!");
static_assert(offsetof(UGzHUDView, ActiveAbilitiesWidgets) == 0x000320, "Member 'UGzHUDView::ActiveAbilitiesWidgets' has a wrong offset!");
static_assert(offsetof(UGzHUDView, AttributeChangedEvents) == 0x000370, "Member 'UGzHUDView::AttributeChangedEvents' has a wrong offset!");
static_assert(offsetof(UGzHUDView, TagChangedEvents) == 0x0003C0, "Member 'UGzHUDView::TagChangedEvents' has a wrong offset!");

// Class G01.GzClientDiscoverySettings
// 0x0010 (0x0048 - 0x0038)
class UGzClientDiscoverySettings final : public UDeveloperSettings
{
public:
	class FString                                 DiscoveryUrl;                                      // 0x0038(0x0010)(ZeroConstructor, Config, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzClientDiscoverySettings">();
	}
	static class UGzClientDiscoverySettings* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzClientDiscoverySettings>();
	}
};
static_assert(alignof(UGzClientDiscoverySettings) == 0x000008, "Wrong alignment on UGzClientDiscoverySettings");
static_assert(sizeof(UGzClientDiscoverySettings) == 0x000048, "Wrong size on UGzClientDiscoverySettings");
static_assert(offsetof(UGzClientDiscoverySettings, DiscoveryUrl) == 0x000038, "Member 'UGzClientDiscoverySettings::DiscoveryUrl' has a wrong offset!");

// Class G01.GzGA_SuperSprint
// 0x00E8 (0x0760 - 0x0678)
class UGzGA_SuperSprint : public UGzGA_BaseLimbAbility
{
public:
	TSoftClassPtr<class UClass>                   MovementSpeedEffectClass;                          // 0x0678(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         SprintAccelerationOverride;                        // 0x06A0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bUseMontage;                                       // 0x06A4(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_30DC[0x3];                                     // 0x06A5(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftObjectPtr<class UAnimMontage>            SprintLoopMontage;                                 // 0x06A8(0x0028)(Edit, DisableEditOnInstance, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftClassPtr<class UClass>                   TrailActor;                                        // 0x06D0(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FGameplayTag                           SuperSprintSprintCameraTag;                        // 0x06F8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         SprintCameraEndDelaySeconds;                       // 0x0700(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FGameplayTag                           SprintCameraBlockingTag;                           // 0x0704(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_30DD[0x4];                                     // 0x070C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UGzSuperSprintComponent*                SuperSprintComponent;                              // 0x0710(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UGzBodyPartAbilityData_SuperSprintLegs* SuperSprintAbilityData;                            // 0x0718(0x0008)(ZeroConstructor, Transient, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FActiveGameplayEffectHandle            SpeedEffectHandle;                                 // 0x0720(0x0008)(Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UAbilityTask_WaitDelay*                 WaitEndSprintCamera;                               // 0x0728(0x0008)(ZeroConstructor, Transient, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UAbilityTask_WaitGameplayTagAdded*      WaitSprintCameraBlockTagAddedTask;                 // 0x0730(0x0008)(ZeroConstructor, Transient, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UGzAT_SuperSprintTrailSpawner*          TrailSpawnerTask;                                  // 0x0738(0x0008)(ZeroConstructor, Transient, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UGzAT_PlayMontageAndWaitForEvent*       SprintMontageTask;                                 // 0x0740(0x0008)(ZeroConstructor, Transient, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_30DE[0x18];                                    // 0x0748(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void BP_OnStartedSprint();
	void BP_OnStoppedSprint();
	void EndSprintCamera();
	void OnAssetsLoaded();
	void OnMovementModeChanged(class ACharacter* Character, EMovementMode PrevMovementMode, uint8 PreviousCustomMode);
	void OnSprintCameraDelayEnd();
	void OnSuperSprintConditionChanged(bool bCanSuperSprint);
	void OnSuperSprintDurationFinished();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzGA_SuperSprint">();
	}
	static class UGzGA_SuperSprint* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzGA_SuperSprint>();
	}
};
static_assert(alignof(UGzGA_SuperSprint) == 0x000008, "Wrong alignment on UGzGA_SuperSprint");
static_assert(sizeof(UGzGA_SuperSprint) == 0x000760, "Wrong size on UGzGA_SuperSprint");
static_assert(offsetof(UGzGA_SuperSprint, MovementSpeedEffectClass) == 0x000678, "Member 'UGzGA_SuperSprint::MovementSpeedEffectClass' has a wrong offset!");
static_assert(offsetof(UGzGA_SuperSprint, SprintAccelerationOverride) == 0x0006A0, "Member 'UGzGA_SuperSprint::SprintAccelerationOverride' has a wrong offset!");
static_assert(offsetof(UGzGA_SuperSprint, bUseMontage) == 0x0006A4, "Member 'UGzGA_SuperSprint::bUseMontage' has a wrong offset!");
static_assert(offsetof(UGzGA_SuperSprint, SprintLoopMontage) == 0x0006A8, "Member 'UGzGA_SuperSprint::SprintLoopMontage' has a wrong offset!");
static_assert(offsetof(UGzGA_SuperSprint, TrailActor) == 0x0006D0, "Member 'UGzGA_SuperSprint::TrailActor' has a wrong offset!");
static_assert(offsetof(UGzGA_SuperSprint, SuperSprintSprintCameraTag) == 0x0006F8, "Member 'UGzGA_SuperSprint::SuperSprintSprintCameraTag' has a wrong offset!");
static_assert(offsetof(UGzGA_SuperSprint, SprintCameraEndDelaySeconds) == 0x000700, "Member 'UGzGA_SuperSprint::SprintCameraEndDelaySeconds' has a wrong offset!");
static_assert(offsetof(UGzGA_SuperSprint, SprintCameraBlockingTag) == 0x000704, "Member 'UGzGA_SuperSprint::SprintCameraBlockingTag' has a wrong offset!");
static_assert(offsetof(UGzGA_SuperSprint, SuperSprintComponent) == 0x000710, "Member 'UGzGA_SuperSprint::SuperSprintComponent' has a wrong offset!");
static_assert(offsetof(UGzGA_SuperSprint, SuperSprintAbilityData) == 0x000718, "Member 'UGzGA_SuperSprint::SuperSprintAbilityData' has a wrong offset!");
static_assert(offsetof(UGzGA_SuperSprint, SpeedEffectHandle) == 0x000720, "Member 'UGzGA_SuperSprint::SpeedEffectHandle' has a wrong offset!");
static_assert(offsetof(UGzGA_SuperSprint, WaitEndSprintCamera) == 0x000728, "Member 'UGzGA_SuperSprint::WaitEndSprintCamera' has a wrong offset!");
static_assert(offsetof(UGzGA_SuperSprint, WaitSprintCameraBlockTagAddedTask) == 0x000730, "Member 'UGzGA_SuperSprint::WaitSprintCameraBlockTagAddedTask' has a wrong offset!");
static_assert(offsetof(UGzGA_SuperSprint, TrailSpawnerTask) == 0x000738, "Member 'UGzGA_SuperSprint::TrailSpawnerTask' has a wrong offset!");
static_assert(offsetof(UGzGA_SuperSprint, SprintMontageTask) == 0x000740, "Member 'UGzGA_SuperSprint::SprintMontageTask' has a wrong offset!");

// Class G01.GzViewportMarkerWidget
// 0x0060 (0x0398 - 0x0338)
class UGzViewportMarkerWidget : public UGzMarkerWidget
{
public:
	FMulticastInlineDelegateProperty_             OnMarkerOffscreenChanged;                          // 0x0338(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	struct FVector2D                              Alignment;                                         // 0x0348(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UWidget*                                ArrowDirection;                                    // 0x0358(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidget*                                InputTooltip;                                      // 0x0360(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidget*                                TeamFeedback;                                      // 0x0368(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCurveFloat*                            ScaleCurveFromDistance;                            // 0x0370(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         MarkerScreenVisibility;                            // 0x0378(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ClampCirclesRadius;                                // 0x037C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector2D                              ClampCirclesOffsetFromCenter;                      // 0x0380(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bCenterToLocation;                                 // 0x0390(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bNeedsDistanceUpdated;                             // 0x0391(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bInFocus;                                          // 0x0392(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsOffScreen;                                      // 0x0393(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_30E0[0x4];                                     // 0x0394(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	float GetArrowRotationAngle();
	void OnMarkerFocusChanged(bool bIsFocused);
	void OnMarkerFocusChangedBP(bool bIsFocused);
	void RotateArrow();
	void UpdateDistanceToViewTarget(float Distance);
	void UpdateInputTooltip();

	float GetDistanceToTarget() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzViewportMarkerWidget">();
	}
	static class UGzViewportMarkerWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzViewportMarkerWidget>();
	}
};
static_assert(alignof(UGzViewportMarkerWidget) == 0x000008, "Wrong alignment on UGzViewportMarkerWidget");
static_assert(sizeof(UGzViewportMarkerWidget) == 0x000398, "Wrong size on UGzViewportMarkerWidget");
static_assert(offsetof(UGzViewportMarkerWidget, OnMarkerOffscreenChanged) == 0x000338, "Member 'UGzViewportMarkerWidget::OnMarkerOffscreenChanged' has a wrong offset!");
static_assert(offsetof(UGzViewportMarkerWidget, Alignment) == 0x000348, "Member 'UGzViewportMarkerWidget::Alignment' has a wrong offset!");
static_assert(offsetof(UGzViewportMarkerWidget, ArrowDirection) == 0x000358, "Member 'UGzViewportMarkerWidget::ArrowDirection' has a wrong offset!");
static_assert(offsetof(UGzViewportMarkerWidget, InputTooltip) == 0x000360, "Member 'UGzViewportMarkerWidget::InputTooltip' has a wrong offset!");
static_assert(offsetof(UGzViewportMarkerWidget, TeamFeedback) == 0x000368, "Member 'UGzViewportMarkerWidget::TeamFeedback' has a wrong offset!");
static_assert(offsetof(UGzViewportMarkerWidget, ScaleCurveFromDistance) == 0x000370, "Member 'UGzViewportMarkerWidget::ScaleCurveFromDistance' has a wrong offset!");
static_assert(offsetof(UGzViewportMarkerWidget, MarkerScreenVisibility) == 0x000378, "Member 'UGzViewportMarkerWidget::MarkerScreenVisibility' has a wrong offset!");
static_assert(offsetof(UGzViewportMarkerWidget, ClampCirclesRadius) == 0x00037C, "Member 'UGzViewportMarkerWidget::ClampCirclesRadius' has a wrong offset!");
static_assert(offsetof(UGzViewportMarkerWidget, ClampCirclesOffsetFromCenter) == 0x000380, "Member 'UGzViewportMarkerWidget::ClampCirclesOffsetFromCenter' has a wrong offset!");
static_assert(offsetof(UGzViewportMarkerWidget, bCenterToLocation) == 0x000390, "Member 'UGzViewportMarkerWidget::bCenterToLocation' has a wrong offset!");
static_assert(offsetof(UGzViewportMarkerWidget, bNeedsDistanceUpdated) == 0x000391, "Member 'UGzViewportMarkerWidget::bNeedsDistanceUpdated' has a wrong offset!");
static_assert(offsetof(UGzViewportMarkerWidget, bInFocus) == 0x000392, "Member 'UGzViewportMarkerWidget::bInFocus' has a wrong offset!");
static_assert(offsetof(UGzViewportMarkerWidget, bIsOffScreen) == 0x000393, "Member 'UGzViewportMarkerWidget::bIsOffScreen' has a wrong offset!");

// Class G01.GzDamageableObjectMarkerWidget
// 0x0018 (0x03B0 - 0x0398)
class UGzDamageableObjectMarkerWidget : public UGzViewportMarkerWidget
{
public:
	float                                         HideMarkerDelay;                                   // 0x0398(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_30E1[0x14];                                    // 0x039C(0x0014)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzDamageableObjectMarkerWidget">();
	}
	static class UGzDamageableObjectMarkerWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzDamageableObjectMarkerWidget>();
	}
};
static_assert(alignof(UGzDamageableObjectMarkerWidget) == 0x000008, "Wrong alignment on UGzDamageableObjectMarkerWidget");
static_assert(sizeof(UGzDamageableObjectMarkerWidget) == 0x0003B0, "Wrong size on UGzDamageableObjectMarkerWidget");
static_assert(offsetof(UGzDamageableObjectMarkerWidget, HideMarkerDelay) == 0x000398, "Member 'UGzDamageableObjectMarkerWidget::HideMarkerDelay' has a wrong offset!");

// Class G01.GzZoneEvent
// 0x0040 (0x0068 - 0x0028)
class UGzZoneEvent final : public UObject
{
public:
	struct FFloatRange                            TriggerPeriod;                                     // 0x0028(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         TriggerDelayCircleLengthScale;                     // 0x0038(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FFloatRange                            DistanceFromZoneBorder;                            // 0x003C(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FFloatRange                            SpawnHeight;                                       // 0x004C(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         MinDistanceFromPlayer;                             // 0x005C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_30E2[0x8];                                     // 0x0060(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Trigger(const struct FTransform& Transform);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzZoneEvent">();
	}
	static class UGzZoneEvent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzZoneEvent>();
	}
};
static_assert(alignof(UGzZoneEvent) == 0x000008, "Wrong alignment on UGzZoneEvent");
static_assert(sizeof(UGzZoneEvent) == 0x000068, "Wrong size on UGzZoneEvent");
static_assert(offsetof(UGzZoneEvent, TriggerPeriod) == 0x000028, "Member 'UGzZoneEvent::TriggerPeriod' has a wrong offset!");
static_assert(offsetof(UGzZoneEvent, TriggerDelayCircleLengthScale) == 0x000038, "Member 'UGzZoneEvent::TriggerDelayCircleLengthScale' has a wrong offset!");
static_assert(offsetof(UGzZoneEvent, DistanceFromZoneBorder) == 0x00003C, "Member 'UGzZoneEvent::DistanceFromZoneBorder' has a wrong offset!");
static_assert(offsetof(UGzZoneEvent, SpawnHeight) == 0x00004C, "Member 'UGzZoneEvent::SpawnHeight' has a wrong offset!");
static_assert(offsetof(UGzZoneEvent, MinDistanceFromPlayer) == 0x00005C, "Member 'UGzZoneEvent::MinDistanceFromPlayer' has a wrong offset!");

// Class G01.GzClientExtraFeaturesService
// 0x0000 (0x00A0 - 0x00A0)
class UGzClientExtraFeaturesService final : public UGzClientPFObject
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzClientExtraFeaturesService">();
	}
	static class UGzClientExtraFeaturesService* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzClientExtraFeaturesService>();
	}
};
static_assert(alignof(UGzClientExtraFeaturesService) == 0x000008, "Wrong alignment on UGzClientExtraFeaturesService");
static_assert(sizeof(UGzClientExtraFeaturesService) == 0x0000A0, "Wrong size on UGzClientExtraFeaturesService");

// Class G01.GzClientLiveFeaturesFacade
// 0x0000 (0x0030 - 0x0030)
class UGzClientLiveFeaturesFacade final : public UGzFacade
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzClientLiveFeaturesFacade">();
	}
	static class UGzClientLiveFeaturesFacade* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzClientLiveFeaturesFacade>();
	}
};
static_assert(alignof(UGzClientLiveFeaturesFacade) == 0x000008, "Wrong alignment on UGzClientLiveFeaturesFacade");
static_assert(sizeof(UGzClientLiveFeaturesFacade) == 0x000030, "Wrong size on UGzClientLiveFeaturesFacade");

// Class G01.GzDamageIndicatorSettings
// 0x0060 (0x0088 - 0x0028)
class UGzDamageIndicatorSettings : public UObject
{
public:
	struct FColor                                 BodyDamageColor;                                   // 0x0028(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FColor                                 LimbDamageColor;                                   // 0x002C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FColor                                 ArmorDamageColor;                                  // 0x0030(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FColor                                 BodyCritDamageColor;                               // 0x0034(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FColor                                 LimbCritDamageColor;                               // 0x0038(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FColor                                 ArmorCritDamageColor;                              // 0x003C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TimeToDisplayDamageIndicator;                      // 0x0040(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TimeToDisplayCritDamageIndicator;                  // 0x0044(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TimeToDisplayDirectionlessDamageIndicator;         // 0x0048(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TimeAfterIndicatorStartDissapear;                  // 0x004C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DamageIndicatorWidgetSize;                         // 0x0050(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DirectionlessDamageIndicatorWidgetSize;            // 0x0054(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CritDamageIndicatorWidgetSize;                     // 0x0058(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DamageIndicatorMinIntensity;                       // 0x005C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DamageIndicatorMaxIntensity;                       // 0x0060(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DefaultDamageIndicatorIntensity;                   // 0x0064(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DirectionlessDamageIndicatorIntensity;             // 0x0068(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CritDamageIndicatorIntensity;                      // 0x006C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DamageIndicatorMinSize;                            // 0x0070(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DamageIndicatorMaxSize;                            // 0x0074(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         StartSizeIndicatorModifier;                        // 0x0078(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DisappearingSpeedModifier;                         // 0x007C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ShrinkingSpeedModifier;                            // 0x0080(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_30E3[0x4];                                     // 0x0084(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UGzDamageIndicatorSettings* GetDamageIndicatorSettings();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzDamageIndicatorSettings">();
	}
	static class UGzDamageIndicatorSettings* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzDamageIndicatorSettings>();
	}
};
static_assert(alignof(UGzDamageIndicatorSettings) == 0x000008, "Wrong alignment on UGzDamageIndicatorSettings");
static_assert(sizeof(UGzDamageIndicatorSettings) == 0x000088, "Wrong size on UGzDamageIndicatorSettings");
static_assert(offsetof(UGzDamageIndicatorSettings, BodyDamageColor) == 0x000028, "Member 'UGzDamageIndicatorSettings::BodyDamageColor' has a wrong offset!");
static_assert(offsetof(UGzDamageIndicatorSettings, LimbDamageColor) == 0x00002C, "Member 'UGzDamageIndicatorSettings::LimbDamageColor' has a wrong offset!");
static_assert(offsetof(UGzDamageIndicatorSettings, ArmorDamageColor) == 0x000030, "Member 'UGzDamageIndicatorSettings::ArmorDamageColor' has a wrong offset!");
static_assert(offsetof(UGzDamageIndicatorSettings, BodyCritDamageColor) == 0x000034, "Member 'UGzDamageIndicatorSettings::BodyCritDamageColor' has a wrong offset!");
static_assert(offsetof(UGzDamageIndicatorSettings, LimbCritDamageColor) == 0x000038, "Member 'UGzDamageIndicatorSettings::LimbCritDamageColor' has a wrong offset!");
static_assert(offsetof(UGzDamageIndicatorSettings, ArmorCritDamageColor) == 0x00003C, "Member 'UGzDamageIndicatorSettings::ArmorCritDamageColor' has a wrong offset!");
static_assert(offsetof(UGzDamageIndicatorSettings, TimeToDisplayDamageIndicator) == 0x000040, "Member 'UGzDamageIndicatorSettings::TimeToDisplayDamageIndicator' has a wrong offset!");
static_assert(offsetof(UGzDamageIndicatorSettings, TimeToDisplayCritDamageIndicator) == 0x000044, "Member 'UGzDamageIndicatorSettings::TimeToDisplayCritDamageIndicator' has a wrong offset!");
static_assert(offsetof(UGzDamageIndicatorSettings, TimeToDisplayDirectionlessDamageIndicator) == 0x000048, "Member 'UGzDamageIndicatorSettings::TimeToDisplayDirectionlessDamageIndicator' has a wrong offset!");
static_assert(offsetof(UGzDamageIndicatorSettings, TimeAfterIndicatorStartDissapear) == 0x00004C, "Member 'UGzDamageIndicatorSettings::TimeAfterIndicatorStartDissapear' has a wrong offset!");
static_assert(offsetof(UGzDamageIndicatorSettings, DamageIndicatorWidgetSize) == 0x000050, "Member 'UGzDamageIndicatorSettings::DamageIndicatorWidgetSize' has a wrong offset!");
static_assert(offsetof(UGzDamageIndicatorSettings, DirectionlessDamageIndicatorWidgetSize) == 0x000054, "Member 'UGzDamageIndicatorSettings::DirectionlessDamageIndicatorWidgetSize' has a wrong offset!");
static_assert(offsetof(UGzDamageIndicatorSettings, CritDamageIndicatorWidgetSize) == 0x000058, "Member 'UGzDamageIndicatorSettings::CritDamageIndicatorWidgetSize' has a wrong offset!");
static_assert(offsetof(UGzDamageIndicatorSettings, DamageIndicatorMinIntensity) == 0x00005C, "Member 'UGzDamageIndicatorSettings::DamageIndicatorMinIntensity' has a wrong offset!");
static_assert(offsetof(UGzDamageIndicatorSettings, DamageIndicatorMaxIntensity) == 0x000060, "Member 'UGzDamageIndicatorSettings::DamageIndicatorMaxIntensity' has a wrong offset!");
static_assert(offsetof(UGzDamageIndicatorSettings, DefaultDamageIndicatorIntensity) == 0x000064, "Member 'UGzDamageIndicatorSettings::DefaultDamageIndicatorIntensity' has a wrong offset!");
static_assert(offsetof(UGzDamageIndicatorSettings, DirectionlessDamageIndicatorIntensity) == 0x000068, "Member 'UGzDamageIndicatorSettings::DirectionlessDamageIndicatorIntensity' has a wrong offset!");
static_assert(offsetof(UGzDamageIndicatorSettings, CritDamageIndicatorIntensity) == 0x00006C, "Member 'UGzDamageIndicatorSettings::CritDamageIndicatorIntensity' has a wrong offset!");
static_assert(offsetof(UGzDamageIndicatorSettings, DamageIndicatorMinSize) == 0x000070, "Member 'UGzDamageIndicatorSettings::DamageIndicatorMinSize' has a wrong offset!");
static_assert(offsetof(UGzDamageIndicatorSettings, DamageIndicatorMaxSize) == 0x000074, "Member 'UGzDamageIndicatorSettings::DamageIndicatorMaxSize' has a wrong offset!");
static_assert(offsetof(UGzDamageIndicatorSettings, StartSizeIndicatorModifier) == 0x000078, "Member 'UGzDamageIndicatorSettings::StartSizeIndicatorModifier' has a wrong offset!");
static_assert(offsetof(UGzDamageIndicatorSettings, DisappearingSpeedModifier) == 0x00007C, "Member 'UGzDamageIndicatorSettings::DisappearingSpeedModifier' has a wrong offset!");
static_assert(offsetof(UGzDamageIndicatorSettings, ShrinkingSpeedModifier) == 0x000080, "Member 'UGzDamageIndicatorSettings::ShrinkingSpeedModifier' has a wrong offset!");

// Class G01.GzClientLiveFeaturesService
// 0x0250 (0x02F0 - 0x00A0)
class UGzClientLiveFeaturesService final : public UGzClientPFObject
{
public:
	uint8                                         Pad_30E4[0x1C8];                                   // 0x00A0(0x01C8)(Fixing Size After Last Property [ Dumper-7 ])
	class UGzHiddenAssetsTrackerComponent*        HiddenAssetsTracker;                               // 0x0268(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_30E5[0x80];                                    // 0x0270(0x0080)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzClientLiveFeaturesService">();
	}
	static class UGzClientLiveFeaturesService* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzClientLiveFeaturesService>();
	}
};
static_assert(alignof(UGzClientLiveFeaturesService) == 0x000008, "Wrong alignment on UGzClientLiveFeaturesService");
static_assert(sizeof(UGzClientLiveFeaturesService) == 0x0002F0, "Wrong size on UGzClientLiveFeaturesService");
static_assert(offsetof(UGzClientLiveFeaturesService, HiddenAssetsTracker) == 0x000268, "Member 'UGzClientLiveFeaturesService::HiddenAssetsTracker' has a wrong offset!");

// Class G01.GzDamageableStaticMeshComponent
// 0x0010 (0x05F0 - 0x05E0)
class UGzDamageableStaticMeshComponent : public UStaticMeshComponent
{
public:
	class UGzDamageableStaticMeshData*            DamageableMeshConfig;                              // 0x05E0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UStaticMesh*                            OriginalMesh;                                      // 0x05E8(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzDamageableStaticMeshComponent">();
	}
	static class UGzDamageableStaticMeshComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzDamageableStaticMeshComponent>();
	}
};
static_assert(alignof(UGzDamageableStaticMeshComponent) == 0x000010, "Wrong alignment on UGzDamageableStaticMeshComponent");
static_assert(sizeof(UGzDamageableStaticMeshComponent) == 0x0005F0, "Wrong size on UGzDamageableStaticMeshComponent");
static_assert(offsetof(UGzDamageableStaticMeshComponent, DamageableMeshConfig) == 0x0005E0, "Member 'UGzDamageableStaticMeshComponent::DamageableMeshConfig' has a wrong offset!");
static_assert(offsetof(UGzDamageableStaticMeshComponent, OriginalMesh) == 0x0005E8, "Member 'UGzDamageableStaticMeshComponent::OriginalMesh' has a wrong offset!");

// Class G01.GzSyncCutscene
// 0x0068 (0x0308 - 0x02A0)
class AGzSyncCutscene : public AActor
{
public:
	TMap<int32, class ULevelSequence*>            PlayerCountSequenceMapping;                        // 0x02A0(0x0050)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	float                                         EndTime;                                           // 0x02F0(0x0004)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_30E6[0x4];                                     // 0x02F4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class ULevelSequencePlayer*                   SequencePlayer;                                    // 0x02F8(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class ALevelSequenceActor*                    SequenceActor;                                     // 0x0300(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void ResetViewTarget();
	void StartPlaying();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzSyncCutscene">();
	}
	static class AGzSyncCutscene* GetDefaultObj()
	{
		return GetDefaultObjImpl<AGzSyncCutscene>();
	}
};
static_assert(alignof(AGzSyncCutscene) == 0x000008, "Wrong alignment on AGzSyncCutscene");
static_assert(sizeof(AGzSyncCutscene) == 0x000308, "Wrong size on AGzSyncCutscene");
static_assert(offsetof(AGzSyncCutscene, PlayerCountSequenceMapping) == 0x0002A0, "Member 'AGzSyncCutscene::PlayerCountSequenceMapping' has a wrong offset!");
static_assert(offsetof(AGzSyncCutscene, EndTime) == 0x0002F0, "Member 'AGzSyncCutscene::EndTime' has a wrong offset!");
static_assert(offsetof(AGzSyncCutscene, SequencePlayer) == 0x0002F8, "Member 'AGzSyncCutscene::SequencePlayer' has a wrong offset!");
static_assert(offsetof(AGzSyncCutscene, SequenceActor) == 0x000300, "Member 'AGzSyncCutscene::SequenceActor' has a wrong offset!");

// Class G01.GzClientLoadoutService
// 0x01D0 (0x0270 - 0x00A0)
class UGzClientLoadoutService final : public UGzClientPFObject
{
public:
	uint8                                         Pad_30E7[0x78];                                    // 0x00A0(0x0078)(Fixing Size After Last Property [ Dumper-7 ])
	FMulticastInlineDelegateProperty_             OnLoadoutScreenOpened;                             // 0x0118(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnLoadoutScreenClosed;                             // 0x0128(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_30E8[0x138];                                   // 0x0138(0x0138)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void GzOnLoadoutScreenClosedEvent__DelegateSignature();
	void GzOnLoadoutScreenOpenedEvent__DelegateSignature();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzClientLoadoutService">();
	}
	static class UGzClientLoadoutService* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzClientLoadoutService>();
	}
};
static_assert(alignof(UGzClientLoadoutService) == 0x000008, "Wrong alignment on UGzClientLoadoutService");
static_assert(sizeof(UGzClientLoadoutService) == 0x000270, "Wrong size on UGzClientLoadoutService");
static_assert(offsetof(UGzClientLoadoutService, OnLoadoutScreenOpened) == 0x000118, "Member 'UGzClientLoadoutService::OnLoadoutScreenOpened' has a wrong offset!");
static_assert(offsetof(UGzClientLoadoutService, OnLoadoutScreenClosed) == 0x000128, "Member 'UGzClientLoadoutService::OnLoadoutScreenClosed' has a wrong offset!");

// Class G01.GzClientMissionService
// 0x0050 (0x00F0 - 0x00A0)
class UGzClientMissionService final : public UGzClientPFObject
{
public:
	uint8                                         Pad_30E9[0x30];                                    // 0x00A0(0x0030)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FGzMetaAvailableAssignment>     MetaAvailableAssignments;                          // 0x00D0(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	uint8                                         Pad_30EA[0x10];                                    // 0x00E0(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzClientMissionService">();
	}
	static class UGzClientMissionService* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzClientMissionService>();
	}
};
static_assert(alignof(UGzClientMissionService) == 0x000008, "Wrong alignment on UGzClientMissionService");
static_assert(sizeof(UGzClientMissionService) == 0x0000F0, "Wrong size on UGzClientMissionService");
static_assert(offsetof(UGzClientMissionService, MetaAvailableAssignments) == 0x0000D0, "Member 'UGzClientMissionService::MetaAvailableAssignments' has a wrong offset!");

// Class G01.GzShootStatCollectorJetPack
// 0x0000 (0x0038 - 0x0038)
class UGzShootStatCollectorJetPack final : public UGzShootHitStatCollector
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzShootStatCollectorJetPack">();
	}
	static class UGzShootStatCollectorJetPack* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzShootStatCollectorJetPack>();
	}
};
static_assert(alignof(UGzShootStatCollectorJetPack) == 0x000008, "Wrong alignment on UGzShootStatCollectorJetPack");
static_assert(sizeof(UGzShootStatCollectorJetPack) == 0x000038, "Wrong size on UGzShootStatCollectorJetPack");

// Class G01.GzDamageableCar
// 0x0030 (0x04F0 - 0x04C0)
class AGzDamageableCar : public AGzCarTrackTransport
{
public:
	uint8                                         Pad_30EB[0x10];                                    // 0x04C0(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bIsCombatRelevant;                                 // 0x04D0(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_30EC[0x7];                                     // 0x04D1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UGzAbilitySystemComponent*              AbilitySystemComponent;                            // 0x04D8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UGzAliveObjectAttributeSet*             AliveObjectAttributeSet;                           // 0x04E0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, Net, ZeroConstructor, InstancedReference, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_30ED[0x8];                                     // 0x04E8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnRep_AliveObjectAttributeSet();
	void ReceiveDamage(float Damage);
	void ReceiveHealthChanged(float NewHealth);
	void ReceiveOnDeath();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzDamageableCar">();
	}
	static class AGzDamageableCar* GetDefaultObj()
	{
		return GetDefaultObjImpl<AGzDamageableCar>();
	}
};
static_assert(alignof(AGzDamageableCar) == 0x000010, "Wrong alignment on AGzDamageableCar");
static_assert(sizeof(AGzDamageableCar) == 0x0004F0, "Wrong size on AGzDamageableCar");
static_assert(offsetof(AGzDamageableCar, bIsCombatRelevant) == 0x0004D0, "Member 'AGzDamageableCar::bIsCombatRelevant' has a wrong offset!");
static_assert(offsetof(AGzDamageableCar, AbilitySystemComponent) == 0x0004D8, "Member 'AGzDamageableCar::AbilitySystemComponent' has a wrong offset!");
static_assert(offsetof(AGzDamageableCar, AliveObjectAttributeSet) == 0x0004E0, "Member 'AGzDamageableCar::AliveObjectAttributeSet' has a wrong offset!");

// Class G01.GzClientPaymentService
// 0x0000 (0x00A0 - 0x00A0)
class UGzClientPaymentService final : public UGzClientPFObject
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzClientPaymentService">();
	}
	static class UGzClientPaymentService* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzClientPaymentService>();
	}
};
static_assert(alignof(UGzClientPaymentService) == 0x000008, "Wrong alignment on UGzClientPaymentService");
static_assert(sizeof(UGzClientPaymentService) == 0x0000A0, "Wrong size on UGzClientPaymentService");

// Class G01.GzSmokeMissile
// 0x0070 (0x03B8 - 0x0348)
class AGzSmokeMissile final : public AGzProjectileBase
{
public:
	TSoftClassPtr<class UClass>                   PropagationActorClass;                             // 0x0348(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAkAudioEvent*                          ShootAudioEvent;                                   // 0x0370(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAkAudioEvent*                          FlightAudioEvent;                                  // 0x0378(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAkAudioEvent*                          SmokeExplosionAudioEvent;                          // 0x0380(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UNiagaraSystem*                         InitialSmokeNiagaraSystem;                         // 0x0388(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ImpactNormalOffsetDistance;                        // 0x0390(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_30EE[0x4];                                     // 0x0394(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UGzBodyPartAbilityData_SmokeWall*       AbilityData;                                       // 0x0398(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_30EF[0x18];                                    // 0x03A0(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnProjectileStopped(const struct FHitResult& HitResult);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzSmokeMissile">();
	}
	static class AGzSmokeMissile* GetDefaultObj()
	{
		return GetDefaultObjImpl<AGzSmokeMissile>();
	}
};
static_assert(alignof(AGzSmokeMissile) == 0x000008, "Wrong alignment on AGzSmokeMissile");
static_assert(sizeof(AGzSmokeMissile) == 0x0003B8, "Wrong size on AGzSmokeMissile");
static_assert(offsetof(AGzSmokeMissile, PropagationActorClass) == 0x000348, "Member 'AGzSmokeMissile::PropagationActorClass' has a wrong offset!");
static_assert(offsetof(AGzSmokeMissile, ShootAudioEvent) == 0x000370, "Member 'AGzSmokeMissile::ShootAudioEvent' has a wrong offset!");
static_assert(offsetof(AGzSmokeMissile, FlightAudioEvent) == 0x000378, "Member 'AGzSmokeMissile::FlightAudioEvent' has a wrong offset!");
static_assert(offsetof(AGzSmokeMissile, SmokeExplosionAudioEvent) == 0x000380, "Member 'AGzSmokeMissile::SmokeExplosionAudioEvent' has a wrong offset!");
static_assert(offsetof(AGzSmokeMissile, InitialSmokeNiagaraSystem) == 0x000388, "Member 'AGzSmokeMissile::InitialSmokeNiagaraSystem' has a wrong offset!");
static_assert(offsetof(AGzSmokeMissile, ImpactNormalOffsetDistance) == 0x000390, "Member 'AGzSmokeMissile::ImpactNormalOffsetDistance' has a wrong offset!");
static_assert(offsetof(AGzSmokeMissile, AbilityData) == 0x000398, "Member 'AGzSmokeMissile::AbilityData' has a wrong offset!");

// Class G01.GzDamageIndicator
// 0x0058 (0x0338 - 0x02E0)
class UGzDamageIndicator : public UUserWidget
{
public:
	struct FGzDamageDirectionData                 DamageData;                                        // 0x02E0(0x0030)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, Protected, NativeAccessSpecifierProtected)
	float                                         DirectionAngle;                                    // 0x0310(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bUseDamagerLocation;                               // 0x0314(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_30F0[0x3];                                     // 0x0315(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class APawn*                                  ViewTarget;                                        // 0x0318(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_30F1[0x18];                                    // 0x0320(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void DestroyIndicator();
	void OnDirectionAngleChanged(float NewDirectionAngle);
	void OnInit();
	void OnRepeat();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzDamageIndicator">();
	}
	static class UGzDamageIndicator* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzDamageIndicator>();
	}
};
static_assert(alignof(UGzDamageIndicator) == 0x000008, "Wrong alignment on UGzDamageIndicator");
static_assert(sizeof(UGzDamageIndicator) == 0x000338, "Wrong size on UGzDamageIndicator");
static_assert(offsetof(UGzDamageIndicator, DamageData) == 0x0002E0, "Member 'UGzDamageIndicator::DamageData' has a wrong offset!");
static_assert(offsetof(UGzDamageIndicator, DirectionAngle) == 0x000310, "Member 'UGzDamageIndicator::DirectionAngle' has a wrong offset!");
static_assert(offsetof(UGzDamageIndicator, bUseDamagerLocation) == 0x000314, "Member 'UGzDamageIndicator::bUseDamagerLocation' has a wrong offset!");
static_assert(offsetof(UGzDamageIndicator, ViewTarget) == 0x000318, "Member 'UGzDamageIndicator::ViewTarget' has a wrong offset!");

// Class G01.GzClientPlayerInventoryService
// 0x0120 (0x01C0 - 0x00A0)
class UGzClientPlayerInventoryService final : public UGzClientPFObject
{
public:
	uint8                                         Pad_30F2[0x30];                                    // 0x00A0(0x0030)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGzOnlineInventoryItemsCollection      Inventory;                                         // 0x00D0(0x0068)(NativeAccessSpecifierPrivate)
	uint8                                         Pad_30F3[0x88];                                    // 0x0138(0x0088)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzClientPlayerInventoryService">();
	}
	static class UGzClientPlayerInventoryService* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzClientPlayerInventoryService>();
	}
};
static_assert(alignof(UGzClientPlayerInventoryService) == 0x000008, "Wrong alignment on UGzClientPlayerInventoryService");
static_assert(sizeof(UGzClientPlayerInventoryService) == 0x0001C0, "Wrong size on UGzClientPlayerInventoryService");
static_assert(offsetof(UGzClientPlayerInventoryService, Inventory) == 0x0000D0, "Member 'UGzClientPlayerInventoryService::Inventory' has a wrong offset!");

// Class G01.GzWeaponSkinItemData
// 0x0168 (0x0480 - 0x0318)
class UGzWeaponSkinItemData final : public UGzSkinItemData
{
public:
	TMap<EGzWeaponAttachmentType, TSoftObjectPtr<class UMaterialInterface>> AttachmentsMaterialMap;                            // 0x0318(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, UObjectWrapper, NativeAccessSpecifierPublic)
	TMap<class UGzWeaponAttachmentItemData*, TSoftObjectPtr<class UMaterialInterface>> SpecificAttachmentItemsMaterialOverride;           // 0x0368(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, UObjectWrapper, NativeAccessSpecifierPublic)
	TMap<EGzWeaponAttachmentType, struct FGzItemSkinMaterials> AttachmentsMaterials;                              // 0x03B8(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, ContainsInstancedReference, NativeAccessSpecifierPublic)
	TMap<class UGzWeaponAttachmentItemData*, struct FGzItemSkinMaterials> SpecificAttachmentItemsMaterialsOverride;          // 0x0408(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, ContainsInstancedReference, NativeAccessSpecifierPublic)
	bool                                          bShouldUseUdim;                                    // 0x0458(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_30F4[0x7];                                     // 0x0459(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UGzWeaponUdimSkinData*                  SkinUdimDataBase;                                  // 0x0460(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UGzWeaponUdimSkinData*                  SkinUdimDataUniqueAtt;                             // 0x0468(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UGzWeaponUdimSkinData*                  SkinUdimDataMagazine;                              // 0x0470(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UGzWeaponUdimSkinData*                  SkinUdimDataGeneralAtt;                            // 0x0478(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	bool IsUdimDataValid() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzWeaponSkinItemData">();
	}
	static class UGzWeaponSkinItemData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzWeaponSkinItemData>();
	}
};
static_assert(alignof(UGzWeaponSkinItemData) == 0x000008, "Wrong alignment on UGzWeaponSkinItemData");
static_assert(sizeof(UGzWeaponSkinItemData) == 0x000480, "Wrong size on UGzWeaponSkinItemData");
static_assert(offsetof(UGzWeaponSkinItemData, AttachmentsMaterialMap) == 0x000318, "Member 'UGzWeaponSkinItemData::AttachmentsMaterialMap' has a wrong offset!");
static_assert(offsetof(UGzWeaponSkinItemData, SpecificAttachmentItemsMaterialOverride) == 0x000368, "Member 'UGzWeaponSkinItemData::SpecificAttachmentItemsMaterialOverride' has a wrong offset!");
static_assert(offsetof(UGzWeaponSkinItemData, AttachmentsMaterials) == 0x0003B8, "Member 'UGzWeaponSkinItemData::AttachmentsMaterials' has a wrong offset!");
static_assert(offsetof(UGzWeaponSkinItemData, SpecificAttachmentItemsMaterialsOverride) == 0x000408, "Member 'UGzWeaponSkinItemData::SpecificAttachmentItemsMaterialsOverride' has a wrong offset!");
static_assert(offsetof(UGzWeaponSkinItemData, bShouldUseUdim) == 0x000458, "Member 'UGzWeaponSkinItemData::bShouldUseUdim' has a wrong offset!");
static_assert(offsetof(UGzWeaponSkinItemData, SkinUdimDataBase) == 0x000460, "Member 'UGzWeaponSkinItemData::SkinUdimDataBase' has a wrong offset!");
static_assert(offsetof(UGzWeaponSkinItemData, SkinUdimDataUniqueAtt) == 0x000468, "Member 'UGzWeaponSkinItemData::SkinUdimDataUniqueAtt' has a wrong offset!");
static_assert(offsetof(UGzWeaponSkinItemData, SkinUdimDataMagazine) == 0x000470, "Member 'UGzWeaponSkinItemData::SkinUdimDataMagazine' has a wrong offset!");
static_assert(offsetof(UGzWeaponSkinItemData, SkinUdimDataGeneralAtt) == 0x000478, "Member 'UGzWeaponSkinItemData::SkinUdimDataGeneralAtt' has a wrong offset!");

// Class G01.GzClientServerTimeService
// 0x0068 (0x0108 - 0x00A0)
class UGzClientServerTimeService final : public UGzServiceComponent
{
public:
	uint8                                         Pad_30F5[0x68];                                    // 0x00A0(0x0068)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzClientServerTimeService">();
	}
	static class UGzClientServerTimeService* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzClientServerTimeService>();
	}
};
static_assert(alignof(UGzClientServerTimeService) == 0x000008, "Wrong alignment on UGzClientServerTimeService");
static_assert(sizeof(UGzClientServerTimeService) == 0x000108, "Wrong size on UGzClientServerTimeService");

// Class G01.GzGA_PhosphorousDart
// 0x0030 (0x07C0 - 0x0790)
class UGzGA_PhosphorousDart : public UGzGA_ChargeProjectile
{
public:
	TSoftObjectPtr<class UGzProjectileData>       PhosphorousDartData;                               // 0x0790(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_30F6[0x8];                                     // 0x07B8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void BP_OnMaxChargeVelocityReached();
	void BP_OnShoot();
	void OnChargeEnded();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzGA_PhosphorousDart">();
	}
	static class UGzGA_PhosphorousDart* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzGA_PhosphorousDart>();
	}
};
static_assert(alignof(UGzGA_PhosphorousDart) == 0x000010, "Wrong alignment on UGzGA_PhosphorousDart");
static_assert(sizeof(UGzGA_PhosphorousDart) == 0x0007C0, "Wrong size on UGzGA_PhosphorousDart");
static_assert(offsetof(UGzGA_PhosphorousDart, PhosphorousDartData) == 0x000790, "Member 'UGzGA_PhosphorousDart::PhosphorousDartData' has a wrong offset!");

// Class G01.GzDamageSource
// 0x0000 (0x0028 - 0x0028)
class IGzDamageSource final : public IInterface
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzDamageSource">();
	}
	static class IGzDamageSource* GetDefaultObj()
	{
		return GetDefaultObjImpl<IGzDamageSource>();
	}
};
static_assert(alignof(IGzDamageSource) == 0x000008, "Wrong alignment on IGzDamageSource");
static_assert(sizeof(IGzDamageSource) == 0x000028, "Wrong size on IGzDamageSource");

// Class G01.GzClientSharedLoadoutService
// 0x0050 (0x00F0 - 0x00A0)
class UGzClientSharedLoadoutService final : public UGzClientPFObject
{
public:
	uint8                                         Pad_30F7[0x50];                                    // 0x00A0(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzClientSharedLoadoutService">();
	}
	static class UGzClientSharedLoadoutService* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzClientSharedLoadoutService>();
	}
};
static_assert(alignof(UGzClientSharedLoadoutService) == 0x000008, "Wrong alignment on UGzClientSharedLoadoutService");
static_assert(sizeof(UGzClientSharedLoadoutService) == 0x0000F0, "Wrong size on UGzClientSharedLoadoutService");

// Class G01.GzClientSupportService
// 0x0008 (0x00A8 - 0x00A0)
class UGzClientSupportService final : public UGzClientPFObject
{
public:
	uint8                                         Pad_30F8[0x8];                                     // 0x00A0(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzClientSupportService">();
	}
	static class UGzClientSupportService* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzClientSupportService>();
	}
};
static_assert(alignof(UGzClientSupportService) == 0x000008, "Wrong alignment on UGzClientSupportService");
static_assert(sizeof(UGzClientSupportService) == 0x0000A8, "Wrong size on UGzClientSupportService");

// Class G01.GzSceneViewpoint
// 0x0000 (0x0A70 - 0x0A70)
class AGzSceneViewpoint : public ACineCameraActor
{
public:
	struct FGameplayTag                           SequenceTag;                                       // 0x0A68(0x0008)(Edit, DisableEditOnTemplate, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	void ReceiveTransitionFromStarted(const struct FGzTransitionEventParameters& Parameters);
	void ReceiveTransitionToStarted(const struct FGzTransitionEventParameters& Parameters);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzSceneViewpoint">();
	}
	static class AGzSceneViewpoint* GetDefaultObj()
	{
		return GetDefaultObjImpl<AGzSceneViewpoint>();
	}
};
static_assert(alignof(AGzSceneViewpoint) == 0x000010, "Wrong alignment on AGzSceneViewpoint");
static_assert(sizeof(AGzSceneViewpoint) == 0x000A70, "Wrong size on AGzSceneViewpoint");
static_assert(offsetof(AGzSceneViewpoint, SequenceTag) == 0x000A68, "Member 'AGzSceneViewpoint::SequenceTag' has a wrong offset!");

// Class G01.GzSpringArmSceneViewpoint
// 0x0010 (0x0A80 - 0x0A70)
class AGzSpringArmSceneViewpoint final : public AGzSceneViewpoint
{
public:
	class UStaticMeshComponent*                   StaticMeshComponent;                               // 0x0A70(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USpringArmComponent*                    SpringArmComponent;                                // 0x0A78(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzSpringArmSceneViewpoint">();
	}
	static class AGzSpringArmSceneViewpoint* GetDefaultObj()
	{
		return GetDefaultObjImpl<AGzSpringArmSceneViewpoint>();
	}
};
static_assert(alignof(AGzSpringArmSceneViewpoint) == 0x000010, "Wrong alignment on AGzSpringArmSceneViewpoint");
static_assert(sizeof(AGzSpringArmSceneViewpoint) == 0x000A80, "Wrong size on AGzSpringArmSceneViewpoint");
static_assert(offsetof(AGzSpringArmSceneViewpoint, StaticMeshComponent) == 0x000A70, "Member 'AGzSpringArmSceneViewpoint::StaticMeshComponent' has a wrong offset!");
static_assert(offsetof(AGzSpringArmSceneViewpoint, SpringArmComponent) == 0x000A78, "Member 'AGzSpringArmSceneViewpoint::SpringArmComponent' has a wrong offset!");

// Class G01.GzDamageFeedbackProvider
// 0x0000 (0x0028 - 0x0028)
class IGzDamageFeedbackProvider final : public IInterface
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzDamageFeedbackProvider">();
	}
	static class IGzDamageFeedbackProvider* GetDefaultObj()
	{
		return GetDefaultObjImpl<IGzDamageFeedbackProvider>();
	}
};
static_assert(alignof(IGzDamageFeedbackProvider) == 0x000008, "Wrong alignment on IGzDamageFeedbackProvider");
static_assert(sizeof(IGzDamageFeedbackProvider) == 0x000028, "Wrong size on IGzDamageFeedbackProvider");

// Class G01.GzTextStylesDataAsset
// 0x0050 (0x0080 - 0x0030)
class UGzTextStylesDataAsset final : public UDataAsset
{
public:
	TMap<struct FGameplayTag, TSubclassOf<class UCommonTextStyle>> TextStyles;                                        // 0x0030(0x0050)(Edit, Protected, UObjectWrapper, NativeAccessSpecifierProtected)

public:
	class UCommonTextStyle* GetTextStyle(const struct FGameplayTag& Tag) const;
	TSubclassOf<class UCommonTextStyle> GetTextStyleClass(const struct FGameplayTag& Tag) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzTextStylesDataAsset">();
	}
	static class UGzTextStylesDataAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzTextStylesDataAsset>();
	}
};
static_assert(alignof(UGzTextStylesDataAsset) == 0x000008, "Wrong alignment on UGzTextStylesDataAsset");
static_assert(sizeof(UGzTextStylesDataAsset) == 0x000080, "Wrong size on UGzTextStylesDataAsset");
static_assert(offsetof(UGzTextStylesDataAsset, TextStyles) == 0x000030, "Member 'UGzTextStylesDataAsset::TextStyles' has a wrong offset!");

// Class G01.GzClientWeaponConfigurationFacade
// 0x0000 (0x0030 - 0x0030)
class UGzClientWeaponConfigurationFacade final : public UGzFacade
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzClientWeaponConfigurationFacade">();
	}
	static class UGzClientWeaponConfigurationFacade* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzClientWeaponConfigurationFacade>();
	}
};
static_assert(alignof(UGzClientWeaponConfigurationFacade) == 0x000008, "Wrong alignment on UGzClientWeaponConfigurationFacade");
static_assert(sizeof(UGzClientWeaponConfigurationFacade) == 0x000030, "Wrong size on UGzClientWeaponConfigurationFacade");

// Class G01.GzMissionActivatable
// 0x0000 (0x0028 - 0x0028)
class IGzMissionActivatable final : public IInterface
{
public:
	void SetActive(bool bActive, class UMissionObjective* Objective);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzMissionActivatable">();
	}
	static class IGzMissionActivatable* GetDefaultObj()
	{
		return GetDefaultObjImpl<IGzMissionActivatable>();
	}
};
static_assert(alignof(IGzMissionActivatable) == 0x000008, "Wrong alignment on IGzMissionActivatable");
static_assert(sizeof(IGzMissionActivatable) == 0x000028, "Wrong size on IGzMissionActivatable");

// Class G01.GzMovementSoundNotifyState
// 0x0000 (0x0048 - 0x0048)
class UGzMovementSoundNotifyState final : public UGzSoundNotifyStateBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzMovementSoundNotifyState">();
	}
	static class UGzMovementSoundNotifyState* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzMovementSoundNotifyState>();
	}
};
static_assert(alignof(UGzMovementSoundNotifyState) == 0x000008, "Wrong alignment on UGzMovementSoundNotifyState");
static_assert(sizeof(UGzMovementSoundNotifyState) == 0x000048, "Wrong size on UGzMovementSoundNotifyState");

// Class G01.GzCloak_Gadget
// 0x00F0 (0x03F0 - 0x0300)
class alignas(0x10) AGzCloak_Gadget : public AGzDamageableActor
{
public:
	TSubclassOf<class UGameplayEffect>            MaxHPEffect;                                       // 0x0300(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           MaxHPTag;                                          // 0x0308(0x0008)(Edit, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         GadgetFieldRadiusCurrent;                          // 0x0310(0x0004)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_30FA[0x5C];                                    // 0x0314(0x005C)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UGzCloakComponent>          CloakComponentClass;                               // 0x0370(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UGzCloakComponent*                      CloakComponent;                                    // 0x0378(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_30FB[0x70];                                    // 0x0380(0x0070)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Init(class AGzMultiPartCharacter* GadgetOwningPlayer, const struct FGzCloak_Gadget_InitInfo& InInitInfo);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzCloak_Gadget">();
	}
	static class AGzCloak_Gadget* GetDefaultObj()
	{
		return GetDefaultObjImpl<AGzCloak_Gadget>();
	}
};
static_assert(alignof(AGzCloak_Gadget) == 0x000010, "Wrong alignment on AGzCloak_Gadget");
static_assert(sizeof(AGzCloak_Gadget) == 0x0003F0, "Wrong size on AGzCloak_Gadget");
static_assert(offsetof(AGzCloak_Gadget, MaxHPEffect) == 0x000300, "Member 'AGzCloak_Gadget::MaxHPEffect' has a wrong offset!");
static_assert(offsetof(AGzCloak_Gadget, MaxHPTag) == 0x000308, "Member 'AGzCloak_Gadget::MaxHPTag' has a wrong offset!");
static_assert(offsetof(AGzCloak_Gadget, GadgetFieldRadiusCurrent) == 0x000310, "Member 'AGzCloak_Gadget::GadgetFieldRadiusCurrent' has a wrong offset!");
static_assert(offsetof(AGzCloak_Gadget, CloakComponentClass) == 0x000370, "Member 'AGzCloak_Gadget::CloakComponentClass' has a wrong offset!");
static_assert(offsetof(AGzCloak_Gadget, CloakComponent) == 0x000378, "Member 'AGzCloak_Gadget::CloakComponent' has a wrong offset!");

// Class G01.GzCoinsBalancesUpdatedHandler
// 0x0000 (0x0048 - 0x0048)
class UGzCoinsBalancesUpdatedHandler final : public UGzSignalREvent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzCoinsBalancesUpdatedHandler">();
	}
	static class UGzCoinsBalancesUpdatedHandler* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzCoinsBalancesUpdatedHandler>();
	}
};
static_assert(alignof(UGzCoinsBalancesUpdatedHandler) == 0x000008, "Wrong alignment on UGzCoinsBalancesUpdatedHandler");
static_assert(sizeof(UGzCoinsBalancesUpdatedHandler) == 0x000048, "Wrong size on UGzCoinsBalancesUpdatedHandler");

// Class G01.GzWeaponRecoilProgressTask
// 0x0058 (0x0080 - 0x0028)
class UGzWeaponRecoilProgressTask final : public UObject
{
public:
	uint8                                         Pad_30FC[0x58];                                    // 0x0028(0x0058)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzWeaponRecoilProgressTask">();
	}
	static class UGzWeaponRecoilProgressTask* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzWeaponRecoilProgressTask>();
	}
};
static_assert(alignof(UGzWeaponRecoilProgressTask) == 0x000008, "Wrong alignment on UGzWeaponRecoilProgressTask");
static_assert(sizeof(UGzWeaponRecoilProgressTask) == 0x000080, "Wrong size on UGzWeaponRecoilProgressTask");

// Class G01.GzGA_Montage
// 0x0008 (0x0510 - 0x0508)
class UGzGA_Montage : public UGzGameplayAbility
{
public:
	class UAbilityTask_PlayMontageAndWait*        AbilityTaskPlayMontageAndWaitProxy;                // 0x0508(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void OnMontageCompleted();
	void OnMontageInterrupt();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzGA_Montage">();
	}
	static class UGzGA_Montage* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzGA_Montage>();
	}
};
static_assert(alignof(UGzGA_Montage) == 0x000008, "Wrong alignment on UGzGA_Montage");
static_assert(sizeof(UGzGA_Montage) == 0x000510, "Wrong size on UGzGA_Montage");
static_assert(offsetof(UGzGA_Montage, AbilityTaskPlayMontageAndWaitProxy) == 0x000508, "Member 'UGzGA_Montage::AbilityTaskPlayMontageAndWaitProxy' has a wrong offset!");

// Class G01.GzComebackArena
// 0x0098 (0x0338 - 0x02A0)
class AGzComebackArena final : public AActor
{
public:
	struct FVector2D                              ComebackArenaSize2D;                               // 0x02A0(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class AGzPlayerState*>                 Opponents;                                         // 0x02B0(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_30FD[0x68];                                    // 0x02C0(0x0068)(Fixing Size After Last Property [ Dumper-7 ])
	uint32                                        ComebackArenaMatchNumber;                          // 0x0328(0x0004)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_30FE[0xC];                                     // 0x032C(0x000C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AddComebackArenaStart(int32 TeamIndex, const struct FTransform& Transform);
	void WinComebackArenaMatch(class APawn* WinnerActor);

	int32 GetComebackArenaInstanceId() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzComebackArena">();
	}
	static class AGzComebackArena* GetDefaultObj()
	{
		return GetDefaultObjImpl<AGzComebackArena>();
	}
};
static_assert(alignof(AGzComebackArena) == 0x000008, "Wrong alignment on AGzComebackArena");
static_assert(sizeof(AGzComebackArena) == 0x000338, "Wrong size on AGzComebackArena");
static_assert(offsetof(AGzComebackArena, ComebackArenaSize2D) == 0x0002A0, "Member 'AGzComebackArena::ComebackArenaSize2D' has a wrong offset!");
static_assert(offsetof(AGzComebackArena, Opponents) == 0x0002B0, "Member 'AGzComebackArena::Opponents' has a wrong offset!");
static_assert(offsetof(AGzComebackArena, ComebackArenaMatchNumber) == 0x000328, "Member 'AGzComebackArena::ComebackArenaMatchNumber' has a wrong offset!");

// Class G01.GzComebackArenaContextComponent
// 0x0010 (0x00B8 - 0x00A8)
class UGzComebackArenaContextComponent final : public UActorComponent
{
public:
	class AGzComebackArena*                       ComebackArena;                                     // 0x00A8(0x0008)(Net, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         ComebackArenaEndTime;                              // 0x00B0(0x0004)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         ComebackArenaQueueEnteredTime;                     // 0x00B4(0x0004)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	class AGzComebackArena* GetComebackArena() const;
	float GetComebackArenaEndTime() const;
	float GetComebackArenaQueueEnteredTime() const;
	bool IsValidContext() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzComebackArenaContextComponent">();
	}
	static class UGzComebackArenaContextComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzComebackArenaContextComponent>();
	}
};
static_assert(alignof(UGzComebackArenaContextComponent) == 0x000008, "Wrong alignment on UGzComebackArenaContextComponent");
static_assert(sizeof(UGzComebackArenaContextComponent) == 0x0000B8, "Wrong size on UGzComebackArenaContextComponent");
static_assert(offsetof(UGzComebackArenaContextComponent, ComebackArena) == 0x0000A8, "Member 'UGzComebackArenaContextComponent::ComebackArena' has a wrong offset!");
static_assert(offsetof(UGzComebackArenaContextComponent, ComebackArenaEndTime) == 0x0000B0, "Member 'UGzComebackArenaContextComponent::ComebackArenaEndTime' has a wrong offset!");
static_assert(offsetof(UGzComebackArenaContextComponent, ComebackArenaQueueEnteredTime) == 0x0000B4, "Member 'UGzComebackArenaContextComponent::ComebackArenaQueueEnteredTime' has a wrong offset!");

// Class G01.PSOWeaponsLogger
// 0x0010 (0x02B0 - 0x02A0)
class APSOWeaponsLogger final : public AActor
{
public:
	TArray<class UNiagaraSystem*>                 FXs;                                               // 0x02A0(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)

public:
	bool IsReady();
	void StartWeaponEnumeration();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PSOWeaponsLogger">();
	}
	static class APSOWeaponsLogger* GetDefaultObj()
	{
		return GetDefaultObjImpl<APSOWeaponsLogger>();
	}
};
static_assert(alignof(APSOWeaponsLogger) == 0x000008, "Wrong alignment on APSOWeaponsLogger");
static_assert(sizeof(APSOWeaponsLogger) == 0x0002B0, "Wrong size on APSOWeaponsLogger");
static_assert(offsetof(APSOWeaponsLogger, FXs) == 0x0002A0, "Member 'APSOWeaponsLogger::FXs' has a wrong offset!");

// Class G01.GzComebackArenaManager
// 0x00A8 (0x0348 - 0x02A0)
class AGzComebackArenaManager final : public AGzGameModeSubsystem
{
public:
	float                                         SpawnHeight;                                       // 0x02A0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FGzSoundStateKey                       SpawnInComebackArenaSoundState;                    // 0x02A4(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FGzSoundStateKey                       RedeploySoundState;                                // 0x02AC(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, Protected, NativeAccessSpecifierProtected)
	float                                         ComebackArenaSpawnPadding;                         // 0x02B4(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         ColumnsCount;                                      // 0x02B8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_3100[0x4];                                     // 0x02BC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class AGzUnsafeArea>              UnsafeToSpawnActor;                                // 0x02C0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	double                                        RedeployInRadius;                                  // 0x02C8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         RedeploymentHeight;                                // 0x02D0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         MaxDistanceBetweenTeammates;                       // 0x02D4(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<struct FGzInvItem>                     DefaultRedeploymentItems;                          // 0x02D8(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	int32                                         NumberOfClipsForRedeploymentWeapon;                // 0x02E8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_3101[0x4];                                     // 0x02EC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class AGzComebackArena>           ComebackArenaClassToSpawn;                         // 0x02F0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         OpponentsSpawnDelay;                               // 0x02F8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         MatchDuration;                                     // 0x02FC(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<class AGzPlayerState*>                 PlayersQueue;                                      // 0x0300(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	TArray<class AGzComebackArena*>               ComebackArenas;                                    // 0x0310(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	TArray<class AGzUnsafeArea*>                  UnsafeAreas;                                       // 0x0320(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	uint8                                         Pad_3102[0x18];                                    // 0x0330(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnComebackArenaMatchEnded(class AGzComebackArena* ComebackArena);
	void OnPlayerDisconnected(class AGzPlayerController* PC, EGzPlayerLogoutReason LogoutReason);
	void SetIsActive(bool bNewActive);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzComebackArenaManager">();
	}
	static class AGzComebackArenaManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<AGzComebackArenaManager>();
	}
};
static_assert(alignof(AGzComebackArenaManager) == 0x000008, "Wrong alignment on AGzComebackArenaManager");
static_assert(sizeof(AGzComebackArenaManager) == 0x000348, "Wrong size on AGzComebackArenaManager");
static_assert(offsetof(AGzComebackArenaManager, SpawnHeight) == 0x0002A0, "Member 'AGzComebackArenaManager::SpawnHeight' has a wrong offset!");
static_assert(offsetof(AGzComebackArenaManager, SpawnInComebackArenaSoundState) == 0x0002A4, "Member 'AGzComebackArenaManager::SpawnInComebackArenaSoundState' has a wrong offset!");
static_assert(offsetof(AGzComebackArenaManager, RedeploySoundState) == 0x0002AC, "Member 'AGzComebackArenaManager::RedeploySoundState' has a wrong offset!");
static_assert(offsetof(AGzComebackArenaManager, ComebackArenaSpawnPadding) == 0x0002B4, "Member 'AGzComebackArenaManager::ComebackArenaSpawnPadding' has a wrong offset!");
static_assert(offsetof(AGzComebackArenaManager, ColumnsCount) == 0x0002B8, "Member 'AGzComebackArenaManager::ColumnsCount' has a wrong offset!");
static_assert(offsetof(AGzComebackArenaManager, UnsafeToSpawnActor) == 0x0002C0, "Member 'AGzComebackArenaManager::UnsafeToSpawnActor' has a wrong offset!");
static_assert(offsetof(AGzComebackArenaManager, RedeployInRadius) == 0x0002C8, "Member 'AGzComebackArenaManager::RedeployInRadius' has a wrong offset!");
static_assert(offsetof(AGzComebackArenaManager, RedeploymentHeight) == 0x0002D0, "Member 'AGzComebackArenaManager::RedeploymentHeight' has a wrong offset!");
static_assert(offsetof(AGzComebackArenaManager, MaxDistanceBetweenTeammates) == 0x0002D4, "Member 'AGzComebackArenaManager::MaxDistanceBetweenTeammates' has a wrong offset!");
static_assert(offsetof(AGzComebackArenaManager, DefaultRedeploymentItems) == 0x0002D8, "Member 'AGzComebackArenaManager::DefaultRedeploymentItems' has a wrong offset!");
static_assert(offsetof(AGzComebackArenaManager, NumberOfClipsForRedeploymentWeapon) == 0x0002E8, "Member 'AGzComebackArenaManager::NumberOfClipsForRedeploymentWeapon' has a wrong offset!");
static_assert(offsetof(AGzComebackArenaManager, ComebackArenaClassToSpawn) == 0x0002F0, "Member 'AGzComebackArenaManager::ComebackArenaClassToSpawn' has a wrong offset!");
static_assert(offsetof(AGzComebackArenaManager, OpponentsSpawnDelay) == 0x0002F8, "Member 'AGzComebackArenaManager::OpponentsSpawnDelay' has a wrong offset!");
static_assert(offsetof(AGzComebackArenaManager, MatchDuration) == 0x0002FC, "Member 'AGzComebackArenaManager::MatchDuration' has a wrong offset!");
static_assert(offsetof(AGzComebackArenaManager, PlayersQueue) == 0x000300, "Member 'AGzComebackArenaManager::PlayersQueue' has a wrong offset!");
static_assert(offsetof(AGzComebackArenaManager, ComebackArenas) == 0x000310, "Member 'AGzComebackArenaManager::ComebackArenas' has a wrong offset!");
static_assert(offsetof(AGzComebackArenaManager, UnsafeAreas) == 0x000320, "Member 'AGzComebackArenaManager::UnsafeAreas' has a wrong offset!");

// Class G01.GzCommandCenterTerminal
// 0x0000 (0x02F8 - 0x02F8)
class AGzCommandCenterTerminal final : public AGzBaseTerminal
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzCommandCenterTerminal">();
	}
	static class AGzCommandCenterTerminal* GetDefaultObj()
	{
		return GetDefaultObjImpl<AGzCommandCenterTerminal>();
	}
};
static_assert(alignof(AGzCommandCenterTerminal) == 0x000008, "Wrong alignment on AGzCommandCenterTerminal");
static_assert(sizeof(AGzCommandCenterTerminal) == 0x0002F8, "Wrong size on AGzCommandCenterTerminal");

// Class G01.GzCommandLineOptions
// 0x0000 (0x0028 - 0x0028)
class UGzCommandLineOptions final : public UBlueprintFunctionLibrary
{
public:
	static class FString GetBackendEnvName();
	static EGzClientMode GetCoherentApiTestClientMode();
	static bool GetCoherentApiTestParams(class FString* ApiTestArgs);
	static int32 GetCoherentApiTestPort();
	static class FString GetEpicAuthLogin();
	static class FString GetEpicAuthPassword();
	static class FString GetEpicAuthType();
	static class FString GetGameRegisterArgs();
	static EGzMatchmakingType GetMatchmakingType();
	static bool GetNoPlayfab();
	static class FString GetRegisterGameName();
	static bool HasEpicParams();
	static bool IsAllowJoiningUnexpectedPlayers();
	static bool IsRunningUnattended();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzCommandLineOptions">();
	}
	static class UGzCommandLineOptions* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzCommandLineOptions>();
	}
};
static_assert(alignof(UGzCommandLineOptions) == 0x000008, "Wrong alignment on UGzCommandLineOptions");
static_assert(sizeof(UGzCommandLineOptions) == 0x000028, "Wrong size on UGzCommandLineOptions");

// Class G01.GzToxicSmokeMissile
// 0x0050 (0x0398 - 0x0348)
class AGzToxicSmokeMissile : public AGzProjectileBase
{
public:
	TSubclassOf<class AGzPropagationActor>        PropagationActorClass;                             // 0x0348(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAkAudioEvent*                          ShootAudioEvent;                                   // 0x0350(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAkAudioEvent*                          FlightAudioEvent;                                  // 0x0358(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAkAudioEvent*                          SmokeExplosionAudioEvent;                          // 0x0360(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UNiagaraSystem*                         InitialSmokeNiagaraSystem;                         // 0x0368(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ImpactNormalOffsetDistance;                        // 0x0370(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3105[0x4];                                     // 0x0374(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UGzBodyPartAbilityData_ToxicSmoke*      AbilityData;                                       // 0x0378(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3106[0x18];                                    // 0x0380(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnProjectileStopped(const struct FHitResult& HitResult);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzToxicSmokeMissile">();
	}
	static class AGzToxicSmokeMissile* GetDefaultObj()
	{
		return GetDefaultObjImpl<AGzToxicSmokeMissile>();
	}
};
static_assert(alignof(AGzToxicSmokeMissile) == 0x000008, "Wrong alignment on AGzToxicSmokeMissile");
static_assert(sizeof(AGzToxicSmokeMissile) == 0x000398, "Wrong size on AGzToxicSmokeMissile");
static_assert(offsetof(AGzToxicSmokeMissile, PropagationActorClass) == 0x000348, "Member 'AGzToxicSmokeMissile::PropagationActorClass' has a wrong offset!");
static_assert(offsetof(AGzToxicSmokeMissile, ShootAudioEvent) == 0x000350, "Member 'AGzToxicSmokeMissile::ShootAudioEvent' has a wrong offset!");
static_assert(offsetof(AGzToxicSmokeMissile, FlightAudioEvent) == 0x000358, "Member 'AGzToxicSmokeMissile::FlightAudioEvent' has a wrong offset!");
static_assert(offsetof(AGzToxicSmokeMissile, SmokeExplosionAudioEvent) == 0x000360, "Member 'AGzToxicSmokeMissile::SmokeExplosionAudioEvent' has a wrong offset!");
static_assert(offsetof(AGzToxicSmokeMissile, InitialSmokeNiagaraSystem) == 0x000368, "Member 'AGzToxicSmokeMissile::InitialSmokeNiagaraSystem' has a wrong offset!");
static_assert(offsetof(AGzToxicSmokeMissile, ImpactNormalOffsetDistance) == 0x000370, "Member 'AGzToxicSmokeMissile::ImpactNormalOffsetDistance' has a wrong offset!");
static_assert(offsetof(AGzToxicSmokeMissile, AbilityData) == 0x000378, "Member 'AGzToxicSmokeMissile::AbilityData' has a wrong offset!");

// Class G01.GzCommonButtonStyle
// 0x0030 (0x07E0 - 0x07B0)
class UGzCommonButtonStyle : public UCommonButtonStyle
{
public:
	class FName                                   TextNormalColor;                                   // 0x07B0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   TextHoveredColor;                                  // 0x07B8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   TextPressedColor;                                  // 0x07C0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   TextSelectedNormalColor;                           // 0x07C8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   TextSelectedHoveredColor;                          // 0x07D0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   TextSelectedPressedColor;                          // 0x07D8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzCommonButtonStyle">();
	}
	static class UGzCommonButtonStyle* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzCommonButtonStyle>();
	}
};
static_assert(alignof(UGzCommonButtonStyle) == 0x000010, "Wrong alignment on UGzCommonButtonStyle");
static_assert(sizeof(UGzCommonButtonStyle) == 0x0007E0, "Wrong size on UGzCommonButtonStyle");
static_assert(offsetof(UGzCommonButtonStyle, TextNormalColor) == 0x0007B0, "Member 'UGzCommonButtonStyle::TextNormalColor' has a wrong offset!");
static_assert(offsetof(UGzCommonButtonStyle, TextHoveredColor) == 0x0007B8, "Member 'UGzCommonButtonStyle::TextHoveredColor' has a wrong offset!");
static_assert(offsetof(UGzCommonButtonStyle, TextPressedColor) == 0x0007C0, "Member 'UGzCommonButtonStyle::TextPressedColor' has a wrong offset!");
static_assert(offsetof(UGzCommonButtonStyle, TextSelectedNormalColor) == 0x0007C8, "Member 'UGzCommonButtonStyle::TextSelectedNormalColor' has a wrong offset!");
static_assert(offsetof(UGzCommonButtonStyle, TextSelectedHoveredColor) == 0x0007D0, "Member 'UGzCommonButtonStyle::TextSelectedHoveredColor' has a wrong offset!");
static_assert(offsetof(UGzCommonButtonStyle, TextSelectedPressedColor) == 0x0007D8, "Member 'UGzCommonButtonStyle::TextSelectedPressedColor' has a wrong offset!");

// Class G01.GzCompassMarkerContainer
// 0x0010 (0x04F8 - 0x04E8)
class UGzCompassMarkerContainer : public UGzBaseMarkerContainer
{
public:
	class USizeBox*                               CompassSizeBox;                                    // 0x04E8(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 ScaleImage;                                        // 0x04F0(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void SetParentCompassSizeBox(class USizeBox* InSizeBox);
	void SetParentScaleImage(class UImage* InScaleImage);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzCompassMarkerContainer">();
	}
	static class UGzCompassMarkerContainer* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzCompassMarkerContainer>();
	}
};
static_assert(alignof(UGzCompassMarkerContainer) == 0x000008, "Wrong alignment on UGzCompassMarkerContainer");
static_assert(sizeof(UGzCompassMarkerContainer) == 0x0004F8, "Wrong size on UGzCompassMarkerContainer");
static_assert(offsetof(UGzCompassMarkerContainer, CompassSizeBox) == 0x0004E8, "Member 'UGzCompassMarkerContainer::CompassSizeBox' has a wrong offset!");
static_assert(offsetof(UGzCompassMarkerContainer, ScaleImage) == 0x0004F0, "Member 'UGzCompassMarkerContainer::ScaleImage' has a wrong offset!");

// Class G01.GzWeaponSpreadModifier
// 0x0068 (0x0090 - 0x0028)
class UGzWeaponSpreadModifier final : public UGzWeaponModifier
{
public:
	float                                         MaxScaleRatioCoefficient;                          // 0x0028(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         GrowthScaleRatioStepCoefficient;                   // 0x002C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CooldownScaleRatioSpeedCoefficient;                // 0x0030(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ADSMaxScaleRatioCoefficient;                       // 0x0034(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ADSGrowthScaleRatioStepCoefficient;                // 0x0038(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ADSCooldownScaleRatioSpeedCoefficient;             // 0x003C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMap<EGzMovementSpreadPenaltyMode, float>     MovementAccuracyPenalties;                         // 0x0040(0x0050)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzWeaponSpreadModifier">();
	}
	static class UGzWeaponSpreadModifier* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzWeaponSpreadModifier>();
	}
};
static_assert(alignof(UGzWeaponSpreadModifier) == 0x000008, "Wrong alignment on UGzWeaponSpreadModifier");
static_assert(sizeof(UGzWeaponSpreadModifier) == 0x000090, "Wrong size on UGzWeaponSpreadModifier");
static_assert(offsetof(UGzWeaponSpreadModifier, MaxScaleRatioCoefficient) == 0x000028, "Member 'UGzWeaponSpreadModifier::MaxScaleRatioCoefficient' has a wrong offset!");
static_assert(offsetof(UGzWeaponSpreadModifier, GrowthScaleRatioStepCoefficient) == 0x00002C, "Member 'UGzWeaponSpreadModifier::GrowthScaleRatioStepCoefficient' has a wrong offset!");
static_assert(offsetof(UGzWeaponSpreadModifier, CooldownScaleRatioSpeedCoefficient) == 0x000030, "Member 'UGzWeaponSpreadModifier::CooldownScaleRatioSpeedCoefficient' has a wrong offset!");
static_assert(offsetof(UGzWeaponSpreadModifier, ADSMaxScaleRatioCoefficient) == 0x000034, "Member 'UGzWeaponSpreadModifier::ADSMaxScaleRatioCoefficient' has a wrong offset!");
static_assert(offsetof(UGzWeaponSpreadModifier, ADSGrowthScaleRatioStepCoefficient) == 0x000038, "Member 'UGzWeaponSpreadModifier::ADSGrowthScaleRatioStepCoefficient' has a wrong offset!");
static_assert(offsetof(UGzWeaponSpreadModifier, ADSCooldownScaleRatioSpeedCoefficient) == 0x00003C, "Member 'UGzWeaponSpreadModifier::ADSCooldownScaleRatioSpeedCoefficient' has a wrong offset!");
static_assert(offsetof(UGzWeaponSpreadModifier, MovementAccuracyPenalties) == 0x000040, "Member 'UGzWeaponSpreadModifier::MovementAccuracyPenalties' has a wrong offset!");

// Class G01.GzUISystem
// 0x0028 (0x0058 - 0x0030)
class UGzUISystem final : public UGameInstanceSubsystem
{
public:
	class UGzLoadingScreenController*             LoadingScreenController;                           // 0x0030(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UGzLoadingScreenManager*                LoadingScreenManager;                              // 0x0038(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UGzHUDRuntimeSettings*                  HUDRuntimeSettings;                                // 0x0040(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class AGzHUDBase*                             HUD;                                               // 0x0048(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_3107[0x8];                                     // 0x0050(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UGzHUDRuntimeSettings* GetHUDRuntimeSettings(const class UObject* WorldContextObject);
	static class UGzUISystem* GetUISystem(const class UObject* WorldContextObject);

	void OverrideChannelsVisibility(EGzUIChannels Channels, bool bNewVisible);
	void SetGlobalVisibility(bool bNewVisible);
	void SetVisibleChannels(EGzUIChannels Channels);
	void ToggleGlobalVisibility();

	class AGzHUDBase* GetHUD() const;
	class UGzHUDView* GetHUDView() const;
	class UGzLoadingScreenController* GetLoadingScreenController() const;
	class UGzLoadingScreenManager* GetLoadingScreenManager() const;
	float GetTargetMinimapWidth() const;
	EGzUIChannels GetVisibleChannels() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzUISystem">();
	}
	static class UGzUISystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzUISystem>();
	}
};
static_assert(alignof(UGzUISystem) == 0x000008, "Wrong alignment on UGzUISystem");
static_assert(sizeof(UGzUISystem) == 0x000058, "Wrong size on UGzUISystem");
static_assert(offsetof(UGzUISystem, LoadingScreenController) == 0x000030, "Member 'UGzUISystem::LoadingScreenController' has a wrong offset!");
static_assert(offsetof(UGzUISystem, LoadingScreenManager) == 0x000038, "Member 'UGzUISystem::LoadingScreenManager' has a wrong offset!");
static_assert(offsetof(UGzUISystem, HUDRuntimeSettings) == 0x000040, "Member 'UGzUISystem::HUDRuntimeSettings' has a wrong offset!");
static_assert(offsetof(UGzUISystem, HUD) == 0x000048, "Member 'UGzUISystem::HUD' has a wrong offset!");

// Class G01.GzGA_Zipline_Cancel
// 0x0000 (0x0508 - 0x0508)
class UGzGA_Zipline_Cancel : public UGzGameplayAbility
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzGA_Zipline_Cancel">();
	}
	static class UGzGA_Zipline_Cancel* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzGA_Zipline_Cancel>();
	}
};
static_assert(alignof(UGzGA_Zipline_Cancel) == 0x000008, "Wrong alignment on UGzGA_Zipline_Cancel");
static_assert(sizeof(UGzGA_Zipline_Cancel) == 0x000508, "Wrong size on UGzGA_Zipline_Cancel");

// Class G01.GzComposedCondition
// 0x0018 (0x0078 - 0x0060)
class UGzComposedCondition final : public UGzCondition
{
public:
	TArray<class UGzCondition*>                   ChildConditions;                                   // 0x0060(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	uint8                                         Pad_3108[0x8];                                     // 0x0070(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UGzCondition* MakeAndCondition(class AGzAdvancedMission* Mission, const TArray<class UGzCondition*>& Conditions);
	static class UGzCondition* MakeOrCondition(class AGzAdvancedMission* Mission, const TArray<class UGzCondition*>& Conditions);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzComposedCondition">();
	}
	static class UGzComposedCondition* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzComposedCondition>();
	}
};
static_assert(alignof(UGzComposedCondition) == 0x000008, "Wrong alignment on UGzComposedCondition");
static_assert(sizeof(UGzComposedCondition) == 0x000078, "Wrong size on UGzComposedCondition");
static_assert(offsetof(UGzComposedCondition, ChildConditions) == 0x000060, "Member 'UGzComposedCondition::ChildConditions' has a wrong offset!");

// Class G01.GzGA_WeaponRechamber
// 0x0008 (0x0560 - 0x0558)
class UGzGA_WeaponRechamber : public UGzGA_WeaponAbilityBase
{
public:
	class UGzAT_PlayMontageAndWaitForEvent*       PlayMontageAndWaitForEventTask_Rechamber;          // 0x0558(0x0008)(Edit, ZeroConstructor, EditConst, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void OnMontageEnded();
	void OnMontageInterrupted();
	void OnRechamberEvent(class FName NotifyName);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzGA_WeaponRechamber">();
	}
	static class UGzGA_WeaponRechamber* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzGA_WeaponRechamber>();
	}
};
static_assert(alignof(UGzGA_WeaponRechamber) == 0x000008, "Wrong alignment on UGzGA_WeaponRechamber");
static_assert(sizeof(UGzGA_WeaponRechamber) == 0x000560, "Wrong size on UGzGA_WeaponRechamber");
static_assert(offsetof(UGzGA_WeaponRechamber, PlayMontageAndWaitForEventTask_Rechamber) == 0x000558, "Member 'UGzGA_WeaponRechamber::PlayMontageAndWaitForEventTask_Rechamber' has a wrong offset!");

// Class G01.GzComposedObjective
// 0x0018 (0x0078 - 0x0060)
class UGzComposedObjective final : public UGzObjective
{
public:
	TArray<class UGzObjective*>                   ChildObjectives;                                   // 0x0060(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	uint8                                         Pad_3109[0x8];                                     // 0x0070(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UGzObjective* MakeAllObjective(class AGzAdvancedMission* Mission, const TArray<class UGzObjective*>& Objectives);
	static class UGzObjective* MakeAnyObjective(class AGzAdvancedMission* Mission, const TArray<class UGzObjective*>& Objectives);
	static class UGzObjective* MakeFirstObjective(class AGzAdvancedMission* Mission, const TArray<class UGzObjective*>& Objectives);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzComposedObjective">();
	}
	static class UGzComposedObjective* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzComposedObjective>();
	}
};
static_assert(alignof(UGzComposedObjective) == 0x000008, "Wrong alignment on UGzComposedObjective");
static_assert(sizeof(UGzComposedObjective) == 0x000078, "Wrong size on UGzComposedObjective");
static_assert(offsetof(UGzComposedObjective, ChildObjectives) == 0x000060, "Member 'UGzComposedObjective::ChildObjectives' has a wrong offset!");

// Class G01.GzConfirmationWidget
// 0x0038 (0x0560 - 0x0528)
class UGzConfirmationWidget final : public UGzNavigationWidget
{
public:
	class UGzTextBlock*                           ConfirmationTextBlock;                             // 0x0528(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UGzCommonButton*                        ConfirmButton;                                     // 0x0530(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UGzCommonButton*                        CancelButton;                                      // 0x0538(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_310A[0x20];                                    // 0x0540(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void InitCancellation(const TDelegate<void()> Delegate);
	void InitConfirmation(const TDelegate<void()> Delegate, const class FText& ConfirmationText);
	void OnCanceled();
	void OnConfirmed();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzConfirmationWidget">();
	}
	static class UGzConfirmationWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzConfirmationWidget>();
	}
};
static_assert(alignof(UGzConfirmationWidget) == 0x000008, "Wrong alignment on UGzConfirmationWidget");
static_assert(sizeof(UGzConfirmationWidget) == 0x000560, "Wrong size on UGzConfirmationWidget");
static_assert(offsetof(UGzConfirmationWidget, ConfirmationTextBlock) == 0x000528, "Member 'UGzConfirmationWidget::ConfirmationTextBlock' has a wrong offset!");
static_assert(offsetof(UGzConfirmationWidget, ConfirmButton) == 0x000530, "Member 'UGzConfirmationWidget::ConfirmButton' has a wrong offset!");
static_assert(offsetof(UGzConfirmationWidget, CancelButton) == 0x000538, "Member 'UGzConfirmationWidget::CancelButton' has a wrong offset!");

// Class G01.GzConnectionModel
// 0x0030 (0x00A0 - 0x0070)
class UGzConnectionModel final : public UGzBackendModel
{
public:
	uint8                                         Pad_310B[0x30];                                    // 0x0070(0x0030)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzConnectionModel">();
	}
	static class UGzConnectionModel* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzConnectionModel>();
	}
};
static_assert(alignof(UGzConnectionModel) == 0x000008, "Wrong alignment on UGzConnectionModel");
static_assert(sizeof(UGzConnectionModel) == 0x0000A0, "Wrong size on UGzConnectionModel");

// Class G01.GzOperableObjectComponent
// 0x0058 (0x0100 - 0x00A8)
class UGzOperableObjectComponent : public UActorComponent
{
public:
	bool                                          bOnlyTickWhenOperated;                             // 0x00A8(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_310C[0x7];                                     // 0x00A9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<TSubclassOf<class UGameplayAbility>>   GrantedAbilityClasses;                             // 0x00B0(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	uint8                                         Pad_310D[0x10];                                    // 0x00C0(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftClassPtr<class UClass>                   CrosshairClass;                                    // 0x00D0(0x0028)(Edit, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class AGzCharacter*                           OperatorCharacter;                                 // 0x00F8(0x0008)(Net, ZeroConstructor, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void OnOperationStart(class AGzCharacter* NewOperatorCharacter);
	void OnOperationStop(class AGzCharacter* PreviousOperatorCharacter);
	void OnRep_OperatorCharacter(class AGzCharacter* PreviousOperatorCharacter);
	void TryStartOperation(class AGzCharacter* NewOperatorCharacter);
	void TryStopOperation();

	bool CanOperate(class AGzCharacter* NewOperatorCharacter) const;
	class AGzCharacter* GetOperatingCharacter() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzOperableObjectComponent">();
	}
	static class UGzOperableObjectComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzOperableObjectComponent>();
	}
};
static_assert(alignof(UGzOperableObjectComponent) == 0x000008, "Wrong alignment on UGzOperableObjectComponent");
static_assert(sizeof(UGzOperableObjectComponent) == 0x000100, "Wrong size on UGzOperableObjectComponent");
static_assert(offsetof(UGzOperableObjectComponent, bOnlyTickWhenOperated) == 0x0000A8, "Member 'UGzOperableObjectComponent::bOnlyTickWhenOperated' has a wrong offset!");
static_assert(offsetof(UGzOperableObjectComponent, GrantedAbilityClasses) == 0x0000B0, "Member 'UGzOperableObjectComponent::GrantedAbilityClasses' has a wrong offset!");
static_assert(offsetof(UGzOperableObjectComponent, CrosshairClass) == 0x0000D0, "Member 'UGzOperableObjectComponent::CrosshairClass' has a wrong offset!");
static_assert(offsetof(UGzOperableObjectComponent, OperatorCharacter) == 0x0000F8, "Member 'UGzOperableObjectComponent::OperatorCharacter' has a wrong offset!");

// Class G01.GzTurretComponent
// 0x0048 (0x0148 - 0x0100)
class UGzTurretComponent final : public UGzOperableObjectComponent
{
public:
	class UGzItemData*                            TurretItemData;                                    // 0x0100(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                CharacterRelativeOffset;                           // 0x0108(0x0018)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class AGzTurretWeaponActor*                   TurretWeaponActor;                                 // 0x0120(0x0008)(Edit, Net, ZeroConstructor, EditConst, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FRotator                               RelativeTurretRotation;                            // 0x0128(0x0018)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	class USkeletalMeshComponent*                 TurretSkeletalMeshComponent;                       // 0x0140(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void OnRep_TurretWeaponActor();
	void OnTurretOwnerDestroyed(class AActor* DestroyedActor);
	void OnTurretWeaponActorOwnerChanged(class AActor* NewWeaponOwner);

	struct FVector GetRelativeGunnerTurretOffset() const;
	struct FRotator GetRelativeTurretRotation(bool bUseLocalRotation) const;
	class USkeletalMeshComponent* GetTurretSkeletalMeshComponent() const;
	class AGzTurretWeaponActor* GetTurretWeaponActor() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzTurretComponent">();
	}
	static class UGzTurretComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzTurretComponent>();
	}
};
static_assert(alignof(UGzTurretComponent) == 0x000008, "Wrong alignment on UGzTurretComponent");
static_assert(sizeof(UGzTurretComponent) == 0x000148, "Wrong size on UGzTurretComponent");
static_assert(offsetof(UGzTurretComponent, TurretItemData) == 0x000100, "Member 'UGzTurretComponent::TurretItemData' has a wrong offset!");
static_assert(offsetof(UGzTurretComponent, CharacterRelativeOffset) == 0x000108, "Member 'UGzTurretComponent::CharacterRelativeOffset' has a wrong offset!");
static_assert(offsetof(UGzTurretComponent, TurretWeaponActor) == 0x000120, "Member 'UGzTurretComponent::TurretWeaponActor' has a wrong offset!");
static_assert(offsetof(UGzTurretComponent, RelativeTurretRotation) == 0x000128, "Member 'UGzTurretComponent::RelativeTurretRotation' has a wrong offset!");
static_assert(offsetof(UGzTurretComponent, TurretSkeletalMeshComponent) == 0x000140, "Member 'UGzTurretComponent::TurretSkeletalMeshComponent' has a wrong offset!");

// Class G01.GzConnectionStateChangeMessage
// 0x0008 (0x0030 - 0x0028)
class UGzConnectionStateChangeMessage final : public UGzGameMessage
{
public:
	uint8                                         Pad_3110[0x8];                                     // 0x0028(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzConnectionStateChangeMessage">();
	}
	static class UGzConnectionStateChangeMessage* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzConnectionStateChangeMessage>();
	}
};
static_assert(alignof(UGzConnectionStateChangeMessage) == 0x000008, "Wrong alignment on UGzConnectionStateChangeMessage");
static_assert(sizeof(UGzConnectionStateChangeMessage) == 0x000030, "Wrong size on UGzConnectionStateChangeMessage");

// Class G01.GzGA_WeaponAttack
// 0x0000 (0x0558 - 0x0558)
class UGzGA_WeaponAttack : public UGzGA_WeaponAbilityBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzGA_WeaponAttack">();
	}
	static class UGzGA_WeaponAttack* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzGA_WeaponAttack>();
	}
};
static_assert(alignof(UGzGA_WeaponAttack) == 0x000008, "Wrong alignment on UGzGA_WeaponAttack");
static_assert(sizeof(UGzGA_WeaponAttack) == 0x000558, "Wrong size on UGzGA_WeaponAttack");

// Class G01.GzGA_WeaponAttack_Turret
// 0x0000 (0x0558 - 0x0558)
class UGzGA_WeaponAttack_Turret final : public UGzGA_WeaponAttack
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzGA_WeaponAttack_Turret">();
	}
	static class UGzGA_WeaponAttack_Turret* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzGA_WeaponAttack_Turret>();
	}
};
static_assert(alignof(UGzGA_WeaponAttack_Turret) == 0x000008, "Wrong alignment on UGzGA_WeaponAttack_Turret");
static_assert(sizeof(UGzGA_WeaponAttack_Turret) == 0x000558, "Wrong size on UGzGA_WeaponAttack_Turret");

// Class G01.GzConsoleBlacklistService
// 0x0070 (0x0110 - 0x00A0)
class UGzConsoleBlacklistService final : public UGzClientPFObject
{
public:
	uint8                                         Pad_3111[0x70];                                    // 0x00A0(0x0070)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzConsoleBlacklistService">();
	}
	static class UGzConsoleBlacklistService* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzConsoleBlacklistService>();
	}
};
static_assert(alignof(UGzConsoleBlacklistService) == 0x000008, "Wrong alignment on UGzConsoleBlacklistService");
static_assert(sizeof(UGzConsoleBlacklistService) == 0x000110, "Wrong size on UGzConsoleBlacklistService");

// Class G01.GzConsoleFriendsService
// 0x0050 (0x0158 - 0x0108)
class UGzConsoleFriendsService final : public UGzFriendsServiceBase
{
public:
	uint8                                         Pad_3112[0x50];                                    // 0x0108(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzConsoleFriendsService">();
	}
	static class UGzConsoleFriendsService* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzConsoleFriendsService>();
	}
};
static_assert(alignof(UGzConsoleFriendsService) == 0x000008, "Wrong alignment on UGzConsoleFriendsService");
static_assert(sizeof(UGzConsoleFriendsService) == 0x000158, "Wrong size on UGzConsoleFriendsService");

// Class G01.GzStringTable
// 0x0000 (0x0040 - 0x0040)
class UGzStringTable final : public UStringTable
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzStringTable">();
	}
	static class UGzStringTable* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzStringTable>();
	}
};
static_assert(alignof(UGzStringTable) == 0x000008, "Wrong alignment on UGzStringTable");
static_assert(sizeof(UGzStringTable) == 0x000040, "Wrong size on UGzStringTable");

// Class G01.GzConsolePartyService
// 0x03A0 (0x0560 - 0x01C0)
class alignas(0x10) UGzConsolePartyService final : public UGzPartyServiceBase
{
public:
	uint8                                         Pad_3113[0x320];                                   // 0x01C0(0x0320)(Fixing Size After Last Property [ Dumper-7 ])
	class UGzEpicAccountService*                  EpicAccountServicePtr;                             // 0x04E0(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UGzConsoleSessionService*               ConsoleSessionServicePtr;                          // 0x04E8(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_3114[0x70];                                    // 0x04F0(0x0070)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzConsolePartyService">();
	}
	static class UGzConsolePartyService* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzConsolePartyService>();
	}
};
static_assert(alignof(UGzConsolePartyService) == 0x000010, "Wrong alignment on UGzConsolePartyService");
static_assert(sizeof(UGzConsolePartyService) == 0x000560, "Wrong size on UGzConsolePartyService");
static_assert(offsetof(UGzConsolePartyService, EpicAccountServicePtr) == 0x0004E0, "Member 'UGzConsolePartyService::EpicAccountServicePtr' has a wrong offset!");
static_assert(offsetof(UGzConsolePartyService, ConsoleSessionServicePtr) == 0x0004E8, "Member 'UGzConsolePartyService::ConsoleSessionServicePtr' has a wrong offset!");

// Class G01.GzXR_ChangeProgressiveLoadoutEvent
// 0x0008 (0x0060 - 0x0058)
class UGzXR_ChangeProgressiveLoadoutEvent final : public UGzXR_BaseEvent
{
public:
	bool                                          bIncrementStageIndex;                              // 0x0058(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_3115[0x3];                                     // 0x0059(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         ProgressiveLoadoutStageOverride;                   // 0x005C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzXR_ChangeProgressiveLoadoutEvent">();
	}
	static class UGzXR_ChangeProgressiveLoadoutEvent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzXR_ChangeProgressiveLoadoutEvent>();
	}
};
static_assert(alignof(UGzXR_ChangeProgressiveLoadoutEvent) == 0x000008, "Wrong alignment on UGzXR_ChangeProgressiveLoadoutEvent");
static_assert(sizeof(UGzXR_ChangeProgressiveLoadoutEvent) == 0x000060, "Wrong size on UGzXR_ChangeProgressiveLoadoutEvent");
static_assert(offsetof(UGzXR_ChangeProgressiveLoadoutEvent, bIncrementStageIndex) == 0x000058, "Member 'UGzXR_ChangeProgressiveLoadoutEvent::bIncrementStageIndex' has a wrong offset!");
static_assert(offsetof(UGzXR_ChangeProgressiveLoadoutEvent, ProgressiveLoadoutStageOverride) == 0x00005C, "Member 'UGzXR_ChangeProgressiveLoadoutEvent::ProgressiveLoadoutStageOverride' has a wrong offset!");

// Class G01.GzConsolePaymentProviderComponent
// 0x0020 (0x00D8 - 0x00B8)
class UGzConsolePaymentProviderComponent final : public UGzPaymentProviderComponent
{
public:
	uint8                                         Pad_3116[0x20];                                    // 0x00B8(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzConsolePaymentProviderComponent">();
	}
	static class UGzConsolePaymentProviderComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzConsolePaymentProviderComponent>();
	}
};
static_assert(alignof(UGzConsolePaymentProviderComponent) == 0x000008, "Wrong alignment on UGzConsolePaymentProviderComponent");
static_assert(sizeof(UGzConsolePaymentProviderComponent) == 0x0000D8, "Wrong size on UGzConsolePaymentProviderComponent");

// Class G01.GzWorldZoneRegionMetadata
// 0x0038 (0x0060 - 0x0028)
class UGzWorldZoneRegionMetadata final : public UGzWorldZoneMetadata
{
public:
	struct FVector                                NamePosition;                                      // 0x0028(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FText                                   Name_GzWorldZoneRegionMetadata;                    // 0x0040(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)
	float                                         MinZoomVisibility;                                 // 0x0050(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MaxZoomVisibility;                                 // 0x0054(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FGameplayTag                           ZoneTag;                                           // 0x0058(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzWorldZoneRegionMetadata">();
	}
	static class UGzWorldZoneRegionMetadata* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzWorldZoneRegionMetadata>();
	}
};
static_assert(alignof(UGzWorldZoneRegionMetadata) == 0x000008, "Wrong alignment on UGzWorldZoneRegionMetadata");
static_assert(sizeof(UGzWorldZoneRegionMetadata) == 0x000060, "Wrong size on UGzWorldZoneRegionMetadata");
static_assert(offsetof(UGzWorldZoneRegionMetadata, NamePosition) == 0x000028, "Member 'UGzWorldZoneRegionMetadata::NamePosition' has a wrong offset!");
static_assert(offsetof(UGzWorldZoneRegionMetadata, Name_GzWorldZoneRegionMetadata) == 0x000040, "Member 'UGzWorldZoneRegionMetadata::Name_GzWorldZoneRegionMetadata' has a wrong offset!");
static_assert(offsetof(UGzWorldZoneRegionMetadata, MinZoomVisibility) == 0x000050, "Member 'UGzWorldZoneRegionMetadata::MinZoomVisibility' has a wrong offset!");
static_assert(offsetof(UGzWorldZoneRegionMetadata, MaxZoomVisibility) == 0x000054, "Member 'UGzWorldZoneRegionMetadata::MaxZoomVisibility' has a wrong offset!");
static_assert(offsetof(UGzWorldZoneRegionMetadata, ZoneTag) == 0x000058, "Member 'UGzWorldZoneRegionMetadata::ZoneTag' has a wrong offset!");

// Class G01.GzJobZeroGameState
// 0x0000 (0x0678 - 0x0678)
class AGzJobZeroGameState final : public AGzMultiStageGameState
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzJobZeroGameState">();
	}
	static class AGzJobZeroGameState* GetDefaultObj()
	{
		return GetDefaultObjImpl<AGzJobZeroGameState>();
	}
};
static_assert(alignof(AGzJobZeroGameState) == 0x000008, "Wrong alignment on AGzJobZeroGameState");
static_assert(sizeof(AGzJobZeroGameState) == 0x000678, "Wrong size on AGzJobZeroGameState");

// Class G01.GzConsoleSessionService
// 0x01D8 (0x0278 - 0x00A0)
class UGzConsoleSessionService final : public UGzClientPFObject
{
public:
	uint8                                         Pad_3117[0x1D8];                                   // 0x00A0(0x01D8)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzConsoleSessionService">();
	}
	static class UGzConsoleSessionService* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzConsoleSessionService>();
	}
};
static_assert(alignof(UGzConsoleSessionService) == 0x000008, "Wrong alignment on UGzConsoleSessionService");
static_assert(sizeof(UGzConsoleSessionService) == 0x000278, "Wrong size on UGzConsoleSessionService");

// Class G01.GzConsumableStatCollector
// 0x0058 (0x0090 - 0x0038)
class UGzConsumableStatCollector : public UGzGlobalStatsCollector
{
public:
	TMap<class UGzConsumableItemData*, class FName> ConsumableItemData;                                // 0x0038(0x0050)(Edit, NativeAccessSpecifierPublic)
	uint8                                         Pad_3118[0x8];                                     // 0x0088(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzConsumableStatCollector">();
	}
	static class UGzConsumableStatCollector* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzConsumableStatCollector>();
	}
};
static_assert(alignof(UGzConsumableStatCollector) == 0x000008, "Wrong alignment on UGzConsumableStatCollector");
static_assert(sizeof(UGzConsumableStatCollector) == 0x000090, "Wrong size on UGzConsumableStatCollector");
static_assert(offsetof(UGzConsumableStatCollector, ConsumableItemData) == 0x000038, "Member 'UGzConsumableStatCollector::ConsumableItemData' has a wrong offset!");

// Class G01.EnvQueryTest_ZoneControl
// 0x0000 (0x01F8 - 0x01F8)
class UEnvQueryTest_ZoneControl final : public UEnvQueryTest
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EnvQueryTest_ZoneControl">();
	}
	static class UEnvQueryTest_ZoneControl* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEnvQueryTest_ZoneControl>();
	}
};
static_assert(alignof(UEnvQueryTest_ZoneControl) == 0x000008, "Wrong alignment on UEnvQueryTest_ZoneControl");
static_assert(sizeof(UEnvQueryTest_ZoneControl) == 0x0001F8, "Wrong size on UEnvQueryTest_ZoneControl");

// Class G01.GzUnityMatchmakingProcess
// 0x0050 (0x00F0 - 0x00A0)
class UGzUnityMatchmakingProcess final : public UGzServiceComponent
{
public:
	uint8                                         Pad_3119[0x38];                                    // 0x00A0(0x0038)(Fixing Size After Last Property [ Dumper-7 ])
	class UGzUnityMatchmakingServiceState*        ActiveState;                                       // 0x00D8(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_311A[0x10];                                    // 0x00E0(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzUnityMatchmakingProcess">();
	}
	static class UGzUnityMatchmakingProcess* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzUnityMatchmakingProcess>();
	}
};
static_assert(alignof(UGzUnityMatchmakingProcess) == 0x000008, "Wrong alignment on UGzUnityMatchmakingProcess");
static_assert(sizeof(UGzUnityMatchmakingProcess) == 0x0000F0, "Wrong size on UGzUnityMatchmakingProcess");
static_assert(offsetof(UGzUnityMatchmakingProcess, ActiveState) == 0x0000D8, "Member 'UGzUnityMatchmakingProcess::ActiveState' has a wrong offset!");

// Class G01.GzWeaponAttachmentsViewpointCluster
// 0x0108 (0x03B8 - 0x02B0)
class AGzWeaponAttachmentsViewpointCluster final : public AGzViewpointClusterBase
{
public:
	TSubclassOf<class AGzSpringArmViewpoint>      DefaultViewpoint;                                  // 0x02B0(0x0008)(Edit, ZeroConstructor, DisableEditOnTemplate, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMap<EGzWeaponAttachmentType, TSubclassOf<class AGzSpringArmViewpoint>> OverrideForType;                                   // 0x02B8(0x0050)(Edit, DisableEditOnTemplate, UObjectWrapper, NativeAccessSpecifierPublic)
	TMap<class UGzWeaponArchetype*, struct FOverrides> OverrideForArchetype;                              // 0x0308(0x0050)(Edit, DisableEditOnTemplate, NativeAccessSpecifierPublic)
	TMap<class UGzWeaponItemData*, struct FOverrides> OverrideForWeapon;                                 // 0x0358(0x0050)(Edit, DisableEditOnTemplate, NativeAccessSpecifierPublic)
	class AGzWeaponSpawn*                         WeaponSpawn;                                       // 0x03A8(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AGzWeaponPickable*                      SpawnedWeapon;                                     // 0x03B0(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzWeaponAttachmentsViewpointCluster">();
	}
	static class AGzWeaponAttachmentsViewpointCluster* GetDefaultObj()
	{
		return GetDefaultObjImpl<AGzWeaponAttachmentsViewpointCluster>();
	}
};
static_assert(alignof(AGzWeaponAttachmentsViewpointCluster) == 0x000008, "Wrong alignment on AGzWeaponAttachmentsViewpointCluster");
static_assert(sizeof(AGzWeaponAttachmentsViewpointCluster) == 0x0003B8, "Wrong size on AGzWeaponAttachmentsViewpointCluster");
static_assert(offsetof(AGzWeaponAttachmentsViewpointCluster, DefaultViewpoint) == 0x0002B0, "Member 'AGzWeaponAttachmentsViewpointCluster::DefaultViewpoint' has a wrong offset!");
static_assert(offsetof(AGzWeaponAttachmentsViewpointCluster, OverrideForType) == 0x0002B8, "Member 'AGzWeaponAttachmentsViewpointCluster::OverrideForType' has a wrong offset!");
static_assert(offsetof(AGzWeaponAttachmentsViewpointCluster, OverrideForArchetype) == 0x000308, "Member 'AGzWeaponAttachmentsViewpointCluster::OverrideForArchetype' has a wrong offset!");
static_assert(offsetof(AGzWeaponAttachmentsViewpointCluster, OverrideForWeapon) == 0x000358, "Member 'AGzWeaponAttachmentsViewpointCluster::OverrideForWeapon' has a wrong offset!");
static_assert(offsetof(AGzWeaponAttachmentsViewpointCluster, WeaponSpawn) == 0x0003A8, "Member 'AGzWeaponAttachmentsViewpointCluster::WeaponSpawn' has a wrong offset!");
static_assert(offsetof(AGzWeaponAttachmentsViewpointCluster, SpawnedWeapon) == 0x0003B0, "Member 'AGzWeaponAttachmentsViewpointCluster::SpawnedWeapon' has a wrong offset!");

// Class G01.GzGA_Walk
// 0x0000 (0x0550 - 0x0550)
class UGzGA_Walk : public UGzGA_CharacterState
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzGA_Walk">();
	}
	static class UGzGA_Walk* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzGA_Walk>();
	}
};
static_assert(alignof(UGzGA_Walk) == 0x000008, "Wrong alignment on UGzGA_Walk");
static_assert(sizeof(UGzGA_Walk) == 0x000550, "Wrong size on UGzGA_Walk");

// Class G01.GzContentPackManagementComponent
// 0x0010 (0x00B0 - 0x00A0)
class UGzContentPackManagementComponent final : public UGzServiceComponent
{
public:
	class UGzSubscriptionPageLayoutInfo*          CurrentSubscriptionLayout;                         // 0x00A0(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_311B[0x8];                                     // 0x00A8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzContentPackManagementComponent">();
	}
	static class UGzContentPackManagementComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzContentPackManagementComponent>();
	}
};
static_assert(alignof(UGzContentPackManagementComponent) == 0x000008, "Wrong alignment on UGzContentPackManagementComponent");
static_assert(sizeof(UGzContentPackManagementComponent) == 0x0000B0, "Wrong size on UGzContentPackManagementComponent");
static_assert(offsetof(UGzContentPackManagementComponent, CurrentSubscriptionLayout) == 0x0000A0, "Member 'UGzContentPackManagementComponent::CurrentSubscriptionLayout' has a wrong offset!");

// Class G01.GzCoreModel
// 0x0128 (0x0198 - 0x0070)
class UGzCoreModel final : public UGzCohtmlDataModel
{
public:
	uint8                                         Pad_311C[0x60];                                    // 0x0070(0x0060)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<class FName, class UAkAudioEvent*>       PreloadedSounds;                                   // 0x00D0(0x0050)(NativeAccessSpecifierPrivate)
	TMap<class FString, struct FGzQrCodeRecord>   ExistingQrCodes;                                   // 0x0120(0x0050)(Transient, NativeAccessSpecifierPrivate)
	uint8                                         Pad_311D[0x28];                                    // 0x0170(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzCoreModel">();
	}
	static class UGzCoreModel* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzCoreModel>();
	}
};
static_assert(alignof(UGzCoreModel) == 0x000008, "Wrong alignment on UGzCoreModel");
static_assert(sizeof(UGzCoreModel) == 0x000198, "Wrong size on UGzCoreModel");
static_assert(offsetof(UGzCoreModel, PreloadedSounds) == 0x0000D0, "Member 'UGzCoreModel::PreloadedSounds' has a wrong offset!");
static_assert(offsetof(UGzCoreModel, ExistingQrCodes) == 0x000120, "Member 'UGzCoreModel::ExistingQrCodes' has a wrong offset!");

// Class G01.GzXR_RedeployCostModifier
// 0x0008 (0x0060 - 0x0058)
class UGzXR_RedeployCostModifier final : public UGzXR_BaseEvent
{
public:
	float                                         RedeployPriceModifier;                             // 0x0058(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_311E[0x4];                                     // 0x005C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzXR_RedeployCostModifier">();
	}
	static class UGzXR_RedeployCostModifier* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzXR_RedeployCostModifier>();
	}
};
static_assert(alignof(UGzXR_RedeployCostModifier) == 0x000008, "Wrong alignment on UGzXR_RedeployCostModifier");
static_assert(sizeof(UGzXR_RedeployCostModifier) == 0x000060, "Wrong size on UGzXR_RedeployCostModifier");
static_assert(offsetof(UGzXR_RedeployCostModifier, RedeployPriceModifier) == 0x000058, "Member 'UGzXR_RedeployCostModifier::RedeployPriceModifier' has a wrong offset!");

// Class G01.GzCoversComponent
// 0x0110 (0x01C0 - 0x00B0)
class UGzCoversComponent final : public UGzNavigationComponent
{
public:
	uint8                                         Pad_311F[0x100];                                   // 0x00B0(0x0100)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         DrawRadius;                                        // 0x01B0(0x0004)(Edit, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         DebugDrawLifetime;                                 // 0x01B4(0x0004)(Edit, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bDebugDraw;                                        // 0x01B8(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bOctreeIsBuilt;                                    // 0x01B9(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_3120[0x6];                                     // 0x01BA(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzCoversComponent">();
	}
	static class UGzCoversComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzCoversComponent>();
	}
};
static_assert(alignof(UGzCoversComponent) == 0x000008, "Wrong alignment on UGzCoversComponent");
static_assert(sizeof(UGzCoversComponent) == 0x0001C0, "Wrong size on UGzCoversComponent");
static_assert(offsetof(UGzCoversComponent, DrawRadius) == 0x0001B0, "Member 'UGzCoversComponent::DrawRadius' has a wrong offset!");
static_assert(offsetof(UGzCoversComponent, DebugDrawLifetime) == 0x0001B4, "Member 'UGzCoversComponent::DebugDrawLifetime' has a wrong offset!");
static_assert(offsetof(UGzCoversComponent, bDebugDraw) == 0x0001B8, "Member 'UGzCoversComponent::bDebugDraw' has a wrong offset!");
static_assert(offsetof(UGzCoversComponent, bOctreeIsBuilt) == 0x0001B9, "Member 'UGzCoversComponent::bOctreeIsBuilt' has a wrong offset!");

// Class G01.GzHexExtractionReconstitutedMessage
// 0x0008 (0x0050 - 0x0048)
class UGzHexExtractionReconstitutedMessage final : public UGzHexExtractionHackBaseMessage
{
public:
	float                                         ExtractionProgressTime;                            // 0x0048(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3121[0x4];                                     // 0x004C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetExtractionProgressTime(const float Time);

	float GetExtractionProgressTime() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzHexExtractionReconstitutedMessage">();
	}
	static class UGzHexExtractionReconstitutedMessage* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzHexExtractionReconstitutedMessage>();
	}
};
static_assert(alignof(UGzHexExtractionReconstitutedMessage) == 0x000008, "Wrong alignment on UGzHexExtractionReconstitutedMessage");
static_assert(sizeof(UGzHexExtractionReconstitutedMessage) == 0x000050, "Wrong size on UGzHexExtractionReconstitutedMessage");
static_assert(offsetof(UGzHexExtractionReconstitutedMessage, ExtractionProgressTime) == 0x000048, "Member 'UGzHexExtractionReconstitutedMessage::ExtractionProgressTime' has a wrong offset!");

// Class G01.GzGameplayEffect
// 0x0000 (0x0A70 - 0x0A70)
class UGzGameplayEffect : public UGameplayEffect
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzGameplayEffect">();
	}
	static class UGzGameplayEffect* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzGameplayEffect>();
	}
};
static_assert(alignof(UGzGameplayEffect) == 0x000008, "Wrong alignment on UGzGameplayEffect");
static_assert(sizeof(UGzGameplayEffect) == 0x000A70, "Wrong size on UGzGameplayEffect");

// Class G01.GzGE_BaseDamage
// 0x0158 (0x0BC8 - 0x0A70)
class UGzGE_BaseDamage : public UGzGameplayEffect
{
public:
	struct FScalableFloat                         Damage;                                            // 0x0A70(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FScalableFloat                         AdditionalArmorDamage;                             // 0x0A98(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FScalableFloat                         HeadshotMultiplier;                                // 0x0AC0(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FScalableFloat                         ArmsMultiplier;                                    // 0x0AE8(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FScalableFloat                         LegsMultiplier;                                    // 0x0B10(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	class UCurveFloat*                            DistanceMultiplierCurve;                           // 0x0B38(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FScalableFloat                         VehicleMultiplier;                                 // 0x0B40(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FScalableFloat                         ArmorMultiplier;                                   // 0x0B68(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FGameplayTag                           DamageSource;                                      // 0x0B90(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, AssetRegistrySearchable, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FScalableFloat                         Impulse;                                           // 0x0B98(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	class UCurveFloat*                            ImpulseDistanceMultiplierCurve;                    // 0x0BC0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzGE_BaseDamage">();
	}
	static class UGzGE_BaseDamage* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzGE_BaseDamage>();
	}
};
static_assert(alignof(UGzGE_BaseDamage) == 0x000008, "Wrong alignment on UGzGE_BaseDamage");
static_assert(sizeof(UGzGE_BaseDamage) == 0x000BC8, "Wrong size on UGzGE_BaseDamage");
static_assert(offsetof(UGzGE_BaseDamage, Damage) == 0x000A70, "Member 'UGzGE_BaseDamage::Damage' has a wrong offset!");
static_assert(offsetof(UGzGE_BaseDamage, AdditionalArmorDamage) == 0x000A98, "Member 'UGzGE_BaseDamage::AdditionalArmorDamage' has a wrong offset!");
static_assert(offsetof(UGzGE_BaseDamage, HeadshotMultiplier) == 0x000AC0, "Member 'UGzGE_BaseDamage::HeadshotMultiplier' has a wrong offset!");
static_assert(offsetof(UGzGE_BaseDamage, ArmsMultiplier) == 0x000AE8, "Member 'UGzGE_BaseDamage::ArmsMultiplier' has a wrong offset!");
static_assert(offsetof(UGzGE_BaseDamage, LegsMultiplier) == 0x000B10, "Member 'UGzGE_BaseDamage::LegsMultiplier' has a wrong offset!");
static_assert(offsetof(UGzGE_BaseDamage, DistanceMultiplierCurve) == 0x000B38, "Member 'UGzGE_BaseDamage::DistanceMultiplierCurve' has a wrong offset!");
static_assert(offsetof(UGzGE_BaseDamage, VehicleMultiplier) == 0x000B40, "Member 'UGzGE_BaseDamage::VehicleMultiplier' has a wrong offset!");
static_assert(offsetof(UGzGE_BaseDamage, ArmorMultiplier) == 0x000B68, "Member 'UGzGE_BaseDamage::ArmorMultiplier' has a wrong offset!");
static_assert(offsetof(UGzGE_BaseDamage, DamageSource) == 0x000B90, "Member 'UGzGE_BaseDamage::DamageSource' has a wrong offset!");
static_assert(offsetof(UGzGE_BaseDamage, Impulse) == 0x000B98, "Member 'UGzGE_BaseDamage::Impulse' has a wrong offset!");
static_assert(offsetof(UGzGE_BaseDamage, ImpulseDistanceMultiplierCurve) == 0x000BC0, "Member 'UGzGE_BaseDamage::ImpulseDistanceMultiplierCurve' has a wrong offset!");

// Class G01.GzKillEffect
// 0x0000 (0x0BC8 - 0x0BC8)
class UGzKillEffect : public UGzGE_BaseDamage
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzKillEffect">();
	}
	static class UGzKillEffect* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzKillEffect>();
	}
};
static_assert(alignof(UGzKillEffect) == 0x000008, "Wrong alignment on UGzKillEffect");
static_assert(sizeof(UGzKillEffect) == 0x000BC8, "Wrong size on UGzKillEffect");

// Class G01.GzSuicideEffect
// 0x0000 (0x0BC8 - 0x0BC8)
class UGzSuicideEffect final : public UGzKillEffect
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzSuicideEffect">();
	}
	static class UGzSuicideEffect* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzSuicideEffect>();
	}
};
static_assert(alignof(UGzSuicideEffect) == 0x000008, "Wrong alignment on UGzSuicideEffect");
static_assert(sizeof(UGzSuicideEffect) == 0x000BC8, "Wrong size on UGzSuicideEffect");

// Class G01.GzCreatePartyHandler
// 0x0018 (0x0060 - 0x0048)
class UGzCreatePartyHandler final : public UGzSignalREvent
{
public:
	uint8                                         Pad_3122[0x18];                                    // 0x0048(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzCreatePartyHandler">();
	}
	static class UGzCreatePartyHandler* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzCreatePartyHandler>();
	}
};
static_assert(alignof(UGzCreatePartyHandler) == 0x000008, "Wrong alignment on UGzCreatePartyHandler");
static_assert(sizeof(UGzCreatePartyHandler) == 0x000060, "Wrong size on UGzCreatePartyHandler");

// Class G01.GzCriticalMessageActionHandler
// 0x0008 (0x0030 - 0x0028)
class UGzCriticalMessageActionHandler : public UObject
{
public:
	class UGzBackendManager*                      BackendManager;                                    // 0x0028(0x0008)(ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzCriticalMessageActionHandler">();
	}
	static class UGzCriticalMessageActionHandler* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzCriticalMessageActionHandler>();
	}
};
static_assert(alignof(UGzCriticalMessageActionHandler) == 0x000008, "Wrong alignment on UGzCriticalMessageActionHandler");
static_assert(sizeof(UGzCriticalMessageActionHandler) == 0x000030, "Wrong size on UGzCriticalMessageActionHandler");
static_assert(offsetof(UGzCriticalMessageActionHandler, BackendManager) == 0x000028, "Member 'UGzCriticalMessageActionHandler::BackendManager' has a wrong offset!");

// Class G01.GzCrosshair
// 0x0008 (0x02E8 - 0x02E0)
class UGzCrosshair : public UUserWidget
{
public:
	class APawn*                                  ViewTarget;                                        // 0x02E0(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void OnAdsUpdated(bool bIsInAds);
	void OnInit_BP();
	void OnLimbChanged(EGzLimbType LimbType);
	void OnReset_BP();

	void OnAimUpdated(const struct FVector& blockedLocation, bool bIsBlocked) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzCrosshair">();
	}
	static class UGzCrosshair* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzCrosshair>();
	}
};
static_assert(alignof(UGzCrosshair) == 0x000008, "Wrong alignment on UGzCrosshair");
static_assert(sizeof(UGzCrosshair) == 0x0002E8, "Wrong size on UGzCrosshair");
static_assert(offsetof(UGzCrosshair, ViewTarget) == 0x0002E0, "Member 'UGzCrosshair::ViewTarget' has a wrong offset!");

// Class G01.GzGameSettingCollection
// 0x0000 (0x0160 - 0x0160)
class UGzGameSettingCollection : public UGameSettingCollection
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzGameSettingCollection">();
	}
	static class UGzGameSettingCollection* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzGameSettingCollection>();
	}
};
static_assert(alignof(UGzGameSettingCollection) == 0x000008, "Wrong alignment on UGzGameSettingCollection");
static_assert(sizeof(UGzGameSettingCollection) == 0x000160, "Wrong size on UGzGameSettingCollection");

// Class G01.GzVideoSettingCollection
// 0x0000 (0x0160 - 0x0160)
class UGzVideoSettingCollection final : public UGzGameSettingCollection
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzVideoSettingCollection">();
	}
	static class UGzVideoSettingCollection* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzVideoSettingCollection>();
	}
};
static_assert(alignof(UGzVideoSettingCollection) == 0x000008, "Wrong alignment on UGzVideoSettingCollection");
static_assert(sizeof(UGzVideoSettingCollection) == 0x000160, "Wrong size on UGzVideoSettingCollection");

// Class G01.GzCrosshairLeaf
// 0x0008 (0x02E8 - 0x02E0)
class UGzCrosshairLeaf : public UUserWidget
{
public:
	float                                         DirectionAngle;                                    // 0x02E0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3124[0x4];                                     // 0x02E4(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzCrosshairLeaf">();
	}
	static class UGzCrosshairLeaf* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzCrosshairLeaf>();
	}
};
static_assert(alignof(UGzCrosshairLeaf) == 0x000008, "Wrong alignment on UGzCrosshairLeaf");
static_assert(sizeof(UGzCrosshairLeaf) == 0x0002E8, "Wrong size on UGzCrosshairLeaf");
static_assert(offsetof(UGzCrosshairLeaf, DirectionAngle) == 0x0002E0, "Member 'UGzCrosshairLeaf::DirectionAngle' has a wrong offset!");

// Class G01.GzCurrencyItemData
// 0x0008 (0x03D0 - 0x03C8)
class UGzCurrencyItemData final : public UGzSimpleItemData
{
public:
	double                                        Amount;                                            // 0x03C8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzCurrencyItemData">();
	}
	static class UGzCurrencyItemData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzCurrencyItemData>();
	}
};
static_assert(alignof(UGzCurrencyItemData) == 0x000008, "Wrong alignment on UGzCurrencyItemData");
static_assert(sizeof(UGzCurrencyItemData) == 0x0003D0, "Wrong size on UGzCurrencyItemData");
static_assert(offsetof(UGzCurrencyItemData, Amount) == 0x0003C8, "Member 'UGzCurrencyItemData::Amount' has a wrong offset!");

// Class G01.GzSA_OverlayCameraMode
// 0x0010 (0x0048 - 0x0038)
class UGzSA_OverlayCameraMode final : public UGzStateAction
{
public:
	struct FGameplayTag                           OverlayCameraModeTag;                              // 0x0038(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bApplyCameraModeWithInterpolation;                 // 0x0040(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3125[0x7];                                     // 0x0041(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzSA_OverlayCameraMode">();
	}
	static class UGzSA_OverlayCameraMode* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzSA_OverlayCameraMode>();
	}
};
static_assert(alignof(UGzSA_OverlayCameraMode) == 0x000008, "Wrong alignment on UGzSA_OverlayCameraMode");
static_assert(sizeof(UGzSA_OverlayCameraMode) == 0x000048, "Wrong size on UGzSA_OverlayCameraMode");
static_assert(offsetof(UGzSA_OverlayCameraMode, OverlayCameraModeTag) == 0x000038, "Member 'UGzSA_OverlayCameraMode::OverlayCameraModeTag' has a wrong offset!");
static_assert(offsetof(UGzSA_OverlayCameraMode, bApplyCameraModeWithInterpolation) == 0x000040, "Member 'UGzSA_OverlayCameraMode::bApplyCameraModeWithInterpolation' has a wrong offset!");

// Class G01.GzDashParamsData
// 0x0088 (0x00B8 - 0x0030)
class UGzDashParamsData final : public UDataAsset
{
public:
	struct FGzDashParams                          DashParams;                                        // 0x0030(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	EGzDashType                                   DashType;                                          // 0x0058(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUsesDynamicDistance;                              // 0x0059(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3126[0x2];                                     // 0x005A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         DashingMaxDistance;                                // 0x005C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DashingMaxSpeed;                                   // 0x0060(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DashingStopMaxSpeed;                               // 0x0064(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEnableGravity;                                    // 0x0068(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3127[0x7];                                     // 0x0069(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UCurveFloat*                            GravityMultiplierCurve;                            // 0x0070(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCurveFloat*                            DashingAccelerationCurve;                          // 0x0078(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bRedirectDashOnWalkableCollision;                  // 0x0080(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bResetVelocityOnFloorOnNoHit;                      // 0x0081(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUpdateJumpApexOnDashEnd;                          // 0x0082(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3128[0x1];                                     // 0x0083(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ImpactAbortAngle;                                  // 0x0084(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HomingVelocityCorrectionMagnitude;                 // 0x0088(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxHomingDistance;                                 // 0x008C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DistanceTriggerDistancePercentage;                 // 0x0090(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3129[0x4];                                     // 0x0094(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                TargetLocationOffset;                              // 0x0098(0x0018)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCurveFloat*                            TimeMappingCurve;                                  // 0x00B0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzDashParamsData">();
	}
	static class UGzDashParamsData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzDashParamsData>();
	}
};
static_assert(alignof(UGzDashParamsData) == 0x000008, "Wrong alignment on UGzDashParamsData");
static_assert(sizeof(UGzDashParamsData) == 0x0000B8, "Wrong size on UGzDashParamsData");
static_assert(offsetof(UGzDashParamsData, DashParams) == 0x000030, "Member 'UGzDashParamsData::DashParams' has a wrong offset!");
static_assert(offsetof(UGzDashParamsData, DashType) == 0x000058, "Member 'UGzDashParamsData::DashType' has a wrong offset!");
static_assert(offsetof(UGzDashParamsData, bUsesDynamicDistance) == 0x000059, "Member 'UGzDashParamsData::bUsesDynamicDistance' has a wrong offset!");
static_assert(offsetof(UGzDashParamsData, DashingMaxDistance) == 0x00005C, "Member 'UGzDashParamsData::DashingMaxDistance' has a wrong offset!");
static_assert(offsetof(UGzDashParamsData, DashingMaxSpeed) == 0x000060, "Member 'UGzDashParamsData::DashingMaxSpeed' has a wrong offset!");
static_assert(offsetof(UGzDashParamsData, DashingStopMaxSpeed) == 0x000064, "Member 'UGzDashParamsData::DashingStopMaxSpeed' has a wrong offset!");
static_assert(offsetof(UGzDashParamsData, bEnableGravity) == 0x000068, "Member 'UGzDashParamsData::bEnableGravity' has a wrong offset!");
static_assert(offsetof(UGzDashParamsData, GravityMultiplierCurve) == 0x000070, "Member 'UGzDashParamsData::GravityMultiplierCurve' has a wrong offset!");
static_assert(offsetof(UGzDashParamsData, DashingAccelerationCurve) == 0x000078, "Member 'UGzDashParamsData::DashingAccelerationCurve' has a wrong offset!");
static_assert(offsetof(UGzDashParamsData, bRedirectDashOnWalkableCollision) == 0x000080, "Member 'UGzDashParamsData::bRedirectDashOnWalkableCollision' has a wrong offset!");
static_assert(offsetof(UGzDashParamsData, bResetVelocityOnFloorOnNoHit) == 0x000081, "Member 'UGzDashParamsData::bResetVelocityOnFloorOnNoHit' has a wrong offset!");
static_assert(offsetof(UGzDashParamsData, bUpdateJumpApexOnDashEnd) == 0x000082, "Member 'UGzDashParamsData::bUpdateJumpApexOnDashEnd' has a wrong offset!");
static_assert(offsetof(UGzDashParamsData, ImpactAbortAngle) == 0x000084, "Member 'UGzDashParamsData::ImpactAbortAngle' has a wrong offset!");
static_assert(offsetof(UGzDashParamsData, HomingVelocityCorrectionMagnitude) == 0x000088, "Member 'UGzDashParamsData::HomingVelocityCorrectionMagnitude' has a wrong offset!");
static_assert(offsetof(UGzDashParamsData, MaxHomingDistance) == 0x00008C, "Member 'UGzDashParamsData::MaxHomingDistance' has a wrong offset!");
static_assert(offsetof(UGzDashParamsData, DistanceTriggerDistancePercentage) == 0x000090, "Member 'UGzDashParamsData::DistanceTriggerDistancePercentage' has a wrong offset!");
static_assert(offsetof(UGzDashParamsData, TargetLocationOffset) == 0x000098, "Member 'UGzDashParamsData::TargetLocationOffset' has a wrong offset!");
static_assert(offsetof(UGzDashParamsData, TimeMappingCurve) == 0x0000B0, "Member 'UGzDashParamsData::TimeMappingCurve' has a wrong offset!");

// Class G01.GzOrderLoadoutMessage
// 0x0008 (0x0030 - 0x0028)
class UGzOrderLoadoutMessage final : public UGzGameMessage
{
public:
	int32                                         PlayerId;                                          // 0x0028(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_312A[0x4];                                     // 0x002C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzOrderLoadoutMessage">();
	}
	static class UGzOrderLoadoutMessage* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzOrderLoadoutMessage>();
	}
};
static_assert(alignof(UGzOrderLoadoutMessage) == 0x000008, "Wrong alignment on UGzOrderLoadoutMessage");
static_assert(sizeof(UGzOrderLoadoutMessage) == 0x000030, "Wrong size on UGzOrderLoadoutMessage");
static_assert(offsetof(UGzOrderLoadoutMessage, PlayerId) == 0x000028, "Member 'UGzOrderLoadoutMessage::PlayerId' has a wrong offset!");

// Class G01.GzCustomizationEmoteComponent
// 0x00B8 (0x0158 - 0x00A0)
class UGzCustomizationEmoteComponent final : public UGzServiceComponent
{
public:
	uint8                                         Pad_312B[0xB8];                                    // 0x00A0(0x00B8)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzCustomizationEmoteComponent">();
	}
	static class UGzCustomizationEmoteComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzCustomizationEmoteComponent>();
	}
};
static_assert(alignof(UGzCustomizationEmoteComponent) == 0x000008, "Wrong alignment on UGzCustomizationEmoteComponent");
static_assert(sizeof(UGzCustomizationEmoteComponent) == 0x000158, "Wrong size on UGzCustomizationEmoteComponent");

// Class G01.GzCustomizationMetaSubsystem
// 0x0010 (0x0040 - 0x0030)
class UGzCustomizationMetaSubsystem final : public UGzMetaSubsystem
{
public:
	uint8                                         Pad_312C[0x10];                                    // 0x0030(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzCustomizationMetaSubsystem">();
	}
	static class UGzCustomizationMetaSubsystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzCustomizationMetaSubsystem>();
	}
};
static_assert(alignof(UGzCustomizationMetaSubsystem) == 0x000008, "Wrong alignment on UGzCustomizationMetaSubsystem");
static_assert(sizeof(UGzCustomizationMetaSubsystem) == 0x000040, "Wrong size on UGzCustomizationMetaSubsystem");

// Class G01.GzTeamStart
// 0x0008 (0x02D8 - 0x02D0)
class AGzTeamStart final : public APlayerStart
{
public:
	int32                                         TeamID;                                            // 0x02D0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bPreMatch : 1;                                     // 0x02D4(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, DisableEditOnTemplate, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_312D[0x3];                                     // 0x02D5(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzTeamStart">();
	}
	static class AGzTeamStart* GetDefaultObj()
	{
		return GetDefaultObjImpl<AGzTeamStart>();
	}
};
static_assert(alignof(AGzTeamStart) == 0x000008, "Wrong alignment on AGzTeamStart");
static_assert(sizeof(AGzTeamStart) == 0x0002D8, "Wrong size on AGzTeamStart");
static_assert(offsetof(AGzTeamStart, TeamID) == 0x0002D0, "Member 'AGzTeamStart::TeamID' has a wrong offset!");

// Class G01.GzCustomizationModifierFactory
// 0x0000 (0x0028 - 0x0028)
class UGzCustomizationModifierFactory final : public UObject
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzCustomizationModifierFactory">();
	}
	static class UGzCustomizationModifierFactory* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzCustomizationModifierFactory>();
	}
};
static_assert(alignof(UGzCustomizationModifierFactory) == 0x000008, "Wrong alignment on UGzCustomizationModifierFactory");
static_assert(sizeof(UGzCustomizationModifierFactory) == 0x000028, "Wrong size on UGzCustomizationModifierFactory");

// Class G01.Gz_BTTask_ActivateAbilityAndWaitForFinish
// 0x0090 (0x0100 - 0x0070)
class UGz_BTTask_ActivateAbilityAndWaitForFinish final : public UBTTaskNode
{
public:
	struct FGameplayTag                           AbilityTag;                                        // 0x0070(0x0008)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FBlackboardKeySelector                 OptionalObjectKey;                                 // 0x0078(0x0028)(Edit, NativeAccessSpecifierPrivate)
	struct FBlackboardKeySelector                 OptionalObject2Key;                                // 0x00A0(0x0028)(Edit, NativeAccessSpecifierPrivate)
	struct FBlackboardKeySelector                 TargetKey;                                         // 0x00C8(0x0028)(Edit, NativeAccessSpecifierPrivate)
	float                                         Timeout;                                           // 0x00F0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_312E[0xC];                                     // 0x00F4(0x000C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Gz_BTTask_ActivateAbilityAndWaitForFinish">();
	}
	static class UGz_BTTask_ActivateAbilityAndWaitForFinish* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGz_BTTask_ActivateAbilityAndWaitForFinish>();
	}
};
static_assert(alignof(UGz_BTTask_ActivateAbilityAndWaitForFinish) == 0x000008, "Wrong alignment on UGz_BTTask_ActivateAbilityAndWaitForFinish");
static_assert(sizeof(UGz_BTTask_ActivateAbilityAndWaitForFinish) == 0x000100, "Wrong size on UGz_BTTask_ActivateAbilityAndWaitForFinish");
static_assert(offsetof(UGz_BTTask_ActivateAbilityAndWaitForFinish, AbilityTag) == 0x000070, "Member 'UGz_BTTask_ActivateAbilityAndWaitForFinish::AbilityTag' has a wrong offset!");
static_assert(offsetof(UGz_BTTask_ActivateAbilityAndWaitForFinish, OptionalObjectKey) == 0x000078, "Member 'UGz_BTTask_ActivateAbilityAndWaitForFinish::OptionalObjectKey' has a wrong offset!");
static_assert(offsetof(UGz_BTTask_ActivateAbilityAndWaitForFinish, OptionalObject2Key) == 0x0000A0, "Member 'UGz_BTTask_ActivateAbilityAndWaitForFinish::OptionalObject2Key' has a wrong offset!");
static_assert(offsetof(UGz_BTTask_ActivateAbilityAndWaitForFinish, TargetKey) == 0x0000C8, "Member 'UGz_BTTask_ActivateAbilityAndWaitForFinish::TargetKey' has a wrong offset!");
static_assert(offsetof(UGz_BTTask_ActivateAbilityAndWaitForFinish, Timeout) == 0x0000F0, "Member 'UGz_BTTask_ActivateAbilityAndWaitForFinish::Timeout' has a wrong offset!");

// Class G01.GzWeaponAdsSystem
// 0x00A0 (0x00D8 - 0x0038)
class UGzWeaponAdsSystem final : public UGzWeaponSystemBase
{
public:
	TArray<class UGzWeaponADSModifier*>           ADSModifiers;                                      // 0x0038(0x0010)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	TArray<class UGzWeaponSensitivityModifier*>   SensitivityModifiers;                              // 0x0048(0x0010)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	class UGzWeaponScopeModifier*                 ScopeModifier;                                     // 0x0058(0x0008)(ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UGzADSDepthOfFieldModifier*             ADSDepthOfFieldModifier;                           // 0x0060(0x0008)(ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_312F[0x28];                                    // 0x0068(0x0028)(Fixing Size After Last Property [ Dumper-7 ])
	class AActor*                                 CachedScopeMeshActor;                              // 0x0090(0x0008)(ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USceneCaptureComponent2D*               CachedScopeSceneCaptureComponent;                  // 0x0098(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3130[0x8];                                     // 0x00A0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UMaterialInterface*                     BlendableToRemove;                                 // 0x00A8(0x0008)(ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3131[0x28];                                    // 0x00B0(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void UpdateScopeMeshLocation(float InFOV);

	int32 GetCurrenMagnification() const;
	const struct FGzScopeMode GetCurrentScopeMode() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzWeaponAdsSystem">();
	}
	static class UGzWeaponAdsSystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzWeaponAdsSystem>();
	}
};
static_assert(alignof(UGzWeaponAdsSystem) == 0x000008, "Wrong alignment on UGzWeaponAdsSystem");
static_assert(sizeof(UGzWeaponAdsSystem) == 0x0000D8, "Wrong size on UGzWeaponAdsSystem");
static_assert(offsetof(UGzWeaponAdsSystem, ADSModifiers) == 0x000038, "Member 'UGzWeaponAdsSystem::ADSModifiers' has a wrong offset!");
static_assert(offsetof(UGzWeaponAdsSystem, SensitivityModifiers) == 0x000048, "Member 'UGzWeaponAdsSystem::SensitivityModifiers' has a wrong offset!");
static_assert(offsetof(UGzWeaponAdsSystem, ScopeModifier) == 0x000058, "Member 'UGzWeaponAdsSystem::ScopeModifier' has a wrong offset!");
static_assert(offsetof(UGzWeaponAdsSystem, ADSDepthOfFieldModifier) == 0x000060, "Member 'UGzWeaponAdsSystem::ADSDepthOfFieldModifier' has a wrong offset!");
static_assert(offsetof(UGzWeaponAdsSystem, CachedScopeMeshActor) == 0x000090, "Member 'UGzWeaponAdsSystem::CachedScopeMeshActor' has a wrong offset!");
static_assert(offsetof(UGzWeaponAdsSystem, CachedScopeSceneCaptureComponent) == 0x000098, "Member 'UGzWeaponAdsSystem::CachedScopeSceneCaptureComponent' has a wrong offset!");
static_assert(offsetof(UGzWeaponAdsSystem, BlendableToRemove) == 0x0000A8, "Member 'UGzWeaponAdsSystem::BlendableToRemove' has a wrong offset!");

// Class G01.GzXR_PostMatchStage
// 0x0008 (0x0118 - 0x0110)
class UGzXR_PostMatchStage : public UGzGameStageBase
{
public:
	uint8                                         Pad_3132[0x8];                                     // 0x0110(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzXR_PostMatchStage">();
	}
	static class UGzXR_PostMatchStage* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzXR_PostMatchStage>();
	}
};
static_assert(alignof(UGzXR_PostMatchStage) == 0x000008, "Wrong alignment on UGzXR_PostMatchStage");
static_assert(sizeof(UGzXR_PostMatchStage) == 0x000118, "Wrong size on UGzXR_PostMatchStage");

// Class G01.GzHexExtractionCancelMessage
// 0x0010 (0x0058 - 0x0048)
class UGzHexExtractionCancelMessage final : public UGzHexExtractionHackBaseMessage
{
public:
	uint8                                         Pad_3133[0x10];                                    // 0x0048(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzHexExtractionCancelMessage">();
	}
	static class UGzHexExtractionCancelMessage* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzHexExtractionCancelMessage>();
	}
};
static_assert(alignof(UGzHexExtractionCancelMessage) == 0x000008, "Wrong alignment on UGzHexExtractionCancelMessage");
static_assert(sizeof(UGzHexExtractionCancelMessage) == 0x000058, "Wrong size on UGzHexExtractionCancelMessage");

// Class G01.GzCustomizationModifier_MaterialVector
// 0x0018 (0x0058 - 0x0040)
class UGzCustomizationModifier_MaterialVector final : public UGzCustomizationModifier_Material
{
public:
	struct FVector                                ParamValue;                                        // 0x0040(0x0018)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzCustomizationModifier_MaterialVector">();
	}
	static class UGzCustomizationModifier_MaterialVector* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzCustomizationModifier_MaterialVector>();
	}
};
static_assert(alignof(UGzCustomizationModifier_MaterialVector) == 0x000008, "Wrong alignment on UGzCustomizationModifier_MaterialVector");
static_assert(sizeof(UGzCustomizationModifier_MaterialVector) == 0x000058, "Wrong size on UGzCustomizationModifier_MaterialVector");
static_assert(offsetof(UGzCustomizationModifier_MaterialVector, ParamValue) == 0x000040, "Member 'UGzCustomizationModifier_MaterialVector::ParamValue' has a wrong offset!");

// Class G01.GzCustomizationModifier_MaterialColor
// 0x0008 (0x0048 - 0x0040)
class UGzCustomizationModifier_MaterialColor final : public UGzCustomizationModifier_Material
{
public:
	struct FColor                                 ParamValue;                                        // 0x0040(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3134[0x4];                                     // 0x0044(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzCustomizationModifier_MaterialColor">();
	}
	static class UGzCustomizationModifier_MaterialColor* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzCustomizationModifier_MaterialColor>();
	}
};
static_assert(alignof(UGzCustomizationModifier_MaterialColor) == 0x000008, "Wrong alignment on UGzCustomizationModifier_MaterialColor");
static_assert(sizeof(UGzCustomizationModifier_MaterialColor) == 0x000048, "Wrong size on UGzCustomizationModifier_MaterialColor");
static_assert(offsetof(UGzCustomizationModifier_MaterialColor, ParamValue) == 0x000040, "Member 'UGzCustomizationModifier_MaterialColor::ParamValue' has a wrong offset!");

// Class G01.GzVoiceChatModel
// 0x0010 (0x0080 - 0x0070)
class UGzVoiceChatModel final : public UGzBackendModel
{
public:
	uint8                                         Pad_3135[0x10];                                    // 0x0070(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzVoiceChatModel">();
	}
	static class UGzVoiceChatModel* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzVoiceChatModel>();
	}
};
static_assert(alignof(UGzVoiceChatModel) == 0x000008, "Wrong alignment on UGzVoiceChatModel");
static_assert(sizeof(UGzVoiceChatModel) == 0x000080, "Wrong size on UGzVoiceChatModel");

// Class G01.GzWeaponMovementModifier
// 0x0010 (0x0038 - 0x0028)
class UGzWeaponMovementModifier final : public UGzWeaponModifier
{
public:
	TSubclassOf<class UGzGE_MovementSpeedModifier> MovementEffect;                                    // 0x0028(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3136[0x8];                                     // 0x0030(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzWeaponMovementModifier">();
	}
	static class UGzWeaponMovementModifier* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzWeaponMovementModifier>();
	}
};
static_assert(alignof(UGzWeaponMovementModifier) == 0x000008, "Wrong alignment on UGzWeaponMovementModifier");
static_assert(sizeof(UGzWeaponMovementModifier) == 0x000038, "Wrong size on UGzWeaponMovementModifier");
static_assert(offsetof(UGzWeaponMovementModifier, MovementEffect) == 0x000028, "Member 'UGzWeaponMovementModifier::MovementEffect' has a wrong offset!");

// Class G01.GzHasMaterialModifier
// 0x0000 (0x0028 - 0x0028)
class IGzHasMaterialModifier final : public IInterface
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzHasMaterialModifier">();
	}
	static class IGzHasMaterialModifier* GetDefaultObj()
	{
		return GetDefaultObjImpl<IGzHasMaterialModifier>();
	}
};
static_assert(alignof(IGzHasMaterialModifier) == 0x000008, "Wrong alignment on IGzHasMaterialModifier");
static_assert(sizeof(IGzHasMaterialModifier) == 0x000028, "Wrong size on IGzHasMaterialModifier");

// Class G01.GzCustomizationModifierTemplate_MaterialVector
// 0x0048 (0x0118 - 0x00D0)
class UGzCustomizationModifierTemplate_MaterialVector final : public UGzCustomizationModifierTemplate_MaterialParam
{
public:
	struct FGzVectorRange                         ValueRange;                                        // 0x00D0(0x0030)(Edit, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	struct FVector                                DefaultValue;                                      // 0x0100(0x0018)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzCustomizationModifierTemplate_MaterialVector">();
	}
	static class UGzCustomizationModifierTemplate_MaterialVector* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzCustomizationModifierTemplate_MaterialVector>();
	}
};
static_assert(alignof(UGzCustomizationModifierTemplate_MaterialVector) == 0x000008, "Wrong alignment on UGzCustomizationModifierTemplate_MaterialVector");
static_assert(sizeof(UGzCustomizationModifierTemplate_MaterialVector) == 0x000118, "Wrong size on UGzCustomizationModifierTemplate_MaterialVector");
static_assert(offsetof(UGzCustomizationModifierTemplate_MaterialVector, ValueRange) == 0x0000D0, "Member 'UGzCustomizationModifierTemplate_MaterialVector::ValueRange' has a wrong offset!");
static_assert(offsetof(UGzCustomizationModifierTemplate_MaterialVector, DefaultValue) == 0x000100, "Member 'UGzCustomizationModifierTemplate_MaterialVector::DefaultValue' has a wrong offset!");

// Class G01.GzCustomizationModifierTemplate_MaterialColorPalette
// 0x0020 (0x00F0 - 0x00D0)
class UGzCustomizationModifierTemplate_MaterialColorPalette final : public UGzCustomizationModifierTemplate_MaterialParam
{
public:
	struct FGzColorPaletteContainer               ValueRange;                                        // 0x00D0(0x0008)(Edit, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         DefaultValue;                                      // 0x00D8(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3137[0x3];                                     // 0x00D9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FLinearColor                           ChosenValue;                                       // 0x00DC(0x0010)(Edit, ZeroConstructor, Transient, DisableEditOnInstance, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3138[0x4];                                     // 0x00EC(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzCustomizationModifierTemplate_MaterialColorPalette">();
	}
	static class UGzCustomizationModifierTemplate_MaterialColorPalette* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzCustomizationModifierTemplate_MaterialColorPalette>();
	}
};
static_assert(alignof(UGzCustomizationModifierTemplate_MaterialColorPalette) == 0x000008, "Wrong alignment on UGzCustomizationModifierTemplate_MaterialColorPalette");
static_assert(sizeof(UGzCustomizationModifierTemplate_MaterialColorPalette) == 0x0000F0, "Wrong size on UGzCustomizationModifierTemplate_MaterialColorPalette");
static_assert(offsetof(UGzCustomizationModifierTemplate_MaterialColorPalette, ValueRange) == 0x0000D0, "Member 'UGzCustomizationModifierTemplate_MaterialColorPalette::ValueRange' has a wrong offset!");
static_assert(offsetof(UGzCustomizationModifierTemplate_MaterialColorPalette, DefaultValue) == 0x0000D8, "Member 'UGzCustomizationModifierTemplate_MaterialColorPalette::DefaultValue' has a wrong offset!");
static_assert(offsetof(UGzCustomizationModifierTemplate_MaterialColorPalette, ChosenValue) == 0x0000DC, "Member 'UGzCustomizationModifierTemplate_MaterialColorPalette::ChosenValue' has a wrong offset!");

// Class G01.GzWeaponModifierInterface
// 0x0000 (0x0028 - 0x0028)
class IGzWeaponModifierInterface final : public IInterface
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzWeaponModifierInterface">();
	}
	static class IGzWeaponModifierInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IGzWeaponModifierInterface>();
	}
};
static_assert(alignof(IGzWeaponModifierInterface) == 0x000008, "Wrong alignment on IGzWeaponModifierInterface");
static_assert(sizeof(IGzWeaponModifierInterface) == 0x000028, "Wrong size on IGzWeaponModifierInterface");

// Class G01.GzCustomizationModifierTemplate_Scale
// 0x0048 (0x00F0 - 0x00A8)
class UGzCustomizationModifierTemplate_Scale final : public UGzCustomizationModifierTemplate
{
public:
	struct FGzVectorRange                         ValueRange;                                        // 0x00A8(0x0030)(Edit, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	struct FVector                                DefaultValue;                                      // 0x00D8(0x0018)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzCustomizationModifierTemplate_Scale">();
	}
	static class UGzCustomizationModifierTemplate_Scale* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzCustomizationModifierTemplate_Scale>();
	}
};
static_assert(alignof(UGzCustomizationModifierTemplate_Scale) == 0x000008, "Wrong alignment on UGzCustomizationModifierTemplate_Scale");
static_assert(sizeof(UGzCustomizationModifierTemplate_Scale) == 0x0000F0, "Wrong size on UGzCustomizationModifierTemplate_Scale");
static_assert(offsetof(UGzCustomizationModifierTemplate_Scale, ValueRange) == 0x0000A8, "Member 'UGzCustomizationModifierTemplate_Scale::ValueRange' has a wrong offset!");
static_assert(offsetof(UGzCustomizationModifierTemplate_Scale, DefaultValue) == 0x0000D8, "Member 'UGzCustomizationModifierTemplate_Scale::DefaultValue' has a wrong offset!");

// Class G01.GzInitialSettingsConfigurationState
// 0x0000 (0x0070 - 0x0070)
class UGzInitialSettingsConfigurationState final : public UGzFlowStateWithActionGraph
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzInitialSettingsConfigurationState">();
	}
	static class UGzInitialSettingsConfigurationState* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzInitialSettingsConfigurationState>();
	}
};
static_assert(alignof(UGzInitialSettingsConfigurationState) == 0x000008, "Wrong alignment on UGzInitialSettingsConfigurationState");
static_assert(sizeof(UGzInitialSettingsConfigurationState) == 0x000070, "Wrong size on UGzInitialSettingsConfigurationState");

// Class G01.GzShield
// 0x0010 (0x0310 - 0x0300)
class AGzShield : public AGzDamageableActor
{
public:
	uint8                                         Pad_3139[0x8];                                     // 0x0300(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bIgnoreTeamBullets;                                // 0x0308(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_313A[0x3];                                     // 0x0309(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         HitReactionMultiplier;                             // 0x030C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	void HandleHit(const bool bHitFromFront);
	void OnHealthChanged(const struct FGameplayEffectSpec& Spec, float Value);
	void SpawnBulletImpactVFX(const struct FVector& HitLocation);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzShield">();
	}
	static class AGzShield* GetDefaultObj()
	{
		return GetDefaultObjImpl<AGzShield>();
	}
};
static_assert(alignof(AGzShield) == 0x000008, "Wrong alignment on AGzShield");
static_assert(sizeof(AGzShield) == 0x000310, "Wrong size on AGzShield");
static_assert(offsetof(AGzShield, bIgnoreTeamBullets) == 0x000308, "Member 'AGzShield::bIgnoreTeamBullets' has a wrong offset!");
static_assert(offsetof(AGzShield, HitReactionMultiplier) == 0x00030C, "Member 'AGzShield::HitReactionMultiplier' has a wrong offset!");

// Class G01.GzThrowableShield
// 0x01B8 (0x04C8 - 0x0310)
class AGzThrowableShield final : public AGzShield
{
public:
	uint8                                         Pad_313C[0x18];                                    // 0x0310(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	class UStaticMeshComponent*                   ShieldMesh;                                        // 0x0328(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UGzProjectileMovementComponent*         MovementComponent;                                 // 0x0330(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USphereComponent*                       TargetingOverlapSphere;                            // 0x0338(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UGzThrowableShieldData*                 ShieldData;                                        // 0x0340(0x0008)(Net, ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EGzThrowableShieldState                       ShieldState;                                       // 0x0348(0x0001)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_313D[0x17F];                                   // 0x0349(0x017F)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void HandleShieldMeshBeginOverlap(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const struct FHitResult& SweepResul);
	void HandleTargetingSphereBeginOverlap(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const struct FHitResult& SweepResul);
	void HandleTargetingSphereEndOverlap(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex);
	void OnRep_ShieldState();

	class USceneComponent* GetInterpolatedComponent() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzThrowableShield">();
	}
	static class AGzThrowableShield* GetDefaultObj()
	{
		return GetDefaultObjImpl<AGzThrowableShield>();
	}
};
static_assert(alignof(AGzThrowableShield) == 0x000008, "Wrong alignment on AGzThrowableShield");
static_assert(sizeof(AGzThrowableShield) == 0x0004C8, "Wrong size on AGzThrowableShield");
static_assert(offsetof(AGzThrowableShield, ShieldMesh) == 0x000328, "Member 'AGzThrowableShield::ShieldMesh' has a wrong offset!");
static_assert(offsetof(AGzThrowableShield, MovementComponent) == 0x000330, "Member 'AGzThrowableShield::MovementComponent' has a wrong offset!");
static_assert(offsetof(AGzThrowableShield, TargetingOverlapSphere) == 0x000338, "Member 'AGzThrowableShield::TargetingOverlapSphere' has a wrong offset!");
static_assert(offsetof(AGzThrowableShield, ShieldData) == 0x000340, "Member 'AGzThrowableShield::ShieldData' has a wrong offset!");
static_assert(offsetof(AGzThrowableShield, ShieldState) == 0x000348, "Member 'AGzThrowableShield::ShieldState' has a wrong offset!");

// Class G01.GzCustomMatchmakingModel
// 0x0008 (0x0078 - 0x0070)
class UGzCustomMatchmakingModel final : public UGzBackendModel
{
public:
	uint8                                         Pad_3141[0x8];                                     // 0x0070(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzCustomMatchmakingModel">();
	}
	static class UGzCustomMatchmakingModel* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzCustomMatchmakingModel>();
	}
};
static_assert(alignof(UGzCustomMatchmakingModel) == 0x000008, "Wrong alignment on UGzCustomMatchmakingModel");
static_assert(sizeof(UGzCustomMatchmakingModel) == 0x000078, "Wrong size on UGzCustomMatchmakingModel");

// Class G01.GzItemExtractor
// 0x00B0 (0x03A8 - 0x02F8)
class AGzItemExtractor : public AGzBaseTerminal
{
public:
	uint8                                         Pad_3142[0x8];                                     // 0x02F8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	FMulticastInlineDelegateProperty_             OnExtractionDataChanged;                           // 0x0300(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	class FName                                   ExtractorId;                                       // 0x0310(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USceneComponent*                        ItemDropLocationComponent;                         // 0x0318(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FGzExtractionData                      ExtractionData;                                    // 0x0320(0x0040)(BlueprintVisible, Net, RepNotify, NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FGzExtractionData                      PreviousExtractionData;                            // 0x0360(0x0040)(BlueprintVisible, BlueprintReadOnly, NoDestructor, Protected, NativeAccessSpecifierProtected)
	float                                         HackingProgressMultiplier;                         // 0x03A0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3143[0x4];                                     // 0x03A4(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void CancelItemExtraction();
	void CompleteItemExtraction();
	void OnCancelItemExtraction();
	void OnCompleteItemExtraction();
	void OnExtractionEnded();
	void OnExtractionStateChanged();
	void OnHackItemExtraction();
	void OnPauseChanged();
	void OnRep_ExtractionData();
	void OnRestoreItemExtraction();
	void OnStartItemExtraction(class AGzPlayerState* Player, class UGzItemData* ItemData);
	void PostHexExtractionCancelMessage();
	void PostHexExtractionHackMessage();
	void PostHexExtractionReconstitutedMessage(const float ExtractionProgressTime);
	void RemoveHackingState();
	void SetHackingState(class AGzPlayerState* HackerPS);
	void SetPaused(bool bInPaused);
	void StartItemExtraction(class AGzPlayerState* Player, class UGzItemData* ItemData, const float ExtractTime);

	const struct FGzExtractionData GetExtractionData() const;
	TArray<struct FTransform> GetLocalHexItemTransforms() const;
	bool HasHexInside() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzItemExtractor">();
	}
	static class AGzItemExtractor* GetDefaultObj()
	{
		return GetDefaultObjImpl<AGzItemExtractor>();
	}
};
static_assert(alignof(AGzItemExtractor) == 0x000008, "Wrong alignment on AGzItemExtractor");
static_assert(sizeof(AGzItemExtractor) == 0x0003A8, "Wrong size on AGzItemExtractor");
static_assert(offsetof(AGzItemExtractor, OnExtractionDataChanged) == 0x000300, "Member 'AGzItemExtractor::OnExtractionDataChanged' has a wrong offset!");
static_assert(offsetof(AGzItemExtractor, ExtractorId) == 0x000310, "Member 'AGzItemExtractor::ExtractorId' has a wrong offset!");
static_assert(offsetof(AGzItemExtractor, ItemDropLocationComponent) == 0x000318, "Member 'AGzItemExtractor::ItemDropLocationComponent' has a wrong offset!");
static_assert(offsetof(AGzItemExtractor, ExtractionData) == 0x000320, "Member 'AGzItemExtractor::ExtractionData' has a wrong offset!");
static_assert(offsetof(AGzItemExtractor, PreviousExtractionData) == 0x000360, "Member 'AGzItemExtractor::PreviousExtractionData' has a wrong offset!");
static_assert(offsetof(AGzItemExtractor, HackingProgressMultiplier) == 0x0003A0, "Member 'AGzItemExtractor::HackingProgressMultiplier' has a wrong offset!");

// Class G01.GzCyberlimbFunctionLibrary
// 0x0000 (0x0028 - 0x0028)
class UGzCyberlimbFunctionLibrary final : public UBlueprintFunctionLibrary
{
public:
	static class FName GetHandSocketName(const EGzLimbType LimbType);
	static struct FGameplayAttribute GetLimbChargeAttribute(const EGzLimbType LimbType);
	static int32 GetLimbCurrentCharges(class AActor* AbilityOwner, const EGzLimbType LimbType);
	static int32 GetLimbMaxCharges(class AActor* AbilityOwner, const EGzLimbType LimbType);
	static struct FGameplayAttribute GetLimbMaxChargesAttribute(const EGzLimbType LimbType);
	static struct FGameplayTag GetLimbRechargeTag(const EGzLimbType LimbType);
	static class FName GetShoulderSocketName(const EGzLimbType LimbType);
	static bool IsLimbAtMaxCharges(class AActor* AbilityOwner, const EGzLimbType LimbType);
	static bool IsLimbRecharging(class AActor* AbilityOwner, const EGzLimbType LimbType);
	static bool StartDashing(class AGzCharacter* TargetCharacter, class UGzDashParamsData* DashParams, const struct FVector& TargetLocation, const struct FGameplayTagContainer& TagsToApply, class AActor* AimAssistTarget, const struct FVector& ExtraOverlapExtents, const struct FVector& ExtraOverlapOffset, class FName ExtraOverlapCollisionProfile, const bool bInResetVelocityAtEnd);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzCyberlimbFunctionLibrary">();
	}
	static class UGzCyberlimbFunctionLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzCyberlimbFunctionLibrary>();
	}
};
static_assert(alignof(UGzCyberlimbFunctionLibrary) == 0x000008, "Wrong alignment on UGzCyberlimbFunctionLibrary");
static_assert(sizeof(UGzCyberlimbFunctionLibrary) == 0x000028, "Wrong size on UGzCyberlimbFunctionLibrary");

// Class G01.GzDamageableArea
// 0x0000 (0x0028 - 0x0028)
class IGzDamageableArea final : public IInterface
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzDamageableArea">();
	}
	static class IGzDamageableArea* GetDefaultObj()
	{
		return GetDefaultObjImpl<IGzDamageableArea>();
	}
};
static_assert(alignof(IGzDamageableArea) == 0x000008, "Wrong alignment on IGzDamageableArea");
static_assert(sizeof(IGzDamageableArea) == 0x000028, "Wrong size on IGzDamageableArea");

// Class G01.GzDamageableAreasManager
// 0x0060 (0x0108 - 0x00A8)
class UGzDamageableAreasManager final : public UActorComponent
{
public:
	TArray<TScriptInterface<class IGzDamageableArea>> ExternalDamageableAreas;                           // 0x00A8(0x0010)(ZeroConstructor, Transient, UObjectWrapper, NativeAccessSpecifierPrivate)
	uint8                                         Pad_314F[0x50];                                    // 0x00B8(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzDamageableAreasManager">();
	}
	static class UGzDamageableAreasManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzDamageableAreasManager>();
	}
};
static_assert(alignof(UGzDamageableAreasManager) == 0x000008, "Wrong alignment on UGzDamageableAreasManager");
static_assert(sizeof(UGzDamageableAreasManager) == 0x000108, "Wrong size on UGzDamageableAreasManager");
static_assert(offsetof(UGzDamageableAreasManager, ExternalDamageableAreas) == 0x0000A8, "Member 'UGzDamageableAreasManager::ExternalDamageableAreas' has a wrong offset!");

// Class G01.GzImmunityGameplayEffectComponentByExecution
// 0x0020 (0x0048 - 0x0028)
class UGzImmunityGameplayEffectComponentByExecution final : public UGameplayEffectComponent
{
public:
	TArray<struct FGameplayEffectExecutionDefinition> ImmunityExecutionDefinitions;                      // 0x0028(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TArray<TSubclassOf<class UObject>>            AllowedEffectClasses;                              // 0x0038(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, UObjectWrapper, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzImmunityGameplayEffectComponentByExecution">();
	}
	static class UGzImmunityGameplayEffectComponentByExecution* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzImmunityGameplayEffectComponentByExecution>();
	}
};
static_assert(alignof(UGzImmunityGameplayEffectComponentByExecution) == 0x000008, "Wrong alignment on UGzImmunityGameplayEffectComponentByExecution");
static_assert(sizeof(UGzImmunityGameplayEffectComponentByExecution) == 0x000048, "Wrong size on UGzImmunityGameplayEffectComponentByExecution");
static_assert(offsetof(UGzImmunityGameplayEffectComponentByExecution, ImmunityExecutionDefinitions) == 0x000028, "Member 'UGzImmunityGameplayEffectComponentByExecution::ImmunityExecutionDefinitions' has a wrong offset!");
static_assert(offsetof(UGzImmunityGameplayEffectComponentByExecution, AllowedEffectClasses) == 0x000038, "Member 'UGzImmunityGameplayEffectComponentByExecution::AllowedEffectClasses' has a wrong offset!");

// Class G01.GzNegativeCondition
// 0x0000 (0x0060 - 0x0060)
class UGzNegativeCondition final : public UGzCondition
{
public:
	static class UGzCondition* MakeNegativeCondition(class AGzAdvancedMission* Mission);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzNegativeCondition">();
	}
	static class UGzNegativeCondition* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzNegativeCondition>();
	}
};
static_assert(alignof(UGzNegativeCondition) == 0x000008, "Wrong alignment on UGzNegativeCondition");
static_assert(sizeof(UGzNegativeCondition) == 0x000060, "Wrong size on UGzNegativeCondition");

// Class G01.GzHexSpawnedMessage
// 0x0008 (0x0038 - 0x0030)
class UGzHexSpawnedMessage final : public UGzInstigatedMessage
{
public:
	class FName                                   HexRarity;                                         // 0x0030(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzHexSpawnedMessage">();
	}
	static class UGzHexSpawnedMessage* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzHexSpawnedMessage>();
	}
};
static_assert(alignof(UGzHexSpawnedMessage) == 0x000008, "Wrong alignment on UGzHexSpawnedMessage");
static_assert(sizeof(UGzHexSpawnedMessage) == 0x000038, "Wrong size on UGzHexSpawnedMessage");
static_assert(offsetof(UGzHexSpawnedMessage, HexRarity) == 0x000030, "Member 'UGzHexSpawnedMessage::HexRarity' has a wrong offset!");

// Class G01.GzDamageableRepProxy
// 0x0048 (0x02E8 - 0x02A0)
class AGzDamageableRepProxy final : public AActor
{
public:
	TSoftObjectPtr<class AActor>                  DamageableVisualActor;                             // 0x02A0(0x0028)(Net, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint64                                        DamageableVisualActorId;                           // 0x02C8(0x0008)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FGzFastStaticDamageableItem>    Items;                                             // 0x02D0(0x0010)(Net, ZeroConstructor, RepNotify, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	uint8                                         Pad_3150[0x8];                                     // 0x02E0(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnRep_Items(const TArray<struct FGzFastStaticDamageableItem>& OldItems);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzDamageableRepProxy">();
	}
	static class AGzDamageableRepProxy* GetDefaultObj()
	{
		return GetDefaultObjImpl<AGzDamageableRepProxy>();
	}
};
static_assert(alignof(AGzDamageableRepProxy) == 0x000008, "Wrong alignment on AGzDamageableRepProxy");
static_assert(sizeof(AGzDamageableRepProxy) == 0x0002E8, "Wrong size on AGzDamageableRepProxy");
static_assert(offsetof(AGzDamageableRepProxy, DamageableVisualActor) == 0x0002A0, "Member 'AGzDamageableRepProxy::DamageableVisualActor' has a wrong offset!");
static_assert(offsetof(AGzDamageableRepProxy, DamageableVisualActorId) == 0x0002C8, "Member 'AGzDamageableRepProxy::DamageableVisualActorId' has a wrong offset!");
static_assert(offsetof(AGzDamageableRepProxy, Items) == 0x0002D0, "Member 'AGzDamageableRepProxy::Items' has a wrong offset!");

// Class G01.GzPreMatchDurationMessage
// 0x0008 (0x0030 - 0x0028)
class UGzPreMatchDurationMessage final : public UGzGameMessage
{
public:
	float                                         TotalDurationTime;                                 // 0x0028(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         PlayerId;                                          // 0x002C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzPreMatchDurationMessage">();
	}
	static class UGzPreMatchDurationMessage* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzPreMatchDurationMessage>();
	}
};
static_assert(alignof(UGzPreMatchDurationMessage) == 0x000008, "Wrong alignment on UGzPreMatchDurationMessage");
static_assert(sizeof(UGzPreMatchDurationMessage) == 0x000030, "Wrong size on UGzPreMatchDurationMessage");
static_assert(offsetof(UGzPreMatchDurationMessage, TotalDurationTime) == 0x000028, "Member 'UGzPreMatchDurationMessage::TotalDurationTime' has a wrong offset!");
static_assert(offsetof(UGzPreMatchDurationMessage, PlayerId) == 0x00002C, "Member 'UGzPreMatchDurationMessage::PlayerId' has a wrong offset!");

// Class G01.GzDamageableStaticMeshData
// 0x0010 (0x0040 - 0x0030)
class UGzDamageableStaticMeshData final : public UDataAsset
{
public:
	TArray<struct FGzDamageableStaticMeshConfig>  DamageableData;                                    // 0x0030(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzDamageableStaticMeshData">();
	}
	static class UGzDamageableStaticMeshData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzDamageableStaticMeshData>();
	}
};
static_assert(alignof(UGzDamageableStaticMeshData) == 0x000008, "Wrong alignment on UGzDamageableStaticMeshData");
static_assert(sizeof(UGzDamageableStaticMeshData) == 0x000040, "Wrong size on UGzDamageableStaticMeshData");
static_assert(offsetof(UGzDamageableStaticMeshData, DamageableData) == 0x000030, "Member 'UGzDamageableStaticMeshData::DamageableData' has a wrong offset!");

// Class G01.GzDamageExecutionCalculation
// 0x0000 (0x0040 - 0x0040)
class UGzDamageExecutionCalculation : public UGameplayEffectExecutionCalculation
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzDamageExecutionCalculation">();
	}
	static class UGzDamageExecutionCalculation* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzDamageExecutionCalculation>();
	}
};
static_assert(alignof(UGzDamageExecutionCalculation) == 0x000008, "Wrong alignment on UGzDamageExecutionCalculation");
static_assert(sizeof(UGzDamageExecutionCalculation) == 0x000040, "Wrong size on UGzDamageExecutionCalculation");

// Class G01.GzDamageHistorySubsystem
// 0x0098 (0x00C8 - 0x0030)
class UGzDamageHistorySubsystem final : public UGameInstanceSubsystem
{
public:
	FMulticastInlineDelegateProperty_             OnDamageRecordAdded_BP;                            // 0x0030(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_3151[0x30];                                    // 0x0040(0x0030)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<struct FGzDamageKey, struct FGzLimbDamage> AccumulatedLimbDamage;                             // 0x0070(0x0050)(Transient, NativeAccessSpecifierPrivate)
	float                                         FrequencyTime;                                     // 0x00C0(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_3152[0x4];                                     // 0x00C4(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzDamageHistorySubsystem">();
	}
	static class UGzDamageHistorySubsystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzDamageHistorySubsystem>();
	}
};
static_assert(alignof(UGzDamageHistorySubsystem) == 0x000008, "Wrong alignment on UGzDamageHistorySubsystem");
static_assert(sizeof(UGzDamageHistorySubsystem) == 0x0000C8, "Wrong size on UGzDamageHistorySubsystem");
static_assert(offsetof(UGzDamageHistorySubsystem, OnDamageRecordAdded_BP) == 0x000030, "Member 'UGzDamageHistorySubsystem::OnDamageRecordAdded_BP' has a wrong offset!");
static_assert(offsetof(UGzDamageHistorySubsystem, AccumulatedLimbDamage) == 0x000070, "Member 'UGzDamageHistorySubsystem::AccumulatedLimbDamage' has a wrong offset!");
static_assert(offsetof(UGzDamageHistorySubsystem, FrequencyTime) == 0x0000C0, "Member 'UGzDamageHistorySubsystem::FrequencyTime' has a wrong offset!");

// Class G01.GzGA_PullTowardsActor
// 0x0028 (0x0530 - 0x0508)
class UGzGA_PullTowardsActor : public UGzGameplayAbility
{
public:
	class UAnimMontage*                           PullMontageLeft;                                   // 0x0508(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAnimMontage*                           PullMontageRight;                                  // 0x0510(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAnimMontage*                           PullMontageForward;                                // 0x0518(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAnimMontage*                           PullMontageBackwards;                              // 0x0520(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class AActor*                                 PullSourceActor;                                   // 0x0528(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzGA_PullTowardsActor">();
	}
	static class UGzGA_PullTowardsActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzGA_PullTowardsActor>();
	}
};
static_assert(alignof(UGzGA_PullTowardsActor) == 0x000008, "Wrong alignment on UGzGA_PullTowardsActor");
static_assert(sizeof(UGzGA_PullTowardsActor) == 0x000530, "Wrong size on UGzGA_PullTowardsActor");
static_assert(offsetof(UGzGA_PullTowardsActor, PullMontageLeft) == 0x000508, "Member 'UGzGA_PullTowardsActor::PullMontageLeft' has a wrong offset!");
static_assert(offsetof(UGzGA_PullTowardsActor, PullMontageRight) == 0x000510, "Member 'UGzGA_PullTowardsActor::PullMontageRight' has a wrong offset!");
static_assert(offsetof(UGzGA_PullTowardsActor, PullMontageForward) == 0x000518, "Member 'UGzGA_PullTowardsActor::PullMontageForward' has a wrong offset!");
static_assert(offsetof(UGzGA_PullTowardsActor, PullMontageBackwards) == 0x000520, "Member 'UGzGA_PullTowardsActor::PullMontageBackwards' has a wrong offset!");
static_assert(offsetof(UGzGA_PullTowardsActor, PullSourceActor) == 0x000528, "Member 'UGzGA_PullTowardsActor::PullSourceActor' has a wrong offset!");

// Class G01.GzDamageIndicatorContainer
// 0x0100 (0x0440 - 0x0340)
class UGzDamageIndicatorContainer : public UGzHUDComponent
{
public:
	TSubclassOf<class UGzDamageIndicator>         IndicatorClass;                                    // 0x0340(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSet<struct FGameplayTag>                     AllowedSelfDamageSources;                          // 0x0348(0x0050)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	TMap<EGzDamageIndicatorType, int32>           IndicatorTypesPriority;                            // 0x0398(0x0050)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	float                                         IndicatorDisplayTime;                              // 0x03E8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3153[0x4];                                     // 0x03EC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<struct FGzDamageIndicatorKey, class UGzDamageIndicator*> CachedIndicators;                                  // 0x03F0(0x0050)(ExportObject, Transient, ContainsInstancedReference, NativeAccessSpecifierPrivate)

public:
	void AddIndicator(class UGzDamageIndicator* NewIndicator);
	void ClearIndicators();
	TSubclassOf<class UGzDamageIndicator> GetDamageIndicatorClass(const struct FGzDamageDirectionData& DamageData);
	void RemoveIndicator(class UGzDamageIndicator* DamageIndicator);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzDamageIndicatorContainer">();
	}
	static class UGzDamageIndicatorContainer* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzDamageIndicatorContainer>();
	}
};
static_assert(alignof(UGzDamageIndicatorContainer) == 0x000008, "Wrong alignment on UGzDamageIndicatorContainer");
static_assert(sizeof(UGzDamageIndicatorContainer) == 0x000440, "Wrong size on UGzDamageIndicatorContainer");
static_assert(offsetof(UGzDamageIndicatorContainer, IndicatorClass) == 0x000340, "Member 'UGzDamageIndicatorContainer::IndicatorClass' has a wrong offset!");
static_assert(offsetof(UGzDamageIndicatorContainer, AllowedSelfDamageSources) == 0x000348, "Member 'UGzDamageIndicatorContainer::AllowedSelfDamageSources' has a wrong offset!");
static_assert(offsetof(UGzDamageIndicatorContainer, IndicatorTypesPriority) == 0x000398, "Member 'UGzDamageIndicatorContainer::IndicatorTypesPriority' has a wrong offset!");
static_assert(offsetof(UGzDamageIndicatorContainer, IndicatorDisplayTime) == 0x0003E8, "Member 'UGzDamageIndicatorContainer::IndicatorDisplayTime' has a wrong offset!");
static_assert(offsetof(UGzDamageIndicatorContainer, CachedIndicators) == 0x0003F0, "Member 'UGzDamageIndicatorContainer::CachedIndicators' has a wrong offset!");

// Class G01.GzDamageSettings
// 0x0020 (0x0048 - 0x0028)
class UGzDamageSettings : public UObject
{
public:
	uint8                                         ArmorProtectionFlags;                              // 0x0028(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3154[0x3];                                     // 0x0029(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FColor                                 GridArmorDamageColor;                              // 0x002C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FColor                                 ArmorDamageColor;                                  // 0x0030(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FColor                                 BodyDamageColor;                                   // 0x0034(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FColor                                 LimbDamageColor;                                   // 0x0038(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FColor                                 VehicleDamageColor;                                // 0x003C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FColor                                 JetpackDamageColor;                                // 0x0040(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3155[0x4];                                     // 0x0044(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UGzDamageSettings* GetDamageSettings();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzDamageSettings">();
	}
	static class UGzDamageSettings* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzDamageSettings>();
	}
};
static_assert(alignof(UGzDamageSettings) == 0x000008, "Wrong alignment on UGzDamageSettings");
static_assert(sizeof(UGzDamageSettings) == 0x000048, "Wrong size on UGzDamageSettings");
static_assert(offsetof(UGzDamageSettings, ArmorProtectionFlags) == 0x000028, "Member 'UGzDamageSettings::ArmorProtectionFlags' has a wrong offset!");
static_assert(offsetof(UGzDamageSettings, GridArmorDamageColor) == 0x00002C, "Member 'UGzDamageSettings::GridArmorDamageColor' has a wrong offset!");
static_assert(offsetof(UGzDamageSettings, ArmorDamageColor) == 0x000030, "Member 'UGzDamageSettings::ArmorDamageColor' has a wrong offset!");
static_assert(offsetof(UGzDamageSettings, BodyDamageColor) == 0x000034, "Member 'UGzDamageSettings::BodyDamageColor' has a wrong offset!");
static_assert(offsetof(UGzDamageSettings, LimbDamageColor) == 0x000038, "Member 'UGzDamageSettings::LimbDamageColor' has a wrong offset!");
static_assert(offsetof(UGzDamageSettings, VehicleDamageColor) == 0x00003C, "Member 'UGzDamageSettings::VehicleDamageColor' has a wrong offset!");
static_assert(offsetof(UGzDamageSettings, JetpackDamageColor) == 0x000040, "Member 'UGzDamageSettings::JetpackDamageColor' has a wrong offset!");

// Class G01.GzDamageStatics
// 0x0000 (0x0028 - 0x0028)
class UGzDamageStatics final : public UBlueprintFunctionLibrary
{
public:
	static float GetBaseMultiHitDamage(const struct FGzMultiHitDamage& Damage);
	static float GetBaseSimpleHitDamage(const struct FGzSingleHitDamage& Damage);
	static TArray<class AActor*> MakeAreaAttack(const struct FGzAreaAttackParams& Params_0);
	static bool MakeTargetAttack(const struct FGzTargetAttackParams& Params_0);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzDamageStatics">();
	}
	static class UGzDamageStatics* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzDamageStatics>();
	}
};
static_assert(alignof(UGzDamageStatics) == 0x000008, "Wrong alignment on UGzDamageStatics");
static_assert(sizeof(UGzDamageStatics) == 0x000028, "Wrong size on UGzDamageStatics");

// Class G01.GzLimbStatics
// 0x0000 (0x0028 - 0x0028)
class UGzLimbStatics final : public UBlueprintFunctionLibrary
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzLimbStatics">();
	}
	static class UGzLimbStatics* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzLimbStatics>();
	}
};
static_assert(alignof(UGzLimbStatics) == 0x000008, "Wrong alignment on UGzLimbStatics");
static_assert(sizeof(UGzLimbStatics) == 0x000028, "Wrong size on UGzLimbStatics");

// Class G01.GzDatacubeDecoder
// 0x0040 (0x02E0 - 0x02A0)
class AGzDatacubeDecoder final : public AActor
{
public:
	uint8                                         Pad_3159[0x30];                                    // 0x02A0(0x0030)(Fixing Size After Last Property [ Dumper-7 ])
	class UGzContainerItemData*                   Datacube;                                          // 0x02D0(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bIsDecodeInProgress;                               // 0x02D8(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_315A[0x7];                                     // 0x02D9(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void FinalizeDecode();
	void ReceiveDatacubeSet();
	void ReceiveDecodeStarted();

	class UGzContainerItemData* GetDatacube() const;
	EGzItemRarity GetDatacubeRarity() const;
	bool IsDatacubeSet() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzDatacubeDecoder">();
	}
	static class AGzDatacubeDecoder* GetDefaultObj()
	{
		return GetDefaultObjImpl<AGzDatacubeDecoder>();
	}
};
static_assert(alignof(AGzDatacubeDecoder) == 0x000008, "Wrong alignment on AGzDatacubeDecoder");
static_assert(sizeof(AGzDatacubeDecoder) == 0x0002E0, "Wrong size on AGzDatacubeDecoder");
static_assert(offsetof(AGzDatacubeDecoder, Datacube) == 0x0002D0, "Member 'AGzDatacubeDecoder::Datacube' has a wrong offset!");
static_assert(offsetof(AGzDatacubeDecoder, bIsDecodeInProgress) == 0x0002D8, "Member 'AGzDatacubeDecoder::bIsDecodeInProgress' has a wrong offset!");

// Class G01.GzServerDiscoverySettings
// 0x0020 (0x0058 - 0x0038)
class UGzServerDiscoverySettings final : public UDeveloperSettings
{
public:
	class FString                                 DiscoveryUrl;                                      // 0x0038(0x0010)(ZeroConstructor, Config, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 DiscoverySecretKey;                                // 0x0048(0x0010)(ZeroConstructor, Config, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzServerDiscoverySettings">();
	}
	static class UGzServerDiscoverySettings* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzServerDiscoverySettings>();
	}
};
static_assert(alignof(UGzServerDiscoverySettings) == 0x000008, "Wrong alignment on UGzServerDiscoverySettings");
static_assert(sizeof(UGzServerDiscoverySettings) == 0x000058, "Wrong size on UGzServerDiscoverySettings");
static_assert(offsetof(UGzServerDiscoverySettings, DiscoveryUrl) == 0x000038, "Member 'UGzServerDiscoverySettings::DiscoveryUrl' has a wrong offset!");
static_assert(offsetof(UGzServerDiscoverySettings, DiscoverySecretKey) == 0x000048, "Member 'UGzServerDiscoverySettings::DiscoverySecretKey' has a wrong offset!");

// Class G01.GzDataCubeModel
// 0x0110 (0x0180 - 0x0070)
class UGzDataCubeModel final : public UGzBackendModel
{
public:
	uint8                                         Pad_315B[0x110];                                   // 0x0070(0x0110)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzDataCubeModel">();
	}
	static class UGzDataCubeModel* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzDataCubeModel>();
	}
};
static_assert(alignof(UGzDataCubeModel) == 0x000008, "Wrong alignment on UGzDataCubeModel");
static_assert(sizeof(UGzDataCubeModel) == 0x000180, "Wrong size on UGzDataCubeModel");

// Class G01.GzPropagationCollisionStrategy_TileToTile
// 0x0000 (0x0068 - 0x0068)
class UGzPropagationCollisionStrategy_TileToTile final : public UGzPropagationCollisionStrategy
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzPropagationCollisionStrategy_TileToTile">();
	}
	static class UGzPropagationCollisionStrategy_TileToTile* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzPropagationCollisionStrategy_TileToTile>();
	}
};
static_assert(alignof(UGzPropagationCollisionStrategy_TileToTile) == 0x000008, "Wrong alignment on UGzPropagationCollisionStrategy_TileToTile");
static_assert(sizeof(UGzPropagationCollisionStrategy_TileToTile) == 0x000068, "Wrong size on UGzPropagationCollisionStrategy_TileToTile");

// Class G01.GzTrialTracker
// 0x0010 (0x0038 - 0x0028)
class UGzTrialTracker : public UObject
{
public:
	int32                                         PlayerId;                                          // 0x0028(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_315C[0x4];                                     // 0x002C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UGzTrialTemplate*                       Template;                                          // 0x0030(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void OnTrackingStarted();

	void CommitProgress(const float ProgressMade) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzTrialTracker">();
	}
	static class UGzTrialTracker* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzTrialTracker>();
	}
};
static_assert(alignof(UGzTrialTracker) == 0x000008, "Wrong alignment on UGzTrialTracker");
static_assert(sizeof(UGzTrialTracker) == 0x000038, "Wrong size on UGzTrialTracker");
static_assert(offsetof(UGzTrialTracker, PlayerId) == 0x000028, "Member 'UGzTrialTracker::PlayerId' has a wrong offset!");
static_assert(offsetof(UGzTrialTracker, Template) == 0x000030, "Member 'UGzTrialTracker::Template' has a wrong offset!");

// Class G01.GzDealDamageTrialTracker
// 0x0018 (0x0050 - 0x0038)
class UGzDealDamageTrialTracker : public UGzTrialTracker
{
public:
	float                                         FlushInterval;                                     // 0x0038(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_315D[0x14];                                    // 0x003C(0x0014)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzDealDamageTrialTracker">();
	}
	static class UGzDealDamageTrialTracker* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzDealDamageTrialTracker>();
	}
};
static_assert(alignof(UGzDealDamageTrialTracker) == 0x000008, "Wrong alignment on UGzDealDamageTrialTracker");
static_assert(sizeof(UGzDealDamageTrialTracker) == 0x000050, "Wrong size on UGzDealDamageTrialTracker");
static_assert(offsetof(UGzDealDamageTrialTracker, FlushInterval) == 0x000038, "Member 'UGzDealDamageTrialTracker::FlushInterval' has a wrong offset!");

// Class G01.GzDeathMatchCheatManager
// 0x0000 (0x0150 - 0x0150)
class UGzDeathMatchCheatManager final : public UGzCheatManager
{
public:
	void RandomizeAllTeamsSpawn() const;
	void RandomizeMyTeamSpawn() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzDeathMatchCheatManager">();
	}
	static class UGzDeathMatchCheatManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzDeathMatchCheatManager>();
	}
};
static_assert(alignof(UGzDeathMatchCheatManager) == 0x000008, "Wrong alignment on UGzDeathMatchCheatManager");
static_assert(sizeof(UGzDeathMatchCheatManager) == 0x000150, "Wrong size on UGzDeathMatchCheatManager");

// Class G01.GzDeathMatchGameMode
// 0x0018 (0x0658 - 0x0640)
class AGzDeathMatchGameMode final : public AGzMultiStageGameMode
{
public:
	TArray<TSubclassOf<class UGzGameStageBase>>   PrepareForMatchClasses;                            // 0x0640(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, UObjectWrapper, NativeAccessSpecifierPublic)
	TSubclassOf<class UGzDM_MatchInProgressStage> MatchInProgressClass;                              // 0x0650(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzDeathMatchGameMode">();
	}
	static class AGzDeathMatchGameMode* GetDefaultObj()
	{
		return GetDefaultObjImpl<AGzDeathMatchGameMode>();
	}
};
static_assert(alignof(AGzDeathMatchGameMode) == 0x000008, "Wrong alignment on AGzDeathMatchGameMode");
static_assert(sizeof(AGzDeathMatchGameMode) == 0x000658, "Wrong size on AGzDeathMatchGameMode");
static_assert(offsetof(AGzDeathMatchGameMode, PrepareForMatchClasses) == 0x000640, "Member 'AGzDeathMatchGameMode::PrepareForMatchClasses' has a wrong offset!");
static_assert(offsetof(AGzDeathMatchGameMode, MatchInProgressClass) == 0x000650, "Member 'AGzDeathMatchGameMode::MatchInProgressClass' has a wrong offset!");

// Class G01.GzDeathMatchGameModeSettings
// 0x0040 (0x01B0 - 0x0170)
class UGzDeathMatchGameModeSettings final : public UGzSessionGameModeSettings
{
public:
	float                                         RespawnTimer;                                      // 0x0170(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUsePlayerStarts;                                  // 0x0174(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_315E[0x3];                                     // 0x0175(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         SpawnOffset;                                       // 0x0178(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SpawnHeight;                                       // 0x017C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxDistanceFromCenter;                             // 0x0180(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bRandomizeSpawnPointOnEachRestart;                 // 0x0184(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_315F[0x3];                                     // 0x0185(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftClassPtr<class UClass>                   BoundaryZoneClass;                                 // 0x0188(0x0028)(Edit, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzDeathMatchGameModeSettings">();
	}
	static class UGzDeathMatchGameModeSettings* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzDeathMatchGameModeSettings>();
	}
};
static_assert(alignof(UGzDeathMatchGameModeSettings) == 0x000008, "Wrong alignment on UGzDeathMatchGameModeSettings");
static_assert(sizeof(UGzDeathMatchGameModeSettings) == 0x0001B0, "Wrong size on UGzDeathMatchGameModeSettings");
static_assert(offsetof(UGzDeathMatchGameModeSettings, RespawnTimer) == 0x000170, "Member 'UGzDeathMatchGameModeSettings::RespawnTimer' has a wrong offset!");
static_assert(offsetof(UGzDeathMatchGameModeSettings, bUsePlayerStarts) == 0x000174, "Member 'UGzDeathMatchGameModeSettings::bUsePlayerStarts' has a wrong offset!");
static_assert(offsetof(UGzDeathMatchGameModeSettings, SpawnOffset) == 0x000178, "Member 'UGzDeathMatchGameModeSettings::SpawnOffset' has a wrong offset!");
static_assert(offsetof(UGzDeathMatchGameModeSettings, SpawnHeight) == 0x00017C, "Member 'UGzDeathMatchGameModeSettings::SpawnHeight' has a wrong offset!");
static_assert(offsetof(UGzDeathMatchGameModeSettings, MaxDistanceFromCenter) == 0x000180, "Member 'UGzDeathMatchGameModeSettings::MaxDistanceFromCenter' has a wrong offset!");
static_assert(offsetof(UGzDeathMatchGameModeSettings, bRandomizeSpawnPointOnEachRestart) == 0x000184, "Member 'UGzDeathMatchGameModeSettings::bRandomizeSpawnPointOnEachRestart' has a wrong offset!");
static_assert(offsetof(UGzDeathMatchGameModeSettings, BoundaryZoneClass) == 0x000188, "Member 'UGzDeathMatchGameModeSettings::BoundaryZoneClass' has a wrong offset!");

// Class G01.GzInventoryReviewStateComponent
// 0x0028 (0x00C8 - 0x00A0)
class UGzInventoryReviewStateComponent final : public UGzServiceComponent
{
public:
	uint8                                         Pad_3160[0x28];                                    // 0x00A0(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzInventoryReviewStateComponent">();
	}
	static class UGzInventoryReviewStateComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzInventoryReviewStateComponent>();
	}
};
static_assert(alignof(UGzInventoryReviewStateComponent) == 0x000008, "Wrong alignment on UGzInventoryReviewStateComponent");
static_assert(sizeof(UGzInventoryReviewStateComponent) == 0x0000C8, "Wrong size on UGzInventoryReviewStateComponent");

// Class G01.GzDeathRevealMarker
// 0x0008 (0x0320 - 0x0318)
class AGzDeathRevealMarker final : public AGzMarkerSceneContainer
{
public:
	int32                                         PlayerId;                                          // 0x0318(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3161[0x4];                                     // 0x031C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzDeathRevealMarker">();
	}
	static class AGzDeathRevealMarker* GetDefaultObj()
	{
		return GetDefaultObjImpl<AGzDeathRevealMarker>();
	}
};
static_assert(alignof(AGzDeathRevealMarker) == 0x000008, "Wrong alignment on AGzDeathRevealMarker");
static_assert(sizeof(AGzDeathRevealMarker) == 0x000320, "Wrong size on AGzDeathRevealMarker");
static_assert(offsetof(AGzDeathRevealMarker, PlayerId) == 0x000318, "Member 'AGzDeathRevealMarker::PlayerId' has a wrong offset!");

// Class G01.GzMissionData
// 0x0190 (0x01C0 - 0x0030)
class UGzMissionData : public UPrimaryDataAsset
{
public:
	uint8                                         Pad_3162[0x8];                                     // 0x0030(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	EGzMissionType                                Type;                                              // 0x0038(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3163[0x7];                                     // 0x0039(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   Name_GzMissionData;                                // 0x0040(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	class FText                                   Description;                                       // 0x0050(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UTexture2D>              Icon;                                              // 0x0060(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UTexture2D>              CompassIcon;                                       // 0x0088(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UTexture2D>              ViewportIcon;                                      // 0x00B0(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UTexture2D>              SearchZoneIcon;                                    // 0x00D8(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftClassPtr<class UClass>                   MissionClass;                                      // 0x0100(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftClassPtr<class UClass>                   MissionCreatorClass;                               // 0x0128(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDoNotNotifyOnMissionStart;                        // 0x0150(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDoNotNotifyOnMissionComplete;                     // 0x0151(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDoNotNotifyOnMissionFail;                         // 0x0152(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bOverrideMissionLogWidget;                         // 0x0153(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3164[0x4];                                     // 0x0154(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftClassPtr<class UClass>                   MissionLogWidgetClass;                             // 0x0158(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FGzMissionRewardWidgetData>     RewardWidgetData;                                  // 0x0180(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	bool                                          bIsSpecial;                                        // 0x0190(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EGzMissionGroupType                           GroupType;                                         // 0x0191(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3165[0x6];                                     // 0x0192(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class UGzMissionData*                         SupplementalMission;                               // 0x0198(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EGzMissionDuplicationPolicy                   MissionDuplicationPolicy;                          // 0x01A0(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          AccountCompletedMissionsForCreation;               // 0x01A1(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3166[0x6];                                     // 0x01A2(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FName>                           SupportedMapsList;                                 // 0x01A8(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	bool                                          bAllowLocalTest;                                   // 0x01B8(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3167[0x7];                                     // 0x01B9(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static TArray<class FName> GetMapAssetNames();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzMissionData">();
	}
	static class UGzMissionData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzMissionData>();
	}
};
static_assert(alignof(UGzMissionData) == 0x000008, "Wrong alignment on UGzMissionData");
static_assert(sizeof(UGzMissionData) == 0x0001C0, "Wrong size on UGzMissionData");
static_assert(offsetof(UGzMissionData, Type) == 0x000038, "Member 'UGzMissionData::Type' has a wrong offset!");
static_assert(offsetof(UGzMissionData, Name_GzMissionData) == 0x000040, "Member 'UGzMissionData::Name_GzMissionData' has a wrong offset!");
static_assert(offsetof(UGzMissionData, Description) == 0x000050, "Member 'UGzMissionData::Description' has a wrong offset!");
static_assert(offsetof(UGzMissionData, Icon) == 0x000060, "Member 'UGzMissionData::Icon' has a wrong offset!");
static_assert(offsetof(UGzMissionData, CompassIcon) == 0x000088, "Member 'UGzMissionData::CompassIcon' has a wrong offset!");
static_assert(offsetof(UGzMissionData, ViewportIcon) == 0x0000B0, "Member 'UGzMissionData::ViewportIcon' has a wrong offset!");
static_assert(offsetof(UGzMissionData, SearchZoneIcon) == 0x0000D8, "Member 'UGzMissionData::SearchZoneIcon' has a wrong offset!");
static_assert(offsetof(UGzMissionData, MissionClass) == 0x000100, "Member 'UGzMissionData::MissionClass' has a wrong offset!");
static_assert(offsetof(UGzMissionData, MissionCreatorClass) == 0x000128, "Member 'UGzMissionData::MissionCreatorClass' has a wrong offset!");
static_assert(offsetof(UGzMissionData, bDoNotNotifyOnMissionStart) == 0x000150, "Member 'UGzMissionData::bDoNotNotifyOnMissionStart' has a wrong offset!");
static_assert(offsetof(UGzMissionData, bDoNotNotifyOnMissionComplete) == 0x000151, "Member 'UGzMissionData::bDoNotNotifyOnMissionComplete' has a wrong offset!");
static_assert(offsetof(UGzMissionData, bDoNotNotifyOnMissionFail) == 0x000152, "Member 'UGzMissionData::bDoNotNotifyOnMissionFail' has a wrong offset!");
static_assert(offsetof(UGzMissionData, bOverrideMissionLogWidget) == 0x000153, "Member 'UGzMissionData::bOverrideMissionLogWidget' has a wrong offset!");
static_assert(offsetof(UGzMissionData, MissionLogWidgetClass) == 0x000158, "Member 'UGzMissionData::MissionLogWidgetClass' has a wrong offset!");
static_assert(offsetof(UGzMissionData, RewardWidgetData) == 0x000180, "Member 'UGzMissionData::RewardWidgetData' has a wrong offset!");
static_assert(offsetof(UGzMissionData, bIsSpecial) == 0x000190, "Member 'UGzMissionData::bIsSpecial' has a wrong offset!");
static_assert(offsetof(UGzMissionData, GroupType) == 0x000191, "Member 'UGzMissionData::GroupType' has a wrong offset!");
static_assert(offsetof(UGzMissionData, SupplementalMission) == 0x000198, "Member 'UGzMissionData::SupplementalMission' has a wrong offset!");
static_assert(offsetof(UGzMissionData, MissionDuplicationPolicy) == 0x0001A0, "Member 'UGzMissionData::MissionDuplicationPolicy' has a wrong offset!");
static_assert(offsetof(UGzMissionData, AccountCompletedMissionsForCreation) == 0x0001A1, "Member 'UGzMissionData::AccountCompletedMissionsForCreation' has a wrong offset!");
static_assert(offsetof(UGzMissionData, SupportedMapsList) == 0x0001A8, "Member 'UGzMissionData::SupportedMapsList' has a wrong offset!");
static_assert(offsetof(UGzMissionData, bAllowLocalTest) == 0x0001B8, "Member 'UGzMissionData::bAllowLocalTest' has a wrong offset!");

// Class G01.GzOpportunityMissionData
// 0x0008 (0x01C8 - 0x01C0)
class UGzOpportunityMissionData : public UGzMissionData
{
public:
	int32                                         AvailableMissionStageMin;                          // 0x01C0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         AvailableMissionStageMax;                          // 0x01C4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzOpportunityMissionData">();
	}
	static class UGzOpportunityMissionData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzOpportunityMissionData>();
	}
};
static_assert(alignof(UGzOpportunityMissionData) == 0x000008, "Wrong alignment on UGzOpportunityMissionData");
static_assert(sizeof(UGzOpportunityMissionData) == 0x0001C8, "Wrong size on UGzOpportunityMissionData");
static_assert(offsetof(UGzOpportunityMissionData, AvailableMissionStageMin) == 0x0001C0, "Member 'UGzOpportunityMissionData::AvailableMissionStageMin' has a wrong offset!");
static_assert(offsetof(UGzOpportunityMissionData, AvailableMissionStageMax) == 0x0001C4, "Member 'UGzOpportunityMissionData::AvailableMissionStageMax' has a wrong offset!");

// Class G01.GzDebugCameraController
// 0x0000 (0x0A18 - 0x0A18)
class AGzDebugCameraController final : public ADebugCameraController
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzDebugCameraController">();
	}
	static class AGzDebugCameraController* GetDefaultObj()
	{
		return GetDefaultObjImpl<AGzDebugCameraController>();
	}
};
static_assert(alignof(AGzDebugCameraController) == 0x000008, "Wrong alignment on AGzDebugCameraController");
static_assert(sizeof(AGzDebugCameraController) == 0x000A18, "Wrong size on AGzDebugCameraController");

// Class G01.GzPlinkService
// 0x0038 (0x00D8 - 0x00A0)
class UGzPlinkService final : public UGzClientPFObject
{
public:
	uint8                                         Pad_3168[0x38];                                    // 0x00A0(0x0038)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzPlinkService">();
	}
	static class UGzPlinkService* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzPlinkService>();
	}
};
static_assert(alignof(UGzPlinkService) == 0x000008, "Wrong alignment on UGzPlinkService");
static_assert(sizeof(UGzPlinkService) == 0x0000D8, "Wrong size on UGzPlinkService");

// Class G01.GzOnlineMatchManager
// 0x0090 (0x00C0 - 0x0030)
class UGzOnlineMatchManager final : public UGameInstanceSubsystem
{
public:
	uint8                                         Pad_3169[0x30];                                    // 0x0030(0x0030)(Fixing Size After Last Property [ Dumper-7 ])
	class UGzOnlineMatchRecoveryManager*          MatchRecoveryManager;                              // 0x0060(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UGzOnlineMatchJoinPreparationComponent* MatchJoinPreparationComponent;                     // 0x0068(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UGzPersistentMatchResult*               LastMatchResult;                                   // 0x0070(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_316A[0x48];                                    // 0x0078(0x0048)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void LeaveMatch();
	void OnNetworkFailure(class UWorld* World, class UNetDriver* NetDriver, ENetworkFailure Arg, const class FString& String);
	void OnTravelFailure(class UWorld* World, ETravelFailure Arg, const class FString& String);

	const struct FGzMatchResult GetLastMatchResult() const;
	bool HasLastMatchResult() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzOnlineMatchManager">();
	}
	static class UGzOnlineMatchManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzOnlineMatchManager>();
	}
};
static_assert(alignof(UGzOnlineMatchManager) == 0x000008, "Wrong alignment on UGzOnlineMatchManager");
static_assert(sizeof(UGzOnlineMatchManager) == 0x0000C0, "Wrong size on UGzOnlineMatchManager");
static_assert(offsetof(UGzOnlineMatchManager, MatchRecoveryManager) == 0x000060, "Member 'UGzOnlineMatchManager::MatchRecoveryManager' has a wrong offset!");
static_assert(offsetof(UGzOnlineMatchManager, MatchJoinPreparationComponent) == 0x000068, "Member 'UGzOnlineMatchManager::MatchJoinPreparationComponent' has a wrong offset!");
static_assert(offsetof(UGzOnlineMatchManager, LastMatchResult) == 0x000070, "Member 'UGzOnlineMatchManager::LastMatchResult' has a wrong offset!");

// Class G01.GzDebugCredentialsMaintainingComponent
// 0x00B8 (0x0158 - 0x00A0)
class UGzDebugCredentialsMaintainingComponent final : public UGzServiceComponent
{
public:
	struct FGzSavedCredentials                    SavedCredentials;                                  // 0x00A0(0x00B0)(NativeAccessSpecifierPrivate)
	uint8                                         Pad_316D[0x8];                                     // 0x0150(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzDebugCredentialsMaintainingComponent">();
	}
	static class UGzDebugCredentialsMaintainingComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzDebugCredentialsMaintainingComponent>();
	}
};
static_assert(alignof(UGzDebugCredentialsMaintainingComponent) == 0x000008, "Wrong alignment on UGzDebugCredentialsMaintainingComponent");
static_assert(sizeof(UGzDebugCredentialsMaintainingComponent) == 0x000158, "Wrong size on UGzDebugCredentialsMaintainingComponent");
static_assert(offsetof(UGzDebugCredentialsMaintainingComponent, SavedCredentials) == 0x0000A0, "Member 'UGzDebugCredentialsMaintainingComponent::SavedCredentials' has a wrong offset!");

// Class G01.GzLegacyCameraShake
// 0x0010 (0x0200 - 0x01F0)
class UGzLegacyCameraShake : public ULegacyCameraShake
{
public:
	float                                         StartXLocOscillation;                              // 0x01F0(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_316E[0xC];                                     // 0x01F4(0x000C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	class APlayerCameraManager* BlueprintGetCameraManager() const;
	float GetDefaultFOV() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzLegacyCameraShake">();
	}
	static class UGzLegacyCameraShake* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzLegacyCameraShake>();
	}
};
static_assert(alignof(UGzLegacyCameraShake) == 0x000010, "Wrong alignment on UGzLegacyCameraShake");
static_assert(sizeof(UGzLegacyCameraShake) == 0x000200, "Wrong size on UGzLegacyCameraShake");
static_assert(offsetof(UGzLegacyCameraShake, StartXLocOscillation) == 0x0001F0, "Member 'UGzLegacyCameraShake::StartXLocOscillation' has a wrong offset!");

// Class G01.GzDebugInfoWidget
// 0x0040 (0x0320 - 0x02E0)
class UGzDebugInfoWidget final : public UUserWidget
{
public:
	class UTextBlock*                             BuildStatsTextBlock;                               // 0x02E0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UTextBlock*                             RuntimeStatsTextBlock;                             // 0x02E8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UTextBlock*                             LocationStatsTextBlock;                            // 0x02F0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UTextBlock*                             PlayersCountStatsTextBlock;                        // 0x02F8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UTextBlock*                             ClientStateTextBlock;                              // 0x0300(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UTextBlock*                             MovePingTextBlock;                                 // 0x0308(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UTextBlock*                             MoveFloorTextBlock;                                // 0x0310(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UTextBlock*                             MoveInfoTextBlock;                                 // 0x0318(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzDebugInfoWidget">();
	}
	static class UGzDebugInfoWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzDebugInfoWidget>();
	}
};
static_assert(alignof(UGzDebugInfoWidget) == 0x000008, "Wrong alignment on UGzDebugInfoWidget");
static_assert(sizeof(UGzDebugInfoWidget) == 0x000320, "Wrong size on UGzDebugInfoWidget");
static_assert(offsetof(UGzDebugInfoWidget, BuildStatsTextBlock) == 0x0002E0, "Member 'UGzDebugInfoWidget::BuildStatsTextBlock' has a wrong offset!");
static_assert(offsetof(UGzDebugInfoWidget, RuntimeStatsTextBlock) == 0x0002E8, "Member 'UGzDebugInfoWidget::RuntimeStatsTextBlock' has a wrong offset!");
static_assert(offsetof(UGzDebugInfoWidget, LocationStatsTextBlock) == 0x0002F0, "Member 'UGzDebugInfoWidget::LocationStatsTextBlock' has a wrong offset!");
static_assert(offsetof(UGzDebugInfoWidget, PlayersCountStatsTextBlock) == 0x0002F8, "Member 'UGzDebugInfoWidget::PlayersCountStatsTextBlock' has a wrong offset!");
static_assert(offsetof(UGzDebugInfoWidget, ClientStateTextBlock) == 0x000300, "Member 'UGzDebugInfoWidget::ClientStateTextBlock' has a wrong offset!");
static_assert(offsetof(UGzDebugInfoWidget, MovePingTextBlock) == 0x000308, "Member 'UGzDebugInfoWidget::MovePingTextBlock' has a wrong offset!");
static_assert(offsetof(UGzDebugInfoWidget, MoveFloorTextBlock) == 0x000310, "Member 'UGzDebugInfoWidget::MoveFloorTextBlock' has a wrong offset!");
static_assert(offsetof(UGzDebugInfoWidget, MoveInfoTextBlock) == 0x000318, "Member 'UGzDebugInfoWidget::MoveInfoTextBlock' has a wrong offset!");

// Class G01.GzDebugMenuFunctionLibrary
// 0x0000 (0x0028 - 0x0028)
class UGzDebugMenuFunctionLibrary final : public UBlueprintFunctionLibrary
{
public:
	static bool GetBoolValue(const struct FGzDebugMenuVariableInfo& VariableInfo);
	static bool GetCategory(const class FString& Param_Name, struct FGzDebugMenuCategory* OutCategory);
	static float GetFloatValue(const struct FGzDebugMenuVariableInfo& VariableInfo);
	static int32 GetIntValue(const struct FGzDebugMenuVariableInfo& VariableInfo);
	static class FString GetStringValue(const struct FGzDebugMenuVariableInfo& VariableInfo);
	static void GetVariableInfo(const class FString& Param_Name, struct FGzDebugMenuVariableInfo* VariableInfoOut, bool* bExists);
	static bool IsBool(const class FString& Param_Name);
	static bool IsFloat(const class FString& Param_Name);
	static bool IsInt(const class FString& Param_Name);
	static bool IsString(const class FString& Param_Name);
	static struct FGzDebugMenuVariableInfo RegisterBoolVariable(const class FString& Param_Name, bool Value);
	static struct FGzDebugMenuVariableInfo RegisterFloatVariable(const class FString& Param_Name, float Value);
	static struct FGzDebugMenuVariableInfo RegisterIntVariable(const class FString& Param_Name, int32 Value);
	static struct FGzDebugMenuVariableInfo RegisterStringVariable(const class FString& Param_Name, const class FString& Value);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzDebugMenuFunctionLibrary">();
	}
	static class UGzDebugMenuFunctionLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzDebugMenuFunctionLibrary>();
	}
};
static_assert(alignof(UGzDebugMenuFunctionLibrary) == 0x000008, "Wrong alignment on UGzDebugMenuFunctionLibrary");
static_assert(sizeof(UGzDebugMenuFunctionLibrary) == 0x000028, "Wrong size on UGzDebugMenuFunctionLibrary");

// Class G01.GzDebugMenuItemComboBox
// 0x0060 (0x1E30 - 0x1DD0)
class UGzDebugMenuItemComboBox final : public UComboBoxString
{
public:
	EGzItemType                                   ItemType;                                          // 0x1DD0(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EGzLimbType                                   LimbType;                                          // 0x1DD1(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EGzItemRarity                                 SelectedRarity;                                    // 0x1DD2(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bShowHiddenItems;                                  // 0x1DD3(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_317B[0x5C];                                    // 0x1DD4(0x005C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void InitializeList(EGzItemType InItemType);
	void InitializeListForLimb(EGzItemType InItemType, EGzLimbType InLimbType);
	void SetItemRarity(EGzItemRarity Rarity);
	void SetShowHiddenItems(bool bShouldShow);

	const class UGzItemData* FindItemData(const class FString& Key) const;
	const class UGzItemData* GetSelectedItemData() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzDebugMenuItemComboBox">();
	}
	static class UGzDebugMenuItemComboBox* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzDebugMenuItemComboBox>();
	}
};
static_assert(alignof(UGzDebugMenuItemComboBox) == 0x000010, "Wrong alignment on UGzDebugMenuItemComboBox");
static_assert(sizeof(UGzDebugMenuItemComboBox) == 0x001E30, "Wrong size on UGzDebugMenuItemComboBox");
static_assert(offsetof(UGzDebugMenuItemComboBox, ItemType) == 0x001DD0, "Member 'UGzDebugMenuItemComboBox::ItemType' has a wrong offset!");
static_assert(offsetof(UGzDebugMenuItemComboBox, LimbType) == 0x001DD1, "Member 'UGzDebugMenuItemComboBox::LimbType' has a wrong offset!");
static_assert(offsetof(UGzDebugMenuItemComboBox, SelectedRarity) == 0x001DD2, "Member 'UGzDebugMenuItemComboBox::SelectedRarity' has a wrong offset!");
static_assert(offsetof(UGzDebugMenuItemComboBox, bShowHiddenItems) == 0x001DD3, "Member 'UGzDebugMenuItemComboBox::bShowHiddenItems' has a wrong offset!");

// Class G01.GzDebugMenuSubsystem
// 0x00D0 (0x0100 - 0x0030)
class UGzDebugMenuSubsystem final : public UEngineSubsystem
{
public:
	uint8                                         Pad_317C[0xD0];                                    // 0x0030(0x00D0)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzDebugMenuSubsystem">();
	}
	static class UGzDebugMenuSubsystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzDebugMenuSubsystem>();
	}
};
static_assert(alignof(UGzDebugMenuSubsystem) == 0x000008, "Wrong alignment on UGzDebugMenuSubsystem");
static_assert(sizeof(UGzDebugMenuSubsystem) == 0x000100, "Wrong size on UGzDebugMenuSubsystem");

// Class G01.GzDebugUISettings
// 0x0008 (0x0040 - 0x0038)
class UGzDebugUISettings final : public UDeveloperSettings
{
public:
	bool                                          bEnableDebugWidgetInEditor;                        // 0x0038(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_317D[0x7];                                     // 0x0039(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzDebugUISettings">();
	}
	static class UGzDebugUISettings* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzDebugUISettings>();
	}
};
static_assert(alignof(UGzDebugUISettings) == 0x000008, "Wrong alignment on UGzDebugUISettings");
static_assert(sizeof(UGzDebugUISettings) == 0x000040, "Wrong size on UGzDebugUISettings");
static_assert(offsetof(UGzDebugUISettings, bEnableDebugWidgetInEditor) == 0x000038, "Member 'UGzDebugUISettings::bEnableDebugWidgetInEditor' has a wrong offset!");

// Class G01.GzGA_MortarLegs
// 0x0238 (0x08B0 - 0x0678)
class UGzGA_MortarLegs : public UGzGA_BaseLimbAbility
{
public:
	class UGzPawnInputMappingConfig*              MortarInputConfig;                                 // 0x0678(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         CancelSpeedThreshold;                              // 0x0680(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   LaunchSocketName;                                  // 0x0684(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_317E[0x4];                                     // 0x068C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftClassPtr<class UClass>                   ProjectileClass;                                   // 0x0690(0x0028)(Edit, DisableEditOnInstance, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UGzGrenadeProjectileData*               ProjectileData;                                    // 0x06B8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         DelayBetweenShots;                                 // 0x06C0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ShootingAngle;                                     // 0x06C4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ObstacleTraceDistance;                             // 0x06C8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   ObstacleTraceCollisionProfile;                     // 0x06CC(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ScannerRoofCheckDistance;                          // 0x06D4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         PostTargetSelectionDelay;                          // 0x06D8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bShowFriendliesOnMap;                              // 0x06DC(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_317F[0x3];                                     // 0x06DD(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MapToWorldTraceMaxHeight;                          // 0x06E0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FGameplayTag                           ShootingCameraModeTag;                             // 0x06E4(0x0008)(Edit, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FGameplayTag                           CancelTargetingCameraModeTag;                      // 0x06EC(0x0008)(Edit, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3180[0x4];                                     // 0x06F4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftClassPtr<class UClass>                   ScannedTargetMarkerActorClass;                     // 0x06F8(0x0028)(Edit, DisableEditOnInstance, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAkAudioEvent*                          ObstacleFoundEvent;                                // 0x0720(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UGzMortarLegs_MapScreen*                MapScreenWidget;                                   // 0x0728(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UGzNavigationWidget*                    TabletMapOverlayWidget;                            // 0x0730(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UGzAT_ServerWaitForTargetData*          ServerWaitForTargetDataTask;                       // 0x0738(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UGzAT_MortarLegs_Scanner*               ScannerTask;                                       // 0x0740(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UGzAT_LimbAbilityMonitor*               MonitorLimbAbilityTask;                            // 0x0748(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UGzAT_MovementMonitor*                  MonitorMovementTask;                               // 0x0750(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3181[0x158];                                   // 0x0758(0x0158)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void HideMapScreenAndPrepareShooting();
	void Initialize();
	void OnLimbMonitorEvent();
	void OnScanFinished();
	void OnScanStarted();
	void OnScanUpdate(const float NewProgress);
	void OnShootingFinished();
	void OnTargetingCancelled();
	void OnTargetSelectionFinished();
	void ReceiveTargetData(const struct FGameplayAbilityTargetDataHandle& TargetData);
	void SendWorldTargetsToServer();
	void ShowMapScreen();
	void SpawnProjectile();
	void StartShooting();
	void WaitNetSyncForAnimationFinished();
	void WaitNetSyncForShooting();
	void WaitNetSyncForShootingFinished();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzGA_MortarLegs">();
	}
	static class UGzGA_MortarLegs* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzGA_MortarLegs>();
	}
};
static_assert(alignof(UGzGA_MortarLegs) == 0x000008, "Wrong alignment on UGzGA_MortarLegs");
static_assert(sizeof(UGzGA_MortarLegs) == 0x0008B0, "Wrong size on UGzGA_MortarLegs");
static_assert(offsetof(UGzGA_MortarLegs, MortarInputConfig) == 0x000678, "Member 'UGzGA_MortarLegs::MortarInputConfig' has a wrong offset!");
static_assert(offsetof(UGzGA_MortarLegs, CancelSpeedThreshold) == 0x000680, "Member 'UGzGA_MortarLegs::CancelSpeedThreshold' has a wrong offset!");
static_assert(offsetof(UGzGA_MortarLegs, LaunchSocketName) == 0x000684, "Member 'UGzGA_MortarLegs::LaunchSocketName' has a wrong offset!");
static_assert(offsetof(UGzGA_MortarLegs, ProjectileClass) == 0x000690, "Member 'UGzGA_MortarLegs::ProjectileClass' has a wrong offset!");
static_assert(offsetof(UGzGA_MortarLegs, ProjectileData) == 0x0006B8, "Member 'UGzGA_MortarLegs::ProjectileData' has a wrong offset!");
static_assert(offsetof(UGzGA_MortarLegs, DelayBetweenShots) == 0x0006C0, "Member 'UGzGA_MortarLegs::DelayBetweenShots' has a wrong offset!");
static_assert(offsetof(UGzGA_MortarLegs, ShootingAngle) == 0x0006C4, "Member 'UGzGA_MortarLegs::ShootingAngle' has a wrong offset!");
static_assert(offsetof(UGzGA_MortarLegs, ObstacleTraceDistance) == 0x0006C8, "Member 'UGzGA_MortarLegs::ObstacleTraceDistance' has a wrong offset!");
static_assert(offsetof(UGzGA_MortarLegs, ObstacleTraceCollisionProfile) == 0x0006CC, "Member 'UGzGA_MortarLegs::ObstacleTraceCollisionProfile' has a wrong offset!");
static_assert(offsetof(UGzGA_MortarLegs, ScannerRoofCheckDistance) == 0x0006D4, "Member 'UGzGA_MortarLegs::ScannerRoofCheckDistance' has a wrong offset!");
static_assert(offsetof(UGzGA_MortarLegs, PostTargetSelectionDelay) == 0x0006D8, "Member 'UGzGA_MortarLegs::PostTargetSelectionDelay' has a wrong offset!");
static_assert(offsetof(UGzGA_MortarLegs, bShowFriendliesOnMap) == 0x0006DC, "Member 'UGzGA_MortarLegs::bShowFriendliesOnMap' has a wrong offset!");
static_assert(offsetof(UGzGA_MortarLegs, MapToWorldTraceMaxHeight) == 0x0006E0, "Member 'UGzGA_MortarLegs::MapToWorldTraceMaxHeight' has a wrong offset!");
static_assert(offsetof(UGzGA_MortarLegs, ShootingCameraModeTag) == 0x0006E4, "Member 'UGzGA_MortarLegs::ShootingCameraModeTag' has a wrong offset!");
static_assert(offsetof(UGzGA_MortarLegs, CancelTargetingCameraModeTag) == 0x0006EC, "Member 'UGzGA_MortarLegs::CancelTargetingCameraModeTag' has a wrong offset!");
static_assert(offsetof(UGzGA_MortarLegs, ScannedTargetMarkerActorClass) == 0x0006F8, "Member 'UGzGA_MortarLegs::ScannedTargetMarkerActorClass' has a wrong offset!");
static_assert(offsetof(UGzGA_MortarLegs, ObstacleFoundEvent) == 0x000720, "Member 'UGzGA_MortarLegs::ObstacleFoundEvent' has a wrong offset!");
static_assert(offsetof(UGzGA_MortarLegs, MapScreenWidget) == 0x000728, "Member 'UGzGA_MortarLegs::MapScreenWidget' has a wrong offset!");
static_assert(offsetof(UGzGA_MortarLegs, TabletMapOverlayWidget) == 0x000730, "Member 'UGzGA_MortarLegs::TabletMapOverlayWidget' has a wrong offset!");
static_assert(offsetof(UGzGA_MortarLegs, ServerWaitForTargetDataTask) == 0x000738, "Member 'UGzGA_MortarLegs::ServerWaitForTargetDataTask' has a wrong offset!");
static_assert(offsetof(UGzGA_MortarLegs, ScannerTask) == 0x000740, "Member 'UGzGA_MortarLegs::ScannerTask' has a wrong offset!");
static_assert(offsetof(UGzGA_MortarLegs, MonitorLimbAbilityTask) == 0x000748, "Member 'UGzGA_MortarLegs::MonitorLimbAbilityTask' has a wrong offset!");
static_assert(offsetof(UGzGA_MortarLegs, MonitorMovementTask) == 0x000750, "Member 'UGzGA_MortarLegs::MonitorMovementTask' has a wrong offset!");

// Class G01.GzSpiderMine_PreviewComponent
// 0x01F8 (0x02E8 - 0x00F0)
class UGzSpiderMine_PreviewComponent : public UGzLimbAbilityComponent
{
public:
	class AGzMultiPartCharacter*                  AsGzMultipartCharacter;                            // 0x00F0(0x0008)(BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxPlacementDistance;                              // 0x00F8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3182[0x4];                                     // 0x00FC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class AGzSpiderMine_PreviewActor*             SpiderMinePreviewActor;                            // 0x0100(0x0008)(BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 SpiderMineLinkPreviewActor;                        // 0x0108(0x0008)(BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         CurrentActiveMines;                                // 0x0110(0x0004)(BlueprintVisible, Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxLinkLength;                                     // 0x0114(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaxActiveMines;                                    // 0x0118(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3183[0x4];                                     // 0x011C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class AGzSpiderMine*                          SpiderMineToLinkTo;                                // 0x0120(0x0008)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnMineCountChanged;                                // 0x0128(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnValidChanged;                                    // 0x0138(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnComponentEndPlayCalled;                          // 0x0148(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	struct FHitResult                             ViewHitResult;                                     // 0x0158(0x00F8)(BlueprintVisible, BlueprintReadOnly, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	uint8                                         Pad_3184[0x10];                                    // 0x0250(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   SocketHandR;                                       // 0x0260(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FName                                   SocketHandL;                                       // 0x0268(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FGameplayTag                           MineTriggeredTag;                                  // 0x0270(0x0008)(Edit, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         MineTriggeredUIDuration;                           // 0x0278(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_3185[0x4];                                     // 0x027C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UAkAudioEvent*                          ReloadSound;                                       // 0x0280(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<ECollisionChannel>                     ValidPlacementObjectTypes;                         // 0x0288(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	float                                         ServerNoAnimationLengthOffset;                     // 0x0298(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_3186[0x4];                                     // 0x029C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<ECollisionChannel>                     ValidObjects;                                      // 0x02A0(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	class UAkAudioEvent*                          MineAudioEvent;                                    // 0x02B0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<EObjectTypeQuery>                      LinkTraceTypes;                                    // 0x02B8(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPrivate)
	uint8                                         Pad_3187[0x20];                                    // 0x02C8(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void DestroyWidget();
	void OnRep_CurrentActiveMines();
	void PlayClientShootFX();
	void SetPreviewEnabled();
	void SpawnSpiderMine_PreviewActor();
	void UpdateLinkPreviewActor(bool bCanShow, bool bValid, const struct FVector& Start, const struct FVector& End);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzSpiderMine_PreviewComponent">();
	}
	static class UGzSpiderMine_PreviewComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzSpiderMine_PreviewComponent>();
	}
};
static_assert(alignof(UGzSpiderMine_PreviewComponent) == 0x000008, "Wrong alignment on UGzSpiderMine_PreviewComponent");
static_assert(sizeof(UGzSpiderMine_PreviewComponent) == 0x0002E8, "Wrong size on UGzSpiderMine_PreviewComponent");
static_assert(offsetof(UGzSpiderMine_PreviewComponent, AsGzMultipartCharacter) == 0x0000F0, "Member 'UGzSpiderMine_PreviewComponent::AsGzMultipartCharacter' has a wrong offset!");
static_assert(offsetof(UGzSpiderMine_PreviewComponent, MaxPlacementDistance) == 0x0000F8, "Member 'UGzSpiderMine_PreviewComponent::MaxPlacementDistance' has a wrong offset!");
static_assert(offsetof(UGzSpiderMine_PreviewComponent, SpiderMinePreviewActor) == 0x000100, "Member 'UGzSpiderMine_PreviewComponent::SpiderMinePreviewActor' has a wrong offset!");
static_assert(offsetof(UGzSpiderMine_PreviewComponent, SpiderMineLinkPreviewActor) == 0x000108, "Member 'UGzSpiderMine_PreviewComponent::SpiderMineLinkPreviewActor' has a wrong offset!");
static_assert(offsetof(UGzSpiderMine_PreviewComponent, CurrentActiveMines) == 0x000110, "Member 'UGzSpiderMine_PreviewComponent::CurrentActiveMines' has a wrong offset!");
static_assert(offsetof(UGzSpiderMine_PreviewComponent, MaxLinkLength) == 0x000114, "Member 'UGzSpiderMine_PreviewComponent::MaxLinkLength' has a wrong offset!");
static_assert(offsetof(UGzSpiderMine_PreviewComponent, MaxActiveMines) == 0x000118, "Member 'UGzSpiderMine_PreviewComponent::MaxActiveMines' has a wrong offset!");
static_assert(offsetof(UGzSpiderMine_PreviewComponent, SpiderMineToLinkTo) == 0x000120, "Member 'UGzSpiderMine_PreviewComponent::SpiderMineToLinkTo' has a wrong offset!");
static_assert(offsetof(UGzSpiderMine_PreviewComponent, OnMineCountChanged) == 0x000128, "Member 'UGzSpiderMine_PreviewComponent::OnMineCountChanged' has a wrong offset!");
static_assert(offsetof(UGzSpiderMine_PreviewComponent, OnValidChanged) == 0x000138, "Member 'UGzSpiderMine_PreviewComponent::OnValidChanged' has a wrong offset!");
static_assert(offsetof(UGzSpiderMine_PreviewComponent, OnComponentEndPlayCalled) == 0x000148, "Member 'UGzSpiderMine_PreviewComponent::OnComponentEndPlayCalled' has a wrong offset!");
static_assert(offsetof(UGzSpiderMine_PreviewComponent, ViewHitResult) == 0x000158, "Member 'UGzSpiderMine_PreviewComponent::ViewHitResult' has a wrong offset!");
static_assert(offsetof(UGzSpiderMine_PreviewComponent, SocketHandR) == 0x000260, "Member 'UGzSpiderMine_PreviewComponent::SocketHandR' has a wrong offset!");
static_assert(offsetof(UGzSpiderMine_PreviewComponent, SocketHandL) == 0x000268, "Member 'UGzSpiderMine_PreviewComponent::SocketHandL' has a wrong offset!");
static_assert(offsetof(UGzSpiderMine_PreviewComponent, MineTriggeredTag) == 0x000270, "Member 'UGzSpiderMine_PreviewComponent::MineTriggeredTag' has a wrong offset!");
static_assert(offsetof(UGzSpiderMine_PreviewComponent, MineTriggeredUIDuration) == 0x000278, "Member 'UGzSpiderMine_PreviewComponent::MineTriggeredUIDuration' has a wrong offset!");
static_assert(offsetof(UGzSpiderMine_PreviewComponent, ReloadSound) == 0x000280, "Member 'UGzSpiderMine_PreviewComponent::ReloadSound' has a wrong offset!");
static_assert(offsetof(UGzSpiderMine_PreviewComponent, ValidPlacementObjectTypes) == 0x000288, "Member 'UGzSpiderMine_PreviewComponent::ValidPlacementObjectTypes' has a wrong offset!");
static_assert(offsetof(UGzSpiderMine_PreviewComponent, ServerNoAnimationLengthOffset) == 0x000298, "Member 'UGzSpiderMine_PreviewComponent::ServerNoAnimationLengthOffset' has a wrong offset!");
static_assert(offsetof(UGzSpiderMine_PreviewComponent, ValidObjects) == 0x0002A0, "Member 'UGzSpiderMine_PreviewComponent::ValidObjects' has a wrong offset!");
static_assert(offsetof(UGzSpiderMine_PreviewComponent, MineAudioEvent) == 0x0002B0, "Member 'UGzSpiderMine_PreviewComponent::MineAudioEvent' has a wrong offset!");
static_assert(offsetof(UGzSpiderMine_PreviewComponent, LinkTraceTypes) == 0x0002B8, "Member 'UGzSpiderMine_PreviewComponent::LinkTraceTypes' has a wrong offset!");

// Class G01.GzDecoratorCondition
// 0x0008 (0x0068 - 0x0060)
class UGzDecoratorCondition : public UGzCondition
{
public:
	class UGzCondition*                           WrappedCondition;                                  // 0x0060(0x0008)(ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzDecoratorCondition">();
	}
	static class UGzDecoratorCondition* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzDecoratorCondition>();
	}
};
static_assert(alignof(UGzDecoratorCondition) == 0x000008, "Wrong alignment on UGzDecoratorCondition");
static_assert(sizeof(UGzDecoratorCondition) == 0x000068, "Wrong size on UGzDecoratorCondition");
static_assert(offsetof(UGzDecoratorCondition, WrappedCondition) == 0x000060, "Member 'UGzDecoratorCondition::WrappedCondition' has a wrong offset!");

// Class G01.GzOnlineMatchJoinPreparationComponent
// 0x0058 (0x0080 - 0x0028)
class UGzOnlineMatchJoinPreparationComponent final : public UObject
{
public:
	uint8                                         Pad_3189[0x58];                                    // 0x0028(0x0058)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzOnlineMatchJoinPreparationComponent">();
	}
	static class UGzOnlineMatchJoinPreparationComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzOnlineMatchJoinPreparationComponent>();
	}
};
static_assert(alignof(UGzOnlineMatchJoinPreparationComponent) == 0x000008, "Wrong alignment on UGzOnlineMatchJoinPreparationComponent");
static_assert(sizeof(UGzOnlineMatchJoinPreparationComponent) == 0x000080, "Wrong size on UGzOnlineMatchJoinPreparationComponent");

// Class G01.GzDecoratorObjective
// 0x0008 (0x0068 - 0x0060)
class UGzDecoratorObjective : public UGzObjective
{
public:
	class UGzObjective*                           WrappedObjective;                                  // 0x0060(0x0008)(ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzDecoratorObjective">();
	}
	static class UGzDecoratorObjective* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzDecoratorObjective>();
	}
};
static_assert(alignof(UGzDecoratorObjective) == 0x000008, "Wrong alignment on UGzDecoratorObjective");
static_assert(sizeof(UGzDecoratorObjective) == 0x000068, "Wrong size on UGzDecoratorObjective");
static_assert(offsetof(UGzDecoratorObjective, WrappedObjective) == 0x000060, "Member 'UGzDecoratorObjective::WrappedObjective' has a wrong offset!");

// Class G01.GzGrappleHookData
// 0x00D0 (0x0100 - 0x0030)
class UGzGrappleHookData final : public UDataAsset
{
public:
	float                                         HookDetachDistance;                                // 0x0030(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HookDetachOffsetZ;                                 // 0x0034(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HookDetachYaw;                                     // 0x0038(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HookDetachPitch;                                   // 0x003C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxAcceleration;                                   // 0x0040(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LateralFriction;                                   // 0x0044(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RotationSpeed;                                     // 0x0048(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ForceFinishInSeconds;                              // 0x004C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxMovementSpeed;                                  // 0x0050(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CustomAirControl;                                  // 0x0054(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CustomGravityScaleForContinuousPull;               // 0x0058(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_318A[0x4];                                     // 0x005C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UCurveFloat*                            LaunchImpulseCurve;                                // 0x0060(0x0008)(Edit, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCurveFloat*                            LaunchDegreeCurve;                                 // 0x0068(0x0008)(Edit, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bInheritVelocity;                                  // 0x0070(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bContinuousPullForceCurveUsesLiveDistance;         // 0x0071(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_318B[0x6];                                     // 0x0072(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class UCurveFloat*                            ContinuousPullDelayCurve;                          // 0x0078(0x0008)(Edit, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCurveFloat*                            ContinuousPullForceCurve;                          // 0x0080(0x0008)(Edit, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinDistance;                                       // 0x0088(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxDistance;                                       // 0x008C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ProjectileSpeed;                                   // 0x0090(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ProjectileFlyBackSpeed;                            // 0x0094(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AimAssistSphereRadius;                             // 0x0098(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         AimAssistTraceSegments;                            // 0x009C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCanGrappleCharacters;                             // 0x00A0(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_318C[0x3];                                     // 0x00A1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTag                           HookImpactGameplayCueTag;                          // 0x00A4(0x0008)(Edit, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           HookDetachFromSurfaceGameplayCueTag;               // 0x00AC(0x0008)(Edit, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EGzLimbType                                   LimbSlot;                                          // 0x00B4(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_318D[0x3];                                     // 0x00B5(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   HookLaunchSocket;                                  // 0x00B8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class AGzGrappleHookProjectile>   GrappleHookProjectileClass;                        // 0x00C0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class ACableActor>                CableLineClass;                                    // 0x00C8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAkAudioEvent*                          StartThrowAudioEvent;                              // 0x00D0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAkAudioEvent*                          EndThrowAudioEvent;                                // 0x00D8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAkAudioEvent*                          HookMissedAudioEvent;                              // 0x00E0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAkAudioEvent*                          StartPullAudioEvent;                               // 0x00E8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAkAudioEvent*                          EndPullAudioEvent;                                 // 0x00F0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAkRtpc*                                RopeLengthRtpc;                                    // 0x00F8(0x0008)(Edit, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzGrappleHookData">();
	}
	static class UGzGrappleHookData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzGrappleHookData>();
	}
};
static_assert(alignof(UGzGrappleHookData) == 0x000008, "Wrong alignment on UGzGrappleHookData");
static_assert(sizeof(UGzGrappleHookData) == 0x000100, "Wrong size on UGzGrappleHookData");
static_assert(offsetof(UGzGrappleHookData, HookDetachDistance) == 0x000030, "Member 'UGzGrappleHookData::HookDetachDistance' has a wrong offset!");
static_assert(offsetof(UGzGrappleHookData, HookDetachOffsetZ) == 0x000034, "Member 'UGzGrappleHookData::HookDetachOffsetZ' has a wrong offset!");
static_assert(offsetof(UGzGrappleHookData, HookDetachYaw) == 0x000038, "Member 'UGzGrappleHookData::HookDetachYaw' has a wrong offset!");
static_assert(offsetof(UGzGrappleHookData, HookDetachPitch) == 0x00003C, "Member 'UGzGrappleHookData::HookDetachPitch' has a wrong offset!");
static_assert(offsetof(UGzGrappleHookData, MaxAcceleration) == 0x000040, "Member 'UGzGrappleHookData::MaxAcceleration' has a wrong offset!");
static_assert(offsetof(UGzGrappleHookData, LateralFriction) == 0x000044, "Member 'UGzGrappleHookData::LateralFriction' has a wrong offset!");
static_assert(offsetof(UGzGrappleHookData, RotationSpeed) == 0x000048, "Member 'UGzGrappleHookData::RotationSpeed' has a wrong offset!");
static_assert(offsetof(UGzGrappleHookData, ForceFinishInSeconds) == 0x00004C, "Member 'UGzGrappleHookData::ForceFinishInSeconds' has a wrong offset!");
static_assert(offsetof(UGzGrappleHookData, MaxMovementSpeed) == 0x000050, "Member 'UGzGrappleHookData::MaxMovementSpeed' has a wrong offset!");
static_assert(offsetof(UGzGrappleHookData, CustomAirControl) == 0x000054, "Member 'UGzGrappleHookData::CustomAirControl' has a wrong offset!");
static_assert(offsetof(UGzGrappleHookData, CustomGravityScaleForContinuousPull) == 0x000058, "Member 'UGzGrappleHookData::CustomGravityScaleForContinuousPull' has a wrong offset!");
static_assert(offsetof(UGzGrappleHookData, LaunchImpulseCurve) == 0x000060, "Member 'UGzGrappleHookData::LaunchImpulseCurve' has a wrong offset!");
static_assert(offsetof(UGzGrappleHookData, LaunchDegreeCurve) == 0x000068, "Member 'UGzGrappleHookData::LaunchDegreeCurve' has a wrong offset!");
static_assert(offsetof(UGzGrappleHookData, bInheritVelocity) == 0x000070, "Member 'UGzGrappleHookData::bInheritVelocity' has a wrong offset!");
static_assert(offsetof(UGzGrappleHookData, bContinuousPullForceCurveUsesLiveDistance) == 0x000071, "Member 'UGzGrappleHookData::bContinuousPullForceCurveUsesLiveDistance' has a wrong offset!");
static_assert(offsetof(UGzGrappleHookData, ContinuousPullDelayCurve) == 0x000078, "Member 'UGzGrappleHookData::ContinuousPullDelayCurve' has a wrong offset!");
static_assert(offsetof(UGzGrappleHookData, ContinuousPullForceCurve) == 0x000080, "Member 'UGzGrappleHookData::ContinuousPullForceCurve' has a wrong offset!");
static_assert(offsetof(UGzGrappleHookData, MinDistance) == 0x000088, "Member 'UGzGrappleHookData::MinDistance' has a wrong offset!");
static_assert(offsetof(UGzGrappleHookData, MaxDistance) == 0x00008C, "Member 'UGzGrappleHookData::MaxDistance' has a wrong offset!");
static_assert(offsetof(UGzGrappleHookData, ProjectileSpeed) == 0x000090, "Member 'UGzGrappleHookData::ProjectileSpeed' has a wrong offset!");
static_assert(offsetof(UGzGrappleHookData, ProjectileFlyBackSpeed) == 0x000094, "Member 'UGzGrappleHookData::ProjectileFlyBackSpeed' has a wrong offset!");
static_assert(offsetof(UGzGrappleHookData, AimAssistSphereRadius) == 0x000098, "Member 'UGzGrappleHookData::AimAssistSphereRadius' has a wrong offset!");
static_assert(offsetof(UGzGrappleHookData, AimAssistTraceSegments) == 0x00009C, "Member 'UGzGrappleHookData::AimAssistTraceSegments' has a wrong offset!");
static_assert(offsetof(UGzGrappleHookData, bCanGrappleCharacters) == 0x0000A0, "Member 'UGzGrappleHookData::bCanGrappleCharacters' has a wrong offset!");
static_assert(offsetof(UGzGrappleHookData, HookImpactGameplayCueTag) == 0x0000A4, "Member 'UGzGrappleHookData::HookImpactGameplayCueTag' has a wrong offset!");
static_assert(offsetof(UGzGrappleHookData, HookDetachFromSurfaceGameplayCueTag) == 0x0000AC, "Member 'UGzGrappleHookData::HookDetachFromSurfaceGameplayCueTag' has a wrong offset!");
static_assert(offsetof(UGzGrappleHookData, LimbSlot) == 0x0000B4, "Member 'UGzGrappleHookData::LimbSlot' has a wrong offset!");
static_assert(offsetof(UGzGrappleHookData, HookLaunchSocket) == 0x0000B8, "Member 'UGzGrappleHookData::HookLaunchSocket' has a wrong offset!");
static_assert(offsetof(UGzGrappleHookData, GrappleHookProjectileClass) == 0x0000C0, "Member 'UGzGrappleHookData::GrappleHookProjectileClass' has a wrong offset!");
static_assert(offsetof(UGzGrappleHookData, CableLineClass) == 0x0000C8, "Member 'UGzGrappleHookData::CableLineClass' has a wrong offset!");
static_assert(offsetof(UGzGrappleHookData, StartThrowAudioEvent) == 0x0000D0, "Member 'UGzGrappleHookData::StartThrowAudioEvent' has a wrong offset!");
static_assert(offsetof(UGzGrappleHookData, EndThrowAudioEvent) == 0x0000D8, "Member 'UGzGrappleHookData::EndThrowAudioEvent' has a wrong offset!");
static_assert(offsetof(UGzGrappleHookData, HookMissedAudioEvent) == 0x0000E0, "Member 'UGzGrappleHookData::HookMissedAudioEvent' has a wrong offset!");
static_assert(offsetof(UGzGrappleHookData, StartPullAudioEvent) == 0x0000E8, "Member 'UGzGrappleHookData::StartPullAudioEvent' has a wrong offset!");
static_assert(offsetof(UGzGrappleHookData, EndPullAudioEvent) == 0x0000F0, "Member 'UGzGrappleHookData::EndPullAudioEvent' has a wrong offset!");
static_assert(offsetof(UGzGrappleHookData, RopeLengthRtpc) == 0x0000F8, "Member 'UGzGrappleHookData::RopeLengthRtpc' has a wrong offset!");

// Class G01.GzDedicatedAchievementService
// 0x0078 (0x0118 - 0x00A0)
class UGzDedicatedAchievementService final : public UGzPlayFabObject
{
public:
	uint8                                         Pad_318E[0x50];                                    // 0x00A0(0x0050)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UGzAchievementTemplate*>         EnabledAchievementList;                            // 0x00F0(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	uint8                                         Pad_318F[0x18];                                    // 0x0100(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzDedicatedAchievementService">();
	}
	static class UGzDedicatedAchievementService* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzDedicatedAchievementService>();
	}
};
static_assert(alignof(UGzDedicatedAchievementService) == 0x000008, "Wrong alignment on UGzDedicatedAchievementService");
static_assert(sizeof(UGzDedicatedAchievementService) == 0x000118, "Wrong size on UGzDedicatedAchievementService");
static_assert(offsetof(UGzDedicatedAchievementService, EnabledAchievementList) == 0x0000F0, "Member 'UGzDedicatedAchievementService::EnabledAchievementList' has a wrong offset!");

// Class G01.GzInputTriggerExcludeKey
// 0x0010 (0x0060 - 0x0050)
class UGzInputTriggerExcludeKey final : public UInputTrigger
{
public:
	TArray<struct FKey>                           ExcludedKeys;                                      // 0x0050(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzInputTriggerExcludeKey">();
	}
	static class UGzInputTriggerExcludeKey* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzInputTriggerExcludeKey>();
	}
};
static_assert(alignof(UGzInputTriggerExcludeKey) == 0x000008, "Wrong alignment on UGzInputTriggerExcludeKey");
static_assert(sizeof(UGzInputTriggerExcludeKey) == 0x000060, "Wrong size on UGzInputTriggerExcludeKey");
static_assert(offsetof(UGzInputTriggerExcludeKey, ExcludedKeys) == 0x000050, "Member 'UGzInputTriggerExcludeKey::ExcludedKeys' has a wrong offset!");

// Class G01.GzDedicatedChallengeService
// 0x0068 (0x0108 - 0x00A0)
class UGzDedicatedChallengeService final : public UGzPlayFabObject
{
public:
	uint8                                         Pad_3190[0x68];                                    // 0x00A0(0x0068)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzDedicatedChallengeService">();
	}
	static class UGzDedicatedChallengeService* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzDedicatedChallengeService>();
	}
};
static_assert(alignof(UGzDedicatedChallengeService) == 0x000008, "Wrong alignment on UGzDedicatedChallengeService");
static_assert(sizeof(UGzDedicatedChallengeService) == 0x000108, "Wrong size on UGzDedicatedChallengeService");

// Class G01.GzDedicatedConsoleMatchService
// 0x00B0 (0x0150 - 0x00A0)
class UGzDedicatedConsoleMatchService final : public UGzPlayFabObject
{
public:
	uint8                                         Pad_3191[0xB0];                                    // 0x00A0(0x00B0)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzDedicatedConsoleMatchService">();
	}
	static class UGzDedicatedConsoleMatchService* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzDedicatedConsoleMatchService>();
	}
};
static_assert(alignof(UGzDedicatedConsoleMatchService) == 0x000008, "Wrong alignment on UGzDedicatedConsoleMatchService");
static_assert(sizeof(UGzDedicatedConsoleMatchService) == 0x000150, "Wrong size on UGzDedicatedConsoleMatchService");

// Class G01.GzDedicatedCustomizationService
// 0x00A0 (0x0140 - 0x00A0)
class UGzDedicatedCustomizationService final : public UGzPlayFabObject
{
public:
	uint8                                         Pad_3192[0xA0];                                    // 0x00A0(0x00A0)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzDedicatedCustomizationService">();
	}
	static class UGzDedicatedCustomizationService* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzDedicatedCustomizationService>();
	}
};
static_assert(alignof(UGzDedicatedCustomizationService) == 0x000008, "Wrong alignment on UGzDedicatedCustomizationService");
static_assert(sizeof(UGzDedicatedCustomizationService) == 0x000140, "Wrong size on UGzDedicatedCustomizationService");

// Class G01.GzDedicatedDatacubeService
// 0x0050 (0x00F0 - 0x00A0)
class UGzDedicatedDatacubeService final : public UGzPlayFabObject
{
public:
	TMap<class FString, struct FGzExtractedItems> PlayersExtractedItems;                             // 0x00A0(0x0050)(NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzDedicatedDatacubeService">();
	}
	static class UGzDedicatedDatacubeService* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzDedicatedDatacubeService>();
	}
};
static_assert(alignof(UGzDedicatedDatacubeService) == 0x000008, "Wrong alignment on UGzDedicatedDatacubeService");
static_assert(sizeof(UGzDedicatedDatacubeService) == 0x0000F0, "Wrong size on UGzDedicatedDatacubeService");
static_assert(offsetof(UGzDedicatedDatacubeService, PlayersExtractedItems) == 0x0000A0, "Member 'UGzDedicatedDatacubeService::PlayersExtractedItems' has a wrong offset!");

// Class G01.GzDedicatedLiveFeaturesFacade
// 0x0000 (0x0030 - 0x0030)
class UGzDedicatedLiveFeaturesFacade final : public UGzFacade
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzDedicatedLiveFeaturesFacade">();
	}
	static class UGzDedicatedLiveFeaturesFacade* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzDedicatedLiveFeaturesFacade>();
	}
};
static_assert(alignof(UGzDedicatedLiveFeaturesFacade) == 0x000008, "Wrong alignment on UGzDedicatedLiveFeaturesFacade");
static_assert(sizeof(UGzDedicatedLiveFeaturesFacade) == 0x000030, "Wrong size on UGzDedicatedLiveFeaturesFacade");

// Class G01.GzSettingDiscreteDLSS
// 0x0010 (0x0160 - 0x0150)
class UGzSettingDiscreteDLSS final : public UGameSettingValueDiscrete
{
public:
	uint8                                         Pad_3193[0x10];                                    // 0x0150(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzSettingDiscreteDLSS">();
	}
	static class UGzSettingDiscreteDLSS* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzSettingDiscreteDLSS>();
	}
};
static_assert(alignof(UGzSettingDiscreteDLSS) == 0x000008, "Wrong alignment on UGzSettingDiscreteDLSS");
static_assert(sizeof(UGzSettingDiscreteDLSS) == 0x000160, "Wrong size on UGzSettingDiscreteDLSS");

// Class G01.GzDedicatedLiveFeaturesService
// 0x0028 (0x00C8 - 0x00A0)
class UGzDedicatedLiveFeaturesService final : public UGzPlayFabObject
{
public:
	uint8                                         Pad_3194[0x20];                                    // 0x00A0(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	class UGzHiddenAssetsTrackerComponent*        HiddenAssetsTracker;                               // 0x00C0(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzDedicatedLiveFeaturesService">();
	}
	static class UGzDedicatedLiveFeaturesService* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzDedicatedLiveFeaturesService>();
	}
};
static_assert(alignof(UGzDedicatedLiveFeaturesService) == 0x000008, "Wrong alignment on UGzDedicatedLiveFeaturesService");
static_assert(sizeof(UGzDedicatedLiveFeaturesService) == 0x0000C8, "Wrong size on UGzDedicatedLiveFeaturesService");
static_assert(offsetof(UGzDedicatedLiveFeaturesService, HiddenAssetsTracker) == 0x0000C0, "Member 'UGzDedicatedLiveFeaturesService::HiddenAssetsTracker' has a wrong offset!");

// Class G01.GzDedicatedLoadoutService
// 0x0058 (0x00F8 - 0x00A0)
class UGzDedicatedLoadoutService final : public UGzPlayFabObject
{
public:
	uint8                                         Pad_3195[0x58];                                    // 0x00A0(0x0058)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzDedicatedLoadoutService">();
	}
	static class UGzDedicatedLoadoutService* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzDedicatedLoadoutService>();
	}
};
static_assert(alignof(UGzDedicatedLoadoutService) == 0x000008, "Wrong alignment on UGzDedicatedLoadoutService");
static_assert(sizeof(UGzDedicatedLoadoutService) == 0x0000F8, "Wrong size on UGzDedicatedLoadoutService");

// Class G01.GzStatRewardPolicy
// 0x0008 (0x0030 - 0x0028)
class UGzStatRewardPolicy : public UObject
{
public:
	uint8                                         Pad_3196[0x8];                                     // 0x0028(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzStatRewardPolicy">();
	}
	static class UGzStatRewardPolicy* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzStatRewardPolicy>();
	}
};
static_assert(alignof(UGzStatRewardPolicy) == 0x000008, "Wrong alignment on UGzStatRewardPolicy");
static_assert(sizeof(UGzStatRewardPolicy) == 0x000030, "Wrong size on UGzStatRewardPolicy");

// Class G01.GzStatRewardForEachLevel
// 0x0010 (0x0040 - 0x0030)
class UGzStatRewardForEachLevel final : public UGzStatRewardPolicy
{
public:
	int32                                         StatValueToLevel;                                  // 0x0030(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_3197[0x4];                                     // 0x0034(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UGzRewardData*                          Reward;                                            // 0x0038(0x0008)(Edit, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzStatRewardForEachLevel">();
	}
	static class UGzStatRewardForEachLevel* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzStatRewardForEachLevel>();
	}
};
static_assert(alignof(UGzStatRewardForEachLevel) == 0x000008, "Wrong alignment on UGzStatRewardForEachLevel");
static_assert(sizeof(UGzStatRewardForEachLevel) == 0x000040, "Wrong size on UGzStatRewardForEachLevel");
static_assert(offsetof(UGzStatRewardForEachLevel, StatValueToLevel) == 0x000030, "Member 'UGzStatRewardForEachLevel::StatValueToLevel' has a wrong offset!");
static_assert(offsetof(UGzStatRewardForEachLevel, Reward) == 0x000038, "Member 'UGzStatRewardForEachLevel::Reward' has a wrong offset!");

// Class G01.GzDedicatedMissionService
// 0x0018 (0x00B8 - 0x00A0)
class UGzDedicatedMissionService final : public UGzPlayFabObject
{
public:
	uint8                                         Pad_3198[0x18];                                    // 0x00A0(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzDedicatedMissionService">();
	}
	static class UGzDedicatedMissionService* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzDedicatedMissionService>();
	}
};
static_assert(alignof(UGzDedicatedMissionService) == 0x000008, "Wrong alignment on UGzDedicatedMissionService");
static_assert(sizeof(UGzDedicatedMissionService) == 0x0000B8, "Wrong size on UGzDedicatedMissionService");

// Class G01.GzGA_Zipline_JumpOff
// 0x0000 (0x0508 - 0x0508)
class UGzGA_Zipline_JumpOff : public UGzGameplayAbility
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzGA_Zipline_JumpOff">();
	}
	static class UGzGA_Zipline_JumpOff* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzGA_Zipline_JumpOff>();
	}
};
static_assert(alignof(UGzGA_Zipline_JumpOff) == 0x000008, "Wrong alignment on UGzGA_Zipline_JumpOff");
static_assert(sizeof(UGzGA_Zipline_JumpOff) == 0x000508, "Wrong size on UGzGA_Zipline_JumpOff");

// Class G01.GzDedicatedRewardService
// 0x0000 (0x00A0 - 0x00A0)
class UGzDedicatedRewardService final : public UGzPlayFabObject
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzDedicatedRewardService">();
	}
	static class UGzDedicatedRewardService* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzDedicatedRewardService>();
	}
};
static_assert(alignof(UGzDedicatedRewardService) == 0x000008, "Wrong alignment on UGzDedicatedRewardService");
static_assert(sizeof(UGzDedicatedRewardService) == 0x0000A0, "Wrong size on UGzDedicatedRewardService");

// Class G01.GzDedicatedSharedLoadoutService
// 0x0050 (0x00F0 - 0x00A0)
class UGzDedicatedSharedLoadoutService final : public UGzPlayFabObject
{
public:
	uint8                                         Pad_3199[0x50];                                    // 0x00A0(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzDedicatedSharedLoadoutService">();
	}
	static class UGzDedicatedSharedLoadoutService* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzDedicatedSharedLoadoutService>();
	}
};
static_assert(alignof(UGzDedicatedSharedLoadoutService) == 0x000008, "Wrong alignment on UGzDedicatedSharedLoadoutService");
static_assert(sizeof(UGzDedicatedSharedLoadoutService) == 0x0000F0, "Wrong size on UGzDedicatedSharedLoadoutService");

// Class G01.GzDedicatedTelemetryFacade
// 0x0000 (0x0030 - 0x0030)
class UGzDedicatedTelemetryFacade final : public UGzFacade
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzDedicatedTelemetryFacade">();
	}
	static class UGzDedicatedTelemetryFacade* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzDedicatedTelemetryFacade>();
	}
};
static_assert(alignof(UGzDedicatedTelemetryFacade) == 0x000008, "Wrong alignment on UGzDedicatedTelemetryFacade");
static_assert(sizeof(UGzDedicatedTelemetryFacade) == 0x000030, "Wrong size on UGzDedicatedTelemetryFacade");

// Class G01.GzDedicatedTelemetryService
// 0x0088 (0x0128 - 0x00A0)
class UGzDedicatedTelemetryService final : public UGzPlayFabObject
{
public:
	uint8                                         Pad_319A[0x88];                                    // 0x00A0(0x0088)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzDedicatedTelemetryService">();
	}
	static class UGzDedicatedTelemetryService* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzDedicatedTelemetryService>();
	}
};
static_assert(alignof(UGzDedicatedTelemetryService) == 0x000008, "Wrong alignment on UGzDedicatedTelemetryService");
static_assert(sizeof(UGzDedicatedTelemetryService) == 0x000128, "Wrong size on UGzDedicatedTelemetryService");

// Class G01.GzDedicatedWeaponConfigurationService
// 0x0070 (0x0110 - 0x00A0)
class UGzDedicatedWeaponConfigurationService final : public UGzPlayFabObject
{
public:
	uint8                                         Pad_319B[0x70];                                    // 0x00A0(0x0070)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzDedicatedWeaponConfigurationService">();
	}
	static class UGzDedicatedWeaponConfigurationService* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzDedicatedWeaponConfigurationService>();
	}
};
static_assert(alignof(UGzDedicatedWeaponConfigurationService) == 0x000008, "Wrong alignment on UGzDedicatedWeaponConfigurationService");
static_assert(sizeof(UGzDedicatedWeaponConfigurationService) == 0x000110, "Wrong size on UGzDedicatedWeaponConfigurationService");

// Class G01.GzLoadoutSelectionScreenQuickOrder
// 0x0010 (0x0688 - 0x0678)
class UGzLoadoutSelectionScreenQuickOrder : public UGzLoadoutSelectionScreen
{
public:
	class AGzPlayerCharacter*                     CachedOwningPlayerCharacter;                       // 0x0678(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_319C[0x8];                                     // 0x0680(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void HandleDroneCallAvailability(const struct FGuid& Guid);
	void OnValidationFailed(EGzQuickOrderCallValidationFailReason FailReason);
	void OnValidationPassed();
	void StartCallingDrone();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzLoadoutSelectionScreenQuickOrder">();
	}
	static class UGzLoadoutSelectionScreenQuickOrder* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzLoadoutSelectionScreenQuickOrder>();
	}
};
static_assert(alignof(UGzLoadoutSelectionScreenQuickOrder) == 0x000008, "Wrong alignment on UGzLoadoutSelectionScreenQuickOrder");
static_assert(sizeof(UGzLoadoutSelectionScreenQuickOrder) == 0x000688, "Wrong size on UGzLoadoutSelectionScreenQuickOrder");
static_assert(offsetof(UGzLoadoutSelectionScreenQuickOrder, CachedOwningPlayerCharacter) == 0x000678, "Member 'UGzLoadoutSelectionScreenQuickOrder::CachedOwningPlayerCharacter' has a wrong offset!");

// Class G01.GzPrecommitTestingGameMode
// 0x0000 (0x05C8 - 0x05C8)
class AGzPrecommitTestingGameMode final : public AGzSessionGameModeBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzPrecommitTestingGameMode">();
	}
	static class AGzPrecommitTestingGameMode* GetDefaultObj()
	{
		return GetDefaultObjImpl<AGzPrecommitTestingGameMode>();
	}
};
static_assert(alignof(AGzPrecommitTestingGameMode) == 0x000008, "Wrong alignment on AGzPrecommitTestingGameMode");
static_assert(sizeof(AGzPrecommitTestingGameMode) == 0x0005C8, "Wrong size on AGzPrecommitTestingGameMode");

// Class G01.ModularCharacterAnimInstance
// 0x0010 (0x0380 - 0x0370)
#pragma pack(push, 0x1)
class alignas(0x10) UModularCharacterAnimInstance : public UAnimInstance
{
public:
	uint8                                         Pad_319D[0x8];                                     // 0x0368(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class AGzMultiPartCharacter*                  ModularCharacter;                                  // 0x0370(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	class AGzMultiPartCharacter* GetModularCharacter() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ModularCharacterAnimInstance">();
	}
	static class UModularCharacterAnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UModularCharacterAnimInstance>();
	}
};
#pragma pack(pop)
static_assert(alignof(UModularCharacterAnimInstance) == 0x000010, "Wrong alignment on UModularCharacterAnimInstance");
static_assert(sizeof(UModularCharacterAnimInstance) == 0x000380, "Wrong size on UModularCharacterAnimInstance");
static_assert(offsetof(UModularCharacterAnimInstance, ModularCharacter) == 0x000370, "Member 'UModularCharacterAnimInstance::ModularCharacter' has a wrong offset!");

// Class G01.GzDefaultCharacterAnimInstance
// 0x0910 (0x0C90 - 0x0380)
class UGzDefaultCharacterAnimInstance : public UModularCharacterAnimInstance
{
public:
	struct FAnimCache                             AnimCacheData;                                     // 0x0378(0x0218)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, NoDestructor, NativeAccessSpecifierPublic)
	TArray<struct FGzAnimHitReactionData>         AnimHitReactionData;                               // 0x0590(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, NativeAccessSpecifierPublic)
	TMap<EGzCharacterDamageAreaType, struct FHitDirectionInfo> AnimHitDirectionsByDamageArea;                     // 0x05A0(0x0050)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	class UCurveFloat*                            AnimHitDamageMultiplierCurve;                      // 0x05F0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCurveFloat*                            AnimHitTimeMultiplierCurve;                        // 0x05F8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AnimHitDirectionMaxValue;                          // 0x0600(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_319E[0x4];                                     // 0x0604(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FAnimStanceBlend                       AnimStancesBlends;                                 // 0x0608(0x00F0)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	float                                         ShockReactionDirectionChangeInterval;              // 0x06F8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FFloatRange                            ShockReactionDirectionChangeIntervalRandomness;    // 0x06FC(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FFloatRange                            ShockReactionHitPowerDefault;                      // 0x070C(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_319F[0x4];                                     // 0x071C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<EGzCharacterDamageAreaType, struct FFloatRange> ShockReactionHitPowerByDamageArea;                 // 0x0720(0x0050)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	bool                                          bIsPlayingShockReaction;                           // 0x0770(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_31A0[0x7];                                     // 0x0771(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<EGzCharacterDamageAreaType, struct FHitDirectionInfo> ShockReactionVectorByDamageArea;                   // 0x0778(0x0050)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	TMap<EGzCharacterDamageAreaType, float>       ShockReactionTimeSinceLastUpdateByDamageArea;      // 0x07C8(0x0050)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	uint8                                         Pad_31A1[0x8];                                     // 0x0818(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGzIKTransformInfo                     GroundLeftHandIK;                                  // 0x0820(0x0050)(BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic)
	struct FGzIKTransformInfo                     GroundRightHandIK;                                 // 0x0870(0x0050)(BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic)
	struct FGzIKTransformInfo                     GroundLeftFootIK;                                  // 0x08C0(0x0050)(BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic)
	struct FGzIKTransformInfo                     GroundRightFootIK;                                 // 0x0910(0x0050)(BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic)
	float                                         SuperSprintVelocityThreshhold;                     // 0x0960(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_31A2[0x4];                                     // 0x0964(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTagBlueprintPropertyMap       GameplayTagPropertyMap;                            // 0x0968(0x0020)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	float                                         GroundDistance;                                    // 0x0988(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	ELeglessLocoSubState                          OwnerLeglessSubState;                              // 0x098C(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	ELeglessLocoState                             OwnerLeglessState;                                 // 0x098D(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_31A3[0x2];                                     // 0x098E(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UAnimInstance>              UnarmedAnimLayer;                                  // 0x0990(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_31A4[0x8];                                     // 0x0998(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGzLeftHandIKInfo                      LeftHandIK;                                        // 0x09A0(0x0090)(BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPrivate)
	struct FAnimAbilityData                       AnimAbilityState;                                  // 0x0A30(0x0040)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	struct FVector                                MagazineBonePosition;                              // 0x0A70(0x0018)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         NormalFallingMaxDuration;                          // 0x0A88(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         ParaFallingActionPause;                            // 0x0A8C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         NormalFallingHeight;                               // 0x0A90(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_31A5[0xC];                                     // 0x0A94(0x000C)(Fixing Size After Last Property [ Dumper-7 ])
	class AGzCharacter*                           GzCharacter;                                       // 0x0AA0(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FName                                   LeftHandIKCurveName;                               // 0x0AA8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FName                                   LeftHandIKoffsetXName;                             // 0x0AB0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FName                                   LeftHandIKoffsetYName;                             // 0x0AB8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FName                                   LeftHandIKoffsetZName;                             // 0x0AC0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FName                                   GroundHandsIKPositionRightCurveName;               // 0x0AC8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FName                                   GroundHandsIKPositionLeftCurveName;                // 0x0AD0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FName                                   GroundFootIKPositionRightCurveName;                // 0x0AD8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FName                                   GroundFootIKPositionLeftCurveName;                 // 0x0AE0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         GroundHandsIKMaxDistance;                          // 0x0AE8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         GroundHandsIKStartOffset;                          // 0x0AEC(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         GroundFeetIKMaxDistance;                           // 0x0AF0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_31A6[0xC];                                     // 0x0AF4(0x000C)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             LeftHandIKOffset;                                  // 0x0B00(0x0060)(Edit, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	ELocomotionMovementState                      OwnerMovementState;                                // 0x0B60(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	ELocomotionStance                             OwnerStance;                                       // 0x0B61(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_31A7[0x2];                                     // 0x0B62(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         AnimHitReactionLifeTime;                           // 0x0B64(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         RootYawOffsetRatio;                                // 0x0B68(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_31A8[0x4];                                     // 0x0B6C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRotator                               ControlStartRot;                                   // 0x0B70(0x0018)(ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPrivate)
	struct FRotator                               ControlDeltaRot;                                   // 0x0B88(0x0018)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPrivate)
	uint8                                         Pad_31A9[0xF0];                                    // 0x0BA0(0x00F0)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void CheckParaFallActivation();
	struct FAnimCache GetAnimCache();
	TArray<struct FGzAnimHitReactionData> GetAnimHitReactionData();
	ECardinalDirectionType GetOppositeCardinalDirectionNative(ECardinalDirectionType CurrentDirection);
	void ProcessTurnYawCurveNative();
	void ResetAnimAbilityState();
	ECardinalDirectionType SelectCardinalDirectionFromAngleNative(float Angle, float DeadZone, ECardinalDirectionType CurrentDirection, bool UseCurrentDirection);
	void SetAnimAbilityState(bool bIsActive);
	void SetAnimLayerInstance(TSubclassOf<class UAnimInstance> NewLayer);
	void SetAnimStance(EAnimStances Value);
	void SetDefaultAnimLayer();
	void SetLastLinkedLayer(class UAnimInstance* NewInstance);
	void SetLastPivotTime(float Value);
	void SetLinkedLayerChanged(bool Value);
	void SetRootYawOffsetNative(float InRootYawOffset);
	void SetUpPivotStateNative(const struct FAnimUpdateContext& Context, const struct FAnimNodeReference& Node);
	void SetUpStartStateNative(const struct FAnimUpdateContext& Context, const struct FAnimNodeReference& Node);
	void StartLeglessState();
	void StopLeglessState();
	void SwitchAnimLayer(const EGzLayerItemType LayerIndex);
	void SwitchAnimLayerInstance(TSubclassOf<class UAnimInstance> NewLayer);
	void UpdateAbilityAnimWeight(float DeltaSeconds);
	void UpdateAccelerationDataNative();
	void UpdateAimingDataNative();
	void UpdateBlendWeightDataNative(float DeltaTime);
	void UpdateCacheLimbFlags(const int32 NewLimbFlags);
	void UpdateCharacterStateDataNative();
	void UpdateGrappleLimbData();
	void UpdateIdleStateNative(const struct FAnimUpdateContext& Context, const struct FAnimNodeReference& Node);
	void UpdateJumpFallDataNative();
	void UpdateLeanDataNative(const class UGzCharacterMovementComponent* CharacterMovementCmpRef);
	void UpdateLocationDataNative(float DeltaTime);
	void UpdateLocomotionStateMachineNative(const struct FAnimUpdateContext& Context, const struct FAnimNodeReference& Node);
	void UpdateMirrorData();
	void UpdatePivotStateNative(const struct FAnimUpdateContext& Context, const struct FAnimNodeReference& Node);
	void UpdateRootYawOffsetNative(float DeltaTime);
	void UpdateRotationDataNative();
	void UpdateStartStateNative(const struct FAnimUpdateContext& Context, const struct FAnimNodeReference& Node);
	void UpdateStopStateNative(const struct FAnimUpdateContext& Context, const struct FAnimNodeReference& Node);
	void UpdateVelocityDataNative();
	void UpdateWallDetectionHeuristicNative();

	const EGzLimbType GetActiveLimbType() const;
	const struct FVector GetAimPoint() const;
	EAnimStances GetAnimStance() const;
	float GetAnimStanceBlendValue() const;
	const EGzLayerItemType GetCurrentLayerType() const;
	EGzLayerItemType GetCurrentLogicalLayerType() const;
	float GetGroundFeetIKMaxDistance() const;
	class FName GetGroundFootIKPositionLeftCurveName() const;
	class FName GetGroundFootIKPositionRightCurveName() const;
	float GetGroundHandsIKMaxDistance() const;
	class FName GetGroundHandsIKPositionLeftCurveName() const;
	class FName GetGroundHandsIKPositionRightCurveName() const;
	float GetGroundHandsIKStartOffset() const;
	class AGzCharacter* GetGzCharacter() const;
	const struct FVector GetJointTargetLocation() const;
	float GetLeftHandIKBlendValue() const;
	class FName GetLeftHandIKCurveName() const;
	struct FVector GetLeftHandIKLocation() const;
	struct FVector GetLeftHandIKOffsetLocation() const;
	struct FQuat GetLeftHandIKOffsetRotation() const;
	class FName GetLeftHandIKOffsetXName() const;
	float GetLeftHandIKOffsetXValue() const;
	class FName GetLeftHandIKOffsetYName() const;
	float GetLeftHandIKOffsetYValue() const;
	class FName GetLeftHandIKOffsetZName() const;
	float GetLeftHandIKOffsetZValue() const;
	struct FRotator GetLeftHandIKRotation() const;
	ELocomotionMovementState GetOwnerMovementState() const;
	ELocomotionStance GetOwnerStance() const;
	const EGzWeaponSupportHoldType GetWeaponUnderBarrelGripType() const;
	bool IsMovingPerpendicularToInitialPivotNative() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzDefaultCharacterAnimInstance">();
	}
	static class UGzDefaultCharacterAnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzDefaultCharacterAnimInstance>();
	}
};
static_assert(alignof(UGzDefaultCharacterAnimInstance) == 0x000010, "Wrong alignment on UGzDefaultCharacterAnimInstance");
static_assert(sizeof(UGzDefaultCharacterAnimInstance) == 0x000C90, "Wrong size on UGzDefaultCharacterAnimInstance");
static_assert(offsetof(UGzDefaultCharacterAnimInstance, AnimCacheData) == 0x000378, "Member 'UGzDefaultCharacterAnimInstance::AnimCacheData' has a wrong offset!");
static_assert(offsetof(UGzDefaultCharacterAnimInstance, AnimHitReactionData) == 0x000590, "Member 'UGzDefaultCharacterAnimInstance::AnimHitReactionData' has a wrong offset!");
static_assert(offsetof(UGzDefaultCharacterAnimInstance, AnimHitDirectionsByDamageArea) == 0x0005A0, "Member 'UGzDefaultCharacterAnimInstance::AnimHitDirectionsByDamageArea' has a wrong offset!");
static_assert(offsetof(UGzDefaultCharacterAnimInstance, AnimHitDamageMultiplierCurve) == 0x0005F0, "Member 'UGzDefaultCharacterAnimInstance::AnimHitDamageMultiplierCurve' has a wrong offset!");
static_assert(offsetof(UGzDefaultCharacterAnimInstance, AnimHitTimeMultiplierCurve) == 0x0005F8, "Member 'UGzDefaultCharacterAnimInstance::AnimHitTimeMultiplierCurve' has a wrong offset!");
static_assert(offsetof(UGzDefaultCharacterAnimInstance, AnimHitDirectionMaxValue) == 0x000600, "Member 'UGzDefaultCharacterAnimInstance::AnimHitDirectionMaxValue' has a wrong offset!");
static_assert(offsetof(UGzDefaultCharacterAnimInstance, AnimStancesBlends) == 0x000608, "Member 'UGzDefaultCharacterAnimInstance::AnimStancesBlends' has a wrong offset!");
static_assert(offsetof(UGzDefaultCharacterAnimInstance, ShockReactionDirectionChangeInterval) == 0x0006F8, "Member 'UGzDefaultCharacterAnimInstance::ShockReactionDirectionChangeInterval' has a wrong offset!");
static_assert(offsetof(UGzDefaultCharacterAnimInstance, ShockReactionDirectionChangeIntervalRandomness) == 0x0006FC, "Member 'UGzDefaultCharacterAnimInstance::ShockReactionDirectionChangeIntervalRandomness' has a wrong offset!");
static_assert(offsetof(UGzDefaultCharacterAnimInstance, ShockReactionHitPowerDefault) == 0x00070C, "Member 'UGzDefaultCharacterAnimInstance::ShockReactionHitPowerDefault' has a wrong offset!");
static_assert(offsetof(UGzDefaultCharacterAnimInstance, ShockReactionHitPowerByDamageArea) == 0x000720, "Member 'UGzDefaultCharacterAnimInstance::ShockReactionHitPowerByDamageArea' has a wrong offset!");
static_assert(offsetof(UGzDefaultCharacterAnimInstance, bIsPlayingShockReaction) == 0x000770, "Member 'UGzDefaultCharacterAnimInstance::bIsPlayingShockReaction' has a wrong offset!");
static_assert(offsetof(UGzDefaultCharacterAnimInstance, ShockReactionVectorByDamageArea) == 0x000778, "Member 'UGzDefaultCharacterAnimInstance::ShockReactionVectorByDamageArea' has a wrong offset!");
static_assert(offsetof(UGzDefaultCharacterAnimInstance, ShockReactionTimeSinceLastUpdateByDamageArea) == 0x0007C8, "Member 'UGzDefaultCharacterAnimInstance::ShockReactionTimeSinceLastUpdateByDamageArea' has a wrong offset!");
static_assert(offsetof(UGzDefaultCharacterAnimInstance, GroundLeftHandIK) == 0x000820, "Member 'UGzDefaultCharacterAnimInstance::GroundLeftHandIK' has a wrong offset!");
static_assert(offsetof(UGzDefaultCharacterAnimInstance, GroundRightHandIK) == 0x000870, "Member 'UGzDefaultCharacterAnimInstance::GroundRightHandIK' has a wrong offset!");
static_assert(offsetof(UGzDefaultCharacterAnimInstance, GroundLeftFootIK) == 0x0008C0, "Member 'UGzDefaultCharacterAnimInstance::GroundLeftFootIK' has a wrong offset!");
static_assert(offsetof(UGzDefaultCharacterAnimInstance, GroundRightFootIK) == 0x000910, "Member 'UGzDefaultCharacterAnimInstance::GroundRightFootIK' has a wrong offset!");
static_assert(offsetof(UGzDefaultCharacterAnimInstance, SuperSprintVelocityThreshhold) == 0x000960, "Member 'UGzDefaultCharacterAnimInstance::SuperSprintVelocityThreshhold' has a wrong offset!");
static_assert(offsetof(UGzDefaultCharacterAnimInstance, GameplayTagPropertyMap) == 0x000968, "Member 'UGzDefaultCharacterAnimInstance::GameplayTagPropertyMap' has a wrong offset!");
static_assert(offsetof(UGzDefaultCharacterAnimInstance, GroundDistance) == 0x000988, "Member 'UGzDefaultCharacterAnimInstance::GroundDistance' has a wrong offset!");
static_assert(offsetof(UGzDefaultCharacterAnimInstance, OwnerLeglessSubState) == 0x00098C, "Member 'UGzDefaultCharacterAnimInstance::OwnerLeglessSubState' has a wrong offset!");
static_assert(offsetof(UGzDefaultCharacterAnimInstance, OwnerLeglessState) == 0x00098D, "Member 'UGzDefaultCharacterAnimInstance::OwnerLeglessState' has a wrong offset!");
static_assert(offsetof(UGzDefaultCharacterAnimInstance, UnarmedAnimLayer) == 0x000990, "Member 'UGzDefaultCharacterAnimInstance::UnarmedAnimLayer' has a wrong offset!");
static_assert(offsetof(UGzDefaultCharacterAnimInstance, LeftHandIK) == 0x0009A0, "Member 'UGzDefaultCharacterAnimInstance::LeftHandIK' has a wrong offset!");
static_assert(offsetof(UGzDefaultCharacterAnimInstance, AnimAbilityState) == 0x000A30, "Member 'UGzDefaultCharacterAnimInstance::AnimAbilityState' has a wrong offset!");
static_assert(offsetof(UGzDefaultCharacterAnimInstance, MagazineBonePosition) == 0x000A70, "Member 'UGzDefaultCharacterAnimInstance::MagazineBonePosition' has a wrong offset!");
static_assert(offsetof(UGzDefaultCharacterAnimInstance, NormalFallingMaxDuration) == 0x000A88, "Member 'UGzDefaultCharacterAnimInstance::NormalFallingMaxDuration' has a wrong offset!");
static_assert(offsetof(UGzDefaultCharacterAnimInstance, ParaFallingActionPause) == 0x000A8C, "Member 'UGzDefaultCharacterAnimInstance::ParaFallingActionPause' has a wrong offset!");
static_assert(offsetof(UGzDefaultCharacterAnimInstance, NormalFallingHeight) == 0x000A90, "Member 'UGzDefaultCharacterAnimInstance::NormalFallingHeight' has a wrong offset!");
static_assert(offsetof(UGzDefaultCharacterAnimInstance, GzCharacter) == 0x000AA0, "Member 'UGzDefaultCharacterAnimInstance::GzCharacter' has a wrong offset!");
static_assert(offsetof(UGzDefaultCharacterAnimInstance, LeftHandIKCurveName) == 0x000AA8, "Member 'UGzDefaultCharacterAnimInstance::LeftHandIKCurveName' has a wrong offset!");
static_assert(offsetof(UGzDefaultCharacterAnimInstance, LeftHandIKoffsetXName) == 0x000AB0, "Member 'UGzDefaultCharacterAnimInstance::LeftHandIKoffsetXName' has a wrong offset!");
static_assert(offsetof(UGzDefaultCharacterAnimInstance, LeftHandIKoffsetYName) == 0x000AB8, "Member 'UGzDefaultCharacterAnimInstance::LeftHandIKoffsetYName' has a wrong offset!");
static_assert(offsetof(UGzDefaultCharacterAnimInstance, LeftHandIKoffsetZName) == 0x000AC0, "Member 'UGzDefaultCharacterAnimInstance::LeftHandIKoffsetZName' has a wrong offset!");
static_assert(offsetof(UGzDefaultCharacterAnimInstance, GroundHandsIKPositionRightCurveName) == 0x000AC8, "Member 'UGzDefaultCharacterAnimInstance::GroundHandsIKPositionRightCurveName' has a wrong offset!");
static_assert(offsetof(UGzDefaultCharacterAnimInstance, GroundHandsIKPositionLeftCurveName) == 0x000AD0, "Member 'UGzDefaultCharacterAnimInstance::GroundHandsIKPositionLeftCurveName' has a wrong offset!");
static_assert(offsetof(UGzDefaultCharacterAnimInstance, GroundFootIKPositionRightCurveName) == 0x000AD8, "Member 'UGzDefaultCharacterAnimInstance::GroundFootIKPositionRightCurveName' has a wrong offset!");
static_assert(offsetof(UGzDefaultCharacterAnimInstance, GroundFootIKPositionLeftCurveName) == 0x000AE0, "Member 'UGzDefaultCharacterAnimInstance::GroundFootIKPositionLeftCurveName' has a wrong offset!");
static_assert(offsetof(UGzDefaultCharacterAnimInstance, GroundHandsIKMaxDistance) == 0x000AE8, "Member 'UGzDefaultCharacterAnimInstance::GroundHandsIKMaxDistance' has a wrong offset!");
static_assert(offsetof(UGzDefaultCharacterAnimInstance, GroundHandsIKStartOffset) == 0x000AEC, "Member 'UGzDefaultCharacterAnimInstance::GroundHandsIKStartOffset' has a wrong offset!");
static_assert(offsetof(UGzDefaultCharacterAnimInstance, GroundFeetIKMaxDistance) == 0x000AF0, "Member 'UGzDefaultCharacterAnimInstance::GroundFeetIKMaxDistance' has a wrong offset!");
static_assert(offsetof(UGzDefaultCharacterAnimInstance, LeftHandIKOffset) == 0x000B00, "Member 'UGzDefaultCharacterAnimInstance::LeftHandIKOffset' has a wrong offset!");
static_assert(offsetof(UGzDefaultCharacterAnimInstance, OwnerMovementState) == 0x000B60, "Member 'UGzDefaultCharacterAnimInstance::OwnerMovementState' has a wrong offset!");
static_assert(offsetof(UGzDefaultCharacterAnimInstance, OwnerStance) == 0x000B61, "Member 'UGzDefaultCharacterAnimInstance::OwnerStance' has a wrong offset!");
static_assert(offsetof(UGzDefaultCharacterAnimInstance, AnimHitReactionLifeTime) == 0x000B64, "Member 'UGzDefaultCharacterAnimInstance::AnimHitReactionLifeTime' has a wrong offset!");
static_assert(offsetof(UGzDefaultCharacterAnimInstance, RootYawOffsetRatio) == 0x000B68, "Member 'UGzDefaultCharacterAnimInstance::RootYawOffsetRatio' has a wrong offset!");
static_assert(offsetof(UGzDefaultCharacterAnimInstance, ControlStartRot) == 0x000B70, "Member 'UGzDefaultCharacterAnimInstance::ControlStartRot' has a wrong offset!");
static_assert(offsetof(UGzDefaultCharacterAnimInstance, ControlDeltaRot) == 0x000B88, "Member 'UGzDefaultCharacterAnimInstance::ControlDeltaRot' has a wrong offset!");

// Class G01.GzSettingsCollectionWidget
// 0x0010 (0x0318 - 0x0308)
class UGzSettingsCollectionWidget final : public UCommonUserWidget
{
public:
	class UVerticalBox*                           SettingsContainer;                                 // 0x0308(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             CollectionTitleText;                               // 0x0310(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzSettingsCollectionWidget">();
	}
	static class UGzSettingsCollectionWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzSettingsCollectionWidget>();
	}
};
static_assert(alignof(UGzSettingsCollectionWidget) == 0x000008, "Wrong alignment on UGzSettingsCollectionWidget");
static_assert(sizeof(UGzSettingsCollectionWidget) == 0x000318, "Wrong size on UGzSettingsCollectionWidget");
static_assert(offsetof(UGzSettingsCollectionWidget, SettingsContainer) == 0x000308, "Member 'UGzSettingsCollectionWidget::SettingsContainer' has a wrong offset!");
static_assert(offsetof(UGzSettingsCollectionWidget, CollectionTitleText) == 0x000310, "Member 'UGzSettingsCollectionWidget::CollectionTitleText' has a wrong offset!");

// Class G01.GzDefaultPocketWidget
// 0x0000 (0x0358 - 0x0358)
class UGzDefaultPocketWidget : public UGzPocketWidget
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzDefaultPocketWidget">();
	}
	static class UGzDefaultPocketWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzDefaultPocketWidget>();
	}
};
static_assert(alignof(UGzDefaultPocketWidget) == 0x000008, "Wrong alignment on UGzDefaultPocketWidget");
static_assert(sizeof(UGzDefaultPocketWidget) == 0x000358, "Wrong size on UGzDefaultPocketWidget");

// Class G01.GzDefilerTarget
// 0x0000 (0x0028 - 0x0028)
class IGzDefilerTarget final : public IInterface
{
public:
	bool CanScanOnAnyDistance();
	bool OnDefilerEffectApplied();
	bool OnDefilerEffectRemoved();

	EGzDefilerTargetType GetDefilerTargetType() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzDefilerTarget">();
	}
	static class IGzDefilerTarget* GetDefaultObj()
	{
		return GetDefaultObjImpl<IGzDefilerTarget>();
	}
};
static_assert(alignof(IGzDefilerTarget) == 0x000008, "Wrong alignment on IGzDefilerTarget");
static_assert(sizeof(IGzDefilerTarget) == 0x000028, "Wrong size on IGzDefilerTarget");

// Class G01.GzDelayedHexExtractionStatCollector
// 0x0020 (0x0058 - 0x0038)
class UGzDelayedHexExtractionStatCollector final : public UGzGlobalStatsCollector
{
public:
	uint8                                         Pad_31AB[0x18];                                    // 0x0038(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bHexHadPause;                                      // 0x0050(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_31AC[0x7];                                     // 0x0051(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzDelayedHexExtractionStatCollector">();
	}
	static class UGzDelayedHexExtractionStatCollector* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzDelayedHexExtractionStatCollector>();
	}
};
static_assert(alignof(UGzDelayedHexExtractionStatCollector) == 0x000008, "Wrong alignment on UGzDelayedHexExtractionStatCollector");
static_assert(sizeof(UGzDelayedHexExtractionStatCollector) == 0x000058, "Wrong size on UGzDelayedHexExtractionStatCollector");
static_assert(offsetof(UGzDelayedHexExtractionStatCollector, bHexHadPause) == 0x000050, "Member 'UGzDelayedHexExtractionStatCollector::bHexHadPause' has a wrong offset!");

// Class G01.GzDeliveryDrone
// 0x00A8 (0x0458 - 0x03B0)
class AGzDeliveryDrone final : public AGzAutoTrackTransport
{
public:
	TSubclassOf<class AGzTrack>                   DeliveryTrackClass;                                // 0x03B0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftClassPtr<class UClass>                   ArrivalMarkerClass;                                // 0x03B8(0x0028)(Edit, DisableEditOnInstance, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftClassPtr<class UClass>                   DeliveryLocationSelectionMarker;                   // 0x03E0(0x0028)(Edit, DisableEditOnInstance, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<struct FGzInvItem>                     Items;                                             // 0x0408(0x0010)(BlueprintVisible, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	TSubclassOf<class AActor>                     RestrictionAreaVolumeClass;                        // 0x0418(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class AActor*                                 RestrictionAreaVolume;                             // 0x0420(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FGzDeliveryLocationData                LocationData;                                      // 0x0428(0x0020)(Net, RepNotify, NoDestructor, Protected, NativeAccessSpecifierProtected)
	int32                                         CallerTeamId;                                      // 0x0448(0x0004)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_31AD[0xC];                                     // 0x044C(0x000C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnRep_LocationData();

	int32 GetCallerTeamID() const;
	struct FVector GetDeliveryLocation() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzDeliveryDrone">();
	}
	static class AGzDeliveryDrone* GetDefaultObj()
	{
		return GetDefaultObjImpl<AGzDeliveryDrone>();
	}
};
static_assert(alignof(AGzDeliveryDrone) == 0x000008, "Wrong alignment on AGzDeliveryDrone");
static_assert(sizeof(AGzDeliveryDrone) == 0x000458, "Wrong size on AGzDeliveryDrone");
static_assert(offsetof(AGzDeliveryDrone, DeliveryTrackClass) == 0x0003B0, "Member 'AGzDeliveryDrone::DeliveryTrackClass' has a wrong offset!");
static_assert(offsetof(AGzDeliveryDrone, ArrivalMarkerClass) == 0x0003B8, "Member 'AGzDeliveryDrone::ArrivalMarkerClass' has a wrong offset!");
static_assert(offsetof(AGzDeliveryDrone, DeliveryLocationSelectionMarker) == 0x0003E0, "Member 'AGzDeliveryDrone::DeliveryLocationSelectionMarker' has a wrong offset!");
static_assert(offsetof(AGzDeliveryDrone, Items) == 0x000408, "Member 'AGzDeliveryDrone::Items' has a wrong offset!");
static_assert(offsetof(AGzDeliveryDrone, RestrictionAreaVolumeClass) == 0x000418, "Member 'AGzDeliveryDrone::RestrictionAreaVolumeClass' has a wrong offset!");
static_assert(offsetof(AGzDeliveryDrone, RestrictionAreaVolume) == 0x000420, "Member 'AGzDeliveryDrone::RestrictionAreaVolume' has a wrong offset!");
static_assert(offsetof(AGzDeliveryDrone, LocationData) == 0x000428, "Member 'AGzDeliveryDrone::LocationData' has a wrong offset!");
static_assert(offsetof(AGzDeliveryDrone, CallerTeamId) == 0x000448, "Member 'AGzDeliveryDrone::CallerTeamId' has a wrong offset!");

// Class G01.GzDeliveryPreviewMarker
// 0x0000 (0x02A0 - 0x02A0)
class AGzDeliveryPreviewMarker final : public AActor
{
public:
	void UpdateDeliveryPreview(bool bHasHit, bool bValidHit);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzDeliveryPreviewMarker">();
	}
	static class AGzDeliveryPreviewMarker* GetDefaultObj()
	{
		return GetDefaultObjImpl<AGzDeliveryPreviewMarker>();
	}
};
static_assert(alignof(AGzDeliveryPreviewMarker) == 0x000008, "Wrong alignment on AGzDeliveryPreviewMarker");
static_assert(sizeof(AGzDeliveryPreviewMarker) == 0x0002A0, "Wrong size on AGzDeliveryPreviewMarker");

// Class G01.GzKatanaComponent
// 0x0030 (0x0288 - 0x0258)
class UGzKatanaComponent : public UGzChargeableAbilityComponent
{
public:
	class UGzDashParamsData*                      HorizontalDashParamsData;                          // 0x0258(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UGzDashParamsData*                      VerticalDashParamsData;                            // 0x0260(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MinHeightForVerticalAttack;                        // 0x0268(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MinPitchForHorizontalAttack;                       // 0x026C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MaxAllowedPitch;                                   // 0x0270(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MaxAngleToViewHitDirection;                        // 0x0274(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class AActor>                     AimAssistTargetMarkerClass;                        // 0x0278(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class AActor*                                 AimAssistTargetMarker;                             // 0x0280(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	bool ShouldDashVertically() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzKatanaComponent">();
	}
	static class UGzKatanaComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzKatanaComponent>();
	}
};
static_assert(alignof(UGzKatanaComponent) == 0x000008, "Wrong alignment on UGzKatanaComponent");
static_assert(sizeof(UGzKatanaComponent) == 0x000288, "Wrong size on UGzKatanaComponent");
static_assert(offsetof(UGzKatanaComponent, HorizontalDashParamsData) == 0x000258, "Member 'UGzKatanaComponent::HorizontalDashParamsData' has a wrong offset!");
static_assert(offsetof(UGzKatanaComponent, VerticalDashParamsData) == 0x000260, "Member 'UGzKatanaComponent::VerticalDashParamsData' has a wrong offset!");
static_assert(offsetof(UGzKatanaComponent, MinHeightForVerticalAttack) == 0x000268, "Member 'UGzKatanaComponent::MinHeightForVerticalAttack' has a wrong offset!");
static_assert(offsetof(UGzKatanaComponent, MinPitchForHorizontalAttack) == 0x00026C, "Member 'UGzKatanaComponent::MinPitchForHorizontalAttack' has a wrong offset!");
static_assert(offsetof(UGzKatanaComponent, MaxAllowedPitch) == 0x000270, "Member 'UGzKatanaComponent::MaxAllowedPitch' has a wrong offset!");
static_assert(offsetof(UGzKatanaComponent, MaxAngleToViewHitDirection) == 0x000274, "Member 'UGzKatanaComponent::MaxAngleToViewHitDirection' has a wrong offset!");
static_assert(offsetof(UGzKatanaComponent, AimAssistTargetMarkerClass) == 0x000278, "Member 'UGzKatanaComponent::AimAssistTargetMarkerClass' has a wrong offset!");
static_assert(offsetof(UGzKatanaComponent, AimAssistTargetMarker) == 0x000280, "Member 'UGzKatanaComponent::AimAssistTargetMarker' has a wrong offset!");

// Class G01.GzDeliveryTransportSettings
// 0x0060 (0x0090 - 0x0030)
class UGzDeliveryTransportSettings final : public UDataAsset
{
public:
	TSoftClassPtr<class UClass>                   DeliveryDroneClass;                                // 0x0030(0x0028)(Edit, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftClassPtr<class UClass>                   DeliveryLocationSelectionMarker;                   // 0x0058(0x0028)(Edit, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DeliveryPathWidth;                                 // 0x0080(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LocationHeightOffset;                              // 0x0084(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DroneSpawnHeight;                                  // 0x0088(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_31AE[0x4];                                     // 0x008C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzDeliveryTransportSettings">();
	}
	static class UGzDeliveryTransportSettings* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzDeliveryTransportSettings>();
	}
};
static_assert(alignof(UGzDeliveryTransportSettings) == 0x000008, "Wrong alignment on UGzDeliveryTransportSettings");
static_assert(sizeof(UGzDeliveryTransportSettings) == 0x000090, "Wrong size on UGzDeliveryTransportSettings");
static_assert(offsetof(UGzDeliveryTransportSettings, DeliveryDroneClass) == 0x000030, "Member 'UGzDeliveryTransportSettings::DeliveryDroneClass' has a wrong offset!");
static_assert(offsetof(UGzDeliveryTransportSettings, DeliveryLocationSelectionMarker) == 0x000058, "Member 'UGzDeliveryTransportSettings::DeliveryLocationSelectionMarker' has a wrong offset!");
static_assert(offsetof(UGzDeliveryTransportSettings, DeliveryPathWidth) == 0x000080, "Member 'UGzDeliveryTransportSettings::DeliveryPathWidth' has a wrong offset!");
static_assert(offsetof(UGzDeliveryTransportSettings, LocationHeightOffset) == 0x000084, "Member 'UGzDeliveryTransportSettings::LocationHeightOffset' has a wrong offset!");
static_assert(offsetof(UGzDeliveryTransportSettings, DroneSpawnHeight) == 0x000088, "Member 'UGzDeliveryTransportSettings::DroneSpawnHeight' has a wrong offset!");

// Class G01.GzDeploymentPathComponent
// 0x0000 (0x00A8 - 0x00A8)
class UGzDeploymentPathComponent final : public UActorComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzDeploymentPathComponent">();
	}
	static class UGzDeploymentPathComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzDeploymentPathComponent>();
	}
};
static_assert(alignof(UGzDeploymentPathComponent) == 0x000008, "Wrong alignment on UGzDeploymentPathComponent");
static_assert(sizeof(UGzDeploymentPathComponent) == 0x0000A8, "Wrong size on UGzDeploymentPathComponent");

// Class G01.GzSettingEditConditionBP
// 0x0018 (0x0040 - 0x0028)
class UGzSettingEditConditionBP final : public UObject
{
public:
	class FText                                   DisableReason;                                     // 0x0028(0x0010)(BlueprintVisible, Protected, NativeAccessSpecifierProtected)
	class UGzGameSettingRegistry*                 Owner;                                             // 0x0038(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	EGzDisableSettingType GetDisableType();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzSettingEditConditionBP">();
	}
	static class UGzSettingEditConditionBP* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzSettingEditConditionBP>();
	}
};
static_assert(alignof(UGzSettingEditConditionBP) == 0x000008, "Wrong alignment on UGzSettingEditConditionBP");
static_assert(sizeof(UGzSettingEditConditionBP) == 0x000040, "Wrong size on UGzSettingEditConditionBP");
static_assert(offsetof(UGzSettingEditConditionBP, DisableReason) == 0x000028, "Member 'UGzSettingEditConditionBP::DisableReason' has a wrong offset!");
static_assert(offsetof(UGzSettingEditConditionBP, Owner) == 0x000038, "Member 'UGzSettingEditConditionBP::Owner' has a wrong offset!");

// Class G01.GzPhysicsSimulationSyncComponent
// 0x01C0 (0x0268 - 0x00A8)
class UGzPhysicsSimulationSyncComponent final : public UActorComponent
{
public:
	float                                         ForceSleepTime;                                    // 0x00A8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDelayForceSleepAtHighSpeed;                       // 0x00AC(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_31AF[0x3];                                     // 0x00AD(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         DelayForceSleepAtSpeed;                            // 0x00B0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DelayForceSleepBy;                                 // 0x00B4(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinimalSimulationDuration;                         // 0x00B8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FFloatRange                            AngularDampingRange;                               // 0x00BC(0x0010)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         IncreaseAngularDampingDuration;                    // 0x00CC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_31B0[0x10];                                    // 0x00D0(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	FMulticastInlineDelegateProperty_             OnSleepingStarted;                                 // 0x00E0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_31B1[0x10];                                    // 0x00F0(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class UMeshComponent*                         MeshComponent;                                     // 0x0100(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FGzPhysicsSimulationState              PhysicsState;                                      // 0x0108(0x0008)(Net, Transient, RepNotify, NoDestructor, NativeAccessSpecifierPrivate)
	struct FGzSkeletalPoseSyncData                TransformSyncData;                                 // 0x0110(0x0018)(Net, Transient, RepNotify, NativeAccessSpecifierPrivate)
	struct FGzPhysicsSimulationParams             SimulationParams;                                  // 0x0128(0x0030)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	uint8                                         Pad_31B2[0x110];                                   // 0x0158(0x0110)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ForceSleep();
	void OnPhysicsStartSleeping(class UPrimitiveComponent* SleepingComponent, class FName BoneName);
	void OnPoseUpdatedOfSleepingObject();
	void OnRep_PhysicsState(const struct FGzPhysicsSimulationState& PrevState);
	void OnRep_TransformSyncData();
	void Reset();
	void SetClientReadyForSimulation();
	void SetPoseReplicationFrequency(const float ReplicationsPerSecond);
	void SetUp(class UMeshComponent* InMeshComponent);
	void TryStartSimulating(const struct FGzImpulseInfo& InImpulseInfo);

	EGzPhysicsSimulationStateType GetPhysicsSimulationStateType() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzPhysicsSimulationSyncComponent">();
	}
	static class UGzPhysicsSimulationSyncComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzPhysicsSimulationSyncComponent>();
	}
};
static_assert(alignof(UGzPhysicsSimulationSyncComponent) == 0x000008, "Wrong alignment on UGzPhysicsSimulationSyncComponent");
static_assert(sizeof(UGzPhysicsSimulationSyncComponent) == 0x000268, "Wrong size on UGzPhysicsSimulationSyncComponent");
static_assert(offsetof(UGzPhysicsSimulationSyncComponent, ForceSleepTime) == 0x0000A8, "Member 'UGzPhysicsSimulationSyncComponent::ForceSleepTime' has a wrong offset!");
static_assert(offsetof(UGzPhysicsSimulationSyncComponent, bDelayForceSleepAtHighSpeed) == 0x0000AC, "Member 'UGzPhysicsSimulationSyncComponent::bDelayForceSleepAtHighSpeed' has a wrong offset!");
static_assert(offsetof(UGzPhysicsSimulationSyncComponent, DelayForceSleepAtSpeed) == 0x0000B0, "Member 'UGzPhysicsSimulationSyncComponent::DelayForceSleepAtSpeed' has a wrong offset!");
static_assert(offsetof(UGzPhysicsSimulationSyncComponent, DelayForceSleepBy) == 0x0000B4, "Member 'UGzPhysicsSimulationSyncComponent::DelayForceSleepBy' has a wrong offset!");
static_assert(offsetof(UGzPhysicsSimulationSyncComponent, MinimalSimulationDuration) == 0x0000B8, "Member 'UGzPhysicsSimulationSyncComponent::MinimalSimulationDuration' has a wrong offset!");
static_assert(offsetof(UGzPhysicsSimulationSyncComponent, AngularDampingRange) == 0x0000BC, "Member 'UGzPhysicsSimulationSyncComponent::AngularDampingRange' has a wrong offset!");
static_assert(offsetof(UGzPhysicsSimulationSyncComponent, IncreaseAngularDampingDuration) == 0x0000CC, "Member 'UGzPhysicsSimulationSyncComponent::IncreaseAngularDampingDuration' has a wrong offset!");
static_assert(offsetof(UGzPhysicsSimulationSyncComponent, OnSleepingStarted) == 0x0000E0, "Member 'UGzPhysicsSimulationSyncComponent::OnSleepingStarted' has a wrong offset!");
static_assert(offsetof(UGzPhysicsSimulationSyncComponent, MeshComponent) == 0x000100, "Member 'UGzPhysicsSimulationSyncComponent::MeshComponent' has a wrong offset!");
static_assert(offsetof(UGzPhysicsSimulationSyncComponent, PhysicsState) == 0x000108, "Member 'UGzPhysicsSimulationSyncComponent::PhysicsState' has a wrong offset!");
static_assert(offsetof(UGzPhysicsSimulationSyncComponent, TransformSyncData) == 0x000110, "Member 'UGzPhysicsSimulationSyncComponent::TransformSyncData' has a wrong offset!");
static_assert(offsetof(UGzPhysicsSimulationSyncComponent, SimulationParams) == 0x000128, "Member 'UGzPhysicsSimulationSyncComponent::SimulationParams' has a wrong offset!");

// Class G01.GzDeploymentPathSetup
// 0x0020 (0x02C0 - 0x02A0)
class AGzDeploymentPathSetup : public AActor
{
public:
	struct FGameplayTag                           ZoneTag;                                           // 0x02A0(0x0008)(Edit, DisableEditOnTemplate, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         PathLength;                                        // 0x02A8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         NumberOfTransport;                                 // 0x02AC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         DeploymentPathSpacing;                             // 0x02B0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         AllowDeploymentDistFromBorder;                     // 0x02B4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         ForceDeploymentDistFromBorder;                     // 0x02B8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_31B3[0x4];                                     // 0x02BC(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	struct FVector GetTransportOffset(int32 TransportIndex, int32 NumOfTransport) const;
	const struct FGameplayTag GetZoneTag() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzDeploymentPathSetup">();
	}
	static class AGzDeploymentPathSetup* GetDefaultObj()
	{
		return GetDefaultObjImpl<AGzDeploymentPathSetup>();
	}
};
static_assert(alignof(AGzDeploymentPathSetup) == 0x000008, "Wrong alignment on AGzDeploymentPathSetup");
static_assert(sizeof(AGzDeploymentPathSetup) == 0x0002C0, "Wrong size on AGzDeploymentPathSetup");
static_assert(offsetof(AGzDeploymentPathSetup, ZoneTag) == 0x0002A0, "Member 'AGzDeploymentPathSetup::ZoneTag' has a wrong offset!");
static_assert(offsetof(AGzDeploymentPathSetup, PathLength) == 0x0002A8, "Member 'AGzDeploymentPathSetup::PathLength' has a wrong offset!");
static_assert(offsetof(AGzDeploymentPathSetup, NumberOfTransport) == 0x0002AC, "Member 'AGzDeploymentPathSetup::NumberOfTransport' has a wrong offset!");
static_assert(offsetof(AGzDeploymentPathSetup, DeploymentPathSpacing) == 0x0002B0, "Member 'AGzDeploymentPathSetup::DeploymentPathSpacing' has a wrong offset!");
static_assert(offsetof(AGzDeploymentPathSetup, AllowDeploymentDistFromBorder) == 0x0002B4, "Member 'AGzDeploymentPathSetup::AllowDeploymentDistFromBorder' has a wrong offset!");
static_assert(offsetof(AGzDeploymentPathSetup, ForceDeploymentDistFromBorder) == 0x0002B8, "Member 'AGzDeploymentPathSetup::ForceDeploymentDistFromBorder' has a wrong offset!");

// Class G01.GzLimbSwitchedMessage
// 0x0008 (0x0038 - 0x0030)
class UGzLimbSwitchedMessage final : public UGzInstigatedMessage
{
public:
	EGzLimbType                                   LimbType;                                          // 0x0030(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_31B4[0x7];                                     // 0x0031(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzLimbSwitchedMessage">();
	}
	static class UGzLimbSwitchedMessage* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzLimbSwitchedMessage>();
	}
};
static_assert(alignof(UGzLimbSwitchedMessage) == 0x000008, "Wrong alignment on UGzLimbSwitchedMessage");
static_assert(sizeof(UGzLimbSwitchedMessage) == 0x000038, "Wrong size on UGzLimbSwitchedMessage");
static_assert(offsetof(UGzLimbSwitchedMessage, LimbType) == 0x000030, "Member 'UGzLimbSwitchedMessage::LimbType' has a wrong offset!");

// Class G01.GzDeploymentPawn
// 0x0088 (0x03B0 - 0x0328)
class AGzDeploymentPawn : public APawn
{
public:
	uint8                                         Pad_31B5[0x30];                                    // 0x0328(0x0030)(Fixing Size After Last Property [ Dumper-7 ])
	FMulticastInlineDelegateProperty_             OnDeploymentTransportReady;                        // 0x0358(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	struct FGzSoundStateKey                       DeploymentStageSoundStateKey;                      // 0x0368(0x0008)(Edit, DisableEditOnInstance, NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FGzSoundStateKey                       PawnDeployedSoundStateKey;                         // 0x0370(0x0008)(Edit, DisableEditOnInstance, NoDestructor, Protected, NativeAccessSpecifierProtected)
	class UGzPawnControlsComponent*               PawnControlsComponent;                             // 0x0378(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UGzAdvancedCameraParamsComponent*       AdvancedCameraComponent;                           // 0x0380(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class AGzDeploymentTransport*                 DeploymentTransport;                               // 0x0388(0x0008)(Net, ZeroConstructor, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_31B6[0x20];                                    // 0x0390(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnRep_DeploymentTransport();
	void ReceiveDeploymentAllowed(bool bCanPawnDeploy);
	void ServerDeploy(float ViewRotationYaw);
	void TryDeploy();

	bool CanDeploy() const;
	class AGzDeploymentTransport* GetDeploymentTransport() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzDeploymentPawn">();
	}
	static class AGzDeploymentPawn* GetDefaultObj()
	{
		return GetDefaultObjImpl<AGzDeploymentPawn>();
	}
};
static_assert(alignof(AGzDeploymentPawn) == 0x000008, "Wrong alignment on AGzDeploymentPawn");
static_assert(sizeof(AGzDeploymentPawn) == 0x0003B0, "Wrong size on AGzDeploymentPawn");
static_assert(offsetof(AGzDeploymentPawn, OnDeploymentTransportReady) == 0x000358, "Member 'AGzDeploymentPawn::OnDeploymentTransportReady' has a wrong offset!");
static_assert(offsetof(AGzDeploymentPawn, DeploymentStageSoundStateKey) == 0x000368, "Member 'AGzDeploymentPawn::DeploymentStageSoundStateKey' has a wrong offset!");
static_assert(offsetof(AGzDeploymentPawn, PawnDeployedSoundStateKey) == 0x000370, "Member 'AGzDeploymentPawn::PawnDeployedSoundStateKey' has a wrong offset!");
static_assert(offsetof(AGzDeploymentPawn, PawnControlsComponent) == 0x000378, "Member 'AGzDeploymentPawn::PawnControlsComponent' has a wrong offset!");
static_assert(offsetof(AGzDeploymentPawn, AdvancedCameraComponent) == 0x000380, "Member 'AGzDeploymentPawn::AdvancedCameraComponent' has a wrong offset!");
static_assert(offsetof(AGzDeploymentPawn, DeploymentTransport) == 0x000388, "Member 'AGzDeploymentPawn::DeploymentTransport' has a wrong offset!");

// Class G01.GzDeploymentTransport
// 0x0138 (0x04E8 - 0x03B0)
class AGzDeploymentTransport : public AGzAutoTrackTransport
{
public:
	TArray<class AGzTeam*>                        AssignedTeams;                                     // 0x03B0(0x0010)(BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnDeploymentStartMove;                             // 0x03C0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	class USkeletalMeshComponent*                 TransportMesh;                                     // 0x03D0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bUseFactionMesh;                                   // 0x03D8(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_31B7[0x7];                                     // 0x03D9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRotator                               InitialPawnRotation;                               // 0x03E0(0x0018)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FVector                                PawnDeploymentOffset;                              // 0x03F8(0x0018)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ForceDeploymentDelay;                              // 0x0410(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bAllowDeploymentByTimer;                           // 0x0414(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_31B8[0x3];                                     // 0x0415(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         DeploymentDelay;                                   // 0x0418(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_31B9[0x4];                                     // 0x041C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class AGzDeploymentPawn*>              DeploymentPawns;                                   // 0x0420(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_31BA[0x4];                                     // 0x0430(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bDeploymentEnabled;                                // 0x0434(0x0001)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_31BB[0x3];                                     // 0x0435(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class AGzDeploymentPawn*>              PendingDeploymentPawns;                            // 0x0438(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	struct FGzFaction                             TransportFaction;                                  // 0x0448(0x0048)(Transient, NativeAccessSpecifierPrivate)
	uint8                                         Pad_31BC[0x58];                                    // 0x0490(0x0058)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AddDeploymentPawn(class AGzDeploymentPawn* DeploymentPawn);
	void ForceDeployAll();
	float GetDeploymentAvailableTime();
	void OnEndReached();
	void OnRep_CanPawnsDeploy();
	void SetDeploymentEnabled(bool bEnable);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzDeploymentTransport">();
	}
	static class AGzDeploymentTransport* GetDefaultObj()
	{
		return GetDefaultObjImpl<AGzDeploymentTransport>();
	}
};
static_assert(alignof(AGzDeploymentTransport) == 0x000008, "Wrong alignment on AGzDeploymentTransport");
static_assert(sizeof(AGzDeploymentTransport) == 0x0004E8, "Wrong size on AGzDeploymentTransport");
static_assert(offsetof(AGzDeploymentTransport, AssignedTeams) == 0x0003B0, "Member 'AGzDeploymentTransport::AssignedTeams' has a wrong offset!");
static_assert(offsetof(AGzDeploymentTransport, OnDeploymentStartMove) == 0x0003C0, "Member 'AGzDeploymentTransport::OnDeploymentStartMove' has a wrong offset!");
static_assert(offsetof(AGzDeploymentTransport, TransportMesh) == 0x0003D0, "Member 'AGzDeploymentTransport::TransportMesh' has a wrong offset!");
static_assert(offsetof(AGzDeploymentTransport, bUseFactionMesh) == 0x0003D8, "Member 'AGzDeploymentTransport::bUseFactionMesh' has a wrong offset!");
static_assert(offsetof(AGzDeploymentTransport, InitialPawnRotation) == 0x0003E0, "Member 'AGzDeploymentTransport::InitialPawnRotation' has a wrong offset!");
static_assert(offsetof(AGzDeploymentTransport, PawnDeploymentOffset) == 0x0003F8, "Member 'AGzDeploymentTransport::PawnDeploymentOffset' has a wrong offset!");
static_assert(offsetof(AGzDeploymentTransport, ForceDeploymentDelay) == 0x000410, "Member 'AGzDeploymentTransport::ForceDeploymentDelay' has a wrong offset!");
static_assert(offsetof(AGzDeploymentTransport, bAllowDeploymentByTimer) == 0x000414, "Member 'AGzDeploymentTransport::bAllowDeploymentByTimer' has a wrong offset!");
static_assert(offsetof(AGzDeploymentTransport, DeploymentDelay) == 0x000418, "Member 'AGzDeploymentTransport::DeploymentDelay' has a wrong offset!");
static_assert(offsetof(AGzDeploymentTransport, DeploymentPawns) == 0x000420, "Member 'AGzDeploymentTransport::DeploymentPawns' has a wrong offset!");
static_assert(offsetof(AGzDeploymentTransport, bDeploymentEnabled) == 0x000434, "Member 'AGzDeploymentTransport::bDeploymentEnabled' has a wrong offset!");
static_assert(offsetof(AGzDeploymentTransport, PendingDeploymentPawns) == 0x000438, "Member 'AGzDeploymentTransport::PendingDeploymentPawns' has a wrong offset!");
static_assert(offsetof(AGzDeploymentTransport, TransportFaction) == 0x000448, "Member 'AGzDeploymentTransport::TransportFaction' has a wrong offset!");

// Class G01.GzDepthOfFieldDataAsset
// 0x0020 (0x0050 - 0x0030)
class UGzDepthOfFieldDataAsset final : public UDataAsset
{
public:
	float                                         NearDistance;                                      // 0x0030(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FarDistance;                                       // 0x0034(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGzDepthOfFieldCameraSettings          CameraSettings;                                    // 0x0038(0x0018)(Edit, NoDestructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzDepthOfFieldDataAsset">();
	}
	static class UGzDepthOfFieldDataAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzDepthOfFieldDataAsset>();
	}
};
static_assert(alignof(UGzDepthOfFieldDataAsset) == 0x000008, "Wrong alignment on UGzDepthOfFieldDataAsset");
static_assert(sizeof(UGzDepthOfFieldDataAsset) == 0x000050, "Wrong size on UGzDepthOfFieldDataAsset");
static_assert(offsetof(UGzDepthOfFieldDataAsset, NearDistance) == 0x000030, "Member 'UGzDepthOfFieldDataAsset::NearDistance' has a wrong offset!");
static_assert(offsetof(UGzDepthOfFieldDataAsset, FarDistance) == 0x000034, "Member 'UGzDepthOfFieldDataAsset::FarDistance' has a wrong offset!");
static_assert(offsetof(UGzDepthOfFieldDataAsset, CameraSettings) == 0x000038, "Member 'UGzDepthOfFieldDataAsset::CameraSettings' has a wrong offset!");

// Class G01.GzDestructibleComponent
// 0x0000 (0x0F70 - 0x0F70)
class UGzDestructibleComponent final : public USkeletalMeshComponent
{
public:
	bool                                          bUseTightBounds;                                   // 0x0F68(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_31BD[0x7];                                     // 0x0F69(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzDestructibleComponent">();
	}
	static class UGzDestructibleComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzDestructibleComponent>();
	}
};
static_assert(alignof(UGzDestructibleComponent) == 0x000010, "Wrong alignment on UGzDestructibleComponent");
static_assert(sizeof(UGzDestructibleComponent) == 0x000F70, "Wrong size on UGzDestructibleComponent");
static_assert(offsetof(UGzDestructibleComponent, bUseTightBounds) == 0x000F68, "Member 'UGzDestructibleComponent::bUseTightBounds' has a wrong offset!");

// Class G01.GzImpulseAffectedInterface
// 0x0000 (0x0028 - 0x0028)
class IGzImpulseAffectedInterface final : public IInterface
{
public:
	void AddDampedImpulse(const struct FVector& Impulse);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzImpulseAffectedInterface">();
	}
	static class IGzImpulseAffectedInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IGzImpulseAffectedInterface>();
	}
};
static_assert(alignof(IGzImpulseAffectedInterface) == 0x000008, "Wrong alignment on IGzImpulseAffectedInterface");
static_assert(sizeof(IGzImpulseAffectedInterface) == 0x000028, "Wrong size on IGzImpulseAffectedInterface");

// Class G01.GzFloatingStatusBarWidget
// 0x0000 (0x02E0 - 0x02E0)
class UGzFloatingStatusBarWidget : public UUserWidget
{
public:
	void SetHealthPercentage(float HealthPercentage);
	void SetName(const class FText& NewName);
	void SetOwnerActor(class AActor* Actor);

	bool ShouldShow() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzFloatingStatusBarWidget">();
	}
	static class UGzFloatingStatusBarWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzFloatingStatusBarWidget>();
	}
};
static_assert(alignof(UGzFloatingStatusBarWidget) == 0x000008, "Wrong alignment on UGzFloatingStatusBarWidget");
static_assert(sizeof(UGzFloatingStatusBarWidget) == 0x0002E0, "Wrong size on UGzFloatingStatusBarWidget");

// Class G01.GzJobZeroPlayArea
// 0x0020 (0x02C0 - 0x02A0)
class AGzJobZeroPlayArea final : public AActor
{
public:
	class USplineComponent*                       AreaSpline;                                        // 0x02A0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UProceduralMeshComponent*               AreaMesh;                                          // 0x02A8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UMaterialInterface*                     Material;                                          // 0x02B0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         WallHalfHeight;                                    // 0x02B8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_31BE[0x4];                                     // 0x02BC(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzJobZeroPlayArea">();
	}
	static class AGzJobZeroPlayArea* GetDefaultObj()
	{
		return GetDefaultObjImpl<AGzJobZeroPlayArea>();
	}
};
static_assert(alignof(AGzJobZeroPlayArea) == 0x000008, "Wrong alignment on AGzJobZeroPlayArea");
static_assert(sizeof(AGzJobZeroPlayArea) == 0x0002C0, "Wrong size on AGzJobZeroPlayArea");
static_assert(offsetof(AGzJobZeroPlayArea, AreaSpline) == 0x0002A0, "Member 'AGzJobZeroPlayArea::AreaSpline' has a wrong offset!");
static_assert(offsetof(AGzJobZeroPlayArea, AreaMesh) == 0x0002A8, "Member 'AGzJobZeroPlayArea::AreaMesh' has a wrong offset!");
static_assert(offsetof(AGzJobZeroPlayArea, Material) == 0x0002B0, "Member 'AGzJobZeroPlayArea::Material' has a wrong offset!");
static_assert(offsetof(AGzJobZeroPlayArea, WallHalfHeight) == 0x0002B8, "Member 'AGzJobZeroPlayArea::WallHalfHeight' has a wrong offset!");

// Class G01.GzFloatingStatusBarDestructibleWidget
// 0x0010 (0x02F0 - 0x02E0)
class UGzFloatingStatusBarDestructibleWidget final : public UGzFloatingStatusBarWidget
{
public:
	uint8                                         Pad_31BF[0x8];                                     // 0x02E0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         DrawDistance;                                      // 0x02E8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_31C0[0x4];                                     // 0x02EC(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzFloatingStatusBarDestructibleWidget">();
	}
	static class UGzFloatingStatusBarDestructibleWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzFloatingStatusBarDestructibleWidget>();
	}
};
static_assert(alignof(UGzFloatingStatusBarDestructibleWidget) == 0x000008, "Wrong alignment on UGzFloatingStatusBarDestructibleWidget");
static_assert(sizeof(UGzFloatingStatusBarDestructibleWidget) == 0x0002F0, "Wrong size on UGzFloatingStatusBarDestructibleWidget");
static_assert(offsetof(UGzFloatingStatusBarDestructibleWidget, DrawDistance) == 0x0002E8, "Member 'UGzFloatingStatusBarDestructibleWidget::DrawDistance' has a wrong offset!");

// Class G01.GzPhosphorousDartProjectile
// 0x0158 (0x04A0 - 0x0348)
class AGzPhosphorousDartProjectile : public AGzProjectileBase
{
public:
	class UGzExplosionComponent*                  ExplosionComponent;                                // 0x0348(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DetonationDelaySeconds;                            // 0x0350(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_31C1[0x4];                                     // 0x0354(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UGzGE_BaseDamage>           OverlapDamageEffect;                               // 0x0358(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PostExplodeLifeSpanSeconds;                        // 0x0360(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxValidSurfaceDistance;                           // 0x0364(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAllowOverlapFriendlyFire;                         // 0x0368(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_31C2[0x7];                                     // 0x0369(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UGzCheckedOverlapSphereComponent*       OverlapSphere;                                     // 0x0370(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bShouldDoExtraStuckDamage;                         // 0x0378(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_31C3[0x7];                                     // 0x0379(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UGzGE_BaseDamage>           StuckAttackDamageEffect;                           // 0x0380(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class AActor*                                 HitActor;                                          // 0x0388(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FHitResult                             ImpactHit;                                         // 0x0390(0x00F8)(Net, IsPlainOldData, RepNotify, NoDestructor, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	struct FTimerHandle                           DetonationTimer;                                   // 0x0488(0x0008)(NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<struct FActiveGameplayEffectHandle>    ActiveEffectHandles;                               // 0x0490(0x0010)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)

public:
	void BP_OnHit(const struct FHitResult& Hit);
	void BP_OnLaunched();
	void BP_OnSpawnOverlap();
	void OnRep_ImpactHit();
	void OnSphereOverlapBegin(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const struct FHitResult& SweepResult);
	void OnSphereOverlapEnd(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzPhosphorousDartProjectile">();
	}
	static class AGzPhosphorousDartProjectile* GetDefaultObj()
	{
		return GetDefaultObjImpl<AGzPhosphorousDartProjectile>();
	}
};
static_assert(alignof(AGzPhosphorousDartProjectile) == 0x000008, "Wrong alignment on AGzPhosphorousDartProjectile");
static_assert(sizeof(AGzPhosphorousDartProjectile) == 0x0004A0, "Wrong size on AGzPhosphorousDartProjectile");
static_assert(offsetof(AGzPhosphorousDartProjectile, ExplosionComponent) == 0x000348, "Member 'AGzPhosphorousDartProjectile::ExplosionComponent' has a wrong offset!");
static_assert(offsetof(AGzPhosphorousDartProjectile, DetonationDelaySeconds) == 0x000350, "Member 'AGzPhosphorousDartProjectile::DetonationDelaySeconds' has a wrong offset!");
static_assert(offsetof(AGzPhosphorousDartProjectile, OverlapDamageEffect) == 0x000358, "Member 'AGzPhosphorousDartProjectile::OverlapDamageEffect' has a wrong offset!");
static_assert(offsetof(AGzPhosphorousDartProjectile, PostExplodeLifeSpanSeconds) == 0x000360, "Member 'AGzPhosphorousDartProjectile::PostExplodeLifeSpanSeconds' has a wrong offset!");
static_assert(offsetof(AGzPhosphorousDartProjectile, MaxValidSurfaceDistance) == 0x000364, "Member 'AGzPhosphorousDartProjectile::MaxValidSurfaceDistance' has a wrong offset!");
static_assert(offsetof(AGzPhosphorousDartProjectile, bAllowOverlapFriendlyFire) == 0x000368, "Member 'AGzPhosphorousDartProjectile::bAllowOverlapFriendlyFire' has a wrong offset!");
static_assert(offsetof(AGzPhosphorousDartProjectile, OverlapSphere) == 0x000370, "Member 'AGzPhosphorousDartProjectile::OverlapSphere' has a wrong offset!");
static_assert(offsetof(AGzPhosphorousDartProjectile, bShouldDoExtraStuckDamage) == 0x000378, "Member 'AGzPhosphorousDartProjectile::bShouldDoExtraStuckDamage' has a wrong offset!");
static_assert(offsetof(AGzPhosphorousDartProjectile, StuckAttackDamageEffect) == 0x000380, "Member 'AGzPhosphorousDartProjectile::StuckAttackDamageEffect' has a wrong offset!");
static_assert(offsetof(AGzPhosphorousDartProjectile, HitActor) == 0x000388, "Member 'AGzPhosphorousDartProjectile::HitActor' has a wrong offset!");
static_assert(offsetof(AGzPhosphorousDartProjectile, ImpactHit) == 0x000390, "Member 'AGzPhosphorousDartProjectile::ImpactHit' has a wrong offset!");
static_assert(offsetof(AGzPhosphorousDartProjectile, DetonationTimer) == 0x000488, "Member 'AGzPhosphorousDartProjectile::DetonationTimer' has a wrong offset!");
static_assert(offsetof(AGzPhosphorousDartProjectile, ActiveEffectHandles) == 0x000490, "Member 'AGzPhosphorousDartProjectile::ActiveEffectHandles' has a wrong offset!");

// Class G01.GzDestructibleActor
// 0x0080 (0x0320 - 0x02A0)
class AGzDestructibleActor final : public AActor
{
public:
	uint8                                         Pad_31C6[0x38];                                    // 0x02A0(0x0038)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MaxHealth;                                         // 0x02D8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_31C7[0x4];                                     // 0x02DC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UGzDestructibleComponent*               DestructibleComponent;                             // 0x02E0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UGzFloatingStatusBarWidget> UIFloatingStatusBarClass;                          // 0x02E8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetComponent*                       UIFloatingStatusBarComponent;                      // 0x02F0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UGzAbilitySystemComponent*              ASC;                                               // 0x02F8(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UGzDamageableComponent*                 DamageableComponent;                               // 0x0300(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UGzAliveObjectAttributeSet*             AliveObjectAttributeSet;                           // 0x0308(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_31C8[0x8];                                     // 0x0310(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UGzFloatingStatusBarWidget*             UIFloatingStatusBar;                               // 0x0318(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void OnHealthChanged(float Health);

	bool IsDestructed() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzDestructibleActor">();
	}
	static class AGzDestructibleActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<AGzDestructibleActor>();
	}
};
static_assert(alignof(AGzDestructibleActor) == 0x000008, "Wrong alignment on AGzDestructibleActor");
static_assert(sizeof(AGzDestructibleActor) == 0x000320, "Wrong size on AGzDestructibleActor");
static_assert(offsetof(AGzDestructibleActor, MaxHealth) == 0x0002D8, "Member 'AGzDestructibleActor::MaxHealth' has a wrong offset!");
static_assert(offsetof(AGzDestructibleActor, DestructibleComponent) == 0x0002E0, "Member 'AGzDestructibleActor::DestructibleComponent' has a wrong offset!");
static_assert(offsetof(AGzDestructibleActor, UIFloatingStatusBarClass) == 0x0002E8, "Member 'AGzDestructibleActor::UIFloatingStatusBarClass' has a wrong offset!");
static_assert(offsetof(AGzDestructibleActor, UIFloatingStatusBarComponent) == 0x0002F0, "Member 'AGzDestructibleActor::UIFloatingStatusBarComponent' has a wrong offset!");
static_assert(offsetof(AGzDestructibleActor, ASC) == 0x0002F8, "Member 'AGzDestructibleActor::ASC' has a wrong offset!");
static_assert(offsetof(AGzDestructibleActor, DamageableComponent) == 0x000300, "Member 'AGzDestructibleActor::DamageableComponent' has a wrong offset!");
static_assert(offsetof(AGzDestructibleActor, AliveObjectAttributeSet) == 0x000308, "Member 'AGzDestructibleActor::AliveObjectAttributeSet' has a wrong offset!");
static_assert(offsetof(AGzDestructibleActor, UIFloatingStatusBar) == 0x000318, "Member 'AGzDestructibleActor::UIFloatingStatusBar' has a wrong offset!");

// Class G01.GzHexSpawnedStatCollector
// 0x0008 (0x0040 - 0x0038)
class UGzHexSpawnedStatCollector final : public UGzGlobalStatsCollector
{
public:
	uint8                                         Pad_31C9[0x8];                                     // 0x0038(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzHexSpawnedStatCollector">();
	}
	static class UGzHexSpawnedStatCollector* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzHexSpawnedStatCollector>();
	}
};
static_assert(alignof(UGzHexSpawnedStatCollector) == 0x000008, "Wrong alignment on UGzHexSpawnedStatCollector");
static_assert(sizeof(UGzHexSpawnedStatCollector) == 0x000040, "Wrong size on UGzHexSpawnedStatCollector");

// Class G01.GzDestructibleBase
// 0x0038 (0x02D8 - 0x02A0)
class AGzDestructibleBase final : public AActor
{
public:
	bool                                          bClientOnly;                                       // 0x02A0(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_31CA[0x3];                                     // 0x02A1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	uint32                                        HitMask;                                           // 0x02A4(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint32                                        DestroyHitMask;                                    // 0x02A8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bGenerateHitEvenWhenDestroyed;                     // 0x02AC(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_31CB[0x3];                                     // 0x02AD(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ImpulseToDestroy;                                  // 0x02B0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         ForceSyncTime;                                     // 0x02B4(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bDisableCollisionOnDedicatedServer;                // 0x02B8(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bDestroyActorOnClient;                             // 0x02B9(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_31CC[0x2];                                     // 0x02BA(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ClientDestroyDelay;                                // 0x02BC(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bAuthorityDestroyed;                               // 0x02C0(0x0001)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_31CD[0x17];                                    // 0x02C1(0x0017)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void DestroyOnClient();
	void OnRep_AuthorityDestroyed();
	void ReceiveDestructibleDestroyed(const struct FVector& DestructionImpulse);
	void ReceiveDestructibleHit(const struct FVector& HitImpulse);

	EGzDestructibleHitType GetDestroyHitMask() const;
	EGzDestructibleHitType GetHitMask() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzDestructibleBase">();
	}
	static class AGzDestructibleBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<AGzDestructibleBase>();
	}
};
static_assert(alignof(AGzDestructibleBase) == 0x000008, "Wrong alignment on AGzDestructibleBase");
static_assert(sizeof(AGzDestructibleBase) == 0x0002D8, "Wrong size on AGzDestructibleBase");
static_assert(offsetof(AGzDestructibleBase, bClientOnly) == 0x0002A0, "Member 'AGzDestructibleBase::bClientOnly' has a wrong offset!");
static_assert(offsetof(AGzDestructibleBase, HitMask) == 0x0002A4, "Member 'AGzDestructibleBase::HitMask' has a wrong offset!");
static_assert(offsetof(AGzDestructibleBase, DestroyHitMask) == 0x0002A8, "Member 'AGzDestructibleBase::DestroyHitMask' has a wrong offset!");
static_assert(offsetof(AGzDestructibleBase, bGenerateHitEvenWhenDestroyed) == 0x0002AC, "Member 'AGzDestructibleBase::bGenerateHitEvenWhenDestroyed' has a wrong offset!");
static_assert(offsetof(AGzDestructibleBase, ImpulseToDestroy) == 0x0002B0, "Member 'AGzDestructibleBase::ImpulseToDestroy' has a wrong offset!");
static_assert(offsetof(AGzDestructibleBase, ForceSyncTime) == 0x0002B4, "Member 'AGzDestructibleBase::ForceSyncTime' has a wrong offset!");
static_assert(offsetof(AGzDestructibleBase, bDisableCollisionOnDedicatedServer) == 0x0002B8, "Member 'AGzDestructibleBase::bDisableCollisionOnDedicatedServer' has a wrong offset!");
static_assert(offsetof(AGzDestructibleBase, bDestroyActorOnClient) == 0x0002B9, "Member 'AGzDestructibleBase::bDestroyActorOnClient' has a wrong offset!");
static_assert(offsetof(AGzDestructibleBase, ClientDestroyDelay) == 0x0002BC, "Member 'AGzDestructibleBase::ClientDestroyDelay' has a wrong offset!");
static_assert(offsetof(AGzDestructibleBase, bAuthorityDestroyed) == 0x0002C0, "Member 'AGzDestructibleBase::bAuthorityDestroyed' has a wrong offset!");

// Class G01.GzInvStatics
// 0x0000 (0x0028 - 0x0028)
class UGzInvStatics final : public UBlueprintFunctionLibrary
{
public:
	static bool CanAddItem(const class UGzInvComponent* Inventory, const struct FGzInvItem& Item, bool bAllowSwap);
	static void EquipLoadout(class UGzInvComponent* Inventory, const TArray<struct FGzInvItem>& Items, bool bDropReplacedItems);
	static TArray<struct FGzInvItem> GetAllItems(const class UGzInvComponent* Inventory);
	static float GetAttributeFromItemByTag(const struct FGzInvItem& Item, const struct FGameplayTag& Tag);
	static int32 GetCapacityToAutoStack(const class UGzInvComponent* Inventory, const struct FGzInvItem& Item);
	static float GetDefaultAttributeFromItemByTag(const struct FGzInvItem& Item, const struct FGameplayTag& Tag);
	static float GetDefaultAttributeFromItemDataByTag(const class UGzItemData* ItemData, const struct FGameplayTag& Tag);
	static TArray<struct FGzInvPocket> GetDefaultPockets(const class UGzInvComponent* Inventory);
	static struct FGzInvItem GetHighestRarityItem(const TArray<struct FGzInvItem>& Items);
	static int32 GetItemCountByItemData(const class UGzInvComponent* Inventory, const class UGzItemData* ItemData);
	static int32 GetItemCountByType(const class UGzInvComponent* Inventory, const struct FGameplayTag& ItemType);
	static class UGzItemData* GetItemData(const struct FGzInvItem& Item);
	static class UGzItemData* GetItemDataByItemType(const class UGzInvComponent* Inventory, const struct FGameplayTag& Slot);
	static int32 GetItemQuantity(const struct FGzInvItem& Item);
	static TArray<struct FGzInvItem> GetItemsByItemData(const class UGzInvComponent* Inventory, const class UGzItemData* ItemData);
	static TArray<struct FGzInvItem> GetItemsByItemType(const class UGzInvComponent* Inventory, const struct FGameplayTag& ItemType);
	static TArray<struct FGzInvItem> GetItemsBySlot(const class UGzInvComponent* Inventory, const struct FGameplayTag& Slot);
	static struct FGzLimbInvItem GetLimbItem(const struct FGzInvItem& Item, EGzExecResult* ExecResult);
	static EGzLimbType GetLimbTypeBySlot(const struct FGameplayTag& Slot);
	static const struct FGzInvPocket GetPocketByItemData(const class UGzInvComponent* Inventory, const class UGzItemData* ItemData);
	static const struct FGzInvPocket GetPocketByItemType(const class UGzInvComponent* Inventory, const struct FGameplayTag& ItemType);
	static const struct FGzInvPocket GetPocketBySlot(const class UGzInvComponent* Inventory, const struct FGameplayTag& Slot);
	static TArray<struct FGzInvPocket> GetPocketsByItemData(const class UGzInvComponent* Inventory, const class UGzItemData* ItemData);
	static TArray<struct FGzInvPocket> GetPocketsByItemType(const class UGzInvComponent* Inventory, const struct FGameplayTag& ItemType);
	static TArray<struct FGzInvPocket> GetPocketsBySlot(const class UGzInvComponent* Inventory, const struct FGameplayTag& Slot);
	static struct FGzSimpleInvItem GetSimpleItem(const struct FGzInvItem& Item, EGzExecResult* ExecResult);
	static TArray<struct FGzInvItem> GetSortedByRarity(const TArray<struct FGzInvItem>& Items, bool bAscending);
	static TArray<struct FGzInvPocket> GetVirtualPockets(const class UGzInvComponent* Inventory);
	static struct FGzWeaponInvItem GetWeaponItem(const struct FGzInvItem& Item, EGzExecResult* ExecResult);
	static bool HasItemInSlot(const class UGzInvComponent* Inventory, const struct FGameplayTag& Slot);
	static bool HasItemOfType(const class UGzInvComponent* Inventory, const struct FGameplayTag& ItemType);
	static bool HasItemWithData(const class UGzInvComponent* Inventory, const class UGzItemData* ItemData);
	static bool IsAmmoItemType(const struct FGameplayTag& Type);
	static bool IsBackpackItemType(const struct FGameplayTag& Type);
	static bool IsConsumableItemType(const struct FGameplayTag& Type);
	static bool IsEmptyPocket(const struct FGzInvPocket& Pocket);
	static bool IsEqualPocketIds(const struct FGzInvPocketId& LHS, const struct FGzInvPocketId& RHS);
	static bool IsInGameCurrencyItemType(const struct FGameplayTag& Type);
	static bool IsLimbItemType(const struct FGameplayTag& Type);
	static bool IsPrimaryWeaponItemType(const struct FGameplayTag& Type);
	static bool IsSidearmItemType(const struct FGameplayTag& Type);
	static bool IsValidItem(const struct FGzInvItem& Item);
	static bool IsValidPocket(const struct FGzInvPocket& Pocket);
	static bool IsWeaponItemType(const struct FGameplayTag& Type);
	static struct FGzInvItem MakeItemFromContent(const struct FGzInventoryItemContent& Content);
	static struct FGzInvItem MakeItemFromLimb(const struct FGzLimbInvItem& Item);
	static struct FGzInvItem MakeItemFromSimple(const struct FGzSimpleInvItem& Item);
	static struct FGzInvItem MakeItemFromWeapon(const struct FGzWeaponInvItem& Item);
	static bool MatchItemToType(const struct FGzInvItem& Item, const struct FGameplayTag& ItemType);
	static void SubscribeToInventoryItemChange(class UGzInvComponent* Inventory, struct FGzItemChangeHandle& Handle, const TDelegate<void(struct FGzInvItem& Item, EGzInvChangeEvent ChangeEvent)>& Filter, const TDelegate<void(struct FGzInvItem& ItemDelta, EGzInvChangeEvent Event)>& Callback);
	static void SubscribeToInventoryPocketChange(class UGzInvComponent* Inventory, struct FGzPocketChangeHandle& Handle, const TDelegate<void(struct FGzInvPocketDef& PocketDef, struct FGzInvPocket& Pocket)>& Filter, const TDelegate<void(struct FGzInvPocketChangeData& PocketChangeData)>& Callback);
	static bool TryConsumeInGameCurrency(class UGzInvComponent* Inventory, int32 Quantity);
	static void UnsubscribeFromItemChange(struct FGzItemChangeHandle& Handle);
	static void UnsubscribeFromPocketChange(struct FGzPocketChangeHandle& Handle);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzInvStatics">();
	}
	static class UGzInvStatics* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzInvStatics>();
	}
};
static_assert(alignof(UGzInvStatics) == 0x000008, "Wrong alignment on UGzInvStatics");
static_assert(sizeof(UGzInvStatics) == 0x000028, "Wrong size on UGzInvStatics");

// Class G01.GzDestructibleHeatSink
// 0x0020 (0x02C0 - 0x02A0)
class AGzDestructibleHeatSink : public AActor
{
public:
	class UGzDamageableComponent*                 DamageableComponent;                               // 0x02A0(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class AGzExtractorTowerSupply*                HeatSinkOwner;                                     // 0x02A8(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_31EF[0x10];                                    // 0x02B0(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnMultiHit(class UGzDamageableComponent* Receiver, const struct FGzMultiHitDamage& MultiHit);
	void OnSingleHit(class UGzDamageableComponent* Receiver, const struct FGzSingleHitDamage& SingleHit);
	void ReceiveDestroy(const struct FHitResult& HitResult, bool bInstant);
	void ReceiveReset();
	void SetOwningTeam(int32 TeamID);

	bool IsDestroyed() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzDestructibleHeatSink">();
	}
	static class AGzDestructibleHeatSink* GetDefaultObj()
	{
		return GetDefaultObjImpl<AGzDestructibleHeatSink>();
	}
};
static_assert(alignof(AGzDestructibleHeatSink) == 0x000008, "Wrong alignment on AGzDestructibleHeatSink");
static_assert(sizeof(AGzDestructibleHeatSink) == 0x0002C0, "Wrong size on AGzDestructibleHeatSink");
static_assert(offsetof(AGzDestructibleHeatSink, DamageableComponent) == 0x0002A0, "Member 'AGzDestructibleHeatSink::DamageableComponent' has a wrong offset!");
static_assert(offsetof(AGzDestructibleHeatSink, HeatSinkOwner) == 0x0002A8, "Member 'AGzDestructibleHeatSink::HeatSinkOwner' has a wrong offset!");

// Class G01.GzDeveloperSettings
// 0x0000 (0x0038 - 0x0038)
class UGzDeveloperSettings final : public UDeveloperSettingsBackedByCVars
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzDeveloperSettings">();
	}
	static class UGzDeveloperSettings* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzDeveloperSettings>();
	}
};
static_assert(alignof(UGzDeveloperSettings) == 0x000008, "Wrong alignment on UGzDeveloperSettings");
static_assert(sizeof(UGzDeveloperSettings) == 0x000038, "Wrong size on UGzDeveloperSettings");

// Class G01.GzRewardData
// 0x00D8 (0x0108 - 0x0030)
class UGzRewardData final : public UPrimaryDataAsset
{
public:
	uint8                                         Pad_31F1[0x8];                                     // 0x0030(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   Description;                                       // 0x0038(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	TMap<EGzBlockchainCoinType, double>           Coins;                                             // 0x0048(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	TMap<EGzVirtualCurrencyType, int32>           VirtualCurrencies;                                 // 0x0098(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	int32                                         ProgressXp;                                        // 0x00E8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PlayerXpModifier;                                  // 0x00EC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BattlePassXpModifier;                              // 0x00F0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_31F2[0x4];                                     // 0x00F4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FGzExpirableItemData>           GrantItems;                                        // 0x00F8(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	class FString GetIdentifierString() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzRewardData">();
	}
	static class UGzRewardData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzRewardData>();
	}
};
static_assert(alignof(UGzRewardData) == 0x000008, "Wrong alignment on UGzRewardData");
static_assert(sizeof(UGzRewardData) == 0x000108, "Wrong size on UGzRewardData");
static_assert(offsetof(UGzRewardData, Description) == 0x000038, "Member 'UGzRewardData::Description' has a wrong offset!");
static_assert(offsetof(UGzRewardData, Coins) == 0x000048, "Member 'UGzRewardData::Coins' has a wrong offset!");
static_assert(offsetof(UGzRewardData, VirtualCurrencies) == 0x000098, "Member 'UGzRewardData::VirtualCurrencies' has a wrong offset!");
static_assert(offsetof(UGzRewardData, ProgressXp) == 0x0000E8, "Member 'UGzRewardData::ProgressXp' has a wrong offset!");
static_assert(offsetof(UGzRewardData, PlayerXpModifier) == 0x0000EC, "Member 'UGzRewardData::PlayerXpModifier' has a wrong offset!");
static_assert(offsetof(UGzRewardData, BattlePassXpModifier) == 0x0000F0, "Member 'UGzRewardData::BattlePassXpModifier' has a wrong offset!");
static_assert(offsetof(UGzRewardData, GrantItems) == 0x0000F8, "Member 'UGzRewardData::GrantItems' has a wrong offset!");

// Class G01.GzDisplayNameMaintainingComponent
// 0x0018 (0x00B8 - 0x00A0)
class UGzDisplayNameMaintainingComponent final : public UGzServiceComponent
{
public:
	uint8                                         Pad_31F3[0x18];                                    // 0x00A0(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzDisplayNameMaintainingComponent">();
	}
	static class UGzDisplayNameMaintainingComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzDisplayNameMaintainingComponent>();
	}
};
static_assert(alignof(UGzDisplayNameMaintainingComponent) == 0x000008, "Wrong alignment on UGzDisplayNameMaintainingComponent");
static_assert(sizeof(UGzDisplayNameMaintainingComponent) == 0x0000B8, "Wrong size on UGzDisplayNameMaintainingComponent");

// Class G01.GzDM_MatchInProgressStage
// 0x0058 (0x0170 - 0x0118)
class UGzDM_MatchInProgressStage final : public UGzMatchInProgressStage
{
public:
	TMap<int32, struct FGzTeamSpawnPoints>        TeamSpawnPoints;                                   // 0x0118(0x0050)(Transient, Protected, NativeAccessSpecifierProtected)
	class AGzBoundaryZone*                        BoundaryZone;                                      // 0x0168(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzDM_MatchInProgressStage">();
	}
	static class UGzDM_MatchInProgressStage* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzDM_MatchInProgressStage>();
	}
};
static_assert(alignof(UGzDM_MatchInProgressStage) == 0x000008, "Wrong alignment on UGzDM_MatchInProgressStage");
static_assert(sizeof(UGzDM_MatchInProgressStage) == 0x000170, "Wrong size on UGzDM_MatchInProgressStage");
static_assert(offsetof(UGzDM_MatchInProgressStage, TeamSpawnPoints) == 0x000118, "Member 'UGzDM_MatchInProgressStage::TeamSpawnPoints' has a wrong offset!");
static_assert(offsetof(UGzDM_MatchInProgressStage, BoundaryZone) == 0x000168, "Member 'UGzDM_MatchInProgressStage::BoundaryZone' has a wrong offset!");

// Class G01.GzDomeShield
// 0x0000 (0x0300 - 0x0300)
class AGzDomeShield : public AGzDamageableActor
{
public:
	void SpawnBulletImpactVFX(const struct FVector& HitLocation, const struct FRotator& HitRotation);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzDomeShield">();
	}
	static class AGzDomeShield* GetDefaultObj()
	{
		return GetDefaultObjImpl<AGzDomeShield>();
	}
};
static_assert(alignof(AGzDomeShield) == 0x000008, "Wrong alignment on AGzDomeShield");
static_assert(sizeof(AGzDomeShield) == 0x000300, "Wrong size on AGzDomeShield");

// Class G01.GzShootingRangeGameState
// 0x0000 (0x0678 - 0x0678)
class AGzShootingRangeGameState final : public AGzMultiStageGameState
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzShootingRangeGameState">();
	}
	static class AGzShootingRangeGameState* GetDefaultObj()
	{
		return GetDefaultObjImpl<AGzShootingRangeGameState>();
	}
};
static_assert(alignof(AGzShootingRangeGameState) == 0x000008, "Wrong alignment on AGzShootingRangeGameState");
static_assert(sizeof(AGzShootingRangeGameState) == 0x000678, "Wrong size on AGzShootingRangeGameState");

// Class G01.GzDoorBase
// 0x0048 (0x02E8 - 0x02A0)
class AGzDoorBase : public AActor
{
public:
	FMulticastInlineDelegateProperty_             OnLockedStateChanged;                              // 0x02A0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnOpenStateChanged;                                // 0x02B0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	class UGzInteractableComponent*               InteractableComponent;                             // 0x02C0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBoxComponent*                          OpenDoorTrigger;                                   // 0x02C8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bLocked;                                           // 0x02D0(0x0001)(Edit, Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_31F4[0x3];                                     // 0x02D1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         StateTransitionTime;                               // 0x02D4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bOpenByDefault;                                    // 0x02D8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bAutomaticDoor;                                    // 0x02D9(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bDisableInteractionDuringTransition;               // 0x02DA(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bShowInteractionTooltipIfDisabled;                 // 0x02DB(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EGzDoorState                                  State;                                             // 0x02DC(0x0001)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_31F5[0xB];                                     // 0x02DD(0x000B)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	bool GetShowInteractionTooltipIfDisabled();
	void OnComponentBeginOverlap(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const struct FHitResult& SweepResult);
	void OnComponentEndOverlap(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex);
	void OnInteract(class AActor* InteractedBy, const class UGzInteractableComponent* Interactable);
	void OnRep_Locked();
	void OnRep_State(EGzDoorState OldState);
	void ReceiveDynamicStateChanged(bool bOpening);
	void ReceiveLockedStateChanged(bool bNewLocked);
	void ReceiveStaticStateChanged(bool bOpened);
	void SetIsLocked(bool bNewLocked);
	void SetOpen(bool bInOpen);
	void SetShowInteractionTooltipIfDisabled(bool bNewShowTooltip);
	void SetTransitionTime(const float Time);
	bool ShouldReactToOverlappedActor(class AActor* Actor);

	EGzDoorState GetDoorState() const;
	float GetMontagePlaybackRate(const class UAnimMontage* Montage) const;
	float GetMontageStartingPosition(const class UAnimMontage* Montage, bool bOpenMontage) const;
	float GetTransitionProgress() const;
	float GetTransitionTime() const;
	bool IsAutomaticDoor() const;
	bool IsCloseState() const;
	bool IsLocked() const;
	bool IsOpenState() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzDoorBase">();
	}
	static class AGzDoorBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<AGzDoorBase>();
	}
};
static_assert(alignof(AGzDoorBase) == 0x000008, "Wrong alignment on AGzDoorBase");
static_assert(sizeof(AGzDoorBase) == 0x0002E8, "Wrong size on AGzDoorBase");
static_assert(offsetof(AGzDoorBase, OnLockedStateChanged) == 0x0002A0, "Member 'AGzDoorBase::OnLockedStateChanged' has a wrong offset!");
static_assert(offsetof(AGzDoorBase, OnOpenStateChanged) == 0x0002B0, "Member 'AGzDoorBase::OnOpenStateChanged' has a wrong offset!");
static_assert(offsetof(AGzDoorBase, InteractableComponent) == 0x0002C0, "Member 'AGzDoorBase::InteractableComponent' has a wrong offset!");
static_assert(offsetof(AGzDoorBase, OpenDoorTrigger) == 0x0002C8, "Member 'AGzDoorBase::OpenDoorTrigger' has a wrong offset!");
static_assert(offsetof(AGzDoorBase, bLocked) == 0x0002D0, "Member 'AGzDoorBase::bLocked' has a wrong offset!");
static_assert(offsetof(AGzDoorBase, StateTransitionTime) == 0x0002D4, "Member 'AGzDoorBase::StateTransitionTime' has a wrong offset!");
static_assert(offsetof(AGzDoorBase, bOpenByDefault) == 0x0002D8, "Member 'AGzDoorBase::bOpenByDefault' has a wrong offset!");
static_assert(offsetof(AGzDoorBase, bAutomaticDoor) == 0x0002D9, "Member 'AGzDoorBase::bAutomaticDoor' has a wrong offset!");
static_assert(offsetof(AGzDoorBase, bDisableInteractionDuringTransition) == 0x0002DA, "Member 'AGzDoorBase::bDisableInteractionDuringTransition' has a wrong offset!");
static_assert(offsetof(AGzDoorBase, bShowInteractionTooltipIfDisabled) == 0x0002DB, "Member 'AGzDoorBase::bShowInteractionTooltipIfDisabled' has a wrong offset!");
static_assert(offsetof(AGzDoorBase, State) == 0x0002DC, "Member 'AGzDoorBase::State' has a wrong offset!");

// Class G01.GzDormantCapableActor
// 0x0000 (0x02A0 - 0x02A0)
class AGzDormantCapableActor final : public AActor
{
public:
	void FlushNetworkDormancy();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzDormantCapableActor">();
	}
	static class AGzDormantCapableActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<AGzDormantCapableActor>();
	}
};
static_assert(alignof(AGzDormantCapableActor) == 0x000008, "Wrong alignment on AGzDormantCapableActor");
static_assert(sizeof(AGzDormantCapableActor) == 0x0002A0, "Wrong size on AGzDormantCapableActor");

// Class G01.GzGA_QuickMeleeAttack
// 0x0098 (0x05A0 - 0x0508)
class UGzGA_QuickMeleeAttack : public UGzGameplayAbility
{
public:
	TSubclassOf<class UGzGE_BaseDamage>           DamageEffectClass;                                 // 0x0508(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bAllowFriendlyFire;                                // 0x0510(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_31FB[0x3];                                     // 0x0511(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         SweepSphereRadius;                                 // 0x0514(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MeleeAttackDistance;                               // 0x0518(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         DamageRatioKnockDown;                              // 0x051C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         DamageRatioWithoutLegs;                            // 0x0520(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         DamageRatioWithoutHand;                            // 0x0524(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         DamageRatioBackAttack;                             // 0x0528(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         DamageRatioSideAttack;                             // 0x052C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FGameplayTag                           TargetHitGameplayCueTag;                           // 0x0530(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FGameplayTag                           SurfaceHitGameplayCueTag;                          // 0x0538(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TMap<EQuickMeleeAttackType, class UAnimMontage*> AnimMontageMap;                                    // 0x0540(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	class UGzCombatComponent*                     GzCombatComponentCached;                           // 0x0590(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UGzAT_PlayMontageAndWaitForEvent*       MeleeAttackMontageTask;                            // 0x0598(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void OnMeleeAttackAnimationNotification(class FName NotifyName);
	void OnMontageEnded();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzGA_QuickMeleeAttack">();
	}
	static class UGzGA_QuickMeleeAttack* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzGA_QuickMeleeAttack>();
	}
};
static_assert(alignof(UGzGA_QuickMeleeAttack) == 0x000008, "Wrong alignment on UGzGA_QuickMeleeAttack");
static_assert(sizeof(UGzGA_QuickMeleeAttack) == 0x0005A0, "Wrong size on UGzGA_QuickMeleeAttack");
static_assert(offsetof(UGzGA_QuickMeleeAttack, DamageEffectClass) == 0x000508, "Member 'UGzGA_QuickMeleeAttack::DamageEffectClass' has a wrong offset!");
static_assert(offsetof(UGzGA_QuickMeleeAttack, bAllowFriendlyFire) == 0x000510, "Member 'UGzGA_QuickMeleeAttack::bAllowFriendlyFire' has a wrong offset!");
static_assert(offsetof(UGzGA_QuickMeleeAttack, SweepSphereRadius) == 0x000514, "Member 'UGzGA_QuickMeleeAttack::SweepSphereRadius' has a wrong offset!");
static_assert(offsetof(UGzGA_QuickMeleeAttack, MeleeAttackDistance) == 0x000518, "Member 'UGzGA_QuickMeleeAttack::MeleeAttackDistance' has a wrong offset!");
static_assert(offsetof(UGzGA_QuickMeleeAttack, DamageRatioKnockDown) == 0x00051C, "Member 'UGzGA_QuickMeleeAttack::DamageRatioKnockDown' has a wrong offset!");
static_assert(offsetof(UGzGA_QuickMeleeAttack, DamageRatioWithoutLegs) == 0x000520, "Member 'UGzGA_QuickMeleeAttack::DamageRatioWithoutLegs' has a wrong offset!");
static_assert(offsetof(UGzGA_QuickMeleeAttack, DamageRatioWithoutHand) == 0x000524, "Member 'UGzGA_QuickMeleeAttack::DamageRatioWithoutHand' has a wrong offset!");
static_assert(offsetof(UGzGA_QuickMeleeAttack, DamageRatioBackAttack) == 0x000528, "Member 'UGzGA_QuickMeleeAttack::DamageRatioBackAttack' has a wrong offset!");
static_assert(offsetof(UGzGA_QuickMeleeAttack, DamageRatioSideAttack) == 0x00052C, "Member 'UGzGA_QuickMeleeAttack::DamageRatioSideAttack' has a wrong offset!");
static_assert(offsetof(UGzGA_QuickMeleeAttack, TargetHitGameplayCueTag) == 0x000530, "Member 'UGzGA_QuickMeleeAttack::TargetHitGameplayCueTag' has a wrong offset!");
static_assert(offsetof(UGzGA_QuickMeleeAttack, SurfaceHitGameplayCueTag) == 0x000538, "Member 'UGzGA_QuickMeleeAttack::SurfaceHitGameplayCueTag' has a wrong offset!");
static_assert(offsetof(UGzGA_QuickMeleeAttack, AnimMontageMap) == 0x000540, "Member 'UGzGA_QuickMeleeAttack::AnimMontageMap' has a wrong offset!");
static_assert(offsetof(UGzGA_QuickMeleeAttack, GzCombatComponentCached) == 0x000590, "Member 'UGzGA_QuickMeleeAttack::GzCombatComponentCached' has a wrong offset!");
static_assert(offsetof(UGzGA_QuickMeleeAttack, MeleeAttackMontageTask) == 0x000598, "Member 'UGzGA_QuickMeleeAttack::MeleeAttackMontageTask' has a wrong offset!");

// Class G01.GzDroneGoblin
// 0x0020 (0x03D0 - 0x03B0)
class AGzDroneGoblin : public AGzAutoTrackTransport
{
public:
	uint8                                         Pad_31FC[0x20];                                    // 0x03B0(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzDroneGoblin">();
	}
	static class AGzDroneGoblin* GetDefaultObj()
	{
		return GetDefaultObjImpl<AGzDroneGoblin>();
	}
};
static_assert(alignof(AGzDroneGoblin) == 0x000008, "Wrong alignment on AGzDroneGoblin");
static_assert(sizeof(AGzDroneGoblin) == 0x0003D0, "Wrong size on AGzDroneGoblin");

// Class G01.GzHexExtractionStartedMessage
// 0x0020 (0x0060 - 0x0040)
class UGzHexExtractionStartedMessage final : public UGzHexExtractionMessageBase
{
public:
	float                                         Time;                                              // 0x0040(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_31FD[0x4];                                     // 0x0044(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                TerminalLocation;                                  // 0x0048(0x0018)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void SetTerminalLocation(const struct FVector& Location);
	void SetTime(const float InTime);

	struct FVector GetTerminalLocation() const;
	float GetTime() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzHexExtractionStartedMessage">();
	}
	static class UGzHexExtractionStartedMessage* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzHexExtractionStartedMessage>();
	}
};
static_assert(alignof(UGzHexExtractionStartedMessage) == 0x000008, "Wrong alignment on UGzHexExtractionStartedMessage");
static_assert(sizeof(UGzHexExtractionStartedMessage) == 0x000060, "Wrong size on UGzHexExtractionStartedMessage");
static_assert(offsetof(UGzHexExtractionStartedMessage, Time) == 0x000040, "Member 'UGzHexExtractionStartedMessage::Time' has a wrong offset!");
static_assert(offsetof(UGzHexExtractionStartedMessage, TerminalLocation) == 0x000048, "Member 'UGzHexExtractionStartedMessage::TerminalLocation' has a wrong offset!");

// Class G01.GzDroneGoblinSpawner
// 0x0018 (0x02B8 - 0x02A0)
class AGzDroneGoblinSpawner : public AActor
{
public:
	TArray<class AGzTrack*>                       TrackSet;                                          // 0x02A0(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPrivate)
	TSubclassOf<class AGzDroneGoblin>             DroneClassToSpawn;                                 // 0x02B0(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	class AGzDroneGoblin* TriggerDroneSpawn();

	const TArray<class AGzTrack*> GetTrackSet() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzDroneGoblinSpawner">();
	}
	static class AGzDroneGoblinSpawner* GetDefaultObj()
	{
		return GetDefaultObjImpl<AGzDroneGoblinSpawner>();
	}
};
static_assert(alignof(AGzDroneGoblinSpawner) == 0x000008, "Wrong alignment on AGzDroneGoblinSpawner");
static_assert(sizeof(AGzDroneGoblinSpawner) == 0x0002B8, "Wrong size on AGzDroneGoblinSpawner");
static_assert(offsetof(AGzDroneGoblinSpawner, TrackSet) == 0x0002A0, "Member 'AGzDroneGoblinSpawner::TrackSet' has a wrong offset!");
static_assert(offsetof(AGzDroneGoblinSpawner, DroneClassToSpawn) == 0x0002B0, "Member 'AGzDroneGoblinSpawner::DroneClassToSpawn' has a wrong offset!");

// Class G01.GzRollTableData
// 0x0008 (0x0038 - 0x0030)
class UGzRollTableData : public UPrimaryDataAsset
{
public:
	uint8                                         Pad_31FE[0x8];                                     // 0x0030(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzRollTableData">();
	}
	static class UGzRollTableData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzRollTableData>();
	}
};
static_assert(alignof(UGzRollTableData) == 0x000008, "Wrong alignment on UGzRollTableData");
static_assert(sizeof(UGzRollTableData) == 0x000038, "Wrong size on UGzRollTableData");

// Class G01.GzDropTableData
// 0x0018 (0x0050 - 0x0038)
class UGzDropTableData final : public UGzRollTableData
{
public:
	uint8                                         Pad_31FF[0x8];                                     // 0x0038(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FGzDropTableRow>                Table;                                             // 0x0040(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)

public:
	struct FGzInventoryItemContent RollItem() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzDropTableData">();
	}
	static class UGzDropTableData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzDropTableData>();
	}
};
static_assert(alignof(UGzDropTableData) == 0x000008, "Wrong alignment on UGzDropTableData");
static_assert(sizeof(UGzDropTableData) == 0x000050, "Wrong size on UGzDropTableData");
static_assert(offsetof(UGzDropTableData, Table) == 0x000040, "Member 'UGzDropTableData::Table' has a wrong offset!");

// Class G01.GzDummyFriendsService
// 0x0000 (0x0108 - 0x0108)
class UGzDummyFriendsService final : public UGzFriendsServiceBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzDummyFriendsService">();
	}
	static class UGzDummyFriendsService* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzDummyFriendsService>();
	}
};
static_assert(alignof(UGzDummyFriendsService) == 0x000008, "Wrong alignment on UGzDummyFriendsService");
static_assert(sizeof(UGzDummyFriendsService) == 0x000108, "Wrong size on UGzDummyFriendsService");

// Class G01.GzDummyPartyService
// 0x0000 (0x01C0 - 0x01C0)
class UGzDummyPartyService final : public UGzPartyServiceBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzDummyPartyService">();
	}
	static class UGzDummyPartyService* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzDummyPartyService>();
	}
};
static_assert(alignof(UGzDummyPartyService) == 0x000008, "Wrong alignment on UGzDummyPartyService");
static_assert(sizeof(UGzDummyPartyService) == 0x0001C0, "Wrong size on UGzDummyPartyService");

// Class G01.GzSettingUIAspectRatio
// 0x0010 (0x0160 - 0x0150)
class UGzSettingUIAspectRatio : public UGameSettingValueDiscrete
{
public:
	TArray<class FText>                           OPTIONS;                                           // 0x0150(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzSettingUIAspectRatio">();
	}
	static class UGzSettingUIAspectRatio* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzSettingUIAspectRatio>();
	}
};
static_assert(alignof(UGzSettingUIAspectRatio) == 0x000008, "Wrong alignment on UGzSettingUIAspectRatio");
static_assert(sizeof(UGzSettingUIAspectRatio) == 0x000160, "Wrong size on UGzSettingUIAspectRatio");
static_assert(offsetof(UGzSettingUIAspectRatio, OPTIONS) == 0x000150, "Member 'UGzSettingUIAspectRatio::OPTIONS' has a wrong offset!");

// Class G01.GzVoiceChatServiceBase
// 0x00B8 (0x0158 - 0x00A0)
class UGzVoiceChatServiceBase : public UGzClientPFObject
{
public:
	uint8                                         Pad_3200[0xB8];                                    // 0x00A0(0x00B8)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzVoiceChatServiceBase">();
	}
	static class UGzVoiceChatServiceBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzVoiceChatServiceBase>();
	}
};
static_assert(alignof(UGzVoiceChatServiceBase) == 0x000008, "Wrong alignment on UGzVoiceChatServiceBase");
static_assert(sizeof(UGzVoiceChatServiceBase) == 0x000158, "Wrong size on UGzVoiceChatServiceBase");

// Class G01.GzDummyVoiceChatService
// 0x0000 (0x0158 - 0x0158)
class UGzDummyVoiceChatService final : public UGzVoiceChatServiceBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzDummyVoiceChatService">();
	}
	static class UGzDummyVoiceChatService* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzDummyVoiceChatService>();
	}
};
static_assert(alignof(UGzDummyVoiceChatService) == 0x000008, "Wrong alignment on UGzDummyVoiceChatService");
static_assert(sizeof(UGzDummyVoiceChatService) == 0x000158, "Wrong size on UGzDummyVoiceChatService");

// Class G01.GzPostProcessFX
// 0x0068 (0x0090 - 0x0028)
class UGzPostProcessFX : public UObject
{
public:
	uint8                                         Pad_3201[0x18];                                    // 0x0028(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	class UCameraComponent*                       CameraComponent;                                   // 0x0040(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, Transient, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class APlayerController*                      PlayerController;                                  // 0x0048(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAkAudioEvent*                          StartFxAkEvent;                                    // 0x0050(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAkAudioEvent*                          StopFxAkEvent;                                     // 0x0058(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         FadeInDuration;                                    // 0x0060(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         FadeOutDuration;                                   // 0x0064(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UGzPostProcessControllerComponent*      Owner;                                             // 0x0068(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UGzAudioControllerComponent*            AudioController;                                   // 0x0070(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bPlaySound;                                        // 0x0078(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_3202[0x17];                                    // 0x0079(0x0017)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnFadeInEnded();
	void StartBP();
	void StopBP();
	void StopSelf(bool bImmediate);
	void TickBP(float DeltaTime);

	float GetFadeInProgress() const;
	float GetFadeOutProgress() const;
	bool IsFadingIn() const;
	bool IsFadingOut() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzPostProcessFX">();
	}
	static class UGzPostProcessFX* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzPostProcessFX>();
	}
};
static_assert(alignof(UGzPostProcessFX) == 0x000008, "Wrong alignment on UGzPostProcessFX");
static_assert(sizeof(UGzPostProcessFX) == 0x000090, "Wrong size on UGzPostProcessFX");
static_assert(offsetof(UGzPostProcessFX, CameraComponent) == 0x000040, "Member 'UGzPostProcessFX::CameraComponent' has a wrong offset!");
static_assert(offsetof(UGzPostProcessFX, PlayerController) == 0x000048, "Member 'UGzPostProcessFX::PlayerController' has a wrong offset!");
static_assert(offsetof(UGzPostProcessFX, StartFxAkEvent) == 0x000050, "Member 'UGzPostProcessFX::StartFxAkEvent' has a wrong offset!");
static_assert(offsetof(UGzPostProcessFX, StopFxAkEvent) == 0x000058, "Member 'UGzPostProcessFX::StopFxAkEvent' has a wrong offset!");
static_assert(offsetof(UGzPostProcessFX, FadeInDuration) == 0x000060, "Member 'UGzPostProcessFX::FadeInDuration' has a wrong offset!");
static_assert(offsetof(UGzPostProcessFX, FadeOutDuration) == 0x000064, "Member 'UGzPostProcessFX::FadeOutDuration' has a wrong offset!");
static_assert(offsetof(UGzPostProcessFX, Owner) == 0x000068, "Member 'UGzPostProcessFX::Owner' has a wrong offset!");
static_assert(offsetof(UGzPostProcessFX, AudioController) == 0x000070, "Member 'UGzPostProcessFX::AudioController' has a wrong offset!");
static_assert(offsetof(UGzPostProcessFX, bPlaySound) == 0x000078, "Member 'UGzPostProcessFX::bPlaySound' has a wrong offset!");

// Class G01.GzShrinkingZonePostProcessFX
// 0x0058 (0x00E8 - 0x0090)
class UGzShrinkingZonePostProcessFX : public UGzPostProcessFX
{
public:
	class UMaterialInterface*                     ZoneMaterial;                                      // 0x0090(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   FadeParamName;                                     // 0x0098(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   LookingAtParam;                                    // 0x00A0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   LookingAtColorIntensityParam;                      // 0x00A8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCurveFloat*                            DistanceToAlpha;                                   // 0x00B0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCurveFloat*                            DistanceToLookAtParam;                             // 0x00B8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         StartFadeInDistance;                               // 0x00C0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3203[0x4];                                     // 0x00C4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UMaterialInstanceDynamic*               ZoneMaterialInstance;                              // 0x00C8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         FadeInValue;                                       // 0x00D0(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         LookingAtValue;                                    // 0x00D4(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bInvertLookAtParam;                                // 0x00D8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3204[0x3];                                     // 0x00D9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         LookAtDistanceToZoneTolerance;                     // 0x00DC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UGzZoneTrackingComponent*               ZoneTrackingComponent;                             // 0x00E0(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzShrinkingZonePostProcessFX">();
	}
	static class UGzShrinkingZonePostProcessFX* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzShrinkingZonePostProcessFX>();
	}
};
static_assert(alignof(UGzShrinkingZonePostProcessFX) == 0x000008, "Wrong alignment on UGzShrinkingZonePostProcessFX");
static_assert(sizeof(UGzShrinkingZonePostProcessFX) == 0x0000E8, "Wrong size on UGzShrinkingZonePostProcessFX");
static_assert(offsetof(UGzShrinkingZonePostProcessFX, ZoneMaterial) == 0x000090, "Member 'UGzShrinkingZonePostProcessFX::ZoneMaterial' has a wrong offset!");
static_assert(offsetof(UGzShrinkingZonePostProcessFX, FadeParamName) == 0x000098, "Member 'UGzShrinkingZonePostProcessFX::FadeParamName' has a wrong offset!");
static_assert(offsetof(UGzShrinkingZonePostProcessFX, LookingAtParam) == 0x0000A0, "Member 'UGzShrinkingZonePostProcessFX::LookingAtParam' has a wrong offset!");
static_assert(offsetof(UGzShrinkingZonePostProcessFX, LookingAtColorIntensityParam) == 0x0000A8, "Member 'UGzShrinkingZonePostProcessFX::LookingAtColorIntensityParam' has a wrong offset!");
static_assert(offsetof(UGzShrinkingZonePostProcessFX, DistanceToAlpha) == 0x0000B0, "Member 'UGzShrinkingZonePostProcessFX::DistanceToAlpha' has a wrong offset!");
static_assert(offsetof(UGzShrinkingZonePostProcessFX, DistanceToLookAtParam) == 0x0000B8, "Member 'UGzShrinkingZonePostProcessFX::DistanceToLookAtParam' has a wrong offset!");
static_assert(offsetof(UGzShrinkingZonePostProcessFX, StartFadeInDistance) == 0x0000C0, "Member 'UGzShrinkingZonePostProcessFX::StartFadeInDistance' has a wrong offset!");
static_assert(offsetof(UGzShrinkingZonePostProcessFX, ZoneMaterialInstance) == 0x0000C8, "Member 'UGzShrinkingZonePostProcessFX::ZoneMaterialInstance' has a wrong offset!");
static_assert(offsetof(UGzShrinkingZonePostProcessFX, FadeInValue) == 0x0000D0, "Member 'UGzShrinkingZonePostProcessFX::FadeInValue' has a wrong offset!");
static_assert(offsetof(UGzShrinkingZonePostProcessFX, LookingAtValue) == 0x0000D4, "Member 'UGzShrinkingZonePostProcessFX::LookingAtValue' has a wrong offset!");
static_assert(offsetof(UGzShrinkingZonePostProcessFX, bInvertLookAtParam) == 0x0000D8, "Member 'UGzShrinkingZonePostProcessFX::bInvertLookAtParam' has a wrong offset!");
static_assert(offsetof(UGzShrinkingZonePostProcessFX, LookAtDistanceToZoneTolerance) == 0x0000DC, "Member 'UGzShrinkingZonePostProcessFX::LookAtDistanceToZoneTolerance' has a wrong offset!");
static_assert(offsetof(UGzShrinkingZonePostProcessFX, ZoneTrackingComponent) == 0x0000E0, "Member 'UGzShrinkingZonePostProcessFX::ZoneTrackingComponent' has a wrong offset!");

// Class G01.GzEditorPreviewCharacter
// 0x0000 (0x15D0 - 0x15D0)
class AGzEditorPreviewCharacter final : public AGzMultiPartCharacter
{
public:
	void EditorInitMeshComponents(class UGzCharacterCustomizationComponent* EditorCustomizationComponent);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzEditorPreviewCharacter">();
	}
	static class AGzEditorPreviewCharacter* GetDefaultObj()
	{
		return GetDefaultObjImpl<AGzEditorPreviewCharacter>();
	}
};
static_assert(alignof(AGzEditorPreviewCharacter) == 0x000010, "Wrong alignment on AGzEditorPreviewCharacter");
static_assert(sizeof(AGzEditorPreviewCharacter) == 0x0015D0, "Wrong size on AGzEditorPreviewCharacter");

// Class G01.GzSA_MovementMode
// 0x0008 (0x0040 - 0x0038)
class UGzSA_MovementMode final : public UGzStateAction
{
public:
	bool                                          bRequireModeToStart;                               // 0x0038(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bActiveWhileMode;                                  // 0x0039(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EMovementMode                                 MovementMode;                                      // 0x003A(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EGzCustomMovementMode                         CustomMovementMode;                                // 0x003B(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3205[0x4];                                     // 0x003C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzSA_MovementMode">();
	}
	static class UGzSA_MovementMode* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzSA_MovementMode>();
	}
};
static_assert(alignof(UGzSA_MovementMode) == 0x000008, "Wrong alignment on UGzSA_MovementMode");
static_assert(sizeof(UGzSA_MovementMode) == 0x000040, "Wrong size on UGzSA_MovementMode");
static_assert(offsetof(UGzSA_MovementMode, bRequireModeToStart) == 0x000038, "Member 'UGzSA_MovementMode::bRequireModeToStart' has a wrong offset!");
static_assert(offsetof(UGzSA_MovementMode, bActiveWhileMode) == 0x000039, "Member 'UGzSA_MovementMode::bActiveWhileMode' has a wrong offset!");
static_assert(offsetof(UGzSA_MovementMode, MovementMode) == 0x00003A, "Member 'UGzSA_MovementMode::MovementMode' has a wrong offset!");
static_assert(offsetof(UGzSA_MovementMode, CustomMovementMode) == 0x00003B, "Member 'UGzSA_MovementMode::CustomMovementMode' has a wrong offset!");

// Class G01.GzEffectPropagationActor
// 0x0030 (0x04B8 - 0x0488)
class AGzEffectPropagationActor : public AGzPropagationActor
{
public:
	float                                         DefaultLifespan;                                   // 0x0488(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         EffectRadius;                                      // 0x048C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MaxAllowedDistanceToParentPropagation;             // 0x0490(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3206[0x4];                                     // 0x0494(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<ECollisionChannel>                     PropagationCollisionChannels;                      // 0x0498(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	EGzEffectPropagationType                      EffectPropagationType;                             // 0x04A8(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3207[0x7];                                     // 0x04A9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UGameplayEffect>            AppliedEffectClass;                                // 0x04B0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void OnPawnBeginOverlap(class AActor* OverlappedActor, class AActor* OtherActor);
	void OnPawnEndOverlap(class AActor* OverlappedActor, class AActor* OtherActor);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzEffectPropagationActor">();
	}
	static class AGzEffectPropagationActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<AGzEffectPropagationActor>();
	}
};
static_assert(alignof(AGzEffectPropagationActor) == 0x000008, "Wrong alignment on AGzEffectPropagationActor");
static_assert(sizeof(AGzEffectPropagationActor) == 0x0004B8, "Wrong size on AGzEffectPropagationActor");
static_assert(offsetof(AGzEffectPropagationActor, DefaultLifespan) == 0x000488, "Member 'AGzEffectPropagationActor::DefaultLifespan' has a wrong offset!");
static_assert(offsetof(AGzEffectPropagationActor, EffectRadius) == 0x00048C, "Member 'AGzEffectPropagationActor::EffectRadius' has a wrong offset!");
static_assert(offsetof(AGzEffectPropagationActor, MaxAllowedDistanceToParentPropagation) == 0x000490, "Member 'AGzEffectPropagationActor::MaxAllowedDistanceToParentPropagation' has a wrong offset!");
static_assert(offsetof(AGzEffectPropagationActor, PropagationCollisionChannels) == 0x000498, "Member 'AGzEffectPropagationActor::PropagationCollisionChannels' has a wrong offset!");
static_assert(offsetof(AGzEffectPropagationActor, EffectPropagationType) == 0x0004A8, "Member 'AGzEffectPropagationActor::EffectPropagationType' has a wrong offset!");
static_assert(offsetof(AGzEffectPropagationActor, AppliedEffectClass) == 0x0004B0, "Member 'AGzEffectPropagationActor::AppliedEffectClass' has a wrong offset!");

// Class G01.GzEffectPropagationInterface
// 0x0000 (0x0028 - 0x0028)
class IGzEffectPropagationInterface final : public IInterface
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzEffectPropagationInterface">();
	}
	static class IGzEffectPropagationInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IGzEffectPropagationInterface>();
	}
};
static_assert(alignof(IGzEffectPropagationInterface) == 0x000008, "Wrong alignment on IGzEffectPropagationInterface");
static_assert(sizeof(IGzEffectPropagationInterface) == 0x000028, "Wrong size on IGzEffectPropagationInterface");

// Class G01.GzBPEmoteHelper
// 0x0000 (0x0028 - 0x0028)
class UGzBPEmoteHelper final : public UBlueprintFunctionLibrary
{
public:
	static const class UGzCIT_Emote* GetEmoteCIT(const struct FGzEmoteCustomizationData& CustomizationData);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzBPEmoteHelper">();
	}
	static class UGzBPEmoteHelper* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzBPEmoteHelper>();
	}
};
static_assert(alignof(UGzBPEmoteHelper) == 0x000008, "Wrong alignment on UGzBPEmoteHelper");
static_assert(sizeof(UGzBPEmoteHelper) == 0x000028, "Wrong size on UGzBPEmoteHelper");

// Class G01.GzLimbPreviewCluster
// 0x0050 (0x0300 - 0x02B0)
class AGzLimbPreviewCluster final : public AGzViewpointClusterBase
{
public:
	TMap<EGzLimbType, struct FGzViewpoint>        Viewpoints;                                        // 0x02B0(0x0050)(Edit, DisableEditOnTemplate, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzLimbPreviewCluster">();
	}
	static class AGzLimbPreviewCluster* GetDefaultObj()
	{
		return GetDefaultObjImpl<AGzLimbPreviewCluster>();
	}
};
static_assert(alignof(AGzLimbPreviewCluster) == 0x000008, "Wrong alignment on AGzLimbPreviewCluster");
static_assert(sizeof(AGzLimbPreviewCluster) == 0x000300, "Wrong size on AGzLimbPreviewCluster");
static_assert(offsetof(AGzLimbPreviewCluster, Viewpoints) == 0x0002B0, "Member 'AGzLimbPreviewCluster::Viewpoints' has a wrong offset!");

// Class G01.GzEnclaveOpsMissionData
// 0x0000 (0x01C0 - 0x01C0)
class UGzEnclaveOpsMissionData final : public UGzMissionData
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzEnclaveOpsMissionData">();
	}
	static class UGzEnclaveOpsMissionData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzEnclaveOpsMissionData>();
	}
};
static_assert(alignof(UGzEnclaveOpsMissionData) == 0x000008, "Wrong alignment on UGzEnclaveOpsMissionData");
static_assert(sizeof(UGzEnclaveOpsMissionData) == 0x0001C0, "Wrong size on UGzEnclaveOpsMissionData");

// Class G01.GzEntitlementReadingComponent
// 0x0020 (0x00C0 - 0x00A0)
class UGzEntitlementReadingComponent final : public UGzServiceComponent
{
public:
	uint8                                         Pad_3208[0x20];                                    // 0x00A0(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzEntitlementReadingComponent">();
	}
	static class UGzEntitlementReadingComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzEntitlementReadingComponent>();
	}
};
static_assert(alignof(UGzEntitlementReadingComponent) == 0x000008, "Wrong alignment on UGzEntitlementReadingComponent");
static_assert(sizeof(UGzEntitlementReadingComponent) == 0x0000C0, "Wrong size on UGzEntitlementReadingComponent");

// Class G01.GzRangedImpactData
// 0x0020 (0x0048 - 0x0028)
class UGzRangedImpactData final : public UObject
{
public:
	class UObject*                                WorldContextObject;                                // 0x0028(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FHitResult>                     HitResults;                                        // 0x0030(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	EGzWeaponResourceType                         ResourceType;                                      // 0x0040(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3209[0x7];                                     // 0x0041(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzRangedImpactData">();
	}
	static class UGzRangedImpactData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzRangedImpactData>();
	}
};
static_assert(alignof(UGzRangedImpactData) == 0x000008, "Wrong alignment on UGzRangedImpactData");
static_assert(sizeof(UGzRangedImpactData) == 0x000048, "Wrong size on UGzRangedImpactData");
static_assert(offsetof(UGzRangedImpactData, WorldContextObject) == 0x000028, "Member 'UGzRangedImpactData::WorldContextObject' has a wrong offset!");
static_assert(offsetof(UGzRangedImpactData, HitResults) == 0x000030, "Member 'UGzRangedImpactData::HitResults' has a wrong offset!");
static_assert(offsetof(UGzRangedImpactData, ResourceType) == 0x000040, "Member 'UGzRangedImpactData::ResourceType' has a wrong offset!");

// Class G01.GzPlayerMarkersHolderComponent
// 0x0268 (0x0310 - 0x00A8)
class UGzPlayerMarkersHolderComponent final : public UControllerComponent
{
public:
	FMulticastInlineDelegateProperty_             OnMarkerAddedDelegate;                             // 0x00A8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnMarkerRemovedDelegate;                           // 0x00B8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_320A[0x28];                                    // 0x00C8(0x0028)(Fixing Size After Last Property [ Dumper-7 ])
	FMulticastInlineDelegateProperty_             OnClosestMarkerChanged;                            // 0x00F0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	float                                         DistancePollingFrequency;                          // 0x0100(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_320B[0x4];                                     // 0x0104(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<class UClass*, struct FGzMarkerOwnerDistanceCache> ClosestMarkers;                                    // 0x0108(0x0050)(Transient, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	TArray<class UGzMarkerComponent*>             ActiveMarkerComponents;                            // 0x0158(0x0010)(ExportObject, ZeroConstructor, Transient, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	class AGzTeam*                                CurrentTeam;                                       // 0x0168(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class APawn*                                  ViewTarget;                                        // 0x0170(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FGzMarkerServerDataArray               ServerMarkers;                                     // 0x0178(0x0168)(Net, NativeAccessSpecifierPrivate)
	uint8                                         Pad_320C[0x30];                                    // 0x02E0(0x0030)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	class UGzMarkerComponent* GetMarkerById(int32 MarkerId);
	void OnControllerInit(class AGzPlayerController* PlayerController, class AGzPlayerState* PlayerState);
	void OnMarkersDirty();
	void OnMissionStarted(class AGzMission* Mission);
	void OnMissionStateChanged(class AGzMission* Mission, const struct FGzMissionState& OldState, const struct FGzMissionState& MissionState);
	void OnMissionTrackingChanged(class AGzAdvancedMission* Mission, bool bIsTracked);
	void OnPawnChanged(class APawn* Pawn);
	void OnPlayerChangeTeam(class AGzPlayerState* PlayerState);
	void OnRedeployPriceChanged(const class AGzGameState* GS);
	void OnSubscribeToTeammateEvents();
	void OnTeammateAliveStateChanged(class AGzPlayerState* PlayerState);
	void OnWorldInstanceIdChanged(class AGzPlayerState* PlayerState);

	const TArray<class UGzMarkerComponent*> GetActiveMarkers() const;
	class UGzMarkerComponent* GetClosestMarkerByOwnerClass(class UClass* OwnerClass) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzPlayerMarkersHolderComponent">();
	}
	static class UGzPlayerMarkersHolderComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzPlayerMarkersHolderComponent>();
	}
};
static_assert(alignof(UGzPlayerMarkersHolderComponent) == 0x000008, "Wrong alignment on UGzPlayerMarkersHolderComponent");
static_assert(sizeof(UGzPlayerMarkersHolderComponent) == 0x000310, "Wrong size on UGzPlayerMarkersHolderComponent");
static_assert(offsetof(UGzPlayerMarkersHolderComponent, OnMarkerAddedDelegate) == 0x0000A8, "Member 'UGzPlayerMarkersHolderComponent::OnMarkerAddedDelegate' has a wrong offset!");
static_assert(offsetof(UGzPlayerMarkersHolderComponent, OnMarkerRemovedDelegate) == 0x0000B8, "Member 'UGzPlayerMarkersHolderComponent::OnMarkerRemovedDelegate' has a wrong offset!");
static_assert(offsetof(UGzPlayerMarkersHolderComponent, OnClosestMarkerChanged) == 0x0000F0, "Member 'UGzPlayerMarkersHolderComponent::OnClosestMarkerChanged' has a wrong offset!");
static_assert(offsetof(UGzPlayerMarkersHolderComponent, DistancePollingFrequency) == 0x000100, "Member 'UGzPlayerMarkersHolderComponent::DistancePollingFrequency' has a wrong offset!");
static_assert(offsetof(UGzPlayerMarkersHolderComponent, ClosestMarkers) == 0x000108, "Member 'UGzPlayerMarkersHolderComponent::ClosestMarkers' has a wrong offset!");
static_assert(offsetof(UGzPlayerMarkersHolderComponent, ActiveMarkerComponents) == 0x000158, "Member 'UGzPlayerMarkersHolderComponent::ActiveMarkerComponents' has a wrong offset!");
static_assert(offsetof(UGzPlayerMarkersHolderComponent, CurrentTeam) == 0x000168, "Member 'UGzPlayerMarkersHolderComponent::CurrentTeam' has a wrong offset!");
static_assert(offsetof(UGzPlayerMarkersHolderComponent, ViewTarget) == 0x000170, "Member 'UGzPlayerMarkersHolderComponent::ViewTarget' has a wrong offset!");
static_assert(offsetof(UGzPlayerMarkersHolderComponent, ServerMarkers) == 0x000178, "Member 'UGzPlayerMarkersHolderComponent::ServerMarkers' has a wrong offset!");

// Class G01.GzEnvironmentZoneComponent
// 0x00E8 (0x0190 - 0x00A8)
class alignas(0x10) UGzEnvironmentZoneComponent final : public UActorComponent
{
public:
	int32                                         Priority;                                          // 0x00A8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FGzEnvironmentZoneKey                  EnvironmentZone;                                   // 0x00AC(0x0010)(Edit, NoDestructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_320F[0x4];                                     // 0x00BC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UAkAudioEvent*                          PlayAmbientEvent;                                  // 0x00C0(0x0008)(Edit, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAkAudioEvent*                          StopAmbientEvent;                                  // 0x00C8(0x0008)(Edit, ZeroConstructor, EditConst, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bOverrideFadeParams;                               // 0x00D0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3210[0x3];                                     // 0x00D1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGzAudioFadeParams                     AmbientFadeParamsOverride;                         // 0x00D4(0x000C)(Edit, NoDestructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_3211[0xB0];                                    // 0x00E0(0x00B0)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	int32 GetPriority() const;
	bool IsLocationInside(const struct FVector& Location) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzEnvironmentZoneComponent">();
	}
	static class UGzEnvironmentZoneComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzEnvironmentZoneComponent>();
	}
};
static_assert(alignof(UGzEnvironmentZoneComponent) == 0x000010, "Wrong alignment on UGzEnvironmentZoneComponent");
static_assert(sizeof(UGzEnvironmentZoneComponent) == 0x000190, "Wrong size on UGzEnvironmentZoneComponent");
static_assert(offsetof(UGzEnvironmentZoneComponent, Priority) == 0x0000A8, "Member 'UGzEnvironmentZoneComponent::Priority' has a wrong offset!");
static_assert(offsetof(UGzEnvironmentZoneComponent, EnvironmentZone) == 0x0000AC, "Member 'UGzEnvironmentZoneComponent::EnvironmentZone' has a wrong offset!");
static_assert(offsetof(UGzEnvironmentZoneComponent, PlayAmbientEvent) == 0x0000C0, "Member 'UGzEnvironmentZoneComponent::PlayAmbientEvent' has a wrong offset!");
static_assert(offsetof(UGzEnvironmentZoneComponent, StopAmbientEvent) == 0x0000C8, "Member 'UGzEnvironmentZoneComponent::StopAmbientEvent' has a wrong offset!");
static_assert(offsetof(UGzEnvironmentZoneComponent, bOverrideFadeParams) == 0x0000D0, "Member 'UGzEnvironmentZoneComponent::bOverrideFadeParams' has a wrong offset!");
static_assert(offsetof(UGzEnvironmentZoneComponent, AmbientFadeParamsOverride) == 0x0000D4, "Member 'UGzEnvironmentZoneComponent::AmbientFadeParamsOverride' has a wrong offset!");

// Class G01.GzLoadoutSelectionSpawning
// 0x0010 (0x0688 - 0x0678)
class UGzLoadoutSelectionSpawning : public UGzLoadoutSelectionScreen
{
public:
	float                                         SelectionTime;                                     // 0x0678(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3213[0xC];                                     // 0x067C(0x000C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzLoadoutSelectionSpawning">();
	}
	static class UGzLoadoutSelectionSpawning* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzLoadoutSelectionSpawning>();
	}
};
static_assert(alignof(UGzLoadoutSelectionSpawning) == 0x000008, "Wrong alignment on UGzLoadoutSelectionSpawning");
static_assert(sizeof(UGzLoadoutSelectionSpawning) == 0x000688, "Wrong size on UGzLoadoutSelectionSpawning");
static_assert(offsetof(UGzLoadoutSelectionSpawning, SelectionTime) == 0x000678, "Member 'UGzLoadoutSelectionSpawning::SelectionTime' has a wrong offset!");

// Class G01.GzEnvironmentZoneManagerComponent
// 0x0088 (0x0130 - 0x00A8)
class UGzEnvironmentZoneManagerComponent final : public UActorComponent
{
public:
	TSet<struct FGzEnvironmentZoneWithName>       ZoneComponents;                                    // 0x00A8(0x0050)(Transient, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	uint8                                         Pad_3214[0x38];                                    // 0x00F8(0x0038)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void TryUpdateEnvironmentZones();

	class UGzEnvironmentZoneComponent* GetHighestPriorityEnvironmentZone() const;
	bool GetHighestPriorityEnvironmentZoneType(struct FGzEnvironmentZoneType* OutEnvZoneType) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzEnvironmentZoneManagerComponent">();
	}
	static class UGzEnvironmentZoneManagerComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzEnvironmentZoneManagerComponent>();
	}
};
static_assert(alignof(UGzEnvironmentZoneManagerComponent) == 0x000008, "Wrong alignment on UGzEnvironmentZoneManagerComponent");
static_assert(sizeof(UGzEnvironmentZoneManagerComponent) == 0x000130, "Wrong size on UGzEnvironmentZoneManagerComponent");
static_assert(offsetof(UGzEnvironmentZoneManagerComponent, ZoneComponents) == 0x0000A8, "Member 'UGzEnvironmentZoneManagerComponent::ZoneComponents' has a wrong offset!");

// Class G01.GzEnvironmentZoneManagerInterface
// 0x0000 (0x0028 - 0x0028)
class IGzEnvironmentZoneManagerInterface final : public IInterface
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzEnvironmentZoneManagerInterface">();
	}
	static class IGzEnvironmentZoneManagerInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IGzEnvironmentZoneManagerInterface>();
	}
};
static_assert(alignof(IGzEnvironmentZoneManagerInterface) == 0x000008, "Wrong alignment on IGzEnvironmentZoneManagerInterface");
static_assert(sizeof(IGzEnvironmentZoneManagerInterface) == 0x000028, "Wrong size on IGzEnvironmentZoneManagerInterface");

// Class G01.GzEnvQueryCoversGenerator
// 0x0040 (0x0090 - 0x0050)
class UGzEnvQueryCoversGenerator final : public UEnvQueryGenerator
{
public:
	struct FAIDataProviderFloatValue              SearchRadius;                                      // 0x0050(0x0038)(Edit, DisableEditOnInstance, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	TSubclassOf<class UEnvQueryContext>           GenerateAround;                                    // 0x0088(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzEnvQueryCoversGenerator">();
	}
	static class UGzEnvQueryCoversGenerator* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzEnvQueryCoversGenerator>();
	}
};
static_assert(alignof(UGzEnvQueryCoversGenerator) == 0x000008, "Wrong alignment on UGzEnvQueryCoversGenerator");
static_assert(sizeof(UGzEnvQueryCoversGenerator) == 0x000090, "Wrong size on UGzEnvQueryCoversGenerator");
static_assert(offsetof(UGzEnvQueryCoversGenerator, SearchRadius) == 0x000050, "Member 'UGzEnvQueryCoversGenerator::SearchRadius' has a wrong offset!");
static_assert(offsetof(UGzEnvQueryCoversGenerator, GenerateAround) == 0x000088, "Member 'UGzEnvQueryCoversGenerator::GenerateAround' has a wrong offset!");

// Class G01.GzEnvQueryItemType_Cover
// 0x0000 (0x0030 - 0x0030)
class UGzEnvQueryItemType_Cover final : public UEnvQueryItemType_Point
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzEnvQueryItemType_Cover">();
	}
	static class UGzEnvQueryItemType_Cover* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzEnvQueryItemType_Cover>();
	}
};
static_assert(alignof(UGzEnvQueryItemType_Cover) == 0x000008, "Wrong alignment on UGzEnvQueryItemType_Cover");
static_assert(sizeof(UGzEnvQueryItemType_Cover) == 0x000030, "Wrong size on UGzEnvQueryItemType_Cover");

// Class G01.GzGA_NpcReloadWeapons
// 0x0000 (0x0570 - 0x0570)
class UGzGA_NpcReloadWeapons final : public UGzGA_WeaponReload
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzGA_NpcReloadWeapons">();
	}
	static class UGzGA_NpcReloadWeapons* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzGA_NpcReloadWeapons>();
	}
};
static_assert(alignof(UGzGA_NpcReloadWeapons) == 0x000008, "Wrong alignment on UGzGA_NpcReloadWeapons");
static_assert(sizeof(UGzGA_NpcReloadWeapons) == 0x000570, "Wrong size on UGzGA_NpcReloadWeapons");

// Class G01.GzEnvQueryTest_CoverFree
// 0x0000 (0x01F8 - 0x01F8)
class UGzEnvQueryTest_CoverFree final : public UEnvQueryTest
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzEnvQueryTest_CoverFree">();
	}
	static class UGzEnvQueryTest_CoverFree* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzEnvQueryTest_CoverFree>();
	}
};
static_assert(alignof(UGzEnvQueryTest_CoverFree) == 0x000008, "Wrong alignment on UGzEnvQueryTest_CoverFree");
static_assert(sizeof(UGzEnvQueryTest_CoverFree) == 0x0001F8, "Wrong size on UGzEnvQueryTest_CoverFree");

// Class G01.GzHexExtractionCompletedMessage
// 0x0010 (0x0050 - 0x0040)
class UGzHexExtractionCompletedMessage final : public UGzHexExtractionMessageBase
{
public:
	uint8                                         Pad_3216[0x10];                                    // 0x0040(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzHexExtractionCompletedMessage">();
	}
	static class UGzHexExtractionCompletedMessage* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzHexExtractionCompletedMessage>();
	}
};
static_assert(alignof(UGzHexExtractionCompletedMessage) == 0x000008, "Wrong alignment on UGzHexExtractionCompletedMessage");
static_assert(sizeof(UGzHexExtractionCompletedMessage) == 0x000050, "Wrong size on UGzHexExtractionCompletedMessage");

// Class G01.GzEpicAccountService
// 0x0098 (0x0138 - 0x00A0)
class UGzEpicAccountService final : public UGzClientPFObject
{
public:
	uint8                                         Pad_3217[0x98];                                    // 0x00A0(0x0098)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzEpicAccountService">();
	}
	static class UGzEpicAccountService* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzEpicAccountService>();
	}
};
static_assert(alignof(UGzEpicAccountService) == 0x000008, "Wrong alignment on UGzEpicAccountService");
static_assert(sizeof(UGzEpicAccountService) == 0x000138, "Wrong size on UGzEpicAccountService");

// Class G01.GzPlayerLoadout
// 0x0240 (0x0270 - 0x0030)
class UGzPlayerLoadout final : public UDataAsset
{
public:
	struct FGzPlayerLoadoutData                   Loadout;                                           // 0x0030(0x0240)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzPlayerLoadout">();
	}
	static class UGzPlayerLoadout* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzPlayerLoadout>();
	}
};
static_assert(alignof(UGzPlayerLoadout) == 0x000008, "Wrong alignment on UGzPlayerLoadout");
static_assert(sizeof(UGzPlayerLoadout) == 0x000270, "Wrong size on UGzPlayerLoadout");
static_assert(offsetof(UGzPlayerLoadout, Loadout) == 0x000030, "Member 'UGzPlayerLoadout::Loadout' has a wrong offset!");

// Class G01.GzEpicFriendsService
// 0x0128 (0x0230 - 0x0108)
class UGzEpicFriendsService final : public UGzFriendsServiceBase
{
public:
	uint8                                         Pad_3218[0x128];                                   // 0x0108(0x0128)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzEpicFriendsService">();
	}
	static class UGzEpicFriendsService* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzEpicFriendsService>();
	}
};
static_assert(alignof(UGzEpicFriendsService) == 0x000008, "Wrong alignment on UGzEpicFriendsService");
static_assert(sizeof(UGzEpicFriendsService) == 0x000230, "Wrong size on UGzEpicFriendsService");

// Class G01.GzInputTriggerMultikeyPressed
// 0x0018 (0x0068 - 0x0050)
class UGzInputTriggerMultikeyPressed final : public UInputTrigger
{
public:
	TArray<struct FKey>                           AdditionalKeys;                                    // 0x0050(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPrivate)
	bool                                          bTriggerOnlyOnce;                                  // 0x0060(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_3219[0x7];                                     // 0x0061(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzInputTriggerMultikeyPressed">();
	}
	static class UGzInputTriggerMultikeyPressed* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzInputTriggerMultikeyPressed>();
	}
};
static_assert(alignof(UGzInputTriggerMultikeyPressed) == 0x000008, "Wrong alignment on UGzInputTriggerMultikeyPressed");
static_assert(sizeof(UGzInputTriggerMultikeyPressed) == 0x000068, "Wrong size on UGzInputTriggerMultikeyPressed");
static_assert(offsetof(UGzInputTriggerMultikeyPressed, AdditionalKeys) == 0x000050, "Member 'UGzInputTriggerMultikeyPressed::AdditionalKeys' has a wrong offset!");
static_assert(offsetof(UGzInputTriggerMultikeyPressed, bTriggerOnlyOnce) == 0x000060, "Member 'UGzInputTriggerMultikeyPressed::bTriggerOnlyOnce' has a wrong offset!");

// Class G01.GzEpicPartyService
// 0x0370 (0x0530 - 0x01C0)
class UGzEpicPartyService final : public UGzPartyServiceBase
{
public:
	uint8                                         Pad_321A[0x370];                                   // 0x01C0(0x0370)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzEpicPartyService">();
	}
	static class UGzEpicPartyService* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzEpicPartyService>();
	}
};
static_assert(alignof(UGzEpicPartyService) == 0x000008, "Wrong alignment on UGzEpicPartyService");
static_assert(sizeof(UGzEpicPartyService) == 0x000530, "Wrong size on UGzEpicPartyService");

// Class G01.GzKillLogWidget
// 0x0040 (0x03B0 - 0x0370)
class UGzKillLogWidget : public UGzBaseLogWidget
{
public:
	class UPanelWidget*                           KillMarksContainer;                                // 0x0368(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_321B[0x10];                                    // 0x0370(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   KillText;                                          // 0x0380(0x0010)(Edit, NativeAccessSpecifierPrivate)
	class FText                                   AssistText;                                        // 0x0390(0x0010)(Edit, NativeAccessSpecifierPrivate)
	class FText                                   KnockDownText;                                     // 0x03A0(0x0010)(Edit, NativeAccessSpecifierPrivate)

public:
	void AddKillMark();
	void OnEntryAddedOrUpdated();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzKillLogWidget">();
	}
	static class UGzKillLogWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzKillLogWidget>();
	}
};
static_assert(alignof(UGzKillLogWidget) == 0x000010, "Wrong alignment on UGzKillLogWidget");
static_assert(sizeof(UGzKillLogWidget) == 0x0003B0, "Wrong size on UGzKillLogWidget");
static_assert(offsetof(UGzKillLogWidget, KillMarksContainer) == 0x000368, "Member 'UGzKillLogWidget::KillMarksContainer' has a wrong offset!");
static_assert(offsetof(UGzKillLogWidget, KillText) == 0x000380, "Member 'UGzKillLogWidget::KillText' has a wrong offset!");
static_assert(offsetof(UGzKillLogWidget, AssistText) == 0x000390, "Member 'UGzKillLogWidget::AssistText' has a wrong offset!");
static_assert(offsetof(UGzKillLogWidget, KnockDownText) == 0x0003A0, "Member 'UGzKillLogWidget::KnockDownText' has a wrong offset!");

// Class G01.GzEpicVoiceChatService
// 0x0070 (0x01C8 - 0x0158)
class UGzEpicVoiceChatService final : public UGzVoiceChatServiceBase
{
public:
	uint8                                         Pad_321C[0x70];                                    // 0x0158(0x0070)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnSettingsApplied();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzEpicVoiceChatService">();
	}
	static class UGzEpicVoiceChatService* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzEpicVoiceChatService>();
	}
};
static_assert(alignof(UGzEpicVoiceChatService) == 0x000008, "Wrong alignment on UGzEpicVoiceChatService");
static_assert(sizeof(UGzEpicVoiceChatService) == 0x0001C8, "Wrong size on UGzEpicVoiceChatService");

// Class G01.GzEquipAnimationInterface
// 0x0000 (0x0028 - 0x0028)
class IGzEquipAnimationInterface final : public IInterface
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzEquipAnimationInterface">();
	}
	static class IGzEquipAnimationInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IGzEquipAnimationInterface>();
	}
};
static_assert(alignof(IGzEquipAnimationInterface) == 0x000008, "Wrong alignment on IGzEquipAnimationInterface");
static_assert(sizeof(IGzEquipAnimationInterface) == 0x000028, "Wrong size on IGzEquipAnimationInterface");

// Class G01.GzPlayerRevivedMessage
// 0x0000 (0x0048 - 0x0048)
class UGzPlayerRevivedMessage final : public UGzPlayerToPlayerInteractionMessage
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzPlayerRevivedMessage">();
	}
	static class UGzPlayerRevivedMessage* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzPlayerRevivedMessage>();
	}
};
static_assert(alignof(UGzPlayerRevivedMessage) == 0x000008, "Wrong alignment on UGzPlayerRevivedMessage");
static_assert(sizeof(UGzPlayerRevivedMessage) == 0x000048, "Wrong size on UGzPlayerRevivedMessage");

// Class G01.GzErrorCodeDescriptions
// 0x0070 (0x00A8 - 0x0038)
class UGzErrorCodeDescriptions final : public UDeveloperSettings
{
public:
	TArray<struct FGzStatusCodesDescription>      StatusCodesDescription;                            // 0x0038(0x0010)(Edit, ZeroConstructor, Config, DisableEditOnInstance, NativeAccessSpecifierPublic)
	uint8                                         Pad_321D[0x50];                                    // 0x0048(0x0050)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   GenericErrorText;                                  // 0x0098(0x0010)(Edit, Config, DisableEditOnInstance, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzErrorCodeDescriptions">();
	}
	static class UGzErrorCodeDescriptions* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzErrorCodeDescriptions>();
	}
};
static_assert(alignof(UGzErrorCodeDescriptions) == 0x000008, "Wrong alignment on UGzErrorCodeDescriptions");
static_assert(sizeof(UGzErrorCodeDescriptions) == 0x0000A8, "Wrong size on UGzErrorCodeDescriptions");
static_assert(offsetof(UGzErrorCodeDescriptions, StatusCodesDescription) == 0x000038, "Member 'UGzErrorCodeDescriptions::StatusCodesDescription' has a wrong offset!");
static_assert(offsetof(UGzErrorCodeDescriptions, GenericErrorText) == 0x000098, "Member 'UGzErrorCodeDescriptions::GenericErrorText' has a wrong offset!");

// Class G01.GzErrorNotificationsCheatExtension
// 0x0000 (0x0028 - 0x0028)
class UGzErrorNotificationsCheatExtension final : public UGzCheatManagerExtension
{
public:
	void PostMetaErrorFromAzureCode(const int32 InCode) const;
	void PostMetaErrorFromCustomError() const;
	void PostMetaErrorFromErrorNotification(const int32 InCode) const;
	void PostMetaErrorFromPlayFabCode(const int32 InCode) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzErrorNotificationsCheatExtension">();
	}
	static class UGzErrorNotificationsCheatExtension* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzErrorNotificationsCheatExtension>();
	}
};
static_assert(alignof(UGzErrorNotificationsCheatExtension) == 0x000008, "Wrong alignment on UGzErrorNotificationsCheatExtension");
static_assert(sizeof(UGzErrorNotificationsCheatExtension) == 0x000028, "Wrong size on UGzErrorNotificationsCheatExtension");

// Class G01.GzSoundSettings
// 0x0590 (0x05C8 - 0x0038)
class UGzSoundSettings final : public UDeveloperSettings
{
public:
	TArray<struct FGzSoundState>                  SoundStates;                                       // 0x0038(0x0010)(Edit, ZeroConstructor, Config, NativeAccessSpecifierPublic)
	struct FGzSoundStateKey                       DeathSoundState;                                   // 0x0048(0x0008)(Edit, Config, NoDestructor, NativeAccessSpecifierPublic)
	class FName                                   LeftArmEndBoneName;                                // 0x0050(0x0008)(Edit, ZeroConstructor, Config, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   RightArmEndBoneName;                               // 0x0058(0x0008)(Edit, ZeroConstructor, Config, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   LeftLegEndBoneName;                                // 0x0060(0x0008)(Edit, ZeroConstructor, Config, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   RightLegEndBoneName;                               // 0x0068(0x0008)(Edit, ZeroConstructor, Config, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   TorsoBoneName;                                     // 0x0070(0x0008)(Edit, ZeroConstructor, Config, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                BoneTraceStartOffset;                              // 0x0078(0x0018)(Edit, ZeroConstructor, Config, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TraceLength;                                       // 0x0090(0x0004)(Edit, ZeroConstructor, Config, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_321E[0x4];                                     // 0x0094(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftObjectPtr<class UGzLimbStepSoundsData>   MovementSounds;                                    // 0x0098(0x0028)(Edit, Config, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGzEnvironmentZoneType                 DefaultEnvironmentZone;                            // 0x00C0(0x0058)(Edit, Config, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TArray<struct FGzEnvironmentZoneType>         EnvironmentZoneParameters;                         // 0x0118(0x0010)(Edit, ZeroConstructor, Config, DisableEditOnInstance, NativeAccessSpecifierPublic)
	float                                         EnvironmentZoneUpdateDistance;                     // 0x0128(0x0004)(Edit, ZeroConstructor, Config, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         EnvironmentZoneUpdateRateSeconds;                  // 0x012C(0x0004)(Edit, ZeroConstructor, Config, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UAkRtpc>                 ClipAmmoCountRtpc;                                 // 0x0130(0x0028)(Edit, Config, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FlybySoundDetectionRange;                          // 0x0158(0x0004)(Edit, ZeroConstructor, Config, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ApproximateShellInitialUpSpeed;                    // 0x015C(0x0004)(Edit, ZeroConstructor, Config, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              ApproximateShellFallOffset;                        // 0x0160(0x0010)(Edit, ZeroConstructor, Config, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UAkAudioEvent>           HoldBreathStartEvent;                              // 0x0170(0x0028)(Edit, Config, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UAkAudioEvent>           HoldBreathEndEvent;                                // 0x0198(0x0028)(Edit, Config, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UAkAudioEvent>           DefaultAudioPreset;                                // 0x01C0(0x0028)(Edit, Config, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMap<class FString, TSoftObjectPtr<class UAkAudioEvent>> AudioPresets;                                      // 0x01E8(0x0050)(Edit, Config, DisableEditOnInstance, UObjectWrapper, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UAkSwitchValue>          DefaultPersonalAssistantVoiceType;                 // 0x0238(0x0028)(Edit, Config, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMap<class FString, TSoftObjectPtr<class UAkSwitchValue>> PersonalAssistantVoiceType;                        // 0x0260(0x0050)(Edit, Config, DisableEditOnInstance, UObjectWrapper, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UAkRtpc>                 MainVolumeRtpc;                                    // 0x02B0(0x0028)(Edit, Config, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UAkRtpc>                 MusicVolumeRtpc;                                   // 0x02D8(0x0028)(Edit, Config, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UAkRtpc>                 SfxVolumeRtpc;                                     // 0x0300(0x0028)(Edit, Config, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UAkRtpc>                 VoVolumeRtpc;                                      // 0x0328(0x0028)(Edit, Config, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UAkRtpc>                 MatchStateAnnouncerVolumeRtpc;                     // 0x0350(0x0028)(Edit, Config, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UAkRtpc>                 PersonalAssistantVolumeRtpc;                       // 0x0378(0x0028)(Edit, Config, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UAkRtpc>                 CharacterVoiceVolumeRtpc;                          // 0x03A0(0x0028)(Edit, Config, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UAkRtpc>                 HapticsStrengthRtpc;                               // 0x03C8(0x0028)(Edit, Config, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UAkRtpc>                 InGameSoundRtpc;                                   // 0x03F0(0x0028)(Edit, Config, DisableEditOnInstance, AdvancedDisplay, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UAkRtpc>                 MovementSpeedRtpc;                                 // 0x0418(0x0028)(Edit, Config, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UAkRtpc>                 ZiplineDistanceLeftRtpc;                           // 0x0440(0x0028)(Edit, Config, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MovementSpeedInterpolationTime;                    // 0x0468(0x0004)(Edit, ZeroConstructor, Config, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShouldPlayOwnVoiceLine;                           // 0x046C(0x0001)(Edit, ZeroConstructor, Config, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_321F[0x3];                                     // 0x046D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<struct FGameplayTag, struct FGzSoftVoiceLineData> StartActionVoiceLineData;                          // 0x0470(0x0050)(Edit, Config, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TMap<struct FGameplayTag, struct FGzSoftVoiceLineData> EndActionVoiceLineData;                            // 0x04C0(0x0050)(Edit, Config, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TMap<struct FGameplayTag, TSubclassOf<class AGzAudioAnnouncer>> AudioAnnouncerClasses;                             // 0x0510(0x0050)(Edit, Config, DisableEditOnInstance, UObjectWrapper, NativeAccessSpecifierPublic)
	int32                                         PlayerCountToNotify;                               // 0x0560(0x0004)(Edit, ZeroConstructor, Config, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         TeamCountToNotify;                                 // 0x0564(0x0004)(Edit, ZeroConstructor, Config, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	double                                        DefaultVoiceLineRepeatDelay;                       // 0x0568(0x0008)(Edit, ZeroConstructor, Config, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         DefaultVoiceLineQueueSize;                         // 0x0570(0x0004)(Edit, ZeroConstructor, Config, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         KnockdownFallingScreamMinHeight;                   // 0x0574(0x0004)(Edit, ZeroConstructor, Config, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HintActivationDistMultiplier;                      // 0x0578(0x0004)(Edit, ZeroConstructor, Config, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3220[0x4];                                     // 0x057C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 WwiseMotionSharesetName;                           // 0x0580(0x0010)(Edit, ZeroConstructor, Config, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UAkAudioEvent>           DebugMotionInputEvent;                             // 0x0590(0x0028)(Edit, Config, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SpeedOfSound;                                      // 0x05B8(0x0004)(Edit, ZeroConstructor, Config, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3221[0x4];                                     // 0x05BC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UGzLimbStepSoundsData*                  CachedMovementSounds;                              // 0x05C0(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzSoundSettings">();
	}
	static class UGzSoundSettings* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzSoundSettings>();
	}
};
static_assert(alignof(UGzSoundSettings) == 0x000008, "Wrong alignment on UGzSoundSettings");
static_assert(sizeof(UGzSoundSettings) == 0x0005C8, "Wrong size on UGzSoundSettings");
static_assert(offsetof(UGzSoundSettings, SoundStates) == 0x000038, "Member 'UGzSoundSettings::SoundStates' has a wrong offset!");
static_assert(offsetof(UGzSoundSettings, DeathSoundState) == 0x000048, "Member 'UGzSoundSettings::DeathSoundState' has a wrong offset!");
static_assert(offsetof(UGzSoundSettings, LeftArmEndBoneName) == 0x000050, "Member 'UGzSoundSettings::LeftArmEndBoneName' has a wrong offset!");
static_assert(offsetof(UGzSoundSettings, RightArmEndBoneName) == 0x000058, "Member 'UGzSoundSettings::RightArmEndBoneName' has a wrong offset!");
static_assert(offsetof(UGzSoundSettings, LeftLegEndBoneName) == 0x000060, "Member 'UGzSoundSettings::LeftLegEndBoneName' has a wrong offset!");
static_assert(offsetof(UGzSoundSettings, RightLegEndBoneName) == 0x000068, "Member 'UGzSoundSettings::RightLegEndBoneName' has a wrong offset!");
static_assert(offsetof(UGzSoundSettings, TorsoBoneName) == 0x000070, "Member 'UGzSoundSettings::TorsoBoneName' has a wrong offset!");
static_assert(offsetof(UGzSoundSettings, BoneTraceStartOffset) == 0x000078, "Member 'UGzSoundSettings::BoneTraceStartOffset' has a wrong offset!");
static_assert(offsetof(UGzSoundSettings, TraceLength) == 0x000090, "Member 'UGzSoundSettings::TraceLength' has a wrong offset!");
static_assert(offsetof(UGzSoundSettings, MovementSounds) == 0x000098, "Member 'UGzSoundSettings::MovementSounds' has a wrong offset!");
static_assert(offsetof(UGzSoundSettings, DefaultEnvironmentZone) == 0x0000C0, "Member 'UGzSoundSettings::DefaultEnvironmentZone' has a wrong offset!");
static_assert(offsetof(UGzSoundSettings, EnvironmentZoneParameters) == 0x000118, "Member 'UGzSoundSettings::EnvironmentZoneParameters' has a wrong offset!");
static_assert(offsetof(UGzSoundSettings, EnvironmentZoneUpdateDistance) == 0x000128, "Member 'UGzSoundSettings::EnvironmentZoneUpdateDistance' has a wrong offset!");
static_assert(offsetof(UGzSoundSettings, EnvironmentZoneUpdateRateSeconds) == 0x00012C, "Member 'UGzSoundSettings::EnvironmentZoneUpdateRateSeconds' has a wrong offset!");
static_assert(offsetof(UGzSoundSettings, ClipAmmoCountRtpc) == 0x000130, "Member 'UGzSoundSettings::ClipAmmoCountRtpc' has a wrong offset!");
static_assert(offsetof(UGzSoundSettings, FlybySoundDetectionRange) == 0x000158, "Member 'UGzSoundSettings::FlybySoundDetectionRange' has a wrong offset!");
static_assert(offsetof(UGzSoundSettings, ApproximateShellInitialUpSpeed) == 0x00015C, "Member 'UGzSoundSettings::ApproximateShellInitialUpSpeed' has a wrong offset!");
static_assert(offsetof(UGzSoundSettings, ApproximateShellFallOffset) == 0x000160, "Member 'UGzSoundSettings::ApproximateShellFallOffset' has a wrong offset!");
static_assert(offsetof(UGzSoundSettings, HoldBreathStartEvent) == 0x000170, "Member 'UGzSoundSettings::HoldBreathStartEvent' has a wrong offset!");
static_assert(offsetof(UGzSoundSettings, HoldBreathEndEvent) == 0x000198, "Member 'UGzSoundSettings::HoldBreathEndEvent' has a wrong offset!");
static_assert(offsetof(UGzSoundSettings, DefaultAudioPreset) == 0x0001C0, "Member 'UGzSoundSettings::DefaultAudioPreset' has a wrong offset!");
static_assert(offsetof(UGzSoundSettings, AudioPresets) == 0x0001E8, "Member 'UGzSoundSettings::AudioPresets' has a wrong offset!");
static_assert(offsetof(UGzSoundSettings, DefaultPersonalAssistantVoiceType) == 0x000238, "Member 'UGzSoundSettings::DefaultPersonalAssistantVoiceType' has a wrong offset!");
static_assert(offsetof(UGzSoundSettings, PersonalAssistantVoiceType) == 0x000260, "Member 'UGzSoundSettings::PersonalAssistantVoiceType' has a wrong offset!");
static_assert(offsetof(UGzSoundSettings, MainVolumeRtpc) == 0x0002B0, "Member 'UGzSoundSettings::MainVolumeRtpc' has a wrong offset!");
static_assert(offsetof(UGzSoundSettings, MusicVolumeRtpc) == 0x0002D8, "Member 'UGzSoundSettings::MusicVolumeRtpc' has a wrong offset!");
static_assert(offsetof(UGzSoundSettings, SfxVolumeRtpc) == 0x000300, "Member 'UGzSoundSettings::SfxVolumeRtpc' has a wrong offset!");
static_assert(offsetof(UGzSoundSettings, VoVolumeRtpc) == 0x000328, "Member 'UGzSoundSettings::VoVolumeRtpc' has a wrong offset!");
static_assert(offsetof(UGzSoundSettings, MatchStateAnnouncerVolumeRtpc) == 0x000350, "Member 'UGzSoundSettings::MatchStateAnnouncerVolumeRtpc' has a wrong offset!");
static_assert(offsetof(UGzSoundSettings, PersonalAssistantVolumeRtpc) == 0x000378, "Member 'UGzSoundSettings::PersonalAssistantVolumeRtpc' has a wrong offset!");
static_assert(offsetof(UGzSoundSettings, CharacterVoiceVolumeRtpc) == 0x0003A0, "Member 'UGzSoundSettings::CharacterVoiceVolumeRtpc' has a wrong offset!");
static_assert(offsetof(UGzSoundSettings, HapticsStrengthRtpc) == 0x0003C8, "Member 'UGzSoundSettings::HapticsStrengthRtpc' has a wrong offset!");
static_assert(offsetof(UGzSoundSettings, InGameSoundRtpc) == 0x0003F0, "Member 'UGzSoundSettings::InGameSoundRtpc' has a wrong offset!");
static_assert(offsetof(UGzSoundSettings, MovementSpeedRtpc) == 0x000418, "Member 'UGzSoundSettings::MovementSpeedRtpc' has a wrong offset!");
static_assert(offsetof(UGzSoundSettings, ZiplineDistanceLeftRtpc) == 0x000440, "Member 'UGzSoundSettings::ZiplineDistanceLeftRtpc' has a wrong offset!");
static_assert(offsetof(UGzSoundSettings, MovementSpeedInterpolationTime) == 0x000468, "Member 'UGzSoundSettings::MovementSpeedInterpolationTime' has a wrong offset!");
static_assert(offsetof(UGzSoundSettings, bShouldPlayOwnVoiceLine) == 0x00046C, "Member 'UGzSoundSettings::bShouldPlayOwnVoiceLine' has a wrong offset!");
static_assert(offsetof(UGzSoundSettings, StartActionVoiceLineData) == 0x000470, "Member 'UGzSoundSettings::StartActionVoiceLineData' has a wrong offset!");
static_assert(offsetof(UGzSoundSettings, EndActionVoiceLineData) == 0x0004C0, "Member 'UGzSoundSettings::EndActionVoiceLineData' has a wrong offset!");
static_assert(offsetof(UGzSoundSettings, AudioAnnouncerClasses) == 0x000510, "Member 'UGzSoundSettings::AudioAnnouncerClasses' has a wrong offset!");
static_assert(offsetof(UGzSoundSettings, PlayerCountToNotify) == 0x000560, "Member 'UGzSoundSettings::PlayerCountToNotify' has a wrong offset!");
static_assert(offsetof(UGzSoundSettings, TeamCountToNotify) == 0x000564, "Member 'UGzSoundSettings::TeamCountToNotify' has a wrong offset!");
static_assert(offsetof(UGzSoundSettings, DefaultVoiceLineRepeatDelay) == 0x000568, "Member 'UGzSoundSettings::DefaultVoiceLineRepeatDelay' has a wrong offset!");
static_assert(offsetof(UGzSoundSettings, DefaultVoiceLineQueueSize) == 0x000570, "Member 'UGzSoundSettings::DefaultVoiceLineQueueSize' has a wrong offset!");
static_assert(offsetof(UGzSoundSettings, KnockdownFallingScreamMinHeight) == 0x000574, "Member 'UGzSoundSettings::KnockdownFallingScreamMinHeight' has a wrong offset!");
static_assert(offsetof(UGzSoundSettings, HintActivationDistMultiplier) == 0x000578, "Member 'UGzSoundSettings::HintActivationDistMultiplier' has a wrong offset!");
static_assert(offsetof(UGzSoundSettings, WwiseMotionSharesetName) == 0x000580, "Member 'UGzSoundSettings::WwiseMotionSharesetName' has a wrong offset!");
static_assert(offsetof(UGzSoundSettings, DebugMotionInputEvent) == 0x000590, "Member 'UGzSoundSettings::DebugMotionInputEvent' has a wrong offset!");
static_assert(offsetof(UGzSoundSettings, SpeedOfSound) == 0x0005B8, "Member 'UGzSoundSettings::SpeedOfSound' has a wrong offset!");
static_assert(offsetof(UGzSoundSettings, CachedMovementSounds) == 0x0005C0, "Member 'UGzSoundSettings::CachedMovementSounds' has a wrong offset!");

// Class G01.GzErrorNotificationService
// 0x00B8 (0x0158 - 0x00A0)
class UGzErrorNotificationService final : public UGzClientPFObject
{
public:
	uint8                                         Pad_3222[0xB8];                                    // 0x00A0(0x00B8)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzErrorNotificationService">();
	}
	static class UGzErrorNotificationService* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzErrorNotificationService>();
	}
};
static_assert(alignof(UGzErrorNotificationService) == 0x000008, "Wrong alignment on UGzErrorNotificationService");
static_assert(sizeof(UGzErrorNotificationService) == 0x000158, "Wrong size on UGzErrorNotificationService");

// Class G01.GzErrorNotificationsModel
// 0x0000 (0x0070 - 0x0070)
class UGzErrorNotificationsModel final : public UGzBackendModel
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzErrorNotificationsModel">();
	}
	static class UGzErrorNotificationsModel* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzErrorNotificationsModel>();
	}
};
static_assert(alignof(UGzErrorNotificationsModel) == 0x000008, "Wrong alignment on UGzErrorNotificationsModel");
static_assert(sizeof(UGzErrorNotificationsModel) == 0x000070, "Wrong size on UGzErrorNotificationsModel");

// Class G01.GzGC_CharacterVoiceLine
// 0x0010 (0x0050 - 0x0040)
class UGzGC_CharacterVoiceLine final : public UGameplayCueNotify_Static
{
public:
	struct FGameplayTag                           VoiceLineTag;                                      // 0x0040(0x0008)(Edit, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bStarted;                                          // 0x0048(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3223[0x7];                                     // 0x0049(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzGC_CharacterVoiceLine">();
	}
	static class UGzGC_CharacterVoiceLine* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzGC_CharacterVoiceLine>();
	}
};
static_assert(alignof(UGzGC_CharacterVoiceLine) == 0x000008, "Wrong alignment on UGzGC_CharacterVoiceLine");
static_assert(sizeof(UGzGC_CharacterVoiceLine) == 0x000050, "Wrong size on UGzGC_CharacterVoiceLine");
static_assert(offsetof(UGzGC_CharacterVoiceLine, VoiceLineTag) == 0x000040, "Member 'UGzGC_CharacterVoiceLine::VoiceLineTag' has a wrong offset!");
static_assert(offsetof(UGzGC_CharacterVoiceLine, bStarted) == 0x000048, "Member 'UGzGC_CharacterVoiceLine::bStarted' has a wrong offset!");

// Class G01.GzEventLogWidget
// 0x00B8 (0x0398 - 0x02E0)
class UGzEventLogWidget : public UUserWidget
{
public:
	float                                         KnockDownNotificationDelay;                        // 0x02E0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_3224[0x4];                                     // 0x02E4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSet<class UGzPlayerOutOfHealthMessage*>      MessageBuffer;                                     // 0x02E8(0x0050)(NativeAccessSpecifierPrivate)
	uint8                                         Pad_3225[0x60];                                    // 0x0338(0x0060)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AddPlayerOutOfHealthNotification_BP(const class UGzPlayerOutOfHealthMessage* PlayerOutOfHealthMessage);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzEventLogWidget">();
	}
	static class UGzEventLogWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzEventLogWidget>();
	}
};
static_assert(alignof(UGzEventLogWidget) == 0x000008, "Wrong alignment on UGzEventLogWidget");
static_assert(sizeof(UGzEventLogWidget) == 0x000398, "Wrong size on UGzEventLogWidget");
static_assert(offsetof(UGzEventLogWidget, KnockDownNotificationDelay) == 0x0002E0, "Member 'UGzEventLogWidget::KnockDownNotificationDelay' has a wrong offset!");
static_assert(offsetof(UGzEventLogWidget, MessageBuffer) == 0x0002E8, "Member 'UGzEventLogWidget::MessageBuffer' has a wrong offset!");

// Class G01.GzInitialSetupControllerState
// 0x0000 (0x0060 - 0x0060)
class UGzInitialSetupControllerState final : public UGzFlowState
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzInitialSetupControllerState">();
	}
	static class UGzInitialSetupControllerState* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzInitialSetupControllerState>();
	}
};
static_assert(alignof(UGzInitialSetupControllerState) == 0x000008, "Wrong alignment on UGzInitialSetupControllerState");
static_assert(sizeof(UGzInitialSetupControllerState) == 0x000060, "Wrong size on UGzInitialSetupControllerState");

// Class G01.GzExplosionComponent
// 0x0030 (0x00D8 - 0x00A8)
class UGzExplosionComponent final : public UActorComponent
{
public:
	TArray<ECollisionChannel>                     ExplosionTraceTypes;                               // 0x00A8(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	bool                                          bDrawDebug;                                        // 0x00B8(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3226[0x7];                                     // 0x00B9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UGzExplosionData*                       ExplosionData;                                     // 0x00C0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class AGzPropagationActor*                    PropagationActor;                                  // 0x00C8(0x0008)(ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3227[0x8];                                     // 0x00D0(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Explode();
	void ExplodeAtClients(const struct FGzProjectileImpactData& ImpactData);
	void ExplodeWithInstigator(class APawn* InstigatorPawn, class AActor* CharacterIdAccessActor);
	void ExplodeWithParameters(const struct FGzExplosionParameters& Params_0);
	void SetCharge(float Charge);
	void SetExplosionData(class UGzExplosionData* Data);

	class UGzExplosionData* GetExplosionData() const;
	const TArray<ECollisionChannel> GetExplosionTraceTypes() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzExplosionComponent">();
	}
	static class UGzExplosionComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzExplosionComponent>();
	}
};
static_assert(alignof(UGzExplosionComponent) == 0x000008, "Wrong alignment on UGzExplosionComponent");
static_assert(sizeof(UGzExplosionComponent) == 0x0000D8, "Wrong size on UGzExplosionComponent");
static_assert(offsetof(UGzExplosionComponent, ExplosionTraceTypes) == 0x0000A8, "Member 'UGzExplosionComponent::ExplosionTraceTypes' has a wrong offset!");
static_assert(offsetof(UGzExplosionComponent, bDrawDebug) == 0x0000B8, "Member 'UGzExplosionComponent::bDrawDebug' has a wrong offset!");
static_assert(offsetof(UGzExplosionComponent, ExplosionData) == 0x0000C0, "Member 'UGzExplosionComponent::ExplosionData' has a wrong offset!");
static_assert(offsetof(UGzExplosionComponent, PropagationActor) == 0x0000C8, "Member 'UGzExplosionComponent::PropagationActor' has a wrong offset!");

// Class G01.GzExplosionData
// 0x0060 (0x0090 - 0x0030)
class UGzExplosionData final : public UDataAsset
{
public:
	TSubclassOf<class UGzGE_BaseDamage>           AttackDamageEffect;                                // 0x0030(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<TSubclassOf<class UGameplayEffect>>    AdditionalEffects;                                 // 0x0038(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, UObjectWrapper, NativeAccessSpecifierPublic)
	float                                         ExplosionRadius;                                   // 0x0048(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDestroyOwnerOnDetonation;                         // 0x004C(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShouldDamageInstigator;                           // 0x004D(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShouldDamageAttachedActors;                       // 0x004E(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShouldDamageInstigatorsTeam;                      // 0x004F(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShouldDamageAttachParent;                         // 0x0050(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bHasPropagation;                                   // 0x0051(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3228[0x6];                                     // 0x0052(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class AGzPropagationActor>        PropagationActorClass;                             // 0x0058(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDestroyPropagationWithOwner;                      // 0x0060(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseInstigatorLifespan;                            // 0x0061(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3229[0x2];                                     // 0x0062(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         PropagationLifespan;                               // 0x0064(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UNiagaraSystem*                         ExplosionParticleNiagaraSystem;                    // 0x0068(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAkAudioEvent*                          ExplosionAkAudioEvent;                             // 0x0070(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECameraShakeAttenuation                       CameraShakeAttenuation;                            // 0x0078(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_322A[0x3];                                     // 0x0079(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         CameraShakeInnerAttenuationRadius;                 // 0x007C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CameraShakeOuterAttenuationRadius;                 // 0x0080(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECameraShakePlaySpace                         CameraShakePlaySpace;                              // 0x0084(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_322B[0x3];                                     // 0x0085(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UCameraShakeBase>           CameraShakeClass;                                  // 0x0088(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzExplosionData">();
	}
	static class UGzExplosionData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzExplosionData>();
	}
};
static_assert(alignof(UGzExplosionData) == 0x000008, "Wrong alignment on UGzExplosionData");
static_assert(sizeof(UGzExplosionData) == 0x000090, "Wrong size on UGzExplosionData");
static_assert(offsetof(UGzExplosionData, AttackDamageEffect) == 0x000030, "Member 'UGzExplosionData::AttackDamageEffect' has a wrong offset!");
static_assert(offsetof(UGzExplosionData, AdditionalEffects) == 0x000038, "Member 'UGzExplosionData::AdditionalEffects' has a wrong offset!");
static_assert(offsetof(UGzExplosionData, ExplosionRadius) == 0x000048, "Member 'UGzExplosionData::ExplosionRadius' has a wrong offset!");
static_assert(offsetof(UGzExplosionData, bDestroyOwnerOnDetonation) == 0x00004C, "Member 'UGzExplosionData::bDestroyOwnerOnDetonation' has a wrong offset!");
static_assert(offsetof(UGzExplosionData, bShouldDamageInstigator) == 0x00004D, "Member 'UGzExplosionData::bShouldDamageInstigator' has a wrong offset!");
static_assert(offsetof(UGzExplosionData, bShouldDamageAttachedActors) == 0x00004E, "Member 'UGzExplosionData::bShouldDamageAttachedActors' has a wrong offset!");
static_assert(offsetof(UGzExplosionData, bShouldDamageInstigatorsTeam) == 0x00004F, "Member 'UGzExplosionData::bShouldDamageInstigatorsTeam' has a wrong offset!");
static_assert(offsetof(UGzExplosionData, bShouldDamageAttachParent) == 0x000050, "Member 'UGzExplosionData::bShouldDamageAttachParent' has a wrong offset!");
static_assert(offsetof(UGzExplosionData, bHasPropagation) == 0x000051, "Member 'UGzExplosionData::bHasPropagation' has a wrong offset!");
static_assert(offsetof(UGzExplosionData, PropagationActorClass) == 0x000058, "Member 'UGzExplosionData::PropagationActorClass' has a wrong offset!");
static_assert(offsetof(UGzExplosionData, bDestroyPropagationWithOwner) == 0x000060, "Member 'UGzExplosionData::bDestroyPropagationWithOwner' has a wrong offset!");
static_assert(offsetof(UGzExplosionData, bUseInstigatorLifespan) == 0x000061, "Member 'UGzExplosionData::bUseInstigatorLifespan' has a wrong offset!");
static_assert(offsetof(UGzExplosionData, PropagationLifespan) == 0x000064, "Member 'UGzExplosionData::PropagationLifespan' has a wrong offset!");
static_assert(offsetof(UGzExplosionData, ExplosionParticleNiagaraSystem) == 0x000068, "Member 'UGzExplosionData::ExplosionParticleNiagaraSystem' has a wrong offset!");
static_assert(offsetof(UGzExplosionData, ExplosionAkAudioEvent) == 0x000070, "Member 'UGzExplosionData::ExplosionAkAudioEvent' has a wrong offset!");
static_assert(offsetof(UGzExplosionData, CameraShakeAttenuation) == 0x000078, "Member 'UGzExplosionData::CameraShakeAttenuation' has a wrong offset!");
static_assert(offsetof(UGzExplosionData, CameraShakeInnerAttenuationRadius) == 0x00007C, "Member 'UGzExplosionData::CameraShakeInnerAttenuationRadius' has a wrong offset!");
static_assert(offsetof(UGzExplosionData, CameraShakeOuterAttenuationRadius) == 0x000080, "Member 'UGzExplosionData::CameraShakeOuterAttenuationRadius' has a wrong offset!");
static_assert(offsetof(UGzExplosionData, CameraShakePlaySpace) == 0x000084, "Member 'UGzExplosionData::CameraShakePlaySpace' has a wrong offset!");
static_assert(offsetof(UGzExplosionData, CameraShakeClass) == 0x000088, "Member 'UGzExplosionData::CameraShakeClass' has a wrong offset!");

// Class G01.GzExtractionRoyaleCheatExtension
// 0x0028 (0x0050 - 0x0028)
class UGzExtractionRoyaleCheatExtension final : public UGzCheatManagerExtension
{
public:
	TArray<class AGzProcedureTrackTransportLandingLocation*> PreviouslyUsedLandingLocations;                    // 0x0028(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	TArray<class AGzProcedureTrackTransportLandingLocation*> NewlyUsedLandingLocations;                         // 0x0038(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	uint8                                         Pad_322C[0x8];                                     // 0x0048(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void NotificationRecieved(const struct FGzEventNotificationData& GzEventNotificationData);
	void TeleportToNextLandingLocation();
	void TriggerAllDropPodDelivery();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzExtractionRoyaleCheatExtension">();
	}
	static class UGzExtractionRoyaleCheatExtension* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzExtractionRoyaleCheatExtension>();
	}
};
static_assert(alignof(UGzExtractionRoyaleCheatExtension) == 0x000008, "Wrong alignment on UGzExtractionRoyaleCheatExtension");
static_assert(sizeof(UGzExtractionRoyaleCheatExtension) == 0x000050, "Wrong size on UGzExtractionRoyaleCheatExtension");
static_assert(offsetof(UGzExtractionRoyaleCheatExtension, PreviouslyUsedLandingLocations) == 0x000028, "Member 'UGzExtractionRoyaleCheatExtension::PreviouslyUsedLandingLocations' has a wrong offset!");
static_assert(offsetof(UGzExtractionRoyaleCheatExtension, NewlyUsedLandingLocations) == 0x000038, "Member 'UGzExtractionRoyaleCheatExtension::NewlyUsedLandingLocations' has a wrong offset!");

// Class G01.GzExtractionRoyaleGameMode
// 0x0050 (0x0690 - 0x0640)
class AGzExtractionRoyaleGameMode : public AGzMultiStageGameMode
{
public:
	uint8                                         Pad_322D[0x18];                                    // 0x0640(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UGzXR_PreMatchStage>        PreMatchClass;                                     // 0x0658(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoClear, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSubclassOf<class UGzXR_MatchInProgressStage> MatchInProgressClass;                              // 0x0660(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoClear, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSubclassOf<class UGzXR_PostMatchStage>       PostMatchClass;                                    // 0x0668(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoClear, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSubclassOf<class UGzXR_PrepareMatch>         PrepareForMatchClass;                              // 0x0670(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSubclassOf<class UGzXR_DeploymentCutsceneStage> DeploymentCutsceneClass;                           // 0x0678(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UGzXR_DeploymentCutsceneStage*          DeploymentCutsceneStage;                           // 0x0680(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_322E[0x8];                                     // 0x0688(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzExtractionRoyaleGameMode">();
	}
	static class AGzExtractionRoyaleGameMode* GetDefaultObj()
	{
		return GetDefaultObjImpl<AGzExtractionRoyaleGameMode>();
	}
};
static_assert(alignof(AGzExtractionRoyaleGameMode) == 0x000008, "Wrong alignment on AGzExtractionRoyaleGameMode");
static_assert(sizeof(AGzExtractionRoyaleGameMode) == 0x000690, "Wrong size on AGzExtractionRoyaleGameMode");
static_assert(offsetof(AGzExtractionRoyaleGameMode, PreMatchClass) == 0x000658, "Member 'AGzExtractionRoyaleGameMode::PreMatchClass' has a wrong offset!");
static_assert(offsetof(AGzExtractionRoyaleGameMode, MatchInProgressClass) == 0x000660, "Member 'AGzExtractionRoyaleGameMode::MatchInProgressClass' has a wrong offset!");
static_assert(offsetof(AGzExtractionRoyaleGameMode, PostMatchClass) == 0x000668, "Member 'AGzExtractionRoyaleGameMode::PostMatchClass' has a wrong offset!");
static_assert(offsetof(AGzExtractionRoyaleGameMode, PrepareForMatchClass) == 0x000670, "Member 'AGzExtractionRoyaleGameMode::PrepareForMatchClass' has a wrong offset!");
static_assert(offsetof(AGzExtractionRoyaleGameMode, DeploymentCutsceneClass) == 0x000678, "Member 'AGzExtractionRoyaleGameMode::DeploymentCutsceneClass' has a wrong offset!");
static_assert(offsetof(AGzExtractionRoyaleGameMode, DeploymentCutsceneStage) == 0x000680, "Member 'AGzExtractionRoyaleGameMode::DeploymentCutsceneStage' has a wrong offset!");

// Class G01.GzExtractionRoyaleGameState
// 0x0068 (0x06E0 - 0x0678)
class AGzExtractionRoyaleGameState : public AGzMultiStageGameState
{
public:
	FMulticastInlineDelegateProperty_             OnEventNotificationReceived;                       // 0x0678(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnRedeployPriceChanged;                            // 0x0688(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_322F[0x18];                                    // 0x0698(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         LoadoutPriceMultiplier;                            // 0x06B0(0x0004)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         RedeployPriceMultiplier;                           // 0x06B4(0x0004)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         HexExtractionPriceMultiplier;                      // 0x06B8(0x0004)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         HexExtractionTimeMultiplier;                       // 0x06BC(0x0004)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_3230[0x8];                                     // 0x06C0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FGzEventNotificationData>       PersistantNotifications;                           // 0x06C8(0x0010)(Net, ZeroConstructor, RepNotify, NativeAccessSpecifierPrivate)
	uint8                                         Pad_3231[0x8];                                     // 0x06D8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Multicast_PostEventNotification(const struct FGzEventNotificationData& EventData);

	const TArray<struct FGzEventNotificationData> GetActivePersistantNotifications() const;
	float GetRedeployPriceMultiplier() const;
	bool IsNextStageShift() const;
	void OnRep_ActiveGlobalEvents() const;
	void OnRep_LoadoutPriceMultiplier() const;
	void OnRep_RedeployPriceMultiplier() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzExtractionRoyaleGameState">();
	}
	static class AGzExtractionRoyaleGameState* GetDefaultObj()
	{
		return GetDefaultObjImpl<AGzExtractionRoyaleGameState>();
	}
};
static_assert(alignof(AGzExtractionRoyaleGameState) == 0x000008, "Wrong alignment on AGzExtractionRoyaleGameState");
static_assert(sizeof(AGzExtractionRoyaleGameState) == 0x0006E0, "Wrong size on AGzExtractionRoyaleGameState");
static_assert(offsetof(AGzExtractionRoyaleGameState, OnEventNotificationReceived) == 0x000678, "Member 'AGzExtractionRoyaleGameState::OnEventNotificationReceived' has a wrong offset!");
static_assert(offsetof(AGzExtractionRoyaleGameState, OnRedeployPriceChanged) == 0x000688, "Member 'AGzExtractionRoyaleGameState::OnRedeployPriceChanged' has a wrong offset!");
static_assert(offsetof(AGzExtractionRoyaleGameState, LoadoutPriceMultiplier) == 0x0006B0, "Member 'AGzExtractionRoyaleGameState::LoadoutPriceMultiplier' has a wrong offset!");
static_assert(offsetof(AGzExtractionRoyaleGameState, RedeployPriceMultiplier) == 0x0006B4, "Member 'AGzExtractionRoyaleGameState::RedeployPriceMultiplier' has a wrong offset!");
static_assert(offsetof(AGzExtractionRoyaleGameState, HexExtractionPriceMultiplier) == 0x0006B8, "Member 'AGzExtractionRoyaleGameState::HexExtractionPriceMultiplier' has a wrong offset!");
static_assert(offsetof(AGzExtractionRoyaleGameState, HexExtractionTimeMultiplier) == 0x0006BC, "Member 'AGzExtractionRoyaleGameState::HexExtractionTimeMultiplier' has a wrong offset!");
static_assert(offsetof(AGzExtractionRoyaleGameState, PersistantNotifications) == 0x0006C8, "Member 'AGzExtractionRoyaleGameState::PersistantNotifications' has a wrong offset!");

// Class G01.GzReplayCameraRecorder
// 0x0018 (0x02B8 - 0x02A0)
class AGzReplayCameraRecorder final : public AActor
{
public:
	class USceneComponent*                        RecordingComponent;                                // 0x02A0(0x0008)(ExportObject, Net, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 PlayerName;                                        // 0x02A8(0x0010)(Net, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	void Client_Recording();
	void Server_ReportError();
	void Server_UpdateLocation(const struct FVector& InLocation, const struct FRotator& InRotator);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzReplayCameraRecorder">();
	}
	static class AGzReplayCameraRecorder* GetDefaultObj()
	{
		return GetDefaultObjImpl<AGzReplayCameraRecorder>();
	}
};
static_assert(alignof(AGzReplayCameraRecorder) == 0x000008, "Wrong alignment on AGzReplayCameraRecorder");
static_assert(sizeof(AGzReplayCameraRecorder) == 0x0002B8, "Wrong size on AGzReplayCameraRecorder");
static_assert(offsetof(AGzReplayCameraRecorder, RecordingComponent) == 0x0002A0, "Member 'AGzReplayCameraRecorder::RecordingComponent' has a wrong offset!");
static_assert(offsetof(AGzReplayCameraRecorder, PlayerName) == 0x0002A8, "Member 'AGzReplayCameraRecorder::PlayerName' has a wrong offset!");

// Class G01.GzExtractionRoyalePlayerState
// 0x0020 (0x06B0 - 0x0690)
class AGzExtractionRoyalePlayerState final : public AGzPlayerState
{
public:
	uint8                                         Pad_3232[0x18];                                    // 0x0690(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         LastRevealedStageIndex;                            // 0x06A8(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_3233[0x4];                                     // 0x06AC(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	float GetRespawnBonusTime() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzExtractionRoyalePlayerState">();
	}
	static class AGzExtractionRoyalePlayerState* GetDefaultObj()
	{
		return GetDefaultObjImpl<AGzExtractionRoyalePlayerState>();
	}
};
static_assert(alignof(AGzExtractionRoyalePlayerState) == 0x000008, "Wrong alignment on AGzExtractionRoyalePlayerState");
static_assert(sizeof(AGzExtractionRoyalePlayerState) == 0x0006B0, "Wrong size on AGzExtractionRoyalePlayerState");
static_assert(offsetof(AGzExtractionRoyalePlayerState, LastRevealedStageIndex) == 0x0006A8, "Member 'AGzExtractionRoyalePlayerState::LastRevealedStageIndex' has a wrong offset!");

// Class G01.GzXR_StageSettings
// 0x0030 (0x0058 - 0x0028)
class UGzXR_StageSettings : public UObject
{
public:
	float                                         BaseAutoRedeployTime;                              // 0x0028(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3234[0x4];                                     // 0x002C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UGzXR_BaseEvent*>                Events;                                            // 0x0030(0x0010)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, ContainsInstancedReference, NativeAccessSpecifierPublic)
	class UGzLootModifierTableData*               StageLootModifier;                                 // 0x0040(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class FName>                           StageLootZoneLayers;                               // 0x0048(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzXR_StageSettings">();
	}
	static class UGzXR_StageSettings* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzXR_StageSettings>();
	}
};
static_assert(alignof(UGzXR_StageSettings) == 0x000008, "Wrong alignment on UGzXR_StageSettings");
static_assert(sizeof(UGzXR_StageSettings) == 0x000058, "Wrong size on UGzXR_StageSettings");
static_assert(offsetof(UGzXR_StageSettings, BaseAutoRedeployTime) == 0x000028, "Member 'UGzXR_StageSettings::BaseAutoRedeployTime' has a wrong offset!");
static_assert(offsetof(UGzXR_StageSettings, Events) == 0x000030, "Member 'UGzXR_StageSettings::Events' has a wrong offset!");
static_assert(offsetof(UGzXR_StageSettings, StageLootModifier) == 0x000040, "Member 'UGzXR_StageSettings::StageLootModifier' has a wrong offset!");
static_assert(offsetof(UGzXR_StageSettings, StageLootZoneLayers) == 0x000048, "Member 'UGzXR_StageSettings::StageLootZoneLayers' has a wrong offset!");

// Class G01.GzSA_CancelAbility
// 0x0000 (0x0038 - 0x0038)
class UGzSA_CancelAbility final : public UGzStateAction
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzSA_CancelAbility">();
	}
	static class UGzSA_CancelAbility* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzSA_CancelAbility>();
	}
};
static_assert(alignof(UGzSA_CancelAbility) == 0x000008, "Wrong alignment on UGzSA_CancelAbility");
static_assert(sizeof(UGzSA_CancelAbility) == 0x000038, "Wrong size on UGzSA_CancelAbility");

// Class G01.GzXR_DeploymentStageSettings
// 0x0010 (0x0068 - 0x0058)
class UGzXR_DeploymentStageSettings final : public UGzXR_StageSettings
{
public:
	TSubclassOf<class UGzXR_DeploymentStage>      StageClass;                                        // 0x0058(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         StageEndDelay;                                     // 0x0060(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3235[0x4];                                     // 0x0064(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzXR_DeploymentStageSettings">();
	}
	static class UGzXR_DeploymentStageSettings* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzXR_DeploymentStageSettings>();
	}
};
static_assert(alignof(UGzXR_DeploymentStageSettings) == 0x000008, "Wrong alignment on UGzXR_DeploymentStageSettings");
static_assert(sizeof(UGzXR_DeploymentStageSettings) == 0x000068, "Wrong size on UGzXR_DeploymentStageSettings");
static_assert(offsetof(UGzXR_DeploymentStageSettings, StageClass) == 0x000058, "Member 'UGzXR_DeploymentStageSettings::StageClass' has a wrong offset!");
static_assert(offsetof(UGzXR_DeploymentStageSettings, StageEndDelay) == 0x000060, "Member 'UGzXR_DeploymentStageSettings::StageEndDelay' has a wrong offset!");

// Class G01.GzPostProcessConfigs
// 0x0100 (0x0130 - 0x0030)
class UGzPostProcessConfigs final : public UDataAsset
{
public:
	TMap<struct FGameplayTag, struct FGzTagPostProcessConfig> TagsAddedFxConfigs;                                // 0x0030(0x0050)(Edit, DisableEditOnInstance, ContainsInstancedReference, NativeAccessSpecifierPublic)
	TMap<struct FGameplayTag, struct FGzTagPostProcessConfig> TagsRemovedFXConfigs;                              // 0x0080(0x0050)(Edit, DisableEditOnInstance, ContainsInstancedReference, NativeAccessSpecifierPublic)
	TMap<struct FGameplayAttribute, struct FGzAttributePostProcessConfigs> AttributesFXs;                                     // 0x00D0(0x0050)(Edit, DisableEditOnInstance, ContainsInstancedReference, NativeAccessSpecifierPublic)
	TArray<class UGzPostProcessFX*>               StartupFXs;                                        // 0x0120(0x0010)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, ContainsInstancedReference, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzPostProcessConfigs">();
	}
	static class UGzPostProcessConfigs* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzPostProcessConfigs>();
	}
};
static_assert(alignof(UGzPostProcessConfigs) == 0x000008, "Wrong alignment on UGzPostProcessConfigs");
static_assert(sizeof(UGzPostProcessConfigs) == 0x000130, "Wrong size on UGzPostProcessConfigs");
static_assert(offsetof(UGzPostProcessConfigs, TagsAddedFxConfigs) == 0x000030, "Member 'UGzPostProcessConfigs::TagsAddedFxConfigs' has a wrong offset!");
static_assert(offsetof(UGzPostProcessConfigs, TagsRemovedFXConfigs) == 0x000080, "Member 'UGzPostProcessConfigs::TagsRemovedFXConfigs' has a wrong offset!");
static_assert(offsetof(UGzPostProcessConfigs, AttributesFXs) == 0x0000D0, "Member 'UGzPostProcessConfigs::AttributesFXs' has a wrong offset!");
static_assert(offsetof(UGzPostProcessConfigs, StartupFXs) == 0x000120, "Member 'UGzPostProcessConfigs::StartupFXs' has a wrong offset!");

// Class G01.GzXR_WaitingStageSettings
// 0x0010 (0x0068 - 0x0058)
class UGzXR_WaitingStageSettings final : public UGzXR_StageSettings
{
public:
	TSubclassOf<class UGzXR_WaitingStage>         StageClass;                                        // 0x0058(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Duration;                                          // 0x0060(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3236[0x4];                                     // 0x0064(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzXR_WaitingStageSettings">();
	}
	static class UGzXR_WaitingStageSettings* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzXR_WaitingStageSettings>();
	}
};
static_assert(alignof(UGzXR_WaitingStageSettings) == 0x000008, "Wrong alignment on UGzXR_WaitingStageSettings");
static_assert(sizeof(UGzXR_WaitingStageSettings) == 0x000068, "Wrong size on UGzXR_WaitingStageSettings");
static_assert(offsetof(UGzXR_WaitingStageSettings, StageClass) == 0x000058, "Member 'UGzXR_WaitingStageSettings::StageClass' has a wrong offset!");
static_assert(offsetof(UGzXR_WaitingStageSettings, Duration) == 0x000060, "Member 'UGzXR_WaitingStageSettings::Duration' has a wrong offset!");

// Class G01.GzXR_ShrinkingStageSettings
// 0x0018 (0x0070 - 0x0058)
class UGzXR_ShrinkingStageSettings final : public UGzXR_StageSettings
{
public:
	TSubclassOf<class UGzXR_ShrinkingStage>       StageClass;                                        // 0x0058(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEnableEndsSoonMessage;                            // 0x0060(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3237[0x7];                                     // 0x0061(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UGzBaseZoneStageParams*                 ZoneParams;                                        // 0x0068(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, PersistentInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzXR_ShrinkingStageSettings">();
	}
	static class UGzXR_ShrinkingStageSettings* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzXR_ShrinkingStageSettings>();
	}
};
static_assert(alignof(UGzXR_ShrinkingStageSettings) == 0x000008, "Wrong alignment on UGzXR_ShrinkingStageSettings");
static_assert(sizeof(UGzXR_ShrinkingStageSettings) == 0x000070, "Wrong size on UGzXR_ShrinkingStageSettings");
static_assert(offsetof(UGzXR_ShrinkingStageSettings, StageClass) == 0x000058, "Member 'UGzXR_ShrinkingStageSettings::StageClass' has a wrong offset!");
static_assert(offsetof(UGzXR_ShrinkingStageSettings, bEnableEndsSoonMessage) == 0x000060, "Member 'UGzXR_ShrinkingStageSettings::bEnableEndsSoonMessage' has a wrong offset!");
static_assert(offsetof(UGzXR_ShrinkingStageSettings, ZoneParams) == 0x000068, "Member 'UGzXR_ShrinkingStageSettings::ZoneParams' has a wrong offset!");

// Class G01.GzXR_StagesConfig
// 0x0010 (0x0040 - 0x0030)
class UGzXR_StagesConfig final : public UDataAsset
{
public:
	TArray<class UGzXR_StageSettings*>            Stages;                                            // 0x0030(0x0010)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, ContainsInstancedReference, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzXR_StagesConfig">();
	}
	static class UGzXR_StagesConfig* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzXR_StagesConfig>();
	}
};
static_assert(alignof(UGzXR_StagesConfig) == 0x000008, "Wrong alignment on UGzXR_StagesConfig");
static_assert(sizeof(UGzXR_StagesConfig) == 0x000040, "Wrong size on UGzXR_StagesConfig");
static_assert(offsetof(UGzXR_StagesConfig, Stages) == 0x000030, "Member 'UGzXR_StagesConfig::Stages' has a wrong offset!");

// Class G01.GzExtractionRoyaleSettings
// 0x00D0 (0x0240 - 0x0170)
class UGzExtractionRoyaleSettings final : public UGzSessionGameModeSettings
{
public:
	int32                                         ZoneSetupIndex;                                    // 0x0170(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         PreMatchDuration;                                  // 0x0174(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         MinPlayersForValidGame;                            // 0x0178(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         MinPlayersForPreMatchTimeReduction;                // 0x017C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         PreMatchReducedDuration;                           // 0x0180(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         MinPlayersForCountdown;                            // 0x0184(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         PreMatchCountdownDuration;                         // 0x0188(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         SpawnAreaNum;                                      // 0x018C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UGzBaseZoneStageParams*                 InitialZoneParams;                                 // 0x0190(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, PersistentInstance, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UGzXR_StagesConfig*                     StagesConfig;                                      // 0x0198(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         WaitingEndsSoonNotificationTime;                   // 0x01A0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_3238[0x4];                                     // 0x01A4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	double                                        RedeploymentRadius;                                // 0x01A8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	double                                        SafeSpawnDistance;                                 // 0x01B0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UGzPlayerLoadout*                       InitialLoadout;                                    // 0x01B8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<struct FGzPlayerLoadoutsSet>           ProgressiveLoadouts;                               // 0x01C0(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	float                                         PostMatchDuration;                                 // 0x01D0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_3239[0x4];                                     // 0x01D4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftClassPtr<class UClass>                   DeploymentTransportClass;                          // 0x01D8(0x0028)(Edit, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSoftClassPtr<class UClass>                   DeploymentPawnClass;                               // 0x0200(0x0028)(Edit, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         DeploymentCutsceneTimeOffset;                      // 0x0228(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bSyncDeploymentEnable;                             // 0x022C(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_323A[0x3];                                     // 0x022D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         KillerFocusDuration;                               // 0x0230(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bInitialAutoRedeploy;                              // 0x0234(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_323B[0x3];                                     // 0x0235(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         AutoRedeployDelay;                                 // 0x0238(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_323C[0x4];                                     // 0x023C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	int32 GetMinPlayersForCountdown() const;
	int32 GetMinPlayersForPreMatchTimeReduction() const;
	float GetPostMatchDuration() const;
	float GetPreMatchCountdownDuration() const;
	float GetPreMatchDurationRange() const;
	float GetPreMatchReducedDuration() const;
	int32 GetRequiredPlayers() const;
	int32 GetZoneSetupIndex() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzExtractionRoyaleSettings">();
	}
	static class UGzExtractionRoyaleSettings* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzExtractionRoyaleSettings>();
	}
};
static_assert(alignof(UGzExtractionRoyaleSettings) == 0x000008, "Wrong alignment on UGzExtractionRoyaleSettings");
static_assert(sizeof(UGzExtractionRoyaleSettings) == 0x000240, "Wrong size on UGzExtractionRoyaleSettings");
static_assert(offsetof(UGzExtractionRoyaleSettings, ZoneSetupIndex) == 0x000170, "Member 'UGzExtractionRoyaleSettings::ZoneSetupIndex' has a wrong offset!");
static_assert(offsetof(UGzExtractionRoyaleSettings, PreMatchDuration) == 0x000174, "Member 'UGzExtractionRoyaleSettings::PreMatchDuration' has a wrong offset!");
static_assert(offsetof(UGzExtractionRoyaleSettings, MinPlayersForValidGame) == 0x000178, "Member 'UGzExtractionRoyaleSettings::MinPlayersForValidGame' has a wrong offset!");
static_assert(offsetof(UGzExtractionRoyaleSettings, MinPlayersForPreMatchTimeReduction) == 0x00017C, "Member 'UGzExtractionRoyaleSettings::MinPlayersForPreMatchTimeReduction' has a wrong offset!");
static_assert(offsetof(UGzExtractionRoyaleSettings, PreMatchReducedDuration) == 0x000180, "Member 'UGzExtractionRoyaleSettings::PreMatchReducedDuration' has a wrong offset!");
static_assert(offsetof(UGzExtractionRoyaleSettings, MinPlayersForCountdown) == 0x000184, "Member 'UGzExtractionRoyaleSettings::MinPlayersForCountdown' has a wrong offset!");
static_assert(offsetof(UGzExtractionRoyaleSettings, PreMatchCountdownDuration) == 0x000188, "Member 'UGzExtractionRoyaleSettings::PreMatchCountdownDuration' has a wrong offset!");
static_assert(offsetof(UGzExtractionRoyaleSettings, SpawnAreaNum) == 0x00018C, "Member 'UGzExtractionRoyaleSettings::SpawnAreaNum' has a wrong offset!");
static_assert(offsetof(UGzExtractionRoyaleSettings, InitialZoneParams) == 0x000190, "Member 'UGzExtractionRoyaleSettings::InitialZoneParams' has a wrong offset!");
static_assert(offsetof(UGzExtractionRoyaleSettings, StagesConfig) == 0x000198, "Member 'UGzExtractionRoyaleSettings::StagesConfig' has a wrong offset!");
static_assert(offsetof(UGzExtractionRoyaleSettings, WaitingEndsSoonNotificationTime) == 0x0001A0, "Member 'UGzExtractionRoyaleSettings::WaitingEndsSoonNotificationTime' has a wrong offset!");
static_assert(offsetof(UGzExtractionRoyaleSettings, RedeploymentRadius) == 0x0001A8, "Member 'UGzExtractionRoyaleSettings::RedeploymentRadius' has a wrong offset!");
static_assert(offsetof(UGzExtractionRoyaleSettings, SafeSpawnDistance) == 0x0001B0, "Member 'UGzExtractionRoyaleSettings::SafeSpawnDistance' has a wrong offset!");
static_assert(offsetof(UGzExtractionRoyaleSettings, InitialLoadout) == 0x0001B8, "Member 'UGzExtractionRoyaleSettings::InitialLoadout' has a wrong offset!");
static_assert(offsetof(UGzExtractionRoyaleSettings, ProgressiveLoadouts) == 0x0001C0, "Member 'UGzExtractionRoyaleSettings::ProgressiveLoadouts' has a wrong offset!");
static_assert(offsetof(UGzExtractionRoyaleSettings, PostMatchDuration) == 0x0001D0, "Member 'UGzExtractionRoyaleSettings::PostMatchDuration' has a wrong offset!");
static_assert(offsetof(UGzExtractionRoyaleSettings, DeploymentTransportClass) == 0x0001D8, "Member 'UGzExtractionRoyaleSettings::DeploymentTransportClass' has a wrong offset!");
static_assert(offsetof(UGzExtractionRoyaleSettings, DeploymentPawnClass) == 0x000200, "Member 'UGzExtractionRoyaleSettings::DeploymentPawnClass' has a wrong offset!");
static_assert(offsetof(UGzExtractionRoyaleSettings, DeploymentCutsceneTimeOffset) == 0x000228, "Member 'UGzExtractionRoyaleSettings::DeploymentCutsceneTimeOffset' has a wrong offset!");
static_assert(offsetof(UGzExtractionRoyaleSettings, bSyncDeploymentEnable) == 0x00022C, "Member 'UGzExtractionRoyaleSettings::bSyncDeploymentEnable' has a wrong offset!");
static_assert(offsetof(UGzExtractionRoyaleSettings, KillerFocusDuration) == 0x000230, "Member 'UGzExtractionRoyaleSettings::KillerFocusDuration' has a wrong offset!");
static_assert(offsetof(UGzExtractionRoyaleSettings, bInitialAutoRedeploy) == 0x000234, "Member 'UGzExtractionRoyaleSettings::bInitialAutoRedeploy' has a wrong offset!");
static_assert(offsetof(UGzExtractionRoyaleSettings, AutoRedeployDelay) == 0x000238, "Member 'UGzExtractionRoyaleSettings::AutoRedeployDelay' has a wrong offset!");

// Class G01.GzExtractionRoyaleZoneCheatExtension
// 0x0000 (0x0028 - 0x0028)
class UGzExtractionRoyaleZoneCheatExtension final : public UGzCheatManagerExtension
{
public:
	void ContinueZoneShrinking() const;
	void PauseZoneShrinking() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzExtractionRoyaleZoneCheatExtension">();
	}
	static class UGzExtractionRoyaleZoneCheatExtension* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzExtractionRoyaleZoneCheatExtension>();
	}
};
static_assert(alignof(UGzExtractionRoyaleZoneCheatExtension) == 0x000008, "Wrong alignment on UGzExtractionRoyaleZoneCheatExtension");
static_assert(sizeof(UGzExtractionRoyaleZoneCheatExtension) == 0x000028, "Wrong size on UGzExtractionRoyaleZoneCheatExtension");

// Class G01.GzLoadoutListPreMatch
// 0x0010 (0x0478 - 0x0468)
class UGzLoadoutListPreMatch : public UGzLoadoutListSingleTab
{
public:
	uint8                                         Pad_323D[0x10];                                    // 0x0468(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void MemorizeLastChoosenGuid(bool bSuccessfull, const class AGzPlayerController* Controller, const struct FGzLoadoutDataConfig& CompletedWithConfig);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzLoadoutListPreMatch">();
	}
	static class UGzLoadoutListPreMatch* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzLoadoutListPreMatch>();
	}
};
static_assert(alignof(UGzLoadoutListPreMatch) == 0x000008, "Wrong alignment on UGzLoadoutListPreMatch");
static_assert(sizeof(UGzLoadoutListPreMatch) == 0x000478, "Wrong size on UGzLoadoutListPreMatch");

// Class G01.GzExtractorTowerSupply
// 0x0050 (0x02F0 - 0x02A0)
class AGzExtractorTowerSupply : public AActor
{
public:
	uint8                                         Pad_323F[0x8];                                     // 0x02A0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         HeatSinkHealth;                                    // 0x02A8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         MinRequiredHeatSinks;                              // 0x02AC(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         DormancyTime;                                      // 0x02B0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_3240[0x4];                                     // 0x02B4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class AGzItemExtractor*                       ItemExtractor;                                     // 0x02B8(0x0008)(Edit, ZeroConstructor, DisableEditOnTemplate, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint64                                        HeatSinksState;                                    // 0x02C0(0x0008)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bProtectionDown;                                   // 0x02C8(0x0001)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_3241[0x7];                                     // 0x02C9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class AGzDestructibleHeatSink*>        HeatSinks;                                         // 0x02D0(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	uint8                                         Pad_3242[0x10];                                    // 0x02E0(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	TArray<class AGzDestructibleHeatSink*> CollectHeatSinks();
	void Multicast_HeatSinkDestroyed(int32 Param_Index, const struct FHitResult& HitResult);
	void Multicast_ResetState();
	void OnExtractionDataChanged(const struct FGzExtractionData& Current);
	void OnRep_HeatSinksState();
	void OnRep_ProtectionDown();
	void ReceiveProtectionDownChanged();
	void ReceiveRequiredHeatSinksDestroyed();
	void ResetState();
	void SetExtractionOwnerTeam(int32 TeamID);
	void SetProtectionDown(bool bInProtectionDown);

	int32 GetDestroyedHeatSinkNum() const;
	const TArray<class AGzDestructibleHeatSink*> GetHeatSinks() const;
	class AGzItemExtractor* GetItemExtractor() const;
	int32 GetRemainingHeatSinkNum() const;
	bool IsHeatSinkDestroyed(const int32 Param_Index) const;
	bool IsProtectionDown() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzExtractorTowerSupply">();
	}
	static class AGzExtractorTowerSupply* GetDefaultObj()
	{
		return GetDefaultObjImpl<AGzExtractorTowerSupply>();
	}
};
static_assert(alignof(AGzExtractorTowerSupply) == 0x000008, "Wrong alignment on AGzExtractorTowerSupply");
static_assert(sizeof(AGzExtractorTowerSupply) == 0x0002F0, "Wrong size on AGzExtractorTowerSupply");
static_assert(offsetof(AGzExtractorTowerSupply, HeatSinkHealth) == 0x0002A8, "Member 'AGzExtractorTowerSupply::HeatSinkHealth' has a wrong offset!");
static_assert(offsetof(AGzExtractorTowerSupply, MinRequiredHeatSinks) == 0x0002AC, "Member 'AGzExtractorTowerSupply::MinRequiredHeatSinks' has a wrong offset!");
static_assert(offsetof(AGzExtractorTowerSupply, DormancyTime) == 0x0002B0, "Member 'AGzExtractorTowerSupply::DormancyTime' has a wrong offset!");
static_assert(offsetof(AGzExtractorTowerSupply, ItemExtractor) == 0x0002B8, "Member 'AGzExtractorTowerSupply::ItemExtractor' has a wrong offset!");
static_assert(offsetof(AGzExtractorTowerSupply, HeatSinksState) == 0x0002C0, "Member 'AGzExtractorTowerSupply::HeatSinksState' has a wrong offset!");
static_assert(offsetof(AGzExtractorTowerSupply, bProtectionDown) == 0x0002C8, "Member 'AGzExtractorTowerSupply::bProtectionDown' has a wrong offset!");
static_assert(offsetof(AGzExtractorTowerSupply, HeatSinks) == 0x0002D0, "Member 'AGzExtractorTowerSupply::HeatSinks' has a wrong offset!");

// Class G01.GzFactionSettings
// 0x0018 (0x0050 - 0x0038)
class UGzFactionSettings final : public UDeveloperSettings
{
public:
	uint8                                         Pad_3245[0x8];                                     // 0x0038(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FGzFaction>                     Factions;                                          // 0x0040(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, NativeAccessSpecifierPublic)

public:
	static const class UGzFactionSettings* GetFactionSettings();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzFactionSettings">();
	}
	static class UGzFactionSettings* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzFactionSettings>();
	}
};
static_assert(alignof(UGzFactionSettings) == 0x000008, "Wrong alignment on UGzFactionSettings");
static_assert(sizeof(UGzFactionSettings) == 0x000050, "Wrong size on UGzFactionSettings");
static_assert(offsetof(UGzFactionSettings, Factions) == 0x000040, "Member 'UGzFactionSettings::Factions' has a wrong offset!");

// Class G01.GzSplineSoundShape
// 0x0060 (0x0300 - 0x02A0)
class AGzSplineSoundShape : public AActor
{
public:
	class USplineComponent*                       Spline;                                            // 0x02A0(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAkAudioEvent*                          AudioEvent;                                        // 0x02A8(0x0008)(Edit, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         NumOfAudioPositions;                               // 0x02B0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         DistanceBetweenAudioPositions;                     // 0x02B4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         EventDisableAttenuationMultiplier;                 // 0x02B8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         CloseRangeDistance;                                // 0x02BC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         CloseRangeTickInterval;                            // 0x02C0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         LongRangeTickInterval;                             // 0x02C4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bSoundEmittingArea;                                // 0x02C8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3246[0x7];                                     // 0x02C9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                InsideSplinePosition;                              // 0x02D0(0x0018)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UGzStaticAkComponent*                   StaticAkComponent;                                 // 0x02E8(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3247[0x10];                                    // 0x02F0(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzSplineSoundShape">();
	}
	static class AGzSplineSoundShape* GetDefaultObj()
	{
		return GetDefaultObjImpl<AGzSplineSoundShape>();
	}
};
static_assert(alignof(AGzSplineSoundShape) == 0x000008, "Wrong alignment on AGzSplineSoundShape");
static_assert(sizeof(AGzSplineSoundShape) == 0x000300, "Wrong size on AGzSplineSoundShape");
static_assert(offsetof(AGzSplineSoundShape, Spline) == 0x0002A0, "Member 'AGzSplineSoundShape::Spline' has a wrong offset!");
static_assert(offsetof(AGzSplineSoundShape, AudioEvent) == 0x0002A8, "Member 'AGzSplineSoundShape::AudioEvent' has a wrong offset!");
static_assert(offsetof(AGzSplineSoundShape, NumOfAudioPositions) == 0x0002B0, "Member 'AGzSplineSoundShape::NumOfAudioPositions' has a wrong offset!");
static_assert(offsetof(AGzSplineSoundShape, DistanceBetweenAudioPositions) == 0x0002B4, "Member 'AGzSplineSoundShape::DistanceBetweenAudioPositions' has a wrong offset!");
static_assert(offsetof(AGzSplineSoundShape, EventDisableAttenuationMultiplier) == 0x0002B8, "Member 'AGzSplineSoundShape::EventDisableAttenuationMultiplier' has a wrong offset!");
static_assert(offsetof(AGzSplineSoundShape, CloseRangeDistance) == 0x0002BC, "Member 'AGzSplineSoundShape::CloseRangeDistance' has a wrong offset!");
static_assert(offsetof(AGzSplineSoundShape, CloseRangeTickInterval) == 0x0002C0, "Member 'AGzSplineSoundShape::CloseRangeTickInterval' has a wrong offset!");
static_assert(offsetof(AGzSplineSoundShape, LongRangeTickInterval) == 0x0002C4, "Member 'AGzSplineSoundShape::LongRangeTickInterval' has a wrong offset!");
static_assert(offsetof(AGzSplineSoundShape, bSoundEmittingArea) == 0x0002C8, "Member 'AGzSplineSoundShape::bSoundEmittingArea' has a wrong offset!");
static_assert(offsetof(AGzSplineSoundShape, InsideSplinePosition) == 0x0002D0, "Member 'AGzSplineSoundShape::InsideSplinePosition' has a wrong offset!");
static_assert(offsetof(AGzSplineSoundShape, StaticAkComponent) == 0x0002E8, "Member 'AGzSplineSoundShape::StaticAkComponent' has a wrong offset!");

// Class G01.GzFactionUtility
// 0x0000 (0x0028 - 0x0028)
class UGzFactionUtility final : public UBlueprintFunctionLibrary
{
public:
	static struct FGzFaction GetFactionData(const struct FGzFactionKey& Faction);
	static int32 GetFactionId(const struct FGzFactionKey& Faction);
	static TArray<class FName> GetFactionsNames();
	static TArray<int32> GetPlayerFactionIds();
	static TArray<class FName> GetPlayerFactionsNames();
	static int32 GetRandomFactionId();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzFactionUtility">();
	}
	static class UGzFactionUtility* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzFactionUtility>();
	}
};
static_assert(alignof(UGzFactionUtility) == 0x000008, "Wrong alignment on UGzFactionUtility");
static_assert(sizeof(UGzFactionUtility) == 0x000028, "Wrong size on UGzFactionUtility");

// Class G01.GzPolygonMarkerShape
// 0x0030 (0x0068 - 0x0038)
class UGzPolygonMarkerShape final : public UGzMarkerShape
{
public:
	float                                         MaxSqrDistanceFromSpline;                          // 0x0038(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3248[0x2C];                                    // 0x003C(0x002C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	TArray<struct FVector> GetWorldPoints() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzPolygonMarkerShape">();
	}
	static class UGzPolygonMarkerShape* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzPolygonMarkerShape>();
	}
};
static_assert(alignof(UGzPolygonMarkerShape) == 0x000008, "Wrong alignment on UGzPolygonMarkerShape");
static_assert(sizeof(UGzPolygonMarkerShape) == 0x000068, "Wrong size on UGzPolygonMarkerShape");
static_assert(offsetof(UGzPolygonMarkerShape, MaxSqrDistanceFromSpline) == 0x000038, "Member 'UGzPolygonMarkerShape::MaxSqrDistanceFromSpline' has a wrong offset!");

// Class G01.GzFailedObjective
// 0x0000 (0x0060 - 0x0060)
class UGzFailedObjective final : public UGzObjective
{
public:
	static class UGzObjective* MakeCompletedObjective(class AGzAdvancedMission* Mission);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzFailedObjective">();
	}
	static class UGzFailedObjective* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzFailedObjective>();
	}
};
static_assert(alignof(UGzFailedObjective) == 0x000008, "Wrong alignment on UGzFailedObjective");
static_assert(sizeof(UGzFailedObjective) == 0x000060, "Wrong size on UGzFailedObjective");

// Class G01.GzFallDamageExecutionCalculation
// 0x0000 (0x0040 - 0x0040)
class UGzFallDamageExecutionCalculation final : public UGzDamageExecutionCalculation
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzFallDamageExecutionCalculation">();
	}
	static class UGzFallDamageExecutionCalculation* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzFallDamageExecutionCalculation>();
	}
};
static_assert(alignof(UGzFallDamageExecutionCalculation) == 0x000008, "Wrong alignment on UGzFallDamageExecutionCalculation");
static_assert(sizeof(UGzFallDamageExecutionCalculation) == 0x000040, "Wrong size on UGzFallDamageExecutionCalculation");

// Class G01.GzFeedbackProviderSubsystem
// 0x0000 (0x0030 - 0x0030)
class UGzFeedbackProviderSubsystem final : public UGameInstanceSubsystem
{
public:
	void PlayHitResponse(class AActor* TargetActor, class AActor* Instigator, const struct FGzHitResponseData& HitResponseData);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzFeedbackProviderSubsystem">();
	}
	static class UGzFeedbackProviderSubsystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzFeedbackProviderSubsystem>();
	}
};
static_assert(alignof(UGzFeedbackProviderSubsystem) == 0x000008, "Wrong alignment on UGzFeedbackProviderSubsystem");
static_assert(sizeof(UGzFeedbackProviderSubsystem) == 0x000030, "Wrong size on UGzFeedbackProviderSubsystem");

// Class G01.GzFlowStateManager
// 0x0168 (0x0198 - 0x0030)
class UGzFlowStateManager final : public UGameInstanceSubsystem
{
public:
	TMap<EGzFlowState, TSubclassOf<class UGzFlowState>> StateClasses;                                      // 0x0030(0x0050)(UObjectWrapper, NativeAccessSpecifierPrivate)
	uint8                                         Pad_3249[0x8];                                     // 0x0080(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UGzFlowState*                           CurrentStatePtr;                                   // 0x0088(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_324A[0x108];                                   // 0x0090(0x0108)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzFlowStateManager">();
	}
	static class UGzFlowStateManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzFlowStateManager>();
	}
};
static_assert(alignof(UGzFlowStateManager) == 0x000008, "Wrong alignment on UGzFlowStateManager");
static_assert(sizeof(UGzFlowStateManager) == 0x000198, "Wrong size on UGzFlowStateManager");
static_assert(offsetof(UGzFlowStateManager, StateClasses) == 0x000030, "Member 'UGzFlowStateManager::StateClasses' has a wrong offset!");
static_assert(offsetof(UGzFlowStateManager, CurrentStatePtr) == 0x000088, "Member 'UGzFlowStateManager::CurrentStatePtr' has a wrong offset!");

// Class G01.GzJobZeroPlayerController
// 0x0098 (0x0F98 - 0x0F00)
class AGzJobZeroPlayerController final : public AGzPlayerController
{
public:
	FMulticastInlineDelegateProperty_             OnResultReceived;                                  // 0x0F00(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, Protected, NativeAccessSpecifierProtected)
	struct FGzJobZeroMatchResult                  JobZeroResult;                                     // 0x0F10(0x0018)(BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_324B[0x70];                                    // 0x0F28(0x0070)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ClientSetJobZeroResult(const struct FGzJobZeroMatchResult& Result);

	bool HasJobZeroResults() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzJobZeroPlayerController">();
	}
	static class AGzJobZeroPlayerController* GetDefaultObj()
	{
		return GetDefaultObjImpl<AGzJobZeroPlayerController>();
	}
};
static_assert(alignof(AGzJobZeroPlayerController) == 0x000008, "Wrong alignment on AGzJobZeroPlayerController");
static_assert(sizeof(AGzJobZeroPlayerController) == 0x000F98, "Wrong size on AGzJobZeroPlayerController");
static_assert(offsetof(AGzJobZeroPlayerController, OnResultReceived) == 0x000F00, "Member 'AGzJobZeroPlayerController::OnResultReceived' has a wrong offset!");
static_assert(offsetof(AGzJobZeroPlayerController, JobZeroResult) == 0x000F10, "Member 'AGzJobZeroPlayerController::JobZeroResult' has a wrong offset!");

// Class G01.GzFlowStateManagerCheatExtension
// 0x0008 (0x0030 - 0x0028)
class UGzFlowStateManagerCheatExtension final : public UGzCheatManagerExtension
{
public:
	uint8                                         Pad_324C[0x8];                                     // 0x0028(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void LoginWithPlayFab(const class FString& Login, const class FString& Password);
	void SetPlayFabId(const class FString& PlayFabId);

	void LogCurrentFlowState() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzFlowStateManagerCheatExtension">();
	}
	static class UGzFlowStateManagerCheatExtension* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzFlowStateManagerCheatExtension>();
	}
};
static_assert(alignof(UGzFlowStateManagerCheatExtension) == 0x000008, "Wrong alignment on UGzFlowStateManagerCheatExtension");
static_assert(sizeof(UGzFlowStateManagerCheatExtension) == 0x000030, "Wrong size on UGzFlowStateManagerCheatExtension");

// Class G01.GzLoadingScreenMoviesCollection
// 0x0020 (0x0050 - 0x0030)
class UGzLoadingScreenMoviesCollection final : public UDataAsset
{
public:
	struct FGuid                                  Guid;                                              // 0x0030(0x0010)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FFilePath>                      Movies;                                            // 0x0040(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzLoadingScreenMoviesCollection">();
	}
	static class UGzLoadingScreenMoviesCollection* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzLoadingScreenMoviesCollection>();
	}
};
static_assert(alignof(UGzLoadingScreenMoviesCollection) == 0x000008, "Wrong alignment on UGzLoadingScreenMoviesCollection");
static_assert(sizeof(UGzLoadingScreenMoviesCollection) == 0x000050, "Wrong size on UGzLoadingScreenMoviesCollection");
static_assert(offsetof(UGzLoadingScreenMoviesCollection, Guid) == 0x000030, "Member 'UGzLoadingScreenMoviesCollection::Guid' has a wrong offset!");
static_assert(offsetof(UGzLoadingScreenMoviesCollection, Movies) == 0x000040, "Member 'UGzLoadingScreenMoviesCollection::Movies' has a wrong offset!");

// Class G01.GzFlowStateModel
// 0x0058 (0x00C8 - 0x0070)
class UGzFlowStateModel final : public UGzCohtmlDataModel
{
public:
	uint8                                         Pad_324D[0x58];                                    // 0x0070(0x0058)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzFlowStateModel">();
	}
	static class UGzFlowStateModel* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzFlowStateModel>();
	}
};
static_assert(alignof(UGzFlowStateModel) == 0x000008, "Wrong alignment on UGzFlowStateModel");
static_assert(sizeof(UGzFlowStateModel) == 0x0000C8, "Wrong size on UGzFlowStateModel");

// Class G01.GzInWorldHitmarkConfig
// 0x0038 (0x0070 - 0x0038)
class UGzInWorldHitmarkConfig final : public UDeveloperSettings
{
public:
	TSoftClassPtr<class UClass>                   MarkerClass;                                       // 0x0038(0x0028)(Edit, Config, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Lifetime;                                          // 0x0060(0x0004)(Edit, ZeroConstructor, Config, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         PoolSize;                                          // 0x0064(0x0004)(Edit, ZeroConstructor, Config, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSystemActive;                                     // 0x0068(0x0001)(Edit, ZeroConstructor, Config, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_324E[0x7];                                     // 0x0069(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzInWorldHitmarkConfig">();
	}
	static class UGzInWorldHitmarkConfig* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzInWorldHitmarkConfig>();
	}
};
static_assert(alignof(UGzInWorldHitmarkConfig) == 0x000008, "Wrong alignment on UGzInWorldHitmarkConfig");
static_assert(sizeof(UGzInWorldHitmarkConfig) == 0x000070, "Wrong size on UGzInWorldHitmarkConfig");
static_assert(offsetof(UGzInWorldHitmarkConfig, MarkerClass) == 0x000038, "Member 'UGzInWorldHitmarkConfig::MarkerClass' has a wrong offset!");
static_assert(offsetof(UGzInWorldHitmarkConfig, Lifetime) == 0x000060, "Member 'UGzInWorldHitmarkConfig::Lifetime' has a wrong offset!");
static_assert(offsetof(UGzInWorldHitmarkConfig, PoolSize) == 0x000064, "Member 'UGzInWorldHitmarkConfig::PoolSize' has a wrong offset!");
static_assert(offsetof(UGzInWorldHitmarkConfig, bSystemActive) == 0x000068, "Member 'UGzInWorldHitmarkConfig::bSystemActive' has a wrong offset!");

// Class G01.GzFocusable
// 0x0000 (0x0028 - 0x0028)
class IGzFocusable final : public IInterface
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzFocusable">();
	}
	static class IGzFocusable* GetDefaultObj()
	{
		return GetDefaultObjImpl<IGzFocusable>();
	}
};
static_assert(alignof(IGzFocusable) == 0x000008, "Wrong alignment on IGzFocusable");
static_assert(sizeof(IGzFocusable) == 0x000028, "Wrong size on IGzFocusable");

// Class G01.GzLimbsLostStatsCollector
// 0x0008 (0x0040 - 0x0038)
class UGzLimbsLostStatsCollector final : public UGzGlobalStatsCollector
{
public:
	uint8                                         Pad_324F[0x8];                                     // 0x0038(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzLimbsLostStatsCollector">();
	}
	static class UGzLimbsLostStatsCollector* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzLimbsLostStatsCollector>();
	}
};
static_assert(alignof(UGzLimbsLostStatsCollector) == 0x000008, "Wrong alignment on UGzLimbsLostStatsCollector");
static_assert(sizeof(UGzLimbsLostStatsCollector) == 0x000040, "Wrong size on UGzLimbsLostStatsCollector");

// Class G01.GzForbiddenMarkerFilter
// 0x0010 (0x0048 - 0x0038)
class UGzForbiddenMarkerFilter : public UGzMarkerActiveStateFilter
{
public:
	TArray<TSubclassOf<class UGzMarkerWidget>>    ForbiddenMarkerClasses;                            // 0x0038(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, Protected, UObjectWrapper, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzForbiddenMarkerFilter">();
	}
	static class UGzForbiddenMarkerFilter* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzForbiddenMarkerFilter>();
	}
};
static_assert(alignof(UGzForbiddenMarkerFilter) == 0x000008, "Wrong alignment on UGzForbiddenMarkerFilter");
static_assert(sizeof(UGzForbiddenMarkerFilter) == 0x000048, "Wrong size on UGzForbiddenMarkerFilter");
static_assert(offsetof(UGzForbiddenMarkerFilter, ForbiddenMarkerClasses) == 0x000038, "Member 'UGzForbiddenMarkerFilter::ForbiddenMarkerClasses' has a wrong offset!");

// Class G01.GzSettingData
// 0x0000 (0x0028 - 0x0028)
class UGzSettingData : public UObject
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzSettingData">();
	}
	static class UGzSettingData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzSettingData>();
	}
};
static_assert(alignof(UGzSettingData) == 0x000008, "Wrong alignment on UGzSettingData");
static_assert(sizeof(UGzSettingData) == 0x000028, "Wrong size on UGzSettingData");

// Class G01.GzSettingScalarData
// 0x0030 (0x0058 - 0x0028)
class UGzSettingScalarData final : public UGzSettingData
{
public:
	EGzScalarFormat                               ScalarFormat;                                      // 0x0028(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3250[0x7];                                     // 0x0029(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	double                                        Minimum;                                           // 0x0030(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	double                                        Maximum;                                           // 0x0038(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	double                                        Step;                                              // 0x0040(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	double                                        DefaultValue;                                      // 0x0048(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UGzGameSettingScalarDataSourceBP> ScalarDataSourceClass;                             // 0x0050(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzSettingScalarData">();
	}
	static class UGzSettingScalarData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzSettingScalarData>();
	}
};
static_assert(alignof(UGzSettingScalarData) == 0x000008, "Wrong alignment on UGzSettingScalarData");
static_assert(sizeof(UGzSettingScalarData) == 0x000058, "Wrong size on UGzSettingScalarData");
static_assert(offsetof(UGzSettingScalarData, ScalarFormat) == 0x000028, "Member 'UGzSettingScalarData::ScalarFormat' has a wrong offset!");
static_assert(offsetof(UGzSettingScalarData, Minimum) == 0x000030, "Member 'UGzSettingScalarData::Minimum' has a wrong offset!");
static_assert(offsetof(UGzSettingScalarData, Maximum) == 0x000038, "Member 'UGzSettingScalarData::Maximum' has a wrong offset!");
static_assert(offsetof(UGzSettingScalarData, Step) == 0x000040, "Member 'UGzSettingScalarData::Step' has a wrong offset!");
static_assert(offsetof(UGzSettingScalarData, DefaultValue) == 0x000048, "Member 'UGzSettingScalarData::DefaultValue' has a wrong offset!");
static_assert(offsetof(UGzSettingScalarData, ScalarDataSourceClass) == 0x000050, "Member 'UGzSettingScalarData::ScalarDataSourceClass' has a wrong offset!");

// Class G01.GzUpdateFriendsData
// 0x0000 (0x0028 - 0x0028)
class UGzUpdateFriendsData final : public UGzSignalREventData
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzUpdateFriendsData">();
	}
	static class UGzUpdateFriendsData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzUpdateFriendsData>();
	}
};
static_assert(alignof(UGzUpdateFriendsData) == 0x000008, "Wrong alignment on UGzUpdateFriendsData");
static_assert(sizeof(UGzUpdateFriendsData) == 0x000028, "Wrong size on UGzUpdateFriendsData");

// Class G01.GzFriendsUpdatedHandler
// 0x0000 (0x0048 - 0x0048)
class UGzFriendsUpdatedHandler final : public UGzSignalREvent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzFriendsUpdatedHandler">();
	}
	static class UGzFriendsUpdatedHandler* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzFriendsUpdatedHandler>();
	}
};
static_assert(alignof(UGzFriendsUpdatedHandler) == 0x000008, "Wrong alignment on UGzFriendsUpdatedHandler");
static_assert(sizeof(UGzFriendsUpdatedHandler) == 0x000048, "Wrong size on UGzFriendsUpdatedHandler");

// Class G01.GzGA_WeaponAim_Turret
// 0x0000 (0x05F8 - 0x05F8)
class UGzGA_WeaponAim_Turret final : public UGzGA_WeaponAim
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzGA_WeaponAim_Turret">();
	}
	static class UGzGA_WeaponAim_Turret* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzGA_WeaponAim_Turret>();
	}
};
static_assert(alignof(UGzGA_WeaponAim_Turret) == 0x000008, "Wrong alignment on UGzGA_WeaponAim_Turret");
static_assert(sizeof(UGzGA_WeaponAim_Turret) == 0x0005F8, "Wrong size on UGzGA_WeaponAim_Turret");

// Class G01.GzZoneSelectionPolicy
// 0x0070 (0x0098 - 0x0028)
class UGzZoneSelectionPolicy : public UObject
{
public:
	float                                         OverloadStartDelay;                                // 0x0028(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         LandingZoneOverloadDelay;                          // 0x002C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         TickRate;                                          // 0x0030(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3251[0x4];                                     // 0x0034(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class AGzBattleRoyaleZone*>            Zones;                                             // 0x0038(0x0010)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	TArray<class AGzBattleRoyaleZone*>            SafeZones;                                         // 0x0048(0x0010)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_3252[0x8];                                     // 0x0058(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FGzStagedZone>                  StageOverloadingZonesData;                         // 0x0060(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	uint8                                         Pad_3253[0x28];                                    // 0x0070(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzZoneSelectionPolicy">();
	}
	static class UGzZoneSelectionPolicy* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzZoneSelectionPolicy>();
	}
};
static_assert(alignof(UGzZoneSelectionPolicy) == 0x000008, "Wrong alignment on UGzZoneSelectionPolicy");
static_assert(sizeof(UGzZoneSelectionPolicy) == 0x000098, "Wrong size on UGzZoneSelectionPolicy");
static_assert(offsetof(UGzZoneSelectionPolicy, OverloadStartDelay) == 0x000028, "Member 'UGzZoneSelectionPolicy::OverloadStartDelay' has a wrong offset!");
static_assert(offsetof(UGzZoneSelectionPolicy, LandingZoneOverloadDelay) == 0x00002C, "Member 'UGzZoneSelectionPolicy::LandingZoneOverloadDelay' has a wrong offset!");
static_assert(offsetof(UGzZoneSelectionPolicy, TickRate) == 0x000030, "Member 'UGzZoneSelectionPolicy::TickRate' has a wrong offset!");
static_assert(offsetof(UGzZoneSelectionPolicy, Zones) == 0x000038, "Member 'UGzZoneSelectionPolicy::Zones' has a wrong offset!");
static_assert(offsetof(UGzZoneSelectionPolicy, SafeZones) == 0x000048, "Member 'UGzZoneSelectionPolicy::SafeZones' has a wrong offset!");
static_assert(offsetof(UGzZoneSelectionPolicy, StageOverloadingZonesData) == 0x000060, "Member 'UGzZoneSelectionPolicy::StageOverloadingZonesData' has a wrong offset!");

// Class G01.GzFurthestZonePolicy
// 0x0000 (0x0098 - 0x0098)
class UGzFurthestZonePolicy final : public UGzZoneSelectionPolicy
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzFurthestZonePolicy">();
	}
	static class UGzFurthestZonePolicy* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzFurthestZonePolicy>();
	}
};
static_assert(alignof(UGzFurthestZonePolicy) == 0x000008, "Wrong alignment on UGzFurthestZonePolicy");
static_assert(sizeof(UGzFurthestZonePolicy) == 0x000098, "Wrong size on UGzFurthestZonePolicy");

// Class G01.GzGadgetMovementComponent
// 0x0218 (0x02C0 - 0x00A8)
class UGzGadgetMovementComponent final : public UActorComponent
{
public:
	FMulticastInlineDelegateProperty_             OnPosition;                                        // 0x00A8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnMove;                                            // 0x00B8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnReplicatedDataUpdated;                           // 0x00C8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_3254[0x8];                                     // 0x00D8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGzGadgetMoveDataInternal              MoveData;                                          // 0x00E0(0x00E0)(BlueprintVisible, BlueprintReadOnly, Net, RepNotify, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	class AActor*                                 HitActor;                                          // 0x01C0(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<ECollisionChannel>                     BlockingPresetCollisionTypes;                      // 0x01C8(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	TArray<ECollisionChannel>                     EndMoveCollisionTypes;                             // 0x01D8(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	float                                         PingPrediction;                                    // 0x01E8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         PingPredictionPerFrame;                            // 0x01EC(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         GravityZ;                                          // 0x01F0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         AirFriction;                                       // 0x01F4(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         BounceCoef;                                        // 0x01F8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         BounceMaxSpeed;                                    // 0x01FC(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         BounceMinSpeed;                                    // 0x0200(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         ImpactLocationOffset;                              // 0x0204(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UPrimitiveComponent*                    OwnerRoot;                                         // 0x0208(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FName                                   BlockingPreset;                                    // 0x0210(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FName                                   NoBlockingPreset;                                  // 0x0218(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<class FName>                           BoneNames;                                         // 0x0220(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	uint8                                         Pad_3255[0x90];                                    // 0x0230(0x0090)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void FallFromAttach();
	void Move(const struct FGzGadgetMoveData& Data);
	void OnParentDestroyed(class AActor* DestroyedActor);
	void OnParentRecieveDamage(class UGzDamageableComponent* Receiver, const struct FGzSingleHitDamage& Hit);
	void OnParentRecieveMultiDamage(class UGzDamageableComponent* Receiver, const struct FGzMultiHitDamage& Hit);
	void OnRep_MoveData();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzGadgetMovementComponent">();
	}
	static class UGzGadgetMovementComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzGadgetMovementComponent>();
	}
};
static_assert(alignof(UGzGadgetMovementComponent) == 0x000010, "Wrong alignment on UGzGadgetMovementComponent");
static_assert(sizeof(UGzGadgetMovementComponent) == 0x0002C0, "Wrong size on UGzGadgetMovementComponent");
static_assert(offsetof(UGzGadgetMovementComponent, OnPosition) == 0x0000A8, "Member 'UGzGadgetMovementComponent::OnPosition' has a wrong offset!");
static_assert(offsetof(UGzGadgetMovementComponent, OnMove) == 0x0000B8, "Member 'UGzGadgetMovementComponent::OnMove' has a wrong offset!");
static_assert(offsetof(UGzGadgetMovementComponent, OnReplicatedDataUpdated) == 0x0000C8, "Member 'UGzGadgetMovementComponent::OnReplicatedDataUpdated' has a wrong offset!");
static_assert(offsetof(UGzGadgetMovementComponent, MoveData) == 0x0000E0, "Member 'UGzGadgetMovementComponent::MoveData' has a wrong offset!");
static_assert(offsetof(UGzGadgetMovementComponent, HitActor) == 0x0001C0, "Member 'UGzGadgetMovementComponent::HitActor' has a wrong offset!");
static_assert(offsetof(UGzGadgetMovementComponent, BlockingPresetCollisionTypes) == 0x0001C8, "Member 'UGzGadgetMovementComponent::BlockingPresetCollisionTypes' has a wrong offset!");
static_assert(offsetof(UGzGadgetMovementComponent, EndMoveCollisionTypes) == 0x0001D8, "Member 'UGzGadgetMovementComponent::EndMoveCollisionTypes' has a wrong offset!");
static_assert(offsetof(UGzGadgetMovementComponent, PingPrediction) == 0x0001E8, "Member 'UGzGadgetMovementComponent::PingPrediction' has a wrong offset!");
static_assert(offsetof(UGzGadgetMovementComponent, PingPredictionPerFrame) == 0x0001EC, "Member 'UGzGadgetMovementComponent::PingPredictionPerFrame' has a wrong offset!");
static_assert(offsetof(UGzGadgetMovementComponent, GravityZ) == 0x0001F0, "Member 'UGzGadgetMovementComponent::GravityZ' has a wrong offset!");
static_assert(offsetof(UGzGadgetMovementComponent, AirFriction) == 0x0001F4, "Member 'UGzGadgetMovementComponent::AirFriction' has a wrong offset!");
static_assert(offsetof(UGzGadgetMovementComponent, BounceCoef) == 0x0001F8, "Member 'UGzGadgetMovementComponent::BounceCoef' has a wrong offset!");
static_assert(offsetof(UGzGadgetMovementComponent, BounceMaxSpeed) == 0x0001FC, "Member 'UGzGadgetMovementComponent::BounceMaxSpeed' has a wrong offset!");
static_assert(offsetof(UGzGadgetMovementComponent, BounceMinSpeed) == 0x000200, "Member 'UGzGadgetMovementComponent::BounceMinSpeed' has a wrong offset!");
static_assert(offsetof(UGzGadgetMovementComponent, ImpactLocationOffset) == 0x000204, "Member 'UGzGadgetMovementComponent::ImpactLocationOffset' has a wrong offset!");
static_assert(offsetof(UGzGadgetMovementComponent, OwnerRoot) == 0x000208, "Member 'UGzGadgetMovementComponent::OwnerRoot' has a wrong offset!");
static_assert(offsetof(UGzGadgetMovementComponent, BlockingPreset) == 0x000210, "Member 'UGzGadgetMovementComponent::BlockingPreset' has a wrong offset!");
static_assert(offsetof(UGzGadgetMovementComponent, NoBlockingPreset) == 0x000218, "Member 'UGzGadgetMovementComponent::NoBlockingPreset' has a wrong offset!");
static_assert(offsetof(UGzGadgetMovementComponent, BoneNames) == 0x000220, "Member 'UGzGadgetMovementComponent::BoneNames' has a wrong offset!");

// Class G01.GzHexExtractionStatsCollector
// 0x0008 (0x0040 - 0x0038)
class UGzHexExtractionStatsCollector final : public UGzGlobalStatsCollector
{
public:
	uint8                                         Pad_3256[0x8];                                     // 0x0038(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzHexExtractionStatsCollector">();
	}
	static class UGzHexExtractionStatsCollector* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzHexExtractionStatsCollector>();
	}
};
static_assert(alignof(UGzHexExtractionStatsCollector) == 0x000008, "Wrong alignment on UGzHexExtractionStatsCollector");
static_assert(sizeof(UGzHexExtractionStatsCollector) == 0x000040, "Wrong size on UGzHexExtractionStatsCollector");

// Class G01.GzGadgetValidAttachment
// 0x0000 (0x0028 - 0x0028)
class IGzGadgetValidAttachment final : public IInterface
{
public:
	bool CanAttachTo(class AActor* Actor) const;
	bool IsValidAttachment() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzGadgetValidAttachment">();
	}
	static class IGzGadgetValidAttachment* GetDefaultObj()
	{
		return GetDefaultObjImpl<IGzGadgetValidAttachment>();
	}
};
static_assert(alignof(IGzGadgetValidAttachment) == 0x000008, "Wrong alignment on IGzGadgetValidAttachment");
static_assert(sizeof(IGzGadgetValidAttachment) == 0x000028, "Wrong size on IGzGadgetValidAttachment");

// Class G01.GzInventoryInterface
// 0x0000 (0x0028 - 0x0028)
class IGzInventoryInterface final : public IInterface
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzInventoryInterface">();
	}
	static class IGzInventoryInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IGzInventoryInterface>();
	}
};
static_assert(alignof(IGzInventoryInterface) == 0x000008, "Wrong alignment on IGzInventoryInterface");
static_assert(sizeof(IGzInventoryInterface) == 0x000028, "Wrong size on IGzInventoryInterface");

// Class G01.GzGameAbortStage
// 0x0020 (0x0130 - 0x0110)
class UGzGameAbortStage final : public UGzGameStageBase
{
public:
	class FText                                   AbortKickReason;                                   // 0x0110(0x0010)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	float                                         AbortDelay;                                        // 0x0120(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_3258[0xC];                                     // 0x0124(0x000C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzGameAbortStage">();
	}
	static class UGzGameAbortStage* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzGameAbortStage>();
	}
};
static_assert(alignof(UGzGameAbortStage) == 0x000008, "Wrong alignment on UGzGameAbortStage");
static_assert(sizeof(UGzGameAbortStage) == 0x000130, "Wrong size on UGzGameAbortStage");
static_assert(offsetof(UGzGameAbortStage, AbortKickReason) == 0x000110, "Member 'UGzGameAbortStage::AbortKickReason' has a wrong offset!");
static_assert(offsetof(UGzGameAbortStage, AbortDelay) == 0x000120, "Member 'UGzGameAbortStage::AbortDelay' has a wrong offset!");

// Class G01.GzGameDefaultSettings
// 0x0270 (0x02A8 - 0x0038)
class UGzGameDefaultSettings final : public UDeveloperSettings
{
public:
	float                                         LimbFallbackLifetime;                              // 0x0038(0x0004)(Edit, ZeroConstructor, Config, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InitialLinearDamping;                              // 0x003C(0x0004)(Edit, ZeroConstructor, Config, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InitialAngularDamping;                             // 0x0040(0x0004)(Edit, ZeroConstructor, Config, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TargetLinearDamping;                               // 0x0044(0x0004)(Edit, ZeroConstructor, Config, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TargetAngularDamping;                              // 0x0048(0x0004)(Edit, ZeroConstructor, Config, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InventoryItemDropOffsetXAxis;                      // 0x004C(0x0004)(Edit, ZeroConstructor, Config, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InventoryItemDropMinImpulseMultiplier;             // 0x0050(0x0004)(Edit, ZeroConstructor, Config, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InventoryItemDropMaxImpulseMultiplier;             // 0x0054(0x0004)(Edit, ZeroConstructor, Config, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InventoryMinDropOffset;                            // 0x0058(0x0004)(Edit, ZeroConstructor, Config, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InventoryMaxDropOffset;                            // 0x005C(0x0004)(Edit, ZeroConstructor, Config, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InventoryDropSectorAngle;                          // 0x0060(0x0004)(Edit, ZeroConstructor, Config, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   BoneNameForDropLootOnDeath;                        // 0x0064(0x0008)(Edit, ZeroConstructor, Config, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEnableServerAbilityBuffering;                     // 0x006C(0x0001)(Edit, ZeroConstructor, Config, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3259[0x3];                                     // 0x006D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ServerAbilityBufferTimeWindow;                     // 0x0070(0x0004)(Edit, ZeroConstructor, Config, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEnableInputBuffering;                             // 0x0074(0x0001)(Edit, ZeroConstructor, Config, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_325A[0x3];                                     // 0x0075(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         InputBufferTimeWindow;                             // 0x0078(0x0004)(Edit, ZeroConstructor, Config, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_325B[0x4];                                     // 0x007C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<TSoftClassPtr<class UClass>>           AvailableVehicles;                                 // 0x0080(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, DisableEditOnInstance, UObjectWrapper, NativeAccessSpecifierPublic)
	TArray<TSoftClassPtr<class UClass>>           AvailableNPCData;                                  // 0x0090(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, DisableEditOnInstance, UObjectWrapper, NativeAccessSpecifierPublic)
	uint32                                        OnlineMatchRecoveryDataExpirationTime;             // 0x00A0(0x0004)(Edit, ZeroConstructor, Config, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_325C[0x4];                                     // 0x00A4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGzPickableClassSettings               PickableClassSettings;                             // 0x00A8(0x0078)(Edit, Config, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TSoftClassPtr<class UClass>                   PlayableAreaClass;                                 // 0x0120(0x0028)(Edit, Config, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   DefaultPlayableAreaLayer;                          // 0x0148(0x0008)(Edit, ZeroConstructor, Config, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<EPhysicalSurface>                      PenetrablePhysicalMaterials;                       // 0x0150(0x0010)(Edit, ZeroConstructor, Config, DisableEditOnInstance, NativeAccessSpecifierPublic)
	float                                         BulletGravityAcceleration;                         // 0x0160(0x0004)(Edit, ZeroConstructor, Config, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_325D[0x4];                                     // 0x0164(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftObjectPtr<class UPhysicalMaterial>       ArmorPhysicalMaterial;                             // 0x0168(0x0028)(Edit, Config, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UPhysicalMaterial>       DeadPlayerMaterial;                                // 0x0190(0x0028)(Edit, Config, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UGzDeliveryTransportSettings> DefaultDeliverySettings;                           // 0x01B8(0x0028)(Edit, Config, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UGzAbilityCacheAsset>    AbilityCache;                                      // 0x01E0(0x0028)(Edit, Config, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMap<EGzItemType, struct FGzCustomSpawnRotation> CustomSpawnRotationsMap;                           // 0x0208(0x0050)(Edit, Config, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TSoftClassPtr<class UClass>                   DynamicTagGameplayEffect;                          // 0x0258(0x0028)(Edit, Config, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2f                              CustomizationMeshMinMaxScreenSize;                 // 0x0280(0x0008)(Edit, ZeroConstructor, Config, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2f                              CustomizationMeshMinMaxTickInterval;               // 0x0288(0x0008)(Edit, ZeroConstructor, Config, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CustomizationMeshUnrenderedTickIntervalFactor;     // 0x0290(0x0004)(Edit, ZeroConstructor, Config, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CustomizationMeshUnrenderedTickInterval;           // 0x0294(0x0004)(Edit, ZeroConstructor, Config, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<TSoftClassPtr<class UClass>>           MorphLootContainerClasses;                         // 0x0298(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, DisableEditOnInstance, UObjectWrapper, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzGameDefaultSettings">();
	}
	static class UGzGameDefaultSettings* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzGameDefaultSettings>();
	}
};
static_assert(alignof(UGzGameDefaultSettings) == 0x000008, "Wrong alignment on UGzGameDefaultSettings");
static_assert(sizeof(UGzGameDefaultSettings) == 0x0002A8, "Wrong size on UGzGameDefaultSettings");
static_assert(offsetof(UGzGameDefaultSettings, LimbFallbackLifetime) == 0x000038, "Member 'UGzGameDefaultSettings::LimbFallbackLifetime' has a wrong offset!");
static_assert(offsetof(UGzGameDefaultSettings, InitialLinearDamping) == 0x00003C, "Member 'UGzGameDefaultSettings::InitialLinearDamping' has a wrong offset!");
static_assert(offsetof(UGzGameDefaultSettings, InitialAngularDamping) == 0x000040, "Member 'UGzGameDefaultSettings::InitialAngularDamping' has a wrong offset!");
static_assert(offsetof(UGzGameDefaultSettings, TargetLinearDamping) == 0x000044, "Member 'UGzGameDefaultSettings::TargetLinearDamping' has a wrong offset!");
static_assert(offsetof(UGzGameDefaultSettings, TargetAngularDamping) == 0x000048, "Member 'UGzGameDefaultSettings::TargetAngularDamping' has a wrong offset!");
static_assert(offsetof(UGzGameDefaultSettings, InventoryItemDropOffsetXAxis) == 0x00004C, "Member 'UGzGameDefaultSettings::InventoryItemDropOffsetXAxis' has a wrong offset!");
static_assert(offsetof(UGzGameDefaultSettings, InventoryItemDropMinImpulseMultiplier) == 0x000050, "Member 'UGzGameDefaultSettings::InventoryItemDropMinImpulseMultiplier' has a wrong offset!");
static_assert(offsetof(UGzGameDefaultSettings, InventoryItemDropMaxImpulseMultiplier) == 0x000054, "Member 'UGzGameDefaultSettings::InventoryItemDropMaxImpulseMultiplier' has a wrong offset!");
static_assert(offsetof(UGzGameDefaultSettings, InventoryMinDropOffset) == 0x000058, "Member 'UGzGameDefaultSettings::InventoryMinDropOffset' has a wrong offset!");
static_assert(offsetof(UGzGameDefaultSettings, InventoryMaxDropOffset) == 0x00005C, "Member 'UGzGameDefaultSettings::InventoryMaxDropOffset' has a wrong offset!");
static_assert(offsetof(UGzGameDefaultSettings, InventoryDropSectorAngle) == 0x000060, "Member 'UGzGameDefaultSettings::InventoryDropSectorAngle' has a wrong offset!");
static_assert(offsetof(UGzGameDefaultSettings, BoneNameForDropLootOnDeath) == 0x000064, "Member 'UGzGameDefaultSettings::BoneNameForDropLootOnDeath' has a wrong offset!");
static_assert(offsetof(UGzGameDefaultSettings, bEnableServerAbilityBuffering) == 0x00006C, "Member 'UGzGameDefaultSettings::bEnableServerAbilityBuffering' has a wrong offset!");
static_assert(offsetof(UGzGameDefaultSettings, ServerAbilityBufferTimeWindow) == 0x000070, "Member 'UGzGameDefaultSettings::ServerAbilityBufferTimeWindow' has a wrong offset!");
static_assert(offsetof(UGzGameDefaultSettings, bEnableInputBuffering) == 0x000074, "Member 'UGzGameDefaultSettings::bEnableInputBuffering' has a wrong offset!");
static_assert(offsetof(UGzGameDefaultSettings, InputBufferTimeWindow) == 0x000078, "Member 'UGzGameDefaultSettings::InputBufferTimeWindow' has a wrong offset!");
static_assert(offsetof(UGzGameDefaultSettings, AvailableVehicles) == 0x000080, "Member 'UGzGameDefaultSettings::AvailableVehicles' has a wrong offset!");
static_assert(offsetof(UGzGameDefaultSettings, AvailableNPCData) == 0x000090, "Member 'UGzGameDefaultSettings::AvailableNPCData' has a wrong offset!");
static_assert(offsetof(UGzGameDefaultSettings, OnlineMatchRecoveryDataExpirationTime) == 0x0000A0, "Member 'UGzGameDefaultSettings::OnlineMatchRecoveryDataExpirationTime' has a wrong offset!");
static_assert(offsetof(UGzGameDefaultSettings, PickableClassSettings) == 0x0000A8, "Member 'UGzGameDefaultSettings::PickableClassSettings' has a wrong offset!");
static_assert(offsetof(UGzGameDefaultSettings, PlayableAreaClass) == 0x000120, "Member 'UGzGameDefaultSettings::PlayableAreaClass' has a wrong offset!");
static_assert(offsetof(UGzGameDefaultSettings, DefaultPlayableAreaLayer) == 0x000148, "Member 'UGzGameDefaultSettings::DefaultPlayableAreaLayer' has a wrong offset!");
static_assert(offsetof(UGzGameDefaultSettings, PenetrablePhysicalMaterials) == 0x000150, "Member 'UGzGameDefaultSettings::PenetrablePhysicalMaterials' has a wrong offset!");
static_assert(offsetof(UGzGameDefaultSettings, BulletGravityAcceleration) == 0x000160, "Member 'UGzGameDefaultSettings::BulletGravityAcceleration' has a wrong offset!");
static_assert(offsetof(UGzGameDefaultSettings, ArmorPhysicalMaterial) == 0x000168, "Member 'UGzGameDefaultSettings::ArmorPhysicalMaterial' has a wrong offset!");
static_assert(offsetof(UGzGameDefaultSettings, DeadPlayerMaterial) == 0x000190, "Member 'UGzGameDefaultSettings::DeadPlayerMaterial' has a wrong offset!");
static_assert(offsetof(UGzGameDefaultSettings, DefaultDeliverySettings) == 0x0001B8, "Member 'UGzGameDefaultSettings::DefaultDeliverySettings' has a wrong offset!");
static_assert(offsetof(UGzGameDefaultSettings, AbilityCache) == 0x0001E0, "Member 'UGzGameDefaultSettings::AbilityCache' has a wrong offset!");
static_assert(offsetof(UGzGameDefaultSettings, CustomSpawnRotationsMap) == 0x000208, "Member 'UGzGameDefaultSettings::CustomSpawnRotationsMap' has a wrong offset!");
static_assert(offsetof(UGzGameDefaultSettings, DynamicTagGameplayEffect) == 0x000258, "Member 'UGzGameDefaultSettings::DynamicTagGameplayEffect' has a wrong offset!");
static_assert(offsetof(UGzGameDefaultSettings, CustomizationMeshMinMaxScreenSize) == 0x000280, "Member 'UGzGameDefaultSettings::CustomizationMeshMinMaxScreenSize' has a wrong offset!");
static_assert(offsetof(UGzGameDefaultSettings, CustomizationMeshMinMaxTickInterval) == 0x000288, "Member 'UGzGameDefaultSettings::CustomizationMeshMinMaxTickInterval' has a wrong offset!");
static_assert(offsetof(UGzGameDefaultSettings, CustomizationMeshUnrenderedTickIntervalFactor) == 0x000290, "Member 'UGzGameDefaultSettings::CustomizationMeshUnrenderedTickIntervalFactor' has a wrong offset!");
static_assert(offsetof(UGzGameDefaultSettings, CustomizationMeshUnrenderedTickInterval) == 0x000294, "Member 'UGzGameDefaultSettings::CustomizationMeshUnrenderedTickInterval' has a wrong offset!");
static_assert(offsetof(UGzGameDefaultSettings, MorphLootContainerClasses) == 0x000298, "Member 'UGzGameDefaultSettings::MorphLootContainerClasses' has a wrong offset!");

// Class G01.GzGamefaceMoviePlayerSettings
// 0x0078 (0x00B0 - 0x0038)
class UGzGamefaceMoviePlayerSettings final : public UDeveloperSettings
{
public:
	TMap<class FString, struct FGzGamefaceMovieData> KnownMovies;                                       // 0x0038(0x0050)(Edit, Config, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UAkAudioEvent>           MovieStopEvent;                                    // 0x0088(0x0028)(Edit, Config, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzGamefaceMoviePlayerSettings">();
	}
	static class UGzGamefaceMoviePlayerSettings* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzGamefaceMoviePlayerSettings>();
	}
};
static_assert(alignof(UGzGamefaceMoviePlayerSettings) == 0x000008, "Wrong alignment on UGzGamefaceMoviePlayerSettings");
static_assert(sizeof(UGzGamefaceMoviePlayerSettings) == 0x0000B0, "Wrong size on UGzGamefaceMoviePlayerSettings");
static_assert(offsetof(UGzGamefaceMoviePlayerSettings, KnownMovies) == 0x000038, "Member 'UGzGamefaceMoviePlayerSettings::KnownMovies' has a wrong offset!");
static_assert(offsetof(UGzGamefaceMoviePlayerSettings, MovieStopEvent) == 0x000088, "Member 'UGzGamefaceMoviePlayerSettings::MovieStopEvent' has a wrong offset!");

// Class G01.GzGamefaceSettings
// 0x02D0 (0x0308 - 0x0038)
class UGzGamefaceSettings final : public UDeveloperSettings
{
public:
	TSoftObjectPtr<class UTexture2D>              DefaultItemIcon;                                   // 0x0038(0x0028)(Edit, Config, DisableEditOnInstance, AdvancedDisplay, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMap<class FName, TSoftObjectPtr<class UAkAudioEvent>> MenuSounds;                                        // 0x0060(0x0050)(Edit, Config, DisableEditOnInstance, UObjectWrapper, NativeAccessSpecifierPublic)
	TArray<TSoftObjectPtr<class UAkAudioEvent>>   OnboardingAudios;                                  // 0x00B0(0x0010)(Edit, ZeroConstructor, Config, DisableEditOnInstance, UObjectWrapper, NativeAccessSpecifierPublic)
	TMap<class FString, TSoftObjectPtr<class UMaterial>> CustomMaterials;                                   // 0x00C0(0x0050)(Edit, Config, DisableEditOnInstance, UObjectWrapper, NativeAccessSpecifierPublic)
	TMap<EGzCohtmlUrl, class FString>             Urls;                                              // 0x0110(0x0050)(Edit, Config, DisableEditOnInstance, NativeAccessSpecifierPublic)
	EGzCohtmlUrl                                  BuildType;                                         // 0x0160(0x0004)(Edit, ZeroConstructor, Config, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_325E[0x4];                                     // 0x0164(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGzCohtmlCriticalMessageData           UnknownCriticalMessage;                            // 0x0168(0x0080)(Edit, Config, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TMap<EGzCohtmlCriticalMessageType, struct FGzCohtmlCriticalMessageData> CriticalMessages;                                  // 0x01E8(0x0050)(Edit, Config, DisableEditOnInstance, NativeAccessSpecifierPublic)
	class FString                                 LocalesJsonRootDirectory;                          // 0x0238(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMap<EGzRichPresenceType, class FText>        StatePresenceStrings;                              // 0x0248(0x0050)(Edit, Config, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TMap<EGzRichPresenceType, class FText>        XSXRichPresenceIDs;                                // 0x0298(0x0050)(Edit, Config, DisableEditOnInstance, NativeAccessSpecifierPublic)
	class FString                                 XSXRichPresenceContentStr;                         // 0x02E8(0x0010)(Edit, ZeroConstructor, Config, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 XSXRichPresenceUpdateEventStr;                     // 0x02F8(0x0010)(Edit, ZeroConstructor, Config, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzGamefaceSettings">();
	}
	static class UGzGamefaceSettings* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzGamefaceSettings>();
	}
};
static_assert(alignof(UGzGamefaceSettings) == 0x000008, "Wrong alignment on UGzGamefaceSettings");
static_assert(sizeof(UGzGamefaceSettings) == 0x000308, "Wrong size on UGzGamefaceSettings");
static_assert(offsetof(UGzGamefaceSettings, DefaultItemIcon) == 0x000038, "Member 'UGzGamefaceSettings::DefaultItemIcon' has a wrong offset!");
static_assert(offsetof(UGzGamefaceSettings, MenuSounds) == 0x000060, "Member 'UGzGamefaceSettings::MenuSounds' has a wrong offset!");
static_assert(offsetof(UGzGamefaceSettings, OnboardingAudios) == 0x0000B0, "Member 'UGzGamefaceSettings::OnboardingAudios' has a wrong offset!");
static_assert(offsetof(UGzGamefaceSettings, CustomMaterials) == 0x0000C0, "Member 'UGzGamefaceSettings::CustomMaterials' has a wrong offset!");
static_assert(offsetof(UGzGamefaceSettings, Urls) == 0x000110, "Member 'UGzGamefaceSettings::Urls' has a wrong offset!");
static_assert(offsetof(UGzGamefaceSettings, BuildType) == 0x000160, "Member 'UGzGamefaceSettings::BuildType' has a wrong offset!");
static_assert(offsetof(UGzGamefaceSettings, UnknownCriticalMessage) == 0x000168, "Member 'UGzGamefaceSettings::UnknownCriticalMessage' has a wrong offset!");
static_assert(offsetof(UGzGamefaceSettings, CriticalMessages) == 0x0001E8, "Member 'UGzGamefaceSettings::CriticalMessages' has a wrong offset!");
static_assert(offsetof(UGzGamefaceSettings, LocalesJsonRootDirectory) == 0x000238, "Member 'UGzGamefaceSettings::LocalesJsonRootDirectory' has a wrong offset!");
static_assert(offsetof(UGzGamefaceSettings, StatePresenceStrings) == 0x000248, "Member 'UGzGamefaceSettings::StatePresenceStrings' has a wrong offset!");
static_assert(offsetof(UGzGamefaceSettings, XSXRichPresenceIDs) == 0x000298, "Member 'UGzGamefaceSettings::XSXRichPresenceIDs' has a wrong offset!");
static_assert(offsetof(UGzGamefaceSettings, XSXRichPresenceContentStr) == 0x0002E8, "Member 'UGzGamefaceSettings::XSXRichPresenceContentStr' has a wrong offset!");
static_assert(offsetof(UGzGamefaceSettings, XSXRichPresenceUpdateEventStr) == 0x0002F8, "Member 'UGzGamefaceSettings::XSXRichPresenceUpdateEventStr' has a wrong offset!");

// Class G01.GzGameInstance
// 0x0040 (0x0200 - 0x01C0)
class UGzGameInstance final : public UGameInstance
{
public:
	class UGzUserSettingsManager*                 UserSettingsManager;                               // 0x01C0(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_325F[0x38];                                    // 0x01C8(0x0038)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzGameInstance">();
	}
	static class UGzGameInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzGameInstance>();
	}
};
static_assert(alignof(UGzGameInstance) == 0x000008, "Wrong alignment on UGzGameInstance");
static_assert(sizeof(UGzGameInstance) == 0x000200, "Wrong size on UGzGameInstance");
static_assert(offsetof(UGzGameInstance, UserSettingsManager) == 0x0001C0, "Member 'UGzGameInstance::UserSettingsManager' has a wrong offset!");

// Class G01.GzStatisticsSettings
// 0x0010 (0x0048 - 0x0038)
class UGzStatisticsSettings final : public UDeveloperSettings
{
public:
	TArray<TSoftObjectPtr<class UGzGameStatTemplate>> DisplayedStats;                                    // 0x0038(0x0010)(Edit, ZeroConstructor, Config, DisableEditOnInstance, UObjectWrapper, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzStatisticsSettings">();
	}
	static class UGzStatisticsSettings* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzStatisticsSettings>();
	}
};
static_assert(alignof(UGzStatisticsSettings) == 0x000008, "Wrong alignment on UGzStatisticsSettings");
static_assert(sizeof(UGzStatisticsSettings) == 0x000048, "Wrong size on UGzStatisticsSettings");
static_assert(offsetof(UGzStatisticsSettings, DisplayedStats) == 0x000038, "Member 'UGzStatisticsSettings::DisplayedStats' has a wrong offset!");

// Class G01.GzGameMessageSubsystem
// 0x00B0 (0x0350 - 0x02A0)
class AGzGameMessageSubsystem final : public AGzGameModeSubsystem
{
public:
	FMulticastInlineDelegateProperty_             MessageReceivedGlobal;                             // 0x02A0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_3260[0xA0];                                    // 0x02B0(0x00A0)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static void BP_PostMessage(class UGzGameMessage* Message);
	static void BP_PostMessageToPlayers(class UGzGameMessage* Message, const TArray<class AGzPlayerController*>& Receivers);
	static void BP_PostMessageToTeam(class UGzGameMessage* Message, class AGzTeam* Team);
	static class AGzGameMessageSubsystem* GetInstance(class UObject* WorldContextObject);

	void DistributeMessage(const struct FGzMessageNetData& MessageData);
	void SubscribeToMessage(TSubclassOf<class UGzGameMessage> MessageClass, TDelegate<void(class UGzGameMessage* Message)> BPCallback);
	void UnsubscribeToMessage(TSubclassOf<class UGzGameMessage> MessageClass, class UObject* DelegateObject);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzGameMessageSubsystem">();
	}
	static class AGzGameMessageSubsystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<AGzGameMessageSubsystem>();
	}
};
static_assert(alignof(AGzGameMessageSubsystem) == 0x000008, "Wrong alignment on AGzGameMessageSubsystem");
static_assert(sizeof(AGzGameMessageSubsystem) == 0x000350, "Wrong size on AGzGameMessageSubsystem");
static_assert(offsetof(AGzGameMessageSubsystem, MessageReceivedGlobal) == 0x0002A0, "Member 'AGzGameMessageSubsystem::MessageReceivedGlobal' has a wrong offset!");

// Class G01.GzGameNotificationBody
// 0x00A8 (0x0388 - 0x02E0)
class UGzGameNotificationBody : public UUserWidget
{
public:
	struct FGzGameNotificationSpec                NotificationSpec;                                  // 0x02E0(0x00A0)(Protected, NativeAccessSpecifierProtected)
	class UGzNotificationDisplayData*             DisplayData;                                       // 0x0380(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void SetNotificationData(const struct FGzGameNotificationSpec& InNotificationSpec, class UGzNotificationDisplayData* InDisplayData);
	bool UpdateNotificationData();

	class UGzNotificationDisplayData* GetDisplayData() const;
	const struct FGzGameNotificationSpec GetNotificationSpec() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzGameNotificationBody">();
	}
	static class UGzGameNotificationBody* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzGameNotificationBody>();
	}
};
static_assert(alignof(UGzGameNotificationBody) == 0x000008, "Wrong alignment on UGzGameNotificationBody");
static_assert(sizeof(UGzGameNotificationBody) == 0x000388, "Wrong size on UGzGameNotificationBody");
static_assert(offsetof(UGzGameNotificationBody, NotificationSpec) == 0x0002E0, "Member 'UGzGameNotificationBody::NotificationSpec' has a wrong offset!");
static_assert(offsetof(UGzGameNotificationBody, DisplayData) == 0x000380, "Member 'UGzGameNotificationBody::DisplayData' has a wrong offset!");

// Class G01.GzGA_MicroMissiles
// 0x0080 (0x0778 - 0x06F8)
class UGzGA_MicroMissiles : public UGzGA_Charge_LimbAbility
{
public:
	TSoftClassPtr<class UClass>                   MicroMissileClass;                                 // 0x06F8(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3261[0x48];                                    // 0x0720(0x0048)(Fixing Size After Last Property [ Dumper-7 ])
	class UGzMicroMissilesComponent*              MicroMissileComponent;                             // 0x0768(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UGzBodyPartAbilityData_MicroMissileArm* MicroMissileData;                                  // 0x0770(0x0008)(ZeroConstructor, Transient, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void OnMissileShootingFinished(const int32 MissileIndex);
	void ShootMissile(const int32 MissileIndex);
	void StartShootingMissiles(const struct FGameplayAbilityTargetDataHandle& TargetDataHandle);
	void WaitNetSyncPostFiring();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzGA_MicroMissiles">();
	}
	static class UGzGA_MicroMissiles* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzGA_MicroMissiles>();
	}
};
static_assert(alignof(UGzGA_MicroMissiles) == 0x000008, "Wrong alignment on UGzGA_MicroMissiles");
static_assert(sizeof(UGzGA_MicroMissiles) == 0x000778, "Wrong size on UGzGA_MicroMissiles");
static_assert(offsetof(UGzGA_MicroMissiles, MicroMissileClass) == 0x0006F8, "Member 'UGzGA_MicroMissiles::MicroMissileClass' has a wrong offset!");
static_assert(offsetof(UGzGA_MicroMissiles, MicroMissileComponent) == 0x000768, "Member 'UGzGA_MicroMissiles::MicroMissileComponent' has a wrong offset!");
static_assert(offsetof(UGzGA_MicroMissiles, MicroMissileData) == 0x000770, "Member 'UGzGA_MicroMissiles::MicroMissileData' has a wrong offset!");

// Class G01.GzNotificationConditionBase
// 0x0000 (0x0028 - 0x0028)
class UGzNotificationConditionBase : public UObject
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzNotificationConditionBase">();
	}
	static class UGzNotificationConditionBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzNotificationConditionBase>();
	}
};
static_assert(alignof(UGzNotificationConditionBase) == 0x000008, "Wrong alignment on UGzNotificationConditionBase");
static_assert(sizeof(UGzNotificationConditionBase) == 0x000028, "Wrong size on UGzNotificationConditionBase");

// Class G01.GzSettingsMenuWidget
// 0x0050 (0x04F0 - 0x04A0)
class UGzSettingsMenuWidget : public UGameSettingScreen
{
public:
	class UInputAction*                           ApplySettingsInputAction;                          // 0x04A0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UInputAction*                           ResetToDefaultInputAction;                         // 0x04A8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCommonTabListWidgetBase*               SettingsTabs;                                      // 0x04B0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UGzCommonButton>            TabButtonClass;                                    // 0x04B8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSoftClassPtr<class UClass>                   ConfirmationWidgetClass;                           // 0x04C0(0x0028)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_3262[0x8];                                     // 0x04E8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AddMappingUpdateNotification(const TArray<struct FGzInputActionMappingChange>& InputActionMappingChanges);
	void HandleApplySettings();
	void InitResetConfirmation(class UGzNavigationWidget* NavigationWidget);
	void OnResetToDefaultApplied();
	void OnResetToDefaultCanceled();
	void OnTabSelected(class FName TabId);
	void ResetToDefault();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzSettingsMenuWidget">();
	}
	static class UGzSettingsMenuWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzSettingsMenuWidget>();
	}
};
static_assert(alignof(UGzSettingsMenuWidget) == 0x000008, "Wrong alignment on UGzSettingsMenuWidget");
static_assert(sizeof(UGzSettingsMenuWidget) == 0x0004F0, "Wrong size on UGzSettingsMenuWidget");
static_assert(offsetof(UGzSettingsMenuWidget, ApplySettingsInputAction) == 0x0004A0, "Member 'UGzSettingsMenuWidget::ApplySettingsInputAction' has a wrong offset!");
static_assert(offsetof(UGzSettingsMenuWidget, ResetToDefaultInputAction) == 0x0004A8, "Member 'UGzSettingsMenuWidget::ResetToDefaultInputAction' has a wrong offset!");
static_assert(offsetof(UGzSettingsMenuWidget, SettingsTabs) == 0x0004B0, "Member 'UGzSettingsMenuWidget::SettingsTabs' has a wrong offset!");
static_assert(offsetof(UGzSettingsMenuWidget, TabButtonClass) == 0x0004B8, "Member 'UGzSettingsMenuWidget::TabButtonClass' has a wrong offset!");
static_assert(offsetof(UGzSettingsMenuWidget, ConfirmationWidgetClass) == 0x0004C0, "Member 'UGzSettingsMenuWidget::ConfirmationWidgetClass' has a wrong offset!");

// Class G01.GzGameNotificationConditionBase
// 0x00B0 (0x00D8 - 0x0028)
class UGzGameNotificationConditionBase : public UGzNotificationConditionBase
{
public:
	uint8                                         Pad_3263[0x8];                                     // 0x0028(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGzGameNotificationSpec                NotificationSpec;                                  // 0x0030(0x00A0)(NativeAccessSpecifierPrivate)
	uint8                                         Pad_3264[0x8];                                     // 0x00D0(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzGameNotificationConditionBase">();
	}
	static class UGzGameNotificationConditionBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzGameNotificationConditionBase>();
	}
};
static_assert(alignof(UGzGameNotificationConditionBase) == 0x000008, "Wrong alignment on UGzGameNotificationConditionBase");
static_assert(sizeof(UGzGameNotificationConditionBase) == 0x0000D8, "Wrong size on UGzGameNotificationConditionBase");
static_assert(offsetof(UGzGameNotificationConditionBase, NotificationSpec) == 0x000030, "Member 'UGzGameNotificationConditionBase::NotificationSpec' has a wrong offset!");

// Class G01.GzLootArchetypeTableData
// 0x0010 (0x0048 - 0x0038)
class UGzLootArchetypeTableData final : public UGzRollTableData
{
public:
	TArray<struct FGzLootArchetypeTableRow>       Table;                                             // 0x0038(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)

public:
	class UGzLootArchetypeData* RollItemArchetype(const class UGzLootModifierTableData* ModifiersTable) const;
	class UGzLootArchetypeData* RollItemArchetypeWithModArray(const TArray<struct FGzLootModifier>& ModifiersTable) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzLootArchetypeTableData">();
	}
	static class UGzLootArchetypeTableData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzLootArchetypeTableData>();
	}
};
static_assert(alignof(UGzLootArchetypeTableData) == 0x000008, "Wrong alignment on UGzLootArchetypeTableData");
static_assert(sizeof(UGzLootArchetypeTableData) == 0x000048, "Wrong size on UGzLootArchetypeTableData");
static_assert(offsetof(UGzLootArchetypeTableData, Table) == 0x000038, "Member 'UGzLootArchetypeTableData::Table' has a wrong offset!");

// Class G01.GzGameNotificationConditionAudioFinished
// 0x0028 (0x0100 - 0x00D8)
class UGzGameNotificationConditionAudioFinished final : public UGzGameNotificationConditionBase
{
public:
	uint8                                         Pad_3265[0x28];                                    // 0x00D8(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnPostedVoiceLineEnded();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzGameNotificationConditionAudioFinished">();
	}
	static class UGzGameNotificationConditionAudioFinished* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzGameNotificationConditionAudioFinished>();
	}
};
static_assert(alignof(UGzGameNotificationConditionAudioFinished) == 0x000008, "Wrong alignment on UGzGameNotificationConditionAudioFinished");
static_assert(sizeof(UGzGameNotificationConditionAudioFinished) == 0x000100, "Wrong size on UGzGameNotificationConditionAudioFinished");

// Class G01.GzLocationHandlingComponent
// 0x0000 (0x00A0 - 0x00A0)
class UGzLocationHandlingComponent final : public UGzServiceComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzLocationHandlingComponent">();
	}
	static class UGzLocationHandlingComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzLocationHandlingComponent>();
	}
};
static_assert(alignof(UGzLocationHandlingComponent) == 0x000008, "Wrong alignment on UGzLocationHandlingComponent");
static_assert(sizeof(UGzLocationHandlingComponent) == 0x0000A0, "Wrong size on UGzLocationHandlingComponent");

// Class G01.GzGameNotificationConditionDisplayTimeFinished
// 0x0000 (0x00D8 - 0x00D8)
class UGzGameNotificationConditionDisplayTimeFinished final : public UGzGameNotificationConditionBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzGameNotificationConditionDisplayTimeFinished">();
	}
	static class UGzGameNotificationConditionDisplayTimeFinished* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzGameNotificationConditionDisplayTimeFinished>();
	}
};
static_assert(alignof(UGzGameNotificationConditionDisplayTimeFinished) == 0x000008, "Wrong alignment on UGzGameNotificationConditionDisplayTimeFinished");
static_assert(sizeof(UGzGameNotificationConditionDisplayTimeFinished) == 0x0000D8, "Wrong size on UGzGameNotificationConditionDisplayTimeFinished");

// Class G01.GzNotificationContainerBase
// 0x0090 (0x0370 - 0x02E0)
class UGzNotificationContainerBase : public UUserWidget
{
public:
	TMap<int32, struct FGzNotificationQueueSlot>  Queue;                                             // 0x02E0(0x0050)(ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_3266[0x8];                                     // 0x0330(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bEnableQueuePrio;                                  // 0x0338(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3267[0x3];                                     // 0x0339(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         QueueSizeMax;                                      // 0x033C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         NotificationSkipTime;                              // 0x0340(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         TimeUpdateQueue;                                   // 0x0344(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDataTable*                             NotificationDataTable;                             // 0x0348(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<TSubclassOf<class UGzNotificationConditionBase>> NotificationConditionClass;                        // 0x0350(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	class UGzNotificationSettingsAsset*           NotificationSettings;                              // 0x0360(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UPanelWidget*                           SlotContainer;                                     // 0x0368(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	struct FGzNotificationSettings GetNotificationSettings();
	void UpdateAllQueueSlots();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzNotificationContainerBase">();
	}
	static class UGzNotificationContainerBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzNotificationContainerBase>();
	}
};
static_assert(alignof(UGzNotificationContainerBase) == 0x000008, "Wrong alignment on UGzNotificationContainerBase");
static_assert(sizeof(UGzNotificationContainerBase) == 0x000370, "Wrong size on UGzNotificationContainerBase");
static_assert(offsetof(UGzNotificationContainerBase, Queue) == 0x0002E0, "Member 'UGzNotificationContainerBase::Queue' has a wrong offset!");
static_assert(offsetof(UGzNotificationContainerBase, bEnableQueuePrio) == 0x000338, "Member 'UGzNotificationContainerBase::bEnableQueuePrio' has a wrong offset!");
static_assert(offsetof(UGzNotificationContainerBase, QueueSizeMax) == 0x00033C, "Member 'UGzNotificationContainerBase::QueueSizeMax' has a wrong offset!");
static_assert(offsetof(UGzNotificationContainerBase, NotificationSkipTime) == 0x000340, "Member 'UGzNotificationContainerBase::NotificationSkipTime' has a wrong offset!");
static_assert(offsetof(UGzNotificationContainerBase, TimeUpdateQueue) == 0x000344, "Member 'UGzNotificationContainerBase::TimeUpdateQueue' has a wrong offset!");
static_assert(offsetof(UGzNotificationContainerBase, NotificationDataTable) == 0x000348, "Member 'UGzNotificationContainerBase::NotificationDataTable' has a wrong offset!");
static_assert(offsetof(UGzNotificationContainerBase, NotificationConditionClass) == 0x000350, "Member 'UGzNotificationContainerBase::NotificationConditionClass' has a wrong offset!");
static_assert(offsetof(UGzNotificationContainerBase, NotificationSettings) == 0x000360, "Member 'UGzNotificationContainerBase::NotificationSettings' has a wrong offset!");
static_assert(offsetof(UGzNotificationContainerBase, SlotContainer) == 0x000368, "Member 'UGzNotificationContainerBase::SlotContainer' has a wrong offset!");

// Class G01.GzGameNotificationContainer
// 0x0008 (0x0378 - 0x0370)
class UGzGameNotificationContainer : public UGzNotificationContainerBase
{
public:
	TSubclassOf<class UGzGameNotificationSlot>    GameNotificationSlotClass;                         // 0x0370(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	bool CanCreateNotification(const class FName InNotificationID);
	bool CreateNotifiction(const class FName InNotificationID, class UGzGameNotificationDisplayData* NotificationData);
	class UGzGameNotificationDisplayData* CreateNotifictionDisplayData(const class FName InNotificationID, const TSubclassOf<class UGzGameNotificationDisplayData> GameNotificationClass, const struct FGzGameNotificationSpec& CustomeDisplaySpec);
	bool ForceClearCurrentNotification(const class FName InNotificationID);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzGameNotificationContainer">();
	}
	static class UGzGameNotificationContainer* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzGameNotificationContainer>();
	}
};
static_assert(alignof(UGzGameNotificationContainer) == 0x000008, "Wrong alignment on UGzGameNotificationContainer");
static_assert(sizeof(UGzGameNotificationContainer) == 0x000378, "Wrong size on UGzGameNotificationContainer");
static_assert(offsetof(UGzGameNotificationContainer, GameNotificationSlotClass) == 0x000370, "Member 'UGzGameNotificationContainer::GameNotificationSlotClass' has a wrong offset!");

// Class G01.GzNotificationDisplayData
// 0x0000 (0x0028 - 0x0028)
class UGzNotificationDisplayData : public UObject
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzNotificationDisplayData">();
	}
	static class UGzNotificationDisplayData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzNotificationDisplayData>();
	}
};
static_assert(alignof(UGzNotificationDisplayData) == 0x000008, "Wrong alignment on UGzNotificationDisplayData");
static_assert(sizeof(UGzNotificationDisplayData) == 0x000028, "Wrong size on UGzNotificationDisplayData");

// Class G01.GzGameNotificationDisplayData
// 0x00C0 (0x00E8 - 0x0028)
class UGzGameNotificationDisplayData : public UGzNotificationDisplayData
{
public:
	uint8                                         Pad_326B[0xC0];                                    // 0x0028(0x00C0)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetBodyIcon(class UTexture2D* Value);
	void SetBodyIconColor(const struct FLinearColor& Color);
	void SetDefaultHeaderText(const class FText& InText);
	void SetDisplayShowTime(float Value);
	void SetRemainingTime(float Value);
	void SetVoiceLineTag(const struct FGameplayTag& VoiceLineTag);

	class FText GetDefaultHeaderText() const;
	const struct FGzGameNotificationSpec GetNotificationSpec() const;
	bool IsEnableDefaultHeaderText() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzGameNotificationDisplayData">();
	}
	static class UGzGameNotificationDisplayData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzGameNotificationDisplayData>();
	}
};
static_assert(alignof(UGzGameNotificationDisplayData) == 0x000008, "Wrong alignment on UGzGameNotificationDisplayData");
static_assert(sizeof(UGzGameNotificationDisplayData) == 0x0000E8, "Wrong size on UGzGameNotificationDisplayData");

// Class G01.GzSelectObjective
// 0x0020 (0x0080 - 0x0060)
class UGzSelectObjective final : public UGzObjective
{
public:
	class UGzObjective*                           IfObjective;                                       // 0x0060(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UGzObjective*                           ThenObjective;                                     // 0x0068(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UGzObjective*                           ElseObjective;                                     // 0x0070(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UGzObjective*                           TrackedObjective;                                  // 0x0078(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UGzObjective* MakeSelectObjective(class AGzAdvancedMission* Mission, class UGzObjective* If, class UGzObjective* Success, class UGzObjective* Fail);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzSelectObjective">();
	}
	static class UGzSelectObjective* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzSelectObjective>();
	}
};
static_assert(alignof(UGzSelectObjective) == 0x000008, "Wrong alignment on UGzSelectObjective");
static_assert(sizeof(UGzSelectObjective) == 0x000080, "Wrong size on UGzSelectObjective");
static_assert(offsetof(UGzSelectObjective, IfObjective) == 0x000060, "Member 'UGzSelectObjective::IfObjective' has a wrong offset!");
static_assert(offsetof(UGzSelectObjective, ThenObjective) == 0x000068, "Member 'UGzSelectObjective::ThenObjective' has a wrong offset!");
static_assert(offsetof(UGzSelectObjective, ElseObjective) == 0x000070, "Member 'UGzSelectObjective::ElseObjective' has a wrong offset!");
static_assert(offsetof(UGzSelectObjective, TrackedObjective) == 0x000078, "Member 'UGzSelectObjective::TrackedObjective' has a wrong offset!");

// Class G01.GzGameNotificationDisplayDataMission
// 0x0008 (0x00F0 - 0x00E8)
class UGzGameNotificationDisplayDataMission : public UGzGameNotificationDisplayData
{
public:
	class UGzMissionData*                         MissionData;                                       // 0x00E8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	void SetMissionData(class UGzMissionData* InMissionData);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzGameNotificationDisplayDataMission">();
	}
	static class UGzGameNotificationDisplayDataMission* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzGameNotificationDisplayDataMission>();
	}
};
static_assert(alignof(UGzGameNotificationDisplayDataMission) == 0x000008, "Wrong alignment on UGzGameNotificationDisplayDataMission");
static_assert(sizeof(UGzGameNotificationDisplayDataMission) == 0x0000F0, "Wrong size on UGzGameNotificationDisplayDataMission");
static_assert(offsetof(UGzGameNotificationDisplayDataMission, MissionData) == 0x0000E8, "Member 'UGzGameNotificationDisplayDataMission::MissionData' has a wrong offset!");

// Class G01.GzProgressLogUISubsystem
// 0x0048 (0x0078 - 0x0030)
class UGzProgressLogUISubsystem final : public UWorldSubsystem
{
public:
	uint8                                         Pad_326C[0x48];                                    // 0x0030(0x0048)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void CancelProgress(int32 Handle) const;
	void SetCurrentProgress(int32 Handle, float NewDuration) const;
	int32 StartProgress(const TSubclassOf<class UGzProgressLogEntryWidget>& ProgressWidgetClass, float Duration) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzProgressLogUISubsystem">();
	}
	static class UGzProgressLogUISubsystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzProgressLogUISubsystem>();
	}
};
static_assert(alignof(UGzProgressLogUISubsystem) == 0x000008, "Wrong alignment on UGzProgressLogUISubsystem");
static_assert(sizeof(UGzProgressLogUISubsystem) == 0x000078, "Wrong size on UGzProgressLogUISubsystem");

// Class G01.GzGameNotificationDisplayDataPlayer
// 0x0028 (0x0118 - 0x00F0)
class UGzGameNotificationDisplayDataPlayer final : public UGzGameNotificationDisplayDataMission
{
public:
	class FText                                   PlayerName;                                        // 0x00F0(0x0010)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	int32                                         PlayerIndexInTeam;                                 // 0x0100(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_326D[0x4];                                     // 0x0104(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   PlayerClanTag;                                     // 0x0108(0x0010)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)

public:
	void SetDisplayDataInfo(const class FText& InPlayerName, const int32 InPlayerIndexInTeam, const class FText& InPlayerClanTag);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzGameNotificationDisplayDataPlayer">();
	}
	static class UGzGameNotificationDisplayDataPlayer* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzGameNotificationDisplayDataPlayer>();
	}
};
static_assert(alignof(UGzGameNotificationDisplayDataPlayer) == 0x000008, "Wrong alignment on UGzGameNotificationDisplayDataPlayer");
static_assert(sizeof(UGzGameNotificationDisplayDataPlayer) == 0x000118, "Wrong size on UGzGameNotificationDisplayDataPlayer");
static_assert(offsetof(UGzGameNotificationDisplayDataPlayer, PlayerName) == 0x0000F0, "Member 'UGzGameNotificationDisplayDataPlayer::PlayerName' has a wrong offset!");
static_assert(offsetof(UGzGameNotificationDisplayDataPlayer, PlayerIndexInTeam) == 0x000100, "Member 'UGzGameNotificationDisplayDataPlayer::PlayerIndexInTeam' has a wrong offset!");
static_assert(offsetof(UGzGameNotificationDisplayDataPlayer, PlayerClanTag) == 0x000108, "Member 'UGzGameNotificationDisplayDataPlayer::PlayerClanTag' has a wrong offset!");

// Class G01.GzGameNotificationHeader
// 0x0028 (0x0308 - 0x02E0)
class UGzGameNotificationHeader : public UUserWidget
{
public:
	struct FGzNotificationQueue                   Notification;                                      // 0x02E0(0x0028)(NativeAccessSpecifierPrivate)

public:
	class UGzGameNotificationDisplayData* GetDisplayData();
	class UGzTextBlock* GetNotificationText();
	void SetHeaderText(const class FText& InText);
	bool UpdateHeaderNotification(const class UGzGameNotificationDisplayData* InNotificationData);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzGameNotificationHeader">();
	}
	static class UGzGameNotificationHeader* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzGameNotificationHeader>();
	}
};
static_assert(alignof(UGzGameNotificationHeader) == 0x000008, "Wrong alignment on UGzGameNotificationHeader");
static_assert(sizeof(UGzGameNotificationHeader) == 0x000308, "Wrong size on UGzGameNotificationHeader");
static_assert(offsetof(UGzGameNotificationHeader, Notification) == 0x0002E0, "Member 'UGzGameNotificationHeader::Notification' has a wrong offset!");

// Class G01.GzNotificationSlotBase
// 0x0030 (0x0310 - 0x02E0)
class UGzNotificationSlotBase : public UUserWidget
{
public:
	uint8                                         Pad_3270[0x30];                                    // 0x02E0(0x0030)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	struct FGzGameNotificationSpec GetNotificationSpec();
	void PlayAnimationById(const class FName& AnimationID);
	void SetActivateAnimation(const bool bActivated);
	void UpdateNotification(const struct FGzNotificationQueue& Notification);

	const struct FGzNotificationQueue GetNotificationData() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzNotificationSlotBase">();
	}
	static class UGzNotificationSlotBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzNotificationSlotBase>();
	}
};
static_assert(alignof(UGzNotificationSlotBase) == 0x000008, "Wrong alignment on UGzNotificationSlotBase");
static_assert(sizeof(UGzNotificationSlotBase) == 0x000310, "Wrong size on UGzNotificationSlotBase");

// Class G01.GzGameNotificationSlot
// 0x0110 (0x0420 - 0x0310)
class UGzGameNotificationSlot : public UGzNotificationSlotBase
{
public:
	TMap<EGzGameNotificationBodyType, TSubclassOf<class UGzGameNotificationBody>> BodyTypeClass;                                     // 0x0310(0x0050)(Edit, DisableEditOnInstance, Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	TMap<EGzNotificationTimerType, TSubclassOf<class UGzGameNotificationBody>> RemainingTypeClass;                                // 0x0360(0x0050)(Edit, DisableEditOnInstance, Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	TSubclassOf<class UGzGameNotificationHeader>  DefaultHeaderClass;                                // 0x03B0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TMap<EGzNotificationTextType, TSubclassOf<class UGzGameNotificationHeader>> SpecialHeaderTypeClass;                            // 0x03B8(0x0050)(Edit, DisableEditOnInstance, Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	class UPanelWidget*                           HeaderContainer;                                   // 0x0408(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UPanelWidget*                           RemainingContainer;                                // 0x0410(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UPanelWidget*                           BodyContainer;                                     // 0x0418(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzGameNotificationSlot">();
	}
	static class UGzGameNotificationSlot* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzGameNotificationSlot>();
	}
};
static_assert(alignof(UGzGameNotificationSlot) == 0x000008, "Wrong alignment on UGzGameNotificationSlot");
static_assert(sizeof(UGzGameNotificationSlot) == 0x000420, "Wrong size on UGzGameNotificationSlot");
static_assert(offsetof(UGzGameNotificationSlot, BodyTypeClass) == 0x000310, "Member 'UGzGameNotificationSlot::BodyTypeClass' has a wrong offset!");
static_assert(offsetof(UGzGameNotificationSlot, RemainingTypeClass) == 0x000360, "Member 'UGzGameNotificationSlot::RemainingTypeClass' has a wrong offset!");
static_assert(offsetof(UGzGameNotificationSlot, DefaultHeaderClass) == 0x0003B0, "Member 'UGzGameNotificationSlot::DefaultHeaderClass' has a wrong offset!");
static_assert(offsetof(UGzGameNotificationSlot, SpecialHeaderTypeClass) == 0x0003B8, "Member 'UGzGameNotificationSlot::SpecialHeaderTypeClass' has a wrong offset!");
static_assert(offsetof(UGzGameNotificationSlot, HeaderContainer) == 0x000408, "Member 'UGzGameNotificationSlot::HeaderContainer' has a wrong offset!");
static_assert(offsetof(UGzGameNotificationSlot, RemainingContainer) == 0x000410, "Member 'UGzGameNotificationSlot::RemainingContainer' has a wrong offset!");
static_assert(offsetof(UGzGameNotificationSlot, BodyContainer) == 0x000418, "Member 'UGzGameNotificationSlot::BodyContainer' has a wrong offset!");

// Class G01.GzHexExtractionHackedMessage
// 0x0000 (0x0048 - 0x0048)
class UGzHexExtractionHackedMessage final : public UGzHexExtractionHackBaseMessage
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzHexExtractionHackedMessage">();
	}
	static class UGzHexExtractionHackedMessage* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzHexExtractionHackedMessage>();
	}
};
static_assert(alignof(UGzHexExtractionHackedMessage) == 0x000008, "Wrong alignment on UGzHexExtractionHackedMessage");
static_assert(sizeof(UGzHexExtractionHackedMessage) == 0x000048, "Wrong size on UGzHexExtractionHackedMessage");

// Class G01.GzGameNotificationSubsystem
// 0x00B0 (0x00E0 - 0x0030)
class UGzGameNotificationSubsystem final : public UWorldSubsystem
{
public:
	FMulticastInlineDelegateProperty_             OnShowGameNotification;                            // 0x0030(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             EventNotificationStageDelegate;                    // 0x0040(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnHideStageDelegate;                               // 0x0050(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnShowStageDelegate;                               // 0x0060(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnConditionFinishedStageDelegate;                  // 0x0070(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnShowDebugGameNotification;                       // 0x0080(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMap<class FName, struct FGzEventNotificationData> EventNotificationDatas;                            // 0x0090(0x0050)(Protected, NativeAccessSpecifierProtected)

public:
	void EventNotificationStage(const class FName& NotificationID, EGzNotificationStageType StageType, const bool bCustomData, const struct FGzEventNotificationData& NotificationData);
	void RequestGameNotification(const class FName NotificationID);
	void ShowDebugGameNotification(const class FName& TestNotificationID);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzGameNotificationSubsystem">();
	}
	static class UGzGameNotificationSubsystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzGameNotificationSubsystem>();
	}
};
static_assert(alignof(UGzGameNotificationSubsystem) == 0x000008, "Wrong alignment on UGzGameNotificationSubsystem");
static_assert(sizeof(UGzGameNotificationSubsystem) == 0x0000E0, "Wrong size on UGzGameNotificationSubsystem");
static_assert(offsetof(UGzGameNotificationSubsystem, OnShowGameNotification) == 0x000030, "Member 'UGzGameNotificationSubsystem::OnShowGameNotification' has a wrong offset!");
static_assert(offsetof(UGzGameNotificationSubsystem, EventNotificationStageDelegate) == 0x000040, "Member 'UGzGameNotificationSubsystem::EventNotificationStageDelegate' has a wrong offset!");
static_assert(offsetof(UGzGameNotificationSubsystem, OnHideStageDelegate) == 0x000050, "Member 'UGzGameNotificationSubsystem::OnHideStageDelegate' has a wrong offset!");
static_assert(offsetof(UGzGameNotificationSubsystem, OnShowStageDelegate) == 0x000060, "Member 'UGzGameNotificationSubsystem::OnShowStageDelegate' has a wrong offset!");
static_assert(offsetof(UGzGameNotificationSubsystem, OnConditionFinishedStageDelegate) == 0x000070, "Member 'UGzGameNotificationSubsystem::OnConditionFinishedStageDelegate' has a wrong offset!");
static_assert(offsetof(UGzGameNotificationSubsystem, OnShowDebugGameNotification) == 0x000080, "Member 'UGzGameNotificationSubsystem::OnShowDebugGameNotification' has a wrong offset!");
static_assert(offsetof(UGzGameNotificationSubsystem, EventNotificationDatas) == 0x000090, "Member 'UGzGameNotificationSubsystem::EventNotificationDatas' has a wrong offset!");

// Class G01.GzInventoryFullCatalogAccessComponent
// 0x0008 (0x00A8 - 0x00A0)
class UGzInventoryFullCatalogAccessComponent final : public UGzServiceComponent
{
public:
	uint8                                         Pad_3272[0x8];                                     // 0x00A0(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzInventoryFullCatalogAccessComponent">();
	}
	static class UGzInventoryFullCatalogAccessComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzInventoryFullCatalogAccessComponent>();
	}
};
static_assert(alignof(UGzInventoryFullCatalogAccessComponent) == 0x000008, "Wrong alignment on UGzInventoryFullCatalogAccessComponent");
static_assert(sizeof(UGzInventoryFullCatalogAccessComponent) == 0x0000A8, "Wrong size on UGzInventoryFullCatalogAccessComponent");

// Class G01.GzGamepadFeedbackController
// 0x00C0 (0x0168 - 0x00A8)
class UGzGamepadFeedbackController final : public UControllerComponent
{
public:
	TMap<struct FGameplayTag, struct FGzGamepadFeedbackSpec> FeedbackSpecs;                                     // 0x00A8(0x0050)(Edit, Protected, NativeAccessSpecifierProtected)
	TMap<EGzWeaponMode, struct FGzGamepadFeedbackSpec> DefaultShootGamepadFeedback;                       // 0x00F8(0x0050)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	class APawn*                                  ControlledPawn;                                    // 0x0148(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<struct FGzActiveGamepadFeedbacks>      ActiveFeedbacks;                                   // 0x0150(0x0010)(ZeroConstructor, Transient, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	uint8                                         Pad_3273[0x8];                                     // 0x0160(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AddActiveFeedback(const struct FGzGamepadFeedbackSpec& FoundSpec);
	void OnEquippedWeaponChanged(const struct FGzInvPocketId& InvPocketId, const class AGzWeaponActor* WeaponActor, bool bEquipped);
	void OnOwningPawnShot();
	void OnPawnChanged(class APawn* NewPawn);
	void PushFeedbackByTag(const struct FGameplayTag& GameplayTag, bool bAddition);
	void RemoveActiveFeedback(const struct FGzGamepadFeedbackSpec& FoundSpec);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzGamepadFeedbackController">();
	}
	static class UGzGamepadFeedbackController* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzGamepadFeedbackController>();
	}
};
static_assert(alignof(UGzGamepadFeedbackController) == 0x000008, "Wrong alignment on UGzGamepadFeedbackController");
static_assert(sizeof(UGzGamepadFeedbackController) == 0x000168, "Wrong size on UGzGamepadFeedbackController");
static_assert(offsetof(UGzGamepadFeedbackController, FeedbackSpecs) == 0x0000A8, "Member 'UGzGamepadFeedbackController::FeedbackSpecs' has a wrong offset!");
static_assert(offsetof(UGzGamepadFeedbackController, DefaultShootGamepadFeedback) == 0x0000F8, "Member 'UGzGamepadFeedbackController::DefaultShootGamepadFeedback' has a wrong offset!");
static_assert(offsetof(UGzGamepadFeedbackController, ControlledPawn) == 0x000148, "Member 'UGzGamepadFeedbackController::ControlledPawn' has a wrong offset!");
static_assert(offsetof(UGzGamepadFeedbackController, ActiveFeedbacks) == 0x000150, "Member 'UGzGamepadFeedbackController::ActiveFeedbacks' has a wrong offset!");

// Class G01.GzGamepadProfileSettingDiscrete
// 0x0020 (0x0170 - 0x0150)
class UGzGamepadProfileSettingDiscrete : public UGameSettingValueDiscrete
{
public:
	TArray<struct FGzGamepadProfileInfo>          GamepadProfiles;                                   // 0x0150(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	class FName                                   XSXControllerName;                                 // 0x0160(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FName                                   PS5ControllerName;                                 // 0x0168(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzGamepadProfileSettingDiscrete">();
	}
	static class UGzGamepadProfileSettingDiscrete* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzGamepadProfileSettingDiscrete>();
	}
};
static_assert(alignof(UGzGamepadProfileSettingDiscrete) == 0x000008, "Wrong alignment on UGzGamepadProfileSettingDiscrete");
static_assert(sizeof(UGzGamepadProfileSettingDiscrete) == 0x000170, "Wrong size on UGzGamepadProfileSettingDiscrete");
static_assert(offsetof(UGzGamepadProfileSettingDiscrete, GamepadProfiles) == 0x000150, "Member 'UGzGamepadProfileSettingDiscrete::GamepadProfiles' has a wrong offset!");
static_assert(offsetof(UGzGamepadProfileSettingDiscrete, XSXControllerName) == 0x000160, "Member 'UGzGamepadProfileSettingDiscrete::XSXControllerName' has a wrong offset!");
static_assert(offsetof(UGzGamepadProfileSettingDiscrete, PS5ControllerName) == 0x000168, "Member 'UGzGamepadProfileSettingDiscrete::PS5ControllerName' has a wrong offset!");

// Class G01.GzKillStatCollector
// 0x0000 (0x0040 - 0x0040)
class UGzKillStatCollector final : public UGzCharacterDeathStatCollector
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzKillStatCollector">();
	}
	static class UGzKillStatCollector* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzKillStatCollector>();
	}
};
static_assert(alignof(UGzKillStatCollector) == 0x000008, "Wrong alignment on UGzKillStatCollector");
static_assert(sizeof(UGzKillStatCollector) == 0x000040, "Wrong size on UGzKillStatCollector");

// Class G01.GzLoadoutsCalledInStatCollector
// 0x0008 (0x0040 - 0x0038)
class UGzLoadoutsCalledInStatCollector final : public UGzGlobalStatsCollector
{
public:
	uint8                                         Pad_3276[0x8];                                     // 0x0038(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzLoadoutsCalledInStatCollector">();
	}
	static class UGzLoadoutsCalledInStatCollector* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzLoadoutsCalledInStatCollector>();
	}
};
static_assert(alignof(UGzLoadoutsCalledInStatCollector) == 0x000008, "Wrong alignment on UGzLoadoutsCalledInStatCollector");
static_assert(sizeof(UGzLoadoutsCalledInStatCollector) == 0x000040, "Wrong size on UGzLoadoutsCalledInStatCollector");

// Class G01.GzPropagationStrategyConfig
// 0x0048 (0x0070 - 0x0028)
class UGzPropagationStrategyConfig : public UObject
{
public:
	TSoftClassPtr<class UClass>                   PropagatedActorClass;                              // 0x0028(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                ActorTileExtents;                                  // 0x0050(0x0018)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinTimeDelayDestruction;                           // 0x0068(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxTimeDelayDestruction;                           // 0x006C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	const struct FVector GetTileExtents() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzPropagationStrategyConfig">();
	}
	static class UGzPropagationStrategyConfig* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzPropagationStrategyConfig>();
	}
};
static_assert(alignof(UGzPropagationStrategyConfig) == 0x000008, "Wrong alignment on UGzPropagationStrategyConfig");
static_assert(sizeof(UGzPropagationStrategyConfig) == 0x000070, "Wrong size on UGzPropagationStrategyConfig");
static_assert(offsetof(UGzPropagationStrategyConfig, PropagatedActorClass) == 0x000028, "Member 'UGzPropagationStrategyConfig::PropagatedActorClass' has a wrong offset!");
static_assert(offsetof(UGzPropagationStrategyConfig, ActorTileExtents) == 0x000050, "Member 'UGzPropagationStrategyConfig::ActorTileExtents' has a wrong offset!");
static_assert(offsetof(UGzPropagationStrategyConfig, MinTimeDelayDestruction) == 0x000068, "Member 'UGzPropagationStrategyConfig::MinTimeDelayDestruction' has a wrong offset!");
static_assert(offsetof(UGzPropagationStrategyConfig, MaxTimeDelayDestruction) == 0x00006C, "Member 'UGzPropagationStrategyConfig::MaxTimeDelayDestruction' has a wrong offset!");

// Class G01.GzPropagationStrategyConfig_Grid
// 0x0038 (0x00A8 - 0x0070)
class UGzPropagationStrategyConfig_Grid : public UGzPropagationStrategyConfig
{
public:
	TArray<int32>                                 LengthLevels;                                      // 0x0070(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TArray<int32>                                 WidthLevels;                                       // 0x0080(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TArray<int32>                                 HeightLevels;                                      // 0x0090(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	uint8                                         CenterLocationFlags;                               // 0x00A0(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3277[0x7];                                     // 0x00A1(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	int32 GetHeight(const int32 Level) const;
	int32 GetLength(const int32 Level) const;
	int32 GetWidth(const int32 Level) const;
	bool IsCenteredAt(EGzCenterLocation CenterLocation) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzPropagationStrategyConfig_Grid">();
	}
	static class UGzPropagationStrategyConfig_Grid* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzPropagationStrategyConfig_Grid>();
	}
};
static_assert(alignof(UGzPropagationStrategyConfig_Grid) == 0x000008, "Wrong alignment on UGzPropagationStrategyConfig_Grid");
static_assert(sizeof(UGzPropagationStrategyConfig_Grid) == 0x0000A8, "Wrong size on UGzPropagationStrategyConfig_Grid");
static_assert(offsetof(UGzPropagationStrategyConfig_Grid, LengthLevels) == 0x000070, "Member 'UGzPropagationStrategyConfig_Grid::LengthLevels' has a wrong offset!");
static_assert(offsetof(UGzPropagationStrategyConfig_Grid, WidthLevels) == 0x000080, "Member 'UGzPropagationStrategyConfig_Grid::WidthLevels' has a wrong offset!");
static_assert(offsetof(UGzPropagationStrategyConfig_Grid, HeightLevels) == 0x000090, "Member 'UGzPropagationStrategyConfig_Grid::HeightLevels' has a wrong offset!");
static_assert(offsetof(UGzPropagationStrategyConfig_Grid, CenterLocationFlags) == 0x0000A0, "Member 'UGzPropagationStrategyConfig_Grid::CenterLocationFlags' has a wrong offset!");

// Class G01.GzPropagationStrategyConfig_SphericalGrid
// 0x0010 (0x00B8 - 0x00A8)
class UGzPropagationStrategyConfig_SphericalGrid final : public UGzPropagationStrategyConfig_Grid
{
public:
	EGzPropagationSphereRadiusLimit               RadiusLimit;                                       // 0x00A8(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3278[0x3];                                     // 0x00A9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         PropagationSpeedPerSecond;                         // 0x00AC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDestroyInSpawnOrder;                              // 0x00B0(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3279[0x7];                                     // 0x00B1(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzPropagationStrategyConfig_SphericalGrid">();
	}
	static class UGzPropagationStrategyConfig_SphericalGrid* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzPropagationStrategyConfig_SphericalGrid>();
	}
};
static_assert(alignof(UGzPropagationStrategyConfig_SphericalGrid) == 0x000008, "Wrong alignment on UGzPropagationStrategyConfig_SphericalGrid");
static_assert(sizeof(UGzPropagationStrategyConfig_SphericalGrid) == 0x0000B8, "Wrong size on UGzPropagationStrategyConfig_SphericalGrid");
static_assert(offsetof(UGzPropagationStrategyConfig_SphericalGrid, RadiusLimit) == 0x0000A8, "Member 'UGzPropagationStrategyConfig_SphericalGrid::RadiusLimit' has a wrong offset!");
static_assert(offsetof(UGzPropagationStrategyConfig_SphericalGrid, PropagationSpeedPerSecond) == 0x0000AC, "Member 'UGzPropagationStrategyConfig_SphericalGrid::PropagationSpeedPerSecond' has a wrong offset!");
static_assert(offsetof(UGzPropagationStrategyConfig_SphericalGrid, bDestroyInSpawnOrder) == 0x0000B0, "Member 'UGzPropagationStrategyConfig_SphericalGrid::bDestroyInSpawnOrder' has a wrong offset!");

// Class G01.GzGameplayAbilityShield
// 0x0000 (0x0678 - 0x0678)
class UGzGameplayAbilityShield final : public UGzGA_BaseLimbAbility
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzGameplayAbilityShield">();
	}
	static class UGzGameplayAbilityShield* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzGameplayAbilityShield>();
	}
};
static_assert(alignof(UGzGameplayAbilityShield) == 0x000008, "Wrong alignment on UGzGameplayAbilityShield");
static_assert(sizeof(UGzGameplayAbilityShield) == 0x000678, "Wrong size on UGzGameplayAbilityShield");

// Class G01.GzGameplayCondition
// 0x0038 (0x0098 - 0x0060)
class UGzGameplayCondition : public UGzCondition
{
public:
	FMulticastInlineDelegateProperty_             OnStateChangedEvent;                               // 0x0060(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	class FText                                   Name_GzGameplayCondition;                          // 0x0070(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, Protected, ExposeOnSpawn, NativeAccessSpecifierProtected)
	class FText                                   Description;                                       // 0x0080(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, Protected, ExposeOnSpawn, NativeAccessSpecifierProtected)
	bool                                          bHidden;                                           // 0x0090(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_327A[0x7];                                     // 0x0091(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnPlayerJoined(int32 PlayerId);
	void OnPlayerLeft(int32 PlayerId);
	void OnStateChanged_BP(EGzConditionState NewState);
	void Signal(bool bValue);

	EGzConditionState GetPlayerState(int32 PlayerId) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzGameplayCondition">();
	}
	static class UGzGameplayCondition* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzGameplayCondition>();
	}
};
static_assert(alignof(UGzGameplayCondition) == 0x000008, "Wrong alignment on UGzGameplayCondition");
static_assert(sizeof(UGzGameplayCondition) == 0x000098, "Wrong size on UGzGameplayCondition");
static_assert(offsetof(UGzGameplayCondition, OnStateChangedEvent) == 0x000060, "Member 'UGzGameplayCondition::OnStateChangedEvent' has a wrong offset!");
static_assert(offsetof(UGzGameplayCondition, Name_GzGameplayCondition) == 0x000070, "Member 'UGzGameplayCondition::Name_GzGameplayCondition' has a wrong offset!");
static_assert(offsetof(UGzGameplayCondition, Description) == 0x000080, "Member 'UGzGameplayCondition::Description' has a wrong offset!");
static_assert(offsetof(UGzGameplayCondition, bHidden) == 0x000090, "Member 'UGzGameplayCondition::bHidden' has a wrong offset!");

// Class G01.GzHeadShotKillsStatsCollector
// 0x0008 (0x0040 - 0x0038)
class UGzHeadShotKillsStatsCollector final : public UGzGlobalStatsCollector
{
public:
	uint8                                         Pad_327C[0x8];                                     // 0x0038(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzHeadShotKillsStatsCollector">();
	}
	static class UGzHeadShotKillsStatsCollector* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzHeadShotKillsStatsCollector>();
	}
};
static_assert(alignof(UGzHeadShotKillsStatsCollector) == 0x000008, "Wrong alignment on UGzHeadShotKillsStatsCollector");
static_assert(sizeof(UGzHeadShotKillsStatsCollector) == 0x000040, "Wrong size on UGzHeadShotKillsStatsCollector");

// Class G01.GzSettingsChangeAction
// 0x0000 (0x0028 - 0x0028)
class UGzSettingsChangeAction final : public UObject
{
public:
	void Trigger();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzSettingsChangeAction">();
	}
	static class UGzSettingsChangeAction* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzSettingsChangeAction>();
	}
};
static_assert(alignof(UGzSettingsChangeAction) == 0x000008, "Wrong alignment on UGzSettingsChangeAction");
static_assert(sizeof(UGzSettingsChangeAction) == 0x000028, "Wrong size on UGzSettingsChangeAction");

// Class G01.GzLoginState
// 0x0010 (0x0080 - 0x0070)
class UGzLoginState final : public UGzFlowStateWithActionGraph
{
public:
	uint8                                         Pad_327D[0x10];                                    // 0x0070(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzLoginState">();
	}
	static class UGzLoginState* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzLoginState>();
	}
};
static_assert(alignof(UGzLoginState) == 0x000008, "Wrong alignment on UGzLoginState");
static_assert(sizeof(UGzLoginState) == 0x000080, "Wrong size on UGzLoginState");

// Class G01.GZGameplayCueManager
// 0x0000 (0x02C0 - 0x02C0)
class UGZGameplayCueManager final : public UGameplayCueManager
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GZGameplayCueManager">();
	}
	static class UGZGameplayCueManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGZGameplayCueManager>();
	}
};
static_assert(alignof(UGZGameplayCueManager) == 0x000008, "Wrong alignment on UGZGameplayCueManager");
static_assert(sizeof(UGZGameplayCueManager) == 0x0002C0, "Wrong size on UGZGameplayCueManager");

// Class G01.GzInitialShrinkingZoneComponent
// 0x0018 (0x00C0 - 0x00A8)
class UGzInitialShrinkingZoneComponent final : public UActorComponent
{
public:
	bool                                          bIncludeInVisualization;                           // 0x00A8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_327E[0x3];                                     // 0x00A9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FColor                                 OtherInitialZoneColor;                             // 0x00AC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FColor                                 BoundingZoneColor;                                 // 0x00B0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FColor                                 InitialZoneColor;                                  // 0x00B4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FColor                                 PossibleInitialZoneAreaColor;                      // 0x00B8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_327F[0x4];                                     // 0x00BC(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzInitialShrinkingZoneComponent">();
	}
	static class UGzInitialShrinkingZoneComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzInitialShrinkingZoneComponent>();
	}
};
static_assert(alignof(UGzInitialShrinkingZoneComponent) == 0x000008, "Wrong alignment on UGzInitialShrinkingZoneComponent");
static_assert(sizeof(UGzInitialShrinkingZoneComponent) == 0x0000C0, "Wrong size on UGzInitialShrinkingZoneComponent");
static_assert(offsetof(UGzInitialShrinkingZoneComponent, bIncludeInVisualization) == 0x0000A8, "Member 'UGzInitialShrinkingZoneComponent::bIncludeInVisualization' has a wrong offset!");
static_assert(offsetof(UGzInitialShrinkingZoneComponent, OtherInitialZoneColor) == 0x0000AC, "Member 'UGzInitialShrinkingZoneComponent::OtherInitialZoneColor' has a wrong offset!");
static_assert(offsetof(UGzInitialShrinkingZoneComponent, BoundingZoneColor) == 0x0000B0, "Member 'UGzInitialShrinkingZoneComponent::BoundingZoneColor' has a wrong offset!");
static_assert(offsetof(UGzInitialShrinkingZoneComponent, InitialZoneColor) == 0x0000B4, "Member 'UGzInitialShrinkingZoneComponent::InitialZoneColor' has a wrong offset!");
static_assert(offsetof(UGzInitialShrinkingZoneComponent, PossibleInitialZoneAreaColor) == 0x0000B8, "Member 'UGzInitialShrinkingZoneComponent::PossibleInitialZoneAreaColor' has a wrong offset!");

// Class G01.GzGE_LimbLossDamage
// 0x0050 (0x0C18 - 0x0BC8)
class UGzGE_LimbLossDamage : public UGzGE_BaseDamage
{
public:
	TMap<EGzLimbType, struct FScalableFloat>      DamageForLimb;                                     // 0x0BC8(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzGE_LimbLossDamage">();
	}
	static class UGzGE_LimbLossDamage* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzGE_LimbLossDamage>();
	}
};
static_assert(alignof(UGzGE_LimbLossDamage) == 0x000008, "Wrong alignment on UGzGE_LimbLossDamage");
static_assert(sizeof(UGzGE_LimbLossDamage) == 0x000C18, "Wrong size on UGzGE_LimbLossDamage");
static_assert(offsetof(UGzGE_LimbLossDamage, DamageForLimb) == 0x000BC8, "Member 'UGzGE_LimbLossDamage::DamageForLimb' has a wrong offset!");

// Class G01.GzJZ_MatchInProgressStage
// 0x0008 (0x0120 - 0x0118)
class UGzJZ_MatchInProgressStage final : public UGzMatchInProgressStage
{
public:
	class AGzAdvancedMission*                     MissionInstance;                                   // 0x0118(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void OnMissionStateChanged(class AGzAdvancedMission* Mission, EGzMissionState NewState);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzJZ_MatchInProgressStage">();
	}
	static class UGzJZ_MatchInProgressStage* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzJZ_MatchInProgressStage>();
	}
};
static_assert(alignof(UGzJZ_MatchInProgressStage) == 0x000008, "Wrong alignment on UGzJZ_MatchInProgressStage");
static_assert(sizeof(UGzJZ_MatchInProgressStage) == 0x000120, "Wrong size on UGzJZ_MatchInProgressStage");
static_assert(offsetof(UGzJZ_MatchInProgressStage, MissionInstance) == 0x000118, "Member 'UGzJZ_MatchInProgressStage::MissionInstance' has a wrong offset!");

// Class G01.GzGE_FallDamage
// 0x0018 (0x0BE0 - 0x0BC8)
class UGzGE_FallDamage : public UGzGE_BaseDamage
{
public:
	TArray<struct FGzGameplayAttributeValueRange> AttributesToAffect;                                // 0x0BC8(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	class UCurveFloat*                            DamageHeightDependency;                            // 0x0BD8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzGE_FallDamage">();
	}
	static class UGzGE_FallDamage* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzGE_FallDamage>();
	}
};
static_assert(alignof(UGzGE_FallDamage) == 0x000008, "Wrong alignment on UGzGE_FallDamage");
static_assert(sizeof(UGzGE_FallDamage) == 0x000BE0, "Wrong size on UGzGE_FallDamage");
static_assert(offsetof(UGzGE_FallDamage, AttributesToAffect) == 0x000BC8, "Member 'UGzGE_FallDamage::AttributesToAffect' has a wrong offset!");
static_assert(offsetof(UGzGE_FallDamage, DamageHeightDependency) == 0x000BD8, "Member 'UGzGE_FallDamage::DamageHeightDependency' has a wrong offset!");

// Class G01.GzGE_Knockdown
// 0x0000 (0x0A70 - 0x0A70)
class UGzGE_Knockdown : public UGameplayEffect
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzGE_Knockdown">();
	}
	static class UGzGE_Knockdown* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzGE_Knockdown>();
	}
};
static_assert(alignof(UGzGE_Knockdown) == 0x000008, "Wrong alignment on UGzGE_Knockdown");
static_assert(sizeof(UGzGE_Knockdown) == 0x000A70, "Wrong size on UGzGE_Knockdown");

// Class G01.GzGE_Alive
// 0x0000 (0x0A70 - 0x0A70)
class UGzGE_Alive : public UGameplayEffect
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzGE_Alive">();
	}
	static class UGzGE_Alive* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzGE_Alive>();
	}
};
static_assert(alignof(UGzGE_Alive) == 0x000008, "Wrong alignment on UGzGE_Alive");
static_assert(sizeof(UGzGE_Alive) == 0x000A70, "Wrong size on UGzGE_Alive");

// Class G01.GzGE_Dead
// 0x0000 (0x0A70 - 0x0A70)
class UGzGE_Dead : public UGameplayEffect
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzGE_Dead">();
	}
	static class UGzGE_Dead* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzGE_Dead>();
	}
};
static_assert(alignof(UGzGE_Dead) == 0x000008, "Wrong alignment on UGzGE_Dead");
static_assert(sizeof(UGzGE_Dead) == 0x000A70, "Wrong size on UGzGE_Dead");

// Class G01.GzGE_Dying
// 0x0000 (0x0A70 - 0x0A70)
class UGzGE_Dying : public UGameplayEffect
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzGE_Dying">();
	}
	static class UGzGE_Dying* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzGE_Dying>();
	}
};
static_assert(alignof(UGzGE_Dying) == 0x000008, "Wrong alignment on UGzGE_Dying");
static_assert(sizeof(UGzGE_Dying) == 0x000A70, "Wrong size on UGzGE_Dying");

// Class G01.GzServerService
// 0x0128 (0x01C8 - 0x00A0)
class UGzServerService : public UGzPlayFabObject
{
public:
	uint8                                         Pad_3281[0x128];                                   // 0x00A0(0x0128)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzServerService">();
	}
	static class UGzServerService* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzServerService>();
	}
};
static_assert(alignof(UGzServerService) == 0x000008, "Wrong alignment on UGzServerService");
static_assert(sizeof(UGzServerService) == 0x0001C8, "Wrong size on UGzServerService");

// Class G01.GzGE_Revive
// 0x0000 (0x0A70 - 0x0A70)
class UGzGE_Revive : public UGameplayEffect
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzGE_Revive">();
	}
	static class UGzGE_Revive* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzGE_Revive>();
	}
};
static_assert(alignof(UGzGE_Revive) == 0x000008, "Wrong alignment on UGzGE_Revive");
static_assert(sizeof(UGzGE_Revive) == 0x000A70, "Wrong size on UGzGE_Revive");

// Class G01.GzGE_PickupItem
// 0x0000 (0x0A70 - 0x0A70)
class UGzGE_PickupItem final : public UGameplayEffect
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzGE_PickupItem">();
	}
	static class UGzGE_PickupItem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzGE_PickupItem>();
	}
};
static_assert(alignof(UGzGE_PickupItem) == 0x000008, "Wrong alignment on UGzGE_PickupItem");
static_assert(sizeof(UGzGE_PickupItem) == 0x000A70, "Wrong size on UGzGE_PickupItem");

// Class G01.GzGA_WeaponSocketAttack
// 0x0000 (0x0558 - 0x0558)
class UGzGA_WeaponSocketAttack final : public UGzGA_WeaponAttack
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzGA_WeaponSocketAttack">();
	}
	static class UGzGA_WeaponSocketAttack* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzGA_WeaponSocketAttack>();
	}
};
static_assert(alignof(UGzGA_WeaponSocketAttack) == 0x000008, "Wrong alignment on UGzGA_WeaponSocketAttack");
static_assert(sizeof(UGzGA_WeaponSocketAttack) == 0x000558, "Wrong size on UGzGA_WeaponSocketAttack");

// Class G01.GzGE_WeaponParamsModifier
// 0x0030 (0x0AA0 - 0x0A70)
class UGzGE_WeaponParamsModifier : public UGameplayEffect
{
public:
	TArray<class UGzWeaponModifier*>              WeaponModifiers;                                   // 0x0A70(0x0010)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, ContainsInstancedReference, NativeAccessSpecifierPublic)
	TArray<class UGzWeaponModifier*>              OneHandedWeaponModifiers;                          // 0x0A80(0x0010)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, ContainsInstancedReference, NativeAccessSpecifierPublic)
	TArray<class UGzWeaponModifier*>              TwoHandedWeaponModifiers;                          // 0x0A90(0x0010)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, ContainsInstancedReference, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzGE_WeaponParamsModifier">();
	}
	static class UGzGE_WeaponParamsModifier* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzGE_WeaponParamsModifier>();
	}
};
static_assert(alignof(UGzGE_WeaponParamsModifier) == 0x000008, "Wrong alignment on UGzGE_WeaponParamsModifier");
static_assert(sizeof(UGzGE_WeaponParamsModifier) == 0x000AA0, "Wrong size on UGzGE_WeaponParamsModifier");
static_assert(offsetof(UGzGE_WeaponParamsModifier, WeaponModifiers) == 0x000A70, "Member 'UGzGE_WeaponParamsModifier::WeaponModifiers' has a wrong offset!");
static_assert(offsetof(UGzGE_WeaponParamsModifier, OneHandedWeaponModifiers) == 0x000A80, "Member 'UGzGE_WeaponParamsModifier::OneHandedWeaponModifiers' has a wrong offset!");
static_assert(offsetof(UGzGE_WeaponParamsModifier, TwoHandedWeaponModifiers) == 0x000A90, "Member 'UGzGE_WeaponParamsModifier::TwoHandedWeaponModifiers' has a wrong offset!");

// Class G01.GzReloadMetagameActionHandler
// 0x0000 (0x0030 - 0x0030)
class UGzReloadMetagameActionHandler final : public UGzCriticalMessageActionHandler
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzReloadMetagameActionHandler">();
	}
	static class UGzReloadMetagameActionHandler* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzReloadMetagameActionHandler>();
	}
};
static_assert(alignof(UGzReloadMetagameActionHandler) == 0x000008, "Wrong alignment on UGzReloadMetagameActionHandler");
static_assert(sizeof(UGzReloadMetagameActionHandler) == 0x000030, "Wrong size on UGzReloadMetagameActionHandler");

// Class G01.GzMatchmakingCheatExtension
// 0x0000 (0x0028 - 0x0028)
class UGzMatchmakingCheatExtension final : public UGzCheatManagerExtension
{
public:
	void MatchmakingIsInProgress() const;
	void MatchmakingIsReady() const;
	void MatchmakingPingsDump() const;
	void MatchmakingPingsFake(uint32 Param_Index, uint32 Latency, float PacketLoss) const;
	void MatchmakingPingsFakeDeleteRegion(uint32 Param_Index) const;
	void MatchmakingPingsFakeStop() const;
	void MatchmakingPingsRefresh() const;
	void MatchmakingQueueDump() const;
	void MatchmakingQueueSet(const class FString& QueueName) const;
	void MatchmakingReadyStatusesDump() const;
	void MatchmakingSetReady(bool bReady) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzMatchmakingCheatExtension">();
	}
	static class UGzMatchmakingCheatExtension* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzMatchmakingCheatExtension>();
	}
};
static_assert(alignof(UGzMatchmakingCheatExtension) == 0x000008, "Wrong alignment on UGzMatchmakingCheatExtension");
static_assert(sizeof(UGzMatchmakingCheatExtension) == 0x000028, "Wrong size on UGzMatchmakingCheatExtension");

// Class G01.GzGE_AbsentLimb
// 0x0000 (0x0AA0 - 0x0AA0)
class UGzGE_AbsentLimb : public UGzGE_WeaponParamsModifier
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzGE_AbsentLimb">();
	}
	static class UGzGE_AbsentLimb* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzGE_AbsentLimb>();
	}
};
static_assert(alignof(UGzGE_AbsentLimb) == 0x000008, "Wrong alignment on UGzGE_AbsentLimb");
static_assert(sizeof(UGzGE_AbsentLimb) == 0x000AA0, "Wrong size on UGzGE_AbsentLimb");

// Class G01.GzMarketplaceCheatExtension
// 0x0000 (0x0028 - 0x0028)
class UGzMarketplaceCheatExtension final : public UGzCheatManagerExtension
{
public:
	void ReportPlayerMarketplaceLot(const class FString& LotId, const class FString& Reason) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzMarketplaceCheatExtension">();
	}
	static class UGzMarketplaceCheatExtension* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzMarketplaceCheatExtension>();
	}
};
static_assert(alignof(UGzMarketplaceCheatExtension) == 0x000008, "Wrong alignment on UGzMarketplaceCheatExtension");
static_assert(sizeof(UGzMarketplaceCheatExtension) == 0x000028, "Wrong size on UGzMarketplaceCheatExtension");

// Class G01.GzGE_PresentLimb
// 0x0000 (0x0AA0 - 0x0AA0)
class UGzGE_PresentLimb : public UGzGE_WeaponParamsModifier
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzGE_PresentLimb">();
	}
	static class UGzGE_PresentLimb* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzGE_PresentLimb>();
	}
};
static_assert(alignof(UGzGE_PresentLimb) == 0x000008, "Wrong alignment on UGzGE_PresentLimb");
static_assert(sizeof(UGzGE_PresentLimb) == 0x000AA0, "Wrong size on UGzGE_PresentLimb");

// Class G01.GzGE_MovementSpeedModifier
// 0x0010 (0x0A80 - 0x0A70)
class UGzGE_MovementSpeedModifier : public UGameplayEffect
{
public:
	float                                         MovementSpeedModifier;                             // 0x0A70(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         WalkModifier;                                      // 0x0A74(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CrouchModifier;                                    // 0x0A78(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SprintModifier;                                    // 0x0A7C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzGE_MovementSpeedModifier">();
	}
	static class UGzGE_MovementSpeedModifier* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzGE_MovementSpeedModifier>();
	}
};
static_assert(alignof(UGzGE_MovementSpeedModifier) == 0x000008, "Wrong alignment on UGzGE_MovementSpeedModifier");
static_assert(sizeof(UGzGE_MovementSpeedModifier) == 0x000A80, "Wrong size on UGzGE_MovementSpeedModifier");
static_assert(offsetof(UGzGE_MovementSpeedModifier, MovementSpeedModifier) == 0x000A70, "Member 'UGzGE_MovementSpeedModifier::MovementSpeedModifier' has a wrong offset!");
static_assert(offsetof(UGzGE_MovementSpeedModifier, WalkModifier) == 0x000A74, "Member 'UGzGE_MovementSpeedModifier::WalkModifier' has a wrong offset!");
static_assert(offsetof(UGzGE_MovementSpeedModifier, CrouchModifier) == 0x000A78, "Member 'UGzGE_MovementSpeedModifier::CrouchModifier' has a wrong offset!");
static_assert(offsetof(UGzGE_MovementSpeedModifier, SprintModifier) == 0x000A7C, "Member 'UGzGE_MovementSpeedModifier::SprintModifier' has a wrong offset!");

// Class G01.GzGE_DefaultLegsPresent
// 0x0010 (0x0A80 - 0x0A70)
class UGzGE_DefaultLegsPresent : public UGzGameplayEffect
{
public:
	TArray<class UGzBodyPartItemData*>            DefaultLegs;                                       // 0x0A70(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzGE_DefaultLegsPresent">();
	}
	static class UGzGE_DefaultLegsPresent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzGE_DefaultLegsPresent>();
	}
};
static_assert(alignof(UGzGE_DefaultLegsPresent) == 0x000008, "Wrong alignment on UGzGE_DefaultLegsPresent");
static_assert(sizeof(UGzGE_DefaultLegsPresent) == 0x000A80, "Wrong size on UGzGE_DefaultLegsPresent");
static_assert(offsetof(UGzGE_DefaultLegsPresent, DefaultLegs) == 0x000A70, "Member 'UGzGE_DefaultLegsPresent::DefaultLegs' has a wrong offset!");

// Class G01.GzGE_AttributeRegen
// 0x0058 (0x0AC8 - 0x0A70)
class UGzGE_AttributeRegen : public UGameplayEffect
{
public:
	float                                         RegenPeriod;                                       // 0x0A70(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3282[0x4];                                     // 0x0A74(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayAttribute                     AttributeToRegen;                                  // 0x0A78(0x0038)(Edit, DisableEditOnInstance, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FGameplayTag                           ProhibitionTag;                                    // 0x0AB0(0x0008)(Edit, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FGameplayTag                           MagnitudeTag;                                      // 0x0AB8(0x0008)(Edit, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         FixedRegenValuePerSecond;                          // 0x0AC0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3283[0x4];                                     // 0x0AC4(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzGE_AttributeRegen">();
	}
	static class UGzGE_AttributeRegen* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzGE_AttributeRegen>();
	}
};
static_assert(alignof(UGzGE_AttributeRegen) == 0x000008, "Wrong alignment on UGzGE_AttributeRegen");
static_assert(sizeof(UGzGE_AttributeRegen) == 0x000AC8, "Wrong size on UGzGE_AttributeRegen");
static_assert(offsetof(UGzGE_AttributeRegen, RegenPeriod) == 0x000A70, "Member 'UGzGE_AttributeRegen::RegenPeriod' has a wrong offset!");
static_assert(offsetof(UGzGE_AttributeRegen, AttributeToRegen) == 0x000A78, "Member 'UGzGE_AttributeRegen::AttributeToRegen' has a wrong offset!");
static_assert(offsetof(UGzGE_AttributeRegen, ProhibitionTag) == 0x000AB0, "Member 'UGzGE_AttributeRegen::ProhibitionTag' has a wrong offset!");
static_assert(offsetof(UGzGE_AttributeRegen, MagnitudeTag) == 0x000AB8, "Member 'UGzGE_AttributeRegen::MagnitudeTag' has a wrong offset!");
static_assert(offsetof(UGzGE_AttributeRegen, FixedRegenValuePerSecond) == 0x000AC0, "Member 'UGzGE_AttributeRegen::FixedRegenValuePerSecond' has a wrong offset!");

// Class G01.GzGEAR_LimbLossDamage
// 0x0000 (0x0028 - 0x0028)
class UGzGEAR_LimbLossDamage final : public UGameplayEffectCustomApplicationRequirement
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzGEAR_LimbLossDamage">();
	}
	static class UGzGEAR_LimbLossDamage* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzGEAR_LimbLossDamage>();
	}
};
static_assert(alignof(UGzGEAR_LimbLossDamage) == 0x000008, "Wrong alignment on UGzGEAR_LimbLossDamage");
static_assert(sizeof(UGzGEAR_LimbLossDamage) == 0x000028, "Wrong size on UGzGEAR_LimbLossDamage");

// Class G01.GzGEAR_PresentDefaultLegs
// 0x0000 (0x0028 - 0x0028)
class UGzGEAR_PresentDefaultLegs final : public UGameplayEffectCustomApplicationRequirement
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzGEAR_PresentDefaultLegs">();
	}
	static class UGzGEAR_PresentDefaultLegs* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzGEAR_PresentDefaultLegs>();
	}
};
static_assert(alignof(UGzGEAR_PresentDefaultLegs) == 0x000008, "Wrong alignment on UGzGEAR_PresentDefaultLegs");
static_assert(sizeof(UGzGEAR_PresentDefaultLegs) == 0x000028, "Wrong size on UGzGEAR_PresentDefaultLegs");

// Class G01.GzGameplayObjective
// 0x0048 (0x00A8 - 0x0060)
class UGzGameplayObjective final : public UGzObjective
{
public:
	FMulticastInlineDelegateProperty_             OnStateChangedEvent;                               // 0x0060(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnProgressChangedEvent;                            // 0x0070(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	class FText                                   Name_GzGameplayObjective;                          // 0x0080(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, Protected, ExposeOnSpawn, NativeAccessSpecifierProtected)
	class FText                                   Description;                                       // 0x0090(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, Protected, ExposeOnSpawn, NativeAccessSpecifierProtected)
	bool                                          bHidden;                                           // 0x00A0(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3284[0x3];                                     // 0x00A1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Progress;                                          // 0x00A4(0x0004)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void FinishObjective(const bool bSuccessful);
	void IncrementProgress();
	void OnPlayerJoined(int32 PlayerId);
	void OnPlayerLeft(int32 PlayerId);
	void OnRep_Progress();
	void SetProgress(float NewProgress);
	void SubscribeOnProgressChange(const TDelegate<void()>& OnProgressChanged);
	void TryFinishObjective(const bool bSuccessful);

	EGzObjectiveState GetObjectiveState() const;
	float GetProgress() const;
	float GetRequiredProgress() const;
	bool IsSupportingProgress() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzGameplayObjective">();
	}
	static class UGzGameplayObjective* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzGameplayObjective>();
	}
};
static_assert(alignof(UGzGameplayObjective) == 0x000008, "Wrong alignment on UGzGameplayObjective");
static_assert(sizeof(UGzGameplayObjective) == 0x0000A8, "Wrong size on UGzGameplayObjective");
static_assert(offsetof(UGzGameplayObjective, OnStateChangedEvent) == 0x000060, "Member 'UGzGameplayObjective::OnStateChangedEvent' has a wrong offset!");
static_assert(offsetof(UGzGameplayObjective, OnProgressChangedEvent) == 0x000070, "Member 'UGzGameplayObjective::OnProgressChangedEvent' has a wrong offset!");
static_assert(offsetof(UGzGameplayObjective, Name_GzGameplayObjective) == 0x000080, "Member 'UGzGameplayObjective::Name_GzGameplayObjective' has a wrong offset!");
static_assert(offsetof(UGzGameplayObjective, Description) == 0x000090, "Member 'UGzGameplayObjective::Description' has a wrong offset!");
static_assert(offsetof(UGzGameplayObjective, bHidden) == 0x0000A0, "Member 'UGzGameplayObjective::bHidden' has a wrong offset!");
static_assert(offsetof(UGzGameplayObjective, Progress) == 0x0000A4, "Member 'UGzGameplayObjective::Progress' has a wrong offset!");

// Class G01.GzRecastNavMesh
// 0x0028 (0x06C0 - 0x0698)
class AGzRecastNavMesh final : public ARecastNavMesh
{
public:
	int32                                         NavMeshChangelist;                                 // 0x0698(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         LoadedCoversNum;                                   // 0x069C(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         LoadedNavLinksNum;                                 // 0x06A0(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3285[0x4];                                     // 0x06A4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UGzNavLinksComponent*                   NavLinksComponent;                                 // 0x06A8(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnTemplate, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UGzCoversComponent*                     CoversComponent;                                   // 0x06B0(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnTemplate, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UGzBaseNavDataDelegate*                 DataDelegate;                                      // 0x06B8(0x0008)(Edit, ZeroConstructor, DisableEditOnTemplate, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzRecastNavMesh">();
	}
	static class AGzRecastNavMesh* GetDefaultObj()
	{
		return GetDefaultObjImpl<AGzRecastNavMesh>();
	}
};
static_assert(alignof(AGzRecastNavMesh) == 0x000008, "Wrong alignment on AGzRecastNavMesh");
static_assert(sizeof(AGzRecastNavMesh) == 0x0006C0, "Wrong size on AGzRecastNavMesh");
static_assert(offsetof(AGzRecastNavMesh, NavMeshChangelist) == 0x000698, "Member 'AGzRecastNavMesh::NavMeshChangelist' has a wrong offset!");
static_assert(offsetof(AGzRecastNavMesh, LoadedCoversNum) == 0x00069C, "Member 'AGzRecastNavMesh::LoadedCoversNum' has a wrong offset!");
static_assert(offsetof(AGzRecastNavMesh, LoadedNavLinksNum) == 0x0006A0, "Member 'AGzRecastNavMesh::LoadedNavLinksNum' has a wrong offset!");
static_assert(offsetof(AGzRecastNavMesh, NavLinksComponent) == 0x0006A8, "Member 'AGzRecastNavMesh::NavLinksComponent' has a wrong offset!");
static_assert(offsetof(AGzRecastNavMesh, CoversComponent) == 0x0006B0, "Member 'AGzRecastNavMesh::CoversComponent' has a wrong offset!");
static_assert(offsetof(AGzRecastNavMesh, DataDelegate) == 0x0006B8, "Member 'AGzRecastNavMesh::DataDelegate' has a wrong offset!");

// Class G01.GzMarketingService
// 0x0000 (0x00A0 - 0x00A0)
class UGzMarketingService final : public UGzClientPFObject
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzMarketingService">();
	}
	static class UGzMarketingService* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzMarketingService>();
	}
};
static_assert(alignof(UGzMarketingService) == 0x000008, "Wrong alignment on UGzMarketingService");
static_assert(sizeof(UGzMarketingService) == 0x0000A0, "Wrong size on UGzMarketingService");

// Class G01.GzGameplayPerformanceTrackerExtension
// 0x0000 (0x0028 - 0x0028)
class UGzGameplayPerformanceTrackerExtension final : public UGzCheatManagerExtension
{
public:
	void SetClientGameplayPerformanceTrackerInterval(float Interval) const;
	void SetServerGameplayPerformanceTrackerInterval(float Interval) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzGameplayPerformanceTrackerExtension">();
	}
	static class UGzGameplayPerformanceTrackerExtension* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzGameplayPerformanceTrackerExtension>();
	}
};
static_assert(alignof(UGzGameplayPerformanceTrackerExtension) == 0x000008, "Wrong alignment on UGzGameplayPerformanceTrackerExtension");
static_assert(sizeof(UGzGameplayPerformanceTrackerExtension) == 0x000028, "Wrong size on UGzGameplayPerformanceTrackerExtension");

// Class G01.GzGameplayStatics
// 0x0000 (0x0028 - 0x0028)
class UGzGameplayStatics final : public UBlueprintFunctionLibrary
{
public:
	static void AddDynamicTagGameplayEffect(class UGzAbilitySystemComponent* TargetASC, const struct FGameplayTag& Tag);
	static bool Blueprint_PredictProjectilePath_Advanced_WithDrag(const class UObject* WorldContextObject, const struct FGzPredictProjectilePathParams& PredictParams, struct FPredictProjectilePathResult* PredictResult);
	static bool Blueprint_PredictProjectilePath_Advanced_WithHoming(const class UObject* WorldContextObject, const struct FGzPredictProjectilePathParams_WithHoming& PredictParams, struct FPredictProjectilePathResult* PredictResult);
	static TArray<struct FHitResult> BulletMultiTraceSkipOwner(const class AActor* Owner, const bool bSkipRecursively, const struct FVector& Start, const struct FVector& End, bool bUseComplex, class FName TraceTag);
	static struct FHitResult BulletTraceSkipOwner(const class AActor* Owner, const bool bSkipRecursively, const struct FVector& Start, const struct FVector& End, bool bUseComplex);
	static class AGzBoundaryZone* CreateBoundaryZone(TSubclassOf<class AGzBoundaryZone> BoundaryZoneClass, class UObject* WorldContextObject);
	static class AGzSyncCutscene* CreateSyncCutscene(const class UObject* WorldContextObject, TSubclassOf<class AGzSyncCutscene> CutsceneClass);
	static bool DeprojectSignNormalizedScreenToWorld(class APlayerController* PlayerController, const struct FVector2D& ScreenPosition, struct FVector* WorldPosition, struct FVector* WorldDirection);
	static void DestroyNetForce(class AActor* Target);
	static float EstimateAttributeValueChange(const TArray<class UGameplayEffect*>& Effects, const struct FGameplayAttribute& Attribute);
	static void ExitOfflineSession(const class UObject* WorldContextObject);
	static class APawn* FindClosestEnemy(class AGzBaseCharacter* MyPawn, float MinDist, float MaxDist);
	static bool FindClosestPlayerLocationToTarget(class AGzTeam* Team, const struct FVector& Location, struct FVector* OutPosition);
	static void GetAllLevelTypes(const class UObject* WorldContextObject, TSubclassOf<class AActor> Param_Class, TArray<class UClass*>* OutClasses);
	static class AGzBoundaryZone* GetBoundaryZone(class UObject* WorldContextObject);
	static class AActor* GetCharacterIdAccessActor(const struct FGzCharacterIdAccess& CharacterIdAccess);
	static const struct FGzAimAssistPresetSettings GetCurrentAimAssistSettings();
	static float GetCurrentTime(const class UObject* WorldContextObject);
	static float GetHexExtractionCostMultiplier(const class UObject* WorldContextObject);
	static float GetHexExtractionTimeMultiplier(const class UObject* WorldContextObject);
	static class UPhysicalMaterial* GetImpactPhysicalMaterial(const struct FHitResult& Hit, bool bHitArmor);
	static int32 GetItemExtractionCost(const class UObject* WorldContextObject, const class UGzItemData* Item);
	static class AGzPlayerController* GetLocalPlayerController(const class UObject* WorldContextObject);
	static class AActor* GetLocalViewTarget(const class UObject* WorldContextObject);
	static TArray<class AGzPickableBase*> GetPickupsInRadius(const class UObject* WorldContextObject, const struct FVector& Location, const float Radius, const struct FGameplayTag& ItemType);
	static class AGzPlayerState* GetPlayerStateFromContext(class AActor* ActorContext);
	static class AGzPlayerState* GetPlayerStateFromPlayerId(const class UObject* WorldContextObject, int32 PlayerId);
	static class AGzPlayerState* GetPlayerStateFromPlayFabId(const class UObject* WorldContextObject, const class FString& PlayFabId);
	static class AActor* GetRandomActorOfClass(const class UObject* WorldContextObject, TSubclassOf<class AActor> Param_Class);
	static float GetServerWorldTimeSeconds(class UObject* WorldContextObject);
	static void GetSubsystem(class UObject* WorldContextObject, TSubclassOf<class AGzGameModeSubsystem> InClass, class AGzGameModeSubsystem** OutSubsystem, EGzGetSubsystemResult* OutExecNodes);
	static class AGzTeam* GetTeamFromPlayerId(const class UObject* WorldContextObject, const int32 PlayerId);
	static float GetTotalRedeployCostModifier(const class UObject* WorldContextObject);
	static struct FGameplayTag GetWorldZoneGameplayTag(class UGzWorldZone* WorldZone);
	static class AGzCharacter* HasWeaponLOSToCharacter(class AGzCharacter* MyPawn, class AGzCharacter* TargetCharacter, const bool bAnyCharacter);
	static bool IsGameRuleEnabled(const class UObject* WorldContextObject, const struct FGameplayTag& Rule);
	static bool IsLocalPlayerCommunicationRestricted(const class UObject* WorldContextObject);
	static bool IsWithEditor();
	static struct FHitResult LineTraceSkipOwner(const class AActor* Owner, const bool bSkipRecursively, ECollisionChannel CollisionChannel, const struct FVector& Start, const struct FVector& End, bool bUseComplex);
	static void MarkSplineEdited(class USplineComponent* Spline, bool bEdited);
	static class AGzSyncCutscene* PlaySyncCutscene(const class UObject* WorldContextObject, TSubclassOf<class AGzSyncCutscene> CutsceneClass);
	static void PrintCallstack_BP();
	static void PrintCallstack_CPP();
	static void PrintCallstack_FULL(const bool bCollapseVMStack);
	static void ReportPlayer(class AGzPlayerState* PlayerToReport, const TArray<EGzReportReason>& Reasons);
	static void SetCharacterIdAccessActor(struct FGzCharacterIdAccess& CharacterIdAccess, class AActor* Actor);
	static void SetNetAddressable(class UActorComponent* Component);
	static void SortActorsArrayByName(TArray<class AActor*>& Actors);
	static class AGzAIController* SpawnAI(const class UObject* WorldContextObject, const class FString& BotName, const struct FTransform& Transform, bool bUseTransform, int32 TeamID, const TSubclassOf<class AGzAIController> ControllerClass);
	static class AGzAIController* SpawnMirrorBreaker(const class UObject* WorldContextObject, const struct FTransform& Transform, const class AGzPlayerCharacter* InPlayerCharacter, const struct FGameplayTag& NPCTypeTag);
	static class AGzAIController* SpawnNPC(const class UObject* WorldContextObject, const class FString& NPCName, const struct FTransform& Transform, int32 TeamID, const TSubclassOf<class AGzAIController> ControllerClass, const TSubclassOf<class APawn> NonPlayerCharacterClass, ENPCType Type, class UBehaviorTree* BehaviorTree);
	static class AGzAIController* SpawnNPCByTag(const class UObject* WorldContextObject, const struct FTransform& Transform, int32 TeamID, const struct FGameplayTag& NPCTypeTag);
	static struct FHitResult SphereSweepSkipOwner(const class AActor* Owner, const bool bSkipRecursively, ECollisionChannel CollisionChannel, const struct FVector& Start, const struct FVector& End, const float SphereRadius);
	static void TriggerLocalGameplayTagEvent(class AActor* TargetActor, const struct FGameplayTag& Tag);
	static bool TryGetWorldZoneSetup(const class UObject* WorldContextObject, struct FGzWorldZoneSetup* OutSetup);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzGameplayStatics">();
	}
	static class UGzGameplayStatics* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzGameplayStatics>();
	}
};
static_assert(alignof(UGzGameplayStatics) == 0x000008, "Wrong alignment on UGzGameplayStatics");
static_assert(sizeof(UGzGameplayStatics) == 0x000028, "Wrong size on UGzGameplayStatics");

// Class G01.GzGameplayEffectHandler
// 0x0000 (0x0028 - 0x0028)
class UGzGameplayEffectHandler : public UObject
{
public:
	void OnEffectAdded(class UGzAbilitySystemComponent* Target, const struct FGameplayEffectSpec& Spec) const;
	void OnEffectRemoved(class UGzAbilitySystemComponent* Target, const struct FGameplayEffectSpec& Spec) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzGameplayEffectHandler">();
	}
	static class UGzGameplayEffectHandler* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzGameplayEffectHandler>();
	}
};
static_assert(alignof(UGzGameplayEffectHandler) == 0x000008, "Wrong alignment on UGzGameplayEffectHandler");
static_assert(sizeof(UGzGameplayEffectHandler) == 0x000028, "Wrong size on UGzGameplayEffectHandler");

// Class G01.GzLoadingScreenTickSpinner
// 0x0000 (0x0028 - 0x0028)
class UGzLoadingScreenTickSpinner final : public UObject
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzLoadingScreenTickSpinner">();
	}
	static class UGzLoadingScreenTickSpinner* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzLoadingScreenTickSpinner>();
	}
};
static_assert(alignof(UGzLoadingScreenTickSpinner) == 0x000008, "Wrong alignment on UGzLoadingScreenTickSpinner");
static_assert(sizeof(UGzLoadingScreenTickSpinner) == 0x000028, "Wrong size on UGzLoadingScreenTickSpinner");

// Class G01.GzGameplayTagHandlingComponent
// 0x0108 (0x01B0 - 0x00A8)
class UGzGameplayTagHandlingComponent final : public UActorComponent
{
public:
	TMap<struct FGameplayTag, TSubclassOf<class UGzGameplayTagHandler>> TagHandlers;                                       // 0x00A8(0x0050)(Edit, DisableEditOnInstance, UObjectWrapper, NativeAccessSpecifierPublic)
	TMap<struct FGameplayTag, TSubclassOf<class UGzGameplayEffectHandler>> EffectHandlers;                                    // 0x00F8(0x0050)(Edit, DisableEditOnInstance, UObjectWrapper, NativeAccessSpecifierPublic)
	uint8                                         Pad_32AF[0x60];                                    // 0x0148(0x0060)(Fixing Size After Last Property [ Dumper-7 ])
	class UAbilitySystemComponent*                OwnerASC;                                          // 0x01A8(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void OnGameplayEffectAddedToSelf(class UAbilitySystemComponent* Target, const struct FGameplayEffectSpec& Spec, const struct FActiveGameplayEffectHandle& Handle);
	void OnGameplayEffectRemoved(const struct FActiveGameplayEffect& Effect);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzGameplayTagHandlingComponent">();
	}
	static class UGzGameplayTagHandlingComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzGameplayTagHandlingComponent>();
	}
};
static_assert(alignof(UGzGameplayTagHandlingComponent) == 0x000008, "Wrong alignment on UGzGameplayTagHandlingComponent");
static_assert(sizeof(UGzGameplayTagHandlingComponent) == 0x0001B0, "Wrong size on UGzGameplayTagHandlingComponent");
static_assert(offsetof(UGzGameplayTagHandlingComponent, TagHandlers) == 0x0000A8, "Member 'UGzGameplayTagHandlingComponent::TagHandlers' has a wrong offset!");
static_assert(offsetof(UGzGameplayTagHandlingComponent, EffectHandlers) == 0x0000F8, "Member 'UGzGameplayTagHandlingComponent::EffectHandlers' has a wrong offset!");
static_assert(offsetof(UGzGameplayTagHandlingComponent, OwnerASC) == 0x0001A8, "Member 'UGzGameplayTagHandlingComponent::OwnerASC' has a wrong offset!");

// Class G01.GzMapDeploymentTrackExtension
// 0x0038 (0x0070 - 0x0038)
class UGzMapDeploymentTrackExtension : public UGzMapWidgetExtension
{
public:
	TSoftClassPtr<class UClass>                   SplineMapWidgetClass;                              // 0x0038(0x0028)(Edit, DisableEditOnInstance, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UGzSplineMapWidget*                     SplineMapWidget;                                   // 0x0060(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, Transient, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class AGzDeploymentPawn*                      DeploymentPawn;                                    // 0x0068(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void OnViewTargetChanged(class APawn* Pawn);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzMapDeploymentTrackExtension">();
	}
	static class UGzMapDeploymentTrackExtension* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzMapDeploymentTrackExtension>();
	}
};
static_assert(alignof(UGzMapDeploymentTrackExtension) == 0x000008, "Wrong alignment on UGzMapDeploymentTrackExtension");
static_assert(sizeof(UGzMapDeploymentTrackExtension) == 0x000070, "Wrong size on UGzMapDeploymentTrackExtension");
static_assert(offsetof(UGzMapDeploymentTrackExtension, SplineMapWidgetClass) == 0x000038, "Member 'UGzMapDeploymentTrackExtension::SplineMapWidgetClass' has a wrong offset!");
static_assert(offsetof(UGzMapDeploymentTrackExtension, SplineMapWidget) == 0x000060, "Member 'UGzMapDeploymentTrackExtension::SplineMapWidget' has a wrong offset!");
static_assert(offsetof(UGzMapDeploymentTrackExtension, DeploymentPawn) == 0x000068, "Member 'UGzMapDeploymentTrackExtension::DeploymentPawn' has a wrong offset!");

// Class G01.GzGameplayTagsSettings
// 0x00B0 (0x00E8 - 0x0038)
class UGzGameplayTagsSettings final : public UDeveloperSettings
{
public:
	TMap<struct FGameplayTag, struct FGameplayTag> PlayerTagToUITag;                                  // 0x0038(0x0050)(Edit, Config, NativeAccessSpecifierPublic)
	TMap<struct FGameplayTag, struct FGameplayAttribute> GameplayTagToAttributes;                           // 0x0088(0x0050)(Edit, Config, NativeAccessSpecifierPublic)
	TArray<struct FGzComplianceAbilityInteraction> ComplianceInteractionAbilities;                    // 0x00D8(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzGameplayTagsSettings">();
	}
	static class UGzGameplayTagsSettings* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzGameplayTagsSettings>();
	}
};
static_assert(alignof(UGzGameplayTagsSettings) == 0x000008, "Wrong alignment on UGzGameplayTagsSettings");
static_assert(sizeof(UGzGameplayTagsSettings) == 0x0000E8, "Wrong size on UGzGameplayTagsSettings");
static_assert(offsetof(UGzGameplayTagsSettings, PlayerTagToUITag) == 0x000038, "Member 'UGzGameplayTagsSettings::PlayerTagToUITag' has a wrong offset!");
static_assert(offsetof(UGzGameplayTagsSettings, GameplayTagToAttributes) == 0x000088, "Member 'UGzGameplayTagsSettings::GameplayTagToAttributes' has a wrong offset!");
static_assert(offsetof(UGzGameplayTagsSettings, ComplianceInteractionAbilities) == 0x0000D8, "Member 'UGzGameplayTagsSettings::ComplianceInteractionAbilities' has a wrong offset!");

// Class G01.GzGameRestartStage
// 0x0028 (0x0138 - 0x0110)
class UGzGameRestartStage final : public UGzGameStageBase
{
public:
	int32                                         MaxRetries;                                        // 0x0110(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         CheckInterval;                                     // 0x0114(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FText                                   RestartKickReason;                                 // 0x0118(0x0010)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	uint8                                         Pad_32B0[0x10];                                    // 0x0128(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzGameRestartStage">();
	}
	static class UGzGameRestartStage* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzGameRestartStage>();
	}
};
static_assert(alignof(UGzGameRestartStage) == 0x000008, "Wrong alignment on UGzGameRestartStage");
static_assert(sizeof(UGzGameRestartStage) == 0x000138, "Wrong size on UGzGameRestartStage");
static_assert(offsetof(UGzGameRestartStage, MaxRetries) == 0x000110, "Member 'UGzGameRestartStage::MaxRetries' has a wrong offset!");
static_assert(offsetof(UGzGameRestartStage, CheckInterval) == 0x000114, "Member 'UGzGameRestartStage::CheckInterval' has a wrong offset!");
static_assert(offsetof(UGzGameRestartStage, RestartKickReason) == 0x000118, "Member 'UGzGameRestartStage::RestartKickReason' has a wrong offset!");

// Class G01.GzLimbsSpawnedMessage
// 0x0008 (0x0038 - 0x0030)
class UGzLimbsSpawnedMessage final : public UGzInstigatedMessage
{
public:
	class FName                                   SpawnedLimbType;                                   // 0x0030(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzLimbsSpawnedMessage">();
	}
	static class UGzLimbsSpawnedMessage* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzLimbsSpawnedMessage>();
	}
};
static_assert(alignof(UGzLimbsSpawnedMessage) == 0x000008, "Wrong alignment on UGzLimbsSpawnedMessage");
static_assert(sizeof(UGzLimbsSpawnedMessage) == 0x000038, "Wrong size on UGzLimbsSpawnedMessage");
static_assert(offsetof(UGzLimbsSpawnedMessage, SpawnedLimbType) == 0x000030, "Member 'UGzLimbsSpawnedMessage::SpawnedLimbType' has a wrong offset!");

// Class G01.GzPlayFabTelemetrySettings
// 0x0018 (0x0050 - 0x0038)
class UGzPlayFabTelemetrySettings final : public UDeveloperSettings
{
public:
	int16                                         MaxCachedEventsCount;                              // 0x0038(0x0002)(Edit, ZeroConstructor, Config, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int16                                         TelemetrySaveDelaySeconds;                         // 0x003A(0x0002)(Edit, ZeroConstructor, Config, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int16                                         TelemetrySaveMaxDelaySeconds;                      // 0x003C(0x0002)(Edit, ZeroConstructor, Config, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_32B1[0x2];                                     // 0x003E(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 DedicatedEventNamespace;                           // 0x0040(0x0010)(Edit, ZeroConstructor, Config, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzPlayFabTelemetrySettings">();
	}
	static class UGzPlayFabTelemetrySettings* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzPlayFabTelemetrySettings>();
	}
};
static_assert(alignof(UGzPlayFabTelemetrySettings) == 0x000008, "Wrong alignment on UGzPlayFabTelemetrySettings");
static_assert(sizeof(UGzPlayFabTelemetrySettings) == 0x000050, "Wrong size on UGzPlayFabTelemetrySettings");
static_assert(offsetof(UGzPlayFabTelemetrySettings, MaxCachedEventsCount) == 0x000038, "Member 'UGzPlayFabTelemetrySettings::MaxCachedEventsCount' has a wrong offset!");
static_assert(offsetof(UGzPlayFabTelemetrySettings, TelemetrySaveDelaySeconds) == 0x00003A, "Member 'UGzPlayFabTelemetrySettings::TelemetrySaveDelaySeconds' has a wrong offset!");
static_assert(offsetof(UGzPlayFabTelemetrySettings, TelemetrySaveMaxDelaySeconds) == 0x00003C, "Member 'UGzPlayFabTelemetrySettings::TelemetrySaveMaxDelaySeconds' has a wrong offset!");
static_assert(offsetof(UGzPlayFabTelemetrySettings, DedicatedEventNamespace) == 0x000040, "Member 'UGzPlayFabTelemetrySettings::DedicatedEventNamespace' has a wrong offset!");

// Class G01.GzGameSettingCollectionDataAsset
// 0x0050 (0x0080 - 0x0030)
class UGzGameSettingCollectionDataAsset : public UDataAsset
{
public:
	struct FGzGameSettingCollectionData           CollectionData;                                    // 0x0030(0x0050)(Edit, DisableEditOnInstance, ContainsInstancedReference, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzGameSettingCollectionDataAsset">();
	}
	static class UGzGameSettingCollectionDataAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzGameSettingCollectionDataAsset>();
	}
};
static_assert(alignof(UGzGameSettingCollectionDataAsset) == 0x000008, "Wrong alignment on UGzGameSettingCollectionDataAsset");
static_assert(sizeof(UGzGameSettingCollectionDataAsset) == 0x000080, "Wrong size on UGzGameSettingCollectionDataAsset");
static_assert(offsetof(UGzGameSettingCollectionDataAsset, CollectionData) == 0x000030, "Member 'UGzGameSettingCollectionDataAsset::CollectionData' has a wrong offset!");

// Class G01.GzSocialService
// 0x0038 (0x00D8 - 0x00A0)
class UGzSocialService final : public UGzClientPFObject
{
public:
	uint8                                         Pad_32B2[0x38];                                    // 0x00A0(0x0038)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzSocialService">();
	}
	static class UGzSocialService* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzSocialService>();
	}
};
static_assert(alignof(UGzSocialService) == 0x000008, "Wrong alignment on UGzSocialService");
static_assert(sizeof(UGzSocialService) == 0x0000D8, "Wrong size on UGzSocialService");

// Class G01.GzInputRemappingSettingsData
// 0x0090 (0x0110 - 0x0080)
class UGzInputRemappingSettingsData final : public UGzGameSettingCollectionDataAsset
{
public:
	struct FGameplayTagContainer                  EditConditions;                                    // 0x0080(0x0020)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TArray<class UInputMappingContext*>           InputMappingContextsToRegister;                    // 0x00A0(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TMap<class UInputAction*, class FText>        InputActionDescriptions;                           // 0x00B0(0x0050)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	class FText                                   ProfileName;                                       // 0x0100(0x0010)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzInputRemappingSettingsData">();
	}
	static class UGzInputRemappingSettingsData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzInputRemappingSettingsData>();
	}
};
static_assert(alignof(UGzInputRemappingSettingsData) == 0x000008, "Wrong alignment on UGzInputRemappingSettingsData");
static_assert(sizeof(UGzInputRemappingSettingsData) == 0x000110, "Wrong size on UGzInputRemappingSettingsData");
static_assert(offsetof(UGzInputRemappingSettingsData, EditConditions) == 0x000080, "Member 'UGzInputRemappingSettingsData::EditConditions' has a wrong offset!");
static_assert(offsetof(UGzInputRemappingSettingsData, InputMappingContextsToRegister) == 0x0000A0, "Member 'UGzInputRemappingSettingsData::InputMappingContextsToRegister' has a wrong offset!");
static_assert(offsetof(UGzInputRemappingSettingsData, InputActionDescriptions) == 0x0000B0, "Member 'UGzInputRemappingSettingsData::InputActionDescriptions' has a wrong offset!");
static_assert(offsetof(UGzInputRemappingSettingsData, ProfileName) == 0x000100, "Member 'UGzInputRemappingSettingsData::ProfileName' has a wrong offset!");

// Class G01.GzGameSettingDiscreteDataSourceBP
// 0x0000 (0x0028 - 0x0028)
class UGzGameSettingDiscreteDataSourceBP : public UObject
{
public:
	class FString GetValue();
	void SetValue(const class FString& NewValue);

	class UGzGameUserSettings* GetUserSettings() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzGameSettingDiscreteDataSourceBP">();
	}
	static class UGzGameSettingDiscreteDataSourceBP* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzGameSettingDiscreteDataSourceBP>();
	}
};
static_assert(alignof(UGzGameSettingDiscreteDataSourceBP) == 0x000008, "Wrong alignment on UGzGameSettingDiscreteDataSourceBP");
static_assert(sizeof(UGzGameSettingDiscreteDataSourceBP) == 0x000028, "Wrong size on UGzGameSettingDiscreteDataSourceBP");

// Class G01.GzHitReactionInterface
// 0x0000 (0x0028 - 0x0028)
class IGzHitReactionInterface final : public IInterface
{
public:
	float CalculateHitReactionPowerValue(const float InPowerValue) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzHitReactionInterface">();
	}
	static class IGzHitReactionInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IGzHitReactionInterface>();
	}
};
static_assert(alignof(IGzHitReactionInterface) == 0x000008, "Wrong alignment on IGzHitReactionInterface");
static_assert(sizeof(IGzHitReactionInterface) == 0x000028, "Wrong size on IGzHitReactionInterface");

// Class G01.GzGameSettingScalarDataSourceBP
// 0x0000 (0x0028 - 0x0028)
class UGzGameSettingScalarDataSourceBP : public UObject
{
public:
	double GetValue();
	void SetValue(double NewValue);

	class UGzGameUserSettings* GetUserSettings() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzGameSettingScalarDataSourceBP">();
	}
	static class UGzGameSettingScalarDataSourceBP* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzGameSettingScalarDataSourceBP>();
	}
};
static_assert(alignof(UGzGameSettingScalarDataSourceBP) == 0x000008, "Wrong alignment on UGzGameSettingScalarDataSourceBP");
static_assert(sizeof(UGzGameSettingScalarDataSourceBP) == 0x000028, "Wrong size on UGzGameSettingScalarDataSourceBP");

// Class G01.GzGameSettingListView
// 0x0010 (0x0C80 - 0x0C70)
class UGzGameSettingListView final : public UListView
{
public:
	class UGzGameSettingVisualData*               VisualData;                                        // 0x0C70(0x0008)(Edit, ZeroConstructor, DisableEditOnTemplate, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_32B3[0x8];                                     // 0x0C78(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzGameSettingListView">();
	}
	static class UGzGameSettingListView* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzGameSettingListView>();
	}
};
static_assert(alignof(UGzGameSettingListView) == 0x000010, "Wrong alignment on UGzGameSettingListView");
static_assert(sizeof(UGzGameSettingListView) == 0x000C80, "Wrong size on UGzGameSettingListView");
static_assert(offsetof(UGzGameSettingListView, VisualData) == 0x000C70, "Member 'UGzGameSettingListView::VisualData' has a wrong offset!");

// Class G01.GzGameSettingPressAnyKey
// 0x0048 (0x0570 - 0x0528)
class UGzGameSettingPressAnyKey final : public UGzNavigationWidget
{
public:
	uint8                                         Pad_32B4[0x30];                                    // 0x0528(0x0030)(Fixing Size After Last Property [ Dumper-7 ])
	class UGzActionWidget*                        ActionWidget;                                      // 0x0558(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         CancelHoldDuration;                                // 0x0560(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_32B5[0xC];                                     // 0x0564(0x000C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzGameSettingPressAnyKey">();
	}
	static class UGzGameSettingPressAnyKey* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzGameSettingPressAnyKey>();
	}
};
static_assert(alignof(UGzGameSettingPressAnyKey) == 0x000008, "Wrong alignment on UGzGameSettingPressAnyKey");
static_assert(sizeof(UGzGameSettingPressAnyKey) == 0x000570, "Wrong size on UGzGameSettingPressAnyKey");
static_assert(offsetof(UGzGameSettingPressAnyKey, ActionWidget) == 0x000558, "Member 'UGzGameSettingPressAnyKey::ActionWidget' has a wrong offset!");
static_assert(offsetof(UGzGameSettingPressAnyKey, CancelHoldDuration) == 0x000560, "Member 'UGzGameSettingPressAnyKey::CancelHoldDuration' has a wrong offset!");

// Class G01.GzInventoryItemContentHelper
// 0x0028 (0x0050 - 0x0028)
class UGzInventoryItemContentHelper final : public UObject
{
public:
	class UGzItemData*                            ItemData;                                          // 0x0028(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UGzSkinItemData*                        SkinItemData;                                      // 0x0030(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class UGzItemData*>                    AttachmentItems;                                   // 0x0038(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	int32                                         Quantity;                                          // 0x0048(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_32B6[0x4];                                     // 0x004C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzInventoryItemContentHelper">();
	}
	static class UGzInventoryItemContentHelper* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzInventoryItemContentHelper>();
	}
};
static_assert(alignof(UGzInventoryItemContentHelper) == 0x000008, "Wrong alignment on UGzInventoryItemContentHelper");
static_assert(sizeof(UGzInventoryItemContentHelper) == 0x000050, "Wrong size on UGzInventoryItemContentHelper");
static_assert(offsetof(UGzInventoryItemContentHelper, ItemData) == 0x000028, "Member 'UGzInventoryItemContentHelper::ItemData' has a wrong offset!");
static_assert(offsetof(UGzInventoryItemContentHelper, SkinItemData) == 0x000030, "Member 'UGzInventoryItemContentHelper::SkinItemData' has a wrong offset!");
static_assert(offsetof(UGzInventoryItemContentHelper, AttachmentItems) == 0x000038, "Member 'UGzInventoryItemContentHelper::AttachmentItems' has a wrong offset!");
static_assert(offsetof(UGzInventoryItemContentHelper, Quantity) == 0x000048, "Member 'UGzInventoryItemContentHelper::Quantity' has a wrong offset!");

// Class G01.GzGameSettingRegistry
// 0x0108 (0x01B8 - 0x00B0)
class UGzGameSettingRegistry : public UGameSettingRegistry
{
public:
	TArray<class UGameSettingCollection*>         Collections;                                       // 0x00B0(0x0010)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	TArray<class UGzGameSettingCollectionDataAsset*> SettingCollections;                                // 0x00C0(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	class FText                                   ResetToDefaultText;                                // 0x00D0(0x0010)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	class UGzInputRemappingSettingsData*          InputRemappingData;                                // 0x00E0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FGzControllerRemappingData             GamepadRemappingData;                              // 0x00E8(0x0030)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	TSet<class UObject*>                          DataSources;                                       // 0x0118(0x0050)(Transient, NativeAccessSpecifierPrivate)
	uint8                                         Pad_32B7[0x50];                                    // 0x0168(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzGameSettingRegistry">();
	}
	static class UGzGameSettingRegistry* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzGameSettingRegistry>();
	}
};
static_assert(alignof(UGzGameSettingRegistry) == 0x000008, "Wrong alignment on UGzGameSettingRegistry");
static_assert(sizeof(UGzGameSettingRegistry) == 0x0001B8, "Wrong size on UGzGameSettingRegistry");
static_assert(offsetof(UGzGameSettingRegistry, Collections) == 0x0000B0, "Member 'UGzGameSettingRegistry::Collections' has a wrong offset!");
static_assert(offsetof(UGzGameSettingRegistry, SettingCollections) == 0x0000C0, "Member 'UGzGameSettingRegistry::SettingCollections' has a wrong offset!");
static_assert(offsetof(UGzGameSettingRegistry, ResetToDefaultText) == 0x0000D0, "Member 'UGzGameSettingRegistry::ResetToDefaultText' has a wrong offset!");
static_assert(offsetof(UGzGameSettingRegistry, InputRemappingData) == 0x0000E0, "Member 'UGzGameSettingRegistry::InputRemappingData' has a wrong offset!");
static_assert(offsetof(UGzGameSettingRegistry, GamepadRemappingData) == 0x0000E8, "Member 'UGzGameSettingRegistry::GamepadRemappingData' has a wrong offset!");
static_assert(offsetof(UGzGameSettingRegistry, DataSources) == 0x000118, "Member 'UGzGameSettingRegistry::DataSources' has a wrong offset!");

// Class G01.GzPickableBase
// 0x01E0 (0x0480 - 0x02A0)
#pragma pack(push, 0x1)
class alignas(0x10) AGzPickableBase : public AActor
{
public:
	uint8                                         Pad_32B8[0x10];                                    // 0x02A0(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGzPickableSpawnInfo                   SpawnInfo;                                         // 0x02B0(0x00D0)(BlueprintVisible, BlueprintReadOnly, Net, NativeAccessSpecifierPublic)
	TArray<struct FGzItemAttribute>               ItemAttributes;                                    // 0x0380(0x0010)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_32B9[0x18];                                    // 0x0390(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	class UGzInteractableComponent*               InteractableComponent;                             // 0x03A8(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UItemInteractionData*                   PickupData;                                        // 0x03B0(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UGzPickableEffectsComponent*            PickableEffectsComponent;                          // 0x03B8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UPhysicalMaterial*                      PhysicalMaterial;                                  // 0x03C0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UGzPhysicsSimulationSyncComponent*      PhysicsSyncComponent;                              // 0x03C8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EGzPickablePhysicsType                        PhysicsType;                                       // 0x03D0(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_32BA[0xF];                                     // 0x03D1(0x000F)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             TransformAfterSimulation;                          // 0x03E0(0x0060)(BlueprintVisible, BlueprintReadOnly, Net, Transient, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         DelayBeforeDestruction;                            // 0x0440(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         AngularDamping;                                    // 0x0444(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bUseCCD;                                           // 0x0448(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bLocationAdjusted;                                 // 0x0449(0x0001)(Net, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bDeferredDestructionStarted;                       // 0x044A(0x0001)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_32BB[0x5];                                     // 0x044B(0x0005)(Fixing Size After Last Property [ Dumper-7 ])
	FMulticastInlineDelegateProperty_             OnDeferredDestructionStarted;                      // 0x0450(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_32BC[0x18];                                    // 0x0460(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnInteract(class AActor* InteractedBy, const class UGzInteractableComponent* Interactable);
	void OnRep_bDeferredDestructionStarted();
	void OnRep_TransformAfterSimulation();
	void OnSettingsApplied();

	class UGzPickableEffectsComponent* GetEffectsComponent() const;
	class UGzInteractableComponent* GetInteractableComponent() const;
	struct FGzInvItem GetInventoryItem() const;
	struct FGzItemAttribute GetItemAttributeValue(const struct FGameplayTag& Tag, bool* OutSuccessful) const;
	struct FGzItemAttribute GetItemAttributeValueMax(const struct FGameplayTag& Tag, bool* OutSuccessful) const;
	class UGzItemData* GetItemData() const;
	class UMeshComponent* GetMeshComponent() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzPickableBase">();
	}
	static class AGzPickableBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<AGzPickableBase>();
	}
};
#pragma pack(pop)
static_assert(alignof(AGzPickableBase) == 0x000010, "Wrong alignment on AGzPickableBase");
static_assert(sizeof(AGzPickableBase) == 0x000480, "Wrong size on AGzPickableBase");
static_assert(offsetof(AGzPickableBase, SpawnInfo) == 0x0002B0, "Member 'AGzPickableBase::SpawnInfo' has a wrong offset!");
static_assert(offsetof(AGzPickableBase, ItemAttributes) == 0x000380, "Member 'AGzPickableBase::ItemAttributes' has a wrong offset!");
static_assert(offsetof(AGzPickableBase, InteractableComponent) == 0x0003A8, "Member 'AGzPickableBase::InteractableComponent' has a wrong offset!");
static_assert(offsetof(AGzPickableBase, PickupData) == 0x0003B0, "Member 'AGzPickableBase::PickupData' has a wrong offset!");
static_assert(offsetof(AGzPickableBase, PickableEffectsComponent) == 0x0003B8, "Member 'AGzPickableBase::PickableEffectsComponent' has a wrong offset!");
static_assert(offsetof(AGzPickableBase, PhysicalMaterial) == 0x0003C0, "Member 'AGzPickableBase::PhysicalMaterial' has a wrong offset!");
static_assert(offsetof(AGzPickableBase, PhysicsSyncComponent) == 0x0003C8, "Member 'AGzPickableBase::PhysicsSyncComponent' has a wrong offset!");
static_assert(offsetof(AGzPickableBase, PhysicsType) == 0x0003D0, "Member 'AGzPickableBase::PhysicsType' has a wrong offset!");
static_assert(offsetof(AGzPickableBase, TransformAfterSimulation) == 0x0003E0, "Member 'AGzPickableBase::TransformAfterSimulation' has a wrong offset!");
static_assert(offsetof(AGzPickableBase, DelayBeforeDestruction) == 0x000440, "Member 'AGzPickableBase::DelayBeforeDestruction' has a wrong offset!");
static_assert(offsetof(AGzPickableBase, AngularDamping) == 0x000444, "Member 'AGzPickableBase::AngularDamping' has a wrong offset!");
static_assert(offsetof(AGzPickableBase, bUseCCD) == 0x000448, "Member 'AGzPickableBase::bUseCCD' has a wrong offset!");
static_assert(offsetof(AGzPickableBase, bLocationAdjusted) == 0x000449, "Member 'AGzPickableBase::bLocationAdjusted' has a wrong offset!");
static_assert(offsetof(AGzPickableBase, bDeferredDestructionStarted) == 0x00044A, "Member 'AGzPickableBase::bDeferredDestructionStarted' has a wrong offset!");
static_assert(offsetof(AGzPickableBase, OnDeferredDestructionStarted) == 0x000450, "Member 'AGzPickableBase::OnDeferredDestructionStarted' has a wrong offset!");

// Class G01.GzGameSettingsConfig
// 0x0008 (0x0040 - 0x0038)
class UGzGameSettingsConfig final : public UDeveloperSettings
{
public:
	TSubclassOf<class UGzGameSettingRegistry>     SettingsRegistryClass;                             // 0x0038(0x0008)(Edit, ZeroConstructor, Config, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzGameSettingsConfig">();
	}
	static class UGzGameSettingsConfig* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzGameSettingsConfig>();
	}
};
static_assert(alignof(UGzGameSettingsConfig) == 0x000008, "Wrong alignment on UGzGameSettingsConfig");
static_assert(sizeof(UGzGameSettingsConfig) == 0x000040, "Wrong size on UGzGameSettingsConfig");
static_assert(offsetof(UGzGameSettingsConfig, SettingsRegistryClass) == 0x000038, "Member 'UGzGameSettingsConfig::SettingsRegistryClass' has a wrong offset!");

// Class G01.GzGameSettingVisualData
// 0x00A0 (0x00D0 - 0x0030)
class UGzGameSettingVisualData final : public UDataAsset
{
public:
	TMap<TSubclassOf<class UGameSettingCollection>, TSubclassOf<class UGzSettingsCollectionWidget>> CollectionWidgetClasses;                           // 0x0030(0x0050)(Edit, DisableEditOnInstance, UObjectWrapper, NativeAccessSpecifierPublic)
	TMap<TSubclassOf<class UGameSetting>, TSubclassOf<class UGzSettingEntryWidget>> SettingsWidgetClasses;                             // 0x0080(0x0050)(Edit, DisableEditOnInstance, UObjectWrapper, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzGameSettingVisualData">();
	}
	static class UGzGameSettingVisualData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzGameSettingVisualData>();
	}
};
static_assert(alignof(UGzGameSettingVisualData) == 0x000008, "Wrong alignment on UGzGameSettingVisualData");
static_assert(sizeof(UGzGameSettingVisualData) == 0x0000D0, "Wrong size on UGzGameSettingVisualData");
static_assert(offsetof(UGzGameSettingVisualData, CollectionWidgetClasses) == 0x000030, "Member 'UGzGameSettingVisualData::CollectionWidgetClasses' has a wrong offset!");
static_assert(offsetof(UGzGameSettingVisualData, SettingsWidgetClasses) == 0x000080, "Member 'UGzGameSettingVisualData::SettingsWidgetClasses' has a wrong offset!");

// Class G01.GzRenderItemIconsSettings
// 0x0280 (0x02B8 - 0x0038)
class UGzRenderItemIconsSettings final : public UDeveloperSettings
{
public:
	TMap<struct FGameplayTag, struct FGzItemSetting> CustomizationItemsSettings;                        // 0x0038(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, Config, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TMap<EGzWeaponAttachmentType, struct FGzWeaponAttachmentSetting> WeaponAttachmentItemsSettings;                     // 0x0088(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, Config, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TSet<struct FGameplayTag>                     CustomizationItemsToRender;                        // 0x00D8(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, Config, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TSet<EGzWeaponAttachmentType>                 WeaponAttachmentsToRender;                         // 0x0128(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, Config, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TSet<struct FGameplayTag>                     WeaponsToRender;                                   // 0x0178(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, Config, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TArray<TSoftObjectPtr<class UGzWeaponItemData>> WeaponsToRenderOverride;                           // 0x01C8(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, DisableEditOnInstance, UObjectWrapper, NativeAccessSpecifierPublic)
	TMap<struct FGameplayTag, struct FGzWeaponSetting> WeaponSettings;                                    // 0x01D8(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, Config, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TMap<struct FGameplayTag, struct FGzWeaponSetting> WeaponViewSettings;                                // 0x0228(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, Config, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FGzItemSetting                         DefaultItemSetting;                                // 0x0278(0x0038)(Edit, BlueprintVisible, BlueprintReadOnly, Config, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          bSavePNGs;                                         // 0x02B0(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSetInTexture;                                     // 0x02B1(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_32BF[0x2];                                     // 0x02B2(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         AdjustBrightness;                                  // 0x02B4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzRenderItemIconsSettings">();
	}
	static class UGzRenderItemIconsSettings* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzRenderItemIconsSettings>();
	}
};
static_assert(alignof(UGzRenderItemIconsSettings) == 0x000008, "Wrong alignment on UGzRenderItemIconsSettings");
static_assert(sizeof(UGzRenderItemIconsSettings) == 0x0002B8, "Wrong size on UGzRenderItemIconsSettings");
static_assert(offsetof(UGzRenderItemIconsSettings, CustomizationItemsSettings) == 0x000038, "Member 'UGzRenderItemIconsSettings::CustomizationItemsSettings' has a wrong offset!");
static_assert(offsetof(UGzRenderItemIconsSettings, WeaponAttachmentItemsSettings) == 0x000088, "Member 'UGzRenderItemIconsSettings::WeaponAttachmentItemsSettings' has a wrong offset!");
static_assert(offsetof(UGzRenderItemIconsSettings, CustomizationItemsToRender) == 0x0000D8, "Member 'UGzRenderItemIconsSettings::CustomizationItemsToRender' has a wrong offset!");
static_assert(offsetof(UGzRenderItemIconsSettings, WeaponAttachmentsToRender) == 0x000128, "Member 'UGzRenderItemIconsSettings::WeaponAttachmentsToRender' has a wrong offset!");
static_assert(offsetof(UGzRenderItemIconsSettings, WeaponsToRender) == 0x000178, "Member 'UGzRenderItemIconsSettings::WeaponsToRender' has a wrong offset!");
static_assert(offsetof(UGzRenderItemIconsSettings, WeaponsToRenderOverride) == 0x0001C8, "Member 'UGzRenderItemIconsSettings::WeaponsToRenderOverride' has a wrong offset!");
static_assert(offsetof(UGzRenderItemIconsSettings, WeaponSettings) == 0x0001D8, "Member 'UGzRenderItemIconsSettings::WeaponSettings' has a wrong offset!");
static_assert(offsetof(UGzRenderItemIconsSettings, WeaponViewSettings) == 0x000228, "Member 'UGzRenderItemIconsSettings::WeaponViewSettings' has a wrong offset!");
static_assert(offsetof(UGzRenderItemIconsSettings, DefaultItemSetting) == 0x000278, "Member 'UGzRenderItemIconsSettings::DefaultItemSetting' has a wrong offset!");
static_assert(offsetof(UGzRenderItemIconsSettings, bSavePNGs) == 0x0002B0, "Member 'UGzRenderItemIconsSettings::bSavePNGs' has a wrong offset!");
static_assert(offsetof(UGzRenderItemIconsSettings, bSetInTexture) == 0x0002B1, "Member 'UGzRenderItemIconsSettings::bSetInTexture' has a wrong offset!");
static_assert(offsetof(UGzRenderItemIconsSettings, AdjustBrightness) == 0x0002B4, "Member 'UGzRenderItemIconsSettings::AdjustBrightness' has a wrong offset!");

// Class G01.GzRootStage
// 0x0000 (0x0110 - 0x0110)
class UGzRootStage final : public UGzGameStageBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzRootStage">();
	}
	static class UGzRootStage* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzRootStage>();
	}
};
static_assert(alignof(UGzRootStage) == 0x000008, "Wrong alignment on UGzRootStage");
static_assert(sizeof(UGzRootStage) == 0x000110, "Wrong size on UGzRootStage");

// Class G01.GzGameStatTemplate
// 0x0070 (0x00A0 - 0x0030)
class UGzGameStatTemplate : public UPrimaryDataAsset
{
public:
	uint8                                         Pad_32C0[0x8];                                     // 0x0030(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   Key;                                               // 0x0038(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EGzStatSharingType                            SharingType;                                       // 0x0040(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_32C1[0x3];                                     // 0x0041(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         DefaultValue;                                      // 0x0044(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   PostMatchDisplayName;                              // 0x0048(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TSubclassOf<class UGzGameStatCollector>       StatCollectorType;                                 // 0x0058(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EGzGameStatCollectionStage                    CollectionStage;                                   // 0x0060(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_32C2[0x3];                                     // 0x0061(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         PlayerXpMultiplier;                                // 0x0064(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BattlePassXpMultiplier;                            // 0x0068(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CurrencyMultiplier;                                // 0x006C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CoinsMultiplier;                                   // 0x0070(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_32C3[0x4];                                     // 0x0074(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UGzStatRewardPolicy*                    RewardPolicy;                                      // 0x0078(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, PersistentInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UObject>                    HandleType;                                        // 0x0080(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class FString>                         HandleSubTypes;                                    // 0x0088(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	bool                                          bIsPostMatchStat;                                  // 0x0098(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShowInXPLog;                                      // 0x0099(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSubmitToBackend;                                  // 0x009A(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_32C4[0x5];                                     // 0x009B(0x0005)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	class FText GetStatDisplayName() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzGameStatTemplate">();
	}
	static class UGzGameStatTemplate* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzGameStatTemplate>();
	}
};
static_assert(alignof(UGzGameStatTemplate) == 0x000008, "Wrong alignment on UGzGameStatTemplate");
static_assert(sizeof(UGzGameStatTemplate) == 0x0000A0, "Wrong size on UGzGameStatTemplate");
static_assert(offsetof(UGzGameStatTemplate, Key) == 0x000038, "Member 'UGzGameStatTemplate::Key' has a wrong offset!");
static_assert(offsetof(UGzGameStatTemplate, SharingType) == 0x000040, "Member 'UGzGameStatTemplate::SharingType' has a wrong offset!");
static_assert(offsetof(UGzGameStatTemplate, DefaultValue) == 0x000044, "Member 'UGzGameStatTemplate::DefaultValue' has a wrong offset!");
static_assert(offsetof(UGzGameStatTemplate, PostMatchDisplayName) == 0x000048, "Member 'UGzGameStatTemplate::PostMatchDisplayName' has a wrong offset!");
static_assert(offsetof(UGzGameStatTemplate, StatCollectorType) == 0x000058, "Member 'UGzGameStatTemplate::StatCollectorType' has a wrong offset!");
static_assert(offsetof(UGzGameStatTemplate, CollectionStage) == 0x000060, "Member 'UGzGameStatTemplate::CollectionStage' has a wrong offset!");
static_assert(offsetof(UGzGameStatTemplate, PlayerXpMultiplier) == 0x000064, "Member 'UGzGameStatTemplate::PlayerXpMultiplier' has a wrong offset!");
static_assert(offsetof(UGzGameStatTemplate, BattlePassXpMultiplier) == 0x000068, "Member 'UGzGameStatTemplate::BattlePassXpMultiplier' has a wrong offset!");
static_assert(offsetof(UGzGameStatTemplate, CurrencyMultiplier) == 0x00006C, "Member 'UGzGameStatTemplate::CurrencyMultiplier' has a wrong offset!");
static_assert(offsetof(UGzGameStatTemplate, CoinsMultiplier) == 0x000070, "Member 'UGzGameStatTemplate::CoinsMultiplier' has a wrong offset!");
static_assert(offsetof(UGzGameStatTemplate, RewardPolicy) == 0x000078, "Member 'UGzGameStatTemplate::RewardPolicy' has a wrong offset!");
static_assert(offsetof(UGzGameStatTemplate, HandleType) == 0x000080, "Member 'UGzGameStatTemplate::HandleType' has a wrong offset!");
static_assert(offsetof(UGzGameStatTemplate, HandleSubTypes) == 0x000088, "Member 'UGzGameStatTemplate::HandleSubTypes' has a wrong offset!");
static_assert(offsetof(UGzGameStatTemplate, bIsPostMatchStat) == 0x000098, "Member 'UGzGameStatTemplate::bIsPostMatchStat' has a wrong offset!");
static_assert(offsetof(UGzGameStatTemplate, bShowInXPLog) == 0x000099, "Member 'UGzGameStatTemplate::bShowInXPLog' has a wrong offset!");
static_assert(offsetof(UGzGameStatTemplate, bSubmitToBackend) == 0x00009A, "Member 'UGzGameStatTemplate::bSubmitToBackend' has a wrong offset!");

// Class G01.GzGA_Tether
// 0x0038 (0x06B0 - 0x0678)
class UGzGA_Tether : public UGzGA_BaseLimbAbility
{
public:
	TSoftClassPtr<class UClass>                   TetherLinkClass;                                   // 0x0678(0x0028)(Edit, BlueprintVisible, DisableEditOnInstance, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class AGzTetherEnd*                           FirstTetherEnd;                                    // 0x06A0(0x0008)(BlueprintVisible, ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class AGzTetherEnd*                           SecondTetherEnd;                                   // 0x06A8(0x0008)(BlueprintVisible, ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	bool SpawnTetherLink();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzGA_Tether">();
	}
	static class UGzGA_Tether* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzGA_Tether>();
	}
};
static_assert(alignof(UGzGA_Tether) == 0x000008, "Wrong alignment on UGzGA_Tether");
static_assert(sizeof(UGzGA_Tether) == 0x0006B0, "Wrong size on UGzGA_Tether");
static_assert(offsetof(UGzGA_Tether, TetherLinkClass) == 0x000678, "Member 'UGzGA_Tether::TetherLinkClass' has a wrong offset!");
static_assert(offsetof(UGzGA_Tether, FirstTetherEnd) == 0x0006A0, "Member 'UGzGA_Tether::FirstTetherEnd' has a wrong offset!");
static_assert(offsetof(UGzGA_Tether, SecondTetherEnd) == 0x0006A8, "Member 'UGzGA_Tether::SecondTetherEnd' has a wrong offset!");

// Class G01.GzStatsProfile
// 0x0010 (0x0040 - 0x0030)
class UGzStatsProfile final : public UDataAsset
{
public:
	TArray<class UGzGameStatTemplate*>            Templates;                                         // 0x0030(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzStatsProfile">();
	}
	static class UGzStatsProfile* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzStatsProfile>();
	}
};
static_assert(alignof(UGzStatsProfile) == 0x000008, "Wrong alignment on UGzStatsProfile");
static_assert(sizeof(UGzStatsProfile) == 0x000040, "Wrong size on UGzStatsProfile");
static_assert(offsetof(UGzStatsProfile, Templates) == 0x000030, "Member 'UGzStatsProfile::Templates' has a wrong offset!");

// Class G01.GzGameUserSettings
// 0x01F0 (0x0338 - 0x0148)
class UGzGameUserSettings final : public UGameUserSettings
{
public:
	uint8                                         Pad_32C5[0x50];                                    // 0x0148(0x0050)(Fixing Size After Last Property [ Dumper-7 ])
	FMulticastInlineDelegateProperty_             OnSettingsApplied;                                 // 0x0198(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnSettingsDirty;                                   // 0x01A8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_32C6[0x180];                                   // 0x01B8(0x0180)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ApplyAndSaveSettings(bool bCheckForConsoleOverrides);
	class FString GetAudioPresetName();
	class FString GetPersonalAssistantVoiceType();
	void SaveNonVideoSettings();
	void SetAcesGamutCompression(const float InGamutCompression);
	void SetAcesSceneColorMultiplier(const float InAcesSceneColorMultiplier);
	void SetAimAssistPreset(const class FString& InAimAssistPreset);
	void SetAlignMinimap(const bool bInAlignMinimap);
	void SetAntiAliasingMethod(int32 Value);
	void SetAudioPresetName(const class FString& InAudioPresetName);
	void SetAutoLoginEnabled(bool Value);
	void SetAutomaticallyConnectToHostHideout(bool Value);
	void SetAutoPickUpEnabled(bool Value);
	void SetCharacterVoiceVolumeScale(float NewScaleFactor);
	void SetColorVisionDeficiency(EColorVisionDeficiency InDeficiency);
	void SetDeadZone(const float InDeadZone);
	void SetDevNotificationsEnabled(bool Value);
	void SetDisplayGamma(float InGamma);
	void SetDisplayIndex(int32 Value);
	void SetEnableAdaptiveTriggers(bool bInEnable);
	void SetEnableHapticsFeedback(bool bInEnable);
	void SetFullCatalogAccessEnabled(bool Value);
	void SetGameMeshMinLODQuality(int32 InQuality);
	void SetGamepadHorizontalAimSensitivityScale(float InGamepadHorizontalAimSensitivityScale);
	void SetGamepadHorizontalLookSensitivityScale(float InGamepadHorizontalLookSensitivityScale);
	void SetGamepadHorizontalSnipeSensitivityScale(float InGamepadHorizontalSnipeSensitivityScale);
	void SetGamepadVerticalAimSensitivityScale(float InGamepadVerticalAimSensitivityScaleFactor);
	void SetGamepadVerticalLookSensitivityScale(float InGamepadVerticalLookSensitivityScale);
	void SetGamepadVerticalSnipeSensitivityScale(float InGamepadVerticalSnipeSensitivityScale);
	void SetGzAntiAliasingQuality(int32 Value);
	void SetGzFoliageQuality(int32 Value);
	void SetGzFrameRateLimit(float NewLimit);
	void SetGzFullscreenMode(EWindowMode InFullscreenMode);
	void SetGzGlobalIlluminationQuality(int32 Value);
	void SetGzOverallScalabilityLevel(int32 Value);
	void SetGzPostProcessingQuality(int32 Value);
	void SetGzReflectionQuality(int32 Value);
	void SetGzScreenResolution(const struct FIntPoint& Resolution);
	void SetGzShadingQuality(int32 Value);
	void SetGzShadowQuality(int32 Value);
	void SetGzTextureQuality(int32 Value);
	void SetGzViewDistanceQuality(int32 Value);
	void SetGzVisualEffectQuality(int32 Value);
	void SetGzVSyncEnabled(bool bEnabled);
	void SetHardwareRayTracingEnabled(const bool bInHardwareRayTracingEnabled);
	void SetHDROutputEnabled(bool bEnable);
	void SetHDRUiLevel(float InHDRUiLevel);
	void SetHideoutMeshMinLODQuality(int32 InQuality);
	void SetHorizontalAimSensitivityScaleFactor(float NewScaleFactor);
	void SetHorizontalInputInverted(bool bInverted);
	void SetHorizontalLookSensitivityScaleFactor(float NewScaleFactor);
	void SetHorizontalSnipeSensitivityScaleFactor(float NewScaleFactor);
	void SetIsAdvancedKeyBindings(bool bIsAdvanced);
	void SetLanguage(const class FString& LanguageId);
	void SetLootBeamsEnabled(bool Value);
	void SetMainVolumeScale(float NewScaleFactor);
	void SetMatchStateAnnouncerVolumeScale(float NewScaleFactor);
	void SetMicrophoneSensitivity(float Value);
	void SetMidLuminance(const float InMidLuminance);
	void SetMinLuminanceLog10(const float InMinLuminanceLog10);
	void SetMotionBlurActive(bool bActive);
	void SetMusicVolumeScale(float NewScaleFactor);
	void SetMuteAudioWhenUnfocused(bool bMute);
	void SetPerformanceStatsEnabled(const bool bEnabled);
	void SetPersonalAssistantVoiceType(const class FString& InPersonalAssistantVoiceType);
	void SetPersonalAssistantVolumeScale(float NewScaleFactor);
	void SetQualityMode(bool bInIsPerformanceMode);
	void SetResolutionScaleValue(float Value);
	void SetResolutionScalingMethod(const class FString& ScalingMethod);
	void SetSfxVolumeScale(float NewScaleFactor);
	void SetShowLobbyOldScreenEffect(bool bInShowOldScreenEffect);
	void SetSidearmAmmoAutoPickUpEnabled(bool Value);
	void SetToggleAimingMode(bool bToggle);
	void SetToggleSprint(bool bToggle);
	void SetUIAspectRatio(const float Ratio);
	void SetVerticalAimSensitivityScaleFactor(float NewScaleFactor);
	void SetVerticalInputInverted(bool bInverted);
	void SetVerticalLookSensitivityScaleFactor(float NewScaleFactor);
	void SetVerticalSnipeSensitivityScaleFactor(float NewScaleFactor);
	void SetVoiceChatInputDeviceId(const class FString& DeviceID);
	void SetVoiceChatOutputDeviceId(const class FString& DeviceID);
	void SetVoiceChatState(EGzVoiceChatState NewValue);
	void SetVoiceChatVolumeScale(float NewScaleFactor);
	void SetVovVolumeScale(float NewScaleFactor);
	void ShowDamageNumbers(bool bInShowDamageNumbers);
	void ShowShowComparisonTooltip(bool bInShowComparisonTooltip);

	bool AreLootBeamsEnabled() const;
	bool ArePerformanceStatsEnabled() const;
	bool AreSettingsDirty() const;
	bool AreVideoSettingsDirty() const;
	float GetAcesGamutCompression() const;
	float GetAcesSceneColorMultiplier() const;
	struct FIntPoint GetActiveMonitorResolution() const;
	class FString GetAimAssistPreset() const;
	int32 GetAntialiasingMethod() const;
	bool GetAutoLoginEnabled() const;
	bool GetAutomaticallyConnectToHostHideout() const;
	bool GetAutoPickUpEnabled() const;
	float GetCharacterVoiceVolumeScale() const;
	EColorVisionDeficiency GetColorVisionDeficiency() const;
	class FString GetCurrentLanguage() const;
	float GetDeadZone() const;
	bool GetDevNotificationsEnabled() const;
	float GetDisplayGamma() const;
	int32 GetDisplayIndex() const;
	bool GetEnableAdaptiveTriggers() const;
	bool GetEnableHapticsFeedback() const;
	bool GetFullCatalogAccessEnabled() const;
	int32 GetGameMeshMinLODQuality() const;
	float GetGamepadHorizontalAimSensitivityScale() const;
	float GetGamepadHorizontalLookSensitivityScale() const;
	float GetGamepadHorizontalSnipeSensitivityScale() const;
	const struct FGameplayTag GetGamepadProfileIdentifier() const;
	float GetGamepadVerticalAimSensitivityScale() const;
	float GetGamepadVerticalLookSensitivityScale() const;
	float GetGamepadVerticalSnipeSensitivityScale() const;
	float GetHDRUILevel() const;
	int32 GetHideoutMeshMinLODQuality() const;
	float GetHorizontalAimSensitivityScaleFactor() const;
	float GetHorizontalLookSensitivityScaleFactor() const;
	float GetHorizontalSnipeSensitivityScaleFactor() const;
	bool GetIsAdvancedKeyBindings() const;
	TArray<class FString> GetLanguages() const;
	int32 GetLastConfirmedDisplayIndex() const;
	float GetMainVolumeScale() const;
	float GetMatchStateAnnouncerVolumeScale() const;
	float GetMicrophoneSensitivity() const;
	float GetMidLuminance() const;
	float GetMinLuminanceLog10() const;
	float GetMusicVolumeScale() const;
	bool GetMuteAudioWhenUnfocused() const;
	float GetPersonalAssistantVolumeScale() const;
	float GetResolutionScaleValue() const;
	class FString GetResolutionScalingMethod() const;
	float GetSfxVolumeScale() const;
	bool GetShowLobbyOldScreenEffect() const;
	bool GetSidearmAmmoAutoPickUpEnabled() const;
	float GetUIAspectRatio() const;
	float GetVerticalAimSensitivityScaleFactor() const;
	float GetVerticalLookSensitivityScaleFactor() const;
	float GetVerticalSnipeSensitivityScaleFactor() const;
	class FString GetVoiceChatInputDeviceId() const;
	class FString GetVoiceChatOutputDeviceId() const;
	EGzVoiceChatState GetVoiceChatState() const;
	float GetVoiceChatVolumeScale() const;
	float GetVovVolumeScale() const;
	bool HasMonitorChanged() const;
	bool IsAlignMinimap() const;
	bool IsDLSSSupported() const;
	bool IsHardwareRayTracingEnabled() const;
	bool IsHDROutputEnabled() const;
	bool IsHorizontalInputInverted() const;
	bool IsMotionBlurActive() const;
	bool IsPerformanceMode() const;
	bool IsToggleAimingMode() const;
	bool IsToggleSprintMode() const;
	bool IsVerticalInputInverted() const;
	bool ShouldShowComparisonTooltip() const;
	bool ShouldShowDamageNumbers() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzGameUserSettings">();
	}
	static class UGzGameUserSettings* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzGameUserSettings>();
	}
};
static_assert(alignof(UGzGameUserSettings) == 0x000008, "Wrong alignment on UGzGameUserSettings");
static_assert(sizeof(UGzGameUserSettings) == 0x000338, "Wrong size on UGzGameUserSettings");
static_assert(offsetof(UGzGameUserSettings, OnSettingsApplied) == 0x000198, "Member 'UGzGameUserSettings::OnSettingsApplied' has a wrong offset!");
static_assert(offsetof(UGzGameUserSettings, OnSettingsDirty) == 0x0001A8, "Member 'UGzGameUserSettings::OnSettingsDirty' has a wrong offset!");

// Class G01.GzGameViewportClient
// 0x0000 (0x03F0 - 0x03F0)
class UGzGameViewportClient final : public UCommonGameViewportClient
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzGameViewportClient">();
	}
	static class UGzGameViewportClient* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzGameViewportClient>();
	}
};
static_assert(alignof(UGzGameViewportClient) == 0x000008, "Wrong alignment on UGzGameViewportClient");
static_assert(sizeof(UGzGameViewportClient) == 0x0003F0, "Wrong size on UGzGameViewportClient");

// Class G01.GzGateObjective
// 0x0018 (0x0078 - 0x0060)
class UGzGateObjective final : public UGzObjective
{
public:
	class UGzCondition*                           Condition;                                         // 0x0060(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UGzObjective*                           Objective;                                         // 0x0068(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_32C7[0x8];                                     // 0x0070(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UGzObjective* MakeUntilObjective(class AGzAdvancedMission* Mission, class UGzCondition* Param_Condition, class UGzObjective* Param_Objective);
	static class UGzObjective* MakeWhileObjective(class AGzAdvancedMission* Mission, class UGzCondition* Param_Condition, class UGzObjective* Param_Objective);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzGateObjective">();
	}
	static class UGzGateObjective* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzGateObjective>();
	}
};
static_assert(alignof(UGzGateObjective) == 0x000008, "Wrong alignment on UGzGateObjective");
static_assert(sizeof(UGzGateObjective) == 0x000078, "Wrong size on UGzGateObjective");
static_assert(offsetof(UGzGateObjective, Condition) == 0x000060, "Member 'UGzGateObjective::Condition' has a wrong offset!");
static_assert(offsetof(UGzGateObjective, Objective) == 0x000068, "Member 'UGzGateObjective::Objective' has a wrong offset!");

// Class G01.GzStaticAkComponent
// 0x0000 (0x0440 - 0x0440)
class UGzStaticAkComponent final : public UAkComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzStaticAkComponent">();
	}
	static class UGzStaticAkComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzStaticAkComponent>();
	}
};
static_assert(alignof(UGzStaticAkComponent) == 0x000010, "Wrong alignment on UGzStaticAkComponent");
static_assert(sizeof(UGzStaticAkComponent) == 0x000440, "Wrong size on UGzStaticAkComponent");

// Class G01.GzMissionMarker
// 0x0030 (0x02D0 - 0x02A0)
class AGzMissionMarker : public AActor
{
public:
	FMulticastInlineDelegateProperty_             OnVisibilityChanged;                               // 0x02A0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	bool                                          bVisible;                                          // 0x02B0(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_32C8[0x7];                                     // 0x02B1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   MarkerText;                                        // 0x02B8(0x0010)(Edit, BlueprintVisible, Protected, ExposeOnSpawn, NativeAccessSpecifierProtected)
	bool                                          bInitialised;                                      // 0x02C8(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_32C9[0x7];                                     // 0x02C9(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Hide();
	void OnHide();
	void OnShow();
	void SetMarkerLocation(const struct FVector& Location);
	void SetMarkerTargetAttached(class AActor* Target, const struct FVector& Offset);
	void SetMarkerTargetLocation(const class AActor* Target, const struct FVector& Offset);
	void SetVisibility(bool bNewVisibility);
	void Show();
	void TriggerDestroy();

	bool IsVisible() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzMissionMarker">();
	}
	static class AGzMissionMarker* GetDefaultObj()
	{
		return GetDefaultObjImpl<AGzMissionMarker>();
	}
};
static_assert(alignof(AGzMissionMarker) == 0x000008, "Wrong alignment on AGzMissionMarker");
static_assert(sizeof(AGzMissionMarker) == 0x0002D0, "Wrong size on AGzMissionMarker");
static_assert(offsetof(AGzMissionMarker, OnVisibilityChanged) == 0x0002A0, "Member 'AGzMissionMarker::OnVisibilityChanged' has a wrong offset!");
static_assert(offsetof(AGzMissionMarker, bVisible) == 0x0002B0, "Member 'AGzMissionMarker::bVisible' has a wrong offset!");
static_assert(offsetof(AGzMissionMarker, MarkerText) == 0x0002B8, "Member 'AGzMissionMarker::MarkerText' has a wrong offset!");
static_assert(offsetof(AGzMissionMarker, bInitialised) == 0x0002C8, "Member 'AGzMissionMarker::bInitialised' has a wrong offset!");

// Class G01.GzGA_BaseLimbInteraction
// 0x0108 (0x0658 - 0x0550)
class UGzGA_BaseLimbInteraction : public UGzGA_CharacterState
{
public:
	EGzLimbType                                   LimbType;                                          // 0x0550(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_32CA[0x7];                                     // 0x0551(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UGzLimbInteractionData*                 SetupData;                                         // 0x0558(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TMap<EGzLimbType, class UAnimMontage*>        MontagesByLimbType;                                // 0x0560(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	class UGzAT_PlayMontageAndWaitForEvent*       PlayMontageAndWaitForEventTask_LimbInteraction;    // 0x05B0(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TMap<EGzLimbType, TSubclassOf<class UGameplayEffect>> OnAttachSuccessEffectMap;                          // 0x05B8(0x0050)(Edit, BlueprintVisible, DisableEditOnInstance, Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	TMap<EGzLimbType, TSubclassOf<class UGameplayEffect>> OnAttachFailedEffectMap;                           // 0x0608(0x0050)(Edit, BlueprintVisible, DisableEditOnInstance, Protected, UObjectWrapper, NativeAccessSpecifierProtected)

public:
	void OnMontageNotify(const class FName NotifyName);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzGA_BaseLimbInteraction">();
	}
	static class UGzGA_BaseLimbInteraction* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzGA_BaseLimbInteraction>();
	}
};
static_assert(alignof(UGzGA_BaseLimbInteraction) == 0x000008, "Wrong alignment on UGzGA_BaseLimbInteraction");
static_assert(sizeof(UGzGA_BaseLimbInteraction) == 0x000658, "Wrong size on UGzGA_BaseLimbInteraction");
static_assert(offsetof(UGzGA_BaseLimbInteraction, LimbType) == 0x000550, "Member 'UGzGA_BaseLimbInteraction::LimbType' has a wrong offset!");
static_assert(offsetof(UGzGA_BaseLimbInteraction, SetupData) == 0x000558, "Member 'UGzGA_BaseLimbInteraction::SetupData' has a wrong offset!");
static_assert(offsetof(UGzGA_BaseLimbInteraction, MontagesByLimbType) == 0x000560, "Member 'UGzGA_BaseLimbInteraction::MontagesByLimbType' has a wrong offset!");
static_assert(offsetof(UGzGA_BaseLimbInteraction, PlayMontageAndWaitForEventTask_LimbInteraction) == 0x0005B0, "Member 'UGzGA_BaseLimbInteraction::PlayMontageAndWaitForEventTask_LimbInteraction' has a wrong offset!");
static_assert(offsetof(UGzGA_BaseLimbInteraction, OnAttachSuccessEffectMap) == 0x0005B8, "Member 'UGzGA_BaseLimbInteraction::OnAttachSuccessEffectMap' has a wrong offset!");
static_assert(offsetof(UGzGA_BaseLimbInteraction, OnAttachFailedEffectMap) == 0x000608, "Member 'UGzGA_BaseLimbInteraction::OnAttachFailedEffectMap' has a wrong offset!");

// Class G01.GzMissionAction_GrantMission
// 0x0010 (0x0060 - 0x0050)
class UGzMissionAction_GrantMission final : public UMissionAction
{
public:
	class UGzMissionData*                         MissionToGrant;                                    // 0x0050(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EGzGrantMissionTarget                         WhomToGrantTo;                                     // 0x0058(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_32CB[0x7];                                     // 0x0059(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzMissionAction_GrantMission">();
	}
	static class UGzMissionAction_GrantMission* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzMissionAction_GrantMission>();
	}
};
static_assert(alignof(UGzMissionAction_GrantMission) == 0x000008, "Wrong alignment on UGzMissionAction_GrantMission");
static_assert(sizeof(UGzMissionAction_GrantMission) == 0x000060, "Wrong size on UGzMissionAction_GrantMission");
static_assert(offsetof(UGzMissionAction_GrantMission, MissionToGrant) == 0x000050, "Member 'UGzMissionAction_GrantMission::MissionToGrant' has a wrong offset!");
static_assert(offsetof(UGzMissionAction_GrantMission, WhomToGrantTo) == 0x000058, "Member 'UGzMissionAction_GrantMission::WhomToGrantTo' has a wrong offset!");

// Class G01.GzGA_AttachLimb
// 0x0058 (0x06B0 - 0x0658)
class UGzGA_AttachLimb : public UGzGA_BaseLimbInteraction
{
public:
	struct FGzLimbAttachingParams                 Params;                                            // 0x0658(0x0040)(Edit, BlueprintVisible, DisableEditOnInstance, NoDestructor, Protected, NativeAccessSpecifierProtected)
	class UGzAT_AttachLimb*                       AttachLimbTask;                                    // 0x0698(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UGzBodyPartItemData*                    BodyPartItemData;                                  // 0x06A0(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_32CC[0x8];                                     // 0x06A8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void InitiateCancelByPlayer() const;
	void RecallCancelByPlayer() const;
	void SendLimbAttachedMessage() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzGA_AttachLimb">();
	}
	static class UGzGA_AttachLimb* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzGA_AttachLimb>();
	}
};
static_assert(alignof(UGzGA_AttachLimb) == 0x000008, "Wrong alignment on UGzGA_AttachLimb");
static_assert(sizeof(UGzGA_AttachLimb) == 0x0006B0, "Wrong size on UGzGA_AttachLimb");
static_assert(offsetof(UGzGA_AttachLimb, Params) == 0x000658, "Member 'UGzGA_AttachLimb::Params' has a wrong offset!");
static_assert(offsetof(UGzGA_AttachLimb, AttachLimbTask) == 0x000698, "Member 'UGzGA_AttachLimb::AttachLimbTask' has a wrong offset!");
static_assert(offsetof(UGzGA_AttachLimb, BodyPartItemData) == 0x0006A0, "Member 'UGzGA_AttachLimb::BodyPartItemData' has a wrong offset!");

// Class G01.GzPositiveCondition
// 0x0000 (0x0060 - 0x0060)
class UGzPositiveCondition final : public UGzCondition
{
public:
	static class UGzCondition* MakePositiveCondition(class AGzAdvancedMission* Mission);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzPositiveCondition">();
	}
	static class UGzPositiveCondition* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzPositiveCondition>();
	}
};
static_assert(alignof(UGzPositiveCondition) == 0x000008, "Wrong alignment on UGzPositiveCondition");
static_assert(sizeof(UGzPositiveCondition) == 0x000060, "Wrong size on UGzPositiveCondition");

// Class G01.GzGA_AutoWeaponReload
// 0x0000 (0x0570 - 0x0570)
class UGzGA_AutoWeaponReload : public UGzGA_WeaponReload
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzGA_AutoWeaponReload">();
	}
	static class UGzGA_AutoWeaponReload* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzGA_AutoWeaponReload>();
	}
};
static_assert(alignof(UGzGA_AutoWeaponReload) == 0x000008, "Wrong alignment on UGzGA_AutoWeaponReload");
static_assert(sizeof(UGzGA_AutoWeaponReload) == 0x000570, "Wrong size on UGzGA_AutoWeaponReload");

// Class G01.GzLimbInteractionData
// 0x0060 (0x0090 - 0x0030)
class UGzLimbInteractionData final : public UDataAsset
{
public:
	TMap<EGzLimbType, struct FGzLimbStateTagsSettings> LimbStateTagsByLimbType;                           // 0x0030(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TArray<struct FGzLimbStateTags>               LimbStateByLimbMasks;                              // 0x0080(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzLimbInteractionData">();
	}
	static class UGzLimbInteractionData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzLimbInteractionData>();
	}
};
static_assert(alignof(UGzLimbInteractionData) == 0x000008, "Wrong alignment on UGzLimbInteractionData");
static_assert(sizeof(UGzLimbInteractionData) == 0x000090, "Wrong size on UGzLimbInteractionData");
static_assert(offsetof(UGzLimbInteractionData, LimbStateTagsByLimbType) == 0x000030, "Member 'UGzLimbInteractionData::LimbStateTagsByLimbType' has a wrong offset!");
static_assert(offsetof(UGzLimbInteractionData, LimbStateByLimbMasks) == 0x000080, "Member 'UGzLimbInteractionData::LimbStateByLimbMasks' has a wrong offset!");

// Class G01.GzAT_AttachLimb
// 0x00A0 (0x0120 - 0x0080)
class UGzAT_AttachLimb final : public UAbilityTask
{
public:
	uint8                                         Pad_32CD[0x30];                                    // 0x0080(0x0030)(Fixing Size After Last Property [ Dumper-7 ])
	class AGzMultiPartCharacter*                  Character;                                         // 0x00B0(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UGzBodyPartItemData*                    BodyPartItemData;                                  // 0x00B8(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class AGzLimbPickable*                        LimbPickable;                                      // 0x00C0(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSubclassOf<class AGzLimbAttachingReplica>    LimbProxyClass;                                    // 0x00C8(0x0008)(ZeroConstructor, Transient, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class AGzLimbAttachingReplica*                LimbReplica;                                       // 0x00D0(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_32CE[0x48];                                    // 0x00D8(0x0048)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzAT_AttachLimb">();
	}
	static class UGzAT_AttachLimb* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzAT_AttachLimb>();
	}
};
static_assert(alignof(UGzAT_AttachLimb) == 0x000008, "Wrong alignment on UGzAT_AttachLimb");
static_assert(sizeof(UGzAT_AttachLimb) == 0x000120, "Wrong size on UGzAT_AttachLimb");
static_assert(offsetof(UGzAT_AttachLimb, Character) == 0x0000B0, "Member 'UGzAT_AttachLimb::Character' has a wrong offset!");
static_assert(offsetof(UGzAT_AttachLimb, BodyPartItemData) == 0x0000B8, "Member 'UGzAT_AttachLimb::BodyPartItemData' has a wrong offset!");
static_assert(offsetof(UGzAT_AttachLimb, LimbPickable) == 0x0000C0, "Member 'UGzAT_AttachLimb::LimbPickable' has a wrong offset!");
static_assert(offsetof(UGzAT_AttachLimb, LimbProxyClass) == 0x0000C8, "Member 'UGzAT_AttachLimb::LimbProxyClass' has a wrong offset!");
static_assert(offsetof(UGzAT_AttachLimb, LimbReplica) == 0x0000D0, "Member 'UGzAT_AttachLimb::LimbReplica' has a wrong offset!");

// Class G01.GzShrinkingZone
// 0x0098 (0x0338 - 0x02A0)
class AGzShrinkingZone : public AActor
{
public:
	uint8                                         Pad_32CF[0x18];                                    // 0x02A0(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	class UProceduralMeshComponent*               ZoneMesh;                                          // 0x02B8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UGzShrinkingZoneAkComponent*            ZoneAkComponent;                                   // 0x02C0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UMaterialInterface*                     Material;                                          // 0x02C8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         MeshHeight;                                        // 0x02D0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         MaxDistanceBetweenPoints;                          // 0x02D4(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         MinPoints;                                         // 0x02D8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         MaxPoints;                                         // 0x02DC(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FGzShrinkingParams                     ShrinkingParams;                                   // 0x02E0(0x0038)(Net, RepNotify, NoDestructor, NativeAccessSpecifierPrivate)
	uint8                                         Pad_32D0[0x20];                                    // 0x0318(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Init(const struct FGzCircle2D& InInitialCircle);
	void OnRep_ShrinkingParams();
	void SetTarget(const struct FGzCircle2D& InTargetCircle, float Time);

	const struct FGzCircle2D GetCurrentCircle() const;
	float GetShrinkingTime() const;
	const struct FGzCircle2D GetTargetCircle() const;
	void OnCurrentCircleChanged(const struct FGzCircle2D& NewCurrentCircle) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzShrinkingZone">();
	}
	static class AGzShrinkingZone* GetDefaultObj()
	{
		return GetDefaultObjImpl<AGzShrinkingZone>();
	}
};
static_assert(alignof(AGzShrinkingZone) == 0x000008, "Wrong alignment on AGzShrinkingZone");
static_assert(sizeof(AGzShrinkingZone) == 0x000338, "Wrong size on AGzShrinkingZone");
static_assert(offsetof(AGzShrinkingZone, ZoneMesh) == 0x0002B8, "Member 'AGzShrinkingZone::ZoneMesh' has a wrong offset!");
static_assert(offsetof(AGzShrinkingZone, ZoneAkComponent) == 0x0002C0, "Member 'AGzShrinkingZone::ZoneAkComponent' has a wrong offset!");
static_assert(offsetof(AGzShrinkingZone, Material) == 0x0002C8, "Member 'AGzShrinkingZone::Material' has a wrong offset!");
static_assert(offsetof(AGzShrinkingZone, MeshHeight) == 0x0002D0, "Member 'AGzShrinkingZone::MeshHeight' has a wrong offset!");
static_assert(offsetof(AGzShrinkingZone, MaxDistanceBetweenPoints) == 0x0002D4, "Member 'AGzShrinkingZone::MaxDistanceBetweenPoints' has a wrong offset!");
static_assert(offsetof(AGzShrinkingZone, MinPoints) == 0x0002D8, "Member 'AGzShrinkingZone::MinPoints' has a wrong offset!");
static_assert(offsetof(AGzShrinkingZone, MaxPoints) == 0x0002DC, "Member 'AGzShrinkingZone::MaxPoints' has a wrong offset!");
static_assert(offsetof(AGzShrinkingZone, ShrinkingParams) == 0x0002E0, "Member 'AGzShrinkingZone::ShrinkingParams' has a wrong offset!");

// Class G01.GzAT_DetachLimb
// 0x0080 (0x0100 - 0x0080)
class UGzAT_DetachLimb final : public UAbilityTask
{
public:
	uint8                                         Pad_32D2[0x10];                                    // 0x0080(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class AGzMultiPartCharacter*                  Character;                                         // 0x0090(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UGzLimbComponent*                       LimbComponent;                                     // 0x0098(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_32D3[0x60];                                    // 0x00A0(0x0060)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzAT_DetachLimb">();
	}
	static class UGzAT_DetachLimb* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzAT_DetachLimb>();
	}
};
static_assert(alignof(UGzAT_DetachLimb) == 0x000008, "Wrong alignment on UGzAT_DetachLimb");
static_assert(sizeof(UGzAT_DetachLimb) == 0x000100, "Wrong size on UGzAT_DetachLimb");
static_assert(offsetof(UGzAT_DetachLimb, Character) == 0x000090, "Member 'UGzAT_DetachLimb::Character' has a wrong offset!");
static_assert(offsetof(UGzAT_DetachLimb, LimbComponent) == 0x000098, "Member 'UGzAT_DetachLimb::LimbComponent' has a wrong offset!");

// Class G01.GzSA_CameraMode
// 0x0010 (0x0048 - 0x0038)
class UGzSA_CameraMode final : public UGzStateAction
{
public:
	struct FGameplayTag                           CameraModeTag;                                     // 0x0038(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bApplyCameraModeWithInterpolation;                 // 0x0040(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_32D4[0x7];                                     // 0x0041(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzSA_CameraMode">();
	}
	static class UGzSA_CameraMode* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzSA_CameraMode>();
	}
};
static_assert(alignof(UGzSA_CameraMode) == 0x000008, "Wrong alignment on UGzSA_CameraMode");
static_assert(sizeof(UGzSA_CameraMode) == 0x000048, "Wrong size on UGzSA_CameraMode");
static_assert(offsetof(UGzSA_CameraMode, CameraModeTag) == 0x000038, "Member 'UGzSA_CameraMode::CameraModeTag' has a wrong offset!");
static_assert(offsetof(UGzSA_CameraMode, bApplyCameraModeWithInterpolation) == 0x000040, "Member 'UGzSA_CameraMode::bApplyCameraModeWithInterpolation' has a wrong offset!");

// Class G01.GzGA_BoostSlide
// 0x0060 (0x0568 - 0x0508)
class UGzGA_BoostSlide : public UGzGameplayAbility
{
public:
	float                                         SpeedThreshold;                                    // 0x0508(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MaxSlideTime;                                      // 0x050C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FGzSlideParams                         Params;                                            // 0x0510(0x0038)(Edit, DisableEditOnInstance, NoDestructor, Protected, NativeAccessSpecifierProtected)
	class UAnimMontage*                           EndMontage;                                        // 0x0548(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UGzAT_PlayMontageAndWaitForEvent*       PlayMontageAndWaitForEventTask;                    // 0x0550(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UGzAT_WaitSlideEndConditionsMeet*       WaitSlideEndConditionTask;                         // 0x0558(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UGzAT_AbilityTick*                      SlideTickTask;                                     // 0x0560(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void OnSlideConditionsEnds();
	void OnTickTaskEnds(bool bWasCompleted);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzGA_BoostSlide">();
	}
	static class UGzGA_BoostSlide* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzGA_BoostSlide>();
	}
};
static_assert(alignof(UGzGA_BoostSlide) == 0x000008, "Wrong alignment on UGzGA_BoostSlide");
static_assert(sizeof(UGzGA_BoostSlide) == 0x000568, "Wrong size on UGzGA_BoostSlide");
static_assert(offsetof(UGzGA_BoostSlide, SpeedThreshold) == 0x000508, "Member 'UGzGA_BoostSlide::SpeedThreshold' has a wrong offset!");
static_assert(offsetof(UGzGA_BoostSlide, MaxSlideTime) == 0x00050C, "Member 'UGzGA_BoostSlide::MaxSlideTime' has a wrong offset!");
static_assert(offsetof(UGzGA_BoostSlide, Params) == 0x000510, "Member 'UGzGA_BoostSlide::Params' has a wrong offset!");
static_assert(offsetof(UGzGA_BoostSlide, EndMontage) == 0x000548, "Member 'UGzGA_BoostSlide::EndMontage' has a wrong offset!");
static_assert(offsetof(UGzGA_BoostSlide, PlayMontageAndWaitForEventTask) == 0x000550, "Member 'UGzGA_BoostSlide::PlayMontageAndWaitForEventTask' has a wrong offset!");
static_assert(offsetof(UGzGA_BoostSlide, WaitSlideEndConditionTask) == 0x000558, "Member 'UGzGA_BoostSlide::WaitSlideEndConditionTask' has a wrong offset!");
static_assert(offsetof(UGzGA_BoostSlide, SlideTickTask) == 0x000560, "Member 'UGzGA_BoostSlide::SlideTickTask' has a wrong offset!");

// Class G01.GzGA_BreakObstacle
// 0x0018 (0x0520 - 0x0508)
class UGzGA_BreakObstacle : public UGzGameplayAbility
{
public:
	float                                         RequiredSpeedToBreakObstacleOnMovement;            // 0x0508(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         ShouldBeWithinRangeToBreakObstacle;                // 0x050C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UGzGT_CheckObstacleAhead*               CheckObstacleAhead_GameplayTask;                   // 0x0510(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_32D5[0x8];                                     // 0x0518(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzGA_BreakObstacle">();
	}
	static class UGzGA_BreakObstacle* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzGA_BreakObstacle>();
	}
};
static_assert(alignof(UGzGA_BreakObstacle) == 0x000008, "Wrong alignment on UGzGA_BreakObstacle");
static_assert(sizeof(UGzGA_BreakObstacle) == 0x000520, "Wrong size on UGzGA_BreakObstacle");
static_assert(offsetof(UGzGA_BreakObstacle, RequiredSpeedToBreakObstacleOnMovement) == 0x000508, "Member 'UGzGA_BreakObstacle::RequiredSpeedToBreakObstacleOnMovement' has a wrong offset!");
static_assert(offsetof(UGzGA_BreakObstacle, ShouldBeWithinRangeToBreakObstacle) == 0x00050C, "Member 'UGzGA_BreakObstacle::ShouldBeWithinRangeToBreakObstacle' has a wrong offset!");
static_assert(offsetof(UGzGA_BreakObstacle, CheckObstacleAhead_GameplayTask) == 0x000510, "Member 'UGzGA_BreakObstacle::CheckObstacleAhead_GameplayTask' has a wrong offset!");

// Class G01.GzGT_CheckObstacleAhead
// 0x0008 (0x0070 - 0x0068)
class UGzGT_CheckObstacleAhead final : public UGameplayTask
{
public:
	uint8                                         Pad_32D6[0x8];                                     // 0x0068(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzGT_CheckObstacleAhead">();
	}
	static class UGzGT_CheckObstacleAhead* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzGT_CheckObstacleAhead>();
	}
};
static_assert(alignof(UGzGT_CheckObstacleAhead) == 0x000008, "Wrong alignment on UGzGT_CheckObstacleAhead");
static_assert(sizeof(UGzGT_CheckObstacleAhead) == 0x000070, "Wrong size on UGzGT_CheckObstacleAhead");

// Class G01.GzGA_ChargedJump
// 0x0038 (0x0540 - 0x0508)
class UGzGA_ChargedJump final : public UGzGameplayAbility
{
public:
	TSubclassOf<class UGameplayEffect>            GE_JumpHeldClass;                                  // 0x0508(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         MaxChargeTime;                                     // 0x0510(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         ChargePeriod;                                      // 0x0514(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         JumpIncreaseCoeff;                                 // 0x0518(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_32D7[0xC];                                     // 0x051C(0x000C)(Fixing Size After Last Property [ Dumper-7 ])
	class UAbilityTask_WaitInputRelease*          AT_WaitInputRelease;                               // 0x0528(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_32D8[0x10];                                    // 0x0530(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void CreateChargingWidget();
	void OnChargeUpComplete(float AmountOfTimeHeld);
	void OnMovementModeChange(class ACharacter* Character, EMovementMode PrevMovementMode, uint8 PreviousCustomMode);
	void RemoveChargingWidget();

	float GetChargePercent() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzGA_ChargedJump">();
	}
	static class UGzGA_ChargedJump* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzGA_ChargedJump>();
	}
};
static_assert(alignof(UGzGA_ChargedJump) == 0x000008, "Wrong alignment on UGzGA_ChargedJump");
static_assert(sizeof(UGzGA_ChargedJump) == 0x000540, "Wrong size on UGzGA_ChargedJump");
static_assert(offsetof(UGzGA_ChargedJump, GE_JumpHeldClass) == 0x000508, "Member 'UGzGA_ChargedJump::GE_JumpHeldClass' has a wrong offset!");
static_assert(offsetof(UGzGA_ChargedJump, MaxChargeTime) == 0x000510, "Member 'UGzGA_ChargedJump::MaxChargeTime' has a wrong offset!");
static_assert(offsetof(UGzGA_ChargedJump, ChargePeriod) == 0x000514, "Member 'UGzGA_ChargedJump::ChargePeriod' has a wrong offset!");
static_assert(offsetof(UGzGA_ChargedJump, JumpIncreaseCoeff) == 0x000518, "Member 'UGzGA_ChargedJump::JumpIncreaseCoeff' has a wrong offset!");
static_assert(offsetof(UGzGA_ChargedJump, AT_WaitInputRelease) == 0x000528, "Member 'UGzGA_ChargedJump::AT_WaitInputRelease' has a wrong offset!");

// Class G01.GzInventoryFunctionLibrary
// 0x0000 (0x0028 - 0x0028)
class UGzInventoryFunctionLibrary final : public UBlueprintFunctionLibrary
{
public:
	static TArray<class FName> GetAllBackpacks();
	static TArray<class FName> GetAllConsumables();
	static TArray<class FName> GetAllContainerItems();
	static TArray<class FName> GetAllCyberLimbs();
	static TArray<class FName> GetAllMiscItems();
	static TArray<class FName> GetAllWeapons();
	static TArray<class FName> GetAllWeaponsByRarity(EGzItemRarity WeaponRarity);
	static TArray<class FName> GetCyberLimbs(EGzLimbType Type);
	static TArray<class FName> GetCyberLimbsByRarity(EGzLimbType Type, EGzItemRarity LimbRarity);
	static TArray<class FName> GetSuitableWeaponAttachmentsOfType(class AGzWeaponActor* WeaponActor, EGzWeaponAttachmentType AttachmentType);
	static TArray<class FName> GetSuitableWeaponAttachmentsOfTypeFromItemData(class UGzWeaponItemData* WeaponItemData, EGzWeaponAttachmentType AttachmentType);
	static bool MatchItemContentToType(const struct FGzInventoryItemContent& ItemContent, const struct FGameplayTag& ItemType);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzInventoryFunctionLibrary">();
	}
	static class UGzInventoryFunctionLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzInventoryFunctionLibrary>();
	}
};
static_assert(alignof(UGzInventoryFunctionLibrary) == 0x000008, "Wrong alignment on UGzInventoryFunctionLibrary");
static_assert(sizeof(UGzInventoryFunctionLibrary) == 0x000028, "Wrong size on UGzInventoryFunctionLibrary");

// Class G01.GzLimbDoubleAbilityComponent
// 0x0010 (0x0100 - 0x00F0)
class UGzLimbDoubleAbilityComponent : public UGzLimbAbilityComponent
{
public:
	float                                         CurrentSecondaryCharges;                           // 0x00F0(0x0004)(Edit, Net, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bSecondaryChargesAvailable;                        // 0x00F4(0x0001)(Edit, Net, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_32E0[0xB];                                     // 0x00F5(0x000B)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetCurrentSecondaryCharges(float Current);
	void SetSecondaryChargesAvailable(bool bAvailable);

	float GetCurrentSecondaryCharges() const;
	float GetMaxSecondaryCharges() const;
	float GetSecondaryChargeDuration() const;
	bool GetSecondaryChargesAvailable() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzLimbDoubleAbilityComponent">();
	}
	static class UGzLimbDoubleAbilityComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzLimbDoubleAbilityComponent>();
	}
};
static_assert(alignof(UGzLimbDoubleAbilityComponent) == 0x000008, "Wrong alignment on UGzLimbDoubleAbilityComponent");
static_assert(sizeof(UGzLimbDoubleAbilityComponent) == 0x000100, "Wrong size on UGzLimbDoubleAbilityComponent");
static_assert(offsetof(UGzLimbDoubleAbilityComponent, CurrentSecondaryCharges) == 0x0000F0, "Member 'UGzLimbDoubleAbilityComponent::CurrentSecondaryCharges' has a wrong offset!");
static_assert(offsetof(UGzLimbDoubleAbilityComponent, bSecondaryChargesAvailable) == 0x0000F4, "Member 'UGzLimbDoubleAbilityComponent::bSecondaryChargesAvailable' has a wrong offset!");

// Class G01.GzGA_CloakArm
// 0x0008 (0x0680 - 0x0678)
class UGzGA_CloakArm : public UGzGA_BaseLimbAbility
{
public:
	class FName                                   ArmBoneName;                                       // 0x0678(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void ParseGadgetSpawnData(const struct FGameplayAbilityTargetDataHandle& TargetData, class AGzMultiPartCharacter** Character, struct FVector_NetQuantize* SpawnLocation, struct FVector_NetQuantize* TargetLocation);
	void SendGadgetSpawnData();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzGA_CloakArm">();
	}
	static class UGzGA_CloakArm* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzGA_CloakArm>();
	}
};
static_assert(alignof(UGzGA_CloakArm) == 0x000008, "Wrong alignment on UGzGA_CloakArm");
static_assert(sizeof(UGzGA_CloakArm) == 0x000680, "Wrong size on UGzGA_CloakArm");
static_assert(offsetof(UGzGA_CloakArm, ArmBoneName) == 0x000678, "Member 'UGzGA_CloakArm::ArmBoneName' has a wrong offset!");

// Class G01.GzLoadoutSelectionButton
// 0x0070 (0x16A0 - 0x1630)
class UGzLoadoutSelectionButton : public UGzCommonButton
{
public:
	uint8                                         Pad_32E1[0x70];                                    // 0x1630(0x0070)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnInitialized_BP();
	void Refresh();

	bool GetIsRandomLoadout() const;
	const struct FGzLoadoutDataConfig GetLoadoutData() const;
	bool GetShowLoadoutPrice() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzLoadoutSelectionButton">();
	}
	static class UGzLoadoutSelectionButton* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzLoadoutSelectionButton>();
	}
};
static_assert(alignof(UGzLoadoutSelectionButton) == 0x000010, "Wrong alignment on UGzLoadoutSelectionButton");
static_assert(sizeof(UGzLoadoutSelectionButton) == 0x0016A0, "Wrong size on UGzLoadoutSelectionButton");

// Class G01.GzGA_Consume
// 0x0048 (0x0550 - 0x0508)
class UGzGA_Consume : public UGzGameplayAbility
{
public:
	bool                                          bUseVirtualPocket;                                 // 0x0508(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_32E2[0x7];                                     // 0x0509(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UGzItemData*                            ItemToConsume;                                     // 0x0510(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FGameplayTag                           VirtualPocketSlotTag;                              // 0x0518(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<struct FGzConsumeAnimationData>        Animations;                                        // 0x0520(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	class UGzAT_PlayMontageAndWaitForEvent*       MontageTask;                                       // 0x0530(0x0008)(ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UGzItemData*                            CachedItemToConsume;                               // 0x0538(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAnimMontage*                           AnimMontage_Left;                                  // 0x0540(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAnimMontage*                           AnimMontage_Right;                                 // 0x0548(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzGA_Consume">();
	}
	static class UGzGA_Consume* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzGA_Consume>();
	}
};
static_assert(alignof(UGzGA_Consume) == 0x000008, "Wrong alignment on UGzGA_Consume");
static_assert(sizeof(UGzGA_Consume) == 0x000550, "Wrong size on UGzGA_Consume");
static_assert(offsetof(UGzGA_Consume, bUseVirtualPocket) == 0x000508, "Member 'UGzGA_Consume::bUseVirtualPocket' has a wrong offset!");
static_assert(offsetof(UGzGA_Consume, ItemToConsume) == 0x000510, "Member 'UGzGA_Consume::ItemToConsume' has a wrong offset!");
static_assert(offsetof(UGzGA_Consume, VirtualPocketSlotTag) == 0x000518, "Member 'UGzGA_Consume::VirtualPocketSlotTag' has a wrong offset!");
static_assert(offsetof(UGzGA_Consume, Animations) == 0x000520, "Member 'UGzGA_Consume::Animations' has a wrong offset!");
static_assert(offsetof(UGzGA_Consume, MontageTask) == 0x000530, "Member 'UGzGA_Consume::MontageTask' has a wrong offset!");
static_assert(offsetof(UGzGA_Consume, CachedItemToConsume) == 0x000538, "Member 'UGzGA_Consume::CachedItemToConsume' has a wrong offset!");
static_assert(offsetof(UGzGA_Consume, AnimMontage_Left) == 0x000540, "Member 'UGzGA_Consume::AnimMontage_Left' has a wrong offset!");
static_assert(offsetof(UGzGA_Consume, AnimMontage_Right) == 0x000548, "Member 'UGzGA_Consume::AnimMontage_Right' has a wrong offset!");

// Class G01.GzTrack
// 0x0130 (0x03D0 - 0x02A0)
class AGzTrack : public AActor
{
public:
	class USplineComponent*                       Spline;                                            // 0x02A0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSet<struct FGzTrackStopDetails>              TrackStopDetails;                                  // 0x02A8(0x0050)(Edit, Protected, NativeAccessSpecifierProtected)
	TSet<struct FGzAccelerationSegmentDetails>    AccelerationPointDetails;                          // 0x02F8(0x0050)(Edit, Protected, NativeAccessSpecifierProtected)
	TArray<struct FGzTrackEventPointDetails>      TrackEventPointsDetails;                           // 0x0348(0x0010)(Edit, ZeroConstructor, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	TArray<struct FGzTrackEventSegmentDetails>    TrackEventSegmentsDetails;                         // 0x0358(0x0010)(Edit, ZeroConstructor, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	int32                                         TrackStartPoint;                                   // 0x0368(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         TrackEndPoint;                                     // 0x036C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         MaxSplineToWorldDistanceInterpolationSteps;        // 0x0370(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         SplineToWorldDistanceErrorTolerance;               // 0x0374(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<struct FGzTrackStop>                   SortedTrackStops;                                  // 0x0378(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	TArray<struct FGzAccelerationSegment>         SortedAccelerationPoints;                          // 0x0388(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	TArray<struct FGzTrackEventsPoint>            SortedTrackEventsPoints;                           // 0x0398(0x0010)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	TArray<struct FGzTrackEventsSegment>          SortedTrackEventsSegments;                         // 0x03A8(0x0010)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	double                                        TrackLength;                                       // 0x03B8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	double                                        LoopLength;                                        // 0x03C0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_32E3[0x8];                                     // 0x03C8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	double GetDistanceAt(const int32 Param_Index) const;
	double GetDistanceAtTrackPoint(const int32 TrackPointIndex) const;
	double GetLoopLength() const;
	double GetTrackLength() const;
	const struct FGzTrackStop GetTrackStop(const int32 StopIndex) const;
	int32 GetTrackStopsCount() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzTrack">();
	}
	static class AGzTrack* GetDefaultObj()
	{
		return GetDefaultObjImpl<AGzTrack>();
	}
};
static_assert(alignof(AGzTrack) == 0x000008, "Wrong alignment on AGzTrack");
static_assert(sizeof(AGzTrack) == 0x0003D0, "Wrong size on AGzTrack");
static_assert(offsetof(AGzTrack, Spline) == 0x0002A0, "Member 'AGzTrack::Spline' has a wrong offset!");
static_assert(offsetof(AGzTrack, TrackStopDetails) == 0x0002A8, "Member 'AGzTrack::TrackStopDetails' has a wrong offset!");
static_assert(offsetof(AGzTrack, AccelerationPointDetails) == 0x0002F8, "Member 'AGzTrack::AccelerationPointDetails' has a wrong offset!");
static_assert(offsetof(AGzTrack, TrackEventPointsDetails) == 0x000348, "Member 'AGzTrack::TrackEventPointsDetails' has a wrong offset!");
static_assert(offsetof(AGzTrack, TrackEventSegmentsDetails) == 0x000358, "Member 'AGzTrack::TrackEventSegmentsDetails' has a wrong offset!");
static_assert(offsetof(AGzTrack, TrackStartPoint) == 0x000368, "Member 'AGzTrack::TrackStartPoint' has a wrong offset!");
static_assert(offsetof(AGzTrack, TrackEndPoint) == 0x00036C, "Member 'AGzTrack::TrackEndPoint' has a wrong offset!");
static_assert(offsetof(AGzTrack, MaxSplineToWorldDistanceInterpolationSteps) == 0x000370, "Member 'AGzTrack::MaxSplineToWorldDistanceInterpolationSteps' has a wrong offset!");
static_assert(offsetof(AGzTrack, SplineToWorldDistanceErrorTolerance) == 0x000374, "Member 'AGzTrack::SplineToWorldDistanceErrorTolerance' has a wrong offset!");
static_assert(offsetof(AGzTrack, SortedTrackStops) == 0x000378, "Member 'AGzTrack::SortedTrackStops' has a wrong offset!");
static_assert(offsetof(AGzTrack, SortedAccelerationPoints) == 0x000388, "Member 'AGzTrack::SortedAccelerationPoints' has a wrong offset!");
static_assert(offsetof(AGzTrack, SortedTrackEventsPoints) == 0x000398, "Member 'AGzTrack::SortedTrackEventsPoints' has a wrong offset!");
static_assert(offsetof(AGzTrack, SortedTrackEventsSegments) == 0x0003A8, "Member 'AGzTrack::SortedTrackEventsSegments' has a wrong offset!");
static_assert(offsetof(AGzTrack, TrackLength) == 0x0003B8, "Member 'AGzTrack::TrackLength' has a wrong offset!");
static_assert(offsetof(AGzTrack, LoopLength) == 0x0003C0, "Member 'AGzTrack::LoopLength' has a wrong offset!");

// Class G01.GzProceduralTrack
// 0x0000 (0x03D0 - 0x03D0)
class AGzProceduralTrack : public AGzTrack
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzProceduralTrack">();
	}
	static class AGzProceduralTrack* GetDefaultObj()
	{
		return GetDefaultObjImpl<AGzProceduralTrack>();
	}
};
static_assert(alignof(AGzProceduralTrack) == 0x000008, "Wrong alignment on AGzProceduralTrack");
static_assert(sizeof(AGzProceduralTrack) == 0x0003D0, "Wrong size on AGzProceduralTrack");

// Class G01.GzGA_ConsumeHold
// 0x0010 (0x0560 - 0x0550)
class UGzGA_ConsumeHold : public UGzGA_Consume
{
public:
	float                                         HoldTime;                                          // 0x0550(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_32E7[0xC];                                     // 0x0554(0x000C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	float GetCurrentHoldProgress() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzGA_ConsumeHold">();
	}
	static class UGzGA_ConsumeHold* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzGA_ConsumeHold>();
	}
};
static_assert(alignof(UGzGA_ConsumeHold) == 0x000008, "Wrong alignment on UGzGA_ConsumeHold");
static_assert(sizeof(UGzGA_ConsumeHold) == 0x000560, "Wrong size on UGzGA_ConsumeHold");
static_assert(offsetof(UGzGA_ConsumeHold, HoldTime) == 0x000550, "Member 'UGzGA_ConsumeHold::HoldTime' has a wrong offset!");

// Class G01.GzGA_Crouch
// 0x0010 (0x0560 - 0x0550)
class UGzGA_Crouch : public UGzGA_CharacterState
{
public:
	struct FGameplayTag                           UncrouchEvent;                                     // 0x0550(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_32E8[0x8];                                     // 0x0558(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnUncrouchEvent(const struct FGameplayEventData& TriggerEventData);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzGA_Crouch">();
	}
	static class UGzGA_Crouch* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzGA_Crouch>();
	}
};
static_assert(alignof(UGzGA_Crouch) == 0x000008, "Wrong alignment on UGzGA_Crouch");
static_assert(sizeof(UGzGA_Crouch) == 0x000560, "Wrong size on UGzGA_Crouch");
static_assert(offsetof(UGzGA_Crouch, UncrouchEvent) == 0x000550, "Member 'UGzGA_Crouch::UncrouchEvent' has a wrong offset!");

// Class G01.GzGA_Dash
// 0x0040 (0x0548 - 0x0508)
class UGzGA_Dash : public UGzGameplayAbility
{
public:
	class UGzAT_ApplyRootMotionDash*              DashTask;                                          // 0x0508(0x0008)(ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UPrimitiveComponent*                    ExtraOverlapCollision;                             // 0x0510(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_32E9[0x30];                                    // 0x0518(0x0030)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnCancelEvent(const struct FGameplayEventData& EventData);
	void OnDashFinished(bool DestinationReached, bool TimedOut, const struct FVector& FinalTargetLocation);
	void OnDashHit(class AActor* OtherActor, const struct FVector& NormalImpulse, const struct FHitResult& Hit);
	void OnDashHitCharacter(class AGzMultiPartCharacter* HitCharacter, const struct FVector& NormalImpulse, const struct FHitResult& Hit);
	void OnDashTriggerDistanceReached();
	void OnExtraCollisionBeginOverlap(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const struct FHitResult& SweepResult);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzGA_Dash">();
	}
	static class UGzGA_Dash* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzGA_Dash>();
	}
};
static_assert(alignof(UGzGA_Dash) == 0x000008, "Wrong alignment on UGzGA_Dash");
static_assert(sizeof(UGzGA_Dash) == 0x000548, "Wrong size on UGzGA_Dash");
static_assert(offsetof(UGzGA_Dash, DashTask) == 0x000508, "Member 'UGzGA_Dash::DashTask' has a wrong offset!");
static_assert(offsetof(UGzGA_Dash, ExtraOverlapCollision) == 0x000510, "Member 'UGzGA_Dash::ExtraOverlapCollision' has a wrong offset!");

// Class G01.GzGA_DetachLimb
// 0x00C0 (0x0718 - 0x0658)
class UGzGA_DetachLimb : public UGzGA_BaseLimbInteraction
{
public:
	TMap<EGzLimbType, class UAnimMontage*>        ViolentDetachMontagesByLimbType;                   // 0x0658(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FGzLimbDetachingParams                 Params;                                            // 0x06A8(0x0060)(Edit, BlueprintVisible, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	class UGzInvComponent*                        CachedInventory;                                   // 0x0708(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FGzInvPocketId                         CachedInvPocketId;                                 // 0x0710(0x0008)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzGA_DetachLimb">();
	}
	static class UGzGA_DetachLimb* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzGA_DetachLimb>();
	}
};
static_assert(alignof(UGzGA_DetachLimb) == 0x000008, "Wrong alignment on UGzGA_DetachLimb");
static_assert(sizeof(UGzGA_DetachLimb) == 0x000718, "Wrong size on UGzGA_DetachLimb");
static_assert(offsetof(UGzGA_DetachLimb, ViolentDetachMontagesByLimbType) == 0x000658, "Member 'UGzGA_DetachLimb::ViolentDetachMontagesByLimbType' has a wrong offset!");
static_assert(offsetof(UGzGA_DetachLimb, Params) == 0x0006A8, "Member 'UGzGA_DetachLimb::Params' has a wrong offset!");
static_assert(offsetof(UGzGA_DetachLimb, CachedInventory) == 0x000708, "Member 'UGzGA_DetachLimb::CachedInventory' has a wrong offset!");
static_assert(offsetof(UGzGA_DetachLimb, CachedInvPocketId) == 0x000710, "Member 'UGzGA_DetachLimb::CachedInvPocketId' has a wrong offset!");

// Class G01.GzInteractionTooltip
// 0x0078 (0x03B8 - 0x0340)
class UGzInteractionTooltip : public UGzHUDComponent
{
public:
	class UGzInteractableComponent*               FocusedInteractable;                               // 0x0340(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                Offset;                                            // 0x0348(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bFollowFocusable;                                  // 0x0360(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_32EC[0x7];                                     // 0x0361(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UGzPingControllerComponent*             PingControllerComponent;                           // 0x0368(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UGzPlayerMarkersHolderComponent*        MarkersHolderComponent;                            // 0x0370(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_32ED[0x40];                                    // 0x0378(0x0040)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnFocusChange(class UGzInteractableComponent* Interactable, bool bInInteractionRange);
	void OnFocusChange_BP(class UGzInteractableComponent* Interactable, bool bFocused);
	void OnFollowFocusable_BP(bool bShouldFollow);
	void SetFollowFocusable(bool bShouldFollow);
	void SetTooltipOffset(const struct FVector& InOffset);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzInteractionTooltip">();
	}
	static class UGzInteractionTooltip* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzInteractionTooltip>();
	}
};
static_assert(alignof(UGzInteractionTooltip) == 0x000008, "Wrong alignment on UGzInteractionTooltip");
static_assert(sizeof(UGzInteractionTooltip) == 0x0003B8, "Wrong size on UGzInteractionTooltip");
static_assert(offsetof(UGzInteractionTooltip, FocusedInteractable) == 0x000340, "Member 'UGzInteractionTooltip::FocusedInteractable' has a wrong offset!");
static_assert(offsetof(UGzInteractionTooltip, Offset) == 0x000348, "Member 'UGzInteractionTooltip::Offset' has a wrong offset!");
static_assert(offsetof(UGzInteractionTooltip, bFollowFocusable) == 0x000360, "Member 'UGzInteractionTooltip::bFollowFocusable' has a wrong offset!");
static_assert(offsetof(UGzInteractionTooltip, PingControllerComponent) == 0x000368, "Member 'UGzInteractionTooltip::PingControllerComponent' has a wrong offset!");
static_assert(offsetof(UGzInteractionTooltip, MarkersHolderComponent) == 0x000370, "Member 'UGzInteractionTooltip::MarkersHolderComponent' has a wrong offset!");

// Class G01.GzGA_Emotion
// 0x0030 (0x0538 - 0x0508)
class UGzGA_Emotion : public UGzGameplayAbility
{
public:
	class UGzAT_PlayMontageAndWaitForEvent*       MontageTask;                                       // 0x0508(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UInputAction*                           ActivationInputAction;                             // 0x0510(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FGzInputMappingContextInfo             CancelEmoteInputDecorator;                         // 0x0518(0x0010)(Edit, DisableEditOnInstance, NoDestructor, Protected, NativeAccessSpecifierProtected)
	class UGzAT_WaitCustomInputPress*             WaitForCancelActivationInputTask;                  // 0x0528(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_32F0[0x8];                                     // 0x0530(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnCancelEmotePressed(float WaitTime);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzGA_Emotion">();
	}
	static class UGzGA_Emotion* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzGA_Emotion>();
	}
};
static_assert(alignof(UGzGA_Emotion) == 0x000008, "Wrong alignment on UGzGA_Emotion");
static_assert(sizeof(UGzGA_Emotion) == 0x000538, "Wrong size on UGzGA_Emotion");
static_assert(offsetof(UGzGA_Emotion, MontageTask) == 0x000508, "Member 'UGzGA_Emotion::MontageTask' has a wrong offset!");
static_assert(offsetof(UGzGA_Emotion, ActivationInputAction) == 0x000510, "Member 'UGzGA_Emotion::ActivationInputAction' has a wrong offset!");
static_assert(offsetof(UGzGA_Emotion, CancelEmoteInputDecorator) == 0x000518, "Member 'UGzGA_Emotion::CancelEmoteInputDecorator' has a wrong offset!");
static_assert(offsetof(UGzGA_Emotion, WaitForCancelActivationInputTask) == 0x000528, "Member 'UGzGA_Emotion::WaitForCancelActivationInputTask' has a wrong offset!");

// Class G01.GzGA_Equip
// 0x0040 (0x0548 - 0x0508)
class UGzGA_Equip : public UGzGameplayAbility
{
public:
	class UAkAudioEvent*                          MontagelessEquipEvent;                             // 0x0508(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UGzAbilityTaskBase*                     WaitEquipTask;                                     // 0x0510(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UGzSequentialEquipTaskConfig*           EquipTaskConfig;                                   // 0x0518(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FGameplayTagContainer                  TagsDesiredEquip;                                  // 0x0520(0x0020)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	uint8                                         Pad_32F1[0x8];                                     // 0x0540(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnTaskEvent(class UGzAbilityTaskBase* AbilityTask);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzGA_Equip">();
	}
	static class UGzGA_Equip* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzGA_Equip>();
	}
};
static_assert(alignof(UGzGA_Equip) == 0x000008, "Wrong alignment on UGzGA_Equip");
static_assert(sizeof(UGzGA_Equip) == 0x000548, "Wrong size on UGzGA_Equip");
static_assert(offsetof(UGzGA_Equip, MontagelessEquipEvent) == 0x000508, "Member 'UGzGA_Equip::MontagelessEquipEvent' has a wrong offset!");
static_assert(offsetof(UGzGA_Equip, WaitEquipTask) == 0x000510, "Member 'UGzGA_Equip::WaitEquipTask' has a wrong offset!");
static_assert(offsetof(UGzGA_Equip, EquipTaskConfig) == 0x000518, "Member 'UGzGA_Equip::EquipTaskConfig' has a wrong offset!");
static_assert(offsetof(UGzGA_Equip, TagsDesiredEquip) == 0x000520, "Member 'UGzGA_Equip::TagsDesiredEquip' has a wrong offset!");

// Class G01.GzGA_GorillaArm
// 0x01A8 (0x08A0 - 0x06F8)
class UGzGA_GorillaArm : public UGzGA_Charge_LimbAbility
{
public:
	TSubclassOf<class UGzGE_BaseDamage>           DamageEffectClass;                                 // 0x06F8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UGameplayEffect>            ConcussionEffectClass;                             // 0x0700(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UGameplayEffect>            DebuffEffectClass;                                 // 0x0708(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UInputAction*                           AttackInputAction;                                 // 0x0710(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UGzDashParamsData*                      DashParamsData;                                    // 0x0718(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                ExtraDashingCollisionRelativeOffset;               // 0x0720(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                ExtraDashingCollisionExtents;                      // 0x0738(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   DashingCollisionProfileName;                       // 0x0750(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FGameplayTag                           ChargingTag;                                       // 0x0758(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FGameplayTag                           DashingTag;                                        // 0x0760(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FGameplayTag                           PunchTag;                                          // 0x0768(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FGameplayTag                           PunchStartListenTag;                               // 0x0770(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FGameplayTag                           PunchEndListenTag;                                 // 0x0778(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MinimumPunchCharge;                                // 0x0780(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ServerPunchTimeoutSeconds;                         // 0x0784(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UGzGorillaArmComponent*                 GorillaArmComponent;                               // 0x0788(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, Transient, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UGzBodyPartAbilityData_GorillaArm*      GorillaArmData;                                    // 0x0790(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UGzAT_ServerWaitForTargetData*          ServerWaitForTargetData;                           // 0x0798(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAbilityTask_WaitDelay*                 WaitServerTimeOut;                                 // 0x07A0(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FHitResult                             PunchTarget;                                       // 0x07A8(0x00F8)(Transient, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPrivate)

public:
	void BP_OnDashEnded();
	void BP_OnDashStarted(const struct FVector& Direction);
	void BP_OnMaxChargeReached();
	void BP_OnPunch(const struct FHitResult& HitResult);
	void OnChargeStopped();
	void OnDashEvent(const struct FGameplayEventData& Payload);
	void OnDashFinished(const struct FGameplayEventData& Payload);
	void OnPunchAnimEnded();
	void OnPunchAnimNotify();
	void OnServerPunchTimeOut();
	void ServerHandleClientPunchTargetData(const struct FGameplayAbilityTargetDataHandle& TargetData);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzGA_GorillaArm">();
	}
	static class UGzGA_GorillaArm* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzGA_GorillaArm>();
	}
};
static_assert(alignof(UGzGA_GorillaArm) == 0x000008, "Wrong alignment on UGzGA_GorillaArm");
static_assert(sizeof(UGzGA_GorillaArm) == 0x0008A0, "Wrong size on UGzGA_GorillaArm");
static_assert(offsetof(UGzGA_GorillaArm, DamageEffectClass) == 0x0006F8, "Member 'UGzGA_GorillaArm::DamageEffectClass' has a wrong offset!");
static_assert(offsetof(UGzGA_GorillaArm, ConcussionEffectClass) == 0x000700, "Member 'UGzGA_GorillaArm::ConcussionEffectClass' has a wrong offset!");
static_assert(offsetof(UGzGA_GorillaArm, DebuffEffectClass) == 0x000708, "Member 'UGzGA_GorillaArm::DebuffEffectClass' has a wrong offset!");
static_assert(offsetof(UGzGA_GorillaArm, AttackInputAction) == 0x000710, "Member 'UGzGA_GorillaArm::AttackInputAction' has a wrong offset!");
static_assert(offsetof(UGzGA_GorillaArm, DashParamsData) == 0x000718, "Member 'UGzGA_GorillaArm::DashParamsData' has a wrong offset!");
static_assert(offsetof(UGzGA_GorillaArm, ExtraDashingCollisionRelativeOffset) == 0x000720, "Member 'UGzGA_GorillaArm::ExtraDashingCollisionRelativeOffset' has a wrong offset!");
static_assert(offsetof(UGzGA_GorillaArm, ExtraDashingCollisionExtents) == 0x000738, "Member 'UGzGA_GorillaArm::ExtraDashingCollisionExtents' has a wrong offset!");
static_assert(offsetof(UGzGA_GorillaArm, DashingCollisionProfileName) == 0x000750, "Member 'UGzGA_GorillaArm::DashingCollisionProfileName' has a wrong offset!");
static_assert(offsetof(UGzGA_GorillaArm, ChargingTag) == 0x000758, "Member 'UGzGA_GorillaArm::ChargingTag' has a wrong offset!");
static_assert(offsetof(UGzGA_GorillaArm, DashingTag) == 0x000760, "Member 'UGzGA_GorillaArm::DashingTag' has a wrong offset!");
static_assert(offsetof(UGzGA_GorillaArm, PunchTag) == 0x000768, "Member 'UGzGA_GorillaArm::PunchTag' has a wrong offset!");
static_assert(offsetof(UGzGA_GorillaArm, PunchStartListenTag) == 0x000770, "Member 'UGzGA_GorillaArm::PunchStartListenTag' has a wrong offset!");
static_assert(offsetof(UGzGA_GorillaArm, PunchEndListenTag) == 0x000778, "Member 'UGzGA_GorillaArm::PunchEndListenTag' has a wrong offset!");
static_assert(offsetof(UGzGA_GorillaArm, MinimumPunchCharge) == 0x000780, "Member 'UGzGA_GorillaArm::MinimumPunchCharge' has a wrong offset!");
static_assert(offsetof(UGzGA_GorillaArm, ServerPunchTimeoutSeconds) == 0x000784, "Member 'UGzGA_GorillaArm::ServerPunchTimeoutSeconds' has a wrong offset!");
static_assert(offsetof(UGzGA_GorillaArm, GorillaArmComponent) == 0x000788, "Member 'UGzGA_GorillaArm::GorillaArmComponent' has a wrong offset!");
static_assert(offsetof(UGzGA_GorillaArm, GorillaArmData) == 0x000790, "Member 'UGzGA_GorillaArm::GorillaArmData' has a wrong offset!");
static_assert(offsetof(UGzGA_GorillaArm, ServerWaitForTargetData) == 0x000798, "Member 'UGzGA_GorillaArm::ServerWaitForTargetData' has a wrong offset!");
static_assert(offsetof(UGzGA_GorillaArm, WaitServerTimeOut) == 0x0007A0, "Member 'UGzGA_GorillaArm::WaitServerTimeOut' has a wrong offset!");
static_assert(offsetof(UGzGA_GorillaArm, PunchTarget) == 0x0007A8, "Member 'UGzGA_GorillaArm::PunchTarget' has a wrong offset!");

// Class G01.GzJZ_PostMatchStage
// 0x0008 (0x0118 - 0x0110)
class UGzJZ_PostMatchStage final : public UGzGameStageBase
{
public:
	uint8                                         Pad_32F2[0x8];                                     // 0x0110(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzJZ_PostMatchStage">();
	}
	static class UGzJZ_PostMatchStage* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzJZ_PostMatchStage>();
	}
};
static_assert(alignof(UGzJZ_PostMatchStage) == 0x000008, "Wrong alignment on UGzJZ_PostMatchStage");
static_assert(sizeof(UGzJZ_PostMatchStage) == 0x000118, "Wrong size on UGzJZ_PostMatchStage");

// Class G01.GzGA_GrappleHook
// 0x0070 (0x06E8 - 0x0678)
class UGzGA_GrappleHook : public UGzGA_BaseLimbAbility
{
public:
	class UAnimMontage*                           ThrowHookMontage;                                  // 0x0678(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   ThrowAnimNotificationEventName;                    // 0x0680(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAnimMontage*                           PullCharacterMontage;                              // 0x0688(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   PullAnimNotificationEventName;                     // 0x0690(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAnimMontage*                           HookReturnedMontage;                               // 0x0698(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UGzGE_BaseDamage>           DamageEffectClass;                                 // 0x06A0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FGameplayTag                           PullAbilityTag;                                    // 0x06A8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FGameplayTag                           HookEnemyAbilityTag;                               // 0x06B0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UGzGrappleHookData*                     GrappleHookData;                                   // 0x06B8(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UGzAT_PlayMontageAndWaitForEvent*       ThrowHookMontageAndWaitForEventTask;               // 0x06C0(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UGzAT_PlayMontageAndWaitForEvent*       PullCharacterMontageAndWaitForEventTask;           // 0x06C8(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UGzAT_PlayMontageAndWaitForEvent*       HookReturnedMontageTask;                           // 0x06D0(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UGzGrappleHookComponent*                GrappleHookComponent;                              // 0x06D8(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_32F3[0x8];                                     // 0x06E0(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnMontageInterupted();
	void OnPullCharacterAnimationNotification(class FName NotifyName);
	void OnThrowAnimationNotification(class FName NotifyName);

	bool IsTargetInRange() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzGA_GrappleHook">();
	}
	static class UGzGA_GrappleHook* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzGA_GrappleHook>();
	}
};
static_assert(alignof(UGzGA_GrappleHook) == 0x000008, "Wrong alignment on UGzGA_GrappleHook");
static_assert(sizeof(UGzGA_GrappleHook) == 0x0006E8, "Wrong size on UGzGA_GrappleHook");
static_assert(offsetof(UGzGA_GrappleHook, ThrowHookMontage) == 0x000678, "Member 'UGzGA_GrappleHook::ThrowHookMontage' has a wrong offset!");
static_assert(offsetof(UGzGA_GrappleHook, ThrowAnimNotificationEventName) == 0x000680, "Member 'UGzGA_GrappleHook::ThrowAnimNotificationEventName' has a wrong offset!");
static_assert(offsetof(UGzGA_GrappleHook, PullCharacterMontage) == 0x000688, "Member 'UGzGA_GrappleHook::PullCharacterMontage' has a wrong offset!");
static_assert(offsetof(UGzGA_GrappleHook, PullAnimNotificationEventName) == 0x000690, "Member 'UGzGA_GrappleHook::PullAnimNotificationEventName' has a wrong offset!");
static_assert(offsetof(UGzGA_GrappleHook, HookReturnedMontage) == 0x000698, "Member 'UGzGA_GrappleHook::HookReturnedMontage' has a wrong offset!");
static_assert(offsetof(UGzGA_GrappleHook, DamageEffectClass) == 0x0006A0, "Member 'UGzGA_GrappleHook::DamageEffectClass' has a wrong offset!");
static_assert(offsetof(UGzGA_GrappleHook, PullAbilityTag) == 0x0006A8, "Member 'UGzGA_GrappleHook::PullAbilityTag' has a wrong offset!");
static_assert(offsetof(UGzGA_GrappleHook, HookEnemyAbilityTag) == 0x0006B0, "Member 'UGzGA_GrappleHook::HookEnemyAbilityTag' has a wrong offset!");
static_assert(offsetof(UGzGA_GrappleHook, GrappleHookData) == 0x0006B8, "Member 'UGzGA_GrappleHook::GrappleHookData' has a wrong offset!");
static_assert(offsetof(UGzGA_GrappleHook, ThrowHookMontageAndWaitForEventTask) == 0x0006C0, "Member 'UGzGA_GrappleHook::ThrowHookMontageAndWaitForEventTask' has a wrong offset!");
static_assert(offsetof(UGzGA_GrappleHook, PullCharacterMontageAndWaitForEventTask) == 0x0006C8, "Member 'UGzGA_GrappleHook::PullCharacterMontageAndWaitForEventTask' has a wrong offset!");
static_assert(offsetof(UGzGA_GrappleHook, HookReturnedMontageTask) == 0x0006D0, "Member 'UGzGA_GrappleHook::HookReturnedMontageTask' has a wrong offset!");
static_assert(offsetof(UGzGA_GrappleHook, GrappleHookComponent) == 0x0006D8, "Member 'UGzGA_GrappleHook::GrappleHookComponent' has a wrong offset!");

// Class G01.GzGA_GrappleHookEnemy
// 0x0060 (0x0568 - 0x0508)
class UGzGA_GrappleHookEnemy : public UGzGameplayAbility
{
public:
	EGzLimbType                                   LimbSlot;                                          // 0x0508(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_32F4[0x7];                                     // 0x0509(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UInputAction*                           CancelReleaseInput;                                // 0x0510(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FGameplayTag                           PullAbilityTag;                                    // 0x0518(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MaxDurationTime;                                   // 0x0520(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MinDurationTime;                                   // 0x0524(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAnimMontage*                           PullEnemyMontage;                                  // 0x0528(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UGzAT_WaitCustomInputRelease*           WaitCancelInputReleaseTask;                        // 0x0530(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UGzAT_WaitCustomInputPress*             WaitCancelInputPressTask;                          // 0x0538(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAbilityTask_WaitDelay*                 WaitDelayEndTask;                                  // 0x0540(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAbilityTask_WaitDelay*                 WaitDelayMinActivationTimeTask;                    // 0x0548(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAbilityTask_WaitGameplayEvent*         WaitPullEndEventTask;                              // 0x0550(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UGzGrappleHookComponent*                CachedGrappleHookComponent;                        // 0x0558(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class AGzCharacter*                           HitCharacter;                                      // 0x0560(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void OnCancelInputReleased(float Time);
	void OnMaxActivationTimeReached();
	void OnMinActivationTimeReached();
	void OnPullEnded(const struct FGameplayEventData& Payload);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzGA_GrappleHookEnemy">();
	}
	static class UGzGA_GrappleHookEnemy* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzGA_GrappleHookEnemy>();
	}
};
static_assert(alignof(UGzGA_GrappleHookEnemy) == 0x000008, "Wrong alignment on UGzGA_GrappleHookEnemy");
static_assert(sizeof(UGzGA_GrappleHookEnemy) == 0x000568, "Wrong size on UGzGA_GrappleHookEnemy");
static_assert(offsetof(UGzGA_GrappleHookEnemy, LimbSlot) == 0x000508, "Member 'UGzGA_GrappleHookEnemy::LimbSlot' has a wrong offset!");
static_assert(offsetof(UGzGA_GrappleHookEnemy, CancelReleaseInput) == 0x000510, "Member 'UGzGA_GrappleHookEnemy::CancelReleaseInput' has a wrong offset!");
static_assert(offsetof(UGzGA_GrappleHookEnemy, PullAbilityTag) == 0x000518, "Member 'UGzGA_GrappleHookEnemy::PullAbilityTag' has a wrong offset!");
static_assert(offsetof(UGzGA_GrappleHookEnemy, MaxDurationTime) == 0x000520, "Member 'UGzGA_GrappleHookEnemy::MaxDurationTime' has a wrong offset!");
static_assert(offsetof(UGzGA_GrappleHookEnemy, MinDurationTime) == 0x000524, "Member 'UGzGA_GrappleHookEnemy::MinDurationTime' has a wrong offset!");
static_assert(offsetof(UGzGA_GrappleHookEnemy, PullEnemyMontage) == 0x000528, "Member 'UGzGA_GrappleHookEnemy::PullEnemyMontage' has a wrong offset!");
static_assert(offsetof(UGzGA_GrappleHookEnemy, WaitCancelInputReleaseTask) == 0x000530, "Member 'UGzGA_GrappleHookEnemy::WaitCancelInputReleaseTask' has a wrong offset!");
static_assert(offsetof(UGzGA_GrappleHookEnemy, WaitCancelInputPressTask) == 0x000538, "Member 'UGzGA_GrappleHookEnemy::WaitCancelInputPressTask' has a wrong offset!");
static_assert(offsetof(UGzGA_GrappleHookEnemy, WaitDelayEndTask) == 0x000540, "Member 'UGzGA_GrappleHookEnemy::WaitDelayEndTask' has a wrong offset!");
static_assert(offsetof(UGzGA_GrappleHookEnemy, WaitDelayMinActivationTimeTask) == 0x000548, "Member 'UGzGA_GrappleHookEnemy::WaitDelayMinActivationTimeTask' has a wrong offset!");
static_assert(offsetof(UGzGA_GrappleHookEnemy, WaitPullEndEventTask) == 0x000550, "Member 'UGzGA_GrappleHookEnemy::WaitPullEndEventTask' has a wrong offset!");
static_assert(offsetof(UGzGA_GrappleHookEnemy, CachedGrappleHookComponent) == 0x000558, "Member 'UGzGA_GrappleHookEnemy::CachedGrappleHookComponent' has a wrong offset!");
static_assert(offsetof(UGzGA_GrappleHookEnemy, HitCharacter) == 0x000560, "Member 'UGzGA_GrappleHookEnemy::HitCharacter' has a wrong offset!");

// Class G01.GzGA_GrapplePull
// 0x0050 (0x0558 - 0x0508)
class UGzGA_GrapplePull : public UGzGameplayAbility
{
public:
	EGzLimbType                                   LimbSlot;                                          // 0x0508(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_32F5[0x7];                                     // 0x0509(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UInputAction*                           CancelReleaseInput;                                // 0x0510(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MaxDurationTime;                                   // 0x0518(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MinDurationTime;                                   // 0x051C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAnimMontage*                           FlyingMontage;                                     // 0x0520(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   FlyingEndSectionName;                              // 0x0528(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UGzAT_WaitCustomInputRelease*           WaitCancelInputReleaseTask;                        // 0x0530(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAbilityTask_WaitDelay*                 WaitDelayEndTask;                                  // 0x0538(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAbilityTask_WaitDelay*                 WaitDelayMinActivationTimeTask;                    // 0x0540(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UGzAT_PlayMontageAndWaitForEvent*       FlyingMontageTask;                                 // 0x0548(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UGzGrappleHookComponent*                GrappleHookComponent;                              // 0x0550(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void OnArrivedToGrappling();
	void OnCancelInputReleased(float Time);
	void OnHookReturned();
	void OnMinActivationTimeReached();
	void OnTimeoutReached();
	void WaitNetSyncHookReturn();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzGA_GrapplePull">();
	}
	static class UGzGA_GrapplePull* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzGA_GrapplePull>();
	}
};
static_assert(alignof(UGzGA_GrapplePull) == 0x000008, "Wrong alignment on UGzGA_GrapplePull");
static_assert(sizeof(UGzGA_GrapplePull) == 0x000558, "Wrong size on UGzGA_GrapplePull");
static_assert(offsetof(UGzGA_GrapplePull, LimbSlot) == 0x000508, "Member 'UGzGA_GrapplePull::LimbSlot' has a wrong offset!");
static_assert(offsetof(UGzGA_GrapplePull, CancelReleaseInput) == 0x000510, "Member 'UGzGA_GrapplePull::CancelReleaseInput' has a wrong offset!");
static_assert(offsetof(UGzGA_GrapplePull, MaxDurationTime) == 0x000518, "Member 'UGzGA_GrapplePull::MaxDurationTime' has a wrong offset!");
static_assert(offsetof(UGzGA_GrapplePull, MinDurationTime) == 0x00051C, "Member 'UGzGA_GrapplePull::MinDurationTime' has a wrong offset!");
static_assert(offsetof(UGzGA_GrapplePull, FlyingMontage) == 0x000520, "Member 'UGzGA_GrapplePull::FlyingMontage' has a wrong offset!");
static_assert(offsetof(UGzGA_GrapplePull, FlyingEndSectionName) == 0x000528, "Member 'UGzGA_GrapplePull::FlyingEndSectionName' has a wrong offset!");
static_assert(offsetof(UGzGA_GrapplePull, WaitCancelInputReleaseTask) == 0x000530, "Member 'UGzGA_GrapplePull::WaitCancelInputReleaseTask' has a wrong offset!");
static_assert(offsetof(UGzGA_GrapplePull, WaitDelayEndTask) == 0x000538, "Member 'UGzGA_GrapplePull::WaitDelayEndTask' has a wrong offset!");
static_assert(offsetof(UGzGA_GrapplePull, WaitDelayMinActivationTimeTask) == 0x000540, "Member 'UGzGA_GrapplePull::WaitDelayMinActivationTimeTask' has a wrong offset!");
static_assert(offsetof(UGzGA_GrapplePull, FlyingMontageTask) == 0x000548, "Member 'UGzGA_GrapplePull::FlyingMontageTask' has a wrong offset!");
static_assert(offsetof(UGzGA_GrapplePull, GrappleHookComponent) == 0x000550, "Member 'UGzGA_GrapplePull::GrappleHookComponent' has a wrong offset!");

// Class G01.GzSA_SetRotationMode
// 0x0008 (0x0040 - 0x0038)
class UGzSA_SetRotationMode final : public UGzStateAction
{
public:
	ELocomotionRotationMode                       RotationMode;                                      // 0x0038(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_32F6[0x7];                                     // 0x0039(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzSA_SetRotationMode">();
	}
	static class UGzSA_SetRotationMode* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzSA_SetRotationMode>();
	}
};
static_assert(alignof(UGzSA_SetRotationMode) == 0x000008, "Wrong alignment on UGzSA_SetRotationMode");
static_assert(sizeof(UGzSA_SetRotationMode) == 0x000040, "Wrong size on UGzSA_SetRotationMode");
static_assert(offsetof(UGzSA_SetRotationMode, RotationMode) == 0x000038, "Member 'UGzSA_SetRotationMode::RotationMode' has a wrong offset!");

// Class G01.GzGA_HexInsertion
// 0x0030 (0x0538 - 0x0508)
class UGzGA_HexInsertion : public UGzGameplayAbility
{
public:
	class FName                                   HexCreationEventName;                              // 0x0508(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   HexDeletionEventName;                              // 0x0510(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAnimMontage*                           LeftHandHexPlacingMontage;                         // 0x0518(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAnimMontage*                           RightHandHexPlacingMontage;                        // 0x0520(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UGzAT_PlayMontageAndWaitForEvent*       PlayMontage_AbilityTask;                           // 0x0528(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UGzContainerItemData*                   InsertedHexItemData;                               // 0x0530(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void OnAnimNotifyReceived(class FName NotifyName);
	void StartPlayMontageAbilityTask();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzGA_HexInsertion">();
	}
	static class UGzGA_HexInsertion* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzGA_HexInsertion>();
	}
};
static_assert(alignof(UGzGA_HexInsertion) == 0x000008, "Wrong alignment on UGzGA_HexInsertion");
static_assert(sizeof(UGzGA_HexInsertion) == 0x000538, "Wrong size on UGzGA_HexInsertion");
static_assert(offsetof(UGzGA_HexInsertion, HexCreationEventName) == 0x000508, "Member 'UGzGA_HexInsertion::HexCreationEventName' has a wrong offset!");
static_assert(offsetof(UGzGA_HexInsertion, HexDeletionEventName) == 0x000510, "Member 'UGzGA_HexInsertion::HexDeletionEventName' has a wrong offset!");
static_assert(offsetof(UGzGA_HexInsertion, LeftHandHexPlacingMontage) == 0x000518, "Member 'UGzGA_HexInsertion::LeftHandHexPlacingMontage' has a wrong offset!");
static_assert(offsetof(UGzGA_HexInsertion, RightHandHexPlacingMontage) == 0x000520, "Member 'UGzGA_HexInsertion::RightHandHexPlacingMontage' has a wrong offset!");
static_assert(offsetof(UGzGA_HexInsertion, PlayMontage_AbilityTask) == 0x000528, "Member 'UGzGA_HexInsertion::PlayMontage_AbilityTask' has a wrong offset!");
static_assert(offsetof(UGzGA_HexInsertion, InsertedHexItemData) == 0x000530, "Member 'UGzGA_HexInsertion::InsertedHexItemData' has a wrong offset!");

// Class G01.GzGA_Interact
// 0x0190 (0x0698 - 0x0508)
class UGzGA_Interact : public UGzGameplayAbility
{
public:
	class UGzInteractableComponent*               CachedInteractable;                                // 0x0508(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UGzAT_WaitCustomInputRelease*           WaitCustomCancelInputRelease_AbilityTask;          // 0x0510(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UGzAT_CheckInteractionAbility*          CheckInteractionAbility_AbilityTask;               // 0x0518(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UGzAT_PlayMontageAndWaitForEvent*       PlayMontage_AbilityTask;                           // 0x0520(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UGzAT_PlayMontageAndWaitForEvent*       PendingPlayMontage_AbilityTask;                    // 0x0528(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UGzAT_ApplyRootMotionInteractable*      ApplyRootMotionInteractable_AbilityTask;           // 0x0530(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FGzInteractionStage                    CurrentInteractionStage;                           // 0x0538(0x0030)(Transient, Protected, NativeAccessSpecifierProtected)
	class UGzInteractableTransitionSettings*      TransitionSettings;                                // 0x0568(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_32F7[0x118];                                   // 0x0570(0x0118)(Fixing Size After Last Property [ Dumper-7 ])
	class UDefaultInteractionBehavior*            CachedInteraction;                                 // 0x0688(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_32F8[0x8];                                     // 0x0690(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnConnectionChanged(class AGzPlayerState* InPlayerState);
	void OnInteractionComplete();
	void OnInteractionStageFinished();
	void OnMontageNotify(const class FName NotifyName);
	void ProcessInteractionStages();
	void StartInteraction();
	void TryStartTransitionToInteractable();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzGA_Interact">();
	}
	static class UGzGA_Interact* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzGA_Interact>();
	}
};
static_assert(alignof(UGzGA_Interact) == 0x000008, "Wrong alignment on UGzGA_Interact");
static_assert(sizeof(UGzGA_Interact) == 0x000698, "Wrong size on UGzGA_Interact");
static_assert(offsetof(UGzGA_Interact, CachedInteractable) == 0x000508, "Member 'UGzGA_Interact::CachedInteractable' has a wrong offset!");
static_assert(offsetof(UGzGA_Interact, WaitCustomCancelInputRelease_AbilityTask) == 0x000510, "Member 'UGzGA_Interact::WaitCustomCancelInputRelease_AbilityTask' has a wrong offset!");
static_assert(offsetof(UGzGA_Interact, CheckInteractionAbility_AbilityTask) == 0x000518, "Member 'UGzGA_Interact::CheckInteractionAbility_AbilityTask' has a wrong offset!");
static_assert(offsetof(UGzGA_Interact, PlayMontage_AbilityTask) == 0x000520, "Member 'UGzGA_Interact::PlayMontage_AbilityTask' has a wrong offset!");
static_assert(offsetof(UGzGA_Interact, PendingPlayMontage_AbilityTask) == 0x000528, "Member 'UGzGA_Interact::PendingPlayMontage_AbilityTask' has a wrong offset!");
static_assert(offsetof(UGzGA_Interact, ApplyRootMotionInteractable_AbilityTask) == 0x000530, "Member 'UGzGA_Interact::ApplyRootMotionInteractable_AbilityTask' has a wrong offset!");
static_assert(offsetof(UGzGA_Interact, CurrentInteractionStage) == 0x000538, "Member 'UGzGA_Interact::CurrentInteractionStage' has a wrong offset!");
static_assert(offsetof(UGzGA_Interact, TransitionSettings) == 0x000568, "Member 'UGzGA_Interact::TransitionSettings' has a wrong offset!");
static_assert(offsetof(UGzGA_Interact, CachedInteraction) == 0x000688, "Member 'UGzGA_Interact::CachedInteraction' has a wrong offset!");

// Class G01.GzGA_Jump
// 0x0000 (0x0550 - 0x0550)
class UGzGA_Jump : public UGzGA_CharacterState
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzGA_Jump">();
	}
	static class UGzGA_Jump* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzGA_Jump>();
	}
};
static_assert(alignof(UGzGA_Jump) == 0x000008, "Wrong alignment on UGzGA_Jump");
static_assert(sizeof(UGzGA_Jump) == 0x000550, "Wrong size on UGzGA_Jump");

// Class G01.GzSingleWorldNavDataDelegate
// 0x0020 (0x0050 - 0x0030)
class UGzSingleWorldNavDataDelegate final : public UGzBaseNavDataDelegate
{
public:
	bool                                          RebuildInProcess;                                  // 0x0030(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_32F9[0x7];                                     // 0x0031(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FGzCoverData>                   GeneratedCovers;                                   // 0x0038(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	int32                                         GeneratedNavLinksNumber;                           // 0x0048(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_32FA[0x4];                                     // 0x004C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzSingleWorldNavDataDelegate">();
	}
	static class UGzSingleWorldNavDataDelegate* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzSingleWorldNavDataDelegate>();
	}
};
static_assert(alignof(UGzSingleWorldNavDataDelegate) == 0x000008, "Wrong alignment on UGzSingleWorldNavDataDelegate");
static_assert(sizeof(UGzSingleWorldNavDataDelegate) == 0x000050, "Wrong size on UGzSingleWorldNavDataDelegate");
static_assert(offsetof(UGzSingleWorldNavDataDelegate, RebuildInProcess) == 0x000030, "Member 'UGzSingleWorldNavDataDelegate::RebuildInProcess' has a wrong offset!");
static_assert(offsetof(UGzSingleWorldNavDataDelegate, GeneratedCovers) == 0x000038, "Member 'UGzSingleWorldNavDataDelegate::GeneratedCovers' has a wrong offset!");
static_assert(offsetof(UGzSingleWorldNavDataDelegate, GeneratedNavLinksNumber) == 0x000048, "Member 'UGzSingleWorldNavDataDelegate::GeneratedNavLinksNumber' has a wrong offset!");

// Class G01.GzGA_JumpBoost
// 0x0050 (0x06C8 - 0x0678)
class UGzGA_JumpBoost : public UGzGA_BaseLimbAbility
{
public:
	float                                         BoostUpAngle;                                      // 0x0678(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         JumpBoostDuration;                                 // 0x067C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         JumpBoostStrength;                                 // 0x0680(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_32FB[0x4];                                     // 0x0684(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UCurveFloat*                            JumpBoostStrengthOverTime;                         // 0x0688(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bDodgeWhenNotForward;                              // 0x0690(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_32FC[0x3];                                     // 0x0691(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MinAngleForSideDodge;                              // 0x0694(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         DodgeBoostDuration;                                // 0x0698(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         DodgeBoostStrength;                                // 0x069C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCurveFloat*                            DodgeBoostStrengthOverTime;                        // 0x06A0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bNotifyApex;                                       // 0x06A8(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bSetApexOnActivate;                                // 0x06A9(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_32FD[0x2];                                     // 0x06AA(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTag                           ActivationGameplayCue;                             // 0x06AC(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_32FE[0x4];                                     // 0x06B4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UGzCharacterMovementComponent*          CharacterMovementComp;                             // 0x06B8(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_32FF[0x8];                                     // 0x06C0(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnCharacterHit(class AActor* SelfActor, class AActor* OtherActor, const struct FVector& NormalImpulse, const struct FHitResult& Hit);
	void OnMovementModeChanged(class ACharacter* Character, EMovementMode PrevMovementMode, uint8 PreviousCustomMode);
	void UpdateNotifyApex();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzGA_JumpBoost">();
	}
	static class UGzGA_JumpBoost* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzGA_JumpBoost>();
	}
};
static_assert(alignof(UGzGA_JumpBoost) == 0x000008, "Wrong alignment on UGzGA_JumpBoost");
static_assert(sizeof(UGzGA_JumpBoost) == 0x0006C8, "Wrong size on UGzGA_JumpBoost");
static_assert(offsetof(UGzGA_JumpBoost, BoostUpAngle) == 0x000678, "Member 'UGzGA_JumpBoost::BoostUpAngle' has a wrong offset!");
static_assert(offsetof(UGzGA_JumpBoost, JumpBoostDuration) == 0x00067C, "Member 'UGzGA_JumpBoost::JumpBoostDuration' has a wrong offset!");
static_assert(offsetof(UGzGA_JumpBoost, JumpBoostStrength) == 0x000680, "Member 'UGzGA_JumpBoost::JumpBoostStrength' has a wrong offset!");
static_assert(offsetof(UGzGA_JumpBoost, JumpBoostStrengthOverTime) == 0x000688, "Member 'UGzGA_JumpBoost::JumpBoostStrengthOverTime' has a wrong offset!");
static_assert(offsetof(UGzGA_JumpBoost, bDodgeWhenNotForward) == 0x000690, "Member 'UGzGA_JumpBoost::bDodgeWhenNotForward' has a wrong offset!");
static_assert(offsetof(UGzGA_JumpBoost, MinAngleForSideDodge) == 0x000694, "Member 'UGzGA_JumpBoost::MinAngleForSideDodge' has a wrong offset!");
static_assert(offsetof(UGzGA_JumpBoost, DodgeBoostDuration) == 0x000698, "Member 'UGzGA_JumpBoost::DodgeBoostDuration' has a wrong offset!");
static_assert(offsetof(UGzGA_JumpBoost, DodgeBoostStrength) == 0x00069C, "Member 'UGzGA_JumpBoost::DodgeBoostStrength' has a wrong offset!");
static_assert(offsetof(UGzGA_JumpBoost, DodgeBoostStrengthOverTime) == 0x0006A0, "Member 'UGzGA_JumpBoost::DodgeBoostStrengthOverTime' has a wrong offset!");
static_assert(offsetof(UGzGA_JumpBoost, bNotifyApex) == 0x0006A8, "Member 'UGzGA_JumpBoost::bNotifyApex' has a wrong offset!");
static_assert(offsetof(UGzGA_JumpBoost, bSetApexOnActivate) == 0x0006A9, "Member 'UGzGA_JumpBoost::bSetApexOnActivate' has a wrong offset!");
static_assert(offsetof(UGzGA_JumpBoost, ActivationGameplayCue) == 0x0006AC, "Member 'UGzGA_JumpBoost::ActivationGameplayCue' has a wrong offset!");
static_assert(offsetof(UGzGA_JumpBoost, CharacterMovementComp) == 0x0006B8, "Member 'UGzGA_JumpBoost::CharacterMovementComp' has a wrong offset!");

// Class G01.GzGA_KatanaArm
// 0x01D8 (0x08D0 - 0x06F8)
class UGzGA_KatanaArm : public UGzGA_Charge_LimbAbility
{
public:
	bool                                          bEnableExtraDashingCollision;                      // 0x06F8(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3301[0x3];                                     // 0x06F9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   ExtraDashingCollisionProfileName;                  // 0x06FC(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3302[0x4];                                     // 0x0704(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                ExtraDashingCollisionRelativeOffset;               // 0x0708(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                ExtraDashingCollisionExtents;                      // 0x0720(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ExtraTraceDistance;                                // 0x0738(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         SweepSphereRadius;                                 // 0x073C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         TargetValidationRadius;                            // 0x0740(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         InnerTargetValidationRadius;                       // 0x0744(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UGzGE_BaseDamage>           DamageEffectClass;                                 // 0x0748(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         CenterHalfConeAngle;                               // 0x0750(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         SideHalfConeAngle;                                 // 0x0754(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         AttackHalfHeight;                                  // 0x0758(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         AttackUpOffset;                                    // 0x075C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<ECollisionChannel>                     ValidTargetCollisionChannels;                      // 0x0760(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FGameplayTag                           HorizontalAttackCameraTag;                         // 0x0770(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FGameplayTag                           VerticalAttackCameraTag;                           // 0x0778(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         AnimationTimeout;                                  // 0x0780(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FGameplayTag                           AttackImpaleGameplayCueTag;                        // 0x0784(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3303[0x4];                                     // 0x078C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UGzKatanaComponent*                     KatanaComponent;                                   // 0x0790(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UGzAT_ServerWaitForTargetData*          WaitForDashDataTask;                               // 0x0798(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsDashingVertically;                              // 0x07A0(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3304[0x12F];                                   // 0x07A1(0x012F)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnAttackStart(const struct FGameplayEventData& Payload);
	void OnAttackTimeout();
	void OnDashEvent(const struct FGameplayEventData& Payload);
	void OnDashFinished(const struct FGameplayEventData& Payload);
	void ReceiveTargetData(const struct FGameplayAbilityTargetDataHandle& TargetData);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzGA_KatanaArm">();
	}
	static class UGzGA_KatanaArm* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzGA_KatanaArm>();
	}
};
static_assert(alignof(UGzGA_KatanaArm) == 0x000008, "Wrong alignment on UGzGA_KatanaArm");
static_assert(sizeof(UGzGA_KatanaArm) == 0x0008D0, "Wrong size on UGzGA_KatanaArm");
static_assert(offsetof(UGzGA_KatanaArm, bEnableExtraDashingCollision) == 0x0006F8, "Member 'UGzGA_KatanaArm::bEnableExtraDashingCollision' has a wrong offset!");
static_assert(offsetof(UGzGA_KatanaArm, ExtraDashingCollisionProfileName) == 0x0006FC, "Member 'UGzGA_KatanaArm::ExtraDashingCollisionProfileName' has a wrong offset!");
static_assert(offsetof(UGzGA_KatanaArm, ExtraDashingCollisionRelativeOffset) == 0x000708, "Member 'UGzGA_KatanaArm::ExtraDashingCollisionRelativeOffset' has a wrong offset!");
static_assert(offsetof(UGzGA_KatanaArm, ExtraDashingCollisionExtents) == 0x000720, "Member 'UGzGA_KatanaArm::ExtraDashingCollisionExtents' has a wrong offset!");
static_assert(offsetof(UGzGA_KatanaArm, ExtraTraceDistance) == 0x000738, "Member 'UGzGA_KatanaArm::ExtraTraceDistance' has a wrong offset!");
static_assert(offsetof(UGzGA_KatanaArm, SweepSphereRadius) == 0x00073C, "Member 'UGzGA_KatanaArm::SweepSphereRadius' has a wrong offset!");
static_assert(offsetof(UGzGA_KatanaArm, TargetValidationRadius) == 0x000740, "Member 'UGzGA_KatanaArm::TargetValidationRadius' has a wrong offset!");
static_assert(offsetof(UGzGA_KatanaArm, InnerTargetValidationRadius) == 0x000744, "Member 'UGzGA_KatanaArm::InnerTargetValidationRadius' has a wrong offset!");
static_assert(offsetof(UGzGA_KatanaArm, DamageEffectClass) == 0x000748, "Member 'UGzGA_KatanaArm::DamageEffectClass' has a wrong offset!");
static_assert(offsetof(UGzGA_KatanaArm, CenterHalfConeAngle) == 0x000750, "Member 'UGzGA_KatanaArm::CenterHalfConeAngle' has a wrong offset!");
static_assert(offsetof(UGzGA_KatanaArm, SideHalfConeAngle) == 0x000754, "Member 'UGzGA_KatanaArm::SideHalfConeAngle' has a wrong offset!");
static_assert(offsetof(UGzGA_KatanaArm, AttackHalfHeight) == 0x000758, "Member 'UGzGA_KatanaArm::AttackHalfHeight' has a wrong offset!");
static_assert(offsetof(UGzGA_KatanaArm, AttackUpOffset) == 0x00075C, "Member 'UGzGA_KatanaArm::AttackUpOffset' has a wrong offset!");
static_assert(offsetof(UGzGA_KatanaArm, ValidTargetCollisionChannels) == 0x000760, "Member 'UGzGA_KatanaArm::ValidTargetCollisionChannels' has a wrong offset!");
static_assert(offsetof(UGzGA_KatanaArm, HorizontalAttackCameraTag) == 0x000770, "Member 'UGzGA_KatanaArm::HorizontalAttackCameraTag' has a wrong offset!");
static_assert(offsetof(UGzGA_KatanaArm, VerticalAttackCameraTag) == 0x000778, "Member 'UGzGA_KatanaArm::VerticalAttackCameraTag' has a wrong offset!");
static_assert(offsetof(UGzGA_KatanaArm, AnimationTimeout) == 0x000780, "Member 'UGzGA_KatanaArm::AnimationTimeout' has a wrong offset!");
static_assert(offsetof(UGzGA_KatanaArm, AttackImpaleGameplayCueTag) == 0x000784, "Member 'UGzGA_KatanaArm::AttackImpaleGameplayCueTag' has a wrong offset!");
static_assert(offsetof(UGzGA_KatanaArm, KatanaComponent) == 0x000790, "Member 'UGzGA_KatanaArm::KatanaComponent' has a wrong offset!");
static_assert(offsetof(UGzGA_KatanaArm, WaitForDashDataTask) == 0x000798, "Member 'UGzGA_KatanaArm::WaitForDashDataTask' has a wrong offset!");
static_assert(offsetof(UGzGA_KatanaArm, bIsDashingVertically) == 0x0007A0, "Member 'UGzGA_KatanaArm::bIsDashingVertically' has a wrong offset!");

// Class G01.GzHUDRuntimeSettings
// 0x0000 (0x0038 - 0x0038)
class UGzHUDRuntimeSettings : public UDeveloperSettings
{
public:
	void ApplySettings();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzHUDRuntimeSettings">();
	}
	static class UGzHUDRuntimeSettings* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzHUDRuntimeSettings>();
	}
};
static_assert(alignof(UGzHUDRuntimeSettings) == 0x000008, "Wrong alignment on UGzHUDRuntimeSettings");
static_assert(sizeof(UGzHUDRuntimeSettings) == 0x000038, "Wrong size on UGzHUDRuntimeSettings");

// Class G01.GzGA_KineticShield
// 0x0010 (0x0688 - 0x0678)
class UGzGA_KineticShield : public UGzGA_BaseLimbAbility
{
public:
	bool                                          bAllowFriendlyFire;                                // 0x0678(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3305[0x7];                                     // 0x0679(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UGzGE_BaseDamage>           BlastDamageEffect;                                 // 0x0680(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	bool ApplyBlastDamage(const struct FHitResult& TargetHitResult, const float DamageAmount);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzGA_KineticShield">();
	}
	static class UGzGA_KineticShield* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzGA_KineticShield>();
	}
};
static_assert(alignof(UGzGA_KineticShield) == 0x000008, "Wrong alignment on UGzGA_KineticShield");
static_assert(sizeof(UGzGA_KineticShield) == 0x000688, "Wrong size on UGzGA_KineticShield");
static_assert(offsetof(UGzGA_KineticShield, bAllowFriendlyFire) == 0x000678, "Member 'UGzGA_KineticShield::bAllowFriendlyFire' has a wrong offset!");
static_assert(offsetof(UGzGA_KineticShield, BlastDamageEffect) == 0x000680, "Member 'UGzGA_KineticShield::BlastDamageEffect' has a wrong offset!");

// Class G01.GzServerLaunchSettings
// 0x0088 (0x00C0 - 0x0038)
class UGzServerLaunchSettings final : public UDeveloperSettings
{
public:
	class FString                                 MapName;                                           // 0x0038(0x0010)(Edit, ZeroConstructor, Config, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 HiddenAdditionalCommandOptions;                    // 0x0048(0x0010)(Edit, ZeroConstructor, Config, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 TraceCommandOptions;                               // 0x0058(0x0010)(Edit, ZeroConstructor, Config, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGzServerLaunchOptions                 LaunchOptions;                                     // 0x0068(0x0058)(Edit, Config, DisableEditOnInstance, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzServerLaunchSettings">();
	}
	static class UGzServerLaunchSettings* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzServerLaunchSettings>();
	}
};
static_assert(alignof(UGzServerLaunchSettings) == 0x000008, "Wrong alignment on UGzServerLaunchSettings");
static_assert(sizeof(UGzServerLaunchSettings) == 0x0000C0, "Wrong size on UGzServerLaunchSettings");
static_assert(offsetof(UGzServerLaunchSettings, MapName) == 0x000038, "Member 'UGzServerLaunchSettings::MapName' has a wrong offset!");
static_assert(offsetof(UGzServerLaunchSettings, HiddenAdditionalCommandOptions) == 0x000048, "Member 'UGzServerLaunchSettings::HiddenAdditionalCommandOptions' has a wrong offset!");
static_assert(offsetof(UGzServerLaunchSettings, TraceCommandOptions) == 0x000058, "Member 'UGzServerLaunchSettings::TraceCommandOptions' has a wrong offset!");
static_assert(offsetof(UGzServerLaunchSettings, LaunchOptions) == 0x000068, "Member 'UGzServerLaunchSettings::LaunchOptions' has a wrong offset!");

// Class G01.GzMissionRuntimeContext_BountyHunter
// 0x0008 (0x0030 - 0x0028)
class UGzMissionRuntimeContext_BountyHunter final : public UMissionRuntimeContext
{
public:
	int32                                         PickedPlayerId;                                    // 0x0028(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3307[0x4];                                     // 0x002C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzMissionRuntimeContext_BountyHunter">();
	}
	static class UGzMissionRuntimeContext_BountyHunter* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzMissionRuntimeContext_BountyHunter>();
	}
};
static_assert(alignof(UGzMissionRuntimeContext_BountyHunter) == 0x000008, "Wrong alignment on UGzMissionRuntimeContext_BountyHunter");
static_assert(sizeof(UGzMissionRuntimeContext_BountyHunter) == 0x000030, "Wrong size on UGzMissionRuntimeContext_BountyHunter");
static_assert(offsetof(UGzMissionRuntimeContext_BountyHunter, PickedPlayerId) == 0x000028, "Member 'UGzMissionRuntimeContext_BountyHunter::PickedPlayerId' has a wrong offset!");

// Class G01.GzGA_KneeSlide
// 0x0040 (0x0548 - 0x0508)
class UGzGA_KneeSlide final : public UGzGameplayAbility
{
public:
	class UAnimMontage*                           Montage;                                           // 0x0508(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         Force;                                             // 0x0510(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bAdditive;                                         // 0x0514(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bEnableGravity;                                    // 0x0515(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	ERootMotionFinishVelocityMode                 VelocityMode;                                      // 0x0516(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_3308[0x1];                                     // 0x0517(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ClampEndVelocityTo;                                // 0x0518(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_3309[0x4];                                     // 0x051C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                SetEndVelocityTo;                                  // 0x0520(0x0018)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UGzAT_PlayMontageAndWaitForEvent*       PlayMontageAndWaitForEventTask;                    // 0x0538(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UAbilityTask_ApplyRootMotionConstantForce* ApplyRootMotionConstantForce;                      // 0x0540(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void OnMontageEnded();
	void OnMontageInterrupted();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzGA_KneeSlide">();
	}
	static class UGzGA_KneeSlide* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzGA_KneeSlide>();
	}
};
static_assert(alignof(UGzGA_KneeSlide) == 0x000008, "Wrong alignment on UGzGA_KneeSlide");
static_assert(sizeof(UGzGA_KneeSlide) == 0x000548, "Wrong size on UGzGA_KneeSlide");
static_assert(offsetof(UGzGA_KneeSlide, Montage) == 0x000508, "Member 'UGzGA_KneeSlide::Montage' has a wrong offset!");
static_assert(offsetof(UGzGA_KneeSlide, Force) == 0x000510, "Member 'UGzGA_KneeSlide::Force' has a wrong offset!");
static_assert(offsetof(UGzGA_KneeSlide, bAdditive) == 0x000514, "Member 'UGzGA_KneeSlide::bAdditive' has a wrong offset!");
static_assert(offsetof(UGzGA_KneeSlide, bEnableGravity) == 0x000515, "Member 'UGzGA_KneeSlide::bEnableGravity' has a wrong offset!");
static_assert(offsetof(UGzGA_KneeSlide, VelocityMode) == 0x000516, "Member 'UGzGA_KneeSlide::VelocityMode' has a wrong offset!");
static_assert(offsetof(UGzGA_KneeSlide, ClampEndVelocityTo) == 0x000518, "Member 'UGzGA_KneeSlide::ClampEndVelocityTo' has a wrong offset!");
static_assert(offsetof(UGzGA_KneeSlide, SetEndVelocityTo) == 0x000520, "Member 'UGzGA_KneeSlide::SetEndVelocityTo' has a wrong offset!");
static_assert(offsetof(UGzGA_KneeSlide, PlayMontageAndWaitForEventTask) == 0x000538, "Member 'UGzGA_KneeSlide::PlayMontageAndWaitForEventTask' has a wrong offset!");
static_assert(offsetof(UGzGA_KneeSlide, ApplyRootMotionConstantForce) == 0x000540, "Member 'UGzGA_KneeSlide::ApplyRootMotionConstantForce' has a wrong offset!");

// Class G01.GzMissionObjectInteractionBehavior
// 0x0020 (0x00F8 - 0x00D8)
class UGzMissionObjectInteractionBehavior final : public UMontageInteractionBehavior
{
public:
	TArray<class UGzObjective*>                   RegisteredObjectives;                              // 0x00D8(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	TArray<class UMissionObjective*>              RegisteredMissionObjectives;                       // 0x00E8(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)

public:
	void RegisterObjective(class UGzObjective* Objective);
	void UnregisterObjective(class UGzObjective* Objective);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzMissionObjectInteractionBehavior">();
	}
	static class UGzMissionObjectInteractionBehavior* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzMissionObjectInteractionBehavior>();
	}
};
static_assert(alignof(UGzMissionObjectInteractionBehavior) == 0x000008, "Wrong alignment on UGzMissionObjectInteractionBehavior");
static_assert(sizeof(UGzMissionObjectInteractionBehavior) == 0x0000F8, "Wrong size on UGzMissionObjectInteractionBehavior");
static_assert(offsetof(UGzMissionObjectInteractionBehavior, RegisteredObjectives) == 0x0000D8, "Member 'UGzMissionObjectInteractionBehavior::RegisteredObjectives' has a wrong offset!");
static_assert(offsetof(UGzMissionObjectInteractionBehavior, RegisteredMissionObjectives) == 0x0000E8, "Member 'UGzMissionObjectInteractionBehavior::RegisteredMissionObjectives' has a wrong offset!");

// Class G01.GzGA_KnockdownState
// 0x0018 (0x0568 - 0x0550)
class UGzGA_KnockdownState : public UGzGA_CharacterState
{
public:
	TArray<TSubclassOf<class UGameplayAbility>>   AbilitiesToReactivate;                             // 0x0550(0x0010)(Edit, ZeroConstructor, DisableEditOnTemplate, EditConst, Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	TSubclassOf<class UGameplayEffect>            TemporarilyDamageImmunityClass;                    // 0x0560(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzGA_KnockdownState">();
	}
	static class UGzGA_KnockdownState* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzGA_KnockdownState>();
	}
};
static_assert(alignof(UGzGA_KnockdownState) == 0x000008, "Wrong alignment on UGzGA_KnockdownState");
static_assert(sizeof(UGzGA_KnockdownState) == 0x000568, "Wrong size on UGzGA_KnockdownState");
static_assert(offsetof(UGzGA_KnockdownState, AbilitiesToReactivate) == 0x000550, "Member 'UGzGA_KnockdownState::AbilitiesToReactivate' has a wrong offset!");
static_assert(offsetof(UGzGA_KnockdownState, TemporarilyDamageImmunityClass) == 0x000560, "Member 'UGzGA_KnockdownState::TemporarilyDamageImmunityClass' has a wrong offset!");

// Class G01.GzProjectileAttackStrategy
// 0x0000 (0x00A8 - 0x00A8)
class UGzProjectileAttackStrategy final : public UGzWeaponAttackStrategy
{
public:
	void NotifyAttack();
	void ProcessAttackRequest(const struct FVector& Location, const struct FVector& Direction, uint8 ShotID);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzProjectileAttackStrategy">();
	}
	static class UGzProjectileAttackStrategy* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzProjectileAttackStrategy>();
	}
};
static_assert(alignof(UGzProjectileAttackStrategy) == 0x000008, "Wrong alignment on UGzProjectileAttackStrategy");
static_assert(sizeof(UGzProjectileAttackStrategy) == 0x0000A8, "Wrong size on UGzProjectileAttackStrategy");

// Class G01.GzGA_LimbPassive
// 0x0008 (0x0530 - 0x0528)
class UGzGA_LimbPassive final : public UGzGA_Passive
{
public:
	class UGzBodyPartAbilityData*                 BodyPartAbilityData;                               // 0x0528(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void ReadAbilityConfig();

	class UGzBodyPartAbilityData* GetAbilityData() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzGA_LimbPassive">();
	}
	static class UGzGA_LimbPassive* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzGA_LimbPassive>();
	}
};
static_assert(alignof(UGzGA_LimbPassive) == 0x000008, "Wrong alignment on UGzGA_LimbPassive");
static_assert(sizeof(UGzGA_LimbPassive) == 0x000530, "Wrong size on UGzGA_LimbPassive");
static_assert(offsetof(UGzGA_LimbPassive, BodyPartAbilityData) == 0x000528, "Member 'UGzGA_LimbPassive::BodyPartAbilityData' has a wrong offset!");

// Class G01.GzGA_Mantle
// 0x0488 (0x0990 - 0x0508)
class UGzGA_Mantle : public UGzGameplayAbility
{
public:
	struct FLocomotionMantleTraceSettings         MantleTraceSettings;                               // 0x0508(0x0020)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, Protected, NativeAccessSpecifierProtected)
	class ULocomotionVaultingAssetCollection*     Assets;                                            // 0x0528(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<ECollisionChannel>                     MantleableObjectTypes;                             // 0x0530(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	float                                         AngleLimit;                                        // 0x0540(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         TraceForwardCapsuleHalfHeight;                     // 0x0544(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bUseVelocityForDirection;                          // 0x0548(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_330B[0x3];                                     // 0x0549(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         CliffOffset;                                       // 0x054C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MaxCliffAngle;                                     // 0x0550(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_330C[0x4];                                     // 0x0554(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UGzCharacterMovementComponent*          CachedMovementComponent;                           // 0x0558(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FMantleAbilityActivationData           InitData;                                          // 0x0560(0x03D0)(Transient, NoDestructor, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	class UGzAT_AbilityTick*                      CheckCancelInputTickTask;                          // 0x0930(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   AllowCancelCurveName;                              // 0x0938(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   AllowCancelAnimCurveName;                          // 0x0940(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UInputAction*                           CancelInputAction;                                 // 0x0948(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         CancelInputActionHandle;                           // 0x0950(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   AllowEarlyFinishCurveName;                         // 0x0954(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_330D[0x4];                                     // 0x095C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UInputAction*>                   EarlyFinishInputActions;                           // 0x0960(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	uint8                                         Pad_330E[0x8];                                     // 0x0970(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UAbilityTask_PlayMontageAndWait*        MantleMontageTask;                                 // 0x0978(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_330F[0x10];                                    // 0x0980(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnCancelPressed();
	void UpdateTick(float DeltaTime);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzGA_Mantle">();
	}
	static class UGzGA_Mantle* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzGA_Mantle>();
	}
};
static_assert(alignof(UGzGA_Mantle) == 0x000010, "Wrong alignment on UGzGA_Mantle");
static_assert(sizeof(UGzGA_Mantle) == 0x000990, "Wrong size on UGzGA_Mantle");
static_assert(offsetof(UGzGA_Mantle, MantleTraceSettings) == 0x000508, "Member 'UGzGA_Mantle::MantleTraceSettings' has a wrong offset!");
static_assert(offsetof(UGzGA_Mantle, Assets) == 0x000528, "Member 'UGzGA_Mantle::Assets' has a wrong offset!");
static_assert(offsetof(UGzGA_Mantle, MantleableObjectTypes) == 0x000530, "Member 'UGzGA_Mantle::MantleableObjectTypes' has a wrong offset!");
static_assert(offsetof(UGzGA_Mantle, AngleLimit) == 0x000540, "Member 'UGzGA_Mantle::AngleLimit' has a wrong offset!");
static_assert(offsetof(UGzGA_Mantle, TraceForwardCapsuleHalfHeight) == 0x000544, "Member 'UGzGA_Mantle::TraceForwardCapsuleHalfHeight' has a wrong offset!");
static_assert(offsetof(UGzGA_Mantle, bUseVelocityForDirection) == 0x000548, "Member 'UGzGA_Mantle::bUseVelocityForDirection' has a wrong offset!");
static_assert(offsetof(UGzGA_Mantle, CliffOffset) == 0x00054C, "Member 'UGzGA_Mantle::CliffOffset' has a wrong offset!");
static_assert(offsetof(UGzGA_Mantle, MaxCliffAngle) == 0x000550, "Member 'UGzGA_Mantle::MaxCliffAngle' has a wrong offset!");
static_assert(offsetof(UGzGA_Mantle, CachedMovementComponent) == 0x000558, "Member 'UGzGA_Mantle::CachedMovementComponent' has a wrong offset!");
static_assert(offsetof(UGzGA_Mantle, InitData) == 0x000560, "Member 'UGzGA_Mantle::InitData' has a wrong offset!");
static_assert(offsetof(UGzGA_Mantle, CheckCancelInputTickTask) == 0x000930, "Member 'UGzGA_Mantle::CheckCancelInputTickTask' has a wrong offset!");
static_assert(offsetof(UGzGA_Mantle, AllowCancelCurveName) == 0x000938, "Member 'UGzGA_Mantle::AllowCancelCurveName' has a wrong offset!");
static_assert(offsetof(UGzGA_Mantle, AllowCancelAnimCurveName) == 0x000940, "Member 'UGzGA_Mantle::AllowCancelAnimCurveName' has a wrong offset!");
static_assert(offsetof(UGzGA_Mantle, CancelInputAction) == 0x000948, "Member 'UGzGA_Mantle::CancelInputAction' has a wrong offset!");
static_assert(offsetof(UGzGA_Mantle, CancelInputActionHandle) == 0x000950, "Member 'UGzGA_Mantle::CancelInputActionHandle' has a wrong offset!");
static_assert(offsetof(UGzGA_Mantle, AllowEarlyFinishCurveName) == 0x000954, "Member 'UGzGA_Mantle::AllowEarlyFinishCurveName' has a wrong offset!");
static_assert(offsetof(UGzGA_Mantle, EarlyFinishInputActions) == 0x000960, "Member 'UGzGA_Mantle::EarlyFinishInputActions' has a wrong offset!");
static_assert(offsetof(UGzGA_Mantle, MantleMontageTask) == 0x000978, "Member 'UGzGA_Mantle::MantleMontageTask' has a wrong offset!");

// Class G01.GzGA_Mantle_Cancel
// 0x0010 (0x0518 - 0x0508)
class UGzGA_Mantle_Cancel : public UGzGameplayAbility
{
public:
	class UAnimMontage*                           CancelMontage;                                     // 0x0508(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAbilityTask_PlayMontageAndWait*        CancelMontageTask;                                 // 0x0510(0x0008)(ZeroConstructor, Transient, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzGA_Mantle_Cancel">();
	}
	static class UGzGA_Mantle_Cancel* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzGA_Mantle_Cancel>();
	}
};
static_assert(alignof(UGzGA_Mantle_Cancel) == 0x000008, "Wrong alignment on UGzGA_Mantle_Cancel");
static_assert(sizeof(UGzGA_Mantle_Cancel) == 0x000518, "Wrong size on UGzGA_Mantle_Cancel");
static_assert(offsetof(UGzGA_Mantle_Cancel, CancelMontage) == 0x000508, "Member 'UGzGA_Mantle_Cancel::CancelMontage' has a wrong offset!");
static_assert(offsetof(UGzGA_Mantle_Cancel, CancelMontageTask) == 0x000510, "Member 'UGzGA_Mantle_Cancel::CancelMontageTask' has a wrong offset!");

// Class G01.GzSkeletalMeshPickable
// 0x0010 (0x0490 - 0x0480)
#pragma pack(push, 0x1)
class alignas(0x10) AGzSkeletalMeshPickable : public AGzPickableBase
{
public:
	class USkeletalMeshComponent*                 MeshComponent;                                     // 0x0478(0x0008)(Edit, ExportObject, ZeroConstructor, Transient, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MeshTickIntervalAfterPhysicsStartSleeping;         // 0x0480(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3310[0x4];                                     // 0x0484(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzSkeletalMeshPickable">();
	}
	static class AGzSkeletalMeshPickable* GetDefaultObj()
	{
		return GetDefaultObjImpl<AGzSkeletalMeshPickable>();
	}
};
#pragma pack(pop)
static_assert(alignof(AGzSkeletalMeshPickable) == 0x000010, "Wrong alignment on AGzSkeletalMeshPickable");
static_assert(sizeof(AGzSkeletalMeshPickable) == 0x000490, "Wrong size on AGzSkeletalMeshPickable");
static_assert(offsetof(AGzSkeletalMeshPickable, MeshComponent) == 0x000478, "Member 'AGzSkeletalMeshPickable::MeshComponent' has a wrong offset!");
static_assert(offsetof(AGzSkeletalMeshPickable, MeshTickIntervalAfterPhysicsStartSleeping) == 0x000480, "Member 'AGzSkeletalMeshPickable::MeshTickIntervalAfterPhysicsStartSleeping' has a wrong offset!");

// Class G01.GzWeaponPickable
// 0x0050 (0x04E0 - 0x0490)
class AGzWeaponPickable final : public AGzSkeletalMeshPickable
{
public:
	uint8                                         Pad_3311[0x8];                                     // 0x0488(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGzWeaponInvItem                       WeaponItem;                                        // 0x0490(0x0050)(Net, Transient, NativeAccessSpecifierPrivate)

public:
	const struct FGzWeaponInvItem GetWeaponItem() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzWeaponPickable">();
	}
	static class AGzWeaponPickable* GetDefaultObj()
	{
		return GetDefaultObjImpl<AGzWeaponPickable>();
	}
};
static_assert(alignof(AGzWeaponPickable) == 0x000010, "Wrong alignment on AGzWeaponPickable");
static_assert(sizeof(AGzWeaponPickable) == 0x0004E0, "Wrong size on AGzWeaponPickable");
static_assert(offsetof(AGzWeaponPickable, WeaponItem) == 0x000490, "Member 'AGzWeaponPickable::WeaponItem' has a wrong offset!");

// Class G01.GzGA_Mantle_JumpOff
// 0x0028 (0x0530 - 0x0508)
class UGzGA_Mantle_JumpOff : public UGzGameplayAbility
{
public:
	class UAnimMontage*                           JumpOffLeftMontage;                                // 0x0508(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAnimMontage*                           JumpOffRightMontage;                               // 0x0510(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   AllowJumpOffCurveName;                             // 0x0518(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         JumpOffTranslationScale;                           // 0x0520(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3312[0x4];                                     // 0x0524(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UAbilityTask_PlayMontageAndWait*        JumpOffMontageTask;                                // 0x0528(0x0008)(ZeroConstructor, Transient, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzGA_Mantle_JumpOff">();
	}
	static class UGzGA_Mantle_JumpOff* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzGA_Mantle_JumpOff>();
	}
};
static_assert(alignof(UGzGA_Mantle_JumpOff) == 0x000008, "Wrong alignment on UGzGA_Mantle_JumpOff");
static_assert(sizeof(UGzGA_Mantle_JumpOff) == 0x000530, "Wrong size on UGzGA_Mantle_JumpOff");
static_assert(offsetof(UGzGA_Mantle_JumpOff, JumpOffLeftMontage) == 0x000508, "Member 'UGzGA_Mantle_JumpOff::JumpOffLeftMontage' has a wrong offset!");
static_assert(offsetof(UGzGA_Mantle_JumpOff, JumpOffRightMontage) == 0x000510, "Member 'UGzGA_Mantle_JumpOff::JumpOffRightMontage' has a wrong offset!");
static_assert(offsetof(UGzGA_Mantle_JumpOff, AllowJumpOffCurveName) == 0x000518, "Member 'UGzGA_Mantle_JumpOff::AllowJumpOffCurveName' has a wrong offset!");
static_assert(offsetof(UGzGA_Mantle_JumpOff, JumpOffTranslationScale) == 0x000520, "Member 'UGzGA_Mantle_JumpOff::JumpOffTranslationScale' has a wrong offset!");
static_assert(offsetof(UGzGA_Mantle_JumpOff, JumpOffMontageTask) == 0x000528, "Member 'UGzGA_Mantle_JumpOff::JumpOffMontageTask' has a wrong offset!");

// Class G01.GzGA_SpiderMine
// 0x0040 (0x06B8 - 0x0678)
class UGzGA_SpiderMine : public UGzGA_BaseLimbAbility
{
public:
	class UGzSpiderMine_PreviewComponent*         AsSpiderMine_PreviewComponent;                     // 0x0678(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, Transient, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class AGzMultiPartCharacter*                  AsGzMultipartCharacter;                            // 0x0680(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FName                                   HandTransformLeftArmSocket;                        // 0x0688(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FName                                   HandTransformRightArmSocket;                       // 0x0690(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UInputAction*                           ToLinkMineInput;                                   // 0x0698(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UGzAT_WaitCustomInputRelease*           LinkedMineTask;                                    // 0x06A0(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UGzAT_ServerWaitForTargetData*          ServerWaitAsyncTask;                               // 0x06A8(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         ActivationDelay;                                   // 0x06B0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_3313[0x4];                                     // 0x06B4(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ActivationAfterDelay();
	void AssignOnFinish();
	struct FVector GetHandTransform();
	void OnMineInputRelease(float TimeHeld);
	void OnMineShootRequested();
	void OnReceiveTargetLocationOnServer(const struct FGameplayAbilityTargetDataHandle& TargetDataHandle);
	class AGzSpiderMine* SpawnMine(const struct FTransform& Transform, const struct FGzSpiderMine_SpawnInfo& SpawnInfo);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzGA_SpiderMine">();
	}
	static class UGzGA_SpiderMine* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzGA_SpiderMine>();
	}
};
static_assert(alignof(UGzGA_SpiderMine) == 0x000008, "Wrong alignment on UGzGA_SpiderMine");
static_assert(sizeof(UGzGA_SpiderMine) == 0x0006B8, "Wrong size on UGzGA_SpiderMine");
static_assert(offsetof(UGzGA_SpiderMine, AsSpiderMine_PreviewComponent) == 0x000678, "Member 'UGzGA_SpiderMine::AsSpiderMine_PreviewComponent' has a wrong offset!");
static_assert(offsetof(UGzGA_SpiderMine, AsGzMultipartCharacter) == 0x000680, "Member 'UGzGA_SpiderMine::AsGzMultipartCharacter' has a wrong offset!");
static_assert(offsetof(UGzGA_SpiderMine, HandTransformLeftArmSocket) == 0x000688, "Member 'UGzGA_SpiderMine::HandTransformLeftArmSocket' has a wrong offset!");
static_assert(offsetof(UGzGA_SpiderMine, HandTransformRightArmSocket) == 0x000690, "Member 'UGzGA_SpiderMine::HandTransformRightArmSocket' has a wrong offset!");
static_assert(offsetof(UGzGA_SpiderMine, ToLinkMineInput) == 0x000698, "Member 'UGzGA_SpiderMine::ToLinkMineInput' has a wrong offset!");
static_assert(offsetof(UGzGA_SpiderMine, LinkedMineTask) == 0x0006A0, "Member 'UGzGA_SpiderMine::LinkedMineTask' has a wrong offset!");
static_assert(offsetof(UGzGA_SpiderMine, ServerWaitAsyncTask) == 0x0006A8, "Member 'UGzGA_SpiderMine::ServerWaitAsyncTask' has a wrong offset!");
static_assert(offsetof(UGzGA_SpiderMine, ActivationDelay) == 0x0006B0, "Member 'UGzGA_SpiderMine::ActivationDelay' has a wrong offset!");

// Class G01.GzGA_SuperSprint_Sprint
// 0x00A8 (0x05F8 - 0x0550)
class UGzGA_SuperSprint_Sprint final : public UGzGA_CharacterState
{
public:
	float                                         MininmumSprintSpeedNecessary;                      // 0x0550(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3315[0x4];                                     // 0x0554(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftObjectPtr<class UCurveFloat>             SprintAbortThresholdCurve;                         // 0x0558(0x0028)(Edit, DisableEditOnInstance, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftObjectPtr<class UAnimMontage>            SprintLoopMontage;                                 // 0x0580(0x0028)(Edit, DisableEditOnInstance, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftClassPtr<class UClass>                   TrailActor;                                        // 0x05A8(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UGzAT_SuperSprintTrailSpawner*          TrailSpawnerTask;                                  // 0x05D0(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UGzBodyPartAbilityData_SuperSprintLegs* AbilityData;                                       // 0x05D8(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UGzAT_WatchSprintConditions*            SprintConditionsWatcher;                           // 0x05E0(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3316[0x10];                                    // 0x05E8(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnAssetsLoaded();
	void OnSprintConditionFailed(const struct FGameplayEventData& Payload);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzGA_SuperSprint_Sprint">();
	}
	static class UGzGA_SuperSprint_Sprint* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzGA_SuperSprint_Sprint>();
	}
};
static_assert(alignof(UGzGA_SuperSprint_Sprint) == 0x000008, "Wrong alignment on UGzGA_SuperSprint_Sprint");
static_assert(sizeof(UGzGA_SuperSprint_Sprint) == 0x0005F8, "Wrong size on UGzGA_SuperSprint_Sprint");
static_assert(offsetof(UGzGA_SuperSprint_Sprint, MininmumSprintSpeedNecessary) == 0x000550, "Member 'UGzGA_SuperSprint_Sprint::MininmumSprintSpeedNecessary' has a wrong offset!");
static_assert(offsetof(UGzGA_SuperSprint_Sprint, SprintAbortThresholdCurve) == 0x000558, "Member 'UGzGA_SuperSprint_Sprint::SprintAbortThresholdCurve' has a wrong offset!");
static_assert(offsetof(UGzGA_SuperSprint_Sprint, SprintLoopMontage) == 0x000580, "Member 'UGzGA_SuperSprint_Sprint::SprintLoopMontage' has a wrong offset!");
static_assert(offsetof(UGzGA_SuperSprint_Sprint, TrailActor) == 0x0005A8, "Member 'UGzGA_SuperSprint_Sprint::TrailActor' has a wrong offset!");
static_assert(offsetof(UGzGA_SuperSprint_Sprint, TrailSpawnerTask) == 0x0005D0, "Member 'UGzGA_SuperSprint_Sprint::TrailSpawnerTask' has a wrong offset!");
static_assert(offsetof(UGzGA_SuperSprint_Sprint, AbilityData) == 0x0005D8, "Member 'UGzGA_SuperSprint_Sprint::AbilityData' has a wrong offset!");
static_assert(offsetof(UGzGA_SuperSprint_Sprint, SprintConditionsWatcher) == 0x0005E0, "Member 'UGzGA_SuperSprint_Sprint::SprintConditionsWatcher' has a wrong offset!");

// Class G01.GzWeaponAnimationData
// 0x0078 (0x00A8 - 0x0030)
class UGzWeaponAnimationData final : public UDataAsset
{
public:
	ELocomotionOverlayState                       WeaponAnimOverlay;                                 // 0x0030(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3317[0x7];                                     // 0x0031(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FGzWeaponShootingAnimationData> ShootingDataPerSituation;                          // 0x0038(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TArray<struct FGzWeaponReloadAnimationData>   ReloadDataPerSituation;                            // 0x0048(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TArray<struct FGzWeaponReloadAnimationData>   RechamberDataPerSituation;                         // 0x0058(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TArray<struct FGzWeaponAnimationLayerData>    LayerDataPerSituation;                             // 0x0068(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FVector                                JointTargetLocation;                               // 0x0078(0x0018)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UCameraShakeBase>           ShotCameraShake;                                   // 0x0090(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UCameraShakeBase>           ShotADSCameraShake;                                // 0x0098(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EGzWeaponSupportHoldType                      LHBodySupportHoldTypeDefault;                      // 0x00A0(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3318[0x7];                                     // 0x00A1(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzWeaponAnimationData">();
	}
	static class UGzWeaponAnimationData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzWeaponAnimationData>();
	}
};
static_assert(alignof(UGzWeaponAnimationData) == 0x000008, "Wrong alignment on UGzWeaponAnimationData");
static_assert(sizeof(UGzWeaponAnimationData) == 0x0000A8, "Wrong size on UGzWeaponAnimationData");
static_assert(offsetof(UGzWeaponAnimationData, WeaponAnimOverlay) == 0x000030, "Member 'UGzWeaponAnimationData::WeaponAnimOverlay' has a wrong offset!");
static_assert(offsetof(UGzWeaponAnimationData, ShootingDataPerSituation) == 0x000038, "Member 'UGzWeaponAnimationData::ShootingDataPerSituation' has a wrong offset!");
static_assert(offsetof(UGzWeaponAnimationData, ReloadDataPerSituation) == 0x000048, "Member 'UGzWeaponAnimationData::ReloadDataPerSituation' has a wrong offset!");
static_assert(offsetof(UGzWeaponAnimationData, RechamberDataPerSituation) == 0x000058, "Member 'UGzWeaponAnimationData::RechamberDataPerSituation' has a wrong offset!");
static_assert(offsetof(UGzWeaponAnimationData, LayerDataPerSituation) == 0x000068, "Member 'UGzWeaponAnimationData::LayerDataPerSituation' has a wrong offset!");
static_assert(offsetof(UGzWeaponAnimationData, JointTargetLocation) == 0x000078, "Member 'UGzWeaponAnimationData::JointTargetLocation' has a wrong offset!");
static_assert(offsetof(UGzWeaponAnimationData, ShotCameraShake) == 0x000090, "Member 'UGzWeaponAnimationData::ShotCameraShake' has a wrong offset!");
static_assert(offsetof(UGzWeaponAnimationData, ShotADSCameraShake) == 0x000098, "Member 'UGzWeaponAnimationData::ShotADSCameraShake' has a wrong offset!");
static_assert(offsetof(UGzWeaponAnimationData, LHBodySupportHoldTypeDefault) == 0x0000A0, "Member 'UGzWeaponAnimationData::LHBodySupportHoldTypeDefault' has a wrong offset!");

// Class G01.GzGA_SwapLimb
// 0x00D8 (0x0730 - 0x0658)
class UGzGA_SwapLimb : public UGzGA_BaseLimbInteraction
{
public:
	struct FGzLimbAttachingParams                 AttachingParams;                                   // 0x0658(0x0040)(Edit, BlueprintVisible, DisableEditOnInstance, NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FGzLimbDetachingParams                 DetachingParams;                                   // 0x0698(0x0060)(Edit, BlueprintVisible, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	class UGzBodyPartItemData*                    BodyPartItemData;                                  // 0x06F8(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UGzBodyPartData*                        BodyPartData;                                      // 0x0700(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UGzAT_AttachLimb*                       AttachLimbTask;                                    // 0x0708(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UGzAT_DetachLimb*                       DetachLimbTask;                                    // 0x0710(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_3319[0x18];                                    // 0x0718(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Detach();

	void InitiateCancelByPlayer() const;
	void LimbSwitchedMessage() const;
	void RecallCancelByPlayer() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzGA_SwapLimb">();
	}
	static class UGzGA_SwapLimb* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzGA_SwapLimb>();
	}
};
static_assert(alignof(UGzGA_SwapLimb) == 0x000008, "Wrong alignment on UGzGA_SwapLimb");
static_assert(sizeof(UGzGA_SwapLimb) == 0x000730, "Wrong size on UGzGA_SwapLimb");
static_assert(offsetof(UGzGA_SwapLimb, AttachingParams) == 0x000658, "Member 'UGzGA_SwapLimb::AttachingParams' has a wrong offset!");
static_assert(offsetof(UGzGA_SwapLimb, DetachingParams) == 0x000698, "Member 'UGzGA_SwapLimb::DetachingParams' has a wrong offset!");
static_assert(offsetof(UGzGA_SwapLimb, BodyPartItemData) == 0x0006F8, "Member 'UGzGA_SwapLimb::BodyPartItemData' has a wrong offset!");
static_assert(offsetof(UGzGA_SwapLimb, BodyPartData) == 0x000700, "Member 'UGzGA_SwapLimb::BodyPartData' has a wrong offset!");
static_assert(offsetof(UGzGA_SwapLimb, AttachLimbTask) == 0x000708, "Member 'UGzGA_SwapLimb::AttachLimbTask' has a wrong offset!");
static_assert(offsetof(UGzGA_SwapLimb, DetachLimbTask) == 0x000710, "Member 'UGzGA_SwapLimb::DetachLimbTask' has a wrong offset!");

// Class G01.GzWeaponAttachementSpawner
// 0x0018 (0x02B8 - 0x02A0)
class AGzWeaponAttachementSpawner final : public AActor
{
public:
	class UGzWeaponSpawner*                       WeaponSpawner;                                     // 0x02A0(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ACameraActor*                           CameraActor;                                       // 0x02A8(0x0008)(Edit, ZeroConstructor, DisableEditOnTemplate, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ASceneCapture2D*                        SceneCapture2D;                                    // 0x02B0(0x0008)(Edit, ZeroConstructor, DisableEditOnTemplate, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzWeaponAttachementSpawner">();
	}
	static class AGzWeaponAttachementSpawner* GetDefaultObj()
	{
		return GetDefaultObjImpl<AGzWeaponAttachementSpawner>();
	}
};
static_assert(alignof(AGzWeaponAttachementSpawner) == 0x000008, "Wrong alignment on AGzWeaponAttachementSpawner");
static_assert(sizeof(AGzWeaponAttachementSpawner) == 0x0002B8, "Wrong size on AGzWeaponAttachementSpawner");
static_assert(offsetof(AGzWeaponAttachementSpawner, WeaponSpawner) == 0x0002A0, "Member 'AGzWeaponAttachementSpawner::WeaponSpawner' has a wrong offset!");
static_assert(offsetof(AGzWeaponAttachementSpawner, CameraActor) == 0x0002A8, "Member 'AGzWeaponAttachementSpawner::CameraActor' has a wrong offset!");
static_assert(offsetof(AGzWeaponAttachementSpawner, SceneCapture2D) == 0x0002B0, "Member 'AGzWeaponAttachementSpawner::SceneCapture2D' has a wrong offset!");

// Class G01.GzGA_ThrowableShield
// 0x00E0 (0x0758 - 0x0678)
class UGzGA_ThrowableShield : public UGzGA_BaseLimbAbility
{
public:
	TSoftObjectPtr<class UGzThrowableShieldData>  ShieldData;                                        // 0x0678(0x0028)(Edit, DisableEditOnInstance, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UInputAction*                           LaunchInputAction;                                 // 0x06A0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftClassPtr<class UClass>                   LaunchedShieldEffectClass;                         // 0x06A8(0x0028)(Edit, DisableEditOnInstance, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftObjectPtr<class UAnimMontage>            ShieldActivationMontage;                           // 0x06D0(0x0028)(Edit, DisableEditOnInstance, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   ShieldAttachSocketName;                            // 0x06F8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   ShieldAimSocketName;                               // 0x0700(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FGameplayTag                           ShieldDeployEventTag;                              // 0x0708(0x0008)(Edit, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UGzAT_ServerWaitForTargetData*          AT_ServerWaitForTargetData;                        // 0x0710(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAbilityTask_PlayMontageAndWait*        AT_PlayMontage;                                    // 0x0718(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UGzAT_WaitCustomInputPress*             AT_WaitLaunchInputPress;                           // 0x0720(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UGzAT_WaitCustomInputRelease*           AT_WaitLaunchInputRelease;                         // 0x0728(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAbilityTask_WaitInputPress*            AT_WaitInputPress;                                 // 0x0730(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_331A[0x20];                                    // 0x0738(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void HandleAbilityInputPressed(float TimeHeld);
	void HandleLaunchInputPressed(float TimeHeld);
	void HandleLaunchInputReleased(float TimeHeld);
	void ReceiveClientTargetData(const struct FGameplayAbilityTargetDataHandle& TargetData);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzGA_ThrowableShield">();
	}
	static class UGzGA_ThrowableShield* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzGA_ThrowableShield>();
	}
};
static_assert(alignof(UGzGA_ThrowableShield) == 0x000008, "Wrong alignment on UGzGA_ThrowableShield");
static_assert(sizeof(UGzGA_ThrowableShield) == 0x000758, "Wrong size on UGzGA_ThrowableShield");
static_assert(offsetof(UGzGA_ThrowableShield, ShieldData) == 0x000678, "Member 'UGzGA_ThrowableShield::ShieldData' has a wrong offset!");
static_assert(offsetof(UGzGA_ThrowableShield, LaunchInputAction) == 0x0006A0, "Member 'UGzGA_ThrowableShield::LaunchInputAction' has a wrong offset!");
static_assert(offsetof(UGzGA_ThrowableShield, LaunchedShieldEffectClass) == 0x0006A8, "Member 'UGzGA_ThrowableShield::LaunchedShieldEffectClass' has a wrong offset!");
static_assert(offsetof(UGzGA_ThrowableShield, ShieldActivationMontage) == 0x0006D0, "Member 'UGzGA_ThrowableShield::ShieldActivationMontage' has a wrong offset!");
static_assert(offsetof(UGzGA_ThrowableShield, ShieldAttachSocketName) == 0x0006F8, "Member 'UGzGA_ThrowableShield::ShieldAttachSocketName' has a wrong offset!");
static_assert(offsetof(UGzGA_ThrowableShield, ShieldAimSocketName) == 0x000700, "Member 'UGzGA_ThrowableShield::ShieldAimSocketName' has a wrong offset!");
static_assert(offsetof(UGzGA_ThrowableShield, ShieldDeployEventTag) == 0x000708, "Member 'UGzGA_ThrowableShield::ShieldDeployEventTag' has a wrong offset!");
static_assert(offsetof(UGzGA_ThrowableShield, AT_ServerWaitForTargetData) == 0x000710, "Member 'UGzGA_ThrowableShield::AT_ServerWaitForTargetData' has a wrong offset!");
static_assert(offsetof(UGzGA_ThrowableShield, AT_PlayMontage) == 0x000718, "Member 'UGzGA_ThrowableShield::AT_PlayMontage' has a wrong offset!");
static_assert(offsetof(UGzGA_ThrowableShield, AT_WaitLaunchInputPress) == 0x000720, "Member 'UGzGA_ThrowableShield::AT_WaitLaunchInputPress' has a wrong offset!");
static_assert(offsetof(UGzGA_ThrowableShield, AT_WaitLaunchInputRelease) == 0x000728, "Member 'UGzGA_ThrowableShield::AT_WaitLaunchInputRelease' has a wrong offset!");
static_assert(offsetof(UGzGA_ThrowableShield, AT_WaitInputPress) == 0x000730, "Member 'UGzGA_ThrowableShield::AT_WaitInputPress' has a wrong offset!");

// Class G01.GzGA_ToxicSmoke
// 0x0010 (0x07A0 - 0x0790)
class UGzGA_ToxicSmoke : public UGzGA_ChargeProjectile
{
public:
	float                                         MissileLifespan;                                   // 0x0790(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_331B[0xC];                                     // 0x0794(0x000C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzGA_ToxicSmoke">();
	}
	static class UGzGA_ToxicSmoke* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzGA_ToxicSmoke>();
	}
};
static_assert(alignof(UGzGA_ToxicSmoke) == 0x000010, "Wrong alignment on UGzGA_ToxicSmoke");
static_assert(sizeof(UGzGA_ToxicSmoke) == 0x0007A0, "Wrong size on UGzGA_ToxicSmoke");
static_assert(offsetof(UGzGA_ToxicSmoke, MissileLifespan) == 0x000790, "Member 'UGzGA_ToxicSmoke::MissileLifespan' has a wrong offset!");

// Class G01.GzUnityMatchmakingService
// 0x0180 (0x0220 - 0x00A0)
class UGzUnityMatchmakingService final : public UGzClientPFObject
{
public:
	uint8                                         Pad_331C[0x168];                                   // 0x00A0(0x0168)(Fixing Size After Last Property [ Dumper-7 ])
	class UGzUnityMatchmakingServicePartyCommunicator* PartyCommunicator;                                 // 0x0208(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UGzUnityMatchmakingQueuesManager*       QueuesManager;                                     // 0x0210(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UGzUnityMatchmakingProcess*             MatchmakingProcess;                                // 0x0218(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzUnityMatchmakingService">();
	}
	static class UGzUnityMatchmakingService* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzUnityMatchmakingService>();
	}
};
static_assert(alignof(UGzUnityMatchmakingService) == 0x000008, "Wrong alignment on UGzUnityMatchmakingService");
static_assert(sizeof(UGzUnityMatchmakingService) == 0x000220, "Wrong size on UGzUnityMatchmakingService");
static_assert(offsetof(UGzUnityMatchmakingService, PartyCommunicator) == 0x000208, "Member 'UGzUnityMatchmakingService::PartyCommunicator' has a wrong offset!");
static_assert(offsetof(UGzUnityMatchmakingService, QueuesManager) == 0x000210, "Member 'UGzUnityMatchmakingService::QueuesManager' has a wrong offset!");
static_assert(offsetof(UGzUnityMatchmakingService, MatchmakingProcess) == 0x000218, "Member 'UGzUnityMatchmakingService::MatchmakingProcess' has a wrong offset!");

// Class G01.GzGenericCharacter
// 0x0090 (0x0860 - 0x07D0)
class AGzGenericCharacter final : public AGzBaseCharacter
{
public:
	uint8                                         Pad_331D[0x10];                                    // 0x07D0(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<TSubclassOf<class UGzGameplayAbility>> DefaultStartupAbilities;                           // 0x07E0(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	TArray<struct FGzInventoryItemContent>        StartupInventoryItems;                             // 0x07F0(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	TMap<struct FGameplayTag, struct FGzEquipStateData> NewEquipStateMapping;                              // 0x0800(0x0050)(Edit, Config, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FGenericTeamId                         TeamID;                                            // 0x0850(0x0001)(Net, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_331E[0x3];                                     // 0x0851(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         AiId;                                              // 0x0854(0x0004)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_331F[0x8];                                     // 0x0858(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnDeath();
	void OnHealthChange(float Health);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzGenericCharacter">();
	}
	static class AGzGenericCharacter* GetDefaultObj()
	{
		return GetDefaultObjImpl<AGzGenericCharacter>();
	}
};
static_assert(alignof(AGzGenericCharacter) == 0x000010, "Wrong alignment on AGzGenericCharacter");
static_assert(sizeof(AGzGenericCharacter) == 0x000860, "Wrong size on AGzGenericCharacter");
static_assert(offsetof(AGzGenericCharacter, DefaultStartupAbilities) == 0x0007E0, "Member 'AGzGenericCharacter::DefaultStartupAbilities' has a wrong offset!");
static_assert(offsetof(AGzGenericCharacter, StartupInventoryItems) == 0x0007F0, "Member 'AGzGenericCharacter::StartupInventoryItems' has a wrong offset!");
static_assert(offsetof(AGzGenericCharacter, NewEquipStateMapping) == 0x000800, "Member 'AGzGenericCharacter::NewEquipStateMapping' has a wrong offset!");
static_assert(offsetof(AGzGenericCharacter, TeamID) == 0x000850, "Member 'AGzGenericCharacter::TeamID' has a wrong offset!");
static_assert(offsetof(AGzGenericCharacter, AiId) == 0x000854, "Member 'AGzGenericCharacter::AiId' has a wrong offset!");

// Class G01.GzADSDepthOfFieldModifier
// 0x0010 (0x0038 - 0x0028)
class UGzADSDepthOfFieldModifier final : public UGzWeaponAimModifier
{
public:
	int32                                         Priority;                                          // 0x0028(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3320[0x4];                                     // 0x002C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UGzDepthOfFieldDataAsset*               Data;                                              // 0x0030(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzADSDepthOfFieldModifier">();
	}
	static class UGzADSDepthOfFieldModifier* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzADSDepthOfFieldModifier>();
	}
};
static_assert(alignof(UGzADSDepthOfFieldModifier) == 0x000008, "Wrong alignment on UGzADSDepthOfFieldModifier");
static_assert(sizeof(UGzADSDepthOfFieldModifier) == 0x000038, "Wrong size on UGzADSDepthOfFieldModifier");
static_assert(offsetof(UGzADSDepthOfFieldModifier, Priority) == 0x000028, "Member 'UGzADSDepthOfFieldModifier::Priority' has a wrong offset!");
static_assert(offsetof(UGzADSDepthOfFieldModifier, Data) == 0x000030, "Member 'UGzADSDepthOfFieldModifier::Data' has a wrong offset!");

// Class G01.GzAnimLayerModifier
// 0x0010 (0x0038 - 0x0028)
class UGzAnimLayerModifier final : public UGzWeaponModifier
{
public:
	TArray<struct FGzWeaponAnimationLayerData>    AnimationLayerPerSituation;                        // 0x0028(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzAnimLayerModifier">();
	}
	static class UGzAnimLayerModifier* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzAnimLayerModifier>();
	}
};
static_assert(alignof(UGzAnimLayerModifier) == 0x000008, "Wrong alignment on UGzAnimLayerModifier");
static_assert(sizeof(UGzAnimLayerModifier) == 0x000038, "Wrong size on UGzAnimLayerModifier");
static_assert(offsetof(UGzAnimLayerModifier, AnimationLayerPerSituation) == 0x000028, "Member 'UGzAnimLayerModifier::AnimationLayerPerSituation' has a wrong offset!");

// Class G01.GzGridOverloadStatCollector
// 0x0000 (0x0038 - 0x0038)
class UGzGridOverloadStatCollector final : public UGzGlobalStatsCollector
{
public:
	void OnOverloadActivated(bool bActivated);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzGridOverloadStatCollector">();
	}
	static class UGzGridOverloadStatCollector* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzGridOverloadStatCollector>();
	}
};
static_assert(alignof(UGzGridOverloadStatCollector) == 0x000008, "Wrong alignment on UGzGridOverloadStatCollector");
static_assert(sizeof(UGzGridOverloadStatCollector) == 0x000038, "Wrong size on UGzGridOverloadStatCollector");

// Class G01.GzHackedHexExtractionStatCollector
// 0x0008 (0x0040 - 0x0038)
class UGzHackedHexExtractionStatCollector final : public UGzGlobalStatsCollector
{
public:
	uint8                                         Pad_3321[0x8];                                     // 0x0038(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzHackedHexExtractionStatCollector">();
	}
	static class UGzHackedHexExtractionStatCollector* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzHackedHexExtractionStatCollector>();
	}
};
static_assert(alignof(UGzHackedHexExtractionStatCollector) == 0x000008, "Wrong alignment on UGzHackedHexExtractionStatCollector");
static_assert(sizeof(UGzHackedHexExtractionStatCollector) == 0x000040, "Wrong size on UGzHackedHexExtractionStatCollector");

// Class G01.GzHeadShotKnockDownMessage
// 0x0008 (0x0050 - 0x0048)
class UGzHeadShotKnockDownMessage final : public UGzPlayerToPlayerInteractionMessage
{
public:
	class FName                                   WeaponArchetype;                                   // 0x0048(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzHeadShotKnockDownMessage">();
	}
	static class UGzHeadShotKnockDownMessage* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzHeadShotKnockDownMessage>();
	}
};
static_assert(alignof(UGzHeadShotKnockDownMessage) == 0x000008, "Wrong alignment on UGzHeadShotKnockDownMessage");
static_assert(sizeof(UGzHeadShotKnockDownMessage) == 0x000050, "Wrong size on UGzHeadShotKnockDownMessage");
static_assert(offsetof(UGzHeadShotKnockDownMessage, WeaponArchetype) == 0x000048, "Member 'UGzHeadShotKnockDownMessage::WeaponArchetype' has a wrong offset!");

// Class G01.GzXR_MatchInProgressStage
// 0x00C8 (0x01E0 - 0x0118)
class UGzXR_MatchInProgressStage : public UGzMatchInProgressStage
{
public:
	TArray<class UGzXR_BaseRedeployModifier*>     RedeployModifiers;                                 // 0x0118(0x0010)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	TArray<class AGzTeam*>                        AliveTeams;                                        // 0x0128(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	TMap<int32, struct FTimerHandle>              AutoRedeployTimers;                                // 0x0138(0x0050)(Transient, NativeAccessSpecifierPrivate)
	TSet<int32>                                   AutoRedeployReadyPlayers;                          // 0x0188(0x0050)(Transient, NativeAccessSpecifierPrivate)
	uint8                                         Pad_3322[0x8];                                     // 0x01D8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnTeamAliveStateChanged(class AGzTeam* Team);
	void OnTeamChanged(class AGzPlayerState* PlayerState, int32 PrevTeamID, int32 NewTeamId);
	void SetupInitialAutoRedeploy(class APlayerState* Player, class APawn* NewPawn, class APawn* OldPawn);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzXR_MatchInProgressStage">();
	}
	static class UGzXR_MatchInProgressStage* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzXR_MatchInProgressStage>();
	}
};
static_assert(alignof(UGzXR_MatchInProgressStage) == 0x000008, "Wrong alignment on UGzXR_MatchInProgressStage");
static_assert(sizeof(UGzXR_MatchInProgressStage) == 0x0001E0, "Wrong size on UGzXR_MatchInProgressStage");
static_assert(offsetof(UGzXR_MatchInProgressStage, RedeployModifiers) == 0x000118, "Member 'UGzXR_MatchInProgressStage::RedeployModifiers' has a wrong offset!");
static_assert(offsetof(UGzXR_MatchInProgressStage, AliveTeams) == 0x000128, "Member 'UGzXR_MatchInProgressStage::AliveTeams' has a wrong offset!");
static_assert(offsetof(UGzXR_MatchInProgressStage, AutoRedeployTimers) == 0x000138, "Member 'UGzXR_MatchInProgressStage::AutoRedeployTimers' has a wrong offset!");
static_assert(offsetof(UGzXR_MatchInProgressStage, AutoRedeployReadyPlayers) == 0x000188, "Member 'UGzXR_MatchInProgressStage::AutoRedeployReadyPlayers' has a wrong offset!");

// Class G01.GzHeadShotKnockDownStatsCollector
// 0x0008 (0x0040 - 0x0038)
class UGzHeadShotKnockDownStatsCollector final : public UGzGlobalStatsCollector
{
public:
	uint8                                         Pad_3323[0x8];                                     // 0x0038(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzHeadShotKnockDownStatsCollector">();
	}
	static class UGzHeadShotKnockDownStatsCollector* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzHeadShotKnockDownStatsCollector>();
	}
};
static_assert(alignof(UGzHeadShotKnockDownStatsCollector) == 0x000008, "Wrong alignment on UGzHeadShotKnockDownStatsCollector");
static_assert(sizeof(UGzHeadShotKnockDownStatsCollector) == 0x000040, "Wrong size on UGzHeadShotKnockDownStatsCollector");

// Class G01.GzHexExtractionPausedMessage
// 0x0008 (0x0048 - 0x0040)
class UGzHexExtractionPausedMessage final : public UGzHexExtractionMessageBase
{
public:
	bool                                          bPaused;                                           // 0x0040(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3324[0x7];                                     // 0x0041(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzHexExtractionPausedMessage">();
	}
	static class UGzHexExtractionPausedMessage* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzHexExtractionPausedMessage>();
	}
};
static_assert(alignof(UGzHexExtractionPausedMessage) == 0x000008, "Wrong alignment on UGzHexExtractionPausedMessage");
static_assert(sizeof(UGzHexExtractionPausedMessage) == 0x000048, "Wrong size on UGzHexExtractionPausedMessage");
static_assert(offsetof(UGzHexExtractionPausedMessage, bPaused) == 0x000040, "Member 'UGzHexExtractionPausedMessage::bPaused' has a wrong offset!");

// Class G01.GzHexPoolSubsystem
// 0x0060 (0x0300 - 0x02A0)
class AGzHexPoolSubsystem : public AGzGameModeSubsystem
{
public:
	bool                                          bShouldTryReroll;                                  // 0x02A0(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3325[0x7];                                     // 0x02A1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<EGzItemRarity, uint8>                    HexConstraints;                                    // 0x02A8(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	bool                                          bRarityDecreaseOrder;                              // 0x02F8(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3326[0x7];                                     // 0x02F9(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzHexPoolSubsystem">();
	}
	static class AGzHexPoolSubsystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<AGzHexPoolSubsystem>();
	}
};
static_assert(alignof(AGzHexPoolSubsystem) == 0x000008, "Wrong alignment on AGzHexPoolSubsystem");
static_assert(sizeof(AGzHexPoolSubsystem) == 0x000300, "Wrong size on AGzHexPoolSubsystem");
static_assert(offsetof(AGzHexPoolSubsystem, bShouldTryReroll) == 0x0002A0, "Member 'AGzHexPoolSubsystem::bShouldTryReroll' has a wrong offset!");
static_assert(offsetof(AGzHexPoolSubsystem, HexConstraints) == 0x0002A8, "Member 'AGzHexPoolSubsystem::HexConstraints' has a wrong offset!");
static_assert(offsetof(AGzHexPoolSubsystem, bRarityDecreaseOrder) == 0x0002F8, "Member 'AGzHexPoolSubsystem::bRarityDecreaseOrder' has a wrong offset!");

// Class G01.GzWE_PlayerDeathAware
// 0x0008 (0x0030 - 0x0028)
class UGzWE_PlayerDeathAware final : public UUserWidgetExtension
{
public:
	class APawn*                                  ControlledPawn;                                    // 0x0028(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzWE_PlayerDeathAware">();
	}
	static class UGzWE_PlayerDeathAware* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzWE_PlayerDeathAware>();
	}
};
static_assert(alignof(UGzWE_PlayerDeathAware) == 0x000008, "Wrong alignment on UGzWE_PlayerDeathAware");
static_assert(sizeof(UGzWE_PlayerDeathAware) == 0x000030, "Wrong size on UGzWE_PlayerDeathAware");
static_assert(offsetof(UGzWE_PlayerDeathAware, ControlledPawn) == 0x000028, "Member 'UGzWE_PlayerDeathAware::ControlledPawn' has a wrong offset!");

// Class G01.GzHiddenAssetsTrackerComponent
// 0x00E8 (0x0188 - 0x00A0)
class UGzHiddenAssetsTrackerComponent final : public UGzServiceComponent
{
public:
	uint8                                         Pad_3327[0xE8];                                    // 0x00A0(0x00E8)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzHiddenAssetsTrackerComponent">();
	}
	static class UGzHiddenAssetsTrackerComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzHiddenAssetsTrackerComponent>();
	}
};
static_assert(alignof(UGzHiddenAssetsTrackerComponent) == 0x000008, "Wrong alignment on UGzHiddenAssetsTrackerComponent");
static_assert(sizeof(UGzHiddenAssetsTrackerComponent) == 0x000188, "Wrong size on UGzHiddenAssetsTrackerComponent");

// Class G01.GzHideoutModel
// 0x0018 (0x0088 - 0x0070)
class UGzHideoutModel final : public UGzBackendModel
{
public:
	class UGzWeaponSpawner*                       WeaponSpawner;                                     // 0x0070(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_3328[0x10];                                    // 0x0078(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzHideoutModel">();
	}
	static class UGzHideoutModel* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzHideoutModel>();
	}
};
static_assert(alignof(UGzHideoutModel) == 0x000008, "Wrong alignment on UGzHideoutModel");
static_assert(sizeof(UGzHideoutModel) == 0x000088, "Wrong size on UGzHideoutModel");
static_assert(offsetof(UGzHideoutModel, WeaponSpawner) == 0x000070, "Member 'UGzHideoutModel::WeaponSpawner' has a wrong offset!");

// Class G01.GzWidgetComponent
// 0x0000 (0x06A0 - 0x06A0)
class UGzWidgetComponent final : public UWidgetComponent
{
public:
	float                                         RedrawCullDistance;                                // 0x0698(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3329[0x4];                                     // 0x069C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzWidgetComponent">();
	}
	static class UGzWidgetComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzWidgetComponent>();
	}
};
static_assert(alignof(UGzWidgetComponent) == 0x000010, "Wrong alignment on UGzWidgetComponent");
static_assert(sizeof(UGzWidgetComponent) == 0x0006A0, "Wrong size on UGzWidgetComponent");
static_assert(offsetof(UGzWidgetComponent, RedrawCullDistance) == 0x000698, "Member 'UGzWidgetComponent::RedrawCullDistance' has a wrong offset!");

// Class G01.GzHideoutState
// 0x0028 (0x0088 - 0x0060)
class UGzHideoutState final : public UGzFlowState
{
public:
	uint8                                         Pad_332A[0x28];                                    // 0x0060(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzHideoutState">();
	}
	static class UGzHideoutState* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzHideoutState>();
	}
};
static_assert(alignof(UGzHideoutState) == 0x000008, "Wrong alignment on UGzHideoutState");
static_assert(sizeof(UGzHideoutState) == 0x000088, "Wrong size on UGzHideoutState");

// Class G01.GzTetherLink
// 0x0060 (0x0300 - 0x02A0)
class AGzTetherLink final : public AActor
{
public:
	uint8                                         Pad_332B[0x10];                                    // 0x02A0(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class UGzAbilitySystemComponent*              AbilitySystemComponent;                            // 0x02B0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, Transient, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UGzGE_BaseDamage>           DamageEffectClass;                                 // 0x02B8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UGameplayEffect>            SlowEffectClass;                                   // 0x02C0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class AGzTetherEnd*                           FirstTetherEnd;                                    // 0x02C8(0x0008)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class AGzTetherEnd*                           SecondTetherEnd;                                   // 0x02D0(0x0008)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MaxLinkLength;                                     // 0x02D8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         SlowPercentage;                                    // 0x02DC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         Damage;                                            // 0x02E0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         TetherEndsReady;                                   // 0x02E4(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDataAsset*                             DamageSourceDataAsset;                             // 0x02E8(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FGzCharacterIdAccess                   CharacterIdAccess;                                 // 0x02F0(0x0010)(BlueprintVisible, Transient, NoDestructor, NativeAccessSpecifierPublic)

public:
	void ApplySlowEffect(class UAbilitySystemComponent* TargetASC);
	void ApplyTrapDamage(class UAbilitySystemComponent* TargetASC, const struct FVector& ExplosionOrigin);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzTetherLink">();
	}
	static class AGzTetherLink* GetDefaultObj()
	{
		return GetDefaultObjImpl<AGzTetherLink>();
	}
};
static_assert(alignof(AGzTetherLink) == 0x000008, "Wrong alignment on AGzTetherLink");
static_assert(sizeof(AGzTetherLink) == 0x000300, "Wrong size on AGzTetherLink");
static_assert(offsetof(AGzTetherLink, AbilitySystemComponent) == 0x0002B0, "Member 'AGzTetherLink::AbilitySystemComponent' has a wrong offset!");
static_assert(offsetof(AGzTetherLink, DamageEffectClass) == 0x0002B8, "Member 'AGzTetherLink::DamageEffectClass' has a wrong offset!");
static_assert(offsetof(AGzTetherLink, SlowEffectClass) == 0x0002C0, "Member 'AGzTetherLink::SlowEffectClass' has a wrong offset!");
static_assert(offsetof(AGzTetherLink, FirstTetherEnd) == 0x0002C8, "Member 'AGzTetherLink::FirstTetherEnd' has a wrong offset!");
static_assert(offsetof(AGzTetherLink, SecondTetherEnd) == 0x0002D0, "Member 'AGzTetherLink::SecondTetherEnd' has a wrong offset!");
static_assert(offsetof(AGzTetherLink, MaxLinkLength) == 0x0002D8, "Member 'AGzTetherLink::MaxLinkLength' has a wrong offset!");
static_assert(offsetof(AGzTetherLink, SlowPercentage) == 0x0002DC, "Member 'AGzTetherLink::SlowPercentage' has a wrong offset!");
static_assert(offsetof(AGzTetherLink, Damage) == 0x0002E0, "Member 'AGzTetherLink::Damage' has a wrong offset!");
static_assert(offsetof(AGzTetherLink, TetherEndsReady) == 0x0002E4, "Member 'AGzTetherLink::TetherEndsReady' has a wrong offset!");
static_assert(offsetof(AGzTetherLink, DamageSourceDataAsset) == 0x0002E8, "Member 'AGzTetherLink::DamageSourceDataAsset' has a wrong offset!");
static_assert(offsetof(AGzTetherLink, CharacterIdAccess) == 0x0002F0, "Member 'AGzTetherLink::CharacterIdAccess' has a wrong offset!");

// Class G01.GzHitmark
// 0x0010 (0x02F0 - 0x02E0)
class UGzHitmark : public UUserWidget
{
public:
	class UWidgetAnimation*                       DisplayAnimation;                                  // 0x02E0(0x0008)(BlueprintVisible, ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_332C[0x8];                                     // 0x02E8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Play();

	class UWidgetAnimation* GetDisplayAnimation() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzHitmark">();
	}
	static class UGzHitmark* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzHitmark>();
	}
};
static_assert(alignof(UGzHitmark) == 0x000008, "Wrong alignment on UGzHitmark");
static_assert(sizeof(UGzHitmark) == 0x0002F0, "Wrong size on UGzHitmark");
static_assert(offsetof(UGzHitmark, DisplayAnimation) == 0x0002E0, "Member 'UGzHitmark::DisplayAnimation' has a wrong offset!");

// Class G01.GzWingsuitSettingsDataAsset
// 0x02E0 (0x0310 - 0x0030)
class UGzWingsuitSettingsDataAsset final : public UDataAsset
{
public:
	float                                         Speed;                                             // 0x0030(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         AccelerationInPlayerDirection;                     // 0x0034(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RollLimit;                                         // 0x0038(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAlwaysApplyInitialBoost;                          // 0x003C(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_332D[0x3];                                     // 0x003D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         InitialBoostImpulse;                               // 0x0040(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxInitialSpeed;                                   // 0x0044(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InitialBoostMomentum;                              // 0x0048(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MomentumLossPerSecond;                             // 0x004C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         YawControlPower;                                   // 0x0050(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         PitchControlPower;                                 // 0x0054(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MomentumLossWhenMissingLimb;                       // 0x0058(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RollControlPower;                                  // 0x005C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         WingsuitPitchStep;                                 // 0x0060(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         WingsuitUpperPitchStep;                            // 0x0064(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         WingsuitUpperPitchAngle;                           // 0x0068(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxLandingPitch;                                   // 0x006C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MomentumFromSpeedMultiplier;                       // 0x0070(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MomentumFromVerticalSpeedMultiplier;               // 0x0074(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         WingsuitOpeningPitchThreshold;                     // 0x0078(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShouldLimitControlOnLimbLoss;                     // 0x007C(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_332E[0x3];                                     // 0x007D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         LimitControlTurnOnLimbLoss;                        // 0x0080(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LimitControlPitchOnLimbLoss;                       // 0x0084(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSetInitialPitch;                                  // 0x0088(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_332F[0x3];                                     // 0x0089(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         InitialPitch;                                      // 0x008C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EGzWingsuitCollisionCrashBehaviour            CollisionCrashBehaviour;                           // 0x0090(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3330[0x3];                                     // 0x0091(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         BounceOffBumpStrength;                             // 0x0094(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BounceOffVelocityDropOff;                          // 0x0098(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShouldSnapWingsuitToForward;                      // 0x009C(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3331[0x3];                                     // 0x009D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class UCurveFloat*                            PitchToMomentumCurve;                              // 0x00A0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCurveFloat*                            PitchLimitByMomentumCurve;                         // 0x00A8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCurveFloat*                            SpeedBonusByMomentumCurve;                         // 0x00B0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCurveFloat*                            SpeedBonusByPitchCurve;                            // 0x00B8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCurveFloat*                            BreakingDecelerationCurve;                         // 0x00C0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCurveFloat*                            DampingMaxSpeedCurve;                              // 0x00C8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCurveFloat*                            DampingMomentumCurve;                              // 0x00D0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCurveVector*                           LandingRollMovement;                               // 0x00D8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UGzWingsuitSoundSettingsDataAsset*      SoundSettings;                                     // 0x00E0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   AllowLandingRollCancelNotifyName;                  // 0x00E8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRuntimeFloatCurve                     HitReactionPitchReductionPerStack;                 // 0x00F0(0x0088)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FRuntimeFloatCurve                     HitReactionYawReductioPerStack;                    // 0x0178(0x0088)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FRuntimeFloatCurve                     HitReactionSpeedReductionPerStack;                 // 0x0200(0x0088)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FRuntimeFloatCurve                     HitReactionMomentumReductionPerStack;              // 0x0288(0x0088)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzWingsuitSettingsDataAsset">();
	}
	static class UGzWingsuitSettingsDataAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzWingsuitSettingsDataAsset>();
	}
};
static_assert(alignof(UGzWingsuitSettingsDataAsset) == 0x000008, "Wrong alignment on UGzWingsuitSettingsDataAsset");
static_assert(sizeof(UGzWingsuitSettingsDataAsset) == 0x000310, "Wrong size on UGzWingsuitSettingsDataAsset");
static_assert(offsetof(UGzWingsuitSettingsDataAsset, Speed) == 0x000030, "Member 'UGzWingsuitSettingsDataAsset::Speed' has a wrong offset!");
static_assert(offsetof(UGzWingsuitSettingsDataAsset, AccelerationInPlayerDirection) == 0x000034, "Member 'UGzWingsuitSettingsDataAsset::AccelerationInPlayerDirection' has a wrong offset!");
static_assert(offsetof(UGzWingsuitSettingsDataAsset, RollLimit) == 0x000038, "Member 'UGzWingsuitSettingsDataAsset::RollLimit' has a wrong offset!");
static_assert(offsetof(UGzWingsuitSettingsDataAsset, bAlwaysApplyInitialBoost) == 0x00003C, "Member 'UGzWingsuitSettingsDataAsset::bAlwaysApplyInitialBoost' has a wrong offset!");
static_assert(offsetof(UGzWingsuitSettingsDataAsset, InitialBoostImpulse) == 0x000040, "Member 'UGzWingsuitSettingsDataAsset::InitialBoostImpulse' has a wrong offset!");
static_assert(offsetof(UGzWingsuitSettingsDataAsset, MaxInitialSpeed) == 0x000044, "Member 'UGzWingsuitSettingsDataAsset::MaxInitialSpeed' has a wrong offset!");
static_assert(offsetof(UGzWingsuitSettingsDataAsset, InitialBoostMomentum) == 0x000048, "Member 'UGzWingsuitSettingsDataAsset::InitialBoostMomentum' has a wrong offset!");
static_assert(offsetof(UGzWingsuitSettingsDataAsset, MomentumLossPerSecond) == 0x00004C, "Member 'UGzWingsuitSettingsDataAsset::MomentumLossPerSecond' has a wrong offset!");
static_assert(offsetof(UGzWingsuitSettingsDataAsset, YawControlPower) == 0x000050, "Member 'UGzWingsuitSettingsDataAsset::YawControlPower' has a wrong offset!");
static_assert(offsetof(UGzWingsuitSettingsDataAsset, PitchControlPower) == 0x000054, "Member 'UGzWingsuitSettingsDataAsset::PitchControlPower' has a wrong offset!");
static_assert(offsetof(UGzWingsuitSettingsDataAsset, MomentumLossWhenMissingLimb) == 0x000058, "Member 'UGzWingsuitSettingsDataAsset::MomentumLossWhenMissingLimb' has a wrong offset!");
static_assert(offsetof(UGzWingsuitSettingsDataAsset, RollControlPower) == 0x00005C, "Member 'UGzWingsuitSettingsDataAsset::RollControlPower' has a wrong offset!");
static_assert(offsetof(UGzWingsuitSettingsDataAsset, WingsuitPitchStep) == 0x000060, "Member 'UGzWingsuitSettingsDataAsset::WingsuitPitchStep' has a wrong offset!");
static_assert(offsetof(UGzWingsuitSettingsDataAsset, WingsuitUpperPitchStep) == 0x000064, "Member 'UGzWingsuitSettingsDataAsset::WingsuitUpperPitchStep' has a wrong offset!");
static_assert(offsetof(UGzWingsuitSettingsDataAsset, WingsuitUpperPitchAngle) == 0x000068, "Member 'UGzWingsuitSettingsDataAsset::WingsuitUpperPitchAngle' has a wrong offset!");
static_assert(offsetof(UGzWingsuitSettingsDataAsset, MaxLandingPitch) == 0x00006C, "Member 'UGzWingsuitSettingsDataAsset::MaxLandingPitch' has a wrong offset!");
static_assert(offsetof(UGzWingsuitSettingsDataAsset, MomentumFromSpeedMultiplier) == 0x000070, "Member 'UGzWingsuitSettingsDataAsset::MomentumFromSpeedMultiplier' has a wrong offset!");
static_assert(offsetof(UGzWingsuitSettingsDataAsset, MomentumFromVerticalSpeedMultiplier) == 0x000074, "Member 'UGzWingsuitSettingsDataAsset::MomentumFromVerticalSpeedMultiplier' has a wrong offset!");
static_assert(offsetof(UGzWingsuitSettingsDataAsset, WingsuitOpeningPitchThreshold) == 0x000078, "Member 'UGzWingsuitSettingsDataAsset::WingsuitOpeningPitchThreshold' has a wrong offset!");
static_assert(offsetof(UGzWingsuitSettingsDataAsset, bShouldLimitControlOnLimbLoss) == 0x00007C, "Member 'UGzWingsuitSettingsDataAsset::bShouldLimitControlOnLimbLoss' has a wrong offset!");
static_assert(offsetof(UGzWingsuitSettingsDataAsset, LimitControlTurnOnLimbLoss) == 0x000080, "Member 'UGzWingsuitSettingsDataAsset::LimitControlTurnOnLimbLoss' has a wrong offset!");
static_assert(offsetof(UGzWingsuitSettingsDataAsset, LimitControlPitchOnLimbLoss) == 0x000084, "Member 'UGzWingsuitSettingsDataAsset::LimitControlPitchOnLimbLoss' has a wrong offset!");
static_assert(offsetof(UGzWingsuitSettingsDataAsset, bSetInitialPitch) == 0x000088, "Member 'UGzWingsuitSettingsDataAsset::bSetInitialPitch' has a wrong offset!");
static_assert(offsetof(UGzWingsuitSettingsDataAsset, InitialPitch) == 0x00008C, "Member 'UGzWingsuitSettingsDataAsset::InitialPitch' has a wrong offset!");
static_assert(offsetof(UGzWingsuitSettingsDataAsset, CollisionCrashBehaviour) == 0x000090, "Member 'UGzWingsuitSettingsDataAsset::CollisionCrashBehaviour' has a wrong offset!");
static_assert(offsetof(UGzWingsuitSettingsDataAsset, BounceOffBumpStrength) == 0x000094, "Member 'UGzWingsuitSettingsDataAsset::BounceOffBumpStrength' has a wrong offset!");
static_assert(offsetof(UGzWingsuitSettingsDataAsset, BounceOffVelocityDropOff) == 0x000098, "Member 'UGzWingsuitSettingsDataAsset::BounceOffVelocityDropOff' has a wrong offset!");
static_assert(offsetof(UGzWingsuitSettingsDataAsset, bShouldSnapWingsuitToForward) == 0x00009C, "Member 'UGzWingsuitSettingsDataAsset::bShouldSnapWingsuitToForward' has a wrong offset!");
static_assert(offsetof(UGzWingsuitSettingsDataAsset, PitchToMomentumCurve) == 0x0000A0, "Member 'UGzWingsuitSettingsDataAsset::PitchToMomentumCurve' has a wrong offset!");
static_assert(offsetof(UGzWingsuitSettingsDataAsset, PitchLimitByMomentumCurve) == 0x0000A8, "Member 'UGzWingsuitSettingsDataAsset::PitchLimitByMomentumCurve' has a wrong offset!");
static_assert(offsetof(UGzWingsuitSettingsDataAsset, SpeedBonusByMomentumCurve) == 0x0000B0, "Member 'UGzWingsuitSettingsDataAsset::SpeedBonusByMomentumCurve' has a wrong offset!");
static_assert(offsetof(UGzWingsuitSettingsDataAsset, SpeedBonusByPitchCurve) == 0x0000B8, "Member 'UGzWingsuitSettingsDataAsset::SpeedBonusByPitchCurve' has a wrong offset!");
static_assert(offsetof(UGzWingsuitSettingsDataAsset, BreakingDecelerationCurve) == 0x0000C0, "Member 'UGzWingsuitSettingsDataAsset::BreakingDecelerationCurve' has a wrong offset!");
static_assert(offsetof(UGzWingsuitSettingsDataAsset, DampingMaxSpeedCurve) == 0x0000C8, "Member 'UGzWingsuitSettingsDataAsset::DampingMaxSpeedCurve' has a wrong offset!");
static_assert(offsetof(UGzWingsuitSettingsDataAsset, DampingMomentumCurve) == 0x0000D0, "Member 'UGzWingsuitSettingsDataAsset::DampingMomentumCurve' has a wrong offset!");
static_assert(offsetof(UGzWingsuitSettingsDataAsset, LandingRollMovement) == 0x0000D8, "Member 'UGzWingsuitSettingsDataAsset::LandingRollMovement' has a wrong offset!");
static_assert(offsetof(UGzWingsuitSettingsDataAsset, SoundSettings) == 0x0000E0, "Member 'UGzWingsuitSettingsDataAsset::SoundSettings' has a wrong offset!");
static_assert(offsetof(UGzWingsuitSettingsDataAsset, AllowLandingRollCancelNotifyName) == 0x0000E8, "Member 'UGzWingsuitSettingsDataAsset::AllowLandingRollCancelNotifyName' has a wrong offset!");
static_assert(offsetof(UGzWingsuitSettingsDataAsset, HitReactionPitchReductionPerStack) == 0x0000F0, "Member 'UGzWingsuitSettingsDataAsset::HitReactionPitchReductionPerStack' has a wrong offset!");
static_assert(offsetof(UGzWingsuitSettingsDataAsset, HitReactionYawReductioPerStack) == 0x000178, "Member 'UGzWingsuitSettingsDataAsset::HitReactionYawReductioPerStack' has a wrong offset!");
static_assert(offsetof(UGzWingsuitSettingsDataAsset, HitReactionSpeedReductionPerStack) == 0x000200, "Member 'UGzWingsuitSettingsDataAsset::HitReactionSpeedReductionPerStack' has a wrong offset!");
static_assert(offsetof(UGzWingsuitSettingsDataAsset, HitReactionMomentumReductionPerStack) == 0x000288, "Member 'UGzWingsuitSettingsDataAsset::HitReactionMomentumReductionPerStack' has a wrong offset!");

// Class G01.GzHitmarkContainer
// 0x00F8 (0x0438 - 0x0340)
class UGzHitmarkContainer : public UGzHUDComponent
{
public:
	class UCanvasPanel*                           Root;                                              // 0x0340(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TMap<EGzHitmarkCategory, class UGzHitmark*>   HitmarkWidgets;                                    // 0x0348(0x0050)(ExportObject, Transient, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	TMap<EGzHitResponseType, TSubclassOf<class UGzHitmark>> HitmarkClasses;                                    // 0x0398(0x0050)(Edit, DisableEditOnInstance, UObjectWrapper, NativeAccessSpecifierPrivate)
	TMap<EGzHitResponseType, int32>               Priorities;                                        // 0x03E8(0x0050)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)

public:
	void NotifyHitResponse(const struct FGzHitResponseData& HitResponseData);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzHitmarkContainer">();
	}
	static class UGzHitmarkContainer* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzHitmarkContainer>();
	}
};
static_assert(alignof(UGzHitmarkContainer) == 0x000008, "Wrong alignment on UGzHitmarkContainer");
static_assert(sizeof(UGzHitmarkContainer) == 0x000438, "Wrong size on UGzHitmarkContainer");
static_assert(offsetof(UGzHitmarkContainer, Root) == 0x000340, "Member 'UGzHitmarkContainer::Root' has a wrong offset!");
static_assert(offsetof(UGzHitmarkContainer, HitmarkWidgets) == 0x000348, "Member 'UGzHitmarkContainer::HitmarkWidgets' has a wrong offset!");
static_assert(offsetof(UGzHitmarkContainer, HitmarkClasses) == 0x000398, "Member 'UGzHitmarkContainer::HitmarkClasses' has a wrong offset!");
static_assert(offsetof(UGzHitmarkContainer, Priorities) == 0x0003E8, "Member 'UGzHitmarkContainer::Priorities' has a wrong offset!");

// Class G01.GzHitScanAttackStrategy
// 0x0010 (0x00B8 - 0x00A8)
class UGzHitScanAttackStrategy final : public UGzWeaponAttackStrategy
{
public:
	TArray<struct FGzHitReport>                   PendingConfirmationReports;                        // 0x00A8(0x0010)(ZeroConstructor, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)

public:
	void ClientProcessValidationInfo(const struct FGzHitValidationInfo& ValidationInfo);
	void NotifyAttack(const struct FVector& SpawnLocation, const struct FRotator& SpawnRotation, const struct FGzShootNotificationInfo& NotificationInfo);
	void ServerProcessAttackRequest(const struct FVector& SpawnLocation, const struct FRotator& SpawnRotation, const struct FGzHitReport& HitReport);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzHitScanAttackStrategy">();
	}
	static class UGzHitScanAttackStrategy* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzHitScanAttackStrategy>();
	}
};
static_assert(alignof(UGzHitScanAttackStrategy) == 0x000008, "Wrong alignment on UGzHitScanAttackStrategy");
static_assert(sizeof(UGzHitScanAttackStrategy) == 0x0000B8, "Wrong size on UGzHitScanAttackStrategy");
static_assert(offsetof(UGzHitScanAttackStrategy, PendingConfirmationReports) == 0x0000A8, "Member 'UGzHitScanAttackStrategy::PendingConfirmationReports' has a wrong offset!");

// Class G01.GzWeaponData
// 0x02D8 (0x0308 - 0x0030)
class UGzWeaponData final : public UDataAsset
{
public:
	TArray<struct FGzWeaponFireMode>              WeaponFireModes;                                   // 0x0030(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	EGzWeaponResourceType                         ResourceType;                                      // 0x0040(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3332[0x7];                                     // 0x0041(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftObjectPtr<class UGzAmmoItemData>         AmmoItemData;                                      // 0x0048(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Range;                                             // 0x0070(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ClipSize;                                          // 0x0074(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ProjectilesPerShot;                                // 0x0078(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ResourceDrainPerConsume;                           // 0x007C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseResourceDirectlyFromStock;                     // 0x0080(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUsesMagazineReload;                               // 0x0081(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUsesShellReload;                                  // 0x0082(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3333[0x1];                                     // 0x0083(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         ResourceGainPerReload;                             // 0x0084(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class AActor>                     ScopeMeshActor;                                    // 0x0088(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UATPCCameraModeDataAsset*               AimingCameraMode;                                  // 0x0090(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AimingBlendInTime;                                 // 0x0098(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3334[0x4];                                     // 0x009C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGzScopeMode                           WeaponScopeMode;                                   // 0x00A0(0x0080)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	float                                         WeaponHolsteredScale;                              // 0x0120(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MeleeDamageRatio;                                  // 0x0124(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCustomShellEjectNotify;                           // 0x0128(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3335[0x7];                                     // 0x0129(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UGzWeaponAttackStrategy>    AttackStrategyClass;                               // 0x0130(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UGzBulletParams*                        BulletAttackParams;                                // 0x0138(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, PersistentInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UGzBulletParams*                        AIBulletAttackParams;                              // 0x0140(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, PersistentInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UGzProjectileAttackParams*              ProjectileAttackParams;                            // 0x0148(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, PersistentInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UGzProjectileAttackParams*              AIProjectileAttackParams;                          // 0x0150(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, PersistentInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UGzGE_BaseDamage>           AttackDamageEffect;                                // 0x0158(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UGzGE_BaseDamage>           AIAttackDamageEffect;                              // 0x0160(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UGzGE_MovementSpeedModifier> MovementEffect;                                    // 0x0168(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UGzGE_MovementSpeedModifier> AdsMovementEffect;                                 // 0x0170(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UGzWeaponAIData>         AIDataSoftRef;                                     // 0x0178(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UGzWeaponAnimationData>  AnimationDataSoftRef;                              // 0x01A0(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UGzWeaponFXData>         FXDataSoftRef;                                     // 0x01C8(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UGzWeaponSoundData>      SoundDataSoftRef;                                  // 0x01F0(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UGzWeaponSpreadData>     SpreadDataSoftRef;                                 // 0x0218(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UGzWeaponSpreadData>     AISpreadDataSoftRef;                               // 0x0240(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UGzWeaponRecoilData>     RecoilDataSoftRef;                                 // 0x0268(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UGzWeaponSwayData>       SwayDataSoftRef;                                   // 0x0290(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UGzWeaponOverheatData>   OverheatDataSoftRef;                               // 0x02B8(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UGzWeaponOverheatData>   AIOverheatDataSoftRef;                             // 0x02E0(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzWeaponData">();
	}
	static class UGzWeaponData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzWeaponData>();
	}
};
static_assert(alignof(UGzWeaponData) == 0x000008, "Wrong alignment on UGzWeaponData");
static_assert(sizeof(UGzWeaponData) == 0x000308, "Wrong size on UGzWeaponData");
static_assert(offsetof(UGzWeaponData, WeaponFireModes) == 0x000030, "Member 'UGzWeaponData::WeaponFireModes' has a wrong offset!");
static_assert(offsetof(UGzWeaponData, ResourceType) == 0x000040, "Member 'UGzWeaponData::ResourceType' has a wrong offset!");
static_assert(offsetof(UGzWeaponData, AmmoItemData) == 0x000048, "Member 'UGzWeaponData::AmmoItemData' has a wrong offset!");
static_assert(offsetof(UGzWeaponData, Range) == 0x000070, "Member 'UGzWeaponData::Range' has a wrong offset!");
static_assert(offsetof(UGzWeaponData, ClipSize) == 0x000074, "Member 'UGzWeaponData::ClipSize' has a wrong offset!");
static_assert(offsetof(UGzWeaponData, ProjectilesPerShot) == 0x000078, "Member 'UGzWeaponData::ProjectilesPerShot' has a wrong offset!");
static_assert(offsetof(UGzWeaponData, ResourceDrainPerConsume) == 0x00007C, "Member 'UGzWeaponData::ResourceDrainPerConsume' has a wrong offset!");
static_assert(offsetof(UGzWeaponData, bUseResourceDirectlyFromStock) == 0x000080, "Member 'UGzWeaponData::bUseResourceDirectlyFromStock' has a wrong offset!");
static_assert(offsetof(UGzWeaponData, bUsesMagazineReload) == 0x000081, "Member 'UGzWeaponData::bUsesMagazineReload' has a wrong offset!");
static_assert(offsetof(UGzWeaponData, bUsesShellReload) == 0x000082, "Member 'UGzWeaponData::bUsesShellReload' has a wrong offset!");
static_assert(offsetof(UGzWeaponData, ResourceGainPerReload) == 0x000084, "Member 'UGzWeaponData::ResourceGainPerReload' has a wrong offset!");
static_assert(offsetof(UGzWeaponData, ScopeMeshActor) == 0x000088, "Member 'UGzWeaponData::ScopeMeshActor' has a wrong offset!");
static_assert(offsetof(UGzWeaponData, AimingCameraMode) == 0x000090, "Member 'UGzWeaponData::AimingCameraMode' has a wrong offset!");
static_assert(offsetof(UGzWeaponData, AimingBlendInTime) == 0x000098, "Member 'UGzWeaponData::AimingBlendInTime' has a wrong offset!");
static_assert(offsetof(UGzWeaponData, WeaponScopeMode) == 0x0000A0, "Member 'UGzWeaponData::WeaponScopeMode' has a wrong offset!");
static_assert(offsetof(UGzWeaponData, WeaponHolsteredScale) == 0x000120, "Member 'UGzWeaponData::WeaponHolsteredScale' has a wrong offset!");
static_assert(offsetof(UGzWeaponData, MeleeDamageRatio) == 0x000124, "Member 'UGzWeaponData::MeleeDamageRatio' has a wrong offset!");
static_assert(offsetof(UGzWeaponData, bCustomShellEjectNotify) == 0x000128, "Member 'UGzWeaponData::bCustomShellEjectNotify' has a wrong offset!");
static_assert(offsetof(UGzWeaponData, AttackStrategyClass) == 0x000130, "Member 'UGzWeaponData::AttackStrategyClass' has a wrong offset!");
static_assert(offsetof(UGzWeaponData, BulletAttackParams) == 0x000138, "Member 'UGzWeaponData::BulletAttackParams' has a wrong offset!");
static_assert(offsetof(UGzWeaponData, AIBulletAttackParams) == 0x000140, "Member 'UGzWeaponData::AIBulletAttackParams' has a wrong offset!");
static_assert(offsetof(UGzWeaponData, ProjectileAttackParams) == 0x000148, "Member 'UGzWeaponData::ProjectileAttackParams' has a wrong offset!");
static_assert(offsetof(UGzWeaponData, AIProjectileAttackParams) == 0x000150, "Member 'UGzWeaponData::AIProjectileAttackParams' has a wrong offset!");
static_assert(offsetof(UGzWeaponData, AttackDamageEffect) == 0x000158, "Member 'UGzWeaponData::AttackDamageEffect' has a wrong offset!");
static_assert(offsetof(UGzWeaponData, AIAttackDamageEffect) == 0x000160, "Member 'UGzWeaponData::AIAttackDamageEffect' has a wrong offset!");
static_assert(offsetof(UGzWeaponData, MovementEffect) == 0x000168, "Member 'UGzWeaponData::MovementEffect' has a wrong offset!");
static_assert(offsetof(UGzWeaponData, AdsMovementEffect) == 0x000170, "Member 'UGzWeaponData::AdsMovementEffect' has a wrong offset!");
static_assert(offsetof(UGzWeaponData, AIDataSoftRef) == 0x000178, "Member 'UGzWeaponData::AIDataSoftRef' has a wrong offset!");
static_assert(offsetof(UGzWeaponData, AnimationDataSoftRef) == 0x0001A0, "Member 'UGzWeaponData::AnimationDataSoftRef' has a wrong offset!");
static_assert(offsetof(UGzWeaponData, FXDataSoftRef) == 0x0001C8, "Member 'UGzWeaponData::FXDataSoftRef' has a wrong offset!");
static_assert(offsetof(UGzWeaponData, SoundDataSoftRef) == 0x0001F0, "Member 'UGzWeaponData::SoundDataSoftRef' has a wrong offset!");
static_assert(offsetof(UGzWeaponData, SpreadDataSoftRef) == 0x000218, "Member 'UGzWeaponData::SpreadDataSoftRef' has a wrong offset!");
static_assert(offsetof(UGzWeaponData, AISpreadDataSoftRef) == 0x000240, "Member 'UGzWeaponData::AISpreadDataSoftRef' has a wrong offset!");
static_assert(offsetof(UGzWeaponData, RecoilDataSoftRef) == 0x000268, "Member 'UGzWeaponData::RecoilDataSoftRef' has a wrong offset!");
static_assert(offsetof(UGzWeaponData, SwayDataSoftRef) == 0x000290, "Member 'UGzWeaponData::SwayDataSoftRef' has a wrong offset!");
static_assert(offsetof(UGzWeaponData, OverheatDataSoftRef) == 0x0002B8, "Member 'UGzWeaponData::OverheatDataSoftRef' has a wrong offset!");
static_assert(offsetof(UGzWeaponData, AIOverheatDataSoftRef) == 0x0002E0, "Member 'UGzWeaponData::AIOverheatDataSoftRef' has a wrong offset!");

// Class G01.GzHUD
// 0x00F8 (0x0488 - 0x0390)
class AGzHUD final : public AHUD
{
public:
	uint8                                         Pad_3336[0x18];                                    // 0x0390(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<struct FGameplayTag, class UUserWidget*> MappedWidgets;                                     // 0x03A8(0x0050)(ExportObject, Transient, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	TSubclassOf<class AGzUIDataSystem>            DataSystemType;                                    // 0x03F8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UGzGamefaceSettings*                    GamefaceSettings;                                  // 0x0400(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UGzCohtmlUserWidget*                    CohtmlWidget;                                      // 0x0408(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UGzDebugInfoWidget*                     DebugInfo;                                         // 0x0410(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSoftClassPtr<class UClass>                   CohtmlWidgetClass;                                 // 0x0418(0x0028)(Edit, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSoftClassPtr<class UClass>                   VoiceChatStateWidgetClass;                         // 0x0440(0x0028)(Edit, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FVector2D                              VoiceChatStatePosNormalized;                       // 0x0468(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UGzVoiceChatStateWidget*                VoiceChatStateWidget;                              // 0x0478(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UGzWatermarkWidget*                     WatermarkWidget;                                   // 0x0480(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	class UUserWidget* AddWidget(TSubclassOf<class UUserWidget> WidgetClass, const struct FGameplayTag& WidgetId);
	bool EnableCohtmlInput(bool bFocus);
	void RemoveWidget(const struct FGameplayTag& WidgetId);
	void ToggleCohtmlUIVisibility(bool bFocus);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzHUD">();
	}
	static class AGzHUD* GetDefaultObj()
	{
		return GetDefaultObjImpl<AGzHUD>();
	}
};
static_assert(alignof(AGzHUD) == 0x000008, "Wrong alignment on AGzHUD");
static_assert(sizeof(AGzHUD) == 0x000488, "Wrong size on AGzHUD");
static_assert(offsetof(AGzHUD, MappedWidgets) == 0x0003A8, "Member 'AGzHUD::MappedWidgets' has a wrong offset!");
static_assert(offsetof(AGzHUD, DataSystemType) == 0x0003F8, "Member 'AGzHUD::DataSystemType' has a wrong offset!");
static_assert(offsetof(AGzHUD, GamefaceSettings) == 0x000400, "Member 'AGzHUD::GamefaceSettings' has a wrong offset!");
static_assert(offsetof(AGzHUD, CohtmlWidget) == 0x000408, "Member 'AGzHUD::CohtmlWidget' has a wrong offset!");
static_assert(offsetof(AGzHUD, DebugInfo) == 0x000410, "Member 'AGzHUD::DebugInfo' has a wrong offset!");
static_assert(offsetof(AGzHUD, CohtmlWidgetClass) == 0x000418, "Member 'AGzHUD::CohtmlWidgetClass' has a wrong offset!");
static_assert(offsetof(AGzHUD, VoiceChatStateWidgetClass) == 0x000440, "Member 'AGzHUD::VoiceChatStateWidgetClass' has a wrong offset!");
static_assert(offsetof(AGzHUD, VoiceChatStatePosNormalized) == 0x000468, "Member 'AGzHUD::VoiceChatStatePosNormalized' has a wrong offset!");
static_assert(offsetof(AGzHUD, VoiceChatStateWidget) == 0x000478, "Member 'AGzHUD::VoiceChatStateWidget' has a wrong offset!");
static_assert(offsetof(AGzHUD, WatermarkWidget) == 0x000480, "Member 'AGzHUD::WatermarkWidget' has a wrong offset!");

// Class G01.GzInactiveMarkerFilter
// 0x0000 (0x0038 - 0x0038)
class UGzInactiveMarkerFilter final : public UGzMarkerActiveStateFilter
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzInactiveMarkerFilter">();
	}
	static class UGzInactiveMarkerFilter* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzInactiveMarkerFilter>();
	}
};
static_assert(alignof(UGzInactiveMarkerFilter) == 0x000008, "Wrong alignment on UGzInactiveMarkerFilter");
static_assert(sizeof(UGzInactiveMarkerFilter) == 0x000038, "Wrong size on UGzInactiveMarkerFilter");

// Class G01.GzWeaponSwayModifier
// 0x0008 (0x0030 - 0x0028)
class UGzWeaponSwayModifier final : public UGzWeaponModifier
{
public:
	float                                         DistanceModifierCoefficient;                       // 0x0028(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3337[0x4];                                     // 0x002C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzWeaponSwayModifier">();
	}
	static class UGzWeaponSwayModifier* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzWeaponSwayModifier>();
	}
};
static_assert(alignof(UGzWeaponSwayModifier) == 0x000008, "Wrong alignment on UGzWeaponSwayModifier");
static_assert(sizeof(UGzWeaponSwayModifier) == 0x000030, "Wrong size on UGzWeaponSwayModifier");
static_assert(offsetof(UGzWeaponSwayModifier, DistanceModifierCoefficient) == 0x000028, "Member 'UGzWeaponSwayModifier::DistanceModifierCoefficient' has a wrong offset!");

// Class G01.GzInitState
// 0x0000 (0x0070 - 0x0070)
class UGzInitState final : public UGzFlowStateWithActionGraph
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzInitState">();
	}
	static class UGzInitState* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzInitState>();
	}
};
static_assert(alignof(UGzInitState) == 0x000008, "Wrong alignment on UGzInitState");
static_assert(sizeof(UGzInitState) == 0x000070, "Wrong size on UGzInitState");

// Class G01.GzXR_DamageRedeployModifier
// 0x0068 (0x00F0 - 0x0088)
class UGzXR_DamageRedeployModifier final : public UGzXR_BaseRedeployModifier
{
public:
	TArray<struct FGameplayAttribute>             DamageAttributesToTrack;                           // 0x0088(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPrivate)
	float                                         MinDamageToTrigger;                                // 0x0098(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_3338[0x54];                                    // 0x009C(0x0054)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzXR_DamageRedeployModifier">();
	}
	static class UGzXR_DamageRedeployModifier* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzXR_DamageRedeployModifier>();
	}
};
static_assert(alignof(UGzXR_DamageRedeployModifier) == 0x000008, "Wrong alignment on UGzXR_DamageRedeployModifier");
static_assert(sizeof(UGzXR_DamageRedeployModifier) == 0x0000F0, "Wrong size on UGzXR_DamageRedeployModifier");
static_assert(offsetof(UGzXR_DamageRedeployModifier, DamageAttributesToTrack) == 0x000088, "Member 'UGzXR_DamageRedeployModifier::DamageAttributesToTrack' has a wrong offset!");
static_assert(offsetof(UGzXR_DamageRedeployModifier, MinDamageToTrigger) == 0x000098, "Member 'UGzXR_DamageRedeployModifier::MinDamageToTrigger' has a wrong offset!");

// Class G01.GzInputUserSettings
// 0x0000 (0x0120 - 0x0120)
class UGzInputUserSettings final : public UEnhancedInputUserSettings
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzInputUserSettings">();
	}
	static class UGzInputUserSettings* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzInputUserSettings>();
	}
};
static_assert(alignof(UGzInputUserSettings) == 0x000008, "Wrong alignment on UGzInputUserSettings");
static_assert(sizeof(UGzInputUserSettings) == 0x000120, "Wrong size on UGzInputUserSettings");

// Class G01.GzInteractionCondition_NotHaveMissionWithType
// 0x0000 (0x0040 - 0x0040)
class UGzInteractionCondition_NotHaveMissionWithType final : public UGzInteractionCondition
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzInteractionCondition_NotHaveMissionWithType">();
	}
	static class UGzInteractionCondition_NotHaveMissionWithType* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzInteractionCondition_NotHaveMissionWithType>();
	}
};
static_assert(alignof(UGzInteractionCondition_NotHaveMissionWithType) == 0x000008, "Wrong alignment on UGzInteractionCondition_NotHaveMissionWithType");
static_assert(sizeof(UGzInteractionCondition_NotHaveMissionWithType) == 0x000040, "Wrong size on UGzInteractionCondition_NotHaveMissionWithType");

// Class G01.GzInteractionSetup
// 0x00F8 (0x0128 - 0x0030)
class UGzInteractionSetup final : public UDataAsset
{
public:
	struct FGzInteractionData                     InteractionData;                                   // 0x0030(0x00F8)(Edit, ContainsInstancedReference, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzInteractionSetup">();
	}
	static class UGzInteractionSetup* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzInteractionSetup>();
	}
};
static_assert(alignof(UGzInteractionSetup) == 0x000008, "Wrong alignment on UGzInteractionSetup");
static_assert(sizeof(UGzInteractionSetup) == 0x000128, "Wrong size on UGzInteractionSetup");
static_assert(offsetof(UGzInteractionSetup, InteractionData) == 0x000030, "Member 'UGzInteractionSetup::InteractionData' has a wrong offset!");

// Class G01.GzXR_HexExtractionModifierEvent
// 0x0008 (0x0060 - 0x0058)
class UGzXR_HexExtractionModifierEvent final : public UGzXR_BaseEvent
{
public:
	float                                         HexExtractionPriceModifier;                        // 0x0058(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         HexExtractionTimeModifier;                         // 0x005C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzXR_HexExtractionModifierEvent">();
	}
	static class UGzXR_HexExtractionModifierEvent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzXR_HexExtractionModifierEvent>();
	}
};
static_assert(alignof(UGzXR_HexExtractionModifierEvent) == 0x000008, "Wrong alignment on UGzXR_HexExtractionModifierEvent");
static_assert(sizeof(UGzXR_HexExtractionModifierEvent) == 0x000060, "Wrong size on UGzXR_HexExtractionModifierEvent");
static_assert(offsetof(UGzXR_HexExtractionModifierEvent, HexExtractionPriceModifier) == 0x000058, "Member 'UGzXR_HexExtractionModifierEvent::HexExtractionPriceModifier' has a wrong offset!");
static_assert(offsetof(UGzXR_HexExtractionModifierEvent, HexExtractionTimeModifier) == 0x00005C, "Member 'UGzXR_HexExtractionModifierEvent::HexExtractionTimeModifier' has a wrong offset!");

// Class G01.GzInteractionDataInterface
// 0x0000 (0x0028 - 0x0028)
class IGzInteractionDataInterface final : public IInterface
{
public:
	bool GetCurrentInteractionInfo(const class AGzCharacter* InteractedBy, const TArray<struct FGzInteractionInfo>& InteractionInfoArray, struct FGameplayTag* OutInteractionTag, struct FGzInteractionData* OutInteractionData) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzInteractionDataInterface">();
	}
	static class IGzInteractionDataInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IGzInteractionDataInterface>();
	}
};
static_assert(alignof(IGzInteractionDataInterface) == 0x000008, "Wrong alignment on IGzInteractionDataInterface");
static_assert(sizeof(IGzInteractionDataInterface) == 0x000028, "Wrong size on IGzInteractionDataInterface");

// Class G01.GzInventoryDisabledAssetsTrackerComponent
// 0x0000 (0x00A0 - 0x00A0)
class UGzInventoryDisabledAssetsTrackerComponent final : public UGzServiceComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzInventoryDisabledAssetsTrackerComponent">();
	}
	static class UGzInventoryDisabledAssetsTrackerComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzInventoryDisabledAssetsTrackerComponent>();
	}
};
static_assert(alignof(UGzInventoryDisabledAssetsTrackerComponent) == 0x000008, "Wrong alignment on UGzInventoryDisabledAssetsTrackerComponent");
static_assert(sizeof(UGzInventoryDisabledAssetsTrackerComponent) == 0x0000A0, "Wrong size on UGzInventoryDisabledAssetsTrackerComponent");

// Class G01.GzSupplementalMissionData
// 0x0000 (0x01C0 - 0x01C0)
class UGzSupplementalMissionData final : public UGzMissionData
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzSupplementalMissionData">();
	}
	static class UGzSupplementalMissionData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzSupplementalMissionData>();
	}
};
static_assert(alignof(UGzSupplementalMissionData) == 0x000008, "Wrong alignment on UGzSupplementalMissionData");
static_assert(sizeof(UGzSupplementalMissionData) == 0x0001C0, "Wrong size on UGzSupplementalMissionData");

// Class G01.GzInventoryEventHandlingComponent
// 0x0058 (0x00F8 - 0x00A0)
class UGzInventoryEventHandlingComponent final : public UGzServiceComponent
{
public:
	uint8                                         Pad_333A[0x58];                                    // 0x00A0(0x0058)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzInventoryEventHandlingComponent">();
	}
	static class UGzInventoryEventHandlingComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzInventoryEventHandlingComponent>();
	}
};
static_assert(alignof(UGzInventoryEventHandlingComponent) == 0x000008, "Wrong alignment on UGzInventoryEventHandlingComponent");
static_assert(sizeof(UGzInventoryEventHandlingComponent) == 0x0000F8, "Wrong size on UGzInventoryEventHandlingComponent");

// Class G01.GzInventoryFetchingComponent
// 0x0070 (0x0110 - 0x00A0)
class UGzInventoryFetchingComponent final : public UGzServiceComponent
{
public:
	struct FGzOnlineInventoryItemsCollection      LoadProxyInventory;                                // 0x00A0(0x0068)(NativeAccessSpecifierPrivate)
	uint8                                         Pad_333B[0x8];                                     // 0x0108(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzInventoryFetchingComponent">();
	}
	static class UGzInventoryFetchingComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzInventoryFetchingComponent>();
	}
};
static_assert(alignof(UGzInventoryFetchingComponent) == 0x000008, "Wrong alignment on UGzInventoryFetchingComponent");
static_assert(sizeof(UGzInventoryFetchingComponent) == 0x000110, "Wrong size on UGzInventoryFetchingComponent");
static_assert(offsetof(UGzInventoryFetchingComponent, LoadProxyInventory) == 0x0000A0, "Member 'UGzInventoryFetchingComponent::LoadProxyInventory' has a wrong offset!");

// Class G01.GzSymbolEncodeWidget
// 0x0010 (0x02F0 - 0x02E0)
class UGzSymbolEncodeWidget : public UUserWidget
{
public:
	class UTextBlock*                             TextBlock;                                         // 0x02E0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bVertical;                                         // 0x02E8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_333C[0x7];                                     // 0x02E9(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetHexString(const class FString& InString);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzSymbolEncodeWidget">();
	}
	static class UGzSymbolEncodeWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzSymbolEncodeWidget>();
	}
};
static_assert(alignof(UGzSymbolEncodeWidget) == 0x000008, "Wrong alignment on UGzSymbolEncodeWidget");
static_assert(sizeof(UGzSymbolEncodeWidget) == 0x0002F0, "Wrong size on UGzSymbolEncodeWidget");
static_assert(offsetof(UGzSymbolEncodeWidget, TextBlock) == 0x0002E0, "Member 'UGzSymbolEncodeWidget::TextBlock' has a wrong offset!");
static_assert(offsetof(UGzSymbolEncodeWidget, bVertical) == 0x0002E8, "Member 'UGzSymbolEncodeWidget::bVertical' has a wrong offset!");

// Class G01.GzInventoryGlobalItemLimitsComponent
// 0x0068 (0x0108 - 0x00A0)
class UGzInventoryGlobalItemLimitsComponent final : public UGzServiceComponent
{
public:
	uint8                                         Pad_333D[0x68];                                    // 0x00A0(0x0068)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzInventoryGlobalItemLimitsComponent">();
	}
	static class UGzInventoryGlobalItemLimitsComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzInventoryGlobalItemLimitsComponent>();
	}
};
static_assert(alignof(UGzInventoryGlobalItemLimitsComponent) == 0x000008, "Wrong alignment on UGzInventoryGlobalItemLimitsComponent");
static_assert(sizeof(UGzInventoryGlobalItemLimitsComponent) == 0x000108, "Wrong size on UGzInventoryGlobalItemLimitsComponent");

// Class G01.GzInventoryGunHoldingComponent
// 0x0018 (0x00B8 - 0x00A0)
class UGzInventoryGunHoldingComponent final : public UGzServiceComponent
{
public:
	uint8                                         Pad_333E[0x18];                                    // 0x00A0(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzInventoryGunHoldingComponent">();
	}
	static class UGzInventoryGunHoldingComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzInventoryGunHoldingComponent>();
	}
};
static_assert(alignof(UGzInventoryGunHoldingComponent) == 0x000008, "Wrong alignment on UGzInventoryGunHoldingComponent");
static_assert(sizeof(UGzInventoryGunHoldingComponent) == 0x0000B8, "Wrong size on UGzInventoryGunHoldingComponent");

// Class G01.GzUnityMatchmakingServiceState
// 0x0018 (0x00B8 - 0x00A0)
class UGzUnityMatchmakingServiceState : public UGzServiceComponent
{
public:
	uint8                                         Pad_333F[0x18];                                    // 0x00A0(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzUnityMatchmakingServiceState">();
	}
	static class UGzUnityMatchmakingServiceState* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzUnityMatchmakingServiceState>();
	}
};
static_assert(alignof(UGzUnityMatchmakingServiceState) == 0x000008, "Wrong alignment on UGzUnityMatchmakingServiceState");
static_assert(sizeof(UGzUnityMatchmakingServiceState) == 0x0000B8, "Wrong size on UGzUnityMatchmakingServiceState");

// Class G01.GzUnityMatchmakingServiceStateTicketRequest
// 0x0078 (0x0130 - 0x00B8)
class UGzUnityMatchmakingServiceStateTicketRequest final : public UGzUnityMatchmakingServiceState
{
public:
	uint8                                         Pad_3340[0x78];                                    // 0x00B8(0x0078)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzUnityMatchmakingServiceStateTicketRequest">();
	}
	static class UGzUnityMatchmakingServiceStateTicketRequest* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzUnityMatchmakingServiceStateTicketRequest>();
	}
};
static_assert(alignof(UGzUnityMatchmakingServiceStateTicketRequest) == 0x000008, "Wrong alignment on UGzUnityMatchmakingServiceStateTicketRequest");
static_assert(sizeof(UGzUnityMatchmakingServiceStateTicketRequest) == 0x000130, "Wrong size on UGzUnityMatchmakingServiceStateTicketRequest");

// Class G01.GzInventoryStarterItemsComponent
// 0x0000 (0x00A0 - 0x00A0)
class UGzInventoryStarterItemsComponent final : public UGzServiceComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzInventoryStarterItemsComponent">();
	}
	static class UGzInventoryStarterItemsComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzInventoryStarterItemsComponent>();
	}
};
static_assert(alignof(UGzInventoryStarterItemsComponent) == 0x000008, "Wrong alignment on UGzInventoryStarterItemsComponent");
static_assert(sizeof(UGzInventoryStarterItemsComponent) == 0x0000A0, "Wrong size on UGzInventoryStarterItemsComponent");

// Class G01.GzItemSkinMaterial
// 0x0040 (0x0068 - 0x0028)
class UGzItemSkinMaterial final : public UObject
{
public:
	TSoftObjectPtr<class UMaterialInterface>      MaterialAsset;                                     // 0x0028(0x0028)(Edit, BlueprintVisible, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   MaterialSlotName;                                  // 0x0050(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   MaterialSlotNameManual;                            // 0x0058(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bUseManualSlotName;                                // 0x0060(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3341[0x7];                                     // 0x0061(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzItemSkinMaterial">();
	}
	static class UGzItemSkinMaterial* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzItemSkinMaterial>();
	}
};
static_assert(alignof(UGzItemSkinMaterial) == 0x000008, "Wrong alignment on UGzItemSkinMaterial");
static_assert(sizeof(UGzItemSkinMaterial) == 0x000068, "Wrong size on UGzItemSkinMaterial");
static_assert(offsetof(UGzItemSkinMaterial, MaterialAsset) == 0x000028, "Member 'UGzItemSkinMaterial::MaterialAsset' has a wrong offset!");
static_assert(offsetof(UGzItemSkinMaterial, MaterialSlotName) == 0x000050, "Member 'UGzItemSkinMaterial::MaterialSlotName' has a wrong offset!");
static_assert(offsetof(UGzItemSkinMaterial, MaterialSlotNameManual) == 0x000058, "Member 'UGzItemSkinMaterial::MaterialSlotNameManual' has a wrong offset!");
static_assert(offsetof(UGzItemSkinMaterial, bUseManualSlotName) == 0x000060, "Member 'UGzItemSkinMaterial::bUseManualSlotName' has a wrong offset!");

// Class G01.GzItemsValidatingComponent
// 0x0008 (0x00A8 - 0x00A0)
class UGzItemsValidatingComponent final : public UGzServiceComponent
{
public:
	uint8                                         Pad_3342[0x8];                                     // 0x00A0(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzItemsValidatingComponent">();
	}
	static class UGzItemsValidatingComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzItemsValidatingComponent>();
	}
};
static_assert(alignof(UGzItemsValidatingComponent) == 0x000008, "Wrong alignment on UGzItemsValidatingComponent");
static_assert(sizeof(UGzItemsValidatingComponent) == 0x0000A8, "Wrong size on UGzItemsValidatingComponent");

// Class G01.GzWorldSettings
// 0x0138 (0x05F8 - 0x04C0)
class AGzWorldSettings final : public AWorldSettings
{
public:
	TMap<class FName, struct FGzWorldDataLayerPreset> NamedDataLayerPresets;                             // 0x04C0(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	class UGzGameModeSettings*                    GameModeOverrides;                                 // 0x0510(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UGzMapData*                             Map;                                               // 0x0518(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<struct FGzTrackSet>                    NamedDeploymentPathSets;                           // 0x0520(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	class FName                                   DefaultDeploymentPathSetName;                      // 0x0530(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MapPingOffset;                                     // 0x0538(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MapDefaultZ;                                       // 0x053C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class FName>                           PlayableZones;                                     // 0x0540(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	class FName                                   PlayableAreaLayer;                                 // 0x0550(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<struct FGzWorldZoneSetup>              ZoneSetups;                                        // 0x0558(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	TSoftClassPtr<class UClass>                   DeploymentCutsceneClass;                           // 0x0568(0x0028)(Edit, DisableEditOnInstance, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class UGzWorldZone*>                   WorldZones;                                        // 0x0590(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, Protected, NativeAccessSpecifierProtected)
	TMap<class FName, struct FGzWorldZoneArray>   WorldZonesLayers;                                  // 0x05A0(0x0050)(Edit, EditConst, Protected, NativeAccessSpecifierProtected)
	class UGzGroupRarityInstancesSetupData*       LootContainersGroupRarityInstancesSetup;           // 0x05F0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	const TArray<class UGzWorldZone*> GetLayerWorldZones(class FName Layer) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzWorldSettings">();
	}
	static class AGzWorldSettings* GetDefaultObj()
	{
		return GetDefaultObjImpl<AGzWorldSettings>();
	}
};
static_assert(alignof(AGzWorldSettings) == 0x000008, "Wrong alignment on AGzWorldSettings");
static_assert(sizeof(AGzWorldSettings) == 0x0005F8, "Wrong size on AGzWorldSettings");
static_assert(offsetof(AGzWorldSettings, NamedDataLayerPresets) == 0x0004C0, "Member 'AGzWorldSettings::NamedDataLayerPresets' has a wrong offset!");
static_assert(offsetof(AGzWorldSettings, GameModeOverrides) == 0x000510, "Member 'AGzWorldSettings::GameModeOverrides' has a wrong offset!");
static_assert(offsetof(AGzWorldSettings, Map) == 0x000518, "Member 'AGzWorldSettings::Map' has a wrong offset!");
static_assert(offsetof(AGzWorldSettings, NamedDeploymentPathSets) == 0x000520, "Member 'AGzWorldSettings::NamedDeploymentPathSets' has a wrong offset!");
static_assert(offsetof(AGzWorldSettings, DefaultDeploymentPathSetName) == 0x000530, "Member 'AGzWorldSettings::DefaultDeploymentPathSetName' has a wrong offset!");
static_assert(offsetof(AGzWorldSettings, MapPingOffset) == 0x000538, "Member 'AGzWorldSettings::MapPingOffset' has a wrong offset!");
static_assert(offsetof(AGzWorldSettings, MapDefaultZ) == 0x00053C, "Member 'AGzWorldSettings::MapDefaultZ' has a wrong offset!");
static_assert(offsetof(AGzWorldSettings, PlayableZones) == 0x000540, "Member 'AGzWorldSettings::PlayableZones' has a wrong offset!");
static_assert(offsetof(AGzWorldSettings, PlayableAreaLayer) == 0x000550, "Member 'AGzWorldSettings::PlayableAreaLayer' has a wrong offset!");
static_assert(offsetof(AGzWorldSettings, ZoneSetups) == 0x000558, "Member 'AGzWorldSettings::ZoneSetups' has a wrong offset!");
static_assert(offsetof(AGzWorldSettings, DeploymentCutsceneClass) == 0x000568, "Member 'AGzWorldSettings::DeploymentCutsceneClass' has a wrong offset!");
static_assert(offsetof(AGzWorldSettings, WorldZones) == 0x000590, "Member 'AGzWorldSettings::WorldZones' has a wrong offset!");
static_assert(offsetof(AGzWorldSettings, WorldZonesLayers) == 0x0005A0, "Member 'AGzWorldSettings::WorldZonesLayers' has a wrong offset!");
static_assert(offsetof(AGzWorldSettings, LootContainersGroupRarityInstancesSetup) == 0x0005F0, "Member 'AGzWorldSettings::LootContainersGroupRarityInstancesSetup' has a wrong offset!");

// Class G01.GzJobZeroCheatManager
// 0x0000 (0x0150 - 0x0150)
class UGzJobZeroCheatManager final : public UGzCheatManager
{
public:
	void EndPostMatch();
	void ForceLoseMatch();
	void ForceWinMatch();
	void StartMatch();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzJobZeroCheatManager">();
	}
	static class UGzJobZeroCheatManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzJobZeroCheatManager>();
	}
};
static_assert(alignof(UGzJobZeroCheatManager) == 0x000008, "Wrong alignment on UGzJobZeroCheatManager");
static_assert(sizeof(UGzJobZeroCheatManager) == 0x000150, "Wrong size on UGzJobZeroCheatManager");

// Class G01.GzThrowableShieldPreviewPathActor
// 0x0008 (0x0498 - 0x0490)
class AGzThrowableShieldPreviewPathActor final : public AGzPreviewPathActor
{
public:
	class UGzThrowableShieldComponent*            ThrowableShieldComponent;                          // 0x0490(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzThrowableShieldPreviewPathActor">();
	}
	static class AGzThrowableShieldPreviewPathActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<AGzThrowableShieldPreviewPathActor>();
	}
};
static_assert(alignof(AGzThrowableShieldPreviewPathActor) == 0x000008, "Wrong alignment on AGzThrowableShieldPreviewPathActor");
static_assert(sizeof(AGzThrowableShieldPreviewPathActor) == 0x000498, "Wrong size on AGzThrowableShieldPreviewPathActor");
static_assert(offsetof(AGzThrowableShieldPreviewPathActor, ThrowableShieldComponent) == 0x000490, "Member 'AGzThrowableShieldPreviewPathActor::ThrowableShieldComponent' has a wrong offset!");

// Class G01.GzJobZeroGameSettings
// 0x0060 (0x01D0 - 0x0170)
class UGzJobZeroGameSettings final : public UGzSessionGameModeSettings
{
public:
	float                                         PrepareMatchDuration;                              // 0x0170(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PostMatchDuration;                                 // 0x0174(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         TargetTeamId;                                      // 0x0178(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3343[0x4];                                     // 0x017C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftClassPtr<class UClass>                   MissionSoftClass;                                  // 0x0180(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftClassPtr<class UClass>                   AntagonistMissionSoftClass;                        // 0x01A8(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzJobZeroGameSettings">();
	}
	static class UGzJobZeroGameSettings* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzJobZeroGameSettings>();
	}
};
static_assert(alignof(UGzJobZeroGameSettings) == 0x000008, "Wrong alignment on UGzJobZeroGameSettings");
static_assert(sizeof(UGzJobZeroGameSettings) == 0x0001D0, "Wrong size on UGzJobZeroGameSettings");
static_assert(offsetof(UGzJobZeroGameSettings, PrepareMatchDuration) == 0x000170, "Member 'UGzJobZeroGameSettings::PrepareMatchDuration' has a wrong offset!");
static_assert(offsetof(UGzJobZeroGameSettings, PostMatchDuration) == 0x000174, "Member 'UGzJobZeroGameSettings::PostMatchDuration' has a wrong offset!");
static_assert(offsetof(UGzJobZeroGameSettings, TargetTeamId) == 0x000178, "Member 'UGzJobZeroGameSettings::TargetTeamId' has a wrong offset!");
static_assert(offsetof(UGzJobZeroGameSettings, MissionSoftClass) == 0x000180, "Member 'UGzJobZeroGameSettings::MissionSoftClass' has a wrong offset!");
static_assert(offsetof(UGzJobZeroGameSettings, AntagonistMissionSoftClass) == 0x0001A8, "Member 'UGzJobZeroGameSettings::AntagonistMissionSoftClass' has a wrong offset!");

// Class G01.GzToxicSmokeComponent
// 0x0000 (0x0258 - 0x0258)
class UGzToxicSmokeComponent : public UGzChargeableAbilityComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzToxicSmokeComponent">();
	}
	static class UGzToxicSmokeComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzToxicSmokeComponent>();
	}
};
static_assert(alignof(UGzToxicSmokeComponent) == 0x000008, "Wrong alignment on UGzToxicSmokeComponent");
static_assert(sizeof(UGzToxicSmokeComponent) == 0x000258, "Wrong size on UGzToxicSmokeComponent");

// Class G01.GzJobZeroPlayerStart
// 0x0008 (0x02D8 - 0x02D0)
class AGzJobZeroPlayerStart final : public APlayerStart
{
public:
	int32                                         PlayerId;                                          // 0x02D0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3344[0x4];                                     // 0x02D4(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzJobZeroPlayerStart">();
	}
	static class AGzJobZeroPlayerStart* GetDefaultObj()
	{
		return GetDefaultObjImpl<AGzJobZeroPlayerStart>();
	}
};
static_assert(alignof(AGzJobZeroPlayerStart) == 0x000008, "Wrong alignment on AGzJobZeroPlayerStart");
static_assert(sizeof(AGzJobZeroPlayerStart) == 0x0002D8, "Wrong size on AGzJobZeroPlayerStart");
static_assert(offsetof(AGzJobZeroPlayerStart, PlayerId) == 0x0002D0, "Member 'AGzJobZeroPlayerStart::PlayerId' has a wrong offset!");

// Class G01.GzWorldZonesSubsystem
// 0x0050 (0x0080 - 0x0030)
class UGzWorldZonesSubsystem final : public UWorldSubsystem
{
public:
	TMap<class UClass*, struct FGzWorldZoneTrackingArray> TrackedComponents;                                 // 0x0030(0x0050)(Transient, ContainsInstancedReference, NativeAccessSpecifierPrivate)

public:
	int32 GetNumActorsInWorldZone(class UClass* Param_Class, class UGzWorldZone* InZone) const;
	TArray<class FName> GetWorldZoneNames(class FName Layer) const;
	const class UGzWorldZone* GetZoneByPosition(class FName Layer, const struct FVector2D& Position) const;
	class FText GetZoneDisplayName(class FName Layer, const struct FVector& Location) const;
	class FName GetZoneName(class FName Layer, const struct FVector& Position) const;
	bool HasWorldZone(const class FName& Layer, const class FName& Param_Name) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzWorldZonesSubsystem">();
	}
	static class UGzWorldZonesSubsystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzWorldZonesSubsystem>();
	}
};
static_assert(alignof(UGzWorldZonesSubsystem) == 0x000008, "Wrong alignment on UGzWorldZonesSubsystem");
static_assert(sizeof(UGzWorldZonesSubsystem) == 0x000080, "Wrong size on UGzWorldZonesSubsystem");
static_assert(offsetof(UGzWorldZonesSubsystem, TrackedComponents) == 0x000030, "Member 'UGzWorldZonesSubsystem::TrackedComponents' has a wrong offset!");

// Class G01.GzJobZeroPlayerState
// 0x0000 (0x0690 - 0x0690)
class AGzJobZeroPlayerState final : public AGzPlayerState
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzJobZeroPlayerState">();
	}
	static class AGzJobZeroPlayerState* GetDefaultObj()
	{
		return GetDefaultObjImpl<AGzJobZeroPlayerState>();
	}
};
static_assert(alignof(AGzJobZeroPlayerState) == 0x000008, "Wrong alignment on AGzJobZeroPlayerState");
static_assert(sizeof(AGzJobZeroPlayerState) == 0x000690, "Wrong size on AGzJobZeroPlayerState");

// Class G01.GzStatsSubsystem
// 0x00B0 (0x00E0 - 0x0030)
class UGzStatsSubsystem final : public UWorldSubsystem
{
public:
	FMulticastInlineDelegateProperty_             OnStatChanged;                                     // 0x0030(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TArray<class UGzGameStatTemplate*>            StatTemplates;                                     // 0x0040(0x0010)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	TArray<class UGzGlobalStatsCollector*>        StatCollectors;                                    // 0x0050(0x0010)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	TArray<struct FGzPlayerStatSet>               PlayerStatsArray;                                  // 0x0060(0x0010)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	TArray<class UGzStatsHolderComponent*>        StatComponents;                                    // 0x0070(0x0010)(ExportObject, ZeroConstructor, Transient, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_3347[0x60];                                    // 0x0080(0x0060)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void NotifyNewCollectionStage(EGzGameStatCollectionStage NewCollectionStage);
	void ResetStats();

	const TArray<struct FGzGameStat> GetAllPlayerStats(int32 PlayerId) const;
	const TArray<class UGzGameStatTemplate*> GetStatTemplates() const;
	float GetStatValue(int32 PlayerId, const class FName& Key) const;
	bool HasPlayer(const int32 PlayerId) const;
	bool IsInitialized() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzStatsSubsystem">();
	}
	static class UGzStatsSubsystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzStatsSubsystem>();
	}
};
static_assert(alignof(UGzStatsSubsystem) == 0x000008, "Wrong alignment on UGzStatsSubsystem");
static_assert(sizeof(UGzStatsSubsystem) == 0x0000E0, "Wrong size on UGzStatsSubsystem");
static_assert(offsetof(UGzStatsSubsystem, OnStatChanged) == 0x000030, "Member 'UGzStatsSubsystem::OnStatChanged' has a wrong offset!");
static_assert(offsetof(UGzStatsSubsystem, StatTemplates) == 0x000040, "Member 'UGzStatsSubsystem::StatTemplates' has a wrong offset!");
static_assert(offsetof(UGzStatsSubsystem, StatCollectors) == 0x000050, "Member 'UGzStatsSubsystem::StatCollectors' has a wrong offset!");
static_assert(offsetof(UGzStatsSubsystem, PlayerStatsArray) == 0x000060, "Member 'UGzStatsSubsystem::PlayerStatsArray' has a wrong offset!");
static_assert(offsetof(UGzStatsSubsystem, StatComponents) == 0x000070, "Member 'UGzStatsSubsystem::StatComponents' has a wrong offset!");

// Class G01.GzLegalDocsState
// 0x0000 (0x0070 - 0x0070)
class UGzLegalDocsState final : public UGzFlowStateWithActionGraph
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzLegalDocsState">();
	}
	static class UGzLegalDocsState* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzLegalDocsState>();
	}
};
static_assert(alignof(UGzLegalDocsState) == 0x000008, "Wrong alignment on UGzLegalDocsState");
static_assert(sizeof(UGzLegalDocsState) == 0x000070, "Wrong size on UGzLegalDocsState");

// Class G01.GzLimbAttachingReplica
// 0x03B0 (0x0650 - 0x02A0)
class alignas(0x10) AGzLimbAttachingReplica : public AActor
{
public:
	struct FCurveTableRowHandle                   HorizontalTranslationProgressCurveHandle;          // 0x02A0(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bNormalizeHorizontalCurveTimes;                    // 0x02B0(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bNormalizeHorizontalCurveValues;                   // 0x02B1(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_334A[0x6];                                     // 0x02B2(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	struct FCurveTableRowHandle                   VerticalTranslationProgressCurveHandle;            // 0x02B8(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bNormalizeVerticalCurveTimes;                      // 0x02C8(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bNormalizeVerticalCurveValues;                     // 0x02C9(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_334B[0x6];                                     // 0x02CA(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	struct FCurveTableRowHandle                   RotationProgressCurveHandle;                       // 0x02D0(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bNormalizeRotationCurveTimes;                      // 0x02E0(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bNormalizeRotationCurveValues;                     // 0x02E1(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_334C[0x6];                                     // 0x02E2(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	struct FCurveTableRowHandle                   BlendingProgressCurveHandle;                       // 0x02E8(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bNormalizeBlendingCurveTimes;                      // 0x02F8(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bNormalizeBlendingCurveValues;                     // 0x02F9(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_334D[0x6];                                     // 0x02FA(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<EGzLimbType, TSubclassOf<class UAnimInstance>> AnimInstanceClasses;                               // 0x0300(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	float                                         VerticalAdjustmentSpeed;                           // 0x0350(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         LinearDamping;                                     // 0x0354(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         AngularDamping;                                    // 0x0358(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_334E[0x4];                                     // 0x035C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class AGzMultiPartCharacter*                  Character;                                         // 0x0360(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UGzBodyPartItemData*                    BodyPartItemData;                                  // 0x0368(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FGzInvItem                             InventoryItem;                                     // 0x0370(0x0010)(Transient, NativeAccessSpecifierPrivate)
	class USkeletalMeshComponent*                 MeshComponent;                                     // 0x0380(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class USkeletalMesh*                          CachedSkeletalMeshAsset;                           // 0x0388(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UNiagaraComponent*                      AttachingLimbParticleComponent;                    // 0x0390(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bFinishedAttaching;                                // 0x0398(0x0001)(Net, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_334F[0x3];                                     // 0x0399(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	EGzLimbAttachingProxyState                    State;                                             // 0x039C(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         BlendingProgress;                                  // 0x03A0(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_3350[0x2AC];                                   // 0x03A4(0x02AC)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void CancelAttaching();
	void StartAttaching(class AGzMultiPartCharacter* InCharacter, const class UGzBodyPartItemData* InBodyPartItemData, const struct FGzLimbAttachingParams& Params_0, const class AGzLimbPickable* Pickable);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzLimbAttachingReplica">();
	}
	static class AGzLimbAttachingReplica* GetDefaultObj()
	{
		return GetDefaultObjImpl<AGzLimbAttachingReplica>();
	}
};
static_assert(alignof(AGzLimbAttachingReplica) == 0x000010, "Wrong alignment on AGzLimbAttachingReplica");
static_assert(sizeof(AGzLimbAttachingReplica) == 0x000650, "Wrong size on AGzLimbAttachingReplica");
static_assert(offsetof(AGzLimbAttachingReplica, HorizontalTranslationProgressCurveHandle) == 0x0002A0, "Member 'AGzLimbAttachingReplica::HorizontalTranslationProgressCurveHandle' has a wrong offset!");
static_assert(offsetof(AGzLimbAttachingReplica, bNormalizeHorizontalCurveTimes) == 0x0002B0, "Member 'AGzLimbAttachingReplica::bNormalizeHorizontalCurveTimes' has a wrong offset!");
static_assert(offsetof(AGzLimbAttachingReplica, bNormalizeHorizontalCurveValues) == 0x0002B1, "Member 'AGzLimbAttachingReplica::bNormalizeHorizontalCurveValues' has a wrong offset!");
static_assert(offsetof(AGzLimbAttachingReplica, VerticalTranslationProgressCurveHandle) == 0x0002B8, "Member 'AGzLimbAttachingReplica::VerticalTranslationProgressCurveHandle' has a wrong offset!");
static_assert(offsetof(AGzLimbAttachingReplica, bNormalizeVerticalCurveTimes) == 0x0002C8, "Member 'AGzLimbAttachingReplica::bNormalizeVerticalCurveTimes' has a wrong offset!");
static_assert(offsetof(AGzLimbAttachingReplica, bNormalizeVerticalCurveValues) == 0x0002C9, "Member 'AGzLimbAttachingReplica::bNormalizeVerticalCurveValues' has a wrong offset!");
static_assert(offsetof(AGzLimbAttachingReplica, RotationProgressCurveHandle) == 0x0002D0, "Member 'AGzLimbAttachingReplica::RotationProgressCurveHandle' has a wrong offset!");
static_assert(offsetof(AGzLimbAttachingReplica, bNormalizeRotationCurveTimes) == 0x0002E0, "Member 'AGzLimbAttachingReplica::bNormalizeRotationCurveTimes' has a wrong offset!");
static_assert(offsetof(AGzLimbAttachingReplica, bNormalizeRotationCurveValues) == 0x0002E1, "Member 'AGzLimbAttachingReplica::bNormalizeRotationCurveValues' has a wrong offset!");
static_assert(offsetof(AGzLimbAttachingReplica, BlendingProgressCurveHandle) == 0x0002E8, "Member 'AGzLimbAttachingReplica::BlendingProgressCurveHandle' has a wrong offset!");
static_assert(offsetof(AGzLimbAttachingReplica, bNormalizeBlendingCurveTimes) == 0x0002F8, "Member 'AGzLimbAttachingReplica::bNormalizeBlendingCurveTimes' has a wrong offset!");
static_assert(offsetof(AGzLimbAttachingReplica, bNormalizeBlendingCurveValues) == 0x0002F9, "Member 'AGzLimbAttachingReplica::bNormalizeBlendingCurveValues' has a wrong offset!");
static_assert(offsetof(AGzLimbAttachingReplica, AnimInstanceClasses) == 0x000300, "Member 'AGzLimbAttachingReplica::AnimInstanceClasses' has a wrong offset!");
static_assert(offsetof(AGzLimbAttachingReplica, VerticalAdjustmentSpeed) == 0x000350, "Member 'AGzLimbAttachingReplica::VerticalAdjustmentSpeed' has a wrong offset!");
static_assert(offsetof(AGzLimbAttachingReplica, LinearDamping) == 0x000354, "Member 'AGzLimbAttachingReplica::LinearDamping' has a wrong offset!");
static_assert(offsetof(AGzLimbAttachingReplica, AngularDamping) == 0x000358, "Member 'AGzLimbAttachingReplica::AngularDamping' has a wrong offset!");
static_assert(offsetof(AGzLimbAttachingReplica, Character) == 0x000360, "Member 'AGzLimbAttachingReplica::Character' has a wrong offset!");
static_assert(offsetof(AGzLimbAttachingReplica, BodyPartItemData) == 0x000368, "Member 'AGzLimbAttachingReplica::BodyPartItemData' has a wrong offset!");
static_assert(offsetof(AGzLimbAttachingReplica, InventoryItem) == 0x000370, "Member 'AGzLimbAttachingReplica::InventoryItem' has a wrong offset!");
static_assert(offsetof(AGzLimbAttachingReplica, MeshComponent) == 0x000380, "Member 'AGzLimbAttachingReplica::MeshComponent' has a wrong offset!");
static_assert(offsetof(AGzLimbAttachingReplica, CachedSkeletalMeshAsset) == 0x000388, "Member 'AGzLimbAttachingReplica::CachedSkeletalMeshAsset' has a wrong offset!");
static_assert(offsetof(AGzLimbAttachingReplica, AttachingLimbParticleComponent) == 0x000390, "Member 'AGzLimbAttachingReplica::AttachingLimbParticleComponent' has a wrong offset!");
static_assert(offsetof(AGzLimbAttachingReplica, bFinishedAttaching) == 0x000398, "Member 'AGzLimbAttachingReplica::bFinishedAttaching' has a wrong offset!");
static_assert(offsetof(AGzLimbAttachingReplica, State) == 0x00039C, "Member 'AGzLimbAttachingReplica::State' has a wrong offset!");
static_assert(offsetof(AGzLimbAttachingReplica, BlendingProgress) == 0x0003A0, "Member 'AGzLimbAttachingReplica::BlendingProgress' has a wrong offset!");

// Class G01.GzUILobbyDataSystem
// 0x0000 (0x0308 - 0x0308)
class AGzUILobbyDataSystem final : public AGzUIDataSystem
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzUILobbyDataSystem">();
	}
	static class AGzUILobbyDataSystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<AGzUILobbyDataSystem>();
	}
};
static_assert(alignof(AGzUILobbyDataSystem) == 0x000008, "Wrong alignment on AGzUILobbyDataSystem");
static_assert(sizeof(AGzUILobbyDataSystem) == 0x000308, "Wrong size on AGzUILobbyDataSystem");

// Class G01.GzLimbCostMagnitudeCalculation
// 0x0000 (0x0040 - 0x0040)
class UGzLimbCostMagnitudeCalculation final : public UGameplayModMagnitudeCalculation
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzLimbCostMagnitudeCalculation">();
	}
	static class UGzLimbCostMagnitudeCalculation* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzLimbCostMagnitudeCalculation>();
	}
};
static_assert(alignof(UGzLimbCostMagnitudeCalculation) == 0x000008, "Wrong alignment on UGzLimbCostMagnitudeCalculation");
static_assert(sizeof(UGzLimbCostMagnitudeCalculation) == 0x000040, "Wrong size on UGzLimbCostMagnitudeCalculation");

// Class G01.GzLimbCrosshair
// 0x0008 (0x02F0 - 0x02E8)
class UGzLimbCrosshair : public UGzCrosshair
{
public:
	class UGzGA_BaseLimbAbility*                  LimbAbility;                                       // 0x02E8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void OnLimbActivated(EGzLimbType LimbType, const struct FGzLimbGaugeData& GaugeData);
	void OnLimbActivationEnded(EGzLimbType LimbType);
	void OnLimbActivationReachedFinalValue(EGzLimbType LimbType, const struct FGzLimbGaugeData& GaugeData);
	void OnLimbActivationUpdate(EGzLimbType LimbType, const struct FGzLimbGaugeData& GaugeData);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzLimbCrosshair">();
	}
	static class UGzLimbCrosshair* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzLimbCrosshair>();
	}
};
static_assert(alignof(UGzLimbCrosshair) == 0x000008, "Wrong alignment on UGzLimbCrosshair");
static_assert(sizeof(UGzLimbCrosshair) == 0x0002F0, "Wrong size on UGzLimbCrosshair");
static_assert(offsetof(UGzLimbCrosshair, LimbAbility) == 0x0002E8, "Member 'UGzLimbCrosshair::LimbAbility' has a wrong offset!");

// Class G01.GzLimbGaugeWidget
// 0x0000 (0x02E0 - 0x02E0)
class UGzLimbGaugeWidget final : public UUserWidget
{
public:
	void NotifyReachedFinal(float CurrentValue, float MaxValue);
	void SetCurrentValue(float CurrentValue, float MaxValue);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzLimbGaugeWidget">();
	}
	static class UGzLimbGaugeWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzLimbGaugeWidget>();
	}
};
static_assert(alignof(UGzLimbGaugeWidget) == 0x000008, "Wrong alignment on UGzLimbGaugeWidget");
static_assert(sizeof(UGzLimbGaugeWidget) == 0x0002E0, "Wrong size on UGzLimbGaugeWidget");

// Class G01.GzUnityMatchmakingServicePartyCommunicator
// 0x0138 (0x01D8 - 0x00A0)
class UGzUnityMatchmakingServicePartyCommunicator final : public UGzServiceComponent
{
public:
	uint8                                         Pad_3354[0x138];                                   // 0x00A0(0x0138)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzUnityMatchmakingServicePartyCommunicator">();
	}
	static class UGzUnityMatchmakingServicePartyCommunicator* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzUnityMatchmakingServicePartyCommunicator>();
	}
};
static_assert(alignof(UGzUnityMatchmakingServicePartyCommunicator) == 0x000008, "Wrong alignment on UGzUnityMatchmakingServicePartyCommunicator");
static_assert(sizeof(UGzUnityMatchmakingServicePartyCommunicator) == 0x0001D8, "Wrong size on UGzUnityMatchmakingServicePartyCommunicator");

// Class G01.GzLimbPickable
// 0x0180 (0x0610 - 0x0490)
class AGzLimbPickable : public AGzSkeletalMeshPickable
{
public:
	FMulticastInlineDelegateProperty_             OnHealthChanged;                                   // 0x0488(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnStatusChanged;                                   // 0x0498(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_3355[0x10];                                    // 0x04A8(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class UStaticMeshComponent*                   SimulationMeshComponent;                           // 0x04B8(0x0008)(Edit, ExportObject, ZeroConstructor, Transient, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TMap<EGzLimbType, class FName>                LimbTypeToEffectsSocketMap;                        // 0x04C0(0x0050)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	TMap<EGzLimbType, TSoftObjectPtr<class UStaticMesh>> SimulationProxyMeshes;                             // 0x0510(0x0050)(Edit, DisableEditOnInstance, Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	class FName                                   ProxyStaticMeshSocketName;                         // 0x0560(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         Health;                                            // 0x0568(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, EditConst, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         HealthNormalizedToAllowPickup;                     // 0x056C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         RegenerationRate;                                  // 0x0570(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         RegenerationIntervalServer;                        // 0x0574(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         RegenerationIntervalClient;                        // 0x0578(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3356[0xC];                                     // 0x057C(0x000C)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGzLimbStatusData                      LimbStatus;                                        // 0x0588(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, Net, EditConst, RepNotify, NoDestructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_3357[0x10];                                    // 0x05A0(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGzLimbInvItem                         LimbItem;                                          // 0x05B0(0x0058)(Net, Transient, NativeAccessSpecifierPrivate)
	uint8                                         Pad_3358[0x8];                                     // 0x0608(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnPickedUp();
	void OnRep_Health(const float OldHealth);
	void OnRep_LimbStatus(const struct FGzLimbStatusData& OldStatus);

	float GetHealth() const;
	float GetHealthNormalized() const;
	float GetHealthToAllowPickup() const;
	const struct FGzLimbStatusData GetLimbStatus() const;
	EGzLimbType GetLimbType() const;
	float GetMaxHealth() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzLimbPickable">();
	}
	static class AGzLimbPickable* GetDefaultObj()
	{
		return GetDefaultObjImpl<AGzLimbPickable>();
	}
};
static_assert(alignof(AGzLimbPickable) == 0x000010, "Wrong alignment on AGzLimbPickable");
static_assert(sizeof(AGzLimbPickable) == 0x000610, "Wrong size on AGzLimbPickable");
static_assert(offsetof(AGzLimbPickable, OnHealthChanged) == 0x000488, "Member 'AGzLimbPickable::OnHealthChanged' has a wrong offset!");
static_assert(offsetof(AGzLimbPickable, OnStatusChanged) == 0x000498, "Member 'AGzLimbPickable::OnStatusChanged' has a wrong offset!");
static_assert(offsetof(AGzLimbPickable, SimulationMeshComponent) == 0x0004B8, "Member 'AGzLimbPickable::SimulationMeshComponent' has a wrong offset!");
static_assert(offsetof(AGzLimbPickable, LimbTypeToEffectsSocketMap) == 0x0004C0, "Member 'AGzLimbPickable::LimbTypeToEffectsSocketMap' has a wrong offset!");
static_assert(offsetof(AGzLimbPickable, SimulationProxyMeshes) == 0x000510, "Member 'AGzLimbPickable::SimulationProxyMeshes' has a wrong offset!");
static_assert(offsetof(AGzLimbPickable, ProxyStaticMeshSocketName) == 0x000560, "Member 'AGzLimbPickable::ProxyStaticMeshSocketName' has a wrong offset!");
static_assert(offsetof(AGzLimbPickable, Health) == 0x000568, "Member 'AGzLimbPickable::Health' has a wrong offset!");
static_assert(offsetof(AGzLimbPickable, HealthNormalizedToAllowPickup) == 0x00056C, "Member 'AGzLimbPickable::HealthNormalizedToAllowPickup' has a wrong offset!");
static_assert(offsetof(AGzLimbPickable, RegenerationRate) == 0x000570, "Member 'AGzLimbPickable::RegenerationRate' has a wrong offset!");
static_assert(offsetof(AGzLimbPickable, RegenerationIntervalServer) == 0x000574, "Member 'AGzLimbPickable::RegenerationIntervalServer' has a wrong offset!");
static_assert(offsetof(AGzLimbPickable, RegenerationIntervalClient) == 0x000578, "Member 'AGzLimbPickable::RegenerationIntervalClient' has a wrong offset!");
static_assert(offsetof(AGzLimbPickable, LimbStatus) == 0x000588, "Member 'AGzLimbPickable::LimbStatus' has a wrong offset!");
static_assert(offsetof(AGzLimbPickable, LimbItem) == 0x0005B0, "Member 'AGzLimbPickable::LimbItem' has a wrong offset!");

// Class G01.GzWeaponScopeModifier
// 0x0050 (0x0078 - 0x0028)
class UGzWeaponScopeModifier : public UGzWeaponAimModifier
{
public:
	TSoftClassPtr<class UClass>                   ScopeMeshActorOverride;                            // 0x0028(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FGzScopeMode>                   ScopeModes;                                        // 0x0050(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	class UAkAudioEvent*                          ScopeIdleSound;                                    // 0x0060(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAkAudioEvent*                          ScopeModeChangedSound;                             // 0x0068(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3359[0x8];                                     // 0x0070(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzWeaponScopeModifier">();
	}
	static class UGzWeaponScopeModifier* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzWeaponScopeModifier>();
	}
};
static_assert(alignof(UGzWeaponScopeModifier) == 0x000008, "Wrong alignment on UGzWeaponScopeModifier");
static_assert(sizeof(UGzWeaponScopeModifier) == 0x000078, "Wrong size on UGzWeaponScopeModifier");
static_assert(offsetof(UGzWeaponScopeModifier, ScopeMeshActorOverride) == 0x000028, "Member 'UGzWeaponScopeModifier::ScopeMeshActorOverride' has a wrong offset!");
static_assert(offsetof(UGzWeaponScopeModifier, ScopeModes) == 0x000050, "Member 'UGzWeaponScopeModifier::ScopeModes' has a wrong offset!");
static_assert(offsetof(UGzWeaponScopeModifier, ScopeIdleSound) == 0x000060, "Member 'UGzWeaponScopeModifier::ScopeIdleSound' has a wrong offset!");
static_assert(offsetof(UGzWeaponScopeModifier, ScopeModeChangedSound) == 0x000068, "Member 'UGzWeaponScopeModifier::ScopeModeChangedSound' has a wrong offset!");

// Class G01.GzLimbShootOffMessage
// 0x0008 (0x0050 - 0x0048)
class UGzLimbShootOffMessage final : public UGzPlayerToPlayerInteractionMessage
{
public:
	EGzLimbType                                   LimbType;                                          // 0x0048(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_335A[0x7];                                     // 0x0049(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzLimbShootOffMessage">();
	}
	static class UGzLimbShootOffMessage* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzLimbShootOffMessage>();
	}
};
static_assert(alignof(UGzLimbShootOffMessage) == 0x000008, "Wrong alignment on UGzLimbShootOffMessage");
static_assert(sizeof(UGzLimbShootOffMessage) == 0x000050, "Wrong size on UGzLimbShootOffMessage");
static_assert(offsetof(UGzLimbShootOffMessage, LimbType) == 0x000048, "Member 'UGzLimbShootOffMessage::LimbType' has a wrong offset!");

// Class G01.GzWeaponBulletTravelModifier
// 0x0008 (0x0030 - 0x0028)
class UGzWeaponBulletTravelModifier final : public UGzWeaponModifier
{
public:
	float                                         BulletStartVelocityMultiplier;                     // 0x0028(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_335B[0x4];                                     // 0x002C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzWeaponBulletTravelModifier">();
	}
	static class UGzWeaponBulletTravelModifier* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzWeaponBulletTravelModifier>();
	}
};
static_assert(alignof(UGzWeaponBulletTravelModifier) == 0x000008, "Wrong alignment on UGzWeaponBulletTravelModifier");
static_assert(sizeof(UGzWeaponBulletTravelModifier) == 0x000030, "Wrong size on UGzWeaponBulletTravelModifier");
static_assert(offsetof(UGzWeaponBulletTravelModifier, BulletStartVelocityMultiplier) == 0x000028, "Member 'UGzWeaponBulletTravelModifier::BulletStartVelocityMultiplier' has a wrong offset!");

// Class G01.GzLimbsUsageMessage
// 0x0008 (0x0038 - 0x0030)
class UGzLimbsUsageMessage final : public UGzInstigatedMessage
{
public:
	uint8                                         Pad_335C[0x8];                                     // 0x0030(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzLimbsUsageMessage">();
	}
	static class UGzLimbsUsageMessage* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzLimbsUsageMessage>();
	}
};
static_assert(alignof(UGzLimbsUsageMessage) == 0x000008, "Wrong alignment on UGzLimbsUsageMessage");
static_assert(sizeof(UGzLimbsUsageMessage) == 0x000038, "Wrong size on UGzLimbsUsageMessage");

// Class G01.GzLiveFeaturesCdnFetchingComponent
// 0x0028 (0x00C8 - 0x00A0)
class UGzLiveFeaturesCdnFetchingComponent final : public UGzServiceComponent
{
public:
	uint8                                         Pad_335D[0x28];                                    // 0x00A0(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzLiveFeaturesCdnFetchingComponent">();
	}
	static class UGzLiveFeaturesCdnFetchingComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzLiveFeaturesCdnFetchingComponent>();
	}
};
static_assert(alignof(UGzLiveFeaturesCdnFetchingComponent) == 0x000008, "Wrong alignment on UGzLiveFeaturesCdnFetchingComponent");
static_assert(sizeof(UGzLiveFeaturesCdnFetchingComponent) == 0x0000C8, "Wrong size on UGzLiveFeaturesCdnFetchingComponent");

// Class G01.GzLivePatchingSubsystem
// 0x0000 (0x0030 - 0x0030)
class UGzLivePatchingSubsystem final : public UEngineSubsystem
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzLivePatchingSubsystem">();
	}
	static class UGzLivePatchingSubsystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzLivePatchingSubsystem>();
	}
};
static_assert(alignof(UGzLivePatchingSubsystem) == 0x000008, "Wrong alignment on UGzLivePatchingSubsystem");
static_assert(sizeof(UGzLivePatchingSubsystem) == 0x000030, "Wrong size on UGzLivePatchingSubsystem");

// Class G01.GzViewpointManager
// 0x0078 (0x0318 - 0x02A0)
class AGzViewpointManager final : public AActor
{
public:
	FMulticastInlineDelegateProperty_             OnHideoutViewpointTransitionDone;                  // 0x02A0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMap<class FName, class AGzViewpointClusterBase*> Clusters;                                          // 0x02B0(0x0050)(Edit, DisableEditOnTemplate, NativeAccessSpecifierPrivate)
	TArray<struct FGzViewpointTransitionParameters> Transitions;                                       // 0x0300(0x0010)(Edit, ZeroConstructor, DisableEditOnTemplate, NativeAccessSpecifierPrivate)
	uint8                                         Pad_335E[0x8];                                     // 0x0310(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	TArray<class FString> GetViewpointNames() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzViewpointManager">();
	}
	static class AGzViewpointManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<AGzViewpointManager>();
	}
};
static_assert(alignof(AGzViewpointManager) == 0x000008, "Wrong alignment on AGzViewpointManager");
static_assert(sizeof(AGzViewpointManager) == 0x000318, "Wrong size on AGzViewpointManager");
static_assert(offsetof(AGzViewpointManager, OnHideoutViewpointTransitionDone) == 0x0002A0, "Member 'AGzViewpointManager::OnHideoutViewpointTransitionDone' has a wrong offset!");
static_assert(offsetof(AGzViewpointManager, Clusters) == 0x0002B0, "Member 'AGzViewpointManager::Clusters' has a wrong offset!");
static_assert(offsetof(AGzViewpointManager, Transitions) == 0x000300, "Member 'AGzViewpointManager::Transitions' has a wrong offset!");

// Class G01.GzLoadingScreenDlssController
// 0x0000 (0x0028 - 0x0028)
class UGzLoadingScreenDlssController final : public UObject
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzLoadingScreenDlssController">();
	}
	static class UGzLoadingScreenDlssController* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzLoadingScreenDlssController>();
	}
};
static_assert(alignof(UGzLoadingScreenDlssController) == 0x000008, "Wrong alignment on UGzLoadingScreenDlssController");
static_assert(sizeof(UGzLoadingScreenDlssController) == 0x000028, "Wrong size on UGzLoadingScreenDlssController");

// Class G01.GzLoadingScreenManager
// 0x0020 (0x0048 - 0x0028)
class UGzLoadingScreenManager final : public UObject
{
public:
	class UGzLoadingScreenTickSpinner*            TickSpinner;                                       // 0x0028(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UGzLoadingScreenDlssController*         DlssController;                                    // 0x0030(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_335F[0x10];                                    // 0x0038(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzLoadingScreenManager">();
	}
	static class UGzLoadingScreenManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzLoadingScreenManager>();
	}
};
static_assert(alignof(UGzLoadingScreenManager) == 0x000008, "Wrong alignment on UGzLoadingScreenManager");
static_assert(sizeof(UGzLoadingScreenManager) == 0x000048, "Wrong size on UGzLoadingScreenManager");
static_assert(offsetof(UGzLoadingScreenManager, TickSpinner) == 0x000028, "Member 'UGzLoadingScreenManager::TickSpinner' has a wrong offset!");
static_assert(offsetof(UGzLoadingScreenManager, DlssController) == 0x000030, "Member 'UGzLoadingScreenManager::DlssController' has a wrong offset!");

// Class G01.GzLoadoutContainer
// 0x0018 (0x02B8 - 0x02A0)
class AGzLoadoutContainer final : public AActor
{
public:
	uint8                                         Pad_3360[0x8];                                     // 0x02A0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UGzInteractableComponent*               InteractableComponent;                             // 0x02A8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UGzLoadoutSelectionComponent*           LoadoutSelectionComponent;                         // 0x02B0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzLoadoutContainer">();
	}
	static class AGzLoadoutContainer* GetDefaultObj()
	{
		return GetDefaultObjImpl<AGzLoadoutContainer>();
	}
};
static_assert(alignof(AGzLoadoutContainer) == 0x000008, "Wrong alignment on AGzLoadoutContainer");
static_assert(sizeof(AGzLoadoutContainer) == 0x0002B8, "Wrong size on AGzLoadoutContainer");
static_assert(offsetof(AGzLoadoutContainer, InteractableComponent) == 0x0002A8, "Member 'AGzLoadoutContainer::InteractableComponent' has a wrong offset!");
static_assert(offsetof(AGzLoadoutContainer, LoadoutSelectionComponent) == 0x0002B0, "Member 'AGzLoadoutContainer::LoadoutSelectionComponent' has a wrong offset!");

// Class G01.GzWaitSubsystem
// 0x0020 (0x0050 - 0x0030)
class UGzWaitSubsystem final : public UBlueprintAsyncActionBase
{
public:
	FMulticastInlineDelegateProperty_             OnReady;                                           // 0x0030(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	class UObject*                                WorldContextObject;                                // 0x0040(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_3361[0x8];                                     // 0x0048(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UGzWaitSubsystem* WaitSubsystem(const class UObject* Param_WorldContextObject, const TSubclassOf<class AGzGameModeSubsystem> Param_Class);

	void OnSubsystemReady(class AGzGameModeSubsystem* Subsystem);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzWaitSubsystem">();
	}
	static class UGzWaitSubsystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzWaitSubsystem>();
	}
};
static_assert(alignof(UGzWaitSubsystem) == 0x000008, "Wrong alignment on UGzWaitSubsystem");
static_assert(sizeof(UGzWaitSubsystem) == 0x000050, "Wrong size on UGzWaitSubsystem");
static_assert(offsetof(UGzWaitSubsystem, OnReady) == 0x000030, "Member 'UGzWaitSubsystem::OnReady' has a wrong offset!");
static_assert(offsetof(UGzWaitSubsystem, WorldContextObject) == 0x000040, "Member 'UGzWaitSubsystem::WorldContextObject' has a wrong offset!");

// Class G01.GzLoadoutListMultiTab
// 0x0020 (0x0488 - 0x0468)
class UGzLoadoutListMultiTab final : public UGzLoadoutListBase
{
public:
	class UCommonTabListWidgetBase*               TabsBox;                                           // 0x0468(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<struct FGzLoadoutMultiTabData>         TabsSetUp;                                         // 0x0470(0x0010)(Edit, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	TSubclassOf<class UGzLoadoutListTab>          TabClass;                                          // 0x0480(0x0008)(Edit, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void OnTabAdded(class UGzLoadoutListTab* NewTab);
	void OnTabSelected(class FName TabId);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzLoadoutListMultiTab">();
	}
	static class UGzLoadoutListMultiTab* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzLoadoutListMultiTab>();
	}
};
static_assert(alignof(UGzLoadoutListMultiTab) == 0x000008, "Wrong alignment on UGzLoadoutListMultiTab");
static_assert(sizeof(UGzLoadoutListMultiTab) == 0x000488, "Wrong size on UGzLoadoutListMultiTab");
static_assert(offsetof(UGzLoadoutListMultiTab, TabsBox) == 0x000468, "Member 'UGzLoadoutListMultiTab::TabsBox' has a wrong offset!");
static_assert(offsetof(UGzLoadoutListMultiTab, TabsSetUp) == 0x000470, "Member 'UGzLoadoutListMultiTab::TabsSetUp' has a wrong offset!");
static_assert(offsetof(UGzLoadoutListMultiTab, TabClass) == 0x000480, "Member 'UGzLoadoutListMultiTab::TabClass' has a wrong offset!");

// Class G01.GzTrackEventHandlerComponent
// 0x0008 (0x00B0 - 0x00A8)
class UGzTrackEventHandlerComponent : public UActorComponent
{
public:
	TSubclassOf<class UGzTrackEventBase>          HandleEventClass;                                  // 0x00A8(0x0008)(Edit, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void HandleTrackEvent(class UGzTrackEventBase* Event, int32 TrackPoint);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzTrackEventHandlerComponent">();
	}
	static class UGzTrackEventHandlerComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzTrackEventHandlerComponent>();
	}
};
static_assert(alignof(UGzTrackEventHandlerComponent) == 0x000008, "Wrong alignment on UGzTrackEventHandlerComponent");
static_assert(sizeof(UGzTrackEventHandlerComponent) == 0x0000B0, "Wrong size on UGzTrackEventHandlerComponent");
static_assert(offsetof(UGzTrackEventHandlerComponent, HandleEventClass) == 0x0000A8, "Member 'UGzTrackEventHandlerComponent::HandleEventClass' has a wrong offset!");

// Class G01.GzLoadoutListTab
// 0x0020 (0x1650 - 0x1630)
class UGzLoadoutListTab final : public UGzCommonButton
{
public:
	uint8                                         Pad_3363[0x20];                                    // 0x1630(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void BP_Init(EGzLoadoutListTabOptions TabOf, const struct FGzLoadoutSelectionTabShowData& Data);
	EGzLoadoutListTabOptions GetCategory();
	bool GetIsInitialized();
	struct FGzLoadoutSelectionTabShowData GetShowData();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzLoadoutListTab">();
	}
	static class UGzLoadoutListTab* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzLoadoutListTab>();
	}
};
static_assert(alignof(UGzLoadoutListTab) == 0x000010, "Wrong alignment on UGzLoadoutListTab");
static_assert(sizeof(UGzLoadoutListTab) == 0x001650, "Wrong size on UGzLoadoutListTab");

// Class G01.GzLobbyMissionsModel
// 0x0020 (0x0090 - 0x0070)
class UGzLobbyMissionsModel final : public UGzBackendModel
{
public:
	class FString                                 ActiveJobId;                                       // 0x0070(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<struct FGzCohtmlAvailableAssignment>   CohtmlAvailableAssignments;                        // 0x0080(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzLobbyMissionsModel">();
	}
	static class UGzLobbyMissionsModel* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzLobbyMissionsModel>();
	}
};
static_assert(alignof(UGzLobbyMissionsModel) == 0x000008, "Wrong alignment on UGzLobbyMissionsModel");
static_assert(sizeof(UGzLobbyMissionsModel) == 0x000090, "Wrong size on UGzLobbyMissionsModel");
static_assert(offsetof(UGzLobbyMissionsModel, ActiveJobId) == 0x000070, "Member 'UGzLobbyMissionsModel::ActiveJobId' has a wrong offset!");
static_assert(offsetof(UGzLobbyMissionsModel, CohtmlAvailableAssignments) == 0x000080, "Member 'UGzLobbyMissionsModel::CohtmlAvailableAssignments' has a wrong offset!");

// Class G01.GzSettingEntryScalarWidget
// 0x0010 (0x0338 - 0x0328)
class UGzSettingEntryScalarWidget final : public UGzSettingEntryWidget
{
public:
	class UTextBlock*                             CurrentValueText;                                  // 0x0328(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UAnalogSlider*                          SettingSlider;                                     // 0x0330(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void HandleOnValueChanged(float NewValue);
	void OnDefaultValueChanged(double NewDefaultValue);
	void OnValueChanged(float NewValue);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzSettingEntryScalarWidget">();
	}
	static class UGzSettingEntryScalarWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzSettingEntryScalarWidget>();
	}
};
static_assert(alignof(UGzSettingEntryScalarWidget) == 0x000008, "Wrong alignment on UGzSettingEntryScalarWidget");
static_assert(sizeof(UGzSettingEntryScalarWidget) == 0x000338, "Wrong size on UGzSettingEntryScalarWidget");
static_assert(offsetof(UGzSettingEntryScalarWidget, CurrentValueText) == 0x000328, "Member 'UGzSettingEntryScalarWidget::CurrentValueText' has a wrong offset!");
static_assert(offsetof(UGzSettingEntryScalarWidget, SettingSlider) == 0x000330, "Member 'UGzSettingEntryScalarWidget::SettingSlider' has a wrong offset!");

// Class G01.GzLocalPlayer
// 0x0000 (0x02B0 - 0x02B0)
class UGzLocalPlayer final : public ULocalPlayer
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzLocalPlayer">();
	}
	static class UGzLocalPlayer* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzLocalPlayer>();
	}
};
static_assert(alignof(UGzLocalPlayer) == 0x000008, "Wrong alignment on UGzLocalPlayer");
static_assert(sizeof(UGzLocalPlayer) == 0x0002B0, "Wrong size on UGzLocalPlayer");

// Class G01.GzLoginQueueState
// 0x0000 (0x0070 - 0x0070)
class UGzLoginQueueState final : public UGzFlowStateWithActionGraph
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzLoginQueueState">();
	}
	static class UGzLoginQueueState* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzLoginQueueState>();
	}
};
static_assert(alignof(UGzLoginQueueState) == 0x000008, "Wrong alignment on UGzLoginQueueState");
static_assert(sizeof(UGzLoginQueueState) == 0x000070, "Wrong size on UGzLoginQueueState");

// Class G01.GzLootArchetypeData
// 0x0050 (0x0088 - 0x0038)
class UGzLootArchetypeData final : public UGzRollTableData
{
public:
	TMap<EGzItemRarity, class UGzLootItemVariationsTableData*> Items;                                             // 0x0038(0x0050)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)

public:
	const class UGzLootItemVariationsTableData* GetItemByRarity(EGzItemRarity Rarity) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzLootArchetypeData">();
	}
	static class UGzLootArchetypeData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzLootArchetypeData>();
	}
};
static_assert(alignof(UGzLootArchetypeData) == 0x000008, "Wrong alignment on UGzLootArchetypeData");
static_assert(sizeof(UGzLootArchetypeData) == 0x000088, "Wrong size on UGzLootArchetypeData");
static_assert(offsetof(UGzLootArchetypeData, Items) == 0x000038, "Member 'UGzLootArchetypeData::Items' has a wrong offset!");

// Class G01.GzLootModifierTableData
// 0x0010 (0x0040 - 0x0030)
class UGzLootModifierTableData final : public UPrimaryDataAsset
{
public:
	TArray<struct FGzLootModifier>                Modifiers;                                         // 0x0030(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzLootModifierTableData">();
	}
	static class UGzLootModifierTableData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzLootModifierTableData>();
	}
};
static_assert(alignof(UGzLootModifierTableData) == 0x000008, "Wrong alignment on UGzLootModifierTableData");
static_assert(sizeof(UGzLootModifierTableData) == 0x000040, "Wrong size on UGzLootModifierTableData");
static_assert(offsetof(UGzLootModifierTableData, Modifiers) == 0x000030, "Member 'UGzLootModifierTableData::Modifiers' has a wrong offset!");

// Class G01.GzSettingVCInputDevice
// 0x0020 (0x0170 - 0x0150)
class UGzSettingVCInputDevice : public UGameSettingValueDiscrete
{
public:
	TArray<struct FGzVoiceChatAudioDevice>        InputDevices;                                      // 0x0150(0x0010)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	class FText                                   NoDevicesText;                                     // 0x0160(0x0010)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzSettingVCInputDevice">();
	}
	static class UGzSettingVCInputDevice* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzSettingVCInputDevice>();
	}
};
static_assert(alignof(UGzSettingVCInputDevice) == 0x000008, "Wrong alignment on UGzSettingVCInputDevice");
static_assert(sizeof(UGzSettingVCInputDevice) == 0x000170, "Wrong size on UGzSettingVCInputDevice");
static_assert(offsetof(UGzSettingVCInputDevice, InputDevices) == 0x000150, "Member 'UGzSettingVCInputDevice::InputDevices' has a wrong offset!");
static_assert(offsetof(UGzSettingVCInputDevice, NoDevicesText) == 0x000160, "Member 'UGzSettingVCInputDevice::NoDevicesText' has a wrong offset!");

// Class G01.GzLootRarityTableData
// 0x0010 (0x0048 - 0x0038)
class UGzLootRarityTableData final : public UGzRollTableData
{
public:
	TArray<struct FGzLootRarityTableRow>          Table;                                             // 0x0038(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)

public:
	EGzItemRarity RollItemRarity(const class UGzLootModifierTableData* ModifiersTable) const;
	EGzItemRarity RollItemRarityWithModArray(const TArray<struct FGzLootModifier>& Modifiers) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzLootRarityTableData">();
	}
	static class UGzLootRarityTableData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzLootRarityTableData>();
	}
};
static_assert(alignof(UGzLootRarityTableData) == 0x000008, "Wrong alignment on UGzLootRarityTableData");
static_assert(sizeof(UGzLootRarityTableData) == 0x000048, "Wrong size on UGzLootRarityTableData");
static_assert(offsetof(UGzLootRarityTableData, Table) == 0x000038, "Member 'UGzLootRarityTableData::Table' has a wrong offset!");

// Class G01.GzLootSpawnInterface
// 0x0000 (0x0028 - 0x0028)
class IGzLootSpawnInterface final : public IInterface
{
public:
	TArray<struct FTransform> GetInitialWorldSpawnTransforms() const;
	class UGzLootSpawnerComponent* GetLootSpawnerComponent() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzLootSpawnInterface">();
	}
	static class IGzLootSpawnInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IGzLootSpawnInterface>();
	}
};
static_assert(alignof(IGzLootSpawnInterface) == 0x000008, "Wrong alignment on IGzLootSpawnInterface");
static_assert(sizeof(IGzLootSpawnInterface) == 0x000028, "Wrong size on IGzLootSpawnInterface");

// Class G01.GzLootItemVariationsTableData
// 0x0010 (0x0048 - 0x0038)
class UGzLootItemVariationsTableData final : public UGzRollTableData
{
public:
	TArray<struct FGzLootItemVariantionsTableRow> Table;                                             // 0x0038(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)

public:
	struct FGzInventoryItemContent RollItemVariation(const class UGzLootModifierTableData* ModifiersTable) const;
	struct FGzInventoryItemContent RollItemVariationWithModArray(const TArray<struct FGzLootModifier>& Modifiers) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzLootItemVariationsTableData">();
	}
	static class UGzLootItemVariationsTableData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzLootItemVariationsTableData>();
	}
};
static_assert(alignof(UGzLootItemVariationsTableData) == 0x000008, "Wrong alignment on UGzLootItemVariationsTableData");
static_assert(sizeof(UGzLootItemVariationsTableData) == 0x000048, "Wrong size on UGzLootItemVariationsTableData");
static_assert(offsetof(UGzLootItemVariationsTableData, Table) == 0x000038, "Member 'UGzLootItemVariationsTableData::Table' has a wrong offset!");

// Class G01.UGzMantleNavLink
// 0x0010 (0x0348 - 0x0338)
class AUGzMantleNavLink final : public AGzAutoNavLink
{
public:
	struct FTimerHandle                           AgentAbilityTimer;                                 // 0x0338(0x0008)(Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          MantleActivated;                                   // 0x0340(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3368[0x3];                                     // 0x0341(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MinMantleHeight;                                   // 0x0344(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	void TryRunMantleAbility();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UGzMantleNavLink">();
	}
	static class AUGzMantleNavLink* GetDefaultObj()
	{
		return GetDefaultObjImpl<AUGzMantleNavLink>();
	}
};
static_assert(alignof(AUGzMantleNavLink) == 0x000008, "Wrong alignment on AUGzMantleNavLink");
static_assert(sizeof(AUGzMantleNavLink) == 0x000348, "Wrong size on AUGzMantleNavLink");
static_assert(offsetof(AUGzMantleNavLink, AgentAbilityTimer) == 0x000338, "Member 'AUGzMantleNavLink::AgentAbilityTimer' has a wrong offset!");
static_assert(offsetof(AUGzMantleNavLink, MantleActivated) == 0x000340, "Member 'AUGzMantleNavLink::MantleActivated' has a wrong offset!");
static_assert(offsetof(AUGzMantleNavLink, MinMantleHeight) == 0x000344, "Member 'AUGzMantleNavLink::MinMantleHeight' has a wrong offset!");

// Class G01.GzScenePuppeteer
// 0x0010 (0x0038 - 0x0028)
class UGzScenePuppeteer final : public UObject
{
public:
	FMulticastInlineDelegateProperty_             OnPlayAnimationRequested;                          // 0x0028(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)

public:
	void GzOnPlayAnimationRequested__DelegateSignature(const EGzAnimationActionType AnimationAction);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzScenePuppeteer">();
	}
	static class UGzScenePuppeteer* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzScenePuppeteer>();
	}
};
static_assert(alignof(UGzScenePuppeteer) == 0x000008, "Wrong alignment on UGzScenePuppeteer");
static_assert(sizeof(UGzScenePuppeteer) == 0x000038, "Wrong size on UGzScenePuppeteer");
static_assert(offsetof(UGzScenePuppeteer, OnPlayAnimationRequested) == 0x000028, "Member 'UGzScenePuppeteer::OnPlayAnimationRequested' has a wrong offset!");

// Class G01.GzManualTrackTransport
// 0x0000 (0x0380 - 0x0380)
class AGzManualTrackTransport final : public AGzTrackTransport
{
public:
	void ForceSetPosition(double Distance);
	void MoveToDistance(double Distance);
	void MoveToEnd();
	void MulticastForceSetPosition(double Distance);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzManualTrackTransport">();
	}
	static class AGzManualTrackTransport* GetDefaultObj()
	{
		return GetDefaultObjImpl<AGzManualTrackTransport>();
	}
};
static_assert(alignof(AGzManualTrackTransport) == 0x000008, "Wrong alignment on AGzManualTrackTransport");
static_assert(sizeof(AGzManualTrackTransport) == 0x000380, "Wrong size on AGzManualTrackTransport");

// Class G01.GzMapBRZoneBordersExtension
// 0x0078 (0x00B0 - 0x0038)
class UGzMapBRZoneBordersExtension : public UGzMapWidgetExtension
{
public:
	TSoftClassPtr<class UClass>                   SplineMapWidgetClass;                              // 0x0038(0x0028)(Edit, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TMap<class AGzBattleRoyaleZone*, class UGzSplineMapWidget*> BordersToDraw;                                     // 0x0060(0x0050)(ExportObject, Transient, ContainsInstancedReference, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzMapBRZoneBordersExtension">();
	}
	static class UGzMapBRZoneBordersExtension* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzMapBRZoneBordersExtension>();
	}
};
static_assert(alignof(UGzMapBRZoneBordersExtension) == 0x000008, "Wrong alignment on UGzMapBRZoneBordersExtension");
static_assert(sizeof(UGzMapBRZoneBordersExtension) == 0x0000B0, "Wrong size on UGzMapBRZoneBordersExtension");
static_assert(offsetof(UGzMapBRZoneBordersExtension, SplineMapWidgetClass) == 0x000038, "Member 'UGzMapBRZoneBordersExtension::SplineMapWidgetClass' has a wrong offset!");
static_assert(offsetof(UGzMapBRZoneBordersExtension, BordersToDraw) == 0x000060, "Member 'UGzMapBRZoneBordersExtension::BordersToDraw' has a wrong offset!");

// Class G01.GzMapData
// 0x0080 (0x00B0 - 0x0030)
class UGzMapData final : public UDataAsset
{
public:
	TSoftObjectPtr<class UTexture>                MapTexture;                                        // 0x0030(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTexture2D*                             MapTextureVirtual;                                 // 0x0058(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UTexture2D>              ZonesTexture;                                      // 0x0060(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              Offset;                                            // 0x0088(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MapWidth;                                          // 0x0098(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Rotation;                                          // 0x009C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              CaptureSize;                                       // 0x00A0(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzMapData">();
	}
	static class UGzMapData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzMapData>();
	}
};
static_assert(alignof(UGzMapData) == 0x000008, "Wrong alignment on UGzMapData");
static_assert(sizeof(UGzMapData) == 0x0000B0, "Wrong size on UGzMapData");
static_assert(offsetof(UGzMapData, MapTexture) == 0x000030, "Member 'UGzMapData::MapTexture' has a wrong offset!");
static_assert(offsetof(UGzMapData, MapTextureVirtual) == 0x000058, "Member 'UGzMapData::MapTextureVirtual' has a wrong offset!");
static_assert(offsetof(UGzMapData, ZonesTexture) == 0x000060, "Member 'UGzMapData::ZonesTexture' has a wrong offset!");
static_assert(offsetof(UGzMapData, Offset) == 0x000088, "Member 'UGzMapData::Offset' has a wrong offset!");
static_assert(offsetof(UGzMapData, MapWidth) == 0x000098, "Member 'UGzMapData::MapWidth' has a wrong offset!");
static_assert(offsetof(UGzMapData, Rotation) == 0x00009C, "Member 'UGzMapData::Rotation' has a wrong offset!");
static_assert(offsetof(UGzMapData, CaptureSize) == 0x0000A0, "Member 'UGzMapData::CaptureSize' has a wrong offset!");

// Class G01.GzScoreboard
// 0x00D8 (0x0508 - 0x0430)
class UGzScoreboard : public UCommonActivatableWidget
{
public:
	TSubclassOf<class UGzScoreboardEntry>         EntryClass;                                        // 0x0430(0x0008)(Edit, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class FName>                           StatsNames;                                        // 0x0438(0x0010)(Edit, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	TMap<class FName, bool>                       SortingConditions;                                 // 0x0448(0x0050)(Edit, Protected, NativeAccessSpecifierProtected)
	struct FMargin                                EntryPadding;                                      // 0x0498(0x0010)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	class UCommonHierarchicalScrollBox*           StatList;                                          // 0x04A8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UGzScoreboardHeader*                    ScoreboardHeader;                                  // 0x04B0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TMap<int32, class UGzScoreboardEntry*>        ActiveEntries;                                     // 0x04B8(0x0050)(ExportObject, Transient, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)

public:
	void OnStatChanged(int32 PlayerId, const struct FGzGameStat& Stat);
	void RefreshStats(bool bClear);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzScoreboard">();
	}
	static class UGzScoreboard* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzScoreboard>();
	}
};
static_assert(alignof(UGzScoreboard) == 0x000008, "Wrong alignment on UGzScoreboard");
static_assert(sizeof(UGzScoreboard) == 0x000508, "Wrong size on UGzScoreboard");
static_assert(offsetof(UGzScoreboard, EntryClass) == 0x000430, "Member 'UGzScoreboard::EntryClass' has a wrong offset!");
static_assert(offsetof(UGzScoreboard, StatsNames) == 0x000438, "Member 'UGzScoreboard::StatsNames' has a wrong offset!");
static_assert(offsetof(UGzScoreboard, SortingConditions) == 0x000448, "Member 'UGzScoreboard::SortingConditions' has a wrong offset!");
static_assert(offsetof(UGzScoreboard, EntryPadding) == 0x000498, "Member 'UGzScoreboard::EntryPadding' has a wrong offset!");
static_assert(offsetof(UGzScoreboard, StatList) == 0x0004A8, "Member 'UGzScoreboard::StatList' has a wrong offset!");
static_assert(offsetof(UGzScoreboard, ScoreboardHeader) == 0x0004B0, "Member 'UGzScoreboard::ScoreboardHeader' has a wrong offset!");
static_assert(offsetof(UGzScoreboard, ActiveEntries) == 0x0004B8, "Member 'UGzScoreboard::ActiveEntries' has a wrong offset!");

// Class G01.GzMapDecoration
// 0x0010 (0x02F0 - 0x02E0)
class UGzMapDecoration : public UUserWidget
{
public:
	class UGzMapWidget*                           ParentMap;                                         // 0x02E0(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MinZoom;                                           // 0x02E8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MaxZoom;                                           // 0x02EC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void SetMaxZoom(float InMaxZoom);
	void SetMinZoom(float InMinZoom);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzMapDecoration">();
	}
	static class UGzMapDecoration* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzMapDecoration>();
	}
};
static_assert(alignof(UGzMapDecoration) == 0x000008, "Wrong alignment on UGzMapDecoration");
static_assert(sizeof(UGzMapDecoration) == 0x0002F0, "Wrong size on UGzMapDecoration");
static_assert(offsetof(UGzMapDecoration, ParentMap) == 0x0002E0, "Member 'UGzMapDecoration::ParentMap' has a wrong offset!");
static_assert(offsetof(UGzMapDecoration, MinZoom) == 0x0002E8, "Member 'UGzMapDecoration::MinZoom' has a wrong offset!");
static_assert(offsetof(UGzMapDecoration, MaxZoom) == 0x0002EC, "Member 'UGzMapDecoration::MaxZoom' has a wrong offset!");

// Class G01.GzMapRegionNamesExtension
// 0x0060 (0x0098 - 0x0038)
class UGzMapRegionNamesExtension : public UGzMapWidgetExtension
{
public:
	TMap<class FName, TSubclassOf<class UGzMapTextDecoration>> LayerTextWidgetClasses;                            // 0x0038(0x0050)(Edit, Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	TArray<class UGzMapTextDecoration*>           RegionTexts;                                       // 0x0088(0x0010)(ExportObject, ZeroConstructor, Transient, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzMapRegionNamesExtension">();
	}
	static class UGzMapRegionNamesExtension* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzMapRegionNamesExtension>();
	}
};
static_assert(alignof(UGzMapRegionNamesExtension) == 0x000008, "Wrong alignment on UGzMapRegionNamesExtension");
static_assert(sizeof(UGzMapRegionNamesExtension) == 0x000098, "Wrong size on UGzMapRegionNamesExtension");
static_assert(offsetof(UGzMapRegionNamesExtension, LayerTextWidgetClasses) == 0x000038, "Member 'UGzMapRegionNamesExtension::LayerTextWidgetClasses' has a wrong offset!");
static_assert(offsetof(UGzMapRegionNamesExtension, RegionTexts) == 0x000088, "Member 'UGzMapRegionNamesExtension::RegionTexts' has a wrong offset!");

// Class G01.GzSearchZoneSettings
// 0x0010 (0x0048 - 0x0038)
class UGzSearchZoneSettings final : public UDeveloperSettings
{
public:
	TArray<TSoftClassPtr<class UClass>>           AvailableZonesClasses;                             // 0x0038(0x0010)(Edit, ZeroConstructor, Config, UObjectWrapper, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzSearchZoneSettings">();
	}
	static class UGzSearchZoneSettings* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzSearchZoneSettings>();
	}
};
static_assert(alignof(UGzSearchZoneSettings) == 0x000008, "Wrong alignment on UGzSearchZoneSettings");
static_assert(sizeof(UGzSearchZoneSettings) == 0x000048, "Wrong size on UGzSearchZoneSettings");
static_assert(offsetof(UGzSearchZoneSettings, AvailableZonesClasses) == 0x000038, "Member 'UGzSearchZoneSettings::AvailableZonesClasses' has a wrong offset!");

// Class G01.GzMapTextDecoration
// 0x0018 (0x0308 - 0x02F0)
class UGzMapTextDecoration : public UGzMapDecoration
{
public:
	struct FVector2D                              WorldLocation;                                     // 0x02F0(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bHideIfNotInPlayableArea;                          // 0x0300(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_336A[0x7];                                     // 0x0301(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnTextSet(const class FText& InText);
	void UpdateVisibilityInPlayableArea();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzMapTextDecoration">();
	}
	static class UGzMapTextDecoration* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzMapTextDecoration>();
	}
};
static_assert(alignof(UGzMapTextDecoration) == 0x000008, "Wrong alignment on UGzMapTextDecoration");
static_assert(sizeof(UGzMapTextDecoration) == 0x000308, "Wrong size on UGzMapTextDecoration");
static_assert(offsetof(UGzMapTextDecoration, WorldLocation) == 0x0002F0, "Member 'UGzMapTextDecoration::WorldLocation' has a wrong offset!");
static_assert(offsetof(UGzMapTextDecoration, bHideIfNotInPlayableArea) == 0x000300, "Member 'UGzMapTextDecoration::bHideIfNotInPlayableArea' has a wrong offset!");

// Class G01.GzMapWidget
// 0x02A0 (0x0580 - 0x02E0)
class UGzMapWidget : public UUserWidget
{
public:
	FMulticastInlineDelegateProperty_             OnMapReady;                                        // 0x02E0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnInputAnalogueValueChanged;                       // 0x02F0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnMapMouseLeave;                                   // 0x0300(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnMapMouseWheel;                                   // 0x0310(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnMapKeyDown;                                      // 0x0320(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnMapZoomChanged;                                  // 0x0330(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_336B[0x40];                                    // 0x0340(0x0040)(Fixing Size After Last Property [ Dumper-7 ])
	class UMaterialInterface*                     MapMaterial;                                       // 0x0380(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UMaterialInterface*                     MapUIMaterial;                                     // 0x0388(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FGzMapMaterialNameParams               MaterialNameParams;                                // 0x0390(0x0050)(Edit, DisableEditOnInstance, NoDestructor, Protected, NativeAccessSpecifierProtected)
	TSubclassOf<class UGzMapZoneWidget>           ZoneWidgetType;                                    // 0x03E0(0x0008)(Edit, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector2D                              MapSize;                                           // 0x03E8(0x0010)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MapMovementTolerance;                              // 0x03F8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MaxZoom;                                           // 0x03FC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MinZoom;                                           // 0x0400(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bMinimap;                                          // 0x0404(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EGzMapZonesUpdateMode                         ZonesUpdateMode;                                   // 0x0405(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_336C[0x2];                                     // 0x0406(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<TSubclassOf<class UGzMapWidgetExtension>> MapExtensions;                                     // 0x0408(0x0010)(Edit, ZeroConstructor, Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	class UGzMapData*                             MapData;                                           // 0x0418(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UMaterialInstanceDynamic*               MapMaterialInstance;                               // 0x0420(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UMaterialInstanceDynamic*               MapUIMaterialInstance;                             // 0x0428(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class AMapPlaneActor>             MapPlaneClass;                                     // 0x0430(0x0008)(Edit, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class ASceneCapture2D>            MapCameraClass;                                    // 0x0438(0x0008)(Edit, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextureRenderTarget2D*                 MapRenderTarget;                                   // 0x0440(0x0008)(Edit, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint32                                        MapRenderTargetSize;                               // 0x0448(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_336D[0x4];                                     // 0x044C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class ASceneCapture2D*                        MapCamera;                                         // 0x0450(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class AMapPlaneActor*                         MapPlane;                                          // 0x0458(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UMaterialInterface*                     ZoneFillMaterial;                                  // 0x0460(0x0008)(Edit, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class UGzMapZoneWidget*>               ZoneWidgets;                                       // 0x0468(0x0010)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	class UGzMapMarkerContainer*                  MarkerContainer;                                   // 0x0478(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector2D                              MapCenter;                                         // 0x0480(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector2D                              NormalizedOffset;                                  // 0x0490(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UGzZoneFillLayerWidget>     ZoneFillLayerClass;                                // 0x04A0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCanvasPanel*                           ZonesFillLayersContainer;                          // 0x04A8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_336E[0x8];                                     // 0x04B0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector2D                              InitialZoomOffset;                                 // 0x04B8(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FVector2D                              ZoomOffset;                                        // 0x04C8(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class USizeBox*                               RootPanel;                                         // 0x04D8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UBorder*                                InteractionPanel;                                  // 0x04E0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UImage*                                 MapImage;                                          // 0x04E8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UOverlay*                               ZoneContainer;                                     // 0x04F0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UCanvasPanel*                           DecorationsContainer;                              // 0x04F8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UCanvasPanel*                           DecorationsContainerOverlay;                       // 0x0500(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_336F[0x78];                                    // 0x0508(0x0078)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AddDecoration(class UUserWidget* InWidget, const struct FVector2D& WorldPosition, int32 ZOrder, bool bOverlay);
	class UCanvasPanelSlot* AddDecorationToScreen(class UUserWidget* InWidget, bool bOverlay);
	void AddSplineDecoration(class UGzSplineMapWidget* InWidget, bool bOverlay);
	class UGzZoneFillLayerWidget* AddZoneFillLayer(class UMaterialInterface* InMaterial, int32 ZOrder);
	void RemoveDecoration(class UUserWidget* InWidget);
	void RemoveZoneFillLayer(class UGzZoneFillLayerWidget* LayerWidget);
	void SetBoundingGeometryOverride(const struct FGeometry& InGeometry);
	void SetCaptureEveryFrame(bool bCaptureEveryFram);
	void SetMapZoom(float Zoom);
	void ZoomToExtent(const struct FBox2D& Box, float ZoomMultiplier);
	void ZoomToFit(const TArray<struct FVector2D>& InWorldPoints, float ZoomMultiplier);

	struct FGeometry GetBoundingGeometry() const;
	float GetMapRotationAngle() const;
	const struct FVector2D GetMapSize() const;
	float GetMapZoom() const;
	class UGzMapMarkerContainer* GetMarkerContainer() const;
	float GetMaxZoom() const;
	float GetMinZoom() const;
	bool IsMinimap() const;
	bool IsReady() const;
	struct FVector2D TransformScreenToWorldSpace(const struct FVector2D& Pos) const;
	float TransformWorldToScreenRotation(float ActorRotation) const;
	struct FVector2D TransformWorldToScreenSpace(const struct FVector2D& Pos) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzMapWidget">();
	}
	static class UGzMapWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzMapWidget>();
	}
};
static_assert(alignof(UGzMapWidget) == 0x000008, "Wrong alignment on UGzMapWidget");
static_assert(sizeof(UGzMapWidget) == 0x000580, "Wrong size on UGzMapWidget");
static_assert(offsetof(UGzMapWidget, OnMapReady) == 0x0002E0, "Member 'UGzMapWidget::OnMapReady' has a wrong offset!");
static_assert(offsetof(UGzMapWidget, OnInputAnalogueValueChanged) == 0x0002F0, "Member 'UGzMapWidget::OnInputAnalogueValueChanged' has a wrong offset!");
static_assert(offsetof(UGzMapWidget, OnMapMouseLeave) == 0x000300, "Member 'UGzMapWidget::OnMapMouseLeave' has a wrong offset!");
static_assert(offsetof(UGzMapWidget, OnMapMouseWheel) == 0x000310, "Member 'UGzMapWidget::OnMapMouseWheel' has a wrong offset!");
static_assert(offsetof(UGzMapWidget, OnMapKeyDown) == 0x000320, "Member 'UGzMapWidget::OnMapKeyDown' has a wrong offset!");
static_assert(offsetof(UGzMapWidget, OnMapZoomChanged) == 0x000330, "Member 'UGzMapWidget::OnMapZoomChanged' has a wrong offset!");
static_assert(offsetof(UGzMapWidget, MapMaterial) == 0x000380, "Member 'UGzMapWidget::MapMaterial' has a wrong offset!");
static_assert(offsetof(UGzMapWidget, MapUIMaterial) == 0x000388, "Member 'UGzMapWidget::MapUIMaterial' has a wrong offset!");
static_assert(offsetof(UGzMapWidget, MaterialNameParams) == 0x000390, "Member 'UGzMapWidget::MaterialNameParams' has a wrong offset!");
static_assert(offsetof(UGzMapWidget, ZoneWidgetType) == 0x0003E0, "Member 'UGzMapWidget::ZoneWidgetType' has a wrong offset!");
static_assert(offsetof(UGzMapWidget, MapSize) == 0x0003E8, "Member 'UGzMapWidget::MapSize' has a wrong offset!");
static_assert(offsetof(UGzMapWidget, MapMovementTolerance) == 0x0003F8, "Member 'UGzMapWidget::MapMovementTolerance' has a wrong offset!");
static_assert(offsetof(UGzMapWidget, MaxZoom) == 0x0003FC, "Member 'UGzMapWidget::MaxZoom' has a wrong offset!");
static_assert(offsetof(UGzMapWidget, MinZoom) == 0x000400, "Member 'UGzMapWidget::MinZoom' has a wrong offset!");
static_assert(offsetof(UGzMapWidget, bMinimap) == 0x000404, "Member 'UGzMapWidget::bMinimap' has a wrong offset!");
static_assert(offsetof(UGzMapWidget, ZonesUpdateMode) == 0x000405, "Member 'UGzMapWidget::ZonesUpdateMode' has a wrong offset!");
static_assert(offsetof(UGzMapWidget, MapExtensions) == 0x000408, "Member 'UGzMapWidget::MapExtensions' has a wrong offset!");
static_assert(offsetof(UGzMapWidget, MapData) == 0x000418, "Member 'UGzMapWidget::MapData' has a wrong offset!");
static_assert(offsetof(UGzMapWidget, MapMaterialInstance) == 0x000420, "Member 'UGzMapWidget::MapMaterialInstance' has a wrong offset!");
static_assert(offsetof(UGzMapWidget, MapUIMaterialInstance) == 0x000428, "Member 'UGzMapWidget::MapUIMaterialInstance' has a wrong offset!");
static_assert(offsetof(UGzMapWidget, MapPlaneClass) == 0x000430, "Member 'UGzMapWidget::MapPlaneClass' has a wrong offset!");
static_assert(offsetof(UGzMapWidget, MapCameraClass) == 0x000438, "Member 'UGzMapWidget::MapCameraClass' has a wrong offset!");
static_assert(offsetof(UGzMapWidget, MapRenderTarget) == 0x000440, "Member 'UGzMapWidget::MapRenderTarget' has a wrong offset!");
static_assert(offsetof(UGzMapWidget, MapRenderTargetSize) == 0x000448, "Member 'UGzMapWidget::MapRenderTargetSize' has a wrong offset!");
static_assert(offsetof(UGzMapWidget, MapCamera) == 0x000450, "Member 'UGzMapWidget::MapCamera' has a wrong offset!");
static_assert(offsetof(UGzMapWidget, MapPlane) == 0x000458, "Member 'UGzMapWidget::MapPlane' has a wrong offset!");
static_assert(offsetof(UGzMapWidget, ZoneFillMaterial) == 0x000460, "Member 'UGzMapWidget::ZoneFillMaterial' has a wrong offset!");
static_assert(offsetof(UGzMapWidget, ZoneWidgets) == 0x000468, "Member 'UGzMapWidget::ZoneWidgets' has a wrong offset!");
static_assert(offsetof(UGzMapWidget, MarkerContainer) == 0x000478, "Member 'UGzMapWidget::MarkerContainer' has a wrong offset!");
static_assert(offsetof(UGzMapWidget, MapCenter) == 0x000480, "Member 'UGzMapWidget::MapCenter' has a wrong offset!");
static_assert(offsetof(UGzMapWidget, NormalizedOffset) == 0x000490, "Member 'UGzMapWidget::NormalizedOffset' has a wrong offset!");
static_assert(offsetof(UGzMapWidget, ZoneFillLayerClass) == 0x0004A0, "Member 'UGzMapWidget::ZoneFillLayerClass' has a wrong offset!");
static_assert(offsetof(UGzMapWidget, ZonesFillLayersContainer) == 0x0004A8, "Member 'UGzMapWidget::ZonesFillLayersContainer' has a wrong offset!");
static_assert(offsetof(UGzMapWidget, InitialZoomOffset) == 0x0004B8, "Member 'UGzMapWidget::InitialZoomOffset' has a wrong offset!");
static_assert(offsetof(UGzMapWidget, ZoomOffset) == 0x0004C8, "Member 'UGzMapWidget::ZoomOffset' has a wrong offset!");
static_assert(offsetof(UGzMapWidget, RootPanel) == 0x0004D8, "Member 'UGzMapWidget::RootPanel' has a wrong offset!");
static_assert(offsetof(UGzMapWidget, InteractionPanel) == 0x0004E0, "Member 'UGzMapWidget::InteractionPanel' has a wrong offset!");
static_assert(offsetof(UGzMapWidget, MapImage) == 0x0004E8, "Member 'UGzMapWidget::MapImage' has a wrong offset!");
static_assert(offsetof(UGzMapWidget, ZoneContainer) == 0x0004F0, "Member 'UGzMapWidget::ZoneContainer' has a wrong offset!");
static_assert(offsetof(UGzMapWidget, DecorationsContainer) == 0x0004F8, "Member 'UGzMapWidget::DecorationsContainer' has a wrong offset!");
static_assert(offsetof(UGzMapWidget, DecorationsContainerOverlay) == 0x000500, "Member 'UGzMapWidget::DecorationsContainerOverlay' has a wrong offset!");

// Class G01.GzMapZoneWidget
// 0x0048 (0x0328 - 0x02E0)
class UGzMapZoneWidget : public UUserWidget
{
public:
	class UMaterialInterface*                     ZoneMaterial;                                      // 0x02E0(0x0008)(Edit, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bDrawBorders;                                      // 0x02E8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3376[0x3];                                     // 0x02E9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FLinearColor                           BorderColor;                                       // 0x02EC(0x0010)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         BorderThickness;                                   // 0x02FC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class AGzBattleRoyaleZone*                    Zone;                                              // 0x0300(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UMaterialInstanceDynamic*               ZoneMaterialInstance;                              // 0x0308(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 ZoneImage;                                         // 0x0310(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UGzMapWidget*                           Parent;                                            // 0x0318(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_3377[0x8];                                     // 0x0320(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnBecomeLastZone();
	void OnInit();
	void OnRadiusChange(float NewRadius);

	TArray<struct FGzLandingZoneUIData> GetLandingZonesPositions() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzMapZoneWidget">();
	}
	static class UGzMapZoneWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzMapZoneWidget>();
	}
};
static_assert(alignof(UGzMapZoneWidget) == 0x000008, "Wrong alignment on UGzMapZoneWidget");
static_assert(sizeof(UGzMapZoneWidget) == 0x000328, "Wrong size on UGzMapZoneWidget");
static_assert(offsetof(UGzMapZoneWidget, ZoneMaterial) == 0x0002E0, "Member 'UGzMapZoneWidget::ZoneMaterial' has a wrong offset!");
static_assert(offsetof(UGzMapZoneWidget, bDrawBorders) == 0x0002E8, "Member 'UGzMapZoneWidget::bDrawBorders' has a wrong offset!");
static_assert(offsetof(UGzMapZoneWidget, BorderColor) == 0x0002EC, "Member 'UGzMapZoneWidget::BorderColor' has a wrong offset!");
static_assert(offsetof(UGzMapZoneWidget, BorderThickness) == 0x0002FC, "Member 'UGzMapZoneWidget::BorderThickness' has a wrong offset!");
static_assert(offsetof(UGzMapZoneWidget, Zone) == 0x000300, "Member 'UGzMapZoneWidget::Zone' has a wrong offset!");
static_assert(offsetof(UGzMapZoneWidget, ZoneMaterialInstance) == 0x000308, "Member 'UGzMapZoneWidget::ZoneMaterialInstance' has a wrong offset!");
static_assert(offsetof(UGzMapZoneWidget, ZoneImage) == 0x000310, "Member 'UGzMapZoneWidget::ZoneImage' has a wrong offset!");
static_assert(offsetof(UGzMapZoneWidget, Parent) == 0x000318, "Member 'UGzMapZoneWidget::Parent' has a wrong offset!");

// Class G01.GzSeethroughScope
// 0x0000 (0x02A0 - 0x02A0)
class AGzSeethroughScope : public AActor
{
public:
	class UMeshComponent* GetScopeMesh();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzSeethroughScope">();
	}
	static class AGzSeethroughScope* GetDefaultObj()
	{
		return GetDefaultObjImpl<AGzSeethroughScope>();
	}
};
static_assert(alignof(AGzSeethroughScope) == 0x000008, "Wrong alignment on AGzSeethroughScope");
static_assert(sizeof(AGzSeethroughScope) == 0x0002A0, "Wrong size on AGzSeethroughScope");

// Class G01.GzMarkerRadiusFilter
// 0x0000 (0x0038 - 0x0038)
class UGzMarkerRadiusFilter final : public UGzMarkerActiveStateFilter
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzMarkerRadiusFilter">();
	}
	static class UGzMarkerRadiusFilter* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzMarkerRadiusFilter>();
	}
};
static_assert(alignof(UGzMarkerRadiusFilter) == 0x000008, "Wrong alignment on UGzMarkerRadiusFilter");
static_assert(sizeof(UGzMarkerRadiusFilter) == 0x000038, "Wrong size on UGzMarkerRadiusFilter");

// Class G01.GzMarkerRadiusSettingAsset
// 0x0050 (0x0080 - 0x0030)
class UGzMarkerRadiusSettingAsset final : public UDataAsset
{
public:
	TMap<EGzMarkerContainerType, struct FGzMarkerRadiusSetting> Settings;                                          // 0x0030(0x0050)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzMarkerRadiusSettingAsset">();
	}
	static class UGzMarkerRadiusSettingAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzMarkerRadiusSettingAsset>();
	}
};
static_assert(alignof(UGzMarkerRadiusSettingAsset) == 0x000008, "Wrong alignment on UGzMarkerRadiusSettingAsset");
static_assert(sizeof(UGzMarkerRadiusSettingAsset) == 0x000080, "Wrong size on UGzMarkerRadiusSettingAsset");
static_assert(offsetof(UGzMarkerRadiusSettingAsset, Settings) == 0x000030, "Member 'UGzMarkerRadiusSettingAsset::Settings' has a wrong offset!");

// Class G01.GzMarketingModel
// 0x0000 (0x0070 - 0x0070)
class UGzMarketingModel final : public UGzBackendModel
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzMarketingModel">();
	}
	static class UGzMarketingModel* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzMarketingModel>();
	}
};
static_assert(alignof(UGzMarketingModel) == 0x000008, "Wrong alignment on UGzMarketingModel");
static_assert(sizeof(UGzMarketingModel) == 0x000070, "Wrong size on UGzMarketingModel");

// Class G01.GzMarketplaceModel
// 0x0048 (0x00B8 - 0x0070)
class UGzMarketplaceModel final : public UGzBackendModel
{
public:
	bool                                          bSellingAllowed;                                   // 0x0070(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_3378[0x17];                                    // 0x0071(0x0017)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGzCohtmlTradeRateValidation           TradeRateBuyValidation;                            // 0x0088(0x0018)(NativeAccessSpecifierPrivate)
	struct FGzCohtmlTradeRateValidation           TradeRateSellValidation;                           // 0x00A0(0x0018)(NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzMarketplaceModel">();
	}
	static class UGzMarketplaceModel* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzMarketplaceModel>();
	}
};
static_assert(alignof(UGzMarketplaceModel) == 0x000008, "Wrong alignment on UGzMarketplaceModel");
static_assert(sizeof(UGzMarketplaceModel) == 0x0000B8, "Wrong size on UGzMarketplaceModel");
static_assert(offsetof(UGzMarketplaceModel, bSellingAllowed) == 0x000070, "Member 'UGzMarketplaceModel::bSellingAllowed' has a wrong offset!");
static_assert(offsetof(UGzMarketplaceModel, TradeRateBuyValidation) == 0x000088, "Member 'UGzMarketplaceModel::TradeRateBuyValidation' has a wrong offset!");
static_assert(offsetof(UGzMarketplaceModel, TradeRateSellValidation) == 0x0000A0, "Member 'UGzMarketplaceModel::TradeRateSellValidation' has a wrong offset!");

// Class G01.GzMarketplaceService
// 0x0000 (0x00A0 - 0x00A0)
class UGzMarketplaceService final : public UGzClientPFObject
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzMarketplaceService">();
	}
	static class UGzMarketplaceService* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzMarketplaceService>();
	}
};
static_assert(alignof(UGzMarketplaceService) == 0x000008, "Wrong alignment on UGzMarketplaceService");
static_assert(sizeof(UGzMarketplaceService) == 0x0000A0, "Wrong size on UGzMarketplaceService");

// Class G01.GzRectangleAreaMarkerWidget
// 0x0030 (0x03D8 - 0x03A8)
class UGzRectangleAreaMarkerWidget final : public UGzShapeMapMarkerWidget
{
public:
	TSoftObjectPtr<class UMaterialInterface>      RectFillMaterial;                                  // 0x03A8(0x0028)(Edit, DisableEditOnInstance, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UMaterialInstanceDynamic*               RectFillMaterialInstance;                          // 0x03D0(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzRectangleAreaMarkerWidget">();
	}
	static class UGzRectangleAreaMarkerWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzRectangleAreaMarkerWidget>();
	}
};
static_assert(alignof(UGzRectangleAreaMarkerWidget) == 0x000008, "Wrong alignment on UGzRectangleAreaMarkerWidget");
static_assert(sizeof(UGzRectangleAreaMarkerWidget) == 0x0003D8, "Wrong size on UGzRectangleAreaMarkerWidget");
static_assert(offsetof(UGzRectangleAreaMarkerWidget, RectFillMaterial) == 0x0003A8, "Member 'UGzRectangleAreaMarkerWidget::RectFillMaterial' has a wrong offset!");
static_assert(offsetof(UGzRectangleAreaMarkerWidget, RectFillMaterialInstance) == 0x0003D0, "Member 'UGzRectangleAreaMarkerWidget::RectFillMaterialInstance' has a wrong offset!");

// Class G01.GzMatchesPlayedEndCollector
// 0x0000 (0x0040 - 0x0040)
class UGzMatchesPlayedEndCollector final : public UGzMatchesPlayedStatCollector
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzMatchesPlayedEndCollector">();
	}
	static class UGzMatchesPlayedEndCollector* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzMatchesPlayedEndCollector>();
	}
};
static_assert(alignof(UGzMatchesPlayedEndCollector) == 0x000008, "Wrong alignment on UGzMatchesPlayedEndCollector");
static_assert(sizeof(UGzMatchesPlayedEndCollector) == 0x000040, "Wrong size on UGzMatchesPlayedEndCollector");

// Class G01.GzMatchInitStage
// 0x0010 (0x0120 - 0x0110)
class UGzMatchInitStage final : public UGzGameStageBase
{
public:
	float                                         MaxIdleTime;                                       // 0x0110(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_3379[0xC];                                     // 0x0114(0x000C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzMatchInitStage">();
	}
	static class UGzMatchInitStage* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzMatchInitStage>();
	}
};
static_assert(alignof(UGzMatchInitStage) == 0x000008, "Wrong alignment on UGzMatchInitStage");
static_assert(sizeof(UGzMatchInitStage) == 0x000120, "Wrong size on UGzMatchInitStage");
static_assert(offsetof(UGzMatchInitStage, MaxIdleTime) == 0x000110, "Member 'UGzMatchInitStage::MaxIdleTime' has a wrong offset!");

// Class G01.GzMatchmakingSettings
// 0x0120 (0x0158 - 0x0038)
class UGzMatchmakingSettings final : public UDeveloperSettings
{
public:
	int32                                         IPRequestTimeoutSeconds;                           // 0x0038(0x0004)(Edit, ZeroConstructor, Config, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_337A[0x4];                                     // 0x003C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftObjectPtr<class UTexture2D>              QueueDefaultImage;                                 // 0x0040(0x0028)(Edit, Config, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMap<class FString, struct FGzGameModeData>   KnownQueues;                                       // 0x0068(0x0050)(Edit, Config, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TMap<class FString, struct FGzMatchmakingQueueGroupData> KnownQueueGroups;                                  // 0x00B8(0x0050)(Edit, Config, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TMap<class FString, struct FGzMatchmakingRegionData> KnownRegions;                                      // 0x0108(0x0050)(Edit, Config, DisableEditOnInstance, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzMatchmakingSettings">();
	}
	static class UGzMatchmakingSettings* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzMatchmakingSettings>();
	}
};
static_assert(alignof(UGzMatchmakingSettings) == 0x000008, "Wrong alignment on UGzMatchmakingSettings");
static_assert(sizeof(UGzMatchmakingSettings) == 0x000158, "Wrong size on UGzMatchmakingSettings");
static_assert(offsetof(UGzMatchmakingSettings, IPRequestTimeoutSeconds) == 0x000038, "Member 'UGzMatchmakingSettings::IPRequestTimeoutSeconds' has a wrong offset!");
static_assert(offsetof(UGzMatchmakingSettings, QueueDefaultImage) == 0x000040, "Member 'UGzMatchmakingSettings::QueueDefaultImage' has a wrong offset!");
static_assert(offsetof(UGzMatchmakingSettings, KnownQueues) == 0x000068, "Member 'UGzMatchmakingSettings::KnownQueues' has a wrong offset!");
static_assert(offsetof(UGzMatchmakingSettings, KnownQueueGroups) == 0x0000B8, "Member 'UGzMatchmakingSettings::KnownQueueGroups' has a wrong offset!");
static_assert(offsetof(UGzMatchmakingSettings, KnownRegions) == 0x000108, "Member 'UGzMatchmakingSettings::KnownRegions' has a wrong offset!");

// Class G01.GzMatchmakingModel
// 0x0050 (0x00C0 - 0x0070)
class UGzMatchmakingModel final : public UGzBackendModel
{
public:
	uint8                                         Pad_337B[0x50];                                    // 0x0070(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzMatchmakingModel">();
	}
	static class UGzMatchmakingModel* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzMatchmakingModel>();
	}
};
static_assert(alignof(UGzMatchmakingModel) == 0x000008, "Wrong alignment on UGzMatchmakingModel");
static_assert(sizeof(UGzMatchmakingModel) == 0x0000C0, "Wrong size on UGzMatchmakingModel");

// Class G01.GzMatchStateAnnouncer
// 0x0050 (0x0440 - 0x03F0)
class AGzMatchStateAnnouncer : public AGzAudioAnnouncer
{
public:
	TMap<struct FGameplayTag, struct FGzStageAudioAnnouncementSettings> StageAnnouncements;                                // 0x03F0(0x0050)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzMatchStateAnnouncer">();
	}
	static class AGzMatchStateAnnouncer* GetDefaultObj()
	{
		return GetDefaultObjImpl<AGzMatchStateAnnouncer>();
	}
};
static_assert(alignof(AGzMatchStateAnnouncer) == 0x000008, "Wrong alignment on AGzMatchStateAnnouncer");
static_assert(sizeof(AGzMatchStateAnnouncer) == 0x000440, "Wrong size on AGzMatchStateAnnouncer");
static_assert(offsetof(AGzMatchStateAnnouncer, StageAnnouncements) == 0x0003F0, "Member 'AGzMatchStateAnnouncer::StageAnnouncements' has a wrong offset!");

// Class G01.GzReplayPlayerController
// 0x0038 (0x0F38 - 0x0F00)
class AGzReplayPlayerController final : public AGzPlayerController
{
public:
	class UGzAutoReplaySubsystem*                 ReplaySubsystem;                                   // 0x0F00(0x0008)(ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class AGzReplayCameraRecorder*                PlayerCameraRecorder;                              // 0x0F08(0x0008)(ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class AGzPlayerCharacter*                     CurrentPossessesPlayer;                            // 0x0F10(0x0008)(ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_337C[0x18];                                    // 0x0F18(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	class ACameraActor*                           PossessCamera;                                     // 0x0F30(0x0008)(ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void GotoReplayTimeInSeconds(float Seconds);
	void SetReplayPlayRate(float PlayRate);
	void ShowReplayCurrentTimeInSeconds();
	void ShowReplayTotalTimeInSeconds();
	void SwitchPlayerByName(const class FString& PlayerName);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzReplayPlayerController">();
	}
	static class AGzReplayPlayerController* GetDefaultObj()
	{
		return GetDefaultObjImpl<AGzReplayPlayerController>();
	}
};
static_assert(alignof(AGzReplayPlayerController) == 0x000008, "Wrong alignment on AGzReplayPlayerController");
static_assert(sizeof(AGzReplayPlayerController) == 0x000F38, "Wrong size on AGzReplayPlayerController");
static_assert(offsetof(AGzReplayPlayerController, ReplaySubsystem) == 0x000F00, "Member 'AGzReplayPlayerController::ReplaySubsystem' has a wrong offset!");
static_assert(offsetof(AGzReplayPlayerController, PlayerCameraRecorder) == 0x000F08, "Member 'AGzReplayPlayerController::PlayerCameraRecorder' has a wrong offset!");
static_assert(offsetof(AGzReplayPlayerController, CurrentPossessesPlayer) == 0x000F10, "Member 'AGzReplayPlayerController::CurrentPossessesPlayer' has a wrong offset!");
static_assert(offsetof(AGzReplayPlayerController, PossessCamera) == 0x000F30, "Member 'AGzReplayPlayerController::PossessCamera' has a wrong offset!");

// Class G01.GzMetaChallengeProgressData
// 0x0020 (0x0048 - 0x0028)
class UGzMetaChallengeProgressData final : public UGzSignalREventData
{
public:
	uint8                                         Pad_337D[0x20];                                    // 0x0028(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzMetaChallengeProgressData">();
	}
	static class UGzMetaChallengeProgressData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzMetaChallengeProgressData>();
	}
};
static_assert(alignof(UGzMetaChallengeProgressData) == 0x000008, "Wrong alignment on UGzMetaChallengeProgressData");
static_assert(sizeof(UGzMetaChallengeProgressData) == 0x000048, "Wrong size on UGzMetaChallengeProgressData");

// Class G01.GzMetaChallengeProgressHandler
// 0x0000 (0x0048 - 0x0048)
class UGzMetaChallengeProgressHandler final : public UGzSignalREvent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzMetaChallengeProgressHandler">();
	}
	static class UGzMetaChallengeProgressHandler* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzMetaChallengeProgressHandler>();
	}
};
static_assert(alignof(UGzMetaChallengeProgressHandler) == 0x000008, "Wrong alignment on UGzMetaChallengeProgressHandler");
static_assert(sizeof(UGzMetaChallengeProgressHandler) == 0x000048, "Wrong size on UGzMetaChallengeProgressHandler");

// Class G01.GzMetaCharacterAvatarData
// 0x00D0 (0x0100 - 0x0030)
class UGzMetaCharacterAvatarData final : public UDataAsset
{
public:
	struct FGzMetaCharacterAvatarLoadout          Loadout;                                           // 0x0030(0x0080)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FGzMetaCharacterAvatarAppearance       Appearance;                                        // 0x00B0(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzMetaCharacterAvatarData">();
	}
	static class UGzMetaCharacterAvatarData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzMetaCharacterAvatarData>();
	}
};
static_assert(alignof(UGzMetaCharacterAvatarData) == 0x000008, "Wrong alignment on UGzMetaCharacterAvatarData");
static_assert(sizeof(UGzMetaCharacterAvatarData) == 0x000100, "Wrong size on UGzMetaCharacterAvatarData");
static_assert(offsetof(UGzMetaCharacterAvatarData, Loadout) == 0x000030, "Member 'UGzMetaCharacterAvatarData::Loadout' has a wrong offset!");
static_assert(offsetof(UGzMetaCharacterAvatarData, Appearance) == 0x0000B0, "Member 'UGzMetaCharacterAvatarData::Appearance' has a wrong offset!");

// Class G01.GzMetaEventBus
// 0x00A8 (0x00D8 - 0x0030)
class UGzMetaEventBus final : public UGameInstanceSubsystem
{
public:
	TMap<TSubclassOf<class UGzMetaEventGateway>, class UGzMetaEventGateway*> Gateways;                                          // 0x0030(0x0050)(NativeAccessSpecifierPrivate)
	class UGzMetaEventReceiver*                   Receiver;                                          // 0x0080(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_337E[0x50];                                    // 0x0088(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzMetaEventBus">();
	}
	static class UGzMetaEventBus* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzMetaEventBus>();
	}
};
static_assert(alignof(UGzMetaEventBus) == 0x000008, "Wrong alignment on UGzMetaEventBus");
static_assert(sizeof(UGzMetaEventBus) == 0x0000D8, "Wrong size on UGzMetaEventBus");
static_assert(offsetof(UGzMetaEventBus, Gateways) == 0x000030, "Member 'UGzMetaEventBus::Gateways' has a wrong offset!");
static_assert(offsetof(UGzMetaEventBus, Receiver) == 0x000080, "Member 'UGzMetaEventBus::Receiver' has a wrong offset!");

// Class G01.GzMetaEventGateway
// 0x0020 (0x0048 - 0x0028)
class UGzMetaEventGateway : public UObject
{
public:
	uint8                                         Pad_337F[0x18];                                    // 0x0028(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	class UGzMetaEventBus*                        EventBus;                                          // 0x0040(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzMetaEventGateway">();
	}
	static class UGzMetaEventGateway* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzMetaEventGateway>();
	}
};
static_assert(alignof(UGzMetaEventGateway) == 0x000008, "Wrong alignment on UGzMetaEventGateway");
static_assert(sizeof(UGzMetaEventGateway) == 0x000048, "Wrong size on UGzMetaEventGateway");
static_assert(offsetof(UGzMetaEventGateway, EventBus) == 0x000040, "Member 'UGzMetaEventGateway::EventBus' has a wrong offset!");

// Class G01.GzMetaEventReceiver
// 0x0058 (0x0080 - 0x0028)
class UGzMetaEventReceiver final : public UObject
{
public:
	class UGzMetaEventBus*                        EventBus;                                          // 0x0028(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_3380[0x50];                                    // 0x0030(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzMetaEventReceiver">();
	}
	static class UGzMetaEventReceiver* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzMetaEventReceiver>();
	}
};
static_assert(alignof(UGzMetaEventReceiver) == 0x000008, "Wrong alignment on UGzMetaEventReceiver");
static_assert(sizeof(UGzMetaEventReceiver) == 0x000080, "Wrong size on UGzMetaEventReceiver");
static_assert(offsetof(UGzMetaEventReceiver, EventBus) == 0x000028, "Member 'UGzMetaEventReceiver::EventBus' has a wrong offset!");

// Class G01.GzMetaPlayerInventoryCheatExtension
// 0x0000 (0x0028 - 0x0028)
class UGzMetaPlayerInventoryCheatExtension final : public UGzCheatManagerExtension
{
public:
	void AddItem(const class FString& AssetId, const bool bLimitAndMint);
	void AddItemsByFilters(const class FString& Type, const class FString& Rarity, const class FString& InventoryType, const bool bLimitAndMint);
	void AddItemsOfTypeV2(const class FString& ItemType, const bool bLimitAndMint);
	void DisableSingleItemFromUICatalog(const class FString& AssetId);
	void DumpAllCITsForSlot(const class FString& SlotID);
	void EnableAllItemsInUICatalog();
	void MarkInventoryItemReviewed(const class FString& ItemGuid);
	void PerformClientInventoryIntegrityCheck();
	void RevokeItemsByFilters(const class FString& Type, const class FString& Rarity, const class FString& InventoryType);
	void RevokeItemsOfTypeV2(const class FString& ItemType);
	void SaveInventoryReviewedState();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzMetaPlayerInventoryCheatExtension">();
	}
	static class UGzMetaPlayerInventoryCheatExtension* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzMetaPlayerInventoryCheatExtension>();
	}
};
static_assert(alignof(UGzMetaPlayerInventoryCheatExtension) == 0x000008, "Wrong alignment on UGzMetaPlayerInventoryCheatExtension");
static_assert(sizeof(UGzMetaPlayerInventoryCheatExtension) == 0x000028, "Wrong size on UGzMetaPlayerInventoryCheatExtension");

// Class G01.GzMetaSupportCheatExtension
// 0x0000 (0x0028 - 0x0028)
class UGzMetaSupportCheatExtension final : public UGzCheatManagerExtension
{
public:
	void OnlineSessionReportCheating() const;
	void OnlineSessionReportCheatingIdle() const;
	void OnlineSessionReportIdle() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzMetaSupportCheatExtension">();
	}
	static class UGzMetaSupportCheatExtension* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzMetaSupportCheatExtension>();
	}
};
static_assert(alignof(UGzMetaSupportCheatExtension) == 0x000008, "Wrong alignment on UGzMetaSupportCheatExtension");
static_assert(sizeof(UGzMetaSupportCheatExtension) == 0x000028, "Wrong size on UGzMetaSupportCheatExtension");

// Class G01.GzSettingDiscreteFrameLimit
// 0x0000 (0x01B8 - 0x01B8)
class UGzSettingDiscreteFrameLimit final : public UGameSettingValueDiscreteDynamic
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzSettingDiscreteFrameLimit">();
	}
	static class UGzSettingDiscreteFrameLimit* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzSettingDiscreteFrameLimit>();
	}
};
static_assert(alignof(UGzSettingDiscreteFrameLimit) == 0x000008, "Wrong alignment on UGzSettingDiscreteFrameLimit");
static_assert(sizeof(UGzSettingDiscreteFrameLimit) == 0x0001B8, "Wrong size on UGzSettingDiscreteFrameLimit");

// Class G01.GzMetaTelemetryCheatExtension
// 0x0000 (0x0028 - 0x0028)
class UGzMetaTelemetryCheatExtension final : public UGzCheatManagerExtension
{
public:
	void MockMatchFinishedEvent() const;
	void MockOpportunityStartedEvent() const;
	void RequestImmediateTelemetryWrite() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzMetaTelemetryCheatExtension">();
	}
	static class UGzMetaTelemetryCheatExtension* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzMetaTelemetryCheatExtension>();
	}
};
static_assert(alignof(UGzMetaTelemetryCheatExtension) == 0x000008, "Wrong alignment on UGzMetaTelemetryCheatExtension");
static_assert(sizeof(UGzMetaTelemetryCheatExtension) == 0x000028, "Wrong size on UGzMetaTelemetryCheatExtension");

// Class G01.GzMetricsSubsystem
// 0x0000 (0x02A0 - 0x02A0)
class AGzMetricsSubsystem final : public AGzGameModeSubsystem
{
public:
	void OnMissionStateChanged(class AGzMission* Mission, const struct FGzMissionState& OldState, const struct FGzMissionState& MissionState);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzMetricsSubsystem">();
	}
	static class AGzMetricsSubsystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<AGzMetricsSubsystem>();
	}
};
static_assert(alignof(AGzMetricsSubsystem) == 0x000008, "Wrong alignment on AGzMetricsSubsystem");
static_assert(sizeof(AGzMetricsSubsystem) == 0x0002A0, "Wrong size on AGzMetricsSubsystem");

// Class G01.GzMicroMissilesComponent
// 0x01D0 (0x0428 - 0x0258)
class UGzMicroMissilesComponent : public UGzChargeableAbilityComponent
{
public:
	FMulticastInlineDelegateProperty_             OnTargetingStarted;                                // 0x0258(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, Protected, NativeAccessSpecifierProtected)
	FMulticastInlineDelegateProperty_             OnTargetingStopped;                                // 0x0268(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, Protected, NativeAccessSpecifierProtected)
	FMulticastInlineDelegateProperty_             OnTargetOutOfRange;                                // 0x0278(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, Protected, NativeAccessSpecifierProtected)
	FMulticastInlineDelegateProperty_             OnTargetInRange;                                   // 0x0288(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, Protected, NativeAccessSpecifierProtected)
	FMulticastInlineDelegateProperty_             OnLockOnStarted;                                   // 0x0298(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, Protected, NativeAccessSpecifierProtected)
	FMulticastInlineDelegateProperty_             OnLockOnSuccess;                                   // 0x02A8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, Protected, NativeAccessSpecifierProtected)
	FMulticastInlineDelegateProperty_             OnLockOnExpired;                                   // 0x02B8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, Protected, NativeAccessSpecifierProtected)
	FMulticastInlineDelegateProperty_             OnLockOnLockingStatusChanged;                      // 0x02C8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, Protected, NativeAccessSpecifierProtected)
	FMulticastInlineDelegateProperty_             OnLockOnInterrupted;                               // 0x02D8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, Protected, NativeAccessSpecifierProtected)
	FMulticastInlineDelegateProperty_             OnLockOnFailed;                                    // 0x02E8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, Protected, NativeAccessSpecifierProtected)
	FMulticastInlineDelegateProperty_             OnLockOnValidated;                                 // 0x02F8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, Protected, NativeAccessSpecifierProtected)
	float                                         AimToleranceDistance;                              // 0x0308(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3384[0x4];                                     // 0x030C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                AimOriginLocationOffset;                           // 0x0310(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCurveFloat*                            AimToleranceDistanceCurve;                         // 0x0328(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ValidationTimeoutDuration;                         // 0x0330(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MinChargeTimeUntilLockOnStart;                     // 0x0334(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         TimeToLockOn;                                      // 0x0338(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         LockOnDuration;                                    // 0x033C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         LockOnDurationLocation;                            // 0x0340(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MinHomingMagnitudeMultiplier;                      // 0x0344(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bAllowLockingOnFriendlies;                         // 0x0348(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bAllowShootingWithoutTargetLocation;               // 0x0349(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bEnableLocationAutoLockOn;                         // 0x034A(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3385[0x1];                                     // 0x034B(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         AutoLockOnInterval;                                // 0x034C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class AActor>                     TargetPreviewActorClass;                           // 0x0350(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<TSubclassOf<class AActor>>             IgnoredLockOnTargetClasses;                        // 0x0358(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	bool                                          bShowLockOnWarningToTarget;                        // 0x0368(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bShowMissileIncomingWarningToTarget;               // 0x0369(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3386[0x6];                                     // 0x036A(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UGameplayEffect>            LockedOnWarningEffect;                             // 0x0370(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class AGzMicroMissilesLockOnIndicator> LockOnWidgetActorClass;                            // 0x0378(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                LockOnWidgetAttachRelativeLocation;                // 0x0380(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class AActor*                                 TargetPreviewActor;                                // 0x0398(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UGzBodyPartAbilityData_MicroMissileArm* MicroMissileData;                                  // 0x03A0(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3387[0x80];                                    // 0x03A8(0x0080)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Client_AckLockonTarget(const int32 SlotNumber, const bool bIsValid);
	struct FGameplayAbilityTargetDataHandle GetCurrentLockOnDataAsAbilityTargetData();
	void GzLockOnChanged__DelegateSignature(const struct FGzMicroMissiles_LockOnTarget& TargetData);
	void GzMicroMissileTargetingEvent__DelegateSignature();
	void Server_RemoveLockonTarget(const int32 SlotNumber);
	void Server_ValidateLockonTarget(const struct FGzMicroMissiles_LockOnTarget& LockOnTargetData, const int32 SlotNumber);
	void StartLockOn(struct FGzMicroMissiles_LockOnTarget& TargetData);

	int32 GetCurrentLockOnTargetLimit() const;
	int32 GetLockOnTargetAmount() const;
	bool IsTargetInRange(const struct FGzMicroMissiles_LockOnTarget& TargetData) const;
	bool IsTargetVisible(const struct FGzMicroMissiles_LockOnTarget& TargetData) const;
	bool IsValidLockOnTarget(const struct FGzMicroMissiles_LockOnTarget& TargetData) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzMicroMissilesComponent">();
	}
	static class UGzMicroMissilesComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzMicroMissilesComponent>();
	}
};
static_assert(alignof(UGzMicroMissilesComponent) == 0x000008, "Wrong alignment on UGzMicroMissilesComponent");
static_assert(sizeof(UGzMicroMissilesComponent) == 0x000428, "Wrong size on UGzMicroMissilesComponent");
static_assert(offsetof(UGzMicroMissilesComponent, OnTargetingStarted) == 0x000258, "Member 'UGzMicroMissilesComponent::OnTargetingStarted' has a wrong offset!");
static_assert(offsetof(UGzMicroMissilesComponent, OnTargetingStopped) == 0x000268, "Member 'UGzMicroMissilesComponent::OnTargetingStopped' has a wrong offset!");
static_assert(offsetof(UGzMicroMissilesComponent, OnTargetOutOfRange) == 0x000278, "Member 'UGzMicroMissilesComponent::OnTargetOutOfRange' has a wrong offset!");
static_assert(offsetof(UGzMicroMissilesComponent, OnTargetInRange) == 0x000288, "Member 'UGzMicroMissilesComponent::OnTargetInRange' has a wrong offset!");
static_assert(offsetof(UGzMicroMissilesComponent, OnLockOnStarted) == 0x000298, "Member 'UGzMicroMissilesComponent::OnLockOnStarted' has a wrong offset!");
static_assert(offsetof(UGzMicroMissilesComponent, OnLockOnSuccess) == 0x0002A8, "Member 'UGzMicroMissilesComponent::OnLockOnSuccess' has a wrong offset!");
static_assert(offsetof(UGzMicroMissilesComponent, OnLockOnExpired) == 0x0002B8, "Member 'UGzMicroMissilesComponent::OnLockOnExpired' has a wrong offset!");
static_assert(offsetof(UGzMicroMissilesComponent, OnLockOnLockingStatusChanged) == 0x0002C8, "Member 'UGzMicroMissilesComponent::OnLockOnLockingStatusChanged' has a wrong offset!");
static_assert(offsetof(UGzMicroMissilesComponent, OnLockOnInterrupted) == 0x0002D8, "Member 'UGzMicroMissilesComponent::OnLockOnInterrupted' has a wrong offset!");
static_assert(offsetof(UGzMicroMissilesComponent, OnLockOnFailed) == 0x0002E8, "Member 'UGzMicroMissilesComponent::OnLockOnFailed' has a wrong offset!");
static_assert(offsetof(UGzMicroMissilesComponent, OnLockOnValidated) == 0x0002F8, "Member 'UGzMicroMissilesComponent::OnLockOnValidated' has a wrong offset!");
static_assert(offsetof(UGzMicroMissilesComponent, AimToleranceDistance) == 0x000308, "Member 'UGzMicroMissilesComponent::AimToleranceDistance' has a wrong offset!");
static_assert(offsetof(UGzMicroMissilesComponent, AimOriginLocationOffset) == 0x000310, "Member 'UGzMicroMissilesComponent::AimOriginLocationOffset' has a wrong offset!");
static_assert(offsetof(UGzMicroMissilesComponent, AimToleranceDistanceCurve) == 0x000328, "Member 'UGzMicroMissilesComponent::AimToleranceDistanceCurve' has a wrong offset!");
static_assert(offsetof(UGzMicroMissilesComponent, ValidationTimeoutDuration) == 0x000330, "Member 'UGzMicroMissilesComponent::ValidationTimeoutDuration' has a wrong offset!");
static_assert(offsetof(UGzMicroMissilesComponent, MinChargeTimeUntilLockOnStart) == 0x000334, "Member 'UGzMicroMissilesComponent::MinChargeTimeUntilLockOnStart' has a wrong offset!");
static_assert(offsetof(UGzMicroMissilesComponent, TimeToLockOn) == 0x000338, "Member 'UGzMicroMissilesComponent::TimeToLockOn' has a wrong offset!");
static_assert(offsetof(UGzMicroMissilesComponent, LockOnDuration) == 0x00033C, "Member 'UGzMicroMissilesComponent::LockOnDuration' has a wrong offset!");
static_assert(offsetof(UGzMicroMissilesComponent, LockOnDurationLocation) == 0x000340, "Member 'UGzMicroMissilesComponent::LockOnDurationLocation' has a wrong offset!");
static_assert(offsetof(UGzMicroMissilesComponent, MinHomingMagnitudeMultiplier) == 0x000344, "Member 'UGzMicroMissilesComponent::MinHomingMagnitudeMultiplier' has a wrong offset!");
static_assert(offsetof(UGzMicroMissilesComponent, bAllowLockingOnFriendlies) == 0x000348, "Member 'UGzMicroMissilesComponent::bAllowLockingOnFriendlies' has a wrong offset!");
static_assert(offsetof(UGzMicroMissilesComponent, bAllowShootingWithoutTargetLocation) == 0x000349, "Member 'UGzMicroMissilesComponent::bAllowShootingWithoutTargetLocation' has a wrong offset!");
static_assert(offsetof(UGzMicroMissilesComponent, bEnableLocationAutoLockOn) == 0x00034A, "Member 'UGzMicroMissilesComponent::bEnableLocationAutoLockOn' has a wrong offset!");
static_assert(offsetof(UGzMicroMissilesComponent, AutoLockOnInterval) == 0x00034C, "Member 'UGzMicroMissilesComponent::AutoLockOnInterval' has a wrong offset!");
static_assert(offsetof(UGzMicroMissilesComponent, TargetPreviewActorClass) == 0x000350, "Member 'UGzMicroMissilesComponent::TargetPreviewActorClass' has a wrong offset!");
static_assert(offsetof(UGzMicroMissilesComponent, IgnoredLockOnTargetClasses) == 0x000358, "Member 'UGzMicroMissilesComponent::IgnoredLockOnTargetClasses' has a wrong offset!");
static_assert(offsetof(UGzMicroMissilesComponent, bShowLockOnWarningToTarget) == 0x000368, "Member 'UGzMicroMissilesComponent::bShowLockOnWarningToTarget' has a wrong offset!");
static_assert(offsetof(UGzMicroMissilesComponent, bShowMissileIncomingWarningToTarget) == 0x000369, "Member 'UGzMicroMissilesComponent::bShowMissileIncomingWarningToTarget' has a wrong offset!");
static_assert(offsetof(UGzMicroMissilesComponent, LockedOnWarningEffect) == 0x000370, "Member 'UGzMicroMissilesComponent::LockedOnWarningEffect' has a wrong offset!");
static_assert(offsetof(UGzMicroMissilesComponent, LockOnWidgetActorClass) == 0x000378, "Member 'UGzMicroMissilesComponent::LockOnWidgetActorClass' has a wrong offset!");
static_assert(offsetof(UGzMicroMissilesComponent, LockOnWidgetAttachRelativeLocation) == 0x000380, "Member 'UGzMicroMissilesComponent::LockOnWidgetAttachRelativeLocation' has a wrong offset!");
static_assert(offsetof(UGzMicroMissilesComponent, TargetPreviewActor) == 0x000398, "Member 'UGzMicroMissilesComponent::TargetPreviewActor' has a wrong offset!");
static_assert(offsetof(UGzMicroMissilesComponent, MicroMissileData) == 0x0003A0, "Member 'UGzMicroMissilesComponent::MicroMissileData' has a wrong offset!");

// Class G01.GzSettingDiscreteLanguage
// 0x0020 (0x0170 - 0x0150)
class UGzSettingDiscreteLanguage final : public UGameSettingValueDiscrete
{
public:
	uint8                                         Pad_338D[0x20];                                    // 0x0150(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzSettingDiscreteLanguage">();
	}
	static class UGzSettingDiscreteLanguage* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzSettingDiscreteLanguage>();
	}
};
static_assert(alignof(UGzSettingDiscreteLanguage) == 0x000008, "Wrong alignment on UGzSettingDiscreteLanguage");
static_assert(sizeof(UGzSettingDiscreteLanguage) == 0x000170, "Wrong size on UGzSettingDiscreteLanguage");

// Class G01.GzMicroMissilesLockOnIndicator
// 0x0028 (0x02C8 - 0x02A0)
class AGzMicroMissilesLockOnIndicator : public AActor
{
public:
	FMulticastInlineDelegateProperty_             OnLockOnActivationChanged;                         // 0x02A0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	class USceneComponent*                        RootSceneComponent;                                // 0x02B0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UGzMarkerComponent*                     MarkerComponent;                                   // 0x02B8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsLockOnActive;                                   // 0x02C0(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_338E[0x7];                                     // 0x02C1(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	float GetLockOnProgress() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzMicroMissilesLockOnIndicator">();
	}
	static class AGzMicroMissilesLockOnIndicator* GetDefaultObj()
	{
		return GetDefaultObjImpl<AGzMicroMissilesLockOnIndicator>();
	}
};
static_assert(alignof(AGzMicroMissilesLockOnIndicator) == 0x000008, "Wrong alignment on AGzMicroMissilesLockOnIndicator");
static_assert(sizeof(AGzMicroMissilesLockOnIndicator) == 0x0002C8, "Wrong size on AGzMicroMissilesLockOnIndicator");
static_assert(offsetof(AGzMicroMissilesLockOnIndicator, OnLockOnActivationChanged) == 0x0002A0, "Member 'AGzMicroMissilesLockOnIndicator::OnLockOnActivationChanged' has a wrong offset!");
static_assert(offsetof(AGzMicroMissilesLockOnIndicator, RootSceneComponent) == 0x0002B0, "Member 'AGzMicroMissilesLockOnIndicator::RootSceneComponent' has a wrong offset!");
static_assert(offsetof(AGzMicroMissilesLockOnIndicator, MarkerComponent) == 0x0002B8, "Member 'AGzMicroMissilesLockOnIndicator::MarkerComponent' has a wrong offset!");
static_assert(offsetof(AGzMicroMissilesLockOnIndicator, bIsLockOnActive) == 0x0002C0, "Member 'AGzMicroMissilesLockOnIndicator::bIsLockOnActive' has a wrong offset!");

// Class G01.GzProjectileGrenade
// 0x0030 (0x0378 - 0x0348)
class AGzProjectileGrenade : public AGzProjectileBase
{
public:
	class UGzExplosionComponent*                  ExplosionComponent;                                // 0x0348(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USphereComponent*                       GrenadeTriggerComponent;                           // 0x0350(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_338F[0x10];                                    // 0x0358(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class UPrimitiveComponent*                    SurfaceProjectileIsStuckTo;                        // 0x0368(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UGzGrenadeProjectileData*               GrenadeData;                                       // 0x0370(0x0008)(Net, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void SetMaxGrenadeTimerSeconds(float MaxTimer);
	void TriggerGrenade();

	float GetCurrentGrenadeTimerSeconds() const;
	float GetMaxGrenadeTimerSeconds() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzProjectileGrenade">();
	}
	static class AGzProjectileGrenade* GetDefaultObj()
	{
		return GetDefaultObjImpl<AGzProjectileGrenade>();
	}
};
static_assert(alignof(AGzProjectileGrenade) == 0x000008, "Wrong alignment on AGzProjectileGrenade");
static_assert(sizeof(AGzProjectileGrenade) == 0x000378, "Wrong size on AGzProjectileGrenade");
static_assert(offsetof(AGzProjectileGrenade, ExplosionComponent) == 0x000348, "Member 'AGzProjectileGrenade::ExplosionComponent' has a wrong offset!");
static_assert(offsetof(AGzProjectileGrenade, GrenadeTriggerComponent) == 0x000350, "Member 'AGzProjectileGrenade::GrenadeTriggerComponent' has a wrong offset!");
static_assert(offsetof(AGzProjectileGrenade, SurfaceProjectileIsStuckTo) == 0x000368, "Member 'AGzProjectileGrenade::SurfaceProjectileIsStuckTo' has a wrong offset!");
static_assert(offsetof(AGzProjectileGrenade, GrenadeData) == 0x000370, "Member 'AGzProjectileGrenade::GrenadeData' has a wrong offset!");

// Class G01.GzMicroMissiles_Missile
// 0x01A0 (0x0518 - 0x0378)
class AGzMicroMissiles_Missile final : public AGzProjectileGrenade
{
public:
	FMulticastInlineDelegateProperty_             OnMissileLaunchedEvent;                            // 0x0378(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, Protected, NativeAccessSpecifierProtected)
	class UGzProjectileData*                      ProjectileData;                                    // 0x0388(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bEnableLeading;                                    // 0x0390(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bAddRandomSpreadToLocationTargets;                 // 0x0391(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3390[0x2];                                     // 0x0392(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         LocationTargetMinSpread;                           // 0x0394(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         LocationTargetMaxSpread;                           // 0x0398(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         HomingStartDelay;                                  // 0x039C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         HomingDisableDistance;                             // 0x03A0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bEnablePrimaryMotion;                              // 0x03A4(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3391[0x3];                                     // 0x03A5(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         PrimaryMotionHorizontalAngleBase;                  // 0x03A8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         PrimaryMotionVerticalAngleBase;                    // 0x03AC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         PrimaryMotionMaxAngleDeviation;                    // 0x03B0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bEnableSecondaryMotion;                            // 0x03B4(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3392[0x3];                                     // 0x03B5(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         SecondaryMotionSpeedMultiplier;                    // 0x03B8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         SecondaryMotionDisableDistanceMin;                 // 0x03BC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         SecondaryMotionDisableDistanceMax;                 // 0x03C0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         SecondaryMotionMaxMoveDistance;                    // 0x03C4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bShowViewportMarkerToTargets;                      // 0x03C8(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3393[0x7];                                     // 0x03C9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftClassPtr<class UClass>                   ViewportMarkerWidgetClass;                         // 0x03D0(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FHitResult                             TargetData;                                        // 0x03F8(0x00F8)(BlueprintVisible, BlueprintReadOnly, Net, IsPlainOldData, RepNotify, NoDestructor, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	bool                                          bSecondaryMotionActive;                            // 0x04F0(0x0001)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bMissileWasLaunched;                               // 0x04F1(0x0001)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3394[0x26];                                    // 0x04F2(0x0026)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void EnableHoming();
	void LaunchMissile();
	void LaunchWithDelay(const float DelaySeconds);
	void OnMissileLaunched();
	void OnRep_MissileWasLaunched();
	void OnRep_SecondaryMotionActive();
	void OnRep_TargetData();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzMicroMissiles_Missile">();
	}
	static class AGzMicroMissiles_Missile* GetDefaultObj()
	{
		return GetDefaultObjImpl<AGzMicroMissiles_Missile>();
	}
};
static_assert(alignof(AGzMicroMissiles_Missile) == 0x000008, "Wrong alignment on AGzMicroMissiles_Missile");
static_assert(sizeof(AGzMicroMissiles_Missile) == 0x000518, "Wrong size on AGzMicroMissiles_Missile");
static_assert(offsetof(AGzMicroMissiles_Missile, OnMissileLaunchedEvent) == 0x000378, "Member 'AGzMicroMissiles_Missile::OnMissileLaunchedEvent' has a wrong offset!");
static_assert(offsetof(AGzMicroMissiles_Missile, ProjectileData) == 0x000388, "Member 'AGzMicroMissiles_Missile::ProjectileData' has a wrong offset!");
static_assert(offsetof(AGzMicroMissiles_Missile, bEnableLeading) == 0x000390, "Member 'AGzMicroMissiles_Missile::bEnableLeading' has a wrong offset!");
static_assert(offsetof(AGzMicroMissiles_Missile, bAddRandomSpreadToLocationTargets) == 0x000391, "Member 'AGzMicroMissiles_Missile::bAddRandomSpreadToLocationTargets' has a wrong offset!");
static_assert(offsetof(AGzMicroMissiles_Missile, LocationTargetMinSpread) == 0x000394, "Member 'AGzMicroMissiles_Missile::LocationTargetMinSpread' has a wrong offset!");
static_assert(offsetof(AGzMicroMissiles_Missile, LocationTargetMaxSpread) == 0x000398, "Member 'AGzMicroMissiles_Missile::LocationTargetMaxSpread' has a wrong offset!");
static_assert(offsetof(AGzMicroMissiles_Missile, HomingStartDelay) == 0x00039C, "Member 'AGzMicroMissiles_Missile::HomingStartDelay' has a wrong offset!");
static_assert(offsetof(AGzMicroMissiles_Missile, HomingDisableDistance) == 0x0003A0, "Member 'AGzMicroMissiles_Missile::HomingDisableDistance' has a wrong offset!");
static_assert(offsetof(AGzMicroMissiles_Missile, bEnablePrimaryMotion) == 0x0003A4, "Member 'AGzMicroMissiles_Missile::bEnablePrimaryMotion' has a wrong offset!");
static_assert(offsetof(AGzMicroMissiles_Missile, PrimaryMotionHorizontalAngleBase) == 0x0003A8, "Member 'AGzMicroMissiles_Missile::PrimaryMotionHorizontalAngleBase' has a wrong offset!");
static_assert(offsetof(AGzMicroMissiles_Missile, PrimaryMotionVerticalAngleBase) == 0x0003AC, "Member 'AGzMicroMissiles_Missile::PrimaryMotionVerticalAngleBase' has a wrong offset!");
static_assert(offsetof(AGzMicroMissiles_Missile, PrimaryMotionMaxAngleDeviation) == 0x0003B0, "Member 'AGzMicroMissiles_Missile::PrimaryMotionMaxAngleDeviation' has a wrong offset!");
static_assert(offsetof(AGzMicroMissiles_Missile, bEnableSecondaryMotion) == 0x0003B4, "Member 'AGzMicroMissiles_Missile::bEnableSecondaryMotion' has a wrong offset!");
static_assert(offsetof(AGzMicroMissiles_Missile, SecondaryMotionSpeedMultiplier) == 0x0003B8, "Member 'AGzMicroMissiles_Missile::SecondaryMotionSpeedMultiplier' has a wrong offset!");
static_assert(offsetof(AGzMicroMissiles_Missile, SecondaryMotionDisableDistanceMin) == 0x0003BC, "Member 'AGzMicroMissiles_Missile::SecondaryMotionDisableDistanceMin' has a wrong offset!");
static_assert(offsetof(AGzMicroMissiles_Missile, SecondaryMotionDisableDistanceMax) == 0x0003C0, "Member 'AGzMicroMissiles_Missile::SecondaryMotionDisableDistanceMax' has a wrong offset!");
static_assert(offsetof(AGzMicroMissiles_Missile, SecondaryMotionMaxMoveDistance) == 0x0003C4, "Member 'AGzMicroMissiles_Missile::SecondaryMotionMaxMoveDistance' has a wrong offset!");
static_assert(offsetof(AGzMicroMissiles_Missile, bShowViewportMarkerToTargets) == 0x0003C8, "Member 'AGzMicroMissiles_Missile::bShowViewportMarkerToTargets' has a wrong offset!");
static_assert(offsetof(AGzMicroMissiles_Missile, ViewportMarkerWidgetClass) == 0x0003D0, "Member 'AGzMicroMissiles_Missile::ViewportMarkerWidgetClass' has a wrong offset!");
static_assert(offsetof(AGzMicroMissiles_Missile, TargetData) == 0x0003F8, "Member 'AGzMicroMissiles_Missile::TargetData' has a wrong offset!");
static_assert(offsetof(AGzMicroMissiles_Missile, bSecondaryMotionActive) == 0x0004F0, "Member 'AGzMicroMissiles_Missile::bSecondaryMotionActive' has a wrong offset!");
static_assert(offsetof(AGzMicroMissiles_Missile, bMissileWasLaunched) == 0x0004F1, "Member 'AGzMicroMissiles_Missile::bMissileWasLaunched' has a wrong offset!");

// Class G01.GzShootingAbilityComponent
// 0x0088 (0x0178 - 0x00F0)
class UGzShootingAbilityComponent : public UGzLimbAbilityComponent
{
public:
	uint8                                         Pad_3395[0x20];                                    // 0x00F0(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	class UGzBulletAttackStrategy*                AttackStrategy;                                    // 0x0110(0x0008)(Net, ZeroConstructor, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FGzWeaponInvItem                       Item;                                              // 0x0118(0x0050)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_3396[0x10];                                    // 0x0168(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnRep_AttackStrategy();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzShootingAbilityComponent">();
	}
	static class UGzShootingAbilityComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzShootingAbilityComponent>();
	}
};
static_assert(alignof(UGzShootingAbilityComponent) == 0x000008, "Wrong alignment on UGzShootingAbilityComponent");
static_assert(sizeof(UGzShootingAbilityComponent) == 0x000178, "Wrong size on UGzShootingAbilityComponent");
static_assert(offsetof(UGzShootingAbilityComponent, AttackStrategy) == 0x000110, "Member 'UGzShootingAbilityComponent::AttackStrategy' has a wrong offset!");
static_assert(offsetof(UGzShootingAbilityComponent, Item) == 0x000118, "Member 'UGzShootingAbilityComponent::Item' has a wrong offset!");

// Class G01.GzSettingDiscreteWindowMode
// 0x0000 (0x0150 - 0x0150)
class UGzSettingDiscreteWindowMode final : public UGameSettingValueDiscrete
{
public:
	void OnSettingsApplied();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzSettingDiscreteWindowMode">();
	}
	static class UGzSettingDiscreteWindowMode* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzSettingDiscreteWindowMode>();
	}
};
static_assert(alignof(UGzSettingDiscreteWindowMode) == 0x000008, "Wrong alignment on UGzSettingDiscreteWindowMode");
static_assert(sizeof(UGzSettingDiscreteWindowMode) == 0x000150, "Wrong size on UGzSettingDiscreteWindowMode");

// Class G01.GzMinigunComponent
// 0x0158 (0x02D0 - 0x0178)
class UGzMinigunComponent : public UGzShootingAbilityComponent
{
public:
	FMulticastInlineDelegateProperty_             OnRemainingAmmoChanged;                            // 0x0178(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnOverheatValueChanged;                            // 0x0188(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnSpreadScaleValueChanged;                         // 0x0198(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnEndShooting;                                     // 0x01A8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_3397[0x10];                                    // 0x01B8(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bUseAimInterpolation;                              // 0x01C8(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3398[0x3];                                     // 0x01C9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         AimInterpolationSpeedAngleDegrees;                 // 0x01CC(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         AimInterpolationMaxAngleDegrees;                   // 0x01D0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bLoopRecoilShotIndex;                              // 0x01D4(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3399[0x3];                                     // 0x01D5(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGzMinigunOverheatEffectData           OverheatEffectData;                                // 0x01D8(0x0048)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	int32                                         RemainingAmmo;                                     // 0x0220(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FGzMinigunPerArmReplicatedData         ReplicatedData;                                    // 0x0224(0x0018)(Net, NoDestructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_339A[0x4];                                     // 0x023C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UGzWeaponSpreadData*                    SpreadData;                                        // 0x0240(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UGzWeaponRecoilData*                    RecoilData;                                        // 0x0248(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UGzWeaponOverheatData*                  OverheatData;                                      // 0x0250(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UGzWeaponFXData*                        FXData;                                            // 0x0258(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UGzWeaponSoundData*                     SoundData;                                         // 0x0260(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UGzWeaponAnimationData*                 AnimationData;                                     // 0x0268(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UNiagaraComponent*                      MuzzleNiagaraComponent;                            // 0x0270(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UNiagaraComponent*                      OverheatNiagaraComponent;                          // 0x0278(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UNiagaraComponent*                      ShellEjectNiagaraComponent;                        // 0x0280(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_339B[0x48];                                    // 0x0288(0x0048)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ClientNotifyHostEndShooting(bool bOverheated);

	float GetOverheatPercentage() const;
	int32 GetRemainingAmmo() const;
	float GetSpreadScale() const;
	bool IsOverheated() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzMinigunComponent">();
	}
	static class UGzMinigunComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzMinigunComponent>();
	}
};
static_assert(alignof(UGzMinigunComponent) == 0x000008, "Wrong alignment on UGzMinigunComponent");
static_assert(sizeof(UGzMinigunComponent) == 0x0002D0, "Wrong size on UGzMinigunComponent");
static_assert(offsetof(UGzMinigunComponent, OnRemainingAmmoChanged) == 0x000178, "Member 'UGzMinigunComponent::OnRemainingAmmoChanged' has a wrong offset!");
static_assert(offsetof(UGzMinigunComponent, OnOverheatValueChanged) == 0x000188, "Member 'UGzMinigunComponent::OnOverheatValueChanged' has a wrong offset!");
static_assert(offsetof(UGzMinigunComponent, OnSpreadScaleValueChanged) == 0x000198, "Member 'UGzMinigunComponent::OnSpreadScaleValueChanged' has a wrong offset!");
static_assert(offsetof(UGzMinigunComponent, OnEndShooting) == 0x0001A8, "Member 'UGzMinigunComponent::OnEndShooting' has a wrong offset!");
static_assert(offsetof(UGzMinigunComponent, bUseAimInterpolation) == 0x0001C8, "Member 'UGzMinigunComponent::bUseAimInterpolation' has a wrong offset!");
static_assert(offsetof(UGzMinigunComponent, AimInterpolationSpeedAngleDegrees) == 0x0001CC, "Member 'UGzMinigunComponent::AimInterpolationSpeedAngleDegrees' has a wrong offset!");
static_assert(offsetof(UGzMinigunComponent, AimInterpolationMaxAngleDegrees) == 0x0001D0, "Member 'UGzMinigunComponent::AimInterpolationMaxAngleDegrees' has a wrong offset!");
static_assert(offsetof(UGzMinigunComponent, bLoopRecoilShotIndex) == 0x0001D4, "Member 'UGzMinigunComponent::bLoopRecoilShotIndex' has a wrong offset!");
static_assert(offsetof(UGzMinigunComponent, OverheatEffectData) == 0x0001D8, "Member 'UGzMinigunComponent::OverheatEffectData' has a wrong offset!");
static_assert(offsetof(UGzMinigunComponent, RemainingAmmo) == 0x000220, "Member 'UGzMinigunComponent::RemainingAmmo' has a wrong offset!");
static_assert(offsetof(UGzMinigunComponent, ReplicatedData) == 0x000224, "Member 'UGzMinigunComponent::ReplicatedData' has a wrong offset!");
static_assert(offsetof(UGzMinigunComponent, SpreadData) == 0x000240, "Member 'UGzMinigunComponent::SpreadData' has a wrong offset!");
static_assert(offsetof(UGzMinigunComponent, RecoilData) == 0x000248, "Member 'UGzMinigunComponent::RecoilData' has a wrong offset!");
static_assert(offsetof(UGzMinigunComponent, OverheatData) == 0x000250, "Member 'UGzMinigunComponent::OverheatData' has a wrong offset!");
static_assert(offsetof(UGzMinigunComponent, FXData) == 0x000258, "Member 'UGzMinigunComponent::FXData' has a wrong offset!");
static_assert(offsetof(UGzMinigunComponent, SoundData) == 0x000260, "Member 'UGzMinigunComponent::SoundData' has a wrong offset!");
static_assert(offsetof(UGzMinigunComponent, AnimationData) == 0x000268, "Member 'UGzMinigunComponent::AnimationData' has a wrong offset!");
static_assert(offsetof(UGzMinigunComponent, MuzzleNiagaraComponent) == 0x000270, "Member 'UGzMinigunComponent::MuzzleNiagaraComponent' has a wrong offset!");
static_assert(offsetof(UGzMinigunComponent, OverheatNiagaraComponent) == 0x000278, "Member 'UGzMinigunComponent::OverheatNiagaraComponent' has a wrong offset!");
static_assert(offsetof(UGzMinigunComponent, ShellEjectNiagaraComponent) == 0x000280, "Member 'UGzMinigunComponent::ShellEjectNiagaraComponent' has a wrong offset!");

// Class G01.GzMiscItemData
// 0x0000 (0x03C8 - 0x03C8)
class UGzMiscItemData final : public UGzSimpleItemData
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzMiscItemData">();
	}
	static class UGzMiscItemData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzMiscItemData>();
	}
};
static_assert(alignof(UGzMiscItemData) == 0x000008, "Wrong alignment on UGzMiscItemData");
static_assert(sizeof(UGzMiscItemData) == 0x0003C8, "Wrong size on UGzMiscItemData");

// Class G01.GzMissionAction_AwardInGameItem
// 0x0018 (0x0068 - 0x0050)
class UGzMissionAction_AwardInGameItem final : public UMissionAction
{
public:
	TArray<struct FGzSimpleInvItem>               MissionAwards;                                     // 0x0050(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	int32                                         RewardTier;                                        // 0x0060(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_339C[0x4];                                     // 0x0064(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzMissionAction_AwardInGameItem">();
	}
	static class UGzMissionAction_AwardInGameItem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzMissionAction_AwardInGameItem>();
	}
};
static_assert(alignof(UGzMissionAction_AwardInGameItem) == 0x000008, "Wrong alignment on UGzMissionAction_AwardInGameItem");
static_assert(sizeof(UGzMissionAction_AwardInGameItem) == 0x000068, "Wrong size on UGzMissionAction_AwardInGameItem");
static_assert(offsetof(UGzMissionAction_AwardInGameItem, MissionAwards) == 0x000050, "Member 'UGzMissionAction_AwardInGameItem::MissionAwards' has a wrong offset!");
static_assert(offsetof(UGzMissionAction_AwardInGameItem, RewardTier) == 0x000060, "Member 'UGzMissionAction_AwardInGameItem::RewardTier' has a wrong offset!");

// Class G01.GzSR_InProgressStage
// 0x0000 (0x0118 - 0x0118)
class UGzSR_InProgressStage final : public UGzMatchInProgressStage
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzSR_InProgressStage">();
	}
	static class UGzSR_InProgressStage* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzSR_InProgressStage>();
	}
};
static_assert(alignof(UGzSR_InProgressStage) == 0x000008, "Wrong alignment on UGzSR_InProgressStage");
static_assert(sizeof(UGzSR_InProgressStage) == 0x000118, "Wrong size on UGzSR_InProgressStage");

// Class G01.GzMissionAction_FailOnObjectiveConsumption
// 0x0038 (0x0088 - 0x0050)
class UGzMissionAction_FailOnObjectiveConsumption final : public UMissionAction
{
public:
	float                                         TimeToDestroyAfterConsumption;                     // 0x0050(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bAnnounce;                                         // 0x0054(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_339D[0x3];                                     // 0x0055(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UGzMissionConsumedMessage>  GameMessageClass;                                  // 0x0058(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class AActor*                                 Target;                                            // 0x0060(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class AGzShrinkingZoneManager*                ShrinkingZoneManager;                              // 0x0068(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_339E[0x18];                                    // 0x0070(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnOwningObjectiveStateChanged(class UMissionObjective* Objective, EMissionObjectiveState OldState, EMissionObjectiveState NewState);
	void OnStageChanged(const int32 StageIndex);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzMissionAction_FailOnObjectiveConsumption">();
	}
	static class UGzMissionAction_FailOnObjectiveConsumption* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzMissionAction_FailOnObjectiveConsumption>();
	}
};
static_assert(alignof(UGzMissionAction_FailOnObjectiveConsumption) == 0x000008, "Wrong alignment on UGzMissionAction_FailOnObjectiveConsumption");
static_assert(sizeof(UGzMissionAction_FailOnObjectiveConsumption) == 0x000088, "Wrong size on UGzMissionAction_FailOnObjectiveConsumption");
static_assert(offsetof(UGzMissionAction_FailOnObjectiveConsumption, TimeToDestroyAfterConsumption) == 0x000050, "Member 'UGzMissionAction_FailOnObjectiveConsumption::TimeToDestroyAfterConsumption' has a wrong offset!");
static_assert(offsetof(UGzMissionAction_FailOnObjectiveConsumption, bAnnounce) == 0x000054, "Member 'UGzMissionAction_FailOnObjectiveConsumption::bAnnounce' has a wrong offset!");
static_assert(offsetof(UGzMissionAction_FailOnObjectiveConsumption, GameMessageClass) == 0x000058, "Member 'UGzMissionAction_FailOnObjectiveConsumption::GameMessageClass' has a wrong offset!");
static_assert(offsetof(UGzMissionAction_FailOnObjectiveConsumption, Target) == 0x000060, "Member 'UGzMissionAction_FailOnObjectiveConsumption::Target' has a wrong offset!");
static_assert(offsetof(UGzMissionAction_FailOnObjectiveConsumption, ShrinkingZoneManager) == 0x000068, "Member 'UGzMissionAction_FailOnObjectiveConsumption::ShrinkingZoneManager' has a wrong offset!");

// Class G01.GzMissionAction_PlayCutscene
// 0x0050 (0x00A0 - 0x0050)
class UGzMissionAction_PlayCutscene final : public UMissionAction
{
public:
	uint8                                         Pad_33A0[0x8];                                     // 0x0050(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UMediaPlayer*                           MediaPlayer;                                       // 0x0058(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UMediaSource*                           MediaSource;                                       // 0x0060(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UMaterialInterface*                     CutsceneMaterial;                                  // 0x0068(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         Duration;                                          // 0x0070(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_33A1[0x4];                                     // 0x0074(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UGzMissionCutsceneWidget>   CutsceneWidgetClass;                               // 0x0078(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bPlay;                                             // 0x0080(0x0001)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_33A2[0x7];                                     // 0x0081(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UGzMissionCutsceneWidget*               CutsceneWidget;                                    // 0x0088(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UMediaSoundComponent*                   MediaSoundComponent;                               // 0x0090(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_33A3[0x8];                                     // 0x0098(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnCutsceneFinished();
	void OnRep_Play();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzMissionAction_PlayCutscene">();
	}
	static class UGzMissionAction_PlayCutscene* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzMissionAction_PlayCutscene>();
	}
};
static_assert(alignof(UGzMissionAction_PlayCutscene) == 0x000008, "Wrong alignment on UGzMissionAction_PlayCutscene");
static_assert(sizeof(UGzMissionAction_PlayCutscene) == 0x0000A0, "Wrong size on UGzMissionAction_PlayCutscene");
static_assert(offsetof(UGzMissionAction_PlayCutscene, MediaPlayer) == 0x000058, "Member 'UGzMissionAction_PlayCutscene::MediaPlayer' has a wrong offset!");
static_assert(offsetof(UGzMissionAction_PlayCutscene, MediaSource) == 0x000060, "Member 'UGzMissionAction_PlayCutscene::MediaSource' has a wrong offset!");
static_assert(offsetof(UGzMissionAction_PlayCutscene, CutsceneMaterial) == 0x000068, "Member 'UGzMissionAction_PlayCutscene::CutsceneMaterial' has a wrong offset!");
static_assert(offsetof(UGzMissionAction_PlayCutscene, Duration) == 0x000070, "Member 'UGzMissionAction_PlayCutscene::Duration' has a wrong offset!");
static_assert(offsetof(UGzMissionAction_PlayCutscene, CutsceneWidgetClass) == 0x000078, "Member 'UGzMissionAction_PlayCutscene::CutsceneWidgetClass' has a wrong offset!");
static_assert(offsetof(UGzMissionAction_PlayCutscene, bPlay) == 0x000080, "Member 'UGzMissionAction_PlayCutscene::bPlay' has a wrong offset!");
static_assert(offsetof(UGzMissionAction_PlayCutscene, CutsceneWidget) == 0x000088, "Member 'UGzMissionAction_PlayCutscene::CutsceneWidget' has a wrong offset!");
static_assert(offsetof(UGzMissionAction_PlayCutscene, MediaSoundComponent) == 0x000090, "Member 'UGzMissionAction_PlayCutscene::MediaSoundComponent' has a wrong offset!");

// Class G01.GzMissionAction_PrintString
// 0x0010 (0x0060 - 0x0050)
class UGzMissionAction_PrintString final : public UMissionAction
{
public:
	class FString                                 StringToPrint;                                     // 0x0050(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzMissionAction_PrintString">();
	}
	static class UGzMissionAction_PrintString* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzMissionAction_PrintString>();
	}
};
static_assert(alignof(UGzMissionAction_PrintString) == 0x000008, "Wrong alignment on UGzMissionAction_PrintString");
static_assert(sizeof(UGzMissionAction_PrintString) == 0x000060, "Wrong size on UGzMissionAction_PrintString");
static_assert(offsetof(UGzMissionAction_PrintString, StringToPrint) == 0x000050, "Member 'UGzMissionAction_PrintString::StringToPrint' has a wrong offset!");

// Class G01.GzStartSpot
// 0x0000 (0x02A0 - 0x02A0)
class AGzStartSpot final : public AActor
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzStartSpot">();
	}
	static class AGzStartSpot* GetDefaultObj()
	{
		return GetDefaultObjImpl<AGzStartSpot>();
	}
};
static_assert(alignof(AGzStartSpot) == 0x000008, "Wrong alignment on AGzStartSpot");
static_assert(sizeof(AGzStartSpot) == 0x0002A0, "Wrong size on AGzStartSpot");

// Class G01.GzMissionAction_TeleportPlayers
// 0x0010 (0x0060 - 0x0050)
class UGzMissionAction_TeleportPlayers final : public UMissionAction
{
public:
	TArray<struct FMissionResourceRef>            TeleportLocations;                                 // 0x0050(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzMissionAction_TeleportPlayers">();
	}
	static class UGzMissionAction_TeleportPlayers* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzMissionAction_TeleportPlayers>();
	}
};
static_assert(alignof(UGzMissionAction_TeleportPlayers) == 0x000008, "Wrong alignment on UGzMissionAction_TeleportPlayers");
static_assert(sizeof(UGzMissionAction_TeleportPlayers) == 0x000060, "Wrong size on UGzMissionAction_TeleportPlayers");
static_assert(offsetof(UGzMissionAction_TeleportPlayers, TeleportLocations) == 0x000050, "Member 'UGzMissionAction_TeleportPlayers::TeleportLocations' has a wrong offset!");

// Class G01.GzMissionArchetype
// 0x0048 (0x0078 - 0x0030)
class UGzMissionArchetype final : public UPrimaryDataAsset
{
public:
	class FText                                   DisplayName;                                       // 0x0030(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UTexture2D>              Image;                                             // 0x0040(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 CohtmlImage;                                       // 0x0068(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzMissionArchetype">();
	}
	static class UGzMissionArchetype* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzMissionArchetype>();
	}
};
static_assert(alignof(UGzMissionArchetype) == 0x000008, "Wrong alignment on UGzMissionArchetype");
static_assert(sizeof(UGzMissionArchetype) == 0x000078, "Wrong size on UGzMissionArchetype");
static_assert(offsetof(UGzMissionArchetype, DisplayName) == 0x000030, "Member 'UGzMissionArchetype::DisplayName' has a wrong offset!");
static_assert(offsetof(UGzMissionArchetype, Image) == 0x000040, "Member 'UGzMissionArchetype::Image' has a wrong offset!");
static_assert(offsetof(UGzMissionArchetype, CohtmlImage) == 0x000068, "Member 'UGzMissionArchetype::CohtmlImage' has a wrong offset!");

// Class G01.GzMissionAreaMarker
// 0x0028 (0x02F8 - 0x02D0)
class AGzMissionAreaMarker final : public AGzMissionMarker
{
public:
	class UProceduralMeshComponent*               CircleMesh;                                        // 0x02D0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UMaterialInterface*                     Material;                                          // 0x02D8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         Radius;                                            // 0x02E0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MeshLowerBound;                                    // 0x02E4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MeshUpperBound;                                    // 0x02E8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         InterpolationPointsPerUnit;                        // 0x02EC(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         MinInterpolationPoints;                            // 0x02F0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         MaxInterpolationPoints;                            // 0x02F4(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzMissionAreaMarker">();
	}
	static class AGzMissionAreaMarker* GetDefaultObj()
	{
		return GetDefaultObjImpl<AGzMissionAreaMarker>();
	}
};
static_assert(alignof(AGzMissionAreaMarker) == 0x000008, "Wrong alignment on AGzMissionAreaMarker");
static_assert(sizeof(AGzMissionAreaMarker) == 0x0002F8, "Wrong size on AGzMissionAreaMarker");
static_assert(offsetof(AGzMissionAreaMarker, CircleMesh) == 0x0002D0, "Member 'AGzMissionAreaMarker::CircleMesh' has a wrong offset!");
static_assert(offsetof(AGzMissionAreaMarker, Material) == 0x0002D8, "Member 'AGzMissionAreaMarker::Material' has a wrong offset!");
static_assert(offsetof(AGzMissionAreaMarker, Radius) == 0x0002E0, "Member 'AGzMissionAreaMarker::Radius' has a wrong offset!");
static_assert(offsetof(AGzMissionAreaMarker, MeshLowerBound) == 0x0002E4, "Member 'AGzMissionAreaMarker::MeshLowerBound' has a wrong offset!");
static_assert(offsetof(AGzMissionAreaMarker, MeshUpperBound) == 0x0002E8, "Member 'AGzMissionAreaMarker::MeshUpperBound' has a wrong offset!");
static_assert(offsetof(AGzMissionAreaMarker, InterpolationPointsPerUnit) == 0x0002EC, "Member 'AGzMissionAreaMarker::InterpolationPointsPerUnit' has a wrong offset!");
static_assert(offsetof(AGzMissionAreaMarker, MinInterpolationPoints) == 0x0002F0, "Member 'AGzMissionAreaMarker::MinInterpolationPoints' has a wrong offset!");
static_assert(offsetof(AGzMissionAreaMarker, MaxInterpolationPoints) == 0x0002F4, "Member 'AGzMissionAreaMarker::MaxInterpolationPoints' has a wrong offset!");

// Class G01.GzMissionBaseMessage
// 0x0010 (0x0038 - 0x0028)
class UGzMissionBaseMessage : public UGzGameMessage
{
public:
	struct FPrimaryAssetId                        AssetId;                                           // 0x0028(0x0010)(ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void SetMissionData(class UGzMissionData* InMissionData);

	const class UGzMissionData* GetMissionData() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzMissionBaseMessage">();
	}
	static class UGzMissionBaseMessage* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzMissionBaseMessage>();
	}
};
static_assert(alignof(UGzMissionBaseMessage) == 0x000008, "Wrong alignment on UGzMissionBaseMessage");
static_assert(sizeof(UGzMissionBaseMessage) == 0x000038, "Wrong size on UGzMissionBaseMessage");
static_assert(offsetof(UGzMissionBaseMessage, AssetId) == 0x000028, "Member 'UGzMissionBaseMessage::AssetId' has a wrong offset!");

// Class G01.GzMissionBlueprintFunctionLibrary
// 0x0000 (0x0028 - 0x0028)
class UGzMissionBlueprintFunctionLibrary final : public UBlueprintFunctionLibrary
{
public:
	static class UGzMTW_Base* GenerateMissionUI(class AGzAdvancedMission* Mission, const struct FGzUIBuilderParams& Params_0);
	static void GetAllPlayerMissionsOfClass(const class UObject* WorldContextObject, TSubclassOf<class AGzAdvancedMission> ClassType, TArray<class AGzAdvancedMission*>* Missions);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzMissionBlueprintFunctionLibrary">();
	}
	static class UGzMissionBlueprintFunctionLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzMissionBlueprintFunctionLibrary>();
	}
};
static_assert(alignof(UGzMissionBlueprintFunctionLibrary) == 0x000008, "Wrong alignment on UGzMissionBlueprintFunctionLibrary");
static_assert(sizeof(UGzMissionBlueprintFunctionLibrary) == 0x000028, "Wrong size on UGzMissionBlueprintFunctionLibrary");

// Class G01.GzMissionCheatExtension
// 0x0000 (0x0028 - 0x0028)
class UGzMissionCheatExtension final : public UGzCheatManagerExtension
{
public:
	void CompleteActiveMissions();
	void DebugListMissions();
	void DumpMissionStateByMissionId(const class FString& MissionId);
	void DumpMissionStateByRuntimeId(int32 RuntimeId);
	void FailActiveMissions();
	void StartAllMissionsForMap();
	void StartMissionForPlayer(const class FString& MissionId);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzMissionCheatExtension">();
	}
	static class UGzMissionCheatExtension* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzMissionCheatExtension>();
	}
};
static_assert(alignof(UGzMissionCheatExtension) == 0x000008, "Wrong alignment on UGzMissionCheatExtension");
static_assert(sizeof(UGzMissionCheatExtension) == 0x000028, "Wrong size on UGzMissionCheatExtension");

// Class G01.GzMissionCondition_IsPlayerInLocation
// 0x0028 (0x0080 - 0x0058)
class UGzMissionCondition_IsPlayerInLocation final : public UMissionCondition
{
public:
	struct FMissionResourceRef                    Trigger;                                           // 0x0058(0x0028)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)

public:
	void OnActorEndOverlap(class AActor* OverlappedActor, class AActor* OtherActor);
	void OnActorOverlap(class AActor* OverlappedActor, class AActor* OtherActor);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzMissionCondition_IsPlayerInLocation">();
	}
	static class UGzMissionCondition_IsPlayerInLocation* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzMissionCondition_IsPlayerInLocation>();
	}
};
static_assert(alignof(UGzMissionCondition_IsPlayerInLocation) == 0x000008, "Wrong alignment on UGzMissionCondition_IsPlayerInLocation");
static_assert(sizeof(UGzMissionCondition_IsPlayerInLocation) == 0x000080, "Wrong size on UGzMissionCondition_IsPlayerInLocation");
static_assert(offsetof(UGzMissionCondition_IsPlayerInLocation, Trigger) == 0x000058, "Member 'UGzMissionCondition_IsPlayerInLocation::Trigger' has a wrong offset!");

// Class G01.GzMissionConsumedMessage
// 0x0008 (0x0040 - 0x0038)
class UGzMissionConsumedMessage final : public UGzMissionBaseMessage
{
public:
	float                                         Duration;                                          // 0x0038(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_33A4[0x4];                                     // 0x003C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzMissionConsumedMessage">();
	}
	static class UGzMissionConsumedMessage* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzMissionConsumedMessage>();
	}
};
static_assert(alignof(UGzMissionConsumedMessage) == 0x000008, "Wrong alignment on UGzMissionConsumedMessage");
static_assert(sizeof(UGzMissionConsumedMessage) == 0x000040, "Wrong size on UGzMissionConsumedMessage");
static_assert(offsetof(UGzMissionConsumedMessage, Duration) == 0x000038, "Member 'UGzMissionConsumedMessage::Duration' has a wrong offset!");

// Class G01.GzPreLoginState
// 0x0000 (0x0070 - 0x0070)
class UGzPreLoginState final : public UGzFlowStateWithActionGraph
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzPreLoginState">();
	}
	static class UGzPreLoginState* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzPreLoginState>();
	}
};
static_assert(alignof(UGzPreLoginState) == 0x000008, "Wrong alignment on UGzPreLoginState");
static_assert(sizeof(UGzPreLoginState) == 0x000070, "Wrong size on UGzPreLoginState");

// Class G01.GzMissionCreator
// 0x0030 (0x0058 - 0x0028)
class UGzMissionCreator : public UObject
{
public:
	FMulticastInlineDelegateProperty_             OnMissionResourcesBecameUnavailable;               // 0x0028(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TArray<class UMissionResourceComponent*>      BookedTargets;                                     // 0x0038(0x0010)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, Transient, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	class UGzMissionData*                         MissionData;                                       // 0x0048(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class AActor*                                 MissionStarterActor;                               // 0x0050(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void BookTarget(class UMissionResourceComponent* MissionResourceComponent);
	bool CreateMission(class APlayerState* InInstigator, class UGzMissionData* InMissionData, class AActor* InMissionStarterActor);
	bool GatherMissionResources(class UGzMissionData* InMissionData, class AActor* InMissionStarterActor);
	void OnBookedTargetDestroyed(class UMissionResourceComponent* Resource, float Duration);
	void OnBookedTargetReserved(class UMissionResourceComponent* Resource, class UObject* ReservedBy);
	void OnStageChanged(const int32 StageIndex);
	void RemoveAllBookings();
	void RemoveAllBookingsAndRetry();
	void ReserveAllBookings();

	class UGzMissionData* GetMissionData() const;
	bool IsCulledByStageCount() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzMissionCreator">();
	}
	static class UGzMissionCreator* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzMissionCreator>();
	}
};
static_assert(alignof(UGzMissionCreator) == 0x000008, "Wrong alignment on UGzMissionCreator");
static_assert(sizeof(UGzMissionCreator) == 0x000058, "Wrong size on UGzMissionCreator");
static_assert(offsetof(UGzMissionCreator, OnMissionResourcesBecameUnavailable) == 0x000028, "Member 'UGzMissionCreator::OnMissionResourcesBecameUnavailable' has a wrong offset!");
static_assert(offsetof(UGzMissionCreator, BookedTargets) == 0x000038, "Member 'UGzMissionCreator::BookedTargets' has a wrong offset!");
static_assert(offsetof(UGzMissionCreator, MissionData) == 0x000048, "Member 'UGzMissionCreator::MissionData' has a wrong offset!");
static_assert(offsetof(UGzMissionCreator, MissionStarterActor) == 0x000050, "Member 'UGzMissionCreator::MissionStarterActor' has a wrong offset!");

// Class G01.MissionAction_RevealNextCircle
// 0x0008 (0x0058 - 0x0050)
class UMissionAction_RevealNextCircle final : public UMissionAction
{
public:
	int32                                         StagesToReveal;                                    // 0x0050(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_33A8[0x4];                                     // 0x0054(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MissionAction_RevealNextCircle">();
	}
	static class UMissionAction_RevealNextCircle* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMissionAction_RevealNextCircle>();
	}
};
static_assert(alignof(UMissionAction_RevealNextCircle) == 0x000008, "Wrong alignment on UMissionAction_RevealNextCircle");
static_assert(sizeof(UMissionAction_RevealNextCircle) == 0x000058, "Wrong size on UMissionAction_RevealNextCircle");
static_assert(offsetof(UMissionAction_RevealNextCircle, StagesToReveal) == 0x000050, "Member 'UMissionAction_RevealNextCircle::StagesToReveal' has a wrong offset!");

// Class G01.GzMissionCreator_BountyHunter
// 0x0000 (0x0058 - 0x0058)
class UGzMissionCreator_BountyHunter final : public UGzMissionCreator
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzMissionCreator_BountyHunter">();
	}
	static class UGzMissionCreator_BountyHunter* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzMissionCreator_BountyHunter>();
	}
};
static_assert(alignof(UGzMissionCreator_BountyHunter) == 0x000008, "Wrong alignment on UGzMissionCreator_BountyHunter");
static_assert(sizeof(UGzMissionCreator_BountyHunter) == 0x000058, "Wrong size on UGzMissionCreator_BountyHunter");

// Class G01.GzMissionCutsceneWidget
// 0x0038 (0x0318 - 0x02E0)
class UGzMissionCutsceneWidget final : public UUserWidget
{
public:
	class UMediaPlayer*                           MediaPlayer;                                       // 0x02E0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMediaSource*                           MediaSource;                                       // 0x02E8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMaterialInterface*                     CutsceneMaterial;                                  // 0x02F0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnMediaLoaded;                                     // 0x02F8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnMediaPlaybackFinished;                           // 0x0308(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzMissionCutsceneWidget">();
	}
	static class UGzMissionCutsceneWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzMissionCutsceneWidget>();
	}
};
static_assert(alignof(UGzMissionCutsceneWidget) == 0x000008, "Wrong alignment on UGzMissionCutsceneWidget");
static_assert(sizeof(UGzMissionCutsceneWidget) == 0x000318, "Wrong size on UGzMissionCutsceneWidget");
static_assert(offsetof(UGzMissionCutsceneWidget, MediaPlayer) == 0x0002E0, "Member 'UGzMissionCutsceneWidget::MediaPlayer' has a wrong offset!");
static_assert(offsetof(UGzMissionCutsceneWidget, MediaSource) == 0x0002E8, "Member 'UGzMissionCutsceneWidget::MediaSource' has a wrong offset!");
static_assert(offsetof(UGzMissionCutsceneWidget, CutsceneMaterial) == 0x0002F0, "Member 'UGzMissionCutsceneWidget::CutsceneMaterial' has a wrong offset!");
static_assert(offsetof(UGzMissionCutsceneWidget, OnMediaLoaded) == 0x0002F8, "Member 'UGzMissionCutsceneWidget::OnMediaLoaded' has a wrong offset!");
static_assert(offsetof(UGzMissionCutsceneWidget, OnMediaPlaybackFinished) == 0x000308, "Member 'UGzMissionCutsceneWidget::OnMediaPlaybackFinished' has a wrong offset!");

// Class G01.GzMissionEntryWidget
// 0x0020 (0x0328 - 0x0308)
class UGzMissionEntryWidget final : public UCommonUserWidget
{
public:
	FMulticastInlineDelegateProperty_             OnMissionEntryStateChanged;                        // 0x0308(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	class AGzMission*                             Mission;                                           // 0x0318(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UGzMissionLogWidget*                    ParentLog;                                         // 0x0320(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, Transient, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void NotifyMissionStateChanged(const struct FGzMissionState& OldState, const struct FGzMissionState& MissionState);
	void OnMissionSet(class AGzMission* InMission);
	void OnMissionStateChanged(class AGzMission* InMission, const struct FGzMissionState& OldState, const struct FGzMissionState& MissionState);
	void OnMissionStateChanged_BP(class AGzMission* InMission, const struct FGzMissionState& OldState, const struct FGzMissionState& MissionState);
	void OnMissionTrackedChanged(class AGzMission* InMission, bool bTracked);
	void OnMissionTrackedStateChanged_BP(class AGzMission* InMission, bool bTracked);
	void OnRootWidgetCreated_BP(class UGzMissionObjectiveWidget* RootWidget);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzMissionEntryWidget">();
	}
	static class UGzMissionEntryWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzMissionEntryWidget>();
	}
};
static_assert(alignof(UGzMissionEntryWidget) == 0x000008, "Wrong alignment on UGzMissionEntryWidget");
static_assert(sizeof(UGzMissionEntryWidget) == 0x000328, "Wrong size on UGzMissionEntryWidget");
static_assert(offsetof(UGzMissionEntryWidget, OnMissionEntryStateChanged) == 0x000308, "Member 'UGzMissionEntryWidget::OnMissionEntryStateChanged' has a wrong offset!");
static_assert(offsetof(UGzMissionEntryWidget, Mission) == 0x000318, "Member 'UGzMissionEntryWidget::Mission' has a wrong offset!");
static_assert(offsetof(UGzMissionEntryWidget, ParentLog) == 0x000320, "Member 'UGzMissionEntryWidget::ParentLog' has a wrong offset!");

// Class G01.GzPreTravelToOnlineSessionState
// 0x0018 (0x0078 - 0x0060)
class UGzPreTravelToOnlineSessionState final : public UGzFlowState
{
public:
	uint8                                         Pad_33AB[0x18];                                    // 0x0060(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzPreTravelToOnlineSessionState">();
	}
	static class UGzPreTravelToOnlineSessionState* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzPreTravelToOnlineSessionState>();
	}
};
static_assert(alignof(UGzPreTravelToOnlineSessionState) == 0x000008, "Wrong alignment on UGzPreTravelToOnlineSessionState");
static_assert(sizeof(UGzPreTravelToOnlineSessionState) == 0x000078, "Wrong size on UGzPreTravelToOnlineSessionState");

// Class G01.GzMissionExtension_AudioAnnouncement
// 0x0058 (0x00A0 - 0x0048)
class UGzMissionExtension_AudioAnnouncement final : public UMissionExtension
{
public:
	TMap<EMissionObjectiveState, struct FGzPingVoiceLineData> VoiceLinesPerState;                                // 0x0048(0x0050)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FGameplayTag                           AnnouncerTag;                                      // 0x0098(0x0008)(Edit, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzMissionExtension_AudioAnnouncement">();
	}
	static class UGzMissionExtension_AudioAnnouncement* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzMissionExtension_AudioAnnouncement>();
	}
};
static_assert(alignof(UGzMissionExtension_AudioAnnouncement) == 0x000008, "Wrong alignment on UGzMissionExtension_AudioAnnouncement");
static_assert(sizeof(UGzMissionExtension_AudioAnnouncement) == 0x0000A0, "Wrong size on UGzMissionExtension_AudioAnnouncement");
static_assert(offsetof(UGzMissionExtension_AudioAnnouncement, VoiceLinesPerState) == 0x000048, "Member 'UGzMissionExtension_AudioAnnouncement::VoiceLinesPerState' has a wrong offset!");
static_assert(offsetof(UGzMissionExtension_AudioAnnouncement, AnnouncerTag) == 0x000098, "Member 'UGzMissionExtension_AudioAnnouncement::AnnouncerTag' has a wrong offset!");

// Class G01.GzShootingRangeSettings
// 0x0008 (0x0178 - 0x0170)
class UGzShootingRangeSettings final : public UGzSessionGameModeSettings
{
public:
	float                                         InitTransitionTime;                                // 0x0170(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_33AC[0x4];                                     // 0x0174(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	float GetInitTransitionTime() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzShootingRangeSettings">();
	}
	static class UGzShootingRangeSettings* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzShootingRangeSettings>();
	}
};
static_assert(alignof(UGzShootingRangeSettings) == 0x000008, "Wrong alignment on UGzShootingRangeSettings");
static_assert(sizeof(UGzShootingRangeSettings) == 0x000178, "Wrong size on UGzShootingRangeSettings");
static_assert(offsetof(UGzShootingRangeSettings, InitTransitionTime) == 0x000170, "Member 'UGzShootingRangeSettings::InitTransitionTime' has a wrong offset!");

// Class G01.GzMissionExtension_Marker
// 0x00A0 (0x00E8 - 0x0048)
class UGzMissionExtension_Marker : public UMissionExtension
{
public:
	uint8                                         Pad_33AD[0x10];                                    // 0x0048(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FGzMissionMarkerSettings>       Targets;                                           // 0x0058(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	class FText                                   MarkerText;                                        // 0x0068(0x0010)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	bool                                          bUseGetTextForTargetFunction;                      // 0x0078(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_33AE[0x7];                                     // 0x0079(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class AGzMarkerSceneContainer>    MarkerClass;                                       // 0x0080(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         UpdateFrequency;                                   // 0x0088(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          AutoAttachOnStreamIn;                              // 0x008C(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseRandomOffset;                                  // 0x008D(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_33AF[0x2];                                     // 0x008E(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         RandomOffsetExtent;                                // 0x0090(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_33B0[0x4];                                     // 0x0094(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSet<EMissionObjectiveState>                  StatesToDisplay;                                   // 0x0098(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)

public:
	class FText GetTextForTarget(const TSoftObjectPtr<class AActor>& Target);
	void OnMissionTrackedStateChanged(class AGzMission* Mission, bool bTracked);
	bool ShouldDisplayMarkers();
	void UpdateMarkerVisibility();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzMissionExtension_Marker">();
	}
	static class UGzMissionExtension_Marker* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzMissionExtension_Marker>();
	}
};
static_assert(alignof(UGzMissionExtension_Marker) == 0x000008, "Wrong alignment on UGzMissionExtension_Marker");
static_assert(sizeof(UGzMissionExtension_Marker) == 0x0000E8, "Wrong size on UGzMissionExtension_Marker");
static_assert(offsetof(UGzMissionExtension_Marker, Targets) == 0x000058, "Member 'UGzMissionExtension_Marker::Targets' has a wrong offset!");
static_assert(offsetof(UGzMissionExtension_Marker, MarkerText) == 0x000068, "Member 'UGzMissionExtension_Marker::MarkerText' has a wrong offset!");
static_assert(offsetof(UGzMissionExtension_Marker, bUseGetTextForTargetFunction) == 0x000078, "Member 'UGzMissionExtension_Marker::bUseGetTextForTargetFunction' has a wrong offset!");
static_assert(offsetof(UGzMissionExtension_Marker, MarkerClass) == 0x000080, "Member 'UGzMissionExtension_Marker::MarkerClass' has a wrong offset!");
static_assert(offsetof(UGzMissionExtension_Marker, UpdateFrequency) == 0x000088, "Member 'UGzMissionExtension_Marker::UpdateFrequency' has a wrong offset!");
static_assert(offsetof(UGzMissionExtension_Marker, AutoAttachOnStreamIn) == 0x00008C, "Member 'UGzMissionExtension_Marker::AutoAttachOnStreamIn' has a wrong offset!");
static_assert(offsetof(UGzMissionExtension_Marker, bUseRandomOffset) == 0x00008D, "Member 'UGzMissionExtension_Marker::bUseRandomOffset' has a wrong offset!");
static_assert(offsetof(UGzMissionExtension_Marker, RandomOffsetExtent) == 0x000090, "Member 'UGzMissionExtension_Marker::RandomOffsetExtent' has a wrong offset!");
static_assert(offsetof(UGzMissionExtension_Marker, StatesToDisplay) == 0x000098, "Member 'UGzMissionExtension_Marker::StatesToDisplay' has a wrong offset!");

// Class G01.GzMissionExtension_Play2DSound
// 0x0050 (0x0098 - 0x0048)
class UGzMissionExtension_Play2DSound final : public UMissionExtension
{
public:
	TMap<EMissionObjectiveState, class UAkAudioEvent*> SoundsToPlay;                                      // 0x0048(0x0050)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzMissionExtension_Play2DSound">();
	}
	static class UGzMissionExtension_Play2DSound* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzMissionExtension_Play2DSound>();
	}
};
static_assert(alignof(UGzMissionExtension_Play2DSound) == 0x000008, "Wrong alignment on UGzMissionExtension_Play2DSound");
static_assert(sizeof(UGzMissionExtension_Play2DSound) == 0x000098, "Wrong size on UGzMissionExtension_Play2DSound");
static_assert(offsetof(UGzMissionExtension_Play2DSound, SoundsToPlay) == 0x000048, "Member 'UGzMissionExtension_Play2DSound::SoundsToPlay' has a wrong offset!");

// Class G01.LocomotionVaultingAssetCollection
// 0x0040 (0x0070 - 0x0030)
class ULocomotionVaultingAssetCollection final : public UDataAsset
{
public:
	TArray<class ULocomotionMantleAsset*>         OnGroundScenarios;                                 // 0x0030(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class ULocomotionMantleAsset*>         FallingCatchScenarios;                             // 0x0040(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class ULocomotionMantleAsset*>         VaultingOnGroundScenarios;                         // 0x0050(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class ULocomotionMantleAsset*>         FailedOnGroundScenarios;                           // 0x0060(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LocomotionVaultingAssetCollection">();
	}
	static class ULocomotionVaultingAssetCollection* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULocomotionVaultingAssetCollection>();
	}
};
static_assert(alignof(ULocomotionVaultingAssetCollection) == 0x000008, "Wrong alignment on ULocomotionVaultingAssetCollection");
static_assert(sizeof(ULocomotionVaultingAssetCollection) == 0x000070, "Wrong size on ULocomotionVaultingAssetCollection");
static_assert(offsetof(ULocomotionVaultingAssetCollection, OnGroundScenarios) == 0x000030, "Member 'ULocomotionVaultingAssetCollection::OnGroundScenarios' has a wrong offset!");
static_assert(offsetof(ULocomotionVaultingAssetCollection, FallingCatchScenarios) == 0x000040, "Member 'ULocomotionVaultingAssetCollection::FallingCatchScenarios' has a wrong offset!");
static_assert(offsetof(ULocomotionVaultingAssetCollection, VaultingOnGroundScenarios) == 0x000050, "Member 'ULocomotionVaultingAssetCollection::VaultingOnGroundScenarios' has a wrong offset!");
static_assert(offsetof(ULocomotionVaultingAssetCollection, FailedOnGroundScenarios) == 0x000060, "Member 'ULocomotionVaultingAssetCollection::FailedOnGroundScenarios' has a wrong offset!");

// Class G01.GzMissionExtension_SearchZone
// 0x0060 (0x00A8 - 0x0048)
class UGzMissionExtension_SearchZone final : public UMissionExtension
{
public:
	struct FGzSearchZoneSpec                      SearchZoneSettings;                                // 0x0048(0x0048)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	EGzMissionSearchZoneGrantType                 GrantTo;                                           // 0x0090(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_33B2[0x17];                                    // 0x0091(0x0017)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzMissionExtension_SearchZone">();
	}
	static class UGzMissionExtension_SearchZone* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzMissionExtension_SearchZone>();
	}
};
static_assert(alignof(UGzMissionExtension_SearchZone) == 0x000008, "Wrong alignment on UGzMissionExtension_SearchZone");
static_assert(sizeof(UGzMissionExtension_SearchZone) == 0x0000A8, "Wrong size on UGzMissionExtension_SearchZone");
static_assert(offsetof(UGzMissionExtension_SearchZone, SearchZoneSettings) == 0x000048, "Member 'UGzMissionExtension_SearchZone::SearchZoneSettings' has a wrong offset!");
static_assert(offsetof(UGzMissionExtension_SearchZone, GrantTo) == 0x000090, "Member 'UGzMissionExtension_SearchZone::GrantTo' has a wrong offset!");

// Class G01.GzProceduralTrackTransport
// 0x0038 (0x03E8 - 0x03B0)
class AGzProceduralTrackTransport : public AGzAutoTrackTransport
{
public:
	TSubclassOf<class AGzProceduralTrack>         TrackSpawnClass;                                   // 0x03B0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FGzTrackSpawnData                      TrackSpawnData;                                    // 0x03B8(0x0030)(Net, RepNotify, NoDestructor, NativeAccessSpecifierPrivate)

public:
	void OnRep_DeliveryData();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzProceduralTrackTransport">();
	}
	static class AGzProceduralTrackTransport* GetDefaultObj()
	{
		return GetDefaultObjImpl<AGzProceduralTrackTransport>();
	}
};
static_assert(alignof(AGzProceduralTrackTransport) == 0x000008, "Wrong alignment on AGzProceduralTrackTransport");
static_assert(sizeof(AGzProceduralTrackTransport) == 0x0003E8, "Wrong size on AGzProceduralTrackTransport");
static_assert(offsetof(AGzProceduralTrackTransport, TrackSpawnClass) == 0x0003B0, "Member 'AGzProceduralTrackTransport::TrackSpawnClass' has a wrong offset!");
static_assert(offsetof(AGzProceduralTrackTransport, TrackSpawnData) == 0x0003B8, "Member 'AGzProceduralTrackTransport::TrackSpawnData' has a wrong offset!");

// Class G01.GzMissionHelper
// 0x0000 (0x0028 - 0x0028)
class UGzMissionHelper final : public UBlueprintFunctionLibrary
{
public:
	static void BindOnMissionAccepted(const class UObject* WorldContextObject, const TDelegate<void(class UGzMissionData* MissionData)>& OnMissionAccepted);

	void GzMissionAccepted__DelegateSignature(const class UGzMissionData* MissionData);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzMissionHelper">();
	}
	static class UGzMissionHelper* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzMissionHelper>();
	}
};
static_assert(alignof(UGzMissionHelper) == 0x000008, "Wrong alignment on UGzMissionHelper");
static_assert(sizeof(UGzMissionHelper) == 0x000028, "Wrong size on UGzMissionHelper");

// Class G01.GzShootStatCollectorHands
// 0x0000 (0x0038 - 0x0038)
class UGzShootStatCollectorHands final : public UGzShootHitStatCollector
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzShootStatCollectorHands">();
	}
	static class UGzShootStatCollectorHands* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzShootStatCollectorHands>();
	}
};
static_assert(alignof(UGzShootStatCollectorHands) == 0x000008, "Wrong alignment on UGzShootStatCollectorHands");
static_assert(sizeof(UGzShootStatCollectorHands) == 0x000038, "Wrong size on UGzShootStatCollectorHands");

// Class G01.GzMissionInteractable
// 0x0088 (0x0328 - 0x02A0)
class AGzMissionInteractable : public AActor
{
public:
	uint8                                         Pad_33B3[0x8];                                     // 0x02A0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UGzInteractableComponent*               InteractableComponent;                             // 0x02A8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USkeletalMeshComponent*                 SkeletalMeshComponent;                             // 0x02B0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USphereComponent*                       DetectionSphere;                                   // 0x02B8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USceneComponent*                        DefaultScene;                                      // 0x02C0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bUseOpenCloseLogic;                                // 0x02C8(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bOpenOnlyToMissionOwners;                          // 0x02C9(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_33B4[0x6];                                     // 0x02CA(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTagContainer                  PrematchTags;                                      // 0x02D0(0x0020)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	bool                                          bIsOpen;                                           // 0x02F0(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EGzAnimationUpdateState                       AnimationUpdateState;                              // 0x02F1(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_33B5[0x2];                                     // 0x02F2(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         AnimationMaxDuration;                              // 0x02F4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MeshTickIntervalWhenInactive;                      // 0x02F8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_33B6[0x4];                                     // 0x02FC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class AGzPlayerCharacter*>             PlayersInDetectionSphere;                          // 0x0300(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	TArray<class UMissionObjective*>              AssignedObjectives;                                // 0x0310(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	uint8                                         Pad_33B7[0x8];                                     // 0x0320(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void DisableAnimation();
	void EnableAnimationForDuration(float Duration);
	void HandleClose();
	void HandleOpen();
	void OnDetectionSphereBeginOverlap(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const struct FHitResult& SweepResult);
	void OnDetectionSphereEndOverlap(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex);
	void OnRep_IsOpen();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzMissionInteractable">();
	}
	static class AGzMissionInteractable* GetDefaultObj()
	{
		return GetDefaultObjImpl<AGzMissionInteractable>();
	}
};
static_assert(alignof(AGzMissionInteractable) == 0x000008, "Wrong alignment on AGzMissionInteractable");
static_assert(sizeof(AGzMissionInteractable) == 0x000328, "Wrong size on AGzMissionInteractable");
static_assert(offsetof(AGzMissionInteractable, InteractableComponent) == 0x0002A8, "Member 'AGzMissionInteractable::InteractableComponent' has a wrong offset!");
static_assert(offsetof(AGzMissionInteractable, SkeletalMeshComponent) == 0x0002B0, "Member 'AGzMissionInteractable::SkeletalMeshComponent' has a wrong offset!");
static_assert(offsetof(AGzMissionInteractable, DetectionSphere) == 0x0002B8, "Member 'AGzMissionInteractable::DetectionSphere' has a wrong offset!");
static_assert(offsetof(AGzMissionInteractable, DefaultScene) == 0x0002C0, "Member 'AGzMissionInteractable::DefaultScene' has a wrong offset!");
static_assert(offsetof(AGzMissionInteractable, bUseOpenCloseLogic) == 0x0002C8, "Member 'AGzMissionInteractable::bUseOpenCloseLogic' has a wrong offset!");
static_assert(offsetof(AGzMissionInteractable, bOpenOnlyToMissionOwners) == 0x0002C9, "Member 'AGzMissionInteractable::bOpenOnlyToMissionOwners' has a wrong offset!");
static_assert(offsetof(AGzMissionInteractable, PrematchTags) == 0x0002D0, "Member 'AGzMissionInteractable::PrematchTags' has a wrong offset!");
static_assert(offsetof(AGzMissionInteractable, bIsOpen) == 0x0002F0, "Member 'AGzMissionInteractable::bIsOpen' has a wrong offset!");
static_assert(offsetof(AGzMissionInteractable, AnimationUpdateState) == 0x0002F1, "Member 'AGzMissionInteractable::AnimationUpdateState' has a wrong offset!");
static_assert(offsetof(AGzMissionInteractable, AnimationMaxDuration) == 0x0002F4, "Member 'AGzMissionInteractable::AnimationMaxDuration' has a wrong offset!");
static_assert(offsetof(AGzMissionInteractable, MeshTickIntervalWhenInactive) == 0x0002F8, "Member 'AGzMissionInteractable::MeshTickIntervalWhenInactive' has a wrong offset!");
static_assert(offsetof(AGzMissionInteractable, PlayersInDetectionSphere) == 0x000300, "Member 'AGzMissionInteractable::PlayersInDetectionSphere' has a wrong offset!");
static_assert(offsetof(AGzMissionInteractable, AssignedObjectives) == 0x000310, "Member 'AGzMissionInteractable::AssignedObjectives' has a wrong offset!");

// Class G01.GzMissionListWidget
// 0x0088 (0x0390 - 0x0308)
class UGzMissionListWidget final : public UCommonUserWidget
{
public:
	uint8                                         Pad_33BA[0x30];                                    // 0x0308(0x0030)(Fixing Size After Last Property [ Dumper-7 ])
	class UGzMissionLogWidget*                    ParentLog;                                         // 0x0338(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TMap<class AGzMission*, class UGzMissionEntryWidget*> MissionEntries;                                    // 0x0340(0x0050)(BlueprintVisible, ExportObject, BlueprintReadOnly, Transient, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)

public:
	void OnMissionEntryAdded(class UGzMissionEntryWidget* MissionEntryWidget);
	void OnMissionEntryStateChanged(class AGzMission* InMission, const struct FGzMissionState& OldState, const struct FGzMissionState& MissionState);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzMissionListWidget">();
	}
	static class UGzMissionListWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzMissionListWidget>();
	}
};
static_assert(alignof(UGzMissionListWidget) == 0x000008, "Wrong alignment on UGzMissionListWidget");
static_assert(sizeof(UGzMissionListWidget) == 0x000390, "Wrong size on UGzMissionListWidget");
static_assert(offsetof(UGzMissionListWidget, ParentLog) == 0x000338, "Member 'UGzMissionListWidget::ParentLog' has a wrong offset!");
static_assert(offsetof(UGzMissionListWidget, MissionEntries) == 0x000340, "Member 'UGzMissionListWidget::MissionEntries' has a wrong offset!");

// Class G01.GzMissionLogWidget
// 0x0070 (0x0378 - 0x0308)
class UGzMissionLogWidget final : public UCommonUserWidget
{
public:
	bool                                          bShowOnlyTrackedMissions;                          // 0x0308(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bEmpty;                                            // 0x0309(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_33BB[0x6];                                     // 0x030A(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<EGzMissionType>                        MissionTypesToDisplay;                             // 0x0310(0x0010)(Edit, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	class UGzMissionLogWidgetData*                MissionLogWidgetData;                              // 0x0320(0x0008)(Edit, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TMap<EGzMissionType, class UGzMissionListWidget*> ListWidgets;                                       // 0x0328(0x0050)(BlueprintVisible, ExportObject, BlueprintReadOnly, Transient, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)

public:
	void ClearList_BP();
	void ClearLog();
	void OnListWidgetAdded_BP(class UGzMissionListWidget* MissionListWidget);
	void OnLogEmpty();
	void OnLogNotEmpty();
	void OnMissionTrackedStateChanged(class AGzMission* InMission, bool bTracked);
	void OnNewMissionStarted(class AGzMission* NewMission);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzMissionLogWidget">();
	}
	static class UGzMissionLogWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzMissionLogWidget>();
	}
};
static_assert(alignof(UGzMissionLogWidget) == 0x000008, "Wrong alignment on UGzMissionLogWidget");
static_assert(sizeof(UGzMissionLogWidget) == 0x000378, "Wrong size on UGzMissionLogWidget");
static_assert(offsetof(UGzMissionLogWidget, bShowOnlyTrackedMissions) == 0x000308, "Member 'UGzMissionLogWidget::bShowOnlyTrackedMissions' has a wrong offset!");
static_assert(offsetof(UGzMissionLogWidget, bEmpty) == 0x000309, "Member 'UGzMissionLogWidget::bEmpty' has a wrong offset!");
static_assert(offsetof(UGzMissionLogWidget, MissionTypesToDisplay) == 0x000310, "Member 'UGzMissionLogWidget::MissionTypesToDisplay' has a wrong offset!");
static_assert(offsetof(UGzMissionLogWidget, MissionLogWidgetData) == 0x000320, "Member 'UGzMissionLogWidget::MissionLogWidgetData' has a wrong offset!");
static_assert(offsetof(UGzMissionLogWidget, ListWidgets) == 0x000328, "Member 'UGzMissionLogWidget::ListWidgets' has a wrong offset!");

// Class G01.GzProgressionSettings
// 0x0050 (0x0088 - 0x0038)
class UGzProgressionSettings final : public UDeveloperSettings
{
public:
	uint8                                         Pad_33BD[0x8];                                     // 0x0038(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FGzLevelRangeSettings>          PlayerLevelRangesSettings;                         // 0x0040(0x0010)(Edit, ZeroConstructor, Config, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TArray<struct FGzLevelRangeSettings>          BattlePassLevelRangesSettings;                     // 0x0050(0x0010)(Edit, ZeroConstructor, Config, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TArray<struct FGzLevelSettings>               PlayerLevels;                                      // 0x0060(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, NativeAccessSpecifierPublic)
	TArray<struct FGzBattlePassLevelSettings>     BattlePassLevels;                                  // 0x0070(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, NativeAccessSpecifierPublic)
	int32                                         StartLevel;                                        // 0x0080(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         StartXp;                                           // 0x0084(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static const class UGzProgressionSettings* GetProgressionSettings();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzProgressionSettings">();
	}
	static class UGzProgressionSettings* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzProgressionSettings>();
	}
};
static_assert(alignof(UGzProgressionSettings) == 0x000008, "Wrong alignment on UGzProgressionSettings");
static_assert(sizeof(UGzProgressionSettings) == 0x000088, "Wrong size on UGzProgressionSettings");
static_assert(offsetof(UGzProgressionSettings, PlayerLevelRangesSettings) == 0x000040, "Member 'UGzProgressionSettings::PlayerLevelRangesSettings' has a wrong offset!");
static_assert(offsetof(UGzProgressionSettings, BattlePassLevelRangesSettings) == 0x000050, "Member 'UGzProgressionSettings::BattlePassLevelRangesSettings' has a wrong offset!");
static_assert(offsetof(UGzProgressionSettings, PlayerLevels) == 0x000060, "Member 'UGzProgressionSettings::PlayerLevels' has a wrong offset!");
static_assert(offsetof(UGzProgressionSettings, BattlePassLevels) == 0x000070, "Member 'UGzProgressionSettings::BattlePassLevels' has a wrong offset!");
static_assert(offsetof(UGzProgressionSettings, StartLevel) == 0x000080, "Member 'UGzProgressionSettings::StartLevel' has a wrong offset!");
static_assert(offsetof(UGzProgressionSettings, StartXp) == 0x000084, "Member 'UGzProgressionSettings::StartXp' has a wrong offset!");

// Class G01.GzMissionLogWidgetData
// 0x0060 (0x0090 - 0x0030)
class UGzMissionLogWidgetData final : public UDataAsset
{
public:
	TSubclassOf<class UGzMissionListWidget>       ListWidgetClass;                                   // 0x0030(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UGzMissionEntryWidget>      MissionEntryClass;                                 // 0x0038(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMap<TSubclassOf<class UMissionObjective>, TSubclassOf<class UGzMissionObjectiveWidget>> MissionObjectivesWidgets;                          // 0x0040(0x0050)(Edit, Protected, UObjectWrapper, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzMissionLogWidgetData">();
	}
	static class UGzMissionLogWidgetData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzMissionLogWidgetData>();
	}
};
static_assert(alignof(UGzMissionLogWidgetData) == 0x000008, "Wrong alignment on UGzMissionLogWidgetData");
static_assert(sizeof(UGzMissionLogWidgetData) == 0x000090, "Wrong size on UGzMissionLogWidgetData");
static_assert(offsetof(UGzMissionLogWidgetData, ListWidgetClass) == 0x000030, "Member 'UGzMissionLogWidgetData::ListWidgetClass' has a wrong offset!");
static_assert(offsetof(UGzMissionLogWidgetData, MissionEntryClass) == 0x000038, "Member 'UGzMissionLogWidgetData::MissionEntryClass' has a wrong offset!");
static_assert(offsetof(UGzMissionLogWidgetData, MissionObjectivesWidgets) == 0x000040, "Member 'UGzMissionLogWidgetData::MissionObjectivesWidgets' has a wrong offset!");

// Class G01.GzShopSettings
// 0x0010 (0x0048 - 0x0038)
class UGzShopSettings final : public UDeveloperSettings
{
public:
	class FString                                 GunWalletLinkTemplate;                             // 0x0038(0x0010)(Edit, ZeroConstructor, Config, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzShopSettings">();
	}
	static class UGzShopSettings* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzShopSettings>();
	}
};
static_assert(alignof(UGzShopSettings) == 0x000008, "Wrong alignment on UGzShopSettings");
static_assert(sizeof(UGzShopSettings) == 0x000048, "Wrong size on UGzShopSettings");
static_assert(offsetof(UGzShopSettings, GunWalletLinkTemplate) == 0x000038, "Member 'UGzShopSettings::GunWalletLinkTemplate' has a wrong offset!");

// Class G01.GzMissionManager
// 0x00F0 (0x0390 - 0x02A0)
class AGzMissionManager final : public AGzGameModeSubsystem
{
public:
	uint8                                         Pad_33BE[0x30];                                    // 0x02A0(0x0030)(Fixing Size After Last Property [ Dumper-7 ])
	FMulticastInlineDelegateProperty_             OnMissionTrackingChanged;                          // 0x02D0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnMissionRegistered;                               // 0x02E0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, Protected, NativeAccessSpecifierProtected)
	TArray<class AGzAdvancedMission*>             LocalRegisteredMissions;                           // 0x02F0(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	TArray<class AGzAdvancedMission*>             LocalTrackedMissions;                              // 0x0300(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	bool                                          bShouldAutoTrackMissions;                          // 0x0310(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_33BF[0x7];                                     // 0x0311(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class AGzAdvancedMission*>             MissionTemplates;                                  // 0x0318(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	TMap<int32, class UGzMissionData*>            PlayerSelectedJobs;                                // 0x0328(0x0050)(Transient, NativeAccessSpecifierPrivate)
	TArray<struct FGzMissionGroup>                Groups;                                            // 0x0378(0x0010)(Net, ZeroConstructor, RepNotify, NativeAccessSpecifierPrivate)
	uint8                                         Pad_33C0[0x8];                                     // 0x0388(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnMissionStateChanged(class AGzAdvancedMission* Mission, const EGzMissionState NewState);
	void OnRep_Groups();
	bool SetMissionTrackingEnabled(class AGzAdvancedMission* InMission, bool bIsEnabled);
	void StartMissions();

	bool IsMissionTracked(const class AGzAdvancedMission* InMission) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzMissionManager">();
	}
	static class AGzMissionManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<AGzMissionManager>();
	}
};
static_assert(alignof(AGzMissionManager) == 0x000008, "Wrong alignment on AGzMissionManager");
static_assert(sizeof(AGzMissionManager) == 0x000390, "Wrong size on AGzMissionManager");
static_assert(offsetof(AGzMissionManager, OnMissionTrackingChanged) == 0x0002D0, "Member 'AGzMissionManager::OnMissionTrackingChanged' has a wrong offset!");
static_assert(offsetof(AGzMissionManager, OnMissionRegistered) == 0x0002E0, "Member 'AGzMissionManager::OnMissionRegistered' has a wrong offset!");
static_assert(offsetof(AGzMissionManager, LocalRegisteredMissions) == 0x0002F0, "Member 'AGzMissionManager::LocalRegisteredMissions' has a wrong offset!");
static_assert(offsetof(AGzMissionManager, LocalTrackedMissions) == 0x000300, "Member 'AGzMissionManager::LocalTrackedMissions' has a wrong offset!");
static_assert(offsetof(AGzMissionManager, bShouldAutoTrackMissions) == 0x000310, "Member 'AGzMissionManager::bShouldAutoTrackMissions' has a wrong offset!");
static_assert(offsetof(AGzMissionManager, MissionTemplates) == 0x000318, "Member 'AGzMissionManager::MissionTemplates' has a wrong offset!");
static_assert(offsetof(AGzMissionManager, PlayerSelectedJobs) == 0x000328, "Member 'AGzMissionManager::PlayerSelectedJobs' has a wrong offset!");
static_assert(offsetof(AGzMissionManager, Groups) == 0x000378, "Member 'AGzMissionManager::Groups' has a wrong offset!");

// Class G01.GzMissionMarkerActor
// 0x0020 (0x02C0 - 0x02A0)
class AGzMissionMarkerActor final : public AActor
{
public:
	TSubclassOf<class UGzMissionMarkerComponent_New> MarkerComponentClass;                              // 0x02A0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class UGzMissionMarkerComponent_New*>  MarkerComponents;                                  // 0x02A8(0x0010)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, ContainsInstancedReference, NativeAccessSpecifierPublic)
	class UGzMissionExtension_Marker*             OwningMarkerExtension;                             // 0x02B8(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void Activate();
	void Deactivate();
	void SetOwningMarkerExtension(class UGzMissionExtension_Marker* InMarkerExtension);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzMissionMarkerActor">();
	}
	static class AGzMissionMarkerActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<AGzMissionMarkerActor>();
	}
};
static_assert(alignof(AGzMissionMarkerActor) == 0x000008, "Wrong alignment on AGzMissionMarkerActor");
static_assert(sizeof(AGzMissionMarkerActor) == 0x0002C0, "Wrong size on AGzMissionMarkerActor");
static_assert(offsetof(AGzMissionMarkerActor, MarkerComponentClass) == 0x0002A0, "Member 'AGzMissionMarkerActor::MarkerComponentClass' has a wrong offset!");
static_assert(offsetof(AGzMissionMarkerActor, MarkerComponents) == 0x0002A8, "Member 'AGzMissionMarkerActor::MarkerComponents' has a wrong offset!");
static_assert(offsetof(AGzMissionMarkerActor, OwningMarkerExtension) == 0x0002B8, "Member 'AGzMissionMarkerActor::OwningMarkerExtension' has a wrong offset!");

// Class G01.GzMissionMarkerComponent_New
// 0x0020 (0x04A0 - 0x0480)
class UGzMissionMarkerComponent_New final : public UGzMarkerComponent
{
public:
	FMulticastInlineDelegateProperty_             OnComponentVisibilityChanged;                      // 0x0478(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	class FText                                   MarkerText;                                        // 0x0488(0x0010)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	uint8                                         Pad_33C4[0x8];                                     // 0x0498(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzMissionMarkerComponent_New">();
	}
	static class UGzMissionMarkerComponent_New* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzMissionMarkerComponent_New>();
	}
};
static_assert(alignof(UGzMissionMarkerComponent_New) == 0x000010, "Wrong alignment on UGzMissionMarkerComponent_New");
static_assert(sizeof(UGzMissionMarkerComponent_New) == 0x0004A0, "Wrong size on UGzMissionMarkerComponent_New");
static_assert(offsetof(UGzMissionMarkerComponent_New, OnComponentVisibilityChanged) == 0x000478, "Member 'UGzMissionMarkerComponent_New::OnComponentVisibilityChanged' has a wrong offset!");
static_assert(offsetof(UGzMissionMarkerComponent_New, MarkerText) == 0x000488, "Member 'UGzMissionMarkerComponent_New::MarkerText' has a wrong offset!");

// Class G01.GzSequenceObjective
// 0x0018 (0x0078 - 0x0060)
class UGzSequenceObjective final : public UGzObjective
{
public:
	uint8                                         Pad_33C5[0x8];                                     // 0x0060(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UGzObjective*>                   ChildObjectives;                                   // 0x0068(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)

public:
	static class UGzObjective* MakeSequenceObjective(class AGzAdvancedMission* Mission, const TArray<class UGzObjective*>& Objectives);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzSequenceObjective">();
	}
	static class UGzSequenceObjective* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzSequenceObjective>();
	}
};
static_assert(alignof(UGzSequenceObjective) == 0x000008, "Wrong alignment on UGzSequenceObjective");
static_assert(sizeof(UGzSequenceObjective) == 0x000078, "Wrong size on UGzSequenceObjective");
static_assert(offsetof(UGzSequenceObjective, ChildObjectives) == 0x000068, "Member 'UGzSequenceObjective::ChildObjectives' has a wrong offset!");

// Class G01.GzMissionMessage
// 0x0010 (0x0038 - 0x0028)
class UGzMissionMessage final : public UGzGameMessage
{
public:
	int32                                         NotificationType;                                  // 0x0028(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_33C6[0x4];                                     // 0x002C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class AGzAdvancedMission*                     Mission;                                           // 0x0030(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzMissionMessage">();
	}
	static class UGzMissionMessage* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzMissionMessage>();
	}
};
static_assert(alignof(UGzMissionMessage) == 0x000008, "Wrong alignment on UGzMissionMessage");
static_assert(sizeof(UGzMissionMessage) == 0x000038, "Wrong size on UGzMissionMessage");
static_assert(offsetof(UGzMissionMessage, NotificationType) == 0x000028, "Member 'UGzMissionMessage::NotificationType' has a wrong offset!");
static_assert(offsetof(UGzMissionMessage, Mission) == 0x000030, "Member 'UGzMissionMessage::Mission' has a wrong offset!");

// Class G01.GzMissionObjectiveWidget
// 0x0020 (0x0328 - 0x0308)
class UGzMissionObjectiveWidget final : public UCommonUserWidget
{
public:
	class UMissionObjective*                      Objective;                                         // 0x0308(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UGzMissionLogWidget*                    ParentLog;                                         // 0x0310(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, Transient, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class UGzMissionObjectiveWidget*>      ChildObjectiveWidgets;                             // 0x0318(0x0010)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, Transient, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)

public:
	void OnChildObjectiveWidgetCreated_BP(class UGzMissionObjectiveWidget* NewWidget);
	void OnObjectiveSet_BP(class UMissionObjective* InObjective);
	void OnObjectiveStateChanged_BP(class UMissionObjective* MissionObjective, EMissionObjectiveState OldState, EMissionObjectiveState NewState);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzMissionObjectiveWidget">();
	}
	static class UGzMissionObjectiveWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzMissionObjectiveWidget>();
	}
};
static_assert(alignof(UGzMissionObjectiveWidget) == 0x000008, "Wrong alignment on UGzMissionObjectiveWidget");
static_assert(sizeof(UGzMissionObjectiveWidget) == 0x000328, "Wrong size on UGzMissionObjectiveWidget");
static_assert(offsetof(UGzMissionObjectiveWidget, Objective) == 0x000308, "Member 'UGzMissionObjectiveWidget::Objective' has a wrong offset!");
static_assert(offsetof(UGzMissionObjectiveWidget, ParentLog) == 0x000310, "Member 'UGzMissionObjectiveWidget::ParentLog' has a wrong offset!");
static_assert(offsetof(UGzMissionObjectiveWidget, ChildObjectiveWidgets) == 0x000318, "Member 'UGzMissionObjectiveWidget::ChildObjectiveWidgets' has a wrong offset!");

// Class G01.GzMissionObjective_Destroy
// 0x0040 (0x0228 - 0x01E8)
class UGzMissionObjective_Destroy final : public UGameplayObjective
{
public:
	uint8                                         Pad_33C8[0x8];                                     // 0x01E8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FMissionResourceRef                    Target;                                            // 0x01F0(0x0028)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	class UAbilitySystemComponent*                TargetASC;                                         // 0x0218(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_33C9[0x8];                                     // 0x0220(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetTarget(const struct FMissionResourceRef& InTarget);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzMissionObjective_Destroy">();
	}
	static class UGzMissionObjective_Destroy* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzMissionObjective_Destroy>();
	}
};
static_assert(alignof(UGzMissionObjective_Destroy) == 0x000008, "Wrong alignment on UGzMissionObjective_Destroy");
static_assert(sizeof(UGzMissionObjective_Destroy) == 0x000228, "Wrong size on UGzMissionObjective_Destroy");
static_assert(offsetof(UGzMissionObjective_Destroy, Target) == 0x0001F0, "Member 'UGzMissionObjective_Destroy::Target' has a wrong offset!");
static_assert(offsetof(UGzMissionObjective_Destroy, TargetASC) == 0x000218, "Member 'UGzMissionObjective_Destroy::TargetASC' has a wrong offset!");

// Class G01.GzServerDiscoveryService
// 0x0030 (0x00D0 - 0x00A0)
class UGzServerDiscoveryService final : public UGzPlayFabObject
{
public:
	uint8                                         Pad_33CA[0x30];                                    // 0x00A0(0x0030)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzServerDiscoveryService">();
	}
	static class UGzServerDiscoveryService* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzServerDiscoveryService>();
	}
};
static_assert(alignof(UGzServerDiscoveryService) == 0x000008, "Wrong alignment on UGzServerDiscoveryService");
static_assert(sizeof(UGzServerDiscoveryService) == 0x0000D0, "Wrong size on UGzServerDiscoveryService");

// Class G01.GzMissionObjective_GoToLocation
// 0x0038 (0x0220 - 0x01E8)
class UGzMissionObjective_GoToLocation final : public UGameplayObjective
{
public:
	uint8                                         Pad_33CB[0x8];                                     // 0x01E8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FMissionResourceRef                    Trigger;                                           // 0x01F0(0x0028)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	bool                                          bIsExclusive;                                      // 0x0218(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_33CC[0x7];                                     // 0x0219(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnTriggerOverlap(class AActor* OverlappedActor, class AActor* OtherActor);
	void SetTarget(const struct FMissionResourceRef& InTarget);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzMissionObjective_GoToLocation">();
	}
	static class UGzMissionObjective_GoToLocation* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzMissionObjective_GoToLocation>();
	}
};
static_assert(alignof(UGzMissionObjective_GoToLocation) == 0x000008, "Wrong alignment on UGzMissionObjective_GoToLocation");
static_assert(sizeof(UGzMissionObjective_GoToLocation) == 0x000220, "Wrong size on UGzMissionObjective_GoToLocation");
static_assert(offsetof(UGzMissionObjective_GoToLocation, Trigger) == 0x0001F0, "Member 'UGzMissionObjective_GoToLocation::Trigger' has a wrong offset!");
static_assert(offsetof(UGzMissionObjective_GoToLocation, bIsExclusive) == 0x000218, "Member 'UGzMissionObjective_GoToLocation::bIsExclusive' has a wrong offset!");

// Class G01.GzMissionResourceSubsystem
// 0x0010 (0x0090 - 0x0080)
class UGzMissionResourceSubsystem final : public UMissionResourceSubsystem
{
public:
	FMulticastInlineDelegateProperty_             OnMissionResourcesFiltered;                        // 0x0080(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)

public:
	void Init();
	void OnStageChanged(const int32 StageIndex);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzMissionResourceSubsystem">();
	}
	static class UGzMissionResourceSubsystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzMissionResourceSubsystem>();
	}
};
static_assert(alignof(UGzMissionResourceSubsystem) == 0x000008, "Wrong alignment on UGzMissionResourceSubsystem");
static_assert(sizeof(UGzMissionResourceSubsystem) == 0x000090, "Wrong size on UGzMissionResourceSubsystem");
static_assert(offsetof(UGzMissionResourceSubsystem, OnMissionResourcesFiltered) == 0x000080, "Member 'UGzMissionResourceSubsystem::OnMissionResourcesFiltered' has a wrong offset!");

// Class G01.GzMissionStarterActor
// 0x0060 (0x0300 - 0x02A0)
class AGzMissionStarterActor : public AActor
{
public:
	uint8                                         Pad_33CD[0x8];                                     // 0x02A0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	FMulticastInlineDelegateProperty_             OnMissionDataUpdated;                              // 0x02A8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnMissionCreated;                                  // 0x02B8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnMissionStarterInvalidated;                       // 0x02C8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	class USceneComponent*                        RootScene;                                         // 0x02D8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UGzInteractableComponent*               InteractableComponent;                             // 0x02E0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UStaticMeshComponent*                   InteractionMesh;                                   // 0x02E8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UGzMissionData*                         MissionData;                                       // 0x02F0(0x0008)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UGzMissionCreator*                      MissionCreator;                                    // 0x02F8(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void Invalidate();
	void OnRep_MissionData();
	bool TryStartMission(class AGzPlayerState* PlayerState);

	class UGzMissionData* GetMissionData() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzMissionStarterActor">();
	}
	static class AGzMissionStarterActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<AGzMissionStarterActor>();
	}
};
static_assert(alignof(AGzMissionStarterActor) == 0x000008, "Wrong alignment on AGzMissionStarterActor");
static_assert(sizeof(AGzMissionStarterActor) == 0x000300, "Wrong size on AGzMissionStarterActor");
static_assert(offsetof(AGzMissionStarterActor, OnMissionDataUpdated) == 0x0002A8, "Member 'AGzMissionStarterActor::OnMissionDataUpdated' has a wrong offset!");
static_assert(offsetof(AGzMissionStarterActor, OnMissionCreated) == 0x0002B8, "Member 'AGzMissionStarterActor::OnMissionCreated' has a wrong offset!");
static_assert(offsetof(AGzMissionStarterActor, OnMissionStarterInvalidated) == 0x0002C8, "Member 'AGzMissionStarterActor::OnMissionStarterInvalidated' has a wrong offset!");
static_assert(offsetof(AGzMissionStarterActor, RootScene) == 0x0002D8, "Member 'AGzMissionStarterActor::RootScene' has a wrong offset!");
static_assert(offsetof(AGzMissionStarterActor, InteractableComponent) == 0x0002E0, "Member 'AGzMissionStarterActor::InteractableComponent' has a wrong offset!");
static_assert(offsetof(AGzMissionStarterActor, InteractionMesh) == 0x0002E8, "Member 'AGzMissionStarterActor::InteractionMesh' has a wrong offset!");
static_assert(offsetof(AGzMissionStarterActor, MissionData) == 0x0002F0, "Member 'AGzMissionStarterActor::MissionData' has a wrong offset!");
static_assert(offsetof(AGzMissionStarterActor, MissionCreator) == 0x0002F8, "Member 'AGzMissionStarterActor::MissionCreator' has a wrong offset!");

// Class G01.GzMissionStarterSpawner
// 0x0078 (0x0318 - 0x02A0)
class AGzMissionStarterSpawner : public AActor
{
public:
	FMulticastInlineDelegateProperty_             OnMissionStarterSpawned;                           // 0x02A0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnMissionStarterConsumed;                          // 0x02B0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	class UMissionResourceComponent*              MissionResourceComponent;                          // 0x02C0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UGzMissionStarterSpawnParams*           SpawnParams;                                       // 0x02C8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class AGzMissionStarterActor*                 SpawnedSpawner;                                    // 0x02D0(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bForceSpecificMission;                             // 0x02D8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_33CF[0x7];                                     // 0x02D9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UGzMissionData*                         SpecificMissionData;                               // 0x02E0(0x0008)(Edit, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         DestructionDelay;                                  // 0x02E8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_33D0[0x4];                                     // 0x02EC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class AGzMissionStarterActor>     MissionStarterClass;                               // 0x02F0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<class UGzMissionData*>                 MissionsUnableToStart;                             // 0x02F8(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	uint8                                         Pad_33D1[0x10];                                    // 0x0308(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void DestroyDelayed();
	void DestroyThis();
	void OnMissionCreated(class AGzMissionStarterActor* MissionStarterActor);

	bool IsAvailable() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzMissionStarterSpawner">();
	}
	static class AGzMissionStarterSpawner* GetDefaultObj()
	{
		return GetDefaultObjImpl<AGzMissionStarterSpawner>();
	}
};
static_assert(alignof(AGzMissionStarterSpawner) == 0x000008, "Wrong alignment on AGzMissionStarterSpawner");
static_assert(sizeof(AGzMissionStarterSpawner) == 0x000318, "Wrong size on AGzMissionStarterSpawner");
static_assert(offsetof(AGzMissionStarterSpawner, OnMissionStarterSpawned) == 0x0002A0, "Member 'AGzMissionStarterSpawner::OnMissionStarterSpawned' has a wrong offset!");
static_assert(offsetof(AGzMissionStarterSpawner, OnMissionStarterConsumed) == 0x0002B0, "Member 'AGzMissionStarterSpawner::OnMissionStarterConsumed' has a wrong offset!");
static_assert(offsetof(AGzMissionStarterSpawner, MissionResourceComponent) == 0x0002C0, "Member 'AGzMissionStarterSpawner::MissionResourceComponent' has a wrong offset!");
static_assert(offsetof(AGzMissionStarterSpawner, SpawnParams) == 0x0002C8, "Member 'AGzMissionStarterSpawner::SpawnParams' has a wrong offset!");
static_assert(offsetof(AGzMissionStarterSpawner, SpawnedSpawner) == 0x0002D0, "Member 'AGzMissionStarterSpawner::SpawnedSpawner' has a wrong offset!");
static_assert(offsetof(AGzMissionStarterSpawner, bForceSpecificMission) == 0x0002D8, "Member 'AGzMissionStarterSpawner::bForceSpecificMission' has a wrong offset!");
static_assert(offsetof(AGzMissionStarterSpawner, SpecificMissionData) == 0x0002E0, "Member 'AGzMissionStarterSpawner::SpecificMissionData' has a wrong offset!");
static_assert(offsetof(AGzMissionStarterSpawner, DestructionDelay) == 0x0002E8, "Member 'AGzMissionStarterSpawner::DestructionDelay' has a wrong offset!");
static_assert(offsetof(AGzMissionStarterSpawner, MissionStarterClass) == 0x0002F0, "Member 'AGzMissionStarterSpawner::MissionStarterClass' has a wrong offset!");
static_assert(offsetof(AGzMissionStarterSpawner, MissionsUnableToStart) == 0x0002F8, "Member 'AGzMissionStarterSpawner::MissionsUnableToStart' has a wrong offset!");

// Class G01.GzMissionStarterSpawnParams
// 0x0070 (0x00A0 - 0x0030)
class UGzMissionStarterSpawnParams final : public UPrimaryDataAsset
{
public:
	float                                         RespawnDisableCircleRadius;                        // 0x0030(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MissionStarterSpawnTimeMin;                        // 0x0034(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MissionStarterSpawnTimeMax;                        // 0x0038(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_33D2[0x4];                                     // 0x003C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FGzMissionDataWeightParams>     AvailableMissions;                                 // 0x0040(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	TMap<struct FGameplayTag, struct FGzMissionStarterSpawnParamArray> StarterSpawnParams;                                // 0x0050(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzMissionStarterSpawnParams">();
	}
	static class UGzMissionStarterSpawnParams* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzMissionStarterSpawnParams>();
	}
};
static_assert(alignof(UGzMissionStarterSpawnParams) == 0x000008, "Wrong alignment on UGzMissionStarterSpawnParams");
static_assert(sizeof(UGzMissionStarterSpawnParams) == 0x0000A0, "Wrong size on UGzMissionStarterSpawnParams");
static_assert(offsetof(UGzMissionStarterSpawnParams, RespawnDisableCircleRadius) == 0x000030, "Member 'UGzMissionStarterSpawnParams::RespawnDisableCircleRadius' has a wrong offset!");
static_assert(offsetof(UGzMissionStarterSpawnParams, MissionStarterSpawnTimeMin) == 0x000034, "Member 'UGzMissionStarterSpawnParams::MissionStarterSpawnTimeMin' has a wrong offset!");
static_assert(offsetof(UGzMissionStarterSpawnParams, MissionStarterSpawnTimeMax) == 0x000038, "Member 'UGzMissionStarterSpawnParams::MissionStarterSpawnTimeMax' has a wrong offset!");
static_assert(offsetof(UGzMissionStarterSpawnParams, AvailableMissions) == 0x000040, "Member 'UGzMissionStarterSpawnParams::AvailableMissions' has a wrong offset!");
static_assert(offsetof(UGzMissionStarterSpawnParams, StarterSpawnParams) == 0x000050, "Member 'UGzMissionStarterSpawnParams::StarterSpawnParams' has a wrong offset!");

// Class G01.GzServerUnityService
// 0x0000 (0x01C8 - 0x01C8)
class UGzServerUnityService final : public UGzServerService
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzServerUnityService">();
	}
	static class UGzServerUnityService* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzServerUnityService>();
	}
};
static_assert(alignof(UGzServerUnityService) == 0x000008, "Wrong alignment on UGzServerUnityService");
static_assert(sizeof(UGzServerUnityService) == 0x0001C8, "Wrong size on UGzServerUnityService");

// Class G01.GzMissionStatCollector
// 0x0000 (0x0038 - 0x0038)
class UGzMissionStatCollector : public UGzGlobalStatsCollector
{
public:
	void OnMissionStateChanged(class AGzMission* Mission, const struct FGzMissionState& OldState, const struct FGzMissionState& MissionState);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzMissionStatCollector">();
	}
	static class UGzMissionStatCollector* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzMissionStatCollector>();
	}
};
static_assert(alignof(UGzMissionStatCollector) == 0x000008, "Wrong alignment on UGzMissionStatCollector");
static_assert(sizeof(UGzMissionStatCollector) == 0x000038, "Wrong size on UGzMissionStatCollector");

// Class G01.GzMissionStartedCollector
// 0x0000 (0x0038 - 0x0038)
class UGzMissionStartedCollector final : public UGzMissionStatCollector
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzMissionStartedCollector">();
	}
	static class UGzMissionStartedCollector* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzMissionStartedCollector>();
	}
};
static_assert(alignof(UGzMissionStartedCollector) == 0x000008, "Wrong alignment on UGzMissionStartedCollector");
static_assert(sizeof(UGzMissionStartedCollector) == 0x000038, "Wrong size on UGzMissionStartedCollector");

// Class G01.GzMissionCompletedCollector
// 0x0000 (0x0038 - 0x0038)
class UGzMissionCompletedCollector final : public UGzMissionStatCollector
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzMissionCompletedCollector">();
	}
	static class UGzMissionCompletedCollector* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzMissionCompletedCollector>();
	}
};
static_assert(alignof(UGzMissionCompletedCollector) == 0x000008, "Wrong alignment on UGzMissionCompletedCollector");
static_assert(sizeof(UGzMissionCompletedCollector) == 0x000038, "Wrong size on UGzMissionCompletedCollector");

// Class G01.GzMissionFailedCollector
// 0x0000 (0x0038 - 0x0038)
class UGzMissionFailedCollector final : public UGzMissionStatCollector
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzMissionFailedCollector">();
	}
	static class UGzMissionFailedCollector* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzMissionFailedCollector>();
	}
};
static_assert(alignof(UGzMissionFailedCollector) == 0x000008, "Wrong alignment on UGzMissionFailedCollector");
static_assert(sizeof(UGzMissionFailedCollector) == 0x000038, "Wrong size on UGzMissionFailedCollector");

// Class G01.GzSmoothPawnMovementComponent
// 0x0038 (0x01B0 - 0x0178)
class UGzSmoothPawnMovementComponent final : public UFloatingPawnMovement
{
public:
	uint8                                         Pad_33D3[0x8];                                     // 0x0178(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         NetworkSimulatedSmoothLocationTime;                // 0x0180(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         NetworkSimulatedSmoothRotationTime;                // 0x0184(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ListenServerNetworkSimulatedSmoothLocationTime;    // 0x0188(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ListenServerNetworkSimulatedSmoothRotationTime;    // 0x018C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         NetworkMaxSmoothUpdateDistance;                    // 0x0190(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         NetworkNoSmoothUpdateDistance;                     // 0x0194(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_33D4[0x18];                                    // 0x0198(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzSmoothPawnMovementComponent">();
	}
	static class UGzSmoothPawnMovementComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzSmoothPawnMovementComponent>();
	}
};
static_assert(alignof(UGzSmoothPawnMovementComponent) == 0x000008, "Wrong alignment on UGzSmoothPawnMovementComponent");
static_assert(sizeof(UGzSmoothPawnMovementComponent) == 0x0001B0, "Wrong size on UGzSmoothPawnMovementComponent");
static_assert(offsetof(UGzSmoothPawnMovementComponent, NetworkSimulatedSmoothLocationTime) == 0x000180, "Member 'UGzSmoothPawnMovementComponent::NetworkSimulatedSmoothLocationTime' has a wrong offset!");
static_assert(offsetof(UGzSmoothPawnMovementComponent, NetworkSimulatedSmoothRotationTime) == 0x000184, "Member 'UGzSmoothPawnMovementComponent::NetworkSimulatedSmoothRotationTime' has a wrong offset!");
static_assert(offsetof(UGzSmoothPawnMovementComponent, ListenServerNetworkSimulatedSmoothLocationTime) == 0x000188, "Member 'UGzSmoothPawnMovementComponent::ListenServerNetworkSimulatedSmoothLocationTime' has a wrong offset!");
static_assert(offsetof(UGzSmoothPawnMovementComponent, ListenServerNetworkSimulatedSmoothRotationTime) == 0x00018C, "Member 'UGzSmoothPawnMovementComponent::ListenServerNetworkSimulatedSmoothRotationTime' has a wrong offset!");
static_assert(offsetof(UGzSmoothPawnMovementComponent, NetworkMaxSmoothUpdateDistance) == 0x000190, "Member 'UGzSmoothPawnMovementComponent::NetworkMaxSmoothUpdateDistance' has a wrong offset!");
static_assert(offsetof(UGzSmoothPawnMovementComponent, NetworkNoSmoothUpdateDistance) == 0x000194, "Member 'UGzSmoothPawnMovementComponent::NetworkNoSmoothUpdateDistance' has a wrong offset!");

// Class G01.GzMissionStatics
// 0x0000 (0x0028 - 0x0028)
class UGzMissionStatics final : public UBlueprintFunctionLibrary
{
public:
	static TArray<class AGzPlayerState*> GetAliveMissionParticipants(const class AMission* Mission);
	static int32 GetAliveMissionParticipantsCount(const class AMission* Mission);
	static TArray<int32> GetAliveParticipantsFromGroup(const class UObject* WorldContextObject, const struct FGzMissionGroup& MissionGroup);
	static class UGzMissionData* GetMissionData(const class FString& MissionId);
	static class AActor* Resolve(const class UObject* WorldContextObject, const struct FMissionResourceRef& Ref);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzMissionStatics">();
	}
	static class UGzMissionStatics* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzMissionStatics>();
	}
};
static_assert(alignof(UGzMissionStatics) == 0x000008, "Wrong alignment on UGzMissionStatics");
static_assert(sizeof(UGzMissionStatics) == 0x000028, "Wrong size on UGzMissionStatics");

// Class G01.GzMissionSubsystem
// 0x01D8 (0x0208 - 0x0030)
class UGzMissionSubsystem final : public UWorldSubsystem
{
public:
	FMulticastInlineDelegateProperty_             OnMissionStateChanged;                             // 0x0030(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnMissionStarted;                                  // 0x0040(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnMissionTrackedStateChanged;                      // 0x0050(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnActiveMissionsByTypeChanged;                     // 0x0060(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	bool                                          bShouldAutoTrackMissions;                          // 0x0070(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_33D6[0x3];                                     // 0x0071(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         MaxTrackedMissions;                                // 0x0074(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           MissionStarterGameplayTag;                         // 0x0078(0x0008)(Edit, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMap<int32, struct FGzPlayerMissionCacheEntry> PlayerMissionCache;                                // 0x0080(0x0050)(Transient, NativeAccessSpecifierPrivate)
	TMap<int32, class UGzMissionData*>            PlayerSelectedMissions;                            // 0x00D0(0x0050)(Transient, NativeAccessSpecifierPrivate)
	TArray<class AGzMission*>                     ActiveMissions;                                    // 0x0120(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	TMap<EGzMissionType, struct FGzPlayerMissionCacheEntry> ActiveMissionsByType;                              // 0x0130(0x0050)(Transient, NativeAccessSpecifierPrivate)
	TArray<class AGzMission*>                     TrackedMissions;                                   // 0x0180(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	class UGzMissionStarterSpawnParams*           MissionStarterSpawnParams;                         // 0x0190(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSet<class AGzMissionStarterSpawner*>         UnavailableMissionStarters;                        // 0x0198(0x0050)(Transient, NativeAccessSpecifierPrivate)
	class UGzMissionResourceSubsystem*            MissionResourceSubsystem;                          // 0x01E8(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_33D7[0x8];                                     // 0x01F0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UObject*>                        GarbageCollectionPreventionContainer;              // 0x01F8(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)

public:
	void CreateMission(class AActor* InstigatorContext, class UGzMissionData* MissionData, class UMissionRuntimeContext* RuntimeContext);
	void CreateSelectedMissionForPlayer(class AGzPlayerState* PlayerState);
	void CreateSelectedMissions();
	const TArray<class AGzMission*> GetActiveMissionsByType(EGzMissionType MissionType);
	void InitializeMissionStarters(class UGzMissionStarterSpawnParams* InMissionStarterSpawnParams);
	void OnLocalMissionStateChanged(class AGzMission* Mission, const struct FGzMissionState& OldState, const struct FGzMissionState& MissionState);
	void OnResourcesFiltered(const int32 StageIndex);
	void TrackMission(class AGzMission* InMission);
	void UntrackMission(class AGzMission* InMission);

	const TArray<class AGzMission*> GetActiveMissions() const;
	const TArray<class AGzMission*> GetTrackedMissions() const;
	bool HasMission(class AActor* ParticipantContext, const class UGzMissionData* MissionData) const;
	bool HasMissionOfSameType(class AActor* ParticipantContext, const class UGzMissionData* MissionData) const;
	bool IsEligibleForMission(class AActor* ParticipantContext, const class UGzMissionData* MissionData) const;
	bool IsMissionTracked(class AGzMission* InMission) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzMissionSubsystem">();
	}
	static class UGzMissionSubsystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzMissionSubsystem>();
	}
};
static_assert(alignof(UGzMissionSubsystem) == 0x000008, "Wrong alignment on UGzMissionSubsystem");
static_assert(sizeof(UGzMissionSubsystem) == 0x000208, "Wrong size on UGzMissionSubsystem");
static_assert(offsetof(UGzMissionSubsystem, OnMissionStateChanged) == 0x000030, "Member 'UGzMissionSubsystem::OnMissionStateChanged' has a wrong offset!");
static_assert(offsetof(UGzMissionSubsystem, OnMissionStarted) == 0x000040, "Member 'UGzMissionSubsystem::OnMissionStarted' has a wrong offset!");
static_assert(offsetof(UGzMissionSubsystem, OnMissionTrackedStateChanged) == 0x000050, "Member 'UGzMissionSubsystem::OnMissionTrackedStateChanged' has a wrong offset!");
static_assert(offsetof(UGzMissionSubsystem, OnActiveMissionsByTypeChanged) == 0x000060, "Member 'UGzMissionSubsystem::OnActiveMissionsByTypeChanged' has a wrong offset!");
static_assert(offsetof(UGzMissionSubsystem, bShouldAutoTrackMissions) == 0x000070, "Member 'UGzMissionSubsystem::bShouldAutoTrackMissions' has a wrong offset!");
static_assert(offsetof(UGzMissionSubsystem, MaxTrackedMissions) == 0x000074, "Member 'UGzMissionSubsystem::MaxTrackedMissions' has a wrong offset!");
static_assert(offsetof(UGzMissionSubsystem, MissionStarterGameplayTag) == 0x000078, "Member 'UGzMissionSubsystem::MissionStarterGameplayTag' has a wrong offset!");
static_assert(offsetof(UGzMissionSubsystem, PlayerMissionCache) == 0x000080, "Member 'UGzMissionSubsystem::PlayerMissionCache' has a wrong offset!");
static_assert(offsetof(UGzMissionSubsystem, PlayerSelectedMissions) == 0x0000D0, "Member 'UGzMissionSubsystem::PlayerSelectedMissions' has a wrong offset!");
static_assert(offsetof(UGzMissionSubsystem, ActiveMissions) == 0x000120, "Member 'UGzMissionSubsystem::ActiveMissions' has a wrong offset!");
static_assert(offsetof(UGzMissionSubsystem, ActiveMissionsByType) == 0x000130, "Member 'UGzMissionSubsystem::ActiveMissionsByType' has a wrong offset!");
static_assert(offsetof(UGzMissionSubsystem, TrackedMissions) == 0x000180, "Member 'UGzMissionSubsystem::TrackedMissions' has a wrong offset!");
static_assert(offsetof(UGzMissionSubsystem, MissionStarterSpawnParams) == 0x000190, "Member 'UGzMissionSubsystem::MissionStarterSpawnParams' has a wrong offset!");
static_assert(offsetof(UGzMissionSubsystem, UnavailableMissionStarters) == 0x000198, "Member 'UGzMissionSubsystem::UnavailableMissionStarters' has a wrong offset!");
static_assert(offsetof(UGzMissionSubsystem, MissionResourceSubsystem) == 0x0001E8, "Member 'UGzMissionSubsystem::MissionResourceSubsystem' has a wrong offset!");
static_assert(offsetof(UGzMissionSubsystem, GarbageCollectionPreventionContainer) == 0x0001F8, "Member 'UGzMissionSubsystem::GarbageCollectionPreventionContainer' has a wrong offset!");

// Class G01.GzMissionTargetInterface
// 0x0000 (0x0028 - 0x0028)
class IGzMissionTargetInterface final : public IInterface
{
public:
	class AActor* GetTargetActor() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzMissionTargetInterface">();
	}
	static class IGzMissionTargetInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IGzMissionTargetInterface>();
	}
};
static_assert(alignof(IGzMissionTargetInterface) == 0x000008, "Wrong alignment on IGzMissionTargetInterface");
static_assert(sizeof(IGzMissionTargetInterface) == 0x000028, "Wrong size on IGzMissionTargetInterface");

// Class G01.GzMissionTimeStatCollector
// 0x0050 (0x0088 - 0x0038)
class UGzMissionTimeStatCollector final : public UGzGlobalStatsCollector
{
public:
	TMap<class AGzMission*, float>                ActiveMissions;                                    // 0x0038(0x0050)(Transient, NativeAccessSpecifierPrivate)

public:
	void OnMissionStateChanged(class AGzMission* Mission, const struct FGzMissionState& OldState, const struct FGzMissionState& MissionState);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzMissionTimeStatCollector">();
	}
	static class UGzMissionTimeStatCollector* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzMissionTimeStatCollector>();
	}
};
static_assert(alignof(UGzMissionTimeStatCollector) == 0x000008, "Wrong alignment on UGzMissionTimeStatCollector");
static_assert(sizeof(UGzMissionTimeStatCollector) == 0x000088, "Wrong size on UGzMissionTimeStatCollector");
static_assert(offsetof(UGzMissionTimeStatCollector, ActiveMissions) == 0x000038, "Member 'UGzMissionTimeStatCollector::ActiveMissions' has a wrong offset!");

// Class G01.GzSoundStatics
// 0x0000 (0x0028 - 0x0028)
class UGzSoundStatics final : public UBlueprintFunctionLibrary
{
public:
	static TArray<class FName> GetAllSoundActionTypes();
	static TArray<class FName> GetAllSoundStatesKeys();
	static class UAkSwitchValue* GetEnvironmentZoneSwitch(class UGzEnvironmentZoneManagerComponent* EnvZoneManager, bool bUpdateZones);
	static class UAkSwitchValue* GetEnvironmentZoneSwitchForActor(const class AActor* Actor, bool bUpdateZones);
	static class UAkSwitchValue* GetEnvironmentZoneSwitchForLocation(const class UObject* WorldContext, const struct FVector& Location);
	static class UAkAudioEvent* GetEventForPhysicalMaterial(class UGzSurfaceTypeEvents* SurfaceTypeEvents, const class UPhysicalMaterial* PhysicalMaterial);
	static class UGzAudioControllerComponent* GetLocalAudioController(const class UObject* ContextObject);
	static class UGzLimbStepSoundsData* GetMovementSounds();
	static double GetSoundPlayDelayForLocalPlayer(class UObject* WorldContextObject, const struct FVector& SoundLocation);
	static void PostActionVoiceLineForTeam(class AGzPlayerState* Instigator, const struct FGameplayTag& Tag, bool bStarted);
	static void PostAkEventWithEnvZoneAtLocation(class UAkAudioEvent* Event, const struct FVector& Location, class UObject* WorldContext);
	static bool PostLocalAnnouncement(const class UObject* WorldContext, const struct FGameplayTag& AnnouncerTag, const struct FGameplayTag& VoiceLineTag, bool bStarted);
	static bool PostLocalAnnouncementAndWaitForEnd(const class UObject* WorldContext, const struct FGameplayTag& AnnouncerTag, const struct FGameplayTag& VoiceLineTag, bool bStarted, const TDelegate<void()>& AnnouncementEndDelegate);
	static bool PostLocalAnnouncementByData(const class UObject* WorldContext, const struct FGameplayTag& AnnouncerTag, const struct FGzPingVoiceLineData& Data);
	static bool PostLocalAnnouncementWithPriority(const class UObject* WorldContext, const struct FGameplayTag& AnnouncerTag, const struct FGameplayTag& VoiceLineTag, bool bStarted, int32 PriorityOverride, const TDelegate<void()>& AnnouncementEndDelegate);
	static void SetInGameSoundEnabled(bool bEnable, float InterpolationTimeMs);
	static void SetInGameSoundPercent(float Percent, float InterpolationTimeMs);
	static void SetSoundState(const struct FGzSoundStateKey& State, class AActor* ContextObject);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzSoundStatics">();
	}
	static class UGzSoundStatics* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzSoundStatics>();
	}
};
static_assert(alignof(UGzSoundStatics) == 0x000008, "Wrong alignment on UGzSoundStatics");
static_assert(sizeof(UGzSoundStatics) == 0x000028, "Wrong size on UGzSoundStatics");

// Class G01.GzModifiersPreset
// 0x0018 (0x0048 - 0x0030)
class UGzModifiersPreset final : public UDataAsset
{
public:
	uint8                                         Pad_33E7[0x8];                                     // 0x0030(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UGzCustomizationModifierTemplate*> ModifierTemplates;                                 // 0x0038(0x0010)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, ContainsInstancedReference, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzModifiersPreset">();
	}
	static class UGzModifiersPreset* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzModifiersPreset>();
	}
};
static_assert(alignof(UGzModifiersPreset) == 0x000008, "Wrong alignment on UGzModifiersPreset");
static_assert(sizeof(UGzModifiersPreset) == 0x000048, "Wrong size on UGzModifiersPreset");
static_assert(offsetof(UGzModifiersPreset, ModifierTemplates) == 0x000038, "Member 'UGzModifiersPreset::ModifierTemplates' has a wrong offset!");

// Class G01.GzModularEnvObject
// 0x0000 (0x02A0 - 0x02A0)
class AGzModularEnvObject : public AActor
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzModularEnvObject">();
	}
	static class AGzModularEnvObject* GetDefaultObj()
	{
		return GetDefaultObjImpl<AGzModularEnvObject>();
	}
};
static_assert(alignof(AGzModularEnvObject) == 0x000008, "Wrong alignment on AGzModularEnvObject");
static_assert(sizeof(AGzModularEnvObject) == 0x0002A0, "Wrong size on AGzModularEnvObject");

// Class G01.GzModularEnvSettings
// 0x0050 (0x0088 - 0x0038)
class UGzModularEnvSettings final : public UDeveloperSettings
{
public:
	TMap<struct FGameplayTag, struct FGzModularEnvObjectVisualVariations> AvailableMeshesForSlots;                           // 0x0038(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, Config, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzModularEnvSettings">();
	}
	static class UGzModularEnvSettings* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzModularEnvSettings>();
	}
};
static_assert(alignof(UGzModularEnvSettings) == 0x000008, "Wrong alignment on UGzModularEnvSettings");
static_assert(sizeof(UGzModularEnvSettings) == 0x000088, "Wrong size on UGzModularEnvSettings");
static_assert(offsetof(UGzModularEnvSettings, AvailableMeshesForSlots) == 0x000038, "Member 'UGzModularEnvSettings::AvailableMeshesForSlots' has a wrong offset!");

// Class G01.GzModularEnvStaticMeshComponent
// 0x0020 (0x0600 - 0x05E0)
class UGzModularEnvStaticMeshComponent final : public UStaticMeshComponent
{
public:
	struct FGameplayTag                           ModularitySlot;                                    // 0x05E0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 MeshSelector;                                      // 0x05E8(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_33E8[0x8];                                     // 0x05F8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	TArray<class FString> GetMeshSlotOptions() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzModularEnvStaticMeshComponent">();
	}
	static class UGzModularEnvStaticMeshComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzModularEnvStaticMeshComponent>();
	}
};
static_assert(alignof(UGzModularEnvStaticMeshComponent) == 0x000010, "Wrong alignment on UGzModularEnvStaticMeshComponent");
static_assert(sizeof(UGzModularEnvStaticMeshComponent) == 0x000600, "Wrong size on UGzModularEnvStaticMeshComponent");
static_assert(offsetof(UGzModularEnvStaticMeshComponent, ModularitySlot) == 0x0005E0, "Member 'UGzModularEnvStaticMeshComponent::ModularitySlot' has a wrong offset!");
static_assert(offsetof(UGzModularEnvStaticMeshComponent, MeshSelector) == 0x0005E8, "Member 'UGzModularEnvStaticMeshComponent::MeshSelector' has a wrong offset!");

// Class G01.GzSpectatorPawn
// 0x0008 (0x0358 - 0x0350)
class AGzSpectatorPawn : public ASpectatorPawn
{
public:
	class UGzPawnControlsComponent*               ControlsComponent;                                 // 0x0350(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void SpectateNextPlayer();
	void SpectatePrevPlayer();

	class APawn* GetSpectatedPawn() const;
	class AActor* GetSpectatedPlayer() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzSpectatorPawn">();
	}
	static class AGzSpectatorPawn* GetDefaultObj()
	{
		return GetDefaultObjImpl<AGzSpectatorPawn>();
	}
};
static_assert(alignof(AGzSpectatorPawn) == 0x000008, "Wrong alignment on AGzSpectatorPawn");
static_assert(sizeof(AGzSpectatorPawn) == 0x000358, "Wrong size on AGzSpectatorPawn");
static_assert(offsetof(AGzSpectatorPawn, ControlsComponent) == 0x000350, "Member 'AGzSpectatorPawn::ControlsComponent' has a wrong offset!");

// Class G01.GzMortarGroundTargetPreviewActor
// 0x0008 (0x02A8 - 0x02A0)
class AGzMortarGroundTargetPreviewActor : public AActor
{
public:
	uint8                                         Pad_33E9[0x8];                                     // 0x02A0(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void NetMulticast_ActivateWarning();
	void ShowProjectileWarnings();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzMortarGroundTargetPreviewActor">();
	}
	static class AGzMortarGroundTargetPreviewActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<AGzMortarGroundTargetPreviewActor>();
	}
};
static_assert(alignof(AGzMortarGroundTargetPreviewActor) == 0x000008, "Wrong alignment on AGzMortarGroundTargetPreviewActor");
static_assert(sizeof(AGzMortarGroundTargetPreviewActor) == 0x0002A8, "Wrong size on AGzMortarGroundTargetPreviewActor");

// Class G01.GzMortarLegsComponent
// 0x0078 (0x0168 - 0x00F0)
class UGzMortarLegsComponent : public UGzLimbAbilityComponent
{
public:
	FMulticastInlineDelegateProperty_             OnShowMapEvent;                                    // 0x00F0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	class FName                                   TabletSocketName;                                  // 0x0100(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftClassPtr<class UClass>                   TabletActorClass;                                  // 0x0108(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class AGzMortarTabletActor*                   TabletActor;                                       // 0x0130(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UGzAsyncTaskGameplayTagAddedRemoved*    ListenForMortarEventTags;                          // 0x0138(0x0008)(ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_33EA[0x28];                                    // 0x0140(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ApplyTabletInput_Horizontal(const float Value);
	void ApplyTabletInput_Vertical(const float Value);
	void CancelTargetSelection();
	void OnAssetsLoaded();
	void OnEventTagAdded(const struct FGameplayTag& Tag);
	void OnShowMap();
	void SelectMapTarget();

	bool IsTabletVisible() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzMortarLegsComponent">();
	}
	static class UGzMortarLegsComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzMortarLegsComponent>();
	}
};
static_assert(alignof(UGzMortarLegsComponent) == 0x000008, "Wrong alignment on UGzMortarLegsComponent");
static_assert(sizeof(UGzMortarLegsComponent) == 0x000168, "Wrong size on UGzMortarLegsComponent");
static_assert(offsetof(UGzMortarLegsComponent, OnShowMapEvent) == 0x0000F0, "Member 'UGzMortarLegsComponent::OnShowMapEvent' has a wrong offset!");
static_assert(offsetof(UGzMortarLegsComponent, TabletSocketName) == 0x000100, "Member 'UGzMortarLegsComponent::TabletSocketName' has a wrong offset!");
static_assert(offsetof(UGzMortarLegsComponent, TabletActorClass) == 0x000108, "Member 'UGzMortarLegsComponent::TabletActorClass' has a wrong offset!");
static_assert(offsetof(UGzMortarLegsComponent, TabletActor) == 0x000130, "Member 'UGzMortarLegsComponent::TabletActor' has a wrong offset!");
static_assert(offsetof(UGzMortarLegsComponent, ListenForMortarEventTags) == 0x000138, "Member 'UGzMortarLegsComponent::ListenForMortarEventTags' has a wrong offset!");

// Class G01.GzMortarLegs_MapScreen
// 0x01B8 (0x0498 - 0x02E0)
class UGzMortarLegs_MapScreen : public UUserWidget
{
public:
	FMulticastInlineDelegateProperty_             OnAllTargetsSelected;                              // 0x02E0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnLaunchClicked;                                   // 0x02F0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnCancelClicked;                                   // 0x0300(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	class UOverlay*                               MainBoxOverlay;                                    // 0x0310(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UUserWidget*                            TargetPreviewWidget;                               // 0x0318(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UGzBodyPartAbilityData_MortarLegs*      AbilityData;                                       // 0x0320(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UGzMortarLegs_MapScreenController*      MapController;                                     // 0x0328(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FHitResult                             ObstacleHitResult;                                 // 0x0330(0x00F8)(BlueprintVisible, BlueprintReadOnly, Transient, IsPlainOldData, NoDestructor, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	bool                                          bEnableSectorDecoration;                           // 0x0428(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_33EB[0x7];                                     // 0x0429(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UGzSectorAreaDecoration>    SectorDecorationClass;                             // 0x0430(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UMaterialInterface*                     ScanningMaterial;                                  // 0x0438(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UMaterialInstanceDynamic*               ScanningMaterialInstance;                          // 0x0440(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   ScanningProgressParameter;                         // 0x0448(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 ScanningImage;                                     // 0x0450(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bHasValidLocation;                                 // 0x0458(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_33EC[0x3];                                     // 0x0459(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         DistanceToTarget;                                  // 0x045C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         AngleToTarget;                                     // 0x0460(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_33ED[0x4];                                     // 0x0464(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UGzSectorAreaDecoration*                SectorAreaDecoration;                              // 0x0468(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_33EE[0x28];                                    // 0x0470(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AllTargetsSelected();
	class UGzMortarLegs_MapScreenController* CreateMapController();
	void GzMapButtonEvent__DelegateSignature();
	void HideMap();
	void OnMapReady();
	void ShowMap();

	const TArray<struct FVector2D> GetTargetLocations2D() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzMortarLegs_MapScreen">();
	}
	static class UGzMortarLegs_MapScreen* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzMortarLegs_MapScreen>();
	}
};
static_assert(alignof(UGzMortarLegs_MapScreen) == 0x000008, "Wrong alignment on UGzMortarLegs_MapScreen");
static_assert(sizeof(UGzMortarLegs_MapScreen) == 0x000498, "Wrong size on UGzMortarLegs_MapScreen");
static_assert(offsetof(UGzMortarLegs_MapScreen, OnAllTargetsSelected) == 0x0002E0, "Member 'UGzMortarLegs_MapScreen::OnAllTargetsSelected' has a wrong offset!");
static_assert(offsetof(UGzMortarLegs_MapScreen, OnLaunchClicked) == 0x0002F0, "Member 'UGzMortarLegs_MapScreen::OnLaunchClicked' has a wrong offset!");
static_assert(offsetof(UGzMortarLegs_MapScreen, OnCancelClicked) == 0x000300, "Member 'UGzMortarLegs_MapScreen::OnCancelClicked' has a wrong offset!");
static_assert(offsetof(UGzMortarLegs_MapScreen, MainBoxOverlay) == 0x000310, "Member 'UGzMortarLegs_MapScreen::MainBoxOverlay' has a wrong offset!");
static_assert(offsetof(UGzMortarLegs_MapScreen, TargetPreviewWidget) == 0x000318, "Member 'UGzMortarLegs_MapScreen::TargetPreviewWidget' has a wrong offset!");
static_assert(offsetof(UGzMortarLegs_MapScreen, AbilityData) == 0x000320, "Member 'UGzMortarLegs_MapScreen::AbilityData' has a wrong offset!");
static_assert(offsetof(UGzMortarLegs_MapScreen, MapController) == 0x000328, "Member 'UGzMortarLegs_MapScreen::MapController' has a wrong offset!");
static_assert(offsetof(UGzMortarLegs_MapScreen, ObstacleHitResult) == 0x000330, "Member 'UGzMortarLegs_MapScreen::ObstacleHitResult' has a wrong offset!");
static_assert(offsetof(UGzMortarLegs_MapScreen, bEnableSectorDecoration) == 0x000428, "Member 'UGzMortarLegs_MapScreen::bEnableSectorDecoration' has a wrong offset!");
static_assert(offsetof(UGzMortarLegs_MapScreen, SectorDecorationClass) == 0x000430, "Member 'UGzMortarLegs_MapScreen::SectorDecorationClass' has a wrong offset!");
static_assert(offsetof(UGzMortarLegs_MapScreen, ScanningMaterial) == 0x000438, "Member 'UGzMortarLegs_MapScreen::ScanningMaterial' has a wrong offset!");
static_assert(offsetof(UGzMortarLegs_MapScreen, ScanningMaterialInstance) == 0x000440, "Member 'UGzMortarLegs_MapScreen::ScanningMaterialInstance' has a wrong offset!");
static_assert(offsetof(UGzMortarLegs_MapScreen, ScanningProgressParameter) == 0x000448, "Member 'UGzMortarLegs_MapScreen::ScanningProgressParameter' has a wrong offset!");
static_assert(offsetof(UGzMortarLegs_MapScreen, ScanningImage) == 0x000450, "Member 'UGzMortarLegs_MapScreen::ScanningImage' has a wrong offset!");
static_assert(offsetof(UGzMortarLegs_MapScreen, bHasValidLocation) == 0x000458, "Member 'UGzMortarLegs_MapScreen::bHasValidLocation' has a wrong offset!");
static_assert(offsetof(UGzMortarLegs_MapScreen, DistanceToTarget) == 0x00045C, "Member 'UGzMortarLegs_MapScreen::DistanceToTarget' has a wrong offset!");
static_assert(offsetof(UGzMortarLegs_MapScreen, AngleToTarget) == 0x000460, "Member 'UGzMortarLegs_MapScreen::AngleToTarget' has a wrong offset!");
static_assert(offsetof(UGzMortarLegs_MapScreen, SectorAreaDecoration) == 0x000468, "Member 'UGzMortarLegs_MapScreen::SectorAreaDecoration' has a wrong offset!");

// Class G01.GzMortarLegs_MapScreenController
// 0x0068 (0x00C0 - 0x0058)
class UGzMortarLegs_MapScreenController : public UGzMapController
{
public:
	FMulticastInlineDelegateProperty_             OnAllTargetsSelected;                              // 0x0058(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnValidTargetSelected;                             // 0x0068(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnInvalidTargetSelected;                           // 0x0078(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	class UGzBodyPartAbilityData_MortarLegs*      AbilityData;                                       // 0x0088(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MapSafeZoneWidth;                                  // 0x0090(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MapRotationOffsetAngle;                            // 0x0094(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<struct FVector2D>                      MapTargetLocations2D;                              // 0x0098(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	struct FVector                                OwnerForwardVector;                                // 0x00A8(0x0018)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	bool AddTargetLocation(const struct FVector2D& WorldLocation2D);
	void OnHideMap();
	void OnShowMap();
	void UpdateMapTransform();

	struct FBox2D CalculateMapRectangle() const;
	const TArray<struct FVector2D> GetTargetLocations2D() const;
	bool IsValidTargetLocation(const struct FVector2D& WorldLocation2D) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzMortarLegs_MapScreenController">();
	}
	static class UGzMortarLegs_MapScreenController* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzMortarLegs_MapScreenController>();
	}
};
static_assert(alignof(UGzMortarLegs_MapScreenController) == 0x000008, "Wrong alignment on UGzMortarLegs_MapScreenController");
static_assert(sizeof(UGzMortarLegs_MapScreenController) == 0x0000C0, "Wrong size on UGzMortarLegs_MapScreenController");
static_assert(offsetof(UGzMortarLegs_MapScreenController, OnAllTargetsSelected) == 0x000058, "Member 'UGzMortarLegs_MapScreenController::OnAllTargetsSelected' has a wrong offset!");
static_assert(offsetof(UGzMortarLegs_MapScreenController, OnValidTargetSelected) == 0x000068, "Member 'UGzMortarLegs_MapScreenController::OnValidTargetSelected' has a wrong offset!");
static_assert(offsetof(UGzMortarLegs_MapScreenController, OnInvalidTargetSelected) == 0x000078, "Member 'UGzMortarLegs_MapScreenController::OnInvalidTargetSelected' has a wrong offset!");
static_assert(offsetof(UGzMortarLegs_MapScreenController, AbilityData) == 0x000088, "Member 'UGzMortarLegs_MapScreenController::AbilityData' has a wrong offset!");
static_assert(offsetof(UGzMortarLegs_MapScreenController, MapSafeZoneWidth) == 0x000090, "Member 'UGzMortarLegs_MapScreenController::MapSafeZoneWidth' has a wrong offset!");
static_assert(offsetof(UGzMortarLegs_MapScreenController, MapRotationOffsetAngle) == 0x000094, "Member 'UGzMortarLegs_MapScreenController::MapRotationOffsetAngle' has a wrong offset!");
static_assert(offsetof(UGzMortarLegs_MapScreenController, MapTargetLocations2D) == 0x000098, "Member 'UGzMortarLegs_MapScreenController::MapTargetLocations2D' has a wrong offset!");
static_assert(offsetof(UGzMortarLegs_MapScreenController, OwnerForwardVector) == 0x0000A8, "Member 'UGzMortarLegs_MapScreenController::OwnerForwardVector' has a wrong offset!");

// Class G01.GzSplineMapWidget
// 0x0050 (0x0340 - 0x02F0)
class UGzSplineMapWidget : public UGzMapDecoration
{
public:
	class USplineWidget*                          SplineWidget;                                      // 0x02F0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MaxSquareDistanceFromSpline;                       // 0x02F8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_33F1[0x4];                                     // 0x02FC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FVector2D>                      Points;                                            // 0x0300(0x0010)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_33F2[0x30];                                    // 0x0310(0x0030)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Init(class UGzMapWidget* InParentMap, const TArray<struct FVector>& WorldPoints, bool bInClosedLoop);
	void InitWith2DPoints(class UGzMapWidget* InParentMap, const TArray<struct FVector2D>& WorldPoints, bool bInClosedLoop);
	void InitWithSpline(class UGzMapWidget* InParentMap, class USplineComponent* InSpline, int32 InStart, int32 InEnd);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzSplineMapWidget">();
	}
	static class UGzSplineMapWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzSplineMapWidget>();
	}
};
static_assert(alignof(UGzSplineMapWidget) == 0x000008, "Wrong alignment on UGzSplineMapWidget");
static_assert(sizeof(UGzSplineMapWidget) == 0x000340, "Wrong size on UGzSplineMapWidget");
static_assert(offsetof(UGzSplineMapWidget, SplineWidget) == 0x0002F0, "Member 'UGzSplineMapWidget::SplineWidget' has a wrong offset!");
static_assert(offsetof(UGzSplineMapWidget, MaxSquareDistanceFromSpline) == 0x0002F8, "Member 'UGzSplineMapWidget::MaxSquareDistanceFromSpline' has a wrong offset!");
static_assert(offsetof(UGzSplineMapWidget, Points) == 0x000300, "Member 'UGzSplineMapWidget::Points' has a wrong offset!");

// Class G01.GzMortarPreviewPathActor
// 0x0078 (0x0508 - 0x0490)
class AGzMortarPreviewPathActor final : public AGzPreviewPathActor
{
public:
	bool                                          bDrawDebug;                                        // 0x0490(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_33F5[0x3];                                     // 0x0491(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MaxSimulationTime;                                 // 0x0494(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ProjectileRadius;                                  // 0x0498(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         AimingPitchAngle;                                  // 0x049C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         AimingPitchMin;                                    // 0x04A0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         AimingPitchMax;                                    // 0x04A4(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         AimingAllowedYawConeAngle;                         // 0x04A8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_33F6[0x4];                                     // 0x04AC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UStaticMeshComponent*                   AimingConeLimiterLeft;                             // 0x04B0(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UStaticMeshComponent*                   AimingConeLimiterRight;                            // 0x04B8(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_33F7[0x48];                                    // 0x04C0(0x0048)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzMortarPreviewPathActor">();
	}
	static class AGzMortarPreviewPathActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<AGzMortarPreviewPathActor>();
	}
};
static_assert(alignof(AGzMortarPreviewPathActor) == 0x000008, "Wrong alignment on AGzMortarPreviewPathActor");
static_assert(sizeof(AGzMortarPreviewPathActor) == 0x000508, "Wrong size on AGzMortarPreviewPathActor");
static_assert(offsetof(AGzMortarPreviewPathActor, bDrawDebug) == 0x000490, "Member 'AGzMortarPreviewPathActor::bDrawDebug' has a wrong offset!");
static_assert(offsetof(AGzMortarPreviewPathActor, MaxSimulationTime) == 0x000494, "Member 'AGzMortarPreviewPathActor::MaxSimulationTime' has a wrong offset!");
static_assert(offsetof(AGzMortarPreviewPathActor, ProjectileRadius) == 0x000498, "Member 'AGzMortarPreviewPathActor::ProjectileRadius' has a wrong offset!");
static_assert(offsetof(AGzMortarPreviewPathActor, AimingPitchAngle) == 0x00049C, "Member 'AGzMortarPreviewPathActor::AimingPitchAngle' has a wrong offset!");
static_assert(offsetof(AGzMortarPreviewPathActor, AimingPitchMin) == 0x0004A0, "Member 'AGzMortarPreviewPathActor::AimingPitchMin' has a wrong offset!");
static_assert(offsetof(AGzMortarPreviewPathActor, AimingPitchMax) == 0x0004A4, "Member 'AGzMortarPreviewPathActor::AimingPitchMax' has a wrong offset!");
static_assert(offsetof(AGzMortarPreviewPathActor, AimingAllowedYawConeAngle) == 0x0004A8, "Member 'AGzMortarPreviewPathActor::AimingAllowedYawConeAngle' has a wrong offset!");
static_assert(offsetof(AGzMortarPreviewPathActor, AimingConeLimiterLeft) == 0x0004B0, "Member 'AGzMortarPreviewPathActor::AimingConeLimiterLeft' has a wrong offset!");
static_assert(offsetof(AGzMortarPreviewPathActor, AimingConeLimiterRight) == 0x0004B8, "Member 'AGzMortarPreviewPathActor::AimingConeLimiterRight' has a wrong offset!");

// Class G01.GzMortarProjectile
// 0x0160 (0x04D8 - 0x0378)
class AGzMortarProjectile : public AGzProjectileGrenade
{
public:
	float                                         HideProjectileDelay;                               // 0x0378(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         DropOnTargetDelay;                                 // 0x037C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         DropOnTargetDelayVariation;                        // 0x0380(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         WarningDelay;                                      // 0x0384(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         DropHeight;                                        // 0x0388(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         DropSpeed;                                         // 0x038C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class AGzMortarGroundTargetPreviewActor> GroundTargetPreviewClass;                          // 0x0390(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class AGzMortarGroundTargetPreviewActor*> TargetWarningActors;                               // 0x0398(0x0010)(ZeroConstructor, Transient, Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	class AGzMortarGroundTargetPreviewActor*      TargetWarningActor;                                // 0x03A8(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UGzBodyPartAbilityData_MortarLegs*      AbilityData;                                       // 0x03B0(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_33F8[0x120];                                   // 0x03B8(0x0120)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void DropOverTarget();
	void HideProjectile();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzMortarProjectile">();
	}
	static class AGzMortarProjectile* GetDefaultObj()
	{
		return GetDefaultObjImpl<AGzMortarProjectile>();
	}
};
static_assert(alignof(AGzMortarProjectile) == 0x000008, "Wrong alignment on AGzMortarProjectile");
static_assert(sizeof(AGzMortarProjectile) == 0x0004D8, "Wrong size on AGzMortarProjectile");
static_assert(offsetof(AGzMortarProjectile, HideProjectileDelay) == 0x000378, "Member 'AGzMortarProjectile::HideProjectileDelay' has a wrong offset!");
static_assert(offsetof(AGzMortarProjectile, DropOnTargetDelay) == 0x00037C, "Member 'AGzMortarProjectile::DropOnTargetDelay' has a wrong offset!");
static_assert(offsetof(AGzMortarProjectile, DropOnTargetDelayVariation) == 0x000380, "Member 'AGzMortarProjectile::DropOnTargetDelayVariation' has a wrong offset!");
static_assert(offsetof(AGzMortarProjectile, WarningDelay) == 0x000384, "Member 'AGzMortarProjectile::WarningDelay' has a wrong offset!");
static_assert(offsetof(AGzMortarProjectile, DropHeight) == 0x000388, "Member 'AGzMortarProjectile::DropHeight' has a wrong offset!");
static_assert(offsetof(AGzMortarProjectile, DropSpeed) == 0x00038C, "Member 'AGzMortarProjectile::DropSpeed' has a wrong offset!");
static_assert(offsetof(AGzMortarProjectile, GroundTargetPreviewClass) == 0x000390, "Member 'AGzMortarProjectile::GroundTargetPreviewClass' has a wrong offset!");
static_assert(offsetof(AGzMortarProjectile, TargetWarningActors) == 0x000398, "Member 'AGzMortarProjectile::TargetWarningActors' has a wrong offset!");
static_assert(offsetof(AGzMortarProjectile, TargetWarningActor) == 0x0003A8, "Member 'AGzMortarProjectile::TargetWarningActor' has a wrong offset!");
static_assert(offsetof(AGzMortarProjectile, AbilityData) == 0x0003B0, "Member 'AGzMortarProjectile::AbilityData' has a wrong offset!");

// Class G01.GzPoseableSkeletalMeshComponent
// 0x0170 (0x10E0 - 0x0F70)
class UGzPoseableSkeletalMeshComponent final : public USkeletalMeshComponent
{
public:
	uint8                                         Pad_33F9[0x178];                                   // 0x0F68(0x0178)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void CopyPoseFromSkeletalComponent(class USkeletalMeshComponent* InComponentToCopy);
	struct FVector GetBoneLocationByName(class FName BoneName, EBoneSpaces BoneSpace);
	struct FRotator GetBoneRotationByName(class FName BoneName, EBoneSpaces BoneSpace);
	struct FVector GetBoneScaleByName(class FName BoneName, EBoneSpaces BoneSpace);
	struct FTransform GetBoneTransformByName(class FName BoneName, EBoneSpaces BoneSpace);
	void ResetBoneTransformByName(class FName BoneName);
	void SetBoneLocationAndQuatByName(class FName BoneName, const struct FVector& InLocation, const struct FQuat& InQuat, EBoneSpaces BoneSpace);
	void SetBoneLocationByName(class FName BoneName, const struct FVector& InLocation, EBoneSpaces BoneSpace);
	void SetBoneRotationByName(class FName BoneName, const struct FRotator& InRotation, EBoneSpaces BoneSpace);
	void SetBoneScaleByName(class FName BoneName, const struct FVector& InScale3D, EBoneSpaces BoneSpace);
	void SetBoneTransformByName(class FName BoneName, const struct FTransform& InTransform, EBoneSpaces BoneSpace);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzPoseableSkeletalMeshComponent">();
	}
	static class UGzPoseableSkeletalMeshComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzPoseableSkeletalMeshComponent>();
	}
};
static_assert(alignof(UGzPoseableSkeletalMeshComponent) == 0x000010, "Wrong alignment on UGzPoseableSkeletalMeshComponent");
static_assert(sizeof(UGzPoseableSkeletalMeshComponent) == 0x0010E0, "Wrong size on UGzPoseableSkeletalMeshComponent");

// Class G01.GzMovableMapController
// 0x0188 (0x01E0 - 0x0058)
class UGzMovableMapController : public UGzMapController
{
public:
	float                                         PanSpeed;                                          // 0x0058(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bInversePan;                                       // 0x005C(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3404[0x3];                                     // 0x005D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         PanSlowDownInterpolationSpeed;                     // 0x0060(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bEnableZoomLevels;                                 // 0x0064(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3405[0x3];                                     // 0x0065(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FGzZoomLevelSettings>           ZoomLevelsSettings;                                // 0x0068(0x0010)(Edit, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	struct FGzZoomLevelSettings                   DefaultZoomSettings;                               // 0x0078(0x0008)(Edit, NoDestructor, Protected, NativeAccessSpecifierProtected)
	int32                                         InitialZoomLevel;                                  // 0x0080(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bEnableDebugZoom;                                  // 0x0084(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3406[0x3];                                     // 0x0085(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         TargetZoom;                                        // 0x0088(0x0004)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         PreviousZoomLevel;                                 // 0x008C(0x0004)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         TargetZoomLevel;                                   // 0x0090(0x0004)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3407[0x4];                                     // 0x0094(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class AActor*                                 TrackingTarget;                                    // 0x0098(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UCommonInputSubsystem*                  CommonInputSubsystem;                              // 0x00A0(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_3408[0xE0];                                    // 0x00A8(0x00E0)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         CursorModeSnappingSpeed;                           // 0x0188(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         PanningModeSnappingSpeed;                          // 0x018C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         SnapNavigationAngle;                               // 0x0190(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         SnapNavigationRadius;                              // 0x0194(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         SnappingDelay;                                     // 0x0198(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_3409[0x4];                                     // 0x019C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UUserWidget*                            WidgetToSnap;                                      // 0x01A0(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUserWidget*                            PredictedWidgetToSnap;                             // 0x01A8(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UGzMarkerComponent*                     ComponentToSnap;                                   // 0x01B0(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UGzMarkerComponent*                     PredictedComponentToSnap;                          // 0x01B8(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FVector2D                              CursorModeMaxMapOffset;                            // 0x01C0(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FVector2D                              PanningModeMaxMapOffset;                           // 0x01D0(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	bool AreZoomLevelsEnabled();
	float GetTargetZoomLevel(int32 ZoomLevelIndex);
	int32 GetZoomLevelsCount();
	void OnAnalogValueChanged(const struct FAnalogInputEvent& InKeyEvent);
	void OnKeyDown(const struct FKeyEvent& InKeyEvent);
	struct FEventReply OnMouseButtonDown(const struct FGeometry& MyGeometry, const struct FPointerEvent& MouseEvent);
	void OnMouseLeave(const struct FPointerEvent& InMouseEvent);
	void OnMouseWheel(const struct FPointerEvent& InMouseEvent);
	void SetTrackingTarget(class AActor* Target);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzMovableMapController">();
	}
	static class UGzMovableMapController* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzMovableMapController>();
	}
};
static_assert(alignof(UGzMovableMapController) == 0x000008, "Wrong alignment on UGzMovableMapController");
static_assert(sizeof(UGzMovableMapController) == 0x0001E0, "Wrong size on UGzMovableMapController");
static_assert(offsetof(UGzMovableMapController, PanSpeed) == 0x000058, "Member 'UGzMovableMapController::PanSpeed' has a wrong offset!");
static_assert(offsetof(UGzMovableMapController, bInversePan) == 0x00005C, "Member 'UGzMovableMapController::bInversePan' has a wrong offset!");
static_assert(offsetof(UGzMovableMapController, PanSlowDownInterpolationSpeed) == 0x000060, "Member 'UGzMovableMapController::PanSlowDownInterpolationSpeed' has a wrong offset!");
static_assert(offsetof(UGzMovableMapController, bEnableZoomLevels) == 0x000064, "Member 'UGzMovableMapController::bEnableZoomLevels' has a wrong offset!");
static_assert(offsetof(UGzMovableMapController, ZoomLevelsSettings) == 0x000068, "Member 'UGzMovableMapController::ZoomLevelsSettings' has a wrong offset!");
static_assert(offsetof(UGzMovableMapController, DefaultZoomSettings) == 0x000078, "Member 'UGzMovableMapController::DefaultZoomSettings' has a wrong offset!");
static_assert(offsetof(UGzMovableMapController, InitialZoomLevel) == 0x000080, "Member 'UGzMovableMapController::InitialZoomLevel' has a wrong offset!");
static_assert(offsetof(UGzMovableMapController, bEnableDebugZoom) == 0x000084, "Member 'UGzMovableMapController::bEnableDebugZoom' has a wrong offset!");
static_assert(offsetof(UGzMovableMapController, TargetZoom) == 0x000088, "Member 'UGzMovableMapController::TargetZoom' has a wrong offset!");
static_assert(offsetof(UGzMovableMapController, PreviousZoomLevel) == 0x00008C, "Member 'UGzMovableMapController::PreviousZoomLevel' has a wrong offset!");
static_assert(offsetof(UGzMovableMapController, TargetZoomLevel) == 0x000090, "Member 'UGzMovableMapController::TargetZoomLevel' has a wrong offset!");
static_assert(offsetof(UGzMovableMapController, TrackingTarget) == 0x000098, "Member 'UGzMovableMapController::TrackingTarget' has a wrong offset!");
static_assert(offsetof(UGzMovableMapController, CommonInputSubsystem) == 0x0000A0, "Member 'UGzMovableMapController::CommonInputSubsystem' has a wrong offset!");
static_assert(offsetof(UGzMovableMapController, CursorModeSnappingSpeed) == 0x000188, "Member 'UGzMovableMapController::CursorModeSnappingSpeed' has a wrong offset!");
static_assert(offsetof(UGzMovableMapController, PanningModeSnappingSpeed) == 0x00018C, "Member 'UGzMovableMapController::PanningModeSnappingSpeed' has a wrong offset!");
static_assert(offsetof(UGzMovableMapController, SnapNavigationAngle) == 0x000190, "Member 'UGzMovableMapController::SnapNavigationAngle' has a wrong offset!");
static_assert(offsetof(UGzMovableMapController, SnapNavigationRadius) == 0x000194, "Member 'UGzMovableMapController::SnapNavigationRadius' has a wrong offset!");
static_assert(offsetof(UGzMovableMapController, SnappingDelay) == 0x000198, "Member 'UGzMovableMapController::SnappingDelay' has a wrong offset!");
static_assert(offsetof(UGzMovableMapController, WidgetToSnap) == 0x0001A0, "Member 'UGzMovableMapController::WidgetToSnap' has a wrong offset!");
static_assert(offsetof(UGzMovableMapController, PredictedWidgetToSnap) == 0x0001A8, "Member 'UGzMovableMapController::PredictedWidgetToSnap' has a wrong offset!");
static_assert(offsetof(UGzMovableMapController, ComponentToSnap) == 0x0001B0, "Member 'UGzMovableMapController::ComponentToSnap' has a wrong offset!");
static_assert(offsetof(UGzMovableMapController, PredictedComponentToSnap) == 0x0001B8, "Member 'UGzMovableMapController::PredictedComponentToSnap' has a wrong offset!");
static_assert(offsetof(UGzMovableMapController, CursorModeMaxMapOffset) == 0x0001C0, "Member 'UGzMovableMapController::CursorModeMaxMapOffset' has a wrong offset!");
static_assert(offsetof(UGzMovableMapController, PanningModeMaxMapOffset) == 0x0001D0, "Member 'UGzMovableMapController::PanningModeMaxMapOffset' has a wrong offset!");

// Class G01.Gz_BTTask_GetRandomLocation
// 0x0010 (0x00A8 - 0x0098)
class UGz_BTTask_GetRandomLocation final : public UBTTask_BlackboardBase
{
public:
	float                                         MaxDistance;                                       // 0x0098(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_340A[0x4];                                     // 0x009C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UNavigationQueryFilter>     Filter;                                            // 0x00A0(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Gz_BTTask_GetRandomLocation">();
	}
	static class UGz_BTTask_GetRandomLocation* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGz_BTTask_GetRandomLocation>();
	}
};
static_assert(alignof(UGz_BTTask_GetRandomLocation) == 0x000008, "Wrong alignment on UGz_BTTask_GetRandomLocation");
static_assert(sizeof(UGz_BTTask_GetRandomLocation) == 0x0000A8, "Wrong size on UGz_BTTask_GetRandomLocation");
static_assert(offsetof(UGz_BTTask_GetRandomLocation, MaxDistance) == 0x000098, "Member 'UGz_BTTask_GetRandomLocation::MaxDistance' has a wrong offset!");
static_assert(offsetof(UGz_BTTask_GetRandomLocation, Filter) == 0x0000A0, "Member 'UGz_BTTask_GetRandomLocation::Filter' has a wrong offset!");

// Class G01.GzMovementActionSettings
// 0x0050 (0x0088 - 0x0038)
class UGzMovementActionSettings final : public UDeveloperSettings
{
public:
	TMap<EGzMovementAction, struct FGzMovementActionData> MovementActionsMapping;                            // 0x0038(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, Config, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzMovementActionSettings">();
	}
	static class UGzMovementActionSettings* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzMovementActionSettings>();
	}
};
static_assert(alignof(UGzMovementActionSettings) == 0x000008, "Wrong alignment on UGzMovementActionSettings");
static_assert(sizeof(UGzMovementActionSettings) == 0x000088, "Wrong size on UGzMovementActionSettings");
static_assert(offsetof(UGzMovementActionSettings, MovementActionsMapping) == 0x000038, "Member 'UGzMovementActionSettings::MovementActionsMapping' has a wrong offset!");

// Class G01.GzMovementManagerData
// 0x0050 (0x0080 - 0x0030)
class UGzMovementManagerData final : public UDataAsset
{
public:
	TMap<struct FGzLocomotionState, struct FGzMovementManagerLocomotionState> StateDescription;                                  // 0x0030(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzMovementManagerData">();
	}
	static class UGzMovementManagerData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzMovementManagerData>();
	}
};
static_assert(alignof(UGzMovementManagerData) == 0x000008, "Wrong alignment on UGzMovementManagerData");
static_assert(sizeof(UGzMovementManagerData) == 0x000080, "Wrong size on UGzMovementManagerData");
static_assert(offsetof(UGzMovementManagerData, StateDescription) == 0x000030, "Member 'UGzMovementManagerData::StateDescription' has a wrong offset!");

// Class G01.GzMovementManager
// 0x0030 (0x0058 - 0x0028)
class UGzMovementManager : public UObject
{
public:
	class UGzMovementManagerData*                 Data;                                              // 0x0028(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_340B[0x28];                                    // 0x0030(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzMovementManager">();
	}
	static class UGzMovementManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzMovementManager>();
	}
};
static_assert(alignof(UGzMovementManager) == 0x000008, "Wrong alignment on UGzMovementManager");
static_assert(sizeof(UGzMovementManager) == 0x000058, "Wrong size on UGzMovementManager");
static_assert(offsetof(UGzMovementManager, Data) == 0x000028, "Member 'UGzMovementManager::Data' has a wrong offset!");

// Class G01.GzPostMatchModel
// 0x0080 (0x00F0 - 0x0070)
class UGzPostMatchModel final : public UGzBackendModel
{
public:
	uint8                                         Pad_340C[0x20];                                    // 0x0070(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGzCohtmlMatchResult                   CohtmlMatchResult;                                 // 0x0090(0x0060)(NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzPostMatchModel">();
	}
	static class UGzPostMatchModel* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzPostMatchModel>();
	}
};
static_assert(alignof(UGzPostMatchModel) == 0x000008, "Wrong alignment on UGzPostMatchModel");
static_assert(sizeof(UGzPostMatchModel) == 0x0000F0, "Wrong size on UGzPostMatchModel");
static_assert(offsetof(UGzPostMatchModel, CohtmlMatchResult) == 0x000090, "Member 'UGzPostMatchModel::CohtmlMatchResult' has a wrong offset!");

// Class G01.GzMovementSettings
// 0x0010 (0x0048 - 0x0038)
class UGzMovementSettings final : public UDeveloperSettingsBackedByCVars
{
public:
	float                                         TimeInFlyingBeforeSwitchingMovementMode;           // 0x0038(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEnableAutoMantle;                                 // 0x003C(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_340D[0x3];                                     // 0x003D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         AutoMantleCheckInterval;                           // 0x0040(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EGzSweepMoveOnSimulated                       SweepMoveOnSimulated;                              // 0x0044(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_340E[0x3];                                     // 0x0045(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzMovementSettings">();
	}
	static class UGzMovementSettings* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzMovementSettings>();
	}
};
static_assert(alignof(UGzMovementSettings) == 0x000008, "Wrong alignment on UGzMovementSettings");
static_assert(sizeof(UGzMovementSettings) == 0x000048, "Wrong size on UGzMovementSettings");
static_assert(offsetof(UGzMovementSettings, TimeInFlyingBeforeSwitchingMovementMode) == 0x000038, "Member 'UGzMovementSettings::TimeInFlyingBeforeSwitchingMovementMode' has a wrong offset!");
static_assert(offsetof(UGzMovementSettings, bEnableAutoMantle) == 0x00003C, "Member 'UGzMovementSettings::bEnableAutoMantle' has a wrong offset!");
static_assert(offsetof(UGzMovementSettings, AutoMantleCheckInterval) == 0x000040, "Member 'UGzMovementSettings::AutoMantleCheckInterval' has a wrong offset!");
static_assert(offsetof(UGzMovementSettings, SweepMoveOnSimulated) == 0x000044, "Member 'UGzMovementSettings::SweepMoveOnSimulated' has a wrong offset!");

// Class G01.GzMovementSoundComponent
// 0x0070 (0x0118 - 0x00A8)
class UGzMovementSoundComponent final : public UActorComponent
{
public:
	class UAkRtpc*                                MovementSpeedRtpc;                                 // 0x00A8(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAkRtpc*                                ZiplineDistanceLeftRtpc;                           // 0x00B0(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAkComponent*                           CachedAkComponent;                                 // 0x00B8(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_340F[0x54];                                    // 0x00C0(0x0054)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bSpeedSoundEnabled;                                // 0x0114(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3410[0x3];                                     // 0x0115(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnCustomizationChanged(const struct FGzCharacterCustomizationProfile& NewCustomizationProfile);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzMovementSoundComponent">();
	}
	static class UGzMovementSoundComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzMovementSoundComponent>();
	}
};
static_assert(alignof(UGzMovementSoundComponent) == 0x000008, "Wrong alignment on UGzMovementSoundComponent");
static_assert(sizeof(UGzMovementSoundComponent) == 0x000118, "Wrong size on UGzMovementSoundComponent");
static_assert(offsetof(UGzMovementSoundComponent, MovementSpeedRtpc) == 0x0000A8, "Member 'UGzMovementSoundComponent::MovementSpeedRtpc' has a wrong offset!");
static_assert(offsetof(UGzMovementSoundComponent, ZiplineDistanceLeftRtpc) == 0x0000B0, "Member 'UGzMovementSoundComponent::ZiplineDistanceLeftRtpc' has a wrong offset!");
static_assert(offsetof(UGzMovementSoundComponent, CachedAkComponent) == 0x0000B8, "Member 'UGzMovementSoundComponent::CachedAkComponent' has a wrong offset!");
static_assert(offsetof(UGzMovementSoundComponent, bSpeedSoundEnabled) == 0x000114, "Member 'UGzMovementSoundComponent::bSpeedSoundEnabled' has a wrong offset!");

// Class G01.GzPostProcessControllerComponent
// 0x0060 (0x0108 - 0x00A8)
class UGzPostProcessControllerComponent final : public UControllerComponent
{
public:
	class UGzPostProcessConfigs*                  PostProcessData;                                   // 0x00A8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class APawn*                                  CurrentViewTarget;                                 // 0x00B0(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSet<class UGzPostProcessFX*>                 ActiveFXBlending;                                  // 0x00B8(0x0050)(Transient, NativeAccessSpecifierPrivate)

public:
	class UGzPostProcessFX* AddPostProcessBlend(TSubclassOf<class UGzPostProcessFX> FXClass);
	class UGzPostProcessFX* AddPostProcessInstance(class UGzPostProcessFX* NewFX);
	void OnViewTargetChanged(class APawn* NewPawn);
	void RemovePostProcess(class UGzPostProcessFX* PostProcessFX);

	class UGzCameraComponent* GetViewTargetCameraComponent() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzPostProcessControllerComponent">();
	}
	static class UGzPostProcessControllerComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzPostProcessControllerComponent>();
	}
};
static_assert(alignof(UGzPostProcessControllerComponent) == 0x000008, "Wrong alignment on UGzPostProcessControllerComponent");
static_assert(sizeof(UGzPostProcessControllerComponent) == 0x000108, "Wrong size on UGzPostProcessControllerComponent");
static_assert(offsetof(UGzPostProcessControllerComponent, PostProcessData) == 0x0000A8, "Member 'UGzPostProcessControllerComponent::PostProcessData' has a wrong offset!");
static_assert(offsetof(UGzPostProcessControllerComponent, CurrentViewTarget) == 0x0000B0, "Member 'UGzPostProcessControllerComponent::CurrentViewTarget' has a wrong offset!");
static_assert(offsetof(UGzPostProcessControllerComponent, ActiveFXBlending) == 0x0000B8, "Member 'UGzPostProcessControllerComponent::ActiveFXBlending' has a wrong offset!");

// Class G01.GzLocomotionStatics
// 0x0000 (0x0028 - 0x0028)
class UGzLocomotionStatics final : public UBlueprintFunctionLibrary
{
public:
	static void BreakLocomotionCurrentStates(const struct FLocomotionCurrentStates& Parameters, EMovementMode* PawnMovementMode, ELocomotionMovementState* MovementState, ELocomotionMovementState* PrevMovementState, ELocomotionMovementAction* MovementAction, ELocomotionRotationMode* RotationMode, ELocomotionGait* ActualGait, ELocomotionStance* ActualStance, ELocomotionViewMode* ViewMode, ELocomotionOverlayState* OverlayState);
	static void BreakLocomotionEssentialValues(const struct FLocomotionEssentialValues& Parameters, struct FVector* Velocity, struct FVector* Acceleration, struct FVector* MovementInput, bool* bIsMoving, bool* bHasMovementInput, float* Speed, float* MovementInputAmount, struct FRotator* AimingRotation, float* AimYawRate);
	static TArray<class UAnimMetaData*> GetAllAnimMetaData(class UAnimationAsset* Animation);
	static class UGzTraversalAnimMetaData* GetAnimMetaDataByClass(class UAnimationAsset* Animation, TSubclassOf<class UGzTraversalAnimMetaData> MetaDataClass);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzLocomotionStatics">();
	}
	static class UGzLocomotionStatics* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzLocomotionStatics>();
	}
};
static_assert(alignof(UGzLocomotionStatics) == 0x000008, "Wrong alignment on UGzLocomotionStatics");
static_assert(sizeof(UGzLocomotionStatics) == 0x000028, "Wrong size on UGzLocomotionStatics");

// Class G01.GzMTW_Condition
// 0x0018 (0x0310 - 0x02F8)
class UGzMTW_Condition final : public UGzMTW_Base
{
public:
	int32                                         PlayerId;                                          // 0x02F8(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3414[0x4];                                     // 0x02FC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UGzGameplayCondition*                   Condition;                                         // 0x0300(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3415[0x8];                                     // 0x0308(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnConditionStateChanged(EGzConditionState NewState);
	void OnStateChanged_BP(EGzConditionState NewState);

	EGzConditionState GetConditionState() const;
	bool IsInActiveState(EGzConditionState State) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzMTW_Condition">();
	}
	static class UGzMTW_Condition* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzMTW_Condition>();
	}
};
static_assert(alignof(UGzMTW_Condition) == 0x000008, "Wrong alignment on UGzMTW_Condition");
static_assert(sizeof(UGzMTW_Condition) == 0x000310, "Wrong size on UGzMTW_Condition");
static_assert(offsetof(UGzMTW_Condition, PlayerId) == 0x0002F8, "Member 'UGzMTW_Condition::PlayerId' has a wrong offset!");
static_assert(offsetof(UGzMTW_Condition, Condition) == 0x000300, "Member 'UGzMTW_Condition::Condition' has a wrong offset!");

// Class G01.GzMTW_Container
// 0x0010 (0x0308 - 0x02F8)
class UGzMTW_Container final : public UGzMTW_Base
{
public:
	TArray<class UGzMTW_Base*>                    ChildWidgets;                                      // 0x02F8(0x0010)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)

public:
	void OnChildStateChanged(bool bNewActive);
	void OnInitContainer();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzMTW_Container">();
	}
	static class UGzMTW_Container* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzMTW_Container>();
	}
};
static_assert(alignof(UGzMTW_Container) == 0x000008, "Wrong alignment on UGzMTW_Container");
static_assert(sizeof(UGzMTW_Container) == 0x000308, "Wrong size on UGzMTW_Container");
static_assert(offsetof(UGzMTW_Container, ChildWidgets) == 0x0002F8, "Member 'UGzMTW_Container::ChildWidgets' has a wrong offset!");

// Class G01.GzMTW_Decorator
// 0x0008 (0x0300 - 0x02F8)
class UGzMTW_Decorator : public UGzMTW_Base
{
public:
	class UGzMTW_Base*                            ChildWidget;                                       // 0x02F8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void OnChildStateChanged(bool bNewActive);
	void OnInitDecorator();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzMTW_Decorator">();
	}
	static class UGzMTW_Decorator* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzMTW_Decorator>();
	}
};
static_assert(alignof(UGzMTW_Decorator) == 0x000008, "Wrong alignment on UGzMTW_Decorator");
static_assert(sizeof(UGzMTW_Decorator) == 0x000300, "Wrong size on UGzMTW_Decorator");
static_assert(offsetof(UGzMTW_Decorator, ChildWidget) == 0x0002F8, "Member 'UGzMTW_Decorator::ChildWidget' has a wrong offset!");

// Class G01.GzPredefinedLootChooserComponent
// 0x0020 (0x00C8 - 0x00A8)
class UGzPredefinedLootChooserComponent final : public UGzLootChooserComponent
{
public:
	TArray<struct FGzInventoryItemContent>        ItemContents;                                      // 0x00A8(0x0010)(Edit, BlueprintVisible, ZeroConstructor, EditConst, Protected, NativeAccessSpecifierProtected)
	TArray<struct FGzInvItem>                     Items;                                             // 0x00B8(0x0010)(Edit, BlueprintVisible, ZeroConstructor, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzPredefinedLootChooserComponent">();
	}
	static class UGzPredefinedLootChooserComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzPredefinedLootChooserComponent>();
	}
};
static_assert(alignof(UGzPredefinedLootChooserComponent) == 0x000008, "Wrong alignment on UGzPredefinedLootChooserComponent");
static_assert(sizeof(UGzPredefinedLootChooserComponent) == 0x0000C8, "Wrong size on UGzPredefinedLootChooserComponent");
static_assert(offsetof(UGzPredefinedLootChooserComponent, ItemContents) == 0x0000A8, "Member 'UGzPredefinedLootChooserComponent::ItemContents' has a wrong offset!");
static_assert(offsetof(UGzPredefinedLootChooserComponent, Items) == 0x0000B8, "Member 'UGzPredefinedLootChooserComponent::Items' has a wrong offset!");

// Class G01.GzMTW_Objective
// 0x0010 (0x0308 - 0x02F8)
class UGzMTW_Objective final : public UGzMTW_Base
{
public:
	class UGzGameplayObjective*                   Objective;                                         // 0x02F8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3416[0x8];                                     // 0x0300(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnObjectiveStateChanged(EGzObjectiveState NewState);
	void OnStateChanged_BP(EGzObjectiveState NewState);

	EGzObjectiveState GetObjectiveState() const;
	bool IsInActiveState(EGzObjectiveState State) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzMTW_Objective">();
	}
	static class UGzMTW_Objective* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzMTW_Objective>();
	}
};
static_assert(alignof(UGzMTW_Objective) == 0x000008, "Wrong alignment on UGzMTW_Objective");
static_assert(sizeof(UGzMTW_Objective) == 0x000308, "Wrong size on UGzMTW_Objective");
static_assert(offsetof(UGzMTW_Objective, Objective) == 0x0002F8, "Member 'UGzMTW_Objective::Objective' has a wrong offset!");

// Class G01.GzMTW_Stage
// 0x0010 (0x0310 - 0x0300)
class UGzMTW_Stage final : public UGzMTW_Decorator
{
public:
	class FText                                   Description;                                       // 0x0300(0x0010)(BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzMTW_Stage">();
	}
	static class UGzMTW_Stage* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzMTW_Stage>();
	}
};
static_assert(alignof(UGzMTW_Stage) == 0x000008, "Wrong alignment on UGzMTW_Stage");
static_assert(sizeof(UGzMTW_Stage) == 0x000310, "Wrong size on UGzMTW_Stage");
static_assert(offsetof(UGzMTW_Stage, Description) == 0x000300, "Member 'UGzMTW_Stage::Description' has a wrong offset!");

// Class G01.LocomotionAnimationInterface
// 0x0000 (0x0028 - 0x0028)
class ILocomotionAnimationInterface final : public IInterface
{
public:
	void OnJumped();
	void OnReachedJumpApex();
	void OnShotPerformed();
	void SetGroundedEntryState(ELocomotionGroundedEntryState EntryState);
	void SetOverlayOverrideState(int32 OverlayOverride);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LocomotionAnimationInterface">();
	}
	static class ILocomotionAnimationInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<ILocomotionAnimationInterface>();
	}
};
static_assert(alignof(ILocomotionAnimationInterface) == 0x000008, "Wrong alignment on ILocomotionAnimationInterface");
static_assert(sizeof(ILocomotionAnimationInterface) == 0x000028, "Wrong size on ILocomotionAnimationInterface");

// Class G01.GzMultiClientEventGateway
// 0x0108 (0x0150 - 0x0048)
class alignas(0x10) UGzMultiClientEventGateway final : public UGzMetaEventGateway
{
public:
	TMap<class FString, class FString>            PlayFabIdEndpoints;                                // 0x0048(0x0050)(NativeAccessSpecifierPrivate)
	uint8                                         Pad_3417[0xB8];                                    // 0x0098(0x00B8)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzMultiClientEventGateway">();
	}
	static class UGzMultiClientEventGateway* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzMultiClientEventGateway>();
	}
};
static_assert(alignof(UGzMultiClientEventGateway) == 0x000010, "Wrong alignment on UGzMultiClientEventGateway");
static_assert(sizeof(UGzMultiClientEventGateway) == 0x000150, "Wrong size on UGzMultiClientEventGateway");
static_assert(offsetof(UGzMultiClientEventGateway, PlayFabIdEndpoints) == 0x000048, "Member 'UGzMultiClientEventGateway::PlayFabIdEndpoints' has a wrong offset!");

// Class G01.GzRevivalsStatCollector
// 0x0008 (0x0040 - 0x0038)
class UGzRevivalsStatCollector final : public UGzGlobalStatsCollector
{
public:
	uint8                                         Pad_3418[0x8];                                     // 0x0038(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzRevivalsStatCollector">();
	}
	static class UGzRevivalsStatCollector* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzRevivalsStatCollector>();
	}
};
static_assert(alignof(UGzRevivalsStatCollector) == 0x000008, "Wrong alignment on UGzRevivalsStatCollector");
static_assert(sizeof(UGzRevivalsStatCollector) == 0x000040, "Wrong size on UGzRevivalsStatCollector");

// Class G01.GzMultiPartCharacterMovementComponent
// 0x0010 (0x1BC0 - 0x1BB0)
class UGzMultiPartCharacterMovementComponent final : public UGzCharacterMovementComponent
{
public:
	class AGzMultiPartCharacter*                  MultiPartCharacter;                                // 0x1BB0(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3419[0x8];                                     // 0x1BB8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzMultiPartCharacterMovementComponent">();
	}
	static class UGzMultiPartCharacterMovementComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzMultiPartCharacterMovementComponent>();
	}
};
static_assert(alignof(UGzMultiPartCharacterMovementComponent) == 0x000010, "Wrong alignment on UGzMultiPartCharacterMovementComponent");
static_assert(sizeof(UGzMultiPartCharacterMovementComponent) == 0x001BC0, "Wrong size on UGzMultiPartCharacterMovementComponent");
static_assert(offsetof(UGzMultiPartCharacterMovementComponent, MultiPartCharacter) == 0x001BB0, "Member 'UGzMultiPartCharacterMovementComponent::MultiPartCharacter' has a wrong offset!");

// Class G01.GzMultipleDamageableComponent
// 0x0028 (0x00F8 - 0x00D0)
class UGzMultipleDamageableComponent final : public UGzDamageableComponent
{
public:
	TSoftObjectPtr<class AGzDamageableRepProxy>   RepProxy;                                          // 0x00D0(0x0028)(Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzMultipleDamageableComponent">();
	}
	static class UGzMultipleDamageableComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzMultipleDamageableComponent>();
	}
};
static_assert(alignof(UGzMultipleDamageableComponent) == 0x000008, "Wrong alignment on UGzMultipleDamageableComponent");
static_assert(sizeof(UGzMultipleDamageableComponent) == 0x0000F8, "Wrong size on UGzMultipleDamageableComponent");
static_assert(offsetof(UGzMultipleDamageableComponent, RepProxy) == 0x0000D0, "Member 'UGzMultipleDamageableComponent::RepProxy' has a wrong offset!");

// Class G01.GzMultiPositionAkComponent
// 0x0020 (0x0460 - 0x0440)
class UGzMultiPositionAkComponent final : public UAkComponent
{
public:
	EAkMultiPositionType                          Type;                                              // 0x0438(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_341A[0x3];                                     // 0x0439(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         CloseRangeDistance;                                // 0x043C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         CloseRangeTickInterval;                            // 0x0440(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         LongRangeTickInterval;                             // 0x0444(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_341B[0x18];                                    // 0x0448(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzMultiPositionAkComponent">();
	}
	static class UGzMultiPositionAkComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzMultiPositionAkComponent>();
	}
};
static_assert(alignof(UGzMultiPositionAkComponent) == 0x000010, "Wrong alignment on UGzMultiPositionAkComponent");
static_assert(sizeof(UGzMultiPositionAkComponent) == 0x000460, "Wrong size on UGzMultiPositionAkComponent");
static_assert(offsetof(UGzMultiPositionAkComponent, Type) == 0x000438, "Member 'UGzMultiPositionAkComponent::Type' has a wrong offset!");
static_assert(offsetof(UGzMultiPositionAkComponent, CloseRangeDistance) == 0x00043C, "Member 'UGzMultiPositionAkComponent::CloseRangeDistance' has a wrong offset!");
static_assert(offsetof(UGzMultiPositionAkComponent, CloseRangeTickInterval) == 0x000440, "Member 'UGzMultiPositionAkComponent::CloseRangeTickInterval' has a wrong offset!");
static_assert(offsetof(UGzMultiPositionAkComponent, LongRangeTickInterval) == 0x000444, "Member 'UGzMultiPositionAkComponent::LongRangeTickInterval' has a wrong offset!");

// Class G01.GzNamedMontageNotify
// 0x0000 (0x0040 - 0x0040)
class UGzNamedMontageNotify : public UAnimNotify_PlayMontageNotify
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzNamedMontageNotify">();
	}
	static class UGzNamedMontageNotify* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzNamedMontageNotify>();
	}
};
static_assert(alignof(UGzNamedMontageNotify) == 0x000008, "Wrong alignment on UGzNamedMontageNotify");
static_assert(sizeof(UGzNamedMontageNotify) == 0x000040, "Wrong size on UGzNamedMontageNotify");

// Class G01.GzRichPresenceTypeHandlerComponent
// 0x0010 (0x00B0 - 0x00A0)
class UGzRichPresenceTypeHandlerComponent : public UGzServiceComponent
{
public:
	uint8                                         Pad_341C[0x10];                                    // 0x00A0(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzRichPresenceTypeHandlerComponent">();
	}
	static class UGzRichPresenceTypeHandlerComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzRichPresenceTypeHandlerComponent>();
	}
};
static_assert(alignof(UGzRichPresenceTypeHandlerComponent) == 0x000008, "Wrong alignment on UGzRichPresenceTypeHandlerComponent");
static_assert(sizeof(UGzRichPresenceTypeHandlerComponent) == 0x0000B0, "Wrong size on UGzRichPresenceTypeHandlerComponent");

// Class G01.GzRichPresenceMatchHandlerComponent
// 0x0008 (0x00B8 - 0x00B0)
class UGzRichPresenceMatchHandlerComponent final : public UGzRichPresenceTypeHandlerComponent
{
public:
	uint8                                         Pad_341D[0x8];                                     // 0x00B0(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzRichPresenceMatchHandlerComponent">();
	}
	static class UGzRichPresenceMatchHandlerComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzRichPresenceMatchHandlerComponent>();
	}
};
static_assert(alignof(UGzRichPresenceMatchHandlerComponent) == 0x000008, "Wrong alignment on UGzRichPresenceMatchHandlerComponent");
static_assert(sizeof(UGzRichPresenceMatchHandlerComponent) == 0x0000B8, "Wrong size on UGzRichPresenceMatchHandlerComponent");

// Class G01.GzNarrativeMissionData
// 0x00A0 (0x0260 - 0x01C0)
class UGzNarrativeMissionData final : public UGzMissionData
{
public:
	TArray<class UGzRewardData*>                  Rewards;                                           // 0x01C0(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UTexture2D>              MissionImage;                                      // 0x01D0(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 CohtmlMissionImage;                                // 0x01F8(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UGzMissionArchetype*                    Archetype;                                         // 0x0208(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   Handler;                                           // 0x0210(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FGzFactionKey                          Corporation;                                       // 0x0220(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class UGzNarrativeMissionData*>        BlockedBy;                                         // 0x0228(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class ULevelSequence>          Cutscene;                                          // 0x0238(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzNarrativeMissionData">();
	}
	static class UGzNarrativeMissionData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzNarrativeMissionData>();
	}
};
static_assert(alignof(UGzNarrativeMissionData) == 0x000008, "Wrong alignment on UGzNarrativeMissionData");
static_assert(sizeof(UGzNarrativeMissionData) == 0x000260, "Wrong size on UGzNarrativeMissionData");
static_assert(offsetof(UGzNarrativeMissionData, Rewards) == 0x0001C0, "Member 'UGzNarrativeMissionData::Rewards' has a wrong offset!");
static_assert(offsetof(UGzNarrativeMissionData, MissionImage) == 0x0001D0, "Member 'UGzNarrativeMissionData::MissionImage' has a wrong offset!");
static_assert(offsetof(UGzNarrativeMissionData, CohtmlMissionImage) == 0x0001F8, "Member 'UGzNarrativeMissionData::CohtmlMissionImage' has a wrong offset!");
static_assert(offsetof(UGzNarrativeMissionData, Archetype) == 0x000208, "Member 'UGzNarrativeMissionData::Archetype' has a wrong offset!");
static_assert(offsetof(UGzNarrativeMissionData, Handler) == 0x000210, "Member 'UGzNarrativeMissionData::Handler' has a wrong offset!");
static_assert(offsetof(UGzNarrativeMissionData, Corporation) == 0x000220, "Member 'UGzNarrativeMissionData::Corporation' has a wrong offset!");
static_assert(offsetof(UGzNarrativeMissionData, BlockedBy) == 0x000228, "Member 'UGzNarrativeMissionData::BlockedBy' has a wrong offset!");
static_assert(offsetof(UGzNarrativeMissionData, Cutscene) == 0x000238, "Member 'UGzNarrativeMissionData::Cutscene' has a wrong offset!");

// Class G01.GzNavigationRoot
// 0x01F8 (0x0628 - 0x0430)
class UGzNavigationRoot : public UCommonActivatableWidget
{
public:
	uint8                                         Pad_341E[0x48];                                    // 0x0430(0x0048)(Fixing Size After Last Property [ Dumper-7 ])
	class UGzPawnInputMappingConfig*              UIInputMappingContextConfig;                       // 0x0478(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UOverlay*                               Root;                                              // 0x0480(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TMap<class FName, class UGzActivatableWidgetStack*> LayersStacks;                                      // 0x0488(0x0050)(ExportObject, Transient, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	TArray<class UGzActivatableWidgetStack*>      Layers;                                            // 0x04D8(0x0010)(ExportObject, ZeroConstructor, Transient, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	uint8                                         Pad_341F[0x10];                                    // 0x04E8(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	TSet<TSoftClassPtr<class UClass>>             AvailableNavigationWidgets;                        // 0x04F8(0x0050)(Edit, DisableEditOnInstance, UObjectWrapper, NativeAccessSpecifierPrivate)
	TSet<TSoftClassPtr<class UClass>>             WidgetsToPreload;                                  // 0x0548(0x0050)(Edit, DisableEditOnInstance, UObjectWrapper, NativeAccessSpecifierPrivate)
	TSet<TSubclassOf<class UGzNavigationWidget>>  ClassesListeningTags;                              // 0x0598(0x0050)(Edit, Transient, EditConst, UObjectWrapper, NativeAccessSpecifierPrivate)
	TSubclassOf<class UUserWidget>                DefaultAnalogCursorWidgetClass;                    // 0x05E8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSubclassOf<class UGzNavigationWidget>        GamepadDisconnectedWidgetClass;                    // 0x05F0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UGzNavigationWidget*                    GamepadDisconnectedPopup;                          // 0x05F8(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUserWidget*                            AnalogCursorWidget;                                // 0x0600(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_3420[0x10];                                    // 0x0608(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UGzNavigationWidget*>            ActiveWidgets;                                     // 0x0618(0x0010)(ExportObject, ZeroConstructor, Transient, ContainsInstancedReference, NativeAccessSpecifierPrivate)

public:
	static class UGzNavigationRoot* GetNavigationRoot(const class UObject* WorldContextObject);

	void AddWidget(class UGzNavigationWidget* Widget);
	class UGzNavigationWidget* AddWidgetCached(TSubclassOf<class UGzNavigationWidget> WidgetClass);
	void AddWidgetSoft(TSoftClassPtr<class UClass> WidgetClass, TDelegate<void(class UGzNavigationWidget* NavigationWidget)> Delegate);
	void AddWidgetToLayer(class FName Layer, class UGzNavigationWidget* Widget);
	class UGzNavigationWidget* AddWidgetToLayerCached(class FName Layer, TSubclassOf<class UGzNavigationWidget> WidgetClass);
	void AddWidgetToLayerSoft(class FName Layer, TSoftClassPtr<class UClass> WidgetClass, TDelegate<void(class UGzNavigationWidget* NavigationWidget)> Delegate);
	void DisableAnalogCursor();
	void EnableAnalogCursor(const class UWidget* ContextWidget);
	void ForceHideCannotBeAddedWidgets();
	TArray<class UGzNavigationWidget*> GetAllByClass(TSubclassOf<class UGzNavigationWidget> WidgetClass);
	class UGzNavigationWidget* GetFirstByClass(TSubclassOf<class UGzNavigationWidget> WidgetClass);
	void OnWidgetPreloaded(class UGzNavigationWidget* NavigationWidget);
	void PopUIInputMapping(class UGzInputControlsComponent* ControlsComp);
	void PopWidgetFromLayer(class FName Layer);
	void PushUIInputMapping(class UGzInputControlsComponent* ControlsComp);
	void RemoveAllByClass(TSubclassOf<class UGzNavigationWidget> WidgetClass);
	void RemoveFirstByClass(TSubclassOf<class UGzNavigationWidget> WidgetClass);
	void RemoveWidget(class UGzNavigationWidget* Widget);
	void RemoveWidgetFromLayer(class FName Layer, class UGzNavigationWidget* Widget);
	void SetAnalogCursorWidget(class UUserWidget* InAnalogCursorWidget);
	void SimulateKeyPress(const struct FKey& Key, EInputEvent InputEvent);

	class UGzActivatableWidgetStack* GetLayerStack(class FName LayerName) const;
	class UGzPawnInputMappingConfig* GetUIMappingConfig() const;
	bool IsTopWidget(const class UGzNavigationWidget* Widget) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzNavigationRoot">();
	}
	static class UGzNavigationRoot* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzNavigationRoot>();
	}
};
static_assert(alignof(UGzNavigationRoot) == 0x000008, "Wrong alignment on UGzNavigationRoot");
static_assert(sizeof(UGzNavigationRoot) == 0x000628, "Wrong size on UGzNavigationRoot");
static_assert(offsetof(UGzNavigationRoot, UIInputMappingContextConfig) == 0x000478, "Member 'UGzNavigationRoot::UIInputMappingContextConfig' has a wrong offset!");
static_assert(offsetof(UGzNavigationRoot, Root) == 0x000480, "Member 'UGzNavigationRoot::Root' has a wrong offset!");
static_assert(offsetof(UGzNavigationRoot, LayersStacks) == 0x000488, "Member 'UGzNavigationRoot::LayersStacks' has a wrong offset!");
static_assert(offsetof(UGzNavigationRoot, Layers) == 0x0004D8, "Member 'UGzNavigationRoot::Layers' has a wrong offset!");
static_assert(offsetof(UGzNavigationRoot, AvailableNavigationWidgets) == 0x0004F8, "Member 'UGzNavigationRoot::AvailableNavigationWidgets' has a wrong offset!");
static_assert(offsetof(UGzNavigationRoot, WidgetsToPreload) == 0x000548, "Member 'UGzNavigationRoot::WidgetsToPreload' has a wrong offset!");
static_assert(offsetof(UGzNavigationRoot, ClassesListeningTags) == 0x000598, "Member 'UGzNavigationRoot::ClassesListeningTags' has a wrong offset!");
static_assert(offsetof(UGzNavigationRoot, DefaultAnalogCursorWidgetClass) == 0x0005E8, "Member 'UGzNavigationRoot::DefaultAnalogCursorWidgetClass' has a wrong offset!");
static_assert(offsetof(UGzNavigationRoot, GamepadDisconnectedWidgetClass) == 0x0005F0, "Member 'UGzNavigationRoot::GamepadDisconnectedWidgetClass' has a wrong offset!");
static_assert(offsetof(UGzNavigationRoot, GamepadDisconnectedPopup) == 0x0005F8, "Member 'UGzNavigationRoot::GamepadDisconnectedPopup' has a wrong offset!");
static_assert(offsetof(UGzNavigationRoot, AnalogCursorWidget) == 0x000600, "Member 'UGzNavigationRoot::AnalogCursorWidget' has a wrong offset!");
static_assert(offsetof(UGzNavigationRoot, ActiveWidgets) == 0x000618, "Member 'UGzNavigationRoot::ActiveWidgets' has a wrong offset!");

// Class G01.GzNavigationUtility
// 0x0000 (0x0028 - 0x0028)
class UGzNavigationUtility final : public UBlueprintFunctionLibrary
{
public:
	static TArray<class FString> GetLayerNames();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzNavigationUtility">();
	}
	static class UGzNavigationUtility* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzNavigationUtility>();
	}
};
static_assert(alignof(UGzNavigationUtility) == 0x000008, "Wrong alignment on UGzNavigationUtility");
static_assert(sizeof(UGzNavigationUtility) == 0x000028, "Wrong size on UGzNavigationUtility");

// Class G01.GzNavLinksComponent
// 0x0010 (0x00C0 - 0x00B0)
class UGzNavLinksComponent final : public UGzNavigationComponent
{
public:
	struct FGzNavLinksGenerationConfig            NavLinkGenerationConfig;                           // 0x00B0(0x0010)(NoDestructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzNavLinksComponent">();
	}
	static class UGzNavLinksComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzNavLinksComponent>();
	}
};
static_assert(alignof(UGzNavLinksComponent) == 0x000008, "Wrong alignment on UGzNavLinksComponent");
static_assert(sizeof(UGzNavLinksComponent) == 0x0000C0, "Wrong size on UGzNavLinksComponent");
static_assert(offsetof(UGzNavLinksComponent, NavLinkGenerationConfig) == 0x0000B0, "Member 'UGzNavLinksComponent::NavLinkGenerationConfig' has a wrong offset!");

// Class G01.GzRingMapDecoration
// 0x0050 (0x0340 - 0x02F0)
class UGzRingMapDecoration : public UGzMapDecoration
{
public:
	class UMaterialInterface*                     RingMaterial;                                      // 0x02F0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   ThicknessPropertyName;                             // 0x02F8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         BaseThicknessPixels;                               // 0x0300(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3423[0x4];                                     // 0x0304(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UCurveFloat*                            RingThicknessCurve;                                // 0x0308(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UMaterialInstanceDynamic*               RingMaterialInstance;                              // 0x0310(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 RingImage;                                         // 0x0318(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FGzCircle2D                            TargetCircle;                                      // 0x0320(0x0018)(BlueprintVisible, BlueprintReadOnly, NoDestructor, Protected, NativeAccessSpecifierProtected)
	float                                         AdditionalOffsetPercentage;                        // 0x0338(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3424[0x4];                                     // 0x033C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzRingMapDecoration">();
	}
	static class UGzRingMapDecoration* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzRingMapDecoration>();
	}
};
static_assert(alignof(UGzRingMapDecoration) == 0x000008, "Wrong alignment on UGzRingMapDecoration");
static_assert(sizeof(UGzRingMapDecoration) == 0x000340, "Wrong size on UGzRingMapDecoration");
static_assert(offsetof(UGzRingMapDecoration, RingMaterial) == 0x0002F0, "Member 'UGzRingMapDecoration::RingMaterial' has a wrong offset!");
static_assert(offsetof(UGzRingMapDecoration, ThicknessPropertyName) == 0x0002F8, "Member 'UGzRingMapDecoration::ThicknessPropertyName' has a wrong offset!");
static_assert(offsetof(UGzRingMapDecoration, BaseThicknessPixels) == 0x000300, "Member 'UGzRingMapDecoration::BaseThicknessPixels' has a wrong offset!");
static_assert(offsetof(UGzRingMapDecoration, RingThicknessCurve) == 0x000308, "Member 'UGzRingMapDecoration::RingThicknessCurve' has a wrong offset!");
static_assert(offsetof(UGzRingMapDecoration, RingMaterialInstance) == 0x000310, "Member 'UGzRingMapDecoration::RingMaterialInstance' has a wrong offset!");
static_assert(offsetof(UGzRingMapDecoration, RingImage) == 0x000318, "Member 'UGzRingMapDecoration::RingImage' has a wrong offset!");
static_assert(offsetof(UGzRingMapDecoration, TargetCircle) == 0x000320, "Member 'UGzRingMapDecoration::TargetCircle' has a wrong offset!");
static_assert(offsetof(UGzRingMapDecoration, AdditionalOffsetPercentage) == 0x000338, "Member 'UGzRingMapDecoration::AdditionalOffsetPercentage' has a wrong offset!");

// Class G01.GzNavLinksSpawnManager
// 0x0000 (0x0028 - 0x0028)
class UGzNavLinksSpawnManager final : public UObject
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzNavLinksSpawnManager">();
	}
	static class UGzNavLinksSpawnManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzNavLinksSpawnManager>();
	}
};
static_assert(alignof(UGzNavLinksSpawnManager) == 0x000008, "Wrong alignment on UGzNavLinksSpawnManager");
static_assert(sizeof(UGzNavLinksSpawnManager) == 0x000028, "Wrong size on UGzNavLinksSpawnManager");

// Class G01.GzNegateCondition
// 0x0000 (0x0068 - 0x0068)
class UGzNegateCondition final : public UGzDecoratorCondition
{
public:
	static class UGzCondition* MakeNegateCondition(class AGzAdvancedMission* Mission, class UGzCondition* Condition);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzNegateCondition">();
	}
	static class UGzNegateCondition* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzNegateCondition>();
	}
};
static_assert(alignof(UGzNegateCondition) == 0x000008, "Wrong alignment on UGzNegateCondition");
static_assert(sizeof(UGzNegateCondition) == 0x000068, "Wrong size on UGzNegateCondition");

// Class G01.GzNegateObjective
// 0x0000 (0x0068 - 0x0068)
class UGzNegateObjective final : public UGzDecoratorObjective
{
public:
	static class UGzObjective* MakeNegateObjective(class AGzAdvancedMission* Mission, class UGzObjective* Objective);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzNegateObjective">();
	}
	static class UGzNegateObjective* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzNegateObjective>();
	}
};
static_assert(alignof(UGzNegateObjective) == 0x000008, "Wrong alignment on UGzNegateObjective");
static_assert(sizeof(UGzNegateObjective) == 0x000068, "Wrong size on UGzNegateObjective");

// Class G01.GzNewNotificationsHandler
// 0x0000 (0x0048 - 0x0048)
class UGzNewNotificationsHandler final : public UGzSignalREvent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzNewNotificationsHandler">();
	}
	static class UGzNewNotificationsHandler* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzNewNotificationsHandler>();
	}
};
static_assert(alignof(UGzNewNotificationsHandler) == 0x000008, "Wrong alignment on UGzNewNotificationsHandler");
static_assert(sizeof(UGzNewNotificationsHandler) == 0x000048, "Wrong size on UGzNewNotificationsHandler");

// Class G01.GzNewsModel
// 0x0010 (0x0080 - 0x0070)
class UGzNewsModel final : public UGzBackendModel
{
public:
	uint8                                         Pad_3425[0x10];                                    // 0x0070(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzNewsModel">();
	}
	static class UGzNewsModel* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzNewsModel>();
	}
};
static_assert(alignof(UGzNewsModel) == 0x000008, "Wrong alignment on UGzNewsModel");
static_assert(sizeof(UGzNewsModel) == 0x000080, "Wrong size on UGzNewsModel");

// Class G01.GzNewsService
// 0x00D0 (0x0170 - 0x00A0)
class UGzNewsService final : public UGzClientPFObject
{
public:
	uint8                                         Pad_3426[0xD0];                                    // 0x00A0(0x00D0)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzNewsService">();
	}
	static class UGzNewsService* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzNewsService>();
	}
};
static_assert(alignof(UGzNewsService) == 0x000008, "Wrong alignment on UGzNewsService");
static_assert(sizeof(UGzNewsService) == 0x000170, "Wrong size on UGzNewsService");

// Class G01.GzProgressLogWidget
// 0x0068 (0x03A8 - 0x0340)
class UGzProgressLogWidget : public UGzHUDComponent
{
public:
	class UVerticalBox*                           EntriesContainer;                                  // 0x0340(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FMargin                                EntriesPadding;                                    // 0x0348(0x0010)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPrivate)
	TMap<int32, class UGzProgressLogEntryWidget*> EntryWidgets;                                      // 0x0358(0x0050)(ExportObject, Transient, ContainsInstancedReference, NativeAccessSpecifierPrivate)

public:
	void AddLogEntry(const TSubclassOf<class UGzProgressLogEntryWidget>& ProgressWidgetClass, float Duration, int32 Handle);
	void CancelProgress(int32 Handle);
	void UpdateEntryProgress(int32 Handle, float Duration);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzProgressLogWidget">();
	}
	static class UGzProgressLogWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzProgressLogWidget>();
	}
};
static_assert(alignof(UGzProgressLogWidget) == 0x000008, "Wrong alignment on UGzProgressLogWidget");
static_assert(sizeof(UGzProgressLogWidget) == 0x0003A8, "Wrong size on UGzProgressLogWidget");
static_assert(offsetof(UGzProgressLogWidget, EntriesContainer) == 0x000340, "Member 'UGzProgressLogWidget::EntriesContainer' has a wrong offset!");
static_assert(offsetof(UGzProgressLogWidget, EntriesPadding) == 0x000348, "Member 'UGzProgressLogWidget::EntriesPadding' has a wrong offset!");
static_assert(offsetof(UGzProgressLogWidget, EntryWidgets) == 0x000358, "Member 'UGzProgressLogWidget::EntryWidgets' has a wrong offset!");

// Class G01.GzNewsSettings
// 0x0020 (0x0058 - 0x0038)
class UGzNewsSettings final : public UDeveloperSettings
{
public:
	class FString                                 NewsUrlTemplate;                                   // 0x0038(0x0010)(Edit, ZeroConstructor, Config, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 CdnUrl;                                            // 0x0048(0x0010)(Edit, ZeroConstructor, Config, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzNewsSettings">();
	}
	static class UGzNewsSettings* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzNewsSettings>();
	}
};
static_assert(alignof(UGzNewsSettings) == 0x000008, "Wrong alignment on UGzNewsSettings");
static_assert(sizeof(UGzNewsSettings) == 0x000058, "Wrong size on UGzNewsSettings");
static_assert(offsetof(UGzNewsSettings, NewsUrlTemplate) == 0x000038, "Member 'UGzNewsSettings::NewsUrlTemplate' has a wrong offset!");
static_assert(offsetof(UGzNewsSettings, CdnUrl) == 0x000048, "Member 'UGzNewsSettings::CdnUrl' has a wrong offset!");

// Class G01.GzBaseZoneStageParams
// 0x0008 (0x0030 - 0x0028)
class UGzBaseZoneStageParams : public UObject
{
public:
	float                                         MaxSpeed;                                          // 0x0028(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3427[0x4];                                     // 0x002C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzBaseZoneStageParams">();
	}
	static class UGzBaseZoneStageParams* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzBaseZoneStageParams>();
	}
};
static_assert(alignof(UGzBaseZoneStageParams) == 0x000008, "Wrong alignment on UGzBaseZoneStageParams");
static_assert(sizeof(UGzBaseZoneStageParams) == 0x000030, "Wrong size on UGzBaseZoneStageParams");
static_assert(offsetof(UGzBaseZoneStageParams, MaxSpeed) == 0x000028, "Member 'UGzBaseZoneStageParams::MaxSpeed' has a wrong offset!");

// Class G01.GzOuterZoneStageParams
// 0x0008 (0x0038 - 0x0030)
class UGzOuterZoneStageParams final : public UGzBaseZoneStageParams
{
public:
	float                                         SourceScale;                                       // 0x0030(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3428[0x4];                                     // 0x0034(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzOuterZoneStageParams">();
	}
	static class UGzOuterZoneStageParams* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzOuterZoneStageParams>();
	}
};
static_assert(alignof(UGzOuterZoneStageParams) == 0x000008, "Wrong alignment on UGzOuterZoneStageParams");
static_assert(sizeof(UGzOuterZoneStageParams) == 0x000038, "Wrong size on UGzOuterZoneStageParams");
static_assert(offsetof(UGzOuterZoneStageParams, SourceScale) == 0x000030, "Member 'UGzOuterZoneStageParams::SourceScale' has a wrong offset!");

// Class G01.GzNewsUpdatedData
// 0x0000 (0x0028 - 0x0028)
class UGzNewsUpdatedData final : public UGzSignalREventData
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzNewsUpdatedData">();
	}
	static class UGzNewsUpdatedData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzNewsUpdatedData>();
	}
};
static_assert(alignof(UGzNewsUpdatedData) == 0x000008, "Wrong alignment on UGzNewsUpdatedData");
static_assert(sizeof(UGzNewsUpdatedData) == 0x000028, "Wrong size on UGzNewsUpdatedData");

// Class G01.GzNewsUpdatedHandler
// 0x0000 (0x0048 - 0x0048)
class UGzNewsUpdatedHandler final : public UGzSignalREvent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzNewsUpdatedHandler">();
	}
	static class UGzNewsUpdatedHandler* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzNewsUpdatedHandler>();
	}
};
static_assert(alignof(UGzNewsUpdatedHandler) == 0x000008, "Wrong alignment on UGzNewsUpdatedHandler");
static_assert(sizeof(UGzNewsUpdatedHandler) == 0x000048, "Wrong size on UGzNewsUpdatedHandler");

// Class G01.GzNonPlayerCharacter
// 0x0010 (0x1620 - 0x1610)
class AGzNonPlayerCharacter : public AGzAICharacter
{
public:
	uint8                                         Pad_3429[0x8];                                     // 0x1610(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGenericTeamId                         TeamID;                                            // 0x1618(0x0001)(BlueprintVisible, BlueprintReadOnly, Net, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bShouldApplyDamage;                                // 0x1619(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bDropExcessItems;                                  // 0x161A(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_342A[0x1];                                     // 0x161B(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         AiId;                                              // 0x161C(0x0004)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void OnRep_TeamId();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzNonPlayerCharacter">();
	}
	static class AGzNonPlayerCharacter* GetDefaultObj()
	{
		return GetDefaultObjImpl<AGzNonPlayerCharacter>();
	}
};
static_assert(alignof(AGzNonPlayerCharacter) == 0x000010, "Wrong alignment on AGzNonPlayerCharacter");
static_assert(sizeof(AGzNonPlayerCharacter) == 0x001620, "Wrong size on AGzNonPlayerCharacter");
static_assert(offsetof(AGzNonPlayerCharacter, TeamID) == 0x001618, "Member 'AGzNonPlayerCharacter::TeamID' has a wrong offset!");
static_assert(offsetof(AGzNonPlayerCharacter, bShouldApplyDamage) == 0x001619, "Member 'AGzNonPlayerCharacter::bShouldApplyDamage' has a wrong offset!");
static_assert(offsetof(AGzNonPlayerCharacter, bDropExcessItems) == 0x00161A, "Member 'AGzNonPlayerCharacter::bDropExcessItems' has a wrong offset!");
static_assert(offsetof(AGzNonPlayerCharacter, AiId) == 0x00161C, "Member 'AGzNonPlayerCharacter::AiId' has a wrong offset!");

// Class G01.GzProjectileMovementComponent
// 0x0080 (0x02E0 - 0x0260)
class UGzProjectileMovementComponent final : public UProjectileMovementComponent
{
public:
	bool                                          bEnableDragOnSpawn;                                // 0x0258(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_342B[0x3];                                     // 0x0259(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         DragCoeffecient;                                   // 0x025C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         DragStartDistance;                                 // 0x0260(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_342C[0x4];                                     // 0x0264(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                SpawnLocation;                                     // 0x0268(0x0018)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bApplyDrag;                                        // 0x0280(0x0001)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_342D[0x7];                                     // 0x0281(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UGameplayEffect>            HomingTargetEffectClass;                           // 0x0288(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         HomingMagnitudeMultiplier;                         // 0x0290(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MaxHomingDuration;                                 // 0x0294(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bLeadingEnabled;                                   // 0x0298(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_342E[0x3];                                     // 0x0299(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         HomingTargetLeadingVelocityMultiplier;             // 0x029C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bPlaysFlybyFeedback;                               // 0x02A0(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_342F[0x3];                                     // 0x02A1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         FlybyCheckRange;                                   // 0x02A4(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3430[0x38];                                    // 0x02A8(0x0038)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void EnableHomingLeading(const bool bEnableLeading);
	void SetDragEnabled(const bool bNewDragEnabled);
	void SetHomingLocation(const struct FVector& NewHomingLocation);
	void SetHomingMagnitudeMultiplier(const float NewMagnitudeMultiplier);
	void SetHomingTarget(class USceneComponent* TargetComponent);
	void StopHoming();
	void StopHomingTimeout();

	float GetDistanceToHomingTarget() const;
	float GetDistanceToHomingTargetSquared() const;
	struct FVector GetHomingTargetLeadingLocation() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzProjectileMovementComponent">();
	}
	static class UGzProjectileMovementComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzProjectileMovementComponent>();
	}
};
static_assert(alignof(UGzProjectileMovementComponent) == 0x000010, "Wrong alignment on UGzProjectileMovementComponent");
static_assert(sizeof(UGzProjectileMovementComponent) == 0x0002E0, "Wrong size on UGzProjectileMovementComponent");
static_assert(offsetof(UGzProjectileMovementComponent, bEnableDragOnSpawn) == 0x000258, "Member 'UGzProjectileMovementComponent::bEnableDragOnSpawn' has a wrong offset!");
static_assert(offsetof(UGzProjectileMovementComponent, DragCoeffecient) == 0x00025C, "Member 'UGzProjectileMovementComponent::DragCoeffecient' has a wrong offset!");
static_assert(offsetof(UGzProjectileMovementComponent, DragStartDistance) == 0x000260, "Member 'UGzProjectileMovementComponent::DragStartDistance' has a wrong offset!");
static_assert(offsetof(UGzProjectileMovementComponent, SpawnLocation) == 0x000268, "Member 'UGzProjectileMovementComponent::SpawnLocation' has a wrong offset!");
static_assert(offsetof(UGzProjectileMovementComponent, bApplyDrag) == 0x000280, "Member 'UGzProjectileMovementComponent::bApplyDrag' has a wrong offset!");
static_assert(offsetof(UGzProjectileMovementComponent, HomingTargetEffectClass) == 0x000288, "Member 'UGzProjectileMovementComponent::HomingTargetEffectClass' has a wrong offset!");
static_assert(offsetof(UGzProjectileMovementComponent, HomingMagnitudeMultiplier) == 0x000290, "Member 'UGzProjectileMovementComponent::HomingMagnitudeMultiplier' has a wrong offset!");
static_assert(offsetof(UGzProjectileMovementComponent, MaxHomingDuration) == 0x000294, "Member 'UGzProjectileMovementComponent::MaxHomingDuration' has a wrong offset!");
static_assert(offsetof(UGzProjectileMovementComponent, bLeadingEnabled) == 0x000298, "Member 'UGzProjectileMovementComponent::bLeadingEnabled' has a wrong offset!");
static_assert(offsetof(UGzProjectileMovementComponent, HomingTargetLeadingVelocityMultiplier) == 0x00029C, "Member 'UGzProjectileMovementComponent::HomingTargetLeadingVelocityMultiplier' has a wrong offset!");
static_assert(offsetof(UGzProjectileMovementComponent, bPlaysFlybyFeedback) == 0x0002A0, "Member 'UGzProjectileMovementComponent::bPlaysFlybyFeedback' has a wrong offset!");
static_assert(offsetof(UGzProjectileMovementComponent, FlybyCheckRange) == 0x0002A4, "Member 'UGzProjectileMovementComponent::FlybyCheckRange' has a wrong offset!");

// Class G01.GzNotificationData
// 0x0010 (0x0038 - 0x0028)
class UGzNotificationData final : public UGzSignalREventData
{
public:
	uint8                                         Pad_3431[0x10];                                    // 0x0028(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzNotificationData">();
	}
	static class UGzNotificationData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzNotificationData>();
	}
};
static_assert(alignof(UGzNotificationData) == 0x000008, "Wrong alignment on UGzNotificationData");
static_assert(sizeof(UGzNotificationData) == 0x000038, "Wrong size on UGzNotificationData");

// Class G01.GzShrinkingZoneManager
// 0x01C0 (0x0460 - 0x02A0)
class AGzShrinkingZoneManager : public AGzGameModeSubsystem
{
public:
	uint8                                         Pad_3432[0x8];                                     // 0x02A0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	FMulticastInlineDelegateProperty_             OnStageChanged;                                    // 0x02A8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnZoneAvailable;                                   // 0x02B8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_3433[0x30];                                    // 0x02C8(0x0030)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftClassPtr<class UClass>                   ZoneClass;                                         // 0x02F8(0x0028)(Edit, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         StageIndex;                                        // 0x0320(0x0004)(Net, ZeroConstructor, Transient, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_3434[0x4];                                     // 0x0324(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class AGzShrinkingZone*                       Zone;                                              // 0x0328(0x0008)(Net, ZeroConstructor, Transient, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSet<class UGzZoneTrackingComponent*>         DynamicTrackedComponents;                          // 0x0330(0x0050)(ExportObject, Transient, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	TSet<class UGzZoneTrackingComponent*>         StaticTrackedComponents;                           // 0x0380(0x0050)(ExportObject, Transient, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	TSet<class UGzZoneTrackingComponent*>         StaticTrackedComponentsToUpdate;                   // 0x03D0(0x0050)(ExportObject, Transient, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	uint8                                         Pad_3435[0x40];                                    // 0x0420(0x0040)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ContinueZoneShrinking();
	void Init(const TArray<class UGzBaseZoneStageParams*>& ZoneParams);
	void OnRep_Zone();
	void PauseZoneShrinking();
	void ResetZone();
	float StartNextStage();

	bool CalculateTimeToGetConsumedByNextCircle(const struct FVector2D& WorldPosition, float* OutTime) const;
	const struct FGzCircle2D GetCurrentCircle() const;
	int32 GetCurrentStage() const;
	float GetSpawnHeight() const;
	const struct FGzCircle2D GetStageCircle(int32 Param_Index) const;
	const struct FGzCircle2D GetTargetCircle() const;
	class AGzShrinkingZone* GetZone() const;
	bool IsShrinking() const;
	void OnRep_StageIndex() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzShrinkingZoneManager">();
	}
	static class AGzShrinkingZoneManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<AGzShrinkingZoneManager>();
	}
};
static_assert(alignof(AGzShrinkingZoneManager) == 0x000008, "Wrong alignment on AGzShrinkingZoneManager");
static_assert(sizeof(AGzShrinkingZoneManager) == 0x000460, "Wrong size on AGzShrinkingZoneManager");
static_assert(offsetof(AGzShrinkingZoneManager, OnStageChanged) == 0x0002A8, "Member 'AGzShrinkingZoneManager::OnStageChanged' has a wrong offset!");
static_assert(offsetof(AGzShrinkingZoneManager, OnZoneAvailable) == 0x0002B8, "Member 'AGzShrinkingZoneManager::OnZoneAvailable' has a wrong offset!");
static_assert(offsetof(AGzShrinkingZoneManager, ZoneClass) == 0x0002F8, "Member 'AGzShrinkingZoneManager::ZoneClass' has a wrong offset!");
static_assert(offsetof(AGzShrinkingZoneManager, StageIndex) == 0x000320, "Member 'AGzShrinkingZoneManager::StageIndex' has a wrong offset!");
static_assert(offsetof(AGzShrinkingZoneManager, Zone) == 0x000328, "Member 'AGzShrinkingZoneManager::Zone' has a wrong offset!");
static_assert(offsetof(AGzShrinkingZoneManager, DynamicTrackedComponents) == 0x000330, "Member 'AGzShrinkingZoneManager::DynamicTrackedComponents' has a wrong offset!");
static_assert(offsetof(AGzShrinkingZoneManager, StaticTrackedComponents) == 0x000380, "Member 'AGzShrinkingZoneManager::StaticTrackedComponents' has a wrong offset!");
static_assert(offsetof(AGzShrinkingZoneManager, StaticTrackedComponentsToUpdate) == 0x0003D0, "Member 'AGzShrinkingZoneManager::StaticTrackedComponentsToUpdate' has a wrong offset!");

// Class G01.GzNotificationHandler
// 0x0018 (0x0060 - 0x0048)
class UGzNotificationHandler final : public UGzSignalREvent
{
public:
	uint8                                         Pad_3438[0x18];                                    // 0x0048(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzNotificationHandler">();
	}
	static class UGzNotificationHandler* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzNotificationHandler>();
	}
};
static_assert(alignof(UGzNotificationHandler) == 0x000008, "Wrong alignment on UGzNotificationHandler");
static_assert(sizeof(UGzNotificationHandler) == 0x000060, "Wrong size on UGzNotificationHandler");

// Class G01.GzPropagationComponent
// 0x0018 (0x00C0 - 0x00A8)
class UGzPropagationComponent final : public UActorComponent
{
public:
	FMulticastInlineDelegateProperty_             OnPropagationControllerReady;                      // 0x00A8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	class AGzSurfacePropagationController*        PropagationController;                             // 0x00B8(0x0008)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void GzPropagationControllerReplicated__DelegateSignature();
	void OnRep_PropagationController();

	class AGzSurfacePropagationController* GetPropagationController() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzPropagationComponent">();
	}
	static class UGzPropagationComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzPropagationComponent>();
	}
};
static_assert(alignof(UGzPropagationComponent) == 0x000008, "Wrong alignment on UGzPropagationComponent");
static_assert(sizeof(UGzPropagationComponent) == 0x0000C0, "Wrong size on UGzPropagationComponent");
static_assert(offsetof(UGzPropagationComponent, OnPropagationControllerReady) == 0x0000A8, "Member 'UGzPropagationComponent::OnPropagationControllerReady' has a wrong offset!");
static_assert(offsetof(UGzPropagationComponent, PropagationController) == 0x0000B8, "Member 'UGzPropagationComponent::PropagationController' has a wrong offset!");

// Class G01.GzNotificationSettingsAsset
// 0x0008 (0x0038 - 0x0030)
class UGzNotificationSettingsAsset final : public UDataAsset
{
public:
	struct FGzNotificationSettings                Settings;                                          // 0x0030(0x0008)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzNotificationSettingsAsset">();
	}
	static class UGzNotificationSettingsAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzNotificationSettingsAsset>();
	}
};
static_assert(alignof(UGzNotificationSettingsAsset) == 0x000008, "Wrong alignment on UGzNotificationSettingsAsset");
static_assert(sizeof(UGzNotificationSettingsAsset) == 0x000038, "Wrong size on UGzNotificationSettingsAsset");
static_assert(offsetof(UGzNotificationSettingsAsset, Settings) == 0x000030, "Member 'UGzNotificationSettingsAsset::Settings' has a wrong offset!");

// Class G01.GzSignalRService
// 0x0170 (0x0210 - 0x00A0)
class UGzSignalRService final : public UGzClientPFObject
{
public:
	uint8                                         Pad_3439[0xB8];                                    // 0x00A0(0x00B8)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<TSubclassOf<class UGzSignalREvent>, class UGzSignalREvent*> Handlers;                                          // 0x0158(0x0050)(Transient, NativeAccessSpecifierPrivate)
	uint8                                         Pad_343A[0x68];                                    // 0x01A8(0x0068)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzSignalRService">();
	}
	static class UGzSignalRService* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzSignalRService>();
	}
};
static_assert(alignof(UGzSignalRService) == 0x000008, "Wrong alignment on UGzSignalRService");
static_assert(sizeof(UGzSignalRService) == 0x000210, "Wrong size on UGzSignalRService");
static_assert(offsetof(UGzSignalRService, Handlers) == 0x000158, "Member 'UGzSignalRService::Handlers' has a wrong offset!");

// Class G01.GzNotificationsModel
// 0x0000 (0x0070 - 0x0070)
class UGzNotificationsModel final : public UGzBackendModel
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzNotificationsModel">();
	}
	static class UGzNotificationsModel* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzNotificationsModel>();
	}
};
static_assert(alignof(UGzNotificationsModel) == 0x000008, "Wrong alignment on UGzNotificationsModel");
static_assert(sizeof(UGzNotificationsModel) == 0x000070, "Wrong size on UGzNotificationsModel");

// Class G01.GzNotificationsSettings
// 0x0010 (0x0048 - 0x0038)
class UGzNotificationsSettings final : public UDeveloperSettings
{
public:
	float                                         DisposeTimerDelay;                                 // 0x0038(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DisposeTimerMaxExtension;                          // 0x003C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaximumNotifications;                              // 0x0040(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_343B[0x4];                                     // 0x0044(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzNotificationsSettings">();
	}
	static class UGzNotificationsSettings* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzNotificationsSettings>();
	}
};
static_assert(alignof(UGzNotificationsSettings) == 0x000008, "Wrong alignment on UGzNotificationsSettings");
static_assert(sizeof(UGzNotificationsSettings) == 0x000048, "Wrong size on UGzNotificationsSettings");
static_assert(offsetof(UGzNotificationsSettings, DisposeTimerDelay) == 0x000038, "Member 'UGzNotificationsSettings::DisposeTimerDelay' has a wrong offset!");
static_assert(offsetof(UGzNotificationsSettings, DisposeTimerMaxExtension) == 0x00003C, "Member 'UGzNotificationsSettings::DisposeTimerMaxExtension' has a wrong offset!");
static_assert(offsetof(UGzNotificationsSettings, MaximumNotifications) == 0x000040, "Member 'UGzNotificationsSettings::MaximumNotifications' has a wrong offset!");

// Class G01.GzNPCData
// 0x0068 (0x0098 - 0x0030)
class UGzNPCData : public UDataAsset
{
public:
	class FString                                 AIName;                                            // 0x0030(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class APawn>                      AIPawnClass;                                       // 0x0040(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class AGzAIController>            AIControllerClass;                                 // 0x0048(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBehaviorTree*                          BehaviorTree;                                      // 0x0050(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ENPCType                                      Type;                                              // 0x0058(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_343C[0x7];                                     // 0x0059(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTagContainer                  AttributeTags;                                     // 0x0060(0x0020)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	class UGzAIParamConfig*                       AIParamConfig;                                     // 0x0080(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FGzInventoryItemContent>        InventoryItems;                                    // 0x0088(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzNPCData">();
	}
	static class UGzNPCData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzNPCData>();
	}
};
static_assert(alignof(UGzNPCData) == 0x000008, "Wrong alignment on UGzNPCData");
static_assert(sizeof(UGzNPCData) == 0x000098, "Wrong size on UGzNPCData");
static_assert(offsetof(UGzNPCData, AIName) == 0x000030, "Member 'UGzNPCData::AIName' has a wrong offset!");
static_assert(offsetof(UGzNPCData, AIPawnClass) == 0x000040, "Member 'UGzNPCData::AIPawnClass' has a wrong offset!");
static_assert(offsetof(UGzNPCData, AIControllerClass) == 0x000048, "Member 'UGzNPCData::AIControllerClass' has a wrong offset!");
static_assert(offsetof(UGzNPCData, BehaviorTree) == 0x000050, "Member 'UGzNPCData::BehaviorTree' has a wrong offset!");
static_assert(offsetof(UGzNPCData, Type) == 0x000058, "Member 'UGzNPCData::Type' has a wrong offset!");
static_assert(offsetof(UGzNPCData, AttributeTags) == 0x000060, "Member 'UGzNPCData::AttributeTags' has a wrong offset!");
static_assert(offsetof(UGzNPCData, AIParamConfig) == 0x000080, "Member 'UGzNPCData::AIParamConfig' has a wrong offset!");
static_assert(offsetof(UGzNPCData, InventoryItems) == 0x000088, "Member 'UGzNPCData::InventoryItems' has a wrong offset!");

// Class G01.GzPropagationConfiguration
// 0x0020 (0x0050 - 0x0030)
class UGzPropagationConfiguration final : public UDataAsset
{
public:
	TSubclassOf<class UGzPropagationStrategy>     StrategyClass;                                     // 0x0030(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UGzPropagationCollisionStrategy> CollisionClass;                                    // 0x0038(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UGzPropagationStrategyConfig*           StrategyConfig;                                    // 0x0040(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, PersistentInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UGzPropagationCollisionConfig*          CollisionConfig;                                   // 0x0048(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, PersistentInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzPropagationConfiguration">();
	}
	static class UGzPropagationConfiguration* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzPropagationConfiguration>();
	}
};
static_assert(alignof(UGzPropagationConfiguration) == 0x000008, "Wrong alignment on UGzPropagationConfiguration");
static_assert(sizeof(UGzPropagationConfiguration) == 0x000050, "Wrong size on UGzPropagationConfiguration");
static_assert(offsetof(UGzPropagationConfiguration, StrategyClass) == 0x000030, "Member 'UGzPropagationConfiguration::StrategyClass' has a wrong offset!");
static_assert(offsetof(UGzPropagationConfiguration, CollisionClass) == 0x000038, "Member 'UGzPropagationConfiguration::CollisionClass' has a wrong offset!");
static_assert(offsetof(UGzPropagationConfiguration, StrategyConfig) == 0x000040, "Member 'UGzPropagationConfiguration::StrategyConfig' has a wrong offset!");
static_assert(offsetof(UGzPropagationConfiguration, CollisionConfig) == 0x000048, "Member 'UGzPropagationConfiguration::CollisionConfig' has a wrong offset!");

// Class G01.GzNPCKillStatCollector
// 0x0000 (0x0040 - 0x0040)
class UGzNPCKillStatCollector final : public UGzCharacterDeathStatCollector
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzNPCKillStatCollector">();
	}
	static class UGzNPCKillStatCollector* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzNPCKillStatCollector>();
	}
};
static_assert(alignof(UGzNPCKillStatCollector) == 0x000008, "Wrong alignment on UGzNPCKillStatCollector");
static_assert(sizeof(UGzNPCKillStatCollector) == 0x000040, "Wrong size on UGzNPCKillStatCollector");

// Class G01.GzSlidingNavLink
// 0x0000 (0x0338 - 0x0338)
class AGzSlidingNavLink final : public AGzAutoNavLink
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzSlidingNavLink">();
	}
	static class AGzSlidingNavLink* GetDefaultObj()
	{
		return GetDefaultObjImpl<AGzSlidingNavLink>();
	}
};
static_assert(alignof(AGzSlidingNavLink) == 0x000008, "Wrong alignment on AGzSlidingNavLink");
static_assert(sizeof(AGzSlidingNavLink) == 0x000338, "Wrong size on AGzSlidingNavLink");

// Class G01.GzNPCSpawner
// 0x0068 (0x0308 - 0x02A0)
class AGzNPCSpawner : public AActor
{
public:
	bool                                          bUseZoneControlBox;                                // 0x02A0(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAutoSpawn;                                        // 0x02A1(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_343D[0x2];                                     // 0x02A2(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         MinAmountNPC;                                      // 0x02A4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaxAmountNPC;                                      // 0x02A8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SpawnNum;                                          // 0x02AC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReinforcementInfinity;                             // 0x02B0(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_343E[0x3];                                     // 0x02B1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGzIntervalTimer                       CooldownTimer;                                     // 0x02B4(0x0014)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic)
	struct FGzIntervalTimer                       SpawnTimer;                                        // 0x02C8(0x0014)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic)
	FMulticastSparseDelegateProperty_             OnSpawn_BP;                                        // 0x02DC(0x0001)(InstancedReference, BlueprintAssignable, NoDestructor, NativeAccessSpecifierPublic)
	FMulticastSparseDelegateProperty_             OnReinforcement_BP;                                // 0x02DD(0x0001)(InstancedReference, BlueprintAssignable, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_343F[0x2];                                     // 0x02DE(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	class UBoxComponent*                          ZoneControl;                                       // 0x02E0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3440[0x20];                                    // 0x02E8(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AddUniqueNPC(class AGzAIController* InValue);
	void OnReinforcement();
	void OnReinforcement_BP__DelegateSignature();
	void OnSpawn();
	void OnSpawn_BP__DelegateSignature();
	void SetAlwaysInAlertState(bool InValue);
	bool TrySpawn();

	bool CanReinforcenent() const;
	bool CanSpawn() const;
	TArray<class APawn*> GetAllNPCs() const;
	class APawn* GetNPC(int32 Param_Index) const;
	int32 GetNPCNum() const;
	class APawn* GetRandomNPC() const;
	struct FBox GetZoneControlBox() const;
	bool IsEmpty() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzNPCSpawner">();
	}
	static class AGzNPCSpawner* GetDefaultObj()
	{
		return GetDefaultObjImpl<AGzNPCSpawner>();
	}
};
static_assert(alignof(AGzNPCSpawner) == 0x000008, "Wrong alignment on AGzNPCSpawner");
static_assert(sizeof(AGzNPCSpawner) == 0x000308, "Wrong size on AGzNPCSpawner");
static_assert(offsetof(AGzNPCSpawner, bUseZoneControlBox) == 0x0002A0, "Member 'AGzNPCSpawner::bUseZoneControlBox' has a wrong offset!");
static_assert(offsetof(AGzNPCSpawner, bAutoSpawn) == 0x0002A1, "Member 'AGzNPCSpawner::bAutoSpawn' has a wrong offset!");
static_assert(offsetof(AGzNPCSpawner, MinAmountNPC) == 0x0002A4, "Member 'AGzNPCSpawner::MinAmountNPC' has a wrong offset!");
static_assert(offsetof(AGzNPCSpawner, MaxAmountNPC) == 0x0002A8, "Member 'AGzNPCSpawner::MaxAmountNPC' has a wrong offset!");
static_assert(offsetof(AGzNPCSpawner, SpawnNum) == 0x0002AC, "Member 'AGzNPCSpawner::SpawnNum' has a wrong offset!");
static_assert(offsetof(AGzNPCSpawner, ReinforcementInfinity) == 0x0002B0, "Member 'AGzNPCSpawner::ReinforcementInfinity' has a wrong offset!");
static_assert(offsetof(AGzNPCSpawner, CooldownTimer) == 0x0002B4, "Member 'AGzNPCSpawner::CooldownTimer' has a wrong offset!");
static_assert(offsetof(AGzNPCSpawner, SpawnTimer) == 0x0002C8, "Member 'AGzNPCSpawner::SpawnTimer' has a wrong offset!");
static_assert(offsetof(AGzNPCSpawner, OnSpawn_BP) == 0x0002DC, "Member 'AGzNPCSpawner::OnSpawn_BP' has a wrong offset!");
static_assert(offsetof(AGzNPCSpawner, OnReinforcement_BP) == 0x0002DD, "Member 'AGzNPCSpawner::OnReinforcement_BP' has a wrong offset!");
static_assert(offsetof(AGzNPCSpawner, ZoneControl) == 0x0002E0, "Member 'AGzNPCSpawner::ZoneControl' has a wrong offset!");

// Class G01.GzOfflineSessionManager
// 0x0048 (0x0078 - 0x0030)
class UGzOfflineSessionManager final : public UGameInstanceSubsystem
{
public:
	uint8                                         Pad_3442[0x48];                                    // 0x0030(0x0048)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	bool IsInOfflineSession() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzOfflineSessionManager">();
	}
	static class UGzOfflineSessionManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzOfflineSessionManager>();
	}
};
static_assert(alignof(UGzOfflineSessionManager) == 0x000008, "Wrong alignment on UGzOfflineSessionManager");
static_assert(sizeof(UGzOfflineSessionManager) == 0x000078, "Wrong size on UGzOfflineSessionManager");

// Class G01.GzPlayerRevealMarkerFilter
// 0x0000 (0x0038 - 0x0038)
class UGzPlayerRevealMarkerFilter final : public UGzMarkerActiveStateFilter
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzPlayerRevealMarkerFilter">();
	}
	static class UGzPlayerRevealMarkerFilter* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzPlayerRevealMarkerFilter>();
	}
};
static_assert(alignof(UGzPlayerRevealMarkerFilter) == 0x000008, "Wrong alignment on UGzPlayerRevealMarkerFilter");
static_assert(sizeof(UGzPlayerRevealMarkerFilter) == 0x000038, "Wrong size on UGzPlayerRevealMarkerFilter");

// Class G01.GzOfflineSessionModel
// 0x0010 (0x0080 - 0x0070)
class UGzOfflineSessionModel final : public UGzBackendModel
{
public:
	uint8                                         Pad_3443[0x10];                                    // 0x0070(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzOfflineSessionModel">();
	}
	static class UGzOfflineSessionModel* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzOfflineSessionModel>();
	}
};
static_assert(alignof(UGzOfflineSessionModel) == 0x000008, "Wrong alignment on UGzOfflineSessionModel");
static_assert(sizeof(UGzOfflineSessionModel) == 0x000080, "Wrong size on UGzOfflineSessionModel");

// Class G01.GzZoneDamageExecutionCalculation
// 0x0008 (0x0048 - 0x0040)
class UGzZoneDamageExecutionCalculation : public UGzDamageExecutionCalculation
{
public:
	bool                                          bApplyDamageToArmor;                               // 0x0040(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3444[0x7];                                     // 0x0041(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzZoneDamageExecutionCalculation">();
	}
	static class UGzZoneDamageExecutionCalculation* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzZoneDamageExecutionCalculation>();
	}
};
static_assert(alignof(UGzZoneDamageExecutionCalculation) == 0x000008, "Wrong alignment on UGzZoneDamageExecutionCalculation");
static_assert(sizeof(UGzZoneDamageExecutionCalculation) == 0x000048, "Wrong size on UGzZoneDamageExecutionCalculation");
static_assert(offsetof(UGzZoneDamageExecutionCalculation, bApplyDamageToArmor) == 0x000040, "Member 'UGzZoneDamageExecutionCalculation::bApplyDamageToArmor' has a wrong offset!");

// Class G01.GzOfflineSessionPreTravel
// 0x0018 (0x0078 - 0x0060)
class UGzOfflineSessionPreTravel final : public UGzFlowState
{
public:
	uint8                                         Pad_3445[0x18];                                    // 0x0060(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzOfflineSessionPreTravel">();
	}
	static class UGzOfflineSessionPreTravel* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzOfflineSessionPreTravel>();
	}
};
static_assert(alignof(UGzOfflineSessionPreTravel) == 0x000008, "Wrong alignment on UGzOfflineSessionPreTravel");
static_assert(sizeof(UGzOfflineSessionPreTravel) == 0x000078, "Wrong size on UGzOfflineSessionPreTravel");

// Class G01.GzOfflineSessionSettings
// 0x0050 (0x0088 - 0x0038)
class UGzOfflineSessionSettings final : public UDeveloperSettings
{
public:
	TMap<class FString, struct FGzOfflineGameModeData> OfflineGameModes;                                  // 0x0038(0x0050)(Edit, Config, DisableEditOnInstance, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzOfflineSessionSettings">();
	}
	static class UGzOfflineSessionSettings* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzOfflineSessionSettings>();
	}
};
static_assert(alignof(UGzOfflineSessionSettings) == 0x000008, "Wrong alignment on UGzOfflineSessionSettings");
static_assert(sizeof(UGzOfflineSessionSettings) == 0x000088, "Wrong size on UGzOfflineSessionSettings");
static_assert(offsetof(UGzOfflineSessionSettings, OfflineGameModes) == 0x000038, "Member 'UGzOfflineSessionSettings::OfflineGameModes' has a wrong offset!");

// Class G01.GzOfflineSessionState
// 0x0008 (0x0068 - 0x0060)
class UGzOfflineSessionState final : public UGzFlowState
{
public:
	uint8                                         Pad_3446[0x8];                                     // 0x0060(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzOfflineSessionState">();
	}
	static class UGzOfflineSessionState* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzOfflineSessionState>();
	}
};
static_assert(alignof(UGzOfflineSessionState) == 0x000008, "Wrong alignment on UGzOfflineSessionState");
static_assert(sizeof(UGzOfflineSessionState) == 0x000068, "Wrong size on UGzOfflineSessionState");

// Class G01.GzPlayFabClientSettings
// 0x0010 (0x0038 - 0x0028)
class UGzPlayFabClientSettings final : public UObject
{
public:
	class FString                                 TitleId;                                           // 0x0028(0x0010)(ZeroConstructor, Config, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzPlayFabClientSettings">();
	}
	static class UGzPlayFabClientSettings* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzPlayFabClientSettings>();
	}
};
static_assert(alignof(UGzPlayFabClientSettings) == 0x000008, "Wrong alignment on UGzPlayFabClientSettings");
static_assert(sizeof(UGzPlayFabClientSettings) == 0x000038, "Wrong size on UGzPlayFabClientSettings");
static_assert(offsetof(UGzPlayFabClientSettings, TitleId) == 0x000028, "Member 'UGzPlayFabClientSettings::TitleId' has a wrong offset!");

// Class G01.GzOfflineSessionTravelState
// 0x0078 (0x00D8 - 0x0060)
class UGzOfflineSessionTravelState final : public UGzFlowState
{
public:
	uint8                                         Pad_3447[0x78];                                    // 0x0060(0x0078)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzOfflineSessionTravelState">();
	}
	static class UGzOfflineSessionTravelState* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzOfflineSessionTravelState>();
	}
};
static_assert(alignof(UGzOfflineSessionTravelState) == 0x000008, "Wrong alignment on UGzOfflineSessionTravelState");
static_assert(sizeof(UGzOfflineSessionTravelState) == 0x0000D8, "Wrong size on UGzOfflineSessionTravelState");

// Class G01.GzOffsetedCenterPolicy
// 0x0020 (0x00B8 - 0x0098)
class UGzOffsetedCenterPolicy final : public UGzZoneSelectionPolicy
{
public:
	float                                         RadiusMultiplier;                                  // 0x0098(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         RadiusDecreaseFactor;                              // 0x009C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_3448[0x18];                                    // 0x00A0(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzOffsetedCenterPolicy">();
	}
	static class UGzOffsetedCenterPolicy* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzOffsetedCenterPolicy>();
	}
};
static_assert(alignof(UGzOffsetedCenterPolicy) == 0x000008, "Wrong alignment on UGzOffsetedCenterPolicy");
static_assert(sizeof(UGzOffsetedCenterPolicy) == 0x0000B8, "Wrong size on UGzOffsetedCenterPolicy");
static_assert(offsetof(UGzOffsetedCenterPolicy, RadiusMultiplier) == 0x000098, "Member 'UGzOffsetedCenterPolicy::RadiusMultiplier' has a wrong offset!");
static_assert(offsetof(UGzOffsetedCenterPolicy, RadiusDecreaseFactor) == 0x00009C, "Member 'UGzOffsetedCenterPolicy::RadiusDecreaseFactor' has a wrong offset!");

// Class G01.GzOnboardingModel
// 0x0030 (0x00A0 - 0x0070)
class UGzOnboardingModel final : public UGzBackendModel
{
public:
	uint8                                         Pad_3449[0x18];                                    // 0x0070(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UAkAudioEvent*>                  PreloadedOnboardingSounds;                         // 0x0088(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	uint8                                         Pad_344A[0x8];                                     // 0x0098(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzOnboardingModel">();
	}
	static class UGzOnboardingModel* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzOnboardingModel>();
	}
};
static_assert(alignof(UGzOnboardingModel) == 0x000008, "Wrong alignment on UGzOnboardingModel");
static_assert(sizeof(UGzOnboardingModel) == 0x0000A0, "Wrong size on UGzOnboardingModel");
static_assert(offsetof(UGzOnboardingModel, PreloadedOnboardingSounds) == 0x000088, "Member 'UGzOnboardingModel::PreloadedOnboardingSounds' has a wrong offset!");

// Class G01.GzZiplineMovementSettings
// 0x0048 (0x0078 - 0x0030)
class UGzZiplineMovementSettings final : public UDataAsset
{
public:
	float                                         ActivationAngleThreshold;                          // 0x0030(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MoveAlongZiplineSpeedWhileMovingToIt;              // 0x0034(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MoveToZiplineSpeed;                                // 0x0038(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AccelerationTime;                                  // 0x003C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCurveFloat*                            AccelerationCurve;                                 // 0x0040(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinMoveAlongZiplineSpeed;                          // 0x0048(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxMoveAlongZiplineSpeed;                          // 0x004C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DecelerationTime;                                  // 0x0050(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_344B[0x4];                                     // 0x0054(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UCurveFloat*                            DecelerationCurve;                                 // 0x0058(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         JumpOffSpeed;                                      // 0x0060(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         JumpOffMaxRelativeHeight;                          // 0x0064(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCurveFloat*                            JumpOffHeightCurve;                                // 0x0068(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         JumpOffAngleOnSuccess;                             // 0x0070(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         JumpOffAngleOnCancel;                              // 0x0074(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzZiplineMovementSettings">();
	}
	static class UGzZiplineMovementSettings* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzZiplineMovementSettings>();
	}
};
static_assert(alignof(UGzZiplineMovementSettings) == 0x000008, "Wrong alignment on UGzZiplineMovementSettings");
static_assert(sizeof(UGzZiplineMovementSettings) == 0x000078, "Wrong size on UGzZiplineMovementSettings");
static_assert(offsetof(UGzZiplineMovementSettings, ActivationAngleThreshold) == 0x000030, "Member 'UGzZiplineMovementSettings::ActivationAngleThreshold' has a wrong offset!");
static_assert(offsetof(UGzZiplineMovementSettings, MoveAlongZiplineSpeedWhileMovingToIt) == 0x000034, "Member 'UGzZiplineMovementSettings::MoveAlongZiplineSpeedWhileMovingToIt' has a wrong offset!");
static_assert(offsetof(UGzZiplineMovementSettings, MoveToZiplineSpeed) == 0x000038, "Member 'UGzZiplineMovementSettings::MoveToZiplineSpeed' has a wrong offset!");
static_assert(offsetof(UGzZiplineMovementSettings, AccelerationTime) == 0x00003C, "Member 'UGzZiplineMovementSettings::AccelerationTime' has a wrong offset!");
static_assert(offsetof(UGzZiplineMovementSettings, AccelerationCurve) == 0x000040, "Member 'UGzZiplineMovementSettings::AccelerationCurve' has a wrong offset!");
static_assert(offsetof(UGzZiplineMovementSettings, MinMoveAlongZiplineSpeed) == 0x000048, "Member 'UGzZiplineMovementSettings::MinMoveAlongZiplineSpeed' has a wrong offset!");
static_assert(offsetof(UGzZiplineMovementSettings, MaxMoveAlongZiplineSpeed) == 0x00004C, "Member 'UGzZiplineMovementSettings::MaxMoveAlongZiplineSpeed' has a wrong offset!");
static_assert(offsetof(UGzZiplineMovementSettings, DecelerationTime) == 0x000050, "Member 'UGzZiplineMovementSettings::DecelerationTime' has a wrong offset!");
static_assert(offsetof(UGzZiplineMovementSettings, DecelerationCurve) == 0x000058, "Member 'UGzZiplineMovementSettings::DecelerationCurve' has a wrong offset!");
static_assert(offsetof(UGzZiplineMovementSettings, JumpOffSpeed) == 0x000060, "Member 'UGzZiplineMovementSettings::JumpOffSpeed' has a wrong offset!");
static_assert(offsetof(UGzZiplineMovementSettings, JumpOffMaxRelativeHeight) == 0x000064, "Member 'UGzZiplineMovementSettings::JumpOffMaxRelativeHeight' has a wrong offset!");
static_assert(offsetof(UGzZiplineMovementSettings, JumpOffHeightCurve) == 0x000068, "Member 'UGzZiplineMovementSettings::JumpOffHeightCurve' has a wrong offset!");
static_assert(offsetof(UGzZiplineMovementSettings, JumpOffAngleOnSuccess) == 0x000070, "Member 'UGzZiplineMovementSettings::JumpOffAngleOnSuccess' has a wrong offset!");
static_assert(offsetof(UGzZiplineMovementSettings, JumpOffAngleOnCancel) == 0x000074, "Member 'UGzZiplineMovementSettings::JumpOffAngleOnCancel' has a wrong offset!");

// Class G01.GzOnboardingState
// 0x0000 (0x0070 - 0x0070)
class UGzOnboardingState final : public UGzFlowStateWithActionGraph
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzOnboardingState">();
	}
	static class UGzOnboardingState* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzOnboardingState>();
	}
};
static_assert(alignof(UGzOnboardingState) == 0x000008, "Wrong alignment on UGzOnboardingState");
static_assert(sizeof(UGzOnboardingState) == 0x000070, "Wrong size on UGzOnboardingState");

// Class G01.GzPlinkConfigurationSettings
// 0x0018 (0x0050 - 0x0038)
class UGzPlinkConfigurationSettings final : public UDeveloperSettings
{
public:
	uint8                                         Pad_344C[0x8];                                     // 0x0038(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<TSoftObjectPtr<class UGzRewardData>>   Rewards;                                           // 0x0040(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, DisableEditOnInstance, UObjectWrapper, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzPlinkConfigurationSettings">();
	}
	static class UGzPlinkConfigurationSettings* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzPlinkConfigurationSettings>();
	}
};
static_assert(alignof(UGzPlinkConfigurationSettings) == 0x000008, "Wrong alignment on UGzPlinkConfigurationSettings");
static_assert(sizeof(UGzPlinkConfigurationSettings) == 0x000050, "Wrong size on UGzPlinkConfigurationSettings");
static_assert(offsetof(UGzPlinkConfigurationSettings, Rewards) == 0x000040, "Member 'UGzPlinkConfigurationSettings::Rewards' has a wrong offset!");

// Class G01.GzOnlineClientDisableComponent
// 0x0020 (0x00C0 - 0x00A0)
class UGzOnlineClientDisableComponent final : public UGzServiceComponent
{
public:
	uint8                                         Pad_344D[0x20];                                    // 0x00A0(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzOnlineClientDisableComponent">();
	}
	static class UGzOnlineClientDisableComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzOnlineClientDisableComponent>();
	}
};
static_assert(alignof(UGzOnlineClientDisableComponent) == 0x000008, "Wrong alignment on UGzOnlineClientDisableComponent");
static_assert(sizeof(UGzOnlineClientDisableComponent) == 0x0000C0, "Wrong size on UGzOnlineClientDisableComponent");

// Class G01.GzZoneTrackingManager
// 0x0000 (0x0028 - 0x0028)
class IGzZoneTrackingManager final : public IInterface
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzZoneTrackingManager">();
	}
	static class IGzZoneTrackingManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<IGzZoneTrackingManager>();
	}
};
static_assert(alignof(IGzZoneTrackingManager) == 0x000008, "Wrong alignment on IGzZoneTrackingManager");
static_assert(sizeof(IGzZoneTrackingManager) == 0x000028, "Wrong size on IGzZoneTrackingManager");

// Class G01.GzOnlineInventoryItem
// 0x0060 (0x0088 - 0x0028)
class UGzOnlineInventoryItem : public UObject
{
public:
	class UGzItemData*                            AssetData;                                         // 0x0028(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   AssetName;                                         // 0x0030(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EGzItemType                                   Type;                                              // 0x0038(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_344E[0x7];                                     // 0x0039(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 Guid;                                              // 0x0040(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   ItemNftId;                                         // 0x0050(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EGzMarketplaceState                           MarketplaceState;                                  // 0x0058(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EGzItemSource                                 ItemSource;                                        // 0x0059(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_344F[0x6];                                     // 0x005A(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	struct FDateTime                              CreatedAt;                                         // 0x0060(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FDateTime                              Updated;                                           // 0x0068(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bReviewed;                                         // 0x0070(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3450[0x7];                                     // 0x0071(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	int64                                         SerialNumber;                                      // 0x0078(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FDateTime                              LastTradeTimestamp;                                // 0x0080(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzOnlineInventoryItem">();
	}
	static class UGzOnlineInventoryItem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzOnlineInventoryItem>();
	}
};
static_assert(alignof(UGzOnlineInventoryItem) == 0x000008, "Wrong alignment on UGzOnlineInventoryItem");
static_assert(sizeof(UGzOnlineInventoryItem) == 0x000088, "Wrong size on UGzOnlineInventoryItem");
static_assert(offsetof(UGzOnlineInventoryItem, AssetData) == 0x000028, "Member 'UGzOnlineInventoryItem::AssetData' has a wrong offset!");
static_assert(offsetof(UGzOnlineInventoryItem, AssetName) == 0x000030, "Member 'UGzOnlineInventoryItem::AssetName' has a wrong offset!");
static_assert(offsetof(UGzOnlineInventoryItem, Type) == 0x000038, "Member 'UGzOnlineInventoryItem::Type' has a wrong offset!");
static_assert(offsetof(UGzOnlineInventoryItem, Guid) == 0x000040, "Member 'UGzOnlineInventoryItem::Guid' has a wrong offset!");
static_assert(offsetof(UGzOnlineInventoryItem, ItemNftId) == 0x000050, "Member 'UGzOnlineInventoryItem::ItemNftId' has a wrong offset!");
static_assert(offsetof(UGzOnlineInventoryItem, MarketplaceState) == 0x000058, "Member 'UGzOnlineInventoryItem::MarketplaceState' has a wrong offset!");
static_assert(offsetof(UGzOnlineInventoryItem, ItemSource) == 0x000059, "Member 'UGzOnlineInventoryItem::ItemSource' has a wrong offset!");
static_assert(offsetof(UGzOnlineInventoryItem, CreatedAt) == 0x000060, "Member 'UGzOnlineInventoryItem::CreatedAt' has a wrong offset!");
static_assert(offsetof(UGzOnlineInventoryItem, Updated) == 0x000068, "Member 'UGzOnlineInventoryItem::Updated' has a wrong offset!");
static_assert(offsetof(UGzOnlineInventoryItem, bReviewed) == 0x000070, "Member 'UGzOnlineInventoryItem::bReviewed' has a wrong offset!");
static_assert(offsetof(UGzOnlineInventoryItem, SerialNumber) == 0x000078, "Member 'UGzOnlineInventoryItem::SerialNumber' has a wrong offset!");
static_assert(offsetof(UGzOnlineInventoryItem, LastTradeTimestamp) == 0x000080, "Member 'UGzOnlineInventoryItem::LastTradeTimestamp' has a wrong offset!");

// Class G01.GzOnlineContainerItem
// 0x0008 (0x0090 - 0x0088)
class UGzOnlineContainerItem final : public UGzOnlineInventoryItem
{
public:
	bool                                          bDecodingState;                                    // 0x0088(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3451[0x7];                                     // 0x0089(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzOnlineContainerItem">();
	}
	static class UGzOnlineContainerItem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzOnlineContainerItem>();
	}
};
static_assert(alignof(UGzOnlineContainerItem) == 0x000008, "Wrong alignment on UGzOnlineContainerItem");
static_assert(sizeof(UGzOnlineContainerItem) == 0x000090, "Wrong size on UGzOnlineContainerItem");
static_assert(offsetof(UGzOnlineContainerItem, bDecodingState) == 0x000088, "Member 'UGzOnlineContainerItem::bDecodingState' has a wrong offset!");

// Class G01.GzOnlineMatchRecoveryManager
// 0x0080 (0x00A8 - 0x0028)
class UGzOnlineMatchRecoveryManager final : public UObject
{
public:
	uint8                                         Pad_3452[0x78];                                    // 0x0028(0x0078)(Fixing Size After Last Property [ Dumper-7 ])
	class UGzPlayerCanJoinServerValidator*        PlayerCanJoinServerValidator;                      // 0x00A0(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzOnlineMatchRecoveryManager">();
	}
	static class UGzOnlineMatchRecoveryManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzOnlineMatchRecoveryManager>();
	}
};
static_assert(alignof(UGzOnlineMatchRecoveryManager) == 0x000008, "Wrong alignment on UGzOnlineMatchRecoveryManager");
static_assert(sizeof(UGzOnlineMatchRecoveryManager) == 0x0000A8, "Wrong size on UGzOnlineMatchRecoveryManager");
static_assert(offsetof(UGzOnlineMatchRecoveryManager, PlayerCanJoinServerValidator) == 0x0000A0, "Member 'UGzOnlineMatchRecoveryManager::PlayerCanJoinServerValidator' has a wrong offset!");

// Class G01.GzOnlineSessionReportingComponent
// 0x0018 (0x00B8 - 0x00A0)
class UGzOnlineSessionReportingComponent final : public UGzServiceComponent
{
public:
	uint8                                         Pad_3453[0x18];                                    // 0x00A0(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzOnlineSessionReportingComponent">();
	}
	static class UGzOnlineSessionReportingComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzOnlineSessionReportingComponent>();
	}
};
static_assert(alignof(UGzOnlineSessionReportingComponent) == 0x000008, "Wrong alignment on UGzOnlineSessionReportingComponent");
static_assert(sizeof(UGzOnlineSessionReportingComponent) == 0x0000B8, "Wrong size on UGzOnlineSessionReportingComponent");

// Class G01.GzZoneStatsCollector
// 0x0000 (0x0038 - 0x0038)
class UGzZoneStatsCollector : public UGzGlobalStatsCollector
{
public:
	void SubmitZoneStats(int32 PlayerId, const struct FGzGameStat& Stat);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzZoneStatsCollector">();
	}
	static class UGzZoneStatsCollector* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzZoneStatsCollector>();
	}
};
static_assert(alignof(UGzZoneStatsCollector) == 0x000008, "Wrong alignment on UGzZoneStatsCollector");
static_assert(sizeof(UGzZoneStatsCollector) == 0x000038, "Wrong size on UGzZoneStatsCollector");

// Class G01.GzZoneDeathsStatsCollector
// 0x0000 (0x0038 - 0x0038)
class UGzZoneDeathsStatsCollector final : public UGzZoneStatsCollector
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzZoneDeathsStatsCollector">();
	}
	static class UGzZoneDeathsStatsCollector* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzZoneDeathsStatsCollector>();
	}
};
static_assert(alignof(UGzZoneDeathsStatsCollector) == 0x000008, "Wrong alignment on UGzZoneDeathsStatsCollector");
static_assert(sizeof(UGzZoneDeathsStatsCollector) == 0x000038, "Wrong size on UGzZoneDeathsStatsCollector");

// Class G01.GzOnlineSessionState
// 0x0008 (0x0068 - 0x0060)
class UGzOnlineSessionState final : public UGzFlowState
{
public:
	uint8                                         Pad_3455[0x8];                                     // 0x0060(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzOnlineSessionState">();
	}
	static class UGzOnlineSessionState* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzOnlineSessionState>();
	}
};
static_assert(alignof(UGzOnlineSessionState) == 0x000008, "Wrong alignment on UGzOnlineSessionState");
static_assert(sizeof(UGzOnlineSessionState) == 0x000068, "Wrong size on UGzOnlineSessionState");

// Class G01.GzRecastNavMeshDataChunk
// 0x0018 (0x0058 - 0x0040)
class UGzRecastNavMeshDataChunk final : public URecastNavMeshDataChunk
{
public:
	TArray<struct FGzCoverData>                   Covers;                                            // 0x0040(0x0010)(Edit, ZeroConstructor, EditConst, NativeAccessSpecifierPublic)
	int32                                         UpdChangelistNumber;                               // 0x0050(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         NumberOfNavLinks;                                  // 0x0054(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzRecastNavMeshDataChunk">();
	}
	static class UGzRecastNavMeshDataChunk* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzRecastNavMeshDataChunk>();
	}
};
static_assert(alignof(UGzRecastNavMeshDataChunk) == 0x000008, "Wrong alignment on UGzRecastNavMeshDataChunk");
static_assert(sizeof(UGzRecastNavMeshDataChunk) == 0x000058, "Wrong size on UGzRecastNavMeshDataChunk");
static_assert(offsetof(UGzRecastNavMeshDataChunk, Covers) == 0x000040, "Member 'UGzRecastNavMeshDataChunk::Covers' has a wrong offset!");
static_assert(offsetof(UGzRecastNavMeshDataChunk, UpdChangelistNumber) == 0x000050, "Member 'UGzRecastNavMeshDataChunk::UpdChangelistNumber' has a wrong offset!");
static_assert(offsetof(UGzRecastNavMeshDataChunk, NumberOfNavLinks) == 0x000054, "Member 'UGzRecastNavMeshDataChunk::NumberOfNavLinks' has a wrong offset!");

// Class G01.GzOpenLootContainerMessage
// 0x0000 (0x0030 - 0x0030)
class UGzOpenLootContainerMessage final : public UGzInstigatedMessage
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzOpenLootContainerMessage">();
	}
	static class UGzOpenLootContainerMessage* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzOpenLootContainerMessage>();
	}
};
static_assert(alignof(UGzOpenLootContainerMessage) == 0x000008, "Wrong alignment on UGzOpenLootContainerMessage");
static_assert(sizeof(UGzOpenLootContainerMessage) == 0x000030, "Wrong size on UGzOpenLootContainerMessage");

// Class G01.GzOpenLootSpawner
// 0x0010 (0x02D8 - 0x02C8)
class AGzOpenLootSpawner : public AGzLootSpawner
{
public:
	bool                                          bSpawnOnBeginPlay;                                 // 0x02C8(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3456[0xF];                                     // 0x02C9(0x000F)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void CheckStageToSpawn();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzOpenLootSpawner">();
	}
	static class AGzOpenLootSpawner* GetDefaultObj()
	{
		return GetDefaultObjImpl<AGzOpenLootSpawner>();
	}
};
static_assert(alignof(AGzOpenLootSpawner) == 0x000008, "Wrong alignment on AGzOpenLootSpawner");
static_assert(sizeof(AGzOpenLootSpawner) == 0x0002D8, "Wrong size on AGzOpenLootSpawner");
static_assert(offsetof(AGzOpenLootSpawner, bSpawnOnBeginPlay) == 0x0002C8, "Member 'AGzOpenLootSpawner::bSpawnOnBeginPlay' has a wrong offset!");

// Class G01.GzRectangleMarkerShape
// 0x0010 (0x0048 - 0x0038)
class UGzRectangleMarkerShape final : public UGzMarkerShape
{
public:
	struct FVector2D                              RectSize;                                          // 0x0038(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void SetRectSize(const struct FVector2D& InSize);

	const struct FVector2D GetWorldRectSize() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzRectangleMarkerShape">();
	}
	static class UGzRectangleMarkerShape* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzRectangleMarkerShape>();
	}
};
static_assert(alignof(UGzRectangleMarkerShape) == 0x000008, "Wrong alignment on UGzRectangleMarkerShape");
static_assert(sizeof(UGzRectangleMarkerShape) == 0x000048, "Wrong size on UGzRectangleMarkerShape");
static_assert(offsetof(UGzRectangleMarkerShape, RectSize) == 0x000038, "Member 'UGzRectangleMarkerShape::RectSize' has a wrong offset!");

// Class G01.GzOpportunityMissionData_BountyHunter
// 0x0070 (0x0238 - 0x01C8)
class UGzOpportunityMissionData_BountyHunter final : public UGzOpportunityMissionData
{
public:
	TMap<int32, int32>                            TeamSizeDifferenceToScore;                         // 0x01C8(0x0050)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	int32                                         DoesNotHaveMissionScoreBonus;                      // 0x0218(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         HasNonBountyHunterMissionScoreBonus;               // 0x021C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FDistanceBasedScore>            DistanceBasedScore;                                // 0x0220(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	float                                         RecentSpawnConsiderationTime;                      // 0x0230(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ScorePenaltyForRecentlySpawned;                    // 0x0234(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzOpportunityMissionData_BountyHunter">();
	}
	static class UGzOpportunityMissionData_BountyHunter* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzOpportunityMissionData_BountyHunter>();
	}
};
static_assert(alignof(UGzOpportunityMissionData_BountyHunter) == 0x000008, "Wrong alignment on UGzOpportunityMissionData_BountyHunter");
static_assert(sizeof(UGzOpportunityMissionData_BountyHunter) == 0x000238, "Wrong size on UGzOpportunityMissionData_BountyHunter");
static_assert(offsetof(UGzOpportunityMissionData_BountyHunter, TeamSizeDifferenceToScore) == 0x0001C8, "Member 'UGzOpportunityMissionData_BountyHunter::TeamSizeDifferenceToScore' has a wrong offset!");
static_assert(offsetof(UGzOpportunityMissionData_BountyHunter, DoesNotHaveMissionScoreBonus) == 0x000218, "Member 'UGzOpportunityMissionData_BountyHunter::DoesNotHaveMissionScoreBonus' has a wrong offset!");
static_assert(offsetof(UGzOpportunityMissionData_BountyHunter, HasNonBountyHunterMissionScoreBonus) == 0x00021C, "Member 'UGzOpportunityMissionData_BountyHunter::HasNonBountyHunterMissionScoreBonus' has a wrong offset!");
static_assert(offsetof(UGzOpportunityMissionData_BountyHunter, DistanceBasedScore) == 0x000220, "Member 'UGzOpportunityMissionData_BountyHunter::DistanceBasedScore' has a wrong offset!");
static_assert(offsetof(UGzOpportunityMissionData_BountyHunter, RecentSpawnConsiderationTime) == 0x000230, "Member 'UGzOpportunityMissionData_BountyHunter::RecentSpawnConsiderationTime' has a wrong offset!");
static_assert(offsetof(UGzOpportunityMissionData_BountyHunter, ScorePenaltyForRecentlySpawned) == 0x000234, "Member 'UGzOpportunityMissionData_BountyHunter::ScorePenaltyForRecentlySpawned' has a wrong offset!");

// Class G01.GzOpportunityViewportMarkerWidget
// 0x0000 (0x0398 - 0x0398)
class UGzOpportunityViewportMarkerWidget final : public UGzViewportMarkerWidget
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzOpportunityViewportMarkerWidget">();
	}
	static class UGzOpportunityViewportMarkerWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzOpportunityViewportMarkerWidget>();
	}
};
static_assert(alignof(UGzOpportunityViewportMarkerWidget) == 0x000008, "Wrong alignment on UGzOpportunityViewportMarkerWidget");
static_assert(sizeof(UGzOpportunityViewportMarkerWidget) == 0x000398, "Wrong size on UGzOpportunityViewportMarkerWidget");

// Class G01.GzVideoSettingDiscreteDynamic
// 0x0000 (0x01B8 - 0x01B8)
class UGzVideoSettingDiscreteDynamic : public UGameSettingValueDiscreteDynamic
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzVideoSettingDiscreteDynamic">();
	}
	static class UGzVideoSettingDiscreteDynamic* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzVideoSettingDiscreteDynamic>();
	}
};
static_assert(alignof(UGzVideoSettingDiscreteDynamic) == 0x000008, "Wrong alignment on UGzVideoSettingDiscreteDynamic");
static_assert(sizeof(UGzVideoSettingDiscreteDynamic) == 0x0001B8, "Wrong size on UGzVideoSettingDiscreteDynamic");

// Class G01.GzRenderItemIconsGameMode
// 0x0080 (0x03B8 - 0x0338)
class AGzRenderItemIconsGameMode final : public AGameModeBase
{
public:
	class AGzCustomizationItemSpawner*            CustomizationItemSpawner;                          // 0x0338(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AGzAttachementItemSpawner*              WeaponAttachmentItemSpawner;                       // 0x0340(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AGzWeaponAttachementSpawner*            AttachmentItemSpawner;                             // 0x0348(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AGzWeaponItemSpawner*                   WeaponItemSpawner;                                 // 0x0350(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AGzItemIconRenderer*                    ItemIconRenderer;                                  // 0x0358(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class UGzCustomizationItemTemplate*>   CustomizationItemDatas;                            // 0x0360(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	TArray<class UGzWeaponAttachmentItemData*>    AttachmentItemDatas;                               // 0x0370(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	TArray<class UGzWeaponItemData*>              WeaponItemDatas;                                   // 0x0380(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	uint8                                         Pad_3457[0x28];                                    // 0x0390(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzRenderItemIconsGameMode">();
	}
	static class AGzRenderItemIconsGameMode* GetDefaultObj()
	{
		return GetDefaultObjImpl<AGzRenderItemIconsGameMode>();
	}
};
static_assert(alignof(AGzRenderItemIconsGameMode) == 0x000008, "Wrong alignment on AGzRenderItemIconsGameMode");
static_assert(sizeof(AGzRenderItemIconsGameMode) == 0x0003B8, "Wrong size on AGzRenderItemIconsGameMode");
static_assert(offsetof(AGzRenderItemIconsGameMode, CustomizationItemSpawner) == 0x000338, "Member 'AGzRenderItemIconsGameMode::CustomizationItemSpawner' has a wrong offset!");
static_assert(offsetof(AGzRenderItemIconsGameMode, WeaponAttachmentItemSpawner) == 0x000340, "Member 'AGzRenderItemIconsGameMode::WeaponAttachmentItemSpawner' has a wrong offset!");
static_assert(offsetof(AGzRenderItemIconsGameMode, AttachmentItemSpawner) == 0x000348, "Member 'AGzRenderItemIconsGameMode::AttachmentItemSpawner' has a wrong offset!");
static_assert(offsetof(AGzRenderItemIconsGameMode, WeaponItemSpawner) == 0x000350, "Member 'AGzRenderItemIconsGameMode::WeaponItemSpawner' has a wrong offset!");
static_assert(offsetof(AGzRenderItemIconsGameMode, ItemIconRenderer) == 0x000358, "Member 'AGzRenderItemIconsGameMode::ItemIconRenderer' has a wrong offset!");
static_assert(offsetof(AGzRenderItemIconsGameMode, CustomizationItemDatas) == 0x000360, "Member 'AGzRenderItemIconsGameMode::CustomizationItemDatas' has a wrong offset!");
static_assert(offsetof(AGzRenderItemIconsGameMode, AttachmentItemDatas) == 0x000370, "Member 'AGzRenderItemIconsGameMode::AttachmentItemDatas' has a wrong offset!");
static_assert(offsetof(AGzRenderItemIconsGameMode, WeaponItemDatas) == 0x000380, "Member 'AGzRenderItemIconsGameMode::WeaponItemDatas' has a wrong offset!");

// Class G01.GzOverallVideoSetting
// 0x0010 (0x01C8 - 0x01B8)
class UGzOverallVideoSetting : public UGzVideoSettingDiscreteDynamic
{
public:
	class FText                                   CustomOptionDisplayText;                           // 0x01B8(0x0010)(Edit, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzOverallVideoSetting">();
	}
	static class UGzOverallVideoSetting* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzOverallVideoSetting>();
	}
};
static_assert(alignof(UGzOverallVideoSetting) == 0x000008, "Wrong alignment on UGzOverallVideoSetting");
static_assert(sizeof(UGzOverallVideoSetting) == 0x0001C8, "Wrong size on UGzOverallVideoSetting");
static_assert(offsetof(UGzOverallVideoSetting, CustomOptionDisplayText) == 0x0001B8, "Member 'UGzOverallVideoSetting::CustomOptionDisplayText' has a wrong offset!");

// Class G01.GzOverloadingZoneBordersExtension
// 0x0078 (0x00B0 - 0x0038)
class UGzOverloadingZoneBordersExtension : public UGzMapWidgetExtension
{
public:
	TSoftClassPtr<class UClass>                   SplineWidgetClass;                                 // 0x0038(0x0028)(Edit, DisableEditOnInstance, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TMap<class AGzBattleRoyaleZone*, class UGzSplineMapWidget*> OverloadingZoneBorders;                            // 0x0060(0x0050)(ExportObject, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)

public:
	void OnZoneStartedOverload(class AGzBattleRoyaleZone* Zone);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzOverloadingZoneBordersExtension">();
	}
	static class UGzOverloadingZoneBordersExtension* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzOverloadingZoneBordersExtension>();
	}
};
static_assert(alignof(UGzOverloadingZoneBordersExtension) == 0x000008, "Wrong alignment on UGzOverloadingZoneBordersExtension");
static_assert(sizeof(UGzOverloadingZoneBordersExtension) == 0x0000B0, "Wrong size on UGzOverloadingZoneBordersExtension");
static_assert(offsetof(UGzOverloadingZoneBordersExtension, SplineWidgetClass) == 0x000038, "Member 'UGzOverloadingZoneBordersExtension::SplineWidgetClass' has a wrong offset!");
static_assert(offsetof(UGzOverloadingZoneBordersExtension, OverloadingZoneBorders) == 0x000060, "Member 'UGzOverloadingZoneBordersExtension::OverloadingZoneBorders' has a wrong offset!");

// Class G01.GzOwnerClassMarkerFilter
// 0x0010 (0x0048 - 0x0038)
class UGzOwnerClassMarkerFilter : public UGzMarkerActiveStateFilter
{
public:
	TArray<TSubclassOf<class AActor>>             AllowedMarkerOwnerClasses;                         // 0x0038(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, Protected, UObjectWrapper, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzOwnerClassMarkerFilter">();
	}
	static class UGzOwnerClassMarkerFilter* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzOwnerClassMarkerFilter>();
	}
};
static_assert(alignof(UGzOwnerClassMarkerFilter) == 0x000008, "Wrong alignment on UGzOwnerClassMarkerFilter");
static_assert(sizeof(UGzOwnerClassMarkerFilter) == 0x000048, "Wrong size on UGzOwnerClassMarkerFilter");
static_assert(offsetof(UGzOwnerClassMarkerFilter, AllowedMarkerOwnerClasses) == 0x000038, "Member 'UGzOwnerClassMarkerFilter::AllowedMarkerOwnerClasses' has a wrong offset!");

// Class G01.GzOwnOffersCacheComponent
// 0x00A0 (0x0140 - 0x00A0)
class UGzOwnOffersCacheComponent final : public UGzServiceComponent
{
public:
	uint8                                         Pad_3458[0xA0];                                    // 0x00A0(0x00A0)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzOwnOffersCacheComponent">();
	}
	static class UGzOwnOffersCacheComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzOwnOffersCacheComponent>();
	}
};
static_assert(alignof(UGzOwnOffersCacheComponent) == 0x000008, "Wrong alignment on UGzOwnOffersCacheComponent");
static_assert(sizeof(UGzOwnOffersCacheComponent) == 0x000140, "Wrong size on UGzOwnOffersCacheComponent");

// Class G01.GzReplicatedCommandInterface
// 0x0000 (0x0028 - 0x0028)
class IGzReplicatedCommandInterface final : public IInterface
{
public:
	bool IsReplicatedDateInitialized() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzReplicatedCommandInterface">();
	}
	static class IGzReplicatedCommandInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IGzReplicatedCommandInterface>();
	}
};
static_assert(alignof(IGzReplicatedCommandInterface) == 0x000008, "Wrong alignment on IGzReplicatedCommandInterface");
static_assert(sizeof(IGzReplicatedCommandInterface) == 0x000028, "Wrong size on IGzReplicatedCommandInterface");

// Class G01.GzPartitionNavDataDelegate
// 0x0000 (0x0030 - 0x0030)
class UGzPartitionNavDataDelegate final : public UGzBaseNavDataDelegate
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzPartitionNavDataDelegate">();
	}
	static class UGzPartitionNavDataDelegate* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzPartitionNavDataDelegate>();
	}
};
static_assert(alignof(UGzPartitionNavDataDelegate) == 0x000008, "Wrong alignment on UGzPartitionNavDataDelegate");
static_assert(sizeof(UGzPartitionNavDataDelegate) == 0x000030, "Wrong size on UGzPartitionNavDataDelegate");

// Class G01.GzPartyCustomization
// 0x0070 (0x0310 - 0x02A0)
class AGzPartyCustomization final : public AActor
{
public:
	TArray<class AGzPartyMemberDisplaySlot*>      Slots;                                             // 0x02A0(0x0010)(Edit, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnPlayerTalkingStateChanged;                       // 0x02B0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnPlayerVoiceChatStateChanged;                     // 0x02C0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnPlayerNameChanged;                               // 0x02D0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnMatchmakingStatusChanged;                        // 0x02E0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnPartyMembershipStateChanged;                     // 0x02F0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnMiscDataUpdated;                                 // 0x0300(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)

public:
	class FString GetDisplayName(const class AGzCharacter* Character);
	bool GetMatchmakingStatus(const class AGzCharacter* Character);
	void GzMatchmakingStatusChanged__DelegateSignature(const class AGzCharacter* Character, bool bStatus);
	void GzMiscDataUpdated__DelegateSignature(const class AGzCharacter* Character, const struct FGzPartyMemberMiscData& Data);
	void GzPartyMembershipStateChanged__DelegateSignature(bool bInParty);
	void GzPlayerNameChanged__DelegateSignature(const class AGzCharacter* Character);
	void GzPlayerTalkingStateChanged__DelegateSignature(const class AGzCharacter* Character, bool bTalkingState);
	void GzPlayerVoiceChatStateChanged__DelegateSignature(const class AGzCharacter* Character, bool bIsMuted);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzPartyCustomization">();
	}
	static class AGzPartyCustomization* GetDefaultObj()
	{
		return GetDefaultObjImpl<AGzPartyCustomization>();
	}
};
static_assert(alignof(AGzPartyCustomization) == 0x000008, "Wrong alignment on AGzPartyCustomization");
static_assert(sizeof(AGzPartyCustomization) == 0x000310, "Wrong size on AGzPartyCustomization");
static_assert(offsetof(AGzPartyCustomization, Slots) == 0x0002A0, "Member 'AGzPartyCustomization::Slots' has a wrong offset!");
static_assert(offsetof(AGzPartyCustomization, OnPlayerTalkingStateChanged) == 0x0002B0, "Member 'AGzPartyCustomization::OnPlayerTalkingStateChanged' has a wrong offset!");
static_assert(offsetof(AGzPartyCustomization, OnPlayerVoiceChatStateChanged) == 0x0002C0, "Member 'AGzPartyCustomization::OnPlayerVoiceChatStateChanged' has a wrong offset!");
static_assert(offsetof(AGzPartyCustomization, OnPlayerNameChanged) == 0x0002D0, "Member 'AGzPartyCustomization::OnPlayerNameChanged' has a wrong offset!");
static_assert(offsetof(AGzPartyCustomization, OnMatchmakingStatusChanged) == 0x0002E0, "Member 'AGzPartyCustomization::OnMatchmakingStatusChanged' has a wrong offset!");
static_assert(offsetof(AGzPartyCustomization, OnPartyMembershipStateChanged) == 0x0002F0, "Member 'AGzPartyCustomization::OnPartyMembershipStateChanged' has a wrong offset!");
static_assert(offsetof(AGzPartyCustomization, OnMiscDataUpdated) == 0x000300, "Member 'AGzPartyCustomization::OnMiscDataUpdated' has a wrong offset!");

// Class G01.GzPartyMemberDisplaySlot
// 0x0038 (0x02D8 - 0x02A0)
class AGzPartyMemberDisplaySlot : public AActor
{
public:
	class AGzCharacter*                           Character;                                         // 0x02A0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EGzPartyMemberDisplaySlotType                 SlotType;                                          // 0x02A8(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_345D[0x7];                                     // 0x02A9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UCapsuleComponent*                      CapsuleComponent;                                  // 0x02B0(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FString                                 TitleAccountId;                                    // 0x02B8(0x0010)(ZeroConstructor, Transient, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FString                                 EpicProductUserId;                                 // 0x02C8(0x0010)(ZeroConstructor, Transient, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void CreateCharacter();
	void DebugEquipLoadout();
	void OnCharacterCreatedBP();
	void OnCharacterRemovedBP();
	void RemoveCharacter();
	void UpdateDisplaySlotInCharacter();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzPartyMemberDisplaySlot">();
	}
	static class AGzPartyMemberDisplaySlot* GetDefaultObj()
	{
		return GetDefaultObjImpl<AGzPartyMemberDisplaySlot>();
	}
};
static_assert(alignof(AGzPartyMemberDisplaySlot) == 0x000008, "Wrong alignment on AGzPartyMemberDisplaySlot");
static_assert(sizeof(AGzPartyMemberDisplaySlot) == 0x0002D8, "Wrong size on AGzPartyMemberDisplaySlot");
static_assert(offsetof(AGzPartyMemberDisplaySlot, Character) == 0x0002A0, "Member 'AGzPartyMemberDisplaySlot::Character' has a wrong offset!");
static_assert(offsetof(AGzPartyMemberDisplaySlot, SlotType) == 0x0002A8, "Member 'AGzPartyMemberDisplaySlot::SlotType' has a wrong offset!");
static_assert(offsetof(AGzPartyMemberDisplaySlot, CapsuleComponent) == 0x0002B0, "Member 'AGzPartyMemberDisplaySlot::CapsuleComponent' has a wrong offset!");
static_assert(offsetof(AGzPartyMemberDisplaySlot, TitleAccountId) == 0x0002B8, "Member 'AGzPartyMemberDisplaySlot::TitleAccountId' has a wrong offset!");
static_assert(offsetof(AGzPartyMemberDisplaySlot, EpicProductUserId) == 0x0002C8, "Member 'AGzPartyMemberDisplaySlot::EpicProductUserId' has a wrong offset!");

// Class G01.GzSettingDiscreteData
// 0x0040 (0x0068 - 0x0028)
class UGzSettingDiscreteData final : public UGzSettingData
{
public:
	class FString                                 DefaultValue;                                      // 0x0028(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class FString>                         OptionValues;                                      // 0x0038(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class FText>                           OptionDisplayTexts;                                // 0x0048(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	EGzDiscreteSettingDataType                    DataType;                                          // 0x0058(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_345E[0x7];                                     // 0x0059(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UGzGameSettingDiscreteDataSourceBP> DiscreteDataSourceClass;                           // 0x0060(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzSettingDiscreteData">();
	}
	static class UGzSettingDiscreteData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzSettingDiscreteData>();
	}
};
static_assert(alignof(UGzSettingDiscreteData) == 0x000008, "Wrong alignment on UGzSettingDiscreteData");
static_assert(sizeof(UGzSettingDiscreteData) == 0x000068, "Wrong size on UGzSettingDiscreteData");
static_assert(offsetof(UGzSettingDiscreteData, DefaultValue) == 0x000028, "Member 'UGzSettingDiscreteData::DefaultValue' has a wrong offset!");
static_assert(offsetof(UGzSettingDiscreteData, OptionValues) == 0x000038, "Member 'UGzSettingDiscreteData::OptionValues' has a wrong offset!");
static_assert(offsetof(UGzSettingDiscreteData, OptionDisplayTexts) == 0x000048, "Member 'UGzSettingDiscreteData::OptionDisplayTexts' has a wrong offset!");
static_assert(offsetof(UGzSettingDiscreteData, DataType) == 0x000058, "Member 'UGzSettingDiscreteData::DataType' has a wrong offset!");
static_assert(offsetof(UGzSettingDiscreteData, DiscreteDataSourceClass) == 0x000060, "Member 'UGzSettingDiscreteData::DiscreteDataSourceClass' has a wrong offset!");

// Class G01.GzPathOwner
// 0x0000 (0x0028 - 0x0028)
class IGzPathOwner final : public IInterface
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzPathOwner">();
	}
	static class IGzPathOwner* GetDefaultObj()
	{
		return GetDefaultObjImpl<IGzPathOwner>();
	}
};
static_assert(alignof(IGzPathOwner) == 0x000008, "Wrong alignment on IGzPathOwner");
static_assert(sizeof(IGzPathOwner) == 0x000028, "Wrong size on IGzPathOwner");

// Class G01.GzPathTrackingComponent
// 0x0030 (0x00D8 - 0x00A8)
class UGzPathTrackingComponent : public UActorComponent
{
public:
	TSoftClassPtr<class UClass>                   SplineWidgetClass;                                 // 0x00A8(0x0028)(Edit, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         TrackSubstepLength;                                // 0x00D0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_345F[0x4];                                     // 0x00D4(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void StartTracking();
	void StopTracking();

	bool ShouldCloseLoop() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzPathTrackingComponent">();
	}
	static class UGzPathTrackingComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzPathTrackingComponent>();
	}
};
static_assert(alignof(UGzPathTrackingComponent) == 0x000008, "Wrong alignment on UGzPathTrackingComponent");
static_assert(sizeof(UGzPathTrackingComponent) == 0x0000D8, "Wrong size on UGzPathTrackingComponent");
static_assert(offsetof(UGzPathTrackingComponent, SplineWidgetClass) == 0x0000A8, "Member 'UGzPathTrackingComponent::SplineWidgetClass' has a wrong offset!");
static_assert(offsetof(UGzPathTrackingComponent, TrackSubstepLength) == 0x0000D0, "Member 'UGzPathTrackingComponent::TrackSubstepLength' has a wrong offset!");

// Class G01.GzPawnInputMappingConfig
// 0x0000 (0x0048 - 0x0048)
class UGzPawnInputMappingConfig final : public UGzInputMappingConfig
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzPawnInputMappingConfig">();
	}
	static class UGzPawnInputMappingConfig* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzPawnInputMappingConfig>();
	}
};
static_assert(alignof(UGzPawnInputMappingConfig) == 0x000008, "Wrong alignment on UGzPawnInputMappingConfig");
static_assert(sizeof(UGzPawnInputMappingConfig) == 0x000048, "Wrong size on UGzPawnInputMappingConfig");

// Class G01.GzPaymentCheatExtension
// 0x0000 (0x0028 - 0x0028)
class UGzPaymentCheatExtension final : public UGzCheatManagerExtension
{
public:
	void LaunchPaymentCheckout() const;
	void MockBackendSubscriptionReceivedEvent() const;
	void OpenDummyUrlInPaymentBrowser() const;
	void OpenUrlInPaymentBrowser(const class FString& URL) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzPaymentCheatExtension">();
	}
	static class UGzPaymentCheatExtension* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzPaymentCheatExtension>();
	}
};
static_assert(alignof(UGzPaymentCheatExtension) == 0x000008, "Wrong alignment on UGzPaymentCheatExtension");
static_assert(sizeof(UGzPaymentCheatExtension) == 0x000028, "Wrong size on UGzPaymentCheatExtension");

// Class G01.GzSettingDiscreteFSR
// 0x0010 (0x0160 - 0x0150)
class UGzSettingDiscreteFSR final : public UGameSettingValueDiscrete
{
public:
	uint8                                         Pad_3460[0x10];                                    // 0x0150(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzSettingDiscreteFSR">();
	}
	static class UGzSettingDiscreteFSR* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzSettingDiscreteFSR>();
	}
};
static_assert(alignof(UGzSettingDiscreteFSR) == 0x000008, "Wrong alignment on UGzSettingDiscreteFSR");
static_assert(sizeof(UGzSettingDiscreteFSR) == 0x000160, "Wrong size on UGzSettingDiscreteFSR");

// Class G01.GzPaymentSettings
// 0x0080 (0x00B8 - 0x0038)
class UGzPaymentSettings final : public UDeveloperSettings
{
public:
	uint8                                         Pad_3461[0x8];                                     // 0x0038(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<struct FDateTime, TSoftObjectPtr<class UGzSubscriptionPageLayoutInfo>> SubscriptionSchedule;                              // 0x0040(0x0050)(Edit, Config, DisableEditOnInstance, UObjectWrapper, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UGzCurrencyItemData>     BrokenCurrency;                                    // 0x0090(0x0028)(Edit, Config, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzPaymentSettings">();
	}
	static class UGzPaymentSettings* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzPaymentSettings>();
	}
};
static_assert(alignof(UGzPaymentSettings) == 0x000008, "Wrong alignment on UGzPaymentSettings");
static_assert(sizeof(UGzPaymentSettings) == 0x0000B8, "Wrong size on UGzPaymentSettings");
static_assert(offsetof(UGzPaymentSettings, SubscriptionSchedule) == 0x000040, "Member 'UGzPaymentSettings::SubscriptionSchedule' has a wrong offset!");
static_assert(offsetof(UGzPaymentSettings, BrokenCurrency) == 0x000090, "Member 'UGzPaymentSettings::BrokenCurrency' has a wrong offset!");

// Class G01.GzPcPaymentProviderComponent
// 0x0058 (0x0110 - 0x00B8)
class UGzPcPaymentProviderComponent final : public UGzPaymentProviderComponent
{
public:
	TMap<EGzPcPaymentProviders, class UGzPaymentProviderComponent*> PcPaymentProviders;                                // 0x00B8(0x0050)(NativeAccessSpecifierPrivate)
	uint8                                         Pad_3462[0x8];                                     // 0x0108(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzPcPaymentProviderComponent">();
	}
	static class UGzPcPaymentProviderComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzPcPaymentProviderComponent>();
	}
};
static_assert(alignof(UGzPcPaymentProviderComponent) == 0x000008, "Wrong alignment on UGzPcPaymentProviderComponent");
static_assert(sizeof(UGzPcPaymentProviderComponent) == 0x000110, "Wrong size on UGzPcPaymentProviderComponent");
static_assert(offsetof(UGzPcPaymentProviderComponent, PcPaymentProviders) == 0x0000B8, "Member 'UGzPcPaymentProviderComponent::PcPaymentProviders' has a wrong offset!");

// Class G01.GzPerformanceStatsWidget
// 0x0048 (0x0328 - 0x02E0)
class UGzPerformanceStatsWidget : public UUserWidget
{
public:
	class FText                                   PingText;                                          // 0x02E0(0x0010)(Edit, Protected, NativeAccessSpecifierProtected)
	class FText                                   FPSText;                                           // 0x02F0(0x0010)(Edit, Protected, NativeAccessSpecifierProtected)
	class FText                                   PacketLossText;                                    // 0x0300(0x0010)(Edit, Protected, NativeAccessSpecifierProtected)
	class UTextBlock*                             PingTextBlock;                                     // 0x0310(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UTextBlock*                             FPSTextBlock;                                      // 0x0318(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UTextBlock*                             PacketLossTextBlock;                               // 0x0320(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void UpdateStatsVisibility();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzPerformanceStatsWidget">();
	}
	static class UGzPerformanceStatsWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzPerformanceStatsWidget>();
	}
};
static_assert(alignof(UGzPerformanceStatsWidget) == 0x000008, "Wrong alignment on UGzPerformanceStatsWidget");
static_assert(sizeof(UGzPerformanceStatsWidget) == 0x000328, "Wrong size on UGzPerformanceStatsWidget");
static_assert(offsetof(UGzPerformanceStatsWidget, PingText) == 0x0002E0, "Member 'UGzPerformanceStatsWidget::PingText' has a wrong offset!");
static_assert(offsetof(UGzPerformanceStatsWidget, FPSText) == 0x0002F0, "Member 'UGzPerformanceStatsWidget::FPSText' has a wrong offset!");
static_assert(offsetof(UGzPerformanceStatsWidget, PacketLossText) == 0x000300, "Member 'UGzPerformanceStatsWidget::PacketLossText' has a wrong offset!");
static_assert(offsetof(UGzPerformanceStatsWidget, PingTextBlock) == 0x000310, "Member 'UGzPerformanceStatsWidget::PingTextBlock' has a wrong offset!");
static_assert(offsetof(UGzPerformanceStatsWidget, FPSTextBlock) == 0x000318, "Member 'UGzPerformanceStatsWidget::FPSTextBlock' has a wrong offset!");
static_assert(offsetof(UGzPerformanceStatsWidget, PacketLossTextBlock) == 0x000320, "Member 'UGzPerformanceStatsWidget::PacketLossTextBlock' has a wrong offset!");

// Class G01.GzSettingDiscreteMetalFx
// 0x0010 (0x0160 - 0x0150)
class UGzSettingDiscreteMetalFx final : public UGameSettingValueDiscrete
{
public:
	uint8                                         Pad_3463[0x10];                                    // 0x0150(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzSettingDiscreteMetalFx">();
	}
	static class UGzSettingDiscreteMetalFx* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzSettingDiscreteMetalFx>();
	}
};
static_assert(alignof(UGzSettingDiscreteMetalFx) == 0x000008, "Wrong alignment on UGzSettingDiscreteMetalFx");
static_assert(sizeof(UGzSettingDiscreteMetalFx) == 0x000160, "Wrong size on UGzSettingDiscreteMetalFx");

// Class G01.GzPersistentMatchResult
// 0x0090 (0x00B8 - 0x0028)
class UGzPersistentMatchResult final : public UObject
{
public:
	struct FGzMatchResult                         MatchResult;                                       // 0x0028(0x0090)(NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzPersistentMatchResult">();
	}
	static class UGzPersistentMatchResult* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzPersistentMatchResult>();
	}
};
static_assert(alignof(UGzPersistentMatchResult) == 0x000008, "Wrong alignment on UGzPersistentMatchResult");
static_assert(sizeof(UGzPersistentMatchResult) == 0x0000B8, "Wrong size on UGzPersistentMatchResult");
static_assert(offsetof(UGzPersistentMatchResult, MatchResult) == 0x000028, "Member 'UGzPersistentMatchResult::MatchResult' has a wrong offset!");

// Class G01.GzPersonalAssistant
// 0x0000 (0x03F0 - 0x03F0)
class AGzPersonalAssistant : public AGzAudioAnnouncer
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzPersonalAssistant">();
	}
	static class AGzPersonalAssistant* GetDefaultObj()
	{
		return GetDefaultObjImpl<AGzPersonalAssistant>();
	}
};
static_assert(alignof(AGzPersonalAssistant) == 0x000008, "Wrong alignment on AGzPersonalAssistant");
static_assert(sizeof(AGzPersonalAssistant) == 0x0003F0, "Wrong size on AGzPersonalAssistant");

// Class G01.GzPhosphorDartComponent
// 0x0010 (0x0268 - 0x0258)
class UGzPhosphorDartComponent : public UGzChargeableAbilityComponent
{
public:
	float                                         MaxGravityScale;                                   // 0x0258(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MinGravityScale;                                   // 0x025C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bCancelChargeAfterTime;                            // 0x0260(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3464[0x3];                                     // 0x0261(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ChargeCancelTime;                                  // 0x0264(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzPhosphorDartComponent">();
	}
	static class UGzPhosphorDartComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzPhosphorDartComponent>();
	}
};
static_assert(alignof(UGzPhosphorDartComponent) == 0x000008, "Wrong alignment on UGzPhosphorDartComponent");
static_assert(sizeof(UGzPhosphorDartComponent) == 0x000268, "Wrong size on UGzPhosphorDartComponent");
static_assert(offsetof(UGzPhosphorDartComponent, MaxGravityScale) == 0x000258, "Member 'UGzPhosphorDartComponent::MaxGravityScale' has a wrong offset!");
static_assert(offsetof(UGzPhosphorDartComponent, MinGravityScale) == 0x00025C, "Member 'UGzPhosphorDartComponent::MinGravityScale' has a wrong offset!");
static_assert(offsetof(UGzPhosphorDartComponent, bCancelChargeAfterTime) == 0x000260, "Member 'UGzPhosphorDartComponent::bCancelChargeAfterTime' has a wrong offset!");
static_assert(offsetof(UGzPhosphorDartComponent, ChargeCancelTime) == 0x000264, "Member 'UGzPhosphorDartComponent::ChargeCancelTime' has a wrong offset!");

// Class G01.GzPickableEffectsComponent
// 0x0000 (0x00A8 - 0x00A8)
class UGzPickableEffectsComponent : public UActorComponent
{
public:
	void CreateLootBeam_BP(const struct FVector& Location);
	void CreateNiagara_BP(const struct FVector& Location);
	void CreateSFX_BP(const struct FVector& Location);
	void DestroyLootBeam_BP();
	void DestroyNiagara_BP();
	void DestroySFX_BP();

	bool IsLootBeamCreated() const;
	bool IsNiagaraCreated() const;
	bool IsSFXCreated() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzPickableEffectsComponent">();
	}
	static class UGzPickableEffectsComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzPickableEffectsComponent>();
	}
};
static_assert(alignof(UGzPickableEffectsComponent) == 0x000008, "Wrong alignment on UGzPickableEffectsComponent");
static_assert(sizeof(UGzPickableEffectsComponent) == 0x0000A8, "Wrong size on UGzPickableEffectsComponent");

// Class G01.GzPickableHelper2
// 0x0000 (0x0028 - 0x0028)
class UGzPickableHelper2 final : public UBlueprintFunctionLibrary
{
public:
	static struct FVector CalculateDropLocationFor(const class AActor* Actor);
	static struct FVector CalculateImpulseForDroppedItemFor(const class AActor* Actor);
	static struct FVector CalculateSpawnLocationForDroppedItemFor(const class AActor* Actor);
	static class AGzPickableBase* CreateLimbPickable(const class UObject* WorldContextObject, const struct FGzPickableSpawnInfo& SpawnInfo, const struct FGzLimbInvItem& InvItem);
	static struct FGzInvItem CreateLimbPickableItem(const struct FGzLimbInvItem& LimbItem);
	static class AGzPickableBase* CreatePickable(const class UObject* WorldContextObject, const struct FGzPickableSpawnInfo& SpawnInfo, const struct FGzInvItem& InvItem);
	static class AGzPickableBase* CreatePickableOld(const class UObject* WorldContextObject, const struct FGzPickableSpawnInfo& SpawnInfo, const struct FGzInventoryItemContent& ItemContent);
	static class AGzPickableBase* CreateSimplePickable(const class UObject* WorldContextObject, const struct FGzPickableSpawnInfo& SpawnInfo, const struct FGzSimpleInvItem& InvItem);
	static struct FGzInvItem CreateSimplePickableItem(const struct FGzSimpleInvItem& MiscItem);
	static class AGzPickableBase* CreateWeaponPickable(const class UObject* WorldContextObject, const struct FGzPickableSpawnInfo& SpawnInfo, const struct FGzWeaponInvItem& InvItem);
	static struct FGzInvItem CreateWeaponPickableItem(const struct FGzWeaponInvItem& WeaponItem);
	static class AActor* DropItem(const class UObject* WorldContextObject, const struct FGzInvItem& InvItem, const struct FGzPickableSpawnInfo& SpawnInfo);
	static class AActor* DropItemDefault(const class UObject* WorldContextObject, const struct FGzInvItem& InvItem, const class AActor* LastOwner);
	static class AGzPickableBase* FindHighPriorityPickup(const class AGzCharacter* Character, const TArray<class AGzPickableBase*>& PickableArray);
	static struct FVector GetPickableRealPosition(const class AGzPickableBase* Pickable);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzPickableHelper2">();
	}
	static class UGzPickableHelper2* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzPickableHelper2>();
	}
};
static_assert(alignof(UGzPickableHelper2) == 0x000008, "Wrong alignment on UGzPickableHelper2");
static_assert(sizeof(UGzPickableHelper2) == 0x000028, "Wrong size on UGzPickableHelper2");

// Class G01.GzPickUpLogEntryWidget
// 0x0020 (0x0318 - 0x02F8)
class UGzPickUpLogEntryWidget : public UGzBaseLogEntryWidget
{
public:
	class UImage*                                 ItemIcon;                                          // 0x02F8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class URichTextBlock*                         DisplayText;                                       // 0x0300(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FText                                   ItemQuantityText;                                  // 0x0308(0x0010)(Edit, NativeAccessSpecifierPrivate)

public:
	void SetItemInfo(const struct FGzInvItem& InvItem) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzPickUpLogEntryWidget">();
	}
	static class UGzPickUpLogEntryWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzPickUpLogEntryWidget>();
	}
};
static_assert(alignof(UGzPickUpLogEntryWidget) == 0x000008, "Wrong alignment on UGzPickUpLogEntryWidget");
static_assert(sizeof(UGzPickUpLogEntryWidget) == 0x000318, "Wrong size on UGzPickUpLogEntryWidget");
static_assert(offsetof(UGzPickUpLogEntryWidget, ItemIcon) == 0x0002F8, "Member 'UGzPickUpLogEntryWidget::ItemIcon' has a wrong offset!");
static_assert(offsetof(UGzPickUpLogEntryWidget, DisplayText) == 0x000300, "Member 'UGzPickUpLogEntryWidget::DisplayText' has a wrong offset!");
static_assert(offsetof(UGzPickUpLogEntryWidget, ItemQuantityText) == 0x000308, "Member 'UGzPickUpLogEntryWidget::ItemQuantityText' has a wrong offset!");

// Class G01.GzSA_CharacterInputHandling
// 0x0008 (0x0040 - 0x0038)
class UGzSA_CharacterInputHandling final : public UGzStateAction
{
public:
	uint8                                         NewBlockMoveForwardHandle : 1;                     // 0x0038(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         BlockForwardHandle : 1;                            // 0x0038(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         BlockBackwardHandle : 1;                           // 0x0038(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         NewBlockMoveRightHandle : 1;                       // 0x0038(0x0001)(BitIndex: 0x03, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         BlockRightHandle : 1;                              // 0x0038(0x0001)(BitIndex: 0x04, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         BlockLeftHandle : 1;                               // 0x0038(0x0001)(BitIndex: 0x05, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         NewBlockLookUpHandle : 1;                          // 0x0038(0x0001)(BitIndex: 0x06, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         NewBlockTurnHandle : 1;                            // 0x0038(0x0001)(BitIndex: 0x07, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_346E[0x7];                                     // 0x0039(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzSA_CharacterInputHandling">();
	}
	static class UGzSA_CharacterInputHandling* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzSA_CharacterInputHandling>();
	}
};
static_assert(alignof(UGzSA_CharacterInputHandling) == 0x000008, "Wrong alignment on UGzSA_CharacterInputHandling");
static_assert(sizeof(UGzSA_CharacterInputHandling) == 0x000040, "Wrong size on UGzSA_CharacterInputHandling");

// Class G01.GzPickUpLogWidget
// 0x0030 (0x03A0 - 0x0370)
class UGzPickUpLogWidget : public UGzBaseLogWidget
{
public:
	struct FGameplayTagContainer                  TrackedItemTypes;                                  // 0x0368(0x0020)(Edit, NativeAccessSpecifierPrivate)
	uint8                                         Pad_346F[0x18];                                    // 0x0388(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzPickUpLogWidget">();
	}
	static class UGzPickUpLogWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzPickUpLogWidget>();
	}
};
static_assert(alignof(UGzPickUpLogWidget) == 0x000010, "Wrong alignment on UGzPickUpLogWidget");
static_assert(sizeof(UGzPickUpLogWidget) == 0x0003A0, "Wrong size on UGzPickUpLogWidget");
static_assert(offsetof(UGzPickUpLogWidget, TrackedItemTypes) == 0x000368, "Member 'UGzPickUpLogWidget::TrackedItemTypes' has a wrong offset!");

// Class G01.GzPingActor
// 0x0060 (0x0378 - 0x0318)
class AGzPingActor : public AGzMarkerSceneContainer
{
public:
	struct FGzPingData                            PingData;                                          // 0x0318(0x0060)(BlueprintVisible, BlueprintReadOnly, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	class UGzMarkerComponent* GetMarkerComponent() const;
	const struct FGzPingData GetPingData() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzPingActor">();
	}
	static class AGzPingActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<AGzPingActor>();
	}
};
static_assert(alignof(AGzPingActor) == 0x000008, "Wrong alignment on AGzPingActor");
static_assert(sizeof(AGzPingActor) == 0x000378, "Wrong size on AGzPingActor");
static_assert(offsetof(AGzPingActor, PingData) == 0x000318, "Member 'AGzPingActor::PingData' has a wrong offset!");

// Class G01.GzPingControllerComponent
// 0x0258 (0x0300 - 0x00A8)
class UGzPingControllerComponent final : public UControllerComponent
{
public:
	FMulticastInlineDelegateProperty_             OnPingAdded;                                       // 0x00A8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnPingRemoved;                                     // 0x00B8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnPingCanceled;                                    // 0x00C8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnPingAgreementsChanged;                           // 0x00D8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnTryPingDuringCooldown;                           // 0x00E8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	struct FGameplayTagContainer                  ClearPingGameStageTags;                            // 0x00F8(0x0020)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	float                                         MaxPingRange;                                      // 0x0118(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         PingDuration;                                      // 0x011C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         AgreedPingDuration;                                // 0x0120(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         PingCooldown;                                      // 0x0124(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         MinDistanceBetweenPings;                           // 0x0128(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         RevivePingDistanceTolerance;                       // 0x012C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TMap<struct FGameplayTag, uint32>             MaxPingCountPerType;                               // 0x0130(0x0050)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	TSubclassOf<class AGzPingActor>               PingActorClass;                                    // 0x0180(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TMap<struct FGzPingData, struct FGzPingLifetimeInfo> ActivePings;                                       // 0x0188(0x0050)(NativeAccessSpecifierPrivate)
	class UGzMarkerComponent*                     MarkerCompInFocus;                                 // 0x01D8(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FGzPingContextSnapshot                 PingContextSnapshot;                               // 0x01E0(0x0110)(Transient, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	class AGzPlayerState*                         LocalPlayerState;                                  // 0x02F0(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_3470[0x8];                                     // 0x02F8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Client_AddPing(const struct FGzPingData& PingRequest);
	void Client_CancelPing(const struct FGzPingData& PingRequest);
	void Client_RemovePing(const struct FGzPingData& PingRequest);
	void Client_SetAgree(const struct FGzPingData& PingData, class AGzPlayerState* PS, bool bAgrees);
	void OnGameStageChanged();
	bool Ping(const struct FGameplayTag& PingType, EGzPingChannels PingChannel, bool bConsumeSnapshot);
	void PingAtLocation(const struct FGameplayTag& PingType, const struct FVector2D& WorldLocation);
	bool PingClosestActorOfClass(const struct FGameplayTag& PingType, TSubclassOf<class AActor> ActorClass);
	void PingMarker(const struct FGameplayTag& PingType, class UGzMarkerComponent* MarkerComponent);
	void Server_CancelPing(const struct FGzPingData& PingRequest);
	void Server_CreatePing(const struct FGzPingData& PingRequest);
	void Server_RemovePing(const struct FGzPingData& PingRequest);
	void Server_SetAgree(const struct FGzPingData& PingData, class AGzPlayerState* PS, bool bAgrees);

	class AGzPingActor* GetPingActor(class AActor* InActor) const;
	bool IsPinged(class AActor* InActor) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzPingControllerComponent">();
	}
	static class UGzPingControllerComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzPingControllerComponent>();
	}
};
static_assert(alignof(UGzPingControllerComponent) == 0x000008, "Wrong alignment on UGzPingControllerComponent");
static_assert(sizeof(UGzPingControllerComponent) == 0x000300, "Wrong size on UGzPingControllerComponent");
static_assert(offsetof(UGzPingControllerComponent, OnPingAdded) == 0x0000A8, "Member 'UGzPingControllerComponent::OnPingAdded' has a wrong offset!");
static_assert(offsetof(UGzPingControllerComponent, OnPingRemoved) == 0x0000B8, "Member 'UGzPingControllerComponent::OnPingRemoved' has a wrong offset!");
static_assert(offsetof(UGzPingControllerComponent, OnPingCanceled) == 0x0000C8, "Member 'UGzPingControllerComponent::OnPingCanceled' has a wrong offset!");
static_assert(offsetof(UGzPingControllerComponent, OnPingAgreementsChanged) == 0x0000D8, "Member 'UGzPingControllerComponent::OnPingAgreementsChanged' has a wrong offset!");
static_assert(offsetof(UGzPingControllerComponent, OnTryPingDuringCooldown) == 0x0000E8, "Member 'UGzPingControllerComponent::OnTryPingDuringCooldown' has a wrong offset!");
static_assert(offsetof(UGzPingControllerComponent, ClearPingGameStageTags) == 0x0000F8, "Member 'UGzPingControllerComponent::ClearPingGameStageTags' has a wrong offset!");
static_assert(offsetof(UGzPingControllerComponent, MaxPingRange) == 0x000118, "Member 'UGzPingControllerComponent::MaxPingRange' has a wrong offset!");
static_assert(offsetof(UGzPingControllerComponent, PingDuration) == 0x00011C, "Member 'UGzPingControllerComponent::PingDuration' has a wrong offset!");
static_assert(offsetof(UGzPingControllerComponent, AgreedPingDuration) == 0x000120, "Member 'UGzPingControllerComponent::AgreedPingDuration' has a wrong offset!");
static_assert(offsetof(UGzPingControllerComponent, PingCooldown) == 0x000124, "Member 'UGzPingControllerComponent::PingCooldown' has a wrong offset!");
static_assert(offsetof(UGzPingControllerComponent, MinDistanceBetweenPings) == 0x000128, "Member 'UGzPingControllerComponent::MinDistanceBetweenPings' has a wrong offset!");
static_assert(offsetof(UGzPingControllerComponent, RevivePingDistanceTolerance) == 0x00012C, "Member 'UGzPingControllerComponent::RevivePingDistanceTolerance' has a wrong offset!");
static_assert(offsetof(UGzPingControllerComponent, MaxPingCountPerType) == 0x000130, "Member 'UGzPingControllerComponent::MaxPingCountPerType' has a wrong offset!");
static_assert(offsetof(UGzPingControllerComponent, PingActorClass) == 0x000180, "Member 'UGzPingControllerComponent::PingActorClass' has a wrong offset!");
static_assert(offsetof(UGzPingControllerComponent, ActivePings) == 0x000188, "Member 'UGzPingControllerComponent::ActivePings' has a wrong offset!");
static_assert(offsetof(UGzPingControllerComponent, MarkerCompInFocus) == 0x0001D8, "Member 'UGzPingControllerComponent::MarkerCompInFocus' has a wrong offset!");
static_assert(offsetof(UGzPingControllerComponent, PingContextSnapshot) == 0x0001E0, "Member 'UGzPingControllerComponent::PingContextSnapshot' has a wrong offset!");
static_assert(offsetof(UGzPingControllerComponent, LocalPlayerState) == 0x0002F0, "Member 'UGzPingControllerComponent::LocalPlayerState' has a wrong offset!");

// Class G01.GzPingTooltipActor
// 0x0008 (0x02A8 - 0x02A0)
class AGzPingTooltipActor : public AActor
{
public:
	class UGzMarkerComponent*                     MarkerComponent;                                   // 0x02A0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzPingTooltipActor">();
	}
	static class AGzPingTooltipActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<AGzPingTooltipActor>();
	}
};
static_assert(alignof(AGzPingTooltipActor) == 0x000008, "Wrong alignment on AGzPingTooltipActor");
static_assert(sizeof(AGzPingTooltipActor) == 0x0002A8, "Wrong size on AGzPingTooltipActor");
static_assert(offsetof(AGzPingTooltipActor, MarkerComponent) == 0x0002A0, "Member 'AGzPingTooltipActor::MarkerComponent' has a wrong offset!");

// Class G01.GzSA_ActionOnEvent
// 0x0028 (0x0060 - 0x0038)
class UGzSA_ActionOnEvent final : public UGzStateAction
{
public:
	struct FGameplayTag                           EventTag;                                          // 0x0038(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSkipInitial;                                      // 0x0040(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3476[0x7];                                     // 0x0041(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UGzStateAction*                         Action;                                            // 0x0048(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, PersistentInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAbilityTask_WaitGameplayEvent*         WaitEventTask;                                     // 0x0050(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bShouldSkip;                                       // 0x0058(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_3477[0x7];                                     // 0x0059(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnEvent(const struct FGameplayEventData& TriggerEventData);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzSA_ActionOnEvent">();
	}
	static class UGzSA_ActionOnEvent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzSA_ActionOnEvent>();
	}
};
static_assert(alignof(UGzSA_ActionOnEvent) == 0x000008, "Wrong alignment on UGzSA_ActionOnEvent");
static_assert(sizeof(UGzSA_ActionOnEvent) == 0x000060, "Wrong size on UGzSA_ActionOnEvent");
static_assert(offsetof(UGzSA_ActionOnEvent, EventTag) == 0x000038, "Member 'UGzSA_ActionOnEvent::EventTag' has a wrong offset!");
static_assert(offsetof(UGzSA_ActionOnEvent, bSkipInitial) == 0x000040, "Member 'UGzSA_ActionOnEvent::bSkipInitial' has a wrong offset!");
static_assert(offsetof(UGzSA_ActionOnEvent, Action) == 0x000048, "Member 'UGzSA_ActionOnEvent::Action' has a wrong offset!");
static_assert(offsetof(UGzSA_ActionOnEvent, WaitEventTask) == 0x000050, "Member 'UGzSA_ActionOnEvent::WaitEventTask' has a wrong offset!");
static_assert(offsetof(UGzSA_ActionOnEvent, bShouldSkip) == 0x000058, "Member 'UGzSA_ActionOnEvent::bShouldSkip' has a wrong offset!");

// Class G01.GzPingTooltipExtension
// 0x0040 (0x0068 - 0x0028)
class UGzPingTooltipExtension : public UUserWidgetExtension
{
public:
	TArray<TSubclassOf<class AActor>>             HideInCloseRangeClasses;                           // 0x0028(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, UObjectWrapper, NativeAccessSpecifierPrivate)
	class UGzViewportMarkerContainer*             ViewportMarkerContainer;                           // 0x0038(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class AGzHUDBase*                             HUD;                                               // 0x0040(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UGzPingControllerComponent*             PingController;                                    // 0x0048(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class AGzCharacter*                           ViewTarget;                                        // 0x0050(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UGzInteractableComponent*               CachedInteractable;                                // 0x0058(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class AGzPingTooltipActor*                    ActiveTooltip;                                     // 0x0060(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void InteractionFocusChanged(class UGzInteractableComponent* Interactable, bool bInInteractionRange);
	void OnPingRemoved(const struct FGzPingData& PingData);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzPingTooltipExtension">();
	}
	static class UGzPingTooltipExtension* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzPingTooltipExtension>();
	}
};
static_assert(alignof(UGzPingTooltipExtension) == 0x000008, "Wrong alignment on UGzPingTooltipExtension");
static_assert(sizeof(UGzPingTooltipExtension) == 0x000068, "Wrong size on UGzPingTooltipExtension");
static_assert(offsetof(UGzPingTooltipExtension, HideInCloseRangeClasses) == 0x000028, "Member 'UGzPingTooltipExtension::HideInCloseRangeClasses' has a wrong offset!");
static_assert(offsetof(UGzPingTooltipExtension, ViewportMarkerContainer) == 0x000038, "Member 'UGzPingTooltipExtension::ViewportMarkerContainer' has a wrong offset!");
static_assert(offsetof(UGzPingTooltipExtension, HUD) == 0x000040, "Member 'UGzPingTooltipExtension::HUD' has a wrong offset!");
static_assert(offsetof(UGzPingTooltipExtension, PingController) == 0x000048, "Member 'UGzPingTooltipExtension::PingController' has a wrong offset!");
static_assert(offsetof(UGzPingTooltipExtension, ViewTarget) == 0x000050, "Member 'UGzPingTooltipExtension::ViewTarget' has a wrong offset!");
static_assert(offsetof(UGzPingTooltipExtension, CachedInteractable) == 0x000058, "Member 'UGzPingTooltipExtension::CachedInteractable' has a wrong offset!");
static_assert(offsetof(UGzPingTooltipExtension, ActiveTooltip) == 0x000060, "Member 'UGzPingTooltipExtension::ActiveTooltip' has a wrong offset!");

// Class G01.GzPlatformLoginState
// 0x0000 (0x0070 - 0x0070)
class UGzPlatformLoginState final : public UGzFlowStateWithActionGraph
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzPlatformLoginState">();
	}
	static class UGzPlatformLoginState* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzPlatformLoginState>();
	}
};
static_assert(alignof(UGzPlatformLoginState) == 0x000008, "Wrong alignment on UGzPlatformLoginState");
static_assert(sizeof(UGzPlatformLoginState) == 0x000070, "Wrong size on UGzPlatformLoginState");

// Class G01.GzSA_SetLocomotionGait
// 0x0008 (0x0040 - 0x0038)
class UGzSA_SetLocomotionGait final : public UGzStateAction
{
public:
	ELocomotionGait                               LocomotionGait;                                    // 0x0038(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3479[0x7];                                     // 0x0039(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzSA_SetLocomotionGait">();
	}
	static class UGzSA_SetLocomotionGait* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzSA_SetLocomotionGait>();
	}
};
static_assert(alignof(UGzSA_SetLocomotionGait) == 0x000008, "Wrong alignment on UGzSA_SetLocomotionGait");
static_assert(sizeof(UGzSA_SetLocomotionGait) == 0x000040, "Wrong size on UGzSA_SetLocomotionGait");
static_assert(offsetof(UGzSA_SetLocomotionGait, LocomotionGait) == 0x000038, "Member 'UGzSA_SetLocomotionGait::LocomotionGait' has a wrong offset!");

// Class G01.GzPlayableAreaMapExtension
// 0x0038 (0x0070 - 0x0038)
class UGzPlayableAreaMapExtension : public UGzMapWidgetExtension
{
public:
	class UMaterialInterface*                     ZoneFillMaterial;                                  // 0x0038(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         ZOrder;                                            // 0x0040(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bDrawBorder;                                       // 0x0044(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_347A[0x3];                                     // 0x0045(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UGzSplineMapWidget>         BorderWidgetClass;                                 // 0x0048(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bDrawZone;                                         // 0x0050(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_347B[0x7];                                     // 0x0051(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UMaterialInstanceDynamic*               ZoneFillMaterialInstance;                          // 0x0058(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UGzZoneFillLayerWidget*                 PlayableZoneLayer;                                 // 0x0060(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UGzSplineMapWidget*                     BorderWidget;                                      // 0x0068(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void OnPlayableAreaReady();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzPlayableAreaMapExtension">();
	}
	static class UGzPlayableAreaMapExtension* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzPlayableAreaMapExtension>();
	}
};
static_assert(alignof(UGzPlayableAreaMapExtension) == 0x000008, "Wrong alignment on UGzPlayableAreaMapExtension");
static_assert(sizeof(UGzPlayableAreaMapExtension) == 0x000070, "Wrong size on UGzPlayableAreaMapExtension");
static_assert(offsetof(UGzPlayableAreaMapExtension, ZoneFillMaterial) == 0x000038, "Member 'UGzPlayableAreaMapExtension::ZoneFillMaterial' has a wrong offset!");
static_assert(offsetof(UGzPlayableAreaMapExtension, ZOrder) == 0x000040, "Member 'UGzPlayableAreaMapExtension::ZOrder' has a wrong offset!");
static_assert(offsetof(UGzPlayableAreaMapExtension, bDrawBorder) == 0x000044, "Member 'UGzPlayableAreaMapExtension::bDrawBorder' has a wrong offset!");
static_assert(offsetof(UGzPlayableAreaMapExtension, BorderWidgetClass) == 0x000048, "Member 'UGzPlayableAreaMapExtension::BorderWidgetClass' has a wrong offset!");
static_assert(offsetof(UGzPlayableAreaMapExtension, bDrawZone) == 0x000050, "Member 'UGzPlayableAreaMapExtension::bDrawZone' has a wrong offset!");
static_assert(offsetof(UGzPlayableAreaMapExtension, ZoneFillMaterialInstance) == 0x000058, "Member 'UGzPlayableAreaMapExtension::ZoneFillMaterialInstance' has a wrong offset!");
static_assert(offsetof(UGzPlayableAreaMapExtension, PlayableZoneLayer) == 0x000060, "Member 'UGzPlayableAreaMapExtension::PlayableZoneLayer' has a wrong offset!");
static_assert(offsetof(UGzPlayableAreaMapExtension, BorderWidget) == 0x000068, "Member 'UGzPlayableAreaMapExtension::BorderWidget' has a wrong offset!");

// Class G01.GzPlayableAreaSubsystem
// 0x0028 (0x0058 - 0x0030)
class UGzPlayableAreaSubsystem final : public UWorldSubsystem
{
public:
	FMulticastInlineDelegateProperty_             OnPlayableAreaReady;                               // 0x0030(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	class AGzPlayableArea*                        PlayableArea;                                      // 0x0040(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UTextureRenderTarget2D*                 Mask;                                              // 0x0048(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_347C[0x8];                                     // 0x0050(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	const class FName GetLayer() const;
	const TArray<class FName> GetZones() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzPlayableAreaSubsystem">();
	}
	static class UGzPlayableAreaSubsystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzPlayableAreaSubsystem>();
	}
};
static_assert(alignof(UGzPlayableAreaSubsystem) == 0x000008, "Wrong alignment on UGzPlayableAreaSubsystem");
static_assert(sizeof(UGzPlayableAreaSubsystem) == 0x000058, "Wrong size on UGzPlayableAreaSubsystem");
static_assert(offsetof(UGzPlayableAreaSubsystem, OnPlayableAreaReady) == 0x000030, "Member 'UGzPlayableAreaSubsystem::OnPlayableAreaReady' has a wrong offset!");
static_assert(offsetof(UGzPlayableAreaSubsystem, PlayableArea) == 0x000040, "Member 'UGzPlayableAreaSubsystem::PlayableArea' has a wrong offset!");
static_assert(offsetof(UGzPlayableAreaSubsystem, Mask) == 0x000048, "Member 'UGzPlayableAreaSubsystem::Mask' has a wrong offset!");

// Class G01.GzPlayerAgreementsSigningComponent
// 0x0030 (0x00D0 - 0x00A0)
class UGzPlayerAgreementsSigningComponent final : public UGzServiceComponent
{
public:
	uint8                                         Pad_347D[0x30];                                    // 0x00A0(0x0030)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzPlayerAgreementsSigningComponent">();
	}
	static class UGzPlayerAgreementsSigningComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzPlayerAgreementsSigningComponent>();
	}
};
static_assert(alignof(UGzPlayerAgreementsSigningComponent) == 0x000008, "Wrong alignment on UGzPlayerAgreementsSigningComponent");
static_assert(sizeof(UGzPlayerAgreementsSigningComponent) == 0x0000D0, "Wrong size on UGzPlayerAgreementsSigningComponent");

// Class G01.GzPlayerCanJoinServerValidator
// 0x0048 (0x0070 - 0x0028)
class UGzPlayerCanJoinServerValidator final : public UObject
{
public:
	uint8                                         Pad_347E[0x18];                                    // 0x0028(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	class AGzPlayerJoinValidationBeaconClient*    ValidationBeacon;                                  // 0x0040(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_347F[0x28];                                    // 0x0048(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzPlayerCanJoinServerValidator">();
	}
	static class UGzPlayerCanJoinServerValidator* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzPlayerCanJoinServerValidator>();
	}
};
static_assert(alignof(UGzPlayerCanJoinServerValidator) == 0x000008, "Wrong alignment on UGzPlayerCanJoinServerValidator");
static_assert(sizeof(UGzPlayerCanJoinServerValidator) == 0x000070, "Wrong size on UGzPlayerCanJoinServerValidator");
static_assert(offsetof(UGzPlayerCanJoinServerValidator, ValidationBeacon) == 0x000040, "Member 'UGzPlayerCanJoinServerValidator::ValidationBeacon' has a wrong offset!");

// Class G01.GzSA_WeaponCooldown
// 0x0008 (0x0040 - 0x0038)
class UGzSA_WeaponCooldown final : public UGzStateAction
{
public:
	float                                         WeaponCooldownInSeconds;                           // 0x0038(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bApplyCooldownOnAim;                               // 0x003C(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3480[0x3];                                     // 0x003D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzSA_WeaponCooldown">();
	}
	static class UGzSA_WeaponCooldown* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzSA_WeaponCooldown>();
	}
};
static_assert(alignof(UGzSA_WeaponCooldown) == 0x000008, "Wrong alignment on UGzSA_WeaponCooldown");
static_assert(sizeof(UGzSA_WeaponCooldown) == 0x000040, "Wrong size on UGzSA_WeaponCooldown");
static_assert(offsetof(UGzSA_WeaponCooldown, WeaponCooldownInSeconds) == 0x000038, "Member 'UGzSA_WeaponCooldown::WeaponCooldownInSeconds' has a wrong offset!");
static_assert(offsetof(UGzSA_WeaponCooldown, bApplyCooldownOnAim) == 0x00003C, "Member 'UGzSA_WeaponCooldown::bApplyCooldownOnAim' has a wrong offset!");

// Class G01.GzPlayerCharacter
// 0x03F0 (0x19C0 - 0x15D0)
class AGzPlayerCharacter : public AGzMultiPartCharacter
{
public:
	uint8                                         Pad_3481[0x10];                                    // 0x15D0(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	FMulticastInlineDelegateProperty_             OnReviveProgressChangedEvent;                      // 0x15E0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	struct FGzNativeCharacterComponentSpec        CameraComponentSpec;                               // 0x15F0(0x0080)(Edit, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	class UGzCameraComponent*                     CameraComponent;                                   // 0x1670(0x0008)(Edit, ExportObject, ZeroConstructor, Transient, EditConst, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FCameraTransitionSettings              TransitionSettings;                                // 0x1678(0x0040)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          bUseCameraTransition;                              // 0x16B8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3482[0x3];                                     // 0x16B9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTag                           LeglessCameraModeTag;                              // 0x16BC(0x0008)(Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           OutdoorCameraModeTag;                              // 0x16C4(0x0008)(Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3483[0x4];                                     // 0x16CC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTagContainer                  BufferizeInputInTheseStates;                       // 0x16D0(0x0020)(Edit, BlueprintVisible, DisableEditOnInstance, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnPlayerInputRotatationReceived;                   // 0x16F0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	class UGzInteractionComponent*                InteractionComponent;                              // 0x1700(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bUseFreeRotation;                                  // 0x1708(0x0001)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3484[0x7];                                     // 0x1709(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FGzRevealeInfo>                 RevealInfo;                                        // 0x1710(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	TArray<struct FGzRevealedActorInfo>           RevealedActors;                                    // 0x1720(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	struct FGzNativeCharacterComponentSpec        AdvancedCameraComponentSpec;                       // 0x1730(0x0080)(Edit, NoDestructor, NativeAccessSpecifierPrivate)
	class UGzAdvancedCameraParamsComponent*       AdvancedCameraComponent;                           // 0x17B0(0x0008)(Edit, ExportObject, ZeroConstructor, Transient, EditConst, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSubclassOf<class UGameplayEffect>            ReviveEffect;                                      // 0x17B8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSubclassOf<class UGameplayEffect>            ReviveInteractingEffect;                           // 0x17C0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_3485[0x10];                                    // 0x17C8(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	ELeglessLocoSubState                          LeglessSubState;                                   // 0x17D8(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_3486[0x7];                                     // 0x17D9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UGzCharacterControlsComponent*          ControlsComponent;                                 // 0x17E0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FGzInputMappingContextInfo             InteractionMappingDecorator;                       // 0x17E8(0x0010)(Edit, NoDestructor, NativeAccessSpecifierPrivate)
	uint8                                         Pad_3487[0x8];                                     // 0x17F8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGzInputMappingContextInfo             SelfReviveMappingDecorator;                        // 0x1800(0x0010)(Edit, NoDestructor, NativeAccessSpecifierPrivate)
	uint8                                         Pad_3488[0x20];                                    // 0x1810(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	class UGzAsyncTaskAttributeChanged*           AsyncHealthOrArmorAttributesChanged;               // 0x1830(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_3489[0x80];                                    // 0x1838(0x0080)(Fixing Size After Last Property [ Dumper-7 ])
	TSet<class AGzPlayerController*>              ServerSpectators;                                  // 0x18B8(0x0050)(Transient, NativeAccessSpecifierPrivate)
	struct FTimerHandle                           CameraModeTimer;                                   // 0x1908(0x0008)(Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	FMulticastInlineDelegateProperty_             OnDamageReceived;                                  // 0x1910(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, Protected, NativeAccessSpecifierProtected)
	FMulticastInlineDelegateProperty_             OnConsumableUsageStarted;                          // 0x1920(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, Protected, NativeAccessSpecifierProtected)
	FMulticastInlineDelegateProperty_             OnConsumableUsageEnded;                            // 0x1930(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_348A[0x18];                                    // 0x1940(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         OffLedgeLastTime;                                  // 0x1958(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         CoyoteTime;                                        // 0x195C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ReviveProgress;                                    // 0x1960(0x0004)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MinPitchForYawAcceleration;                        // 0x1964(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MinYawAcceleration;                                // 0x1968(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MaxYawAcceleration;                                // 0x196C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_348B[0x38];                                    // 0x1970(0x0038)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRotator                               AimCameraCompensateCache;                          // 0x19A8(0x0018)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, Protected, NativeAccessSpecifierProtected)

public:
	void AddRevealedActor(class AActor* SourceActor, const struct FGameplayTag& RevealedTag, class AActor* Actor);
	void Client_HandleWeaponSlotDrop();
	void FinishCurrentInteractionStage();
	void Multicast_PlayHitReactionInJetpackVFX();
	void OnAnyAbilityEnded(const struct FAbilityEndedData& AbilityEndedData);
	void OnAnyAbilityEndedNextFrame(const struct FAbilityEndedData& AbilityEndedData);
	void OnCustomizationChanged(class AGzPlayerState* GzPlayerState);
	void OnInteract(class AActor* InteractedBy, const class UGzInteractableComponent* Interactable);
	void OnInteractionCanceled(class AActor* InteractedBy, const class UGzInteractableComponent* Interactable);
	void OnInteractionStarted(class AActor* InteractedBy, const class UGzInteractableComponent* Interactable);
	void OnKnockedDownTagChanged(const struct FGameplayTag& Tag, int32 Count);
	void OnRep_UseFreeRotation();
	void RemoveRevealedActor(class AActor* SourceActor, const struct FGameplayTag& RevealedTag, class AActor* Actor);
	void ResetPlayerCamera(bool WithInterpolation);
	void Server_GiveLoadoutFromContainer(class UGzLoadoutSelectionComponent* LoadoutSelectionComponent, const struct FGuid& LoadoutGuid);
	void Server_SetCameraCompensateRotation(const struct FRotator& Rotation);
	void ServerFinishCurrentInteractionStage();
	void ServerSetFreeRotationEnabled(bool bEnable);
	void SetFreeRotationEnabled(bool bEnable);
	void StartCameraTransition();
	void TryInteract(const bool bAutoInteract);
	void WingsuitOpenCloseEvent(bool bIsOpened);

	bool CanHoldBreath() const;
	bool CanShootAutomaticWeapon() const;
	class UGzAdvancedCameraParamsComponent* GetAdvancedCameraComponent() const;
	float GetBlockingHealDamageableAreaTime(const EGzCharacterDamageAreaType Type) const;
	class UGzCameraComponent* GetCameraComponent() const;
	struct FRotator GetDesiredOnEndInteractionCameraRotation() const;
	class UGzInteractionComponent* GetInteractionComponent() const;
	float GetJetpackDelayAndRepairTime(const struct FGameplayTag& ProhibitionTag, const struct FGameplayAttribute& JetpackHPCurrAttribute, const struct FGameplayAttribute& JetpackHPMaxAttribute) const;
	float GetRegenerationTime(const struct FGameplayTag& ProhibitionTag, const struct FGameplayAttribute& HPCurrAttribute, const struct FGameplayAttribute& HPMaxAttribute) const;
	bool IsInCustomCameraMode() const;
	void OnRep_AimCameraCompensation() const;
	void OnRep_ReviveProgress() const;
	void OnShoulderTagHasChanged() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzPlayerCharacter">();
	}
	static class AGzPlayerCharacter* GetDefaultObj()
	{
		return GetDefaultObjImpl<AGzPlayerCharacter>();
	}
};
static_assert(alignof(AGzPlayerCharacter) == 0x000010, "Wrong alignment on AGzPlayerCharacter");
static_assert(sizeof(AGzPlayerCharacter) == 0x0019C0, "Wrong size on AGzPlayerCharacter");
static_assert(offsetof(AGzPlayerCharacter, OnReviveProgressChangedEvent) == 0x0015E0, "Member 'AGzPlayerCharacter::OnReviveProgressChangedEvent' has a wrong offset!");
static_assert(offsetof(AGzPlayerCharacter, CameraComponentSpec) == 0x0015F0, "Member 'AGzPlayerCharacter::CameraComponentSpec' has a wrong offset!");
static_assert(offsetof(AGzPlayerCharacter, CameraComponent) == 0x001670, "Member 'AGzPlayerCharacter::CameraComponent' has a wrong offset!");
static_assert(offsetof(AGzPlayerCharacter, TransitionSettings) == 0x001678, "Member 'AGzPlayerCharacter::TransitionSettings' has a wrong offset!");
static_assert(offsetof(AGzPlayerCharacter, bUseCameraTransition) == 0x0016B8, "Member 'AGzPlayerCharacter::bUseCameraTransition' has a wrong offset!");
static_assert(offsetof(AGzPlayerCharacter, LeglessCameraModeTag) == 0x0016BC, "Member 'AGzPlayerCharacter::LeglessCameraModeTag' has a wrong offset!");
static_assert(offsetof(AGzPlayerCharacter, OutdoorCameraModeTag) == 0x0016C4, "Member 'AGzPlayerCharacter::OutdoorCameraModeTag' has a wrong offset!");
static_assert(offsetof(AGzPlayerCharacter, BufferizeInputInTheseStates) == 0x0016D0, "Member 'AGzPlayerCharacter::BufferizeInputInTheseStates' has a wrong offset!");
static_assert(offsetof(AGzPlayerCharacter, OnPlayerInputRotatationReceived) == 0x0016F0, "Member 'AGzPlayerCharacter::OnPlayerInputRotatationReceived' has a wrong offset!");
static_assert(offsetof(AGzPlayerCharacter, InteractionComponent) == 0x001700, "Member 'AGzPlayerCharacter::InteractionComponent' has a wrong offset!");
static_assert(offsetof(AGzPlayerCharacter, bUseFreeRotation) == 0x001708, "Member 'AGzPlayerCharacter::bUseFreeRotation' has a wrong offset!");
static_assert(offsetof(AGzPlayerCharacter, RevealInfo) == 0x001710, "Member 'AGzPlayerCharacter::RevealInfo' has a wrong offset!");
static_assert(offsetof(AGzPlayerCharacter, RevealedActors) == 0x001720, "Member 'AGzPlayerCharacter::RevealedActors' has a wrong offset!");
static_assert(offsetof(AGzPlayerCharacter, AdvancedCameraComponentSpec) == 0x001730, "Member 'AGzPlayerCharacter::AdvancedCameraComponentSpec' has a wrong offset!");
static_assert(offsetof(AGzPlayerCharacter, AdvancedCameraComponent) == 0x0017B0, "Member 'AGzPlayerCharacter::AdvancedCameraComponent' has a wrong offset!");
static_assert(offsetof(AGzPlayerCharacter, ReviveEffect) == 0x0017B8, "Member 'AGzPlayerCharacter::ReviveEffect' has a wrong offset!");
static_assert(offsetof(AGzPlayerCharacter, ReviveInteractingEffect) == 0x0017C0, "Member 'AGzPlayerCharacter::ReviveInteractingEffect' has a wrong offset!");
static_assert(offsetof(AGzPlayerCharacter, LeglessSubState) == 0x0017D8, "Member 'AGzPlayerCharacter::LeglessSubState' has a wrong offset!");
static_assert(offsetof(AGzPlayerCharacter, ControlsComponent) == 0x0017E0, "Member 'AGzPlayerCharacter::ControlsComponent' has a wrong offset!");
static_assert(offsetof(AGzPlayerCharacter, InteractionMappingDecorator) == 0x0017E8, "Member 'AGzPlayerCharacter::InteractionMappingDecorator' has a wrong offset!");
static_assert(offsetof(AGzPlayerCharacter, SelfReviveMappingDecorator) == 0x001800, "Member 'AGzPlayerCharacter::SelfReviveMappingDecorator' has a wrong offset!");
static_assert(offsetof(AGzPlayerCharacter, AsyncHealthOrArmorAttributesChanged) == 0x001830, "Member 'AGzPlayerCharacter::AsyncHealthOrArmorAttributesChanged' has a wrong offset!");
static_assert(offsetof(AGzPlayerCharacter, ServerSpectators) == 0x0018B8, "Member 'AGzPlayerCharacter::ServerSpectators' has a wrong offset!");
static_assert(offsetof(AGzPlayerCharacter, CameraModeTimer) == 0x001908, "Member 'AGzPlayerCharacter::CameraModeTimer' has a wrong offset!");
static_assert(offsetof(AGzPlayerCharacter, OnDamageReceived) == 0x001910, "Member 'AGzPlayerCharacter::OnDamageReceived' has a wrong offset!");
static_assert(offsetof(AGzPlayerCharacter, OnConsumableUsageStarted) == 0x001920, "Member 'AGzPlayerCharacter::OnConsumableUsageStarted' has a wrong offset!");
static_assert(offsetof(AGzPlayerCharacter, OnConsumableUsageEnded) == 0x001930, "Member 'AGzPlayerCharacter::OnConsumableUsageEnded' has a wrong offset!");
static_assert(offsetof(AGzPlayerCharacter, OffLedgeLastTime) == 0x001958, "Member 'AGzPlayerCharacter::OffLedgeLastTime' has a wrong offset!");
static_assert(offsetof(AGzPlayerCharacter, CoyoteTime) == 0x00195C, "Member 'AGzPlayerCharacter::CoyoteTime' has a wrong offset!");
static_assert(offsetof(AGzPlayerCharacter, ReviveProgress) == 0x001960, "Member 'AGzPlayerCharacter::ReviveProgress' has a wrong offset!");
static_assert(offsetof(AGzPlayerCharacter, MinPitchForYawAcceleration) == 0x001964, "Member 'AGzPlayerCharacter::MinPitchForYawAcceleration' has a wrong offset!");
static_assert(offsetof(AGzPlayerCharacter, MinYawAcceleration) == 0x001968, "Member 'AGzPlayerCharacter::MinYawAcceleration' has a wrong offset!");
static_assert(offsetof(AGzPlayerCharacter, MaxYawAcceleration) == 0x00196C, "Member 'AGzPlayerCharacter::MaxYawAcceleration' has a wrong offset!");
static_assert(offsetof(AGzPlayerCharacter, AimCameraCompensateCache) == 0x0019A8, "Member 'AGzPlayerCharacter::AimCameraCompensateCache' has a wrong offset!");

// Class G01.GzPlayerCompletedMatchMessage
// 0x0008 (0x0030 - 0x0028)
class UGzPlayerCompletedMatchMessage final : public UGzGameMessage
{
public:
	int32                                         PlayerId;                                          // 0x0028(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Rank;                                              // 0x002C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzPlayerCompletedMatchMessage">();
	}
	static class UGzPlayerCompletedMatchMessage* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzPlayerCompletedMatchMessage>();
	}
};
static_assert(alignof(UGzPlayerCompletedMatchMessage) == 0x000008, "Wrong alignment on UGzPlayerCompletedMatchMessage");
static_assert(sizeof(UGzPlayerCompletedMatchMessage) == 0x000030, "Wrong size on UGzPlayerCompletedMatchMessage");
static_assert(offsetof(UGzPlayerCompletedMatchMessage, PlayerId) == 0x000028, "Member 'UGzPlayerCompletedMatchMessage::PlayerId' has a wrong offset!");
static_assert(offsetof(UGzPlayerCompletedMatchMessage, Rank) == 0x00002C, "Member 'UGzPlayerCompletedMatchMessage::Rank' has a wrong offset!");

// Class G01.GzPlayerDamageDealtStatCollector
// 0x0010 (0x00A8 - 0x0098)
class UGzPlayerDamageDealtStatCollector : public UGzThrottleStatsCollector
{
public:
	TArray<struct FGameplayAttribute>             TrackedAttributes;                                 // 0x0098(0x0010)(Edit, ZeroConstructor, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzPlayerDamageDealtStatCollector">();
	}
	static class UGzPlayerDamageDealtStatCollector* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzPlayerDamageDealtStatCollector>();
	}
};
static_assert(alignof(UGzPlayerDamageDealtStatCollector) == 0x000008, "Wrong alignment on UGzPlayerDamageDealtStatCollector");
static_assert(sizeof(UGzPlayerDamageDealtStatCollector) == 0x0000A8, "Wrong size on UGzPlayerDamageDealtStatCollector");
static_assert(offsetof(UGzPlayerDamageDealtStatCollector, TrackedAttributes) == 0x000098, "Member 'UGzPlayerDamageDealtStatCollector::TrackedAttributes' has a wrong offset!");

// Class G01.GzPropagationStrategy_Spherical
// 0x0010 (0x00D8 - 0x00C8)
class UGzPropagationStrategy_Spherical final : public UGzPropagationStrategy
{
public:
	uint8                                         Pad_348F[0x8];                                     // 0x00C8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UGzPropagationStrategyConfig_Spherical* SphericalConfig;                                   // 0x00D0(0x0008)(ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzPropagationStrategy_Spherical">();
	}
	static class UGzPropagationStrategy_Spherical* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzPropagationStrategy_Spherical>();
	}
};
static_assert(alignof(UGzPropagationStrategy_Spherical) == 0x000008, "Wrong alignment on UGzPropagationStrategy_Spherical");
static_assert(sizeof(UGzPropagationStrategy_Spherical) == 0x0000D8, "Wrong size on UGzPropagationStrategy_Spherical");
static_assert(offsetof(UGzPropagationStrategy_Spherical, SphericalConfig) == 0x0000D0, "Member 'UGzPropagationStrategy_Spherical::SphericalConfig' has a wrong offset!");

// Class G01.GzPlayerDamageTakenStatCollector
// 0x0010 (0x00A8 - 0x0098)
class UGzPlayerDamageTakenStatCollector : public UGzThrottleStatsCollector
{
public:
	TArray<struct FGameplayAttribute>             TrackedAttributes;                                 // 0x0098(0x0010)(Edit, ZeroConstructor, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzPlayerDamageTakenStatCollector">();
	}
	static class UGzPlayerDamageTakenStatCollector* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzPlayerDamageTakenStatCollector>();
	}
};
static_assert(alignof(UGzPlayerDamageTakenStatCollector) == 0x000008, "Wrong alignment on UGzPlayerDamageTakenStatCollector");
static_assert(sizeof(UGzPlayerDamageTakenStatCollector) == 0x0000A8, "Wrong size on UGzPlayerDamageTakenStatCollector");
static_assert(offsetof(UGzPlayerDamageTakenStatCollector, TrackedAttributes) == 0x000098, "Member 'UGzPlayerDamageTakenStatCollector::TrackedAttributes' has a wrong offset!");

// Class G01.GzPlayerDataLoadingState
// 0x0000 (0x0070 - 0x0070)
class UGzPlayerDataLoadingState final : public UGzFlowStateWithActionGraph
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzPlayerDataLoadingState">();
	}
	static class UGzPlayerDataLoadingState* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzPlayerDataLoadingState>();
	}
};
static_assert(alignof(UGzPlayerDataLoadingState) == 0x000008, "Wrong alignment on UGzPlayerDataLoadingState");
static_assert(sizeof(UGzPlayerDataLoadingState) == 0x000070, "Wrong size on UGzPlayerDataLoadingState");

// Class G01.GzPlayerDataSetupState
// 0x0000 (0x0070 - 0x0070)
class UGzPlayerDataSetupState final : public UGzFlowStateWithActionGraph
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzPlayerDataSetupState">();
	}
	static class UGzPlayerDataSetupState* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzPlayerDataSetupState>();
	}
};
static_assert(alignof(UGzPlayerDataSetupState) == 0x000008, "Wrong alignment on UGzPlayerDataSetupState");
static_assert(sizeof(UGzPlayerDataSetupState) == 0x000070, "Wrong size on UGzPlayerDataSetupState");

// Class G01.GzPlayerDeathLocationRevealSubsystem
// 0x0098 (0x0338 - 0x02A0)
class AGzPlayerDeathLocationRevealSubsystem : public AGzGameModeSubsystem
{
public:
	float                                         MarkerDurationAfterRespawn;                        // 0x02A0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3490[0x4];                                     // 0x02A4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftClassPtr<class UClass>                   MarkerToSpawn;                                     // 0x02A8(0x0028)(Edit, DisableEditOnInstance, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         FloorTraceLength;                                  // 0x02D0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3491[0x4];                                     // 0x02D4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<int32, struct FGzDeathLocationReveal>    DeathMarkers;                                      // 0x02D8(0x0050)(Transient, NativeAccessSpecifierPrivate)
	class UGzServerMarkerSubsystem*               ServerMarkerSubsystem;                             // 0x0328(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_3492[0x8];                                     // 0x0330(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnPlayerAliveStateChanged(class AGzPlayerState* PlayerState);
	void OnStageChanged();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzPlayerDeathLocationRevealSubsystem">();
	}
	static class AGzPlayerDeathLocationRevealSubsystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<AGzPlayerDeathLocationRevealSubsystem>();
	}
};
static_assert(alignof(AGzPlayerDeathLocationRevealSubsystem) == 0x000008, "Wrong alignment on AGzPlayerDeathLocationRevealSubsystem");
static_assert(sizeof(AGzPlayerDeathLocationRevealSubsystem) == 0x000338, "Wrong size on AGzPlayerDeathLocationRevealSubsystem");
static_assert(offsetof(AGzPlayerDeathLocationRevealSubsystem, MarkerDurationAfterRespawn) == 0x0002A0, "Member 'AGzPlayerDeathLocationRevealSubsystem::MarkerDurationAfterRespawn' has a wrong offset!");
static_assert(offsetof(AGzPlayerDeathLocationRevealSubsystem, MarkerToSpawn) == 0x0002A8, "Member 'AGzPlayerDeathLocationRevealSubsystem::MarkerToSpawn' has a wrong offset!");
static_assert(offsetof(AGzPlayerDeathLocationRevealSubsystem, FloorTraceLength) == 0x0002D0, "Member 'AGzPlayerDeathLocationRevealSubsystem::FloorTraceLength' has a wrong offset!");
static_assert(offsetof(AGzPlayerDeathLocationRevealSubsystem, DeathMarkers) == 0x0002D8, "Member 'AGzPlayerDeathLocationRevealSubsystem::DeathMarkers' has a wrong offset!");
static_assert(offsetof(AGzPlayerDeathLocationRevealSubsystem, ServerMarkerSubsystem) == 0x000328, "Member 'AGzPlayerDeathLocationRevealSubsystem::ServerMarkerSubsystem' has a wrong offset!");

// Class G01.GzPropagationStrategy_TileToTile
// 0x0018 (0x0100 - 0x00E8)
class UGzPropagationStrategy_TileToTile final : public UGzPropagationStrategy_Grid
{
public:
	uint8                                         Pad_3493[0x10];                                    // 0x00E8(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class UGzPropagationStrategyConfig_TileToTile* TileToTileConfig;                                  // 0x00F8(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzPropagationStrategy_TileToTile">();
	}
	static class UGzPropagationStrategy_TileToTile* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzPropagationStrategy_TileToTile>();
	}
};
static_assert(alignof(UGzPropagationStrategy_TileToTile) == 0x000008, "Wrong alignment on UGzPropagationStrategy_TileToTile");
static_assert(sizeof(UGzPropagationStrategy_TileToTile) == 0x000100, "Wrong size on UGzPropagationStrategy_TileToTile");
static_assert(offsetof(UGzPropagationStrategy_TileToTile, TileToTileConfig) == 0x0000F8, "Member 'UGzPropagationStrategy_TileToTile::TileToTileConfig' has a wrong offset!");

// Class G01.GzPlayerDeathsStatCollector
// 0x0000 (0x0040 - 0x0040)
class UGzPlayerDeathsStatCollector final : public UGzCharacterDeathStatCollector
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzPlayerDeathsStatCollector">();
	}
	static class UGzPlayerDeathsStatCollector* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzPlayerDeathsStatCollector>();
	}
};
static_assert(alignof(UGzPlayerDeathsStatCollector) == 0x000008, "Wrong alignment on UGzPlayerDeathsStatCollector");
static_assert(sizeof(UGzPlayerDeathsStatCollector) == 0x000040, "Wrong size on UGzPlayerDeathsStatCollector");

// Class G01.GzPlayerInput
// 0x0008 (0x07F8 - 0x07F0)
class UGzPlayerInput final : public UEnhancedPlayerInput
{
public:
	class ACohtmlInputActor*                      InputActor;                                        // 0x07F0(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzPlayerInput">();
	}
	static class UGzPlayerInput* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzPlayerInput>();
	}
};
static_assert(alignof(UGzPlayerInput) == 0x000008, "Wrong alignment on UGzPlayerInput");
static_assert(sizeof(UGzPlayerInput) == 0x0007F8, "Wrong size on UGzPlayerInput");
static_assert(offsetof(UGzPlayerInput, InputActor) == 0x0007F0, "Member 'UGzPlayerInput::InputActor' has a wrong offset!");

// Class G01.GzPlayerJoinValidationBeaconClient
// 0x0028 (0x0358 - 0x0330)
class AGzPlayerJoinValidationBeaconClient final : public AOnlineBeaconClient
{
public:
	uint8                                         Pad_3494[0x28];                                    // 0x0330(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ClientOnValidationResult(bool bCanJoin, const class FString& Reason);
	void ServerValidatePlayerCanJoin(const class FString& PlayerId);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzPlayerJoinValidationBeaconClient">();
	}
	static class AGzPlayerJoinValidationBeaconClient* GetDefaultObj()
	{
		return GetDefaultObjImpl<AGzPlayerJoinValidationBeaconClient>();
	}
};
static_assert(alignof(AGzPlayerJoinValidationBeaconClient) == 0x000008, "Wrong alignment on AGzPlayerJoinValidationBeaconClient");
static_assert(sizeof(AGzPlayerJoinValidationBeaconClient) == 0x000358, "Wrong size on AGzPlayerJoinValidationBeaconClient");

// Class G01.GzRadialMenu
// 0x0088 (0x05B0 - 0x0528)
class UGzRadialMenu final : public UGzNavigationWidget
{
public:
	FMulticastInlineDelegateProperty_             OnRadialMenuButtonStateChanged;                    // 0x0528(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	float                                         RotationOffset;                                    // 0x0538(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bHoldMode;                                         // 0x053C(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3496[0x3];                                     // 0x053D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         InnerRadius;                                       // 0x0540(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         HoveredButtonIndex;                                // 0x0544(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         NumberOfSegments;                                  // 0x0548(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3497[0x4];                                     // 0x054C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UGzRadialMenuButton*>            MenuSegments;                                      // 0x0550(0x0010)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	bool                                          bButtonFound;                                      // 0x0560(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3498[0x3];                                     // 0x0561(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         RadialScrollAlignmentAngle;                        // 0x0564(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 RadialScroll;                                      // 0x0568(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         OuterRadius;                                       // 0x0570(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         ButtonDistance;                                    // 0x0574(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSoftClassPtr<class UClass>                   RadialMenuSegmentWidgetClass;                      // 0x0578(0x0028)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         OuterMaxRadius;                                    // 0x05A0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         InnerMaxRadius;                                    // 0x05A4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bCreateSegmentsOnConstruct;                        // 0x05A8(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_3499[0x7];                                     // 0x05A9(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void CreateSegments(int32 InNumberOfSegments);
	void OnSegmentsCreated();
	void ResetRadialScroll();
	void UpdateRadialScroll(float MouseDirectionAngle);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzRadialMenu">();
	}
	static class UGzRadialMenu* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzRadialMenu>();
	}
};
static_assert(alignof(UGzRadialMenu) == 0x000008, "Wrong alignment on UGzRadialMenu");
static_assert(sizeof(UGzRadialMenu) == 0x0005B0, "Wrong size on UGzRadialMenu");
static_assert(offsetof(UGzRadialMenu, OnRadialMenuButtonStateChanged) == 0x000528, "Member 'UGzRadialMenu::OnRadialMenuButtonStateChanged' has a wrong offset!");
static_assert(offsetof(UGzRadialMenu, RotationOffset) == 0x000538, "Member 'UGzRadialMenu::RotationOffset' has a wrong offset!");
static_assert(offsetof(UGzRadialMenu, bHoldMode) == 0x00053C, "Member 'UGzRadialMenu::bHoldMode' has a wrong offset!");
static_assert(offsetof(UGzRadialMenu, InnerRadius) == 0x000540, "Member 'UGzRadialMenu::InnerRadius' has a wrong offset!");
static_assert(offsetof(UGzRadialMenu, HoveredButtonIndex) == 0x000544, "Member 'UGzRadialMenu::HoveredButtonIndex' has a wrong offset!");
static_assert(offsetof(UGzRadialMenu, NumberOfSegments) == 0x000548, "Member 'UGzRadialMenu::NumberOfSegments' has a wrong offset!");
static_assert(offsetof(UGzRadialMenu, MenuSegments) == 0x000550, "Member 'UGzRadialMenu::MenuSegments' has a wrong offset!");
static_assert(offsetof(UGzRadialMenu, bButtonFound) == 0x000560, "Member 'UGzRadialMenu::bButtonFound' has a wrong offset!");
static_assert(offsetof(UGzRadialMenu, RadialScrollAlignmentAngle) == 0x000564, "Member 'UGzRadialMenu::RadialScrollAlignmentAngle' has a wrong offset!");
static_assert(offsetof(UGzRadialMenu, RadialScroll) == 0x000568, "Member 'UGzRadialMenu::RadialScroll' has a wrong offset!");
static_assert(offsetof(UGzRadialMenu, OuterRadius) == 0x000570, "Member 'UGzRadialMenu::OuterRadius' has a wrong offset!");
static_assert(offsetof(UGzRadialMenu, ButtonDistance) == 0x000574, "Member 'UGzRadialMenu::ButtonDistance' has a wrong offset!");
static_assert(offsetof(UGzRadialMenu, RadialMenuSegmentWidgetClass) == 0x000578, "Member 'UGzRadialMenu::RadialMenuSegmentWidgetClass' has a wrong offset!");
static_assert(offsetof(UGzRadialMenu, OuterMaxRadius) == 0x0005A0, "Member 'UGzRadialMenu::OuterMaxRadius' has a wrong offset!");
static_assert(offsetof(UGzRadialMenu, InnerMaxRadius) == 0x0005A4, "Member 'UGzRadialMenu::InnerMaxRadius' has a wrong offset!");
static_assert(offsetof(UGzRadialMenu, bCreateSegmentsOnConstruct) == 0x0005A8, "Member 'UGzRadialMenu::bCreateSegmentsOnConstruct' has a wrong offset!");

// Class G01.GzPlayerOutOfHealthMessage
// 0x0010 (0x0058 - 0x0048)
class UGzPlayerOutOfHealthMessage : public UGzPlayerToPlayerInteractionMessage
{
public:
	struct FGameplayTag                           DamageSource;                                      // 0x0048(0x0008)(BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsCrit;                                           // 0x0050(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_349A[0x7];                                     // 0x0051(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzPlayerOutOfHealthMessage">();
	}
	static class UGzPlayerOutOfHealthMessage* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzPlayerOutOfHealthMessage>();
	}
};
static_assert(alignof(UGzPlayerOutOfHealthMessage) == 0x000008, "Wrong alignment on UGzPlayerOutOfHealthMessage");
static_assert(sizeof(UGzPlayerOutOfHealthMessage) == 0x000058, "Wrong size on UGzPlayerOutOfHealthMessage");
static_assert(offsetof(UGzPlayerOutOfHealthMessage, DamageSource) == 0x000048, "Member 'UGzPlayerOutOfHealthMessage::DamageSource' has a wrong offset!");
static_assert(offsetof(UGzPlayerOutOfHealthMessage, bIsCrit) == 0x000050, "Member 'UGzPlayerOutOfHealthMessage::bIsCrit' has a wrong offset!");

// Class G01.GzPlayerKilledMessage
// 0x0018 (0x0070 - 0x0058)
class UGzPlayerKilledMessage final : public UGzPlayerOutOfHealthMessage
{
public:
	TArray<struct FGzAdvancedIdType>              Assists;                                           // 0x0058(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	class FName                                   WeaponArchetype;                                   // 0x0068(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzPlayerKilledMessage">();
	}
	static class UGzPlayerKilledMessage* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzPlayerKilledMessage>();
	}
};
static_assert(alignof(UGzPlayerKilledMessage) == 0x000008, "Wrong alignment on UGzPlayerKilledMessage");
static_assert(sizeof(UGzPlayerKilledMessage) == 0x000070, "Wrong size on UGzPlayerKilledMessage");
static_assert(offsetof(UGzPlayerKilledMessage, Assists) == 0x000058, "Member 'UGzPlayerKilledMessage::Assists' has a wrong offset!");
static_assert(offsetof(UGzPlayerKilledMessage, WeaponArchetype) == 0x000068, "Member 'UGzPlayerKilledMessage::WeaponArchetype' has a wrong offset!");

// Class G01.GzPlayerKnockedDownMessage
// 0x0008 (0x0060 - 0x0058)
class UGzPlayerKnockedDownMessage final : public UGzPlayerOutOfHealthMessage
{
public:
	class FName                                   WeaponArchetype;                                   // 0x0058(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzPlayerKnockedDownMessage">();
	}
	static class UGzPlayerKnockedDownMessage* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzPlayerKnockedDownMessage>();
	}
};
static_assert(alignof(UGzPlayerKnockedDownMessage) == 0x000008, "Wrong alignment on UGzPlayerKnockedDownMessage");
static_assert(sizeof(UGzPlayerKnockedDownMessage) == 0x000060, "Wrong size on UGzPlayerKnockedDownMessage");
static_assert(offsetof(UGzPlayerKnockedDownMessage, WeaponArchetype) == 0x000058, "Member 'UGzPlayerKnockedDownMessage::WeaponArchetype' has a wrong offset!");

// Class G01.GzPlayerModel
// 0x0018 (0x0088 - 0x0070)
class UGzPlayerModel final : public UGzBackendModel
{
public:
	uint8                                         Pad_349B[0x18];                                    // 0x0070(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzPlayerModel">();
	}
	static class UGzPlayerModel* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzPlayerModel>();
	}
};
static_assert(alignof(UGzPlayerModel) == 0x000008, "Wrong alignment on UGzPlayerModel");
static_assert(sizeof(UGzPlayerModel) == 0x000088, "Wrong size on UGzPlayerModel");

// Class G01.GzPlayerProfileSettings
// 0x0098 (0x00D0 - 0x0038)
class UGzPlayerProfileSettings final : public UDeveloperSettings
{
public:
	uint8                                         Pad_349C[0x8];                                     // 0x0038(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         NicknameMinLength;                                 // 0x0040(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         NicknameMaxLength;                                 // 0x0044(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         NameTagMaxLength;                                  // 0x0048(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   DefaultAvatarId;                                   // 0x004C(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_349D[0x4];                                     // 0x0054(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<struct FGuid, TSoftObjectPtr<class UTexture2D>> Avatars;                                           // 0x0058(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, Config, DisableEditOnInstance, UObjectWrapper, NativeAccessSpecifierPublic)
	int32                                         DefaultCharacterSlotsNum;                          // 0x00A8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaxCharacterSlotsNum;                              // 0x00AC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         CharacterRenameCost;                               // 0x00B0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         CharacterNameMinLength;                            // 0x00B4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         CharacterNameMaxLength;                            // 0x00B8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ClanTagLength;                                     // 0x00BC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class FName>                           AvatarsIds;                                        // 0x00C0(0x0010)(ZeroConstructor, Config, NativeAccessSpecifierPrivate)

public:
	const TArray<class FName> GetAvatarsIds() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzPlayerProfileSettings">();
	}
	static class UGzPlayerProfileSettings* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzPlayerProfileSettings>();
	}
};
static_assert(alignof(UGzPlayerProfileSettings) == 0x000008, "Wrong alignment on UGzPlayerProfileSettings");
static_assert(sizeof(UGzPlayerProfileSettings) == 0x0000D0, "Wrong size on UGzPlayerProfileSettings");
static_assert(offsetof(UGzPlayerProfileSettings, NicknameMinLength) == 0x000040, "Member 'UGzPlayerProfileSettings::NicknameMinLength' has a wrong offset!");
static_assert(offsetof(UGzPlayerProfileSettings, NicknameMaxLength) == 0x000044, "Member 'UGzPlayerProfileSettings::NicknameMaxLength' has a wrong offset!");
static_assert(offsetof(UGzPlayerProfileSettings, NameTagMaxLength) == 0x000048, "Member 'UGzPlayerProfileSettings::NameTagMaxLength' has a wrong offset!");
static_assert(offsetof(UGzPlayerProfileSettings, DefaultAvatarId) == 0x00004C, "Member 'UGzPlayerProfileSettings::DefaultAvatarId' has a wrong offset!");
static_assert(offsetof(UGzPlayerProfileSettings, Avatars) == 0x000058, "Member 'UGzPlayerProfileSettings::Avatars' has a wrong offset!");
static_assert(offsetof(UGzPlayerProfileSettings, DefaultCharacterSlotsNum) == 0x0000A8, "Member 'UGzPlayerProfileSettings::DefaultCharacterSlotsNum' has a wrong offset!");
static_assert(offsetof(UGzPlayerProfileSettings, MaxCharacterSlotsNum) == 0x0000AC, "Member 'UGzPlayerProfileSettings::MaxCharacterSlotsNum' has a wrong offset!");
static_assert(offsetof(UGzPlayerProfileSettings, CharacterRenameCost) == 0x0000B0, "Member 'UGzPlayerProfileSettings::CharacterRenameCost' has a wrong offset!");
static_assert(offsetof(UGzPlayerProfileSettings, CharacterNameMinLength) == 0x0000B4, "Member 'UGzPlayerProfileSettings::CharacterNameMinLength' has a wrong offset!");
static_assert(offsetof(UGzPlayerProfileSettings, CharacterNameMaxLength) == 0x0000B8, "Member 'UGzPlayerProfileSettings::CharacterNameMaxLength' has a wrong offset!");
static_assert(offsetof(UGzPlayerProfileSettings, ClanTagLength) == 0x0000BC, "Member 'UGzPlayerProfileSettings::ClanTagLength' has a wrong offset!");
static_assert(offsetof(UGzPlayerProfileSettings, AvatarsIds) == 0x0000C0, "Member 'UGzPlayerProfileSettings::AvatarsIds' has a wrong offset!");

// Class G01.GzPlayerRedeployedMessage
// 0x0008 (0x0030 - 0x0028)
class UGzPlayerRedeployedMessage final : public UGzGameMessage
{
public:
	int32                                         InitiatorPlayerId;                                 // 0x0028(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         TargetPlayerId;                                    // 0x002C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzPlayerRedeployedMessage">();
	}
	static class UGzPlayerRedeployedMessage* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzPlayerRedeployedMessage>();
	}
};
static_assert(alignof(UGzPlayerRedeployedMessage) == 0x000008, "Wrong alignment on UGzPlayerRedeployedMessage");
static_assert(sizeof(UGzPlayerRedeployedMessage) == 0x000030, "Wrong size on UGzPlayerRedeployedMessage");
static_assert(offsetof(UGzPlayerRedeployedMessage, InitiatorPlayerId) == 0x000028, "Member 'UGzPlayerRedeployedMessage::InitiatorPlayerId' has a wrong offset!");
static_assert(offsetof(UGzPlayerRedeployedMessage, TargetPlayerId) == 0x00002C, "Member 'UGzPlayerRedeployedMessage::TargetPlayerId' has a wrong offset!");

// Class G01.GzPlayerRedeployStatCollector
// 0x0008 (0x0040 - 0x0038)
class UGzPlayerRedeployStatCollector final : public UGzGlobalStatsCollector
{
public:
	uint8                                         Pad_349E[0x8];                                     // 0x0038(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzPlayerRedeployStatCollector">();
	}
	static class UGzPlayerRedeployStatCollector* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzPlayerRedeployStatCollector>();
	}
};
static_assert(alignof(UGzPlayerRedeployStatCollector) == 0x000008, "Wrong alignment on UGzPlayerRedeployStatCollector");
static_assert(sizeof(UGzPlayerRedeployStatCollector) == 0x000040, "Wrong size on UGzPlayerRedeployStatCollector");

// Class G01.GzPlayerService
// 0x0158 (0x01F8 - 0x00A0)
class UGzPlayerService final : public UGzClientPFObject
{
public:
	uint8                                         Pad_349F[0x158];                                   // 0x00A0(0x0158)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	const struct FGzClientUserInfo GetPlayer() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzPlayerService">();
	}
	static class UGzPlayerService* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzPlayerService>();
	}
};
static_assert(alignof(UGzPlayerService) == 0x000008, "Wrong alignment on UGzPlayerService");
static_assert(sizeof(UGzPlayerService) == 0x0001F8, "Wrong size on UGzPlayerService");

// Class G01.GzPlayerViewTargetInterface
// 0x0000 (0x0028 - 0x0028)
class IGzPlayerViewTargetInterface final : public IInterface
{
public:
	class UAbilitySystemComponent* GetViewTargetAbilityComponent() const;
	class AGzBaseCharacter* GetViewTargetCharacter() const;
	class UGzInvComponent* GetViewTargetInventory() const;
	class AGzPlayerState* GetViewTargetPlayerState() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzPlayerViewTargetInterface">();
	}
	static class IGzPlayerViewTargetInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IGzPlayerViewTargetInterface>();
	}
};
static_assert(alignof(IGzPlayerViewTargetInterface) == 0x000008, "Wrong alignment on IGzPlayerViewTargetInterface");
static_assert(sizeof(IGzPlayerViewTargetInterface) == 0x000028, "Wrong size on IGzPlayerViewTargetInterface");

// Class G01.GzPlinkConnectionRewardComponent
// 0x0020 (0x00C0 - 0x00A0)
class UGzPlinkConnectionRewardComponent final : public UGzServiceComponent
{
public:
	uint8                                         Pad_34A0[0x20];                                    // 0x00A0(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzPlinkConnectionRewardComponent">();
	}
	static class UGzPlinkConnectionRewardComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzPlinkConnectionRewardComponent>();
	}
};
static_assert(alignof(UGzPlinkConnectionRewardComponent) == 0x000008, "Wrong alignment on UGzPlinkConnectionRewardComponent");
static_assert(sizeof(UGzPlinkConnectionRewardComponent) == 0x0000C0, "Wrong size on UGzPlinkConnectionRewardComponent");

// Class G01.GzPlinkModel
// 0x0068 (0x00D8 - 0x0070)
class UGzPlinkModel final : public UGzBackendModel
{
public:
	bool                                          bPlinkConnected;                                   // 0x0070(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_34A1[0x7];                                     // 0x0071(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FString>                         ItemRewards;                                       // 0x0078(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	TMap<class FString, double>                   CoinRewards;                                       // 0x0088(0x0050)(NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzPlinkModel">();
	}
	static class UGzPlinkModel* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzPlinkModel>();
	}
};
static_assert(alignof(UGzPlinkModel) == 0x000008, "Wrong alignment on UGzPlinkModel");
static_assert(sizeof(UGzPlinkModel) == 0x0000D8, "Wrong size on UGzPlinkModel");
static_assert(offsetof(UGzPlinkModel, bPlinkConnected) == 0x000070, "Member 'UGzPlinkModel::bPlinkConnected' has a wrong offset!");
static_assert(offsetof(UGzPlinkModel, ItemRewards) == 0x000078, "Member 'UGzPlinkModel::ItemRewards' has a wrong offset!");
static_assert(offsetof(UGzPlinkModel, CoinRewards) == 0x000088, "Member 'UGzPlinkModel::CoinRewards' has a wrong offset!");

// Class G01.GzPlinkPresenceSendingComponent
// 0x0010 (0x00B0 - 0x00A0)
class UGzPlinkPresenceSendingComponent final : public UGzServiceComponent
{
public:
	uint8                                         Pad_34A2[0x10];                                    // 0x00A0(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzPlinkPresenceSendingComponent">();
	}
	static class UGzPlinkPresenceSendingComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzPlinkPresenceSendingComponent>();
	}
};
static_assert(alignof(UGzPlinkPresenceSendingComponent) == 0x000008, "Wrong alignment on UGzPlinkPresenceSendingComponent");
static_assert(sizeof(UGzPlinkPresenceSendingComponent) == 0x0000B0, "Wrong size on UGzPlinkPresenceSendingComponent");

// Class G01.GzPocketGroupWidget
// 0x00D8 (0x03E8 - 0x0310)
class UGzPocketGroupWidget : public UGzBaseInventoryWidget
{
public:
	TSubclassOf<class UGzPocketWidget>            PocketWidgetClass;                                 // 0x0310(0x0008)(Edit, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bSort;                                             // 0x0318(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_34A3[0x7];                                     // 0x0319(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<struct FGameplayTag, int32>              ItemTypeSortWeights;                               // 0x0320(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)
	TArray<struct FGzInvPocket>                   Pockets;                                           // 0x0370(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	TMap<struct FGzInvPocketId, class UGzPocketWidget*> PocketsWidgets;                                    // 0x0380(0x0050)(BlueprintVisible, ExportObject, BlueprintReadOnly, Transient, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_34A4[0x18];                                    // 0x03D0(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnPocketsUpdated();
	void OnPocketWidgetAdded(class UGzPocketWidget* PocketWidget, int32 Param_Index);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzPocketGroupWidget">();
	}
	static class UGzPocketGroupWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzPocketGroupWidget>();
	}
};
static_assert(alignof(UGzPocketGroupWidget) == 0x000008, "Wrong alignment on UGzPocketGroupWidget");
static_assert(sizeof(UGzPocketGroupWidget) == 0x0003E8, "Wrong size on UGzPocketGroupWidget");
static_assert(offsetof(UGzPocketGroupWidget, PocketWidgetClass) == 0x000310, "Member 'UGzPocketGroupWidget::PocketWidgetClass' has a wrong offset!");
static_assert(offsetof(UGzPocketGroupWidget, bSort) == 0x000318, "Member 'UGzPocketGroupWidget::bSort' has a wrong offset!");
static_assert(offsetof(UGzPocketGroupWidget, ItemTypeSortWeights) == 0x000320, "Member 'UGzPocketGroupWidget::ItemTypeSortWeights' has a wrong offset!");
static_assert(offsetof(UGzPocketGroupWidget, Pockets) == 0x000370, "Member 'UGzPocketGroupWidget::Pockets' has a wrong offset!");
static_assert(offsetof(UGzPocketGroupWidget, PocketsWidgets) == 0x000380, "Member 'UGzPocketGroupWidget::PocketsWidgets' has a wrong offset!");

// Class G01.GzPolygonAreaMarkerWidget
// 0x0108 (0x04B0 - 0x03A8)
class UGzPolygonAreaMarkerWidget final : public UGzShapeMapMarkerWidget
{
public:
	TSoftObjectPtr<class UMaterialInterface>      FillMaterial;                                      // 0x03A8(0x0028)(Edit, DisableEditOnInstance, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextureRenderTarget2D*                 RenderTarget;                                      // 0x03D0(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_34A6[0x8];                                     // 0x03D8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FSlateBrush                            Brush;                                             // 0x03E0(0x00D0)(Transient, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzPolygonAreaMarkerWidget">();
	}
	static class UGzPolygonAreaMarkerWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzPolygonAreaMarkerWidget>();
	}
};
static_assert(alignof(UGzPolygonAreaMarkerWidget) == 0x000010, "Wrong alignment on UGzPolygonAreaMarkerWidget");
static_assert(sizeof(UGzPolygonAreaMarkerWidget) == 0x0004B0, "Wrong size on UGzPolygonAreaMarkerWidget");
static_assert(offsetof(UGzPolygonAreaMarkerWidget, FillMaterial) == 0x0003A8, "Member 'UGzPolygonAreaMarkerWidget::FillMaterial' has a wrong offset!");
static_assert(offsetof(UGzPolygonAreaMarkerWidget, RenderTarget) == 0x0003D0, "Member 'UGzPolygonAreaMarkerWidget::RenderTarget' has a wrong offset!");
static_assert(offsetof(UGzPolygonAreaMarkerWidget, Brush) == 0x0003E0, "Member 'UGzPolygonAreaMarkerWidget::Brush' has a wrong offset!");

// Class G01.GzPostLoginState
// 0x0010 (0x0080 - 0x0070)
class UGzPostLoginState final : public UGzFlowStateWithActionGraph
{
public:
	uint8                                         Pad_34A7[0x10];                                    // 0x0070(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzPostLoginState">();
	}
	static class UGzPostLoginState* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzPostLoginState>();
	}
};
static_assert(alignof(UGzPostLoginState) == 0x000008, "Wrong alignment on UGzPostLoginState");
static_assert(sizeof(UGzPostLoginState) == 0x000080, "Wrong size on UGzPostLoginState");

// Class G01.GzPostmatchLoadingState
// 0x0000 (0x0070 - 0x0070)
class UGzPostmatchLoadingState final : public UGzFlowStateWithActionGraph
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzPostmatchLoadingState">();
	}
	static class UGzPostmatchLoadingState* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzPostmatchLoadingState>();
	}
};
static_assert(alignof(UGzPostmatchLoadingState) == 0x000008, "Wrong alignment on UGzPostmatchLoadingState");
static_assert(sizeof(UGzPostmatchLoadingState) == 0x000070, "Wrong size on UGzPostmatchLoadingState");

// Class G01.GzPostMatchRewardSettings
// 0x0018 (0x0050 - 0x0038)
class UGzPostMatchRewardSettings final : public UDeveloperSettings
{
public:
	uint8                                         Pad_34A8[0x8];                                     // 0x0038(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FGzPlacementRangeRewardSetting> PlacementRewardSettings;                           // 0x0040(0x0010)(Edit, ZeroConstructor, Config, DisableEditOnInstance, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzPostMatchRewardSettings">();
	}
	static class UGzPostMatchRewardSettings* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzPostMatchRewardSettings>();
	}
};
static_assert(alignof(UGzPostMatchRewardSettings) == 0x000008, "Wrong alignment on UGzPostMatchRewardSettings");
static_assert(sizeof(UGzPostMatchRewardSettings) == 0x000050, "Wrong size on UGzPostMatchRewardSettings");
static_assert(offsetof(UGzPostMatchRewardSettings, PlacementRewardSettings) == 0x000040, "Member 'UGzPostMatchRewardSettings::PlacementRewardSettings' has a wrong offset!");

// Class G01.GzPrecommitTestingGameState
// 0x0000 (0x05D8 - 0x05D8)
class AGzPrecommitTestingGameState final : public AGzGameState
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzPrecommitTestingGameState">();
	}
	static class AGzPrecommitTestingGameState* GetDefaultObj()
	{
		return GetDefaultObjImpl<AGzPrecommitTestingGameState>();
	}
};
static_assert(alignof(AGzPrecommitTestingGameState) == 0x000008, "Wrong alignment on AGzPrecommitTestingGameState");
static_assert(sizeof(AGzPrecommitTestingGameState) == 0x0005D8, "Wrong size on AGzPrecommitTestingGameState");

// Class G01.GzPredefinedPlayerLoadout
// 0x0020 (0x0050 - 0x0030)
class UGzPredefinedPlayerLoadout final : public UDataAsset
{
public:
	TArray<struct FGzInventoryItemContent>        Items;                                             // 0x0030(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	TArray<struct FGzInvItem>                     InventoryItems;                                    // 0x0040(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzPredefinedPlayerLoadout">();
	}
	static class UGzPredefinedPlayerLoadout* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzPredefinedPlayerLoadout>();
	}
};
static_assert(alignof(UGzPredefinedPlayerLoadout) == 0x000008, "Wrong alignment on UGzPredefinedPlayerLoadout");
static_assert(sizeof(UGzPredefinedPlayerLoadout) == 0x000050, "Wrong size on UGzPredefinedPlayerLoadout");
static_assert(offsetof(UGzPredefinedPlayerLoadout, Items) == 0x000030, "Member 'UGzPredefinedPlayerLoadout::Items' has a wrong offset!");
static_assert(offsetof(UGzPredefinedPlayerLoadout, InventoryItems) == 0x000040, "Member 'UGzPredefinedPlayerLoadout::InventoryItems' has a wrong offset!");

// Class G01.GzPreInitState
// 0x0000 (0x0070 - 0x0070)
class UGzPreInitState final : public UGzFlowStateWithActionGraph
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzPreInitState">();
	}
	static class UGzPreInitState* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzPreInitState>();
	}
};
static_assert(alignof(UGzPreInitState) == 0x000008, "Wrong alignment on UGzPreInitState");
static_assert(sizeof(UGzPreInitState) == 0x000070, "Wrong size on UGzPreInitState");

// Class G01.GzPreMatchDurationStatCollector
// 0x0008 (0x0040 - 0x0038)
class UGzPreMatchDurationStatCollector final : public UGzGlobalStatsCollector
{
public:
	uint8                                         Pad_34A9[0x8];                                     // 0x0038(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzPreMatchDurationStatCollector">();
	}
	static class UGzPreMatchDurationStatCollector* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzPreMatchDurationStatCollector>();
	}
};
static_assert(alignof(UGzPreMatchDurationStatCollector) == 0x000008, "Wrong alignment on UGzPreMatchDurationStatCollector");
static_assert(sizeof(UGzPreMatchDurationStatCollector) == 0x000040, "Wrong size on UGzPreMatchDurationStatCollector");

// Class G01.GzPrematchZonesExtension
// 0x0020 (0x0058 - 0x0038)
class UGzPrematchZonesExtension : public UGzMapWidgetExtension
{
public:
	class UMaterialInterface*                     ZoneFillMaterial;                                  // 0x0038(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UGzZoneFillLayerWidget*                 FillLayerWidget;                                   // 0x0040(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         FillZOrder;                                        // 0x0048(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_34AA[0x4];                                     // 0x004C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class AGzSpawnZone*                           LastZone;                                          // 0x0050(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void MapTransformChanged();
	void OnStageChanged();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzPrematchZonesExtension">();
	}
	static class UGzPrematchZonesExtension* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzPrematchZonesExtension>();
	}
};
static_assert(alignof(UGzPrematchZonesExtension) == 0x000008, "Wrong alignment on UGzPrematchZonesExtension");
static_assert(sizeof(UGzPrematchZonesExtension) == 0x000058, "Wrong size on UGzPrematchZonesExtension");
static_assert(offsetof(UGzPrematchZonesExtension, ZoneFillMaterial) == 0x000038, "Member 'UGzPrematchZonesExtension::ZoneFillMaterial' has a wrong offset!");
static_assert(offsetof(UGzPrematchZonesExtension, FillLayerWidget) == 0x000040, "Member 'UGzPrematchZonesExtension::FillLayerWidget' has a wrong offset!");
static_assert(offsetof(UGzPrematchZonesExtension, FillZOrder) == 0x000048, "Member 'UGzPrematchZonesExtension::FillZOrder' has a wrong offset!");
static_assert(offsetof(UGzPrematchZonesExtension, LastZone) == 0x000050, "Member 'UGzPrematchZonesExtension::LastZone' has a wrong offset!");

// Class G01.GzProceduralDeploymentTransport
// 0x0040 (0x0528 - 0x04E8)
class AGzProceduralDeploymentTransport : public AGzDeploymentTransport
{
public:
	TSubclassOf<class AGzProceduralTrack>         TrackClass;                                        // 0x04E8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FGzDeploymentTrackSpawnData            TrackSpawnData;                                    // 0x04F0(0x0038)(Net, RepNotify, NoDestructor, NativeAccessSpecifierPrivate)

public:
	void OnRep_TrackSpawnData();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzProceduralDeploymentTransport">();
	}
	static class AGzProceduralDeploymentTransport* GetDefaultObj()
	{
		return GetDefaultObjImpl<AGzProceduralDeploymentTransport>();
	}
};
static_assert(alignof(AGzProceduralDeploymentTransport) == 0x000008, "Wrong alignment on AGzProceduralDeploymentTransport");
static_assert(sizeof(AGzProceduralDeploymentTransport) == 0x000528, "Wrong size on AGzProceduralDeploymentTransport");
static_assert(offsetof(AGzProceduralDeploymentTransport, TrackClass) == 0x0004E8, "Member 'AGzProceduralDeploymentTransport::TrackClass' has a wrong offset!");
static_assert(offsetof(AGzProceduralDeploymentTransport, TrackSpawnData) == 0x0004F0, "Member 'AGzProceduralDeploymentTransport::TrackSpawnData' has a wrong offset!");

// Class G01.GzLandingLocationVFX
// 0x0000 (0x02A0 - 0x02A0)
class AGzLandingLocationVFX : public AActor
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzLandingLocationVFX">();
	}
	static class AGzLandingLocationVFX* GetDefaultObj()
	{
		return GetDefaultObjImpl<AGzLandingLocationVFX>();
	}
};
static_assert(alignof(AGzLandingLocationVFX) == 0x000008, "Wrong alignment on AGzLandingLocationVFX");
static_assert(sizeof(AGzLandingLocationVFX) == 0x0002A0, "Wrong size on AGzLandingLocationVFX");

// Class G01.GzProcedureTrackTransportLandingLocation
// 0x0010 (0x02B0 - 0x02A0)
class AGzProcedureTrackTransportLandingLocation : public AActor
{
public:
	float                                         SpawnHeight;                                       // 0x02A0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         DeliveryHeightOffset;                              // 0x02A4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_34AB[0x8];                                     // 0x02A8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static bool GetDebugLoadoutDrop();

	bool CanBeUsed();
	void OnDeliveryTriggered(class AGzProceduralTrackTransport* Transport);
	void TriggerDropPodDelivery(const TSubclassOf<class AGzProceduralTrackTransport>& DropPodClass);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzProcedureTrackTransportLandingLocation">();
	}
	static class AGzProcedureTrackTransportLandingLocation* GetDefaultObj()
	{
		return GetDefaultObjImpl<AGzProcedureTrackTransportLandingLocation>();
	}
};
static_assert(alignof(AGzProcedureTrackTransportLandingLocation) == 0x000008, "Wrong alignment on AGzProcedureTrackTransportLandingLocation");
static_assert(sizeof(AGzProcedureTrackTransportLandingLocation) == 0x0002B0, "Wrong size on AGzProcedureTrackTransportLandingLocation");
static_assert(offsetof(AGzProcedureTrackTransportLandingLocation, SpawnHeight) == 0x0002A0, "Member 'AGzProcedureTrackTransportLandingLocation::SpawnHeight' has a wrong offset!");
static_assert(offsetof(AGzProcedureTrackTransportLandingLocation, DeliveryHeightOffset) == 0x0002A4, "Member 'AGzProcedureTrackTransportLandingLocation::DeliveryHeightOffset' has a wrong offset!");

// Class G01.GzClientProgressionService
// 0x0020 (0x00C0 - 0x00A0)
class UGzClientProgressionService final : public UGzClientPFObject
{
public:
	uint8                                         Pad_34AC[0x20];                                    // 0x00A0(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzClientProgressionService">();
	}
	static class UGzClientProgressionService* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzClientProgressionService>();
	}
};
static_assert(alignof(UGzClientProgressionService) == 0x000008, "Wrong alignment on UGzClientProgressionService");
static_assert(sizeof(UGzClientProgressionService) == 0x0000C0, "Wrong size on UGzClientProgressionService");

// Class G01.GzProgressionSubsystem
// 0x0060 (0x0300 - 0x02A0)
class AGzProgressionSubsystem : public AGzGameModeSubsystem
{
public:
	class FName                                   BaseXpEntryKey;                                    // 0x02A0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   BaseCurrencyEntryKey;                              // 0x02A8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSet<int32>                                   PlayersCompletedProgression;                       // 0x02B0(0x0050)(BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)

public:
	double CalculateBaseHardCurrency(int32 PlayerId) const;
	int32 CalculateBaseSoftCurrency(int32 PlayerId) const;
	int32 CalculateBaseXp(int32 PlayerId) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzProgressionSubsystem">();
	}
	static class AGzProgressionSubsystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<AGzProgressionSubsystem>();
	}
};
static_assert(alignof(AGzProgressionSubsystem) == 0x000008, "Wrong alignment on AGzProgressionSubsystem");
static_assert(sizeof(AGzProgressionSubsystem) == 0x000300, "Wrong size on AGzProgressionSubsystem");
static_assert(offsetof(AGzProgressionSubsystem, BaseXpEntryKey) == 0x0002A0, "Member 'AGzProgressionSubsystem::BaseXpEntryKey' has a wrong offset!");
static_assert(offsetof(AGzProgressionSubsystem, BaseCurrencyEntryKey) == 0x0002A8, "Member 'AGzProgressionSubsystem::BaseCurrencyEntryKey' has a wrong offset!");
static_assert(offsetof(AGzProgressionSubsystem, PlayersCompletedProgression) == 0x0002B0, "Member 'AGzProgressionSubsystem::PlayersCompletedProgression' has a wrong offset!");

// Class G01.GzProgressLogEntryWidget
// 0x0028 (0x0308 - 0x02E0)
class UGzProgressLogEntryWidget : public UUserWidget
{
public:
	float                                         TargetProgress;                                    // 0x02E0(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         CurrentProgress;                                   // 0x02E4(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       FadeInAnimation;                                   // 0x02E8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       FadeOutAnimation;                                  // 0x02F0(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bUpdateProgress;                                   // 0x02F8(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_34AE[0xF];                                     // 0x02F9(0x000F)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnFadeOutFinished_BP();
	void OnInit_BP();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzProgressLogEntryWidget">();
	}
	static class UGzProgressLogEntryWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzProgressLogEntryWidget>();
	}
};
static_assert(alignof(UGzProgressLogEntryWidget) == 0x000008, "Wrong alignment on UGzProgressLogEntryWidget");
static_assert(sizeof(UGzProgressLogEntryWidget) == 0x000308, "Wrong size on UGzProgressLogEntryWidget");
static_assert(offsetof(UGzProgressLogEntryWidget, TargetProgress) == 0x0002E0, "Member 'UGzProgressLogEntryWidget::TargetProgress' has a wrong offset!");
static_assert(offsetof(UGzProgressLogEntryWidget, CurrentProgress) == 0x0002E4, "Member 'UGzProgressLogEntryWidget::CurrentProgress' has a wrong offset!");
static_assert(offsetof(UGzProgressLogEntryWidget, FadeInAnimation) == 0x0002E8, "Member 'UGzProgressLogEntryWidget::FadeInAnimation' has a wrong offset!");
static_assert(offsetof(UGzProgressLogEntryWidget, FadeOutAnimation) == 0x0002F0, "Member 'UGzProgressLogEntryWidget::FadeOutAnimation' has a wrong offset!");
static_assert(offsetof(UGzProgressLogEntryWidget, bUpdateProgress) == 0x0002F8, "Member 'UGzProgressLogEntryWidget::bUpdateProgress' has a wrong offset!");

// Class G01.GzProjectileAttackParams
// 0x0010 (0x0038 - 0x0028)
class UGzProjectileAttackParams final : public UObject
{
public:
	TSubclassOf<class AActor>                     ProjectileActorClass;                              // 0x0028(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Lifetime;                                          // 0x0030(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Speed;                                             // 0x0034(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzProjectileAttackParams">();
	}
	static class UGzProjectileAttackParams* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzProjectileAttackParams>();
	}
};
static_assert(alignof(UGzProjectileAttackParams) == 0x000008, "Wrong alignment on UGzProjectileAttackParams");
static_assert(sizeof(UGzProjectileAttackParams) == 0x000038, "Wrong size on UGzProjectileAttackParams");
static_assert(offsetof(UGzProjectileAttackParams, ProjectileActorClass) == 0x000028, "Member 'UGzProjectileAttackParams::ProjectileActorClass' has a wrong offset!");
static_assert(offsetof(UGzProjectileAttackParams, Lifetime) == 0x000030, "Member 'UGzProjectileAttackParams::Lifetime' has a wrong offset!");
static_assert(offsetof(UGzProjectileAttackParams, Speed) == 0x000034, "Member 'UGzProjectileAttackParams::Speed' has a wrong offset!");

// Class G01.GzProjectileMine
// 0x0030 (0x0378 - 0x0348)
class AGzProjectileMine final : public AGzProjectileBase
{
public:
	TSubclassOf<class UGzGE_BaseDamage>           AttackDamageEffect;                                // 0x0348(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bExplodeOnHit;                                     // 0x0350(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_34AF[0x3];                                     // 0x0351(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         TimeBeforeExplode;                                 // 0x0354(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ExplosionRadius;                                   // 0x0358(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_34B0[0x4];                                     // 0x035C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UNiagaraSystem*                         ExpolisionParticleNiagaraSystem;                   // 0x0360(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAkAudioEvent*                          ExplosionAkAudioEvent;                             // 0x0368(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_34B1[0x8];                                     // 0x0370(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Explode();
	void ExplodeAtClients(const struct FGzProjectileImpactData& ImpactData);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzProjectileMine">();
	}
	static class AGzProjectileMine* GetDefaultObj()
	{
		return GetDefaultObjImpl<AGzProjectileMine>();
	}
};
static_assert(alignof(AGzProjectileMine) == 0x000008, "Wrong alignment on AGzProjectileMine");
static_assert(sizeof(AGzProjectileMine) == 0x000378, "Wrong size on AGzProjectileMine");
static_assert(offsetof(AGzProjectileMine, AttackDamageEffect) == 0x000348, "Member 'AGzProjectileMine::AttackDamageEffect' has a wrong offset!");
static_assert(offsetof(AGzProjectileMine, bExplodeOnHit) == 0x000350, "Member 'AGzProjectileMine::bExplodeOnHit' has a wrong offset!");
static_assert(offsetof(AGzProjectileMine, TimeBeforeExplode) == 0x000354, "Member 'AGzProjectileMine::TimeBeforeExplode' has a wrong offset!");
static_assert(offsetof(AGzProjectileMine, ExplosionRadius) == 0x000358, "Member 'AGzProjectileMine::ExplosionRadius' has a wrong offset!");
static_assert(offsetof(AGzProjectileMine, ExpolisionParticleNiagaraSystem) == 0x000360, "Member 'AGzProjectileMine::ExpolisionParticleNiagaraSystem' has a wrong offset!");
static_assert(offsetof(AGzProjectileMine, ExplosionAkAudioEvent) == 0x000368, "Member 'AGzProjectileMine::ExplosionAkAudioEvent' has a wrong offset!");

// Class G01.GzPropagationCollisionConfig
// 0x0048 (0x0070 - 0x0028)
class UGzPropagationCollisionConfig final : public UObject
{
public:
	bool                                          bEnableHorizontalCheck;                            // 0x0028(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEnableHorizontalPreCheck;                         // 0x0029(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_34B2[0x6];                                     // 0x002A(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                HorizontalCheckStartOffset;                        // 0x0030(0x0018)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEnableVerticalCheck;                              // 0x0048(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_34B3[0x7];                                     // 0x0049(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                VerticalCheckTargetOffset;                         // 0x0050(0x0018)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxAllowedSurfaceAngle;                            // 0x0068(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECollisionChannel                             CollisionChannel;                                  // 0x006C(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_34B4[0x3];                                     // 0x006D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzPropagationCollisionConfig">();
	}
	static class UGzPropagationCollisionConfig* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzPropagationCollisionConfig>();
	}
};
static_assert(alignof(UGzPropagationCollisionConfig) == 0x000008, "Wrong alignment on UGzPropagationCollisionConfig");
static_assert(sizeof(UGzPropagationCollisionConfig) == 0x000070, "Wrong size on UGzPropagationCollisionConfig");
static_assert(offsetof(UGzPropagationCollisionConfig, bEnableHorizontalCheck) == 0x000028, "Member 'UGzPropagationCollisionConfig::bEnableHorizontalCheck' has a wrong offset!");
static_assert(offsetof(UGzPropagationCollisionConfig, bEnableHorizontalPreCheck) == 0x000029, "Member 'UGzPropagationCollisionConfig::bEnableHorizontalPreCheck' has a wrong offset!");
static_assert(offsetof(UGzPropagationCollisionConfig, HorizontalCheckStartOffset) == 0x000030, "Member 'UGzPropagationCollisionConfig::HorizontalCheckStartOffset' has a wrong offset!");
static_assert(offsetof(UGzPropagationCollisionConfig, bEnableVerticalCheck) == 0x000048, "Member 'UGzPropagationCollisionConfig::bEnableVerticalCheck' has a wrong offset!");
static_assert(offsetof(UGzPropagationCollisionConfig, VerticalCheckTargetOffset) == 0x000050, "Member 'UGzPropagationCollisionConfig::VerticalCheckTargetOffset' has a wrong offset!");
static_assert(offsetof(UGzPropagationCollisionConfig, MaxAllowedSurfaceAngle) == 0x000068, "Member 'UGzPropagationCollisionConfig::MaxAllowedSurfaceAngle' has a wrong offset!");
static_assert(offsetof(UGzPropagationCollisionConfig, CollisionChannel) == 0x00006C, "Member 'UGzPropagationCollisionConfig::CollisionChannel' has a wrong offset!");

// Class G01.GzPropagationStrategyConfig_Spherical
// 0x0018 (0x0088 - 0x0070)
class UGzPropagationStrategyConfig_Spherical final : public UGzPropagationStrategyConfig
{
public:
	bool                                          bGenerateDiscDistribution;                         // 0x0070(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_34B5[0x3];                                     // 0x0071(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         MaxPointsPerLayer;                                 // 0x0074(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LayerRadius;                                       // 0x0078(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SphereLayerAmount;                                 // 0x007C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PropagationSpeedPerSecond;                         // 0x0080(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDestroyInSpawnOrder;                              // 0x0084(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_34B6[0x3];                                     // 0x0085(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzPropagationStrategyConfig_Spherical">();
	}
	static class UGzPropagationStrategyConfig_Spherical* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzPropagationStrategyConfig_Spherical>();
	}
};
static_assert(alignof(UGzPropagationStrategyConfig_Spherical) == 0x000008, "Wrong alignment on UGzPropagationStrategyConfig_Spherical");
static_assert(sizeof(UGzPropagationStrategyConfig_Spherical) == 0x000088, "Wrong size on UGzPropagationStrategyConfig_Spherical");
static_assert(offsetof(UGzPropagationStrategyConfig_Spherical, bGenerateDiscDistribution) == 0x000070, "Member 'UGzPropagationStrategyConfig_Spherical::bGenerateDiscDistribution' has a wrong offset!");
static_assert(offsetof(UGzPropagationStrategyConfig_Spherical, MaxPointsPerLayer) == 0x000074, "Member 'UGzPropagationStrategyConfig_Spherical::MaxPointsPerLayer' has a wrong offset!");
static_assert(offsetof(UGzPropagationStrategyConfig_Spherical, LayerRadius) == 0x000078, "Member 'UGzPropagationStrategyConfig_Spherical::LayerRadius' has a wrong offset!");
static_assert(offsetof(UGzPropagationStrategyConfig_Spherical, SphereLayerAmount) == 0x00007C, "Member 'UGzPropagationStrategyConfig_Spherical::SphereLayerAmount' has a wrong offset!");
static_assert(offsetof(UGzPropagationStrategyConfig_Spherical, PropagationSpeedPerSecond) == 0x000080, "Member 'UGzPropagationStrategyConfig_Spherical::PropagationSpeedPerSecond' has a wrong offset!");
static_assert(offsetof(UGzPropagationStrategyConfig_Spherical, bDestroyInSpawnOrder) == 0x000084, "Member 'UGzPropagationStrategyConfig_Spherical::bDestroyInSpawnOrder' has a wrong offset!");

// Class G01.GzPropagationStrategy_SphericalGrid
// 0x0010 (0x00F8 - 0x00E8)
class UGzPropagationStrategy_SphericalGrid final : public UGzPropagationStrategy_Grid
{
public:
	uint8                                         Pad_34B7[0x8];                                     // 0x00E8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UGzPropagationStrategyConfig_SphericalGrid* SphericalGridConfig;                               // 0x00F0(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzPropagationStrategy_SphericalGrid">();
	}
	static class UGzPropagationStrategy_SphericalGrid* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzPropagationStrategy_SphericalGrid>();
	}
};
static_assert(alignof(UGzPropagationStrategy_SphericalGrid) == 0x000008, "Wrong alignment on UGzPropagationStrategy_SphericalGrid");
static_assert(sizeof(UGzPropagationStrategy_SphericalGrid) == 0x0000F8, "Wrong size on UGzPropagationStrategy_SphericalGrid");
static_assert(offsetof(UGzPropagationStrategy_SphericalGrid, SphericalGridConfig) == 0x0000F0, "Member 'UGzPropagationStrategy_SphericalGrid::SphericalGridConfig' has a wrong offset!");

// Class G01.GzPropagationStrategyConfig_TileToTile
// 0x0008 (0x00B0 - 0x00A8)
class UGzPropagationStrategyConfig_TileToTile final : public UGzPropagationStrategyConfig_Grid
{
public:
	float                                         MinTimeDelayPropagation;                           // 0x00A8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxTimeDelayPropagation;                           // 0x00AC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzPropagationStrategyConfig_TileToTile">();
	}
	static class UGzPropagationStrategyConfig_TileToTile* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzPropagationStrategyConfig_TileToTile>();
	}
};
static_assert(alignof(UGzPropagationStrategyConfig_TileToTile) == 0x000008, "Wrong alignment on UGzPropagationStrategyConfig_TileToTile");
static_assert(sizeof(UGzPropagationStrategyConfig_TileToTile) == 0x0000B0, "Wrong size on UGzPropagationStrategyConfig_TileToTile");
static_assert(offsetof(UGzPropagationStrategyConfig_TileToTile, MinTimeDelayPropagation) == 0x0000A8, "Member 'UGzPropagationStrategyConfig_TileToTile::MinTimeDelayPropagation' has a wrong offset!");
static_assert(offsetof(UGzPropagationStrategyConfig_TileToTile, MaxTimeDelayPropagation) == 0x0000AC, "Member 'UGzPropagationStrategyConfig_TileToTile::MaxTimeDelayPropagation' has a wrong offset!");

// Class G01.GzRadialLootSpawnerComponent
// 0x0018 (0x0120 - 0x0108)
class UGzRadialLootSpawnerComponent final : public UGzLootSpawnerComponent
{
public:
	float                                         SizeOfLevel;                                       // 0x0108(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_34B8[0x4];                                     // 0x010C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<int32>                                 MaxItemsPerLevelArray;                             // 0x0110(0x0010)(Edit, ZeroConstructor, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzRadialLootSpawnerComponent">();
	}
	static class UGzRadialLootSpawnerComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzRadialLootSpawnerComponent>();
	}
};
static_assert(alignof(UGzRadialLootSpawnerComponent) == 0x000008, "Wrong alignment on UGzRadialLootSpawnerComponent");
static_assert(sizeof(UGzRadialLootSpawnerComponent) == 0x000120, "Wrong size on UGzRadialLootSpawnerComponent");
static_assert(offsetof(UGzRadialLootSpawnerComponent, SizeOfLevel) == 0x000108, "Member 'UGzRadialLootSpawnerComponent::SizeOfLevel' has a wrong offset!");
static_assert(offsetof(UGzRadialLootSpawnerComponent, MaxItemsPerLevelArray) == 0x000110, "Member 'UGzRadialLootSpawnerComponent::MaxItemsPerLevelArray' has a wrong offset!");

// Class G01.GzRadialMenuButton
// 0x0060 (0x0340 - 0x02E0)
class UGzRadialMenuButton final : public UUserWidget
{
public:
	TMap<EGzRadialMenuButtonState, struct FSlateBrush> ButtonStateBrushes;                                // 0x02E0(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_34B9[0x10];                                    // 0x0330(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnHovered();
	void OnPressed();
	void OnUnhovered();
	void SetButtonName(const class FName& InButtonName);

	class FName GetButtonName() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzRadialMenuButton">();
	}
	static class UGzRadialMenuButton* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzRadialMenuButton>();
	}
};
static_assert(alignof(UGzRadialMenuButton) == 0x000008, "Wrong alignment on UGzRadialMenuButton");
static_assert(sizeof(UGzRadialMenuButton) == 0x000340, "Wrong size on UGzRadialMenuButton");
static_assert(offsetof(UGzRadialMenuButton, ButtonStateBrushes) == 0x0002E0, "Member 'UGzRadialMenuButton::ButtonStateBrushes' has a wrong offset!");

// Class G01.GzRailTransport
// 0x0018 (0x03C8 - 0x03B0)
class AGzRailTransport final : public AGzAutoTrackTransport
{
public:
	TArray<class AGzTrainCar*>                    TrainCars;                                         // 0x03B0(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	uint8                                         Pad_34BA[0x8];                                     // 0x03C0(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void EnableCarsAlignment(const bool bEnable);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzRailTransport">();
	}
	static class AGzRailTransport* GetDefaultObj()
	{
		return GetDefaultObjImpl<AGzRailTransport>();
	}
};
static_assert(alignof(AGzRailTransport) == 0x000008, "Wrong alignment on AGzRailTransport");
static_assert(sizeof(AGzRailTransport) == 0x0003C8, "Wrong size on AGzRailTransport");
static_assert(offsetof(AGzRailTransport, TrainCars) == 0x0003B0, "Member 'AGzRailTransport::TrainCars' has a wrong offset!");

// Class G01.GzRandomStatics
// 0x0000 (0x0028 - 0x0028)
class UGzRandomStatics final : public UBlueprintFunctionLibrary
{
public:
	static void RandomChoice(const TArray<int32>& Weights, int32 Num, TArray<int32>* Result);
	static float RandomFloat(const struct FFloatRange& Range);
	static float RandomInt(const struct FInt32Range& Range);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzRandomStatics">();
	}
	static class UGzRandomStatics* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzRandomStatics>();
	}
};
static_assert(alignof(UGzRandomStatics) == 0x000008, "Wrong alignment on UGzRandomStatics");
static_assert(sizeof(UGzRandomStatics) == 0x000028, "Wrong size on UGzRandomStatics");

// Class G01.GzRarityRandomizationInterface
// 0x0000 (0x0028 - 0x0028)
class IGzRarityRandomizationInterface final : public IInterface
{
public:
	void OnRarityRandomized(const struct FGameplayTag& RarityRandomizationTag);

	struct FGameplayTagContainer GetAvailableRarityPresets(const struct FGameplayTagContainer& RarityPresets) const;
	struct FGameplayTag GetRarityRandomizationGroup() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzRarityRandomizationInterface">();
	}
	static class IGzRarityRandomizationInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IGzRarityRandomizationInterface>();
	}
};
static_assert(alignof(IGzRarityRandomizationInterface) == 0x000008, "Wrong alignment on IGzRarityRandomizationInterface");
static_assert(sizeof(IGzRarityRandomizationInterface) == 0x000028, "Wrong size on IGzRarityRandomizationInterface");

// Class G01.GzRarityRandomizationSubsystem
// 0x0000 (0x0030 - 0x0030)
class UGzRarityRandomizationSubsystem final : public UWorldSubsystem
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzRarityRandomizationSubsystem">();
	}
	static class UGzRarityRandomizationSubsystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzRarityRandomizationSubsystem>();
	}
};
static_assert(alignof(UGzRarityRandomizationSubsystem) == 0x000008, "Wrong alignment on UGzRarityRandomizationSubsystem");
static_assert(sizeof(UGzRarityRandomizationSubsystem) == 0x000030, "Wrong size on UGzRarityRandomizationSubsystem");

// Class G01.GzReconCircleAreaMarkerWidget
// 0x0030 (0x0410 - 0x03E0)
class UGzReconCircleAreaMarkerWidget final : public UGzCircleAreaMarkerWidget
{
public:
	class AGzReconDrone*                          OwningReconDrone;                                  // 0x03E0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, EditConst, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   RadarAngleParameterName;                           // 0x03E8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   IconSizeParameterName;                             // 0x03F0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ScaleToWorldUnits;                                 // 0x03F8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ScanRadiusScale;                                   // 0x03FC(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         DefaultIconSize;                                   // 0x0400(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_34BC[0xC];                                     // 0x0404(0x000C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzReconCircleAreaMarkerWidget">();
	}
	static class UGzReconCircleAreaMarkerWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzReconCircleAreaMarkerWidget>();
	}
};
static_assert(alignof(UGzReconCircleAreaMarkerWidget) == 0x000008, "Wrong alignment on UGzReconCircleAreaMarkerWidget");
static_assert(sizeof(UGzReconCircleAreaMarkerWidget) == 0x000410, "Wrong size on UGzReconCircleAreaMarkerWidget");
static_assert(offsetof(UGzReconCircleAreaMarkerWidget, OwningReconDrone) == 0x0003E0, "Member 'UGzReconCircleAreaMarkerWidget::OwningReconDrone' has a wrong offset!");
static_assert(offsetof(UGzReconCircleAreaMarkerWidget, RadarAngleParameterName) == 0x0003E8, "Member 'UGzReconCircleAreaMarkerWidget::RadarAngleParameterName' has a wrong offset!");
static_assert(offsetof(UGzReconCircleAreaMarkerWidget, IconSizeParameterName) == 0x0003F0, "Member 'UGzReconCircleAreaMarkerWidget::IconSizeParameterName' has a wrong offset!");
static_assert(offsetof(UGzReconCircleAreaMarkerWidget, ScaleToWorldUnits) == 0x0003F8, "Member 'UGzReconCircleAreaMarkerWidget::ScaleToWorldUnits' has a wrong offset!");
static_assert(offsetof(UGzReconCircleAreaMarkerWidget, ScanRadiusScale) == 0x0003FC, "Member 'UGzReconCircleAreaMarkerWidget::ScanRadiusScale' has a wrong offset!");
static_assert(offsetof(UGzReconCircleAreaMarkerWidget, DefaultIconSize) == 0x000400, "Member 'UGzReconCircleAreaMarkerWidget::DefaultIconSize' has a wrong offset!");

// Class G01.GzReconDrone
// 0x0180 (0x0480 - 0x0300)
class AGzReconDrone : public AGzDamageableActor
{
public:
	uint8                                         Pad_34BD[0x8];                                     // 0x0300(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	FMulticastInlineDelegateProperty_             OnRevealedActors;                                  // 0x0308(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	EGzReconDestroyReason                         DestroyReason;                                     // 0x0318(0x0001)(BlueprintVisible, Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_34BE[0x7];                                     // 0x0319(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftClassPtr<class UClass>                   DroneMarkerClass;                                  // 0x0320(0x0028)(Edit, DisableEditOnInstance, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftClassPtr<class UClass>                   EnemyMarkerClass;                                  // 0x0348(0x0028)(Edit, DisableEditOnInstance, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         MarkerId;                                          // 0x0370(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         EndTime;                                           // 0x0374(0x0004)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FGzReconDrone_Gadjet_InitInfo          InitInfo;                                          // 0x0378(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, Net, NoDestructor, Protected, ExposeOnSpawn, NativeAccessSpecifierProtected)
	uint8                                         Pad_34BF[0x4];                                     // 0x0384(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UGameplayEffect>            VisionBuffEffectClass;                             // 0x0388(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSubclassOf<class UGameplayEffect>            RevealEffectClass;                                 // 0x0390(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSubclassOf<class UGameplayEffect>            MaxHPEffect;                                       // 0x0398(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FGameplayTag                           MaxHPTag;                                          // 0x03A0(0x0008)(Edit, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FGameplayTag                           ReconTag;                                          // 0x03A8(0x0008)(Edit, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FGameplayTag                           ReconBuffTag;                                      // 0x03B0(0x0008)(Edit, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FGameplayTagContainer                  TagsThatBlockRecon;                                // 0x03B8(0x0020)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	float                                         TimerInterval;                                     // 0x03D8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_34C0[0x4];                                     // 0x03DC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class AActor*>                         ReconAffectedActors;                               // 0x03E0(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	TMap<class AActor*, struct FGzReconDrone_RevealInfo> ReconAffectedActorsInfo;                           // 0x03F0(0x0050)(Transient, NativeAccessSpecifierPrivate)
	float                                         TimeToRemoveVision;                                // 0x0440(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_34C1[0x3C];                                    // 0x0444(0x003C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AddAffectedActor(class AActor* Actor);
	void DestroyWithReason(EGzReconDestroyReason Reason);
	void DisableVisionForFriends();
	void HandleDestroyReason();
	void Init();
	void OnRep_DestroyReason();
	void RemoveAffectedActor(class AActor* Actor);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzReconDrone">();
	}
	static class AGzReconDrone* GetDefaultObj()
	{
		return GetDefaultObjImpl<AGzReconDrone>();
	}
};
static_assert(alignof(AGzReconDrone) == 0x000008, "Wrong alignment on AGzReconDrone");
static_assert(sizeof(AGzReconDrone) == 0x000480, "Wrong size on AGzReconDrone");
static_assert(offsetof(AGzReconDrone, OnRevealedActors) == 0x000308, "Member 'AGzReconDrone::OnRevealedActors' has a wrong offset!");
static_assert(offsetof(AGzReconDrone, DestroyReason) == 0x000318, "Member 'AGzReconDrone::DestroyReason' has a wrong offset!");
static_assert(offsetof(AGzReconDrone, DroneMarkerClass) == 0x000320, "Member 'AGzReconDrone::DroneMarkerClass' has a wrong offset!");
static_assert(offsetof(AGzReconDrone, EnemyMarkerClass) == 0x000348, "Member 'AGzReconDrone::EnemyMarkerClass' has a wrong offset!");
static_assert(offsetof(AGzReconDrone, MarkerId) == 0x000370, "Member 'AGzReconDrone::MarkerId' has a wrong offset!");
static_assert(offsetof(AGzReconDrone, EndTime) == 0x000374, "Member 'AGzReconDrone::EndTime' has a wrong offset!");
static_assert(offsetof(AGzReconDrone, InitInfo) == 0x000378, "Member 'AGzReconDrone::InitInfo' has a wrong offset!");
static_assert(offsetof(AGzReconDrone, VisionBuffEffectClass) == 0x000388, "Member 'AGzReconDrone::VisionBuffEffectClass' has a wrong offset!");
static_assert(offsetof(AGzReconDrone, RevealEffectClass) == 0x000390, "Member 'AGzReconDrone::RevealEffectClass' has a wrong offset!");
static_assert(offsetof(AGzReconDrone, MaxHPEffect) == 0x000398, "Member 'AGzReconDrone::MaxHPEffect' has a wrong offset!");
static_assert(offsetof(AGzReconDrone, MaxHPTag) == 0x0003A0, "Member 'AGzReconDrone::MaxHPTag' has a wrong offset!");
static_assert(offsetof(AGzReconDrone, ReconTag) == 0x0003A8, "Member 'AGzReconDrone::ReconTag' has a wrong offset!");
static_assert(offsetof(AGzReconDrone, ReconBuffTag) == 0x0003B0, "Member 'AGzReconDrone::ReconBuffTag' has a wrong offset!");
static_assert(offsetof(AGzReconDrone, TagsThatBlockRecon) == 0x0003B8, "Member 'AGzReconDrone::TagsThatBlockRecon' has a wrong offset!");
static_assert(offsetof(AGzReconDrone, TimerInterval) == 0x0003D8, "Member 'AGzReconDrone::TimerInterval' has a wrong offset!");
static_assert(offsetof(AGzReconDrone, ReconAffectedActors) == 0x0003E0, "Member 'AGzReconDrone::ReconAffectedActors' has a wrong offset!");
static_assert(offsetof(AGzReconDrone, ReconAffectedActorsInfo) == 0x0003F0, "Member 'AGzReconDrone::ReconAffectedActorsInfo' has a wrong offset!");
static_assert(offsetof(AGzReconDrone, TimeToRemoveVision) == 0x000440, "Member 'AGzReconDrone::TimeToRemoveVision' has a wrong offset!");

// Class G01.GzRedeploymentContainer
// 0x0030 (0x0370 - 0x0340)
class UGzRedeploymentContainer : public UGzHUDComponent
{
public:
	TSoftClassPtr<class UClass>                   RedeploymentEffect;                                // 0x0340(0x0028)(Edit, DisableEditOnInstance, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_34C2[0x8];                                     // 0x0368(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void CreateRedeploymentWidget();
	void NotifyOnTagAdded(const struct FGameplayTag& NewTag, const struct FGameplayTagContainer& CurrentTags);
	void NotifyOnTagRemoved(const struct FGameplayTag& RemovedTag, const struct FGameplayTagContainer& CurrentTags);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzRedeploymentContainer">();
	}
	static class UGzRedeploymentContainer* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzRedeploymentContainer>();
	}
};
static_assert(alignof(UGzRedeploymentContainer) == 0x000008, "Wrong alignment on UGzRedeploymentContainer");
static_assert(sizeof(UGzRedeploymentContainer) == 0x000370, "Wrong size on UGzRedeploymentContainer");
static_assert(offsetof(UGzRedeploymentContainer, RedeploymentEffect) == 0x000340, "Member 'UGzRedeploymentContainer::RedeploymentEffect' has a wrong offset!");

// Class G01.GzRedeploymentTerminal
// 0x00C8 (0x03C0 - 0x02F8)
class AGzRedeploymentTerminal : public AGzBaseTerminal
{
public:
	bool                                          bOverrideSpawnRules;                               // 0x02F8(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_34C3[0x7];                                     // 0x02F9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TSet<class AGzPlayerState*>                   RedeployableTeammates;                             // 0x0300(0x0050)(Transient, NativeAccessSpecifierPrivate)
	class AGzTeam*                                CachedTeam;                                        // 0x0350(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class AGzBaseCharacter*                       CachedViewTarget;                                  // 0x0358(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_34C4[0x10];                                    // 0x0360(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<class AGzPlayerController*, int32>       RedeployCallers;                                   // 0x0370(0x0050)(NativeAccessSpecifierPrivate)

public:
	struct FTransform GetRedeploymentTransformOverride();
	void OnAvailabilityChanged(bool bNewAvailable);
	void OnPlayerStateReplicated(class AGzPlayerState* PlayerState);
	void OnPlayersTeamChanged(class AGzPlayerState* PlayerState);
	void OnTeamChanged();
	void OnTeammateStateChanged(class AGzPlayerState* Teammate);
	void OnViewTargetChanged(class APawn* NewViewTarget);
	void OnZoneStageChanged(const int32 StageIndex);
	void RedeployPlayers(class AGzPlayerController* Caller, const TArray<class AGzPlayerState*>& PlayerStates);

	int32 GetRedeploymentCost(const class AGzPlayerState* PlayerState) const;
	int32 GetTotalRedeploymentCost(const TArray<class AGzPlayerState*>& PlayerStates) const;
	bool IsAvailable() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzRedeploymentTerminal">();
	}
	static class AGzRedeploymentTerminal* GetDefaultObj()
	{
		return GetDefaultObjImpl<AGzRedeploymentTerminal>();
	}
};
static_assert(alignof(AGzRedeploymentTerminal) == 0x000008, "Wrong alignment on AGzRedeploymentTerminal");
static_assert(sizeof(AGzRedeploymentTerminal) == 0x0003C0, "Wrong size on AGzRedeploymentTerminal");
static_assert(offsetof(AGzRedeploymentTerminal, bOverrideSpawnRules) == 0x0002F8, "Member 'AGzRedeploymentTerminal::bOverrideSpawnRules' has a wrong offset!");
static_assert(offsetof(AGzRedeploymentTerminal, RedeployableTeammates) == 0x000300, "Member 'AGzRedeploymentTerminal::RedeployableTeammates' has a wrong offset!");
static_assert(offsetof(AGzRedeploymentTerminal, CachedTeam) == 0x000350, "Member 'AGzRedeploymentTerminal::CachedTeam' has a wrong offset!");
static_assert(offsetof(AGzRedeploymentTerminal, CachedViewTarget) == 0x000358, "Member 'AGzRedeploymentTerminal::CachedViewTarget' has a wrong offset!");
static_assert(offsetof(AGzRedeploymentTerminal, RedeployCallers) == 0x000370, "Member 'AGzRedeploymentTerminal::RedeployCallers' has a wrong offset!");

// Class G01.GzReplicationGraph
// 0x0100 (0x0670 - 0x0570)
class UGzReplicationGraph final : public UReplicationGraph
{
public:
	class UReplicationGraphNode_GridSpatialization2D* GridNode;                                          // 0x0570(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UReplicationGraphNode_ActorList*        AlwaysRelevantNode;                                // 0x0578(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_34C7[0x50];                                    // 0x0580(0x0050)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UClass*>                         NonSpatializedChildClasses;                        // 0x05D0(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_34C8[0x90];                                    // 0x05E0(0x0090)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzReplicationGraph">();
	}
	static class UGzReplicationGraph* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzReplicationGraph>();
	}
};
static_assert(alignof(UGzReplicationGraph) == 0x000010, "Wrong alignment on UGzReplicationGraph");
static_assert(sizeof(UGzReplicationGraph) == 0x000670, "Wrong size on UGzReplicationGraph");
static_assert(offsetof(UGzReplicationGraph, GridNode) == 0x000570, "Member 'UGzReplicationGraph::GridNode' has a wrong offset!");
static_assert(offsetof(UGzReplicationGraph, AlwaysRelevantNode) == 0x000578, "Member 'UGzReplicationGraph::AlwaysRelevantNode' has a wrong offset!");
static_assert(offsetof(UGzReplicationGraph, NonSpatializedChildClasses) == 0x0005D0, "Member 'UGzReplicationGraph::NonSpatializedChildClasses' has a wrong offset!");

// Class G01.GzReplicationGraphNode_ActorFrequencyLimiter
// 0x0030 (0x0080 - 0x0050)
class UGzReplicationGraphNode_ActorFrequencyLimiter final : public UReplicationGraphNode
{
public:
	class UClass*                                 ActorClass;                                        // 0x0050(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         TargetActorsPerFrame;                              // 0x0058(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_34C9[0x24];                                    // 0x005C(0x0024)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzReplicationGraphNode_ActorFrequencyLimiter">();
	}
	static class UGzReplicationGraphNode_ActorFrequencyLimiter* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzReplicationGraphNode_ActorFrequencyLimiter>();
	}
};
static_assert(alignof(UGzReplicationGraphNode_ActorFrequencyLimiter) == 0x000008, "Wrong alignment on UGzReplicationGraphNode_ActorFrequencyLimiter");
static_assert(sizeof(UGzReplicationGraphNode_ActorFrequencyLimiter) == 0x000080, "Wrong size on UGzReplicationGraphNode_ActorFrequencyLimiter");
static_assert(offsetof(UGzReplicationGraphNode_ActorFrequencyLimiter, ActorClass) == 0x000050, "Member 'UGzReplicationGraphNode_ActorFrequencyLimiter::ActorClass' has a wrong offset!");
static_assert(offsetof(UGzReplicationGraphNode_ActorFrequencyLimiter, TargetActorsPerFrame) == 0x000058, "Member 'UGzReplicationGraphNode_ActorFrequencyLimiter::TargetActorsPerFrame' has a wrong offset!");

// Class G01.GzRewardDataModel
// 0x0050 (0x00C0 - 0x0070)
class UGzRewardDataModel final : public UGzBackendModel
{
public:
	uint8                                         Pad_34CA[0x50];                                    // 0x0070(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzRewardDataModel">();
	}
	static class UGzRewardDataModel* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzRewardDataModel>();
	}
};
static_assert(alignof(UGzRewardDataModel) == 0x000008, "Wrong alignment on UGzRewardDataModel");
static_assert(sizeof(UGzRewardDataModel) == 0x0000C0, "Wrong size on UGzRewardDataModel");

// Class G01.GzRichPresencePrimitiveTypeHandlerComponent
// 0x0000 (0x00B0 - 0x00B0)
class UGzRichPresencePrimitiveTypeHandlerComponent final : public UGzRichPresenceTypeHandlerComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzRichPresencePrimitiveTypeHandlerComponent">();
	}
	static class UGzRichPresencePrimitiveTypeHandlerComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzRichPresencePrimitiveTypeHandlerComponent>();
	}
};
static_assert(alignof(UGzRichPresencePrimitiveTypeHandlerComponent) == 0x000008, "Wrong alignment on UGzRichPresencePrimitiveTypeHandlerComponent");
static_assert(sizeof(UGzRichPresencePrimitiveTypeHandlerComponent) == 0x0000B0, "Wrong size on UGzRichPresencePrimitiveTypeHandlerComponent");

// Class G01.GzRichTextBlock
// 0x0010 (0x08E0 - 0x08D0)
class UGzRichTextBlock final : public UCommonRichTextBlock
{
public:
	TArray<struct FGzTextChunk>                   TextChunks;                                        // 0x08C8(0x0010)(Edit, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_34CB[0x8];                                     // 0x08D8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzRichTextBlock">();
	}
	static class UGzRichTextBlock* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzRichTextBlock>();
	}
};
static_assert(alignof(UGzRichTextBlock) == 0x000010, "Wrong alignment on UGzRichTextBlock");
static_assert(sizeof(UGzRichTextBlock) == 0x0008E0, "Wrong size on UGzRichTextBlock");
static_assert(offsetof(UGzRichTextBlock, TextChunks) == 0x0008C8, "Member 'UGzRichTextBlock::TextChunks' has a wrong offset!");

// Class G01.GzSafetyDirectionMapDecoration
// 0x0048 (0x0338 - 0x02F0)
class UGzSafetyDirectionMapDecoration final : public UGzMapDecoration
{
public:
	float                                         LineThickness;                                     // 0x02F0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FLinearColor                           LineColor;                                         // 0x02F4(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         UpdateDelay;                                       // 0x0304(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class AGzPlayerController*                    PC;                                                // 0x0308(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_34CC[0x28];                                    // 0x0310(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzSafetyDirectionMapDecoration">();
	}
	static class UGzSafetyDirectionMapDecoration* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzSafetyDirectionMapDecoration>();
	}
};
static_assert(alignof(UGzSafetyDirectionMapDecoration) == 0x000008, "Wrong alignment on UGzSafetyDirectionMapDecoration");
static_assert(sizeof(UGzSafetyDirectionMapDecoration) == 0x000338, "Wrong size on UGzSafetyDirectionMapDecoration");
static_assert(offsetof(UGzSafetyDirectionMapDecoration, LineThickness) == 0x0002F0, "Member 'UGzSafetyDirectionMapDecoration::LineThickness' has a wrong offset!");
static_assert(offsetof(UGzSafetyDirectionMapDecoration, LineColor) == 0x0002F4, "Member 'UGzSafetyDirectionMapDecoration::LineColor' has a wrong offset!");
static_assert(offsetof(UGzSafetyDirectionMapDecoration, UpdateDelay) == 0x000304, "Member 'UGzSafetyDirectionMapDecoration::UpdateDelay' has a wrong offset!");
static_assert(offsetof(UGzSafetyDirectionMapDecoration, PC) == 0x000308, "Member 'UGzSafetyDirectionMapDecoration::PC' has a wrong offset!");

// Class G01.GzSafeZoneDirectionExtension
// 0x0010 (0x0048 - 0x0038)
class UGzSafeZoneDirectionExtension : public UGzMapWidgetExtension
{
public:
	TSubclassOf<class UGzSafetyDirectionMapDecoration> SafeZoneDirectionWidgetClass;                      // 0x0038(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UGzSafetyDirectionMapDecoration*        SafeZoneDirectionDecoration;                       // 0x0040(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzSafeZoneDirectionExtension">();
	}
	static class UGzSafeZoneDirectionExtension* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzSafeZoneDirectionExtension>();
	}
};
static_assert(alignof(UGzSafeZoneDirectionExtension) == 0x000008, "Wrong alignment on UGzSafeZoneDirectionExtension");
static_assert(sizeof(UGzSafeZoneDirectionExtension) == 0x000048, "Wrong size on UGzSafeZoneDirectionExtension");
static_assert(offsetof(UGzSafeZoneDirectionExtension, SafeZoneDirectionWidgetClass) == 0x000038, "Member 'UGzSafeZoneDirectionExtension::SafeZoneDirectionWidgetClass' has a wrong offset!");
static_assert(offsetof(UGzSafeZoneDirectionExtension, SafeZoneDirectionDecoration) == 0x000040, "Member 'UGzSafeZoneDirectionExtension::SafeZoneDirectionDecoration' has a wrong offset!");

// Class G01.GzSaveDataManager
// 0x0068 (0x0098 - 0x0030)
class UGzSaveDataManager final : public UGameInstanceSubsystem
{
public:
	uint8                                         Pad_34CD[0x68];                                    // 0x0030(0x0068)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzSaveDataManager">();
	}
	static class UGzSaveDataManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzSaveDataManager>();
	}
};
static_assert(alignof(UGzSaveDataManager) == 0x000008, "Wrong alignment on UGzSaveDataManager");
static_assert(sizeof(UGzSaveDataManager) == 0x000098, "Wrong size on UGzSaveDataManager");

// Class G01.GzSA_AbilityGameplayCue
// 0x0018 (0x0050 - 0x0038)
class UGzSA_AbilityGameplayCue final : public UGzStateAction
{
public:
	struct FGameplayTag                           GameplayCueTag;                                    // 0x0038(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EGzAbilityGameplayCueActivation               WhenActivate;                                      // 0x0040(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_34CE[0x7];                                     // 0x0041(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UGzGameplayCueEventChooser> Event;                                             // 0x0048(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzSA_AbilityGameplayCue">();
	}
	static class UGzSA_AbilityGameplayCue* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzSA_AbilityGameplayCue>();
	}
};
static_assert(alignof(UGzSA_AbilityGameplayCue) == 0x000008, "Wrong alignment on UGzSA_AbilityGameplayCue");
static_assert(sizeof(UGzSA_AbilityGameplayCue) == 0x000050, "Wrong size on UGzSA_AbilityGameplayCue");
static_assert(offsetof(UGzSA_AbilityGameplayCue, GameplayCueTag) == 0x000038, "Member 'UGzSA_AbilityGameplayCue::GameplayCueTag' has a wrong offset!");
static_assert(offsetof(UGzSA_AbilityGameplayCue, WhenActivate) == 0x000040, "Member 'UGzSA_AbilityGameplayCue::WhenActivate' has a wrong offset!");
static_assert(offsetof(UGzSA_AbilityGameplayCue, Event) == 0x000048, "Member 'UGzSA_AbilityGameplayCue::Event' has a wrong offset!");

// Class G01.GzSA_BlockAbilitiesByTags
// 0x0020 (0x0058 - 0x0038)
class UGzSA_BlockAbilitiesByTags final : public UGzStateAction
{
public:
	struct FGameplayTagContainer                  BlockedTags;                                       // 0x0038(0x0020)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzSA_BlockAbilitiesByTags">();
	}
	static class UGzSA_BlockAbilitiesByTags* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzSA_BlockAbilitiesByTags>();
	}
};
static_assert(alignof(UGzSA_BlockAbilitiesByTags) == 0x000008, "Wrong alignment on UGzSA_BlockAbilitiesByTags");
static_assert(sizeof(UGzSA_BlockAbilitiesByTags) == 0x000058, "Wrong size on UGzSA_BlockAbilitiesByTags");
static_assert(offsetof(UGzSA_BlockAbilitiesByTags, BlockedTags) == 0x000038, "Member 'UGzSA_BlockAbilitiesByTags::BlockedTags' has a wrong offset!");

// Class G01.GzSA_ApplyEffect
// 0x0028 (0x0060 - 0x0038)
class UGzSA_ApplyEffect final : public UGzStateAction
{
public:
	TArray<TSubclassOf<class UGameplayEffect>>    GameplayEffectClasses;                             // 0x0038(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, UObjectWrapper, NativeAccessSpecifierPublic)
	bool                                          bEndAbilityOnEffectRemoved;                        // 0x0048(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_34CF[0x7];                                     // 0x0049(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FActiveGameplayEffectHandle>    AppliedEffectsHandles;                             // 0x0050(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzSA_ApplyEffect">();
	}
	static class UGzSA_ApplyEffect* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzSA_ApplyEffect>();
	}
};
static_assert(alignof(UGzSA_ApplyEffect) == 0x000008, "Wrong alignment on UGzSA_ApplyEffect");
static_assert(sizeof(UGzSA_ApplyEffect) == 0x000060, "Wrong size on UGzSA_ApplyEffect");
static_assert(offsetof(UGzSA_ApplyEffect, GameplayEffectClasses) == 0x000038, "Member 'UGzSA_ApplyEffect::GameplayEffectClasses' has a wrong offset!");
static_assert(offsetof(UGzSA_ApplyEffect, bEndAbilityOnEffectRemoved) == 0x000048, "Member 'UGzSA_ApplyEffect::bEndAbilityOnEffectRemoved' has a wrong offset!");
static_assert(offsetof(UGzSA_ApplyEffect, AppliedEffectsHandles) == 0x000050, "Member 'UGzSA_ApplyEffect::AppliedEffectsHandles' has a wrong offset!");

// Class G01.GzSA_EventOnStart
// 0x0008 (0x0040 - 0x0038)
class UGzSA_EventOnStart final : public UGzStateAction
{
public:
	struct FGameplayTag                           EventTag;                                          // 0x0038(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzSA_EventOnStart">();
	}
	static class UGzSA_EventOnStart* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzSA_EventOnStart>();
	}
};
static_assert(alignof(UGzSA_EventOnStart) == 0x000008, "Wrong alignment on UGzSA_EventOnStart");
static_assert(sizeof(UGzSA_EventOnStart) == 0x000040, "Wrong size on UGzSA_EventOnStart");
static_assert(offsetof(UGzSA_EventOnStart, EventTag) == 0x000038, "Member 'UGzSA_EventOnStart::EventTag' has a wrong offset!");

// Class G01.GzSA_EventOnEnd
// 0x0008 (0x0040 - 0x0038)
class UGzSA_EventOnEnd final : public UGzStateAction
{
public:
	struct FGameplayTag                           EventTag;                                          // 0x0038(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzSA_EventOnEnd">();
	}
	static class UGzSA_EventOnEnd* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzSA_EventOnEnd>();
	}
};
static_assert(alignof(UGzSA_EventOnEnd) == 0x000008, "Wrong alignment on UGzSA_EventOnEnd");
static_assert(sizeof(UGzSA_EventOnEnd) == 0x000040, "Wrong size on UGzSA_EventOnEnd");
static_assert(offsetof(UGzSA_EventOnEnd, EventTag) == 0x000038, "Member 'UGzSA_EventOnEnd::EventTag' has a wrong offset!");

// Class G01.GzSA_ActionOnTag
// 0x0028 (0x0060 - 0x0038)
class UGzSA_ActionOnTag final : public UGzStateAction
{
public:
	struct FGameplayTag                           Tag;                                               // 0x0038(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UGzStateAction*                         Action;                                            // 0x0040(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, PersistentInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EGzActionOnTag                                TypeOfAction;                                      // 0x0048(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_34D0[0x7];                                     // 0x0049(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UAbilityTask_WaitGameplayTagAdded*      WaitTagAdded;                                      // 0x0050(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UAbilityTask_WaitGameplayTagRemoved*    WaitTagRemoved;                                    // 0x0058(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void OnTagAdded();
	void OnTagRemoved();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzSA_ActionOnTag">();
	}
	static class UGzSA_ActionOnTag* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzSA_ActionOnTag>();
	}
};
static_assert(alignof(UGzSA_ActionOnTag) == 0x000008, "Wrong alignment on UGzSA_ActionOnTag");
static_assert(sizeof(UGzSA_ActionOnTag) == 0x000060, "Wrong size on UGzSA_ActionOnTag");
static_assert(offsetof(UGzSA_ActionOnTag, Tag) == 0x000038, "Member 'UGzSA_ActionOnTag::Tag' has a wrong offset!");
static_assert(offsetof(UGzSA_ActionOnTag, Action) == 0x000040, "Member 'UGzSA_ActionOnTag::Action' has a wrong offset!");
static_assert(offsetof(UGzSA_ActionOnTag, TypeOfAction) == 0x000048, "Member 'UGzSA_ActionOnTag::TypeOfAction' has a wrong offset!");
static_assert(offsetof(UGzSA_ActionOnTag, WaitTagAdded) == 0x000050, "Member 'UGzSA_ActionOnTag::WaitTagAdded' has a wrong offset!");
static_assert(offsetof(UGzSA_ActionOnTag, WaitTagRemoved) == 0x000058, "Member 'UGzSA_ActionOnTag::WaitTagRemoved' has a wrong offset!");

// Class G01.GzSA_HolsterWeapon
// 0x0008 (0x0048 - 0x0040)
class UGzSA_HolsterWeapon final : public UGzActivatableStateAction
{
public:
	EGzHolsterType                                Type;                                              // 0x0040(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bPlayAnimation;                                    // 0x0041(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_34D1[0x6];                                     // 0x0042(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzSA_HolsterWeapon">();
	}
	static class UGzSA_HolsterWeapon* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzSA_HolsterWeapon>();
	}
};
static_assert(alignof(UGzSA_HolsterWeapon) == 0x000008, "Wrong alignment on UGzSA_HolsterWeapon");
static_assert(sizeof(UGzSA_HolsterWeapon) == 0x000048, "Wrong size on UGzSA_HolsterWeapon");
static_assert(offsetof(UGzSA_HolsterWeapon, Type) == 0x000040, "Member 'UGzSA_HolsterWeapon::Type' has a wrong offset!");
static_assert(offsetof(UGzSA_HolsterWeapon, bPlayAnimation) == 0x000041, "Member 'UGzSA_HolsterWeapon::bPlayAnimation' has a wrong offset!");

// Class G01.GzSA_SwitchWeaponOtherHand
// 0x0008 (0x0048 - 0x0040)
class UGzSA_SwitchWeaponOtherHand final : public UGzActivatableStateAction
{
public:
	bool                                          bPlayUnholsterAnimation;                           // 0x0040(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_34D2[0x7];                                     // 0x0041(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzSA_SwitchWeaponOtherHand">();
	}
	static class UGzSA_SwitchWeaponOtherHand* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzSA_SwitchWeaponOtherHand>();
	}
};
static_assert(alignof(UGzSA_SwitchWeaponOtherHand) == 0x000008, "Wrong alignment on UGzSA_SwitchWeaponOtherHand");
static_assert(sizeof(UGzSA_SwitchWeaponOtherHand) == 0x000048, "Wrong size on UGzSA_SwitchWeaponOtherHand");
static_assert(offsetof(UGzSA_SwitchWeaponOtherHand, bPlayUnholsterAnimation) == 0x000040, "Member 'UGzSA_SwitchWeaponOtherHand::bPlayUnholsterAnimation' has a wrong offset!");

// Class G01.GzSceneCaptureComponent2D
// 0x0000 (0x0B20 - 0x0B20)
class UGzSceneCaptureComponent2D final : public USceneCaptureComponent2D
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzSceneCaptureComponent2D">();
	}
	static class UGzSceneCaptureComponent2D* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzSceneCaptureComponent2D>();
	}
};
static_assert(alignof(UGzSceneCaptureComponent2D) == 0x000010, "Wrong alignment on UGzSceneCaptureComponent2D");
static_assert(sizeof(UGzSceneCaptureComponent2D) == 0x000B20, "Wrong size on UGzSceneCaptureComponent2D");

// Class G01.GzSceneSpawnpoint
// 0x0028 (0x02C8 - 0x02A0)
class AGzSceneSpawnpoint final : public AActor
{
public:
	EGzSceneSpawnpointType                        Type;                                              // 0x02A0(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_34D3[0x7];                                     // 0x02A1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UStaticMeshComponent*                   StaticMeshComponent;                               // 0x02A8(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnTemplate, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USkeletalMeshComponent*                 SkeletalMeshComponent;                             // 0x02B0(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnTemplate, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class AGzSceneSpawnpoint*>             Mirrors;                                           // 0x02B8(0x0010)(Edit, ZeroConstructor, DisableEditOnTemplate, UObjectWrapper, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzSceneSpawnpoint">();
	}
	static class AGzSceneSpawnpoint* GetDefaultObj()
	{
		return GetDefaultObjImpl<AGzSceneSpawnpoint>();
	}
};
static_assert(alignof(AGzSceneSpawnpoint) == 0x000008, "Wrong alignment on AGzSceneSpawnpoint");
static_assert(sizeof(AGzSceneSpawnpoint) == 0x0002C8, "Wrong size on AGzSceneSpawnpoint");
static_assert(offsetof(AGzSceneSpawnpoint, Type) == 0x0002A0, "Member 'AGzSceneSpawnpoint::Type' has a wrong offset!");
static_assert(offsetof(AGzSceneSpawnpoint, StaticMeshComponent) == 0x0002A8, "Member 'AGzSceneSpawnpoint::StaticMeshComponent' has a wrong offset!");
static_assert(offsetof(AGzSceneSpawnpoint, SkeletalMeshComponent) == 0x0002B0, "Member 'AGzSceneSpawnpoint::SkeletalMeshComponent' has a wrong offset!");
static_assert(offsetof(AGzSceneSpawnpoint, Mirrors) == 0x0002B8, "Member 'AGzSceneSpawnpoint::Mirrors' has a wrong offset!");

// Class G01.GzScoreboardEntry
// 0x0028 (0x0330 - 0x0308)
class UGzScoreboardEntry : public UCommonUserWidget
{
public:
	class UHorizontalBox*                         Container;                                         // 0x0308(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCommonTextBlock*                       PlayerNameText;                                    // 0x0310(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UGzScoreValueWidget>        ValueWidgetClass;                                  // 0x0318(0x0008)(Edit, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FMargin                                StatPadding;                                       // 0x0320(0x0010)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzScoreboardEntry">();
	}
	static class UGzScoreboardEntry* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzScoreboardEntry>();
	}
};
static_assert(alignof(UGzScoreboardEntry) == 0x000008, "Wrong alignment on UGzScoreboardEntry");
static_assert(sizeof(UGzScoreboardEntry) == 0x000330, "Wrong size on UGzScoreboardEntry");
static_assert(offsetof(UGzScoreboardEntry, Container) == 0x000308, "Member 'UGzScoreboardEntry::Container' has a wrong offset!");
static_assert(offsetof(UGzScoreboardEntry, PlayerNameText) == 0x000310, "Member 'UGzScoreboardEntry::PlayerNameText' has a wrong offset!");
static_assert(offsetof(UGzScoreboardEntry, ValueWidgetClass) == 0x000318, "Member 'UGzScoreboardEntry::ValueWidgetClass' has a wrong offset!");
static_assert(offsetof(UGzScoreboardEntry, StatPadding) == 0x000320, "Member 'UGzScoreboardEntry::StatPadding' has a wrong offset!");

// Class G01.GzSearchZonesComponent
// 0x0178 (0x0220 - 0x00A8)
class UGzSearchZonesComponent final : public UControllerComponent
{
public:
	struct FGzSearchZoneArray                     SearchZones;                                       // 0x00A8(0x0168)(Net, Protected, NativeAccessSpecifierProtected)
	TArray<class AGzSearchZone*>                  SearchZonesActors;                                 // 0x0210(0x0010)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzSearchZonesComponent">();
	}
	static class UGzSearchZonesComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzSearchZonesComponent>();
	}
};
static_assert(alignof(UGzSearchZonesComponent) == 0x000008, "Wrong alignment on UGzSearchZonesComponent");
static_assert(sizeof(UGzSearchZonesComponent) == 0x000220, "Wrong size on UGzSearchZonesComponent");
static_assert(offsetof(UGzSearchZonesComponent, SearchZones) == 0x0000A8, "Member 'UGzSearchZonesComponent::SearchZones' has a wrong offset!");
static_assert(offsetof(UGzSearchZonesComponent, SearchZonesActors) == 0x000210, "Member 'UGzSearchZonesComponent::SearchZonesActors' has a wrong offset!");

// Class G01.GzSearchZonesSubsystem
// 0x00A8 (0x00D8 - 0x0030)
class UGzSearchZonesSubsystem final : public UWorldSubsystem
{
public:
	TMap<int32, struct FGzSearchZoneServerRuntimeInfo> RegisteredSearchZones;                             // 0x0030(0x0050)(Transient, Protected, NativeAccessSpecifierProtected)
	TMap<int32, class UGzSearchZonesComponent*>   SearchZoneComponents;                              // 0x0080(0x0050)(ExportObject, Transient, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_34D4[0x8];                                     // 0x00D0(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AssignZoneToPlayer(int32 PlayerId, int32 ZoneId);
	void AssignZoneToTeam(class AGzTeam* Team, int32 ZoneId);
	int32 CreateZone(const struct FGzSearchZoneSpec& InSpec, class AActor* TargetActor);
	void RemoveZone(int32 ZoneId);
	void UnassignZoneFromPlayer(int32 PlayerId, int32 ZoneId);
	void UnassignZoneFromTeam(class AGzTeam* Team, int32 ZoneId);

	bool HasWatcher(int32 ZoneId, int32 PlayerId) const;
	bool HasZone(int32 ZoneId) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzSearchZonesSubsystem">();
	}
	static class UGzSearchZonesSubsystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzSearchZonesSubsystem>();
	}
};
static_assert(alignof(UGzSearchZonesSubsystem) == 0x000008, "Wrong alignment on UGzSearchZonesSubsystem");
static_assert(sizeof(UGzSearchZonesSubsystem) == 0x0000D8, "Wrong size on UGzSearchZonesSubsystem");
static_assert(offsetof(UGzSearchZonesSubsystem, RegisteredSearchZones) == 0x000030, "Member 'UGzSearchZonesSubsystem::RegisteredSearchZones' has a wrong offset!");
static_assert(offsetof(UGzSearchZonesSubsystem, SearchZoneComponents) == 0x000080, "Member 'UGzSearchZonesSubsystem::SearchZoneComponents' has a wrong offset!");

// Class G01.GzSectorAreaDecoration
// 0x0030 (0x0320 - 0x02F0)
class UGzSectorAreaDecoration : public UGzMapDecoration
{
public:
	class UMaterialInterface*                     SectorMaterial;                                    // 0x02F0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UMaterialInstanceDynamic*               SectorMaterialInstance;                            // 0x02F8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 SectorImage;                                       // 0x0300(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_34DA[0x18];                                    // 0x0308(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzSectorAreaDecoration">();
	}
	static class UGzSectorAreaDecoration* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzSectorAreaDecoration>();
	}
};
static_assert(alignof(UGzSectorAreaDecoration) == 0x000008, "Wrong alignment on UGzSectorAreaDecoration");
static_assert(sizeof(UGzSectorAreaDecoration) == 0x000320, "Wrong size on UGzSectorAreaDecoration");
static_assert(offsetof(UGzSectorAreaDecoration, SectorMaterial) == 0x0002F0, "Member 'UGzSectorAreaDecoration::SectorMaterial' has a wrong offset!");
static_assert(offsetof(UGzSectorAreaDecoration, SectorMaterialInstance) == 0x0002F8, "Member 'UGzSectorAreaDecoration::SectorMaterialInstance' has a wrong offset!");
static_assert(offsetof(UGzSectorAreaDecoration, SectorImage) == 0x000300, "Member 'UGzSectorAreaDecoration::SectorImage' has a wrong offset!");

// Class G01.GzSensitivityManager
// 0x0038 (0x0060 - 0x0028)
class UGzSensitivityManager final : public UObject
{
public:
	uint8                                         Pad_34DB[0x10];                                    // 0x0028(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class UCommonInputSubsystem*                  CommonInputSubsystem;                              // 0x0038(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_34DC[0x20];                                    // 0x0040(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzSensitivityManager">();
	}
	static class UGzSensitivityManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzSensitivityManager>();
	}
};
static_assert(alignof(UGzSensitivityManager) == 0x000008, "Wrong alignment on UGzSensitivityManager");
static_assert(sizeof(UGzSensitivityManager) == 0x000060, "Wrong size on UGzSensitivityManager");
static_assert(offsetof(UGzSensitivityManager, CommonInputSubsystem) == 0x000038, "Member 'UGzSensitivityManager::CommonInputSubsystem' has a wrong offset!");

// Class G01.GzServerAuthenticationService
// 0x0000 (0x00A0 - 0x00A0)
class UGzServerAuthenticationService final : public UGzPlayFabObject
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzServerAuthenticationService">();
	}
	static class UGzServerAuthenticationService* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzServerAuthenticationService>();
	}
};
static_assert(alignof(UGzServerAuthenticationService) == 0x000008, "Wrong alignment on UGzServerAuthenticationService");
static_assert(sizeof(UGzServerAuthenticationService) == 0x0000A0, "Wrong size on UGzServerAuthenticationService");

// Class G01.GzServerBeaconService
// 0x0008 (0x00A8 - 0x00A0)
class UGzServerBeaconService final : public UGzPlayFabObject
{
public:
	class AOnlineBeaconHost*                      BeaconHost;                                        // 0x00A0(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzServerBeaconService">();
	}
	static class UGzServerBeaconService* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzServerBeaconService>();
	}
};
static_assert(alignof(UGzServerBeaconService) == 0x000008, "Wrong alignment on UGzServerBeaconService");
static_assert(sizeof(UGzServerBeaconService) == 0x0000A8, "Wrong size on UGzServerBeaconService");
static_assert(offsetof(UGzServerBeaconService, BeaconHost) == 0x0000A0, "Member 'UGzServerBeaconService::BeaconHost' has a wrong offset!");

// Class G01.GzServerDetailsService
// 0x00E8 (0x0188 - 0x00A0)
class UGzServerDetailsService final : public UGzPlayFabObject
{
public:
	uint8                                         Pad_34DD[0xE0];                                    // 0x00A0(0x00E0)(Fixing Size After Last Property [ Dumper-7 ])
	class UGzIPReaderHelper*                      IPReader;                                          // 0x0180(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzServerDetailsService">();
	}
	static class UGzServerDetailsService* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzServerDetailsService>();
	}
};
static_assert(alignof(UGzServerDetailsService) == 0x000008, "Wrong alignment on UGzServerDetailsService");
static_assert(sizeof(UGzServerDetailsService) == 0x000188, "Wrong size on UGzServerDetailsService");
static_assert(offsetof(UGzServerDetailsService, IPReader) == 0x000180, "Member 'UGzServerDetailsService::IPReader' has a wrong offset!");

// Class G01.GzServerVoiceChatService
// 0x0000 (0x00A0 - 0x00A0)
class UGzServerVoiceChatService : public UGzPlayFabObject
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzServerVoiceChatService">();
	}
	static class UGzServerVoiceChatService* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzServerVoiceChatService>();
	}
};
static_assert(alignof(UGzServerVoiceChatService) == 0x000008, "Wrong alignment on UGzServerVoiceChatService");
static_assert(sizeof(UGzServerVoiceChatService) == 0x0000A0, "Wrong size on UGzServerVoiceChatService");

// Class G01.GzServerEpicVoiceChatService
// 0x0000 (0x00A0 - 0x00A0)
class UGzServerEpicVoiceChatService final : public UGzServerVoiceChatService
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzServerEpicVoiceChatService">();
	}
	static class UGzServerEpicVoiceChatService* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzServerEpicVoiceChatService>();
	}
};
static_assert(alignof(UGzServerEpicVoiceChatService) == 0x000008, "Wrong alignment on UGzServerEpicVoiceChatService");
static_assert(sizeof(UGzServerEpicVoiceChatService) == 0x0000A0, "Wrong size on UGzServerEpicVoiceChatService");

// Class G01.GzServerMarkerSubsystem
// 0x00A8 (0x00D8 - 0x0030)
class UGzServerMarkerSubsystem final : public UWorldSubsystem
{
public:
	TMap<int32, struct FGzServerMarkerRuntimeInfo> Markers;                                           // 0x0030(0x0050)(Transient, NativeAccessSpecifierPrivate)
	TMap<int32, class UGzPlayerMarkersHolderComponent*> RegisteredHolderComponents;                        // 0x0080(0x0050)(ExportObject, Transient, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	uint8                                         Pad_34DE[0x8];                                     // 0x00D0(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AssignMarkerToPlayer(int32 MarkerId, class AGzPlayerState* PS);
	void AssignMarkerToPlayerId(int32 MarkerId, int32 PlayerId);
	void AssignMarkerToTeam(int32 MarkerId, class AGzTeam* Team);
	void AssignMarkerToTeamId(int32 MarkerId, int32 TeamID);
	int32 CreateMarkerAtLocation(const struct FGzServerMarkerBuildDataLocation& BuildData);
	int32 CreateMarkerForActor(const struct FGzServerMarkerBuildDataActor& BuildData);
	void DestroyMarker(int32 MarkerId);
	bool UnassignMarkerFromPlayer(int32 MarkerId, class AGzPlayerState* PS);
	bool UnassignMarkerFromPlayerId(int32 MarkerId, int32 PlayerId);
	bool UnassignMarkerFromTeam(int32 MarkerId, class AGzTeam* Team);
	bool UnassignMarkerFromTeamId(int32 MarkerId, int32 TeamID);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzServerMarkerSubsystem">();
	}
	static class UGzServerMarkerSubsystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzServerMarkerSubsystem>();
	}
};
static_assert(alignof(UGzServerMarkerSubsystem) == 0x000008, "Wrong alignment on UGzServerMarkerSubsystem");
static_assert(sizeof(UGzServerMarkerSubsystem) == 0x0000D8, "Wrong size on UGzServerMarkerSubsystem");
static_assert(offsetof(UGzServerMarkerSubsystem, Markers) == 0x000030, "Member 'UGzServerMarkerSubsystem::Markers' has a wrong offset!");
static_assert(offsetof(UGzServerMarkerSubsystem, RegisteredHolderComponents) == 0x000080, "Member 'UGzServerMarkerSubsystem::RegisteredHolderComponents' has a wrong offset!");

// Class G01.GzServerRegistrationService
// 0x0018 (0x00B8 - 0x00A0)
class UGzServerRegistrationService final : public UGzPlayFabObject
{
public:
	uint8                                         Pad_34E9[0x18];                                    // 0x00A0(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzServerRegistrationService">();
	}
	static class UGzServerRegistrationService* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzServerRegistrationService>();
	}
};
static_assert(alignof(UGzServerRegistrationService) == 0x000008, "Wrong alignment on UGzServerRegistrationService");
static_assert(sizeof(UGzServerRegistrationService) == 0x0000B8, "Wrong size on UGzServerRegistrationService");

// Class G01.GzSessionClientStatsCollectingComponent
// 0x0060 (0x0100 - 0x00A0)
class UGzSessionClientStatsCollectingComponent final : public UGzServiceComponent
{
public:
	TMap<EGzClientTelemetryMetricsType, class UGzClientTelemetryStatCollector*> Collectors;                                        // 0x00A0(0x0050)(NativeAccessSpecifierPrivate)
	uint8                                         Pad_34EA[0x10];                                    // 0x00F0(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzSessionClientStatsCollectingComponent">();
	}
	static class UGzSessionClientStatsCollectingComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzSessionClientStatsCollectingComponent>();
	}
};
static_assert(alignof(UGzSessionClientStatsCollectingComponent) == 0x000008, "Wrong alignment on UGzSessionClientStatsCollectingComponent");
static_assert(sizeof(UGzSessionClientStatsCollectingComponent) == 0x000100, "Wrong size on UGzSessionClientStatsCollectingComponent");
static_assert(offsetof(UGzSessionClientStatsCollectingComponent, Collectors) == 0x0000A0, "Member 'UGzSessionClientStatsCollectingComponent::Collectors' has a wrong offset!");

// Class G01.GzSettingActionRemapping
// 0x00D0 (0x0220 - 0x0150)
class UGzSettingActionRemapping final : public UGameSettingValue
{
public:
	uint8                                         Pad_34EB[0xD0];                                    // 0x0150(0x00D0)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzSettingActionRemapping">();
	}
	static class UGzSettingActionRemapping* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzSettingActionRemapping>();
	}
};
static_assert(alignof(UGzSettingActionRemapping) == 0x000008, "Wrong alignment on UGzSettingActionRemapping");
static_assert(sizeof(UGzSettingActionRemapping) == 0x000220, "Wrong size on UGzSettingActionRemapping");

// Class G01.GzSettingControllerProfileWidget
// 0x0008 (0x0370 - 0x0368)
class UGzSettingControllerProfileWidget : public UGameSettingListEntrySetting_Discrete
{
public:
	class UImage*                                 ProfileImage;                                      // 0x0368(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzSettingControllerProfileWidget">();
	}
	static class UGzSettingControllerProfileWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzSettingControllerProfileWidget>();
	}
};
static_assert(alignof(UGzSettingControllerProfileWidget) == 0x000008, "Wrong alignment on UGzSettingControllerProfileWidget");
static_assert(sizeof(UGzSettingControllerProfileWidget) == 0x000370, "Wrong size on UGzSettingControllerProfileWidget");
static_assert(offsetof(UGzSettingControllerProfileWidget, ProfileImage) == 0x000368, "Member 'UGzSettingControllerProfileWidget::ProfileImage' has a wrong offset!");

// Class G01.GzSettingDiscreteResolution
// 0x0058 (0x01A8 - 0x0150)
class UGzSettingDiscreteResolution final : public UGameSettingValueDiscrete
{
public:
	uint8                                         Pad_34EC[0x58];                                    // 0x0150(0x0058)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzSettingDiscreteResolution">();
	}
	static class UGzSettingDiscreteResolution* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzSettingDiscreteResolution>();
	}
};
static_assert(alignof(UGzSettingDiscreteResolution) == 0x000008, "Wrong alignment on UGzSettingDiscreteResolution");
static_assert(sizeof(UGzSettingDiscreteResolution) == 0x0001A8, "Wrong size on UGzSettingDiscreteResolution");

// Class G01.GzSettingDiscreteResolution_Mac
// 0x0020 (0x0170 - 0x0150)
class UGzSettingDiscreteResolution_Mac final : public UGameSettingValueDiscrete
{
public:
	uint8                                         Pad_34ED[0x20];                                    // 0x0150(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzSettingDiscreteResolution_Mac">();
	}
	static class UGzSettingDiscreteResolution_Mac* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzSettingDiscreteResolution_Mac>();
	}
};
static_assert(alignof(UGzSettingDiscreteResolution_Mac) == 0x000008, "Wrong alignment on UGzSettingDiscreteResolution_Mac");
static_assert(sizeof(UGzSettingDiscreteResolution_Mac) == 0x000170, "Wrong size on UGzSettingDiscreteResolution_Mac");

// Class G01.GzSettingEntryDiscreteWidget
// 0x0018 (0x0340 - 0x0328)
class UGzSettingEntryDiscreteWidget final : public UGzSettingEntryWidget
{
public:
	class UCommonButtonBase*                      ButtonNext;                                        // 0x0328(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UCommonButtonBase*                      ButtonPrev;                                        // 0x0330(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UGameSettingRotator*                    TextRotator;                                       // 0x0338(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzSettingEntryDiscreteWidget">();
	}
	static class UGzSettingEntryDiscreteWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzSettingEntryDiscreteWidget>();
	}
};
static_assert(alignof(UGzSettingEntryDiscreteWidget) == 0x000008, "Wrong alignment on UGzSettingEntryDiscreteWidget");
static_assert(sizeof(UGzSettingEntryDiscreteWidget) == 0x000340, "Wrong size on UGzSettingEntryDiscreteWidget");
static_assert(offsetof(UGzSettingEntryDiscreteWidget, ButtonNext) == 0x000328, "Member 'UGzSettingEntryDiscreteWidget::ButtonNext' has a wrong offset!");
static_assert(offsetof(UGzSettingEntryDiscreteWidget, ButtonPrev) == 0x000330, "Member 'UGzSettingEntryDiscreteWidget::ButtonPrev' has a wrong offset!");
static_assert(offsetof(UGzSettingEntryDiscreteWidget, TextRotator) == 0x000338, "Member 'UGzSettingEntryDiscreteWidget::TextRotator' has a wrong offset!");

// Class G01.GzSettingResolutionScalingMethod
// 0x0010 (0x0160 - 0x0150)
class UGzSettingResolutionScalingMethod final : public UGameSettingValueDiscrete
{
public:
	uint8                                         Pad_34EE[0x10];                                    // 0x0150(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzSettingResolutionScalingMethod">();
	}
	static class UGzSettingResolutionScalingMethod* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzSettingResolutionScalingMethod>();
	}
};
static_assert(alignof(UGzSettingResolutionScalingMethod) == 0x000008, "Wrong alignment on UGzSettingResolutionScalingMethod");
static_assert(sizeof(UGzSettingResolutionScalingMethod) == 0x000160, "Wrong size on UGzSettingResolutionScalingMethod");

// Class G01.GzSettingScalarHDRMidLuminance
// 0x0000 (0x0150 - 0x0150)
class UGzSettingScalarHDRMidLuminance final : public UGameSettingValueScalar
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzSettingScalarHDRMidLuminance">();
	}
	static class UGzSettingScalarHDRMidLuminance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzSettingScalarHDRMidLuminance>();
	}
};
static_assert(alignof(UGzSettingScalarHDRMidLuminance) == 0x000008, "Wrong alignment on UGzSettingScalarHDRMidLuminance");
static_assert(sizeof(UGzSettingScalarHDRMidLuminance) == 0x000150, "Wrong size on UGzSettingScalarHDRMidLuminance");

// Class G01.GzSettingScalarOutputNits
// 0x0000 (0x0150 - 0x0150)
class UGzSettingScalarOutputNits final : public UGameSettingValueScalar
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzSettingScalarOutputNits">();
	}
	static class UGzSettingScalarOutputNits* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzSettingScalarOutputNits>();
	}
};
static_assert(alignof(UGzSettingScalarOutputNits) == 0x000008, "Wrong alignment on UGzSettingScalarOutputNits");
static_assert(sizeof(UGzSettingScalarOutputNits) == 0x000150, "Wrong size on UGzSettingScalarOutputNits");

// Class G01.GzSettingSelectMonitor
// 0x0000 (0x0150 - 0x0150)
class UGzSettingSelectMonitor final : public UGameSettingValueDiscrete
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzSettingSelectMonitor">();
	}
	static class UGzSettingSelectMonitor* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzSettingSelectMonitor>();
	}
};
static_assert(alignof(UGzSettingSelectMonitor) == 0x000008, "Wrong alignment on UGzSettingSelectMonitor");
static_assert(sizeof(UGzSettingSelectMonitor) == 0x000150, "Wrong size on UGzSettingSelectMonitor");

// Class G01.GzSettingsEntryActionRemapping
// 0x0048 (0x0388 - 0x0340)
class UGzSettingsEntryActionRemapping : public UGameSettingListEntry_Setting
{
public:
	class UGzCommonButton*                        ButtonPrimaryKey;                                  // 0x0340(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UGzCommonButton*                        ButtonSecondaryKey;                                // 0x0348(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftClassPtr<class UClass>                   PressAnyKeyPanelClass;                             // 0x0350(0x0028)(Edit, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UGzSettingActionRemapping*              KeyboardInputSetting;                              // 0x0378(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_34EF[0x8];                                     // 0x0380(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void HandlePrimaryKeyRightClicked(class UCommonButtonBase* Button);
	void HandleSecondaryKeyRightClicked(class UCommonButtonBase* Button);
	void OnPressAnyKeyPanelAdded(class UGzNavigationWidget* NavigationWidget);
	void OnSettingChanged_BP();

	bool GetInputBrushFromKeySlot(EPlayerMappableKeySlot KeySlot, struct FSlateBrush* OutBrush) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzSettingsEntryActionRemapping">();
	}
	static class UGzSettingsEntryActionRemapping* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzSettingsEntryActionRemapping>();
	}
};
static_assert(alignof(UGzSettingsEntryActionRemapping) == 0x000008, "Wrong alignment on UGzSettingsEntryActionRemapping");
static_assert(sizeof(UGzSettingsEntryActionRemapping) == 0x000388, "Wrong size on UGzSettingsEntryActionRemapping");
static_assert(offsetof(UGzSettingsEntryActionRemapping, ButtonPrimaryKey) == 0x000340, "Member 'UGzSettingsEntryActionRemapping::ButtonPrimaryKey' has a wrong offset!");
static_assert(offsetof(UGzSettingsEntryActionRemapping, ButtonSecondaryKey) == 0x000348, "Member 'UGzSettingsEntryActionRemapping::ButtonSecondaryKey' has a wrong offset!");
static_assert(offsetof(UGzSettingsEntryActionRemapping, PressAnyKeyPanelClass) == 0x000350, "Member 'UGzSettingsEntryActionRemapping::PressAnyKeyPanelClass' has a wrong offset!");
static_assert(offsetof(UGzSettingsEntryActionRemapping, KeyboardInputSetting) == 0x000378, "Member 'UGzSettingsEntryActionRemapping::KeyboardInputSetting' has a wrong offset!");

// Class G01.GzSettingsModelV2
// 0x0038 (0x00A8 - 0x0070)
class UGzSettingsModelV2 final : public UGzCohtmlDataModel
{
public:
	uint8                                         Pad_34F2[0x38];                                    // 0x0070(0x0038)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzSettingsModelV2">();
	}
	static class UGzSettingsModelV2* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzSettingsModelV2>();
	}
};
static_assert(alignof(UGzSettingsModelV2) == 0x000008, "Wrong alignment on UGzSettingsModelV2");
static_assert(sizeof(UGzSettingsModelV2) == 0x0000A8, "Wrong size on UGzSettingsModelV2");

// Class G01.GzSettingSprintMode
// 0x0018 (0x0168 - 0x0150)
class UGzSettingSprintMode : public UGameSettingValueDiscrete
{
public:
	TArray<class FText>                           OPTIONS;                                           // 0x0150(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	bool                                          DefaultEnableToggleOnConsoles;                     // 0x0160(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          DefaultEnableToggleOnPC;                           // 0x0161(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_34F3[0x6];                                     // 0x0162(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzSettingSprintMode">();
	}
	static class UGzSettingSprintMode* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzSettingSprintMode>();
	}
};
static_assert(alignof(UGzSettingSprintMode) == 0x000008, "Wrong alignment on UGzSettingSprintMode");
static_assert(sizeof(UGzSettingSprintMode) == 0x000168, "Wrong size on UGzSettingSprintMode");
static_assert(offsetof(UGzSettingSprintMode, OPTIONS) == 0x000150, "Member 'UGzSettingSprintMode::OPTIONS' has a wrong offset!");
static_assert(offsetof(UGzSettingSprintMode, DefaultEnableToggleOnConsoles) == 0x000160, "Member 'UGzSettingSprintMode::DefaultEnableToggleOnConsoles' has a wrong offset!");
static_assert(offsetof(UGzSettingSprintMode, DefaultEnableToggleOnPC) == 0x000161, "Member 'UGzSettingSprintMode::DefaultEnableToggleOnPC' has a wrong offset!");

// Class G01.GzSettingVCOutputDevice
// 0x0020 (0x0170 - 0x0150)
class UGzSettingVCOutputDevice : public UGameSettingValueDiscrete
{
public:
	TArray<struct FGzVoiceChatAudioDevice>        OutputDevices;                                     // 0x0150(0x0010)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	class FText                                   NoDevicesText;                                     // 0x0160(0x0010)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzSettingVCOutputDevice">();
	}
	static class UGzSettingVCOutputDevice* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzSettingVCOutputDevice>();
	}
};
static_assert(alignof(UGzSettingVCOutputDevice) == 0x000008, "Wrong alignment on UGzSettingVCOutputDevice");
static_assert(sizeof(UGzSettingVCOutputDevice) == 0x000170, "Wrong size on UGzSettingVCOutputDevice");
static_assert(offsetof(UGzSettingVCOutputDevice, OutputDevices) == 0x000150, "Member 'UGzSettingVCOutputDevice::OutputDevices' has a wrong offset!");
static_assert(offsetof(UGzSettingVCOutputDevice, NoDevicesText) == 0x000160, "Member 'UGzSettingVCOutputDevice::NoDevicesText' has a wrong offset!");

// Class G01.GzSettingVoiceChatMode
// 0x0000 (0x01B8 - 0x01B8)
class UGzSettingVoiceChatMode final : public UGameSettingValueDiscreteDynamic_Enum
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzSettingVoiceChatMode">();
	}
	static class UGzSettingVoiceChatMode* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzSettingVoiceChatMode>();
	}
};
static_assert(alignof(UGzSettingVoiceChatMode) == 0x000008, "Wrong alignment on UGzSettingVoiceChatMode");
static_assert(sizeof(UGzSettingVoiceChatMode) == 0x0001B8, "Wrong size on UGzSettingVoiceChatMode");

// Class G01.GzShadowBot
// 0x0018 (0x0340 - 0x0328)
class AGzShadowBot : public APawn
{
public:
	class UBehaviorTree*                          AIBehavior;                                        // 0x0328(0x0008)(Edit, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_34F4[0x10];                                    // 0x0330(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SimulateKeyPressed(const struct FKey& Key);
	void SimulateKeyPressedAndReleased(const struct FKey& Key, float Delay);
	void SimulateKeyReleased(const struct FKey& Key);

	class UGzCheatManager* GetCheatManager() const;
	const class APawn* GetControlledPawn() const;
	class AGzPlayerController* GetPlayerController() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzShadowBot">();
	}
	static class AGzShadowBot* GetDefaultObj()
	{
		return GetDefaultObjImpl<AGzShadowBot>();
	}
};
static_assert(alignof(AGzShadowBot) == 0x000008, "Wrong alignment on AGzShadowBot");
static_assert(sizeof(AGzShadowBot) == 0x000340, "Wrong size on AGzShadowBot");
static_assert(offsetof(AGzShadowBot, AIBehavior) == 0x000328, "Member 'AGzShadowBot::AIBehavior' has a wrong offset!");

// Class G01.GzShootableSource
// 0x0000 (0x0028 - 0x0028)
class IGzShootableSource final : public IInterface
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzShootableSource">();
	}
	static class IGzShootableSource* GetDefaultObj()
	{
		return GetDefaultObjImpl<IGzShootableSource>();
	}
};
static_assert(alignof(IGzShootableSource) == 0x000008, "Wrong alignment on IGzShootableSource");
static_assert(sizeof(IGzShootableSource) == 0x000028, "Wrong size on IGzShootableSource");

// Class G01.GzShootingRangeGameMode
// 0x0010 (0x0650 - 0x0640)
class AGzShootingRangeGameMode final : public AGzMultiStageGameMode
{
public:
	TSubclassOf<class UGzSR_InitStage>            InitStageClass;                                    // 0x0640(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoClear, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSubclassOf<class UGzSR_InProgressStage>      InProgressStageClass;                              // 0x0648(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoClear, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzShootingRangeGameMode">();
	}
	static class AGzShootingRangeGameMode* GetDefaultObj()
	{
		return GetDefaultObjImpl<AGzShootingRangeGameMode>();
	}
};
static_assert(alignof(AGzShootingRangeGameMode) == 0x000008, "Wrong alignment on AGzShootingRangeGameMode");
static_assert(sizeof(AGzShootingRangeGameMode) == 0x000650, "Wrong size on AGzShootingRangeGameMode");
static_assert(offsetof(AGzShootingRangeGameMode, InitStageClass) == 0x000640, "Member 'AGzShootingRangeGameMode::InitStageClass' has a wrong offset!");
static_assert(offsetof(AGzShootingRangeGameMode, InProgressStageClass) == 0x000648, "Member 'AGzShootingRangeGameMode::InProgressStageClass' has a wrong offset!");

// Class G01.GzShootStatCollector
// 0x0000 (0x0038 - 0x0038)
class UGzShootStatCollector final : public UGzGlobalStatsCollector
{
public:
	void PlayerShoot(const class APawn* Instigator, class FName WeaponName);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzShootStatCollector">();
	}
	static class UGzShootStatCollector* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzShootStatCollector>();
	}
};
static_assert(alignof(UGzShootStatCollector) == 0x000008, "Wrong alignment on UGzShootStatCollector");
static_assert(sizeof(UGzShootStatCollector) == 0x000038, "Wrong size on UGzShootStatCollector");

// Class G01.LocomotionStateSwitcherWidget
// 0x0008 (0x02E8 - 0x02E0)
class ULocomotionStateSwitcherWidget : public UUserWidget
{
public:
	uint8                                         Pad_34F6[0x8];                                     // 0x02E0(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void CycleState(bool Up);
	void InitializeWidget(class UCanvasPanel* MovablePanel);
	void SelectOverlayState();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LocomotionStateSwitcherWidget">();
	}
	static class ULocomotionStateSwitcherWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULocomotionStateSwitcherWidget>();
	}
};
static_assert(alignof(ULocomotionStateSwitcherWidget) == 0x000008, "Wrong alignment on ULocomotionStateSwitcherWidget");
static_assert(sizeof(ULocomotionStateSwitcherWidget) == 0x0002E8, "Wrong size on ULocomotionStateSwitcherWidget");

// Class G01.GzShootStatCollectorHead
// 0x0000 (0x0038 - 0x0038)
class UGzShootStatCollectorHead final : public UGzShootHitStatCollector
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzShootStatCollectorHead">();
	}
	static class UGzShootStatCollectorHead* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzShootStatCollectorHead>();
	}
};
static_assert(alignof(UGzShootStatCollectorHead) == 0x000008, "Wrong alignment on UGzShootStatCollectorHead");
static_assert(sizeof(UGzShootStatCollectorHead) == 0x000038, "Wrong size on UGzShootStatCollectorHead");

// Class G01.GzShootStatCollectorLegs
// 0x0000 (0x0038 - 0x0038)
class UGzShootStatCollectorLegs final : public UGzShootHitStatCollector
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzShootStatCollectorLegs">();
	}
	static class UGzShootStatCollectorLegs* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzShootStatCollectorLegs>();
	}
};
static_assert(alignof(UGzShootStatCollectorLegs) == 0x000008, "Wrong alignment on UGzShootStatCollectorLegs");
static_assert(sizeof(UGzShootStatCollectorLegs) == 0x000038, "Wrong size on UGzShootStatCollectorLegs");

// Class G01.GzShootStatCollectorTorso
// 0x0000 (0x0038 - 0x0038)
class UGzShootStatCollectorTorso final : public UGzShootHitStatCollector
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzShootStatCollectorTorso">();
	}
	static class UGzShootStatCollectorTorso* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzShootStatCollectorTorso>();
	}
};
static_assert(alignof(UGzShootStatCollectorTorso) == 0x000008, "Wrong alignment on UGzShootStatCollectorTorso");
static_assert(sizeof(UGzShootStatCollectorTorso) == 0x000038, "Wrong size on UGzShootStatCollectorTorso");

// Class G01.GzSourceZoneStageParams
// 0x0000 (0x0030 - 0x0030)
class UGzSourceZoneStageParams final : public UGzBaseZoneStageParams
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzSourceZoneStageParams">();
	}
	static class UGzSourceZoneStageParams* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzSourceZoneStageParams>();
	}
};
static_assert(alignof(UGzSourceZoneStageParams) == 0x000008, "Wrong alignment on UGzSourceZoneStageParams");
static_assert(sizeof(UGzSourceZoneStageParams) == 0x000030, "Wrong size on UGzSourceZoneStageParams");

// Class G01.GzInnerZoneStageParams
// 0x0018 (0x0048 - 0x0030)
class UGzInnerZoneStageParams final : public UGzBaseZoneStageParams
{
public:
	float                                         Radius;                                            // 0x0030(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FFloatRange                            Offset;                                            // 0x0034(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_34F7[0x4];                                     // 0x0044(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzInnerZoneStageParams">();
	}
	static class UGzInnerZoneStageParams* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzInnerZoneStageParams>();
	}
};
static_assert(alignof(UGzInnerZoneStageParams) == 0x000008, "Wrong alignment on UGzInnerZoneStageParams");
static_assert(sizeof(UGzInnerZoneStageParams) == 0x000048, "Wrong size on UGzInnerZoneStageParams");
static_assert(offsetof(UGzInnerZoneStageParams, Radius) == 0x000030, "Member 'UGzInnerZoneStageParams::Radius' has a wrong offset!");
static_assert(offsetof(UGzInnerZoneStageParams, Offset) == 0x000034, "Member 'UGzInnerZoneStageParams::Offset' has a wrong offset!");

// Class G01.GzShiftZoneStageParams
// 0x0018 (0x0048 - 0x0030)
class UGzShiftZoneStageParams final : public UGzBaseZoneStageParams
{
public:
	struct FFloatRange                            Shift;                                             // 0x0030(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	double                                        ShiftBorderTolerance;                              // 0x0040(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzShiftZoneStageParams">();
	}
	static class UGzShiftZoneStageParams* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzShiftZoneStageParams>();
	}
};
static_assert(alignof(UGzShiftZoneStageParams) == 0x000008, "Wrong alignment on UGzShiftZoneStageParams");
static_assert(sizeof(UGzShiftZoneStageParams) == 0x000048, "Wrong size on UGzShiftZoneStageParams");
static_assert(offsetof(UGzShiftZoneStageParams, Shift) == 0x000030, "Member 'UGzShiftZoneStageParams::Shift' has a wrong offset!");
static_assert(offsetof(UGzShiftZoneStageParams, ShiftBorderTolerance) == 0x000040, "Member 'UGzShiftZoneStageParams::ShiftBorderTolerance' has a wrong offset!");

// Class G01.GzShrinkingZoneSettings
// 0x0010 (0x0048 - 0x0038)
class UGzShrinkingZoneSettings final : public UDeveloperSettings
{
public:
	TArray<TSoftClassPtr<class UClass>>           ZonesEvents;                                       // 0x0038(0x0010)(Edit, ZeroConstructor, Config, DisableEditOnInstance, UObjectWrapper, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzShrinkingZoneSettings">();
	}
	static class UGzShrinkingZoneSettings* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzShrinkingZoneSettings>();
	}
};
static_assert(alignof(UGzShrinkingZoneSettings) == 0x000008, "Wrong alignment on UGzShrinkingZoneSettings");
static_assert(sizeof(UGzShrinkingZoneSettings) == 0x000048, "Wrong size on UGzShrinkingZoneSettings");
static_assert(offsetof(UGzShrinkingZoneSettings, ZonesEvents) == 0x000038, "Member 'UGzShrinkingZoneSettings::ZonesEvents' has a wrong offset!");

// Class G01.GzShrinkingZoneStateMessage
// 0x0010 (0x0038 - 0x0028)
class UGzShrinkingZoneStateMessage final : public UGzGameMessage
{
public:
	class FName                                   ZoneName;                                          // 0x0028(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bLastZone;                                         // 0x0030(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_34F8[0x7];                                     // 0x0031(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzShrinkingZoneStateMessage">();
	}
	static class UGzShrinkingZoneStateMessage* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzShrinkingZoneStateMessage>();
	}
};
static_assert(alignof(UGzShrinkingZoneStateMessage) == 0x000008, "Wrong alignment on UGzShrinkingZoneStateMessage");
static_assert(sizeof(UGzShrinkingZoneStateMessage) == 0x000038, "Wrong size on UGzShrinkingZoneStateMessage");
static_assert(offsetof(UGzShrinkingZoneStateMessage, ZoneName) == 0x000028, "Member 'UGzShrinkingZoneStateMessage::ZoneName' has a wrong offset!");
static_assert(offsetof(UGzShrinkingZoneStateMessage, bLastZone) == 0x000030, "Member 'UGzShrinkingZoneStateMessage::bLastZone' has a wrong offset!");

// Class G01.GzStaticMeshPickable
// 0x0000 (0x0480 - 0x0480)
class AGzStaticMeshPickable : public AGzPickableBase
{
public:
	class UStaticMeshComponent*                   MeshComponent;                                     // 0x0478(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzStaticMeshPickable">();
	}
	static class AGzStaticMeshPickable* GetDefaultObj()
	{
		return GetDefaultObjImpl<AGzStaticMeshPickable>();
	}
};
static_assert(alignof(AGzStaticMeshPickable) == 0x000010, "Wrong alignment on AGzStaticMeshPickable");
static_assert(sizeof(AGzStaticMeshPickable) == 0x000480, "Wrong size on AGzStaticMeshPickable");
static_assert(offsetof(AGzStaticMeshPickable, MeshComponent) == 0x000478, "Member 'AGzStaticMeshPickable::MeshComponent' has a wrong offset!");

// Class G01.GzSimplePickable
// 0x0050 (0x04D0 - 0x0480)
class AGzSimplePickable final : public AGzStaticMeshPickable
{
public:
	float                                         RecheckIneligibleInteractablesInterval;            // 0x0480(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_34F9[0x4];                                     // 0x0484(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGzSimpleInvItem                       SimpleItem;                                        // 0x0488(0x0038)(Net, Transient, RepNotify, NativeAccessSpecifierPrivate)
	uint8                                         Pad_34FA[0x10];                                    // 0x04C0(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnRep_SimpleItem();

	bool IsAvailableToAutoPickUp() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzSimplePickable">();
	}
	static class AGzSimplePickable* GetDefaultObj()
	{
		return GetDefaultObjImpl<AGzSimplePickable>();
	}
};
static_assert(alignof(AGzSimplePickable) == 0x000010, "Wrong alignment on AGzSimplePickable");
static_assert(sizeof(AGzSimplePickable) == 0x0004D0, "Wrong size on AGzSimplePickable");
static_assert(offsetof(AGzSimplePickable, RecheckIneligibleInteractablesInterval) == 0x000480, "Member 'AGzSimplePickable::RecheckIneligibleInteractablesInterval' has a wrong offset!");
static_assert(offsetof(AGzSimplePickable, SimpleItem) == 0x000488, "Member 'AGzSimplePickable::SimpleItem' has a wrong offset!");

// Class G01.GzSmokePropagationActor
// 0x0010 (0x0498 - 0x0488)
class AGzSmokePropagationActor final : public AGzPropagationActor
{
public:
	TSubclassOf<class UGzGE_BaseDamage>           DamageEffectClass;                                 // 0x0488(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UGzBodyPartAbilityData_SmokeWall*       SmokeAbilityData;                                  // 0x0490(0x0008)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	struct FActiveGameplayEffectHandle ApplySmokeEffect(class UAbilitySystemComponent* TargetASC);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzSmokePropagationActor">();
	}
	static class AGzSmokePropagationActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<AGzSmokePropagationActor>();
	}
};
static_assert(alignof(AGzSmokePropagationActor) == 0x000008, "Wrong alignment on AGzSmokePropagationActor");
static_assert(sizeof(AGzSmokePropagationActor) == 0x000498, "Wrong size on AGzSmokePropagationActor");
static_assert(offsetof(AGzSmokePropagationActor, DamageEffectClass) == 0x000488, "Member 'AGzSmokePropagationActor::DamageEffectClass' has a wrong offset!");
static_assert(offsetof(AGzSmokePropagationActor, SmokeAbilityData) == 0x000490, "Member 'AGzSmokePropagationActor::SmokeAbilityData' has a wrong offset!");

// Class G01.GzSmokeWallPreviewPathActor
// 0x0050 (0x04E0 - 0x0490)
class AGzSmokeWallPreviewPathActor final : public AGzPreviewPathActor
{
public:
	float                                         MaxSimulationTime;                                 // 0x0490(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ProjectileRadius;                                  // 0x0494(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bEnableDrag;                                       // 0x0498(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_34FB[0x3];                                     // 0x0499(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         DragCoefficient;                                   // 0x049C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         DragStartingDistance;                              // 0x04A0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_34FC[0x4];                                     // 0x04A4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UGzGA_SmokeWall*                        SmokeWallAbility;                                  // 0x04A8(0x0008)(ZeroConstructor, Transient, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_34FD[0x30];                                    // 0x04B0(0x0030)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzSmokeWallPreviewPathActor">();
	}
	static class AGzSmokeWallPreviewPathActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<AGzSmokeWallPreviewPathActor>();
	}
};
static_assert(alignof(AGzSmokeWallPreviewPathActor) == 0x000008, "Wrong alignment on AGzSmokeWallPreviewPathActor");
static_assert(sizeof(AGzSmokeWallPreviewPathActor) == 0x0004E0, "Wrong size on AGzSmokeWallPreviewPathActor");
static_assert(offsetof(AGzSmokeWallPreviewPathActor, MaxSimulationTime) == 0x000490, "Member 'AGzSmokeWallPreviewPathActor::MaxSimulationTime' has a wrong offset!");
static_assert(offsetof(AGzSmokeWallPreviewPathActor, ProjectileRadius) == 0x000494, "Member 'AGzSmokeWallPreviewPathActor::ProjectileRadius' has a wrong offset!");
static_assert(offsetof(AGzSmokeWallPreviewPathActor, bEnableDrag) == 0x000498, "Member 'AGzSmokeWallPreviewPathActor::bEnableDrag' has a wrong offset!");
static_assert(offsetof(AGzSmokeWallPreviewPathActor, DragCoefficient) == 0x00049C, "Member 'AGzSmokeWallPreviewPathActor::DragCoefficient' has a wrong offset!");
static_assert(offsetof(AGzSmokeWallPreviewPathActor, DragStartingDistance) == 0x0004A0, "Member 'AGzSmokeWallPreviewPathActor::DragStartingDistance' has a wrong offset!");
static_assert(offsetof(AGzSmokeWallPreviewPathActor, SmokeWallAbility) == 0x0004A8, "Member 'AGzSmokeWallPreviewPathActor::SmokeWallAbility' has a wrong offset!");

// Class G01.GzSocialModel
// 0x00A0 (0x0110 - 0x0070)
class UGzSocialModel final : public UGzBackendModel
{
public:
	uint8                                         Pad_34FE[0xA0];                                    // 0x0070(0x00A0)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzSocialModel">();
	}
	static class UGzSocialModel* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzSocialModel>();
	}
};
static_assert(alignof(UGzSocialModel) == 0x000008, "Wrong alignment on UGzSocialModel");
static_assert(sizeof(UGzSocialModel) == 0x000110, "Wrong size on UGzSocialModel");

// Class G01.GzSpawnable
// 0x0000 (0x0028 - 0x0028)
class IGzSpawnable final : public IInterface
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzSpawnable">();
	}
	static class IGzSpawnable* GetDefaultObj()
	{
		return GetDefaultObjImpl<IGzSpawnable>();
	}
};
static_assert(alignof(IGzSpawnable) == 0x000008, "Wrong alignment on IGzSpawnable");
static_assert(sizeof(IGzSpawnable) == 0x000028, "Wrong size on IGzSpawnable");

// Class G01.GzSpiderMine
// 0x0290 (0x0590 - 0x0300)
class AGzSpiderMine : public AGzDamageableActor
{
public:
	uint8                                         Pad_34FF[0x10];                                    // 0x0300(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class UStaticMeshComponent*                   VisualLaser1;                                      // 0x0310(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, EditConst, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   VisualLaser2;                                      // 0x0318(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, EditConst, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   VisualLaser3;                                      // 0x0320(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, EditConst, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   Sphere;                                            // 0x0328(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, EditConst, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBoxComponent*                          CollisionComponent;                                // 0x0330(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   StaticMeshComponent;                               // 0x0338(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USceneComponent*                        MeshRoot;                                          // 0x0340(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, EditConst, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USceneComponent*                        LaserSourceRoot;                                   // 0x0348(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, EditConst, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USceneComponent*                        Laser1;                                            // 0x0350(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, EditConst, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USceneComponent*                        Laser2;                                            // 0x0358(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, EditConst, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USceneComponent*                        Laser3;                                            // 0x0360(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, EditConst, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCapsuleComponent*                      Capsule_Laser1;                                    // 0x0368(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, EditConst, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCapsuleComponent*                      Capsule_Laser2;                                    // 0x0370(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, EditConst, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCapsuleComponent*                      Capsule_Laser3;                                    // 0x0378(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, EditConst, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UGzExplosionComponent*                  GzExplosion;                                       // 0x0380(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, EditConst, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UGzGadgetMovementComponent*             GzGadgetMovementComponent;                         // 0x0388(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, EditConst, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AGzSpiderMine*                          OtherSpiderMine;                                   // 0x0390(0x0008)(BlueprintVisible, Net, ZeroConstructor, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UGzSpiderMine_PreviewComponent*         SpiderMineComp;                                    // 0x0398(0x0008)(BlueprintVisible, ExportObject, Net, ZeroConstructor, InstancedReference, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxHealth;                                         // 0x03A0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3500[0x4];                                     // 0x03A4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UMaterialInstanceDynamic*               LaserMaterialDynamic;                              // 0x03A8(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FName                                   FadeScalarParameterName;                           // 0x03B0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UMaterialInstance*                      FriendLight;                                       // 0x03B8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UMaterialInstance*                      EnemyLight;                                        // 0x03C0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bMineActivation;                                   // 0x03C8(0x0001)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_3501[0x7];                                     // 0x03C9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGzSpiderMine_LaunchInfo               LaunchInfo;                                        // 0x03D0(0x0030)(Net, RepNotify, NoDestructor, NativeAccessSpecifierPrivate)
	bool                                          bWasDetonated;                                     // 0x0400(0x0001)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_3502[0x7];                                     // 0x0401(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UCurveFloat*                            FadingOverDistanceCurve;                           // 0x0408(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FVector                                VisualLaserBaseScale;                              // 0x0410(0x0018)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         VisualLaserScaleLinked;                            // 0x0428(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         NotConnectedLaserScale;                            // 0x042C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         DistanceToStartFade;                               // 0x0430(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_3503[0x4];                                     // 0x0434(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UGameplayEffect>            DefaultAttributes;                                 // 0x0438(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FGameplayTag                           MaxHPTag;                                          // 0x0440(0x0008)(Edit, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         ExplosionMultiplier;                               // 0x0448(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_3504[0x4];                                     // 0x044C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRotator                               Laser1Rotation;                                    // 0x0450(0x0018)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, NativeAccessSpecifierPrivate)
	struct FRotator                               Laser2Rotation;                                    // 0x0468(0x0018)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, NativeAccessSpecifierPrivate)
	struct FRotator                               Laser3Rotation;                                    // 0x0480(0x0018)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, NativeAccessSpecifierPrivate)
	struct FVector                                MineBoxExtent;                                     // 0x0498(0x0018)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         BaseHalfHeightCapsule;                             // 0x04B0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_3505[0x4];                                     // 0x04B4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UAkAudioEvent*                          LinkingSound;                                      // 0x04B8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UAkAudioEvent*                          LinkTriggerAudio;                                  // 0x04C0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UAkAudioEvent*                          MineMovementAudio;                                 // 0x04C8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UAkAudioEvent*                          ActiveLaserSound;                                  // 0x04D0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UGzExplosionData*                       SpideMine_ExplosionData;                           // 0x04D8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UNiagaraSystem*                         ShootNS;                                           // 0x04E0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UNiagaraSystem*                         SpawnNS;                                           // 0x04E8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UAkAudioEvent*                          ShootAudioEvent;                                   // 0x04F0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UAkAudioEvent*                          SpawnAudioEvent;                                   // 0x04F8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         MineActivationTime;                                // 0x0500(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         DetonateSpeed;                                     // 0x0504(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         LaunchSpeed;                                       // 0x0508(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         DetonateFlyTime;                                   // 0x050C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         LaunchFlyTime;                                     // 0x0510(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         ExplodeDelay;                                      // 0x0514(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         DirectHitExplodeDelay;                             // 0x0518(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FGameplayTag                           DirectHitAnnouncerTag;                             // 0x051C(0x0008)(Edit, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FGameplayTag                           DirectHitVoiceLineTag;                             // 0x0524(0x0008)(Edit, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_3506[0x4];                                     // 0x052C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UGzItemData*                            ItemData;                                          // 0x0530(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         TickSoundInterval;                                 // 0x0538(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         AdditionalVelocityFromInstigatorMultiplier;        // 0x053C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class AGzPlayerCharacter*                     MineCreator;                                       // 0x0540(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_3507[0x38];                                    // 0x0548(0x0038)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGzCharacterIdAccess                   CharacterIdAccess;                                 // 0x0580(0x0010)(BlueprintVisible, Transient, NoDestructor, NativeAccessSpecifierPublic)

public:
	void ActivateMine();
	void Explode();
	void OnBeginOverlap(class UPrimitiveComponent* OverlappedComp, class AActor* Other, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const struct FHitResult& SweepResult);
	void OnMineReadyForActivation();
	void OnOwnerDestroyed(class AActor* Actor);
	void OnOwnerKilled(int32 KillerId);
	void OnPosition();
	void OnPreviewComponentEndPlay();
	void OnRep_LaunchInfo();
	void OnRep_MineActivation();
	void OnRep_WasDetonated();
	void OnReplicatedDataUpdated();
	void SetItemData(class UGzItemData* InItemData);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzSpiderMine">();
	}
	static class AGzSpiderMine* GetDefaultObj()
	{
		return GetDefaultObjImpl<AGzSpiderMine>();
	}
};
static_assert(alignof(AGzSpiderMine) == 0x000008, "Wrong alignment on AGzSpiderMine");
static_assert(sizeof(AGzSpiderMine) == 0x000590, "Wrong size on AGzSpiderMine");
static_assert(offsetof(AGzSpiderMine, VisualLaser1) == 0x000310, "Member 'AGzSpiderMine::VisualLaser1' has a wrong offset!");
static_assert(offsetof(AGzSpiderMine, VisualLaser2) == 0x000318, "Member 'AGzSpiderMine::VisualLaser2' has a wrong offset!");
static_assert(offsetof(AGzSpiderMine, VisualLaser3) == 0x000320, "Member 'AGzSpiderMine::VisualLaser3' has a wrong offset!");
static_assert(offsetof(AGzSpiderMine, Sphere) == 0x000328, "Member 'AGzSpiderMine::Sphere' has a wrong offset!");
static_assert(offsetof(AGzSpiderMine, CollisionComponent) == 0x000330, "Member 'AGzSpiderMine::CollisionComponent' has a wrong offset!");
static_assert(offsetof(AGzSpiderMine, StaticMeshComponent) == 0x000338, "Member 'AGzSpiderMine::StaticMeshComponent' has a wrong offset!");
static_assert(offsetof(AGzSpiderMine, MeshRoot) == 0x000340, "Member 'AGzSpiderMine::MeshRoot' has a wrong offset!");
static_assert(offsetof(AGzSpiderMine, LaserSourceRoot) == 0x000348, "Member 'AGzSpiderMine::LaserSourceRoot' has a wrong offset!");
static_assert(offsetof(AGzSpiderMine, Laser1) == 0x000350, "Member 'AGzSpiderMine::Laser1' has a wrong offset!");
static_assert(offsetof(AGzSpiderMine, Laser2) == 0x000358, "Member 'AGzSpiderMine::Laser2' has a wrong offset!");
static_assert(offsetof(AGzSpiderMine, Laser3) == 0x000360, "Member 'AGzSpiderMine::Laser3' has a wrong offset!");
static_assert(offsetof(AGzSpiderMine, Capsule_Laser1) == 0x000368, "Member 'AGzSpiderMine::Capsule_Laser1' has a wrong offset!");
static_assert(offsetof(AGzSpiderMine, Capsule_Laser2) == 0x000370, "Member 'AGzSpiderMine::Capsule_Laser2' has a wrong offset!");
static_assert(offsetof(AGzSpiderMine, Capsule_Laser3) == 0x000378, "Member 'AGzSpiderMine::Capsule_Laser3' has a wrong offset!");
static_assert(offsetof(AGzSpiderMine, GzExplosion) == 0x000380, "Member 'AGzSpiderMine::GzExplosion' has a wrong offset!");
static_assert(offsetof(AGzSpiderMine, GzGadgetMovementComponent) == 0x000388, "Member 'AGzSpiderMine::GzGadgetMovementComponent' has a wrong offset!");
static_assert(offsetof(AGzSpiderMine, OtherSpiderMine) == 0x000390, "Member 'AGzSpiderMine::OtherSpiderMine' has a wrong offset!");
static_assert(offsetof(AGzSpiderMine, SpiderMineComp) == 0x000398, "Member 'AGzSpiderMine::SpiderMineComp' has a wrong offset!");
static_assert(offsetof(AGzSpiderMine, MaxHealth) == 0x0003A0, "Member 'AGzSpiderMine::MaxHealth' has a wrong offset!");
static_assert(offsetof(AGzSpiderMine, LaserMaterialDynamic) == 0x0003A8, "Member 'AGzSpiderMine::LaserMaterialDynamic' has a wrong offset!");
static_assert(offsetof(AGzSpiderMine, FadeScalarParameterName) == 0x0003B0, "Member 'AGzSpiderMine::FadeScalarParameterName' has a wrong offset!");
static_assert(offsetof(AGzSpiderMine, FriendLight) == 0x0003B8, "Member 'AGzSpiderMine::FriendLight' has a wrong offset!");
static_assert(offsetof(AGzSpiderMine, EnemyLight) == 0x0003C0, "Member 'AGzSpiderMine::EnemyLight' has a wrong offset!");
static_assert(offsetof(AGzSpiderMine, bMineActivation) == 0x0003C8, "Member 'AGzSpiderMine::bMineActivation' has a wrong offset!");
static_assert(offsetof(AGzSpiderMine, LaunchInfo) == 0x0003D0, "Member 'AGzSpiderMine::LaunchInfo' has a wrong offset!");
static_assert(offsetof(AGzSpiderMine, bWasDetonated) == 0x000400, "Member 'AGzSpiderMine::bWasDetonated' has a wrong offset!");
static_assert(offsetof(AGzSpiderMine, FadingOverDistanceCurve) == 0x000408, "Member 'AGzSpiderMine::FadingOverDistanceCurve' has a wrong offset!");
static_assert(offsetof(AGzSpiderMine, VisualLaserBaseScale) == 0x000410, "Member 'AGzSpiderMine::VisualLaserBaseScale' has a wrong offset!");
static_assert(offsetof(AGzSpiderMine, VisualLaserScaleLinked) == 0x000428, "Member 'AGzSpiderMine::VisualLaserScaleLinked' has a wrong offset!");
static_assert(offsetof(AGzSpiderMine, NotConnectedLaserScale) == 0x00042C, "Member 'AGzSpiderMine::NotConnectedLaserScale' has a wrong offset!");
static_assert(offsetof(AGzSpiderMine, DistanceToStartFade) == 0x000430, "Member 'AGzSpiderMine::DistanceToStartFade' has a wrong offset!");
static_assert(offsetof(AGzSpiderMine, DefaultAttributes) == 0x000438, "Member 'AGzSpiderMine::DefaultAttributes' has a wrong offset!");
static_assert(offsetof(AGzSpiderMine, MaxHPTag) == 0x000440, "Member 'AGzSpiderMine::MaxHPTag' has a wrong offset!");
static_assert(offsetof(AGzSpiderMine, ExplosionMultiplier) == 0x000448, "Member 'AGzSpiderMine::ExplosionMultiplier' has a wrong offset!");
static_assert(offsetof(AGzSpiderMine, Laser1Rotation) == 0x000450, "Member 'AGzSpiderMine::Laser1Rotation' has a wrong offset!");
static_assert(offsetof(AGzSpiderMine, Laser2Rotation) == 0x000468, "Member 'AGzSpiderMine::Laser2Rotation' has a wrong offset!");
static_assert(offsetof(AGzSpiderMine, Laser3Rotation) == 0x000480, "Member 'AGzSpiderMine::Laser3Rotation' has a wrong offset!");
static_assert(offsetof(AGzSpiderMine, MineBoxExtent) == 0x000498, "Member 'AGzSpiderMine::MineBoxExtent' has a wrong offset!");
static_assert(offsetof(AGzSpiderMine, BaseHalfHeightCapsule) == 0x0004B0, "Member 'AGzSpiderMine::BaseHalfHeightCapsule' has a wrong offset!");
static_assert(offsetof(AGzSpiderMine, LinkingSound) == 0x0004B8, "Member 'AGzSpiderMine::LinkingSound' has a wrong offset!");
static_assert(offsetof(AGzSpiderMine, LinkTriggerAudio) == 0x0004C0, "Member 'AGzSpiderMine::LinkTriggerAudio' has a wrong offset!");
static_assert(offsetof(AGzSpiderMine, MineMovementAudio) == 0x0004C8, "Member 'AGzSpiderMine::MineMovementAudio' has a wrong offset!");
static_assert(offsetof(AGzSpiderMine, ActiveLaserSound) == 0x0004D0, "Member 'AGzSpiderMine::ActiveLaserSound' has a wrong offset!");
static_assert(offsetof(AGzSpiderMine, SpideMine_ExplosionData) == 0x0004D8, "Member 'AGzSpiderMine::SpideMine_ExplosionData' has a wrong offset!");
static_assert(offsetof(AGzSpiderMine, ShootNS) == 0x0004E0, "Member 'AGzSpiderMine::ShootNS' has a wrong offset!");
static_assert(offsetof(AGzSpiderMine, SpawnNS) == 0x0004E8, "Member 'AGzSpiderMine::SpawnNS' has a wrong offset!");
static_assert(offsetof(AGzSpiderMine, ShootAudioEvent) == 0x0004F0, "Member 'AGzSpiderMine::ShootAudioEvent' has a wrong offset!");
static_assert(offsetof(AGzSpiderMine, SpawnAudioEvent) == 0x0004F8, "Member 'AGzSpiderMine::SpawnAudioEvent' has a wrong offset!");
static_assert(offsetof(AGzSpiderMine, MineActivationTime) == 0x000500, "Member 'AGzSpiderMine::MineActivationTime' has a wrong offset!");
static_assert(offsetof(AGzSpiderMine, DetonateSpeed) == 0x000504, "Member 'AGzSpiderMine::DetonateSpeed' has a wrong offset!");
static_assert(offsetof(AGzSpiderMine, LaunchSpeed) == 0x000508, "Member 'AGzSpiderMine::LaunchSpeed' has a wrong offset!");
static_assert(offsetof(AGzSpiderMine, DetonateFlyTime) == 0x00050C, "Member 'AGzSpiderMine::DetonateFlyTime' has a wrong offset!");
static_assert(offsetof(AGzSpiderMine, LaunchFlyTime) == 0x000510, "Member 'AGzSpiderMine::LaunchFlyTime' has a wrong offset!");
static_assert(offsetof(AGzSpiderMine, ExplodeDelay) == 0x000514, "Member 'AGzSpiderMine::ExplodeDelay' has a wrong offset!");
static_assert(offsetof(AGzSpiderMine, DirectHitExplodeDelay) == 0x000518, "Member 'AGzSpiderMine::DirectHitExplodeDelay' has a wrong offset!");
static_assert(offsetof(AGzSpiderMine, DirectHitAnnouncerTag) == 0x00051C, "Member 'AGzSpiderMine::DirectHitAnnouncerTag' has a wrong offset!");
static_assert(offsetof(AGzSpiderMine, DirectHitVoiceLineTag) == 0x000524, "Member 'AGzSpiderMine::DirectHitVoiceLineTag' has a wrong offset!");
static_assert(offsetof(AGzSpiderMine, ItemData) == 0x000530, "Member 'AGzSpiderMine::ItemData' has a wrong offset!");
static_assert(offsetof(AGzSpiderMine, TickSoundInterval) == 0x000538, "Member 'AGzSpiderMine::TickSoundInterval' has a wrong offset!");
static_assert(offsetof(AGzSpiderMine, AdditionalVelocityFromInstigatorMultiplier) == 0x00053C, "Member 'AGzSpiderMine::AdditionalVelocityFromInstigatorMultiplier' has a wrong offset!");
static_assert(offsetof(AGzSpiderMine, MineCreator) == 0x000540, "Member 'AGzSpiderMine::MineCreator' has a wrong offset!");
static_assert(offsetof(AGzSpiderMine, CharacterIdAccess) == 0x000580, "Member 'AGzSpiderMine::CharacterIdAccess' has a wrong offset!");

// Class G01.GzSpiderMine_PreviewActor
// 0x0038 (0x02D8 - 0x02A0)
class AGzSpiderMine_PreviewActor : public AActor
{
public:
	EGzLimbType                                   LimbSlot;                                          // 0x02A0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3509[0x3];                                     // 0x02A1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MaxPlacementDistance;                              // 0x02A4(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   StaticMesh;                                        // 0x02A8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USceneComponent*                        LaserParent;                                       // 0x02B0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   LaserCylinder;                                     // 0x02B8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMaterialInstance*                      GreenLight;                                        // 0x02C0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UMaterialInstance*                      RedLight;                                          // 0x02C8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FName                                   MaterilaParameterName;                             // 0x02D0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzSpiderMine_PreviewActor">();
	}
	static class AGzSpiderMine_PreviewActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<AGzSpiderMine_PreviewActor>();
	}
};
static_assert(alignof(AGzSpiderMine_PreviewActor) == 0x000008, "Wrong alignment on AGzSpiderMine_PreviewActor");
static_assert(sizeof(AGzSpiderMine_PreviewActor) == 0x0002D8, "Wrong size on AGzSpiderMine_PreviewActor");
static_assert(offsetof(AGzSpiderMine_PreviewActor, LimbSlot) == 0x0002A0, "Member 'AGzSpiderMine_PreviewActor::LimbSlot' has a wrong offset!");
static_assert(offsetof(AGzSpiderMine_PreviewActor, MaxPlacementDistance) == 0x0002A4, "Member 'AGzSpiderMine_PreviewActor::MaxPlacementDistance' has a wrong offset!");
static_assert(offsetof(AGzSpiderMine_PreviewActor, StaticMesh) == 0x0002A8, "Member 'AGzSpiderMine_PreviewActor::StaticMesh' has a wrong offset!");
static_assert(offsetof(AGzSpiderMine_PreviewActor, LaserParent) == 0x0002B0, "Member 'AGzSpiderMine_PreviewActor::LaserParent' has a wrong offset!");
static_assert(offsetof(AGzSpiderMine_PreviewActor, LaserCylinder) == 0x0002B8, "Member 'AGzSpiderMine_PreviewActor::LaserCylinder' has a wrong offset!");
static_assert(offsetof(AGzSpiderMine_PreviewActor, GreenLight) == 0x0002C0, "Member 'AGzSpiderMine_PreviewActor::GreenLight' has a wrong offset!");
static_assert(offsetof(AGzSpiderMine_PreviewActor, RedLight) == 0x0002C8, "Member 'AGzSpiderMine_PreviewActor::RedLight' has a wrong offset!");
static_assert(offsetof(AGzSpiderMine_PreviewActor, MaterilaParameterName) == 0x0002D0, "Member 'AGzSpiderMine_PreviewActor::MaterilaParameterName' has a wrong offset!");

// Class G01.GzSR_InitStage
// 0x0008 (0x0118 - 0x0110)
class UGzSR_InitStage final : public UGzGameStageBase
{
public:
	uint8                                         Pad_350A[0x8];                                     // 0x0110(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzSR_InitStage">();
	}
	static class UGzSR_InitStage* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzSR_InitStage>();
	}
};
static_assert(alignof(UGzSR_InitStage) == 0x000008, "Wrong alignment on UGzSR_InitStage");
static_assert(sizeof(UGzSR_InitStage) == 0x000118, "Wrong size on UGzSR_InitStage");

// Class G01.GzStageDecorator
// 0x0020 (0x0088 - 0x0068)
class UGzStageDecorator final : public UGzDecoratorObjective
{
public:
	uint8                                         Pad_350B[0x20];                                    // 0x0068(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UGzObjective* MakeStageObjective(class AGzAdvancedMission* Mission, class UGzObjective* Objective, const class FText& Param_Name, const class FText& Description);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzStageDecorator">();
	}
	static class UGzStageDecorator* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzStageDecorator>();
	}
};
static_assert(alignof(UGzStageDecorator) == 0x000008, "Wrong alignment on UGzStageDecorator");
static_assert(sizeof(UGzStageDecorator) == 0x000088, "Wrong size on UGzStageDecorator");

// Class G01.GzStageEndsSoonMessage
// 0x0020 (0x0048 - 0x0028)
class UGzStageEndsSoonMessage final : public UGzGameMessage
{
public:
	struct FGameplayTagContainer                  ActiveStageTags;                                   // 0x0028(0x0020)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzStageEndsSoonMessage">();
	}
	static class UGzStageEndsSoonMessage* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzStageEndsSoonMessage>();
	}
};
static_assert(alignof(UGzStageEndsSoonMessage) == 0x000008, "Wrong alignment on UGzStageEndsSoonMessage");
static_assert(sizeof(UGzStageEndsSoonMessage) == 0x000048, "Wrong size on UGzStageEndsSoonMessage");
static_assert(offsetof(UGzStageEndsSoonMessage, ActiveStageTags) == 0x000028, "Member 'UGzStageEndsSoonMessage::ActiveStageTags' has a wrong offset!");

// Class G01.GzStandTurret
// 0x0040 (0x04D0 - 0x0490)
class AGzStandTurret : public AGzAIPawn
{
public:
	class FName                                   SocketPrefix;                                      // 0x0490(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UGzCombatComponent*                     CombatComponent;                                   // 0x0498(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class AActor*                                 TargetActor;                                       // 0x04A0(0x0008)(Net, ZeroConstructor, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FVector                                CurrentBodyPart;                                   // 0x04A8(0x0018)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class AGzWeaponActor*                         MainWeaponActor;                                   // 0x04C0(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_350C[0x8];                                     // 0x04C8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static void OnRep_CurrentBodyPart();
	static void OnRep_TargetActor();

	void CalculateTarget();
	void OnWeaponReady(const struct FGzInvPocketId& InvPocketId, const class AGzWeaponActor* WeaponActor, bool bEquipped);

	void GetTargetBodyPart(struct FVector* CurrentBodyPartRef) const;
	class AActor* GetTargetEnemy() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzStandTurret">();
	}
	static class AGzStandTurret* GetDefaultObj()
	{
		return GetDefaultObjImpl<AGzStandTurret>();
	}
};
static_assert(alignof(AGzStandTurret) == 0x000010, "Wrong alignment on AGzStandTurret");
static_assert(sizeof(AGzStandTurret) == 0x0004D0, "Wrong size on AGzStandTurret");
static_assert(offsetof(AGzStandTurret, SocketPrefix) == 0x000490, "Member 'AGzStandTurret::SocketPrefix' has a wrong offset!");
static_assert(offsetof(AGzStandTurret, CombatComponent) == 0x000498, "Member 'AGzStandTurret::CombatComponent' has a wrong offset!");
static_assert(offsetof(AGzStandTurret, TargetActor) == 0x0004A0, "Member 'AGzStandTurret::TargetActor' has a wrong offset!");
static_assert(offsetof(AGzStandTurret, CurrentBodyPart) == 0x0004A8, "Member 'AGzStandTurret::CurrentBodyPart' has a wrong offset!");
static_assert(offsetof(AGzStandTurret, MainWeaponActor) == 0x0004C0, "Member 'AGzStandTurret::MainWeaponActor' has a wrong offset!");

// Class G01.GzStateChangedDecorator
// 0x0010 (0x0078 - 0x0068)
class UGzStateChangedDecorator final : public UGzDecoratorObjective
{
public:
	uint8                                         Pad_350E[0x10];                                    // 0x0068(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UGzObjective* MakeStageObjective(class AGzAdvancedMission* Mission, class UGzObjective* Objective, const TDelegate<void(EGzObjectiveState NewState)>& StateChanged);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzStateChangedDecorator">();
	}
	static class UGzStateChangedDecorator* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzStateChangedDecorator>();
	}
};
static_assert(alignof(UGzStateChangedDecorator) == 0x000008, "Wrong alignment on UGzStateChangedDecorator");
static_assert(sizeof(UGzStateChangedDecorator) == 0x000078, "Wrong size on UGzStateChangedDecorator");

// Class G01.GzStatisticsModel
// 0x0020 (0x0090 - 0x0070)
class UGzStatisticsModel final : public UGzBackendModel
{
public:
	uint8                                         Pad_350F[0x20];                                    // 0x0070(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzStatisticsModel">();
	}
	static class UGzStatisticsModel* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzStatisticsModel>();
	}
};
static_assert(alignof(UGzStatisticsModel) == 0x000008, "Wrong alignment on UGzStatisticsModel");
static_assert(sizeof(UGzStatisticsModel) == 0x000090, "Wrong size on UGzStatisticsModel");

// Class G01.GzClientStatisticsService
// 0x0128 (0x01C8 - 0x00A0)
class UGzClientStatisticsService final : public UGzClientPFObject
{
public:
	uint8                                         Pad_3510[0x128];                                   // 0x00A0(0x0128)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzClientStatisticsService">();
	}
	static class UGzClientStatisticsService* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzClientStatisticsService>();
	}
};
static_assert(alignof(UGzClientStatisticsService) == 0x000008, "Wrong alignment on UGzClientStatisticsService");
static_assert(sizeof(UGzClientStatisticsService) == 0x0001C8, "Wrong size on UGzClientStatisticsService");

// Class G01.GzStatRewardGraded
// 0x0018 (0x0048 - 0x0030)
class UGzStatRewardGraded final : public UGzStatRewardPolicy
{
public:
	TArray<struct FGzStatRewardGrade>             RewardGrades;                                      // 0x0030(0x0010)(Edit, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	bool                                          bGrantOnlyLast;                                    // 0x0040(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3511[0x7];                                     // 0x0041(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzStatRewardGraded">();
	}
	static class UGzStatRewardGraded* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzStatRewardGraded>();
	}
};
static_assert(alignof(UGzStatRewardGraded) == 0x000008, "Wrong alignment on UGzStatRewardGraded");
static_assert(sizeof(UGzStatRewardGraded) == 0x000048, "Wrong size on UGzStatRewardGraded");
static_assert(offsetof(UGzStatRewardGraded, RewardGrades) == 0x000030, "Member 'UGzStatRewardGraded::RewardGrades' has a wrong offset!");
static_assert(offsetof(UGzStatRewardGraded, bGrantOnlyLast) == 0x000040, "Member 'UGzStatRewardGraded::bGrantOnlyLast' has a wrong offset!");

// Class G01.GzStatsHandlingRewardComponent
// 0x0058 (0x00F8 - 0x00A0)
class UGzStatsHandlingRewardComponent final : public UGzServiceComponent
{
public:
	uint8                                         Pad_3512[0x58];                                    // 0x00A0(0x0058)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzStatsHandlingRewardComponent">();
	}
	static class UGzStatsHandlingRewardComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzStatsHandlingRewardComponent>();
	}
};
static_assert(alignof(UGzStatsHandlingRewardComponent) == 0x000008, "Wrong alignment on UGzStatsHandlingRewardComponent");
static_assert(sizeof(UGzStatsHandlingRewardComponent) == 0x0000F8, "Wrong size on UGzStatsHandlingRewardComponent");

// Class G01.GzStatsHolderComponent
// 0x01C8 (0x0270 - 0x00A8)
class UGzStatsHolderComponent final : public UControllerComponent
{
public:
	class UGzStatsSubsystem*                      StatsSubsystem;                                    // 0x00A8(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class AGzTeam*                                Team;                                              // 0x00B0(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FGzStatsArray                          ReplicatedStats;                                   // 0x00B8(0x0168)(Net, Transient, NativeAccessSpecifierPrivate)
	uint8                                         Pad_3513[0x50];                                    // 0x0220(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnOwnerChangeTeam(class AGzPlayerState* PlayerState);
	void OnTeammatesChanged();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzStatsHolderComponent">();
	}
	static class UGzStatsHolderComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzStatsHolderComponent>();
	}
};
static_assert(alignof(UGzStatsHolderComponent) == 0x000008, "Wrong alignment on UGzStatsHolderComponent");
static_assert(sizeof(UGzStatsHolderComponent) == 0x000270, "Wrong size on UGzStatsHolderComponent");
static_assert(offsetof(UGzStatsHolderComponent, StatsSubsystem) == 0x0000A8, "Member 'UGzStatsHolderComponent::StatsSubsystem' has a wrong offset!");
static_assert(offsetof(UGzStatsHolderComponent, Team) == 0x0000B0, "Member 'UGzStatsHolderComponent::Team' has a wrong offset!");
static_assert(offsetof(UGzStatsHolderComponent, ReplicatedStats) == 0x0000B8, "Member 'UGzStatsHolderComponent::ReplicatedStats' has a wrong offset!");

// Class G01.GzStickyGooComponent
// 0x0040 (0x0298 - 0x0258)
class UGzStickyGooComponent : public UGzChargeableAbilityComponent
{
public:
	TSoftObjectPtr<class UNiagaraSystem>          ChargeSmokeNiagaraSystem;                          // 0x0258(0x0028)(Edit, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FName                                   ChargeSmokeSocketName_Left;                        // 0x0280(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FName                                   ChargeSmokeSocketName_Right;                       // 0x0288(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UNiagaraComponent*                      ChargeSmokeNiagaraComponent;                       // 0x0290(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzStickyGooComponent">();
	}
	static class UGzStickyGooComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzStickyGooComponent>();
	}
};
static_assert(alignof(UGzStickyGooComponent) == 0x000008, "Wrong alignment on UGzStickyGooComponent");
static_assert(sizeof(UGzStickyGooComponent) == 0x000298, "Wrong size on UGzStickyGooComponent");
static_assert(offsetof(UGzStickyGooComponent, ChargeSmokeNiagaraSystem) == 0x000258, "Member 'UGzStickyGooComponent::ChargeSmokeNiagaraSystem' has a wrong offset!");
static_assert(offsetof(UGzStickyGooComponent, ChargeSmokeSocketName_Left) == 0x000280, "Member 'UGzStickyGooComponent::ChargeSmokeSocketName_Left' has a wrong offset!");
static_assert(offsetof(UGzStickyGooComponent, ChargeSmokeSocketName_Right) == 0x000288, "Member 'UGzStickyGooComponent::ChargeSmokeSocketName_Right' has a wrong offset!");
static_assert(offsetof(UGzStickyGooComponent, ChargeSmokeNiagaraComponent) == 0x000290, "Member 'UGzStickyGooComponent::ChargeSmokeNiagaraComponent' has a wrong offset!");

// Class G01.GzStickyGooProjectile
// 0x0050 (0x0398 - 0x0348)
class AGzStickyGooProjectile final : public AGzProjectileBase
{
public:
	class UGzAbilitySystemComponent*              AbilitySystemComponent;                            // 0x0348(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	FMulticastInlineDelegateProperty_             OnProjectileDeployed;                              // 0x0350(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, Protected, NativeAccessSpecifierProtected)
	class UGzBodyPartAbilityData_StickyGoo*       AbilityData;                                       // 0x0360(0x0008)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bAllowFriendlyFire;                                // 0x0368(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_3514[0x3];                                     // 0x0369(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         GooElementLimit;                                   // 0x036C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSubclassOf<class UGameplayEffect>            StickyGooEffectClass;                              // 0x0370(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSubclassOf<class AGzStickyGooPropagationActor> PropagationActorClass;                             // 0x0378(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<class AGzCharacter*>                   OverlappedCharacters;                              // 0x0380(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	bool                                          bIsDeployed;                                       // 0x0390(0x0001)(Net, ZeroConstructor, Transient, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_3515[0x7];                                     // 0x0391(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void GzGooProjectileDeployedDelegate__DelegateSignature();
	void OnProjectileBounce(const struct FHitResult& ImpactResult, const struct FVector& ImpactVelocity);
	void OnProjectileStop(const struct FHitResult& ImpactResult);
	void OnRep_IsDeployed();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzStickyGooProjectile">();
	}
	static class AGzStickyGooProjectile* GetDefaultObj()
	{
		return GetDefaultObjImpl<AGzStickyGooProjectile>();
	}
};
static_assert(alignof(AGzStickyGooProjectile) == 0x000008, "Wrong alignment on AGzStickyGooProjectile");
static_assert(sizeof(AGzStickyGooProjectile) == 0x000398, "Wrong size on AGzStickyGooProjectile");
static_assert(offsetof(AGzStickyGooProjectile, AbilitySystemComponent) == 0x000348, "Member 'AGzStickyGooProjectile::AbilitySystemComponent' has a wrong offset!");
static_assert(offsetof(AGzStickyGooProjectile, OnProjectileDeployed) == 0x000350, "Member 'AGzStickyGooProjectile::OnProjectileDeployed' has a wrong offset!");
static_assert(offsetof(AGzStickyGooProjectile, AbilityData) == 0x000360, "Member 'AGzStickyGooProjectile::AbilityData' has a wrong offset!");
static_assert(offsetof(AGzStickyGooProjectile, bAllowFriendlyFire) == 0x000368, "Member 'AGzStickyGooProjectile::bAllowFriendlyFire' has a wrong offset!");
static_assert(offsetof(AGzStickyGooProjectile, GooElementLimit) == 0x00036C, "Member 'AGzStickyGooProjectile::GooElementLimit' has a wrong offset!");
static_assert(offsetof(AGzStickyGooProjectile, StickyGooEffectClass) == 0x000370, "Member 'AGzStickyGooProjectile::StickyGooEffectClass' has a wrong offset!");
static_assert(offsetof(AGzStickyGooProjectile, PropagationActorClass) == 0x000378, "Member 'AGzStickyGooProjectile::PropagationActorClass' has a wrong offset!");
static_assert(offsetof(AGzStickyGooProjectile, OverlappedCharacters) == 0x000380, "Member 'AGzStickyGooProjectile::OverlappedCharacters' has a wrong offset!");
static_assert(offsetof(AGzStickyGooProjectile, bIsDeployed) == 0x000390, "Member 'AGzStickyGooProjectile::bIsDeployed' has a wrong offset!");

// Class G01.GzStreamableComponent
// 0x0010 (0x00B8 - 0x00A8)
class UGzStreamableComponent final : public UActorComponent
{
public:
	bool                                          bForceHashEvenWhenReplicated;                      // 0x00A8(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3516[0x7];                                     // 0x00A9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	uint64                                        ObjectNetId;                                       // 0x00B0(0x0008)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void OnRep_ObjectNetId();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzStreamableComponent">();
	}
	static class UGzStreamableComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzStreamableComponent>();
	}
};
static_assert(alignof(UGzStreamableComponent) == 0x000008, "Wrong alignment on UGzStreamableComponent");
static_assert(sizeof(UGzStreamableComponent) == 0x0000B8, "Wrong size on UGzStreamableComponent");
static_assert(offsetof(UGzStreamableComponent, bForceHashEvenWhenReplicated) == 0x0000A8, "Member 'UGzStreamableComponent::bForceHashEvenWhenReplicated' has a wrong offset!");
static_assert(offsetof(UGzStreamableComponent, ObjectNetId) == 0x0000B0, "Member 'UGzStreamableComponent::ObjectNetId' has a wrong offset!");

// Class G01.GzStreamableTrackerSubsystem
// 0x00D8 (0x0108 - 0x0030)
class UGzStreamableTrackerSubsystem final : public UWorldSubsystem
{
public:
	uint8                                         Pad_3517[0x30];                                    // 0x0030(0x0030)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<uint64, class AActor*>                   TrackedActors;                                     // 0x0060(0x0050)(Transient, Protected, NativeAccessSpecifierProtected)
	TMap<uint64, struct FGzItemStreamHandleArray> StreamHandles;                                     // 0x00B0(0x0050)(Transient, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_3518[0x8];                                     // 0x0100(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzStreamableTrackerSubsystem">();
	}
	static class UGzStreamableTrackerSubsystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzStreamableTrackerSubsystem>();
	}
};
static_assert(alignof(UGzStreamableTrackerSubsystem) == 0x000008, "Wrong alignment on UGzStreamableTrackerSubsystem");
static_assert(sizeof(UGzStreamableTrackerSubsystem) == 0x000108, "Wrong size on UGzStreamableTrackerSubsystem");
static_assert(offsetof(UGzStreamableTrackerSubsystem, TrackedActors) == 0x000060, "Member 'UGzStreamableTrackerSubsystem::TrackedActors' has a wrong offset!");
static_assert(offsetof(UGzStreamableTrackerSubsystem, StreamHandles) == 0x0000B0, "Member 'UGzStreamableTrackerSubsystem::StreamHandles' has a wrong offset!");

// Class G01.GzSubscriptionBenefit
// 0x0058 (0x0088 - 0x0030)
class UGzSubscriptionBenefit final : public UDataAsset
{
public:
	TSoftObjectPtr<class UTexture2D>              Image;                                             // 0x0030(0x0028)(Edit, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Rules;                                             // 0x0058(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FText                                   UpperText;                                         // 0x0068(0x0010)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	class FText                                   LowerText;                                         // 0x0078(0x0010)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzSubscriptionBenefit">();
	}
	static class UGzSubscriptionBenefit* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzSubscriptionBenefit>();
	}
};
static_assert(alignof(UGzSubscriptionBenefit) == 0x000008, "Wrong alignment on UGzSubscriptionBenefit");
static_assert(sizeof(UGzSubscriptionBenefit) == 0x000088, "Wrong size on UGzSubscriptionBenefit");
static_assert(offsetof(UGzSubscriptionBenefit, Image) == 0x000030, "Member 'UGzSubscriptionBenefit::Image' has a wrong offset!");
static_assert(offsetof(UGzSubscriptionBenefit, Rules) == 0x000058, "Member 'UGzSubscriptionBenefit::Rules' has a wrong offset!");
static_assert(offsetof(UGzSubscriptionBenefit, UpperText) == 0x000068, "Member 'UGzSubscriptionBenefit::UpperText' has a wrong offset!");
static_assert(offsetof(UGzSubscriptionBenefit, LowerText) == 0x000078, "Member 'UGzSubscriptionBenefit::LowerText' has a wrong offset!");

// Class G01.GzSubscriptionBenefitsStateComponent
// 0x0050 (0x00F0 - 0x00A0)
class UGzSubscriptionBenefitsStateComponent final : public UGzServiceComponent
{
public:
	uint8                                         Pad_3519[0x50];                                    // 0x00A0(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzSubscriptionBenefitsStateComponent">();
	}
	static class UGzSubscriptionBenefitsStateComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzSubscriptionBenefitsStateComponent>();
	}
};
static_assert(alignof(UGzSubscriptionBenefitsStateComponent) == 0x000008, "Wrong alignment on UGzSubscriptionBenefitsStateComponent");
static_assert(sizeof(UGzSubscriptionBenefitsStateComponent) == 0x0000F0, "Wrong size on UGzSubscriptionBenefitsStateComponent");

// Class G01.GzSubscriptionDataModel
// 0x0160 (0x01D0 - 0x0070)
class UGzSubscriptionDataModel final : public UGzBackendModel
{
public:
	uint8                                         Pad_351A[0x40];                                    // 0x0070(0x0040)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGzCohtmlAccountTypesBenefits          AccountTypesBenefits;                              // 0x00B0(0x0050)(NativeAccessSpecifierPrivate)
	struct FGzCohtmlContentPackPreviewInfo        ContentPackPreviewInfo;                            // 0x0100(0x0070)(NativeAccessSpecifierPrivate)
	struct FGzCohtmlAccountTypesPreviewInfo       AccountTypesPreviewInfo;                           // 0x0170(0x0030)(NativeAccessSpecifierPrivate)
	struct FGzCohtmlBattlePassPreviewInfo         BattlePassPreviewInfo;                             // 0x01A0(0x0030)(NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzSubscriptionDataModel">();
	}
	static class UGzSubscriptionDataModel* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzSubscriptionDataModel>();
	}
};
static_assert(alignof(UGzSubscriptionDataModel) == 0x000008, "Wrong alignment on UGzSubscriptionDataModel");
static_assert(sizeof(UGzSubscriptionDataModel) == 0x0001D0, "Wrong size on UGzSubscriptionDataModel");
static_assert(offsetof(UGzSubscriptionDataModel, AccountTypesBenefits) == 0x0000B0, "Member 'UGzSubscriptionDataModel::AccountTypesBenefits' has a wrong offset!");
static_assert(offsetof(UGzSubscriptionDataModel, ContentPackPreviewInfo) == 0x000100, "Member 'UGzSubscriptionDataModel::ContentPackPreviewInfo' has a wrong offset!");
static_assert(offsetof(UGzSubscriptionDataModel, AccountTypesPreviewInfo) == 0x000170, "Member 'UGzSubscriptionDataModel::AccountTypesPreviewInfo' has a wrong offset!");
static_assert(offsetof(UGzSubscriptionDataModel, BattlePassPreviewInfo) == 0x0001A0, "Member 'UGzSubscriptionDataModel::BattlePassPreviewInfo' has a wrong offset!");

// Class G01.GzSubscriptionPageLayoutInfo
// 0x02D0 (0x0300 - 0x0030)
class UGzSubscriptionPageLayoutInfo final : public UDataAsset
{
public:
	struct FGzAccountTypesBenefits                AccountTypesBenefits;                              // 0x0030(0x0050)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FGzContentPackPreviewInfo              ContentPackPreviewInfo;                            // 0x0080(0x00D0)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FGzAccountTypesPreviewInfo             AccountTypesPreviewInfo;                           // 0x0150(0x0048)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FGzBattlePassPreviewInfo               BattlePassPreviewInfo;                             // 0x0198(0x0048)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FGzContentPackCharacterPreviewSetup    ContentPackCharacterPreviewSetup;                  // 0x01E0(0x0120)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzSubscriptionPageLayoutInfo">();
	}
	static class UGzSubscriptionPageLayoutInfo* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzSubscriptionPageLayoutInfo>();
	}
};
static_assert(alignof(UGzSubscriptionPageLayoutInfo) == 0x000008, "Wrong alignment on UGzSubscriptionPageLayoutInfo");
static_assert(sizeof(UGzSubscriptionPageLayoutInfo) == 0x000300, "Wrong size on UGzSubscriptionPageLayoutInfo");
static_assert(offsetof(UGzSubscriptionPageLayoutInfo, AccountTypesBenefits) == 0x000030, "Member 'UGzSubscriptionPageLayoutInfo::AccountTypesBenefits' has a wrong offset!");
static_assert(offsetof(UGzSubscriptionPageLayoutInfo, ContentPackPreviewInfo) == 0x000080, "Member 'UGzSubscriptionPageLayoutInfo::ContentPackPreviewInfo' has a wrong offset!");
static_assert(offsetof(UGzSubscriptionPageLayoutInfo, AccountTypesPreviewInfo) == 0x000150, "Member 'UGzSubscriptionPageLayoutInfo::AccountTypesPreviewInfo' has a wrong offset!");
static_assert(offsetof(UGzSubscriptionPageLayoutInfo, BattlePassPreviewInfo) == 0x000198, "Member 'UGzSubscriptionPageLayoutInfo::BattlePassPreviewInfo' has a wrong offset!");
static_assert(offsetof(UGzSubscriptionPageLayoutInfo, ContentPackCharacterPreviewSetup) == 0x0001E0, "Member 'UGzSubscriptionPageLayoutInfo::ContentPackCharacterPreviewSetup' has a wrong offset!");

// Class G01.GzSubscriptionReceivedData
// 0x0000 (0x0028 - 0x0028)
class UGzSubscriptionReceivedData final : public UGzSignalREventData
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzSubscriptionReceivedData">();
	}
	static class UGzSubscriptionReceivedData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzSubscriptionReceivedData>();
	}
};
static_assert(alignof(UGzSubscriptionReceivedData) == 0x000008, "Wrong alignment on UGzSubscriptionReceivedData");
static_assert(sizeof(UGzSubscriptionReceivedData) == 0x000028, "Wrong size on UGzSubscriptionReceivedData");

// Class G01.GzSuperSprintComponent
// 0x0078 (0x0168 - 0x00F0)
class UGzSuperSprintComponent : public UGzLimbAbilityComponent
{
public:
	FMulticastInlineDelegateProperty_             OnSuperSprintCollision;                            // 0x00F0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnSuperSprintActivated;                            // 0x0100(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnSuperSprintDurationDepleted;                     // 0x0110(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnSprintConditionsChanged;                         // 0x0120(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	bool                                          bShouldCheckCollisions;                            // 0x0130(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_351B[0x3];                                     // 0x0131(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ForwardCollisionCheckDistance;                     // 0x0134(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MininmumSprintSpeedNecessary;                      // 0x0138(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         DurationReplicationTimerRate;                      // 0x013C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsSuperSprintActive;                              // 0x0140(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_351C[0x3];                                     // 0x0141(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         SuperSprintDurationLeft;                           // 0x0144(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, Transient, EditConst, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MaxSuperSprintDuration;                            // 0x0148(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         DurationRegenerationMagnitude;                     // 0x014C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsDurationRegenerationActive;                     // 0x0150(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bShouldWatchSprintConditions;                      // 0x0151(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bSprintConditionsMet;                              // 0x0152(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_351D[0x5];                                     // 0x0153(0x0005)(Fixing Size After Last Property [ Dumper-7 ])
	class UGzBodyPartAbilityData_SuperSprintLegs* SuperSprintAbilityData;                            // 0x0158(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_351E[0x8];                                     // 0x0160(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void GzSprintConditionsChangedEvent__DelegateSignature(const bool bConditionsMet);
	void GzSuperSprintActivationEvent__DelegateSignature(bool Param_bIsActive);
	void GzSuperSprintCollisionEvent__DelegateSignature();
	void GzSuperSprintDurationDepleted__DelegateSignature();
	void OnMarkDurationDirty();
	void OnRecharged();
	void OnRep_SuperSprintDurationLeft();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzSuperSprintComponent">();
	}
	static class UGzSuperSprintComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzSuperSprintComponent>();
	}
};
static_assert(alignof(UGzSuperSprintComponent) == 0x000008, "Wrong alignment on UGzSuperSprintComponent");
static_assert(sizeof(UGzSuperSprintComponent) == 0x000168, "Wrong size on UGzSuperSprintComponent");
static_assert(offsetof(UGzSuperSprintComponent, OnSuperSprintCollision) == 0x0000F0, "Member 'UGzSuperSprintComponent::OnSuperSprintCollision' has a wrong offset!");
static_assert(offsetof(UGzSuperSprintComponent, OnSuperSprintActivated) == 0x000100, "Member 'UGzSuperSprintComponent::OnSuperSprintActivated' has a wrong offset!");
static_assert(offsetof(UGzSuperSprintComponent, OnSuperSprintDurationDepleted) == 0x000110, "Member 'UGzSuperSprintComponent::OnSuperSprintDurationDepleted' has a wrong offset!");
static_assert(offsetof(UGzSuperSprintComponent, OnSprintConditionsChanged) == 0x000120, "Member 'UGzSuperSprintComponent::OnSprintConditionsChanged' has a wrong offset!");
static_assert(offsetof(UGzSuperSprintComponent, bShouldCheckCollisions) == 0x000130, "Member 'UGzSuperSprintComponent::bShouldCheckCollisions' has a wrong offset!");
static_assert(offsetof(UGzSuperSprintComponent, ForwardCollisionCheckDistance) == 0x000134, "Member 'UGzSuperSprintComponent::ForwardCollisionCheckDistance' has a wrong offset!");
static_assert(offsetof(UGzSuperSprintComponent, MininmumSprintSpeedNecessary) == 0x000138, "Member 'UGzSuperSprintComponent::MininmumSprintSpeedNecessary' has a wrong offset!");
static_assert(offsetof(UGzSuperSprintComponent, DurationReplicationTimerRate) == 0x00013C, "Member 'UGzSuperSprintComponent::DurationReplicationTimerRate' has a wrong offset!");
static_assert(offsetof(UGzSuperSprintComponent, bIsSuperSprintActive) == 0x000140, "Member 'UGzSuperSprintComponent::bIsSuperSprintActive' has a wrong offset!");
static_assert(offsetof(UGzSuperSprintComponent, SuperSprintDurationLeft) == 0x000144, "Member 'UGzSuperSprintComponent::SuperSprintDurationLeft' has a wrong offset!");
static_assert(offsetof(UGzSuperSprintComponent, MaxSuperSprintDuration) == 0x000148, "Member 'UGzSuperSprintComponent::MaxSuperSprintDuration' has a wrong offset!");
static_assert(offsetof(UGzSuperSprintComponent, DurationRegenerationMagnitude) == 0x00014C, "Member 'UGzSuperSprintComponent::DurationRegenerationMagnitude' has a wrong offset!");
static_assert(offsetof(UGzSuperSprintComponent, bIsDurationRegenerationActive) == 0x000150, "Member 'UGzSuperSprintComponent::bIsDurationRegenerationActive' has a wrong offset!");
static_assert(offsetof(UGzSuperSprintComponent, bShouldWatchSprintConditions) == 0x000151, "Member 'UGzSuperSprintComponent::bShouldWatchSprintConditions' has a wrong offset!");
static_assert(offsetof(UGzSuperSprintComponent, bSprintConditionsMet) == 0x000152, "Member 'UGzSuperSprintComponent::bSprintConditionsMet' has a wrong offset!");
static_assert(offsetof(UGzSuperSprintComponent, SuperSprintAbilityData) == 0x000158, "Member 'UGzSuperSprintComponent::SuperSprintAbilityData' has a wrong offset!");

// Class G01.GzSuperSprintTrailActor
// 0x0030 (0x02D0 - 0x02A0)
class AGzSuperSprintTrailActor final : public AActor
{
public:
	class USphereComponent*                       CollisionSphere;                                   // 0x02A0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UGameplayEffect>            TrailGameplayEffect;                               // 0x02A8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UGzBodyPartAbilityData_SuperSprintLegs* AbilityData;                                       // 0x02B0(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                PreviousTrailActorLocation;                        // 0x02B8(0x0018)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void OnRep_PreviousTrailActorLocation();
	void OnTrailTouched(class UPrimitiveComponent* OverlappedComp, class AActor* Other, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const struct FHitResult& OverlapInfo);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzSuperSprintTrailActor">();
	}
	static class AGzSuperSprintTrailActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<AGzSuperSprintTrailActor>();
	}
};
static_assert(alignof(AGzSuperSprintTrailActor) == 0x000008, "Wrong alignment on AGzSuperSprintTrailActor");
static_assert(sizeof(AGzSuperSprintTrailActor) == 0x0002D0, "Wrong size on AGzSuperSprintTrailActor");
static_assert(offsetof(AGzSuperSprintTrailActor, CollisionSphere) == 0x0002A0, "Member 'AGzSuperSprintTrailActor::CollisionSphere' has a wrong offset!");
static_assert(offsetof(AGzSuperSprintTrailActor, TrailGameplayEffect) == 0x0002A8, "Member 'AGzSuperSprintTrailActor::TrailGameplayEffect' has a wrong offset!");
static_assert(offsetof(AGzSuperSprintTrailActor, AbilityData) == 0x0002B0, "Member 'AGzSuperSprintTrailActor::AbilityData' has a wrong offset!");
static_assert(offsetof(AGzSuperSprintTrailActor, PreviousTrailActorLocation) == 0x0002B8, "Member 'AGzSuperSprintTrailActor::PreviousTrailActorLocation' has a wrong offset!");

// Class G01.GzSupportModel
// 0x0050 (0x00C0 - 0x0070)
class UGzSupportModel final : public UGzBackendModel
{
public:
	uint8                                         Pad_3520[0x50];                                    // 0x0070(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzSupportModel">();
	}
	static class UGzSupportModel* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzSupportModel>();
	}
};
static_assert(alignof(UGzSupportModel) == 0x000008, "Wrong alignment on UGzSupportModel");
static_assert(sizeof(UGzSupportModel) == 0x0000C0, "Wrong size on UGzSupportModel");

// Class G01.GzSurfacePropagationController
// 0x0030 (0x02D0 - 0x02A0)
class AGzSurfacePropagationController final : public AActor
{
public:
	class UDataAsset*                             OptionalDataAsset;                                 // 0x02A0(0x0008)(Net, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UGzPropagationStrategy*                 PropagationStrategy;                               // 0x02A8(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDataAsset*                             DamageSourceDataAsset;                             // 0x02B0(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UClass*                                 PropagatedActorClass;                              // 0x02B8(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FGzCharacterIdAccess                   CharacterIdAccess;                                 // 0x02C0(0x0010)(BlueprintVisible, Transient, NoDestructor, NativeAccessSpecifierPublic)

public:
	void StartPropagation(class UGzPropagationConfiguration* PropagationData, const int32 Level, class UDataAsset* Param_OptionalDataAsset);

	class UDataAsset* GetDamageSourceDataAsset() const;
	class UDataAsset* GetOptionalDataAsset() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzSurfacePropagationController">();
	}
	static class AGzSurfacePropagationController* GetDefaultObj()
	{
		return GetDefaultObjImpl<AGzSurfacePropagationController>();
	}
};
static_assert(alignof(AGzSurfacePropagationController) == 0x000008, "Wrong alignment on AGzSurfacePropagationController");
static_assert(sizeof(AGzSurfacePropagationController) == 0x0002D0, "Wrong size on AGzSurfacePropagationController");
static_assert(offsetof(AGzSurfacePropagationController, OptionalDataAsset) == 0x0002A0, "Member 'AGzSurfacePropagationController::OptionalDataAsset' has a wrong offset!");
static_assert(offsetof(AGzSurfacePropagationController, PropagationStrategy) == 0x0002A8, "Member 'AGzSurfacePropagationController::PropagationStrategy' has a wrong offset!");
static_assert(offsetof(AGzSurfacePropagationController, DamageSourceDataAsset) == 0x0002B0, "Member 'AGzSurfacePropagationController::DamageSourceDataAsset' has a wrong offset!");
static_assert(offsetof(AGzSurfacePropagationController, PropagatedActorClass) == 0x0002B8, "Member 'AGzSurfacePropagationController::PropagatedActorClass' has a wrong offset!");
static_assert(offsetof(AGzSurfacePropagationController, CharacterIdAccess) == 0x0002C0, "Member 'AGzSurfacePropagationController::CharacterIdAccess' has a wrong offset!");

// Class G01.GzTableLootChooserComponent
// 0x0010 (0x00B8 - 0x00A8)
class UGzTableLootChooserComponent final : public UGzLootChooserComponent
{
public:
	class UGzLootTableSlotsSetup*                 LootTableSlotsSetup;                               // 0x00A8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UGzLootRarityTableData*                 RarityTable;                                       // 0x00B0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzTableLootChooserComponent">();
	}
	static class UGzTableLootChooserComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzTableLootChooserComponent>();
	}
};
static_assert(alignof(UGzTableLootChooserComponent) == 0x000008, "Wrong alignment on UGzTableLootChooserComponent");
static_assert(sizeof(UGzTableLootChooserComponent) == 0x0000B8, "Wrong size on UGzTableLootChooserComponent");
static_assert(offsetof(UGzTableLootChooserComponent, LootTableSlotsSetup) == 0x0000A8, "Member 'UGzTableLootChooserComponent::LootTableSlotsSetup' has a wrong offset!");
static_assert(offsetof(UGzTableLootChooserComponent, RarityTable) == 0x0000B0, "Member 'UGzTableLootChooserComponent::RarityTable' has a wrong offset!");

// Class G01.GzTagSwitcherVertical
// 0x0058 (0x01F8 - 0x01A0)
class UGzTagSwitcherVertical final : public UVerticalBox
{
public:
	struct FGzTagVisibilitySettings               TagSettings;                                       // 0x01A0(0x0050)(Edit, Protected, NativeAccessSpecifierProtected)
	class UUserWidget*                            ParentWidget;                                      // 0x01F0(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void InitializedTag(class UUserWidget* InParentWidget, const bool bResetTagSettings, const struct FGzTagVisibilitySettings& InTagSettings);
	void SetTagVisibility(EGzTargetUITagsState TagsState);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzTagSwitcherVertical">();
	}
	static class UGzTagSwitcherVertical* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzTagSwitcherVertical>();
	}
};
static_assert(alignof(UGzTagSwitcherVertical) == 0x000008, "Wrong alignment on UGzTagSwitcherVertical");
static_assert(sizeof(UGzTagSwitcherVertical) == 0x0001F8, "Wrong size on UGzTagSwitcherVertical");
static_assert(offsetof(UGzTagSwitcherVertical, TagSettings) == 0x0001A0, "Member 'UGzTagSwitcherVertical::TagSettings' has a wrong offset!");
static_assert(offsetof(UGzTagSwitcherVertical, ParentWidget) == 0x0001F0, "Member 'UGzTagSwitcherVertical::ParentWidget' has a wrong offset!");

// Class G01.GzTargetableComponent
// 0x0008 (0x00B0 - 0x00A8)
class UGzTargetableComponent final : public UActorComponent
{
public:
	class UGzTargetableRegisterSubsystem*         CachedSubsystem;                                   // 0x00A8(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzTargetableComponent">();
	}
	static class UGzTargetableComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzTargetableComponent>();
	}
};
static_assert(alignof(UGzTargetableComponent) == 0x000008, "Wrong alignment on UGzTargetableComponent");
static_assert(sizeof(UGzTargetableComponent) == 0x0000B0, "Wrong size on UGzTargetableComponent");
static_assert(offsetof(UGzTargetableComponent, CachedSubsystem) == 0x0000A8, "Member 'UGzTargetableComponent::CachedSubsystem' has a wrong offset!");

// Class G01.GzTargetableRegisterSubsystem
// 0x0010 (0x0040 - 0x0030)
class UGzTargetableRegisterSubsystem final : public ULocalPlayerSubsystem
{
public:
	TArray<class UGzTargetableComponent*>         TargetableComponents;                              // 0x0030(0x0010)(ExportObject, ZeroConstructor, Transient, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzTargetableRegisterSubsystem">();
	}
	static class UGzTargetableRegisterSubsystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzTargetableRegisterSubsystem>();
	}
};
static_assert(alignof(UGzTargetableRegisterSubsystem) == 0x000008, "Wrong alignment on UGzTargetableRegisterSubsystem");
static_assert(sizeof(UGzTargetableRegisterSubsystem) == 0x000040, "Wrong size on UGzTargetableRegisterSubsystem");
static_assert(offsetof(UGzTargetableRegisterSubsystem, TargetableComponents) == 0x000030, "Member 'UGzTargetableRegisterSubsystem::TargetableComponents' has a wrong offset!");

// Class G01.GzTargetType_UseEventData
// 0x0000 (0x0028 - 0x0028)
class UGzTargetType_UseEventData final : public UGzTargetType
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzTargetType_UseEventData">();
	}
	static class UGzTargetType_UseEventData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzTargetType_UseEventData>();
	}
};
static_assert(alignof(UGzTargetType_UseEventData) == 0x000008, "Wrong alignment on UGzTargetType_UseEventData");
static_assert(sizeof(UGzTargetType_UseEventData) == 0x000028, "Wrong size on UGzTargetType_UseEventData");

// Class G01.GzTeam
// 0x0078 (0x0318 - 0x02A0)
class AGzTeam final : public AInfo
{
public:
	uint8                                         Pad_3523[0x8];                                     // 0x02A0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	FMulticastInlineDelegateProperty_             OnTeamChanged;                                     // 0x02A8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnPawnChanged;                                     // 0x02B8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	int32                                         TeamID;                                            // 0x02C8(0x0004)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         Capacity;                                          // 0x02CC(0x0004)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         TeamRank;                                          // 0x02D0(0x0004)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bTeamAlive;                                        // 0x02D4(0x0001)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_3524[0x3];                                     // 0x02D5(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FGzTeamMember>                  TeamMembers;                                       // 0x02D8(0x0010)(Net, ZeroConstructor, RepNotify, NativeAccessSpecifierPrivate)
	uint8                                         Pad_3525[0x30];                                    // 0x02E8(0x0030)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnPlayerAliveStateChanged(class AGzPlayerState* PlayerState);
	void OnRep_TeamAlive();
	void OnRep_TeamMembers();
	void OnTeammatePawnChanged(class APlayerState* Player, class APawn* NewPawn, class APawn* OldPawn);

	bool CanAddPlayer(const class AGzPlayerState* Player) const;
	int32 GetCapacity() const;
	int32 GetEmptySlots() const;
	TArray<class APlayerState*> GetPlayers() const;
	class FString GetSessionId() const;
	int32 GetTeamId() const;
	const class AGzPlayerState* GetTeamLeader() const;
	const struct FGzFaction GetTeamLeaderFaction() const;
	const TArray<struct FGzTeamMember> GetTeamMembers() const;
	int32 GetTeamRank() const;
	int32 GetTeamSize() const;
	const struct FGuid GetVoiceChatRoomId() const;
	bool HasLimitedCapacity() const;
	bool HasPlayersInMatch() const;
	bool HasTeamLeader() const;
	bool IsAnyoneAlive() const;
	bool IsDefeated() const;
	bool IsEmpty() const;
	bool IsFull() const;
	bool IsTeamAlive() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzTeam">();
	}
	static class AGzTeam* GetDefaultObj()
	{
		return GetDefaultObjImpl<AGzTeam>();
	}
};
static_assert(alignof(AGzTeam) == 0x000008, "Wrong alignment on AGzTeam");
static_assert(sizeof(AGzTeam) == 0x000318, "Wrong size on AGzTeam");
static_assert(offsetof(AGzTeam, OnTeamChanged) == 0x0002A8, "Member 'AGzTeam::OnTeamChanged' has a wrong offset!");
static_assert(offsetof(AGzTeam, OnPawnChanged) == 0x0002B8, "Member 'AGzTeam::OnPawnChanged' has a wrong offset!");
static_assert(offsetof(AGzTeam, TeamID) == 0x0002C8, "Member 'AGzTeam::TeamID' has a wrong offset!");
static_assert(offsetof(AGzTeam, Capacity) == 0x0002CC, "Member 'AGzTeam::Capacity' has a wrong offset!");
static_assert(offsetof(AGzTeam, TeamRank) == 0x0002D0, "Member 'AGzTeam::TeamRank' has a wrong offset!");
static_assert(offsetof(AGzTeam, bTeamAlive) == 0x0002D4, "Member 'AGzTeam::bTeamAlive' has a wrong offset!");
static_assert(offsetof(AGzTeam, TeamMembers) == 0x0002D8, "Member 'AGzTeam::TeamMembers' has a wrong offset!");

// Class G01.GzTeammateViewportMarkerWidget
// 0x0000 (0x0398 - 0x0398)
class UGzTeammateViewportMarkerWidget : public UGzViewportMarkerWidget
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzTeammateViewportMarkerWidget">();
	}
	static class UGzTeammateViewportMarkerWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzTeammateViewportMarkerWidget>();
	}
};
static_assert(alignof(UGzTeammateViewportMarkerWidget) == 0x000008, "Wrong alignment on UGzTeammateViewportMarkerWidget");
static_assert(sizeof(UGzTeammateViewportMarkerWidget) == 0x000398, "Wrong size on UGzTeammateViewportMarkerWidget");

// Class G01.GzTeamRevealSubsystem
// 0x0060 (0x0300 - 0x02A0)
class AGzTeamRevealSubsystem : public AGzGameModeSubsystem
{
public:
	TSubclassOf<class AGzMarkerSceneContainer>    MarkerActorClass;                                  // 0x02A0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         RevealDuration;                                    // 0x02A8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         PositionUpdateFrequency;                           // 0x02AC(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TMap<struct FGzRevealTeamPair, struct FGzTeamRevealData> TeamReveals;                                       // 0x02B0(0x0050)(Transient, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzTeamRevealSubsystem">();
	}
	static class AGzTeamRevealSubsystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<AGzTeamRevealSubsystem>();
	}
};
static_assert(alignof(AGzTeamRevealSubsystem) == 0x000008, "Wrong alignment on AGzTeamRevealSubsystem");
static_assert(sizeof(AGzTeamRevealSubsystem) == 0x000300, "Wrong size on AGzTeamRevealSubsystem");
static_assert(offsetof(AGzTeamRevealSubsystem, MarkerActorClass) == 0x0002A0, "Member 'AGzTeamRevealSubsystem::MarkerActorClass' has a wrong offset!");
static_assert(offsetof(AGzTeamRevealSubsystem, RevealDuration) == 0x0002A8, "Member 'AGzTeamRevealSubsystem::RevealDuration' has a wrong offset!");
static_assert(offsetof(AGzTeamRevealSubsystem, PositionUpdateFrequency) == 0x0002AC, "Member 'AGzTeamRevealSubsystem::PositionUpdateFrequency' has a wrong offset!");
static_assert(offsetof(AGzTeamRevealSubsystem, TeamReveals) == 0x0002B0, "Member 'AGzTeamRevealSubsystem::TeamReveals' has a wrong offset!");

// Class G01.GzTelemetrySettings
// 0x0048 (0x0070 - 0x0028)
class UGzTelemetrySettings final : public UObject
{
public:
	class FString                                 InfluxDBURL;                                       // 0x0028(0x0010)(Edit, ZeroConstructor, Config, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 InfluxDBToken;                                     // 0x0038(0x0010)(Edit, ZeroConstructor, Config, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 InfluxDBOrganization;                              // 0x0048(0x0010)(Edit, BlueprintVisible, ZeroConstructor, Config, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 InfluxDBBucket;                                    // 0x0058(0x0010)(Edit, BlueprintVisible, ZeroConstructor, Config, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         TelemetryIntervalSeconds;                          // 0x0068(0x0004)(Edit, BlueprintVisible, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3527[0x4];                                     // 0x006C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzTelemetrySettings">();
	}
	static class UGzTelemetrySettings* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzTelemetrySettings>();
	}
};
static_assert(alignof(UGzTelemetrySettings) == 0x000008, "Wrong alignment on UGzTelemetrySettings");
static_assert(sizeof(UGzTelemetrySettings) == 0x000070, "Wrong size on UGzTelemetrySettings");
static_assert(offsetof(UGzTelemetrySettings, InfluxDBURL) == 0x000028, "Member 'UGzTelemetrySettings::InfluxDBURL' has a wrong offset!");
static_assert(offsetof(UGzTelemetrySettings, InfluxDBToken) == 0x000038, "Member 'UGzTelemetrySettings::InfluxDBToken' has a wrong offset!");
static_assert(offsetof(UGzTelemetrySettings, InfluxDBOrganization) == 0x000048, "Member 'UGzTelemetrySettings::InfluxDBOrganization' has a wrong offset!");
static_assert(offsetof(UGzTelemetrySettings, InfluxDBBucket) == 0x000058, "Member 'UGzTelemetrySettings::InfluxDBBucket' has a wrong offset!");
static_assert(offsetof(UGzTelemetrySettings, TelemetryIntervalSeconds) == 0x000068, "Member 'UGzTelemetrySettings::TelemetryIntervalSeconds' has a wrong offset!");

// Class G01.GzTelemetrySubsystem
// 0x0008 (0x0038 - 0x0030)
class UGzTelemetrySubsystem final : public UGameInstanceSubsystem
{
public:
	uint8                                         Pad_3528[0x8];                                     // 0x0030(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzTelemetrySubsystem">();
	}
	static class UGzTelemetrySubsystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzTelemetrySubsystem>();
	}
};
static_assert(alignof(UGzTelemetrySubsystem) == 0x000008, "Wrong alignment on UGzTelemetrySubsystem");
static_assert(sizeof(UGzTelemetrySubsystem) == 0x000038, "Wrong size on UGzTelemetrySubsystem");

// Class G01.GzTetherEnd
// 0x0020 (0x0320 - 0x0300)
class AGzTetherEnd : public AGzDamageableActor
{
public:
	bool                                          bDestroyedFromLinkTrigger;                         // 0x0300(0x0001)(Edit, BlueprintVisible, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3529[0x7];                                     // 0x0301(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                ParentNormal;                                      // 0x0308(0x0018)(Edit, BlueprintVisible, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzTetherEnd">();
	}
	static class AGzTetherEnd* GetDefaultObj()
	{
		return GetDefaultObjImpl<AGzTetherEnd>();
	}
};
static_assert(alignof(AGzTetherEnd) == 0x000008, "Wrong alignment on AGzTetherEnd");
static_assert(sizeof(AGzTetherEnd) == 0x000320, "Wrong size on AGzTetherEnd");
static_assert(offsetof(AGzTetherEnd, bDestroyedFromLinkTrigger) == 0x000300, "Member 'AGzTetherEnd::bDestroyedFromLinkTrigger' has a wrong offset!");
static_assert(offsetof(AGzTetherEnd, ParentNormal) == 0x000308, "Member 'AGzTetherEnd::ParentNormal' has a wrong offset!");

// Class G01.GzTetherPreviewComponent
// 0x0018 (0x0108 - 0x00F0)
class UGzTetherPreviewComponent : public UGzLimbAbilityComponent
{
public:
	TArray<struct FGzTetherPair>                  TetherPairs;                                       // 0x00F0(0x0010)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_352A[0x8];                                     // 0x0100(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnTetherDestroyed(class AActor* DestroyedActor);
	void RegisterTetherPair(class AActor* FirstTether, class AActor* SecondTether, class AActor* TetherLink);

	int32 GetTetherLimit() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzTetherPreviewComponent">();
	}
	static class UGzTetherPreviewComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzTetherPreviewComponent>();
	}
};
static_assert(alignof(UGzTetherPreviewComponent) == 0x000008, "Wrong alignment on UGzTetherPreviewComponent");
static_assert(sizeof(UGzTetherPreviewComponent) == 0x000108, "Wrong size on UGzTetherPreviewComponent");
static_assert(offsetof(UGzTetherPreviewComponent, TetherPairs) == 0x0000F0, "Member 'UGzTetherPreviewComponent::TetherPairs' has a wrong offset!");

// Class G01.GzTextBlock
// 0x0010 (0x03B0 - 0x03A0)
class UGzTextBlock final : public UCommonTextBlock
{
public:
	struct FGameplayTag                           FontTag;                                           // 0x0398(0x0008)(Edit, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bOverrideColor;                                    // 0x03A0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_352B[0x3];                                     // 0x03A1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   ColorNameOverride;                                 // 0x03A4(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_352C[0x4];                                     // 0x03AC(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static TArray<class FString> GetTextColorNames();

	void SetColorOverrideName(class FName ColorName);
	void SetFontTag(const struct FGameplayTag& InFontTag);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzTextBlock">();
	}
	static class UGzTextBlock* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzTextBlock>();
	}
};
static_assert(alignof(UGzTextBlock) == 0x000010, "Wrong alignment on UGzTextBlock");
static_assert(sizeof(UGzTextBlock) == 0x0003B0, "Wrong size on UGzTextBlock");
static_assert(offsetof(UGzTextBlock, FontTag) == 0x000398, "Member 'UGzTextBlock::FontTag' has a wrong offset!");
static_assert(offsetof(UGzTextBlock, bOverrideColor) == 0x0003A0, "Member 'UGzTextBlock::bOverrideColor' has a wrong offset!");
static_assert(offsetof(UGzTextBlock, ColorNameOverride) == 0x0003A4, "Member 'UGzTextBlock::ColorNameOverride' has a wrong offset!");

// Class G01.GzThrowableShieldComponent
// 0x0058 (0x0148 - 0x00F0)
class UGzThrowableShieldComponent final : public UGzLimbAbilityComponent
{
public:
	class UGzThrowableShieldData*                 ShieldData;                                        // 0x00F0(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class AGzThrowableShield*                     ShieldActor;                                       // 0x00F8(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class AGzThrowableShieldPreviewPathActor*     PreviewPathActor;                                  // 0x0100(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class AActor*                                 CurrentTarget;                                     // 0x0108(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class AActor*                                 PendingTarget;                                     // 0x0110(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_352D[0x30];                                    // 0x0118(0x0030)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void RequestShieldReturn();

	bool IsShieldActive() const;
	bool IsShieldLaunched() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzThrowableShieldComponent">();
	}
	static class UGzThrowableShieldComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzThrowableShieldComponent>();
	}
};
static_assert(alignof(UGzThrowableShieldComponent) == 0x000008, "Wrong alignment on UGzThrowableShieldComponent");
static_assert(sizeof(UGzThrowableShieldComponent) == 0x000148, "Wrong size on UGzThrowableShieldComponent");
static_assert(offsetof(UGzThrowableShieldComponent, ShieldData) == 0x0000F0, "Member 'UGzThrowableShieldComponent::ShieldData' has a wrong offset!");
static_assert(offsetof(UGzThrowableShieldComponent, ShieldActor) == 0x0000F8, "Member 'UGzThrowableShieldComponent::ShieldActor' has a wrong offset!");
static_assert(offsetof(UGzThrowableShieldComponent, PreviewPathActor) == 0x000100, "Member 'UGzThrowableShieldComponent::PreviewPathActor' has a wrong offset!");
static_assert(offsetof(UGzThrowableShieldComponent, CurrentTarget) == 0x000108, "Member 'UGzThrowableShieldComponent::CurrentTarget' has a wrong offset!");
static_assert(offsetof(UGzThrowableShieldComponent, PendingTarget) == 0x000110, "Member 'UGzThrowableShieldComponent::PendingTarget' has a wrong offset!");

// Class G01.GzThrowableShieldData
// 0x00B0 (0x00E0 - 0x0030)
class UGzThrowableShieldData final : public UDataAsset
{
public:
	TSubclassOf<class AGzThrowableShield>         ShieldClass;                                       // 0x0030(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGzThrowableShieldTargetingParameters_User UserTargetingParams;                               // 0x0038(0x0010)(Edit, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	struct FGzThrowableShieldTargetingParameters_Shield ShieldAutoTargetingParams;                         // 0x0048(0x0014)(Edit, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_352E[0x4];                                     // 0x005C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UGameplayEffect>            InitAttributesEffect;                              // 0x0060(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UGzGE_BaseDamage>           DamageEffect;                                      // 0x0068(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bApplyStunToTarget;                                // 0x0070(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_352F[0x3];                                     // 0x0071(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         StunDuration;                                      // 0x0074(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bApplyRotationOffsetOnLaunch;                      // 0x0078(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3530[0x7];                                     // 0x0079(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRotator                               RotationOffset;                                    // 0x0080(0x0018)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	float                                         RotationInterpSpeed;                               // 0x0098(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseCharge;                                        // 0x009C(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3531[0x3];                                     // 0x009D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         FullChargeTime;                                    // 0x00A0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGzThrowableShieldMovementParameters   MovementParams;                                    // 0x00A4(0x000C)(Edit, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	struct FGzThrowableShieldMovementParameters   MovementParams_Charged;                            // 0x00B0(0x000C)(Edit, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	class FName                                   LaunchedShieldCollisionProfileName;                // 0x00BC(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinDistanceToCompleteReturn;                       // 0x00C4(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DeactivationTimeAfterReturn;                       // 0x00C8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxDistanceToStartAutoReturn;                      // 0x00CC(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class AGzThrowableShieldPreviewPathActor> TargetPreviewActorClass;                           // 0x00D0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ShieldProjectileRadius;                            // 0x00D8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxSimulationTime;                                 // 0x00DC(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzThrowableShieldData">();
	}
	static class UGzThrowableShieldData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzThrowableShieldData>();
	}
};
static_assert(alignof(UGzThrowableShieldData) == 0x000008, "Wrong alignment on UGzThrowableShieldData");
static_assert(sizeof(UGzThrowableShieldData) == 0x0000E0, "Wrong size on UGzThrowableShieldData");
static_assert(offsetof(UGzThrowableShieldData, ShieldClass) == 0x000030, "Member 'UGzThrowableShieldData::ShieldClass' has a wrong offset!");
static_assert(offsetof(UGzThrowableShieldData, UserTargetingParams) == 0x000038, "Member 'UGzThrowableShieldData::UserTargetingParams' has a wrong offset!");
static_assert(offsetof(UGzThrowableShieldData, ShieldAutoTargetingParams) == 0x000048, "Member 'UGzThrowableShieldData::ShieldAutoTargetingParams' has a wrong offset!");
static_assert(offsetof(UGzThrowableShieldData, InitAttributesEffect) == 0x000060, "Member 'UGzThrowableShieldData::InitAttributesEffect' has a wrong offset!");
static_assert(offsetof(UGzThrowableShieldData, DamageEffect) == 0x000068, "Member 'UGzThrowableShieldData::DamageEffect' has a wrong offset!");
static_assert(offsetof(UGzThrowableShieldData, bApplyStunToTarget) == 0x000070, "Member 'UGzThrowableShieldData::bApplyStunToTarget' has a wrong offset!");
static_assert(offsetof(UGzThrowableShieldData, StunDuration) == 0x000074, "Member 'UGzThrowableShieldData::StunDuration' has a wrong offset!");
static_assert(offsetof(UGzThrowableShieldData, bApplyRotationOffsetOnLaunch) == 0x000078, "Member 'UGzThrowableShieldData::bApplyRotationOffsetOnLaunch' has a wrong offset!");
static_assert(offsetof(UGzThrowableShieldData, RotationOffset) == 0x000080, "Member 'UGzThrowableShieldData::RotationOffset' has a wrong offset!");
static_assert(offsetof(UGzThrowableShieldData, RotationInterpSpeed) == 0x000098, "Member 'UGzThrowableShieldData::RotationInterpSpeed' has a wrong offset!");
static_assert(offsetof(UGzThrowableShieldData, bUseCharge) == 0x00009C, "Member 'UGzThrowableShieldData::bUseCharge' has a wrong offset!");
static_assert(offsetof(UGzThrowableShieldData, FullChargeTime) == 0x0000A0, "Member 'UGzThrowableShieldData::FullChargeTime' has a wrong offset!");
static_assert(offsetof(UGzThrowableShieldData, MovementParams) == 0x0000A4, "Member 'UGzThrowableShieldData::MovementParams' has a wrong offset!");
static_assert(offsetof(UGzThrowableShieldData, MovementParams_Charged) == 0x0000B0, "Member 'UGzThrowableShieldData::MovementParams_Charged' has a wrong offset!");
static_assert(offsetof(UGzThrowableShieldData, LaunchedShieldCollisionProfileName) == 0x0000BC, "Member 'UGzThrowableShieldData::LaunchedShieldCollisionProfileName' has a wrong offset!");
static_assert(offsetof(UGzThrowableShieldData, MinDistanceToCompleteReturn) == 0x0000C4, "Member 'UGzThrowableShieldData::MinDistanceToCompleteReturn' has a wrong offset!");
static_assert(offsetof(UGzThrowableShieldData, DeactivationTimeAfterReturn) == 0x0000C8, "Member 'UGzThrowableShieldData::DeactivationTimeAfterReturn' has a wrong offset!");
static_assert(offsetof(UGzThrowableShieldData, MaxDistanceToStartAutoReturn) == 0x0000CC, "Member 'UGzThrowableShieldData::MaxDistanceToStartAutoReturn' has a wrong offset!");
static_assert(offsetof(UGzThrowableShieldData, TargetPreviewActorClass) == 0x0000D0, "Member 'UGzThrowableShieldData::TargetPreviewActorClass' has a wrong offset!");
static_assert(offsetof(UGzThrowableShieldData, ShieldProjectileRadius) == 0x0000D8, "Member 'UGzThrowableShieldData::ShieldProjectileRadius' has a wrong offset!");
static_assert(offsetof(UGzThrowableShieldData, MaxSimulationTime) == 0x0000DC, "Member 'UGzThrowableShieldData::MaxSimulationTime' has a wrong offset!");

// Class G01.GzThrowPathActor
// 0x0100 (0x0590 - 0x0490)
class AGzThrowPathActor : public AGzPreviewPathActor
{
public:
	int32                                         BouncePredictionCount;                             // 0x0490(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3532[0xFC];                                    // 0x0494(0x00FC)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void CalculateProjectileTransform();
	void GetSourceLocationAndDirection(struct FVector* OutLocation, struct FVector* OutDirection);
	void GetSourceTransform(struct FTransform* OutTransform);
	void Initialize(const class UGzProjectileData* InProjectileData, float InTargetThrowDistance, float InThrowCurveAddedAngle, float InMaxThrowAngle, class FName InAttachSocketName);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzThrowPathActor">();
	}
	static class AGzThrowPathActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<AGzThrowPathActor>();
	}
};
static_assert(alignof(AGzThrowPathActor) == 0x000008, "Wrong alignment on AGzThrowPathActor");
static_assert(sizeof(AGzThrowPathActor) == 0x000590, "Wrong size on AGzThrowPathActor");
static_assert(offsetof(AGzThrowPathActor, BouncePredictionCount) == 0x000490, "Member 'AGzThrowPathActor::BouncePredictionCount' has a wrong offset!");

// Class G01.GzTimerCondition
// 0x0008 (0x00A0 - 0x0098)
class UGzTimerCondition final : public UGzGameplayCondition
{
public:
	float                                         StartTime;                                         // 0x0098(0x0004)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3534[0x4];                                     // 0x009C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnActivateTimer();
	void OnDeactivateTimer();
	void RestartTimer();

	float GetDuration() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzTimerCondition">();
	}
	static class UGzTimerCondition* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzTimerCondition>();
	}
};
static_assert(alignof(UGzTimerCondition) == 0x000008, "Wrong alignment on UGzTimerCondition");
static_assert(sizeof(UGzTimerCondition) == 0x0000A0, "Wrong size on UGzTimerCondition");
static_assert(offsetof(UGzTimerCondition, StartTime) == 0x000098, "Member 'UGzTimerCondition::StartTime' has a wrong offset!");

// Class G01.GzToxicSmokePropagation
// 0x0010 (0x0498 - 0x0488)
class AGzToxicSmokePropagation : public AGzPropagationActor
{
public:
	TSubclassOf<class UGzGE_BaseDamage>           DamageEffectClass;                                 // 0x0488(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UGzBodyPartAbilityData_ToxicSmoke*      ToxicSmokeAbilityData;                             // 0x0490(0x0008)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	struct FActiveGameplayEffectHandle ApplyDamageEffect(class UAbilitySystemComponent* TargetASC);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzToxicSmokePropagation">();
	}
	static class AGzToxicSmokePropagation* GetDefaultObj()
	{
		return GetDefaultObjImpl<AGzToxicSmokePropagation>();
	}
};
static_assert(alignof(AGzToxicSmokePropagation) == 0x000008, "Wrong alignment on AGzToxicSmokePropagation");
static_assert(sizeof(AGzToxicSmokePropagation) == 0x000498, "Wrong size on AGzToxicSmokePropagation");
static_assert(offsetof(AGzToxicSmokePropagation, DamageEffectClass) == 0x000488, "Member 'AGzToxicSmokePropagation::DamageEffectClass' has a wrong offset!");
static_assert(offsetof(AGzToxicSmokePropagation, ToxicSmokeAbilityData) == 0x000490, "Member 'AGzToxicSmokePropagation::ToxicSmokeAbilityData' has a wrong offset!");

// Class G01.GzTrackedMissionFilter
// 0x0000 (0x0038 - 0x0038)
class UGzTrackedMissionFilter final : public UGzMarkerActiveStateFilter
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzTrackedMissionFilter">();
	}
	static class UGzTrackedMissionFilter* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzTrackedMissionFilter>();
	}
};
static_assert(alignof(UGzTrackedMissionFilter) == 0x000008, "Wrong alignment on UGzTrackedMissionFilter");
static_assert(sizeof(UGzTrackedMissionFilter) == 0x000038, "Wrong size on UGzTrackedMissionFilter");

// Class G01.GzTrackedPathsHolder
// 0x0040 (0x0070 - 0x0030)
class UGzTrackedPathsHolder final : public ULocalPlayerSubsystem
{
public:
	uint8                                         Pad_3535[0x30];                                    // 0x0030(0x0030)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UGzPathTrackingComponent*>       TrackedPaths;                                      // 0x0060(0x0010)(ExportObject, ZeroConstructor, Transient, ContainsInstancedReference, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzTrackedPathsHolder">();
	}
	static class UGzTrackedPathsHolder* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzTrackedPathsHolder>();
	}
};
static_assert(alignof(UGzTrackedPathsHolder) == 0x000008, "Wrong alignment on UGzTrackedPathsHolder");
static_assert(sizeof(UGzTrackedPathsHolder) == 0x000070, "Wrong size on UGzTrackedPathsHolder");
static_assert(offsetof(UGzTrackedPathsHolder, TrackedPaths) == 0x000060, "Member 'UGzTrackedPathsHolder::TrackedPaths' has a wrong offset!");

// Class G01.GzTrackEventBase
// 0x0000 (0x0028 - 0x0028)
class UGzTrackEventBase : public UObject
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzTrackEventBase">();
	}
	static class UGzTrackEventBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzTrackEventBase>();
	}
};
static_assert(alignof(UGzTrackEventBase) == 0x000008, "Wrong alignment on UGzTrackEventBase");
static_assert(sizeof(UGzTrackEventBase) == 0x000028, "Wrong size on UGzTrackEventBase");

// Class G01.GzTrackEventDeploymentAvailability
// 0x0008 (0x0030 - 0x0028)
class UGzTrackEventDeploymentAvailability final : public UGzTrackEventBase
{
public:
	bool                                          bDeploymentAllowed;                                // 0x0028(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3536[0x7];                                     // 0x0029(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzTrackEventDeploymentAvailability">();
	}
	static class UGzTrackEventDeploymentAvailability* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzTrackEventDeploymentAvailability>();
	}
};
static_assert(alignof(UGzTrackEventDeploymentAvailability) == 0x000008, "Wrong alignment on UGzTrackEventDeploymentAvailability");
static_assert(sizeof(UGzTrackEventDeploymentAvailability) == 0x000030, "Wrong size on UGzTrackEventDeploymentAvailability");
static_assert(offsetof(UGzTrackEventDeploymentAvailability, bDeploymentAllowed) == 0x000028, "Member 'UGzTrackEventDeploymentAvailability::bDeploymentAllowed' has a wrong offset!");

// Class G01.GzTradeRateBuyValidationComponent
// 0x0000 (0x00E8 - 0x00E8)
class UGzTradeRateBuyValidationComponent final : public UGzTradeRateValidationComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzTradeRateBuyValidationComponent">();
	}
	static class UGzTradeRateBuyValidationComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzTradeRateBuyValidationComponent>();
	}
};
static_assert(alignof(UGzTradeRateBuyValidationComponent) == 0x000008, "Wrong alignment on UGzTradeRateBuyValidationComponent");
static_assert(sizeof(UGzTradeRateBuyValidationComponent) == 0x0000E8, "Wrong size on UGzTradeRateBuyValidationComponent");

// Class G01.GzTradeRateSellValidationComponent
// 0x0000 (0x00E8 - 0x00E8)
class UGzTradeRateSellValidationComponent final : public UGzTradeRateValidationComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzTradeRateSellValidationComponent">();
	}
	static class UGzTradeRateSellValidationComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzTradeRateSellValidationComponent>();
	}
};
static_assert(alignof(UGzTradeRateSellValidationComponent) == 0x000008, "Wrong alignment on UGzTradeRateSellValidationComponent");
static_assert(sizeof(UGzTradeRateSellValidationComponent) == 0x0000E8, "Wrong size on UGzTradeRateSellValidationComponent");

// Class G01.GzTransactionHistoryReaderComponent
// 0x0040 (0x00E0 - 0x00A0)
class UGzTransactionHistoryReaderComponent final : public UGzServiceComponent
{
public:
	uint8                                         Pad_3537[0x40];                                    // 0x00A0(0x0040)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzTransactionHistoryReaderComponent">();
	}
	static class UGzTransactionHistoryReaderComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzTransactionHistoryReaderComponent>();
	}
};
static_assert(alignof(UGzTransactionHistoryReaderComponent) == 0x000008, "Wrong alignment on UGzTransactionHistoryReaderComponent");
static_assert(sizeof(UGzTransactionHistoryReaderComponent) == 0x0000E0, "Wrong size on UGzTransactionHistoryReaderComponent");

// Class G01.GzTravelFromOnlineSessionState
// 0x0008 (0x0068 - 0x0060)
class UGzTravelFromOnlineSessionState final : public UGzFlowState
{
public:
	uint8                                         Pad_3538[0x8];                                     // 0x0060(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzTravelFromOnlineSessionState">();
	}
	static class UGzTravelFromOnlineSessionState* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzTravelFromOnlineSessionState>();
	}
};
static_assert(alignof(UGzTravelFromOnlineSessionState) == 0x000008, "Wrong alignment on UGzTravelFromOnlineSessionState");
static_assert(sizeof(UGzTravelFromOnlineSessionState) == 0x000068, "Wrong size on UGzTravelFromOnlineSessionState");

// Class G01.GzTravelToOnlineSessionState
// 0x0010 (0x0070 - 0x0060)
class UGzTravelToOnlineSessionState final : public UGzFlowState
{
public:
	uint8                                         Pad_3539[0x10];                                    // 0x0060(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzTravelToOnlineSessionState">();
	}
	static class UGzTravelToOnlineSessionState* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzTravelToOnlineSessionState>();
	}
};
static_assert(alignof(UGzTravelToOnlineSessionState) == 0x000008, "Wrong alignment on UGzTravelToOnlineSessionState");
static_assert(sizeof(UGzTravelToOnlineSessionState) == 0x000070, "Wrong size on UGzTravelToOnlineSessionState");

// Class G01.GzPreClimbAnimMetaData
// 0x0000 (0x0038 - 0x0038)
class UGzPreClimbAnimMetaData final : public UGzTraversalAnimMetaData
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzPreClimbAnimMetaData">();
	}
	static class UGzPreClimbAnimMetaData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzPreClimbAnimMetaData>();
	}
};
static_assert(alignof(UGzPreClimbAnimMetaData) == 0x000008, "Wrong alignment on UGzPreClimbAnimMetaData");
static_assert(sizeof(UGzPreClimbAnimMetaData) == 0x000038, "Wrong size on UGzPreClimbAnimMetaData");

// Class G01.GzClimbUpAnimMetaData
// 0x0000 (0x0038 - 0x0038)
class UGzClimbUpAnimMetaData final : public UGzTraversalAnimMetaData
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzClimbUpAnimMetaData">();
	}
	static class UGzClimbUpAnimMetaData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzClimbUpAnimMetaData>();
	}
};
static_assert(alignof(UGzClimbUpAnimMetaData) == 0x000008, "Wrong alignment on UGzClimbUpAnimMetaData");
static_assert(sizeof(UGzClimbUpAnimMetaData) == 0x000038, "Wrong size on UGzClimbUpAnimMetaData");

// Class G01.GzClimbOnAnimMetaData
// 0x0008 (0x0040 - 0x0038)
class UGzClimbOnAnimMetaData final : public UGzTraversalAnimMetaData
{
public:
	EGzTraversalMovementState                     EndState;                                          // 0x0038(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_353A[0x7];                                     // 0x0039(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzClimbOnAnimMetaData">();
	}
	static class UGzClimbOnAnimMetaData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzClimbOnAnimMetaData>();
	}
};
static_assert(alignof(UGzClimbOnAnimMetaData) == 0x000008, "Wrong alignment on UGzClimbOnAnimMetaData");
static_assert(sizeof(UGzClimbOnAnimMetaData) == 0x000040, "Wrong size on UGzClimbOnAnimMetaData");
static_assert(offsetof(UGzClimbOnAnimMetaData, EndState) == 0x000038, "Member 'UGzClimbOnAnimMetaData::EndState' has a wrong offset!");

// Class G01.GzTrialSubsystem
// 0x0030 (0x02D0 - 0x02A0)
class AGzTrialSubsystem final : public AGzGameModeSubsystem
{
public:
	TArray<struct FGzGameplayTrialsCollection>    PlayersTrialsProgress;                             // 0x02A0(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	TArray<class UGzTrialTracker*>                RegisteredTrackers;                                // 0x02B0(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	TArray<class UGzTrialsControllerComponent*>   RegisteredComponents;                              // 0x02C0(0x0010)(ExportObject, ZeroConstructor, Transient, ContainsInstancedReference, NativeAccessSpecifierPrivate)

public:
	void StartTrials();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzTrialSubsystem">();
	}
	static class AGzTrialSubsystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<AGzTrialSubsystem>();
	}
};
static_assert(alignof(AGzTrialSubsystem) == 0x000008, "Wrong alignment on AGzTrialSubsystem");
static_assert(sizeof(AGzTrialSubsystem) == 0x0002D0, "Wrong size on AGzTrialSubsystem");
static_assert(offsetof(AGzTrialSubsystem, PlayersTrialsProgress) == 0x0002A0, "Member 'AGzTrialSubsystem::PlayersTrialsProgress' has a wrong offset!");
static_assert(offsetof(AGzTrialSubsystem, RegisteredTrackers) == 0x0002B0, "Member 'AGzTrialSubsystem::RegisteredTrackers' has a wrong offset!");
static_assert(offsetof(AGzTrialSubsystem, RegisteredComponents) == 0x0002C0, "Member 'AGzTrialSubsystem::RegisteredComponents' has a wrong offset!");

// Class G01.GzTrialSubsystemCheatExtension
// 0x0000 (0x0028 - 0x0028)
class UGzTrialSubsystemCheatExtension final : public UGzCheatManagerExtension
{
public:
	void AddTrialProgress(const class FName& TrialId, const float ProgressToAdd);
	void EnableDebugTrialTracking(const class FName& TrialId);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzTrialSubsystemCheatExtension">();
	}
	static class UGzTrialSubsystemCheatExtension* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzTrialSubsystemCheatExtension>();
	}
};
static_assert(alignof(UGzTrialSubsystemCheatExtension) == 0x000008, "Wrong alignment on UGzTrialSubsystemCheatExtension");
static_assert(sizeof(UGzTrialSubsystemCheatExtension) == 0x000028, "Wrong size on UGzTrialSubsystemCheatExtension");

// Class G01.LocomotionMantleAsset
// 0x00C0 (0x00F0 - 0x0030)
class ULocomotionMantleAsset final : public UDataAsset
{
public:
	bool                                          bIsEnabled;                                        // 0x0030(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ELocomotionMantleType                         Type;                                              // 0x0031(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_353B[0x6];                                     // 0x0032(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class UBlendSpace*                            BlendSpace2D;                                      // 0x0038(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBlendSpace*                            BlendSpace2DExit;                                  // 0x0040(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBlendSpace*                            BlendSpace2DFall;                                  // 0x0048(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimMontage*                           Montage;                                           // 0x0050(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimMontage*                           MontageMin;                                        // 0x0058(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimMontage*                           MontageFall;                                       // 0x0060(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCurveVector*                           PositionAndCorrectionCurve;                        // 0x0068(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                StartingOffset;                                    // 0x0070(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AnimationStartPosition;                            // 0x0088(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Priority;                                          // 0x008C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AnimationDepth;                                    // 0x0090(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AnimationEndPosition;                              // 0x0094(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LowHeight;                                         // 0x0098(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HighHeight;                                        // 0x009C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinDistance;                                       // 0x00A0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxDistance;                                       // 0x00A4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinThickness;                                      // 0x00A8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxThickness;                                      // 0x00AC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDoAngleCheck;                                     // 0x00B0(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_353C[0x3];                                     // 0x00B1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MinVerticalAngle;                                  // 0x00B4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxVerticalAngle;                                  // 0x00B8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDoAltitudeCheck;                                  // 0x00BC(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_353D[0x3];                                     // 0x00BD(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MinAltitude;                                       // 0x00C0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDoSpeedCheck;                                     // 0x00C4(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_353E[0x3];                                     // 0x00C5(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MinSpeed;                                          // 0x00C8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxSpeed;                                          // 0x00CC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinAllowedFallHeight;                              // 0x00D0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         OverrideAnimationEndPositionForNotBlendableFallHeight; // 0x00D4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinBlendableFallHeight;                            // 0x00D8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxBlendableFallHeight;                            // 0x00DC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BlendTimeIn;                                       // 0x00E0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BlendTimeOut;                                      // 0x00E4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSaveInputDirection;                               // 0x00E8(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_353F[0x7];                                     // 0x00E9(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LocomotionMantleAsset">();
	}
	static class ULocomotionMantleAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULocomotionMantleAsset>();
	}
};
static_assert(alignof(ULocomotionMantleAsset) == 0x000008, "Wrong alignment on ULocomotionMantleAsset");
static_assert(sizeof(ULocomotionMantleAsset) == 0x0000F0, "Wrong size on ULocomotionMantleAsset");
static_assert(offsetof(ULocomotionMantleAsset, bIsEnabled) == 0x000030, "Member 'ULocomotionMantleAsset::bIsEnabled' has a wrong offset!");
static_assert(offsetof(ULocomotionMantleAsset, Type) == 0x000031, "Member 'ULocomotionMantleAsset::Type' has a wrong offset!");
static_assert(offsetof(ULocomotionMantleAsset, BlendSpace2D) == 0x000038, "Member 'ULocomotionMantleAsset::BlendSpace2D' has a wrong offset!");
static_assert(offsetof(ULocomotionMantleAsset, BlendSpace2DExit) == 0x000040, "Member 'ULocomotionMantleAsset::BlendSpace2DExit' has a wrong offset!");
static_assert(offsetof(ULocomotionMantleAsset, BlendSpace2DFall) == 0x000048, "Member 'ULocomotionMantleAsset::BlendSpace2DFall' has a wrong offset!");
static_assert(offsetof(ULocomotionMantleAsset, Montage) == 0x000050, "Member 'ULocomotionMantleAsset::Montage' has a wrong offset!");
static_assert(offsetof(ULocomotionMantleAsset, MontageMin) == 0x000058, "Member 'ULocomotionMantleAsset::MontageMin' has a wrong offset!");
static_assert(offsetof(ULocomotionMantleAsset, MontageFall) == 0x000060, "Member 'ULocomotionMantleAsset::MontageFall' has a wrong offset!");
static_assert(offsetof(ULocomotionMantleAsset, PositionAndCorrectionCurve) == 0x000068, "Member 'ULocomotionMantleAsset::PositionAndCorrectionCurve' has a wrong offset!");
static_assert(offsetof(ULocomotionMantleAsset, StartingOffset) == 0x000070, "Member 'ULocomotionMantleAsset::StartingOffset' has a wrong offset!");
static_assert(offsetof(ULocomotionMantleAsset, AnimationStartPosition) == 0x000088, "Member 'ULocomotionMantleAsset::AnimationStartPosition' has a wrong offset!");
static_assert(offsetof(ULocomotionMantleAsset, Priority) == 0x00008C, "Member 'ULocomotionMantleAsset::Priority' has a wrong offset!");
static_assert(offsetof(ULocomotionMantleAsset, AnimationDepth) == 0x000090, "Member 'ULocomotionMantleAsset::AnimationDepth' has a wrong offset!");
static_assert(offsetof(ULocomotionMantleAsset, AnimationEndPosition) == 0x000094, "Member 'ULocomotionMantleAsset::AnimationEndPosition' has a wrong offset!");
static_assert(offsetof(ULocomotionMantleAsset, LowHeight) == 0x000098, "Member 'ULocomotionMantleAsset::LowHeight' has a wrong offset!");
static_assert(offsetof(ULocomotionMantleAsset, HighHeight) == 0x00009C, "Member 'ULocomotionMantleAsset::HighHeight' has a wrong offset!");
static_assert(offsetof(ULocomotionMantleAsset, MinDistance) == 0x0000A0, "Member 'ULocomotionMantleAsset::MinDistance' has a wrong offset!");
static_assert(offsetof(ULocomotionMantleAsset, MaxDistance) == 0x0000A4, "Member 'ULocomotionMantleAsset::MaxDistance' has a wrong offset!");
static_assert(offsetof(ULocomotionMantleAsset, MinThickness) == 0x0000A8, "Member 'ULocomotionMantleAsset::MinThickness' has a wrong offset!");
static_assert(offsetof(ULocomotionMantleAsset, MaxThickness) == 0x0000AC, "Member 'ULocomotionMantleAsset::MaxThickness' has a wrong offset!");
static_assert(offsetof(ULocomotionMantleAsset, bDoAngleCheck) == 0x0000B0, "Member 'ULocomotionMantleAsset::bDoAngleCheck' has a wrong offset!");
static_assert(offsetof(ULocomotionMantleAsset, MinVerticalAngle) == 0x0000B4, "Member 'ULocomotionMantleAsset::MinVerticalAngle' has a wrong offset!");
static_assert(offsetof(ULocomotionMantleAsset, MaxVerticalAngle) == 0x0000B8, "Member 'ULocomotionMantleAsset::MaxVerticalAngle' has a wrong offset!");
static_assert(offsetof(ULocomotionMantleAsset, bDoAltitudeCheck) == 0x0000BC, "Member 'ULocomotionMantleAsset::bDoAltitudeCheck' has a wrong offset!");
static_assert(offsetof(ULocomotionMantleAsset, MinAltitude) == 0x0000C0, "Member 'ULocomotionMantleAsset::MinAltitude' has a wrong offset!");
static_assert(offsetof(ULocomotionMantleAsset, bDoSpeedCheck) == 0x0000C4, "Member 'ULocomotionMantleAsset::bDoSpeedCheck' has a wrong offset!");
static_assert(offsetof(ULocomotionMantleAsset, MinSpeed) == 0x0000C8, "Member 'ULocomotionMantleAsset::MinSpeed' has a wrong offset!");
static_assert(offsetof(ULocomotionMantleAsset, MaxSpeed) == 0x0000CC, "Member 'ULocomotionMantleAsset::MaxSpeed' has a wrong offset!");
static_assert(offsetof(ULocomotionMantleAsset, MinAllowedFallHeight) == 0x0000D0, "Member 'ULocomotionMantleAsset::MinAllowedFallHeight' has a wrong offset!");
static_assert(offsetof(ULocomotionMantleAsset, OverrideAnimationEndPositionForNotBlendableFallHeight) == 0x0000D4, "Member 'ULocomotionMantleAsset::OverrideAnimationEndPositionForNotBlendableFallHeight' has a wrong offset!");
static_assert(offsetof(ULocomotionMantleAsset, MinBlendableFallHeight) == 0x0000D8, "Member 'ULocomotionMantleAsset::MinBlendableFallHeight' has a wrong offset!");
static_assert(offsetof(ULocomotionMantleAsset, MaxBlendableFallHeight) == 0x0000DC, "Member 'ULocomotionMantleAsset::MaxBlendableFallHeight' has a wrong offset!");
static_assert(offsetof(ULocomotionMantleAsset, BlendTimeIn) == 0x0000E0, "Member 'ULocomotionMantleAsset::BlendTimeIn' has a wrong offset!");
static_assert(offsetof(ULocomotionMantleAsset, BlendTimeOut) == 0x0000E4, "Member 'ULocomotionMantleAsset::BlendTimeOut' has a wrong offset!");
static_assert(offsetof(ULocomotionMantleAsset, bSaveInputDirection) == 0x0000E8, "Member 'ULocomotionMantleAsset::bSaveInputDirection' has a wrong offset!");

// Class G01.GzTurretWeaponActor
// 0x0018 (0x03E0 - 0x03C8)
class AGzTurretWeaponActor final : public AGzWeaponActor
{
public:
	uint8                                         Pad_3540[0x10];                                    // 0x03C8(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class UGzTurretComponent*                     ParentTurretComponent;                             // 0x03D8(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void GzTurretOwnerChanged__DelegateSignature(class AActor* NewActor);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzTurretWeaponActor">();
	}
	static class AGzTurretWeaponActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<AGzTurretWeaponActor>();
	}
};
static_assert(alignof(AGzTurretWeaponActor) == 0x000008, "Wrong alignment on AGzTurretWeaponActor");
static_assert(sizeof(AGzTurretWeaponActor) == 0x0003E0, "Wrong size on AGzTurretWeaponActor");
static_assert(offsetof(AGzTurretWeaponActor, ParentTurretComponent) == 0x0003D8, "Member 'AGzTurretWeaponActor::ParentTurretComponent' has a wrong offset!");

// Class G01.GzUIBlueprintFunctionLibrary
// 0x0000 (0x0028 - 0x0028)
class UGzUIBlueprintFunctionLibrary final : public UBlueprintFunctionLibrary
{
public:
	static struct FTextBlockStyle FindFontSettingsInRichTextBox(class URichTextBlock* Rich, const class FName FontID, bool* OutSuccessful);
	static struct FLinearColor GetColorById(const class FName ColorID);
	static struct FLinearColor GetDefaultErrorColor();
	static class UWidget* GetFocusedUMGWidget();
	static struct FVector2D GetGeometryCenter(class UObject* WorldContextObject, const struct FGeometry& Geometry);
	static bool GetKeyBrush(const class UObject* WorldContextObject, struct FSlateBrush* OutBrush, const struct FKey& Key);
	static TArray<class UClass*> GetLoadedHUDComponents();
	static struct FLinearColor GetTeammateColorFromIndex(int32 InPlayerIndex);
	static class FString GetWatermarkTextTemplate();
	static bool IsVisibleInHierarchy(class UWidget* Widget);
	static void SetCanvasSlotPosition(class UCanvasPanelSlot* Slot, const struct FVector2D& Position);
	static void SetRenderAngle(class UWidget* Widget, float Angle);
	static void SetRenderScale(class UWidget* Widget, const struct FVector2D& Scale);
	static void SetRenderTranslation(class UWidget* Widget, const struct FVector2D& Translation);
	static void SetVisibility(class UWidget* Widget, ESlateVisibility InVisibility);
	static bool ShouldDisplayPlayerIdEncoding();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzUIBlueprintFunctionLibrary">();
	}
	static class UGzUIBlueprintFunctionLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzUIBlueprintFunctionLibrary>();
	}
};
static_assert(alignof(UGzUIBlueprintFunctionLibrary) == 0x000008, "Wrong alignment on UGzUIBlueprintFunctionLibrary");
static_assert(sizeof(UGzUIBlueprintFunctionLibrary) == 0x000028, "Wrong size on UGzUIBlueprintFunctionLibrary");

// Class G01.GzUISettings
// 0x0350 (0x0388 - 0x0038)
class UGzUISettings final : public UDeveloperSettings
{
public:
	TSoftObjectPtr<class UGzHUDRuntimeSettings>   HUDRuntimeSettings;                                // 0x0038(0x0028)(Edit, Config, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftClassPtr<class UClass>                   DefaultHUDViewClass;                               // 0x0060(0x0028)(Edit, Config, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftClassPtr<class UClass>                   DebugInfoWidget;                                   // 0x0088(0x0028)(Edit, Config, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftClassPtr<class UClass>                   DefaultLoadingScreenClass;                         // 0x00B0(0x0028)(Edit, Config, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftClassPtr<class UClass>                   AssetsLoadingScreenClass;                          // 0x00D8(0x0028)(Edit, Config, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMap<EGzFlowState, TSoftClassPtr<class UClass>> StateLoadingScreens;                               // 0x0100(0x0050)(Edit, Config, UObjectWrapper, NativeAccessSpecifierPublic)
	TSoftClassPtr<class UClass>                   NavigationRootClass;                               // 0x0150(0x0028)(Edit, Config, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftClassPtr<class UClass>                   ClosedBetaWatermarkWidgetClass;                    // 0x0178(0x0028)(Edit, Config, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftClassPtr<class UClass>                   OpenBetaWatermarkWidgetClass;                      // 0x01A0(0x0028)(Edit, Config, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class FName>                           NavigationLayers;                                  // 0x01C8(0x0010)(Edit, ZeroConstructor, Config, NativeAccessSpecifierPublic)
	float                                         BulletUIRangeTolerance;                            // 0x01D8(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3547[0x4];                                     // 0x01DC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftObjectPtr<class UGzMarkersSettingAsset>  MarkersSettingAsset;                               // 0x01E0(0x0028)(Edit, Config, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TargetMinimapWorldWidth;                           // 0x0208(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3548[0x4];                                     // 0x020C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<EGzItemRarity, struct FLinearColor>      ItemQualityColors;                                 // 0x0210(0x0050)(Edit, Config, NativeAccessSpecifierPublic)
	TArray<struct FLinearColor>                   TeammateColors;                                    // 0x0260(0x0010)(Edit, ZeroConstructor, Config, NativeAccessSpecifierPublic)
	struct FLinearColor                           TeammateFallbackColor;                             // 0x0270(0x0010)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UGzTextStylesDataAsset>  TextStyleSettingsClass;                            // 0x0280(0x0028)(Edit, Config, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UGzTextStylesDataAsset*                 LoadedTextStylesAsset;                             // 0x02A8(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UGzButtonSoundData>      DefaultButtonSoundData;                            // 0x02B0(0x0028)(Edit, Config, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMap<class FName, struct FLinearColor>        TextColors;                                        // 0x02D8(0x0050)(Edit, Config, NativeAccessSpecifierPublic)
	struct FLinearColor                           DefaultErrorColor;                                 // 0x0328(0x0010)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMap<class FName, struct FLinearColor>        Colors;                                            // 0x0338(0x0050)(Edit, Config, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzUISettings">();
	}
	static class UGzUISettings* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzUISettings>();
	}
};
static_assert(alignof(UGzUISettings) == 0x000008, "Wrong alignment on UGzUISettings");
static_assert(sizeof(UGzUISettings) == 0x000388, "Wrong size on UGzUISettings");
static_assert(offsetof(UGzUISettings, HUDRuntimeSettings) == 0x000038, "Member 'UGzUISettings::HUDRuntimeSettings' has a wrong offset!");
static_assert(offsetof(UGzUISettings, DefaultHUDViewClass) == 0x000060, "Member 'UGzUISettings::DefaultHUDViewClass' has a wrong offset!");
static_assert(offsetof(UGzUISettings, DebugInfoWidget) == 0x000088, "Member 'UGzUISettings::DebugInfoWidget' has a wrong offset!");
static_assert(offsetof(UGzUISettings, DefaultLoadingScreenClass) == 0x0000B0, "Member 'UGzUISettings::DefaultLoadingScreenClass' has a wrong offset!");
static_assert(offsetof(UGzUISettings, AssetsLoadingScreenClass) == 0x0000D8, "Member 'UGzUISettings::AssetsLoadingScreenClass' has a wrong offset!");
static_assert(offsetof(UGzUISettings, StateLoadingScreens) == 0x000100, "Member 'UGzUISettings::StateLoadingScreens' has a wrong offset!");
static_assert(offsetof(UGzUISettings, NavigationRootClass) == 0x000150, "Member 'UGzUISettings::NavigationRootClass' has a wrong offset!");
static_assert(offsetof(UGzUISettings, ClosedBetaWatermarkWidgetClass) == 0x000178, "Member 'UGzUISettings::ClosedBetaWatermarkWidgetClass' has a wrong offset!");
static_assert(offsetof(UGzUISettings, OpenBetaWatermarkWidgetClass) == 0x0001A0, "Member 'UGzUISettings::OpenBetaWatermarkWidgetClass' has a wrong offset!");
static_assert(offsetof(UGzUISettings, NavigationLayers) == 0x0001C8, "Member 'UGzUISettings::NavigationLayers' has a wrong offset!");
static_assert(offsetof(UGzUISettings, BulletUIRangeTolerance) == 0x0001D8, "Member 'UGzUISettings::BulletUIRangeTolerance' has a wrong offset!");
static_assert(offsetof(UGzUISettings, MarkersSettingAsset) == 0x0001E0, "Member 'UGzUISettings::MarkersSettingAsset' has a wrong offset!");
static_assert(offsetof(UGzUISettings, TargetMinimapWorldWidth) == 0x000208, "Member 'UGzUISettings::TargetMinimapWorldWidth' has a wrong offset!");
static_assert(offsetof(UGzUISettings, ItemQualityColors) == 0x000210, "Member 'UGzUISettings::ItemQualityColors' has a wrong offset!");
static_assert(offsetof(UGzUISettings, TeammateColors) == 0x000260, "Member 'UGzUISettings::TeammateColors' has a wrong offset!");
static_assert(offsetof(UGzUISettings, TeammateFallbackColor) == 0x000270, "Member 'UGzUISettings::TeammateFallbackColor' has a wrong offset!");
static_assert(offsetof(UGzUISettings, TextStyleSettingsClass) == 0x000280, "Member 'UGzUISettings::TextStyleSettingsClass' has a wrong offset!");
static_assert(offsetof(UGzUISettings, LoadedTextStylesAsset) == 0x0002A8, "Member 'UGzUISettings::LoadedTextStylesAsset' has a wrong offset!");
static_assert(offsetof(UGzUISettings, DefaultButtonSoundData) == 0x0002B0, "Member 'UGzUISettings::DefaultButtonSoundData' has a wrong offset!");
static_assert(offsetof(UGzUISettings, TextColors) == 0x0002D8, "Member 'UGzUISettings::TextColors' has a wrong offset!");
static_assert(offsetof(UGzUISettings, DefaultErrorColor) == 0x000328, "Member 'UGzUISettings::DefaultErrorColor' has a wrong offset!");
static_assert(offsetof(UGzUISettings, Colors) == 0x000338, "Member 'UGzUISettings::Colors' has a wrong offset!");

// Class G01.GzUiStatLimitSettings
// 0x0040 (0x0078 - 0x0038)
class UGzUiStatLimitSettings final : public UDeveloperSettings
{
public:
	struct FGzUiStatLimits                        AccuracyLimits;                                    // 0x0038(0x0008)(Edit, Config, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	struct FGzUiStatLimits                        HandlingLimits;                                    // 0x0040(0x0008)(Edit, Config, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	struct FGzUiStatLimits                        RecoilLimits;                                      // 0x0048(0x0008)(Edit, Config, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	struct FGzUiStatLimits                        DamageLimits;                                      // 0x0050(0x0008)(Edit, Config, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	struct FGzUiStatLimits                        FireRateLimits;                                    // 0x0058(0x0008)(Edit, Config, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	struct FGzUiStatLimits                        RangeLimits;                                       // 0x0060(0x0008)(Edit, Config, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	struct FGzUiStatLimits                        MobilityLimits;                                    // 0x0068(0x0008)(Edit, Config, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	struct FGzUiStatLimits                        ClipSizeLimits;                                    // 0x0070(0x0008)(Edit, Config, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzUiStatLimitSettings">();
	}
	static class UGzUiStatLimitSettings* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzUiStatLimitSettings>();
	}
};
static_assert(alignof(UGzUiStatLimitSettings) == 0x000008, "Wrong alignment on UGzUiStatLimitSettings");
static_assert(sizeof(UGzUiStatLimitSettings) == 0x000078, "Wrong size on UGzUiStatLimitSettings");
static_assert(offsetof(UGzUiStatLimitSettings, AccuracyLimits) == 0x000038, "Member 'UGzUiStatLimitSettings::AccuracyLimits' has a wrong offset!");
static_assert(offsetof(UGzUiStatLimitSettings, HandlingLimits) == 0x000040, "Member 'UGzUiStatLimitSettings::HandlingLimits' has a wrong offset!");
static_assert(offsetof(UGzUiStatLimitSettings, RecoilLimits) == 0x000048, "Member 'UGzUiStatLimitSettings::RecoilLimits' has a wrong offset!");
static_assert(offsetof(UGzUiStatLimitSettings, DamageLimits) == 0x000050, "Member 'UGzUiStatLimitSettings::DamageLimits' has a wrong offset!");
static_assert(offsetof(UGzUiStatLimitSettings, FireRateLimits) == 0x000058, "Member 'UGzUiStatLimitSettings::FireRateLimits' has a wrong offset!");
static_assert(offsetof(UGzUiStatLimitSettings, RangeLimits) == 0x000060, "Member 'UGzUiStatLimitSettings::RangeLimits' has a wrong offset!");
static_assert(offsetof(UGzUiStatLimitSettings, MobilityLimits) == 0x000068, "Member 'UGzUiStatLimitSettings::MobilityLimits' has a wrong offset!");
static_assert(offsetof(UGzUiStatLimitSettings, ClipSizeLimits) == 0x000070, "Member 'UGzUiStatLimitSettings::ClipSizeLimits' has a wrong offset!");

// Class G01.GzUnityMatchmakingServiceStateGraceDelay
// 0x0018 (0x00D0 - 0x00B8)
class UGzUnityMatchmakingServiceStateGraceDelay final : public UGzUnityMatchmakingServiceState
{
public:
	uint8                                         Pad_3549[0x18];                                    // 0x00B8(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzUnityMatchmakingServiceStateGraceDelay">();
	}
	static class UGzUnityMatchmakingServiceStateGraceDelay* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzUnityMatchmakingServiceStateGraceDelay>();
	}
};
static_assert(alignof(UGzUnityMatchmakingServiceStateGraceDelay) == 0x000008, "Wrong alignment on UGzUnityMatchmakingServiceStateGraceDelay");
static_assert(sizeof(UGzUnityMatchmakingServiceStateGraceDelay) == 0x0000D0, "Wrong size on UGzUnityMatchmakingServiceStateGraceDelay");

// Class G01.GzUnityMatchmakingServiceStatePollingTicket
// 0x0038 (0x00F0 - 0x00B8)
class UGzUnityMatchmakingServiceStatePollingTicket final : public UGzUnityMatchmakingServiceState
{
public:
	uint8                                         Pad_354A[0x20];                                    // 0x00B8(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	class UGzUnityMatchmakingTicketPoller*        TicketPoller;                                      // 0x00D8(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_354B[0x10];                                    // 0x00E0(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnTicketStatusRequestError(const struct FUnityTicketStatusError& Error);
	void OnTicketStatusUpdate(const struct FUnityTicketStatusResult& Result);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzUnityMatchmakingServiceStatePollingTicket">();
	}
	static class UGzUnityMatchmakingServiceStatePollingTicket* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzUnityMatchmakingServiceStatePollingTicket>();
	}
};
static_assert(alignof(UGzUnityMatchmakingServiceStatePollingTicket) == 0x000008, "Wrong alignment on UGzUnityMatchmakingServiceStatePollingTicket");
static_assert(sizeof(UGzUnityMatchmakingServiceStatePollingTicket) == 0x0000F0, "Wrong size on UGzUnityMatchmakingServiceStatePollingTicket");
static_assert(offsetof(UGzUnityMatchmakingServiceStatePollingTicket, TicketPoller) == 0x0000D8, "Member 'UGzUnityMatchmakingServiceStatePollingTicket::TicketPoller' has a wrong offset!");

// Class G01.GzUnsafeArea
// 0x0008 (0x02A8 - 0x02A0)
class AGzUnsafeArea final : public AActor
{
public:
	double                                        Radius;                                            // 0x02A0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzUnsafeArea">();
	}
	static class AGzUnsafeArea* GetDefaultObj()
	{
		return GetDefaultObjImpl<AGzUnsafeArea>();
	}
};
static_assert(alignof(AGzUnsafeArea) == 0x000008, "Wrong alignment on AGzUnsafeArea");
static_assert(sizeof(AGzUnsafeArea) == 0x0002A8, "Wrong size on AGzUnsafeArea");
static_assert(offsetof(AGzUnsafeArea, Radius) == 0x0002A0, "Member 'AGzUnsafeArea::Radius' has a wrong offset!");

// Class G01.GzUserNotificationsModel
// 0x0000 (0x0070 - 0x0070)
class UGzUserNotificationsModel final : public UGzBackendModel
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzUserNotificationsModel">();
	}
	static class UGzUserNotificationsModel* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzUserNotificationsModel>();
	}
};
static_assert(alignof(UGzUserNotificationsModel) == 0x000008, "Wrong alignment on UGzUserNotificationsModel");
static_assert(sizeof(UGzUserNotificationsModel) == 0x000070, "Wrong size on UGzUserNotificationsModel");

// Class G01.GzVaultNavLink
// 0x0000 (0x0338 - 0x0338)
class AGzVaultNavLink final : public AGzAutoNavLink
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzVaultNavLink">();
	}
	static class AGzVaultNavLink* GetDefaultObj()
	{
		return GetDefaultObjImpl<AGzVaultNavLink>();
	}
};
static_assert(alignof(AGzVaultNavLink) == 0x000008, "Wrong alignment on AGzVaultNavLink");
static_assert(sizeof(AGzVaultNavLink) == 0x000338, "Wrong size on AGzVaultNavLink");

// Class G01.GzVehicle
// 0x0238 (0x0570 - 0x0338)
class AGzVehicle final : public AWheeledVehiclePawn
{
public:
	uint8                                         Pad_354C[0x48];                                    // 0x0338(0x0048)(Fixing Size After Last Property [ Dumper-7 ])
	FMulticastInlineDelegateProperty_             OnVehicleSeatChanged;                              // 0x0380(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnHornStateChanged;                                // 0x0390(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	class USceneComponent*                        CharacterCollisionParent;                          // 0x03A0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UStaticMeshComponent*                   CharacterOverlapMesh;                              // 0x03A8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UStaticMeshComponent*                   CharacterCollisionMesh;                            // 0x03B0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UGzAbilitySystemComponent*              AbilitySystemComponent;                            // 0x03B8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UGzDamageableComponent*                 DamageableComponent;                               // 0x03C0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UGzAliveObjectAttributeSet*             GzAliveObjectAttributeSet;                         // 0x03C8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, Net, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UGzInteractableComponent*               InteractableComponent;                             // 0x03D0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UGzVehicleEffectsComponent*             EffectsComponent;                                  // 0x03D8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UGzVehicleControlsComponent*            ControlsComponent;                                 // 0x03E0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FGenericTeamId                         TeamID;                                            // 0x03E8(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, Protected, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_354D[0x7];                                     // 0x03E9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UGzTurretComponent*                     VehicleTurretComponent;                            // 0x03F0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_354E[0x28];                                    // 0x03F8(0x0028)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bIsUpdatingVehicleState;                           // 0x0420(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_354F[0x7];                                     // 0x0421(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class AGzCharacter*>                   AttachedCharacters;                                // 0x0428(0x0010)(Net, ZeroConstructor, Transient, RepNotify, Protected, NativeAccessSpecifierProtected)
	bool                                          bWasDestroyed;                                     // 0x0438(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, Transient, EditConst, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3550[0x7];                                     // 0x0439(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	FMulticastInlineDelegateProperty_             OnVehicleIsDestroyedDelegate;                      // 0x0440(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, InstancedReference, BlueprintAssignable, Protected, NativeAccessSpecifierProtected)
	FMulticastInlineDelegateProperty_             OnVehicleWasDestroyedDelegate;                     // 0x0450(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, InstancedReference, BlueprintAssignable, Protected, NativeAccessSpecifierProtected)
	class UGzVehicleConfig*                       VehicleConfig;                                     // 0x0460(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3551[0x60];                                    // 0x0468(0x0060)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bHornPressed;                                      // 0x04C8(0x0001)(Net, ZeroConstructor, Transient, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_3552[0x7];                                     // 0x04C9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class AGzCharacter*>                   CharactersInVehicle;                               // 0x04D0(0x0010)(Net, ZeroConstructor, Transient, RepNotify, NativeAccessSpecifierPrivate)
	FMulticastInlineDelegateProperty_             OnRepPlayerState;                                  // 0x04E0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPrivate)
	class UGzEnvironmentZoneManagerComponent*     ZoneManagerComponent;                              // 0x04F0(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class AGzCharacter*                           DriverInstigator;                                  // 0x04F8(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         DriverInstigatorClearDelay;                        // 0x0500(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_3553[0xC];                                     // 0x0504(0x000C)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<class UPrimitiveComponent*, ECollisionResponse> CachedCameraCollisionResponse;                     // 0x0510(0x0050)(ContainsInstancedReference, NativeAccessSpecifierPrivate)
	uint8                                         Pad_3554[0x10];                                    // 0x0560(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	bool AssignSeat(class AGzCharacter* Character, EGzVehicleSeatType Seat);
	void BP_ClientOnVehicleHitEvent(class UPrimitiveComponent* HitComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, const struct FVector& NormalImpulse, const struct FHitResult& Hit, float CurrentVehicleSpeed);
	void EjectCharacter(class AGzCharacter* Character);
	void EjectSeat(EGzVehicleSeatType Seat);
	void EnterClosestFreeSeat(class AGzCharacter* Character);
	void EnterNextFreeSeat(class AGzCharacter* Character);
	void MulticastOnVehicleDestroyed();
	void OnCharacterBeginCollision(class AGzCharacter* Character);
	void OnCharacterCollisionBeginOverlap(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const struct FHitResult& SweepResult);
	void OnCharacterConnectionStateChanged(class AGzPlayerState* CharacterPlayerState);
	void OnCharacterEndCollision(class AGzCharacter* Character);
	void OnCharacterSeatChange(class AGzCharacter* Character, EGzVehicleSeatType NewSeat, EGzVehicleSeatType OldSeat);
	void OnInteractedBy(class AActor* InteractedBy, const class UGzInteractableComponent* Interactable);
	void OnPassengerRestarted(class APawn* PassengerPawn);
	void OnRep_AttachedCharacters(const TArray<class AGzCharacter*>& PreviousAttachedCharacters);
	void OnRep_CharactersInVehicle(const TArray<class AGzCharacter*>& PreviousCharactersInVehicle);
	void OnRep_HornPressed(const bool bOldHornPressedValue);
	void OnRep_IsDestroyed();
	void OnVehicleDestroyed();
	void OnVehicleHitEvent(class UPrimitiveComponent* HitComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, const struct FVector& NormalImpulse, const struct FHitResult& Hit);
	void SetHornState(bool bIsHornpressed);
	bool SwitchSeat(class AGzCharacter* Character);
	void VehicleDestroyedDelegate__DelegateSignature();

	class AGzCharacter* GetCharacterInSeat(EGzVehicleSeatType Seat) const;
	class AGzCharacter* GetDriver() const;
	class UGzChaosWheeledVehicleMovementComponent* GetGzVehicleMovementComponent() const;
	EGzVehicleSeatType GetSeatOfCharacter(const class AGzCharacter* Character) const;
	class UGzTurretComponent* GetTurretComponent() const;
	const class UGzVehicleConfig* GetVehicleConfig() const;
	const struct FGzVehicleState GetVehicleState() const;
	bool HasEmptySeats() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzVehicle">();
	}
	static class AGzVehicle* GetDefaultObj()
	{
		return GetDefaultObjImpl<AGzVehicle>();
	}
};
static_assert(alignof(AGzVehicle) == 0x000008, "Wrong alignment on AGzVehicle");
static_assert(sizeof(AGzVehicle) == 0x000570, "Wrong size on AGzVehicle");
static_assert(offsetof(AGzVehicle, OnVehicleSeatChanged) == 0x000380, "Member 'AGzVehicle::OnVehicleSeatChanged' has a wrong offset!");
static_assert(offsetof(AGzVehicle, OnHornStateChanged) == 0x000390, "Member 'AGzVehicle::OnHornStateChanged' has a wrong offset!");
static_assert(offsetof(AGzVehicle, CharacterCollisionParent) == 0x0003A0, "Member 'AGzVehicle::CharacterCollisionParent' has a wrong offset!");
static_assert(offsetof(AGzVehicle, CharacterOverlapMesh) == 0x0003A8, "Member 'AGzVehicle::CharacterOverlapMesh' has a wrong offset!");
static_assert(offsetof(AGzVehicle, CharacterCollisionMesh) == 0x0003B0, "Member 'AGzVehicle::CharacterCollisionMesh' has a wrong offset!");
static_assert(offsetof(AGzVehicle, AbilitySystemComponent) == 0x0003B8, "Member 'AGzVehicle::AbilitySystemComponent' has a wrong offset!");
static_assert(offsetof(AGzVehicle, DamageableComponent) == 0x0003C0, "Member 'AGzVehicle::DamageableComponent' has a wrong offset!");
static_assert(offsetof(AGzVehicle, GzAliveObjectAttributeSet) == 0x0003C8, "Member 'AGzVehicle::GzAliveObjectAttributeSet' has a wrong offset!");
static_assert(offsetof(AGzVehicle, InteractableComponent) == 0x0003D0, "Member 'AGzVehicle::InteractableComponent' has a wrong offset!");
static_assert(offsetof(AGzVehicle, EffectsComponent) == 0x0003D8, "Member 'AGzVehicle::EffectsComponent' has a wrong offset!");
static_assert(offsetof(AGzVehicle, ControlsComponent) == 0x0003E0, "Member 'AGzVehicle::ControlsComponent' has a wrong offset!");
static_assert(offsetof(AGzVehicle, TeamID) == 0x0003E8, "Member 'AGzVehicle::TeamID' has a wrong offset!");
static_assert(offsetof(AGzVehicle, VehicleTurretComponent) == 0x0003F0, "Member 'AGzVehicle::VehicleTurretComponent' has a wrong offset!");
static_assert(offsetof(AGzVehicle, bIsUpdatingVehicleState) == 0x000420, "Member 'AGzVehicle::bIsUpdatingVehicleState' has a wrong offset!");
static_assert(offsetof(AGzVehicle, AttachedCharacters) == 0x000428, "Member 'AGzVehicle::AttachedCharacters' has a wrong offset!");
static_assert(offsetof(AGzVehicle, bWasDestroyed) == 0x000438, "Member 'AGzVehicle::bWasDestroyed' has a wrong offset!");
static_assert(offsetof(AGzVehicle, OnVehicleIsDestroyedDelegate) == 0x000440, "Member 'AGzVehicle::OnVehicleIsDestroyedDelegate' has a wrong offset!");
static_assert(offsetof(AGzVehicle, OnVehicleWasDestroyedDelegate) == 0x000450, "Member 'AGzVehicle::OnVehicleWasDestroyedDelegate' has a wrong offset!");
static_assert(offsetof(AGzVehicle, VehicleConfig) == 0x000460, "Member 'AGzVehicle::VehicleConfig' has a wrong offset!");
static_assert(offsetof(AGzVehicle, bHornPressed) == 0x0004C8, "Member 'AGzVehicle::bHornPressed' has a wrong offset!");
static_assert(offsetof(AGzVehicle, CharactersInVehicle) == 0x0004D0, "Member 'AGzVehicle::CharactersInVehicle' has a wrong offset!");
static_assert(offsetof(AGzVehicle, OnRepPlayerState) == 0x0004E0, "Member 'AGzVehicle::OnRepPlayerState' has a wrong offset!");
static_assert(offsetof(AGzVehicle, ZoneManagerComponent) == 0x0004F0, "Member 'AGzVehicle::ZoneManagerComponent' has a wrong offset!");
static_assert(offsetof(AGzVehicle, DriverInstigator) == 0x0004F8, "Member 'AGzVehicle::DriverInstigator' has a wrong offset!");
static_assert(offsetof(AGzVehicle, DriverInstigatorClearDelay) == 0x000500, "Member 'AGzVehicle::DriverInstigatorClearDelay' has a wrong offset!");
static_assert(offsetof(AGzVehicle, CachedCameraCollisionResponse) == 0x000510, "Member 'AGzVehicle::CachedCameraCollisionResponse' has a wrong offset!");

// Class G01.GzVehicleEffectSettings
// 0x0050 (0x0080 - 0x0030)
class UGzVehicleEffectSettings final : public UDataAsset
{
public:
	TMap<EPhysicalSurface, struct FGzVehicleSurfaceEffects> EffectsMap;                                        // 0x0030(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)

public:
	const struct FGzVehicleSurfaceEffects GetSurfaceEffectsForType(const EPhysicalSurface Surface) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzVehicleEffectSettings">();
	}
	static class UGzVehicleEffectSettings* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzVehicleEffectSettings>();
	}
};
static_assert(alignof(UGzVehicleEffectSettings) == 0x000008, "Wrong alignment on UGzVehicleEffectSettings");
static_assert(sizeof(UGzVehicleEffectSettings) == 0x000080, "Wrong size on UGzVehicleEffectSettings");
static_assert(offsetof(UGzVehicleEffectSettings, EffectsMap) == 0x000030, "Member 'UGzVehicleEffectSettings::EffectsMap' has a wrong offset!");

// Class G01.GzVehicleControlsComponent
// 0x0030 (0x0160 - 0x0130)
class UGzVehicleControlsComponent final : public UGzPawnControlsComponent
{
public:
	FMulticastInlineDelegateProperty_             OnAccelerateInputChanged;                          // 0x0130(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnSteerInputChanged;                               // 0x0140(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnHandbrakeInputChanged;                           // 0x0150(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)

public:
	void HandleAccelerateBrake(const struct FInputActionValue& InputValue);
	void HandleGetOut(const struct FInputActionValue& InputValue);
	void HandleHandBrake(const struct FInputActionValue& InputValue);
	void HandleHorn(const struct FInputActionValue& InputValue);
	void HandleLookPitch(const struct FInputActionValue& InputValue);
	void HandleLookYaw(const struct FInputActionValue& InputValue);
	void HandleSeatSwitch(const struct FInputActionValue& InputValue);
	void HandleSteering(const struct FInputActionValue& InputValue);
	void OnInputAxisChanged__DelegateSignature(float Value);
	void OnInputButtonChanged__DelegateSignature(bool Value);
	void ServerGetOut();
	void ServerSetHornState(const bool bIsHornpressed);
	void ServerSwitchSeat();

	class AGzMultiPartCharacter* GetDriverCharacter() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzVehicleControlsComponent">();
	}
	static class UGzVehicleControlsComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzVehicleControlsComponent>();
	}
};
static_assert(alignof(UGzVehicleControlsComponent) == 0x000008, "Wrong alignment on UGzVehicleControlsComponent");
static_assert(sizeof(UGzVehicleControlsComponent) == 0x000160, "Wrong size on UGzVehicleControlsComponent");
static_assert(offsetof(UGzVehicleControlsComponent, OnAccelerateInputChanged) == 0x000130, "Member 'UGzVehicleControlsComponent::OnAccelerateInputChanged' has a wrong offset!");
static_assert(offsetof(UGzVehicleControlsComponent, OnSteerInputChanged) == 0x000140, "Member 'UGzVehicleControlsComponent::OnSteerInputChanged' has a wrong offset!");
static_assert(offsetof(UGzVehicleControlsComponent, OnHandbrakeInputChanged) == 0x000150, "Member 'UGzVehicleControlsComponent::OnHandbrakeInputChanged' has a wrong offset!");

// Class G01.GzVehicleEffectsComponent
// 0x0188 (0x0230 - 0x00A8)
class UGzVehicleEffectsComponent final : public UActorComponent
{
public:
	class FName                                   TireDustSpeedParameterName;                        // 0x00A8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class UNiagaraComponent*>              TireDustNiagaraComponents;                         // 0x00B0(0x0010)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, EditConst, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	FMulticastInlineDelegateProperty_             OnWheelSteeringStateChanged;                       // 0x00C0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, Protected, NativeAccessSpecifierProtected)
	FMulticastInlineDelegateProperty_             OnHandbrakeStateChanged;                           // 0x00D0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, Protected, NativeAccessSpecifierProtected)
	FMulticastInlineDelegateProperty_             OnActiveBrakeStateChanged;                         // 0x00E0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, Protected, NativeAccessSpecifierProtected)
	FMulticastInlineDelegateProperty_             OnWheelIsSkiddingStateChanged;                     // 0x00F0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, Protected, NativeAccessSpecifierProtected)
	FMulticastInlineDelegateProperty_             OnWheelIsSlippingStateChanged;                     // 0x0100(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, Protected, NativeAccessSpecifierProtected)
	FMulticastInlineDelegateProperty_             OnAxleGroundStateChanged;                          // 0x0110(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, Protected, NativeAccessSpecifierProtected)
	FMulticastInlineDelegateProperty_             OnSuspensionTresholdReached;                       // 0x0120(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, Protected, NativeAccessSpecifierProtected)
	FMulticastInlineDelegateProperty_             OnTurretRotationStateChanged;                      // 0x0130(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, Protected, NativeAccessSpecifierProtected)
	int32                                         SteeringWheelIndex;                                // 0x0140(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         SuspensionPercentageThreshold;                     // 0x0144(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         SurfaceSampleDownTraceDistance;                    // 0x0148(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         TurretRotationSoundGraceFrames;                    // 0x014C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class AGzCharacter*                           CurrentGunnerCharacter;                            // 0x0150(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class AGzVehicle*                             OwnerVehicle;                                      // 0x0158(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UGzVehicleConfig*                       VehicleConfig;                                     // 0x0160(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<struct FGzVehicleAudioEvent>           VehicleWheelSkidChangeEvents;                      // 0x0168(0x0010)(ZeroConstructor, Transient, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	TArray<struct FGzVehicleAudioEvent>           VehicleWheelSurfaceChangeEvents;                   // 0x0178(0x0010)(ZeroConstructor, Transient, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	TArray<struct FGzVehicleAudioEvent>           VehicleWheelTurnChangeEvents;                      // 0x0188(0x0010)(ZeroConstructor, Transient, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	TArray<struct FGzVehicleAudioEvent>           VehicleRPMEvents;                                  // 0x0198(0x0010)(ZeroConstructor, Transient, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	TArray<struct FGzVehicleAudioEvent>           VehicleSpeedEvents;                                // 0x01A8(0x0010)(ZeroConstructor, Transient, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	TArray<struct FGzVehicleAudioEvent>           VehicleWheelAngleEvents;                           // 0x01B8(0x0010)(ZeroConstructor, Transient, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	TArray<class UPhysicalMaterial*>              AxlePhysicalMaterials;                             // 0x01C8(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	TArray<bool>                                  AxleGroundState;                                   // 0x01D8(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	uint8                                         Pad_355D[0x48];                                    // 0x01E8(0x0048)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ActiveBrakeStateChangedDelegate__DelegateSignature(bool bIsBraking, bool bIsAnyWheelInContact);
	void AxleGroundStaetChangedDelegate__DelegateSignature(EGzVehicleAxle Axle, bool bIsOnGround);
	void CreateAudioComponent(struct FGzVehicleAudioEvent& AudioEvent, bool bPlayEvent);
	void HandbrakeStateChangedDelegate__DelegateSignature(bool bIsPullingHandbrake);
	void OnVehicleAxlePhysMaterialChanged(EGzVehicleAxle VehicleAxle, class UPhysicalMaterial* PhysMaterial);
	void PlayEvent(const struct FGzVehicleAudioEvent& AudioEvent);
	void SetCustomRtpcValue(const struct FGzVehicleAudioEvent& AudioEvent, class UAkRtpc* AkRtpc, const float Value);
	void StopEvent(const struct FGzVehicleAudioEvent& AudioEvent);
	void SuspensionPercentageThresholdDelegate__DelegateSignature(float SuspensionValue, int32 WheelIndex);
	void TurretRotationStateChangedDelegate__DelegateSignature(bool bIsTurretRotating);
	void WheelSkiddingOrSlippingDelegate__DelegateSignature(int32 WheelIndex, bool bIsSkiddingOrSlipping);
	void WheelSteeringStateChangedDelegate__DelegateSignature(int32 WheelIndex, float SteeringValue, bool bIsInContact);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzVehicleEffectsComponent">();
	}
	static class UGzVehicleEffectsComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzVehicleEffectsComponent>();
	}
};
static_assert(alignof(UGzVehicleEffectsComponent) == 0x000008, "Wrong alignment on UGzVehicleEffectsComponent");
static_assert(sizeof(UGzVehicleEffectsComponent) == 0x000230, "Wrong size on UGzVehicleEffectsComponent");
static_assert(offsetof(UGzVehicleEffectsComponent, TireDustSpeedParameterName) == 0x0000A8, "Member 'UGzVehicleEffectsComponent::TireDustSpeedParameterName' has a wrong offset!");
static_assert(offsetof(UGzVehicleEffectsComponent, TireDustNiagaraComponents) == 0x0000B0, "Member 'UGzVehicleEffectsComponent::TireDustNiagaraComponents' has a wrong offset!");
static_assert(offsetof(UGzVehicleEffectsComponent, OnWheelSteeringStateChanged) == 0x0000C0, "Member 'UGzVehicleEffectsComponent::OnWheelSteeringStateChanged' has a wrong offset!");
static_assert(offsetof(UGzVehicleEffectsComponent, OnHandbrakeStateChanged) == 0x0000D0, "Member 'UGzVehicleEffectsComponent::OnHandbrakeStateChanged' has a wrong offset!");
static_assert(offsetof(UGzVehicleEffectsComponent, OnActiveBrakeStateChanged) == 0x0000E0, "Member 'UGzVehicleEffectsComponent::OnActiveBrakeStateChanged' has a wrong offset!");
static_assert(offsetof(UGzVehicleEffectsComponent, OnWheelIsSkiddingStateChanged) == 0x0000F0, "Member 'UGzVehicleEffectsComponent::OnWheelIsSkiddingStateChanged' has a wrong offset!");
static_assert(offsetof(UGzVehicleEffectsComponent, OnWheelIsSlippingStateChanged) == 0x000100, "Member 'UGzVehicleEffectsComponent::OnWheelIsSlippingStateChanged' has a wrong offset!");
static_assert(offsetof(UGzVehicleEffectsComponent, OnAxleGroundStateChanged) == 0x000110, "Member 'UGzVehicleEffectsComponent::OnAxleGroundStateChanged' has a wrong offset!");
static_assert(offsetof(UGzVehicleEffectsComponent, OnSuspensionTresholdReached) == 0x000120, "Member 'UGzVehicleEffectsComponent::OnSuspensionTresholdReached' has a wrong offset!");
static_assert(offsetof(UGzVehicleEffectsComponent, OnTurretRotationStateChanged) == 0x000130, "Member 'UGzVehicleEffectsComponent::OnTurretRotationStateChanged' has a wrong offset!");
static_assert(offsetof(UGzVehicleEffectsComponent, SteeringWheelIndex) == 0x000140, "Member 'UGzVehicleEffectsComponent::SteeringWheelIndex' has a wrong offset!");
static_assert(offsetof(UGzVehicleEffectsComponent, SuspensionPercentageThreshold) == 0x000144, "Member 'UGzVehicleEffectsComponent::SuspensionPercentageThreshold' has a wrong offset!");
static_assert(offsetof(UGzVehicleEffectsComponent, SurfaceSampleDownTraceDistance) == 0x000148, "Member 'UGzVehicleEffectsComponent::SurfaceSampleDownTraceDistance' has a wrong offset!");
static_assert(offsetof(UGzVehicleEffectsComponent, TurretRotationSoundGraceFrames) == 0x00014C, "Member 'UGzVehicleEffectsComponent::TurretRotationSoundGraceFrames' has a wrong offset!");
static_assert(offsetof(UGzVehicleEffectsComponent, CurrentGunnerCharacter) == 0x000150, "Member 'UGzVehicleEffectsComponent::CurrentGunnerCharacter' has a wrong offset!");
static_assert(offsetof(UGzVehicleEffectsComponent, OwnerVehicle) == 0x000158, "Member 'UGzVehicleEffectsComponent::OwnerVehicle' has a wrong offset!");
static_assert(offsetof(UGzVehicleEffectsComponent, VehicleConfig) == 0x000160, "Member 'UGzVehicleEffectsComponent::VehicleConfig' has a wrong offset!");
static_assert(offsetof(UGzVehicleEffectsComponent, VehicleWheelSkidChangeEvents) == 0x000168, "Member 'UGzVehicleEffectsComponent::VehicleWheelSkidChangeEvents' has a wrong offset!");
static_assert(offsetof(UGzVehicleEffectsComponent, VehicleWheelSurfaceChangeEvents) == 0x000178, "Member 'UGzVehicleEffectsComponent::VehicleWheelSurfaceChangeEvents' has a wrong offset!");
static_assert(offsetof(UGzVehicleEffectsComponent, VehicleWheelTurnChangeEvents) == 0x000188, "Member 'UGzVehicleEffectsComponent::VehicleWheelTurnChangeEvents' has a wrong offset!");
static_assert(offsetof(UGzVehicleEffectsComponent, VehicleRPMEvents) == 0x000198, "Member 'UGzVehicleEffectsComponent::VehicleRPMEvents' has a wrong offset!");
static_assert(offsetof(UGzVehicleEffectsComponent, VehicleSpeedEvents) == 0x0001A8, "Member 'UGzVehicleEffectsComponent::VehicleSpeedEvents' has a wrong offset!");
static_assert(offsetof(UGzVehicleEffectsComponent, VehicleWheelAngleEvents) == 0x0001B8, "Member 'UGzVehicleEffectsComponent::VehicleWheelAngleEvents' has a wrong offset!");
static_assert(offsetof(UGzVehicleEffectsComponent, AxlePhysicalMaterials) == 0x0001C8, "Member 'UGzVehicleEffectsComponent::AxlePhysicalMaterials' has a wrong offset!");
static_assert(offsetof(UGzVehicleEffectsComponent, AxleGroundState) == 0x0001D8, "Member 'UGzVehicleEffectsComponent::AxleGroundState' has a wrong offset!");

// Class G01.GzVehicleMapMarkerWidget
// 0x0068 (0x0408 - 0x03A0)
class UGzVehicleMapMarkerWidget final : public UGzMapMarkerWidget
{
public:
	class UOverlay*                               RotationContainer;                                 // 0x03A0(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         IconRotationAngle;                                 // 0x03A8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_3563[0x4];                                     // 0x03AC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<EGzVehicleSeatType, class UWidget*>      SeatPositionMap;                                   // 0x03B0(0x0050)(ExportObject, Transient, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	class AGzVehicle*                             Vehicle;                                           // 0x0400(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void OnVehicleSeatChanged(class AGzCharacter* Character, EGzVehicleSeatType NewSeat, EGzVehicleSeatType OldSeat);
	void SetSeatPosition(const TMap<EGzVehicleSeatType, class UWidget*>& InSeatPositionMap);
	void SetTeamColor(const int32 TeamMemberIndex, class UWidget* Point);
	void UpdateAllElements();
	void UpdateIcon();
	void UpdateTeamStateDefault();
	void UpdateTeamStateEnemy();
	void UpdateTeamStateFriend();
	void UpdateTeamStatePlayer();

	bool HasGunnerSeat() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzVehicleMapMarkerWidget">();
	}
	static class UGzVehicleMapMarkerWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzVehicleMapMarkerWidget>();
	}
};
static_assert(alignof(UGzVehicleMapMarkerWidget) == 0x000008, "Wrong alignment on UGzVehicleMapMarkerWidget");
static_assert(sizeof(UGzVehicleMapMarkerWidget) == 0x000408, "Wrong size on UGzVehicleMapMarkerWidget");
static_assert(offsetof(UGzVehicleMapMarkerWidget, RotationContainer) == 0x0003A0, "Member 'UGzVehicleMapMarkerWidget::RotationContainer' has a wrong offset!");
static_assert(offsetof(UGzVehicleMapMarkerWidget, IconRotationAngle) == 0x0003A8, "Member 'UGzVehicleMapMarkerWidget::IconRotationAngle' has a wrong offset!");
static_assert(offsetof(UGzVehicleMapMarkerWidget, SeatPositionMap) == 0x0003B0, "Member 'UGzVehicleMapMarkerWidget::SeatPositionMap' has a wrong offset!");
static_assert(offsetof(UGzVehicleMapMarkerWidget, Vehicle) == 0x000400, "Member 'UGzVehicleMapMarkerWidget::Vehicle' has a wrong offset!");

// Class G01.GzVehicleSkeletalMeshComponent
// 0x0000 (0x0F70 - 0x0F70)
class UGzVehicleSkeletalMeshComponent final : public USkeletalMeshComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzVehicleSkeletalMeshComponent">();
	}
	static class UGzVehicleSkeletalMeshComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzVehicleSkeletalMeshComponent>();
	}
};
static_assert(alignof(UGzVehicleSkeletalMeshComponent) == 0x000010, "Wrong alignment on UGzVehicleSkeletalMeshComponent");
static_assert(sizeof(UGzVehicleSkeletalMeshComponent) == 0x000F70, "Wrong size on UGzVehicleSkeletalMeshComponent");

// Class G01.GzVehicleSpawner
// 0x0000 (0x02A0 - 0x02A0)
class AGzVehicleSpawner final : public AActor
{
public:
	bool CanSpawn() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzVehicleSpawner">();
	}
	static class AGzVehicleSpawner* GetDefaultObj()
	{
		return GetDefaultObjImpl<AGzVehicleSpawner>();
	}
};
static_assert(alignof(AGzVehicleSpawner) == 0x000008, "Wrong alignment on AGzVehicleSpawner");
static_assert(sizeof(AGzVehicleSpawner) == 0x0002A0, "Wrong size on AGzVehicleSpawner");

// Class G01.GzSpringArmViewpoint
// 0x0018 (0x02B8 - 0x02A0)
class AGzSpringArmViewpoint final : public AActor
{
public:
	class UStaticMeshComponent*                   StaticMeshComponent;                               // 0x02A0(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USpringArmComponent*                    SpringArmComponent;                                // 0x02A8(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCineCameraComponent*                   CameraComponent;                                   // 0x02B0(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzSpringArmViewpoint">();
	}
	static class AGzSpringArmViewpoint* GetDefaultObj()
	{
		return GetDefaultObjImpl<AGzSpringArmViewpoint>();
	}
};
static_assert(alignof(AGzSpringArmViewpoint) == 0x000008, "Wrong alignment on AGzSpringArmViewpoint");
static_assert(sizeof(AGzSpringArmViewpoint) == 0x0002B8, "Wrong size on AGzSpringArmViewpoint");
static_assert(offsetof(AGzSpringArmViewpoint, StaticMeshComponent) == 0x0002A0, "Member 'AGzSpringArmViewpoint::StaticMeshComponent' has a wrong offset!");
static_assert(offsetof(AGzSpringArmViewpoint, SpringArmComponent) == 0x0002A8, "Member 'AGzSpringArmViewpoint::SpringArmComponent' has a wrong offset!");
static_assert(offsetof(AGzSpringArmViewpoint, CameraComponent) == 0x0002B0, "Member 'AGzSpringArmViewpoint::CameraComponent' has a wrong offset!");

// Class G01.GzViewpointCamera
// 0x0000 (0x0A70 - 0x0A70)
class AGzViewpointCamera final : public ACineCameraActor
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzViewpointCamera">();
	}
	static class AGzViewpointCamera* GetDefaultObj()
	{
		return GetDefaultObjImpl<AGzViewpointCamera>();
	}
};
static_assert(alignof(AGzViewpointCamera) == 0x000010, "Wrong alignment on AGzViewpointCamera");
static_assert(sizeof(AGzViewpointCamera) == 0x000A70, "Wrong size on AGzViewpointCamera");

// Class G01.GzViewpointCluster
// 0x0050 (0x0300 - 0x02B0)
class AGzViewpointCluster final : public AGzViewpointClusterBase
{
public:
	TMap<class FName, struct FGzViewpoint>        Viewpoints;                                        // 0x02B0(0x0050)(Edit, DisableEditOnTemplate, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzViewpointCluster">();
	}
	static class AGzViewpointCluster* GetDefaultObj()
	{
		return GetDefaultObjImpl<AGzViewpointCluster>();
	}
};
static_assert(alignof(AGzViewpointCluster) == 0x000008, "Wrong alignment on AGzViewpointCluster");
static_assert(sizeof(AGzViewpointCluster) == 0x000300, "Wrong size on AGzViewpointCluster");
static_assert(offsetof(AGzViewpointCluster, Viewpoints) == 0x0002B0, "Member 'AGzViewpointCluster::Viewpoints' has a wrong offset!");

// Class G01.GzViewportMarkerContainer
// 0x0048 (0x0530 - 0x04E8)
class UGzViewportMarkerContainer : public UGzBaseMarkerContainer
{
public:
	class UCanvasPanel*                           Root;                                              // 0x04E8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         WidgetCheckRadius;                                 // 0x04F0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_3566[0x4];                                     // 0x04F4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class APlayerCameraManager*                   CameraManager;                                     // 0x04F8(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bRectangularClamp;                                 // 0x0500(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_3567[0x7];                                     // 0x0501(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector2D                              NormalizedClampRectSize;                           // 0x0508(0x0010)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSubclassOf<class UGzPingTooltipExtension>    TooltipExtensionClass;                             // 0x0518(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_3568[0x10];                                    // 0x0520(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzViewportMarkerContainer">();
	}
	static class UGzViewportMarkerContainer* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzViewportMarkerContainer>();
	}
};
static_assert(alignof(UGzViewportMarkerContainer) == 0x000008, "Wrong alignment on UGzViewportMarkerContainer");
static_assert(sizeof(UGzViewportMarkerContainer) == 0x000530, "Wrong size on UGzViewportMarkerContainer");
static_assert(offsetof(UGzViewportMarkerContainer, Root) == 0x0004E8, "Member 'UGzViewportMarkerContainer::Root' has a wrong offset!");
static_assert(offsetof(UGzViewportMarkerContainer, WidgetCheckRadius) == 0x0004F0, "Member 'UGzViewportMarkerContainer::WidgetCheckRadius' has a wrong offset!");
static_assert(offsetof(UGzViewportMarkerContainer, CameraManager) == 0x0004F8, "Member 'UGzViewportMarkerContainer::CameraManager' has a wrong offset!");
static_assert(offsetof(UGzViewportMarkerContainer, bRectangularClamp) == 0x000500, "Member 'UGzViewportMarkerContainer::bRectangularClamp' has a wrong offset!");
static_assert(offsetof(UGzViewportMarkerContainer, NormalizedClampRectSize) == 0x000508, "Member 'UGzViewportMarkerContainer::NormalizedClampRectSize' has a wrong offset!");
static_assert(offsetof(UGzViewportMarkerContainer, TooltipExtensionClass) == 0x000518, "Member 'UGzViewportMarkerContainer::TooltipExtensionClass' has a wrong offset!");

// Class G01.GzVoiceableObject
// 0x0000 (0x0028 - 0x0028)
class IGzVoiceableObject final : public IInterface
{
public:
	const struct FGzPingVoiceLineData GetPingVoiceLineData() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzVoiceableObject">();
	}
	static class IGzVoiceableObject* GetDefaultObj()
	{
		return GetDefaultObjImpl<IGzVoiceableObject>();
	}
};
static_assert(alignof(IGzVoiceableObject) == 0x000008, "Wrong alignment on IGzVoiceableObject");
static_assert(sizeof(IGzVoiceableObject) == 0x000028, "Wrong size on IGzVoiceableObject");

// Class G01.GzVoiceSource
// 0x0000 (0x0028 - 0x0028)
class IGzVoiceSource final : public IInterface
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzVoiceSource">();
	}
	static class IGzVoiceSource* GetDefaultObj()
	{
		return GetDefaultObjImpl<IGzVoiceSource>();
	}
};
static_assert(alignof(IGzVoiceSource) == 0x000008, "Wrong alignment on IGzVoiceSource");
static_assert(sizeof(IGzVoiceSource) == 0x000028, "Wrong size on IGzVoiceSource");

// Class G01.GzWatermarkDisablingComponent
// 0x0008 (0x00A8 - 0x00A0)
class UGzWatermarkDisablingComponent final : public UGzServiceComponent
{
public:
	uint8                                         Pad_3569[0x8];                                     // 0x00A0(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzWatermarkDisablingComponent">();
	}
	static class UGzWatermarkDisablingComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzWatermarkDisablingComponent>();
	}
};
static_assert(alignof(UGzWatermarkDisablingComponent) == 0x000008, "Wrong alignment on UGzWatermarkDisablingComponent");
static_assert(sizeof(UGzWatermarkDisablingComponent) == 0x0000A8, "Wrong size on UGzWatermarkDisablingComponent");

// Class G01.GzWatermarkWidget
// 0x0038 (0x0318 - 0x02E0)
class UGzWatermarkWidget : public UUserWidget
{
public:
	class UGzTextBlock*                           TextBlock;                                         // 0x02E0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         Repeats;                                           // 0x02E8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         LineFillCount;                                     // 0x02EC(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         GapSize;                                           // 0x02F0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bMoveAroundScreen;                                 // 0x02F4(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_356A[0x3];                                     // 0x02F5(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         InterpSpeed;                                       // 0x02F8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_356B[0x4];                                     // 0x02FC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FVector2D>                      Targets;                                           // 0x0300(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	int32                                         StartTarget;                                       // 0x0310(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_356C[0x4];                                     // 0x0314(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetWaterMarkRepeatWord(const class FString& InWord);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzWatermarkWidget">();
	}
	static class UGzWatermarkWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzWatermarkWidget>();
	}
};
static_assert(alignof(UGzWatermarkWidget) == 0x000008, "Wrong alignment on UGzWatermarkWidget");
static_assert(sizeof(UGzWatermarkWidget) == 0x000318, "Wrong size on UGzWatermarkWidget");
static_assert(offsetof(UGzWatermarkWidget, TextBlock) == 0x0002E0, "Member 'UGzWatermarkWidget::TextBlock' has a wrong offset!");
static_assert(offsetof(UGzWatermarkWidget, Repeats) == 0x0002E8, "Member 'UGzWatermarkWidget::Repeats' has a wrong offset!");
static_assert(offsetof(UGzWatermarkWidget, LineFillCount) == 0x0002EC, "Member 'UGzWatermarkWidget::LineFillCount' has a wrong offset!");
static_assert(offsetof(UGzWatermarkWidget, GapSize) == 0x0002F0, "Member 'UGzWatermarkWidget::GapSize' has a wrong offset!");
static_assert(offsetof(UGzWatermarkWidget, bMoveAroundScreen) == 0x0002F4, "Member 'UGzWatermarkWidget::bMoveAroundScreen' has a wrong offset!");
static_assert(offsetof(UGzWatermarkWidget, InterpSpeed) == 0x0002F8, "Member 'UGzWatermarkWidget::InterpSpeed' has a wrong offset!");
static_assert(offsetof(UGzWatermarkWidget, Targets) == 0x000300, "Member 'UGzWatermarkWidget::Targets' has a wrong offset!");
static_assert(offsetof(UGzWatermarkWidget, StartTarget) == 0x000310, "Member 'UGzWatermarkWidget::StartTarget' has a wrong offset!");

// Class G01.GzWeaponAnimInstance
// 0x0010 (0x0380 - 0x0370)
class UGzWeaponAnimInstance final : public UAnimInstance
{
public:
	bool                                          bIsFollowingCharactersHandWhileReload;             // 0x0368(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsFollowingLefHandWhileReload;                    // 0x0369(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsReloading;                                      // 0x036A(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_356D[0x1];                                     // 0x036B(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   OwnerIKCurveName;                                  // 0x036C(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_356E[0xC];                                     // 0x0374(0x000C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	float GetOwnerIKCurveValue() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzWeaponAnimInstance">();
	}
	static class UGzWeaponAnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzWeaponAnimInstance>();
	}
};
static_assert(alignof(UGzWeaponAnimInstance) == 0x000010, "Wrong alignment on UGzWeaponAnimInstance");
static_assert(sizeof(UGzWeaponAnimInstance) == 0x000380, "Wrong size on UGzWeaponAnimInstance");
static_assert(offsetof(UGzWeaponAnimInstance, bIsFollowingCharactersHandWhileReload) == 0x000368, "Member 'UGzWeaponAnimInstance::bIsFollowingCharactersHandWhileReload' has a wrong offset!");
static_assert(offsetof(UGzWeaponAnimInstance, bIsFollowingLefHandWhileReload) == 0x000369, "Member 'UGzWeaponAnimInstance::bIsFollowingLefHandWhileReload' has a wrong offset!");
static_assert(offsetof(UGzWeaponAnimInstance, bIsReloading) == 0x00036A, "Member 'UGzWeaponAnimInstance::bIsReloading' has a wrong offset!");
static_assert(offsetof(UGzWeaponAnimInstance, OwnerIKCurveName) == 0x00036C, "Member 'UGzWeaponAnimInstance::OwnerIKCurveName' has a wrong offset!");

// Class G01.GzWeaponArchetype
// 0x0120 (0x0150 - 0x0030)
class UGzWeaponArchetype final : public UDataAsset
{
public:
	class FText                                   DisplayName;                                       // 0x0030(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	class FText                                   Description;                                       // 0x0040(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	EGzWeaponType                                 WeaponType;                                        // 0x0050(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, AssetRegistrySearchable, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_356F[0x7];                                     // 0x0051(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UGzWeaponSkinItemData*>          SuitableSkins;                                     // 0x0058(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TMap<EGzWeaponAttachmentType, struct FGzSuitableAttachmentsCategory> SuitableAndDefaultAttachments;                     // 0x0068(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	class UGzWeaponEquipmentConditionData*        EquipConditions;                                   // 0x00B8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bTwoHanded;                                        // 0x00C0(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3570[0x3];                                     // 0x00C1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   WeaponHolsterSocketSizeSuffix;                     // 0x00C4(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3571[0x4];                                     // 0x00CC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGzPingVoiceLineData                   PingVoiceLineEvent;                                // 0x00D0(0x0010)(Edit, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	class UGzWeaponSkinItemData*                  DefaultSkin;                                       // 0x00E0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGzGamepadFeedbackSpec                 TriggerGamepadFeedback;                            // 0x00E8(0x0018)(Edit, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	TMap<EGzWeaponMode, struct FGzGamepadFeedbackSpec> ShootGamepadFeedback;                              // 0x0100(0x0050)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)

public:
	class FName GetAssetId() const;
	TArray<class UGzWeaponAttachmentItemData*> GetDefaultAttachments() const;
	TArray<class FName> GetSuitableAttachmentIDsOfType(EGzWeaponAttachmentType AttachmentType) const;
	TArray<class FName> GetSuitableSkinNames() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzWeaponArchetype">();
	}
	static class UGzWeaponArchetype* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzWeaponArchetype>();
	}
};
static_assert(alignof(UGzWeaponArchetype) == 0x000008, "Wrong alignment on UGzWeaponArchetype");
static_assert(sizeof(UGzWeaponArchetype) == 0x000150, "Wrong size on UGzWeaponArchetype");
static_assert(offsetof(UGzWeaponArchetype, DisplayName) == 0x000030, "Member 'UGzWeaponArchetype::DisplayName' has a wrong offset!");
static_assert(offsetof(UGzWeaponArchetype, Description) == 0x000040, "Member 'UGzWeaponArchetype::Description' has a wrong offset!");
static_assert(offsetof(UGzWeaponArchetype, WeaponType) == 0x000050, "Member 'UGzWeaponArchetype::WeaponType' has a wrong offset!");
static_assert(offsetof(UGzWeaponArchetype, SuitableSkins) == 0x000058, "Member 'UGzWeaponArchetype::SuitableSkins' has a wrong offset!");
static_assert(offsetof(UGzWeaponArchetype, SuitableAndDefaultAttachments) == 0x000068, "Member 'UGzWeaponArchetype::SuitableAndDefaultAttachments' has a wrong offset!");
static_assert(offsetof(UGzWeaponArchetype, EquipConditions) == 0x0000B8, "Member 'UGzWeaponArchetype::EquipConditions' has a wrong offset!");
static_assert(offsetof(UGzWeaponArchetype, bTwoHanded) == 0x0000C0, "Member 'UGzWeaponArchetype::bTwoHanded' has a wrong offset!");
static_assert(offsetof(UGzWeaponArchetype, WeaponHolsterSocketSizeSuffix) == 0x0000C4, "Member 'UGzWeaponArchetype::WeaponHolsterSocketSizeSuffix' has a wrong offset!");
static_assert(offsetof(UGzWeaponArchetype, PingVoiceLineEvent) == 0x0000D0, "Member 'UGzWeaponArchetype::PingVoiceLineEvent' has a wrong offset!");
static_assert(offsetof(UGzWeaponArchetype, DefaultSkin) == 0x0000E0, "Member 'UGzWeaponArchetype::DefaultSkin' has a wrong offset!");
static_assert(offsetof(UGzWeaponArchetype, TriggerGamepadFeedback) == 0x0000E8, "Member 'UGzWeaponArchetype::TriggerGamepadFeedback' has a wrong offset!");
static_assert(offsetof(UGzWeaponArchetype, ShootGamepadFeedback) == 0x000100, "Member 'UGzWeaponArchetype::ShootGamepadFeedback' has a wrong offset!");

// Class G01.GzWeaponAssistStatCollector
// 0x0008 (0x0040 - 0x0038)
class UGzWeaponAssistStatCollector final : public UGzGlobalStatsCollector
{
public:
	uint8                                         Pad_3573[0x8];                                     // 0x0038(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzWeaponAssistStatCollector">();
	}
	static class UGzWeaponAssistStatCollector* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzWeaponAssistStatCollector>();
	}
};
static_assert(alignof(UGzWeaponAssistStatCollector) == 0x000008, "Wrong alignment on UGzWeaponAssistStatCollector");
static_assert(sizeof(UGzWeaponAssistStatCollector) == 0x000040, "Wrong size on UGzWeaponAssistStatCollector");

// Class G01.GzWeaponAttachmentComponentVisual
// 0x0030 (0x0260 - 0x0230)
class UGzWeaponAttachmentComponentVisual final : public USceneComponent
{
public:
	struct FGzItemSkinMaterials                   AttachmentMaterialsSkin;                           // 0x0230(0x0010)(Edit, Transient, EditConst, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	class UMeshComponent*                         AttachMeshComponent;                               // 0x0240(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3574[0x18];                                    // 0x0248(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzWeaponAttachmentComponentVisual">();
	}
	static class UGzWeaponAttachmentComponentVisual* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzWeaponAttachmentComponentVisual>();
	}
};
static_assert(alignof(UGzWeaponAttachmentComponentVisual) == 0x000010, "Wrong alignment on UGzWeaponAttachmentComponentVisual");
static_assert(sizeof(UGzWeaponAttachmentComponentVisual) == 0x000260, "Wrong size on UGzWeaponAttachmentComponentVisual");
static_assert(offsetof(UGzWeaponAttachmentComponentVisual, AttachmentMaterialsSkin) == 0x000230, "Member 'UGzWeaponAttachmentComponentVisual::AttachmentMaterialsSkin' has a wrong offset!");
static_assert(offsetof(UGzWeaponAttachmentComponentVisual, AttachMeshComponent) == 0x000240, "Member 'UGzWeaponAttachmentComponentVisual::AttachMeshComponent' has a wrong offset!");

// Class G01.ItemInteractionData
// 0x0018 (0x0048 - 0x0030)
class UItemInteractionData final : public UDataAsset
{
public:
	class UAkAudioEvent*                          PickupSoundCue;                                    // 0x0030(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UDefaultInteractionBehavior> PickupInteractionBehaviourClass;                   // 0x0038(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAkAudioEvent*                          DropSoundCue;                                      // 0x0040(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ItemInteractionData">();
	}
	static class UItemInteractionData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UItemInteractionData>();
	}
};
static_assert(alignof(UItemInteractionData) == 0x000008, "Wrong alignment on UItemInteractionData");
static_assert(sizeof(UItemInteractionData) == 0x000048, "Wrong size on UItemInteractionData");
static_assert(offsetof(UItemInteractionData, PickupSoundCue) == 0x000030, "Member 'UItemInteractionData::PickupSoundCue' has a wrong offset!");
static_assert(offsetof(UItemInteractionData, PickupInteractionBehaviourClass) == 0x000038, "Member 'UItemInteractionData::PickupInteractionBehaviourClass' has a wrong offset!");
static_assert(offsetof(UItemInteractionData, DropSoundCue) == 0x000040, "Member 'UItemInteractionData::DropSoundCue' has a wrong offset!");

// Class G01.GzWeaponAttachmentComponent
// 0x0018 (0x00C0 - 0x00A8)
class UGzWeaponAttachmentComponent final : public UActorComponent
{
public:
	class UGzWeaponAttachmentItemData*            AttachmentItemData;                                // 0x00A8(0x0008)(Edit, ZeroConstructor, Transient, EditConst, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UGzWeaponAttachmentComponentVisual*     WeaponAttachmentComponentVisual;                   // 0x00B0(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3575[0x8];                                     // 0x00B8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void PlayWeaponAttachmentMontage(const struct FGameplayTag& AnimationTag);
	void StopWeaponAttachmentMontage(const struct FGameplayTag& AnimationTag);

	const class UGzWeaponAttachmentItemData* GetWeaponAttachmentItemData() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzWeaponAttachmentComponent">();
	}
	static class UGzWeaponAttachmentComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzWeaponAttachmentComponent>();
	}
};
static_assert(alignof(UGzWeaponAttachmentComponent) == 0x000008, "Wrong alignment on UGzWeaponAttachmentComponent");
static_assert(sizeof(UGzWeaponAttachmentComponent) == 0x0000C0, "Wrong size on UGzWeaponAttachmentComponent");
static_assert(offsetof(UGzWeaponAttachmentComponent, AttachmentItemData) == 0x0000A8, "Member 'UGzWeaponAttachmentComponent::AttachmentItemData' has a wrong offset!");
static_assert(offsetof(UGzWeaponAttachmentComponent, WeaponAttachmentComponentVisual) == 0x0000B0, "Member 'UGzWeaponAttachmentComponent::WeaponAttachmentComponentVisual' has a wrong offset!");

// Class G01.GzWeaponAttachmentItemData
// 0x0160 (0x0438 - 0x02D8)
class UGzWeaponAttachmentItemData final : public UGzItemData
{
public:
	EGzWeaponAttachmentType                       AttachmentType;                                    // 0x02D8(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3576[0x7];                                     // 0x02D9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UGzWeaponModifier*>              Modifiers;                                         // 0x02E0(0x0010)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FGzWeaponAttachmentVisuals             DefaultVisuals;                                    // 0x02F0(0x0078)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TSoftClassPtr<class UClass>                   WeaponBehaviorAttachmentClass;                     // 0x0368(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMap<EGzWeaponSupplementAttachmentType, struct FGzWeaponAttachmentVisuals> AdditionalVisuals;                                 // 0x0390(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TMap<struct FGameplayTag, struct FGzWeaponAttachmentAnimationsArray> EventAnimationMap;                                 // 0x03E0(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	bool                                          IsCosmetic;                                        // 0x0430(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_3577[0x7];                                     // 0x0431(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzWeaponAttachmentItemData">();
	}
	static class UGzWeaponAttachmentItemData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzWeaponAttachmentItemData>();
	}
};
static_assert(alignof(UGzWeaponAttachmentItemData) == 0x000008, "Wrong alignment on UGzWeaponAttachmentItemData");
static_assert(sizeof(UGzWeaponAttachmentItemData) == 0x000438, "Wrong size on UGzWeaponAttachmentItemData");
static_assert(offsetof(UGzWeaponAttachmentItemData, AttachmentType) == 0x0002D8, "Member 'UGzWeaponAttachmentItemData::AttachmentType' has a wrong offset!");
static_assert(offsetof(UGzWeaponAttachmentItemData, Modifiers) == 0x0002E0, "Member 'UGzWeaponAttachmentItemData::Modifiers' has a wrong offset!");
static_assert(offsetof(UGzWeaponAttachmentItemData, DefaultVisuals) == 0x0002F0, "Member 'UGzWeaponAttachmentItemData::DefaultVisuals' has a wrong offset!");
static_assert(offsetof(UGzWeaponAttachmentItemData, WeaponBehaviorAttachmentClass) == 0x000368, "Member 'UGzWeaponAttachmentItemData::WeaponBehaviorAttachmentClass' has a wrong offset!");
static_assert(offsetof(UGzWeaponAttachmentItemData, AdditionalVisuals) == 0x000390, "Member 'UGzWeaponAttachmentItemData::AdditionalVisuals' has a wrong offset!");
static_assert(offsetof(UGzWeaponAttachmentItemData, EventAnimationMap) == 0x0003E0, "Member 'UGzWeaponAttachmentItemData::EventAnimationMap' has a wrong offset!");
static_assert(offsetof(UGzWeaponAttachmentItemData, IsCosmetic) == 0x000430, "Member 'UGzWeaponAttachmentItemData::IsCosmetic' has a wrong offset!");

// Class G01.GzWeaponCrosshair
// 0x0048 (0x0330 - 0x02E8)
class UGzWeaponCrosshair : public UGzCrosshair
{
public:
	float                                         CrosshairSpreadInterpolationSpeed;                 // 0x02E8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MaxPrecisionTolerance;                             // 0x02EC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCanvasPanel*                           LeavesContainer;                                   // 0x02F0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class AGzWeaponActor*                         ActiveWeapon;                                      // 0x02F8(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UGzWeaponSpreadSystem*                  ActiveWeaponSpreadSystem;                          // 0x0300(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class APlayerCameraManager*                   CameraManager;                                     // 0x0308(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3578[0x20];                                    // 0x0310(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnUpdatedMaxPrecisionStateBP(bool bEnable);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzWeaponCrosshair">();
	}
	static class UGzWeaponCrosshair* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzWeaponCrosshair>();
	}
};
static_assert(alignof(UGzWeaponCrosshair) == 0x000008, "Wrong alignment on UGzWeaponCrosshair");
static_assert(sizeof(UGzWeaponCrosshair) == 0x000330, "Wrong size on UGzWeaponCrosshair");
static_assert(offsetof(UGzWeaponCrosshair, CrosshairSpreadInterpolationSpeed) == 0x0002E8, "Member 'UGzWeaponCrosshair::CrosshairSpreadInterpolationSpeed' has a wrong offset!");
static_assert(offsetof(UGzWeaponCrosshair, MaxPrecisionTolerance) == 0x0002EC, "Member 'UGzWeaponCrosshair::MaxPrecisionTolerance' has a wrong offset!");
static_assert(offsetof(UGzWeaponCrosshair, LeavesContainer) == 0x0002F0, "Member 'UGzWeaponCrosshair::LeavesContainer' has a wrong offset!");
static_assert(offsetof(UGzWeaponCrosshair, ActiveWeapon) == 0x0002F8, "Member 'UGzWeaponCrosshair::ActiveWeapon' has a wrong offset!");
static_assert(offsetof(UGzWeaponCrosshair, ActiveWeaponSpreadSystem) == 0x000300, "Member 'UGzWeaponCrosshair::ActiveWeaponSpreadSystem' has a wrong offset!");
static_assert(offsetof(UGzWeaponCrosshair, CameraManager) == 0x000308, "Member 'UGzWeaponCrosshair::CameraManager' has a wrong offset!");

// Class G01.GzWeaponDamageDoneStatCollector
// 0x0010 (0x0048 - 0x0038)
class UGzWeaponDamageDoneStatCollector : public UGzGlobalStatsCollector
{
public:
	TArray<struct FGameplayAttribute>             TrackedAttributes;                                 // 0x0038(0x0010)(Edit, ZeroConstructor, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzWeaponDamageDoneStatCollector">();
	}
	static class UGzWeaponDamageDoneStatCollector* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzWeaponDamageDoneStatCollector>();
	}
};
static_assert(alignof(UGzWeaponDamageDoneStatCollector) == 0x000008, "Wrong alignment on UGzWeaponDamageDoneStatCollector");
static_assert(sizeof(UGzWeaponDamageDoneStatCollector) == 0x000048, "Wrong size on UGzWeaponDamageDoneStatCollector");
static_assert(offsetof(UGzWeaponDamageDoneStatCollector, TrackedAttributes) == 0x000038, "Member 'UGzWeaponDamageDoneStatCollector::TrackedAttributes' has a wrong offset!");

// Class G01.GzWeaponEquipmentConditionData
// 0x0010 (0x0040 - 0x0030)
class UGzWeaponEquipmentConditionData final : public UDataAsset
{
public:
	int32                                         RequiredParts;                                     // 0x0030(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         RequiredAnyPartsOfThis;                            // 0x0034(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3579[0x8];                                     // 0x0038(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzWeaponEquipmentConditionData">();
	}
	static class UGzWeaponEquipmentConditionData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzWeaponEquipmentConditionData>();
	}
};
static_assert(alignof(UGzWeaponEquipmentConditionData) == 0x000008, "Wrong alignment on UGzWeaponEquipmentConditionData");
static_assert(sizeof(UGzWeaponEquipmentConditionData) == 0x000040, "Wrong size on UGzWeaponEquipmentConditionData");
static_assert(offsetof(UGzWeaponEquipmentConditionData, RequiredParts) == 0x000030, "Member 'UGzWeaponEquipmentConditionData::RequiredParts' has a wrong offset!");
static_assert(offsetof(UGzWeaponEquipmentConditionData, RequiredAnyPartsOfThis) == 0x000034, "Member 'UGzWeaponEquipmentConditionData::RequiredAnyPartsOfThis' has a wrong offset!");

// Class G01.GzWeaponFXData
// 0x0058 (0x0088 - 0x0030)
class UGzWeaponFXData final : public UDataAsset
{
public:
	class UNiagaraSystem*                         MuzzleNiagaraSystem;                               // 0x0030(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UNiagaraSystem*                         InScope_MuzzleNiagaraSystem;                       // 0x0038(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UNiagaraSystem*                         ShellEjectNiagaraSystem;                           // 0x0040(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UNiagaraSystem*                         TraceNiagaraSystem;                                // 0x0048(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UNiagaraSystem*                         InScope_TraceNiagaraSystem;                        // 0x0050(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UNiagaraSystem*                         NoParticle_TraceNiagaraSystem;                     // 0x0058(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UNiagaraSystem*                         GlintNiagaraSystem;                                // 0x0060(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FGzScopeGlintConfig>            GlintConfig;                                       // 0x0068(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FGameplayTag                           PredictedImpactTag;                                // 0x0078(0x0008)(Edit, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           ApprovedImpactTag;                                 // 0x0080(0x0008)(Edit, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzWeaponFXData">();
	}
	static class UGzWeaponFXData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzWeaponFXData>();
	}
};
static_assert(alignof(UGzWeaponFXData) == 0x000008, "Wrong alignment on UGzWeaponFXData");
static_assert(sizeof(UGzWeaponFXData) == 0x000088, "Wrong size on UGzWeaponFXData");
static_assert(offsetof(UGzWeaponFXData, MuzzleNiagaraSystem) == 0x000030, "Member 'UGzWeaponFXData::MuzzleNiagaraSystem' has a wrong offset!");
static_assert(offsetof(UGzWeaponFXData, InScope_MuzzleNiagaraSystem) == 0x000038, "Member 'UGzWeaponFXData::InScope_MuzzleNiagaraSystem' has a wrong offset!");
static_assert(offsetof(UGzWeaponFXData, ShellEjectNiagaraSystem) == 0x000040, "Member 'UGzWeaponFXData::ShellEjectNiagaraSystem' has a wrong offset!");
static_assert(offsetof(UGzWeaponFXData, TraceNiagaraSystem) == 0x000048, "Member 'UGzWeaponFXData::TraceNiagaraSystem' has a wrong offset!");
static_assert(offsetof(UGzWeaponFXData, InScope_TraceNiagaraSystem) == 0x000050, "Member 'UGzWeaponFXData::InScope_TraceNiagaraSystem' has a wrong offset!");
static_assert(offsetof(UGzWeaponFXData, NoParticle_TraceNiagaraSystem) == 0x000058, "Member 'UGzWeaponFXData::NoParticle_TraceNiagaraSystem' has a wrong offset!");
static_assert(offsetof(UGzWeaponFXData, GlintNiagaraSystem) == 0x000060, "Member 'UGzWeaponFXData::GlintNiagaraSystem' has a wrong offset!");
static_assert(offsetof(UGzWeaponFXData, GlintConfig) == 0x000068, "Member 'UGzWeaponFXData::GlintConfig' has a wrong offset!");
static_assert(offsetof(UGzWeaponFXData, PredictedImpactTag) == 0x000078, "Member 'UGzWeaponFXData::PredictedImpactTag' has a wrong offset!");
static_assert(offsetof(UGzWeaponFXData, ApprovedImpactTag) == 0x000080, "Member 'UGzWeaponFXData::ApprovedImpactTag' has a wrong offset!");

// Class G01.GzWeaponStatics
// 0x0000 (0x0028 - 0x0028)
class UGzWeaponStatics final : public UBlueprintFunctionLibrary
{
public:
	static void AttachComponentToWeapon(class USceneComponent* ComponentToAttach, const class AActor* WeaponActor, const class FName SocketName, bool bNeedCheck);
	static TArray<struct FGzInventoryItemContent> GetAllArchetypeCombinations(class UGzWeaponItemData* WeaponItemData);
	static int32 GetAmmoCount(class UGzWeaponComponent* WeaponComponent, bool bInClip, bool bInStock);
	static int32 GetAmmoCountForWeaponPocket(const class APawn* Char, const struct FGzInvPocketId& DedicatedPocketID, bool bInClip, bool bInStock);
	static class UGzAmmoItemData* GetAmmoItemDataForWeaponData(const class UGzWeaponData* WeaponData);
	static struct FGameplayTag GetAmmoType(class UGzWeaponComponent* WeaponComponent);
	static float GetUIAccuracy(class UGzWeaponItemData* WeaponItemData, const TArray<class UGzWeaponAttachmentItemData*>& AttachmentsData);
	static float GetUIClipSize(class UGzWeaponItemData* WeaponItemData, const TArray<class UGzWeaponAttachmentItemData*>& AttachmentsData);
	static float GetUIDamage(class UGzWeaponItemData* WeaponItemData, const TArray<class UGzWeaponAttachmentItemData*>& AttachmentsData);
	static float GetUIFireRate(class UGzWeaponItemData* WeaponItemData, const TArray<class UGzWeaponAttachmentItemData*>& AttachmentsData);
	static float GetUIHandling(class UGzWeaponItemData* WeaponItemData, const TArray<class UGzWeaponAttachmentItemData*>& AttachmentsData);
	static float GetUIMobility(class UGzWeaponItemData* WeaponItemData, const TArray<class UGzWeaponAttachmentItemData*>& AttachmentsData);
	static float GetUIRange(class UGzWeaponItemData* WeaponItemData, const TArray<class UGzWeaponAttachmentItemData*>& AttachmentsData);
	static float GetUIRecoil(class UGzWeaponItemData* WeaponItemData, const TArray<class UGzWeaponAttachmentItemData*>& AttachmentsData);
	static bool IsActiveWeaponClipEmpty(class APawn* Char);
	static bool IsActiveWeaponClipFull(class APawn* Char);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzWeaponStatics">();
	}
	static class UGzWeaponStatics* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzWeaponStatics>();
	}
};
static_assert(alignof(UGzWeaponStatics) == 0x000008, "Wrong alignment on UGzWeaponStatics");
static_assert(sizeof(UGzWeaponStatics) == 0x000028, "Wrong size on UGzWeaponStatics");

// Class G01.GzWeaponKillsStatCollector
// 0x0008 (0x0040 - 0x0038)
class UGzWeaponKillsStatCollector final : public UGzGlobalStatsCollector
{
public:
	uint8                                         Pad_3587[0x8];                                     // 0x0038(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzWeaponKillsStatCollector">();
	}
	static class UGzWeaponKillsStatCollector* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzWeaponKillsStatCollector>();
	}
};
static_assert(alignof(UGzWeaponKillsStatCollector) == 0x000008, "Wrong alignment on UGzWeaponKillsStatCollector");
static_assert(sizeof(UGzWeaponKillsStatCollector) == 0x000040, "Wrong size on UGzWeaponKillsStatCollector");

// Class G01.GzWeaponKnockDownStatCollector
// 0x0008 (0x0040 - 0x0038)
class UGzWeaponKnockDownStatCollector final : public UGzGlobalStatsCollector
{
public:
	uint8                                         Pad_3588[0x8];                                     // 0x0038(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzWeaponKnockDownStatCollector">();
	}
	static class UGzWeaponKnockDownStatCollector* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzWeaponKnockDownStatCollector>();
	}
};
static_assert(alignof(UGzWeaponKnockDownStatCollector) == 0x000008, "Wrong alignment on UGzWeaponKnockDownStatCollector");
static_assert(sizeof(UGzWeaponKnockDownStatCollector) == 0x000040, "Wrong size on UGzWeaponKnockDownStatCollector");

// Class G01.GzWeaponRecoilModifier
// 0x0010 (0x0038 - 0x0028)
class UGzWeaponRecoilModifier final : public UGzWeaponModifier
{
public:
	float                                         HorizontalHandlingCoefficient;                     // 0x0028(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         VerticalHandlingCoefficient;                       // 0x002C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TravelTimeCoefficient;                             // 0x0030(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CooldownTimeCoefficient;                           // 0x0034(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzWeaponRecoilModifier">();
	}
	static class UGzWeaponRecoilModifier* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzWeaponRecoilModifier>();
	}
};
static_assert(alignof(UGzWeaponRecoilModifier) == 0x000008, "Wrong alignment on UGzWeaponRecoilModifier");
static_assert(sizeof(UGzWeaponRecoilModifier) == 0x000038, "Wrong size on UGzWeaponRecoilModifier");
static_assert(offsetof(UGzWeaponRecoilModifier, HorizontalHandlingCoefficient) == 0x000028, "Member 'UGzWeaponRecoilModifier::HorizontalHandlingCoefficient' has a wrong offset!");
static_assert(offsetof(UGzWeaponRecoilModifier, VerticalHandlingCoefficient) == 0x00002C, "Member 'UGzWeaponRecoilModifier::VerticalHandlingCoefficient' has a wrong offset!");
static_assert(offsetof(UGzWeaponRecoilModifier, TravelTimeCoefficient) == 0x000030, "Member 'UGzWeaponRecoilModifier::TravelTimeCoefficient' has a wrong offset!");
static_assert(offsetof(UGzWeaponRecoilModifier, CooldownTimeCoefficient) == 0x000034, "Member 'UGzWeaponRecoilModifier::CooldownTimeCoefficient' has a wrong offset!");

// Class G01.GzWeaponResourceModifier
// 0x0008 (0x0030 - 0x0028)
class UGzWeaponResourceModifier final : public UGzWeaponModifier
{
public:
	int32                                         ClipSizeOverride;                                  // 0x0028(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ResourceDrainPerConsumeOverride;                   // 0x002C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzWeaponResourceModifier">();
	}
	static class UGzWeaponResourceModifier* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzWeaponResourceModifier>();
	}
};
static_assert(alignof(UGzWeaponResourceModifier) == 0x000008, "Wrong alignment on UGzWeaponResourceModifier");
static_assert(sizeof(UGzWeaponResourceModifier) == 0x000030, "Wrong size on UGzWeaponResourceModifier");
static_assert(offsetof(UGzWeaponResourceModifier, ClipSizeOverride) == 0x000028, "Member 'UGzWeaponResourceModifier::ClipSizeOverride' has a wrong offset!");
static_assert(offsetof(UGzWeaponResourceModifier, ResourceDrainPerConsumeOverride) == 0x00002C, "Member 'UGzWeaponResourceModifier::ResourceDrainPerConsumeOverride' has a wrong offset!");

// Class G01.GzWeaponAttackModifier
// 0x0060 (0x0088 - 0x0028)
class UGzWeaponAttackModifier final : public UGzWeaponModifier
{
public:
	float                                         RPMCoefficient;                                    // 0x0028(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ProjectilesPerShotAddendum;                        // 0x002C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FalloffRangePercentageAddendum;                    // 0x0030(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FalloffStrengthPercentageAddendum;                 // 0x0034(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMap<struct FGameplayTag, float>              DamageMultiplierMap;                               // 0x0038(0x0050)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzWeaponAttackModifier">();
	}
	static class UGzWeaponAttackModifier* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzWeaponAttackModifier>();
	}
};
static_assert(alignof(UGzWeaponAttackModifier) == 0x000008, "Wrong alignment on UGzWeaponAttackModifier");
static_assert(sizeof(UGzWeaponAttackModifier) == 0x000088, "Wrong size on UGzWeaponAttackModifier");
static_assert(offsetof(UGzWeaponAttackModifier, RPMCoefficient) == 0x000028, "Member 'UGzWeaponAttackModifier::RPMCoefficient' has a wrong offset!");
static_assert(offsetof(UGzWeaponAttackModifier, ProjectilesPerShotAddendum) == 0x00002C, "Member 'UGzWeaponAttackModifier::ProjectilesPerShotAddendum' has a wrong offset!");
static_assert(offsetof(UGzWeaponAttackModifier, FalloffRangePercentageAddendum) == 0x000030, "Member 'UGzWeaponAttackModifier::FalloffRangePercentageAddendum' has a wrong offset!");
static_assert(offsetof(UGzWeaponAttackModifier, FalloffStrengthPercentageAddendum) == 0x000034, "Member 'UGzWeaponAttackModifier::FalloffStrengthPercentageAddendum' has a wrong offset!");
static_assert(offsetof(UGzWeaponAttackModifier, DamageMultiplierMap) == 0x000038, "Member 'UGzWeaponAttackModifier::DamageMultiplierMap' has a wrong offset!");

// Class G01.GzWeaponAnimationModifier
// 0x0008 (0x0030 - 0x0028)
class UGzWeaponAnimationModifier final : public UGzWeaponModifier
{
public:
	EGzWeaponSupportHoldType                      LHBodySupportHoldTypeOverride;                     // 0x0028(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3589[0x7];                                     // 0x0029(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzWeaponAnimationModifier">();
	}
	static class UGzWeaponAnimationModifier* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzWeaponAnimationModifier>();
	}
};
static_assert(alignof(UGzWeaponAnimationModifier) == 0x000008, "Wrong alignment on UGzWeaponAnimationModifier");
static_assert(sizeof(UGzWeaponAnimationModifier) == 0x000030, "Wrong size on UGzWeaponAnimationModifier");
static_assert(offsetof(UGzWeaponAnimationModifier, LHBodySupportHoldTypeOverride) == 0x000028, "Member 'UGzWeaponAnimationModifier::LHBodySupportHoldTypeOverride' has a wrong offset!");

// Class G01.GzWeaponSoundModifier
// 0x0018 (0x0040 - 0x0028)
class UGzWeaponSoundModifier final : public UGzWeaponModifier
{
public:
	class UAkAudioEvent*                          FireSoundCueOverride;                              // 0x0028(0x0008)(Edit, ZeroConstructor, EditConst, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UGzWeaponSoundData*                     FireSoundOverrides;                                // 0x0030(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bSilencer;                                         // 0x0038(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_358A[0x7];                                     // 0x0039(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzWeaponSoundModifier">();
	}
	static class UGzWeaponSoundModifier* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzWeaponSoundModifier>();
	}
};
static_assert(alignof(UGzWeaponSoundModifier) == 0x000008, "Wrong alignment on UGzWeaponSoundModifier");
static_assert(sizeof(UGzWeaponSoundModifier) == 0x000040, "Wrong size on UGzWeaponSoundModifier");
static_assert(offsetof(UGzWeaponSoundModifier, FireSoundCueOverride) == 0x000028, "Member 'UGzWeaponSoundModifier::FireSoundCueOverride' has a wrong offset!");
static_assert(offsetof(UGzWeaponSoundModifier, FireSoundOverrides) == 0x000030, "Member 'UGzWeaponSoundModifier::FireSoundOverrides' has a wrong offset!");
static_assert(offsetof(UGzWeaponSoundModifier, bSilencer) == 0x000038, "Member 'UGzWeaponSoundModifier::bSilencer' has a wrong offset!");

// Class G01.GzWeaponReloadModifier
// 0x0010 (0x0038 - 0x0028)
class UGzWeaponReloadModifier final : public UGzWeaponModifier
{
public:
	TArray<struct FGzWeaponReloadAnimationData>   ReloadDataPerSituation;                            // 0x0028(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzWeaponReloadModifier">();
	}
	static class UGzWeaponReloadModifier* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzWeaponReloadModifier>();
	}
};
static_assert(alignof(UGzWeaponReloadModifier) == 0x000008, "Wrong alignment on UGzWeaponReloadModifier");
static_assert(sizeof(UGzWeaponReloadModifier) == 0x000038, "Wrong size on UGzWeaponReloadModifier");
static_assert(offsetof(UGzWeaponReloadModifier, ReloadDataPerSituation) == 0x000028, "Member 'UGzWeaponReloadModifier::ReloadDataPerSituation' has a wrong offset!");

// Class G01.GzWeaponBulletFXModifier
// 0x0028 (0x0050 - 0x0028)
class UGzWeaponBulletFXModifier final : public UGzWeaponModifier
{
public:
	float                                         ParticleSpawnOffsetOverride;                       // 0x0028(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_358B[0x4];                                     // 0x002C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                ParticleSpawnOffsetOverride_Scope;                 // 0x0030(0x0018)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UNiagaraSystem*                         BulletNiagaraSystemOverride;                       // 0x0048(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzWeaponBulletFXModifier">();
	}
	static class UGzWeaponBulletFXModifier* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzWeaponBulletFXModifier>();
	}
};
static_assert(alignof(UGzWeaponBulletFXModifier) == 0x000008, "Wrong alignment on UGzWeaponBulletFXModifier");
static_assert(sizeof(UGzWeaponBulletFXModifier) == 0x000050, "Wrong size on UGzWeaponBulletFXModifier");
static_assert(offsetof(UGzWeaponBulletFXModifier, ParticleSpawnOffsetOverride) == 0x000028, "Member 'UGzWeaponBulletFXModifier::ParticleSpawnOffsetOverride' has a wrong offset!");
static_assert(offsetof(UGzWeaponBulletFXModifier, ParticleSpawnOffsetOverride_Scope) == 0x000030, "Member 'UGzWeaponBulletFXModifier::ParticleSpawnOffsetOverride_Scope' has a wrong offset!");
static_assert(offsetof(UGzWeaponBulletFXModifier, BulletNiagaraSystemOverride) == 0x000048, "Member 'UGzWeaponBulletFXModifier::BulletNiagaraSystemOverride' has a wrong offset!");

// Class G01.GzWeaponCameraShakeModifier
// 0x0010 (0x0038 - 0x0028)
class UGzWeaponCameraShakeModifier final : public UGzWeaponModifier
{
public:
	TSubclassOf<class UCameraShakeBase>           ShotCameraShake;                                   // 0x0028(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UCameraShakeBase>           ShotADSCameraShake;                                // 0x0030(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzWeaponCameraShakeModifier">();
	}
	static class UGzWeaponCameraShakeModifier* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzWeaponCameraShakeModifier>();
	}
};
static_assert(alignof(UGzWeaponCameraShakeModifier) == 0x000008, "Wrong alignment on UGzWeaponCameraShakeModifier");
static_assert(sizeof(UGzWeaponCameraShakeModifier) == 0x000038, "Wrong size on UGzWeaponCameraShakeModifier");
static_assert(offsetof(UGzWeaponCameraShakeModifier, ShotCameraShake) == 0x000028, "Member 'UGzWeaponCameraShakeModifier::ShotCameraShake' has a wrong offset!");
static_assert(offsetof(UGzWeaponCameraShakeModifier, ShotADSCameraShake) == 0x000030, "Member 'UGzWeaponCameraShakeModifier::ShotADSCameraShake' has a wrong offset!");

// Class G01.GzWeaponOverheatData
// 0x0018 (0x0048 - 0x0030)
class UGzWeaponOverheatData final : public UDataAsset
{
public:
	float                                         OverheatLimit;                                     // 0x0030(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         OverheatIncreasePerConsume;                        // 0x0034(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         OverheatCooldownPerSecond;                         // 0x0038(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FullOverheatCooldownModifier;                      // 0x003C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseOverheatTimer;                                 // 0x0040(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_358C[0x3];                                     // 0x0041(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         OverheatCooldownDelaySecondsAfterLimit;            // 0x0044(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzWeaponOverheatData">();
	}
	static class UGzWeaponOverheatData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzWeaponOverheatData>();
	}
};
static_assert(alignof(UGzWeaponOverheatData) == 0x000008, "Wrong alignment on UGzWeaponOverheatData");
static_assert(sizeof(UGzWeaponOverheatData) == 0x000048, "Wrong size on UGzWeaponOverheatData");
static_assert(offsetof(UGzWeaponOverheatData, OverheatLimit) == 0x000030, "Member 'UGzWeaponOverheatData::OverheatLimit' has a wrong offset!");
static_assert(offsetof(UGzWeaponOverheatData, OverheatIncreasePerConsume) == 0x000034, "Member 'UGzWeaponOverheatData::OverheatIncreasePerConsume' has a wrong offset!");
static_assert(offsetof(UGzWeaponOverheatData, OverheatCooldownPerSecond) == 0x000038, "Member 'UGzWeaponOverheatData::OverheatCooldownPerSecond' has a wrong offset!");
static_assert(offsetof(UGzWeaponOverheatData, FullOverheatCooldownModifier) == 0x00003C, "Member 'UGzWeaponOverheatData::FullOverheatCooldownModifier' has a wrong offset!");
static_assert(offsetof(UGzWeaponOverheatData, bUseOverheatTimer) == 0x000040, "Member 'UGzWeaponOverheatData::bUseOverheatTimer' has a wrong offset!");
static_assert(offsetof(UGzWeaponOverheatData, OverheatCooldownDelaySecondsAfterLimit) == 0x000044, "Member 'UGzWeaponOverheatData::OverheatCooldownDelaySecondsAfterLimit' has a wrong offset!");

// Class G01.GzWeaponOverheatSystem
// 0x0010 (0x0048 - 0x0038)
class UGzWeaponOverheatSystem final : public UGzWeaponSystemBase
{
public:
	bool                                          bIsHostOverheated;                                 // 0x0038(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_358D[0xF];                                     // 0x0039(0x000F)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	float GetOverheatPercentage() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzWeaponOverheatSystem">();
	}
	static class UGzWeaponOverheatSystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzWeaponOverheatSystem>();
	}
};
static_assert(alignof(UGzWeaponOverheatSystem) == 0x000008, "Wrong alignment on UGzWeaponOverheatSystem");
static_assert(sizeof(UGzWeaponOverheatSystem) == 0x000048, "Wrong size on UGzWeaponOverheatSystem");
static_assert(offsetof(UGzWeaponOverheatSystem, bIsHostOverheated) == 0x000038, "Member 'UGzWeaponOverheatSystem::bIsHostOverheated' has a wrong offset!");

// Class G01.GzWeaponPocketWidget
// 0x0060 (0x03C0 - 0x0360)
class UGzWeaponPocketWidget : public UGzEquipmentPocketWidget
{
public:
	TMap<struct FGameplayTag, struct FGameplayTag> SlotEquipEvents;                                   // 0x0360(0x0050)(Edit, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_358E[0x10];                                    // 0x03B0(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnOwnerLimbChanged(EGzLimbType Limb);
	void OnWeaponEquipped(const struct FGzInvPocketId& InvPocketId, const class AGzWeaponActor* WeaponActor, bool bEquipped);
	void RefreshClipAmount();
	void RefreshEquipCondition(bool bCanEquip);
	void UpdateEquipped(bool bEquipped);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzWeaponPocketWidget">();
	}
	static class UGzWeaponPocketWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzWeaponPocketWidget>();
	}
};
static_assert(alignof(UGzWeaponPocketWidget) == 0x000008, "Wrong alignment on UGzWeaponPocketWidget");
static_assert(sizeof(UGzWeaponPocketWidget) == 0x0003C0, "Wrong size on UGzWeaponPocketWidget");
static_assert(offsetof(UGzWeaponPocketWidget, SlotEquipEvents) == 0x000360, "Member 'UGzWeaponPocketWidget::SlotEquipEvents' has a wrong offset!");

// Class G01.GzZipline
// 0x0470 (0x0710 - 0x02A0)
class AGzZipline : public AActor
{
public:
	class UGzZiplineBuildSplineStrategy*          BuildSplineStrategy;                               // 0x02A0(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, PersistentInstance, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         SegmentLength;                                     // 0x02A8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3590[0x4];                                     // 0x02AC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UStaticMeshComponent*                   StartAndEndEdgeSegmentMeshes[0x2];                 // 0x02B0(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FTransform                             StartEdgeSegmentOffset;                            // 0x02C0(0x0060)(Edit, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FTransform                             EndEdgeSegmentOffset;                              // 0x0320(0x0060)(Edit, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UStaticMesh*                            SegmentMesh;                                       // 0x0380(0x0008)(Edit, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UStaticMesh*                            StartEdgeSegmentMesh;                              // 0x0388(0x0008)(Edit, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UStaticMesh*                            EndEdgeSegmentMesh;                                // 0x0390(0x0008)(Edit, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         StartPointExitImpulseMagnitude;                    // 0x0398(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         EndPointExitImpulseMagnitude;                      // 0x039C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UStreamableRenderAsset*                 StartPointMeshAsset;                               // 0x03A0(0x0008)(Edit, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UStreamableRenderAsset*                 EndPointMeshAsset;                                 // 0x03A8(0x0008)(Edit, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bUseStartPointMeshForEndPoint;                     // 0x03B0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bVerticalZipline;                                  // 0x03B1(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3591[0xE];                                     // 0x03B2(0x000E)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             StartPointMeshOffset;                              // 0x03C0(0x0060)(Edit, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FTransform                             EndPointMeshOffset;                                // 0x0420(0x0060)(Edit, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MaxSplineEdgeLength;                               // 0x0480(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         FromSplineStartDismountDistance;                   // 0x0484(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         FromSplineEndDismountDistance;                     // 0x0488(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3592[0x4];                                     // 0x048C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGzLandingTransformOffsets             LandingTransformOffsetAtStart;                     // 0x0490(0x0030)(Edit, DisableEditOnInstance, NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FGzLandingTransformOffsets             LandingTransformOffsetAtEnd;                       // 0x04C0(0x0030)(Edit, DisableEditOnInstance, NoDestructor, Protected, NativeAccessSpecifierProtected)
	class UStaticMesh*                            PillarMesh;                                        // 0x04F0(0x0008)(Edit, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3593[0x8];                                     // 0x04F8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             PillarMeshOffset;                                  // 0x0500(0x0060)(Edit, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         PillarAmountPerMeter;                              // 0x0560(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3594[0x4];                                     // 0x0564(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                CharacterOffset;                                   // 0x0568(0x0018)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FTransform                             LandingTransformAtStart;                           // 0x0580(0x0060)(IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FTransform                             LandingTransformAtEnd;                             // 0x05E0(0x0060)(IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bRelocationZipline;                                // 0x0640(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3595[0x3];                                     // 0x0641(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         EndMovementDetachForceUpward;                      // 0x0644(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         EndMovementDetachForceForward;                     // 0x0648(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         CancelMovementDetachForceUpward;                   // 0x064C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         CancelMovementDetachForceForward;                  // 0x0650(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3596[0x4];                                     // 0x0654(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class USplineComponent*                       Spline;                                            // 0x0658(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class USplineMeshComponent*>           SplineMeshes;                                      // 0x0660(0x0010)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, EditConst, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	class UMeshComponent*                         StartAndEndMeshes[0x2];                            // 0x0670(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	ECollisionEnabled                             StartAndEndMeshesCollision;                        // 0x0680(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3597[0x7];                                     // 0x0681(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UInstancedStaticMeshComponent*          StartAndEndMeshesContainer;                        // 0x0688(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UInstancedStaticMeshComponent*          PillarMeshesContainer;                             // 0x0690(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UArrowComponent*                        SplineDirection;                                   // 0x0698(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UArrowComponent*                        StartPointExitImpulseDirection;                    // 0x06A0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UArrowComponent*                        EndPointExitImpulseDirection;                      // 0x06A8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UGzInteractableComponent*               InteractableComponent;                             // 0x06B0(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                CurrentLandingTransformOffsetAtStart;              // 0x06B8(0x0018)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                CurrentLandingTransformOffsetAtEnd;                // 0x06D0(0x0018)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3598[0x28];                                    // 0x06E8(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ClearZipline();
	class UStaticMeshComponent* GetEndEdgeSegmentMeshComponent();
	class UMeshComponent* GetEndMeshComponent();
	class UStaticMeshComponent* GetStartEdgeSegmentMeshComponent();
	class UMeshComponent* GetStartMeshComponent();
	void OnInteract(class AActor* InteractedBy, const class UGzInteractableComponent* Interactable);
	void RebuildZipline();

	struct FVector GetLocationAtMovementAlongZiplineProgressOnSpline(const struct FGzZiplineMovementRuntimeData& ZiplineData, ESplineCoordinateSpace CoordinateSpace) const;
	bool IsVertical() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzZipline">();
	}
	static class AGzZipline* GetDefaultObj()
	{
		return GetDefaultObjImpl<AGzZipline>();
	}
};
static_assert(alignof(AGzZipline) == 0x000010, "Wrong alignment on AGzZipline");
static_assert(sizeof(AGzZipline) == 0x000710, "Wrong size on AGzZipline");
static_assert(offsetof(AGzZipline, BuildSplineStrategy) == 0x0002A0, "Member 'AGzZipline::BuildSplineStrategy' has a wrong offset!");
static_assert(offsetof(AGzZipline, SegmentLength) == 0x0002A8, "Member 'AGzZipline::SegmentLength' has a wrong offset!");
static_assert(offsetof(AGzZipline, StartAndEndEdgeSegmentMeshes) == 0x0002B0, "Member 'AGzZipline::StartAndEndEdgeSegmentMeshes' has a wrong offset!");
static_assert(offsetof(AGzZipline, StartEdgeSegmentOffset) == 0x0002C0, "Member 'AGzZipline::StartEdgeSegmentOffset' has a wrong offset!");
static_assert(offsetof(AGzZipline, EndEdgeSegmentOffset) == 0x000320, "Member 'AGzZipline::EndEdgeSegmentOffset' has a wrong offset!");
static_assert(offsetof(AGzZipline, SegmentMesh) == 0x000380, "Member 'AGzZipline::SegmentMesh' has a wrong offset!");
static_assert(offsetof(AGzZipline, StartEdgeSegmentMesh) == 0x000388, "Member 'AGzZipline::StartEdgeSegmentMesh' has a wrong offset!");
static_assert(offsetof(AGzZipline, EndEdgeSegmentMesh) == 0x000390, "Member 'AGzZipline::EndEdgeSegmentMesh' has a wrong offset!");
static_assert(offsetof(AGzZipline, StartPointExitImpulseMagnitude) == 0x000398, "Member 'AGzZipline::StartPointExitImpulseMagnitude' has a wrong offset!");
static_assert(offsetof(AGzZipline, EndPointExitImpulseMagnitude) == 0x00039C, "Member 'AGzZipline::EndPointExitImpulseMagnitude' has a wrong offset!");
static_assert(offsetof(AGzZipline, StartPointMeshAsset) == 0x0003A0, "Member 'AGzZipline::StartPointMeshAsset' has a wrong offset!");
static_assert(offsetof(AGzZipline, EndPointMeshAsset) == 0x0003A8, "Member 'AGzZipline::EndPointMeshAsset' has a wrong offset!");
static_assert(offsetof(AGzZipline, bUseStartPointMeshForEndPoint) == 0x0003B0, "Member 'AGzZipline::bUseStartPointMeshForEndPoint' has a wrong offset!");
static_assert(offsetof(AGzZipline, bVerticalZipline) == 0x0003B1, "Member 'AGzZipline::bVerticalZipline' has a wrong offset!");
static_assert(offsetof(AGzZipline, StartPointMeshOffset) == 0x0003C0, "Member 'AGzZipline::StartPointMeshOffset' has a wrong offset!");
static_assert(offsetof(AGzZipline, EndPointMeshOffset) == 0x000420, "Member 'AGzZipline::EndPointMeshOffset' has a wrong offset!");
static_assert(offsetof(AGzZipline, MaxSplineEdgeLength) == 0x000480, "Member 'AGzZipline::MaxSplineEdgeLength' has a wrong offset!");
static_assert(offsetof(AGzZipline, FromSplineStartDismountDistance) == 0x000484, "Member 'AGzZipline::FromSplineStartDismountDistance' has a wrong offset!");
static_assert(offsetof(AGzZipline, FromSplineEndDismountDistance) == 0x000488, "Member 'AGzZipline::FromSplineEndDismountDistance' has a wrong offset!");
static_assert(offsetof(AGzZipline, LandingTransformOffsetAtStart) == 0x000490, "Member 'AGzZipline::LandingTransformOffsetAtStart' has a wrong offset!");
static_assert(offsetof(AGzZipline, LandingTransformOffsetAtEnd) == 0x0004C0, "Member 'AGzZipline::LandingTransformOffsetAtEnd' has a wrong offset!");
static_assert(offsetof(AGzZipline, PillarMesh) == 0x0004F0, "Member 'AGzZipline::PillarMesh' has a wrong offset!");
static_assert(offsetof(AGzZipline, PillarMeshOffset) == 0x000500, "Member 'AGzZipline::PillarMeshOffset' has a wrong offset!");
static_assert(offsetof(AGzZipline, PillarAmountPerMeter) == 0x000560, "Member 'AGzZipline::PillarAmountPerMeter' has a wrong offset!");
static_assert(offsetof(AGzZipline, CharacterOffset) == 0x000568, "Member 'AGzZipline::CharacterOffset' has a wrong offset!");
static_assert(offsetof(AGzZipline, LandingTransformAtStart) == 0x000580, "Member 'AGzZipline::LandingTransformAtStart' has a wrong offset!");
static_assert(offsetof(AGzZipline, LandingTransformAtEnd) == 0x0005E0, "Member 'AGzZipline::LandingTransformAtEnd' has a wrong offset!");
static_assert(offsetof(AGzZipline, bRelocationZipline) == 0x000640, "Member 'AGzZipline::bRelocationZipline' has a wrong offset!");
static_assert(offsetof(AGzZipline, EndMovementDetachForceUpward) == 0x000644, "Member 'AGzZipline::EndMovementDetachForceUpward' has a wrong offset!");
static_assert(offsetof(AGzZipline, EndMovementDetachForceForward) == 0x000648, "Member 'AGzZipline::EndMovementDetachForceForward' has a wrong offset!");
static_assert(offsetof(AGzZipline, CancelMovementDetachForceUpward) == 0x00064C, "Member 'AGzZipline::CancelMovementDetachForceUpward' has a wrong offset!");
static_assert(offsetof(AGzZipline, CancelMovementDetachForceForward) == 0x000650, "Member 'AGzZipline::CancelMovementDetachForceForward' has a wrong offset!");
static_assert(offsetof(AGzZipline, Spline) == 0x000658, "Member 'AGzZipline::Spline' has a wrong offset!");
static_assert(offsetof(AGzZipline, SplineMeshes) == 0x000660, "Member 'AGzZipline::SplineMeshes' has a wrong offset!");
static_assert(offsetof(AGzZipline, StartAndEndMeshes) == 0x000670, "Member 'AGzZipline::StartAndEndMeshes' has a wrong offset!");
static_assert(offsetof(AGzZipline, StartAndEndMeshesCollision) == 0x000680, "Member 'AGzZipline::StartAndEndMeshesCollision' has a wrong offset!");
static_assert(offsetof(AGzZipline, StartAndEndMeshesContainer) == 0x000688, "Member 'AGzZipline::StartAndEndMeshesContainer' has a wrong offset!");
static_assert(offsetof(AGzZipline, PillarMeshesContainer) == 0x000690, "Member 'AGzZipline::PillarMeshesContainer' has a wrong offset!");
static_assert(offsetof(AGzZipline, SplineDirection) == 0x000698, "Member 'AGzZipline::SplineDirection' has a wrong offset!");
static_assert(offsetof(AGzZipline, StartPointExitImpulseDirection) == 0x0006A0, "Member 'AGzZipline::StartPointExitImpulseDirection' has a wrong offset!");
static_assert(offsetof(AGzZipline, EndPointExitImpulseDirection) == 0x0006A8, "Member 'AGzZipline::EndPointExitImpulseDirection' has a wrong offset!");
static_assert(offsetof(AGzZipline, InteractableComponent) == 0x0006B0, "Member 'AGzZipline::InteractableComponent' has a wrong offset!");
static_assert(offsetof(AGzZipline, CurrentLandingTransformOffsetAtStart) == 0x0006B8, "Member 'AGzZipline::CurrentLandingTransformOffsetAtStart' has a wrong offset!");
static_assert(offsetof(AGzZipline, CurrentLandingTransformOffsetAtEnd) == 0x0006D0, "Member 'AGzZipline::CurrentLandingTransformOffsetAtEnd' has a wrong offset!");

// Class G01.GzWeaponRecoilCompensatingChecker
// 0x0030 (0x0058 - 0x0028)
class UGzWeaponRecoilCompensatingChecker final : public UObject
{
public:
	uint8                                         Pad_359A[0x10];                                    // 0x0028(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FGzTimedRotation>               CachedPlayerRotations;                             // 0x0038(0x0010)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	class UGzWeaponRecoilData*                    CachedRecoilData;                                  // 0x0048(0x0008)(ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_359B[0x8];                                     // 0x0050(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnPlayerInputRotatationReceived(const class AGzPlayerCharacter* Player, EGzPlayerInputRotatationType ViewInputType, float Value);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzWeaponRecoilCompensatingChecker">();
	}
	static class UGzWeaponRecoilCompensatingChecker* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzWeaponRecoilCompensatingChecker>();
	}
};
static_assert(alignof(UGzWeaponRecoilCompensatingChecker) == 0x000008, "Wrong alignment on UGzWeaponRecoilCompensatingChecker");
static_assert(sizeof(UGzWeaponRecoilCompensatingChecker) == 0x000058, "Wrong size on UGzWeaponRecoilCompensatingChecker");
static_assert(offsetof(UGzWeaponRecoilCompensatingChecker, CachedPlayerRotations) == 0x000038, "Member 'UGzWeaponRecoilCompensatingChecker::CachedPlayerRotations' has a wrong offset!");
static_assert(offsetof(UGzWeaponRecoilCompensatingChecker, CachedRecoilData) == 0x000048, "Member 'UGzWeaponRecoilCompensatingChecker::CachedRecoilData' has a wrong offset!");

// Class G01.GzWeaponRecoilData
// 0x0078 (0x00A8 - 0x0030)
class UGzWeaponRecoilData final : public UDataAsset
{
public:
	bool                                          bUseCasualRecoil;                                  // 0x0030(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_359D[0x7];                                     // 0x0031(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FGzWeaponRecoilShotData>        ShotDataSettings;                                  // 0x0038(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	bool                                          bUseRPMIntervalForAimingShiftTravelTime;           // 0x0048(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_359E[0x3];                                     // 0x0049(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         AimingShiftTravelTimeSeconds;                      // 0x004C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCurveFloat*                            AimingShiftCurve;                                  // 0x0050(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DelayBeforePostRecoilTraveling;                    // 0x0058(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PostRecoilTravelAngularSpeed;                      // 0x005C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCurveFloat*                            PostRecoilTravelCurve;                             // 0x0060(0x0008)(Edit, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CasualAimingShiftTravelTimeSeconds;                // 0x0068(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_359F[0x4];                                     // 0x006C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UCurveFloat*                            CasualAimingShiftCurve;                            // 0x0070(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RecoilDegreeAnglePerShot;                          // 0x0078(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxRecoilDegreeAngle;                              // 0x007C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxRandomVerticalDeviation;                        // 0x0080(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinRandomVerticalDeviation;                        // 0x0084(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HorizontalDeviation;                               // 0x0088(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxHorizontalDeviation;                            // 0x008C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CasualDelayBeforePostRecoilTraveling;              // 0x0090(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_35A0[0x4];                                     // 0x0094(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UCurveFloat*                            RecoilTravelBackSpeedCurve;                        // 0x0098(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RecoilPatternWorstCompensatingAngle;               // 0x00A0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         WorstCompensatingAngleMultiplier;                  // 0x00A4(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzWeaponRecoilData">();
	}
	static class UGzWeaponRecoilData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzWeaponRecoilData>();
	}
};
static_assert(alignof(UGzWeaponRecoilData) == 0x000008, "Wrong alignment on UGzWeaponRecoilData");
static_assert(sizeof(UGzWeaponRecoilData) == 0x0000A8, "Wrong size on UGzWeaponRecoilData");
static_assert(offsetof(UGzWeaponRecoilData, bUseCasualRecoil) == 0x000030, "Member 'UGzWeaponRecoilData::bUseCasualRecoil' has a wrong offset!");
static_assert(offsetof(UGzWeaponRecoilData, ShotDataSettings) == 0x000038, "Member 'UGzWeaponRecoilData::ShotDataSettings' has a wrong offset!");
static_assert(offsetof(UGzWeaponRecoilData, bUseRPMIntervalForAimingShiftTravelTime) == 0x000048, "Member 'UGzWeaponRecoilData::bUseRPMIntervalForAimingShiftTravelTime' has a wrong offset!");
static_assert(offsetof(UGzWeaponRecoilData, AimingShiftTravelTimeSeconds) == 0x00004C, "Member 'UGzWeaponRecoilData::AimingShiftTravelTimeSeconds' has a wrong offset!");
static_assert(offsetof(UGzWeaponRecoilData, AimingShiftCurve) == 0x000050, "Member 'UGzWeaponRecoilData::AimingShiftCurve' has a wrong offset!");
static_assert(offsetof(UGzWeaponRecoilData, DelayBeforePostRecoilTraveling) == 0x000058, "Member 'UGzWeaponRecoilData::DelayBeforePostRecoilTraveling' has a wrong offset!");
static_assert(offsetof(UGzWeaponRecoilData, PostRecoilTravelAngularSpeed) == 0x00005C, "Member 'UGzWeaponRecoilData::PostRecoilTravelAngularSpeed' has a wrong offset!");
static_assert(offsetof(UGzWeaponRecoilData, PostRecoilTravelCurve) == 0x000060, "Member 'UGzWeaponRecoilData::PostRecoilTravelCurve' has a wrong offset!");
static_assert(offsetof(UGzWeaponRecoilData, CasualAimingShiftTravelTimeSeconds) == 0x000068, "Member 'UGzWeaponRecoilData::CasualAimingShiftTravelTimeSeconds' has a wrong offset!");
static_assert(offsetof(UGzWeaponRecoilData, CasualAimingShiftCurve) == 0x000070, "Member 'UGzWeaponRecoilData::CasualAimingShiftCurve' has a wrong offset!");
static_assert(offsetof(UGzWeaponRecoilData, RecoilDegreeAnglePerShot) == 0x000078, "Member 'UGzWeaponRecoilData::RecoilDegreeAnglePerShot' has a wrong offset!");
static_assert(offsetof(UGzWeaponRecoilData, MaxRecoilDegreeAngle) == 0x00007C, "Member 'UGzWeaponRecoilData::MaxRecoilDegreeAngle' has a wrong offset!");
static_assert(offsetof(UGzWeaponRecoilData, MaxRandomVerticalDeviation) == 0x000080, "Member 'UGzWeaponRecoilData::MaxRandomVerticalDeviation' has a wrong offset!");
static_assert(offsetof(UGzWeaponRecoilData, MinRandomVerticalDeviation) == 0x000084, "Member 'UGzWeaponRecoilData::MinRandomVerticalDeviation' has a wrong offset!");
static_assert(offsetof(UGzWeaponRecoilData, HorizontalDeviation) == 0x000088, "Member 'UGzWeaponRecoilData::HorizontalDeviation' has a wrong offset!");
static_assert(offsetof(UGzWeaponRecoilData, MaxHorizontalDeviation) == 0x00008C, "Member 'UGzWeaponRecoilData::MaxHorizontalDeviation' has a wrong offset!");
static_assert(offsetof(UGzWeaponRecoilData, CasualDelayBeforePostRecoilTraveling) == 0x000090, "Member 'UGzWeaponRecoilData::CasualDelayBeforePostRecoilTraveling' has a wrong offset!");
static_assert(offsetof(UGzWeaponRecoilData, RecoilTravelBackSpeedCurve) == 0x000098, "Member 'UGzWeaponRecoilData::RecoilTravelBackSpeedCurve' has a wrong offset!");
static_assert(offsetof(UGzWeaponRecoilData, RecoilPatternWorstCompensatingAngle) == 0x0000A0, "Member 'UGzWeaponRecoilData::RecoilPatternWorstCompensatingAngle' has a wrong offset!");
static_assert(offsetof(UGzWeaponRecoilData, WorstCompensatingAngleMultiplier) == 0x0000A4, "Member 'UGzWeaponRecoilData::WorstCompensatingAngleMultiplier' has a wrong offset!");

// Class G01.GzWeaponResourcesSystem
// 0x0040 (0x0078 - 0x0038)
class UGzWeaponResourcesSystem final : public UGzWeaponSystemBase
{
public:
	uint8                                         Pad_35A1[0x10];                                    // 0x0038(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         CurrentResourceInClip;                             // 0x0048(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_35A2[0x4];                                     // 0x004C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UGzInvComponent*                        CachedPawnInventory;                               // 0x0050(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class UGzWeaponResourceModifier*>      WeaponResourceModifiers;                           // 0x0058(0x0010)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_35A3[0x10];                                    // 0x0068(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnPawnOwnerGameplayTagChanged(const struct FGameplayTag& GameplayTag, int32 Count);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzWeaponResourcesSystem">();
	}
	static class UGzWeaponResourcesSystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzWeaponResourcesSystem>();
	}
};
static_assert(alignof(UGzWeaponResourcesSystem) == 0x000008, "Wrong alignment on UGzWeaponResourcesSystem");
static_assert(sizeof(UGzWeaponResourcesSystem) == 0x000078, "Wrong size on UGzWeaponResourcesSystem");
static_assert(offsetof(UGzWeaponResourcesSystem, CurrentResourceInClip) == 0x000048, "Member 'UGzWeaponResourcesSystem::CurrentResourceInClip' has a wrong offset!");
static_assert(offsetof(UGzWeaponResourcesSystem, CachedPawnInventory) == 0x000050, "Member 'UGzWeaponResourcesSystem::CachedPawnInventory' has a wrong offset!");
static_assert(offsetof(UGzWeaponResourcesSystem, WeaponResourceModifiers) == 0x000058, "Member 'UGzWeaponResourcesSystem::WeaponResourceModifiers' has a wrong offset!");

// Class G01.GzWeaponSettings
// 0x0050 (0x0088 - 0x0038)
class UGzWeaponSettings final : public UDeveloperSettings
{
public:
	TMap<EGzItemRarity, uint8>                    CustomAttachCountByRarity;                         // 0x0038(0x0050)(Edit, Config, DisableEditOnInstance, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzWeaponSettings">();
	}
	static class UGzWeaponSettings* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzWeaponSettings>();
	}
};
static_assert(alignof(UGzWeaponSettings) == 0x000008, "Wrong alignment on UGzWeaponSettings");
static_assert(sizeof(UGzWeaponSettings) == 0x000088, "Wrong size on UGzWeaponSettings");
static_assert(offsetof(UGzWeaponSettings, CustomAttachCountByRarity) == 0x000038, "Member 'UGzWeaponSettings::CustomAttachCountByRarity' has a wrong offset!");

// Class G01.GzWeaponSoundData
// 0x0050 (0x0080 - 0x0030)
class UGzWeaponSoundData final : public UDataAsset
{
public:
	class UAkAudioEvent*                          FireSoundCue;                                      // 0x0030(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAkAudioEvent*                          FirstShotSoundCue;                                 // 0x0038(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAkAudioEvent*                          LastShotSoundCue;                                  // 0x0040(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsPlayAudioEachAttack;                            // 0x0048(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_35A4[0x7];                                     // 0x0049(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UAkAudioEvent*                          FlybySound;                                        // 0x0050(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAkAudioEvent*                          FireModeSwitchSoundCue;                            // 0x0058(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAkAudioEvent*                          EmptyWeaponFireSoundCue;                           // 0x0060(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAkAudioEvent*                          StartAimSound;                                     // 0x0068(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAkAudioEvent*                          EndAimSound;                                       // 0x0070(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UGzSurfaceTypeEvents*                   ShellSoundCues;                                    // 0x0078(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzWeaponSoundData">();
	}
	static class UGzWeaponSoundData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzWeaponSoundData>();
	}
};
static_assert(alignof(UGzWeaponSoundData) == 0x000008, "Wrong alignment on UGzWeaponSoundData");
static_assert(sizeof(UGzWeaponSoundData) == 0x000080, "Wrong size on UGzWeaponSoundData");
static_assert(offsetof(UGzWeaponSoundData, FireSoundCue) == 0x000030, "Member 'UGzWeaponSoundData::FireSoundCue' has a wrong offset!");
static_assert(offsetof(UGzWeaponSoundData, FirstShotSoundCue) == 0x000038, "Member 'UGzWeaponSoundData::FirstShotSoundCue' has a wrong offset!");
static_assert(offsetof(UGzWeaponSoundData, LastShotSoundCue) == 0x000040, "Member 'UGzWeaponSoundData::LastShotSoundCue' has a wrong offset!");
static_assert(offsetof(UGzWeaponSoundData, bIsPlayAudioEachAttack) == 0x000048, "Member 'UGzWeaponSoundData::bIsPlayAudioEachAttack' has a wrong offset!");
static_assert(offsetof(UGzWeaponSoundData, FlybySound) == 0x000050, "Member 'UGzWeaponSoundData::FlybySound' has a wrong offset!");
static_assert(offsetof(UGzWeaponSoundData, FireModeSwitchSoundCue) == 0x000058, "Member 'UGzWeaponSoundData::FireModeSwitchSoundCue' has a wrong offset!");
static_assert(offsetof(UGzWeaponSoundData, EmptyWeaponFireSoundCue) == 0x000060, "Member 'UGzWeaponSoundData::EmptyWeaponFireSoundCue' has a wrong offset!");
static_assert(offsetof(UGzWeaponSoundData, StartAimSound) == 0x000068, "Member 'UGzWeaponSoundData::StartAimSound' has a wrong offset!");
static_assert(offsetof(UGzWeaponSoundData, EndAimSound) == 0x000070, "Member 'UGzWeaponSoundData::EndAimSound' has a wrong offset!");
static_assert(offsetof(UGzWeaponSoundData, ShellSoundCues) == 0x000078, "Member 'UGzWeaponSoundData::ShellSoundCues' has a wrong offset!");

// Class G01.GzZoneKillsStatsCollector
// 0x0000 (0x0038 - 0x0038)
class UGzZoneKillsStatsCollector final : public UGzZoneStatsCollector
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzZoneKillsStatsCollector">();
	}
	static class UGzZoneKillsStatsCollector* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzZoneKillsStatsCollector>();
	}
};
static_assert(alignof(UGzZoneKillsStatsCollector) == 0x000008, "Wrong alignment on UGzZoneKillsStatsCollector");
static_assert(sizeof(UGzZoneKillsStatsCollector) == 0x000038, "Wrong size on UGzZoneKillsStatsCollector");

// Class G01.GzWeaponSpawn
// 0x0000 (0x0320 - 0x0320)
class AGzWeaponSpawn final : public ASkeletalMeshActor
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzWeaponSpawn">();
	}
	static class AGzWeaponSpawn* GetDefaultObj()
	{
		return GetDefaultObjImpl<AGzWeaponSpawn>();
	}
};
static_assert(alignof(AGzWeaponSpawn) == 0x000008, "Wrong alignment on AGzWeaponSpawn");
static_assert(sizeof(AGzWeaponSpawn) == 0x000320, "Wrong size on AGzWeaponSpawn");

// Class G01.GzWeaponSpreadSystem
// 0x0048 (0x0080 - 0x0038)
class UGzWeaponSpreadSystem final : public UGzWeaponSystemBase
{
public:
	TArray<class UGzWeaponSpreadModifier*>        SpreadModifiers;                                   // 0x0038(0x0010)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	float                                         CurrentSpreadScale;                                // 0x0048(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_35A5[0x34];                                    // 0x004C(0x0034)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzWeaponSpreadSystem">();
	}
	static class UGzWeaponSpreadSystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzWeaponSpreadSystem>();
	}
};
static_assert(alignof(UGzWeaponSpreadSystem) == 0x000008, "Wrong alignment on UGzWeaponSpreadSystem");
static_assert(sizeof(UGzWeaponSpreadSystem) == 0x000080, "Wrong size on UGzWeaponSpreadSystem");
static_assert(offsetof(UGzWeaponSpreadSystem, SpreadModifiers) == 0x000038, "Member 'UGzWeaponSpreadSystem::SpreadModifiers' has a wrong offset!");
static_assert(offsetof(UGzWeaponSpreadSystem, CurrentSpreadScale) == 0x000048, "Member 'UGzWeaponSpreadSystem::CurrentSpreadScale' has a wrong offset!");

// Class G01.GzWeaponSwayData
// 0x0010 (0x0040 - 0x0030)
class UGzWeaponSwayData final : public UDataAsset
{
public:
	class UCurveVector*                           SwayRotatorOverTime;                               // 0x0030(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TotalSwayCircleTimeSeconds;                        // 0x0038(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InterpolationSwayTimeSeconds;                      // 0x003C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzWeaponSwayData">();
	}
	static class UGzWeaponSwayData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzWeaponSwayData>();
	}
};
static_assert(alignof(UGzWeaponSwayData) == 0x000008, "Wrong alignment on UGzWeaponSwayData");
static_assert(sizeof(UGzWeaponSwayData) == 0x000040, "Wrong size on UGzWeaponSwayData");
static_assert(offsetof(UGzWeaponSwayData, SwayRotatorOverTime) == 0x000030, "Member 'UGzWeaponSwayData::SwayRotatorOverTime' has a wrong offset!");
static_assert(offsetof(UGzWeaponSwayData, TotalSwayCircleTimeSeconds) == 0x000038, "Member 'UGzWeaponSwayData::TotalSwayCircleTimeSeconds' has a wrong offset!");
static_assert(offsetof(UGzWeaponSwayData, InterpolationSwayTimeSeconds) == 0x00003C, "Member 'UGzWeaponSwayData::InterpolationSwayTimeSeconds' has a wrong offset!");

// Class G01.GzWeaponSwaySystem
// 0x0098 (0x00D0 - 0x0038)
class UGzWeaponSwaySystem final : public UGzWeaponSystemBase
{
public:
	uint8                                         Pad_35A6[0x48];                                    // 0x0038(0x0048)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UGzWeaponSwayModifier*>          SwayModifiers;                                     // 0x0080(0x0010)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	float                                         MinBreathHoldSwayMultiplier;                       // 0x0090(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MaxBreathHoldSwayMultiplier;                       // 0x0094(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MaxBreathHoldingStamina;                           // 0x0098(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_35A7[0x34];                                    // 0x009C(0x0034)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzWeaponSwaySystem">();
	}
	static class UGzWeaponSwaySystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzWeaponSwaySystem>();
	}
};
static_assert(alignof(UGzWeaponSwaySystem) == 0x000008, "Wrong alignment on UGzWeaponSwaySystem");
static_assert(sizeof(UGzWeaponSwaySystem) == 0x0000D0, "Wrong size on UGzWeaponSwaySystem");
static_assert(offsetof(UGzWeaponSwaySystem, SwayModifiers) == 0x000080, "Member 'UGzWeaponSwaySystem::SwayModifiers' has a wrong offset!");
static_assert(offsetof(UGzWeaponSwaySystem, MinBreathHoldSwayMultiplier) == 0x000090, "Member 'UGzWeaponSwaySystem::MinBreathHoldSwayMultiplier' has a wrong offset!");
static_assert(offsetof(UGzWeaponSwaySystem, MaxBreathHoldSwayMultiplier) == 0x000094, "Member 'UGzWeaponSwaySystem::MaxBreathHoldSwayMultiplier' has a wrong offset!");
static_assert(offsetof(UGzWeaponSwaySystem, MaxBreathHoldingStamina) == 0x000098, "Member 'UGzWeaponSwaySystem::MaxBreathHoldingStamina' has a wrong offset!");

// Class G01.GzWeaponViewpointCluster
// 0x0110 (0x03C0 - 0x02B0)
class AGzWeaponViewpointCluster final : public AGzViewpointClusterBase
{
public:
	TSubclassOf<class AGzSpringArmViewpoint>      DefaultViewpoint;                                  // 0x02B0(0x0008)(Edit, ZeroConstructor, DisableEditOnTemplate, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   DefaultViewpointName;                              // 0x02B8(0x0008)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMap<EGzWeaponType, TSubclassOf<class AGzSpringArmViewpoint>> OverrideForType;                                   // 0x02C0(0x0050)(Edit, DisableEditOnTemplate, UObjectWrapper, NativeAccessSpecifierPublic)
	TMap<class UGzWeaponArchetype*, TSubclassOf<class AGzSpringArmViewpoint>> OverrideForArchetype;                              // 0x0310(0x0050)(Edit, DisableEditOnTemplate, UObjectWrapper, NativeAccessSpecifierPublic)
	TMap<class UGzWeaponItemData*, TSubclassOf<class AGzSpringArmViewpoint>> OverrideForWeapon;                                 // 0x0360(0x0050)(Edit, DisableEditOnTemplate, UObjectWrapper, NativeAccessSpecifierPublic)
	class AGzWeaponSpawn*                         WeaponSpawn;                                       // 0x03B0(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AGzWeaponPickable*                      SpawnedWeapon;                                     // 0x03B8(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzWeaponViewpointCluster">();
	}
	static class AGzWeaponViewpointCluster* GetDefaultObj()
	{
		return GetDefaultObjImpl<AGzWeaponViewpointCluster>();
	}
};
static_assert(alignof(AGzWeaponViewpointCluster) == 0x000008, "Wrong alignment on AGzWeaponViewpointCluster");
static_assert(sizeof(AGzWeaponViewpointCluster) == 0x0003C0, "Wrong size on AGzWeaponViewpointCluster");
static_assert(offsetof(AGzWeaponViewpointCluster, DefaultViewpoint) == 0x0002B0, "Member 'AGzWeaponViewpointCluster::DefaultViewpoint' has a wrong offset!");
static_assert(offsetof(AGzWeaponViewpointCluster, DefaultViewpointName) == 0x0002B8, "Member 'AGzWeaponViewpointCluster::DefaultViewpointName' has a wrong offset!");
static_assert(offsetof(AGzWeaponViewpointCluster, OverrideForType) == 0x0002C0, "Member 'AGzWeaponViewpointCluster::OverrideForType' has a wrong offset!");
static_assert(offsetof(AGzWeaponViewpointCluster, OverrideForArchetype) == 0x000310, "Member 'AGzWeaponViewpointCluster::OverrideForArchetype' has a wrong offset!");
static_assert(offsetof(AGzWeaponViewpointCluster, OverrideForWeapon) == 0x000360, "Member 'AGzWeaponViewpointCluster::OverrideForWeapon' has a wrong offset!");
static_assert(offsetof(AGzWeaponViewpointCluster, WeaponSpawn) == 0x0003B0, "Member 'AGzWeaponViewpointCluster::WeaponSpawn' has a wrong offset!");
static_assert(offsetof(AGzWeaponViewpointCluster, SpawnedWeapon) == 0x0003B8, "Member 'AGzWeaponViewpointCluster::SpawnedWeapon' has a wrong offset!");

// Class G01.GzWebBrowserService
// 0x0008 (0x00A8 - 0x00A0)
class UGzWebBrowserService final : public UGzClientPFObject
{
public:
	uint8                                         Pad_35A8[0x8];                                     // 0x00A0(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzWebBrowserService">();
	}
	static class UGzWebBrowserService* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzWebBrowserService>();
	}
};
static_assert(alignof(UGzWebBrowserService) == 0x000008, "Wrong alignment on UGzWebBrowserService");
static_assert(sizeof(UGzWebBrowserService) == 0x0000A8, "Wrong size on UGzWebBrowserService");

// Class G01.GzWE_UITagsAware
// 0x0058 (0x0080 - 0x0028)
class UGzWE_UITagsAware final : public UUserWidgetExtension
{
public:
	FMulticastInlineDelegateProperty_             OnTagsUpdated;                                     // 0x0028(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	struct FGameplayTagContainer                  RequiredTags;                                      // 0x0038(0x0020)(Edit, Protected, NativeAccessSpecifierProtected)
	struct FGameplayTagContainer                  BlockingTags;                                      // 0x0058(0x0020)(Edit, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_35A9[0x8];                                     // 0x0078(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void NotifyOnTagAdded(const struct FGameplayTag& NewTag, const struct FGameplayTagContainer& CurrentTags);
	void NotifyOnTagRemoved(const struct FGameplayTag& RemovedTag, const struct FGameplayTagContainer& CurrentTags);
	void OnTagsApplicable(const struct FGameplayTagContainer& CurrentTags, class UUserWidget* Widget);
	void OnTagsNotApplicable(const struct FGameplayTagContainer& CurrentTags, class UUserWidget* Widget);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzWE_UITagsAware">();
	}
	static class UGzWE_UITagsAware* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzWE_UITagsAware>();
	}
};
static_assert(alignof(UGzWE_UITagsAware) == 0x000008, "Wrong alignment on UGzWE_UITagsAware");
static_assert(sizeof(UGzWE_UITagsAware) == 0x000080, "Wrong size on UGzWE_UITagsAware");
static_assert(offsetof(UGzWE_UITagsAware, OnTagsUpdated) == 0x000028, "Member 'UGzWE_UITagsAware::OnTagsUpdated' has a wrong offset!");
static_assert(offsetof(UGzWE_UITagsAware, RequiredTags) == 0x000038, "Member 'UGzWE_UITagsAware::RequiredTags' has a wrong offset!");
static_assert(offsetof(UGzWE_UITagsAware, BlockingTags) == 0x000058, "Member 'UGzWE_UITagsAware::BlockingTags' has a wrong offset!");

// Class G01.GzWhenObjective
// 0x0010 (0x0070 - 0x0060)
class UGzWhenObjective final : public UGzObjective
{
public:
	class UGzCondition*                           Condition;                                         // 0x0060(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_35AA[0x8];                                     // 0x0068(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UGzObjective* MakeWhenAnyObjective(class AGzAdvancedMission* Mission, class UGzCondition* Param_Condition);
	static class UGzObjective* MakeWhenNegativeObjective(class AGzAdvancedMission* Mission, class UGzCondition* Param_Condition);
	static class UGzObjective* MakeWhenPositiveObjective(class AGzAdvancedMission* Mission, class UGzCondition* Param_Condition);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzWhenObjective">();
	}
	static class UGzWhenObjective* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzWhenObjective>();
	}
};
static_assert(alignof(UGzWhenObjective) == 0x000008, "Wrong alignment on UGzWhenObjective");
static_assert(sizeof(UGzWhenObjective) == 0x000070, "Wrong size on UGzWhenObjective");
static_assert(offsetof(UGzWhenObjective, Condition) == 0x000060, "Member 'UGzWhenObjective::Condition' has a wrong offset!");

// Class G01.GzWhiteboardDataModel
// 0x0100 (0x0170 - 0x0070)
class UGzWhiteboardDataModel final : public UGzBackendModel
{
public:
	TMap<class FName, struct FGzCohtmlJobData>    Jobs;                                              // 0x0070(0x0050)(NativeAccessSpecifierPrivate)
	TMap<class FName, struct FGzCohtmlGoalData>   Goals;                                             // 0x00C0(0x0050)(NativeAccessSpecifierPrivate)
	TMap<class FName, struct FGzCohtmlAssignmentData> Assignments;                                       // 0x0110(0x0050)(NativeAccessSpecifierPrivate)
	TArray<struct FGzCohtmlFaction>               Factions;                                          // 0x0160(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzWhiteboardDataModel">();
	}
	static class UGzWhiteboardDataModel* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzWhiteboardDataModel>();
	}
};
static_assert(alignof(UGzWhiteboardDataModel) == 0x000008, "Wrong alignment on UGzWhiteboardDataModel");
static_assert(sizeof(UGzWhiteboardDataModel) == 0x000170, "Wrong size on UGzWhiteboardDataModel");
static_assert(offsetof(UGzWhiteboardDataModel, Jobs) == 0x000070, "Member 'UGzWhiteboardDataModel::Jobs' has a wrong offset!");
static_assert(offsetof(UGzWhiteboardDataModel, Goals) == 0x0000C0, "Member 'UGzWhiteboardDataModel::Goals' has a wrong offset!");
static_assert(offsetof(UGzWhiteboardDataModel, Assignments) == 0x000110, "Member 'UGzWhiteboardDataModel::Assignments' has a wrong offset!");
static_assert(offsetof(UGzWhiteboardDataModel, Factions) == 0x000160, "Member 'UGzWhiteboardDataModel::Factions' has a wrong offset!");

// Class G01.GzWidgetDisplayInterface
// 0x0000 (0x0028 - 0x0028)
class IGzWidgetDisplayInterface final : public IInterface
{
public:
	void Hide();
	void Show();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzWidgetDisplayInterface">();
	}
	static class IGzWidgetDisplayInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IGzWidgetDisplayInterface>();
	}
};
static_assert(alignof(IGzWidgetDisplayInterface) == 0x000008, "Wrong alignment on IGzWidgetDisplayInterface");
static_assert(sizeof(IGzWidgetDisplayInterface) == 0x000028, "Wrong size on IGzWidgetDisplayInterface");

// Class G01.GzWingsuitMeshActor
// 0x0008 (0x0328 - 0x0320)
class AGzWingsuitMeshActor final : public ASkeletalMeshActor
{
public:
	class AGzMultiPartCharacter*                  CachedCharacter;                                   // 0x0320(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void DetachJetpackBoostVisual();
	class AGzMultiPartCharacter* GetOwnerCharacter();
	void K2_OnEndWingsuit();
	void K2_OnStartWingsuit();
	void SetJetpackBoostVisual(class UStaticMesh* JetpackBoostVisual, bool bShow);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzWingsuitMeshActor">();
	}
	static class AGzWingsuitMeshActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<AGzWingsuitMeshActor>();
	}
};
static_assert(alignof(AGzWingsuitMeshActor) == 0x000008, "Wrong alignment on AGzWingsuitMeshActor");
static_assert(sizeof(AGzWingsuitMeshActor) == 0x000328, "Wrong size on AGzWingsuitMeshActor");
static_assert(offsetof(AGzWingsuitMeshActor, CachedCharacter) == 0x000320, "Member 'AGzWingsuitMeshActor::CachedCharacter' has a wrong offset!");

// Class G01.GzWorldInstanceMarkerFilter
// 0x0000 (0x0038 - 0x0038)
class UGzWorldInstanceMarkerFilter final : public UGzMarkerActiveStateFilter
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzWorldInstanceMarkerFilter">();
	}
	static class UGzWorldInstanceMarkerFilter* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzWorldInstanceMarkerFilter>();
	}
};
static_assert(alignof(UGzWorldInstanceMarkerFilter) == 0x000008, "Wrong alignment on UGzWorldInstanceMarkerFilter");
static_assert(sizeof(UGzWorldInstanceMarkerFilter) == 0x000038, "Wrong size on UGzWorldInstanceMarkerFilter");

// Class G01.GzGroupRarityInstancesSetupData
// 0x0050 (0x0080 - 0x0030)
class UGzGroupRarityInstancesSetupData final : public UDataAsset
{
public:
	TMap<struct FGameplayTag, struct FGzRarityInstancesSetupData> GroupRarityInstancesSetup;                         // 0x0030(0x0050)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzGroupRarityInstancesSetupData">();
	}
	static class UGzGroupRarityInstancesSetupData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzGroupRarityInstancesSetupData>();
	}
};
static_assert(alignof(UGzGroupRarityInstancesSetupData) == 0x000008, "Wrong alignment on UGzGroupRarityInstancesSetupData");
static_assert(sizeof(UGzGroupRarityInstancesSetupData) == 0x000080, "Wrong size on UGzGroupRarityInstancesSetupData");
static_assert(offsetof(UGzGroupRarityInstancesSetupData, GroupRarityInstancesSetup) == 0x000030, "Member 'UGzGroupRarityInstancesSetupData::GroupRarityInstancesSetup' has a wrong offset!");

// Class G01.GzWorldVisibilityBlendActor
// 0x0008 (0x02A8 - 0x02A0)
class AGzWorldVisibilityBlendActor : public AActor
{
public:
	float                                         BlendTime;                                         // 0x02A0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_35AC[0x4];                                     // 0x02A4(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetState(EDepthStencilValue Value);
	void SetStateSeparateForLimb(EDepthStencilValue Value, EDepthStencilValue ValueForLimbs);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzWorldVisibilityBlendActor">();
	}
	static class AGzWorldVisibilityBlendActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<AGzWorldVisibilityBlendActor>();
	}
};
static_assert(alignof(AGzWorldVisibilityBlendActor) == 0x000008, "Wrong alignment on AGzWorldVisibilityBlendActor");
static_assert(sizeof(AGzWorldVisibilityBlendActor) == 0x0002A8, "Wrong size on AGzWorldVisibilityBlendActor");
static_assert(offsetof(AGzWorldVisibilityBlendActor, BlendTime) == 0x0002A0, "Member 'AGzWorldVisibilityBlendActor::BlendTime' has a wrong offset!");

// Class G01.GzWorldZone
// 0x0028 (0x0050 - 0x0028)
class UGzWorldZone final : public UObject
{
public:
	TArray<struct FVector2D>                      ZoneBorder;                                        // 0x0028(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, NativeAccessSpecifierPublic)
	class FName                                   ZoneName;                                          // 0x0038(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class UGzWorldZoneMetadata*>           MetadataList;                                      // 0x0040(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, NativeAccessSpecifierPublic)

public:
	class UGzWorldZoneMetadata* GetMetaDataByClass(TSubclassOf<class UGzWorldZoneMetadata> MetaDataClass);

	bool IsInBorders(const struct FVector2D& Position) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzWorldZone">();
	}
	static class UGzWorldZone* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzWorldZone>();
	}
};
static_assert(alignof(UGzWorldZone) == 0x000008, "Wrong alignment on UGzWorldZone");
static_assert(sizeof(UGzWorldZone) == 0x000050, "Wrong size on UGzWorldZone");
static_assert(offsetof(UGzWorldZone, ZoneBorder) == 0x000028, "Member 'UGzWorldZone::ZoneBorder' has a wrong offset!");
static_assert(offsetof(UGzWorldZone, ZoneName) == 0x000038, "Member 'UGzWorldZone::ZoneName' has a wrong offset!");
static_assert(offsetof(UGzWorldZone, MetadataList) == 0x000040, "Member 'UGzWorldZone::MetadataList' has a wrong offset!");

// Class G01.GzWorldZoneTagMetadata
// 0x0008 (0x0030 - 0x0028)
class UGzWorldZoneTagMetadata final : public UGzWorldZoneMetadata
{
public:
	struct FGameplayTag                           ZoneTag;                                           // 0x0028(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzWorldZoneTagMetadata">();
	}
	static class UGzWorldZoneTagMetadata* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzWorldZoneTagMetadata>();
	}
};
static_assert(alignof(UGzWorldZoneTagMetadata) == 0x000008, "Wrong alignment on UGzWorldZoneTagMetadata");
static_assert(sizeof(UGzWorldZoneTagMetadata) == 0x000030, "Wrong size on UGzWorldZoneTagMetadata");
static_assert(offsetof(UGzWorldZoneTagMetadata, ZoneTag) == 0x000028, "Member 'UGzWorldZoneTagMetadata::ZoneTag' has a wrong offset!");

// Class G01.GzWorldZoneNameDecoration
// 0x0008 (0x0310 - 0x0308)
class UGzWorldZoneNameDecoration : public UGzMapTextDecoration
{
public:
	class UGzWorldZone*                           WorldZone;                                         // 0x0308(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzWorldZoneNameDecoration">();
	}
	static class UGzWorldZoneNameDecoration* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzWorldZoneNameDecoration>();
	}
};
static_assert(alignof(UGzWorldZoneNameDecoration) == 0x000008, "Wrong alignment on UGzWorldZoneNameDecoration");
static_assert(sizeof(UGzWorldZoneNameDecoration) == 0x000310, "Wrong size on UGzWorldZoneNameDecoration");
static_assert(offsetof(UGzWorldZoneNameDecoration, WorldZone) == 0x000308, "Member 'UGzWorldZoneNameDecoration::WorldZone' has a wrong offset!");

// Class G01.GzWorldZoneTrackingComponent
// 0x0050 (0x00F8 - 0x00A8)
class UGzWorldZoneTrackingComponent final : public UActorComponent
{
public:
	TMap<class FName, class UGzWorldZone*>        WorldZones;                                        // 0x00A8(0x0050)(Transient, Protected, NativeAccessSpecifierProtected)

public:
	const class UGzWorldZone* GetTrackedWorldZone(class FName Layer) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzWorldZoneTrackingComponent">();
	}
	static class UGzWorldZoneTrackingComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzWorldZoneTrackingComponent>();
	}
};
static_assert(alignof(UGzWorldZoneTrackingComponent) == 0x000008, "Wrong alignment on UGzWorldZoneTrackingComponent");
static_assert(sizeof(UGzWorldZoneTrackingComponent) == 0x0000F8, "Wrong size on UGzWorldZoneTrackingComponent");
static_assert(offsetof(UGzWorldZoneTrackingComponent, WorldZones) == 0x0000A8, "Member 'UGzWorldZoneTrackingComponent::WorldZones' has a wrong offset!");

// Class G01.GzWorldZoneType
// 0x0020 (0x0050 - 0x0030)
class UGzWorldZoneType final : public UPrimaryDataAsset
{
public:
	class FText                                   DisplayName;                                       // 0x0030(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	class FText                                   Description;                                       // 0x0040(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)

public:
	class FName GetAssetId() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzWorldZoneType">();
	}
	static class UGzWorldZoneType* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzWorldZoneType>();
	}
};
static_assert(alignof(UGzWorldZoneType) == 0x000008, "Wrong alignment on UGzWorldZoneType");
static_assert(sizeof(UGzWorldZoneType) == 0x000050, "Wrong size on UGzWorldZoneType");
static_assert(offsetof(UGzWorldZoneType, DisplayName) == 0x000030, "Member 'UGzWorldZoneType::DisplayName' has a wrong offset!");
static_assert(offsetof(UGzWorldZoneType, Description) == 0x000040, "Member 'UGzWorldZoneType::Description' has a wrong offset!");

// Class G01.GzXR_ArmorBreakRedeployModifier
// 0x0008 (0x0090 - 0x0088)
class UGzXR_ArmorBreakRedeployModifier final : public UGzXR_BaseRedeployModifier
{
public:
	uint8                                         Pad_35AE[0x8];                                     // 0x0088(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzXR_ArmorBreakRedeployModifier">();
	}
	static class UGzXR_ArmorBreakRedeployModifier* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzXR_ArmorBreakRedeployModifier>();
	}
};
static_assert(alignof(UGzXR_ArmorBreakRedeployModifier) == 0x000008, "Wrong alignment on UGzXR_ArmorBreakRedeployModifier");
static_assert(sizeof(UGzXR_ArmorBreakRedeployModifier) == 0x000090, "Wrong size on UGzXR_ArmorBreakRedeployModifier");

// Class G01.GzXR_DeploymentCutsceneStage
// 0x0028 (0x0138 - 0x0110)
class UGzXR_DeploymentCutsceneStage : public UGzGameStageBase
{
public:
	class AGzSyncCutscene*                        Cutscene;                                          // 0x0110(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_35AF[0x20];                                    // 0x0118(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzXR_DeploymentCutsceneStage">();
	}
	static class UGzXR_DeploymentCutsceneStage* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzXR_DeploymentCutsceneStage>();
	}
};
static_assert(alignof(UGzXR_DeploymentCutsceneStage) == 0x000008, "Wrong alignment on UGzXR_DeploymentCutsceneStage");
static_assert(sizeof(UGzXR_DeploymentCutsceneStage) == 0x000138, "Wrong size on UGzXR_DeploymentCutsceneStage");
static_assert(offsetof(UGzXR_DeploymentCutsceneStage, Cutscene) == 0x000110, "Member 'UGzXR_DeploymentCutsceneStage::Cutscene' has a wrong offset!");

// Class G01.GzXR_DeploymentStage
// 0x0018 (0x0130 - 0x0118)
class UGzXR_DeploymentStage : public UGzXR_BaseStage
{
public:
	TArray<class AGzDeploymentTransport*>         DeploymentTransport;                               // 0x0118(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	uint8                                         Pad_35B0[0x8];                                     // 0x0128(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzXR_DeploymentStage">();
	}
	static class UGzXR_DeploymentStage* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzXR_DeploymentStage>();
	}
};
static_assert(alignof(UGzXR_DeploymentStage) == 0x000008, "Wrong alignment on UGzXR_DeploymentStage");
static_assert(sizeof(UGzXR_DeploymentStage) == 0x000130, "Wrong size on UGzXR_DeploymentStage");
static_assert(offsetof(UGzXR_DeploymentStage, DeploymentTransport) == 0x000118, "Member 'UGzXR_DeploymentStage::DeploymentTransport' has a wrong offset!");

// Class G01.GzXR_DownEnemyRedeployModifier
// 0x0008 (0x0090 - 0x0088)
class UGzXR_DownEnemyRedeployModifier final : public UGzXR_BaseRedeployModifier
{
public:
	uint8                                         Pad_35B1[0x8];                                     // 0x0088(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzXR_DownEnemyRedeployModifier">();
	}
	static class UGzXR_DownEnemyRedeployModifier* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzXR_DownEnemyRedeployModifier>();
	}
};
static_assert(alignof(UGzXR_DownEnemyRedeployModifier) == 0x000008, "Wrong alignment on UGzXR_DownEnemyRedeployModifier");
static_assert(sizeof(UGzXR_DownEnemyRedeployModifier) == 0x000090, "Wrong size on UGzXR_DownEnemyRedeployModifier");

// Class G01.GzXR_HexExtractionCanceledRedeployModifier
// 0x0008 (0x0090 - 0x0088)
class UGzXR_HexExtractionCanceledRedeployModifier final : public UGzXR_BaseRedeployModifier
{
public:
	uint8                                         Pad_35B2[0x8];                                     // 0x0088(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzXR_HexExtractionCanceledRedeployModifier">();
	}
	static class UGzXR_HexExtractionCanceledRedeployModifier* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzXR_HexExtractionCanceledRedeployModifier>();
	}
};
static_assert(alignof(UGzXR_HexExtractionCanceledRedeployModifier) == 0x000008, "Wrong alignment on UGzXR_HexExtractionCanceledRedeployModifier");
static_assert(sizeof(UGzXR_HexExtractionCanceledRedeployModifier) == 0x000090, "Wrong size on UGzXR_HexExtractionCanceledRedeployModifier");

// Class G01.GzXR_HexExtractionCompleteRedeployModifier
// 0x0008 (0x0090 - 0x0088)
class UGzXR_HexExtractionCompleteRedeployModifier final : public UGzXR_BaseRedeployModifier
{
public:
	uint8                                         Pad_35B3[0x8];                                     // 0x0088(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzXR_HexExtractionCompleteRedeployModifier">();
	}
	static class UGzXR_HexExtractionCompleteRedeployModifier* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzXR_HexExtractionCompleteRedeployModifier>();
	}
};
static_assert(alignof(UGzXR_HexExtractionCompleteRedeployModifier) == 0x000008, "Wrong alignment on UGzXR_HexExtractionCompleteRedeployModifier");
static_assert(sizeof(UGzXR_HexExtractionCompleteRedeployModifier) == 0x000090, "Wrong size on UGzXR_HexExtractionCompleteRedeployModifier");

// Class G01.GzXR_LimbShootOffRedeployModifier
// 0x0008 (0x0090 - 0x0088)
class UGzXR_LimbShootOffRedeployModifier final : public UGzXR_BaseRedeployModifier
{
public:
	uint8                                         Pad_35B4[0x8];                                     // 0x0088(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzXR_LimbShootOffRedeployModifier">();
	}
	static class UGzXR_LimbShootOffRedeployModifier* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzXR_LimbShootOffRedeployModifier>();
	}
};
static_assert(alignof(UGzXR_LimbShootOffRedeployModifier) == 0x000008, "Wrong alignment on UGzXR_LimbShootOffRedeployModifier");
static_assert(sizeof(UGzXR_LimbShootOffRedeployModifier) == 0x000090, "Wrong size on UGzXR_LimbShootOffRedeployModifier");

// Class G01.GzXR_LoadoutDropEvent
// 0x0010 (0x0068 - 0x0058)
class UGzXR_LoadoutDropEvent final : public UGzXR_BaseEvent
{
public:
	TArray<struct FGzLoadoutDropData>             LoadoutDropData;                                   // 0x0058(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzXR_LoadoutDropEvent">();
	}
	static class UGzXR_LoadoutDropEvent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzXR_LoadoutDropEvent>();
	}
};
static_assert(alignof(UGzXR_LoadoutDropEvent) == 0x000008, "Wrong alignment on UGzXR_LoadoutDropEvent");
static_assert(sizeof(UGzXR_LoadoutDropEvent) == 0x000068, "Wrong size on UGzXR_LoadoutDropEvent");
static_assert(offsetof(UGzXR_LoadoutDropEvent, LoadoutDropData) == 0x000058, "Member 'UGzXR_LoadoutDropEvent::LoadoutDropData' has a wrong offset!");

// Class G01.GzXR_MissionCompleteRedeployModifier
// 0x0000 (0x0088 - 0x0088)
class UGzXR_MissionCompleteRedeployModifier final : public UGzXR_BaseRedeployModifier
{
public:
	void OnMissionStateChanged(class AGzMission* Mission, const struct FGzMissionState& OldState, const struct FGzMissionState& MissionState);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzXR_MissionCompleteRedeployModifier">();
	}
	static class UGzXR_MissionCompleteRedeployModifier* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzXR_MissionCompleteRedeployModifier>();
	}
};
static_assert(alignof(UGzXR_MissionCompleteRedeployModifier) == 0x000008, "Wrong alignment on UGzXR_MissionCompleteRedeployModifier");
static_assert(sizeof(UGzXR_MissionCompleteRedeployModifier) == 0x000088, "Wrong size on UGzXR_MissionCompleteRedeployModifier");

// Class G01.GzXR_MovementRedeployModifier
// 0x0068 (0x00F0 - 0x0088)
class UGzXR_MovementRedeployModifier final : public UGzXR_BaseRedeployModifier
{
public:
	float                                         MinTravelDeltaToCollect;                           // 0x0088(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         MinTravelDeltaToTrigger;                           // 0x008C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         CharacterUpdateRate;                               // 0x0090(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_35B5[0x5C];                                    // 0x0094(0x005C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzXR_MovementRedeployModifier">();
	}
	static class UGzXR_MovementRedeployModifier* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzXR_MovementRedeployModifier>();
	}
};
static_assert(alignof(UGzXR_MovementRedeployModifier) == 0x000008, "Wrong alignment on UGzXR_MovementRedeployModifier");
static_assert(sizeof(UGzXR_MovementRedeployModifier) == 0x0000F0, "Wrong size on UGzXR_MovementRedeployModifier");
static_assert(offsetof(UGzXR_MovementRedeployModifier, MinTravelDeltaToCollect) == 0x000088, "Member 'UGzXR_MovementRedeployModifier::MinTravelDeltaToCollect' has a wrong offset!");
static_assert(offsetof(UGzXR_MovementRedeployModifier, MinTravelDeltaToTrigger) == 0x00008C, "Member 'UGzXR_MovementRedeployModifier::MinTravelDeltaToTrigger' has a wrong offset!");
static_assert(offsetof(UGzXR_MovementRedeployModifier, CharacterUpdateRate) == 0x000090, "Member 'UGzXR_MovementRedeployModifier::CharacterUpdateRate' has a wrong offset!");

// Class G01.GzXR_OpenLootContainerRedeployModifier
// 0x0008 (0x0090 - 0x0088)
class UGzXR_OpenLootContainerRedeployModifier final : public UGzXR_BaseRedeployModifier
{
public:
	uint8                                         Pad_35B6[0x8];                                     // 0x0088(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzXR_OpenLootContainerRedeployModifier">();
	}
	static class UGzXR_OpenLootContainerRedeployModifier* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzXR_OpenLootContainerRedeployModifier>();
	}
};
static_assert(alignof(UGzXR_OpenLootContainerRedeployModifier) == 0x000008, "Wrong alignment on UGzXR_OpenLootContainerRedeployModifier");
static_assert(sizeof(UGzXR_OpenLootContainerRedeployModifier) == 0x000090, "Wrong size on UGzXR_OpenLootContainerRedeployModifier");

// Class G01.GzXR_PrepareMatch
// 0x0000 (0x0110 - 0x0110)
class UGzXR_PrepareMatch : public UGzGameStageBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzXR_PrepareMatch">();
	}
	static class UGzXR_PrepareMatch* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzXR_PrepareMatch>();
	}
};
static_assert(alignof(UGzXR_PrepareMatch) == 0x000008, "Wrong alignment on UGzXR_PrepareMatch");
static_assert(sizeof(UGzXR_PrepareMatch) == 0x000110, "Wrong size on UGzXR_PrepareMatch");

// Class G01.GzXR_QuickOrderMenuPriceModifier
// 0x0008 (0x0060 - 0x0058)
class UGzXR_QuickOrderMenuPriceModifier final : public UGzXR_BaseEvent
{
public:
	float                                         LoadoutPriceModifier;                              // 0x0058(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bResetActiveDroneCooldown;                         // 0x005C(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_35B7[0x3];                                     // 0x005D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzXR_QuickOrderMenuPriceModifier">();
	}
	static class UGzXR_QuickOrderMenuPriceModifier* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzXR_QuickOrderMenuPriceModifier>();
	}
};
static_assert(alignof(UGzXR_QuickOrderMenuPriceModifier) == 0x000008, "Wrong alignment on UGzXR_QuickOrderMenuPriceModifier");
static_assert(sizeof(UGzXR_QuickOrderMenuPriceModifier) == 0x000060, "Wrong size on UGzXR_QuickOrderMenuPriceModifier");
static_assert(offsetof(UGzXR_QuickOrderMenuPriceModifier, LoadoutPriceModifier) == 0x000058, "Member 'UGzXR_QuickOrderMenuPriceModifier::LoadoutPriceModifier' has a wrong offset!");
static_assert(offsetof(UGzXR_QuickOrderMenuPriceModifier, bResetActiveDroneCooldown) == 0x00005C, "Member 'UGzXR_QuickOrderMenuPriceModifier::bResetActiveDroneCooldown' has a wrong offset!");

// Class G01.GzXR_RespawnShutdownEvent
// 0x0010 (0x0068 - 0x0058)
class UGzXR_RespawnShutdownEvent final : public UGzXR_BaseEvent
{
public:
	float                                         ShutdownDelay;                                     // 0x0058(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_35B8[0xC];                                     // 0x005C(0x000C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzXR_RespawnShutdownEvent">();
	}
	static class UGzXR_RespawnShutdownEvent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzXR_RespawnShutdownEvent>();
	}
};
static_assert(alignof(UGzXR_RespawnShutdownEvent) == 0x000008, "Wrong alignment on UGzXR_RespawnShutdownEvent");
static_assert(sizeof(UGzXR_RespawnShutdownEvent) == 0x000068, "Wrong size on UGzXR_RespawnShutdownEvent");
static_assert(offsetof(UGzXR_RespawnShutdownEvent, ShutdownDelay) == 0x000058, "Member 'UGzXR_RespawnShutdownEvent::ShutdownDelay' has a wrong offset!");

// Class G01.GzXR_ShrinkingStage
// 0x0008 (0x0120 - 0x0118)
class UGzXR_ShrinkingStage : public UGzXR_BaseStage
{
public:
	uint8                                         Pad_35B9[0x8];                                     // 0x0118(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzXR_ShrinkingStage">();
	}
	static class UGzXR_ShrinkingStage* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzXR_ShrinkingStage>();
	}
};
static_assert(alignof(UGzXR_ShrinkingStage) == 0x000008, "Wrong alignment on UGzXR_ShrinkingStage");
static_assert(sizeof(UGzXR_ShrinkingStage) == 0x000120, "Wrong size on UGzXR_ShrinkingStage");

// Class G01.GzXsollaPaymentProviderComponent
// 0x0000 (0x00B8 - 0x00B8)
class UGzXsollaPaymentProviderComponent final : public UGzPaymentProviderComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzXsollaPaymentProviderComponent">();
	}
	static class UGzXsollaPaymentProviderComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzXsollaPaymentProviderComponent>();
	}
};
static_assert(alignof(UGzXsollaPaymentProviderComponent) == 0x000008, "Wrong alignment on UGzXsollaPaymentProviderComponent");
static_assert(sizeof(UGzXsollaPaymentProviderComponent) == 0x0000B8, "Wrong size on UGzXsollaPaymentProviderComponent");

// Class G01.GzZiplineBuildSplineStrategy
// 0x0000 (0x0028 - 0x0028)
class UGzZiplineBuildSplineStrategy : public UObject
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzZiplineBuildSplineStrategy">();
	}
	static class UGzZiplineBuildSplineStrategy* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzZiplineBuildSplineStrategy>();
	}
};
static_assert(alignof(UGzZiplineBuildSplineStrategy) == 0x000008, "Wrong alignment on UGzZiplineBuildSplineStrategy");
static_assert(sizeof(UGzZiplineBuildSplineStrategy) == 0x000028, "Wrong size on UGzZiplineBuildSplineStrategy");

// Class G01.GzZiplineBuildSplineStrategy_Manual
// 0x0000 (0x0028 - 0x0028)
class UGzZiplineBuildSplineStrategy_Manual final : public UGzZiplineBuildSplineStrategy
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzZiplineBuildSplineStrategy_Manual">();
	}
	static class UGzZiplineBuildSplineStrategy_Manual* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzZiplineBuildSplineStrategy_Manual>();
	}
};
static_assert(alignof(UGzZiplineBuildSplineStrategy_Manual) == 0x000008, "Wrong alignment on UGzZiplineBuildSplineStrategy_Manual");
static_assert(sizeof(UGzZiplineBuildSplineStrategy_Manual) == 0x000028, "Wrong size on UGzZiplineBuildSplineStrategy_Manual");

// Class G01.GzZiplineBuildSplineStrategy_LengthBased
// 0x0010 (0x0038 - 0x0028)
class UGzZiplineBuildSplineStrategy_LengthBased : public UGzZiplineBuildSplineStrategy
{
public:
	float                                         Length;                                            // 0x0028(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint32                                        PointsNum;                                         // 0x002C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         GravityMultiplier;                                 // 0x0030(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_35BA[0x4];                                     // 0x0034(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzZiplineBuildSplineStrategy_LengthBased">();
	}
	static class UGzZiplineBuildSplineStrategy_LengthBased* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzZiplineBuildSplineStrategy_LengthBased>();
	}
};
static_assert(alignof(UGzZiplineBuildSplineStrategy_LengthBased) == 0x000008, "Wrong alignment on UGzZiplineBuildSplineStrategy_LengthBased");
static_assert(sizeof(UGzZiplineBuildSplineStrategy_LengthBased) == 0x000038, "Wrong size on UGzZiplineBuildSplineStrategy_LengthBased");
static_assert(offsetof(UGzZiplineBuildSplineStrategy_LengthBased, Length) == 0x000028, "Member 'UGzZiplineBuildSplineStrategy_LengthBased::Length' has a wrong offset!");
static_assert(offsetof(UGzZiplineBuildSplineStrategy_LengthBased, PointsNum) == 0x00002C, "Member 'UGzZiplineBuildSplineStrategy_LengthBased::PointsNum' has a wrong offset!");
static_assert(offsetof(UGzZiplineBuildSplineStrategy_LengthBased, GravityMultiplier) == 0x000030, "Member 'UGzZiplineBuildSplineStrategy_LengthBased::GravityMultiplier' has a wrong offset!");

// Class G01.GzZiplineBuildSplineStrategy_RayBased
// 0x0008 (0x0040 - 0x0038)
class UGzZiplineBuildSplineStrategy_RayBased final : public UGzZiplineBuildSplineStrategy_LengthBased
{
public:
	float                                         MaxLength;                                         // 0x0038(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_35BB[0x4];                                     // 0x003C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzZiplineBuildSplineStrategy_RayBased">();
	}
	static class UGzZiplineBuildSplineStrategy_RayBased* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzZiplineBuildSplineStrategy_RayBased>();
	}
};
static_assert(alignof(UGzZiplineBuildSplineStrategy_RayBased) == 0x000008, "Wrong alignment on UGzZiplineBuildSplineStrategy_RayBased");
static_assert(sizeof(UGzZiplineBuildSplineStrategy_RayBased) == 0x000040, "Wrong size on UGzZiplineBuildSplineStrategy_RayBased");
static_assert(offsetof(UGzZiplineBuildSplineStrategy_RayBased, MaxLength) == 0x000038, "Member 'UGzZiplineBuildSplineStrategy_RayBased::MaxLength' has a wrong offset!");

// Class G01.GzZiplinePathTrackingComponent
// 0x0000 (0x00D8 - 0x00D8)
class UGzZiplinePathTrackingComponent final : public UGzPathTrackingComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzZiplinePathTrackingComponent">();
	}
	static class UGzZiplinePathTrackingComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzZiplinePathTrackingComponent>();
	}
};
static_assert(alignof(UGzZiplinePathTrackingComponent) == 0x000008, "Wrong alignment on UGzZiplinePathTrackingComponent");
static_assert(sizeof(UGzZiplinePathTrackingComponent) == 0x0000D8, "Wrong size on UGzZiplinePathTrackingComponent");

// Class G01.GzZoneEventsWorldSubsystem
// 0x0020 (0x0050 - 0x0030)
class UGzZoneEventsWorldSubsystem final : public UWorldSubsystem
{
public:
	TArray<class UGzZoneEvent*>                   Events;                                            // 0x0030(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	uint8                                         Pad_35BC[0x10];                                    // 0x0040(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzZoneEventsWorldSubsystem">();
	}
	static class UGzZoneEventsWorldSubsystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzZoneEventsWorldSubsystem>();
	}
};
static_assert(alignof(UGzZoneEventsWorldSubsystem) == 0x000008, "Wrong alignment on UGzZoneEventsWorldSubsystem");
static_assert(sizeof(UGzZoneEventsWorldSubsystem) == 0x000050, "Wrong size on UGzZoneEventsWorldSubsystem");
static_assert(offsetof(UGzZoneEventsWorldSubsystem, Events) == 0x000030, "Member 'UGzZoneEventsWorldSubsystem::Events' has a wrong offset!");

// Class G01.GzZoneFillLayerWidget
// 0x0018 (0x02F8 - 0x02E0)
class UGzZoneFillLayerWidget : public UUserWidget
{
public:
	class UImage*                                 Image;                                             // 0x02E0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UMaterialInstanceDynamic*               CurrentMaterial;                                   // 0x02E8(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UGzMapWidget*                           ParentMap;                                         // 0x02F0(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzZoneFillLayerWidget">();
	}
	static class UGzZoneFillLayerWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzZoneFillLayerWidget>();
	}
};
static_assert(alignof(UGzZoneFillLayerWidget) == 0x000008, "Wrong alignment on UGzZoneFillLayerWidget");
static_assert(sizeof(UGzZoneFillLayerWidget) == 0x0002F8, "Wrong size on UGzZoneFillLayerWidget");
static_assert(offsetof(UGzZoneFillLayerWidget, Image) == 0x0002E0, "Member 'UGzZoneFillLayerWidget::Image' has a wrong offset!");
static_assert(offsetof(UGzZoneFillLayerWidget, CurrentMaterial) == 0x0002E8, "Member 'UGzZoneFillLayerWidget::CurrentMaterial' has a wrong offset!");
static_assert(offsetof(UGzZoneFillLayerWidget, ParentMap) == 0x0002F0, "Member 'UGzZoneFillLayerWidget::ParentMap' has a wrong offset!");

// Class G01.GzZoneTrackingComponent
// 0x0048 (0x00F0 - 0x00A8)
class UGzZoneTrackingComponent final : public UActorComponent
{
public:
	FMulticastInlineDelegateProperty_             OnZoneSideSwitched;                                // 0x00A8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TSubclassOf<class UGameplayEffect>            ZoneEffect;                                        // 0x00B8(0x0008)(Edit, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EGzZoneTrackingType                           TrackingType;                                      // 0x00C0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_35BD[0x7];                                     // 0x00C1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TScriptInterface<class IGzZoneTrackingManager> ZoneManager;                                       // 0x00C8(0x0010)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UGzAbilitySystemComponent*              ASC;                                               // 0x00D8(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_35BE[0x10];                                    // 0x00E0(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnOverloadStageChanged(const int32 NewStageIndex);

	bool GetClosestPointToSafety(struct FVector2D* OutPosition) const;
	bool GetClosestZoneCenter(struct FVector2D* OutCenter) const;
	float GetDistanceToZoneEdge() const;
	struct FVector GetTrackedPosition() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzZoneTrackingComponent">();
	}
	static class UGzZoneTrackingComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzZoneTrackingComponent>();
	}
};
static_assert(alignof(UGzZoneTrackingComponent) == 0x000008, "Wrong alignment on UGzZoneTrackingComponent");
static_assert(sizeof(UGzZoneTrackingComponent) == 0x0000F0, "Wrong size on UGzZoneTrackingComponent");
static_assert(offsetof(UGzZoneTrackingComponent, OnZoneSideSwitched) == 0x0000A8, "Member 'UGzZoneTrackingComponent::OnZoneSideSwitched' has a wrong offset!");
static_assert(offsetof(UGzZoneTrackingComponent, ZoneEffect) == 0x0000B8, "Member 'UGzZoneTrackingComponent::ZoneEffect' has a wrong offset!");
static_assert(offsetof(UGzZoneTrackingComponent, TrackingType) == 0x0000C0, "Member 'UGzZoneTrackingComponent::TrackingType' has a wrong offset!");
static_assert(offsetof(UGzZoneTrackingComponent, ZoneManager) == 0x0000C8, "Member 'UGzZoneTrackingComponent::ZoneManager' has a wrong offset!");
static_assert(offsetof(UGzZoneTrackingComponent, ASC) == 0x0000D8, "Member 'UGzZoneTrackingComponent::ASC' has a wrong offset!");

// Class G01.GzZoneTriangulationTaskRunner
// 0x0040 (0x0070 - 0x0030)
class UGzZoneTriangulationTaskRunner final : public UWorldSubsystem
{
public:
	uint8                                         Pad_35C1[0x10];                                    // 0x0030(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class UTextureRenderTarget2D*                 RenderTarget;                                      // 0x0040(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_35C2[0x28];                                    // 0x0048(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnZoneStartOverload(class AGzBattleRoyaleZone* Zone);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzZoneTriangulationTaskRunner">();
	}
	static class UGzZoneTriangulationTaskRunner* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzZoneTriangulationTaskRunner>();
	}
};
static_assert(alignof(UGzZoneTriangulationTaskRunner) == 0x000008, "Wrong alignment on UGzZoneTriangulationTaskRunner");
static_assert(sizeof(UGzZoneTriangulationTaskRunner) == 0x000070, "Wrong size on UGzZoneTriangulationTaskRunner");
static_assert(offsetof(UGzZoneTriangulationTaskRunner, RenderTarget) == 0x000040, "Member 'UGzZoneTriangulationTaskRunner::RenderTarget' has a wrong offset!");

// Class G01.GzZoneVisualizationComponent
// 0x0020 (0x00C8 - 0x00A8)
class UGzZoneVisualizationComponent final : public UActorComponent
{
public:
	struct FColor                                 ZoneBordersColor;                                  // 0x00A8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FColor                                 ZonePlaneColor;                                    // 0x00AC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FColor                                 LandingZoneDebugColor;                             // 0x00B0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_35C3[0x4];                                     // 0x00B4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UMaterialInterface*                     LandingZonePreviewMaterial;                        // 0x00B8(0x0008)(Edit, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LandingZoneCylinderHalfHeight;                     // 0x00C0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         LandingZoneCylinderSectionsCount;                  // 0x00C4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzZoneVisualizationComponent">();
	}
	static class UGzZoneVisualizationComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzZoneVisualizationComponent>();
	}
};
static_assert(alignof(UGzZoneVisualizationComponent) == 0x000008, "Wrong alignment on UGzZoneVisualizationComponent");
static_assert(sizeof(UGzZoneVisualizationComponent) == 0x0000C8, "Wrong size on UGzZoneVisualizationComponent");
static_assert(offsetof(UGzZoneVisualizationComponent, ZoneBordersColor) == 0x0000A8, "Member 'UGzZoneVisualizationComponent::ZoneBordersColor' has a wrong offset!");
static_assert(offsetof(UGzZoneVisualizationComponent, ZonePlaneColor) == 0x0000AC, "Member 'UGzZoneVisualizationComponent::ZonePlaneColor' has a wrong offset!");
static_assert(offsetof(UGzZoneVisualizationComponent, LandingZoneDebugColor) == 0x0000B0, "Member 'UGzZoneVisualizationComponent::LandingZoneDebugColor' has a wrong offset!");
static_assert(offsetof(UGzZoneVisualizationComponent, LandingZonePreviewMaterial) == 0x0000B8, "Member 'UGzZoneVisualizationComponent::LandingZonePreviewMaterial' has a wrong offset!");
static_assert(offsetof(UGzZoneVisualizationComponent, LandingZoneCylinderHalfHeight) == 0x0000C0, "Member 'UGzZoneVisualizationComponent::LandingZoneCylinderHalfHeight' has a wrong offset!");
static_assert(offsetof(UGzZoneVisualizationComponent, LandingZoneCylinderSectionsCount) == 0x0000C4, "Member 'UGzZoneVisualizationComponent::LandingZoneCylinderSectionsCount' has a wrong offset!");

// Class G01.GzZoomCameraOverlayModeDataAsset
// 0x0008 (0x0248 - 0x0240)
class UGzZoomCameraOverlayModeDataAsset final : public UGzCameraOverlayModeDataAsset
{
public:
	int32                                         ScopeZoomMagnification;                            // 0x0240(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_35C4[0x4];                                     // 0x0244(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzZoomCameraOverlayModeDataAsset">();
	}
	static class UGzZoomCameraOverlayModeDataAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzZoomCameraOverlayModeDataAsset>();
	}
};
static_assert(alignof(UGzZoomCameraOverlayModeDataAsset) == 0x000008, "Wrong alignment on UGzZoomCameraOverlayModeDataAsset");
static_assert(sizeof(UGzZoomCameraOverlayModeDataAsset) == 0x000248, "Wrong size on UGzZoomCameraOverlayModeDataAsset");
static_assert(offsetof(UGzZoomCameraOverlayModeDataAsset, ScopeZoomMagnification) == 0x000240, "Member 'UGzZoomCameraOverlayModeDataAsset::ScopeZoomMagnification' has a wrong offset!");

// Class G01.Gz_BTService_CheckTargetDistance
// 0x00D8 (0x0170 - 0x0098)
class UGz_BTService_CheckTargetDistance final : public UBTService_BlackboardBase
{
public:
	struct FBlackboardKeySelector                 EnemyKey;                                          // 0x0098(0x0028)(Edit, NativeAccessSpecifierPublic)
	TMap<EGzNpcDistanceToTarget, float>           TargetDistanceParameters;                          // 0x00C0(0x0050)(Edit, NativeAccessSpecifierPublic)
	struct FBlackboardKeySelector                 EnumDistanceKey;                                   // 0x0110(0x0028)(Edit, NativeAccessSpecifierPublic)
	struct FBlackboardKeySelector                 TargetDistanceKey;                                 // 0x0138(0x0028)(Edit, NativeAccessSpecifierPublic)
	class AGzAIController*                        GzAIController;                                    // 0x0160(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UBlackboardComponent*                   BlackboardComponent;                               // 0x0168(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void CalculateTargetDistance() const;
	class UBlackboardComponent* GetBlackboardComponent() const;
	class AGzAIController* GetGzAIController() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Gz_BTService_CheckTargetDistance">();
	}
	static class UGz_BTService_CheckTargetDistance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGz_BTService_CheckTargetDistance>();
	}
};
static_assert(alignof(UGz_BTService_CheckTargetDistance) == 0x000008, "Wrong alignment on UGz_BTService_CheckTargetDistance");
static_assert(sizeof(UGz_BTService_CheckTargetDistance) == 0x000170, "Wrong size on UGz_BTService_CheckTargetDistance");
static_assert(offsetof(UGz_BTService_CheckTargetDistance, EnemyKey) == 0x000098, "Member 'UGz_BTService_CheckTargetDistance::EnemyKey' has a wrong offset!");
static_assert(offsetof(UGz_BTService_CheckTargetDistance, TargetDistanceParameters) == 0x0000C0, "Member 'UGz_BTService_CheckTargetDistance::TargetDistanceParameters' has a wrong offset!");
static_assert(offsetof(UGz_BTService_CheckTargetDistance, EnumDistanceKey) == 0x000110, "Member 'UGz_BTService_CheckTargetDistance::EnumDistanceKey' has a wrong offset!");
static_assert(offsetof(UGz_BTService_CheckTargetDistance, TargetDistanceKey) == 0x000138, "Member 'UGz_BTService_CheckTargetDistance::TargetDistanceKey' has a wrong offset!");
static_assert(offsetof(UGz_BTService_CheckTargetDistance, GzAIController) == 0x000160, "Member 'UGz_BTService_CheckTargetDistance::GzAIController' has a wrong offset!");
static_assert(offsetof(UGz_BTService_CheckTargetDistance, BlackboardComponent) == 0x000168, "Member 'UGz_BTService_CheckTargetDistance::BlackboardComponent' has a wrong offset!");

// Class G01.Gz_BTTask_FlyTo
// 0x0070 (0x00E0 - 0x0070)
class UGz_BTTask_FlyTo final : public UBTTaskNode
{
public:
	struct FBlackboardKeySelector                 TargetKey;                                         // 0x0070(0x0028)(Edit, NativeAccessSpecifierPrivate)
	float                                         AcceptableRadius;                                  // 0x0098(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_35C5[0x4];                                     // 0x009C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class AGzAICharacter*                         AICharacter;                                       // 0x00A0(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class AActor*                                 TargetObject;                                      // 0x00A8(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UGzCharacterMovementComponent*          AICharacterMovement;                               // 0x00B0(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_35C6[0x28];                                    // 0x00B8(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static TArray<struct FVector> FindFlightPath(const class AGzAICharacter* TargetAI, const class AActor* DestinationActor);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Gz_BTTask_FlyTo">();
	}
	static class UGz_BTTask_FlyTo* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGz_BTTask_FlyTo>();
	}
};
static_assert(alignof(UGz_BTTask_FlyTo) == 0x000008, "Wrong alignment on UGz_BTTask_FlyTo");
static_assert(sizeof(UGz_BTTask_FlyTo) == 0x0000E0, "Wrong size on UGz_BTTask_FlyTo");
static_assert(offsetof(UGz_BTTask_FlyTo, TargetKey) == 0x000070, "Member 'UGz_BTTask_FlyTo::TargetKey' has a wrong offset!");
static_assert(offsetof(UGz_BTTask_FlyTo, AcceptableRadius) == 0x000098, "Member 'UGz_BTTask_FlyTo::AcceptableRadius' has a wrong offset!");
static_assert(offsetof(UGz_BTTask_FlyTo, AICharacter) == 0x0000A0, "Member 'UGz_BTTask_FlyTo::AICharacter' has a wrong offset!");
static_assert(offsetof(UGz_BTTask_FlyTo, TargetObject) == 0x0000A8, "Member 'UGz_BTTask_FlyTo::TargetObject' has a wrong offset!");
static_assert(offsetof(UGz_BTTask_FlyTo, AICharacterMovement) == 0x0000B0, "Member 'UGz_BTTask_FlyTo::AICharacterMovement' has a wrong offset!");

// Class G01.Gz_BTTask_SetFocusToPlayer
// 0x0000 (0x0070 - 0x0070)
class UGz_BTTask_SetFocusToPlayer final : public UBTTaskNode
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Gz_BTTask_SetFocusToPlayer">();
	}
	static class UGz_BTTask_SetFocusToPlayer* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGz_BTTask_SetFocusToPlayer>();
	}
};
static_assert(alignof(UGz_BTTask_SetFocusToPlayer) == 0x000008, "Wrong alignment on UGz_BTTask_SetFocusToPlayer");
static_assert(sizeof(UGz_BTTask_SetFocusToPlayer) == 0x000070, "Wrong size on UGz_BTTask_SetFocusToPlayer");

// Class G01.HitResultValidatorInterface
// 0x0000 (0x0028 - 0x0028)
class IHitResultValidatorInterface final : public IInterface
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HitResultValidatorInterface">();
	}
	static class IHitResultValidatorInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IHitResultValidatorInterface>();
	}
};
static_assert(alignof(IHitResultValidatorInterface) == 0x000008, "Wrong alignment on IHitResultValidatorInterface");
static_assert(sizeof(IHitResultValidatorInterface) == 0x000028, "Wrong size on IHitResultValidatorInterface");

// Class G01.InterestPoint
// 0x0018 (0x02B8 - 0x02A0)
class AInterestPoint : public AActor
{
public:
	bool                                          Free;                                              // 0x02A0(0x0001)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_35C7[0x3];                                     // 0x02A1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTag                           SoundTag;                                          // 0x02A4(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_35C8[0x4];                                     // 0x02AC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UAnimMontage*                           AnimMontage;                                       // 0x02B0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	void SetPointFree(bool NewFree);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"InterestPoint">();
	}
	static class AInterestPoint* GetDefaultObj()
	{
		return GetDefaultObjImpl<AInterestPoint>();
	}
};
static_assert(alignof(AInterestPoint) == 0x000008, "Wrong alignment on AInterestPoint");
static_assert(sizeof(AInterestPoint) == 0x0002B8, "Wrong size on AInterestPoint");
static_assert(offsetof(AInterestPoint, Free) == 0x0002A0, "Member 'AInterestPoint::Free' has a wrong offset!");
static_assert(offsetof(AInterestPoint, SoundTag) == 0x0002A4, "Member 'AInterestPoint::SoundTag' has a wrong offset!");
static_assert(offsetof(AInterestPoint, AnimMontage) == 0x0002B0, "Member 'AInterestPoint::AnimMontage' has a wrong offset!");

// Class G01.LocomotionCharacterInterface
// 0x0000 (0x0028 - 0x0028)
class ILocomotionCharacterInterface final : public IInterface
{
public:
	void SetMovementAction(ELocomotionMovementAction MovementAction);
	void SetOverlayState(ELocomotionOverlayState OverlayState);

	class UCapsuleComponent* GetCapsule() const;
	void GetCurrentStates(struct FLocomotionCurrentStates* States) const;
	void GetEssentialValues(struct FLocomotionEssentialValues* Values) const;
	class UStaticMeshComponent* GetHeldObjectMesh() const;
	class USceneComponent* GetHeldObjectRoot() const;
	class USkeletalMeshComponent* GetHeldObjectSkeletalMesh() const;
	class UCharacterMovementComponent* GetMovement() const;
	class USkeletalMeshComponent* GetPawnMesh() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LocomotionCharacterInterface">();
	}
	static class ILocomotionCharacterInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<ILocomotionCharacterInterface>();
	}
};
static_assert(alignof(ILocomotionCharacterInterface) == 0x000008, "Wrong alignment on ILocomotionCharacterInterface");
static_assert(sizeof(ILocomotionCharacterInterface) == 0x000028, "Wrong size on ILocomotionCharacterInterface");

// Class G01.LocomotionComponent
// 0x01A0 (0x0248 - 0x00A8)
class ULocomotionComponent final : public UActorComponent
{
public:
	uint8                                         Pad_35C9[0x8];                                     // 0x00A8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	FMulticastInlineDelegateProperty_             OnOverlayStateChangedDelegate;                     // 0x00B0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnViewModeChangedDelegate;                         // 0x00C0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnRotationModeChagedDelegate;                      // 0x00D0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnGaitChangedDelegate;                             // 0x00E0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnMovementStateChangedDelegate;                    // 0x00F0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnStanceChangedDelegate;                           // 0x0100(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	struct FLocomotionHeldObjectVariables         HeldObjectVariables;                               // 0x0110(0x0018)(BlueprintVisible, BlueprintReadOnly, Transient, NoDestructor, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	class UAnimInstance*                          MainAnimInstance;                                  // 0x0128(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UGzCharacterMovementComponent*          CharacterMovement;                                 // 0x0130(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCapsuleComponent*                      CapsuleComponent;                                  // 0x0138(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USkeletalMeshComponent*                 PawnMeshComponent;                                 // 0x0140(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class ACharacter*                             Character;                                         // 0x0148(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class ULocomotionGetUpAnimations*             GetUpAnimations;                                   // 0x0150(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class ULocomotionRollAnimations*              RollAnimations;                                    // 0x0158(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class ULocomotionVaultingAssetCollection*     MantleAssets;                                      // 0x0160(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bForceVerticalAlignment;                           // 0x0168(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_35CA[0x7];                                     // 0x0169(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                Acceleration;                                      // 0x0170(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsMoving;                                         // 0x0188(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bHasMovementInput;                                 // 0x0189(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_35CB[0x6];                                     // 0x018A(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRotator                               LastVelocityRotation;                              // 0x0190(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FRotator                               LastMovementInputRotation;                         // 0x01A8(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	float                                         Speed;                                             // 0x01C0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MovementInputAmount;                               // 0x01C4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         AimYawRate;                                        // 0x01C8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	ELocomotionRotationMode                       RotationMode;                                      // 0x01CC(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	ELocomotionGait                               Gait;                                              // 0x01CD(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	ELocomotionViewMode                           ViewMode;                                          // 0x01CE(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	ELocomotionStance                             Stance;                                            // 0x01CF(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	ELocomotionMovementState                      PrevMovementState;                                 // 0x01D0(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	ELocomotionMovementState                      MovementState;                                     // 0x01D1(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	ELocomotionOverlayState                       OverlayState;                                      // 0x01D2(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_35CC[0x5];                                     // 0x01D3(0x0005)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRotator                               TargetRotation;                                    // 0x01D8(0x0018)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FRotator                               InAirRotation;                                     // 0x01F0(0x0018)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	ELocomotionRotationMode                       DesiredRotationMode;                               // 0x0208(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ELocomotionStance                             DesiredStance;                                     // 0x0209(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          RagdollOnGround;                                   // 0x020A(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          RagdollFaceUp;                                     // 0x020B(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_35CD[0x4];                                     // 0x020C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                LastRagdollVelociy;                                // 0x0210(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                PreviousVelocity;                                  // 0x0228(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PreviousAimYaw;                                    // 0x0240(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_35CE[0x4];                                     // 0x0244(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AttachToHand(class UStaticMesh* NewStaticMesh, class USkeletalMesh* NewSkeletalMesh, class UClass* AnimInstanceClass, bool bLeftHand, const struct FVector& Offset);
	void CacheValues();
	void ClearHeldObject();
	ELocomotionRotationMode GetRotationMode();
	ELocomotionStance GetStance();
	bool Initialize(const class AActor* LocomotionCharacter);
	void OnGaitChanged();
	void OnGaitChanged__DelegateSignature();
	void OnMovementActionChanged(ELocomotionMovementAction PreviousAction);
	void OnMovementModeChanged(class ACharacter* C, EMovementMode PrevMovementMode, uint8 PreviousCustomMode);
	void OnMovementStateChanged__DelegateSignature();
	void OnOverlayChanged();
	void OnOverlayStateChanged__DelegateSignature();
	void OnRotationModeChaged__DelegateSignature();
	void OnRotationModeChanged();
	void OnStanceChanged();
	void OnStanceChanged__DelegateSignature();
	void OnViewModeChanged();
	void OnViewModeChanged__DelegateSignature();
	void Roll(float PlayRate);
	void SetEssentialValues(const float DeltaTime);
	void SetHeldObjectVariables(const struct FLocomotionHeldObjectVariables& Variables);
	void SetMovementState(ELocomotionMovementState NewMovementState);
	void SetOverlayState(ELocomotionOverlayState NewOverlayState);
	void SetStance(ELocomotionStance NewStance);
	void SetViewMode(ELocomotionViewMode NewViewMode);
	struct FRotator UpdateGroundedRotation(float DeltaTime, bool bLocallyControlled);
	void UpdateHeldObject();
	void UpdateHeldObjectAnimations();
	void UpdateInAirRotation(float DeltaTime, bool bLocallyControlled);

	struct FRotator GetControlRotation() const;
	class UAnimMontage* GetGetUpAnimation() const;
	class UAnimMontage* GetRollAnimation() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LocomotionComponent">();
	}
	static class ULocomotionComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULocomotionComponent>();
	}
};
static_assert(alignof(ULocomotionComponent) == 0x000008, "Wrong alignment on ULocomotionComponent");
static_assert(sizeof(ULocomotionComponent) == 0x000248, "Wrong size on ULocomotionComponent");
static_assert(offsetof(ULocomotionComponent, OnOverlayStateChangedDelegate) == 0x0000B0, "Member 'ULocomotionComponent::OnOverlayStateChangedDelegate' has a wrong offset!");
static_assert(offsetof(ULocomotionComponent, OnViewModeChangedDelegate) == 0x0000C0, "Member 'ULocomotionComponent::OnViewModeChangedDelegate' has a wrong offset!");
static_assert(offsetof(ULocomotionComponent, OnRotationModeChagedDelegate) == 0x0000D0, "Member 'ULocomotionComponent::OnRotationModeChagedDelegate' has a wrong offset!");
static_assert(offsetof(ULocomotionComponent, OnGaitChangedDelegate) == 0x0000E0, "Member 'ULocomotionComponent::OnGaitChangedDelegate' has a wrong offset!");
static_assert(offsetof(ULocomotionComponent, OnMovementStateChangedDelegate) == 0x0000F0, "Member 'ULocomotionComponent::OnMovementStateChangedDelegate' has a wrong offset!");
static_assert(offsetof(ULocomotionComponent, OnStanceChangedDelegate) == 0x000100, "Member 'ULocomotionComponent::OnStanceChangedDelegate' has a wrong offset!");
static_assert(offsetof(ULocomotionComponent, HeldObjectVariables) == 0x000110, "Member 'ULocomotionComponent::HeldObjectVariables' has a wrong offset!");
static_assert(offsetof(ULocomotionComponent, MainAnimInstance) == 0x000128, "Member 'ULocomotionComponent::MainAnimInstance' has a wrong offset!");
static_assert(offsetof(ULocomotionComponent, CharacterMovement) == 0x000130, "Member 'ULocomotionComponent::CharacterMovement' has a wrong offset!");
static_assert(offsetof(ULocomotionComponent, CapsuleComponent) == 0x000138, "Member 'ULocomotionComponent::CapsuleComponent' has a wrong offset!");
static_assert(offsetof(ULocomotionComponent, PawnMeshComponent) == 0x000140, "Member 'ULocomotionComponent::PawnMeshComponent' has a wrong offset!");
static_assert(offsetof(ULocomotionComponent, Character) == 0x000148, "Member 'ULocomotionComponent::Character' has a wrong offset!");
static_assert(offsetof(ULocomotionComponent, GetUpAnimations) == 0x000150, "Member 'ULocomotionComponent::GetUpAnimations' has a wrong offset!");
static_assert(offsetof(ULocomotionComponent, RollAnimations) == 0x000158, "Member 'ULocomotionComponent::RollAnimations' has a wrong offset!");
static_assert(offsetof(ULocomotionComponent, MantleAssets) == 0x000160, "Member 'ULocomotionComponent::MantleAssets' has a wrong offset!");
static_assert(offsetof(ULocomotionComponent, bForceVerticalAlignment) == 0x000168, "Member 'ULocomotionComponent::bForceVerticalAlignment' has a wrong offset!");
static_assert(offsetof(ULocomotionComponent, Acceleration) == 0x000170, "Member 'ULocomotionComponent::Acceleration' has a wrong offset!");
static_assert(offsetof(ULocomotionComponent, bIsMoving) == 0x000188, "Member 'ULocomotionComponent::bIsMoving' has a wrong offset!");
static_assert(offsetof(ULocomotionComponent, bHasMovementInput) == 0x000189, "Member 'ULocomotionComponent::bHasMovementInput' has a wrong offset!");
static_assert(offsetof(ULocomotionComponent, LastVelocityRotation) == 0x000190, "Member 'ULocomotionComponent::LastVelocityRotation' has a wrong offset!");
static_assert(offsetof(ULocomotionComponent, LastMovementInputRotation) == 0x0001A8, "Member 'ULocomotionComponent::LastMovementInputRotation' has a wrong offset!");
static_assert(offsetof(ULocomotionComponent, Speed) == 0x0001C0, "Member 'ULocomotionComponent::Speed' has a wrong offset!");
static_assert(offsetof(ULocomotionComponent, MovementInputAmount) == 0x0001C4, "Member 'ULocomotionComponent::MovementInputAmount' has a wrong offset!");
static_assert(offsetof(ULocomotionComponent, AimYawRate) == 0x0001C8, "Member 'ULocomotionComponent::AimYawRate' has a wrong offset!");
static_assert(offsetof(ULocomotionComponent, RotationMode) == 0x0001CC, "Member 'ULocomotionComponent::RotationMode' has a wrong offset!");
static_assert(offsetof(ULocomotionComponent, Gait) == 0x0001CD, "Member 'ULocomotionComponent::Gait' has a wrong offset!");
static_assert(offsetof(ULocomotionComponent, ViewMode) == 0x0001CE, "Member 'ULocomotionComponent::ViewMode' has a wrong offset!");
static_assert(offsetof(ULocomotionComponent, Stance) == 0x0001CF, "Member 'ULocomotionComponent::Stance' has a wrong offset!");
static_assert(offsetof(ULocomotionComponent, PrevMovementState) == 0x0001D0, "Member 'ULocomotionComponent::PrevMovementState' has a wrong offset!");
static_assert(offsetof(ULocomotionComponent, MovementState) == 0x0001D1, "Member 'ULocomotionComponent::MovementState' has a wrong offset!");
static_assert(offsetof(ULocomotionComponent, OverlayState) == 0x0001D2, "Member 'ULocomotionComponent::OverlayState' has a wrong offset!");
static_assert(offsetof(ULocomotionComponent, TargetRotation) == 0x0001D8, "Member 'ULocomotionComponent::TargetRotation' has a wrong offset!");
static_assert(offsetof(ULocomotionComponent, InAirRotation) == 0x0001F0, "Member 'ULocomotionComponent::InAirRotation' has a wrong offset!");
static_assert(offsetof(ULocomotionComponent, DesiredRotationMode) == 0x000208, "Member 'ULocomotionComponent::DesiredRotationMode' has a wrong offset!");
static_assert(offsetof(ULocomotionComponent, DesiredStance) == 0x000209, "Member 'ULocomotionComponent::DesiredStance' has a wrong offset!");
static_assert(offsetof(ULocomotionComponent, RagdollOnGround) == 0x00020A, "Member 'ULocomotionComponent::RagdollOnGround' has a wrong offset!");
static_assert(offsetof(ULocomotionComponent, RagdollFaceUp) == 0x00020B, "Member 'ULocomotionComponent::RagdollFaceUp' has a wrong offset!");
static_assert(offsetof(ULocomotionComponent, LastRagdollVelociy) == 0x000210, "Member 'ULocomotionComponent::LastRagdollVelociy' has a wrong offset!");
static_assert(offsetof(ULocomotionComponent, PreviousVelocity) == 0x000228, "Member 'ULocomotionComponent::PreviousVelocity' has a wrong offset!");
static_assert(offsetof(ULocomotionComponent, PreviousAimYaw) == 0x000240, "Member 'ULocomotionComponent::PreviousAimYaw' has a wrong offset!");

// Class G01.LocomotionComponentInterface
// 0x0000 (0x0028 - 0x0028)
class ILocomotionComponentInterface final : public IInterface
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LocomotionComponentInterface">();
	}
	static class ILocomotionComponentInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<ILocomotionComponentInterface>();
	}
};
static_assert(alignof(ILocomotionComponentInterface) == 0x000008, "Wrong alignment on ILocomotionComponentInterface");
static_assert(sizeof(ILocomotionComponentInterface) == 0x000028, "Wrong size on ILocomotionComponentInterface");

// Class G01.LocomotionControllerInterface
// 0x0000 (0x0028 - 0x0028)
class ILocomotionControllerInterface final : public IInterface
{
public:
	void GetDebugInfo(bool* DebugView, bool* ShowHUD, bool* ShowTraces, bool* ShowDebugShapes, bool* ShowLayerColors, bool* Slomo, bool* ShowCharacterInfo) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LocomotionControllerInterface">();
	}
	static class ILocomotionControllerInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<ILocomotionControllerInterface>();
	}
};
static_assert(alignof(ILocomotionControllerInterface) == 0x000008, "Wrong alignment on ILocomotionControllerInterface");
static_assert(sizeof(ILocomotionControllerInterface) == 0x000028, "Wrong size on ILocomotionControllerInterface");

// Class G01.LocomotionHUDWidget
// 0x0020 (0x0300 - 0x02E0)
class ULocomotionHUDWidget final : public UUserWidget
{
public:
	uint8                                         Pad_35D4[0x10];                                    // 0x02E0(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class ACharacter*                             DebugFocusCharacter;                               // 0x02F0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          ShowTraces;                                        // 0x02F8(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          DebugView;                                         // 0x02F9(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          ShowHUD;                                           // 0x02FA(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          ShowDebugShapes;                                   // 0x02FB(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          ShowLayerColors;                                   // 0x02FC(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          Slomo;                                             // 0x02FD(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          ShowCharacterInfo;                                 // 0x02FE(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_35D5[0x1];                                     // 0x02FF(0x0001)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void InitializeWidget(class UCanvasPanel* MovablePanels, class UImage* Arrow);

	ESlateVisibility GetCharacterInfoVisibility() const;
	class FText GetCharacterStates() const;
	class FText GetDebugViewKey() const;
	class FText GetShowCharacterInfoKey() const;
	class FText GetShowDebugShapesKey() const;
	class FText GetShowHUDKey() const;
	class FText GetShowLayerColorsKey() const;
	class FText GetShowTracesKey() const;
	class FText GetSlomoKey() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LocomotionHUDWidget">();
	}
	static class ULocomotionHUDWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULocomotionHUDWidget>();
	}
};
static_assert(alignof(ULocomotionHUDWidget) == 0x000008, "Wrong alignment on ULocomotionHUDWidget");
static_assert(sizeof(ULocomotionHUDWidget) == 0x000300, "Wrong size on ULocomotionHUDWidget");
static_assert(offsetof(ULocomotionHUDWidget, DebugFocusCharacter) == 0x0002F0, "Member 'ULocomotionHUDWidget::DebugFocusCharacter' has a wrong offset!");
static_assert(offsetof(ULocomotionHUDWidget, ShowTraces) == 0x0002F8, "Member 'ULocomotionHUDWidget::ShowTraces' has a wrong offset!");
static_assert(offsetof(ULocomotionHUDWidget, DebugView) == 0x0002F9, "Member 'ULocomotionHUDWidget::DebugView' has a wrong offset!");
static_assert(offsetof(ULocomotionHUDWidget, ShowHUD) == 0x0002FA, "Member 'ULocomotionHUDWidget::ShowHUD' has a wrong offset!");
static_assert(offsetof(ULocomotionHUDWidget, ShowDebugShapes) == 0x0002FB, "Member 'ULocomotionHUDWidget::ShowDebugShapes' has a wrong offset!");
static_assert(offsetof(ULocomotionHUDWidget, ShowLayerColors) == 0x0002FC, "Member 'ULocomotionHUDWidget::ShowLayerColors' has a wrong offset!");
static_assert(offsetof(ULocomotionHUDWidget, Slomo) == 0x0002FD, "Member 'ULocomotionHUDWidget::Slomo' has a wrong offset!");
static_assert(offsetof(ULocomotionHUDWidget, ShowCharacterInfo) == 0x0002FE, "Member 'ULocomotionHUDWidget::ShowCharacterInfo' has a wrong offset!");

// Class G01.GzAT_WaitSlideEndConditionsMeet
// 0x0020 (0x00A0 - 0x0080)
class UGzAT_WaitSlideEndConditionsMeet final : public UAbilityTask
{
public:
	FMulticastInlineDelegateProperty_             OnEndConditionsMeet;                               // 0x0080(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	class UGzCharacterMovementComponent*          CachedMovementComponent;                           // 0x0090(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_35D6[0x8];                                     // 0x0098(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UGzAT_WaitSlideEndConditionsMeet* CreateWaitSlideEndConditionsMeet(class UGameplayAbility* OwningAbility, float SpeedThreshold);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzAT_WaitSlideEndConditionsMeet">();
	}
	static class UGzAT_WaitSlideEndConditionsMeet* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzAT_WaitSlideEndConditionsMeet>();
	}
};
static_assert(alignof(UGzAT_WaitSlideEndConditionsMeet) == 0x000008, "Wrong alignment on UGzAT_WaitSlideEndConditionsMeet");
static_assert(sizeof(UGzAT_WaitSlideEndConditionsMeet) == 0x0000A0, "Wrong size on UGzAT_WaitSlideEndConditionsMeet");
static_assert(offsetof(UGzAT_WaitSlideEndConditionsMeet, OnEndConditionsMeet) == 0x000080, "Member 'UGzAT_WaitSlideEndConditionsMeet::OnEndConditionsMeet' has a wrong offset!");
static_assert(offsetof(UGzAT_WaitSlideEndConditionsMeet, CachedMovementComponent) == 0x000090, "Member 'UGzAT_WaitSlideEndConditionsMeet::CachedMovementComponent' has a wrong offset!");

// Class G01.GzCharacterCreationModel
// 0x01D0 (0x0240 - 0x0070)
class UGzCharacterCreationModel final : public UGzBackendModel
{
public:
	uint8                                         Pad_35D8[0x1D0];                                   // 0x0070(0x01D0)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzCharacterCreationModel">();
	}
	static class UGzCharacterCreationModel* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzCharacterCreationModel>();
	}
};
static_assert(alignof(UGzCharacterCreationModel) == 0x000008, "Wrong alignment on UGzCharacterCreationModel");
static_assert(sizeof(UGzCharacterCreationModel) == 0x000240, "Wrong size on UGzCharacterCreationModel");

// Class G01.GzGamepadCursorSettings
// 0x00B0 (0x00E8 - 0x0038)
class UGzGamepadCursorSettings final : public UDeveloperSettings
{
public:
	struct FRuntimeFloatCurve                     AnalogCursorAccelerationCurve;                     // 0x0038(0x0088)(Edit, Config, NativeAccessSpecifierPrivate)
	float                                         MaxAnalogCursorSpeed;                              // 0x00C0(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         MaxAnalogCursorSpeedWhenHovered;                   // 0x00C4(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         AnalogCursorDragCoefficient;                       // 0x00C8(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         AnalogCursorDragCoefficientWhenHovered;            // 0x00CC(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         MinAnalogCursorSpeed;                              // 0x00D0(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         AnalogCursorDeadZone;                              // 0x00D4(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         AnalogCursorAccelerationMultiplier;                // 0x00D8(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         AnalogCursorSize;                                  // 0x00DC(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bAnalogCursorNoAcceleration;                       // 0x00E0(0x0001)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_35D9[0x7];                                     // 0x00E1(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GzGamepadCursorSettings">();
	}
	static class UGzGamepadCursorSettings* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGzGamepadCursorSettings>();
	}
};
static_assert(alignof(UGzGamepadCursorSettings) == 0x000008, "Wrong alignment on UGzGamepadCursorSettings");
static_assert(sizeof(UGzGamepadCursorSettings) == 0x0000E8, "Wrong size on UGzGamepadCursorSettings");
static_assert(offsetof(UGzGamepadCursorSettings, AnalogCursorAccelerationCurve) == 0x000038, "Member 'UGzGamepadCursorSettings::AnalogCursorAccelerationCurve' has a wrong offset!");
static_assert(offsetof(UGzGamepadCursorSettings, MaxAnalogCursorSpeed) == 0x0000C0, "Member 'UGzGamepadCursorSettings::MaxAnalogCursorSpeed' has a wrong offset!");
static_assert(offsetof(UGzGamepadCursorSettings, MaxAnalogCursorSpeedWhenHovered) == 0x0000C4, "Member 'UGzGamepadCursorSettings::MaxAnalogCursorSpeedWhenHovered' has a wrong offset!");
static_assert(offsetof(UGzGamepadCursorSettings, AnalogCursorDragCoefficient) == 0x0000C8, "Member 'UGzGamepadCursorSettings::AnalogCursorDragCoefficient' has a wrong offset!");
static_assert(offsetof(UGzGamepadCursorSettings, AnalogCursorDragCoefficientWhenHovered) == 0x0000CC, "Member 'UGzGamepadCursorSettings::AnalogCursorDragCoefficientWhenHovered' has a wrong offset!");
static_assert(offsetof(UGzGamepadCursorSettings, MinAnalogCursorSpeed) == 0x0000D0, "Member 'UGzGamepadCursorSettings::MinAnalogCursorSpeed' has a wrong offset!");
static_assert(offsetof(UGzGamepadCursorSettings, AnalogCursorDeadZone) == 0x0000D4, "Member 'UGzGamepadCursorSettings::AnalogCursorDeadZone' has a wrong offset!");
static_assert(offsetof(UGzGamepadCursorSettings, AnalogCursorAccelerationMultiplier) == 0x0000D8, "Member 'UGzGamepadCursorSettings::AnalogCursorAccelerationMultiplier' has a wrong offset!");
static_assert(offsetof(UGzGamepadCursorSettings, AnalogCursorSize) == 0x0000DC, "Member 'UGzGamepadCursorSettings::AnalogCursorSize' has a wrong offset!");
static_assert(offsetof(UGzGamepadCursorSettings, bAnalogCursorNoAcceleration) == 0x0000E0, "Member 'UGzGamepadCursorSettings::bAnalogCursorNoAcceleration' has a wrong offset!");

}

