#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: UIPF

#include "Basic.hpp"

#include "Engine_structs.hpp"
#include "Engine_classes.hpp"
#include "CoreUObject_structs.hpp"


namespace SDK
{

// Class UIPF.UIPFActor
// 0x0168 (0x0408 - 0x02A0)
class AUIPFActor final : public AActor
{
public:
	class USkeletalMeshComponent*                 SkeletalMeshComp;                                  // 0x02A0(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   BlockingCollisionOverideSMComp;                    // 0x02A8(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UHierarchicalInstancedStaticMeshComponent* MyISM;                                             // 0x02B0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMesh*                            SM;                                                // 0x02B8(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USkeletalMesh*                          SkelMesh;                                          // 0x02C0(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3E65[0x100];                                   // 0x02C8(0x0100)(Fixing Size After Last Property [ Dumper-7 ])
	TWeakObjectPtr<class AUIPFManager>            UIPFManagerect;                                    // 0x03C8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3E66[0x28];                                    // 0x03D0(0x0028)(Fixing Size After Last Property [ Dumper-7 ])
	class UMaterialInstanceDynamic*               DynamicInstance;                                   // 0x03F8(0x0008)(ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UMaterialInstanceDynamic*               DynamicInstanceStatic;                             // 0x0400(0x0008)(ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void DelayPhysEnabled();
	void Init(bool bFromManual);
	void SkeletonSleep(class UPrimitiveComponent* Comp, class FName bone);
	void TrySleep();
	void UpdateTransition();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIPFActor">();
	}
	static class AUIPFActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<AUIPFActor>();
	}
};
static_assert(alignof(AUIPFActor) == 0x000008, "Wrong alignment on AUIPFActor");
static_assert(sizeof(AUIPFActor) == 0x000408, "Wrong size on AUIPFActor");
static_assert(offsetof(AUIPFActor, SkeletalMeshComp) == 0x0002A0, "Member 'AUIPFActor::SkeletalMeshComp' has a wrong offset!");
static_assert(offsetof(AUIPFActor, BlockingCollisionOverideSMComp) == 0x0002A8, "Member 'AUIPFActor::BlockingCollisionOverideSMComp' has a wrong offset!");
static_assert(offsetof(AUIPFActor, MyISM) == 0x0002B0, "Member 'AUIPFActor::MyISM' has a wrong offset!");
static_assert(offsetof(AUIPFActor, SM) == 0x0002B8, "Member 'AUIPFActor::SM' has a wrong offset!");
static_assert(offsetof(AUIPFActor, SkelMesh) == 0x0002C0, "Member 'AUIPFActor::SkelMesh' has a wrong offset!");
static_assert(offsetof(AUIPFActor, UIPFManagerect) == 0x0003C8, "Member 'AUIPFActor::UIPFManagerect' has a wrong offset!");
static_assert(offsetof(AUIPFActor, DynamicInstance) == 0x0003F8, "Member 'AUIPFActor::DynamicInstance' has a wrong offset!");
static_assert(offsetof(AUIPFActor, DynamicInstanceStatic) == 0x000400, "Member 'AUIPFActor::DynamicInstanceStatic' has a wrong offset!");

// Class UIPF.UIPFImpulse
// 0x0030 (0x02D0 - 0x02A0)
class AUIPFImpulse final : public AActor
{
public:
	uint8                                         Pad_3E67[0x20];                                    // 0x02A0(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	TWeakObjectPtr<class AUIPFManager>            UIPFManagerect;                                    // 0x02C0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USphereComponent*                       SphereComp;                                        // 0x02C8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void InitializeImpulse(float ImpulseRadius, bool UsingTruePhys, bool UsingShaderInt, float ImpulseStrength);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIPFImpulse">();
	}
	static class AUIPFImpulse* GetDefaultObj()
	{
		return GetDefaultObjImpl<AUIPFImpulse>();
	}
};
static_assert(alignof(AUIPFImpulse) == 0x000008, "Wrong alignment on AUIPFImpulse");
static_assert(sizeof(AUIPFImpulse) == 0x0002D0, "Wrong size on AUIPFImpulse");
static_assert(offsetof(AUIPFImpulse, UIPFManagerect) == 0x0002C0, "Member 'AUIPFImpulse::UIPFManagerect' has a wrong offset!");
static_assert(offsetof(AUIPFImpulse, SphereComp) == 0x0002C8, "Member 'AUIPFImpulse::SphereComp' has a wrong offset!");

// Class UIPF.IPFTypes
// 0x0000 (0x00B0 - 0x00B0)
class UIPFTypes final : public UDataTable
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"IPFTypes">();
	}
	static class UIPFTypes* GetDefaultObj()
	{
		return GetDefaultObjImpl<UIPFTypes>();
	}
};
static_assert(alignof(UIPFTypes) == 0x000008, "Wrong alignment on UIPFTypes");
static_assert(sizeof(UIPFTypes) == 0x0000B0, "Wrong size on UIPFTypes");

// Class UIPF.UIPFInteractor
// 0x00F0 (0x0610 - 0x0520)
class UUIPFInteractor final : public UPrimitiveComponent
{
public:
	bool                                          bLimitTickRate;                                    // 0x0520(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3E69[0x3];                                     // 0x0521(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         TickRate;                                          // 0x0524(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PhysFoliageSwapTickRate;                           // 0x0528(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bInteractWithGrass;                                // 0x052C(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3E6A[0x3];                                     // 0x052D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         FGrassInteractionDiameter;                         // 0x0530(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3E6B[0x4];                                     // 0x0534(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bOverrideInteractorActivationDistance;             // 0x0538(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3E6C[0x3];                                     // 0x0539(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         InteractorActivationDistance;                      // 0x053C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bPerCompVelocity;                                  // 0x0540(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bForceFixedInteractionStrength;                    // 0x0541(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3E6D[0x2];                                     // 0x0542(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         FixedStrength;                                     // 0x0544(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3E6E[0x10];                                    // 0x0548(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class USphereComponent*                       FoliageDeactivationVolume;                         // 0x0558(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDataTable*                             UIPFDT;                                            // 0x0560(0x0008)(ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TWeakObjectPtr<class AUIPFManager>            UIPFManagerect;                                    // 0x0568(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3E6F[0xA0];                                    // 0x0570(0x00A0)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ManuallyActivateFoliage(bool WithImpulse, float ImpulseStrength, const struct FHitResult& Hit);
	void OnDeactivationEndOverlap(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex);
	void PhysCheck();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIPFInteractor">();
	}
	static class UUIPFInteractor* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIPFInteractor>();
	}
};
static_assert(alignof(UUIPFInteractor) == 0x000010, "Wrong alignment on UUIPFInteractor");
static_assert(sizeof(UUIPFInteractor) == 0x000610, "Wrong size on UUIPFInteractor");
static_assert(offsetof(UUIPFInteractor, bLimitTickRate) == 0x000520, "Member 'UUIPFInteractor::bLimitTickRate' has a wrong offset!");
static_assert(offsetof(UUIPFInteractor, TickRate) == 0x000524, "Member 'UUIPFInteractor::TickRate' has a wrong offset!");
static_assert(offsetof(UUIPFInteractor, PhysFoliageSwapTickRate) == 0x000528, "Member 'UUIPFInteractor::PhysFoliageSwapTickRate' has a wrong offset!");
static_assert(offsetof(UUIPFInteractor, bInteractWithGrass) == 0x00052C, "Member 'UUIPFInteractor::bInteractWithGrass' has a wrong offset!");
static_assert(offsetof(UUIPFInteractor, FGrassInteractionDiameter) == 0x000530, "Member 'UUIPFInteractor::FGrassInteractionDiameter' has a wrong offset!");
static_assert(offsetof(UUIPFInteractor, bOverrideInteractorActivationDistance) == 0x000538, "Member 'UUIPFInteractor::bOverrideInteractorActivationDistance' has a wrong offset!");
static_assert(offsetof(UUIPFInteractor, InteractorActivationDistance) == 0x00053C, "Member 'UUIPFInteractor::InteractorActivationDistance' has a wrong offset!");
static_assert(offsetof(UUIPFInteractor, bPerCompVelocity) == 0x000540, "Member 'UUIPFInteractor::bPerCompVelocity' has a wrong offset!");
static_assert(offsetof(UUIPFInteractor, bForceFixedInteractionStrength) == 0x000541, "Member 'UUIPFInteractor::bForceFixedInteractionStrength' has a wrong offset!");
static_assert(offsetof(UUIPFInteractor, FixedStrength) == 0x000544, "Member 'UUIPFInteractor::FixedStrength' has a wrong offset!");
static_assert(offsetof(UUIPFInteractor, FoliageDeactivationVolume) == 0x000558, "Member 'UUIPFInteractor::FoliageDeactivationVolume' has a wrong offset!");
static_assert(offsetof(UUIPFInteractor, UIPFDT) == 0x000560, "Member 'UUIPFInteractor::UIPFDT' has a wrong offset!");
static_assert(offsetof(UUIPFInteractor, UIPFManagerect) == 0x000568, "Member 'UUIPFInteractor::UIPFManagerect' has a wrong offset!");

// Class UIPF.UIPFManager
// 0x00E0 (0x0380 - 0x02A0)
class AUIPFManager final : public AActor
{
public:
	uint8                                         Pad_3E72[0x2];                                     // 0x02A0(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          UseShaderInteraction;                              // 0x02A2(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          UseTruePhysics;                                    // 0x02A3(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          UseShaderIntSwitch;                                // 0x02A4(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          UseShaderIntPS4;                                   // 0x02A5(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          UseShaderIntXbox;                                  // 0x02A6(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          UseShaderIntIOS;                                   // 0x02A7(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          UseShaderIntAndroid;                               // 0x02A8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          UseTruePhysicsSwitch;                              // 0x02A9(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          UseTruePhysicsPS4;                                 // 0x02AA(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          UseTruePhysicsXbox;                                // 0x02AB(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          UseTruePhysicsIOS;                                 // 0x02AC(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          UseTruePhysicsAndroid;                             // 0x02AD(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ActivateOnImpulse;                                 // 0x02AE(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3E73[0x1];                                     // 0x02AF(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bLimitTickRate;                                    // 0x02B0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3E74[0x3];                                     // 0x02B1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         TickRate;                                          // 0x02B4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PlayerPhysActivationRadius;                        // 0x02B8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PlayerPhysDeactivationRadius;                      // 0x02BC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxManualActivationDistance;                       // 0x02C0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DefaultInteractorActivationDistance;               // 0x02C4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UDataTable*                             FoliageDataTable;                                  // 0x02C8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMaterialParameterCollection*           MPC_UIPF;                                          // 0x02D0(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class AUIPFActor>                 UIPFActorClass;                                    // 0x02D8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bOverrideTraceChannel;                             // 0x02E0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECollisionChannel                             FoliageTraceChannel;                               // 0x02E1(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3E75[0x6];                                     // 0x02E2(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class UMaterialInstanceDynamic*               AccumulatorInst;                                   // 0x02E8(0x0008)(ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UMaterialInstanceDynamic*               ManualSplatInst;                                   // 0x02F0(0x0008)(ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UMaterialInstanceDynamic*               VelocitySplatInst;                                 // 0x02F8(0x0008)(ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCanvas*                                Canvas;                                            // 0x0300(0x0008)(ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector2D                              Size;                                              // 0x0308(0x0010)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FDrawToRenderTargetContext             Context;                                           // 0x0318(0x0008)(NoDestructor, Protected, NativeAccessSpecifierProtected)
	class UCanvas*                                CanvasInteract;                                    // 0x0320(0x0008)(ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector2D                              SizeInteract;                                      // 0x0328(0x0010)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FDrawToRenderTargetContext             ContextInteract;                                   // 0x0338(0x0008)(NoDestructor, Protected, NativeAccessSpecifierProtected)
	class UBoxComponent*                          BoxComp;                                           // 0x0340(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextureRenderTarget2D*                 Rtvel;                                             // 0x0348(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UTextureRenderTarget2D*                 Rtpos;                                             // 0x0350(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UTextureRenderTarget2D*                 Rtobj;                                             // 0x0358(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UMaterialInterface*                     ForceSplatMat;                                     // 0x0360(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UMaterialInterface*                     ManForceSplatMat;                                  // 0x0368(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UMaterialInterface*                     VelSplatMat;                                       // 0x0370(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UMaterialInterface*                     PersistentAccumulator;                             // 0x0378(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void FoliageForceAtLocation(float FStrength, float FSizePercent, const struct FVector& HitLocation, bool bIsImpulse);
	void ForceAppliedAtLocation(const struct FVector& Loc, float Strength);
	void ImpulseAtLocation(const struct FVector& Location, float ImpulseDiameter, float ImpulseStrengthIn);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIPFManager">();
	}
	static class AUIPFManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<AUIPFManager>();
	}
};
static_assert(alignof(AUIPFManager) == 0x000008, "Wrong alignment on AUIPFManager");
static_assert(sizeof(AUIPFManager) == 0x000380, "Wrong size on AUIPFManager");
static_assert(offsetof(AUIPFManager, UseShaderInteraction) == 0x0002A2, "Member 'AUIPFManager::UseShaderInteraction' has a wrong offset!");
static_assert(offsetof(AUIPFManager, UseTruePhysics) == 0x0002A3, "Member 'AUIPFManager::UseTruePhysics' has a wrong offset!");
static_assert(offsetof(AUIPFManager, UseShaderIntSwitch) == 0x0002A4, "Member 'AUIPFManager::UseShaderIntSwitch' has a wrong offset!");
static_assert(offsetof(AUIPFManager, UseShaderIntPS4) == 0x0002A5, "Member 'AUIPFManager::UseShaderIntPS4' has a wrong offset!");
static_assert(offsetof(AUIPFManager, UseShaderIntXbox) == 0x0002A6, "Member 'AUIPFManager::UseShaderIntXbox' has a wrong offset!");
static_assert(offsetof(AUIPFManager, UseShaderIntIOS) == 0x0002A7, "Member 'AUIPFManager::UseShaderIntIOS' has a wrong offset!");
static_assert(offsetof(AUIPFManager, UseShaderIntAndroid) == 0x0002A8, "Member 'AUIPFManager::UseShaderIntAndroid' has a wrong offset!");
static_assert(offsetof(AUIPFManager, UseTruePhysicsSwitch) == 0x0002A9, "Member 'AUIPFManager::UseTruePhysicsSwitch' has a wrong offset!");
static_assert(offsetof(AUIPFManager, UseTruePhysicsPS4) == 0x0002AA, "Member 'AUIPFManager::UseTruePhysicsPS4' has a wrong offset!");
static_assert(offsetof(AUIPFManager, UseTruePhysicsXbox) == 0x0002AB, "Member 'AUIPFManager::UseTruePhysicsXbox' has a wrong offset!");
static_assert(offsetof(AUIPFManager, UseTruePhysicsIOS) == 0x0002AC, "Member 'AUIPFManager::UseTruePhysicsIOS' has a wrong offset!");
static_assert(offsetof(AUIPFManager, UseTruePhysicsAndroid) == 0x0002AD, "Member 'AUIPFManager::UseTruePhysicsAndroid' has a wrong offset!");
static_assert(offsetof(AUIPFManager, ActivateOnImpulse) == 0x0002AE, "Member 'AUIPFManager::ActivateOnImpulse' has a wrong offset!");
static_assert(offsetof(AUIPFManager, bLimitTickRate) == 0x0002B0, "Member 'AUIPFManager::bLimitTickRate' has a wrong offset!");
static_assert(offsetof(AUIPFManager, TickRate) == 0x0002B4, "Member 'AUIPFManager::TickRate' has a wrong offset!");
static_assert(offsetof(AUIPFManager, PlayerPhysActivationRadius) == 0x0002B8, "Member 'AUIPFManager::PlayerPhysActivationRadius' has a wrong offset!");
static_assert(offsetof(AUIPFManager, PlayerPhysDeactivationRadius) == 0x0002BC, "Member 'AUIPFManager::PlayerPhysDeactivationRadius' has a wrong offset!");
static_assert(offsetof(AUIPFManager, MaxManualActivationDistance) == 0x0002C0, "Member 'AUIPFManager::MaxManualActivationDistance' has a wrong offset!");
static_assert(offsetof(AUIPFManager, DefaultInteractorActivationDistance) == 0x0002C4, "Member 'AUIPFManager::DefaultInteractorActivationDistance' has a wrong offset!");
static_assert(offsetof(AUIPFManager, FoliageDataTable) == 0x0002C8, "Member 'AUIPFManager::FoliageDataTable' has a wrong offset!");
static_assert(offsetof(AUIPFManager, MPC_UIPF) == 0x0002D0, "Member 'AUIPFManager::MPC_UIPF' has a wrong offset!");
static_assert(offsetof(AUIPFManager, UIPFActorClass) == 0x0002D8, "Member 'AUIPFManager::UIPFActorClass' has a wrong offset!");
static_assert(offsetof(AUIPFManager, bOverrideTraceChannel) == 0x0002E0, "Member 'AUIPFManager::bOverrideTraceChannel' has a wrong offset!");
static_assert(offsetof(AUIPFManager, FoliageTraceChannel) == 0x0002E1, "Member 'AUIPFManager::FoliageTraceChannel' has a wrong offset!");
static_assert(offsetof(AUIPFManager, AccumulatorInst) == 0x0002E8, "Member 'AUIPFManager::AccumulatorInst' has a wrong offset!");
static_assert(offsetof(AUIPFManager, ManualSplatInst) == 0x0002F0, "Member 'AUIPFManager::ManualSplatInst' has a wrong offset!");
static_assert(offsetof(AUIPFManager, VelocitySplatInst) == 0x0002F8, "Member 'AUIPFManager::VelocitySplatInst' has a wrong offset!");
static_assert(offsetof(AUIPFManager, Canvas) == 0x000300, "Member 'AUIPFManager::Canvas' has a wrong offset!");
static_assert(offsetof(AUIPFManager, Size) == 0x000308, "Member 'AUIPFManager::Size' has a wrong offset!");
static_assert(offsetof(AUIPFManager, Context) == 0x000318, "Member 'AUIPFManager::Context' has a wrong offset!");
static_assert(offsetof(AUIPFManager, CanvasInteract) == 0x000320, "Member 'AUIPFManager::CanvasInteract' has a wrong offset!");
static_assert(offsetof(AUIPFManager, SizeInteract) == 0x000328, "Member 'AUIPFManager::SizeInteract' has a wrong offset!");
static_assert(offsetof(AUIPFManager, ContextInteract) == 0x000338, "Member 'AUIPFManager::ContextInteract' has a wrong offset!");
static_assert(offsetof(AUIPFManager, BoxComp) == 0x000340, "Member 'AUIPFManager::BoxComp' has a wrong offset!");
static_assert(offsetof(AUIPFManager, Rtvel) == 0x000348, "Member 'AUIPFManager::Rtvel' has a wrong offset!");
static_assert(offsetof(AUIPFManager, Rtpos) == 0x000350, "Member 'AUIPFManager::Rtpos' has a wrong offset!");
static_assert(offsetof(AUIPFManager, Rtobj) == 0x000358, "Member 'AUIPFManager::Rtobj' has a wrong offset!");
static_assert(offsetof(AUIPFManager, ForceSplatMat) == 0x000360, "Member 'AUIPFManager::ForceSplatMat' has a wrong offset!");
static_assert(offsetof(AUIPFManager, ManForceSplatMat) == 0x000368, "Member 'AUIPFManager::ManForceSplatMat' has a wrong offset!");
static_assert(offsetof(AUIPFManager, VelSplatMat) == 0x000370, "Member 'AUIPFManager::VelSplatMat' has a wrong offset!");
static_assert(offsetof(AUIPFManager, PersistentAccumulator) == 0x000378, "Member 'AUIPFManager::PersistentAccumulator' has a wrong offset!");

}

