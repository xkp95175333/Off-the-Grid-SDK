#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: VPUtilities

#include "Basic.hpp"

#include "CoreUObject_structs.hpp"
#include "CoreUObject_classes.hpp"
#include "SlateCore_structs.hpp"
#include "VPUtilities_structs.hpp"
#include "UMG_classes.hpp"
#include "Engine_structs.hpp"
#include "Engine_classes.hpp"
#include "TimeManagement_classes.hpp"


namespace SDK
{

// Class VPUtilities.VPContextMenuProvider
// 0x0000 (0x0028 - 0x0028)
class IVPContextMenuProvider final : public IInterface
{
public:
	void OnCreateContextMenu();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VPContextMenuProvider">();
	}
	static class IVPContextMenuProvider* GetDefaultObj()
	{
		return GetDefaultObjImpl<IVPContextMenuProvider>();
	}
};
static_assert(alignof(IVPContextMenuProvider) == 0x000008, "Wrong alignment on IVPContextMenuProvider");
static_assert(sizeof(IVPContextMenuProvider) == 0x000028, "Wrong size on IVPContextMenuProvider");

// Class VPUtilities.VPInteraction
// 0x0000 (0x0028 - 0x0028)
class IVPInteraction final : public IInterface
{
public:
	void OnActorDroppedFromCarry();
	void OnActorDroppedFromTransform();
	void OnActorSelectedForTransform();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VPInteraction">();
	}
	static class IVPInteraction* GetDefaultObj()
	{
		return GetDefaultObjImpl<IVPInteraction>();
	}
};
static_assert(alignof(IVPInteraction) == 0x000008, "Wrong alignment on IVPInteraction");
static_assert(sizeof(IVPInteraction) == 0x000028, "Wrong size on IVPInteraction");

// Class VPUtilities.VPAssetThumbnailWrapperWidget
// 0x00F8 (0x0270 - 0x0178)
class UVPAssetThumbnailWrapperWidget final : public UWidget
{
public:
	uint8                                         Pad_4712[0x8];                                     // 0x0178(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FSlateBrush                            FallbackBrush;                                     // 0x0180(0x00D0)(Edit, BlueprintVisible, NativeAccessSpecifierPrivate)
	uint8                                         Pad_4713[0x20];                                    // 0x0250(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetAsset(const struct FAssetData& AssetData);
	void SetAssetByObject(class UObject* Object);
	void SetDisplayMode(EAssetThumbnailDisplayMode Mode);
	void SetEditorThumbnailResolution(const struct FIntPoint& NewResolution);
	void SetFallbackBrush(const struct FSlateBrush& NewFallbackBrush);

	class UObject* GetEditorAssetWidget() const;
	struct FIntPoint GetEditorThumbnailResolution() const;
	struct FSlateBrush GetFallbackBrush() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VPAssetThumbnailWrapperWidget">();
	}
	static class UVPAssetThumbnailWrapperWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVPAssetThumbnailWrapperWidget>();
	}
};
static_assert(alignof(UVPAssetThumbnailWrapperWidget) == 0x000010, "Wrong alignment on UVPAssetThumbnailWrapperWidget");
static_assert(sizeof(UVPAssetThumbnailWrapperWidget) == 0x000270, "Wrong size on UVPAssetThumbnailWrapperWidget");
static_assert(offsetof(UVPAssetThumbnailWrapperWidget, FallbackBrush) == 0x000180, "Member 'UVPAssetThumbnailWrapperWidget::FallbackBrush' has a wrong offset!");

// Class VPUtilities.VPBlueprintLibrary
// 0x0000 (0x0028 - 0x0028)
class UVPBlueprintLibrary final : public UBlueprintFunctionLibrary
{
public:
	static bool EditorDeleteSelectedObjects();
	static bool EditorDuplicate();
	static bool EditorRedo();
	static bool EditorUndo();
	static struct FTransform GetEditorViewportTransform();
	static struct FTransform GetEditorVRHeadTransform();
	static struct FTransform GetEditorVRRoomTransform();
	static class UWorld* GetEditorWorld();
	static struct FVector GetLeftInteractorLocation();
	static struct FGameplayTagContainer GetVirtualProductionRole();
	static struct FVector GetVREditorLaserHoverLocation();
	static bool IsVREditorModeActive();
	static bool JumpToBookmarkInLevelEditor(const class UVPBookmark* BookMark);
	static void Refresh3DEditorViewport();
	static void SetGrabSpeed(const float Speed);
	static class AActor* SpawnBookmarkAtCurrentLevelEditorPosition(const TSubclassOf<class AActor> ActorClass, const struct FVPBookmarkCreationContext& CreationContext, const struct FVector& Offset, const bool bFlattenRotation);
	static class AVPViewportTickableActorBase* SpawnVPTickableActor(class UObject* ContextObject, const TSubclassOf<class AVPViewportTickableActorBase> ActorClass, const struct FVector& Location, const struct FRotator& Rotation);
	static void VPBookmarkSplineMeshIndicatorDisable(class USplineMeshComponent* SplineMesh);
	static void VPBookmarkSplineMeshIndicatorSetStartAndEnd(class USplineMeshComponent* SplineMesh);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VPBlueprintLibrary">();
	}
	static class UVPBlueprintLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVPBlueprintLibrary>();
	}
};
static_assert(alignof(UVPBlueprintLibrary) == 0x000008, "Wrong alignment on UVPBlueprintLibrary");
static_assert(sizeof(UVPBlueprintLibrary) == 0x000028, "Wrong size on UVPBlueprintLibrary");

// Class VPUtilities.VPViewportTickableActorBase
// 0x0008 (0x02A8 - 0x02A0)
class AVPViewportTickableActorBase : public AActor
{
public:
	EVPViewportTickableFlags                      ViewportTickType;                                  // 0x02A0(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4716[0x7];                                     // 0x02A1(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void EditorDestroyed();
	void EditorLockLocation(bool bSetLockLocation);
	void EditorTick(float DeltaSeconds);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VPViewportTickableActorBase">();
	}
	static class AVPViewportTickableActorBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<AVPViewportTickableActorBase>();
	}
};
static_assert(alignof(AVPViewportTickableActorBase) == 0x000008, "Wrong alignment on AVPViewportTickableActorBase");
static_assert(sizeof(AVPViewportTickableActorBase) == 0x0002A8, "Wrong size on AVPViewportTickableActorBase");
static_assert(offsetof(AVPViewportTickableActorBase, ViewportTickType) == 0x0002A0, "Member 'AVPViewportTickableActorBase::ViewportTickType' has a wrong offset!");

// Class VPUtilities.VPBookmarkActor
// 0x00B0 (0x0358 - 0x02A8)
class AVPBookmarkActor final : public AVPViewportTickableActorBase
{
public:
	uint8                                         Pad_4717[0x10];                                    // 0x02A8(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class UStaticMeshComponent*                   BookmarkMeshComponent;                             // 0x02B8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTextRenderComponent*                   NameTextRenderComponent;                           // 0x02C0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USplineMeshComponent*                   SplineMeshComponent;                               // 0x02C8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCineCameraComponent*                   CameraComponent;                                   // 0x02D0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           BookmarkColor;                                     // 0x02D8(0x0010)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UVPBookmark*                            BookmarkObject;                                    // 0x02E8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsHome;                                            // 0x02F0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4718[0x7];                                     // 0x02F1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UTexture2D*                             SnapshotTexture;                                   // 0x02F8(0x0008)(BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMaterialInstanceDynamic*               DynamicMaterial;                                   // 0x0300(0x0008)(BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMaterialInterface*                     BookmarkMaterial;                                  // 0x0308(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4719[0x18];                                    // 0x0310(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	class UStaticMesh*                            BookmarkStaticMesh;                                // 0x0328(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UMaterial*                              TextMaterial;                                      // 0x0330(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UStaticMesh*                            SplineStaticMesh;                                  // 0x0338(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UMaterialInterface*                     SplineMaterial;                                    // 0x0340(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UMaterialInterface*                     SplineMaterialInstance;                            // 0x0348(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UMaterialInterface*                     LabelMaterialInstance;                             // 0x0350(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void GenerateBookmarkName_Implementation();
	void HideBookmarkSplineMeshIndicator_Implementation();
	void OnActorDroppedFromCarry_Implementation();
	void OnActorDroppedFromTransform_Implementation();
	void OnActorSelectedForTransform_Implementation();
	void OnBookmarkActivation_Implementation(class UVPBookmark* BookMark, bool bActivate);
	void OnBookmarkChanged_Implementation(class UVPBookmark* BookMark);
	void UpdateBookmarkColor(const struct FLinearColor& Color);
	void UpdateBookmarkSplineMeshIndicator_Implementation();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VPBookmarkActor">();
	}
	static class AVPBookmarkActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<AVPBookmarkActor>();
	}
};
static_assert(alignof(AVPBookmarkActor) == 0x000008, "Wrong alignment on AVPBookmarkActor");
static_assert(sizeof(AVPBookmarkActor) == 0x000358, "Wrong size on AVPBookmarkActor");
static_assert(offsetof(AVPBookmarkActor, BookmarkMeshComponent) == 0x0002B8, "Member 'AVPBookmarkActor::BookmarkMeshComponent' has a wrong offset!");
static_assert(offsetof(AVPBookmarkActor, NameTextRenderComponent) == 0x0002C0, "Member 'AVPBookmarkActor::NameTextRenderComponent' has a wrong offset!");
static_assert(offsetof(AVPBookmarkActor, SplineMeshComponent) == 0x0002C8, "Member 'AVPBookmarkActor::SplineMeshComponent' has a wrong offset!");
static_assert(offsetof(AVPBookmarkActor, CameraComponent) == 0x0002D0, "Member 'AVPBookmarkActor::CameraComponent' has a wrong offset!");
static_assert(offsetof(AVPBookmarkActor, BookmarkColor) == 0x0002D8, "Member 'AVPBookmarkActor::BookmarkColor' has a wrong offset!");
static_assert(offsetof(AVPBookmarkActor, BookmarkObject) == 0x0002E8, "Member 'AVPBookmarkActor::BookmarkObject' has a wrong offset!");
static_assert(offsetof(AVPBookmarkActor, IsHome) == 0x0002F0, "Member 'AVPBookmarkActor::IsHome' has a wrong offset!");
static_assert(offsetof(AVPBookmarkActor, SnapshotTexture) == 0x0002F8, "Member 'AVPBookmarkActor::SnapshotTexture' has a wrong offset!");
static_assert(offsetof(AVPBookmarkActor, DynamicMaterial) == 0x000300, "Member 'AVPBookmarkActor::DynamicMaterial' has a wrong offset!");
static_assert(offsetof(AVPBookmarkActor, BookmarkMaterial) == 0x000308, "Member 'AVPBookmarkActor::BookmarkMaterial' has a wrong offset!");
static_assert(offsetof(AVPBookmarkActor, BookmarkStaticMesh) == 0x000328, "Member 'AVPBookmarkActor::BookmarkStaticMesh' has a wrong offset!");
static_assert(offsetof(AVPBookmarkActor, TextMaterial) == 0x000330, "Member 'AVPBookmarkActor::TextMaterial' has a wrong offset!");
static_assert(offsetof(AVPBookmarkActor, SplineStaticMesh) == 0x000338, "Member 'AVPBookmarkActor::SplineStaticMesh' has a wrong offset!");
static_assert(offsetof(AVPBookmarkActor, SplineMaterial) == 0x000340, "Member 'AVPBookmarkActor::SplineMaterial' has a wrong offset!");
static_assert(offsetof(AVPBookmarkActor, SplineMaterialInstance) == 0x000348, "Member 'AVPBookmarkActor::SplineMaterialInstance' has a wrong offset!");
static_assert(offsetof(AVPBookmarkActor, LabelMaterialInstance) == 0x000350, "Member 'AVPBookmarkActor::LabelMaterialInstance' has a wrong offset!");

// Class VPUtilities.VPBookmarkSettings
// 0x00A0 (0x00C8 - 0x0028)
class UVPBookmarkSettings final : public UObject
{
public:
	struct FSoftObjectPath                        BookmarkMeshPath;                                  // 0x0028(0x0020)(Edit, ZeroConstructor, Config, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        BookmarkMaterialPath;                              // 0x0048(0x0020)(Edit, ZeroConstructor, Config, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        BookmarkSplineMeshPath;                            // 0x0068(0x0020)(Edit, ZeroConstructor, Config, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        BookmarkSplineMeshMaterialPath;                    // 0x0088(0x0020)(Edit, ZeroConstructor, Config, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        BookmarkLabelMaterialPath;                         // 0x00A8(0x0020)(Edit, ZeroConstructor, Config, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VPBookmarkSettings">();
	}
	static class UVPBookmarkSettings* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVPBookmarkSettings>();
	}
};
static_assert(alignof(UVPBookmarkSettings) == 0x000008, "Wrong alignment on UVPBookmarkSettings");
static_assert(sizeof(UVPBookmarkSettings) == 0x0000C8, "Wrong size on UVPBookmarkSettings");
static_assert(offsetof(UVPBookmarkSettings, BookmarkMeshPath) == 0x000028, "Member 'UVPBookmarkSettings::BookmarkMeshPath' has a wrong offset!");
static_assert(offsetof(UVPBookmarkSettings, BookmarkMaterialPath) == 0x000048, "Member 'UVPBookmarkSettings::BookmarkMaterialPath' has a wrong offset!");
static_assert(offsetof(UVPBookmarkSettings, BookmarkSplineMeshPath) == 0x000068, "Member 'UVPBookmarkSettings::BookmarkSplineMeshPath' has a wrong offset!");
static_assert(offsetof(UVPBookmarkSettings, BookmarkSplineMeshMaterialPath) == 0x000088, "Member 'UVPBookmarkSettings::BookmarkSplineMeshMaterialPath' has a wrong offset!");
static_assert(offsetof(UVPBookmarkSettings, BookmarkLabelMaterialPath) == 0x0000A8, "Member 'UVPBookmarkSettings::BookmarkLabelMaterialPath' has a wrong offset!");

// Class VPUtilities.VPCameraBlueprintLibrary
// 0x0000 (0x0028 - 0x0028)
class UVPCameraBlueprintLibrary final : public UBlueprintFunctionLibrary
{
public:
	static class ACameraRig_Rail* SpawnCameraRigFromActors(class UObject* WorldContextObject, const struct FTransform& RigTransform, const TArray<class AActor*>& Actors, const struct FVPCameraRigSpawnParams& Params_0);
	static class ACameraRig_Rail* SpawnCameraRigFromPoints(class UObject* WorldContextObject, const struct FTransform& RigTransform, const TArray<struct FVector>& Points, const struct FVPCameraRigSpawnParams& Params_0);
	static class ACameraRig_Rail* SpawnCameraRigFromSelectedActors(class UObject* WorldContextObject, const struct FTransform& RigTransform, const struct FVPCameraRigSpawnParams& Params_0);
	static class ACameraRig_Rail* SpawnDollyTrackFromPoints(class UObject* WorldContextObject, const TArray<struct FTransform>& Points, ESplinePointType InterpType);
	static class ACameraRig_Rail* SpawnDollyTrackFromPointsSmooth(class UObject* WorldContextObject, const TArray<struct FTransform>& Points, ESplinePointType InterpType);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VPCameraBlueprintLibrary">();
	}
	static class UVPCameraBlueprintLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVPCameraBlueprintLibrary>();
	}
};
static_assert(alignof(UVPCameraBlueprintLibrary) == 0x000008, "Wrong alignment on UVPCameraBlueprintLibrary");
static_assert(sizeof(UVPCameraBlueprintLibrary) == 0x000028, "Wrong size on UVPCameraBlueprintLibrary");

// Class VPUtilities.VPFullScreenUserWidget
// 0x01A8 (0x01D0 - 0x0028)
class UVPFullScreenUserWidget final : public UObject
{
public:
	TSubclassOf<class UUserWidget>                WidgetClass;                                       // 0x0028(0x0008)(Edit, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EVPWidgetDisplayType                          EditorDisplayType;                                 // 0x0030(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EVPWidgetDisplayType                          GameDisplayType;                                   // 0x0031(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EVPWidgetDisplayType                          PIEDisplayType;                                    // 0x0032(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_4720[0x5];                                     // 0x0033(0x0005)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVPFullScreenUserWidget_Viewport       ViewportDisplayType;                               // 0x0038(0x0010)(Edit, Protected, NativeAccessSpecifierProtected)
	struct FVPFullScreenUserWidget_PostProcess    PostProcessDisplayTypeWithBlendMaterial;           // 0x0048(0x00C0)(Edit, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	struct FVPFullScreenUserWidget_PostProcessWithSVE PostProcessWithSceneViewExtensions;                // 0x0108(0x00B0)(Edit, Protected, NativeAccessSpecifierProtected)
	class UUserWidget*                            Widget;                                            // 0x01B8(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, DuplicateTransient, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TWeakObjectPtr<class UWorld>                  World;                                             // 0x01C0(0x0008)(ZeroConstructor, Transient, DuplicateTransient, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	EVPWidgetDisplayType                          CurrentDisplayType;                                // 0x01C8(0x0001)(ZeroConstructor, Transient, DuplicateTransient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_4721[0x7];                                     // 0x01C9(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VPFullScreenUserWidget">();
	}
	static class UVPFullScreenUserWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVPFullScreenUserWidget>();
	}
};
static_assert(alignof(UVPFullScreenUserWidget) == 0x000008, "Wrong alignment on UVPFullScreenUserWidget");
static_assert(sizeof(UVPFullScreenUserWidget) == 0x0001D0, "Wrong size on UVPFullScreenUserWidget");
static_assert(offsetof(UVPFullScreenUserWidget, WidgetClass) == 0x000028, "Member 'UVPFullScreenUserWidget::WidgetClass' has a wrong offset!");
static_assert(offsetof(UVPFullScreenUserWidget, EditorDisplayType) == 0x000030, "Member 'UVPFullScreenUserWidget::EditorDisplayType' has a wrong offset!");
static_assert(offsetof(UVPFullScreenUserWidget, GameDisplayType) == 0x000031, "Member 'UVPFullScreenUserWidget::GameDisplayType' has a wrong offset!");
static_assert(offsetof(UVPFullScreenUserWidget, PIEDisplayType) == 0x000032, "Member 'UVPFullScreenUserWidget::PIEDisplayType' has a wrong offset!");
static_assert(offsetof(UVPFullScreenUserWidget, ViewportDisplayType) == 0x000038, "Member 'UVPFullScreenUserWidget::ViewportDisplayType' has a wrong offset!");
static_assert(offsetof(UVPFullScreenUserWidget, PostProcessDisplayTypeWithBlendMaterial) == 0x000048, "Member 'UVPFullScreenUserWidget::PostProcessDisplayTypeWithBlendMaterial' has a wrong offset!");
static_assert(offsetof(UVPFullScreenUserWidget, PostProcessWithSceneViewExtensions) == 0x000108, "Member 'UVPFullScreenUserWidget::PostProcessWithSceneViewExtensions' has a wrong offset!");
static_assert(offsetof(UVPFullScreenUserWidget, Widget) == 0x0001B8, "Member 'UVPFullScreenUserWidget::Widget' has a wrong offset!");
static_assert(offsetof(UVPFullScreenUserWidget, World) == 0x0001C0, "Member 'UVPFullScreenUserWidget::World' has a wrong offset!");
static_assert(offsetof(UVPFullScreenUserWidget, CurrentDisplayType) == 0x0001C8, "Member 'UVPFullScreenUserWidget::CurrentDisplayType' has a wrong offset!");

// Class VPUtilities.FullScreenUserWidgetActor
// 0x0008 (0x02A8 - 0x02A0)
class AFullScreenUserWidgetActor final : public AInfo
{
public:
	class UVPFullScreenUserWidget*                ScreenUserWidget;                                  // 0x02A0(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, NoClear, NoDestructor, Protected, PersistentInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	class UUserWidget* GetUserWidget() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FullScreenUserWidgetActor">();
	}
	static class AFullScreenUserWidgetActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<AFullScreenUserWidgetActor>();
	}
};
static_assert(alignof(AFullScreenUserWidgetActor) == 0x000008, "Wrong alignment on AFullScreenUserWidgetActor");
static_assert(sizeof(AFullScreenUserWidgetActor) == 0x0002A8, "Wrong size on AFullScreenUserWidgetActor");
static_assert(offsetof(AFullScreenUserWidgetActor, ScreenUserWidget) == 0x0002A0, "Member 'AFullScreenUserWidgetActor::ScreenUserWidget' has a wrong offset!");

// Class VPUtilities.VPGameMode
// 0x0008 (0x0388 - 0x0380)
class AVPGameMode final : public AGameMode
{
public:
	class AVPRootActor*                           RootActor;                                         // 0x0380(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	class AVPRootActor* GetRootActor() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VPGameMode">();
	}
	static class AVPGameMode* GetDefaultObj()
	{
		return GetDefaultObjImpl<AVPGameMode>();
	}
};
static_assert(alignof(AVPGameMode) == 0x000008, "Wrong alignment on AVPGameMode");
static_assert(sizeof(AVPGameMode) == 0x000388, "Wrong size on AVPGameMode");
static_assert(offsetof(AVPGameMode, RootActor) == 0x000380, "Member 'AVPGameMode::RootActor' has a wrong offset!");

// Class VPUtilities.VPPassthroughPostProcessVolume
// 0x0000 (0x0A10 - 0x0A10)
class AVPPassthroughPostProcessVolume final : public APostProcessVolume
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VPPassthroughPostProcessVolume">();
	}
	static class AVPPassthroughPostProcessVolume* GetDefaultObj()
	{
		return GetDefaultObjImpl<AVPPassthroughPostProcessVolume>();
	}
};
static_assert(alignof(AVPPassthroughPostProcessVolume) == 0x000010, "Wrong alignment on AVPPassthroughPostProcessVolume");
static_assert(sizeof(AVPPassthroughPostProcessVolume) == 0x000A10, "Wrong size on AVPPassthroughPostProcessVolume");

// Class VPUtilities.VPRenderingBlueprintLibrary
// 0x0000 (0x0028 - 0x0028)
class UVPRenderingBlueprintLibrary final : public UBlueprintFunctionLibrary
{
public:
	static void GenerateSceneViewExtensionIsActiveFunctorForViewportType(struct FSceneViewExtensionIsActiveFunctor* OutIsActiveFunction, bool bPIE, bool bSIE, bool bEditorActive, bool bGamePrimary);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VPRenderingBlueprintLibrary">();
	}
	static class UVPRenderingBlueprintLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVPRenderingBlueprintLibrary>();
	}
};
static_assert(alignof(UVPRenderingBlueprintLibrary) == 0x000008, "Wrong alignment on UVPRenderingBlueprintLibrary");
static_assert(sizeof(UVPRenderingBlueprintLibrary) == 0x000028, "Wrong size on UVPRenderingBlueprintLibrary");

// Class VPUtilities.VPRootActor
// 0x0018 (0x02B8 - 0x02A0)
class AVPRootActor final : public AActor
{
public:
	class UMeshComponent*                         RealWorldSceneRepresentation;                      // 0x02A0(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ACineCameraActor*                       CinematicCamera;                                   // 0x02A8(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAreComponentsVisible;                             // 0x02B0(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_4723[0x7];                                     // 0x02B1(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	class ACineCameraActor* GetCineCameraActor() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VPRootActor">();
	}
	static class AVPRootActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<AVPRootActor>();
	}
};
static_assert(alignof(AVPRootActor) == 0x000008, "Wrong alignment on AVPRootActor");
static_assert(sizeof(AVPRootActor) == 0x0002B8, "Wrong size on AVPRootActor");
static_assert(offsetof(AVPRootActor, RealWorldSceneRepresentation) == 0x0002A0, "Member 'AVPRootActor::RealWorldSceneRepresentation' has a wrong offset!");
static_assert(offsetof(AVPRootActor, CinematicCamera) == 0x0002A8, "Member 'AVPRootActor::CinematicCamera' has a wrong offset!");
static_assert(offsetof(AVPRootActor, bAreComponentsVisible) == 0x0002B0, "Member 'AVPRootActor::bAreComponentsVisible' has a wrong offset!");

// Class VPUtilities.VPWorldAssetUserData
// 0x0018 (0x0040 - 0x0028)
class UVPWorldAssetUserData final : public UAssetUserData
{
public:
	TLazyObjectPtr<class AVPRootActor>            LastSelectedRootActor;                             // 0x0028(0x0018)(Edit, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VPWorldAssetUserData">();
	}
	static class UVPWorldAssetUserData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVPWorldAssetUserData>();
	}
};
static_assert(alignof(UVPWorldAssetUserData) == 0x000008, "Wrong alignment on UVPWorldAssetUserData");
static_assert(sizeof(UVPWorldAssetUserData) == 0x000040, "Wrong size on UVPWorldAssetUserData");
static_assert(offsetof(UVPWorldAssetUserData, LastSelectedRootActor) == 0x000028, "Member 'UVPWorldAssetUserData::LastSelectedRootActor' has a wrong offset!");

// Class VPUtilities.VPTimecodeCustomTimeStep
// 0x0038 (0x0060 - 0x0028)
class UVPTimecodeCustomTimeStep final : public UFixedFrameRateCustomTimeStep
{
public:
	bool                                          bErrorIfFrameAreNotConsecutive;                    // 0x0028(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bErrorIfTimecodeProviderChanged;                   // 0x0029(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4724[0x2];                                     // 0x002A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MaxDeltaTime;                                      // 0x002C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4725[0x30];                                    // 0x0030(0x0030)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VPTimecodeCustomTimeStep">();
	}
	static class UVPTimecodeCustomTimeStep* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVPTimecodeCustomTimeStep>();
	}
};
static_assert(alignof(UVPTimecodeCustomTimeStep) == 0x000008, "Wrong alignment on UVPTimecodeCustomTimeStep");
static_assert(sizeof(UVPTimecodeCustomTimeStep) == 0x000060, "Wrong size on UVPTimecodeCustomTimeStep");
static_assert(offsetof(UVPTimecodeCustomTimeStep, bErrorIfFrameAreNotConsecutive) == 0x000028, "Member 'UVPTimecodeCustomTimeStep::bErrorIfFrameAreNotConsecutive' has a wrong offset!");
static_assert(offsetof(UVPTimecodeCustomTimeStep, bErrorIfTimecodeProviderChanged) == 0x000029, "Member 'UVPTimecodeCustomTimeStep::bErrorIfTimecodeProviderChanged' has a wrong offset!");
static_assert(offsetof(UVPTimecodeCustomTimeStep, MaxDeltaTime) == 0x00002C, "Member 'UVPTimecodeCustomTimeStep::MaxDeltaTime' has a wrong offset!");

}

