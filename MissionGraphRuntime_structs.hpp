#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: MissionGraphRuntime

#include "Basic.hpp"

#include "GameplayTags_structs.hpp"
#include "CoreUObject_structs.hpp"


namespace SDK
{

// Enum MissionGraphRuntime.EMissionObjectiveState
// NumValues: 0x0007
enum class EMissionObjectiveState : uint8
{
	Inactive                                 = 0,
	Blocked                                  = 1,
	Activated                                = 2,
	Completed                                = 3,
	Failed                                   = 4,
	Obsolete                                 = 5,
	EMissionObjectiveState_MAX               = 6,
};

// Enum MissionGraphRuntime.EMissionConditionCompositionType
// NumValues: 0x0003
enum class EMissionConditionCompositionType : uint8
{
	And                                      = 0,
	Or                                       = 1,
	EMissionConditionCompositionType_MAX     = 2,
};

// Enum MissionGraphRuntime.EGzMissionResourceType
// NumValues: 0x0005
enum class EGzMissionResourceType : uint8
{
	None                                     = 0,
	Class                                    = 1,
	Tag                                      = 2,
	SoftRef                                  = 3,
	EGzMissionResourceType_MAX               = 4,
};

// Enum MissionGraphRuntime.EMissionObjectiveScope
// NumValues: 0x0003
enum class EMissionObjectiveScope : uint8
{
	Default                                  = 0,
	Shared                                   = 1,
	EMissionObjectiveScope_MAX               = 2,
};

// Enum MissionGraphRuntime.EMissionCompositionType
// NumValues: 0x0003
enum class EMissionCompositionType : uint8
{
	And                                      = 0,
	Or                                       = 1,
	EMissionCompositionType_MAX              = 2,
};

// Enum MissionGraphRuntime.EConditionEvaluationType
// NumValues: 0x0003
enum class EConditionEvaluationType : uint8
{
	While                                    = 0,
	Until                                    = 1,
	EConditionEvaluationType_MAX             = 2,
};

// Enum MissionGraphRuntime.EMissionActionState
// NumValues: 0x0004
enum class EMissionActionState : uint8
{
	Inactive                                 = 0,
	Active                                   = 1,
	Completed                                = 2,
	EMissionActionState_MAX                  = 3,
};

// Enum MissionGraphRuntime.EMissionActionTime
// NumValues: 0x0004
enum class EMissionActionTime : uint8
{
	OnActivation                             = 0,
	OnSuccess                                = 1,
	OnFailure                                = 2,
	EMissionActionTime_MAX                   = 3,
};

// Enum MissionGraphRuntime.EMissionActionScope
// NumValues: 0x0003
enum class EMissionActionScope : uint8
{
	Default                                  = 0,
	Global                                   = 1,
	EMissionActionScope_MAX                  = 2,
};

// Enum MissionGraphRuntime.EMissionExtensionType
// NumValues: 0x0004
enum class EMissionExtensionType : uint8
{
	Client                                   = 0,
	Server                                   = 1,
	All                                      = 2,
	EMissionExtensionType_MAX                = 3,
};

// Enum MissionGraphRuntime.EObjectiveTimerType
// NumValues: 0x0004
enum class EObjectiveTimerType : uint8
{
	FirstActivation                          = 0,
	Activation                               = 1,
	Initialization                           = 2,
	EObjectiveTimerType_MAX                  = 3,
};

// Enum MissionGraphRuntime.EMissionBypassRules
// NumValues: 0x0006
enum class EMissionBypassRules : uint8
{
	None                                     = 0,
	AllowFail                                = 1,
	AllowComplete                            = 2,
	AllowProgress                            = 4,
	All                                      = 7,
	EMissionBypassRules_MAX                  = 8,
};

// Enum MissionGraphRuntime.EMissionTimeCalculationMethod
// NumValues: 0x0004
enum class EMissionTimeCalculationMethod : uint8
{
	AllExceptBonus                           = 0,
	All                                      = 1,
	Manual                                   = 2,
	EMissionTimeCalculationMethod_MAX        = 3,
};

// ScriptStruct MissionGraphRuntime.NamedCondition
// 0x0018 (0x0018 - 0x0000)
struct FNamedCondition final
{
public:
	class FText                                   DisplayName;                                       // 0x0000(0x0010)(NativeAccessSpecifierPublic)
	class FName                                   TaskName;                                          // 0x0010(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FNamedCondition) == 0x000008, "Wrong alignment on FNamedCondition");
static_assert(sizeof(FNamedCondition) == 0x000018, "Wrong size on FNamedCondition");
static_assert(offsetof(FNamedCondition, DisplayName) == 0x000000, "Member 'FNamedCondition::DisplayName' has a wrong offset!");
static_assert(offsetof(FNamedCondition, TaskName) == 0x000010, "Member 'FNamedCondition::TaskName' has a wrong offset!");

// ScriptStruct MissionGraphRuntime.MissionResourceRef
// 0x0028 (0x0028 - 0x0000)
struct FMissionResourceRef final
{
public:
	EGzMissionResourceType                        Type;                                              // 0x0000(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bAllowLateResolution;                              // 0x0001(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_27ED[0x6];                                     // 0x0002(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class AActor>                     ActorClass;                                        // 0x0008(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FGameplayTag                           ResourceTag;                                       // 0x0010(0x0008)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<TSoftObjectPtr<class AActor>>          SoftReference;                                     // 0x0018(0x0010)(Edit, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPrivate)
};
static_assert(alignof(FMissionResourceRef) == 0x000008, "Wrong alignment on FMissionResourceRef");
static_assert(sizeof(FMissionResourceRef) == 0x000028, "Wrong size on FMissionResourceRef");
static_assert(offsetof(FMissionResourceRef, Type) == 0x000000, "Member 'FMissionResourceRef::Type' has a wrong offset!");
static_assert(offsetof(FMissionResourceRef, bAllowLateResolution) == 0x000001, "Member 'FMissionResourceRef::bAllowLateResolution' has a wrong offset!");
static_assert(offsetof(FMissionResourceRef, ActorClass) == 0x000008, "Member 'FMissionResourceRef::ActorClass' has a wrong offset!");
static_assert(offsetof(FMissionResourceRef, ResourceTag) == 0x000010, "Member 'FMissionResourceRef::ResourceTag' has a wrong offset!");
static_assert(offsetof(FMissionResourceRef, SoftReference) == 0x000018, "Member 'FMissionResourceRef::SoftReference' has a wrong offset!");

// ScriptStruct MissionGraphRuntime.GzResourceCollection
// 0x0050 (0x0050 - 0x0000)
struct FGzResourceCollection final
{
public:
	TSet<class UMissionResourceComponent*>        Resources;                                         // 0x0000(0x0050)(ExportObject, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzResourceCollection) == 0x000008, "Wrong alignment on FGzResourceCollection");
static_assert(sizeof(FGzResourceCollection) == 0x000050, "Wrong size on FGzResourceCollection");
static_assert(offsetof(FGzResourceCollection, Resources) == 0x000000, "Member 'FGzResourceCollection::Resources' has a wrong offset!");

// ScriptStruct MissionGraphRuntime.MissionRadialFilter
// 0x0020 (0x0020 - 0x0000)
struct FMissionRadialFilter final
{
public:
	bool                                          bFilterRadially;                                   // 0x0000(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_27EE[0x7];                                     // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector2D                              RadialFilterOrigin;                                // 0x0008(0x0010)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RadialFilterRadius;                                // 0x0018(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_27EF[0x4];                                     // 0x001C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FMissionRadialFilter) == 0x000008, "Wrong alignment on FMissionRadialFilter");
static_assert(sizeof(FMissionRadialFilter) == 0x000020, "Wrong size on FMissionRadialFilter");
static_assert(offsetof(FMissionRadialFilter, bFilterRadially) == 0x000000, "Member 'FMissionRadialFilter::bFilterRadially' has a wrong offset!");
static_assert(offsetof(FMissionRadialFilter, RadialFilterOrigin) == 0x000008, "Member 'FMissionRadialFilter::RadialFilterOrigin' has a wrong offset!");
static_assert(offsetof(FMissionRadialFilter, RadialFilterRadius) == 0x000018, "Member 'FMissionRadialFilter::RadialFilterRadius' has a wrong offset!");

// ScriptStruct MissionGraphRuntime.GzMissionObjectiveStateContainer
// 0x0018 (0x0018 - 0x0000)
struct FGzMissionObjectiveStateContainer final
{
public:
	EMissionObjectiveState                        State;                                             // 0x0000(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_27F0[0x7];                                     // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UMissionObjective*>              Objectives;                                        // 0x0008(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGzMissionObjectiveStateContainer) == 0x000008, "Wrong alignment on FGzMissionObjectiveStateContainer");
static_assert(sizeof(FGzMissionObjectiveStateContainer) == 0x000018, "Wrong size on FGzMissionObjectiveStateContainer");
static_assert(offsetof(FGzMissionObjectiveStateContainer, State) == 0x000000, "Member 'FGzMissionObjectiveStateContainer::State' has a wrong offset!");
static_assert(offsetof(FGzMissionObjectiveStateContainer, Objectives) == 0x000008, "Member 'FGzMissionObjectiveStateContainer::Objectives' has a wrong offset!");

}

