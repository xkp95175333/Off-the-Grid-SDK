#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: MissionGraphRuntime

#include "Basic.hpp"

#include "CoreUObject_classes.hpp"
#include "MissionGraphRuntime_structs.hpp"
#include "GameplayTags_structs.hpp"
#include "Engine_structs.hpp"
#include "Engine_classes.hpp"


namespace SDK
{

// Class MissionGraphRuntime.MissionObject
// 0x0010 (0x0038 - 0x0028)
class UMissionObject : public UObject
{
public:
	class FString                                 DisplayName;                                       // 0x0028(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void CollectResourceRefsBP(TArray<struct FMissionResourceRef>* OutReferences) const;
	class AMission* GetMissionChecked() const;
	bool HasAuthority() const;
	bool HasParticipant(const int32 PlayerId) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MissionObject">();
	}
	static class UMissionObject* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMissionObject>();
	}
};
static_assert(alignof(UMissionObject) == 0x000008, "Wrong alignment on UMissionObject");
static_assert(sizeof(UMissionObject) == 0x000038, "Wrong size on UMissionObject");
static_assert(offsetof(UMissionObject, DisplayName) == 0x000028, "Member 'UMissionObject::DisplayName' has a wrong offset!");

// Class MissionGraphRuntime.MissionObjective
// 0x0168 (0x01A0 - 0x0038)
class UMissionObjective : public UMissionObject
{
public:
	uint8                                         Pad_27F2[0x20];                                    // 0x0038(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	FMulticastInlineDelegateProperty_             OnObjectiveStateChanged_Delegate;                  // 0x0058(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnObjectiveStateTagChanged_Delegate;               // 0x0068(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	class FText                                   HudText;                                           // 0x0078(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	class FText                                   BlockedHudText;                                    // 0x0088(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	TSoftObjectPtr<class UTexture2D>              ObjectiveIcon;                                     // 0x0098(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FText                                   RewardsShortText;                                  // 0x00C0(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	TSoftObjectPtr<class UTexture2D>              RewardIcon;                                        // 0x00D0(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bShowWhenInactive;                                 // 0x00F8(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bShowWhenFailed;                                   // 0x00F9(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_27F3[0x2];                                     // 0x00FA(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTag                           StateTag;                                          // 0x00FC(0x0008)(BlueprintVisible, BlueprintReadOnly, Net, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FGameplayTag                           DefaultFailTag;                                    // 0x0104(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EMissionObjectiveScope                        ObjectiveScope;                                    // 0x010C(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_27F4[0x3];                                     // 0x010D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UMissionExtension*>              Extensions;                                        // 0x0110(0x0010)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	bool                                          bIsTimed;                                          // 0x0120(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_27F5[0x3];                                     // 0x0121(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         TimerDuration;                                     // 0x0124(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	double                                        ExpiryTime;                                        // 0x0128(0x0008)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EObjectiveTimerType                           TimerType;                                         // 0x0130(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EMissionObjectiveState                        TimerExpiryState;                                  // 0x0131(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsBonus;                                          // 0x0132(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	EConditionEvaluationType                      ConditionEvaluationType;                           // 0x0133(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         InactiveBypassRules;                               // 0x0134(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         BlockedBypassRules;                                // 0x0135(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	EMissionObjectiveState                        State;                                             // 0x0136(0x0001)(Net, ZeroConstructor, Transient, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_27F6[0x1];                                     // 0x0137(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	class UMissionCondition*                      Condition;                                         // 0x0138(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TMap<EMissionActionTime, class UMissionAction*> Actions;                                           // 0x0140(0x0050)(NativeAccessSpecifierPrivate)
	uint8                                         Pad_27F7[0x8];                                     // 0x0190(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTimerHandle                           ExpiryTimer;                                       // 0x0198(0x0008)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void ExtendTimer(float Duration);
	TArray<class UMissionAction*> GetActions();
	class FText GetBlockedHudText();
	class FText GetHudText();
	TSoftObjectPtr<class UTexture2D> GetRewardsIcon();
	class FText GetRewardsShortText();
	void OnRep_State(EMissionObjectiveState PrevState);
	void RefreshExtensions();
	void TrySetState(bool bSuccessful, const struct FGameplayTag& ResultTag);

	EConditionEvaluationType GetConditionEvaluationType() const;
	bool GetConditionState() const;
	EMissionObjectiveScope GetObjectiveScope() const;
	EMissionObjectiveState GetState() const;
	const struct FGameplayTag GetStateTag() const;
	float GetTimeDuration() const;
	bool IsBonusObjective() const;
	bool IsTimed() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MissionObjective">();
	}
	static class UMissionObjective* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMissionObjective>();
	}
};
static_assert(alignof(UMissionObjective) == 0x000008, "Wrong alignment on UMissionObjective");
static_assert(sizeof(UMissionObjective) == 0x0001A0, "Wrong size on UMissionObjective");
static_assert(offsetof(UMissionObjective, OnObjectiveStateChanged_Delegate) == 0x000058, "Member 'UMissionObjective::OnObjectiveStateChanged_Delegate' has a wrong offset!");
static_assert(offsetof(UMissionObjective, OnObjectiveStateTagChanged_Delegate) == 0x000068, "Member 'UMissionObjective::OnObjectiveStateTagChanged_Delegate' has a wrong offset!");
static_assert(offsetof(UMissionObjective, HudText) == 0x000078, "Member 'UMissionObjective::HudText' has a wrong offset!");
static_assert(offsetof(UMissionObjective, BlockedHudText) == 0x000088, "Member 'UMissionObjective::BlockedHudText' has a wrong offset!");
static_assert(offsetof(UMissionObjective, ObjectiveIcon) == 0x000098, "Member 'UMissionObjective::ObjectiveIcon' has a wrong offset!");
static_assert(offsetof(UMissionObjective, RewardsShortText) == 0x0000C0, "Member 'UMissionObjective::RewardsShortText' has a wrong offset!");
static_assert(offsetof(UMissionObjective, RewardIcon) == 0x0000D0, "Member 'UMissionObjective::RewardIcon' has a wrong offset!");
static_assert(offsetof(UMissionObjective, bShowWhenInactive) == 0x0000F8, "Member 'UMissionObjective::bShowWhenInactive' has a wrong offset!");
static_assert(offsetof(UMissionObjective, bShowWhenFailed) == 0x0000F9, "Member 'UMissionObjective::bShowWhenFailed' has a wrong offset!");
static_assert(offsetof(UMissionObjective, StateTag) == 0x0000FC, "Member 'UMissionObjective::StateTag' has a wrong offset!");
static_assert(offsetof(UMissionObjective, DefaultFailTag) == 0x000104, "Member 'UMissionObjective::DefaultFailTag' has a wrong offset!");
static_assert(offsetof(UMissionObjective, ObjectiveScope) == 0x00010C, "Member 'UMissionObjective::ObjectiveScope' has a wrong offset!");
static_assert(offsetof(UMissionObjective, Extensions) == 0x000110, "Member 'UMissionObjective::Extensions' has a wrong offset!");
static_assert(offsetof(UMissionObjective, bIsTimed) == 0x000120, "Member 'UMissionObjective::bIsTimed' has a wrong offset!");
static_assert(offsetof(UMissionObjective, TimerDuration) == 0x000124, "Member 'UMissionObjective::TimerDuration' has a wrong offset!");
static_assert(offsetof(UMissionObjective, ExpiryTime) == 0x000128, "Member 'UMissionObjective::ExpiryTime' has a wrong offset!");
static_assert(offsetof(UMissionObjective, TimerType) == 0x000130, "Member 'UMissionObjective::TimerType' has a wrong offset!");
static_assert(offsetof(UMissionObjective, TimerExpiryState) == 0x000131, "Member 'UMissionObjective::TimerExpiryState' has a wrong offset!");
static_assert(offsetof(UMissionObjective, bIsBonus) == 0x000132, "Member 'UMissionObjective::bIsBonus' has a wrong offset!");
static_assert(offsetof(UMissionObjective, ConditionEvaluationType) == 0x000133, "Member 'UMissionObjective::ConditionEvaluationType' has a wrong offset!");
static_assert(offsetof(UMissionObjective, InactiveBypassRules) == 0x000134, "Member 'UMissionObjective::InactiveBypassRules' has a wrong offset!");
static_assert(offsetof(UMissionObjective, BlockedBypassRules) == 0x000135, "Member 'UMissionObjective::BlockedBypassRules' has a wrong offset!");
static_assert(offsetof(UMissionObjective, State) == 0x000136, "Member 'UMissionObjective::State' has a wrong offset!");
static_assert(offsetof(UMissionObjective, Condition) == 0x000138, "Member 'UMissionObjective::Condition' has a wrong offset!");
static_assert(offsetof(UMissionObjective, Actions) == 0x000140, "Member 'UMissionObjective::Actions' has a wrong offset!");
static_assert(offsetof(UMissionObjective, ExpiryTimer) == 0x000198, "Member 'UMissionObjective::ExpiryTimer' has a wrong offset!");

// Class MissionGraphRuntime.GameplayObjective
// 0x0048 (0x01E8 - 0x01A0)
class UGameplayObjective : public UMissionObjective
{
public:
	bool                                          bUseProgress;                                      // 0x01A0(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_27F9[0x3];                                     // 0x01A1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MinProgress;                                       // 0x01A4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MaxProgress;                                       // 0x01A8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         CurrentProgress;                                   // 0x01AC(0x0004)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, Transient, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         RewardTier;                                        // 0x01B0(0x0004)(Edit, BlueprintVisible, Net, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_27FA[0x4];                                     // 0x01B4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	FMulticastInlineDelegateProperty_             OnObjectiveProgressChanged;                        // 0x01B8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnObjectiveMaxProgressChanged;                     // 0x01C8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnRewardTierChanged;                               // 0x01D8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)

public:
	void AddProgress(float ProgressAmount);
	void OnActivate();
	void OnDeactivate();
	void OnInit();
	void OnRep_MaxProgress();
	void OnRep_Progress();
	void OnRep_RewardTier();
	void SetMaxProgress(float NewMaxProgress);
	void SetProgress(float ProgressAmount);
	void SetRewardTier(int32 NewRewardTier);

	int32 GetRewardTier() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GameplayObjective">();
	}
	static class UGameplayObjective* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGameplayObjective>();
	}
};
static_assert(alignof(UGameplayObjective) == 0x000008, "Wrong alignment on UGameplayObjective");
static_assert(sizeof(UGameplayObjective) == 0x0001E8, "Wrong size on UGameplayObjective");
static_assert(offsetof(UGameplayObjective, bUseProgress) == 0x0001A0, "Member 'UGameplayObjective::bUseProgress' has a wrong offset!");
static_assert(offsetof(UGameplayObjective, MinProgress) == 0x0001A4, "Member 'UGameplayObjective::MinProgress' has a wrong offset!");
static_assert(offsetof(UGameplayObjective, MaxProgress) == 0x0001A8, "Member 'UGameplayObjective::MaxProgress' has a wrong offset!");
static_assert(offsetof(UGameplayObjective, CurrentProgress) == 0x0001AC, "Member 'UGameplayObjective::CurrentProgress' has a wrong offset!");
static_assert(offsetof(UGameplayObjective, RewardTier) == 0x0001B0, "Member 'UGameplayObjective::RewardTier' has a wrong offset!");
static_assert(offsetof(UGameplayObjective, OnObjectiveProgressChanged) == 0x0001B8, "Member 'UGameplayObjective::OnObjectiveProgressChanged' has a wrong offset!");
static_assert(offsetof(UGameplayObjective, OnObjectiveMaxProgressChanged) == 0x0001C8, "Member 'UGameplayObjective::OnObjectiveMaxProgressChanged' has a wrong offset!");
static_assert(offsetof(UGameplayObjective, OnRewardTierChanged) == 0x0001D8, "Member 'UGameplayObjective::OnRewardTierChanged' has a wrong offset!");

// Class MissionGraphRuntime.Mission
// 0x0038 (0x02D8 - 0x02A0)
class AMission : public AActor
{
public:
	EMissionTimeCalculationMethod                 TimeCalculationMethod;                             // 0x02A0(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_27FB[0x3];                                     // 0x02A1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ManualTime;                                        // 0x02A4(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UMissionObjective*                      RootObjective;                                     // 0x02A8(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<class UMissionObject*>                 MissionObjects;                                    // 0x02B0(0x0010)(ExportObject, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	TArray<class APlayerState*>                   Participants;                                      // 0x02C0(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	class UMissionRuntimeContext*                 RuntimeContext;                                    // 0x02D0(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	class UMissionAction* GetActionWithName(class FName ObjectiveName, class FName ActionName);
	class UMissionObjective* GetObjectiveWithName(class FName ObjectiveName);
	void InitializeProperties();
	void StartMission();

	void CollectResourceRefsBP(TArray<struct FMissionResourceRef>* OutReferences) const;
	float GetMissionDuration() const;
	const TArray<class APlayerState*> GetParticipants() const;
	class UMissionObjective* GetRootObjective() const;
	class UMissionRuntimeContext* GetRuntimeContext() const;
	bool HasParticipant(int32 PlayerId) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Mission">();
	}
	static class AMission* GetDefaultObj()
	{
		return GetDefaultObjImpl<AMission>();
	}
};
static_assert(alignof(AMission) == 0x000008, "Wrong alignment on AMission");
static_assert(sizeof(AMission) == 0x0002D8, "Wrong size on AMission");
static_assert(offsetof(AMission, TimeCalculationMethod) == 0x0002A0, "Member 'AMission::TimeCalculationMethod' has a wrong offset!");
static_assert(offsetof(AMission, ManualTime) == 0x0002A4, "Member 'AMission::ManualTime' has a wrong offset!");
static_assert(offsetof(AMission, RootObjective) == 0x0002A8, "Member 'AMission::RootObjective' has a wrong offset!");
static_assert(offsetof(AMission, MissionObjects) == 0x0002B0, "Member 'AMission::MissionObjects' has a wrong offset!");
static_assert(offsetof(AMission, Participants) == 0x0002C0, "Member 'AMission::Participants' has a wrong offset!");
static_assert(offsetof(AMission, RuntimeContext) == 0x0002D0, "Member 'AMission::RuntimeContext' has a wrong offset!");

// Class MissionGraphRuntime.MissionAction
// 0x0018 (0x0050 - 0x0038)
class UMissionAction : public UMissionObject
{
public:
	class UMissionAction*                         Next;                                              // 0x0038(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_27FD[0x1];                                     // 0x0040(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	EMissionActionScope                           ActionScope;                                       // 0x0041(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_27FE[0x6];                                     // 0x0042(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class UMissionObjective*                      OwningObjective;                                   // 0x0048(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void CompleteAction();
	void SetParentState(EMissionObjectiveState NewState, const struct FGameplayTag& StateTag);
	void TakeAction();

	class UMissionAction* GetNextAction() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MissionAction">();
	}
	static class UMissionAction* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMissionAction>();
	}
};
static_assert(alignof(UMissionAction) == 0x000008, "Wrong alignment on UMissionAction");
static_assert(sizeof(UMissionAction) == 0x000050, "Wrong size on UMissionAction");
static_assert(offsetof(UMissionAction, Next) == 0x000038, "Member 'UMissionAction::Next' has a wrong offset!");
static_assert(offsetof(UMissionAction, ActionScope) == 0x000041, "Member 'UMissionAction::ActionScope' has a wrong offset!");
static_assert(offsetof(UMissionAction, OwningObjective) == 0x000048, "Member 'UMissionAction::OwningObjective' has a wrong offset!");

// Class MissionGraphRuntime.MissionBlueprint
// 0x0010 (0x00B8 - 0x00A8)
class UMissionBlueprint final : public UBlueprint
{
public:
	TArray<struct FNamedCondition>                NamedConditions;                                   // 0x00A8(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MissionBlueprint">();
	}
	static class UMissionBlueprint* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMissionBlueprint>();
	}
};
static_assert(alignof(UMissionBlueprint) == 0x000008, "Wrong alignment on UMissionBlueprint");
static_assert(sizeof(UMissionBlueprint) == 0x0000B8, "Wrong size on UMissionBlueprint");
static_assert(offsetof(UMissionBlueprint, NamedConditions) == 0x0000A8, "Member 'UMissionBlueprint::NamedConditions' has a wrong offset!");

// Class MissionGraphRuntime.MissionCondition
// 0x0020 (0x0058 - 0x0038)
class UMissionCondition : public UMissionObject
{
public:
	uint8                                         Pad_2800[0x18];                                    // 0x0038(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bIsReversible;                                     // 0x0050(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bInverted;                                         // 0x0051(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bState;                                            // 0x0052(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bActivated;                                        // 0x0053(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2801[0x4];                                     // 0x0054(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnActivated();
	void OnDeactivated();
	void SetState(bool bNewState);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MissionCondition">();
	}
	static class UMissionCondition* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMissionCondition>();
	}
};
static_assert(alignof(UMissionCondition) == 0x000008, "Wrong alignment on UMissionCondition");
static_assert(sizeof(UMissionCondition) == 0x000058, "Wrong size on UMissionCondition");
static_assert(offsetof(UMissionCondition, bIsReversible) == 0x000050, "Member 'UMissionCondition::bIsReversible' has a wrong offset!");
static_assert(offsetof(UMissionCondition, bInverted) == 0x000051, "Member 'UMissionCondition::bInverted' has a wrong offset!");
static_assert(offsetof(UMissionCondition, bState) == 0x000052, "Member 'UMissionCondition::bState' has a wrong offset!");
static_assert(offsetof(UMissionCondition, bActivated) == 0x000053, "Member 'UMissionCondition::bActivated' has a wrong offset!");

// Class MissionGraphRuntime.MissionConditionComposition
// 0x0018 (0x0070 - 0x0058)
class UMissionConditionComposition final : public UMissionCondition
{
public:
	EMissionConditionCompositionType              ConditionType;                                     // 0x0058(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2802[0x7];                                     // 0x0059(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UMissionCondition*>              ChildConditions;                                   // 0x0060(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MissionConditionComposition">();
	}
	static class UMissionConditionComposition* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMissionConditionComposition>();
	}
};
static_assert(alignof(UMissionConditionComposition) == 0x000008, "Wrong alignment on UMissionConditionComposition");
static_assert(sizeof(UMissionConditionComposition) == 0x000070, "Wrong size on UMissionConditionComposition");
static_assert(offsetof(UMissionConditionComposition, ConditionType) == 0x000058, "Member 'UMissionConditionComposition::ConditionType' has a wrong offset!");
static_assert(offsetof(UMissionConditionComposition, ChildConditions) == 0x000060, "Member 'UMissionConditionComposition::ChildConditions' has a wrong offset!");

// Class MissionGraphRuntime.MissionExtension
// 0x0010 (0x0048 - 0x0038)
class UMissionExtension : public UMissionObject
{
public:
	EMissionExtensionType                         Type;                                              // 0x0038(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2803[0x7];                                     // 0x0039(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UMissionObjective*                      OwningObjective;                                   // 0x0040(0x0008)(ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void Initialize(class UMissionObjective* Owner);
	void OnObjectiveStateChanged(class UMissionObjective* Objective, EMissionObjectiveState OldState, EMissionObjectiveState NewState);
	void RefreshExtension();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MissionExtension">();
	}
	static class UMissionExtension* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMissionExtension>();
	}
};
static_assert(alignof(UMissionExtension) == 0x000008, "Wrong alignment on UMissionExtension");
static_assert(sizeof(UMissionExtension) == 0x000048, "Wrong size on UMissionExtension");
static_assert(offsetof(UMissionExtension, Type) == 0x000038, "Member 'UMissionExtension::Type' has a wrong offset!");
static_assert(offsetof(UMissionExtension, OwningObjective) == 0x000040, "Member 'UMissionExtension::OwningObjective' has a wrong offset!");

// Class MissionGraphRuntime.MissionExtensionContext
// 0x0000 (0x0028 - 0x0028)
class IMissionExtensionContext final : public IInterface
{
public:
	TArray<class AActor*> GetExtensionContext();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MissionExtensionContext">();
	}
	static class IMissionExtensionContext* GetDefaultObj()
	{
		return GetDefaultObjImpl<IMissionExtensionContext>();
	}
};
static_assert(alignof(IMissionExtensionContext) == 0x000008, "Wrong alignment on IMissionExtensionContext");
static_assert(sizeof(IMissionExtensionContext) == 0x000028, "Wrong size on IMissionExtensionContext");

// Class MissionGraphRuntime.MissionObjective_Composition
// 0x0060 (0x0200 - 0x01A0)
class UMissionObjective_Composition : public UMissionObjective
{
public:
	TMap<EMissionObjectiveState, bool>            StateForChildrenOnCompletion;                      // 0x01A0(0x0050)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TArray<class UMissionObjective*>              ChildObjectives;                                   // 0x01F0(0x0010)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)

public:
	const TArray<class UMissionObjective*> GetChildObjectives() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MissionObjective_Composition">();
	}
	static class UMissionObjective_Composition* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMissionObjective_Composition>();
	}
};
static_assert(alignof(UMissionObjective_Composition) == 0x000008, "Wrong alignment on UMissionObjective_Composition");
static_assert(sizeof(UMissionObjective_Composition) == 0x000200, "Wrong size on UMissionObjective_Composition");
static_assert(offsetof(UMissionObjective_Composition, StateForChildrenOnCompletion) == 0x0001A0, "Member 'UMissionObjective_Composition::StateForChildrenOnCompletion' has a wrong offset!");
static_assert(offsetof(UMissionObjective_Composition, ChildObjectives) == 0x0001F0, "Member 'UMissionObjective_Composition::ChildObjectives' has a wrong offset!");

// Class MissionGraphRuntime.MissionObjective_ActivateOnFail
// 0x0008 (0x0208 - 0x0200)
class UMissionObjective_ActivateOnFail final : public UMissionObjective_Composition
{
public:
	class UMissionObjective*                      CurrentObjective;                                  // 0x0200(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	int32 GetCurrentObjectiveIndex() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MissionObjective_ActivateOnFail">();
	}
	static class UMissionObjective_ActivateOnFail* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMissionObjective_ActivateOnFail>();
	}
};
static_assert(alignof(UMissionObjective_ActivateOnFail) == 0x000008, "Wrong alignment on UMissionObjective_ActivateOnFail");
static_assert(sizeof(UMissionObjective_ActivateOnFail) == 0x000208, "Wrong size on UMissionObjective_ActivateOnFail");
static_assert(offsetof(UMissionObjective_ActivateOnFail, CurrentObjective) == 0x000200, "Member 'UMissionObjective_ActivateOnFail::CurrentObjective' has a wrong offset!");

// Class MissionGraphRuntime.MissionObjective_And
// 0x0000 (0x0200 - 0x0200)
class UMissionObjective_And final : public UMissionObjective_Composition
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MissionObjective_And">();
	}
	static class UMissionObjective_And* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMissionObjective_And>();
	}
};
static_assert(alignof(UMissionObjective_And) == 0x000008, "Wrong alignment on UMissionObjective_And");
static_assert(sizeof(UMissionObjective_And) == 0x000200, "Wrong size on UMissionObjective_And");

// Class MissionGraphRuntime.MissionObjective_GatedAnd
// 0x0000 (0x0200 - 0x0200)
class UMissionObjective_GatedAnd final : public UMissionObjective_Composition
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MissionObjective_GatedAnd">();
	}
	static class UMissionObjective_GatedAnd* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMissionObjective_GatedAnd>();
	}
};
static_assert(alignof(UMissionObjective_GatedAnd) == 0x000008, "Wrong alignment on UMissionObjective_GatedAnd");
static_assert(sizeof(UMissionObjective_GatedAnd) == 0x000200, "Wrong size on UMissionObjective_GatedAnd");

// Class MissionGraphRuntime.MissionObjective_GatedOr
// 0x0000 (0x0200 - 0x0200)
class UMissionObjective_GatedOr final : public UMissionObjective_Composition
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MissionObjective_GatedOr">();
	}
	static class UMissionObjective_GatedOr* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMissionObjective_GatedOr>();
	}
};
static_assert(alignof(UMissionObjective_GatedOr) == 0x000008, "Wrong alignment on UMissionObjective_GatedOr");
static_assert(sizeof(UMissionObjective_GatedOr) == 0x000200, "Wrong size on UMissionObjective_GatedOr");

// Class MissionGraphRuntime.MissionObjective_Or
// 0x0008 (0x0208 - 0x0200)
class UMissionObjective_Or final : public UMissionObjective_Composition
{
public:
	uint8                                         Pad_2805[0x8];                                     // 0x0200(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MissionObjective_Or">();
	}
	static class UMissionObjective_Or* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMissionObjective_Or>();
	}
};
static_assert(alignof(UMissionObjective_Or) == 0x000008, "Wrong alignment on UMissionObjective_Or");
static_assert(sizeof(UMissionObjective_Or) == 0x000208, "Wrong size on UMissionObjective_Or");

// Class MissionGraphRuntime.MissionObjective_Sequence
// 0x0008 (0x0208 - 0x0200)
class UMissionObjective_Sequence final : public UMissionObjective_Composition
{
public:
	uint8                                         Pad_2806[0x8];                                     // 0x0200(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	class UMissionObjective* GetCurrentObjective() const;
	int32 GetCurrentObjectiveIndex() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MissionObjective_Sequence">();
	}
	static class UMissionObjective_Sequence* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMissionObjective_Sequence>();
	}
};
static_assert(alignof(UMissionObjective_Sequence) == 0x000008, "Wrong alignment on UMissionObjective_Sequence");
static_assert(sizeof(UMissionObjective_Sequence) == 0x000208, "Wrong size on UMissionObjective_Sequence");

// Class MissionGraphRuntime.MissionResourceComponent
// 0x0080 (0x0128 - 0x00A8)
class UMissionResourceComponent final : public UActorComponent
{
public:
	FMulticastInlineDelegateProperty_             OnResourceReserved;                                // 0x00A8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnResourceUnreserved;                              // 0x00B8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnResourcePendingDestroyStarted;                   // 0x00C8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnResourcePendingDestroyFinished;                  // 0x00D8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	bool                                          bDestroyOwnerOnPendingDestroy;                     // 0x00E8(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bDestroyDependentsOnPendingDestroy;                // 0x00E9(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2807[0x2];                                     // 0x00EA(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         UnreserveDelay;                                    // 0x00EC(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsAvailable;                                      // 0x00F0(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2808[0x3];                                     // 0x00F1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTag                           ResourceTag;                                       // 0x00F4(0x0008)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2809[0x4];                                     // 0x00FC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UMissionResourceComponent*>      DependentResources;                                // 0x0100(0x0010)(ExportObject, ZeroConstructor, Transient, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	uint8                                         Pad_280A[0x18];                                    // 0x0110(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AddDependency(class UMissionResourceComponent* Resource);
	void Reserve(class UObject* ReservedBy);
	void SetIsAvailable(bool bNewIsAvailable);
	void StartPendingDestroy(float Delay);
	void Unreserve(class UObject* ReservedBy);

	bool IsAvailable() const;
	bool IsReserved() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MissionResourceComponent">();
	}
	static class UMissionResourceComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMissionResourceComponent>();
	}
};
static_assert(alignof(UMissionResourceComponent) == 0x000008, "Wrong alignment on UMissionResourceComponent");
static_assert(sizeof(UMissionResourceComponent) == 0x000128, "Wrong size on UMissionResourceComponent");
static_assert(offsetof(UMissionResourceComponent, OnResourceReserved) == 0x0000A8, "Member 'UMissionResourceComponent::OnResourceReserved' has a wrong offset!");
static_assert(offsetof(UMissionResourceComponent, OnResourceUnreserved) == 0x0000B8, "Member 'UMissionResourceComponent::OnResourceUnreserved' has a wrong offset!");
static_assert(offsetof(UMissionResourceComponent, OnResourcePendingDestroyStarted) == 0x0000C8, "Member 'UMissionResourceComponent::OnResourcePendingDestroyStarted' has a wrong offset!");
static_assert(offsetof(UMissionResourceComponent, OnResourcePendingDestroyFinished) == 0x0000D8, "Member 'UMissionResourceComponent::OnResourcePendingDestroyFinished' has a wrong offset!");
static_assert(offsetof(UMissionResourceComponent, bDestroyOwnerOnPendingDestroy) == 0x0000E8, "Member 'UMissionResourceComponent::bDestroyOwnerOnPendingDestroy' has a wrong offset!");
static_assert(offsetof(UMissionResourceComponent, bDestroyDependentsOnPendingDestroy) == 0x0000E9, "Member 'UMissionResourceComponent::bDestroyDependentsOnPendingDestroy' has a wrong offset!");
static_assert(offsetof(UMissionResourceComponent, UnreserveDelay) == 0x0000EC, "Member 'UMissionResourceComponent::UnreserveDelay' has a wrong offset!");
static_assert(offsetof(UMissionResourceComponent, bIsAvailable) == 0x0000F0, "Member 'UMissionResourceComponent::bIsAvailable' has a wrong offset!");
static_assert(offsetof(UMissionResourceComponent, ResourceTag) == 0x0000F4, "Member 'UMissionResourceComponent::ResourceTag' has a wrong offset!");
static_assert(offsetof(UMissionResourceComponent, DependentResources) == 0x000100, "Member 'UMissionResourceComponent::DependentResources' has a wrong offset!");

// Class MissionGraphRuntime.MissionResourceFunctionLibrary
// 0x0000 (0x0028 - 0x0028)
class UMissionResourceFunctionLibrary final : public UBlueprintFunctionLibrary
{
public:
	static struct FMissionResourceRef MakeSoftResourceRef(TSoftObjectPtr<class AActor> Reference);
	static struct FMissionResourceRef MakeTagResourceRef(const struct FGameplayTag& Tag);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MissionResourceFunctionLibrary">();
	}
	static class UMissionResourceFunctionLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMissionResourceFunctionLibrary>();
	}
};
static_assert(alignof(UMissionResourceFunctionLibrary) == 0x000008, "Wrong alignment on UMissionResourceFunctionLibrary");
static_assert(sizeof(UMissionResourceFunctionLibrary) == 0x000028, "Wrong size on UMissionResourceFunctionLibrary");

// Class MissionGraphRuntime.MissionResourceSubsystem
// 0x0050 (0x0080 - 0x0030)
class UMissionResourceSubsystem : public UWorldSubsystem
{
public:
	TMap<struct FGameplayTag, struct FGzResourceCollection> ResourceRegistry;                                  // 0x0030(0x0050)(Transient, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)

public:
	TArray<class AActor*> GetResourcesByRange(class AActor* DistanceFrom, const struct FGameplayTag& ResourceTag, float MinDistance, float MaxDistance, const struct FMissionRadialFilter& RadialFilter);

	void GetAvailableResourcesExact(const struct FGameplayTag& ResourceTag, TArray<class UMissionResourceComponent*>* Resources, int32* UnavailableCount) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MissionResourceSubsystem">();
	}
	static class UMissionResourceSubsystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMissionResourceSubsystem>();
	}
};
static_assert(alignof(UMissionResourceSubsystem) == 0x000008, "Wrong alignment on UMissionResourceSubsystem");
static_assert(sizeof(UMissionResourceSubsystem) == 0x000080, "Wrong size on UMissionResourceSubsystem");
static_assert(offsetof(UMissionResourceSubsystem, ResourceRegistry) == 0x000030, "Member 'UMissionResourceSubsystem::ResourceRegistry' has a wrong offset!");

// Class MissionGraphRuntime.MissionRuntimeContext
// 0x0000 (0x0028 - 0x0028)
class UMissionRuntimeContext : public UObject
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MissionRuntimeContext">();
	}
	static class UMissionRuntimeContext* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMissionRuntimeContext>();
	}
};
static_assert(alignof(UMissionRuntimeContext) == 0x000008, "Wrong alignment on UMissionRuntimeContext");
static_assert(sizeof(UMissionRuntimeContext) == 0x000028, "Wrong size on UMissionRuntimeContext");

// Class MissionGraphRuntime.MissionWorldSubsystem
// 0x00A0 (0x00D0 - 0x0030)
class UMissionWorldSubsystem final : public UWorldSubsystem
{
public:
	uint8                                         Pad_280C[0xA0];                                    // 0x0030(0x00A0)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MissionWorldSubsystem">();
	}
	static class UMissionWorldSubsystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMissionWorldSubsystem>();
	}
};
static_assert(alignof(UMissionWorldSubsystem) == 0x000008, "Wrong alignment on UMissionWorldSubsystem");
static_assert(sizeof(UMissionWorldSubsystem) == 0x0000D0, "Wrong size on UMissionWorldSubsystem");

}

