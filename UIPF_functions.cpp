#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: UIPF

#include "Basic.hpp"

#include "UIPF_classes.hpp"
#include "UIPF_parameters.hpp"


namespace SDK
{

// Function UIPF.UIPFActor.DelayPhysEnabled
// (Final, Native, Public)

void AUIPFActor::DelayPhysEnabled()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UIPFActor", "DelayPhysEnabled");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function UIPF.UIPFActor.Init
// (Final, Native, Public)
// Parameters:
// bool                                    bFromManual                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AUIPFActor::Init(bool bFromManual)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UIPFActor", "Init");

	Params::UIPFActor_Init Parms{};

	Parms.bFromManual = bFromManual;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function UIPF.UIPFActor.SkeletonSleep
// (Native, Protected)
// Parameters:
// class UPrimitiveComponent*              Comp                                                   (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             bone                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AUIPFActor::SkeletonSleep(class UPrimitiveComponent* Comp, class FName bone)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UIPFActor", "SkeletonSleep");

	Params::UIPFActor_SkeletonSleep Parms{};

	Parms.Comp = Comp;
	Parms.bone = bone;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function UIPF.UIPFActor.TrySleep
// (Final, Native, Public)

void AUIPFActor::TrySleep()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UIPFActor", "TrySleep");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function UIPF.UIPFActor.UpdateTransition
// (Native, Protected)

void AUIPFActor::UpdateTransition()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UIPFActor", "UpdateTransition");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function UIPF.UIPFImpulse.InitializeImpulse
// (Native, Public, BlueprintCallable)
// Parameters:
// float                                   ImpulseRadius                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    UsingTruePhys                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    UsingShaderInt                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ImpulseStrength                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AUIPFImpulse::InitializeImpulse(float ImpulseRadius, bool UsingTruePhys, bool UsingShaderInt, float ImpulseStrength)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UIPFImpulse", "InitializeImpulse");

	Params::UIPFImpulse_InitializeImpulse Parms{};

	Parms.ImpulseRadius = ImpulseRadius;
	Parms.UsingTruePhys = UsingTruePhys;
	Parms.UsingShaderInt = UsingShaderInt;
	Parms.ImpulseStrength = ImpulseStrength;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function UIPF.UIPFInteractor.ManuallyActivateFoliage
// (Native, Public, BlueprintCallable)
// Parameters:
// bool                                    WithImpulse                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ImpulseStrength                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FHitResult                       Hit                                                    (Parm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void UUIPFInteractor::ManuallyActivateFoliage(bool WithImpulse, float ImpulseStrength, const struct FHitResult& Hit)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UIPFInteractor", "ManuallyActivateFoliage");

	Params::UIPFInteractor_ManuallyActivateFoliage Parms{};

	Parms.WithImpulse = WithImpulse;
	Parms.ImpulseStrength = ImpulseStrength;
	Parms.Hit = std::move(Hit);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function UIPF.UIPFInteractor.OnDeactivationEndOverlap
// (Native, Public)
// Parameters:
// class UPrimitiveComponent*              OverlappedComponent                                    (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           OtherActor                                             (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*              OtherComp                                              (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   OtherBodyIndex                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UUIPFInteractor::OnDeactivationEndOverlap(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UIPFInteractor", "OnDeactivationEndOverlap");

	Params::UIPFInteractor_OnDeactivationEndOverlap Parms{};

	Parms.OverlappedComponent = OverlappedComponent;
	Parms.OtherActor = OtherActor;
	Parms.OtherComp = OtherComp;
	Parms.OtherBodyIndex = OtherBodyIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function UIPF.UIPFInteractor.PhysCheck
// (Native, Protected)

void UUIPFInteractor::PhysCheck()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UIPFInteractor", "PhysCheck");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function UIPF.UIPFManager.FoliageForceAtLocation
// (Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// float                                   FStrength                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   FSizePercent                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          HitLocation                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bIsImpulse                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AUIPFManager::FoliageForceAtLocation(float FStrength, float FSizePercent, const struct FVector& HitLocation, bool bIsImpulse)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UIPFManager", "FoliageForceAtLocation");

	Params::UIPFManager_FoliageForceAtLocation Parms{};

	Parms.FStrength = FStrength;
	Parms.FSizePercent = FSizePercent;
	Parms.HitLocation = std::move(HitLocation);
	Parms.bIsImpulse = bIsImpulse;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function UIPF.UIPFManager.ForceAppliedAtLocation
// (Event, Public, HasDefaults, BlueprintEvent)
// Parameters:
// struct FVector                          Loc                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Strength                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AUIPFManager::ForceAppliedAtLocation(const struct FVector& Loc, float Strength)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UIPFManager", "ForceAppliedAtLocation");

	Params::UIPFManager_ForceAppliedAtLocation Parms{};

	Parms.Loc = std::move(Loc);
	Parms.Strength = Strength;

	UObject::ProcessEvent(Func, &Parms);
}


// Function UIPF.UIPFManager.ImpulseAtLocation
// (Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector                          Location                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ImpulseDiameter                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ImpulseStrengthIn                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AUIPFManager::ImpulseAtLocation(const struct FVector& Location, float ImpulseDiameter, float ImpulseStrengthIn)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UIPFManager", "ImpulseAtLocation");

	Params::UIPFManager_ImpulseAtLocation Parms{};

	Parms.Location = std::move(Location);
	Parms.ImpulseDiameter = ImpulseDiameter;
	Parms.ImpulseStrengthIn = ImpulseStrengthIn;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}

}

