#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: UIPF

#include "Basic.hpp"

#include "Engine_structs.hpp"
#include "CoreUObject_structs.hpp"


namespace SDK::Params
{

// Function UIPF.UIPFActor.Init
// 0x0001 (0x0001 - 0x0000)
struct UIPFActor_Init final
{
public:
	bool                                          bFromManual;                                       // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(UIPFActor_Init) == 0x000001, "Wrong alignment on UIPFActor_Init");
static_assert(sizeof(UIPFActor_Init) == 0x000001, "Wrong size on UIPFActor_Init");
static_assert(offsetof(UIPFActor_Init, bFromManual) == 0x000000, "Member 'UIPFActor_Init::bFromManual' has a wrong offset!");

// Function UIPF.UIPFActor.SkeletonSleep
// 0x0010 (0x0010 - 0x0000)
struct UIPFActor_SkeletonSleep final
{
public:
	class UPrimitiveComponent*                    Comp;                                              // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   bone;                                              // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(UIPFActor_SkeletonSleep) == 0x000008, "Wrong alignment on UIPFActor_SkeletonSleep");
static_assert(sizeof(UIPFActor_SkeletonSleep) == 0x000010, "Wrong size on UIPFActor_SkeletonSleep");
static_assert(offsetof(UIPFActor_SkeletonSleep, Comp) == 0x000000, "Member 'UIPFActor_SkeletonSleep::Comp' has a wrong offset!");
static_assert(offsetof(UIPFActor_SkeletonSleep, bone) == 0x000008, "Member 'UIPFActor_SkeletonSleep::bone' has a wrong offset!");

// Function UIPF.UIPFImpulse.InitializeImpulse
// 0x000C (0x000C - 0x0000)
struct UIPFImpulse_InitializeImpulse final
{
public:
	float                                         ImpulseRadius;                                     // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          UsingTruePhys;                                     // 0x0004(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          UsingShaderInt;                                    // 0x0005(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3E68[0x2];                                     // 0x0006(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ImpulseStrength;                                   // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(UIPFImpulse_InitializeImpulse) == 0x000004, "Wrong alignment on UIPFImpulse_InitializeImpulse");
static_assert(sizeof(UIPFImpulse_InitializeImpulse) == 0x00000C, "Wrong size on UIPFImpulse_InitializeImpulse");
static_assert(offsetof(UIPFImpulse_InitializeImpulse, ImpulseRadius) == 0x000000, "Member 'UIPFImpulse_InitializeImpulse::ImpulseRadius' has a wrong offset!");
static_assert(offsetof(UIPFImpulse_InitializeImpulse, UsingTruePhys) == 0x000004, "Member 'UIPFImpulse_InitializeImpulse::UsingTruePhys' has a wrong offset!");
static_assert(offsetof(UIPFImpulse_InitializeImpulse, UsingShaderInt) == 0x000005, "Member 'UIPFImpulse_InitializeImpulse::UsingShaderInt' has a wrong offset!");
static_assert(offsetof(UIPFImpulse_InitializeImpulse, ImpulseStrength) == 0x000008, "Member 'UIPFImpulse_InitializeImpulse::ImpulseStrength' has a wrong offset!");

// Function UIPF.UIPFInteractor.ManuallyActivateFoliage
// 0x0100 (0x0100 - 0x0000)
struct UIPFInteractor_ManuallyActivateFoliage final
{
public:
	bool                                          WithImpulse;                                       // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3E70[0x3];                                     // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ImpulseStrength;                                   // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FHitResult                             Hit;                                               // 0x0008(0x00F8)(Parm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(UIPFInteractor_ManuallyActivateFoliage) == 0x000008, "Wrong alignment on UIPFInteractor_ManuallyActivateFoliage");
static_assert(sizeof(UIPFInteractor_ManuallyActivateFoliage) == 0x000100, "Wrong size on UIPFInteractor_ManuallyActivateFoliage");
static_assert(offsetof(UIPFInteractor_ManuallyActivateFoliage, WithImpulse) == 0x000000, "Member 'UIPFInteractor_ManuallyActivateFoliage::WithImpulse' has a wrong offset!");
static_assert(offsetof(UIPFInteractor_ManuallyActivateFoliage, ImpulseStrength) == 0x000004, "Member 'UIPFInteractor_ManuallyActivateFoliage::ImpulseStrength' has a wrong offset!");
static_assert(offsetof(UIPFInteractor_ManuallyActivateFoliage, Hit) == 0x000008, "Member 'UIPFInteractor_ManuallyActivateFoliage::Hit' has a wrong offset!");

// Function UIPF.UIPFInteractor.OnDeactivationEndOverlap
// 0x0020 (0x0020 - 0x0000)
struct UIPFInteractor_OnDeactivationEndOverlap final
{
public:
	class UPrimitiveComponent*                    OverlappedComponent;                               // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 OtherActor;                                        // 0x0008(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UPrimitiveComponent*                    OtherComp;                                         // 0x0010(0x0008)(Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         OtherBodyIndex;                                    // 0x0018(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3E71[0x4];                                     // 0x001C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(UIPFInteractor_OnDeactivationEndOverlap) == 0x000008, "Wrong alignment on UIPFInteractor_OnDeactivationEndOverlap");
static_assert(sizeof(UIPFInteractor_OnDeactivationEndOverlap) == 0x000020, "Wrong size on UIPFInteractor_OnDeactivationEndOverlap");
static_assert(offsetof(UIPFInteractor_OnDeactivationEndOverlap, OverlappedComponent) == 0x000000, "Member 'UIPFInteractor_OnDeactivationEndOverlap::OverlappedComponent' has a wrong offset!");
static_assert(offsetof(UIPFInteractor_OnDeactivationEndOverlap, OtherActor) == 0x000008, "Member 'UIPFInteractor_OnDeactivationEndOverlap::OtherActor' has a wrong offset!");
static_assert(offsetof(UIPFInteractor_OnDeactivationEndOverlap, OtherComp) == 0x000010, "Member 'UIPFInteractor_OnDeactivationEndOverlap::OtherComp' has a wrong offset!");
static_assert(offsetof(UIPFInteractor_OnDeactivationEndOverlap, OtherBodyIndex) == 0x000018, "Member 'UIPFInteractor_OnDeactivationEndOverlap::OtherBodyIndex' has a wrong offset!");

// Function UIPF.UIPFManager.FoliageForceAtLocation
// 0x0028 (0x0028 - 0x0000)
struct UIPFManager_FoliageForceAtLocation final
{
public:
	float                                         FStrength;                                         // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FSizePercent;                                      // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                HitLocation;                                       // 0x0008(0x0018)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsImpulse;                                        // 0x0020(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3E76[0x7];                                     // 0x0021(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(UIPFManager_FoliageForceAtLocation) == 0x000008, "Wrong alignment on UIPFManager_FoliageForceAtLocation");
static_assert(sizeof(UIPFManager_FoliageForceAtLocation) == 0x000028, "Wrong size on UIPFManager_FoliageForceAtLocation");
static_assert(offsetof(UIPFManager_FoliageForceAtLocation, FStrength) == 0x000000, "Member 'UIPFManager_FoliageForceAtLocation::FStrength' has a wrong offset!");
static_assert(offsetof(UIPFManager_FoliageForceAtLocation, FSizePercent) == 0x000004, "Member 'UIPFManager_FoliageForceAtLocation::FSizePercent' has a wrong offset!");
static_assert(offsetof(UIPFManager_FoliageForceAtLocation, HitLocation) == 0x000008, "Member 'UIPFManager_FoliageForceAtLocation::HitLocation' has a wrong offset!");
static_assert(offsetof(UIPFManager_FoliageForceAtLocation, bIsImpulse) == 0x000020, "Member 'UIPFManager_FoliageForceAtLocation::bIsImpulse' has a wrong offset!");

// Function UIPF.UIPFManager.ForceAppliedAtLocation
// 0x0020 (0x0020 - 0x0000)
struct UIPFManager_ForceAppliedAtLocation final
{
public:
	struct FVector                                Loc;                                               // 0x0000(0x0018)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Strength;                                          // 0x0018(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3E77[0x4];                                     // 0x001C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(UIPFManager_ForceAppliedAtLocation) == 0x000008, "Wrong alignment on UIPFManager_ForceAppliedAtLocation");
static_assert(sizeof(UIPFManager_ForceAppliedAtLocation) == 0x000020, "Wrong size on UIPFManager_ForceAppliedAtLocation");
static_assert(offsetof(UIPFManager_ForceAppliedAtLocation, Loc) == 0x000000, "Member 'UIPFManager_ForceAppliedAtLocation::Loc' has a wrong offset!");
static_assert(offsetof(UIPFManager_ForceAppliedAtLocation, Strength) == 0x000018, "Member 'UIPFManager_ForceAppliedAtLocation::Strength' has a wrong offset!");

// Function UIPF.UIPFManager.ImpulseAtLocation
// 0x0020 (0x0020 - 0x0000)
struct UIPFManager_ImpulseAtLocation final
{
public:
	struct FVector                                Location;                                          // 0x0000(0x0018)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ImpulseDiameter;                                   // 0x0018(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ImpulseStrengthIn;                                 // 0x001C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(UIPFManager_ImpulseAtLocation) == 0x000008, "Wrong alignment on UIPFManager_ImpulseAtLocation");
static_assert(sizeof(UIPFManager_ImpulseAtLocation) == 0x000020, "Wrong size on UIPFManager_ImpulseAtLocation");
static_assert(offsetof(UIPFManager_ImpulseAtLocation, Location) == 0x000000, "Member 'UIPFManager_ImpulseAtLocation::Location' has a wrong offset!");
static_assert(offsetof(UIPFManager_ImpulseAtLocation, ImpulseDiameter) == 0x000018, "Member 'UIPFManager_ImpulseAtLocation::ImpulseDiameter' has a wrong offset!");
static_assert(offsetof(UIPFManager_ImpulseAtLocation, ImpulseStrengthIn) == 0x00001C, "Member 'UIPFManager_ImpulseAtLocation::ImpulseStrengthIn' has a wrong offset!");

}

